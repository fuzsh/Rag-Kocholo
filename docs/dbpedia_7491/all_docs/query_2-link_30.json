{
    "id": "dbpedia_7491_2",
    "rank": 30,
    "data": {
        "url": "https://github.com/minio/warp",
        "read_more_link": "",
        "language": "en",
        "title": "minio/warp: S3 benchmarking tool",
        "top_image": "https://opengraph.githubassets.com/71caa7d70e58cfa24ca9cad71cee7e4fcee1f2632176082ed68be18d923d97bc/minio/warp",
        "meta_img": "https://opengraph.githubassets.com/71caa7d70e58cfa24ca9cad71cee7e4fcee1f2632176082ed68be18d923d97bc/minio/warp",
        "images": [
            "https://raw.githubusercontent.com/minio/warp/master/warp_logo.png",
            "https://raw.githubusercontent.com/minio/warp/master/arch_warp.png",
            "https://user-images.githubusercontent.com/5663952/71828619-83381480-3057-11ea-9d6c-ff03607a66a7.png",
            "https://user-images.githubusercontent.com/5663952/72053512-0df95900-327c-11ea-8bc5-9b4064fa595f.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "S3 benchmarking tool. Contribute to minio/warp development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/minio/warp",
        "text": "S3 benchmarking tool.\n\nDownload Binary Releases for various platforms.\n\nWarp requires minimum Go go1.21, please ensure you have compatible version for this build.\n\nYou can follow easy step below to build project\n\nClone project\n\nChange directory and build\n\nTo run a test, please run\n\nWarp can be configured either using commandline parameters or environment variables. The S3 server to use can be specified on the commandline using --host, --access-key, --secret-key and optionally --tls and --region to specify TLS and a custom region.\n\nIt is also possible to set the same parameters using the WARP_HOST, WARP_ACCESS_KEY, WARP_SECRET_KEY, WARP_REGION and WARP_TLS environment variables.\n\nThe credentials must be able to create, delete and list buckets and upload files and perform the operation requested.\n\nBy default operations are performed on a bucket called warp-benchmark-bucket. This can be changed using the --bucket parameter. Do however note that the bucket will be completely cleaned before and after each run, so it should not contain any data.\n\nIf you are running TLS, you can enable server-side-encryption of objects using --encrypt. A random key will be generated and used for objects. To use SSE-S3 encryption use the --sse-s3-encrypt flag.\n\nIf your server is incompatible with AWS v4 signatures the older v2 signatures can be used with --signature=S3V2.\n\nλ warp command [options]\n\nExample running a mixed type benchmark against 8 servers named s3-server-1 to s3-server-8 on port 9000 with the provided keys:\n\nλ warp mixed --host=s3-server{1...8}:9000 --access-key=minio --secret-key=minio123 --autoterm\n\nThis will run the benchmark for up to 5 minutes and print the results.\n\nAs an alternative configuration option you can use an on-disk YAML configuration file.\n\nSee yml-samples for a collection of configuration files for each benchmark type.\n\nTo run a benchmark use λ warp run <file.yml>.\n\nValues can be injected from the commandline using one or multiple -var VarName=Value. These values can be referenced inside YAML files with {{.VarName}}. Go text templates are used for this.\n\nAll benchmarks operate concurrently. By default, 20 operations will run concurrently. This can however also be tweaked using the --concurrent parameter.\n\nTweaking concurrency can have an impact on performance, especially if latency to the server is tested. Most benchmarks will also use different prefixes for each \"thread\" running.\n\nBy default all benchmarks save all request details to a file named warp-operation-yyyy-mm-dd[hhmmss]-xxxx.csv.zst. A custom file name can be specified using the --benchdata parameter. The raw data is zstandard compressed CSV data.\n\nMultiple S3 hosts can be specified as comma-separated values, for instance --host=10.0.0.1:9000,10.0.0.2:9000 will switch between the specified servers.\n\nAlternatively numerical ranges can be specified using --host=10.0.0.{1...10}:9000 which will add 10.0.0.1 through 10.0.0.10. This syntax can be used for any part of the host name and port.\n\nA file with newline separated hosts can also be specified using file: prefix and a file name. For distributed tests the file will be read locally and sent to each client.\n\nBy default a host is chosen between the hosts that have the least number of requests running and with the longest time since the last request finished. This will ensure that in cases where hosts operate at different speeds that the fastest servers will get the most requests. It is possible to choose a simple round-robin algorithm by using the --host-select=roundrobin parameter. If there is only one host this parameter has no effect.\n\nWhen benchmarks are done per host averages will be printed out. For further details, the --analyze.v parameter can also be used.\n\nIt is possible to coordinate several warp instances automatically. This can be useful for testing performance of a cluster from several clients at once.\n\nFor reliable benchmarks, clients should have synchronized clocks. Warp checks whether clocks are within one second of the server, but ideally, clocks should be synchronized with NTP or a similar service.\n\nTo use Kubernetes see Running warp on kubernetes.\n\nWARNING: Never run warp clients on a publicly exposed port. Clients have the potential to DDOS any service.\n\nClients are started with\n\nwarp client Only accepts an optional host/ip to listen on, but otherwise no specific parameters. By default warp will listen on 127.0.0.1:7761.\n\nOnly one server can be connected at the time. However, when a benchmark is done, the client can immediately run another one with different parameters.\n\nThere will be a version check to ensure that clients are compatible with the server, but it is always recommended to keep warp versions the same.\n\nAny benchmark can be run in server mode. When warp is invoked as a server no actual benchmarking will be done on the server. Each client will execute the benchmark.\n\nThe server will coordinate the benchmark runs and make sure they are run correctly.\n\nWhen the benchmark has finished, the combined benchmark info will be collected, merged and saved/displayed. Each client will also save its own data locally.\n\nEnabling server mode is done by adding --warp-client=client-{1...10}:7761 or a comma separated list of warp client hosts. Finally, a file with newline separated hosts can also be specified using file: prefix and a file name. If no host port is specified the default is added.\n\nExample:\n\nNote that parameters apply to each client. So if --concurrent=8 is specified each client will run with 8 concurrent operations. If a warp server is unable to connect to a client the entire benchmark is aborted.\n\nIf the warp server looses connection to a client during a benchmark run an error will be displayed and the server will attempt to reconnect. If the server is unable to reconnect, the benchmark will continue with the remaining clients.\n\nWhile it is highly recommended to use the automatic distributed benchmarking warp can also be run manually on several machines at once.\n\nWhen running benchmarks on several clients, it is possible to synchronize their start time using the --syncstart parameter. The time format is 'hh:mm' where hours are specified in 24h format, and parsed as local computer time.\n\nUsing this will make it more reliable to merge benchmarks from the clients for total result. This will combine the data as if it was run on the same client. Only the time segments that was actually overlapping will be considered.\n\nWhen running benchmarks on several clients it is likely a good idea to specify the --noclear parameter so clients don't accidentally delete each others data on startup.\n\nBy default warp uploads random data.\n\nMost benchmarks use the --obj.size parameter to decide the size of objects to upload.\n\nDifferent benchmark types will have different default values.\n\nIt is possible to randomize object sizes by specifying --obj.randsize and files will have a \"random\" size up to --obj.size. However, there are some things to consider \"under the hood\".\n\nWe use log2 to distribute objects sizes. This means that objects will be distributed in equal number for each doubling of the size. This means that obj.size/64 -> obj.size/32 will have the same number of objects as obj.size/2 -> obj.size.\n\nExample of objects (horizontally) and their sizes, 100MB max:\n\nTo see segmented request statistics, use the --analyze.v parameter.\n\nThe average object size will be close to --obj.size multiplied by 0.179151.\n\nTo get a value for --obj.size multiply the desired average object size by 5.582 to get a maximum value.\n\nAdding --autoterm parameter will enable automatic termination when results are considered stable. To detect a stable setup, warp continuously downsample the current data to 25 data points stretched over the current timeframe.\n\nFor a benchmark to be considered \"stable\", the last 7 of 25 data points must be within a specified percentage. Looking at the throughput over time, it could look like this:\n\nThe red frame shows the window used to evaluate stability. The height of the box is determined by the threshold percentage of the current speed. This percentage is user configurable through --autoterm.pct, default 7.5%. The metric used for this is either MiB/s or obj/s depending on the benchmark type.\n\nTo make sure there is a good sample data, a minimum duration of the 7 of 25 samples is set. This is configurable --autoterm.dur. This specifies the minimum time length the benchmark must have been stable.\n\nIf the benchmark doesn't autoterminate it will continue until the duration is reached. This cannot be used when benchmarks are running remotely.\n\nA permanent 'drift' in throughput will prevent automatic termination, if the drift is more than the specified percentage. This is by design since this should be recorded.\n\nWhen using automatic termination be aware that you should not compare average speeds, since the length of the benchmark runs will likely be different. Instead 50% medians are a much better metrics.\n\nMixed mode benchmark will test several operation types at once. The benchmark will upload --objects objects of size --obj.size and use these objects as a pool for the benchmark. As new objects are uploaded/deleted they are added/removed from the pool.\n\nThe distribution of operations can be adjusted with the --get-distrib, --stat-distrib, --put-distrib and --delete-distrib parameters.\n\nThe final distribution will be determined by the fraction of each value of the total. Note that put-distrib must be bigger or equal to --delete-distrib to not eventually run out of objects.\n\nTo disable a type, set its distribution to 0.\n\nExample:\n\nA similar benchmark is called versioned which operates on versioned objects.\n\nBenchmarking get operations will attempt to download as many objects it can within --duration.\n\nBy default, --objects objects of size --obj.size are uploaded before doing the actual bench. Objects will be uploaded with --concurrent different prefixes, except if --noprefix is specified.\n\nUsing --list-existing will list at most --objects from the bucket and download them instead of uploading random objects (set it to 0 to use all object from the listing). Listing is restricted to --prefix if it is set and recursive listing can be disabled by setting --list-flat\n\nIf versioned listing should be tested, it is possible by setting --versions=n (default 1), which will add multiple versions of each object and request individual versions.\n\nWhen downloading, objects are chosen randomly between all uploaded data and the benchmark will attempt to run --concurrent concurrent downloads.\n\nThe analysis will include the upload stats as PUT operations and the GET operations.\n\nThe GET operations will contain the time until the first byte was received. This can be accessed using the --analyze.v parameter.\n\nIt is possible to test speed of partial file requests using the --range option. This will start reading each object at a random offset and read a random number of bytes. Using this produces output similar to --obj.randsize - and they can even be combined.\n\nBenchmarking put operations will upload objects of size --obj.size until --duration time has elapsed.\n\nObjects will be uploaded with --concurrent different prefixes, except if --noprefix is specified.\n\nIt is possible by forcing md5 checksums on data by using the --md5 option.\n\nBenchmarking delete operations will attempt to delete as many objects it can within --duration.\n\nBy default, --objects objects of size --obj.size are uploaded beforing doin the actual bench.\n\nThe delete operations are done in --batch objects per request in --concurrent concurrently running requests.\n\nIf there are no more objects left the benchmark will end.\n\nUsing --list-existing will list at most --objects from the bucket and delete them instead of deleting random objects (set it to 0 to use all objects from the lsiting). Listing is restricted to --prefix if it is set and recursive listing can be disabled by setting --list-flat.\n\nThe analysis will include the upload stats as PUT operations and the DELETE operations.\n\nBenchmarking list operations will upload --objects objects of size --obj.size with --concurrent prefixes. The list operations are done per prefix.\n\nIf versioned listing should be tested, it is possible by setting --versions=N (default 1), which will add multiple versions of each object and use ListObjectVersions for listing.\n\nThe analysis will include the upload stats as PUT operations and the LIST operations separately. The time from request start to first object is recorded as well and can be accessed using the --analyze.v parameter.\n\nBenchmarking stat object operations will upload --objects objects of size --obj.size with --concurrent prefixes.\n\nIf versioned listing should be tested, it is possible by setting --versions=n (default 1), which will add multiple versions of each object and request information for individual versions.\n\nThe main benchmark will do individual requests to get object information for the uploaded objects.\n\nSince the object size is of little importance, only objects per second is reported.\n\nExample:\n\nBenchmarking PutObjectRetention operations will upload --objects objects of size --obj.size with --concurrent prefixes and --versions versions on each object.\n\nExample:\n\nNote that since object locking can only be specified when creating a bucket, it may be needed to recreate the bucket. Warp will attempt to do that automatically.\n\nMultipart benchmark will upload parts to a single object, and afterwards test download speed of parts.\n\nWhen running in distributed mode each client will upload the number of parts specified.\n\nOnly --concurrent uploads will be started by each client, so having --parts be a multiple of --concurrent is recommended, but not required.\n\nThe zip command benchmarks the MinIO s3zip extension that allows\n\nThis will upload a single zip file with 10000 individual files (change with --files) of 10KiB each (changed with --obj.size).\n\nThe benchmark will then download individual files concurrently and present the result as a GET benchmark.\n\nExample:\n\nThis will only work on recent MinIO versions, from 2022 and going forward.\n\nThe Snowball benchmark will test uploading a \"snowball\" TAR file with multiple files inside that are extracted as individual objects.\n\nParameters:\n\n--obj.size=N controls the size of each object inside the TAR file that is uploaded. Default is 512KiB.\n\n--objs.per=N controls the number of objects per TAR file. Default is 50.\n\n--compress will compress the TAR file before upload. Object data will be duplicated inside each TAR. This limits --obj.size to 10MiB.\n\nSince TAR operations are done in-memory the total size is limited to 1GiB.\n\nThis is calculated as --obj.size * --concurrent. If --compress is NOT specified this is also multiplied by --objs.per.\n\nExamples:\n\nBenchmark using default parameters. 50 x 512KiB duplicated objects inside each TAR file. Compressed.\n\nTest 1000 unique 1KB objects inside each snowball, with 2 concurrent uploads running:\n\nThe analysis throughput represents the object count and sizes as they are written when extracted.\n\nRequest times shown with --analyze.v represents request time for each snowball.\n\nThe Fanout benchmark will test uploading a single object that is copied to multiple individual objects. This feature is only available on a recent MinIO server.\n\nParameters:\n\n--obj.size=N controls the size of each object that is uploaded. Default is 1MiB.\n\n--copies=N controls the number of object copies per request. Default is 100.\n\nSize is calculated as --obj.size * --copies.\n\nExample: Use 8 concurrent uploads to copy a 512KB objects to 50 locations.\n\nThe analysis throughput represents the object count and sizes as they are written when extracted.\n\nRequest times shown with --analyze.v represents request time for each fan-out call.\n\nWhen benchmarks have finished all request data will be saved to a file and an analysis will be shown.\n\nThe saved data can be re-evaluated by running warp analyze (filename).\n\nAll analysis will be done on a reduced part of the full data. The data aggregation will start when all threads have completed one request and the time segment will stop when the last request of a thread is initiated.\n\nThis is to exclude variations due to warm-up and threads finishing at different times. Therefore the analysis time will typically be slightly below the selected benchmark duration.\n\nExample:\n\nThe benchmark run is then divided into fixed duration segments specified by -analyze.dur. For each segment the throughput is calculated across all threads.\n\nThe analysis output will display the fastest, slowest and 50% median segment.\n\nBeside the important --analyze.dur which specifies the time segment size for aggregated data there are some additional parameters that can be used.\n\nSpecifying --analyze.v will output time aggregated data per host instead of just averages. For instance:\n\n--analyze.op=GET will only analyze GET operations.\n\nSpecifying --analyze.host=http://127.0.0.1:9001 will only consider data from this specific host.\n\nWarp will automatically discard the time taking the first and last request of all threads to finish. However, if you would like to discard additional time from the aggregated data, this is possible. For instance analyze.skip=10s will skip the first 10 seconds of data for each operation type.\n\nNote that skipping data will not always result in the exact reduction in time for the aggregated data since the start time will still be aligned with requests starting.\n\nBy adding the --analyze.v parameter it is possible to display per request statistics.\n\nThis is not enabled by default, since it is assumed the benchmarks are throughput limited, but in certain scenarios it can be useful to determine problems with individual hosts for instance.\n\nExample:\n\nTTFB is the time from request was sent to the first byte was received.\n\nFirst Access is the first access per object.\n\nLast Access is the last access per object.\n\nThe fastest and slowest request times are shown, as well as selected percentiles and the total amount is requests considered.\n\nNote that different metrics are used to select the number of requests per host and for the combined, so there will likely be differences.\n\nIt is possible to output the CSV data of analysis using --analyze.out=filename.csv which will write the CSV data to the specified file.\n\nThese are the data fields exported:\n\nHeader Description index Index of the segment op Operation executed host If only one host, host name, otherwise empty duration_s Duration of the segment in seconds objects_per_op Objects per operation bytes Total bytes of operations (distributed) full_ops Operations completely contained within segment partial_ops Operations that either started or ended outside the segment, but was also executed during segment ops_started Operations started within segment ops_ended Operations ended within the segment errors Errors logged on operations ending within the segment mb_per_sec MiB/s of operations within the segment (distributed) ops_ended_per_sec Operations that ended within the segment per second objs_per_sec Objects per second processed in the segment (distributed) start_time Absolute start time of the segment end_time Absolute end time of the segment\n\nSome of these fields are distributed. This means that the data of partial operations have been distributed across the segments they occur in. The bigger a percentage of the operation is within a segment the larger part of it has been attributed there.\n\nThis is why there can be a partial object attributed to a segment, because only a part of the operation took place in the segment.\n\nIt is possible to compare two recorded runs using the warp cmp (file-before) (file-after) to see the differences between before and after. There is no need for 'before' to be chronologically before 'after', but the differences will be shown as change from 'before' to 'after'.\n\nAn example:\n\nAll relevant differences are listed. This is two warp get runs. Differences in parameters will be shown.\n\nThe usual analysis parameters can be applied to define segment lengths.\n\nIt is possible to merge runs from several clients using the λ warp merge (file1) (file2) [additional files...] command.\n\nThe command will output a combined data file with all data that overlap in time.\n\nThe combined output will effectively be the same as having run a single benchmark with a higher concurrency setting. The main reason for running the benchmark on several clients would be to help eliminate client bottlenecks.\n\nIt is important to note that only data that strictly overlaps in absolute time will be considered for analysis.\n\nWarp allows realtime statistics to be pushed to InfluxDB v2 or later.\n\nThis can be combined with the --stress parameter, which will allow to have long-running tests without consuming memory and still get access to performance numbers.\n\nWarp does not provide any analysis on the data sent to InfluxDB.\n\nInfluxDB is enabled via a the --influxdb parameter. Alternatively the parameter can be set in the WARP_INFLUXDB_CONNECT environment variable.\n\nThe value must be formatted like a URL: <schema>://<token>@<hostname>:<port>/<bucket>/<org>?<tag=value>\n\nPart <schema> Connection type. Replace with http or https <token> Replace with the token needed to access the server <hostname> Replace with the host name or IP address of your server <port> Replace with the port of your server <bucket> Replace with the bucket in which to place the data <org> Replace with the organization to which the data should be associated (if any) <tag=value> One or more tags to add to each data point\n\nEach parameter can be URL encoded.\n\nExample:\n\n--influxdb \"http://shmRUvVjk0Ig2J9qU0_g349PF6l-GB1dmwXUXDh5qd19n1Nda_K7yvSIi9tGpax9jyOsmP2dUd-md8yPOoDNHg==@127.0.0.1:8086/mybucket/myorg?mytag=myvalue\"\n\nThis will connect to port 8086 on 127.0.0.1 using the provided token shmRU....\n\nData will be placed in mybucket and associated with myorg. An additional tag mytag will be set to myvalue on all data points.\n\nFor distributed benchmarking all clients will be sending data, so hosts like localhost and 127.0.0.1 should not be used.\n\nAll in-run measurements are of type warp.\n\nTag Value warp_id Contains a random string value, unique per client.\n\nThis can be used to identify individual runs or single warp clients when using distributed benchmarks. op Contains the operation type, for example GET, PUT, DELETE, etc. endpoint Endpoint is the endpoint to which the operation was sent.\n\nMeasurements without this value is total for the warp client.\n\nFields are sent as accumulated totals per run per operation type.\n\nNew metrics are sent as each operation (request) completes. There is no inter-operation progress logged. This means that bigger objects (meaning less requests) will create bigger fluctuations. That is important to note when analyzing.\n\nField Value requests Total number of requests performed objects Total number of objects affected bytes_total Total number of bytes affected errors Total errors encountered request_total_secs Total request time in seconds request_ttfb_total_secs Total time to first byte in seconds for relevant operations\n\nThe statistics provided means that to get \"rates over time\" the numbers must be calculated as differences (increase/positive derivatives).\n\nWhen a run has finished a summary will be sent. This will be a warp_run_summary measurement type. In addition to the fields above it will contain:\n\nField Value request_avg_secs Average Request Time request_max_secs Longest Request Time request_min_secs Shortest Request Time request_ttfb_avg_secs Average Time To First Byte (TTFB) request_ttfb_max_secs Longest TTFB request_ttfb_min_secs Shortest TTFB\n\nAll times are in float point seconds.\n\nThe summary will be sent for each host and operation type.\n\nWhen running against a MinIO server it is possible to enable profiling while the benchmark is running.\n\nThis is done by adding --serverprof=type parameter with the type of profile you would like. This requires that the credentials allows admin access for the first host.\n\nType Description cpu CPU profile determines where a program spends its time while actively consuming CPU cycles (as opposed while sleeping or waiting for I/O). mem Heap profile reports the currently live allocations; used to monitor current memory usage or check for memory leaks. block Block profile show where goroutines block waiting on synchronization primitives (including timer channels). mutex Mutex profile reports the lock contentions. When you think your CPU is not fully utilized due to a mutex contention, use this profile. trace A detailed trace of execution of the current program. This will include information about goroutine scheduling and garbage collection.\n\nProfiles for all cluster members will be downloaded as a zip file."
    }
}