{
    "id": "dbpedia_2200_1",
    "rank": 13,
    "data": {
        "url": "https://in-thread.sonic-pi.net/t/idea-for-drums-management/4874",
        "read_more_link": "",
        "language": "en",
        "title": "Idea for drums management",
        "top_image": "https://europe1.discourse-cdn.com/standard20/uploads/sonic_pi/original/1X/3dd07a5ad869dacd4a151cd9ab6b38d04ee6cdad.png",
        "meta_img": "https://europe1.discourse-cdn.com/standard20/uploads/sonic_pi/original/1X/3dd07a5ad869dacd4a151cd9ab6b38d04ee6cdad.png",
        "images": [
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=9",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=9",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=9",
            "https://avatars.discourse-cdn.com/v4/letter/p/e9bcb4/48.png",
            "https://dub1.discourse-cdn.com/standard20/user_avatar/in-thread.sonic-pi.net/soxsa/48/1669_2.png",
            "https://dub1.discourse-cdn.com/standard20/user_avatar/in-thread.sonic-pi.net/soxsa/48/1669_2.png",
            "https://emoji.discourse-cdn.com/twitter/slightly_smiling_face.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=10",
            "https://emoji.discourse-cdn.com/twitter/slightly_smiling_face.png?v=12"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2020-12-28T16:47:18+00:00",
        "summary": "",
        "meta_description": "Hello, I’m new here and I want to share with you this implementation I made to handle drums inside a Sonic Pi track, in order to understand if this can be a good solution :slight_smile: \nI liked the idea I found around t&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://europe1.discourse-cdn.com/standard20/uploads/sonic_pi/optimized/1X/07c124b86189644045da3b7992dbe493ac9fdb64_2_32x32.ico",
        "meta_site_name": "in_thread",
        "canonical_link": "https://in-thread.sonic-pi.net/t/idea-for-drums-management/4874",
        "text": "Hello, I’m new here and I want to share with you this implementation I made to handle drums inside a Sonic Pi track, in order to understand if this can be a good solution\n\nI liked the idea I found around the web (mostly here and here) to map the beats inside an array, to emulate somehow the common grids used by real drum machines and simplify the creation of beats.\n\nI also wanted to have something that gives the possibility to manage in easy way the evolution of the beats during the track, so I used sync messages to register the measures number in order to create conditions inside the loop based on it.\n\nHere an example of a beat that has a fill every forth measure:\n\nuse_bpm 120 # pattern: is an array of 1s and 0s. 1 = beat played, 0 = no beat # drum_sample: the sample you want to play define :play_drum_pattern do |pattern, drum_sample| # Every time this function is called a new thread is created. # The name of the thread is the tick number, in order to be always new # (I come up with this solution after some issues with timing) in_thread(name: tick.to_s) do pattern.each do |p| if p == 1 then sample drum_sample end sleep 0.25 end # at the end, the thread is stopped to free the resources (don't know if necessary anyway) stop end end live_loop :drums do # loop synced with :measure # :measures carries the current measure of the loop, so we can use it to control the behaviour measure = (sync :measure)[0] puts measure if (measure % 4 != 0) then # pattern played for every measure but the last kick = [1,0,0,0, 0,0,0,0, 1,0,0,0, 0,0,0,0] snare = [0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0] play_drum_pattern(kick, :drum_heavy_kick) play_drum_pattern(snare, :drum_snare_soft) else # pattern played for the last measure (the fill) kick = [1,0,0,1, 0,0,0,1, 1,0,1,0, 0,0,0,0] snare = [0,0,0,0, 1,0,0,0, 0,0,0,0, 0,0,0,0] open_hat = [0,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0] play_drum_pattern(kick, :drum_heavy_kick) play_drum_pattern(snare, :drum_snare_soft) play_drum_pattern(open_hat, :drum_cymbal_open) end end measure = 1; live_loop :conductor do cue :beat # every 4 bars, a :measure message is sent (notifying the beginning of a new measure) if (tick % 4 == 0) then cue :measure, measure measure += 1 end sleep 1 end\n\nWhat do you think?\n\nYou’re welcome, this is what it’s all about. As well as the hard tech tips, one great thing I’ve picked up from people here is how they layout their code and how it makes it feel more like performance instrument. I’ll share a couple of idioms around the drums I’ve taken on board.\n\nThe bools() function like this below. My function p(i) plays each sample complete with modulations and effects to taste. Using the one_in() function optionally adds some variation, and the with_random_seed block makes it repeatable.\n\nin_thread do with_random_seed 2 do 20.times do tick p(0) if (bools 1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0).look or one_in(24) p(1) if (bools 0,0,0,0, 1,0,0,0, 0,0,0,0, 1,0,0,0, 1,0,0,0).look or one_in(16) p(2) if (bools 1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0, 1,0,1,0).look ^ one_in(4) p(3) if (bools 1,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0, 0,0,0,0).look or one_in(3) p(4) if (bools 0,0,0,0, 0,0,0,0, 0,0,0,0, 1,0,0,0, 1,0,0,0).look or one_in(5) sleep 1.0/4 end end end\n\nAnd this is one of my favourties, same kind of thing but using pattern strings which are even more grid-sequencer like…\n\nwith_fx :echo, mix: 0.0, phase: 0.75, decay: 6 do with_random_seed (ring 1,1,1,4).tick(:a) do in_thread do 27.times do tick p(9) if (\"1--2--3--4--5--6--7--8--9--\") p(0) if (\"x--------x--------x--------\"[look]==\"x\") #or one_in(27) p(1) if (\"---x--x-----x-----x--x--x--\"[look]==\"x\") ^ one_in(36) p(2) if (\"--x--x--x--x--x--x--x--x--x\"[look]==\"x\") ^ one_in(12) p(3) if (\"-----------------------xxxx\"[look]==\"x\") ^ one_in(12) p(4) if (\"-xx-xx-xx-xx-xx-xx-xx-xx-xx\"[look]==\"x\") ^ one_in(24) p(5) if (\"---x-x---x-x---x-x---x-x---\"[look]==\"x\") ^ one_in(24) p(6) if (\"---x--x-----x--x-----x--x--\"[look]==\"x\") or one_in(27) p(7) if (\"---x--------x--------x-----\"[look]==\"x\") or one_in(27) sleep 1.0/3 end end end end\n\nAnd how about this one, which uses pattern ‘masks’ to apply fills with variations, all of which can be edited live.\n\n#Drumkit with mask variations use_bpm 120 live_loop :drumtest do cue :bar sleep 4 end define :r0 do \"1---2x--3---4-x-\".ring.tick(:r0)==\"x\" and one_in(2) end define :r1 do \"1---2---3---4xxx\".ring.tick(:r1)==\"x\" and one_in(2) end live_loop :drums do sync :bar #stop a = 1.0 n = tick(:bar) s = [:drum_bass_hard, :drum_snare_hard, :drum_cymbal_closed, :ambi_swoosh] define :p do |i| case i when 0 sample s[i], beat_stretch: 1.5, amp: a*0.3 when 1 sample s[i], amp: a*0.2 when 2 sample s[i], beat_stretch: 1, amp: a*0.1*[2,1,1,1].ring.tick(:hat) when 3 sample s[i], beat_stretch: 0.5, amp: a*0.1 end end with_fx :echo, mix: 0.1, phase: 0.75, decay: 6 do with_fx :lpf, cutoff: 130 do in_thread do 16.times do tick p(0) if (\"x-----x-x-------\"[look]==\"x\") ^ r0 #^ one_in(24) p(1) if (\"----x-------x---\"[look]==\"x\") ^ r1 #^ one_in(24) p(2) if (\"xxxxxxxxxxxxxxxx\"[look]==\"x\") #^ one_in(0) p(3) if (\"-x--x--x--x-----\"[look]==\"x\") ^ one_in(16) sleep 1.0/4 end end end end end\n\nYes that is the purpose\n\nWith these techniques, you can have anything in the spectrum between the code making all the decisions to having everything prescribed! It can all lead to lovely music.\n\nThe one_in() function is built-in, and you can choose to comment it out or set a value to give ‘no variation’ all the way to chaos… With my second ‘mask’ examples, I can prescribe a fill or variation exactly, or choose to vary it a bit. one_in(0) is always false, one_in(1) is always true for instance.\n\nA key thing with Sonic Pi is that the randomness is repeatable - you get the same results every run. Which is a very good thing for various reasons. But you can influence that with use_random_seed and with_random_seed. A technique is to create random patterns, but you can make them repeat. The musicians job is then less to create the patterns, but to choose the ones they like.\n\nThis thread is excellent. I have been using a version of my own. It’s based on the part about nested lists here. The guts are really the grid player function. It finds the length of the outer list (#of beats) and plays each item of each list using the time set with a var. It’s very scalable and can take any parameter that you can put in an array. Throw in lists that have fx/synth parameters and use cues to time the calls, or generate random lists of whatever. You just have to modify for the function that makes the call(instead of sample or sleep). The list of lists has an outer list that is each beat and an inner list that is the contents of that beat. Used nil to fill in the gaps where nothing is to happen because it was a little more readable to me with the color change in the editor. I would love to hear any feedback on how to make it better. I am going to play around with the methods shown in this thread and see what I can find.\n\n#bossa16wPlayer.rb use_bpm 80 folderKick = \"C:/Alpha/music/sonic/Analog Kicks/\" #external sample location folderHats = \"C:/Alpha/music/sonic/Analog Hi Hats/\" folderFoley = \"C:/Alpha/music/sonic/Black Octopus/Black Octopus Sound - Foley Essentials by AK\" #declarations for sample names hihat = folderHats, \"6BD AnalogHiHats 17.wav\" #16/17 closed 12 is closing 6/5 are open 1/2 are tiny open/closed#:drum_cymbal_closed rimshot = folderFoley, \"FEAK_Snares & Rims_04.wav\"#:tabla_ke1#:elec_pop kick = folderKick, \"6BD Analog Kicks 03.wav\" #:bd_ada #:drum_bass_hard #:drum_heavy_kick cymbal = folderHats, \"6BD AnalogHiHats 06.wav\"#:drum_cymbal_pedal #declarations for other things t = 0.5 # timing for sleep #function that reads and plays the given list of lists define :list_player do |the_list| #names func and defines parameter for list of lists tick_reset(:list_tick) ##reset the local tick list_length = the_list.length #use .length to make variable with index length list_length.times do #use length var to determine how many iteration(beats) to play tick_counter = tick(:list_tick) #var to increment through index look_counter = look(:list_tick) #optional var to use whithout advanving count sample the_list.ring[tick_counter][1],amp: 0.5 #fetch the [n] element of list sample the_list.ring[tick_counter][2] #first: what to do sec: parameter.ring sample the_list.ring[tick_counter][3],amp: 0.5 #[var for index][list item] sample the_list.ring[tick_counter][4] sample the_list.ring[tick_counter][5] sample the_list.ring[tick_counter][6] sleep the_list.ring[tick_counter][0] end end ##| a list of lists to contain the instructions for above player ##| is the desired #of beats long and contains the desired instruction name ##| made to be 7 spaces wide w/ nils to make referencing new items easier bossa16 = [[t,hihat,kick,rimshot,nil,nil,nil], #one :measure one [t,hihat,nil,nil,nil,nil,nil], #and [t,hihat,nil,nil,cymbal,nil,nil], #two [t,hihat,kick,rimshot,nil,nil,nil], #and [t,hihat,kick,nil,nil,nil,nil], #three [t,hihat,nil,nil,nil,nil,nil], #and [t,hihat,nil,rimshot,cymbal,nil,nil], #four [t,hihat,kick,nil,nil,nil,nil], #and [t,hihat,kick,nil,nil,nil,nil], #one :measure two [t,hihat,nil,nil,nil,nil,nil], #and [t,hihat,nil,rimshot,cymbal,nil,nil], #two [t,hihat,kick,nil,nil,nil,nil], #and [t,hihat,kick,nil,nil,nil,nil], #three [t,hihat,nil,rimshot,nil,nil,nil], #and [t,hihat,nil,nil,cymbal,nil,nil], #four [t,hihat,kick,nil,nil,nil,nil]] #and ##| main loop to repeat list loop do list_player bossa16 #call function for player and include desired list as parameter end\n\nHi @longpork, just breaking down one line:\n\np(0) if (\"x-----x-x-------\"[look]==\"x\") ^ r0\n\nHere p(i) is a function, defined in the code above, that plays a sample with index i.\n\nIn SonicPi (which is Ruby-like) putting if after a statement means it’s only run when the condition after the ‘if’ is true.\n\nThe bit \"x---x---x---x---\"[look] treats the string as an array, and each ‘look’ returns one character. That’s another Ruby-like thing. So it steps through 16 notes of the bar, returning either an ‘x’ or a ‘-’. If it hits a ‘x’ then it runs p(0) i.e. plays a sample. Otherwise it doesn’t - so that’s a rest. The tick/look runs from 0 to 15 so dividing the bar into 16 notes - but you can choose other values.\n\nFinally the ^ r0 refers to another pattern, defined above. This adds some variation. ^ is the ‘Exclusive Or’ operator. You can add all kinds of interesting functions here to give variety to the patterns. E.g. one_in(6) returns True pseudo-randomly, 1/6 of the time.\n\nIs that any help?\n\nI simply copy and pasted his code. ```\n\nwith_fx :echo, mix: 0.0, phase: 0.75, decay: 6 do\n\nwith_random_seed (ring 1,1,1,4).tick(:a) do\n\nin_thread do\n\n27.times do\n\ntick\n\np(9) if (“1–2–3–4–5–6–7–8–9–”)\n\np(0) if (“x--------x--------x--------”[look]==“x”) #or one_in(27)\n\np(1) if (\"—x–x-----x-----x–x–x–\"[look]==“x”) ^ one_in(36)\n\np(2) if (\"–x–x–x–x–x–x–x–x–x\"[look]==“x”) ^ one_in(12)\n\np(3) if (\"-----------------------xxxx\"[look]==“x”) ^ one_in(12)\n\np(4) if (\"-xx-xx-xx-xx-xx-xx-xx-xx-xx\"[look]==“x”) ^ one_in(24)\n\np(5) if (\"—x-x—x-x—x-x—x-x—\"[look]==“x”) ^ one_in(24)\n\np(6) if (\"—x–x-----x–x-----x–x–\"[look]==“x”) or one_in(27)\n\np(7) if (\"—x--------x--------x-----\"[look]==“x”) or one_in(27)\n\nsleep 1.0/3\n\nend\n\nend\n\nend\n\nend\n\nDo i need to combine the two windows of code in his post?\n\nHi, i read very interesting things here about drums, i do, from a couple of tracks, a mix technique that fit wit my needs, here is the example of an electronic ALT-DrumKit Patterns (only using synths with basic params and fx as it is not the main topic here). this help me to set quickly some base during live coding.\n\ni am using a type of “beat variant” to randomize the 3 instruments along the sequence.\n\nuse_bpm 140 # #----------------------------------------------------------------------------------------- pattern_grid = \"----------------\".ring # 4/4 Beat Measure Structure define :silence do 4/pattern_grid.length.to_f end # 1/4 Beat Tempo #----------------<| | | | >-------<| | | | >-------<| | | | >----- p_myKick_seq = [\"9---7---8---7---\".ring, \"9---------------\".ring, \"9-4-----973-----\".ring] p_mySnare_seq = [\"--1-------1-----\".ring, \"--1---1-2-4-----\".ring, \"321-----321-1---\".ring] p_myHihat_seq = [\"1-1-1-1-1-1-1-1-\".ring, \"1---1-1-1-21--1-\".ring, \"--------132--1--\".ring] #----------------------------------------------------------------------------------------- v = 0 # Init Beat Variants #----------------------------------------------------------------------------------------- define :myKick do synth :sine, note: :C2, attack: 0.01, release: 0.3, cutoff: 120, amp: ((p_myKick_seq[v])[look].to_f / 9) if ((p_myKick_seq[v])[tick] != \"-\") end define :mySnare do synth :bnoise, note: :C3, attack: 0.01, release: 0.8, cutoff: 90, amp: ((p_mySnare_seq[v])[look].to_f / 9) if ((p_mySnare_seq[v])[tick] != \"-\") end define :myHihat do synth :noise, note: :C4, attack: 0.01, release: 0.05, cutoff: 130, amp: ((p_myHihat_seq[v])[look].to_f / 9) if ((p_myHihat_seq[v])[tick] != \"-\") end #----------------------------------------------------------------------------------------- with_fx :compressor, clamp_time: 0.05, threshold: 0.5, relax_time: 0.3, mix: 0.2 do with_fx :reverb, damp: 1, room: 1, mix: 0.2 do with_fx :eq, low: 1.2, mid: 0.4, high: 0.8, mix: 0.8 do #------------------------------------------------------------------------------------ live_loop :BEAT_KICK do v = [0, 1, 2, 0/2, 1/2, 2/2].choose myKick sleep silence end #----------------------------------------------------------------------------------- live_loop :BEAT_SNARE do v = [0, 1, 2, 0/2, 1/2, 2/2, 0/4, 1/4, 2/4].choose mySnare sleep silence end #--------------------------------------------------------------------------------- live_loop :BEAT_HIHAT do v = [0, 1, 2].choose myHihat sleep silence end end end end\n\ni am sure there is shorter way to do exactly the same… i am on it.\n\nGuys, keep going, this is awesome and there are plenty of options\n\nbye\n\nuriel"
    }
}