{
    "id": "correct_subsidiary_00127_0",
    "rank": 78,
    "data": {
        "url": "https://patents.google.com/patent/US6453467",
        "read_more_link": "",
        "language": "en",
        "title": "US6453467B2 - Methods and apparatus for linking a program for remote execution - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/59/7e/42/48ea96b0f40ea3/US06453467-20020917-D00000.png",
            "https://patentimages.storage.googleapis.com/06/3b/2d/4c23364ef781a5/US06453467-20020917-D00001.png",
            "https://patentimages.storage.googleapis.com/32/6b/b1/86854e74162085/US06453467-20020917-D00002.png",
            "https://patentimages.storage.googleapis.com/60/a5/ac/e7e7b885ed1243/US06453467-20020917-D00003.png",
            "https://patentimages.storage.googleapis.com/8e/a1/ea/6138fc70984000/US06453467-20020917-D00004.png",
            "https://patentimages.storage.googleapis.com/59/ca/00/8631cd53fa362d/US06453467-20020917-D00005.png",
            "https://patentimages.storage.googleapis.com/3d/95/8c/ebcb0b8123f311/US06453467-20020917-D00006.png",
            "https://patentimages.storage.googleapis.com/45/ad/95/a6b84059c13dbc/US06453467-20020917-D00007.png",
            "https://patentimages.storage.googleapis.com/a9/b0/68/8babc6aa580db5/US06453467-20020917-D00008.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1998-03-20T00:00:00",
        "summary": "",
        "meta_description": "A linkage editor executing at a server receives instructions for packaging software components that are required for program execution at a client. The linkage editor generates an output file by iteratively analyzing the program for references to other software components and extracting those components from their parent classes. The linkage editor sends the completed output file to an interface task, which transmits it to the client.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US6453467B2/en",
        "text": "Methods and apparatus for linking a program for remote execution Download PDF\n\nInfo\n\nPublication number\n\nUS6453467B2\n\nUS6453467B2 US09/726,609 US72660900A US6453467B2 US 6453467 B2 US6453467 B2 US 6453467B2 US 72660900 A US72660900 A US 72660900A US 6453467 B2 US6453467 B2 US 6453467B2\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\ncomponent\n\ncomponents\n\nprogram\n\nextracted\n\nclient\n\nPrior art date\n\n1998-03-20\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nExpired - Lifetime\n\nApplication number\n\nUS09/726,609\n\nOther versions\n\nUS20010000047A1 (en\n\nInventor\n\nPeter W. Madany\n\nRichard Tuck\n\nNedim Fresko\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nSun Microsystems Inc\n\nOriginal Assignee\n\nSun Microsystems Inc\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n1998-03-20\n\nFiling date\n\n2000-12-01\n\nPublication date\n\n2002-09-17\n\n2000-12-01 Application filed by Sun Microsystems Inc filed Critical Sun Microsystems Inc\n\n2000-12-01 Priority to US09/726,609 priority Critical patent/US6453467B2/en\n\n2001-03-15 Publication of US20010000047A1 publication Critical patent/US20010000047A1/en\n\n2002-09-17 Application granted granted Critical\n\n2002-09-17 Publication of US6453467B2 publication Critical patent/US6453467B2/en\n\n2018-03-20 Anticipated expiration legal-status Critical\n\nStatus Expired - Lifetime legal-status Critical Current\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\nImages\n\nClassifications\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F9/00—Arrangements for program control, e.g. control units\n\nG06F9/06—Arrangements for program control, e.g. control units using stored programs, i.e. using an internal store of processing equipment to receive or retain programs\n\nG06F9/44—Arrangements for executing specific programs\n\nG06F9/445—Program loading or initiating\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F8/00—Arrangements for software engineering\n\nG06F8/40—Transformation of program code\n\nG06F8/54—Link editing before load time\n\nDefinitions\n\nEmbodiments of the invention generally relate to distributed computer systems and, more particularly, to methods and apparatus for packaging a computer program for remote execution.\n\nthe Java programming language is an object-oriented programming language that is described, for example, in a text entitled âThe JavaTM tutorialâ by Mary Campione and Kathy Walrath, Addison-Wesley, 1996. 1 Importantly, the Java programming language is an interpreted language that is platform-independentâthat is, its utility is not limited to one particular computer system.\n\na software developer uses the Java programming language to write programs in a form commonly called Java source code. When the developer completes authoring the program, he then compiles it with a Java compiler into an intermediate form called bytecode. Both the Java source code and the bytecode are platform-independent.\n\nL6 Sun, Sun Microsystems, the Sun Logo, Java, the Java Virtual Machine, and the Java Runtime Environment are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.\n\nthe compiled bytecode can then be executed on any computer system that employs a compatible runtime system that includes a virtual machine (VM), such as the Java Runtime Environment (JRE) that includes the Java Virtual Machine (JVM) and Java class libraries.\n\nVM virtual machine\n\nJRE Java Runtime Environment\n\nJVM Java Virtual Machine\n\nJava class libraries Java classes libraries.\n\nthe Java VM acts as an interpreter between the bytecode and the particular computer system being used.\n\nplatform-independent bytecode and the Java VM a program written in the Java programming language can be executed on any computer system. This is particularly useful in networks such as the Internet that interconnect heterogeneous computer systems.\n\nclasses Before a Java program can be executed, certain requisite classes must be loaded into the memory of the computer executing the program. These classes may be loaded from the computer's disk, but are more commonly transferred across a network from a server. Customarily, these classes are loaded as late during the program's execution as possible; in other words, they are loaded on-demand, when first referenced during the program's execution. When such loading occurs, it is also customary to load an entire class whenever any part of that class is necessary.\n\nthe class file containing the main method is loaded from the server to the client across the network.\n\nThis class file contains the program bytecode.\n\nthe virtual machine then begins execution by invoking the main method of the program.\n\nExecution continues until the program references a component, for example a component referred to as âF.â\n\na component for example a component referred to as âF.â\n\nthe entire class that contains component F is transferred from class files on the server to the client via the network.\n\nthe referenced component F is used and execution then continues until another component, for example a component referred to as âG,â is referenced.\n\nthe entire class containing component G is transferred from class files on the server to the client via the network.\n\nExecution then continues to completion. Once the execution has completed, the series of connections between the client and the server over the network may finally be terminated.\n\na method for packaging a program component for execution in a distributed system comprises the steps of determining a component referenced by a program, extracting the component from a stored class, and generating a package that includes the program and the extracted component.\n\na computer-readable medium contains instructions for packaging a program component for execution in a distributed system by determining a component referenced by a program, extracting the component from a stored class, and generating a package that includes the program and the extracted component.\n\nan apparatus for packaging a program component for execution in a distributed system comprises means for determining a component referenced by a program, means for extracting the component from a stored class, and means for generating a package that includes the program and the extracted component.\n\na system comprises a client, a server, and a network.\n\nthe client has a processor, a memory, and a runtime environment including a virtual machine task.\n\nthe server has a processor, a memory, an interface task, a linkage editor task, and a component file.\n\nthe network interconnects the client and the server.\n\nFIG. 1 is a block diagram of a typical client-server configuration used to explain remote program execution using a runtime environment that includes a virtual machine;\n\nFIG. 2 is a block diagram depicting a typical executable object-oriented program along with its referenced components and their dependencies;\n\nFIG. 3 is a timeline used to explain the timing of linking and execution consistent with the present invention.\n\nFIG. 4 is a block diagram depicting typical interface and linkage editor tasks in relation to a server and a client;\n\nFIG. 5 is a flow diagram of the steps performed by an interface task in a packaging process consistent with the present invention.\n\nFIG. 6 is a flow diagram of the steps performed by the linkage editor in packaging an output file, in an embodiment consistent with the present invention.\n\nFIG. 7 is a flow diagram of steps performed to add necessary methods, in an embodiment consistent with the present invention.\n\nFIG. 8 is a flow diagram of the steps performed by the client to execute a program, in an embodiment consistent with the present invention.\n\nSystems and methods consistent with the present invention operate in a distributed computer system, typically having multiple clients and one or more servers.\n\na client seeking to execute a program requests a server to package together the software needed to run the program.\n\nthe client may specify certain components that should be included in the package.\n\na task executing at the server receives this request, and determines the software components that already reside at the client machine.\n\nthe interface task uses this information to formulate a set of instructions to another task called the linkage editor. These instructions may include: the name of the program to be executed, the components that need not be packaged because they already reside at the client machine, and the names of any software components that the client machine may have specified to include in the package.\n\nthe linkage editor receives this information and generates an output file that contains all software components that reside at the server and are necessary for program execution. This output file is generated by iteratively analyzing the program for references to other software components and extracting those components from their parent classes. The linkage editor sends the completed output file to the interface task, which transmits it to the client that requested it, and program execution begins.\n\na Java application program consists of one or more class definitions, each of which has been compiled into its own class file that contains bytecode and other information.\n\na âclass,â in turn, is a collection of data (âfieldsâ), âmethodsâ that operate on the data, and ancillary information.\n\nthe ancillary information may include, for example, shared data structures, names of superclasses, and interfaces implemented.\n\nthe term âcomponentâ refers to either a method or a field or both.\n\nAn âobjectâ is something created by using the blueprint provided by a class, i.e., it is an âinstanceâ of the class.\n\na Java application program must contain one class that defines the main method, which represents the point at which the Java interpreter starts executing the program. Such an application program may be executed by the Java interpreter, i.e. the Java VM.\n\na Java applet does not contain a main method, and consequently cannot be executed directly by the Java interpreter. Instead, a Java applet is a class that is loaded by an already executing Java application such as a Web browser. The Java application invokes the various methods of the applet at the appropriate times.\n\nprogram when used alone, may refer to either an application program, a Java applet, a process, or other software code.\n\ntask may refer to a program executing on a computer processor.\n\npacket may include components, ancillary information, or other data required for program execution.\n\nFIG. 1 shows the use of the Java programming language in a distributed computing system.\n\nthe system consists of one or more servers such as server 160 and one or more clients, such as clients 100 and 155 , interconnected by a network 150 .\n\nthe software developer creates a program using the Java programming language and compiles it into bytecode 115 that is stored on server 160 .\n\nserver 160 also contains numerous class files 125 that are employed by Java 110 programs.\n\nclient 100 wishes to execute a Java program, it issues a request to server 160 .\n\nserver 160 transmits the bytecode version of program 115 to client 100 .\n\nbytecode 115 executes on a runtime environment 110 , which interprets between bytecode 115 and a processor residing on client 100 .\n\nFIG. 2 is an exemplary block diagram showing component references within a typical is executable program.\n\na program 200 references four components, shown here as component A 210 , component B 220 , component C 230 , and component D 240 . These referenced components, in turn, reference other components.\n\ncomponent B 220 references component B 1 250 .\n\ncomponent C 230 references component A 210 and component C 1 270 .\n\ncomponent C 1 270 references component C 1 A 280 .\n\nSuch a reference by one component of another component is commonly referred to as a dependency. Each referenced component must be loaded because it may be used during program execution.\n\nFIG. 3 is a timeline used to explain the timing of linking and execution consistent with the present invention.\n\nthe process begins when a user issues a request to execute a program (point 310 ) on client 100 .\n\nserver 160 determines what components and dependencies are needed for the program to execute (point 320 ). Each of these needed components, along with ancillary class information, is then transferred from server 160 to client 100 via network 150 (point 330 ). At this point, all components and classes required for program execution have been transferred from server 160 to client 100 and, therefore, the connection between the two may be terminated.\n\nProgram execution then begins (point 340 ), and component A 210 is referenced (point 350 ). Because that component has already been loaded onto client 100 (at point 330 ), however, there need be no separate transfer of that component from server 160 to client 100 . Similarly, when component B 220 is referenced (point 360 ), it need not be transferred because it has already been transferred from server 160 to client 100 . Execution therefore proceeds to completion (point 370 ) uninterrupted.\n\nFIG. 3 demonstrates that a process consistent with the present invention requires client 100 to remain connected to server 160 only until program loading ends (from point 300 to point 330 ). Once the necessary components and ancillary class information have been loaded (at point 330 ), client 100 may disconnect from server 160 . Then, for the entire duration of program execution (point 340 to point 370 ), client 100 and server 160 need not be connected. Moreover, server 160 only transfers to client 100 those components and the ancillary class information that are essential to program execution (point 330 ). By eliminating the transfer of unused components, bandwidth is used more efficiently.\n\nFIG. 4 is a block diagram depicting an interface task and a linkage editor in relation to a server and a client.\n\nClient 100 is interconnected to server 160 via network 150 .\n\nServer 160 contains a memory 482 , which may contain Java class files. Examples of memory 482 include random access memory (RAM), read only memory (ROM), a hard disk drive, or a compact disc based ROM (CD-ROM).\n\nRAM random access memory\n\nROM read only memory\n\nCD-ROM compact disc based ROM\n\nExecuting on server 160 are two tasks: an interface task 484 , and a linkage editor, 487 .\n\na request is issued to server 160 to package the necessary Java code to execute a program on client 100 . At server 160 , this request is received by interface task 484 .\n\nInterface task 484 formulates a set of packaging instructions and sends them to linkage editor 487 .\n\nLinkage editor 487 creates a package containing any components necessary for execution that reside on server 160 , and sends the package to interface task 484 .\n\nInterface task 484 receives this package and sends it to client 100 , which uses the package to execute the program.\n\nFIG. 5 is a flow diagram of the steps performed by an interface task in a packaging process consistent with the present invention.\n\ninterface task 484 executing on server 160 receives a request to package a Java program for execution on a named client, for example client 100 (step 510 ).\n\nthe Java program is typically specified as a collection of Java classes and components. The location of some class files is predefined. The location of other, necessary classes is included in the request to package the Java program.\n\ninterface task 484 formulates a set of instructions for a linkage editor. As part of these instructions, the interface task notifies linkage editor 487 of the starting point of the program (step 515 ). This gives linkage editor 487 a starting point for determining which components are needed.\n\nInterface task 484 also notifies linkage editor 487 of any class that is already present on client 100 (step 520 ). By providing this information, the interface task avoids unnecessary packaging: linkage editor 487 need not package components that already exist on client 100 . This conserves bandwidth usage by minimizing the size of the output file.\n\nThis information may be provided to the interface task as part of the request to package components (step 510 ). Alternatively, this information may be stored within memory 482 of server 160 , from having been previously provided. For this step to operate correctly, the classes already present on client 100 must be consistent with those on server 160 .\n\nInterface task 484 also notifies linkage editor 487 of any supplemental component that should be added to the program package (step 530 ). This may be necessary for example, if a component has been excluded from the linkage step because the class containing that component already exists on client 100 ; that excluded component, however, may reference other components that are not available on client 100 , and therefore may be need to be added to the package by linkage editor 487 . In addition to components that are excluded because their class already exists on client 100 , there may also be some dependencies that cannot be discovered programmatically. Interface task 484 typically is informed (at step 510 ) of any supplemental components as part of the request to package components.\n\nthe method quicksort may be excluded from the linkage step because the class containing that method, sun.misc.Sort, is already loaded on client 100 .\n\nthe method quicksort When the method quicksort is invoked, one of its parameters is an object having the method doCompare. Quicksort will invoke doCompare, which may not already be loaded on client 100 . Accordingly, interface task 484 must notify linkage editor 487 that the method doCompare must be loaded as a supplemental component.\n\nInterface task 484 also notifies linkage editor 487 of a list of places to look for the required Java class files (step 540 ). Interface task 484 sends these instructions to linkage editor 487 (step 550 ), which generates an output file as described below in reference to FIG. 5 . Interface task 484 receives the output file and sends it to client 100 (step 560 ), and the process ends.\n\nFIG. 6 is a detailed flow diagram, consistent with the present invention, of the steps performed by linkage editor 487 in packaging an output file.\n\nlinkage editor 487 in packaging an output file.\n\nthe following description of the flow is based upon the example in FIG. 2 .\n\nlinkage editor 487 (typically executing on server 160 ) receives a set of instructions from interface task 484 . Linkage editor 487 then creates and initializes a list with the starting point of the program to be executed (step 605 ). This list, referred to as the âcomponent list,â contains a reference to each necessary component that must be loaded by linkage editor 487 .\n\nLinkage editor 487 selects the next item in the component list, which initially will be the main method (step 610 ). Linkage editor 487 checks to see if the selected component is on of items to exclude because, for example, the component is more readily available from another source, such as client 100 or another server. Because the main method will not be on the list of things to exclude, linkage editor 487 checks to determine if the selected component has previously been loaded in the linkage process (step 620 ). Because the main method will not have been previously loaded, linkage editor 487 then locates the class file that contains the component to be loaded, using the list of file locations provided by the server in its instructions to linkage editor 487 (step 625 ).\n\nLinkage editor 487 reads that class file, extracts any ancillary information associated with that class file, extracts the selected component from the class file, and adds the extracted ancillary information and component to an output file (step 630 ). Note that by doing so, linkage editor 487 only extracts necessary components and ancillary information, rather than loading the entire class.\n\nlinkage editor 487 After loading the extracted component, linkage editor 487 checks for overridden methods (step 632 ). This step is further described in reference to FIG. 7, below. Next, linkage editor 487 analyzes the extracted component to determine if it references other components (step 635 ). In other words, linkage editor 487 analyzes the extracted component for dependencies. In this example, the main method references four components: A, B, C, and D. Because the extracted component (main) contains dependencies (step 640 ), those dependencies are added to the component list (step 645 ), and the process repeats (at step 610 ).\n\ncomponent D is contained in a class that interface task 484 instructed linkage editor 487 to exclude from the packaging process (because, for example, it is already available on client 100 ), component D would be excluded from the output file (step 615 ).\n\nComponents A, B, and C will be extracted from their respective classes (along with ancillary information associated with those classes) and added to the output file (steps 625 - 630 ).\n\nlinkage editor 487 will discover that component B references component B 1 , and component C references components A and C 1 (step 635 ).\n\nComponents B 1 , A, and C 1 will accordingly be added to the component list (step 645 ), and the process will repeat once again (step 610 ).\n\ncomponent A will not be extracted because it has already been added to the output file (step 620 ).\n\nComponents B 1 and C 1 will be extracted from their respective classes and added to the output file, along with the ancillary information associated with their classes (steps 625 - 630 ).\n\nLinkage editor 487 will discover that component C 1 references component C 1 A (step 635 ), and will add it to the component list (step 645 ).\n\nthe process repeats one more time, during which component C 1 A is extracted from its respective class (along with that class' ancillary information) and added to the output file (steps 625 - 630 ).\n\nlinkage editor 487 creates an output file that contains all components (and ancillary class information) that reside on server 160 and are necessary for executing the program. Linkage editor 487 sends this output file to interface task 484 (step 655 ), and the process ends.\n\nFIG. 7 is a flow diagram, consistent with the present invention, of steps performed by linkage editor 487 to check for overridden methods. Overriding is a technique for replacing a superclass's implementation of a method with that of a subclass. To check for overridden methods, linkage editor 487 first determines whether the extracted component is a method or data (step 705 ). Because the issue of overriding only concerns components that are methods, nothing need be done if the extracted component is data. On the other hand, if the extracted component is a method, linkage editor 487 determines whether the method is a constructor (i.e., whether it creates an object) (step 710 ).\n\na constructor i.e., whether it creates an object\n\nlinkage editor 487 next determines whether the method is a static one (step 715 ). If it is static, nothing need be done because static methods cannot be overridden. If the method is not static, linkage editor 487 checks to see if the extracted method has been overridden. Specifically, linkage editor 487 searches all subclasses (of the extracted method's class) that already have a constructor loaded. If any of those subclasses have a method that overrides the extracted method, then that overriding method must be added to the component list (step 720 ).\n\nlinkage editor 487 searches the extracted method's class to determine if it contains any methods that override previously loaded methods. Specifically, linkage editor 487 searches the class containing the extracted component for nonstatic methods (static methods cannot override) (step 725 ). If any of those non-static methods override a method previously loaded from a superclass of the extracted component's class (step 730 ), then the overriding non-static method must be added to the component list (step 735 ).\n\nthe approach described above applies not only to methods that are overridden, but also to methods that are parts of a Java interface specification.\n\nFIG. 8 is a flow diagram of the steps performed by the client to execute a program consistent with the present invention.\n\nclient 100 issues a request to begin execution of the specified program (step 810 ).\n\nclient 100 receives from server 160 a packaged file (i.e., the output file mentioned above) containing all necessary components for program execution (step 820 ).\n\nClient 100 adds the provided components to those already existing on client 100 (step 830 ).\n\nclient 100 reads the information from the packaged file, builds the internal data structures, and links these data structures into its list of class names.\n\nClient 100 then begins executing the program (step 840 ), resolving class names as needed. The process then ends.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nSoftware Systems (AREA)\n\nTheoretical Computer Science (AREA)\n\nGeneral Engineering & Computer Science (AREA)\n\nPhysics & Mathematics (AREA)\n\nGeneral Physics & Mathematics (AREA)\n\nStored Programmes (AREA)\n\nComputer And Data Communications (AREA)\n\nDevices For Executing Special Programs (AREA)\n\nAbstract\n\nA linkage editor executing at a server receives instructions for packaging software components that are required for program execution at a client. The linkage editor generates an output file by iteratively analyzing the program for references to other software components and extracting those components from their parent classes. The linkage editor sends the completed output file to an interface task, which transmits it to the client.\n\nDescription\n\nRELATED APPLICATIONS\n\nThis is a continuation of application Ser. No. 09/044,904, filed Mar. 20, 1998 which is incorporated herein by reference.\n\nThe following U.S. patent application is relied upon and is incorporated by reference in this application: U.S. patent application Ser. No. 09/044,900, entitled âMethods and Apparatus for Packaging a Program for Remote Execution,â and filed on the same date herewith.\n\nBACKGROUND OF THE INVENTION\n\nA. Field of the Invention\n\nEmbodiments of the invention generally relate to distributed computer systems and, more particularly, to methods and apparatus for packaging a computer program for remote execution.\n\nB. Description of the Related Art\n\nIn today's society, the Internet has become an important medium for information exchange. Although the Internet is now very popular among the general public, it initially began as a system (or network) of interconnected computers used by government and academic researchers. An early problem of this network stemmed from the fact that the interconnected computers were not the same; they employed different hardware as well as different operating systems. Information exchange on such a heterogeneous network posed a communication problem. This problem was resolved through agreement on common standards, including protocols such as Transmission Control Protocol/Internet Protocol (TCP/IP) and HyperText Transfer Protocol (HTTP). These protocols enabled varied interconnected machines to share information in the form of static text or graphic documents.\n\nThese protocols, however, represented only two steps in the evolution of the Internet. Although users can exchange information documents among varied computers connected to the Internet, they cannot exchange executable application programs written in conventional languages such as C or C++, which are designed to interface with a particular processor (e.g., the Intel Pentium processor) and/or a particular operating system (e.g., Windows 95 or DOS). This problem was solved with the advent of the Javaâ¢ programming language and its related runtime system.\n\nThe Java programming language is an object-oriented programming language that is described, for example, in a text entitled âThe Javaâ¢ Tutorialâ by Mary Campione and Kathy Walrath, Addison-Wesley, 1996.1 Importantly, the Java programming language is an interpreted language that is platform-independentâthat is, its utility is not limited to one particular computer system. Using the Java programming language, a software developer writes programs in a form commonly called Java source code. When the developer completes authoring the program, he then compiles it with a Java compiler into an intermediate form called bytecode. Both the Java source code and the bytecode are platform-independent. L6 Sun, Sun Microsystems, the Sun Logo, Java, the Java Virtual Machine, and the Java Runtime Environment are trademarks or registered trademarks of Sun Microsystems, Inc. in the United States and other countries.\n\nThe compiled bytecode can then be executed on any computer system that employs a compatible runtime system that includes a virtual machine (VM), such as the Java Runtime Environment (JRE) that includes the Java Virtual Machine (JVM) and Java class libraries. The JVM is described in a text entitled âThe Java Virtual Machine Specification,â by Tim Lindholm and Frank Yellin, Addison Wesley, 1996. The Java VM acts as an interpreter between the bytecode and the particular computer system being used. By use of platform-independent bytecode and the Java VM, a program written in the Java programming language can be executed on any computer system. This is particularly useful in networks such as the Internet that interconnect heterogeneous computer systems.\n\nBefore a Java program can be executed, certain requisite classes must be loaded into the memory of the computer executing the program. These classes may be loaded from the computer's disk, but are more commonly transferred across a network from a server. Customarily, these classes are loaded as late during the program's execution as possible; in other words, they are loaded on-demand, when first referenced during the program's execution. When such loading occurs, it is also customary to load an entire class whenever any part of that class is necessary.\n\nAccording to a conventional approach, when a user on a machine issues a request to execute the program resident on a remote server, the class file containing the main method is loaded from the server to the client across the network. This class file contains the program bytecode. The virtual machine then begins execution by invoking the main method of the program.\n\nExecution continues until the program references a component, for example a component referred to as âF.â In response to this reference, the entire class that contains component F is transferred from class files on the server to the client via the network. The referenced component F is used and execution then continues until another component, for example a component referred to as âG,â is referenced. In response to this reference, the entire class containing component G is transferred from class files on the server to the client via the network. Execution then continues to completion. Once the execution has completed, the series of connections between the client and the server over the network may finally be terminated.\n\nThis description demonstrates two significant disadvantages with the conventional approach. First, it requires repeated connections between the client and the server throughout the course of program execution. Such a lengthy period during which connections must be made may be problematic for situations such as mobile computing. Second, whenever a component is referenced, for example, component F, this approach requires that the entire class containing that referenced component be loaded from the server. If, however, only a few of the components within the class are ultimately used, the bandwidth required to transfer the unused components from the server to the client has been wasted. This is problematic in situations involving limited bandwidth, i.e., slow connection speeds or high-latency connections, between the client and the server.\n\nThere is therefore a need for a system that alleviates these problems by packaging together only the necessary components of an entire program and delivering it to the client before execution begins. Prepackaging software for remote execution has been employed using other compiled computer languages requiring machine compatibility, such as Cobol, C and Fortran. It has not, however, been employed using an object-oriented languages, such as the Java programming language, which provide additional benefits, such as extracting necessary components from their parent classes.\n\nSUMMARY OF THE INVENTION\n\nIn accordance with the present invention, a method for packaging a program component for execution in a distributed system comprises the steps of determining a component referenced by a program, extracting the component from a stored class, and generating a package that includes the program and the extracted component.\n\nIn accordance with the present invention, a computer-readable medium contains instructions for packaging a program component for execution in a distributed system by determining a component referenced by a program, extracting the component from a stored class, and generating a package that includes the program and the extracted component.\n\nIn accordance with the present invention, an apparatus for packaging a program component for execution in a distributed system comprises means for determining a component referenced by a program, means for extracting the component from a stored class, and means for generating a package that includes the program and the extracted component.\n\nIn accordance with the present invention, a system comprises a client, a server, and a network. The client has a processor, a memory, and a runtime environment including a virtual machine task. The server has a processor, a memory, an interface task, a linkage editor task, and a component file. The network interconnects the client and the server.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nThe accompanying drawings, which are incorporated in and constitute a part of this specification, illustrate an embodiment of the invention and, together with the description, serve to explain the advantages and principles of the invention. In the drawings,\n\nFIG. 1 is a block diagram of a typical client-server configuration used to explain remote program execution using a runtime environment that includes a virtual machine;\n\nFIG. 2 is a block diagram depicting a typical executable object-oriented program along with its referenced components and their dependencies;\n\nFIG. 3 is a timeline used to explain the timing of linking and execution consistent with the present invention;\n\nFIG. 4 is a block diagram depicting typical interface and linkage editor tasks in relation to a server and a client;\n\nFIG. 5 is a flow diagram of the steps performed by an interface task in a packaging process consistent with the present invention;\n\nFIG. 6 is a flow diagram of the steps performed by the linkage editor in packaging an output file, in an embodiment consistent with the present invention; and\n\nFIG. 7 is a flow diagram of steps performed to add necessary methods, in an embodiment consistent with the present invention; and\n\nFIG. 8 is a flow diagram of the steps performed by the client to execute a program, in an embodiment consistent with the present invention.\n\nDETAILED DESCRIPTION\n\nReference will now be made in detail to an implementation of the present invention as illustrated in the accompanying drawings. Wherever possible, the same reference numbers will be used throughout the drawings and the following description to refer to the same or like parts.\n\nA. Overview\n\nSystems and methods consistent with the present invention operate in a distributed computer system, typically having multiple clients and one or more servers. As one example, a client seeking to execute a program requests a server to package together the software needed to run the program. In formulating this request, the client may specify certain components that should be included in the package.\n\nA task executing at the server (the âinterface taskâ) receives this request, and determines the software components that already reside at the client machine. The interface task uses this information to formulate a set of instructions to another task called the linkage editor. These instructions may include: the name of the program to be executed, the components that need not be packaged because they already reside at the client machine, and the names of any software components that the client machine may have specified to include in the package.\n\nThe linkage editor receives this information and generates an output file that contains all software components that reside at the server and are necessary for program execution. This output file is generated by iteratively analyzing the program for references to other software components and extracting those components from their parent classes. The linkage editor sends the completed output file to the interface task, which transmits it to the client that requested it, and program execution begins.\n\nB. Terminology\n\nFor the sake of explanation, the detailed description below is based upon the Java programming language. For that reason, there follows a brief section defining terminology as used hereinafter. One of skill in the art, however, will recognize that the same principles explained below apply to other programming languages.\n\nA Java application program consists of one or more class definitions, each of which has been compiled into its own class file that contains bytecode and other information. A âclass,â in turn, is a collection of data (âfieldsâ), âmethodsâ that operate on the data, and ancillary information. The ancillary information may include, for example, shared data structures, names of superclasses, and interfaces implemented. As used herein, the term âcomponentâ refers to either a method or a field or both. An âobjectâ is something created by using the blueprint provided by a class, i.e., it is an âinstanceâ of the class. A Java application program must contain one class that defines the main method, which represents the point at which the Java interpreter starts executing the program. Such an application program may be executed by the Java interpreter, i.e. the Java VM.\n\nIn contrast to a stand-alone application program, a Java applet does not contain a main method, and consequently cannot be executed directly by the Java interpreter. Instead, a Java applet is a class that is loaded by an already executing Java application such as a Web browser. The Java application invokes the various methods of the applet at the appropriate times.\n\nAs used herein, the term âprogram,â when used alone, may refer to either an application program, a Java applet, a process, or other software code. The term âtaskâ may refer to a program executing on a computer processor. The term âpackageâ may include components, ancillary information, or other data required for program execution.\n\nFor the sake of simplicity, the examples contained herein assume that an application program is being executed. Those of skill in the art, however, will recognize that the claimed invention may encompass execution of an applet and other software code.\n\nC. Architecture\n\nFIG. 1 shows the use of the Java programming language in a distributed computing system. The system consists of one or more servers such as server 160 and one or more clients, such as clients 100 and 155, interconnected by a network 150. The software developer creates a program using the Java programming language and compiles it into bytecode 115 that is stored on server 160. Typically, server 160 also contains numerous class files 125 that are employed by Java 110 programs. When a client 100 wishes to execute a Java program, it issues a request to server 160. In response, server 160 transmits the bytecode version of program 115 to client 100. At client 100, bytecode 115 executes on a runtime environment 110, which interprets between bytecode 115 and a processor residing on client 100.\n\nFIG. 2 is an exemplary block diagram showing component references within a typical is executable program. In this example, a program 200 references four components, shown here as component A 210, component B 220, component C 230, and component D 240. These referenced components, in turn, reference other components. For example, component B 220 references component B1 250. Similarly, component C 230 references component A 210 and component C1 270. In turn, component C1 270 references component C1A 280. Such a reference by one component of another component is commonly referred to as a dependency. Each referenced component must be loaded because it may be used during program execution.\n\nD. Timeline\n\nFIG. 3 is a timeline used to explain the timing of linking and execution consistent with the present invention. The process begins when a user issues a request to execute a program (point 310) on client 100. In response, server 160 determines what components and dependencies are needed for the program to execute (point 320). Each of these needed components, along with ancillary class information, is then transferred from server 160 to client 100 via network 150 (point 330). At this point, all components and classes required for program execution have been transferred from server 160 to client 100 and, therefore, the connection between the two may be terminated.\n\nProgram execution then begins (point 340), and component A 210 is referenced (point 350). Because that component has already been loaded onto client 100 (at point 330), however, there need be no separate transfer of that component from server 160 to client 100. Similarly, when component B 220 is referenced (point 360), it need not be transferred because it has already been transferred from server 160 to client 100. Execution therefore proceeds to completion (point 370) uninterrupted.\n\nFIG. 3 demonstrates that a process consistent with the present invention requires client 100 to remain connected to server 160 only until program loading ends (from point 300 to point 330). Once the necessary components and ancillary class information have been loaded (at point 330), client 100 may disconnect from server 160. Then, for the entire duration of program execution (point 340 to point 370), client 100 and server 160 need not be connected. Moreover, server 160 only transfers to client 100 those components and the ancillary class information that are essential to program execution (point 330). By eliminating the transfer of unused components, bandwidth is used more efficiently.\n\nE. Architecture of Interface Task and Linkage Editor\n\nFIG. 4 is a block diagram depicting an interface task and a linkage editor in relation to a server and a client. Client 100 is interconnected to server 160 via network 150. Server 160 contains a memory 482, which may contain Java class files. Examples of memory 482 include random access memory (RAM), read only memory (ROM), a hard disk drive, or a compact disc based ROM (CD-ROM). Executing on server 160 are two tasks: an interface task 484, and a linkage editor, 487. A request is issued to server 160 to package the necessary Java code to execute a program on client 100. At server 160, this request is received by interface task 484. Interface task 484, in turn, formulates a set of packaging instructions and sends them to linkage editor 487. Linkage editor 487 creates a package containing any components necessary for execution that reside on server 160, and sends the package to interface task 484. Interface task 484 receives this package and sends it to client 100, which uses the package to execute the program.\n\nF. Interface Task\n\nFIG. 5 is a flow diagram of the steps performed by an interface task in a packaging process consistent with the present invention. At the beginning of the process, interface task 484 (executing on server 160) receives a request to package a Java program for execution on a named client, for example client 100 (step 510). The Java program is typically specified as a collection of Java classes and components. The location of some class files is predefined. The location of other, necessary classes is included in the request to package the Java program.\n\nIn response to this request, interface task 484 formulates a set of instructions for a linkage editor. As part of these instructions, the interface task notifies linkage editor 487 of the starting point of the program (step 515). This gives linkage editor 487 a starting point for determining which components are needed.\n\nInterface task 484 also notifies linkage editor 487 of any class that is already present on client 100 (step 520). By providing this information, the interface task avoids unnecessary packaging: linkage editor 487 need not package components that already exist on client 100. This conserves bandwidth usage by minimizing the size of the output file. This information may be provided to the interface task as part of the request to package components (step 510). Alternatively, this information may be stored within memory 482 of server 160, from having been previously provided. For this step to operate correctly, the classes already present on client 100 must be consistent with those on server 160.\n\nInterface task 484 also notifies linkage editor 487 of any supplemental component that should be added to the program package (step 530). This may be necessary for example, if a component has been excluded from the linkage step because the class containing that component already exists on client 100; that excluded component, however, may reference other components that are not available on client 100, and therefore may be need to be added to the package by linkage editor 487. In addition to components that are excluded because their class already exists on client 100, there may also be some dependencies that cannot be discovered programmatically. Interface task 484 typically is informed (at step 510) of any supplemental components as part of the request to package components.\n\nFor example, the method quicksort may be excluded from the linkage step because the class containing that method, sun.misc.Sort, is already loaded on client 100. When the method quicksort is invoked, one of its parameters is an object having the method doCompare. Quicksort will invoke doCompare, which may not already be loaded on client 100. Accordingly, interface task 484 must notify linkage editor 487 that the method doCompare must be loaded as a supplemental component.\n\nInterface task 484 also notifies linkage editor 487 of a list of places to look for the required Java class files (step 540). Interface task 484 sends these instructions to linkage editor 487 (step 550), which generates an output file as described below in reference to FIG. 5. Interface task 484 receives the output file and sends it to client 100 (step 560), and the process ends.\n\nG. Linkage Editor\n\nFIG. 6 is a detailed flow diagram, consistent with the present invention, of the steps performed by linkage editor 487 in packaging an output file. For explanatory purposes, the following description of the flow is based upon the example in FIG. 2.\n\nIn the beginning of the process, linkage editor 487 (typically executing on server 160) receives a set of instructions from interface task 484. Linkage editor 487 then creates and initializes a list with the starting point of the program to be executed (step 605). This list, referred to as the âcomponent list,â contains a reference to each necessary component that must be loaded by linkage editor 487.\n\nLinkage editor 487 then selects the next item in the component list, which initially will be the main method (step 610). Linkage editor 487 checks to see if the selected component is on of items to exclude because, for example, the component is more readily available from another source, such as client 100 or another server. Because the main method will not be on the list of things to exclude, linkage editor 487 checks to determine if the selected component has previously been loaded in the linkage process (step 620). Because the main method will not have been previously loaded, linkage editor 487 then locates the class file that contains the component to be loaded, using the list of file locations provided by the server in its instructions to linkage editor 487 (step 625). Linkage editor 487 reads that class file, extracts any ancillary information associated with that class file, extracts the selected component from the class file, and adds the extracted ancillary information and component to an output file (step 630). Note that by doing so, linkage editor 487 only extracts necessary components and ancillary information, rather than loading the entire class.\n\nAfter loading the extracted component, linkage editor 487 checks for overridden methods (step 632). This step is further described in reference to FIG. 7, below. Next, linkage editor 487 analyzes the extracted component to determine if it references other components (step 635). In other words, linkage editor 487 analyzes the extracted component for dependencies. In this example, the main method references four components: A, B, C, and D. Because the extracted component (main) contains dependencies (step 640), those dependencies are added to the component list (step 645), and the process repeats (at step 610).\n\nThe same process described above with respect to the main method is then followed for components A, B, C, and D. Assuming that component D is contained in a class that interface task 484 instructed linkage editor 487 to exclude from the packaging process (because, for example, it is already available on client 100), component D would be excluded from the output file (step 615). Components A, B, and C, on the other hand, will be extracted from their respective classes (along with ancillary information associated with those classes) and added to the output file (steps 625-630). When those components are extracted and analyzed, linkage editor 487 will discover that component B references component B1, and component C references components A and C1 (step 635). Components B1, A, and C1 will accordingly be added to the component list (step 645), and the process will repeat once again (step 610).\n\nDuring this next iteration, component A will not be extracted because it has already been added to the output file (step 620). Components B1 and C1, however, will be extracted from their respective classes and added to the output file, along with the ancillary information associated with their classes (steps 625-630). Linkage editor 487 will discover that component C1 references component C1A (step 635), and will add it to the component list (step 645). The process repeats one more time, during which component C1A is extracted from its respective class (along with that class' ancillary information) and added to the output file (steps 625-630).\n\nBy using this iterative process, linkage editor 487 creates an output file that contains all components (and ancillary class information) that reside on server 160 and are necessary for executing the program. Linkage editor 487 sends this output file to interface task 484 (step 655), and the process ends.\n\nFIG. 7 is a flow diagram, consistent with the present invention, of steps performed by linkage editor 487 to check for overridden methods. Overriding is a technique for replacing a superclass's implementation of a method with that of a subclass. To check for overridden methods, linkage editor 487 first determines whether the extracted component is a method or data (step 705). Because the issue of overriding only concerns components that are methods, nothing need be done if the extracted component is data. On the other hand, if the extracted component is a method, linkage editor 487 determines whether the method is a constructor (i.e., whether it creates an object) (step 710).\n\nIf the extracted method is not a constructor, linkage editor 487 next determines whether the method is a static one (step 715). If it is static, nothing need be done because static methods cannot be overridden. If the method is not static, linkage editor 487 checks to see if the extracted method has been overridden. Specifically, linkage editor 487 searches all subclasses (of the extracted method's class) that already have a constructor loaded. If any of those subclasses have a method that overrides the extracted method, then that overriding method must be added to the component list (step 720).\n\nIf the extracted method is a constructor, linkage editor 487 searches the extracted method's class to determine if it contains any methods that override previously loaded methods. Specifically, linkage editor 487 searches the class containing the extracted component for nonstatic methods (static methods cannot override) (step 725). If any of those non-static methods override a method previously loaded from a superclass of the extracted component's class (step 730), then the overriding non-static method must be added to the component list (step 735). The approach described above applies not only to methods that are overridden, but also to methods that are parts of a Java interface specification.\n\nH. Client Procedure\n\nFIG. 8 is a flow diagram of the steps performed by the client to execute a program consistent with the present invention. First, client 100 issues a request to begin execution of the specified program (step 810). In response to this request, client 100 receives from server 160 a packaged file (i.e., the output file mentioned above) containing all necessary components for program execution (step 820). Client 100 adds the provided components to those already existing on client 100 (step 830). Specifically, client 100 reads the information from the packaged file, builds the internal data structures, and links these data structures into its list of class names. Client 100 then begins executing the program (step 840), resolving class names as needed. The process then ends.\n\nI. Conclusion\n\nThe system described above packages together only the components necessary for program execution and delivers them to the client before execution begins. The foregoing description of an implementation of the invention has been presented for purposes of illustration and description. For example, the described implementation includes software but the present invention may be implemented as a combination of hardware and software or in hardware alone. Modifications and variations are possible in light of the above teachings or may be acquired from practicing the invention.\n\nAlthough systems and methods consistent with the present invention are described as operating in the exemplary distributed system and the Java programming environment, one skilled in the art will appreciate that the present invention can be practiced in other systems and programming environments. Additionally, although aspects of the present invention are described as being stored in memory, one skilled in the art will appreciate that these aspects can also be stored on other types of computer-readable media, such as secondary storage devices, like hard disks, floppy disks, or CD-ROM; a carrier wave from the Internet; or other forms of RAM or ROM. The scope of the invention is defined by the claims and their equivalents.\n\nClaims (25)\n\nWhat is claimed is:\n\n1. A method for packaging program components for execution in a distributed system comprising:\n\nreceiving a request to package a program for execution on a client;\n\ndetermining whether any components are required to execute the program;\n\ngenerating a notification of classes that are located at the client;\n\nreceiving an output file including the required components;\n\ngenerating a package including the output file; and\n\nsending the package to the client.\n\n2. The method of claim 1, wherein determining whether any components are required to execute the program includes:\n\ndetermining whether any supplemental components are required to execute the program, wherein the output file includes the supplemental components.\n\n3. The method of claim 2, wherein the supplemental components include components that are contained within classes that are located at the client.\n\n4. The method of claim 3, wherein the supplemental components include components that are contained within classes that are located at the client and reference other components not located at the client.\n\n5. The method of claim 1, wherein the request includes the location of classes required for the execution of the program.\n\n6. The method of claim 1, wherein the classes located at the client are indicated in a memory and wherein the step of generating a notification includes:\n\nreading the memory to determine the classes located at the client.\n\n7. The method of claim 1 wherein the program is a collection of classes and components.\n\n8. The method of claim 1, wherein the output file includes overriding methods.\n\n9. A method for packaging program components for execution in a distributed system comprising:\n\nreceiving instructions from an interface task, the instructions including the location of classes required for the execution of a program on a client computer;\n\nusing the instructions to locate a class containing a component required to execute the program;\n\nextracting the component from the located class;\n\ninserting the extracted component into an output file;\n\ndetermining whether the extracted component references another component;\n\nextracting the referenced another component;\n\nadding the extracted referenced another component to the output file; and\n\nsending the output file to the interface task.\n\n10. The method of claim 9, wherein determining whether the extracted component references another component includes:\n\ndetermining whether the extracted component contains dependent components;\n\nadding the dependent components to a component list;\n\nusing the instructions to locate the classes containing the dependent components included in the component list; and\n\nadding the dependent components to the output file.\n\n11. The method of claim 9, wherein extracting the referenced another component includes:\n\ndetermining that the extracted referenced another component is a constructor component;\n\nlocating the extracted referenced another component's class;\n\nlocating an overriding method within the extracted referenced another component's class; and\n\nadding the overriding method to the output file.\n\n12. The method of claim 11, wherein the overriding method overrides a method previously loaded from a superclass of the extracted referenced another component's class.\n\n13. The method of claim 9, wherein extracting the referenced another component includes:\n\ndetermining that the extracted referenced another component is not a constructor component;\n\nlocating the extracted referenced another component's class;\n\nsearching a subclass of the extracted referenced another component's class, wherein the subclass includes a loaded constructor component;\n\ndetermining whether the subclass includes a method that overrides the extracted referenced another component; and\n\nadding the method that overrides the extracted referenced another component to the output file.\n\n14. The method of claim 9, wherein extracting the component includes:\n\ndetermining that the extracted component is a constructor component;\n\nlocating the extracted component's class;\n\nlocating an overriding method within the extracted component's class; and\n\nadding the overriding method to the output file.\n\n15. The method of claim 14, wherein the overriding method overrides a method previously loaded from a superclass of the extracted component's class.\n\n16. The method of claim 9, wherein extracting the referenced component includes:\n\ndetermining that the extracted component is not a constructor component;\n\nlocating the extracted component's class;\n\nsearching a subclass of the extracted method's class, wherein the subclass includes a loaded constructor component;\n\ndetermining whether the subclass includes a method that overrides the extracted component; and\n\nadding the method that overrides the extracted component to the output file.\n\n17. A method for packaging program components for execution in a distributed system comprising:\n\nextracting a component from a stored class, wherein the extracted component is a required component for the execution of a program at a client;\n\ndetermining that the extracted component is a constructor component;\n\nlocating the extracted component's class;\n\nlocating an overriding method within the extracted component's class; and\n\ninserting the overriding method into an output file, wherein the output file includes a plurality of required components needed to execute the program that are not located at the client.\n\n18. A method for packaging program components for execution in a distributed system comprising:\n\nextracting a component from a stored class, wherein the extracted component is a required component for the execution of a program at a client;\n\ndetermining that the extracted component is not a constructor component;\n\nlocating the extracted component's class;\n\nsearching a subclass of the extracted method's class, wherein the subclass includes a loaded constructor component;\n\ndetermining whether the subclass includes a method that overrides the extracted component; and\n\nadding the method that overrides the extracted component to an output file, wherein the output file includes a plurality of required components needed to execute the program that are not located at the client.\n\n19. A method for executing a retrieved program in a distributed system, comprising:\n\nsending a request to execute a program to a server;\n\nreceiving from the server a package of components required to execute the program;\n\nextracting the components from the package;\n\ncombining the extracted components with already existing components; and\n\nusing the extracted and existing components to execute the program.\n\n20. The method of claim 19, wherein the components included in the package include overriding methods.\n\n21. The method of claim 19, wherein the components included in the package include at least a first component, and wherein the package includes all components referenced by the first component.\n\n22. The method of claim 21, wherein the components referenced by the first component are not identical with the existing components.\n\n23. The method of claim 21, wherein the components referenced by the first component include at least one component identical to one of the existing components.\n\n24. A method for packaging program components for execution in a distributed system, the method performed by a client computer comprising the steps of:\n\nsending a request to a server to execute a program, the program including references to components;\n\nreceiving a package from the server, the package including the program and extracted components;\n\nadding the extracted components to preexisting components located at the client computer; and\n\nexecuting the program.\n\n25. A method for packaging program components for execution in a distributed system, comprising:\n\nsending a request to execute a program from a client to a server, the program including references to components;\n\ncreating, at the server, a package that includes the program and components required for execution of the program;\n\nsending the package to the client; and\n\nusing the components in the package to execute the program.\n\nUS09/726,609 1998-03-20 2000-12-01 Methods and apparatus for linking a program for remote execution Expired - Lifetime US6453467B2 (en)\n\nPriority Applications (1)\n\nApplication Number Priority Date Filing Date Title US09/726,609 US6453467B2 (en) 1998-03-20 2000-12-01 Methods and apparatus for linking a program for remote execution\n\nApplications Claiming Priority (2)\n\nApplication Number Priority Date Filing Date Title US09/044,904 US6199196B1 (en) 1998-03-20 1998-03-20 Methods and apparatus for linking a program for remote execution US09/726,609 US6453467B2 (en) 1998-03-20 2000-12-01 Methods and apparatus for linking a program for remote execution\n\nRelated Parent Applications (1)\n\nApplication Number Title Priority Date Filing Date US09/044,904 Continuation US6199196B1 (en) 1998-03-20 1998-03-20 Methods and apparatus for linking a program for remote execution\n\nPublications (2)\n\nPublication Number Publication Date US20010000047A1 US20010000047A1 (en) 2001-03-15 US6453467B2 true US6453467B2 (en) 2002-09-17\n\nFamily\n\nID=21934955\n\nFamily Applications (2)\n\nApplication Number Title Priority Date Filing Date US09/044,904 Expired - Lifetime US6199196B1 (en) 1998-03-20 1998-03-20 Methods and apparatus for linking a program for remote execution US09/726,609 Expired - Lifetime US6453467B2 (en) 1998-03-20 2000-12-01 Methods and apparatus for linking a program for remote execution\n\nFamily Applications Before (1)\n\nApplication Number Title Priority Date Filing Date US09/044,904 Expired - Lifetime US6199196B1 (en) 1998-03-20 1998-03-20 Methods and apparatus for linking a program for remote execution\n\nCountry Status (4)\n\nCountry Link US (2) US6199196B1 (en) EP (1) EP0950950A3 (en) JP (1) JP2000029714A (en) CN (1) CN1205537C (en)\n\nCited By (4)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20010001328A1 (en) * 1998-10-16 2001-05-17 Chikara Yoshida Link apparatus and virtual machine US20030121024A1 (en) * 2001-12-13 2003-06-26 Microsoft Corporation System and method for building a runtime image from components of a software program US6725451B1 (en) * 1997-12-17 2004-04-20 Siemens Aktiengesellschaft Method for converting a system call US20040148613A1 (en) * 2001-05-30 2004-07-29 Yach David P. Mobile communication device application processing system\n\nFamilies Citing this family (30)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US6493870B1 (en) * 1998-03-20 2002-12-10 Sun Microsystems, Inc. Methods and apparatus for packaging a program for remote execution US6199196B1 (en) * 1998-03-20 2001-03-06 Sun Microsystems, Inc. Methods and apparatus for linking a program for remote execution US6829761B1 (en) * 1999-10-21 2004-12-07 Oracle International Corporation Method and apparatus for managing shared memory in a run-time environment US6865732B1 (en) * 1999-11-01 2005-03-08 Hewlett-Packard Development Company, L.P. Providing an embedded application specific web server US6813762B1 (en) * 2000-02-22 2004-11-02 Freescale Semiconductor, Inc. Method for processing program files in a programming language capable of dynamic loading US7092892B1 (en) * 2000-03-01 2006-08-15 Site59, Inc. System and method for grouping and selling products or services US7395220B2 (en) * 2000-03-01 2008-07-01 Travelocity.Com Lp System, methods and computer program products for offering products based on extrapolation of inputs JP2002092366A (en) * 2000-09-11 2002-03-29 Nec Corp Cpu time-division purchase-and-sale method and control server in cpu time-division purchase-and-sale system US6748591B1 (en) * 2000-09-14 2004-06-08 International Business Machines Corporation Method, system, program, and data structures for loading programs into a runtime environment US20020087734A1 (en) * 2000-12-29 2002-07-04 Marshall Donald Brent System and method for managing dependencies in a component-based system US7080373B2 (en) * 2001-03-07 2006-07-18 Freescale Semiconductor, Inc. Method and device for creating and using pre-internalized program files US6971001B1 (en) * 2001-05-17 2005-11-29 Accenture Global Services Gmbh General and reusable components for defining net-centric application program architectures US7243346B1 (en) * 2001-05-21 2007-07-10 Microsoft Corporation Customized library management system US7389515B1 (en) 2001-05-21 2008-06-17 Microsoft Corporation Application deflation system and method US6986148B2 (en) * 2001-07-17 2006-01-10 Appforge, Inc. Methods and systems for providing platform-independent shared software components for mobile devices US6944855B2 (en) 2001-10-25 2005-09-13 Siemens Medical Solutions Health Services Corporation System, method, and article of manufacture for creating and updating an application using software application elements US8074201B2 (en) * 2002-07-10 2011-12-06 National Instruments Corporation Deployment and execution of a program on an embedded device US7293262B2 (en) * 2003-01-27 2007-11-06 Bea Systems, Inc. Web based interface for JAVA message service mark-up language US7647562B2 (en) * 2003-04-03 2010-01-12 National Instruments Corporation Deployment and execution of a graphical program on an embedded device from a PDA US7308684B2 (en) * 2003-06-16 2007-12-11 Microsoft Corporation Classifying software and reformulating resources according to classifications US7210124B2 (en) * 2003-06-16 2007-04-24 Microsoft Corporation Reformulating resources with nodes reachable from defined entry points US20040268302A1 (en) * 2003-06-26 2004-12-30 Microsoft Corporation Framework for determining and exposing binary dependencies US7496904B2 (en) * 2003-06-26 2009-02-24 Microsoft Corporation Mining dependencies for testing and risk management KR100590895B1 (en) 2004-11-09 2006-06-19 ì¼ì±ì ìì£¼ìíì¬ Apparatus of System control using the embedded web and Method thereof US20060225051A1 (en) * 2005-04-05 2006-10-05 Cisco Technology, Inc. Method and system for code coverage US20090070752A1 (en) * 2007-09-06 2009-03-12 International Business Machines Corporation Method and system for optimization of an application US8127273B2 (en) * 2007-11-09 2012-02-28 International Business Machines Corporation Node selection for executing a Java application among a plurality of nodes US8397225B2 (en) 2008-04-24 2013-03-12 International Business Machines Corporation Optimizing just-in-time compiling for a java application executing on a compute node CN103473089A (en) * 2013-09-02 2013-12-25 æ·±å³å¸åå²æ°æ®ææ¯æéå ¬å¸ Distributed JAVA program running method, device and system CN110795200A (en) * 2018-08-01 2020-02-14 åäº¬éäºç©èç§ææéå ¬å¸ Device suitable for Java running environment and implementation method thereof\n\nCitations (9)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US5519866A (en) * 1993-06-28 1996-05-21 Taligent, Inc. Method and apparatus of incrementally linking components of a modeled computer program US5553290A (en) * 1987-11-18 1996-09-03 International Business Machines Corporation Software packaging structure having hierarchical replaceable units US5590331A (en) * 1994-12-23 1996-12-31 Sun Microsystems, Inc. Method and apparatus for generating platform-standard object files containing machine-independent code US5727147A (en) * 1995-12-08 1998-03-10 Sun Microsystems, Inc. System and method for resolving symbolic references to externally located program files US5790796A (en) * 1996-06-14 1998-08-04 Symantec Corporation Polymorphic package files to update software components US5802514A (en) * 1996-04-09 1998-09-01 Vision Software Tools, Inc. Automated client/server development tool using drag-and-drop metaphor US5862346A (en) * 1996-06-28 1999-01-19 Metadigm Distributed group activity data network system and corresponding method US5966702A (en) * 1997-10-31 1999-10-12 Sun Microsystems, Inc. Method and apparatus for pre-processing and packaging class files US6199196B1 (en) * 1998-03-20 2001-03-06 Sun Microsystems, Inc. Methods and apparatus for linking a program for remote execution\n\nFamily Cites Families (3)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US5603031A (en) 1993-07-08 1997-02-11 General Magic, Inc. System and method for distributed computation based upon the movement, execution, and interaction of processes in a network US6526565B1 (en) * 1995-12-21 2003-02-25 International Business Machines Corporation Packaging algorithm for providing object oriented applications having reduced footprints US5815718A (en) * 1996-05-30 1998-09-29 Sun Microsystems, Inc. Method and system for loading classes in read-only memory\n\n1998\n\n1998-03-20 US US09/044,904 patent/US6199196B1/en not_active Expired - Lifetime\n\n1999\n\n1999-03-18 JP JP11116932A patent/JP2000029714A/en active Pending\n\n1999-03-19 CN CN99107382.7A patent/CN1205537C/en not_active Expired - Lifetime\n\n1999-03-19 EP EP99400685A patent/EP0950950A3/en not_active Withdrawn\n\n2000\n\n2000-12-01 US US09/726,609 patent/US6453467B2/en not_active Expired - Lifetime\n\nPatent Citations (9)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US5553290A (en) * 1987-11-18 1996-09-03 International Business Machines Corporation Software packaging structure having hierarchical replaceable units US5519866A (en) * 1993-06-28 1996-05-21 Taligent, Inc. Method and apparatus of incrementally linking components of a modeled computer program US5590331A (en) * 1994-12-23 1996-12-31 Sun Microsystems, Inc. Method and apparatus for generating platform-standard object files containing machine-independent code US5727147A (en) * 1995-12-08 1998-03-10 Sun Microsystems, Inc. System and method for resolving symbolic references to externally located program files US5802514A (en) * 1996-04-09 1998-09-01 Vision Software Tools, Inc. Automated client/server development tool using drag-and-drop metaphor US5790796A (en) * 1996-06-14 1998-08-04 Symantec Corporation Polymorphic package files to update software components US5862346A (en) * 1996-06-28 1999-01-19 Metadigm Distributed group activity data network system and corresponding method US5966702A (en) * 1997-10-31 1999-10-12 Sun Microsystems, Inc. Method and apparatus for pre-processing and packaging class files US6199196B1 (en) * 1998-03-20 2001-03-06 Sun Microsystems, Inc. Methods and apparatus for linking a program for remote execution\n\nNon-Patent Citations (4)\n\n* Cited by examiner, â Cited by third party Title Coffee, \"Speaking Native Language: IBM's HPJ beta performs speedy compilation but has its limits\" PC Week , Jun. 1997, pp 46.* * Hibbard, \"Microsoft, Sun add Java to Web servers\", Computerworld, Dec. 16, 1996, p. 12. * Lentczner, \"Java's Virtual World: Java Components incluse High-level language and Virtual Machine\", Microprocessor Report, Oct. 1996, vol. 10, No. 4.* * Leopold, \"Object-Oriented Programming in Ada\", IEEE, 1989, pp 549-552.* *\n\nCited By (8)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US6725451B1 (en) * 1997-12-17 2004-04-20 Siemens Aktiengesellschaft Method for converting a system call US20010001328A1 (en) * 1998-10-16 2001-05-17 Chikara Yoshida Link apparatus and virtual machine US20040148613A1 (en) * 2001-05-30 2004-07-29 Yach David P. Mobile communication device application processing system US7493616B2 (en) * 2001-05-30 2009-02-17 Research In Motion Limited Mobile communication device application processing system US20090210877A1 (en) * 2001-05-30 2009-08-20 Yach David P Mobile Communications Device Application Processing System US8627316B2 (en) 2001-05-30 2014-01-07 Blackberry Limited Mobile communications device application processing system US20030121024A1 (en) * 2001-12-13 2003-06-26 Microsoft Corporation System and method for building a runtime image from components of a software program US7484223B2 (en) 2001-12-13 2009-01-27 Microsoft Corporation System and method for building a run-time image from components of a software program\n\nAlso Published As\n\nPublication number Publication date EP0950950A2 (en) 1999-10-20 US20010000047A1 (en) 2001-03-15 CN1233010A (en) 1999-10-27 US6199196B1 (en) 2001-03-06 EP0950950A3 (en) 2007-03-07 JP2000029714A (en) 2000-01-28 CN1205537C (en) 2005-06-08\n\nSimilar Documents\n\nPublication Publication Date Title US6453467B2 (en) 2002-09-17 Methods and apparatus for linking a program for remote execution US6493870B1 (en) 2002-12-10 Methods and apparatus for packaging a program for remote execution EP1076290B1 (en) 2007-08-01 Method for on-demand network application download and execution US7213240B2 (en) 2007-05-01 Platform-independent selective ahead-of-time compilation US6877163B1 (en) 2005-04-05 Method and system for dynamic proxy classes US6584612B1 (en) 2003-06-24 Transparent loading of resources from read-only memory for an application program US6557100B1 (en) 2003-04-29 Fastpath redeployment of EJBs US6295643B1 (en) 2001-09-25 Method and apparatus for improving java virtual machine performance using persistent execution information US7210148B2 (en) 2007-04-24 Method and apparatus for dynamic distributed computing over a network US5842220A (en) 1998-11-24 Methods and apparatus for exposing members of an object class through class signature interfaces US6067577A (en) 2000-05-23 Dynamic method resolution for native methods in a dynamic object-oriented programming language US6754659B2 (en) 2004-06-22 Method for running existing java beans in an enterprise java bean environment US20050186625A1 (en) 2005-08-25 Process and system for sharing program fragments US20040073552A1 (en) 2004-04-15 Software mechanism for efficient compiling and loading of java server pages (JSPs) US6473768B1 (en) 2002-10-29 System and method for modifying an executing application WO2000010081A2 (en) 2000-02-24 Method and apparatus of translating and executing native code in a virtual machine environment US20040019887A1 (en) 2004-01-29 Method, system, and program for loading program components EP1057101A2 (en) 2000-12-06 Method and apparatus for dynamic distributed computing over a network WO2003060702A2 (en) 2003-07-24 Modified class loaders Riva et al. 1996 LispWeb: a specialized HTTP server for distributed AI applications US7343391B2 (en) 2008-03-11 System and method for interprocess services client artifact download WO2001097028A2 (en) 2001-12-20 Method and apparatus for rewriting bytecodes to minimize runtime checks Duthie et al. 2003 ASP. NET in a Nutshell: A Desktop Quick Reference Demurjian Sr et al. 0 The Java Programming Language/Environment and Risks/Benefits of Software Engineering with Java Toulemonde et al. 1999 Connecting Domino to the Enterprise Using Java\n\nLegal Events\n\nDate Code Title Description"
    }
}