{
    "id": "correct_subsidiary_00127_3",
    "rank": 43,
    "data": {
        "url": "https://patents.google.com/patent/EP0706684A1/en",
        "read_more_link": "",
        "language": "en",
        "title": "EP0706684A1 - System for object oriented dynamic linking based upon a catalog of registered function set or class identifiers - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1993-06-30T00:00:00",
        "summary": "",
        "meta_description": "A system is provided for managing code resources for use by client applications in a computer, wherein the computer has internal memory storing at least one client application. The apparatus comprises a resource set catalog stored in the internal memory. The resource set catalog identifies a plurality of function sets of functions by respective function set IDs. Further, the resource set catalog includes set records which characterize the functions within the respective sets. A dispatch engine, in the internal memory, linked with a client application, supplies a particular function set ID in response to a call by the client application of a particular function which is a member of a corresponding function set identified by the particular function set ID. A lookup engine in the internal memory, coupled with the resource set catalog and the dispatch engine, is responsive to the particular function set ID to look up a set record for a corresponding function set in the resource set catalog. Finally, a link engine in the internal memory and coupled with the dispatch engine returns the particular function to the client application in response to the set record. Thus, because the link engine is responsive to the set record, which is not linked with the client, the client need not be aware of changes in the structure of the library in which the particular function set resides. Thus, the function set can be moved into and out of internal memory, revised, placed in different sections of internal memory, and otherwise handled independently of the client, without requiring re-compilation of the client application.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/EP0706684A1/en",
        "text": "SYSTEM FOR OBJECT ORIENTED DYNAMIC LINKING\n\nBASED UPON A CATALOG OF REGISTERED FUNCTION SET\n\nOR CLASS IDENTIFIERS\n\nIJMITED COPYRIGHT WAIVER A portion of the disclosure of this patent document contains material to which the claim of copyright protection is made. The copyright owner has no objection to the facsimile reproduction by any person of the patent document or the patent disclosure, as it appears in the U.S. Patent and Trademark Office file or records, but reserves all other rights whatsoever.\n\nBACKGROUND OF THE INVENTION Field of the Invention\n\nThe present invention relates to dynamic linking of client applications with function sets or classes used by the client applications; and, more particularly, to systems for dynamically linking a client application at run time with libraries of function sets or classes registered either before or during execution of the client application.\n\nDescription of the Related Art Traditionally, an application's source files are compiled in object modules and then linked together with other object modules, genetically called libraries, to form a complete stand-alone application. This is called static linking. A disadvantage of static linking is that each application that links with the same library routine has its own private copy of the routine. Most of the size of the applications comes from the library code linked to each application. Another disadvantage of static linking is that the functionality that the application gets from the library is fixed. If the library has a bug in it, the application has to be reÂ¬ linked with the new library to get the bug fixed.\n\nDynamic linking, sometimes called late binding, differs because the application code and library code are not brought together until after the application is launched. If the code in the library is not loaded until it is actually required, then this is called dynamic loading.\n\nIf the same copy of library code being used by one application can be used by other applications at the same time, then the library is called a shared library. Dynamic linking of a class or function set involves binding code (\"client application\") which uses a class or function set to the code which implements the class or function set at run time. Thus, the term \"dynamic\" in this context, means \"occurring at run time\". Linking entails both loading the code and binding imported references to exported implementations of the classes or function sets. Existing dynamic linking systems do not provide class level or function set level dynamic linking. Instead, the linking is done at the level of the individual functions which may be exported by a library and imported by a client. However, each individual function must be exported by the library and each function used by the client must be imported in such prior art systems. To complicate matters, the name of the functions after compilation is not the name of the same in the source code (i.e., C+ +). Thus, the developer must deal with so-called \"mangled\" names to satisfy parameters of the dynamic linking systems of the prior art.\n\nAmong other limitations, prior individual function level binding systems cause the implementation of a client to be dependent on a particular set of classes known at build time. Thus, new derived classes cannot be added later without having to rebuild the client. Further, prior art dynamic linking systems do not provide for dynamic installation of the linking system itself. In some cases, after a new linking system is installed, the host system must be rebooted or at least the client application has to be restarted.\n\nExisting dynamic linking systems are designed to support procedural programming languages and do not provide object oriented dynamic linking. Since some object oriented languages are derivatives of procedural languages (e.g., C+ + is a derivative of C) these systems can sometimes provide dynamic linking of an object oriented language, provided the programmer deals with a class by the awkward approach of explicitly naming all members of the class. Nonetheless, these systems do not directly support object oriented programming languages.\n\nAccordingly, it is desirable to optimize a dynamic linking system to object oriented programming systems involving class level or function set level dynamic binding. Furthermore, such system should be robust, supporting efficient use of internal memory, and versioning of function sets or classes. Finally, it is desirable to provide for dynamic registration of updated or new libraries, so that a client application need not be restarted in order to take advantage of new versions of its libraries.\n\nSUMMARY OF THE INVENTION The present invention provides explicit support for object oriented languages, such as C+ + , MCL, and Dylan. This support includes linking by class or class identifier where a library exports a class and a client imports a class. The client has access to all of the public virtual and non- virtual member functions of such dynamically linked classes. Also, the client may instantiate an object of a class which was not known at compile time. In this case, the client can call public virtual member functions using a known interface of one of the parent classes of a class. The system of the present invention employs a dynamic function set catalog which can be queried directly or indirectly by the client. Since, ultimately, the implementation of a class is a set of functions, it is possible to dynamically link classes. The dynamic function set or class catalog is updated from a catalog resource when a library is registered and when a library is unregistered with the system. Each registered function set or class is given an identifier when registered.\n\nThe system is particularly suited to object oriented programming environments, where for a function set which characterizes a class; a direct catalog query by a client can determine for a given identifier, and the corresponding information in the catalog (1) whether the class is available, (2) the class IDs of its parent classes, (3) the class IDs of its derived classes, and (4) whether the class can be dynamically instantiated by a class ID. These functions enable clients to dynamically determine the availability and compatibility of classes, and enable new functionality to be delivered in the form of new shared class libraries and added to a client without recompiling the client. Since all code that implements a class can be dynamically linked, the client is not dependent on the implementation of the library code. A library can be fixed or enhanced without having to rebuild the client or other libraries. This simplifies the development and distribution of fixes and enhancements, and is generally better than existing patching mechanisms. Since other dynamic linking systems are not aware of classes as a distinct entity, the concept of class identification and class catalog management does not exist in these systems.\n\nAccordingly, the present invention can be characterized as a system for managing code resources for use by client applications in a computer, wherein the computer has internal memory storing at least one client application. The apparatus comprises a resource set catalog stored in the internal memory. The resource set catalog identifies a plurality of function sets by respective function set IDs. Further, the resource set catalog includes set records which characterize the implementation of functions within the respective sets.\n\nA dispatch engine, in the internal memory, linked with a client application, supplies a particular function set ID in response to a call by the client application of a particular function which is a member of a function set identified by the particular function set ID. A lookup engine in the internal memory, coupled with the resource set catalog and the dispatch engine, is responsive to the particular function set ID to look up a set record for a corresponding function set in the resource set catalog. Finally, a link engine in the internal memory and coupled with the dispatch engine returns the particular function to the client application in response to the set record. Thus, because the link engine is responsive to the set record, which is not linked with the client, the client need not be aware of changes in the structure of the library in which the particular function set resides. Thus, the function set can be moved into and out of internal memory, revised, placed in different sections of internal memory, and otherwise handled independently of the client, without requiring re-compilation of the client application.\n\nThe resource set catalog is characterized as containing set records for function sets, where a class for an object oriented system is a type of function set. Thus, where the term \"function set\" is used in the claims, it is intended that a species of function set may be a class.\n\nAccording to one aspect of the invention, the dispatch engine includes a dispatch record which is linked with the client, and stores a particular function set ID corresponding to a function set of which the called function is a member. Also, a dispatch routine is included in the dispatch engine, which is linked to the dispatch record and the lookup engine, and responsive to the call to the particular function to supply the particular function set ID to the lookup engine. In one preferred embodiment, the dispatch routine includes a first level dispatch segment linked to the client and to a global variable in the internal memory, and a second level dispatch segment linked to the global variable and the lookup engine.\n\nAccording to yet another aspect of the present invention, the dispatch record includes a function link cache and a set link cache. The function link cache stores a link to the particular function which is supplied by the link engine in response to the return of the particular function to the client. The dispatch engine includes a routine which looks at the function link cache for a cached link to the particular function and jumps to the particular function in response to the cached link if present.\n\nThe set link cache stores a link to the set record for the set of functions including the particular function which had been previously called by the client. The link engine includes a routine that supplies the link to the set link cache in response to return of a particular function to the client. The dispatch engine includes a routine which looks in the set link cache for a cached link to the set record, and returns the set record to the link engine in response to the cached link upon a call to a function which is a member of the function set. Thus, a function call can be executed quickly if the function link cache is full, with a medium level of speed if the set link cache is full, and more slowly if a catalog search is needed to bind the function implementation.\n\nThe invention further provides for assignment of version numbers to function sets according to a standard protocol. The dispatch record in this aspect includes version information linked with the client indicating a minimum version number supported by the client for the function set of which the particular function is a member. The set record includes a version number for the corresponding function set. The link engine in this aspect includes a routine which is responsive to the version information in the dispatch record and the version number in the set record to insure that the client supports a version of the particular function in the function set.\n\nIn addition, the function sets are assigned serial numbers when loaded in internal memory. The dispatch record further includes a serial number linked with the client indicating a serial number of the corresponding function set when the set link cache is filled. The set link cache stores a pointer to a link structure in internal memory and the link structure includes a pointer to the set record having the particular function set ID. The set record stores the assigned serial number for the function set when it is loaded in internal memory. The link engine includes a routine responsive to the serial number in the set record, and the serial number in the dispatch record to insure validity of the set link cache entry, and a routine for clearing the link structure when the corresponding function set is loaded.\n\nThe invention further provides for a use count record within the set record. The link engine in this aspect includes a routine to increment the use count when a client application binds with the function set corresponding to the set record, and to decrement the use count when a client application frees the function set corresponding to the set record. When the function set characterizes a class, the use count is incremented when a constructor for the class is called, and decremented when a destructor for the class is called. Thus, using the use count, the memory management system can unload function sets which are not in current use by any active applications. Since a client can enumerate all derived classes of a given class by class ID, it can determine what classes are available dynamically. The set of available classes can be extended at run time when new libraries are registered and a client can instantiate a class even though it is added to the system after the client was launched. New classes can be copied into a library directory or folder in the file system at any time and are automatically registered, or a new folder or file can be explicitly registered as a library container by a client.\n\nDynamic registration of libraries of function sets or classes is accomplished using the class catalog. Because the class catalog is not bound with clients, all that needs to be done to register a new library, is to write the appropriate records into the class catalog. Once the appropriate records are written into the class catalog, the new library becomes available to the new client. The procedures outlined above are in place to protect the client from using a version of a class or function set which it does not support, and for finding an unloaded and reloaded version of a particular function which it has already used.\n\nThe invention further provides for insuring type safety of the dynamically linked classes and function sets by means of shared library functions specifically designed to take advantage of the class catalog to insure such safety. The particular functions include the new object function, by which a client application may obtain information needed to construct a new object using the shared library manager, with reference to the class ID of the new object. Thus, using a class ID, the library manager looks up the information about the class in the class catalog, and returns a constructor for the class to the client. The client is then able to call the constructor, even if it did not know at the time it was written or compiled about the class.\n\nIn addition, the library manager provides a verify class routine, by which a client application may verify the parent of a particular derived class for type safety. Finally, a cast object routine is provided, by which a client may cast an instance of a particular object as a parent class object. This routine utilizes the class catalog to return offsets within the particular object to the elements of the parent, even though the client application may not have been aware of the structure of the parent at the time it was written or compiled.\n\nAccordingly, it can be seen that the present invention provides a dynamic class catalog which given a class ID can be queried to determine whether the class is available, the class IDs of the parent class or classes, the class ID or IDs of the derived class or classes, and whether the class can be dynamically instantiated by class ID. When an object is instantiated, the library or libraries which implement the class and its parent classes are dynamically loaded. An object can be instantiated by a client which had no knowledge at compile time of the class of the object. If such client was compiled with the interface of a parent class of the object, then the object can be used as if it were an instance of the parent class.\n\nThe system is particularly suited for object oriented dynamic linking which enables dynamic library registration, dynamic inheritance, and on-demand type- safe dynamic instantiation of objects by class identifier. Other aspects and advantages of the present invention can be seen upon review of the figures, the detailed description, and the claims which follow.\n\nBRIEF DESCRIPTION OF THE FIGURES Fig. 1 is a schematic diagram of a computer system implementing the shared library manager of the present invention.\n\nFig. 2 is a schematic diagram of the resource set catalog used according to the present invention.\n\nFig. 3 is a diagram of the data structures involved in the dynamic binding of the present invention. Figs. 4A-4C provide the \"C\" language definition of the stub record, client\n\nVTable record and class VTable records according to a preferred embodiment.\n\nFigs. 5 A and 5B provide a flowchart for the basic dispatching architecture used with the shared library manager of the present invention.\n\nFigs. 6A, 6B, and 6C provide a flowchart for the GET CLASS VTABLE RECORD step 112 of Fig. 5B. Fig. 7 is a schematic diagram of the library registration function, and organization.\n\nFig. 8 is a flowchart illustrating the operation of the dynamic registration routine using the structure of Fig. 7. Figs. 9A and 9B illustrate a new object routine executed by the shared library manager.\n\nFig. 10 illustrates a variant of the new object routine used when type safety is desired to be verified.\n\nFig. 11 is a flowchart for a verify class routine executed by the shared library manager.\n\nFig. 12 is a flowchart for a cast object routine executed by the shared library manager.\n\nDESCRIPTION OF THE PREFERRED EMBODIMENTS A detailed description of preferred embodiments of the present invention is provided with respect to the figures. Figs. 1-12 provide a high level overview of enabling various aspects of the present invention. A detailed description with references to segments of the source code follows a description of the figures.\n\nFig. 1 shows a computer system in which the present invention is loaded. The computer system includes a host CPU 10 which includes a plurality of registers 11 used during execution of programs. The CPU is coupled to a bus 12. The bus communicates with an input device 13 and a display 14 in the typical computer system. Further, non-volatile memory 15 is coupled to the bus 12. The non-volatile memory holds large volumes of data and programs, such as libraries, client applications, and the like. A high speed memory 16 is coupled to the bus 12 for both data and instructions. The high speed memory will store at least one client application 17, a shared library manager 18, shared library manager global variables at a predetermined address space within the memory 16, exported libraries 20, and other information as known in the art. According to the present invention, when a client application is compiled, a number of items are provided within the application. These items include a stub record, stub code, a library manager interface, a client VTable record, and a first level dispatch routine. The shared library manager will include a library builder routine, a resource set catalog, a second level dispatch routine, class VTable records for registered libraries, a lookup function, and a link function. As mentioned above, the resource set catalog provides information for function sets or classes which are available to a client. The stub record points to the client VTable record within the client. The first level dispatch routine uses information in the client VTable record to call the second level dispatch routine. The second level dispatch routine calls the lookup function to find information about the called function in the resource set catalog. That information is provided to a link engine in the form of a class VTable record which links the client to the particular function that it has called. A particular protocol for using these features of the client and the shared library manager are described below with reference to Figs. 5 and 6. The implementation of the resource set catalog, also called a class catalog herein, is shown in Fig. 2. A class catalog is a record 30 which includes a first field 31 which stores a number indicating the number of exported classes in all the library files which have been registered with the catalog 30. Next, the catalog includes an array 32 which stores class information records, one per exported class. The class information record in the array 32 consists of a structure 33 which includes a number of parameters. This structure includes a first field 34 named library which points to the library in charge of the code for the particular class or function set. A second field 35 stores a class serial number which is unique for each instance of the class; that is, it is incremented on registration of the class.\n\nA next field 36 stores a VTable record pointer which is the pointer to the VTable record for this class. A next field 37 stores a class ID, which is a class identifier for the class. A next record 38 stores the parent class ID. This is the class ID for a parent of this class. Next, a plurality of flags are stored in field 39 which are defined in more detail below. A next field 40 is a class link pointer. This points to a link structure for establishing a link with the client VTable record. Field 41 stores a version parameter indicating a version of the class implementation.\n\nThe class information record is loaded from a library resource having a structure described below with reference to Fig. 8. Fig. 3 schematically illustrates the records used for dynamically linking a function call in a client to a class or function set. The figure is divided generally along line 50. Where elements above line 50 are linked with the client during compile time, and elements below line 50 are linked with the shared library manager. Thus, the client includes a stub record 51 which provides a function link cache for a pointer to the implementation of the called function, and a pointer 52 to a client VTable record 53. The client VTable record stores the class identifier, for the class or function set, and a class link pointer providing a set link cache. The class link pointer 54 points to a link structure 55 which stores a pointer 56 to a class information record 57 in the class catalog. The class information record includes a pointer 58 to the class VTable record 59. The class VTable record includes a pointer 60 to the actual VTable of the class, and a pointer 61 to an export table for non-virtual functions.\n\nIf the class link pointer 54 is null, then a lookup function is called which accesses the class catalog 62 to look up the class information record 57 for the corresponding function. If that function is registered, then the class information record 57 is supplied, and the class VTable record 59 may be retrieved.\n\nThe figure also includes a schematic representation of a load engine 64. The load engine is coupled with the class information record 57. If the class corresponding to the class information record is not loaded at the time it is called, then the load engine 64 is invoked. When the information is moved out of longterm storage into the high speed internal memory, the class information record\n\n57 and class VTable record 59 are updated with the correct pointers and values.\n\nFigs. 4A, 4B, and 4C respectively illustrate the actual \"C\" definitions for the stub record, client VTable record, and class VTable record according to the preferred implementation of the present invention. Details of these structures are provided below in the description of a preferred embodiment. They are placed in these figures for ease of reference, and to illustrate certain features. It can be seen that the client VTable record (Fig. 4B) includes version information (fVersion, fMinVersion) which indicates a current version for the function set or class to which the class link pointer is linked, and the serial number (fClassSerialNumber) for the same. The class information record 57 of Fig. 3 also includes version information for the currently loaded class for a function set, and the serial number for the currently loaded class or function set. These fields are used for insuring version compatibility between the client and the currently loaded library, as well as validity of the link information. The class VTable record 59 (Fig. 4C) also includes a use count parameter\n\n(fUseCount). The use count parameter is incremented each time a class is constructed, and decremented each time a class is destructed. When the use count returns to zero, the class or function set is freed from internal memory.\n\nFigs. 5 A and 5B provide a flowchart for the basic implementation of the run time architecture. The algorithm begins by a client application calling a class constructor or a function by name (block 100). The stub code, generally outlined by dotted line 90, in the client with a matching name refers to the linked stub record (block 101). The stub code then tests whether the stub record includes the address for the constructor or function in its function link cache (block 102). If it does, then the stub code jumps to the address (block 103). This is the fastest way in which a function may be executed.\n\nIf the stub record did not include a valid cached address for the function, then the stub code calls a first level dispatch routine (block 104).\n\nThe first level dispatch routine is generally outlined by dotted line 91. The first step in this routine is to load a pointer to the library manager interface in the client in a host register (block 105). Next, the offset to the second level dispatch routine is read from the SLM global variables in internal memory (block 106). Next, the second level dispatch routine is jumped to based on the offset read in block 106 (block 107). The second level dispatch routine is generally outlined by dotted line 92.\n\nThe second level dispatch routine begins by pushing pointers for the client library manager interface and stub record onto the stack (block 108). Next, a lookup function is called for the class catalog (block 109).\n\nThe lookup function is generally outlined by dotted line 93. The first step in the lookup function is to take the stub record and library manager interface for the client (block 110). Using the information, the lookup function retrieves the class identifier for the named class or function set from the client VTable record (block 111). Next, the class VTable record (a set record) is retrieved based on the class ID (block 112). This step can be accomplished using the class link pointer for cached classes or function sets, or requires a lookup in the class catalog. Once the class VTable record is found, a link engine, generally outlined by dotted line 94, executes. The first step in the link engine is to get the function array pointer from the class VTable record (block 113). Next, the array is searched for the particular called function (block 114). Next, a pointer to the function is stored in the stub record for the client providing a function link cache value (block 115). Finally, the function pointer is returned to the second level dispatch routine (block\n\n116). The second level dispatch routine then cleans up the process and jumps to the function (block 117).\n\nFigs. 6 A, 6B, and 6C provide a flowchart for the step of block 112 in Fig. 5B, which returns a class VTable record in response to the class ID. Thus, the algorithm begins by taking the class ID as input (block 150).\n\nUsing the class ID, the class catalog object is called which first compares the class serial number in the client VTable record to a global start serial number maintained by the shared library manager. The shared library manager insures that all serial numbers of valid clients are at least greater than the global start serial number.\n\nIf this test succeeds, then the algorithm loops to block 152 where it is determined whether the class link pointer in the client VTable is null. If it is null, then the algorithm branches to block 161 in Fig. 6B. However, if the pointer is not null, then the class record is retrieved based on the information in the link pointer. After retrieving the TClass record, the class serial number in the client VTable is compared with the same in the TClass record. If they do not match, then the algorithm branches to block 161. If they do match, then the library record TLibrary for the class is retrieved from the information in TClass (block 155). The library record indicates whether the VTables for the class are initialized\n\n(block 156). If they are not, then the algorithm branches to block 162. If they are initialized, then the \"code\" serial number in the client VTable is compared with the same in the library record (block 157). If they do not match, then the algorithm branches to block 162. If the code serial numbers match, then the class VTable record is returned in response to the information in the TClass record (block 158).\n\nAfter retrieving the class VTable record, the class VTable record use count is incremented as well as the library use count (block 159). After block 159, the algorithm is done, as indicated in block 160. Fig. 6B illustrates the routine for handling the branches from blocks 152,\n\n154, 156, and 157. For branches from blocks 152 and 154, this routine begins with block 161 which calls a lookup class function to get the TClass record from the class catalog (block 161). After retrieving the TClass record, the class VTable record is retrieved in response to the information in TClass (block 162). Next, the class VTable record use count and library use count are incremented (block 163). The class VTable record is reviewed to determine whether it includes pointers to the VTable and the export table for the class (block 164). If there are pointers, then the algorithm is done (block 165). If not, then a set up function is called to initialize the class VTable record (block 166). The setup function is described in Fig. 6C. This algorithm begins with an access to the library record to determine whether the code is loaded (block 167). If the code is loaded, then the library use count is incremented (block 168). If the code is not loaded, then the library is loaded, and its use count incremented (block 169).\n\nAfter either block 168 or 169, the client VTable record is retrieved from the library, and the pointer to the class VTable record is retrieved (block 170). The pointer taken from the client VTable record in the library is used to get the class VTable record (block 171). Next, the cache links in the client VTable record in the client, and the same in the loaded library, and the cache links in the TClass record are updated with information about the class VTable record (block 172). Finally, the algorithm is done (block 173). Fig. 7 is a schematic diagram of the structure for the library's files which can be dynamically registered in the class catalog. The library files are normally stored on disk 200. These library files are registered in an extensions folder 201 which is graphically illustrated on the user interface of the device, such as the Macintoshâ¢ computer. The extension folder includes a number of management files 202, and a plurality of library files 203, 204, 205. The library files are all registered in the class catalog. The library files having a file type \"libr\" 206 include a number of segments, including code resources 207, a dictionary \"libr\" resource 208, and dictionary \"libi\" resource 209. The code resources 207 include the library code segments such as classes and generic function sets. The dictionary \"libr\" resource describes the library. Dictionary \"libi\" resource lists libraries which this library depends on. The dictionary \"libr\" resource 208 is shown in more detail at block 210. This resource includes a library ID field 211 which is the character string identifying the library. A second field 212 in the structure 210 identifies the code resource type. A third field 213 identifies the template version number for the library file. A fourth field 214 identifies the version number of the library, which is maintained according to a standard protocol by the developers of the libraries. The next field 215 stores a plurality of library flags. The next field 216 identifies the number of elements in an exported class information array 217. This information array 217 includes one record per exported class in the library. Each record includes a class identifier 218, class flags 219, a version number of the current version of the class 220, a minimum version number for the backward compatible version number for the class 221, a number 222 which indicates the number of elements in the following array 223 of parent class IDs. The array 223 of parent class IDs includes the identifier of each parent of the class. The information in this resource 210 is used to create the class information records for the class catalog upon registration of the library. Fig. 8 illustrates the basic algorithm for dynamically registering libraries using the structure of Fig. 7.\n\nAs indicated at block 300, the operating system designates a special folder, such as Extensions folder 201 in Fig. 7, and applications may designate additional folders for registered libraries.\n\nThe Library Manager intercepts operating system calls which indicate a file has been copied or moved. Then it is determined whether the file subject of the call is in the special folders or one of the additional folders (block 301).\n\nIf a new file is found, then it is determined whether the new file is a shared library resource. If it is, then library is registered in the class catalog by providing information to fill the TClass records for the classes in the class catalog (block 302). If a library has been moved out of the folder, then the library manager will leave it registered until it is no longer in use. After it is no longer in use, then it is moved out of the class catalog (block 303). The shared library manager also provides functions which are linked to the clients, and allow them to take advantage of the class catalog for various functions. Particular routines include a new object routine which is described with reference to Figs. 9A and 9B, a variant of the new object routine shown in Fig. 10, a verify object routine shown in Fig. 11, a cast object routine shown in Fig. 12, and a GetClassInfo routine shown in Fig. 13.\n\nAs indicated in Figs. 9A-9B, the new object routine takes as input the class identifier for the new object and an indication of a memory pool for allocation of the object (block 320). Using this information, it is determined whether the memory pool has actually been allocated for the object. If not, then the pool is allocated (block 321). Next, a lookup class function is called in the class catalog to get the TClass object for the identified class (block 322). Next, flags maintained in the TClass object indicate whether the new object routine is supported for the particular class (block 323). If it is supported, then it is determined whether the TClass record for the class is associated with a library other than the root library. If it is a root library class, then it is guaranteed to be always loaded, and the use content is incremented (block 324). If the class is associated with a library other than a root library, a load function is called to either load the library and then increment the use count, or if the library is already loaded then just increment the use count (block 325).\n\nNext, the TClass object is used to retrieve the class VTable record (block 326). Using the flags in the class VTable record, it is determined whether the new object routine is supported for the class (once again) (block 327).\n\nNext, the size of the object is determined from the class VTable record, and memory of that size is allocated to the pool (block 328). Next, a pointer to the allocated memory is retrieved (block 329). The library manager requires that the second slot in the export table for classes in the library contain a pointer to a constructor for the class. Thus, the pointer for the constructor is retrieved from the export table location indicated in the class VTable record (block 330). Using the constructor pointer, the constructor is called which places an object in the allocated memory (block 331). Next, the use count is decremented by one to balance the use count (block\n\n332). This is required because the load function step of block 325 increments the use count, as does the calling of a constructor in block 330. Thus, the decrementing of the use count is required for balancing the use counts. After the decrementing of use count in block 332, then the algorithm is done (block 333). Thus, a client is able to obtain and call a constructor for a class of which it was not aware at compile time.\n\nFig. 10 illustrates a variant of the new object routine which has better type safety. In particular, if the client is aware of the parent of the new object to be created, then the variant of Fig. 10 can be called. The variant of Fig. 10 takes as input the parent identifier for the parent of the class, the class ID of the new object to be created, and the memory pool allocation parameters (block 340). Next, a verify class function which is described with respect to Fig. 11 is called to insure that the identified class is derived from the identified parent (block 341). If this verification is successful, then the new object routine of Figs. 9A and 9B is called for the identified class (block 342) . (See Appendix, TLibraryManager: :NewObject (two variants)). Fig. 11 illustrates the verify class routine called in block 341 of Fig. 10. Also, this routine is available to the clients directly. The verify class routine begins by taking the class ID of the base class and of a derived class (block 350). Next, the lookup class function of the class catalog is called to get the TClass record for the derived class (block 351). The TClass record for the derived class will include a list of parent classes. This list is reviewed to determine whether the identified parent class is included (block 352). If the parent class is found, then the algorithm is done (block 353). If the parent class is not found, then go to the TClass record of each parent of the derived class in order. The list of parents for each parent is reviewed to find the identified parent class, following this recursion to the root class. The algorithm ends when the parent is found, or the root class is reached. (See Appendix TLibraryManager: :VerifyClass and :: internal VerifyClass).\n\nIf there is more than one immediate parent in the list of parents for the TClass record, then a case of multiple inherency is found. In this case, the parent class hierarchy must be reviewed to insure that at least one parent appears as a virtual base class (block 355). If the identified parent in the call of verify class is not found as a virtual base class, then it is determined not related to the derived class for the purposes of this function. Fig. 12 is a flowchart for a cast object routine executed by the shared library manager and linked to the clients by the required structure of the objects of the shared library manager environment. Using this function, a client can cast an object of a derived class as a parent class object, even though it may not have been aware of the structure of the parent at the time it was compiled. This algorithm takes as input a pointer to the object and an identifier of the parent class (block 400). Next, the class of the object is determined based on the required structure of the object (block 401). This structure involves placing the pointer to the VTable as the first data member in the object. Also, the first slot in the VTable is a pointer to the VTable record of the shared library manager. Using the class ID of the object determined from the class VTable record, and the parent ID provided when cast object was called, the verify class routine is then called (block 402). If the verify class succeeds, then it is determined from the class VTable record of the object, whether single or multiple inheritance is the case is found (block 403).\n\nIf a case of single inheritance, then the algorithm is done because the offsets are determinate in that case (block 404). If a case of multiple inheritance is encountered, then the correct offsets are found within the object to the data of the parent class (block 405). This can be determined based on the place of the parent class in the hierarchy of parent classes found in the TClass records. (See Appendix TLibraryManager: :CastObject and :: interact CastObject). GetClassInfo is a member function of TLibraryManager, or a non-member function is provided which calls gLibraryManager- > GetClassInfo for you. Given a class id which specifies a given base class and an error code pointer it returns a TClassInfo for the given class if the class is registered in the class catalog. The TClassInfo can then be used to iterate over all of the derived classes of the given base class. If the class is not registered or an error occurs GetClassInfo returns\n\nNULL. (See Appendix, TLibraryManager: : The GetClassInfo).\n\nThe GetClassInfo algorithm is shown in Fig. 13. It involves the following: Steps: 1. Call the LookupClass function with the class id. If this returns a pointer that is not NULL then we know that the class is registered with the class catalog. If it returns NULL then set the error code to kNotFound and return NULL for the function return value (block 500).\n\n2. Using the fClasses field of fClassCatalog, which is a TCollection class instance, call the Createlterator function. If the iterator cannot be created then return NULL for the function return value and set the error code to kOutOfMemory (block 501).\n\n3. Create a TClassInfo instance and set the flterator field to the iterator returned in step 2. Set the fBaseClassID field to the given class id. If the TClassInfo cannot be created then return NULL as the function return value and set the error code to kOutOfMemory (block 502). 4. Call the Reset function of the iterator to re-start the iteration. Return the TClassInfo as the function return value and set the error code to kNoError (block 503).\n\nThe functions of TClassInfo which include using the TClassInfo instance returned by GetClassInfo::\n\nvirtual void ResetO; virtual void* NextO; // safe to cast to TCIassID* or char'* virtual Boolean IterationCompleteO const;\n\n// TClassInfo methods TCIassID* GetClasslDO;\n\nBoolean GetClassNewObjectFlagO const;\n\nBoolean GetClassPreloadFlagO const; size t GetClassSizeO const;\n\nTLibrary* GetÏbraryO const;\n\nTLibraryFile* GetÏbraryFileO const; unsigned short GetVersionO const; unsigned short GetMinVersionO const;\n\nCopyright Apple Computer 1991 -1993 Data members of TClassInfo include:\n\nTCIassID fBaseClassID;\n\nTCIassID fClassID;\n\nTLibrary* fLibrary;\n\nTLibraryFile* fLibraryFile; unsigned short fVersion; unsigned short fMinVersion;\n\nBoolean fNewObjectFlag;\n\nBoolean fPreloadFlag;\n\nBoolean fFunctionSetFlag;\n\nBoolean fFiller; size_t fSize;\n\nTlterator* flterator;\n\nTClass* fClass;\n\nCopyright Apple Computer 1991 -1993\n\nReset - starts the iteration over from the beginning.\n\nNext - gets the next derived class in the list.\n\nIterationComplete - returns true if Next has been called for all derived classes of the given base class. GetClassID - returns the class id of a derived class (fClassID). GetClassNewObjectFlag - returns true if the class id returned by GetClassID can be used to create an object using the NewObject function. ' GetClassPreloadFlag - returns true if the class is preload flag is set to preload the class implementation at boot time.\n\nGetClassSize - returns the size of the data structure for an instance of the class. GetLibrary - returns the TLibrary for the class. GetLibraryFile - returns the TLibraryFile for the class. Get Version - returns the current version of the class. GetMin Version - returns the minimum compatible version of the class. The algorithm for TClassInfo includes the following steps.\n\n1. When the TClassInfo is created the fBaseClassID field is set to the class id passed to GetClassInfo, the flterator field is set to a class catalog iterator which iterates the TClass records registered in the class catalog, and f Class is set to the TClass for the class corresponding to fBaseClassID.\n\n2. The function Next sets the data members fClassID, fLibrary, fLibraryFile, fVersion, fMinVersion, fNewObjectFlag, fFunctionSetFlagandfSize. It gets this information from the next TClass record, using the flterator, which has the desired \"is derived from\" relationship of the class given by fBaseClassID. 3. The \"getter\" functions listed above return the information in the corresponding data member of Tlterator.\n\n4. The first time the getter functions are called, or after Reset is called, the information returned is for the fBaseClassID class itself.\n\nSource code for the cast object, verify class, new object and get class info routines is provided in the Appendix. Also, the Appendix provides selected class interfaces and functions which may be helpful in understanding a particular implementation of the present invention, when considered with the detailed description of the run-time architecture which follows.\n\nA more detailed description of a particular implementation of the shared library manager is provided below with reference to a code written for the Macintoshâ¢ computer. Overview\n\nThe Shared Library Manager (SLM) described herein provides dynamic linking and loading facilities for the 68K Macintosh. The system can be adapted to any platform desired by the user. SLM provides dynamic loading, a.k.a. on- demand loading, both for procedural programs and for C+ + programs. This is different from the traditional approach of launch-time loading, also referred to as \"full transitive closure\", which means that all required libraries are loaded and relocated at once when an application is launched.\n\nSLM provides procedural programming support for exporting and importing functions from C, Pascal, Assembler, or any language with compatible calling conventions. In addition, SLM provides extensive support for exporting and importing C+ + classes, with an emphasis on providing the dynamic features which are fundamental to building extensible applications and system components for Macintosh. Shared libraries can be installed at any time and called in a transparent fashion. There is no dependency when building a client on where the libraries that it uses are, what the filename(s) are, or how many of them may eventually be used during a session. The libraries are loaded and unloaded dynamically based on use counts. The SLM takes care of all of the details of binding and loading, and the client only has to know the interfaces to the classes and functions that it wants to use.\n\nSLM provides facilities for instantiating objects by class name, for enumerating a class hierarchy, and for verifying the class of an object or the class of a class.\n\nBasis of the architecture\n\nThe architecture for SLM is based on the 68K run-time architecture and the MPW tools architecture. A build tool, for the SLM takes an exports file (.exp) and an MPW object file (.o) as input and generates a library file. It does this by processing these files and then calling the MPW linker to finish the job. For C+ + libraries, SLM is based on the MPW/ AT&T 2.1 CFront v-table dispatching model. Development tools must generate v-tables compatible with this model. In particular, we assume that the first entry in the v-table is not used â SLM uses it to point to class \"meta-data\". SLM also requires the v-table pointer to be the first data member in an object in order for certain functions to work. Since these functions do not know the class of the object (their job is to find out the class) they can only find the class meta-data via the v-table pointer if it is in a known place in the object.\n\nIt is theoretically possible for SLM to support more than one dispatching model, however for interoperability it would not be desirable to have more than one model. A dispatching agent could arbitrate between different dispatching models or even different calling conventions which would introduce considerable run-time overhead. It would be possible for different dispatching models to coÂ¬ exist and yet not interoperate. SLM and 68K libraries support both single (SI, SingleObject rooted) and multiple inheritance (non-SingleObject rooted) classes.\n\nA development tool wishing to support the SLM in a non-MPW environment will need to generate a 'libr' resource, a set of code resources, and optionally, a 'libi' resource, a shown in Fig. 7. The jump table resource is not modified at build time â it is a normal model far jump table. It is modified by SLM at load time but the build tools don't need to be aware of this. The glue that does 32-bit relocation and the data initialization glue are code libraries statically linked into the library initialization segment.\n\nShared libraries have a jump table resource ('code' 0) plus an initialization code segment ('code' 1) plus at least one implementation segment ('code' 2 and up). If more than one library is in a library file then the resource type for each set of code resources must be unique (usually 'cdOl', 'cd02' etc.).\n\nLibrary resource - Specifies the type of the 'code' resources, and the classes and function sets exported by this library. Of course, the resource ID for each 'libr' resource in a file must be unique. Jump Table resource - Always present in the file, present in memory only if - SegUnload option is used to SLMBuilder. Note that NoSegUnload is the default.\n\nInitialization code segment resource - Only contains code linked to %A5Init or A5Init segment and used at initialization time, must not contain any other code unless -SegUnload option is used to SLMBuilder.\n\nImplementation code segment(s) - Contains any implementation code for the library, including the CleanupProc if any. Often libraries will have only one implementation segment although there is no harm in having more. Implementation segments are numbered 2 and up.\n\nWhen the SIM loads a library, the jump table resource is loaded, plus the initialization segment. After initialization this segment is released ~ it will not be needed again unless the library is unloaded and then reloaded. If the \"NoSegUnload\" option is used (NoSegUnload option to\n\nLibraryBuilder is the default) then all code segments are loaded. The jump table plus the relocation information generated for each segment is used to relocate the jump table based addresses in the code to absolute addresses pointing to the target function in the target code resource. The jump table resource is then released. When using this option the library should normally have only one implementation segment but this is not a requirement.\n\nIf the \"SegUnload\" option is used (SegUnload option to LibraryBuilder) then the implementation segment is loaded, plus any segments designated preload (preload resource bit can be set on a per-segment basis from a statement in the .r file), or all segments are loaded if a library itself is designated preload (preload flag in the Library descriptor). Each jump table based reference in the code is relocated to point to the absolute address of the jump table entry. The jump table is modified to contain pc-relative jsr instructions instead of segment loader traps. The jsr goes to the SLM segment loader entry point just before the jump table (in the 32 byte gap). This limits the size of the jump table to 32K, which should not be a problem since libraries should not be huge bodies of code â library files can easily have multiple libraries in them if packaging is an issue. It is a jsr and not a jmp since the segment loader uses the return address, which now points to the last two bytes of the jump table entry, to compute which segment is to be loaded. At load time the SLM moves the segment number information out of the jump table entry to an array following the jump table. This is due to the fact that the jsr pc relative takes 2 more bytes than the original segment loader trap. Note that all the machinations on the jump table are transparent to a tool developer.\n\nA segment is loaded when a jump table (jt) entry is called and the jump table is then modified to contain an absolute jump for all jt entries for that segment. When segments are unloaded, the pc relative jsr is put back in the jump table for each entry for that segment.\n\nThe data segment based addresses (the \"global world\", i.e. what would have been A5 based) are relocated to the absolute address of the data.\n\nBuilding a shared library\n\nAny application, extension, driver, or other stand-alone code resource on the Macintosh can use shared libraries. Of course, a client can also be another shared library. A shared library can import and export functions or classes. A non-library client (for brevity, an \"application\") can only import functions or classes. An application can sub-class an imported class, but it cannot export a class. This is a minor limitation since an application can contain shared libraries as resources in the application itself, or register a special folder containing shared libraries that are effectively part of the application.\n\nThe Shared Library Manager accomplishes it's sharing by examining and modifying the object file destined to become a shared library. It generates several source and resource files that are then used to create the shared library and to provide clients with linkable \"stubs\" to gain access to the functions and classes in the shared library. In the sections which follow, we will examine each of these files. Dispatching Architecture\n\nFirst and foremost of the files generated by the SIM LibraryBuilder tool is the file SharedLibTemp.stubs.a. This is an assembly language file that contains the stubs for all of the functions that are exported. Exported functions fall into five categories. They are: 1) function set function; 2) class constructor; 3) class destructor; 4) class virtual functions; and 5) class non-virtual functions. There is a separate dispatching function for each of these classifications, and the stubs are generated slightly different for each. Each one will be examined in detail shortly. For the purposes of explaining the architecture, an exported function in a function set will be used.\n\nFor each dispatching function, there are 5 parts. The first two parts are supplied by the build tool, and are unique for each function. The other 3 parts are supplied by the SIM.\n\nThe first part is a structure called a stub record (see Fig. 6). _stbSample RECORD EXPORT\n\nIMPORT _CVRExampleFSet:Data\n\nDC.L 0\n\nDC.L _CVRExampleFSet\n\nDC.L 0 DC.W 3\n\nENDR\n\nCopyright Apple Computer 1991 -1993\n\nThe stub record contains 2 fields used internally by the Shared Library Manager (the first and third fields in the example shown above). The second field is a pointer to the ClientVTableRec. The ClientVTableRec is a structure (see Fig. 6) that is linked with the application that has all of the information that the SIM needs to dynamically find and load the function set or class referenced by the stub. This is the \"C definition of the ClientVTableRec: struct ClientVTableRec\n\n{ TLin * fClassLinkPtr; long fClassSerialNumber; long fCodeSerialNumber; short fVersion; short fMinVersion; char fClasslDStr[2];\n\n}; Copyright Apple Computer 1991 -1993\n\nThe f ClassLinkPt r field contains information used by the SIM to cache the link to the internal TClass object which contains all of the information known about the class or function set. The two serial number fields are used to insure that the cached information is still valid (if the library unloaded and a new version of a class or function set in the library was dragged into a registered folder, any cached information is invalid). The version number fields contain information about the version number of the class or function set that your application (code resource, extension, etc.) linked with, and the f ClassIDStr field contains the actual ClassID of the class or function set so that it can be found in the SLM catalog.\n\nThe last field in the stub record is an index. It tells the SIM which entry in the function set VTable contains a pointer to the desired function.\n\nMost stub dispatching comes in 3 speeds - very fast, fast, and slow. Very fast dispatching occurs when you have already used the function before. In this case, the first field of the stub record contains the address of the actual function, and can be called immediately. If you have never called this function before, then a dispatching stub is called which causes the SLM to examine the ClientVTableRec. If you have already used another function in this same class or function set, then the ClientVTableRec already contains cached information as to the location of the tables containing the function addresses. In this case, your stub is updated so that the address of the function is cached for next time, and the function is then called. If the ClientVTableRec does not contain cached information, then the SIM must look up the class or function set by the ClassID stored in the ClientVTableRec, load the library containing the class or function set if it is not already loaded, update the cached information in the ClientVTableRec, update the cached information in the stub, and then finally call the function. The second part of the dispatching mechanism is the actual stub code that a client links with:\n\nSample PROC EXPORT\n\nIMPORT _stbSample:Data IF MODEL = O THEN lea stbSample,aO ; Get the stub record into aO\n\nELSE lea ( stbSample).L,aO\n\nENDIF move. I (aO),dO ; Get the cached function address beq.s @1 ; Not cached - do it the hard way move. I dO.aO ; Get address into aO jmp (aO) ; and jump to it\n\nIMPORT _SLM1 1 FuncDispatch @1\n\nIF MODEL = 0 THEN jmp SLM 1 1 FuncDispatch ; More extensive dispatching needed\n\nELSE jmp ( SLM 1 1 FuncDispatch) .L END\n\nIF MACSBUG = 1 THEN rts\n\nDC.B $80, $06\n\nDC.B Sample DC.W O ENDIF ENDP\n\nCopyright Apple Computer 1991 -1993\n\nNormally two (or maybe four) versions of the stub are assembled - one in model near (MODEL = 0), and one in model far (MODEL = 1). There may also be debugging versions generated with Macsbug symbols for each (MACSBUG\n\n= 1). Notice that the first thing that the stub does is to check whether the first field of the stub record is non-zero. If it is, it just jumps through the pointer stored there. Otherwise, it calls a first level dispatching function called SLM11 FuncDispatch (or one of the other 4 variations of this function).\n\nThis function is the third part of the dispatching code: _SLM1 1 FuncDispatch PROC Export move.l $2B6,a1 move. I $10C(a1 ),a1 move.l SLMGIobal.fStubHelp + 16(a1 ),a1\n\nIF MODEL = 0 THEN move.l gLibraryManager,dO\n\nELSE move.l ( gLibraryManager). L,dO\n\nENDIF jmp (a1 )\n\nENDP\n\nCopyright Apple Computer 1 991 -1993\n\nThe first two instructions fetch the SIM globals. The SIM stores it's global information in a low-memory structure known as the ExpandMemRec (location $2B6 in the Macintosh contains a pointer to this structure). The SIM global information is stores as a pointer at offset $ IOC in this structure. One of the fields in this structure contains a vector of dispatch functions. This dispatcher uses the 5th element in the vector to dispatch through (this is the vector to dispatch functions in function sets).\n\nThe code for this dispatching function (and the other four variations) are supplied in LibraryManager . o and LibraryManager . n . o, so clients can link with it. The fourth part of stub dispatch is the second level dispatching function that is stored in this vector:\n\nSLMFuncDispatch PROC Export move.l dO,-(sp) ; Push the library manager move.l aO,-(sp) ; Push the stub record move.l dO,aO ; Put TLibraryManager into aO move.l 20{a0),a0 ; Get the class catalog move.l a0,-(sp) move.l (aO),aO move.l CatVTable.LookupFunction(aO),aO jsr (aO) ; Call the LookupFunction method lea 12(sp),sp ; Drop parameters move.l d0,a0 ; Get the function jmp (aO) ; Call it Copyright Apple Computer 1991 -1993\n\nThis dispatcher calls a function in the TClassCatalog object, which is the fifth and final part of stub dispatch. A partial declaration for TClassCatalog follows. #define kTCIassCatalogID \"!$ccat,1.1 \" typedef ClientVTableRec CVR; typedef FunctionStubRec FSR; typedef void (*VF)(void); typedef VTable VF[]; class TClassCatalog : public TDynamic\n\n{\n\nTClassCatalog!); virtual -TClassCatalog!);\n\n//\n\n// These first functions are here for backward compatibility with\n\n// SLM 1 .0\n\n//\n\n#if COMPAT10 virtual VR ExecDestructor(CVR*) const; virtual VR ExecConstructor(CVR*, size t idx) const; virtual VR ExecVTableEntrylCVR*, size_t idx) const; virtual VR ExecExportEntry(CVR*, size t idx) const; virtual void ExecFunctionlFSR*, TLibraryManager*) const; virtual VR ExecRootDestructor(CVR*) const; virtual VR ExecRootConstructor(CVR*, size_t idx) const; virtual VR ExecRootVTableEntrylCVR*, size t idx) const; virtual VR ExecRootExportEntrylCVR*, size t idx) const;\n\n#endif virtual VF LookupFunction{FSR*, TLibraryManager*); virtual VTableRec* GetVTableRecMemoryfsize t num) const; virtual VTableRec* Initl VTableRec( VTableRec*, ProcPtr setupProc,\n\nCVR* client) const; virtual VTableRec* InitVTableReclVTableRec*, VTable vTable,\n\nVTable exportTable, CVR* parent, long size, char*) const; virtual VTableRec* InitVTableReclVTableRec*, VTable exportTable, char*) const;\n\n#if COMPAT10 virtual VTableRec* GetGenVTableReclCVR*) const; #endif virtual VTableRec* LookupVTableRec(CVR* theClient) const; virtual VTableRec* GetVTableReclCVR*, Boolean isSub) const; virtual VTableRec* ReleaseVTableReclCVR*) const; virtual OSErr InitLibraryManagerlTLibraryManager**, long*, size_t poolsize, ZoneType theZone, MemoryType theMemType); virtual Boolean CleanupLibraryManagerlTLibraryManager**); virtual VF GetDestructorlFSR*, TLibraryManager*) const; virtual VF GetConstructorlFSR*, TLibraryManager*, Boolean isSub) const; virtual VF GetVTableEntry(FSR*, TLibraryManager*) const; virtual VF GetExportEntrylFSR*, TLibraryManager*) const; virtual VTableRec* GetParentVTableReclCVR*) const; };\n\nCopyright Apple Computer 1991 -1 993\n\nThere are five routines in the TClassCatalog, corresponding to each of the five dispatch methods. They are: 1) LookupFunction; 2) GetConstructor; 3) GetDestructor; 4) GetVTableEntry; and 5) GetExportEntry.\n\nIt is not necessary that any generated code know vtable offsets into the class catalog. These offsets are known by the vectorized dispatch code. In fact, the dispatch code was vectorized specifically so that offsets in the TClassCatalog could change without causing recompilation of clients.\n\nThis fifth and final dispatch routine does the actual finding of the class, and storing of any cached values.\n\nIn the code examples that follow, code and structures that have a bold header and trailer is code that must be generated by a build tool in order to create a shared library. Code that is not in bold is shown only for reference.\n\nGenerating Function Set Code\n\nTo import a function a client has to include the interface file when compiling (in C, the .h file), and link with client object file (.cl.o or .cl.n.o) provided by the library developer. The client object file contains the client stubs for the functions that the client calls.\n\nConsider the following example function set which is exported by the ExampleLibrary . This is the FunctionSet declaration in the exports file\n\n(ExampleLibrary . exp) :\n\nFunctionSet ExampleFSet\n\n{ id = kExampleFunctionSet; /\n\n/ We could use the following export line, but we want all exported\n\n/ functions from the library to be exported, so we say nothing!\n\n7\n\n/ exports = Hello, extern HelloC, pascal extern HelloPascal, Goodbye,\n\n/ pascal GoodbyePascal, TExampleClass::Test;\n\n};\n\nCopyright Apple Computer 1991 -1993\n\nThese are the prototypes from the interface file (ExampleLibrary. h): char* Hello(ulong&); char* Hellolulong*); extern \"C\" char* HelloClulong*); ulong Goodbye!); pascal Ptr HelloPascal(ulong& theHelloTicks); pascal ulong GoodbyePascal!);\n\nCopyright Apple Computer 1991 -1993\n\nFunction set function dispatching (stubs)\n\nThe build tool, LibraryBuilder, generates stubs to be linked with the client for each FunctionSet function exported by a given library.\n\n0 A stub is generated for each function. Here is the stub record and the stub that is generated for the \"HelloC \" function (in\n\nSharedLibTemp . stubs . a):\n\nHelloC\n\n@1 IF MODEL = O THEN jmp SLM 1 1 FuncDispatch\n\nELSE jmp ( SLM1 1 FuncDispatch). L END\n\nIF MACSBUG = 1 THEN rts\n\nDC.B $80, $0B\n\nDC.B 'stub_HelloC DC.W 0\n\nENDIF\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nThis is the structure of the stub record in C: struct FunctionStubRec\n\n{\n\nVirtualFunction fFunction; ClientVTableRec* f ClientVTableRec;\n\nFunctionStubRec* fNextStubRec; unsigned short fFunctionID;\n\n> Copyright Apple Computer 1991 -1993\n\nWhen the stub is called, it first checks to see if the address of the function is already cached. If so, it jumps immediately to the function. Otherwise, it jumps to the function dispatcher (_SLMllFuncDispatch) with the stub record as a parameter in register A0. The stub dispatcher then obtains the address of the actual dispatching code from a low-memory global set up when SLM was originally loaded, and it jumps to that code. This extra indirection allows SIM the flexibility to modify the function loading and dispatching mechanism without affecting client code (since clients are linked with the SLM 11 FuncDispatch code).\n\n0 This is the function dispatcher that is linked with the client.\n\n_SLM1 1 FuncDispatch PROC Export move.l $2B6,a1 move.l $10C(a1 ),a1 move.l SLMGIobal.fStubHelp + 16(a1 ),a1\n\nIF MODEL = 0 THEN move.l gLibraryManager,d0\n\nELSE move.l I gLibraryManager). L,d0 ENDIF jmp (a1 )\n\nENDP\n\nCopyright Apple Computer 1 991 -1993\n\n0 This is the actual function dispatcher that is linked with the Shared Library Manager for reference: _SLMFuncDispatch PROC Export\n\nCopyright Apple Computer 1991 -1993\n\nThe CatVTable . LookupFunction is a call to the\n\nTClassCatalog : : LookupFunction method.\n\nÂ° A ClientVTableRec is generated per function set (to be linked with the client in SharedLibTemp . stubs . a):\n\n_CVRExampleFSet RECORD EXPORT DC.L 0, 0, 0\n\nDC.W $0100 DC.W $0000\n\nDC.B 'appl:exam$ExampleFSet', 0 ENDR\n\nCopyright Apple Computer 1991 -1993\n\nThe initialization code is generated in two files: SharedLibTemp . init . a and SharedLibTemp . init . c. Most of the generated code is in \"C, but for each class or function set, a\n\nClientVTableRec is generated which is put into the assembly file. It is possible to put the ClientVTableRec definition in \"C (the inline \"C-string makes it a little more challenging, but it can be done), but we chose to leave it in assembly. Strictly speaking, if your initialization code is going to link with your stub library, a ClientVTableRec does not need to be generated for initialization, but it makes things easier just to generate one as a matter of course. Â° The vector table is generated into SharedLibTemp.Init.c (to be linked with the library): typedef void (*ProcPtr)(void);\n\nProcPtr _vtbl_ExampleFSet[] = {\n\n0, // First entry is normally 0\n\n(ProcPtr)Hello_FRUI,\n\n(ProcPtr)Hello_FPUI,\n\n(ProcPtr)HelloC, (ProcPtr)HELLOPASCAL,\n\n(ProcPtr)Goodbye_Fv,\n\n(ProcPtr)GOODBYEPASCAL,\n\n(ProcPtr)Test_13TExampleClassSFUI,\n\n(ProcPtr)Test 13TExampleClassSFPc, 0,\n\n}\n\nCopyright Apple Computer 1991 -1993\n\nThe SLM allows functions to be exported by name, as well. If any functions are exported by name, one more structure is created. Assuming that the\n\nHelloC routine and the GOODBYEPASCAL routine were to be exported by name, the following extra code would be generated: static char _Str_Sample_2I] = \"HelloC\"; static char _Str_Sample_2[] = \"GOODBYPASCAL\"; char* SampleNameStrucl] =\n\n{\n\n(char*)-1 L, |char*)-1 L, _Str_Sample_1 ,\n\n<char*)-1 L, _Str_Sample_2, 0\n\n};\n\nCopyright Apple Computer 1991 -1993 Any slot corresponding to a function that is not exported by name is filled with a (char*)-lL. A slot with a NULL (0) pointer terminates the list of names. A pointer to this list of names is stored in the first entry of the vector table:\n\nProcPtr _vtbl_ExampleFSetll = {\n\n(ProcPtr)SampleNameStruc,\n\n(ProcPtr)Hello_FRUI,\n\n(ProcPtr)Hello_FPUI,\n\n(ProcPtr)HelloC, (ProcPtr)HELLOPASCAL,\n\n(ProcPtr)Goodbye Fv,\n\n(ProcPtr)GOODBYEPASCAL,\n\n(ProcPtr)Test_13TExampleClassSFUI,\n\n(ProcPtr)Test_13TExampleCiassSFPc, 0,\n\n}â â\n\nCopyright Apple Computer 1991 -1993\n\nÂ° An initialization function is generated for each function set.\n\nFirst, let's show you the header generated for the initialization file (generated in SharedLibTe p . ini t . c):\n\n} ClientVTableRec; void Failliong err, const char* msg); extern void** gLibraryManager; // A convenient lie! extern void pure_virtual_called|void); typedef void (*ProcPtr)(void); typedef struct mptr { short o; short i; ProcPtr func; } mptr; typedef ProcPtr* VTable; typedef void (*SetupProc)(void*, unsigned int); typedef void* (*lnit1 VTableRec) (void*, void*, SetupProc, ClientVTableRec*); typedef void* (*lnitVTableRec)(void*, void*, VTable, VTable, ClientVTableRec*, unsigned int, char*); typedef void* (*GetVTableRec)(void*, ClientVTableRec*, unsigned char); typedef void* (*ReleaseVTableRec)(void\\ ClientVTableRec*); typedef void* (*lnitExportSet)(void*, void*, VTable, char*); typedef void* (*GetVTableMemory)(void*, unsigned int); #define GetClassCatalog ( gLibraryManager[51)\n\nCopyright Apple Computer 1991 -1993\n\nNow the SVR (SVR stands for Setup VTableRec) function (generated in\n\nSharedLibTemp . init . c): #pragma segment AÎ´lnit void SVRExampleFSetlvoid* vtRec, unsigned int vtRecSize) { register ProcPtr toCall; void* * catalog = GetClassCatalog; // Get Class Catalog void* * ctVTable = 'catalog; // Get it's VTable\n\n// // Get pointer to 22nd entry, which is InitExportSet\n\n// function\n\n// toCall = (ProcPtr)ctVTable[221;\n\n// // Call it with the following parameters:\n\n// 1 ) The pointer to the class catalog\n\n// 2) The vtable record pointer passed in to your function\n\n// 3) A pointer to the vtable we created for the function set.\n\n// 4) A zero for future expansion //\n\n(*(lnitExportSet)toCall)(catalog, vtRec, vtbl_ExampleFSet, 0);\n\n}\n\nCopyright Apple Computer 1991 -1993\n\nThe first parameter to the SVR function is known as the VTableRec. This is the definition of the VTableRec structure. This information is for reference only. struct VTableRec\n\n{\n\nVTable fVTablePtr;\n\nVTable fExportTable;\n\nTUseCount fUseCount; // \"long\" in size void* fReserved; ,\n\nClientVTableRec * fParentClientPtr; unsigned short fSize; unsigned fParentlsVirtual: 1 ; unsigned f Filler: 1 ; unsigned fCanNewObject:1 ; unsigned flsFunctionSet:1 ; unsigned flsRootClass:1 ; unsigned fLocalCVRIsParent:1 ; unsigned flsParentVTable:! ; unsigned flsMasterOrLast:1 ; unsigned char fDispatcher;\n\nClientVTableRec* fLocalClientPtr; union\n\n{\n\nSetupProc fSetup;\n\nTRegisteredObjects * f RegisteredObjects;\n\n};\n\n};\n\nCopyright Apple Computer 1991 -1993\n\nThe VTableRec is used internally by the SLM to keep track of information about each function set or class. Library initialization code supplies all of the information the SIM needs to fill in the VTableRec.\n\n0 One initialization function per library is generated which calls the SLM to register all of the ClieÎ·tVTableRecs and SVR functions. This example shows initialization for the example library, which has the function set ExampleFSet and the class TExampleClass. Those parts of this code that you would change depending on what you are initializing are underlined. #pragma segment A5lnit void* InitVTableRecords(void)\n\n{ register ProcPtr toCall; void* vtRec; void* savedRec; void** catalog = GetClassCatalog; // Get Class Catalog void** ctVTable = 'catalog; // Get it's VTable //\n\n// Get the pointer to GetVTableMemory, and call it, asking\n\n// for memory for 2 VTableRecs (Of course, you would ask for\n\n// the number of VTableRecs that you need).\n\n// toCall = (ProcPtr)ctVTable[19l; savedRec = (*(GetVTableMemory)toCall) (catalog, _2);\n\n//\n\n// Get the pointer to the Initl VTableRec method\n\n// toCall = (ProcPtr)ctVTable[201;\n\n//\n\n// Start 'vtRec' pointing to the memory that we got.\n\n// vtRec = savedRec; //\n\n// Call Initl VTableRec for our first export (a Class, in this\n\n// case). Parameters are: // 1 ) The class catalog\n\n// 2) The VTableRec Memory\n\n// 3) A pointer to the \"SetupVTableRec\" procedure\n\n// 4) A pointer to the local \"ClientVTableRec\" // The method will return a pointer to the next VTableRec\n\n// for use with additional initialization. Using this method,\n\n// it is not required for you to \"know\" the size of a VTableRec\n\n// vtRec = (*(lnit1 VTableRec)toCall)(cataloÎ±. vtRec, _SVRTExampleClass.\n\n&_ CVRTExampleClass):\n\n//\n\n// Do it for the next export (a function set, in this example)\n\n// vtRec = (*(lnit1 VTableRec)toCall)(cataloÎ±, vtRec, SVRExampleFSet.\n\n&_ CVRExampleFSet):\n\n//\n\n// Return a pointer to the original VTableRec\n\n// return savedRec;\n\n}\n\nCopyright Apple Computer 1991 -1993\n\nSingly-Inherited Classes (stubs)\n\nThis section will examine the stub creation for a C+ + class which is singly-inherited. This includes both forms of vtables - SingleObject derived, and standard AT&T v2.1 classes. Classes which are multiply-inherited (derive from more than 1 parent class) are handled in a separate section. Here is the definition of the TExampleClass (from ExampleClass . h)\n\n#define kTExampleClassID \"appl:exam$TExampleClass,1 .1 \" class TExampleClass : public TDynamic\n\n{ public:\n\nTExampleClass!); virtual -TExampleClassO;\n\n// New Methods virtual char* GetObjectName!) const; virtual void SetObjectName(char *theName); virtual void DoThisAndThatO; virtual void DoThat!); *~~. virtual void SetGloballntdong theValue); virtual long GetGloballntO; // Public non-virtual function\n\n// Dynamically exported by using ExportFunction void GetGlobalRef(long*&);\n\n// Public static function\n\n// Dynamically exported by the ExportFunction static Boolean Test(ulong test); static Boolean Testfchar* test); private: char *fName;\n\n// static gExampleClassCount counts the number of instances static long gExampleClassCount; };\n\nCopyright Apple Computer 1991 -1993\n\nConstructor stubs Constructor stubs are generated for each constructor of a class. If the export file specifies that no constructor stubs are to be exported (using the no ethodStubs or noStubs flag), then the constructor stubs must be created in the assembly language portion (SharedLibTemp . init . a) of the initialization file. This is so that use counts can be properly maintained for every class.\n\n0 A stub record is generated to be linked with both the client and the library (in SharedLibTemp . stubs . a or SharedLibTemp . init . a, as appropriate). This record is used much like the record for a function set - It contains cached information that is used to speed up the dispatching. In addition, it contains the index into the \"structor table\" for the actual address of the constructor (see the class initialization section for information on creating this table).\n\n_stb_ct_13TExampleClassFv RECORD EXPORT\n\nIMPORT _CVRTExampleClass:Data DC.L 0\n\nDC.L __CVRTExampleClass ; ClientVTableRec\n\nDC.L 0\n\nDC.W 3 ; Index into table\n\nENDR\n\nCopyright Apple Computer 1991 -1993 0 A constructor stub is generated to be linked with both the client and the library (in SharedLibTemp . stubs , a or SharedLibTemp . init . a , as appropriate):\n\n_ct_13TExampleClassFv PROC EXPORT\n\nIMPORT _stb_ct_13TExampleClassFv:Data\n\nIF MODEL = 0\n\nLEA stb ct 13TExampleClassFv,a0 ELSE\n\nLEA ( stb ct 13TExampleClassFv).L,a0 ENDIF\n\nIMPORT SLM1 1 ConstructorDispatch IF MODEL = 0\n\nJMP SLM1 1 ConstructorDispatch ELSE\n\nJMP (_SLM1 1 ConstructorDispatch). L ENDIF IF MACSBUG = 1 THEN rts\n\nDC.B $80, $1 C\n\nDC.B 'stub ct__13TExampleClassFv'\n\nDC.B 0\n\nDC.W 0\n\nENDIF\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nNotice that the constructor does not use any cached information to jump to the constructor directly. This is so that use counts may be updated (see the next bullet point).\n\nÂ° This is the constructor function dispatcher that is linked with the client. This is for reference only â the client should link with the version supplied by SLM.\n\nSLM 1 1 ConstructorDispatch PROC Export WITH FunctionStubRec tst.l (aO) Constructor pointer cached? beq.s @2 No - do it the hard way move.l clientCVR(aO),a1 Get the ClientVTableRec move.l (a1 ),a1 Get the ClassLinkPtr move.l 4(a1 ),a1 Get the TClass move.l TCIass.vtRec(a1 ),a1 Get the VTableRec pointer addq.l #1 ,VTRec.useCount(a1 ) Increment the use count beq.s @1 Have to do the library count? move.l (a0),a0 No - go on jmp (aO) Jump to the constructor Here, we have to bump the libraries use count - so we call the SLMConstructorDispatch function - but first, we have to back off the VTableRec use count we just incremented\n\n@1 subq.l #1 ,VTRec.useCount(a1 ) ; Back off the VTableRec use count @2 move.l $2B6,a1 move.l $10C(a1 ),a1 move.l SLMGIobal.fStubHelp + 4(a1 ),a1 IF MODEL = 0 THEN move.l gLibraryManager,dO\n\nELSE move.l ( gLibraryManager). L,d0\n\nENDIF jmp (a1 )\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nUnder normal circumstances, the bumping the use count of the VTableRec is all that is required, so dispatching is moderately fast. The only time that the more general dispatching mechanism needs to be invoked is if the constructor has never been invoked by the current client before, and there are no outstanding instances of this class among all clients of the SIM.\n\nOf course, if your compiler has a different naming convention for constructors, you must generate stubs that have the same name as the ones generated (See the initialization section for more information).\n\nÂ° This is the actual constructor function dispatcher that is linked with the\n\nShared Library Manager. This is for reference only:\n\nSLMConstructorDispatch PROC Export move.l d0,a1 ; Save the library manager in a1 moveq #1 ,d0\n\nWe test the \"this\" pointer to see if it's NULL. If it is, then the object is being \"newed\", so we set dO to 0, to tell the SLM that we are fetching a primary object, and not a subclass. This allows the SLM a little more latitude in version matching.\n\n; Check the \"this\" pointer\n\nPush the \"isSubClass\" flag Push the library manager\n\nCopyright Apple Computer 1991 -1993\n\nThe CatVTable . GetConstructor is a call to the TClassCatalog : : GetConstructor method.\n\nDestructor stubs\n\nDestructor stubs are generated for the destructor of an exported class. If the export file specifies that the destructor stub are not to be exported (using the noMet hodS tubs or noStubs flag), then the destructor stub must be created in the assembly language portion (SharedLibTemp . Init . a) of the initialization file. This is so that use counts can be properly maintained for every class.\n\n0 The destructor stub is generated to be linked with both client and library\n\n(in SharedLibTemp . stubs , a or SharedLibTemp . init . a, as appropriate). Note that the stub record for a destructor is slightly smaller than one for a constructor or a normal function. This is because we do not need to store the index to the destructor in that table - it is always two (see the class initialization section for more information).\n\n_stb_dt_13TExampleClassFv RECORD EXPORT IMPORT _CVRTExampleClass:Data\n\nDC.L 0\n\nDC.L _CVRTExampleClass ; Client VTable Rec\n\nDC.L 0\n\nENDR\n\n_dt_13TExampleClassFv PROC EXPORT\n\nIMPORT _stb_dt_13TExampleClassFv:Data IF MODEL = 0 LEA _stb_dt_13TExampleClassFv,aO\n\nELSE 13TExampleClassFv).L,aO estructorDispatch estructorDispatch\n\n13TExampleClassFv'\n\nCopyright Apple Computer 1991 -1993\n\nNotice that the destructor does not use any cached information to jump to the destructor directly. This is so that use counts may be updated (see the next bullet point).\n\nÂ° This is the destructor function dispatcher that is linked with the client. This is for reference only â the client should link with the version supplied by SLM. The DestStub record looks just like a function stub record, except that it is one short shorter (it does not need the funcID field, it is known to be two (2)).\n\nSLM 1 1 DestructorDispatch PROC Export WITH DestStub tst.l (aO) Destructor pointer cached? beq.s @2 No - do it the hard way move.l clientCVR(aO),a1 Get the ClientVTableRec move.l (a1 ),a1 Get the ClassLinkPtr move.l 4(a1 ),a1 Get the TClass move.l TCIass.vtRec(a1 ),a1 Get the VTableRec pointer subq.l #1 ,VTRec.useCount(a1 ) Decrement the use count bmi.s @1 Have to do the library count? move.l (aO),aO No - go on jmp (aO) Jump to the destructor\n\nHere, we have to bump the libraries use count - so we call the SLM DestructorDispatch function - but first, we have to back off the VTableRec use count we just incremented\n\n@1 addq.l #1 ,VTRec.useCount(a1 ) Back off the VTableRec use count @2 move.l $2B6,a1 move.l $ 10C(a1 ),a1 move.l SLMGIobal.fStubHelp(a1 ),a1 IF MODEL = 0 THEN move.l gLibraryManager.dO\n\nELSE move.l ( gLibraryManager). L,d0\n\nENDIF jmp (a1 )\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nUnder normal circumstances, the decrementing of the use count of the VTableRec is all that is required, so dispatching is moderately fast. The only time that the more general dispatching mechanism needs to be invoked is if the destructor has never been invoked by the current client before, and we are destroying the last outstanding instance of this class among all clients of the SIM.\n\nÂ° This is the actual destructor function dispatcher that is linked with the Shared Library Manager. This function is the most complex of the dispatching functions. This is because calling the destructor of an object can cause a library to unload. Unloading only occurs when SystemTask is called. However, if the destructor were to call SystemTask, this might be highly embarrassing, so we go to some lengths to insure that the library cannot be unloaded until we return from the destructor. This is for reference only:\n\nSLM DestructorDispatch PROC Export\n\nWITH SLMGIobal move.l d0,-(sp) Push the library manager move.l aO,-(sp) Push the stub record move.l d0,a0 Put TLibraryManager into aO move.l 20(a0),a0 Get the class catalog move.l aO,-(sp) Push it move.l (aO),aO Get the destructor move.l CatVTable.GetDestructor(aO),aO jsr (aO) ; Call class catalog lea 12(sp),sp ; Drop parameters\n\nHere, we're being possibly being unloaded at the next System Task. Just in case the destructor calls SystemTask, we disable code unloading until the destructor is finished running. We shift the stack down by 4 bytes so that we can save a return address, and get returned to ourselves by the destructor\n\nGetSLMGIobal addq.l #1 ,fNoSystemTask(aO) Keep system task from unloading move.l (sp),d1 Save return address move.l 4(sp),(sp) Shift Parm 1 move.l 8(sp),4(sp) Shift Parm 2 move.l d1 ,8(sp) Save original return address move.l dO,aO jsr (aO) Call the destructor\n\nGetSLMGIobal subq.l #1 ,fNoSystemTask(aO) Let system task unload now move.l 8(sp),a0 Recover return address move.l 4(sp),8(sp) Put parms back where they belong move.l (sp),4(sp) addq.l #4,sp Drop return address slot jmp (aO) And return to caller\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nThe CatVTabl e . GetDes tructor is a call to the TClassCatalog : : GetDestructor method.\n\nVirtual method stubs\n\nA virtual method stub is generated for each virtual function which may be linked with the client (in SharedLibTemp . stubs . a), unless the client specified NoStubs or NoVirtual Stubs in the export declaration for the class. These stubs are only used by a client that creates stack objects since the compiler generates a direct call when the dot syntax is used. The compiler is \"smart\" and \"knows\" the class of the object so it does not generate a v-table indirect call. It would be better for SLM if the compiler had an option to generate v-table calls anyway.\n\n_stbGetObjectName_13TExampleClassCFv RECORD EXPORT\n\nIMPORT _CVRTExampleClass:Data\n\nDC.L 0\n\nDC.L _CVRTExampleClass\n\nDC.L 0\n\nDC.W 9 ; Index in VTable\n\nENDR\n\nGetObjectName 13TExampleClassCFv PROC EXPORT\n\nIMPORT stbGetObjectName 13TExampleClassCFv:Data Â° This is the actual virtual function dispatcher that is linked with the Shared Library Manager.\n\nSLMVTableDispatch PROC Export move.l dO,-(sp) Push the library manager move.l aO,-(sp) Push the stub record move.l dO,aO Get lib mgr into aO move.l 20(a0),a0 Get class catalog from lib mgr move.l aO,-(sp) Push it move.l (aO),aO Get it's vtable move.l CatVTable.GetVTableEntry(aO),aO jsr (aO) ; Call the GetVTableEntry entry lea 12(sp),sp ; Drop parameters move.l dO,aO ; Fetch function address jmp (aO) ; Jump to it ENDP\n\nCopyright Apple Computer 1991 -1993\n\nNon- Virtual method stubs Many classes use both virtual and non-virtual functions. Virtual functions allow subclasses to override the behavior of a class, while non- virtual functions do not. SLM supports stubs for the non-virtual methods to be generated (generated automatically unless noS ubs or no ethodStubs is specified in the export declaration for the class). Note that SLM does not export static methods automatically in this manner. Static methods should normally be exported in a function set, since they do not require an instance of the class to be in existence in order for calling the method to be valid.\n\nÂ° A non-virtual member function stub is generated for each non-virtual member function (to be linked with the client in SharedLibTemp . stubs . a) _stbGetGlobalRef_13TExampleClassFRPI RECORD EXPORT\n\nIMPORT _CVRTExampleClass:Data\n\nDC.L 0\n\nDC.L _CVRTExampleClass\n\nDC.L 0 DC.W 0 ; Index into exptbl array\n\nENDR\n\nGetGlobalRef_13TExampleClassFRPI PROC EXPORT\n\nIMPORT _stbGetGlobalRef_13TExampleClassFRPI:Data IF MODEL = 0\n\nLEA _stbGetGlobalRef_13TExampleClassFRPI,aO\n\nELSE\n\nLEA (_stbGetGlobalRef_13TExampleClassFRPI).L,aO\n\n- 48 - IF MODEL =\n\nLEA stbGetObjectName 13TExampleClassCFv,aO ELSE\n\nLEA (_stbGetObjectName__13TExampleCiassCFv).L,aO ENDIF move.l (aO),dO ; Is function address cached? beq.s @1 ; No - do it the hard way move.l d0,aO ; Yes - get address into aO jmp (aO) ; and jump IF MODEL = 0\n\nLEA CVRTExampleClass,aO ELSE\n\nLEA (_CVRTExampleClass).L,aO ENDIF\n\nIMPORT _SLM1 1 VTableDispatch\n\n@1\n\nIF MODEL = 0\n\nJMP _SLM1 1 VTableDispatch ELSE\n\nJMP (_SLM1 1 VTableDispatch). L ENDIF IF MACSBUG = 1 THEN rts\n\nDC.B $80, $26\n\nDC.B 'stub GetObjectName 13TExampleClassCFv'\n\nDC.B 0\n\nDC.W 0 ENDIF\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nNotice that for virtual method stubs, we can once again cache the actual address of the function and call it directly. Â° This is the virtual function dispatcher that is linked with the client.\n\n_SLM 1 1 VTableDispatch PROC Export move.l $2B6,a1 move.l $10C(a1 ),a1 move.l SLMGIobal.fStubHelp + 8(a1 ),a1 IF MODEL = 0 THEN move.l gLibraryManager.dO\n\nELSE move.l ( gLibraryManager). L,dO\n\nENDIF jmp (a1 )\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\n47 - ENDIF move.l (aO),dO ; Is Address cached? beq.s @1 ; No - do it the hard way move.l dO,aO ; Yes - get address into aO jmp (aO) ; and jump IMPORT _SLM1 1 ExtblDispatch\n\n@1\n\nIF MODEL = 0\n\nJMP _SLM1 1 ExtblDispatch ELSE\n\nJMP _SLM1 1 ExtblDispatch). L ENDIF IF MACSBUG 1 THEN rts\n\nDC.B $80, $26\n\nDC.B 'stub_GetGlobalRef_ 13TExampleClassFRPI'\n\nDC.B 0\n\nDC.W 0 ENDIF\n\nENDP\n\nCopyright Apple Computer 1 991 -1993\n\nÂ° This is the non-virtual function dispatcher that is linked with the client. _SLM1 1 ExtblDispatch PROC Export move.! $2B6,a1 move.l $10C(a1 ),a1 move.l SLMGIobal.fStubHelp + 12(a1 ),a1 IF MODEL = 0 THEN move.l gLibraryManager,dO\n\nELSE move.l ( gLibraryManager). L,dO\n\nENDIF jmp (a1 ) ENDP\n\nCopyright Apple Computer 1991 -1993\n\n0 This is the actual non-virtual function dispatcher that is linked with the Shared Library Manager.\n\nmove.l CatVTable.GetExportEntry(aO),aO jsr (aO) ; Call the GetExportEntry entry lea 12(sp),sp ; Drop parameters move.l dO,aO ; Fetch function address jmp (aO) ; Jump to it\n\nENDP\n\nCopyright Apple Computer 1991 -1993\n\nStatic method stubs\n\nStatic methods should normally be exported by function sets, since they are not associated with an instance of an object. You can export a specific static methodby specifying \"exports=<ClassName> : : <StaticMethod>\" inyour function set declaration, or you can export all static methods of a class by specifying \"exports = static <ClassName>\" in the declaration.\n\nSingly-Inherited Classes (initialization)\n\nThis section will examine the initialization code for a C+ + class which is singly-inherited. This includes both forms of vtables - SingleObject derived, and standard AT&T v2.1 classes. Classes which are multiply-inherited (derive from more than 1 parent class) are handled in a separate section. o ClientVTableRecord for TExampleClass:\n\n__CVRTExampleClass RECORD EXPORT\n\nDC.L 0, 0, 0\n\nDC.W $01 10\n\nDC.W $01 10 DC.B 'appl:exam$TExampleClass', 0\n\nENDR\n\nCopyright Apple Computer 1991 -1993\n\nÂ° Of course the vtable for TExampleClass is generated by the compiler. The symbol for it is imported (SharedLibTemp.init.c): extern ProcPtr vtbl 13TExampleClass[];\n\nCopyright Apple Computer 1991 -1993\n\nÂ° The symbols for the non-virtual member functions (in this case GetGlobalRef) and the constructor and destructor are imported. The names of the constructor and destructor have been mangled with a 'q' to distinguish them from the stubs.\n\nSLM modifies the object file that contains the constructor and destructor so that their names are different. This forces any reference to the constructor or destructor from within the library to also go through the stub. This is so that use counts can be maintained. If a library were to create an object, give it to the client, and have the client destroy the object, it would be possible for the library to unload even though there are outstanding references to it, since construction did not increment the use count, but destruction did. The stub for the constructor (the one without the 'q') is called by\n\nNewObject. The real constructors and destructors (the ones with the q mangling) are in the export table so they can be called from the stubs. The original symbols for the constructors and destructors in the object file (.o file) for the library are\n\n\"q mangled\" by the LibraryBuilder tool. extern void ct 13TExampleClassFv(void); extern void dtq_13TExampleClassFv(void); extern void ctq_13TExampleClassFv(void); extern void GetGlobalRef 13TExampleClassFRPI(void); Copyright Apple Computer 1991 -1993\n\nÂ° Two export tables are generated. One for the constructors and destructors\n\n( extbl < ClassName > ) and one for non-virtual functions exptbl < ClassName > ) . ProcPtr exptbl TExampleClass!] =\n\n{\n\n(ProcPtr)GetGlobalRef_13TExampleClassFRPI\n\n};\n\nProcPtr extbl TExampleClass!] =\n\n{\n\n(ProcPtr) exptbl TExampleClass,\n\n(ProcPtr)_ct__13TExampleClassFv, (ProcPtr) dtq_13TExampleClassFv,\n\n(ProcPtr) ctq_13TExampleClassFv\n\n>;\n\nCopyright Apple Computer 1991 -1993 Note that the first entry in the \"extbl\" points to the \"exptbl\". This allows a later version of the library to have new non-virtual method exports and new constructors. The first 4 entries of the extbl are always fixed. They may be zero if the corresponding table or function does not exist. The second entry always points to the stub for the default constructor (the constructor with no arguments). The third entry always points to the \"real\" destructor, and the fourth entry always points to the \"real\" default constructor. Any entries after the fourth are for other versions of the constructors, and they always contain pointers to the\n\n\"real\" version ( ctq_) of those constructors. Â° The actual initialization code then needs to be generated.\n\n#pragma segment A5lnit void SVRTExampleClass(void* vtRec, unsigned int vtRecSize)\n\n{ register ProcPtr toCall; void** cat = GetClassCatalog; void** ctVTable = *cat; void* parentVtRec; // // Initialize the VTableRec for TExampleClass\n\n//\n\n{ extern ProcPtr vtbl 13TExampleClass[]; extern ClientVTableRec CVRTDynamic; toCall = (ProcPtr)ctVTable[21 l;\n\n//\n\n// Call InitVTableRec.\n\n// vtRec = (*(lnitVTableRec)toCall) (cat, vtRec, vtbl 13TExampleClass, extbl TExampleClass, & CVRTDynamic, 8, 0);\n\n} //\n\n// If there is a shared parent. Get it's VTableRec // toCall = (ProcPtr)ctVTable[251; parentVtRec = (*(GetVTableRec)toCall)(cat, &_CVRTDynamic, 1 );\n\n/* This code is OPTIONAL\n\n//\n\n// If there are functions inherited from the parent, let's // copy them. For a standard AT&T V2.1 vtable format, the // copy code would be modified appropriately. //\n\n{ unsigned int idx; register VTable vtbl = *(VTable*)parentVtRec; register VTable myVTable = vtbl 13TExampleClass; myVTable + = 2; vtbl + = 2; for (idx = 0; idx < 7; + +idx)\n\n{\n\n*myVTable + + = *vtbl + + ;\n\n} }\n\n}\n\nCopyright Apple Computer 1991 -1993\n\nThis code does several things. The first is to initialize the VTableRec. The parameters to the Init VTableRec call are as follows:\n\n1) A pointer to the class catalog, obtained from the GetClassCatalog macros.\n\n2) A pointer to the VTableRec that was originally passed in to your initialization function. 3) A pointer to the vtable for the class\n\n4) A pointer to the export table for the class\n\n5) A pointer to the ClientVTableRec of the first \"shared\" parent class, looking backwards up the hierarchy. Normally, it is the ClientVTableRec of your parent class. However, if the parent class is not a shared class, then look at it's parent, and so on until you find a parent class that is shared. Leave this parameter NULL\n\n(zero) if no parent class is shared.\n\n6) The size of the object, in bytes. This parameter is optional, and may be set to zero unless you want your class to be able to be instantiated with the NewOb j ect function. If this is the case, you must supply the size as a negative number whose absolute value is the size of the object in bytes.\n\n7) The last parameter is a flag to tell the SIM about the VTableRec. For singly-inherited classes, only two values are used. NULL (or 0) indicates that the class inherits from SingleObject or HandleObject and has a vtable format that is just an array of function pointers. A value of (char*)-lL indicates that the vtable has the format of an AT&T V2.1 vtable, which looks like: typedef struct mptr { short o; short i; ProcPtr func; } _mptr;\n\nCopyright Apple Computer 1991 -1993\n\nMultiply-Inherited Classes (stubs)\n\nThis section will examine the stub creation for a C+ + class which is multiply-inherited. What follows is a set of declarations for several classes, culminating in the definition of the class TMixedClass2. These are the classes that will be used to demonstrate the generation of code for multiply-inherited classes.\n\n#define kMMixinl lD \"quin:test$MMixin1 ,1 .1 \" class MMixinl : public MDynamic\n\n{ protected:\n\nMMixinl (int a); MMixinl (); virtual â MMixinl (); public: virtual int AddKint a); virtual int Sub1 (int a); int fFieldm;\n\n};\n\n#define kMMixin2ID \"quin:test$MMixin2,1.1 ' class MMixin2 : public MDynamic\n\n{ protected:\n\nMMixin2(); MMixin2(int a); virtual ~ MMixin2(); public: virtual int Add2(int a); virtual int Sub2(int a); int fFieldm;\n\n};\n\n#define kMMixin3ID \"quin:test$MMixin3,1 .V class MMixin3 : public MDynamic\n\n{ protected: int fFieldm;\n\n};\n\n//\n\n// Non-shared class\n\n// class TMainClass : public TStdDynamic\n\n{ public:\n\nTMainClass(int a); virtual -TMainClass!);\n\nvirtual int MuKint a); virtual int Div(int a); int fFieldt;\n\n};\n\n#define kTMixedClassID nquin:test$TMixedClass,1 .1 class TMixedClass : public TMainClass, virtual public MMixinl , public MMixin2\n\n{ public:\n\nTMixedClassfint a); TMixedClassO; virtual -TMixedClassO; virtual int Sub1 (int a); virtual int Div(int a); virtual int Add2(int a);\n\n};\n\n#define kTMixedClass2ID \"quin:test$TMixedClass2,1 .1 \" class TMixedClass2 : public TMixedClass, virtual public MMixinl , public MMixin3\n\n{ public:\n\nTMixedClass2(int a); TMixedClass2(); virtual ~TMixedClass2(); virtual int Sub2(int a); virtual int MuKint a); virtual int AddKint a); virtual int Add3(int a);\n\n};\n\nCopyright Apple Computer 1991 -1993\n\nAll stubs for multiply-inherited classes are generated in exactly the same way as for singly-inherited classes. This works because all inherited virtual functions are present in the primary vtable of the class.\n\nIf you encounter a case where this is not true, SIM provides a way to deal with it. Set the high bit (0x8000) of the index value (for whichever vtable the virtual function is present in), and add a second short (two bytes) immediately after it in the stub record which is the index number of the VTableRec (0 = primary, 1 = next one, etc.).\n\nMultiply-Inherited Classes (initialiTation)\n\nThis section will examine the initialization code for a C+ + class which is multiply-inherited. The situation here is much different than for singly-inherited classes. Consider: using the hierarchy above, if one has an MMixinl object in hand, is it a true MMixinl object, or is it a TMixedClass2 object cast to an MMixinl, or even a TMixedClass object cast to an MMixinl? Information needs to be made available about the offset back to the \"main\" object. This allows the SLM function CastObject to work properly with objects which are instances of multiply-inherited classes.\n\nThis information is stored in the MMixinl VTableRec, which is stored in the MMixinl vtable. However, a different VTableRec is needed for an MMixinl object which is \"stand-alone\", than for an MMixinl object that is part of a TMixedClass2 object. This is because the offset to the \"main\" object is zero for a \"stand-alone\" object, and probably non-zero for one of many parents of a \"main\" object. This leads us to the conclusion that in order to initialize a multiply-inherited class, multiple VTableRecs will need to be initialized in order to keep things running smoothly.\n\nThe initialization for classes MMixinl, MMixin2, and MMixin3 are exactly what you would expect for singly-inherited classes: extern ClientVTableRec CVRMMixinl ; extern void ct 7MMixin1 Fv(void); extern void dtq_7MMixin1 Fv(void); extern void ctq_7MMixin1 Fv(void); extern void ctq_7MMixin1 Fi(void);\n\n};\n\n#pragma segment AÎ´lnit void SVRMMixinKvoid* vtRec, unsigned int vtRecSize)\n\n{ register ProcPtr toCall; void* * catalog = GetClassCatalog; void** ctVTable = * catalog; void* parentVtRec; extern ProcPtr vtbl 7MMixin1 I]; toCall = (ProcPtr)ctVTable[21 l; vtRec = (*(lnitVTableRec)toCall) (catalog, vtRec,\n\n__vtbl_7MMixin1 , _extbl_MMixin1 , 0, 8, (char*)0x0001 ); } extern ClientVTableRec CVRMMixin2; extern void ct 7MMixin2Fv(void); extern void dtq_7MMixin2Fv(void); extern void ctq_7MMixin2Fv(void); extern void ctq_7MMixin2Fi(void);\n\nProcPtr extbl MMixin2[] =\n\n{\n\n0, (ProcPtr)_ct_7MMixin2Fv, (ProcPtr) dtq_7MMixin2Fv,\n\n( Proc Ptr )_ctq_7 M M ixi n 2 F v, (ProcPtr) ctq_7MMixin2Fi\n\n}; #pragma segment A5lnit void SVRMMixin2(void* vtRec, unsigned int vtRecSize)\n\n{ register ProcPtr toCall; void* * catalog = GetClassCatalog; void* * ctVTable = *catalog; void* parentVtRec; extern ProcPtr vtbl_7MMixin2[]; toCall = (ProcPtr)ctVTable[21 l; vtRec = (*(lnitVTableRec)toCall) (catalog, vtRec,\n\n_vtbl_7MMixin2, _extbl_MMixin2, 0, 8, (char*)0x0001 );\n\n} extern ClientVTableRec CVRMMixin3; extern void ct 7MMixin3Fv(void); extern void dtq_7MMixin3Fv(void); extern void ctq_7MMixin3Fv(void); extern void ctq_7MMixin3Fi(void); ProcPtr _extbl_MMixin3[] =\n\n{\n\n0, (ProcPtr)_ct_7MMixin3Fv,\n\n( ProcPtr) dtq_7 M M ixin3 Fv, (ProcPtr)_ctq_7MMixin3Fv,\n\n(ProcPtr)__ctq_7MMixin3Fi\n\n}"
    }
}