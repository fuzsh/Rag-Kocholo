{
    "id": "dbpedia_2924_3",
    "rank": 69,
    "data": {
        "url": "https://rescript-lang.org/docs/manual/latest/record",
        "read_more_link": "",
        "language": "en",
        "title": "ReScript Language Manual",
        "top_image": "https://rescript-lang.org/static/favicon/favicon-32x32.png",
        "meta_img": "https://rescript-lang.org/static/favicon/favicon-32x32.png",
        "images": [
            "https://rescript-lang.org/static/nav-logo@2x.png",
            "https://rescript-lang.org/static/nav-logo-full@2x.png",
            "https://rescript-lang.org/static/ic_manual@2x.png",
            "https://rescript-lang.org/static/ic_rescript_react@2x.png",
            "https://rescript-lang.org/static/ic_gentype@2x.png",
            "https://rescript-lang.org/static/ic_reanalyze@2x.png",
            "https://rescript-lang.org/static/ic_package.svg",
            "https://rescript-lang.org/static/ic_search.svg",
            "https://rescript-lang.org/static/illu_index_rescript@2x.png",
            "https://rescript-lang.org/static/ic_sidebar_drawer.svg",
            "https://rescript-lang.org/static/rescript_logo_black.svg",
            "https://simpleanalyticsbadge.com/rescript-lang.org?counter=true&radius=13",
            "https://queue.simpleanalyticscdn.com/noscript.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Record types in ReScript",
        "meta_lang": "",
        "meta_favicon": "/static/favicon/apple-touch-icon.png",
        "meta_site_name": "ReScript Documentation",
        "canonical_link": "https://rescript-lang.org/docs/manual/latest/record",
        "text": "Record\n\nRecords are like JavaScript objects but:\n\nare immutable by default\n\nhave fixed fields (not extensible)\n\nType Declaration\n\nA record needs a mandatory type declaration:\n\nCreation\n\nTo create a person record (declared above):\n\nWhen you create a new record value, ReScript tries to find a record type declaration that conforms to the shape of the value. So the me value here is inferred as of type person.\n\nThe type is found by looking above the me value. Note: if the type instead resides in another file or module, you need to explicitly indicate which file or module it is:\n\nIn both me and me2 the record definition from School is found. The first one, me with the regular type annotation, is preferred.\n\nAccess\n\nUse the familiar dot notation:\n\nNew records can be created from old records with the ... spread operator. The original record isn't mutated.\n\nNote: spread cannot add new fields to the record value, as a record's shape is fixed by its type.\n\nRecord fields can optionally be mutable. This allows you to efficiently update those fields in-place with the = operator.\n\nFields not marked with mutable in the type declaration cannot be mutated.\n\nJavaScript Output\n\nReScript records compile to straightforward JavaScript objects; see the various JS output tabs above.\n\nOptional Record Fields\n\nReScript v10 introduced optional record fields. This means that you can define fields that can be omitted when creating the record. It looks like this:\n\nNotice how name has a suffixed ?. That means that the field itself is optional.\n\nCreation\n\nYou can omit any optional fields when creating a record. Not setting an optional field will default the field's value to None:\n\nThis has consequences for pattern matching, which we'll expand a bit on soon.\n\nUpdating an optional field via an immutable update above lets you set that field value without needing to care whether it's optional or not.\n\nHowever, if you want to set the field to an optional value, you prefix that value with ?:\n\nYou can unset an optional field's value via that same mechanism by setting it to ?None.\n\nPattern Matching on Optional Fields\n\nPattern matching, one of ReScript's most important features, has two caveats when you deal with optional fields.\n\nWhen matching on the value directly, it's an option. Example:\n\nBut, when matching on the field as part of the general record structure, it's treated as the underlying, non-optional value:\n\nSometimes you do want to know whether the field was set or not. You can tell the pattern matching engine about that by prefixing your option match with ?, like this:\n\nRecord Type Spread\n\nIn ReScript v11, you can now spread one or more record types into a new record type. It looks like this:\n\nRESCRIPT\n\ntype a = { id: string, name: string, } type b = { age: int } type c = { ...a, ...b, active: bool }\n\ntype c will now be:\n\nRESCRIPT\n\ntype c = { id: string, name: string, age: int, active: bool, }\n\nRecord type spreads act as a 'copy-paste' mechanism for fields from one or more records into a new record. This operation inlines the fields from the spread records directly into the new record definition, while preserving their original properties, such as whether they are optional or mandatory. It's important to note that duplicate field names are not allowed across the records being spread, even if the fields have the same type.\n\nRecord Type Coercion\n\nRecord type coercion gives us more flexibility when passing around records in our application code. In other words, we can now coerce a record a to be treated as a record b at the type level, as long as the original record a contains the same set of fields in b. Here's an example:\n\nRESCRIPT\n\ntype a = { name: string, age: int, } type b = { name: string, age: int, } let nameFromB = (b: b) => b.name let a: a = { name: \"Name\", age: 35, } let name = nameFromB(a :> b)\n\nNotice how we coerced the value a to type b using the coercion operator :>. This works because they have the same record fields. This is purely at the type level, and does not involve any runtime operations.\n\nAdditionally, we can also coerce records from a to b whenever a is a super-set of b (i.e. a containing all the fields of b, and more). The same example as above, slightly altered:\n\nRESCRIPT\n\ntype a = { id: string, name: string, age: int, active: bool, } type b = { name: string, age: int, } let nameFromB = (b: b) => b.name let a: a = { id: \"1\", name: \"Name\", age: 35, active: true, } let name = nameFromB(a :> b)\n\nNotice how a now has more fields than b, but we can still coerce a to b because b has a subset of the fields of a.\n\nIn combination with optional record fields, one may coerce a mandatory field of an option type to an optional field:\n\nRESCRIPT\n\ntype a = { name: string, age: option<int>, } type b = { name: string, age?: int, } let nameFromB = (b: b) => b.name let a: a = { name: \"Name\", age: Some(35), } let name = nameFromB(a :> b)\n\nTips & Tricks\n\nRecord Types Are Found By Field Name\n\nWith records, you cannot say \"I'd like this function to take any record type, as long as they have the field age\". The following won't work as intended:\n\nInstead, getAge will infer that the parameter entity must be of type monster, the closest record type with the field age. The following code's last line fails:\n\nRES\n\nlet kraken = {age: 9999, hasTentacles: true} let me = {age: 5, name: \"Baby ReScript\"} getAge(kraken) getAge(me)\n\nThe type system will complain that me is a person, and that getAge only works on monster. If you need such capability, use ReScript objects, described here.\n\nOptional Fields in Records Can Be Useful for Bindings\n\nMany JavaScript APIs tend to have large configuration objects that can be a bit annoying to model as records, since you previously always needed to specify all record fields when creating a record.\n\nOptional record fields, introduced in v10, is intended to help with this. Optional fields will let you avoid having to specify all fields, and let you just specify the one's you care about. A significant improvement in ergonomics for bindings and other APIs with for example large configuration objects.\n\nDesign Decisions\n\nAfter reading the constraints in the previous sections, and if you're coming from a dynamic language background, you might be wondering why one would bother with record in the first place instead of straight using object, since the former needs explicit typing and doesn't allow different records with the same field name to be passed to the same function, etc.\n\nThe truth is that most of the times in your app, your data's shape is actually fixed, and if it's not, it can potentially be better represented as a combination of variant (introduced next) + record instead.\n\nSince a record type is resolved through finding that single explicit type declaration (we call this \"nominal typing\"), the type error messages end up better than the counterpart (\"structural typing\", like for tuples). This makes refactoring easier; changing a record type's fields naturally allows the compiler to know that it's still the same record, just misused in some places. Otherwise, under structural typing, it might get hard to tell whether the definition site or the usage site is wrong."
    }
}