{
    "id": "dbpedia_2924_3",
    "rank": 85,
    "data": {
        "url": "https://guides.rubyonrails.org/v6.0/form_helpers.html",
        "read_more_link": "",
        "language": "en",
        "title": "Action View Form Helpers â Ruby on Rails Guides",
        "top_image": "https://avatars.githubusercontent.com/u/4223",
        "meta_img": "https://avatars.githubusercontent.com/u/4223",
        "images": [
            "https://guides.rubyonrails.org/v6.0/images/chapters_icon.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Action View Form HelpersForms in web applications are an essential interface for user input. However, form markup can quickly become tedious to write and maintain because of the need to handle form control naming and its numerous attributes. Rails does away with this complexity by providing view helpers for generating form markup. However, since these helpers have different use cases, developers need to know the differences between the helper methods before putting them to use.After reading this guide, you will know: How to create search forms and similar kind of generic forms not representing any specific model in your application. How to make model-centric forms for creating and editing specific database records. How to generate select boxes from multiple types of data. What date and time helpers Rails provides. What makes a file upload form different. How to post forms to external resources and specify setting an authenticity_token. How to build complex forms.",
        "meta_lang": "en",
        "meta_favicon": "images/favicon.ico",
        "meta_site_name": "Ruby on Rails Guides",
        "canonical_link": null,
        "text": "1 Dealing with Basic Forms\n\nThe main form helper is form_with.\n\n<%= form_with do %> Form contents <% end %>\n\nWhen called without arguments like this, it creates a form tag which, when submitted, will POST to the current page. For instance, assuming the current page is a home page, the generated HTML will look like this:\n\n<form accept-charset=\"UTF-8\" action=\"/\" data-remote=\"true\" method=\"post\"> <input name=\"authenticity_token\" type=\"hidden\" value=\"J7CBxfHalt49OSHp27hblqK20c9PgwJ108nDHX/8Cts=\" /> Form contents </form>\n\nYou'll notice that the HTML contains an input element with type hidden. This input is important, because non-GET form cannot be successfully submitted without it. The hidden input element with the name authenticity_token is a security feature of Rails called cross-site request forgery protection, and form helpers generate it for every non-GET form (provided that this security feature is enabled). You can read more about this in the Securing Rails Applications guide.\n\n1.1 A Generic Search Form\n\nOne of the most basic forms you see on the web is a search form. This form contains:\n\na form element with \"GET\" method,\n\na label for the input,\n\na text input element, and\n\na submit element.\n\nTo create this form you will use form_with, label_tag, text_field_tag, and submit_tag, respectively. Like this:\n\n<%= form_with(url: \"/search\", method: \"get\") do %> <%= label_tag(:q, \"Search for:\") %> <%= text_field_tag(:q) %> <%= submit_tag(\"Search\") %> <% end %>\n\nThis will generate the following HTML:\n\n<form accept-charset=\"UTF-8\" action=\"/search\" data-remote=\"true\" method=\"get\"> <label for=\"q\">Search for:</label> <input id=\"q\" name=\"q\" type=\"text\" /> <input name=\"commit\" type=\"submit\" value=\"Search\" data-disable-with=\"Search\" /> </form>\n\nUse \"GET\" as the method for search forms. This allows users to bookmark a specific search and get back to it. More generally Rails encourages you to use the right HTTP verb for an action.\n\n1.2 Helpers for Generating Form Elements\n\nRails provides a series of helpers for generating form elements such as checkboxes, text fields, and radio buttons. These basic helpers, with names ending in _tag (such as text_field_tag and check_box_tag), generate just a single <input> element. The first parameter to these is always the name of the input. When the form is submitted, the name will be passed along with the form data, and will make its way to the params in the controller with the value entered by the user for that field. For example, if the form contains <%= text_field_tag(:query) %>, then you would be able to get the value of this field in the controller with params[:query].\n\nWhen naming inputs, Rails uses certain conventions that make it possible to submit parameters with non-scalar values such as arrays or hashes, which will also be accessible in params. You can read more about them in chapter Understanding Parameter Naming Conventions of this guide. For details on the precise usage of these helpers, please refer to the API documentation.\n\n1.2.1 Checkboxes\n\nCheckboxes are form controls that give the user a set of options they can enable or disable:\n\n<%= check_box_tag(:pet_dog) %> <%= label_tag(:pet_dog, \"I own a dog\") %> <%= check_box_tag(:pet_cat) %> <%= label_tag(:pet_cat, \"I own a cat\") %>\n\nThis generates the following:\n\n<input id=\"pet_dog\" name=\"pet_dog\" type=\"checkbox\" value=\"1\" /> <label for=\"pet_dog\">I own a dog</label> <input id=\"pet_cat\" name=\"pet_cat\" type=\"checkbox\" value=\"1\" /> <label for=\"pet_cat\">I own a cat</label>\n\nThe first parameter to check_box_tag, of course, is the name of the input. The second parameter, naturally, is the value of the input. This value will be included in the form data (and be present in params) when the checkbox is checked.\n\n1.2.2 Radio Buttons\n\nRadio buttons, while similar to checkboxes, are controls that specify a set of options in which they are mutually exclusive (i.e., the user can only pick one):\n\n<%= radio_button_tag(:age, \"child\") %> <%= label_tag(:age_child, \"I am younger than 21\") %> <%= radio_button_tag(:age, \"adult\") %> <%= label_tag(:age_adult, \"I am over 21\") %>\n\nOutput:\n\n<input id=\"age_child\" name=\"age\" type=\"radio\" value=\"child\" /> <label for=\"age_child\">I am younger than 21</label> <input id=\"age_adult\" name=\"age\" type=\"radio\" value=\"adult\" /> <label for=\"age_adult\">I am over 21</label>\n\nAs with check_box_tag, the second parameter to radio_button_tag is the value of the input. Because these two radio buttons share the same name (age), the user will only be able to select one of them, and params[:age] will contain either \"child\" or \"adult\".\n\nAlways use labels for checkbox and radio buttons. They associate text with a specific option and, by expanding the clickable region, make it easier for users to click the inputs.\n\n1.3 Other Helpers of Interest\n\nOther form controls worth mentioning are textareas, password fields, hidden fields, search fields, telephone fields, date fields, time fields, color fields, datetime-local fields, month fields, week fields, URL fields, email fields, number fields, and range fields:\n\n<%= text_area_tag(:message, \"Hi, nice site\", size: \"24x6\") %> <%= password_field_tag(:password) %> <%= hidden_field_tag(:parent_id, \"5\") %> <%= search_field(:user, :name) %> <%= telephone_field(:user, :phone) %> <%= date_field(:user, :born_on) %> <%= datetime_local_field(:user, :graduation_day) %> <%= month_field(:user, :birthday_month) %> <%= week_field(:user, :birthday_week) %> <%= url_field(:user, :homepage) %> <%= email_field(:user, :address) %> <%= color_field(:user, :favorite_color) %> <%= time_field(:task, :started_at) %> <%= number_field(:product, :price, in: 1.0..20.0, step: 0.5) %> <%= range_field(:product, :discount, in: 1..100) %>\n\nOutput:\n\n<textarea id=\"message\" name=\"message\" cols=\"24\" rows=\"6\">Hi, nice site</textarea> <input id=\"password\" name=\"password\" type=\"password\" /> <input id=\"parent_id\" name=\"parent_id\" type=\"hidden\" value=\"5\" /> <input id=\"user_name\" name=\"user[name]\" type=\"search\" /> <input id=\"user_phone\" name=\"user[phone]\" type=\"tel\" /> <input id=\"user_born_on\" name=\"user[born_on]\" type=\"date\" /> <input id=\"user_graduation_day\" name=\"user[graduation_day]\" type=\"datetime-local\" /> <input id=\"user_birthday_month\" name=\"user[birthday_month]\" type=\"month\" /> <input id=\"user_birthday_week\" name=\"user[birthday_week]\" type=\"week\" /> <input id=\"user_homepage\" name=\"user[homepage]\" type=\"url\" /> <input id=\"user_address\" name=\"user[address]\" type=\"email\" /> <input id=\"user_favorite_color\" name=\"user[favorite_color]\" type=\"color\" value=\"#000000\" /> <input id=\"task_started_at\" name=\"task[started_at]\" type=\"time\" /> <input id=\"product_price\" max=\"20.0\" min=\"1.0\" name=\"product[price]\" step=\"0.5\" type=\"number\" /> <input id=\"product_discount\" max=\"100\" min=\"1\" name=\"product[discount]\" type=\"range\" />\n\nHidden inputs are not shown to the user but instead hold data like any textual input. Values inside them can be changed with JavaScript.\n\n2 Dealing with Model Objects\n\n2.1 Model Object Helpers\n\nA particularly common task for a form is editing or creating a model object. While the *_tag helpers can certainly be used for this task they are somewhat verbose as for each tag you would have to ensure the correct parameter name is used and set the default value of the input appropriately. Rails provides helpers tailored to this task. These helpers lack the _tag suffix, for example text_field, text_area.\n\nFor these helpers the first argument is the name of an instance variable and the second is the name of a method (usually an attribute) to call on that object. Rails will set the value of the input control to the return value of that method for the object and set an appropriate input name. If your controller has defined @person and that person's name is Henry then a form containing:\n\n<%= text_field(:person, :name) %>\n\nwill produce output similar to\n\n<input id=\"person_name\" name=\"person[name]\" type=\"text\" value=\"Henry\" />\n\nUpon form submission the value entered by the user will be stored in params[:person][:name].\n\nRails provides helpers for displaying the validation errors associated with a model object. These are covered in detail by the Active Record Validations guide.\n\n2.2 Binding a Form to an Object\n\nWhile this is an increase in comfort it is far from perfect. If Person has many attributes to edit then we would be repeating the name of the edited object many times. What we want to do is somehow bind a form to a model object, which is exactly what form_with with :model does.\n\nAssume we have a controller for dealing with articles app/controllers/articles_controller.rb:\n\ndef new @article = Article.new end\n\nThe corresponding view app/views/articles/new.html.erb using form_with looks like this:\n\n<%= form_with model: @article, class: \"nifty_form\" do |f| %> <%= f.text_field :title %> <%= f.text_area :body, size: \"60x12\" %> <%= f.submit \"Create\" %> <% end %>\n\nThere are a few things to note here:\n\n@article is the actual object being edited.\n\nThere is a single hash of options. HTML options (except id and class) are passed in the :html hash. Also you can provide a :namespace option for your form to ensure uniqueness of id attributes on form elements. The scope attribute will be prefixed with underscore on the generated HTML id.\n\nThe form_with method yields a form builder object (the f variable).\n\nIf you wish to direct your form request to a particular URL, you would use form_with url: my_nifty_url_path instead. To see more in depth options on what form_with accepts be sure to check out the API documentation.\n\nMethods to create form controls are called on the form builder object f.\n\nThe resulting HTML is:\n\n<form class=\"nifty_form\" action=\"/articles\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"> <input type=\"hidden\" name=\"authenticity_token\" value=\"NRkFyRWxdYNfUg7vYxLOp2SLf93lvnl+QwDWorR42Dp6yZXPhHEb6arhDOIWcqGit8jfnrPwL781/xlrzj63TA==\" /> <input type=\"text\" name=\"article[title]\" id=\"article_title\" /> <textarea name=\"article[body]\" id=\"article_body\" cols=\"60\" rows=\"12\"></textarea> <input type=\"submit\" name=\"commit\" value=\"Create\" data-disable-with=\"Create\" /> </form>\n\nThe object passed as :model in form_with controls the key used in params to access the form's values. Here the name is article and so all the inputs have names of the form article[attribute_name]. Accordingly, in the create action params[:article] will be a hash with keys :title and :body. You can read more about the significance of input names in chapter Understanding Parameter Naming Conventions of this guide.\n\nThe helper methods called on the form builder are identical to the model object helpers except that it is not necessary to specify which object is being edited since this is already managed by the form builder.\n\nYou can create a similar binding without actually creating <form> tags with the fields_for helper. This is useful for editing additional model objects with the same form. For example, if you had a Person model with an associated ContactDetail model, you could create a form for creating both like so:\n\n<%= form_with model: @person do |person_form| %> <%= person_form.text_field :name %> <%= fields_for :contact_detail, @person.contact_detail do |contact_detail_form| %> <%= contact_detail_form.text_field :phone_number %> <% end %> <% end %>\n\nwhich produces the following output:\n\n<form action=\"/people\" accept-charset=\"UTF-8\" data-remote=\"true\" method=\"post\"> <input type=\"hidden\" name=\"authenticity_token\" value=\"bL13x72pldyDD8bgtkjKQakJCpd4A8JdXGbfksxBDHdf1uC0kCMqe2tvVdUYfidJt0fj3ihC4NxiVHv8GVYxJA==\" /> <input type=\"text\" name=\"person[name]\" id=\"person_name\" /> <input type=\"text\" name=\"contact_detail[phone_number]\" id=\"contact_detail_phone_number\" /> </form>\n\nThe object yielded by fields_for is a form builder like the one yielded by form_with.\n\n2.3 Relying on Record Identification\n\nThe Article model is directly available to users of the application, so - following the best practices for developing with Rails - you should declare it a resource:\n\nresources :articles\n\nWhen dealing with RESTful resources, calls to form_with can get significantly easier if you rely on record identification. In short, you can just pass the model instance and have Rails figure out model name and the rest:\n\n## Creating a new article # long-style: form_with(model: @article, url: articles_path) # short-style: form_with(model: @article) ## Editing an existing article # long-style: form_with(model: @article, url: article_path(@article), method: \"patch\") # short-style: form_with(model: @article)\n\nNotice how the short-style form_with invocation is conveniently the same, regardless of the record being new or existing. Record identification is smart enough to figure out if the record is new by asking record.persisted?. It also selects the correct path to submit to, and the name based on the class of the object.\n\n2.3.1 Dealing with Namespaces\n\nIf you have created namespaced routes, form_with has a nifty shorthand for that too. If your application has an admin namespace then\n\nform_with model: [:admin, @article]\n\nwill create a form that submits to the ArticlesController inside the admin namespace (submitting to admin_article_path(@article) in the case of an update). If you have several levels of namespacing then the syntax is similar:\n\nform_with model: [:admin, :management, @article]\n\nFor more information on Rails' routing system and the associated conventions, please see Rails Routing from the Outside In guide.\n\n2.4 How do forms with PATCH, PUT, or DELETE methods work?\n\nThe Rails framework encourages RESTful design of your applications, which means you'll be making a lot of \"PATCH\", \"PUT\", and \"DELETE\" requests (besides \"GET\" and \"POST\"). However, most browsers don't support methods other than \"GET\" and \"POST\" when it comes to submitting forms.\n\nRails works around this issue by emulating other methods over POST with a hidden input named \"_method\", which is set to reflect the desired method:\n\nform_with(url: search_path, method: \"patch\")\n\nOutput:\n\n<form accept-charset=\"UTF-8\" action=\"/search\" data-remote=\"true\" method=\"post\"> <input name=\"_method\" type=\"hidden\" value=\"patch\" /> <input name=\"authenticity_token\" type=\"hidden\" value=\"f755bb0ed134b76c432144748a6d4b7a7ddf2b71\" /> ... </form>\n\nWhen parsing POSTed data, Rails will take into account the special _method parameter and act as if the HTTP method was the one specified inside it (\"PATCH\" in this example).\n\n3 Making Select Boxes with Ease\n\nSelect boxes in HTML require a significant amount of markup (one OPTION element for each option to choose from), therefore it makes the most sense for them to be dynamically generated.\n\nHere is what the markup might look like:\n\n<select name=\"city_id\" id=\"city_id\"> <option value=\"1\">Lisbon</option> <option value=\"2\">Madrid</option> <option value=\"3\">Berlin</option> </select>\n\nHere you have a list of cities whose names are presented to the user. Internally the application only wants to handle their IDs so they are used as the options' value attribute. Let's see how Rails can help out here.\n\nThe most generic helper is select_tag, which - as the name implies - simply generates the SELECT tag that encapsulates an options string:\n\n<%= select_tag(:city_id, raw('<option value=\"1\">Lisbon</option><option value=\"2\">Madrid</option><option value=\"3\">Berlin</option>')) %>\n\nThis is a start, but it doesn't dynamically create the option tags. You can generate option tags with the options_for_select helper:\n\n<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>\n\nOutput:\n\n<option value=\"1\">Lisbon</option> <option value=\"2\">Madrid</option> <option value=\"3\">Berlin</option>\n\nThe first argument to options_for_select is a nested array where each element has two elements: option text (city name) and option value (city id). The option value is what will be submitted to your controller. Often this will be the id of a corresponding database object but this does not have to be the case.\n\nKnowing this, you can combine select_tag and options_for_select to achieve the desired, complete markup:\n\n<%= select_tag(:city_id, options_for_select(...)) %>\n\noptions_for_select allows you to pre-select an option by passing its value.\n\n<%= options_for_select([['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]], 2) %>\n\nOutput:\n\n<option value=\"1\">Lisbon</option> <option value=\"2\" selected=\"selected\">Madrid</option> <option value=\"3\">Berlin</option>\n\nWhenever Rails sees that the internal value of an option being generated matches this value, it will add the selected attribute to that option.\n\nYou can add arbitrary attributes to the options using hashes:\n\n<%= options_for_select( [ ['Lisbon', 1, { 'data-size' => '2.8 million' }], ['Madrid', 2, { 'data-size' => '3.2 million' }], ['Berlin', 3, { 'data-size' => '3.4 million' }] ], 2 ) %>\n\nOutput:\n\n<option value=\"1\" data-size=\"2.8 million\">Lisbon</option> <option value=\"2\" selected=\"selected\" data-size=\"3.2 million\">Madrid</option> <option value=\"3\" data-size=\"3.4 million\">Berlin</option>\n\n3.2 Select Boxes for Dealing with Model Objects\n\nIn most cases form controls will be tied to a specific model and as you might expect Rails provides helpers tailored for that purpose. Consistent with other form helpers, when dealing with a model object drop the _tag suffix from select_tag:\n\nIf your controller has defined @person and that person's city_id is 2:\n\n@person = Person.new(city_id: 2)\n\n<%= select(:person, :city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %>\n\nwill produce output similar to\n\n<select name=\"person[city_id]\" id=\"person_city_id\"> <option value=\"1\">Lisbon</option> <option value=\"2\" selected=\"selected\">Madrid</option> <option value=\"3\">Berlin</option> </select>\n\nNotice that the third parameter, the options array, is the same kind of argument you pass to options_for_select. One advantage here is that you don't have to worry about pre-selecting the correct city if the user already has one - Rails will do this for you by reading from the @person.city_id attribute.\n\nAs with other helpers, if you were to use the select helper on a form builder scoped to the @person object, the syntax would be:\n\n<%= form_with model: @person do |person_form| %> <%= person_form.select(:city_id, [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]]) %> <% end %>\n\nYou can also pass a block to select helper:\n\n<%= form_with model: @person do |person_form| %> <%= person_form.select(:city_id) do %> <% [['Lisbon', 1], ['Madrid', 2], ['Berlin', 3]].each do |c| %> <%= content_tag(:option, c.first, value: c.last) %> <% end %> <% end %> <% end %>\n\nGenerating options tags with options_for_select requires that you create an array containing the text and value for each option. But what if you had a City model (perhaps an Active Record one) and you wanted to generate option tags from a collection of those objects? One solution would be to make a nested array by iterating over them:\n\n<% cities_array = City.all.map { |city| [city.name, city.id] } %> <%= options_for_select(cities_array) %>\n\nThis is a perfectly valid solution, but Rails provides a less verbose alternative: options_from_collection_for_select. This helper expects a collection of arbitrary objects and two additional arguments: the names of the methods to read the option value and text from, respectively:\n\n<%= options_from_collection_for_select(City.all, :id, :name) %>\n\nAs the name implies, this only generates option tags. To generate a working select box you would need to use collection_select:\n\n<%= collection_select(:person, :city_id, City.all, :id, :name) %>\n\nAs with other helpers, if you were to use the collection_select helper on a form builder scoped to the @person object, the syntax would be:\n\n<%= form_with model: @person do |person_form| %> <%= person_form.collection_select(:city_id, City.all, :id, :name) %> <% end %>\n\n3.4 Time Zone and Country Select\n\nTo leverage time zone support in Rails, you have to ask your users what time zone they are in. Doing so would require generating select options from a list of pre-defined ActiveSupport::TimeZone objects using collection_select, but you can simply use the time_zone_select helper that already wraps this:\n\n<%= time_zone_select(:person, :time_zone) %>\n\nThere is also time_zone_options_for_select helper for a more manual (therefore more customizable) way of doing this. Read the API documentation to learn about the possible arguments for these two methods.\n\nRails used to have a country_select helper for choosing countries, but this has been extracted to the country_select plugin.\n\nYou can choose not to use the form helpers generating HTML5 date and time input fields and use the alternative date and time helpers. These date and time helpers differ from all the other form helpers in two important respects:\n\nDates and times are not representable by a single input element. Instead, you have several, one for each component (year, month, day etc.) and so there is no single value in your params hash with your date or time.\n\nOther helpers use the _tag suffix to indicate whether a helper is a barebones helper or one that operates on model objects. With dates and times, select_date, select_time and select_datetime are the barebones helpers, date_select, time_select and datetime_select are the equivalent model object helpers.\n\nBoth of these families of helpers will create a series of select boxes for the different components (year, month, day etc.).\n\n4.1 Barebones Helpers\n\nThe select_* family of helpers take as their first argument an instance of Date, Time, or DateTime that is used as the currently selected value. You may omit this parameter, in which case the current date is used. For example:\n\n<%= select_date Date.today, prefix: :start_date %>\n\noutputs (with actual option values omitted for brevity)\n\n<select id=\"start_date_year\" name=\"start_date[year]\"> </select> <select id=\"start_date_month\" name=\"start_date[month]\"> </select> <select id=\"start_date_day\" name=\"start_date[day]\"> </select>\n\nThe above inputs would result in params[:start_date] being a hash with keys :year, :month, :day. To get an actual Date, Time, or DateTime object you would have to extract these values and pass them to the appropriate constructor, for example:\n\nDate.civil(params[:start_date][:year].to_i, params[:start_date][:month].to_i, params[:start_date][:day].to_i)\n\nThe :prefix option is the key used to retrieve the hash of date components from the params hash. Here it was set to start_date, if omitted it will default to date.\n\nselect_date does not work well with forms that update or create Active Record objects as Active Record expects each element of the params hash to correspond to one attribute. The model object helpers for dates and times submit parameters with special names; when Active Record sees parameters with such names it knows they must be combined with the other parameters and given to a constructor appropriate to the column type. For example:\n\n<%= date_select :person, :birth_date %>\n\noutputs (with actual option values omitted for brevity)\n\n<select id=\"person_birth_date_1i\" name=\"person[birth_date(1i)]\"> </select> <select id=\"person_birth_date_2i\" name=\"person[birth_date(2i)]\"> </select> <select id=\"person_birth_date_3i\" name=\"person[birth_date(3i)]\"> </select>\n\nwhich results in a params hash like\n\n{'person' => {'birth_date(1i)' => '2008', 'birth_date(2i)' => '11', 'birth_date(3i)' => '22'}}\n\nWhen this is passed to Person.new (or update), Active Record spots that these parameters should all be used to construct the birth_date attribute and uses the suffixed information to determine in which order it should pass these parameters to functions such as Date.civil.\n\n4.3 Common Options\n\nBoth families of helpers use the same core set of functions to generate the individual select tags and so both accept largely the same options. In particular, by default Rails will generate year options 5 years either side of the current year. If this is not an appropriate range, the :start_year and :end_year options override this. For an exhaustive list of the available options, refer to the API documentation.\n\nAs a rule of thumb you should be using date_select when working with model objects and select_date in other cases, such as a search form which filters results by date.\n\n4.4 Individual Components\n\nOccasionally you need to display just a single date component such as a year or a month. Rails provides a series of helpers for this, one for each component select_year, select_month, select_day, select_hour, select_minute, select_second. These helpers are fairly straightforward. By default they will generate an input field named after the time component (for example, \"year\" for select_year, \"month\" for select_month etc.) although this can be overridden with the :field_name option. The :prefix option works in the same way that it does for select_date and select_time and has the same default value.\n\nThe first parameter specifies which value should be selected and can either be an instance of a Date, Time, or DateTime, in which case the relevant component will be extracted, or a numerical value. For example:\n\n<%= select_year(2009) %> <%= select_year(Time.new(2009)) %>\n\nwill produce the same output and the value chosen by the user can be retrieved by params[:date][:year].\n\n5 Uploading Files\n\nA common task is uploading some sort of file, whether it's a picture of a person or a CSV file containing data to process. The most important thing to remember with file uploads is that the rendered form's enctype attribute must be set to \"multipart/form-data\". If you use form_with with :model, this is done automatically. If you use form_with without :model, you must set it yourself, as per the following example.\n\nThe following two forms both upload a file.\n\n<%= form_with(url: {action: :upload}, multipart: true) do %> <%= file_field_tag 'picture' %> <% end %> <%= form_with model: @person do |f| %> <%= f.file_field :picture %> <% end %>\n\nRails provides the usual pair of helpers: the barebones file_field_tag and the model oriented file_field. As you would expect in the first case the uploaded file is in params[:picture] and in the second case in params[:person][:picture].\n\n5.1 What Gets Uploaded\n\nThe object in the params hash is an instance of ActionDispatch::Http::UploadedFile. The following snippet saves the uploaded file in #{Rails.root}/public/uploads under the same name as the original file.\n\ndef upload uploaded_file = params[:picture] File.open(Rails.root.join('public', 'uploads', uploaded_file.original_filename), 'wb') do |file| file.write(uploaded_file.read) end end\n\nOnce a file has been uploaded, there are a multitude of potential tasks, ranging from where to store the files (on Disk, Amazon S3, etc), associating them with models, resizing image files, and generating thumbnails, etc. Active Storage is designed to assist with these tasks.\n\n6 Customizing Form Builders\n\nThe object yielded by form_with and fields_for is an instance of ActionView::Helpers::FormBuilder. Form builders encapsulate the notion of displaying form elements for a single object. While you can write helpers for your forms in the usual way, you can also create subclass ActionView::Helpers::FormBuilder and add the helpers there. For example:\n\n<%= form_with model: @person do |f| %> <%= text_field_with_label f, :first_name %> <% end %>\n\ncan be replaced with\n\n<%= form_with model: @person, builder: LabellingFormBuilder do |f| %> <%= f.text_field :first_name %> <% end %>\n\nby defining a LabellingFormBuilder class similar to the following:\n\nclass LabellingFormBuilder < ActionView::Helpers::FormBuilder def text_field(attribute, options={}) label(attribute) + super end end\n\nIf you reuse this frequently you could define a labeled_form_with helper that automatically applies the builder: LabellingFormBuilder option:\n\ndef labeled_form_with(model: nil, scope: nil, url: nil, format: nil, **options, &block) options.merge! builder: LabellingFormBuilder form_with model: model, scope: scope, url: url, format: format, **options, &block end\n\nThe form builder used also determines what happens when you do\n\n<%= render partial: f %>\n\nIf f is an instance of ActionView::Helpers::FormBuilder then this will render the form partial, setting the partial's object to the form builder. If the form builder is of class LabellingFormBuilder then the labelling_form partial would be rendered instead.\n\n7 Understanding Parameter Naming Conventions\n\nValues from forms can be at the top level of the params hash or nested in another hash. For example, in a standard create action for a Person model, params[:person] would usually be a hash of all the attributes for the person to create. The params hash can also contain arrays, arrays of hashes, and so on.\n\nFundamentally HTML forms don't know about any sort of structured data, all they generate is name-value pairs, where pairs are just plain strings. The arrays and hashes you see in your application are the result of some parameter naming conventions that Rails uses.\n\n7.1 Basic Structures\n\nThe two basic structures are arrays and hashes. Hashes mirror the syntax used for accessing the value in params. For example, if a form contains:\n\n<input id=\"person_name\" name=\"person[name]\" type=\"text\" value=\"Henry\"/>\n\nthe params hash will contain\n\n{'person' => {'name' => 'Henry'}}\n\nand params[:person][:name] will retrieve the submitted value in the controller.\n\nHashes can be nested as many levels as required, for example:\n\n<input id=\"person_address_city\" name=\"person[address][city]\" type=\"text\" value=\"New York\"/>\n\nwill result in the params hash being\n\n{'person' => {'address' => {'city' => 'New York'}}}\n\nNormally Rails ignores duplicate parameter names. If the parameter name contains an empty set of square brackets [] then they will be accumulated in an array. If you wanted users to be able to input multiple phone numbers, you could place this in the form:\n\n<input name=\"person[phone_number][]\" type=\"text\"/> <input name=\"person[phone_number][]\" type=\"text\"/> <input name=\"person[phone_number][]\" type=\"text\"/>\n\nThis would result in params[:person][:phone_number] being an array containing the inputted phone numbers.\n\n7.2 Combining Them\n\nWe can mix and match these two concepts. One element of a hash might be an array as in the previous example, or you can have an array of hashes. For example, a form might let you create any number of addresses by repeating the following form fragment\n\n<input name=\"person[addresses][][line1]\" type=\"text\"/> <input name=\"person[addresses][][line2]\" type=\"text\"/> <input name=\"person[addresses][][city]\" type=\"text\"/> <input name=\"person[addresses][][line1]\" type=\"text\"/> <input name=\"person[addresses][][line2]\" type=\"text\"/> <input name=\"person[addresses][][city]\" type=\"text\"/>\n\nThis would result in params[:person][:addresses] being an array of hashes with keys line1, line2, and city.\n\nThere's a restriction, however, while hashes can be nested arbitrarily, only one level of \"arrayness\" is allowed. Arrays can usually be replaced by hashes; for example, instead of having an array of model objects, one can have a hash of model objects keyed by their id, an array index, or some other parameter.\n\n7.3 Using Form Helpers\n\nThe previous sections did not use the Rails form helpers at all. While you can craft the input names yourself and pass them directly to helpers such as text_field_tag Rails also provides higher level support. The two tools at your disposal here are the name parameter to form_with and fields_for and the :index option that helpers take.\n\nYou might want to render a form with a set of edit fields for each of a person's addresses. For example:\n\n<%= form_with model: @person do |person_form| %> <%= person_form.text_field :name %> <% @person.addresses.each do |address| %> <%= person_form.fields_for address, index: address.id do |address_form| %> <%= address_form.text_field :city %> <% end %> <% end %> <% end %>\n\nAssuming the person had two addresses, with ids 23 and 45 this would create output similar to this:\n\n<form accept-charset=\"UTF-8\" action=\"/people/1\" data-remote=\"true\" method=\"post\"> <input name=\"_method\" type=\"hidden\" value=\"patch\" /> <input id=\"person_name\" name=\"person[name]\" type=\"text\" /> <input id=\"person_address_23_city\" name=\"person[address][23][city]\" type=\"text\" /> <input id=\"person_address_45_city\" name=\"person[address][45][city]\" type=\"text\" /> </form>\n\nThis will result in a params hash that looks like\n\n{'person' => {'name' => 'Bob', 'address' => {'23' => {'city' => 'Paris'}, '45' => {'city' => 'London'}}}}\n\nRails knows that all these inputs should be part of the person hash because you called fields_for on the first form builder. By specifying an :index option you're telling Rails that instead of naming the inputs person[address][city] it should insert that index surrounded by [] between the address and the city. This is often useful as it is then easy to locate which Address record should be modified. You can pass numbers with some other significance, strings or even nil (which will result in an array parameter being created).\n\nTo create more intricate nestings, you can specify the first part of the input name (person[address] in the previous example) explicitly:\n\n<%= fields_for 'person[address][primary]', address, index: address.id do |address_form| %> <%= address_form.text_field :city %> <% end %>\n\nwill create inputs like\n\n<input id=\"person_address_primary_1_city\" name=\"person[address][primary][1][city]\" type=\"text\" value=\"Bologna\" />\n\nAs a general rule the final input name is the concatenation of the name given to fields_for/form_with, the index value, and the name of the attribute. You can also pass an :index option directly to helpers such as text_field, but it is usually less repetitive to specify this at the form builder level rather than on individual input controls.\n\nAs a shortcut you can append [] to the name and omit the :index option. This is the same as specifying index: address.id so\n\n<%= fields_for 'person[address][primary][]', address do |address_form| %> <%= address_form.text_field :city %> <% end %>\n\nproduces exactly the same output as the previous example.\n\n8 Forms to External Resources\n\nRails' form helpers can also be used to build a form for posting data to an external resource. However, at times it can be necessary to set an authenticity_token for the resource; this can be done by passing an authenticity_token: 'your_external_token' parameter to the form_with options:\n\n<%= form_with url: 'http://farfar.away/form', authenticity_token: 'external_token' do %> Form contents <% end %>\n\nSometimes when submitting data to an external resource, like a payment gateway, the fields that can be used in the form are limited by an external API and it may be undesirable to generate an authenticity_token. To not send a token, simply pass false to the :authenticity_token option:\n\n<%= form_with url: 'http://farfar.away/form', authenticity_token: false do %> Form contents <% end %>\n\n9 Building Complex Forms\n\nMany apps grow beyond simple forms editing a single object. For example, when creating a Person you might want to allow the user to (on the same form) create multiple address records (home, work, etc.). When later editing that person the user should be able to add, remove, or amend addresses as necessary.\n\n9.1 Configuring the Model\n\nActive Record provides model level support via the accepts_nested_attributes_for method:\n\nclass Person < ApplicationRecord has_many :addresses, inverse_of: :person accepts_nested_attributes_for :addresses end class Address < ApplicationRecord belongs_to :person end\n\nThis creates an addresses_attributes= method on Person that allows you to create, update, and (optionally) destroy addresses.\n\n9.2 Nested Forms\n\nThe following form allows a user to create a Person and its associated addresses.\n\n<%= form_with model: @person do |f| %> Addresses: <ul> <%= f.fields_for :addresses do |addresses_form| %> <li> <%= addresses_form.label :kind %> <%= addresses_form.text_field :kind %> <%= addresses_form.label :street %> <%= addresses_form.text_field :street %> ... </li> <% end %> </ul> <% end %>\n\nWhen an association accepts nested attributes fields_for renders its block once for every element of the association. In particular, if a person has no addresses it renders nothing. A common pattern is for the controller to build one or more empty children so that at least one set of fields is shown to the user. The example below would result in 2 sets of address fields being rendered on the new person form.\n\ndef new @person = Person.new 2.times { @person.addresses.build } end\n\nThe fields_for yields a form builder. The parameters' name will be what accepts_nested_attributes_for expects. For example, when creating a user with 2 addresses, the submitted parameters would look like:\n\n{ 'person' => { 'name' => 'John Doe', 'addresses_attributes' => { '0' => { 'kind' => 'Home', 'street' => '221b Baker Street' }, '1' => { 'kind' => 'Office', 'street' => '31 Spooner Street' } } } }\n\nThe keys of the :addresses_attributes hash are unimportant, they need merely be different for each address.\n\nIf the associated object is already saved, fields_for autogenerates a hidden input with the id of the saved record. You can disable this by passing include_id: false to fields_for.\n\n9.3 The Controller\n\nAs usual you need to declare the permitted parameters in the controller before you pass them to the model:\n\ndef create @person = Person.new(person_params) # ... end private def person_params params.require(:person).permit(:name, addresses_attributes: [:id, :kind, :street]) end\n\n9.4 Removing Objects\n\nYou can allow users to delete associated objects by passing allow_destroy: true to accepts_nested_attributes_for\n\nclass Person < ApplicationRecord has_many :addresses accepts_nested_attributes_for :addresses, allow_destroy: true end\n\nIf the hash of attributes for an object contains the key _destroy with a value that evaluates to true (eg. 1, '1', true, or 'true') then the object will be destroyed. This form allows users to remove addresses:\n\n<%= form_with model: @person do |f| %> Addresses: <ul> <%= f.fields_for :addresses do |addresses_form| %> <li> <%= addresses_form.check_box :_destroy %> <%= addresses_form.label :kind %> <%= addresses_form.text_field :kind %> ... </li> <% end %> </ul> <% end %>\n\nDon't forget to update the permitted params in your controller to also include the _destroy field:\n\ndef person_params params.require(:person). permit(:name, addresses_attributes: [:id, :kind, :street, :_destroy]) end\n\n9.5 Preventing Empty Records\n\nIt is often useful to ignore sets of fields that the user has not filled in. You can control this by passing a :reject_if proc to accepts_nested_attributes_for. This proc will be called with each hash of attributes submitted by the form. If the proc returns false then Active Record will not build an associated object for that hash. The example below only tries to build an address if the kind attribute is set.\n\nclass Person < ApplicationRecord has_many :addresses accepts_nested_attributes_for :addresses, reject_if: lambda {|attributes| attributes['kind'].blank?} end\n\nAs a convenience you can instead pass the symbol :all_blank which will create a proc that will reject records where all the attributes are blank excluding any value for _destroy.\n\n9.6 Adding Fields on the Fly\n\nRather than rendering multiple sets of fields ahead of time you may wish to add them only when a user clicks on an 'Add new address' button. Rails does not provide any built-in support for this. When generating new sets of fields you must ensure the key of the associated array is unique - the current JavaScript date (milliseconds since the epoch) is a common choice.\n\n10 Using form_for and form_tag\n\nBefore form_with was introduced in Rails 5.1 its functionality used to be split between form_tag and form_for. Both are now soft-deprecated. Documentation on their usage can be found in older versions of this guide.\n\nFeedback\n\nYou're encouraged to help improve the quality of this guide.\n\nPlease contribute if you see any typos or factual errors. To get started, you can read our documentation contributions section.\n\nYou may also find incomplete content or stuff that is not up to date. Please do add any missing documentation for main. Make sure to check Edge Guides first to verify if the issues are already fixed or not on the main branch. Check the Ruby on Rails Guides Guidelines for style and conventions.\n\nIf for whatever reason you spot something to fix but cannot patch it yourself, please open an issue."
    }
}