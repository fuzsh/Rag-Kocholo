{
    "id": "dbpedia_2924_3",
    "rank": 60,
    "data": {
        "url": "https://docs.astropy.org/en/stable/io/fits/usage/table.html",
        "read_more_link": "",
        "language": "en",
        "title": "Table Data — Astropy v6.1.1",
        "top_image": "https://docs.astropy.org/en/stable/_static/astropy_logo.ico",
        "meta_img": "https://docs.astropy.org/en/stable/_static/astropy_logo.ico",
        "images": [
            "https://docs.astropy.org/en/stable/_static/astropy_banner_96.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../../../_static/astropy_logo.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Examples#\n\nTo merge the column definitions of the input tables:\n\n>>> fits_other_table_filename = fits.util.get_testdata_filepath('table.fits') >>> with fits.open(fits_table_filename) as hdul1: ... with fits.open(fits_other_table_filename) as hdul2: ... new_columns = hdul1[1].columns + hdul2[1].columns ... new_hdu = fits.BinTableHDU.from_columns(new_columns) >>> new_columns ColDefs( name = 'order'; format = 'I' name = 'name'; format = '20A' name = 'mag'; format = 'E' name = 'Sp'; format = '10A' name = 'target'; format = '20A' name = 'V_mag'; format = 'E' )\n\nThe number of fields in the output table will be the sum of numbers of fields of the input tables. Users have to make sure the input tables do not share any common field names. The number of records in the output table will be the largest number of records of all input tables. The expanded slots for the originally shorter table(s) will be zero (or blank) filled.\n\nAnother version of this example can be used to append a new column to a table. Updating an existing table with a new column is generally more difficult than it is worth, but you can “append” a column to a table by creating a new table with columns from the existing table plus the new column(s):\n\n>>> with fits.open(fits_table_filename) as hdul: ... orig_table = hdul[1].data ... orig_cols = orig_table.columns >>> new_cols = fits.ColDefs([ ... fits.Column(name='NEWCOL1', format='D', ... array=np.zeros(len(orig_table))), ... fits.Column(name='NEWCOL2', format='D', ... array=np.zeros(len(orig_table)))]) >>> hdu = fits.BinTableHDU.from_columns(orig_cols + new_cols)\n\nNow newtable.fits contains a new table with the original table, plus the two new columns filled with zeros.\n\nExamples#\n\nHere are a few Columns using various combinations of the optional arguments:\n\n>>> counts = np.array([312, 334, 308, 317]) >>> names = np.array(['NGC1', 'NGC2', 'NGC3', 'NGC4']) >>> values = np.arange(2*2*4).reshape(4, 2, 2) >>> col1 = fits.Column(name='target', format='10A', array=names) >>> col2 = fits.Column(name='counts', format='J', unit='count', array=counts) >>> col3 = fits.Column(name='notes', format='A10') >>> col4 = fits.Column(name='spectrum', format='10E') >>> col5 = fits.Column(name='flag', format='L', array=[True, False, True, True]) >>> col6 = fits.Column(name='intarray', format='4I', dim='(2, 2)', array=values)\n\nIn this example, formats are specified with the FITS letter codes. When there is a number (>1) preceding a (numeric type) letter code, it means each cell in that field is a one-dimensional array. In the case of column “col4”, each cell is an array (a NumPy array) of 10 elements. And in the case of column “col6”, with the use of the “dim” argument, each cell is a multi-dimensional array of 2x2 elements.\n\nFor character string fields, the number should be to the left of the letter ‘A’ when creating binary tables, and should be to the right when creating ASCII tables. However, as this is a common confusion, both formats are understood when creating binary tables (note, however, that upon writing to a file the correct format will be written in the header). So, for columns “col1” and “col3”, they both have 10 characters in each of their cells. For numeric data type, the dimension number must be before the letter code, not after.\n\nAfter the columns are constructed, the BinTableHDU.from_columns() class method can be used to construct a table HDU. We can either go through the column definition object:\n\n>>> coldefs = fits.ColDefs([col1, col2, col3, col4, col5, col6]) >>> hdu = fits.BinTableHDU.from_columns(coldefs) >>> coldefs ColDefs( name = 'target'; format = '10A' name = 'counts'; format = 'J'; unit = 'count' name = 'notes'; format = '10A' name = 'spectrum'; format = '10E' name = 'flag'; format = 'L' name = 'intarray'; format = '4I'; dim = '(2, 2)' )\n\nor directly use the BinTableHDU.from_columns() method:\n\n>>> hdu = fits.BinTableHDU.from_columns([col1, col2, col3, col4, col5, col6]) >>> hdu.columns ColDefs( name = 'target'; format = '10A' name = 'counts'; format = 'J'; unit = 'count' name = 'notes'; format = '10A' name = 'spectrum'; format = '10E' name = 'flag'; format = 'L' name = 'intarray'; format = '4I'; dim = '(2, 2)' )\n\nNote\n\nUsers familiar with older versions of astropy will wonder what happened to astropy.io.fits.new_table. BinTableHDU.from_columns() and its companion for ASCII tables TableHDU.from_columns() are the same in the arguments they accept and their behavior, but make it more explicit as to what type of table HDU they create.\n\nA look at the newly created HDU’s header will show that relevant keywords are properly populated:\n\n>>> hdu.header XTENSION= 'BINTABLE' / binary table extension BITPIX = 8 / array data type NAXIS = 2 / number of array dimensions NAXIS1 = 73 / length of dimension 1 NAXIS2 = 4 / length of dimension 2 PCOUNT = 0 / number of group parameters GCOUNT = 1 / number of groups TFIELDS = 6 / number of table fields TTYPE1 = 'target ' TFORM1 = '10A ' TTYPE2 = 'counts ' TFORM2 = 'J ' TUNIT2 = 'count ' TTYPE3 = 'notes ' TFORM3 = '10A ' TTYPE4 = 'spectrum' TFORM4 = '10E ' TTYPE5 = 'flag ' TFORM5 = 'L ' TTYPE6 = 'intarray' TFORM6 = '4I ' TDIM6 = '(2, 2) '\n\nWarning\n\nIt should be noted that when creating a new table with BinTableHDU.from_columns(), an in-memory copy of all of the input column arrays is created. This is because it is not guaranteed that the columns are arranged contiguously in memory in row-major order (in fact, they are most likely not), so they have to be combined into a new array.\n\nHowever, if the array data is already contiguous in memory, such as in an existing record array, a kludge can be used to create a new table HDU without any copying. First, create the Columns as before, but without using the array= argument:\n\n>>> col1 = fits.Column(name='target', format='10A')\n\nThen call BinTableHDU.from_columns():\n\n>>> hdu = fits.BinTableHDU.from_columns([col1, col2, col3, col4, col5])\n\nThis will create a new table HDU as before, with the correct column definitions, but an empty data section. Now you can assign your array directly to the HDU’s data attribute:\n\n>>> hdu.data = mydata\n\nIn a future version of astropy, table creation will be simplified and this process will not be necessary."
    }
}