{
    "id": "wrong_mix_property_foundationPlace_00119_2",
    "rank": 65,
    "data": {
        "url": "https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html",
        "read_more_link": "",
        "language": "en",
        "title": "letter queues in Amazon SQS",
        "top_image": "https://docs.aws.amazon.com/assets/images/favicon.ico",
        "meta_img": "https://docs.aws.amazon.com/assets/images/favicon.ico",
        "images": [
            "https://d1ge0kk1l5kms0.cloudfront.net/images/G/01/webservices/console/warning.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Queue message identifiers",
            "message metadata",
            "queue pagination",
            "cost allocation tags",
            "dead letter queues",
            "visibility timeout",
            "delay queues",
            "temporary queues",
            "message timers",
            "dead-letter queues",
            "DLQ",
            "message handling",
            "redrive",
            "unconsumed messages",
            "redrive policy",
            "MaxReceiveCount",
            "resilience",
            "source queues",
            "message retention",
            "original queue",
            "FIFO queues",
            "best practices"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Learn about dead-letter queues, which serve as targets for messages that fail processing, aiding in application debugging by isolating unconsumed messages. Learn how to examine logs, analyze message contents, assess consumer processing time, and utilize dead-letter queue redrive for managing message flow effectively",
        "meta_lang": "en",
        "meta_favicon": "/assets/images/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://docs.aws.amazon.com/AWSSimpleQueueService/latest/SQSDeveloperGuide/sqs-dead-letter-queues.html",
        "text": "Using dead-letter queues in Amazon SQS\n\nAmazon SQS supports dead-letter queues (DLQs), which source queues can target for messages that are not processed successfully. DLQs are useful for debugging your application because you can isolate unconsumed messages to determine why processing did not succeed. For optimal performance, it is a best practice to keep the source queue and DLQ within the same AWS account and Region. Once messages are in a dead-letter queue, you can:\n\nYou must first create a new queue before configuring it as a dead-letter queue. For information about configuring a dead-letter queue using the Amazon SQS console, see Learn how to configure a dead-letter queue using the Amazon SQS console. For help with dead-letter queues, such as how to configure an alarm for any messages moved to a dead-letter queue, see Create alarms for dead-letter queues using Amazon CloudWatch.\n\nUsing policies for dead-letter queues\n\nUse a redrive policy to specify the maxReceiveCount. The maxReceiveCount is the number of times a consumer can receive a message from a source queue before it is moved to a dead-letter queue. For example, if the maxReceiveCount is set to a low value such as 1, one failure to receive a message would cause the message to move to the dead-letter queue. To ensure that your system is resilient against errors, set the maxReceiveCount high enough to allow for sufficient retries.\n\nThe redrive allow policy specifies which source queues can access the dead-letter queue. You can choose whether to allow all source queues, allow specific source queues, or deny all source queues use of the dead-letter queue. The default allows all source queues to use the dead-letter queue. If you choose to allow specific queues using the byQueue option, you can specify up to 10 source queues using the source queue Amazon Resource Name (ARN). If you specify denyAll, the queue cannot be used as a dead-letter queue.\n\nUnderstanding message retention periods for dead-letter queues\n\nFor standard queues, the expiration of a message is always based on its original enqueue timestamp. When a message is moved to a dead-letter queue, the enqueue timestamp is unchanged. The ApproximateAgeOfOldestMessage metric indicates when the message moved to the dead-letter queue, not when the message was originally sent. For example, assume that a message spends 1 day in the original queue before it's moved to a dead-letter queue. If the dead-letter queue's retention period is 4 days, the message is deleted from the dead-letter queue after 3 days and the ApproximateAgeOfOldestMessage is 3 days. Thus, it is a best practice to always set the retention period of a dead-letter queue to be longer than the retention period of the original queue."
    }
}