{
    "id": "dbpedia_2761_2",
    "rank": 45,
    "data": {
        "url": "http://fsprojects.github.io/FSharp.Data/library/CsvProvider.html",
        "read_more_link": "",
        "language": "en",
        "title": "CSV Type Provider",
        "top_image": "https://fsprojects.github.io/FSharp.Data/img/favicon.ico",
        "meta_img": "https://fsprojects.github.io/FSharp.Data/img/favicon.ico",
        "images": [
            "https://fsprojects.github.io/FSharp.Data/img/logo.png",
            "http://fsprojects.github.io/FSharp.Data/img/badge-binder.svg",
            "http://fsprojects.github.io/FSharp.Data/img/badge-script.svg",
            "http://fsprojects.github.io/FSharp.Data/img/badge-notebook.svg",
            "http://fsprojects.github.io/FSharp.Data/images/csv.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "FSharp.Data"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://fsprojects.github.io/FSharp.Data/img/favicon.ico",
        "meta_site_name": "FSharp.Data",
        "canonical_link": "https://fsprojects.github.io/FSharp.Data/library/CsvProvider.html",
        "text": "This article demonstrates how to use the CSV type provider to read CSV files in a statically typed way.\n\nThe CSV type provider takes a sample CSV as input and generates a type based on the data present on the columns of that sample. The column names are obtained from the first (header) row, and the types are inferred from the values present on the subsequent rows.\n\nIntroducing the provider\n\nThe type provider is located in the FSharp.Data.dll assembly. Assuming the package is referenged we can access its namespace as follows:\n\nopen FSharp.Data\n\nParsing stock prices\n\nThe Yahoo Finance web site provides daily stock prices in a CSV format that has the following structure (you can find a larger example in the data/MSFT.csv file):\n\nDate,Open,High,Low,Close,Volume,Adj Close 2012-01-27,29.45,29.53,29.17,29.23,44187700,29.23 2012-01-26,29.61,29.70,29.40,29.50,49102800,29.50 2012-01-25,29.07,29.65,29.07,29.56,59231700,29.56 2012-01-24,29.47,29.57,29.18,29.34,51703300,29.34\n\nAs usual with CSV files, the first row contains the headers (names of individual columns) and the next rows define the data. We can pass reference to the file to CsvProvider to get a strongly typed view of the file:\n\n[<Literal>] let ResolutionFolder = __SOURCE_DIRECTORY__ type Stocks = CsvProvider<\"../data/MSFT.csv\", =ResolutionFolder>\n\nThe generated type provides two static methods for loading data. The Parse method can be used if we have the data in a string value. The Load method allows reading the data from a file or from a web resource (and there's also an asynchronous AsyncLoad version). We could also have used a web URL instead of a local file in the sample parameter of the type provider. The following sample calls the Load method with an URL that points to a live CSV file on the Yahoo finance web site:\n\n// Download the stock prices let msft = Stocks .Load(__SOURCE_DIRECTORY__ + \"/../data/MSFT.csv\") .Cache() // Look at the most recent row. Note the 'Date' property // is of type 'DateTime' and 'Open' has a type 'decimal' let firstRow = msft.Rows |> Seq.head let lastDate = firstRow.Date let lastOpen = firstRow.Open // Print the first 10 prices in the HLOC format for in msft.Rows |> Seq.truncate 10 do \"HLOC: (%A, %A, %A, %A)\" .High .Low .Open .Close\n\nThe generated type has a property Rows that returns the data from the CSV file as a collection of rows. We iterate over the rows using a for loop. As you can see the (generated) type for rows has properties such as High, Low and Close that correspond to the columns in the CSV file.\n\nAs you can see, the type provider also infers types of individual rows. The Date property is inferred to be a DateTime (because the values in the sample file can all be parsed as dates) while HLOC prices are inferred as decimal.\n\nUsing units of measure\n\nThe CSV type provider supports F# units of measure: if the header includes the name or symbol of one of the standard SI units, then the generated type returns values annotated with the appropriate unit.\n\nIn this section, we use a simple file data/SmallTest.csv which looks as follows:\n\nAs you can see, the second and third columns are annotated with metre and s, respectively. To use units of measure in our code, we need to open the namespace with standard unit names. Then we pass the SmallTest.csv file to the type provider as a static argument. Also note that in this case we're using the same data at runtime, so we use the GetSample method instead of calling Load and passing the same parameter again.\n\nlet small = CsvProvider<\"../data/SmallTest.csv\", =ResolutionFolder>.GetSample ()\n\nval small: CsvProvider<...>\n\nWe can also use the default constructor instead of the GetSample static method:\n\nlet small2 = new CsvProvider<\"../data/SmallTest.csv\", =ResolutionFolder>()\n\nval small2: CsvProvider<...>\n\nbut the VisualStudio IntelliSense for the type provider parameters doesn't work when we use a default constructor for a type provider, so we'll keep using GetSample instead.\n\nAs in the previous example, the small value exposes the rows using the Rows property. The generated properties Distance and Time are now annotated with units. Look at the following simple calculation:\n\nopen FSharp.Data.UnitSystems.SI.UnitNames for in small.Rows do let = .Distance / .Time if > 15.0M<metre/second> then \"%s (%A m/s)\" .Name\n\nThe numerical values of Distance and Time are both inferred as decimal (because they are small enough). Thus the type of speed becomes decimal<metre/second>. The compiler can then statically check that we're not comparing incompatible values - e.g. number in meters per second against a value in kilometres per hour.\n\nCustom separators and tab-separated files\n\nBy default, the CSV type provider uses comma (,) as a separator. However, CSV files sometime use a different separator character than ,. In some European countries, , is already used as the numeric decimal separator, so a semicolon (;) is used instead to separate CSV columns. The CsvProvider has an optional Separators static parameter where you can specify what to use as separator. This means that you can consume any textual tabular format. Here is an example using ; as a separator:\n\ntype AirQuality = CsvProvider<\"../data/AirQuality.csv\", \";\", =ResolutionFolder> let airQuality = new AirQuality() for in airQuality.Rows |> Seq.truncate 10 do if .Month > 6 then \"Temp: %i Ozone: %f \" .Temp .Ozone\n\ntype AirQuality = CsvProvider<...> val airQuality: AirQuality val it: unit = ()\n\nThe air quality dataset (data/AirQuality.csv) is used in many samples for the Statistical Computing language R. A short description of the dataset can be found in the R language manual.\n\nIf you are parsing a tab-separated file that uses \\t as the separator, you can also specify the separator explicitly. However, if you're using an url or file that has the .tsv extension, the type provider will use \\t by default. In the following example, we also set IgnoreErrors static parameter to true so that lines with incorrect number of elements are automatically skipped (the sample file (data/MortalityNY.csv) contains additional unstructured data at the end):\n\nlet mortalityNy = CsvProvider<\"../data/MortalityNY.tsv\", =true, =ResolutionFolder>.GetSample () // Find the name of a cause based on code // (Pedal cyclist injured in an accident) let cause = mortalityNy.Rows |> Seq.find (fun -> .``Cause of death Code`` = \"V13.4\") // Print the number of injured cyclists \"CAUSE: %s\" cause.``Cause of death`` for in mortalityNy.Rows do if .``Cause of death Code`` = \"V13.4\" then \"%s (%d cases)\" .County .Count\n\nFinally, note that it is also possible to specify multiple different separators for the CsvProvider. This might be useful if a file is irregular and contains rows separated by either semicolon or a colon. You can use: CsvProvider<\"../data/AirQuality.csv\", Separators=\";,\", ResolutionFolder=ResolutionFolder>.\n\nMissing values\n\nIt is quite common in statistical datasets for some values to be missing. If you open the data/AirQuality.csv file you will see that some values for the ozone observations are marked #N/A. Such values are parsed as float and will be marked with Double.NaN in F#. The values NaN, NA, N/A, #N/A, :, -, TBA, and TBD are recognized as missing values by default, but you can customize it by specifying the MissingValues static parameter of CsvProvider as a comma-separated string. For example, to ignore this and that we could do:\n\nCsvProvider<\"X,Y,Z\\nthis,that,1.0\", =\"this,that\"> .GetSample() .Rows\n\nval it: CsvProvider<...>.Row seq = seq [(nan, nan, 1.0M)]\n\nThe following snippet calculates the mean of the ozone observations excluding the Double.NaN values. We first obtain the Ozone property for each row, then remove missing values and then use the standard Seq.average function:\n\nopen System let mean = airQuality.Rows |> Seq.toArray |> Array.map (fun -> .Ozone) |> Array.filter (fun -> (Double.IsNaN )) |> Array.average\n\nval mean: float = 42.12931034\n\nIf the sample doesn't have missing values on all columns, but at runtime missing values could appear anywhere, you can set the static parameter AssumeMissingValues to true in order to force CsvProvider to assume missing values can occur in any column.\n\nControlling the column types\n\nBy default, the CSV type provider checks the first 1000 rows to infer the types, but you can customize it by specifying the InferRows static parameter of CsvProvider. If you specify 0 the entire file will be used.\n\nColumns with only 0, 1, Yes, No, True, or False will be set to bool. Columns with numerical values will be set to either int, int64, decimal, or float, in that order of preference.\n\nIf a value is missing in any row, by default the CSV type provider will infer a nullable (for int and int64) or an optional (for bool, DateTime and Guid). When a decimal would be inferred but there are missing values, we will infer a float instead, and use Double.NaN to represent those missing values. The string type is already inherently nullable, so by default we won't generate a string option. If you prefer to use optionals in all cases, you can set the static parameter PreferOptionals to true. In that case you'll never get an empty string or a Double.NaN and will always get a None instead.\n\nIf you have other preferences, e.g. if you want a column to be a float instead of a decimal, you can override the default behaviour by specifying the types in the header column between braces, similar to what can be done to specify the units of measure. This will override both AssumeMissingValues and PreferOptionals. The valid types are:\n\nint\n\nint?\n\nint option\n\nint64\n\nint64?\n\nint64 option\n\nbool\n\nbool?\n\nbool option\n\nfloat\n\nfloat?\n\nfloat option\n\ndecimal\n\ndecimal?\n\ndecimal option\n\ndate\n\ndate?\n\ndate option\n\ndatetimeoffset\n\ndatetimeoffset?\n\ndatetimeoffset option\n\nguid\n\nguid?\n\nguid option\n\nstring\n\nstring option.\n\nYou can also specify both the type and a unit (e.g float<metre>). Example:\n\nAdditionally, you can also specify some or all the types in the Schema static parameter of CsvProvider. Valid formats are:\n\nType\n\nType<Measure>\n\nName (Type)\n\nName (Type<Measure>)\n\nWhat's specified in the Schema static parameter will always take precedence to what's specified in the column headers.\n\nIf the first row of the file is not a header row, you can specify the HasHeaders static parameter to false in order to consider that row as a data row. In that case, the columns will be named Column1, Column2, etc..., unless the names are overridden using the Schema parameter. Note that you can override only the name in the Schema parameter and still have the provider infer the type for you. Example:\n\ntype OneTwoThree = CsvProvider<\"1,2,3\", =false, =\"Duration (float<second>),foo,float option\"> let csv = OneTwoThree.GetSample() for in csv.Rows do \"%f%d%f\" (.Duration / 1.0<second>) .Foo ( .Column3 1.0)\n\nYou don't need to override all the columns, you can skip the ones to leave as default. For example, in the titanic training dataset from Kaggle (data/Titanic.csv), if you want to rename the 3rd column (the PClass column) to Passenger Class and override the 6th column (the Fare column) to be a float instead of a decimal, you can define only that, and leave the other columns blank in the schema (you also don't need to add all the trailing commas).\n\ntype Titanic1 = CsvProvider<\"../data/Titanic.csv\", =\",,Passenger Class,,,float\", =ResolutionFolder> let titanic1 = Titanic1.GetSample() for in titanic1.Rows |> Seq.truncate 10 do \"%s Class = %d Fare = %g\" .Name .``Passenger Class`` .Fare\n\nAlternatively, you can rename and override the type of any column by name instead of by position:\n\ntype Titanic2 = CsvProvider<\"../data/Titanic.csv\", =\"Fare=float,PClass->Passenger Class\", =ResolutionFolder> let titanic2 = Titanic2.GetSample() for in titanic2.Rows |> Seq.truncate 10 do \"%s Class = %d Fare = %g\" .Name .``Passenger Class`` .Fare\n\nYou can even mix and match the two syntaxes like this Schema=\"int64,DidSurvive,PClass->Passenger Class=string\"\n\nTransforming CSV files\n\nIn addition to reading, CsvProvider also has support for transforming the row collection of CSV files. The operations available are Filter, Take, TakeWhile, Skip, SkipWhile, and Truncate. All these operations preserve the schema, so after transforming you can save the results by using one of the overloads of the Save method. You can also use the SaveToString() to get the output directly as a string.\n\n// Saving the first 10 rows that don't have missing values to a new csv file airQuality .Filter(fun -> (Double.IsNaN .Ozone) && (Double.IsNaN .``Solar.R``)) .Truncate(10) .SaveToString()\n\nIt's also possible to transform the columns themselves by using Map and the constructor for the Row type.\n\nlet doubleOzone = airQuality.Map(fun -> AirQuality.Row(.Ozone * 2.0, .``Solar.R``, .Wind, .Temp, .Month, .Day))\n\nval doubleOzone: Runtime.CsvFile<CsvProvider<...>.Row>\n\nYou can also append new rows, either by creating them directly as in the previous example, or by parsing them from a string.\n\nlet newRows = AirQuality.ParseRows( \"\"\"41;190;7.4;67;5;1 36;118;8;72;5;2\"\"\" ) let airQualityWithExtraRows = airQuality.Append newRows\n\nIt's even possible to create csv files without parsing at all:\n\ntype MyCsvType = CsvProvider<=\"A (int), B (string), C (date option)\", =false> let myRows = [ MyCsvType.Row(1, \"a\", None) MyCsvType.Row(2, \"B\", Some System.DateTime.Now) ] let myCsv = new MyCsvType(myRows) myCsv.SaveToString()\n\nHandling big datasets\n\nBy default, the rows are cached so you can iterate over the Rows property multiple times without worrying. But if you will only iterate once, you can disable caching by setting the CacheRows static parameter of CsvProvider to false. If the number of rows is very big, you have to do this otherwise you may exhaust the memory. You can still cache the data at some point by using the Cache method, but only do that if you have already transformed the dataset to be smaller.\n\nRelated articles\n\nUsing JSON provider in a library also applies to CSV type provider\n\nCSV Parser - provides more information about working with CSV documents dynamically.\n\nAPI Reference: CsvProvider type provider\n\n[<Literal>] val ResolutionFolder: string = \"D:\\a\\FSharp.Data\\FSharp.Data\\docs\\library\"\n\ntype Stocks = CsvProvider<...>\n\nval msft: Runtime.CsvFile<CsvProvider<...>.Row>\n\nval firstRow: CsvProvider<...>.Row\n\nmodule Seq from Microsoft.FSharp.Collections\n\nval head: source: 'T seq -> 'T\n\nval lastDate: System.DateTime\n\nproperty CsvProvider<...>.Row.Date: System.DateTime with get\n\nval lastOpen: decimal\n\nproperty CsvProvider<...>.Row.Open: decimal with get\n\nval row: CsvProvider<...>.Row\n\nval truncate: count: int -> source: 'T seq -> 'T seq\n\nval printfn: format: Printf.TextWriterFormat<'T> -> 'T\n\nproperty CsvProvider<...>.Row.High: decimal with get\n\nproperty CsvProvider<...>.Row.Low: decimal with get\n\nproperty CsvProvider<...>.Row.Close: decimal with get\n\nval small: CsvProvider<...>\n\nval small2: CsvProvider<...>\n\nnamespace Microsoft.FSharp.Data.UnitSystems\n\nnamespace Microsoft.FSharp.Data.UnitSystems.SI\n\nnamespace Microsoft.FSharp.Data.UnitSystems.SI.UnitNames\n\nval speed: decimal<metre/UnitSystems.SI.UnitSymbols.s>\n\nproperty CsvProvider<...>.Row.Distance: decimal<metre> with get\n\nproperty CsvProvider<...>.Row.Time: decimal<UnitSystems.SI.UnitSymbols.s> with get\n\n[<Measure>] type metre\n\n[<Measure>] type second\n\nproperty CsvProvider<...>.Row.Name: string with get\n\ntype AirQuality = CsvProvider<...>\n\nval airQuality: AirQuality\n\nproperty CsvProvider<...>.Row.Month: int with get\n\nproperty CsvProvider<...>.Row.Temp: int with get\n\nproperty CsvProvider<...>.Row.Ozone: float with get\n\nval mortalityNy: CsvProvider<...>\n\nval cause: CsvProvider<...>.Row\n\nval find: predicate: ('T -> bool) -> source: 'T seq -> 'T\n\nval r: CsvProvider<...>.Row\n\nproperty CsvProvider<...>.Row.County: string with get\n\nproperty CsvProvider<...>.Row.Count: int with get\n\nnamespace System\n\nval mean: float\n\nval toArray: source: 'T seq -> 'T array\n\nval map: mapping: ('T -> 'U) -> array: 'T array -> 'U array\n\nval filter: predicate: ('T -> bool) -> array: 'T array -> 'T array\n\nval elem: float\n\nDouble.IsNaN(d: float) : bool\n\nval average: array: 'T array -> 'T (requires member (+) and member DivideByInt and member Zero)\n\ntype OneTwoThree = CsvProvider<...>\n\nval csv: CsvProvider<...>\n\nCsvProvider<...>.GetSample() : CsvProvider<...>\n\nproperty CsvProvider<...>.Row.Duration: float<second> with get\n\nproperty CsvProvider<...>.Row.Foo: int with get\n\nval defaultArg: arg: 'T option -> defaultValue: 'T -> 'T\n\nproperty CsvProvider<...>.Row.Column3: Option<float> with get\n\ntype Titanic1 = CsvProvider<...>\n\nval titanic1: CsvProvider<...>\n\nproperty CsvProvider<...>.Row.Fare: decimal with get\n\ntype Titanic2 = CsvProvider<...>\n\nval titanic2: CsvProvider<...>\n\nproperty CsvProvider<...>.Row.Fare: float with get\n\nval doubleOzone: Runtime.CsvFile<CsvProvider<...>.Row>\n\nmember Runtime.CsvFile.Map: mapping: Func<'RowType,'RowType> -> Runtime.CsvFile<'RowType>\n\ntype Row = inherit float * float * decimal * int * int * int new: ozone: float * solarR: float * wind: decimal * temp: int * month: int * day: int -> Row member Day: int member Month: int member Ozone: float member ``Solar.R`` : float member Temp: int member Wind: decimal\n\nproperty CsvProvider<...>.Row.Wind: decimal with get\n\nproperty CsvProvider<...>.Row.Day: int with get\n\nval newRows: CsvProvider<...>.Row array\n\nCsvProvider<...>.ParseRows(text: string) : CsvProvider<...>.Row array\n\nval airQualityWithExtraRows: Runtime.CsvFile<CsvProvider<...>.Row>\n\nmember Runtime.CsvFile.Append: rows: 'RowType seq -> Runtime.CsvFile<'RowType>\n\ntype MyCsvType = CsvProvider<...>\n\nval myRows: CsvProvider<...>.Row list\n\ntype Row = inherit int * string * Option<DateTime> new: a: int * b: string * c: Option<DateTime> -> Row member A: int member B: string member C: Option<DateTime>\n\nunion case Option.None: Option<'T>\n\nunion case Option.Some: Value: 'T -> Option<'T>\n\nval myCsv: MyCsvType\n\nmember Runtime.CsvFile.SaveToString: [<Runtime.InteropServices.Optional>] ?separator: char * [<Runtime.InteropServices.Optional>] ?quote: char -> string"
    }
}