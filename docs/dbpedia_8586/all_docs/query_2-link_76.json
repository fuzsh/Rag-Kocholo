{
    "id": "dbpedia_8586_2",
    "rank": 76,
    "data": {
        "url": "https://andreyor.st/posts/2024-03-05-accepting-your-own-solutions-to-your-own-problems/",
        "read_more_link": "",
        "language": "en",
        "title": "Accepting your own solutions to your own problems",
        "top_image": "https://andreyor.st/me.jpg",
        "meta_img": "https://andreyor.st/me.jpg",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-03-05T00:00:00",
        "summary": "",
        "meta_description": "There was a weird thought going over and over in my head, regarding my Emacs configuration, and it extends to the other projects I do both at home and at work. You see, my configuration is riddled with custom code, and up until recently I had mixed feelings about that.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://andreyor.st/posts/2024-03-05-accepting-your-own-solutions-to-your-own-problems/",
        "text": "There was a weird thought going over and over in my head, regarding my Emacs configuration, and it extends to the other projects I do both at home and at work. You see, my configuration is riddled with custom code, and up until recently I had mixed feelings about that.\n\nFor example, I have a custom piece of code to automatically switch themes, based on the dark mode setting in my desktop environment. I do so via the DBUS interface:\n\nIt works perfectly fine for me, yet there’s a certain feeling I experience every time I see it in my configuration.\n\nOr, here’s another example, that kinda motivated me to write this post.\n\nWith the introduction of Tree-Sitter, Emacs now can use different parsers to provide syntax highlighting for certain modes. I use it with several modes, but the default experience is a bit rough because while there are functions to install grammars, they’re a bit inconvenient for general use. So to mitigate that, I made this function:\n\nI use it like this:\n\nAs you can see, this function handles everything from installing the grammar to remapping the major modes to use tree-sitter-backed ones, and also handles Org Mode source block languages.\n\nFinally, I have these packages, that I made over the years of using Emacs:\n\nThe isayt package automatically keeps the lisp code indented as I type, and the region-bindings package enables mappings while the region is active. Originally both these packages were just a part of my configuration, but the amount of code became a bit too big for my liking so I moved them into separate files, and uploaded them to GitLab.\n\nNow, why am I telling you all this, you might ask, and what it has to do with the title of this post?\n\nWell, you see, each example that I have shown you has a package that already does something like that.\n\nThe DBUS theme switching is handled by the auto-dark-emacs package, however, it also handles macOS, Termux, and Windows, while I only support my operating system of choice. Tree-Sitter is handled by the treesit-auto package, which covers much more languages than I am. For automatic indentation, there’s the aggressive-indent-mode which, unlike isayt, handles not only lisps, but other language modes as well. And the region-bindings package is basically a reimplementation of the region-bindings-mode package.\n\nSo why did I create all these things, even if there are solutions already available and used by the community?\n\nWell, I created isayt because I wasn’t satisfied with the timer-based approach of aggressive-indent-mode. It felt laggy. Moreover, I don’t really need this in any modes other than lisps. Lisp is structured, and indentation is semantic, so having it automatically adjust is nice. Other languages either can’t do that properly, while having semantic indentation (e.g. Python) or don’t really need it, because there’s no real benefit to having your code always shift around, as it doesn’t really represent a data structure.\n\nI made region-bindings because the original region-bindings-mode didn’t work properly with turned off transient-mark-mode (TMM). I don’t remember why I disabled it, perhaps after reading Mastering Emacs, or some other power-users note on how not having a visible region makes you more productive. In the end, I enabled TMM back, but the package already performed with fewer bugs than the region-bindings-mode so I decided to keep it.\n\nThe DBUS stuff is simple, really. At the time I wrote this code, I don’t think any packages did that. Now, it works fine, and I don’t see any reason to replace it with a package from someone else. It works, so don’t touch it. Moreover, I haven’t changed this piece of code ever since I wrote it (except for that time when the API changed in GNOME), and the auto-dark-mode is somehow constantly updated.\n\nFinally, I just don’t need support for all of the tree-sitter-based modes out there, so it’s fine for me to throw a small use-package form with a single call to my custom function.\n\nThere are many more examples of custom weird things I do in my configuration, like custom compilation modes with complicated filename handling. Or the mu4e context managing code based on some private data structures I defined to automate the process of adding new inboxes. I have a custom memoization macro and a piece of code that decides if I can scroll my window to the left. I wrote so much code for automating stuff for this very blog that I decided to move it into a separate package. Yet, there are still pieces spread across my init.el that are related to my blog workflow.\n\nI have a lot of custom code that is oriented to solve my problems and enhance my editing experience. After years, I learned to accept this kind of philosophy in programming - if you can solve your problem, and learn something new along the way, then do it. It doesn’t matter if the solution already exists. More often than not I’m frustrated with small annoyances of how many packages kinda do what I want, but also not exactly how I’d like to.\n\nThis also affected how I think about code in general. When faced with a problem I don’t want to reach to a library until I see that implementing a solution is either pointless, too complicated, and error-prone, or if I don’t have time to do that. Only then do I go and look for a library. I guess, I’m lucky to code in Clojure at work, as the language has a lot of useful features, making it often unnecessary to search for a library to do something. In other languages, the situation may be different.\n\nIt’s kinda the same in Emacs - the core has so much stuff that most of the time you don’t need any extra packages. You just have to dig a bit, and you’ll probably find a function that solves your problem. Or can help you solve it.\n\nToday’s code is often complicated, and this complexity is justified by achieving so-called “reuse”.\n\nThis library is so general that you can reuse it in your very specific context! This code is so abstract that it is basically an art form!\n\nI don’t buy that anymore. The most reusable code is the one you can copy from one project and paste into another one, and just use it. Of course, copy-pasting is just a metaphor, we create a library with that code and use it in different projects. But the code in that library could as well just be copied, meaning there were no changes to that code to make it support multiple scenarios. And if you have to support multiple scenarios - just modify this code!\n\nThat was a bit of a tangent, but I feel that it applies to what I do in my Emacs configuration. A lot of Emacs packages are way too complicated because they have to support very specific cases that the author of a package might not even have. We became too afraid to take a piece of code and modify it to our needs ourselves. And Emacs actually gives you tools to do that - the hooks, and the advice system. I advice a lot of stuff in my Emacs configuration, and I’m glad that this system is there and that it works in such a robust way that it allows me to do crazy stuff without fear that it’ll break. And if it breaks, I’ll just fix it.\n\nIt’s a fine solution."
    }
}