{
    "id": "dbpedia_8586_3",
    "rank": 24,
    "data": {
        "url": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/language",
        "read_more_link": "",
        "language": "en",
        "title": "Compiler Options - language feature rules - C# reference",
        "top_image": "https://learn.microsoft.com/dotnet/media/logo_csharp.png",
        "meta_img": "https://learn.microsoft.com/dotnet/media/logo_csharp.png",
        "images": [
            "https://learn.microsoft.com/media/logos/logo_net.svg",
            "https://learn.microsoft.com/media/logos/logo_net.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2023-11-01T10:51:00+00:00",
        "summary": "",
        "meta_description": "C# Compiler Options for language feature rules. These options control how the compiler interprets certain language constructs.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://learn.microsoft.com/en-us/dotnet/csharp/language-reference/compiler-options/language",
        "text": "C# Compiler Options for language feature rules\n\nThe following options control how the compiler interprets language features. The new MSBuild syntax is shown in Bold. The older csc.exe syntax is shown in code style.\n\nCheckForOverflowUnderflow / -checked: Generate overflow checks.\n\nAllowUnsafeBlocks / -unsafe: Allow 'unsafe' code.\n\nDefineConstants / -define: Define conditional compilation symbol(s).\n\nLangVersion / -langversion: Specify language version such as default (latest major version), or latest (latest version, including minor versions).\n\nNullable / -nullable: Enable nullable context, or nullable warnings.\n\nCheckForOverflowUnderflow\n\nThe CheckForOverflowUnderflow option controls the default overflow-checking context that defines the program behavior if integer arithmetic overflows.\n\n<CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>\n\nWhen CheckForOverflowUnderflow is true, the default context is a checked context and overflow checking is enabled; otherwise, the default context is an unchecked context. The default value for this option is false, that is, overflow checking is disabled.\n\nYou can also explicitly control the overflow-checking context for the parts of your code by using the checked and unchecked statements.\n\nFor information about how the overflow-checking context affects operations and what operations are affected, see the article about checked and unchecked statements.\n\nAllowUnsafeBlocks\n\nThe AllowUnsafeBlocks compiler option allows code that uses the unsafe keyword to compile. The default value for this option is false, meaning unsafe code isn't allowed.\n\n<AllowUnsafeBlocks>true</AllowUnsafeBlocks>\n\nFor more information about unsafe code, see Unsafe Code and Pointers.\n\nDefineConstants\n\nThe DefineConstants option defines symbols in all source code files of your program.\n\n<DefineConstants>name;name2</DefineConstants>\n\nThis option specifies the names of one or more symbols that you want to define. The DefineConstants option has the same effect as the #define preprocessor directive except that the compiler option is in effect for all files in the project. A symbol remains defined in a source file until an #undef directive in the source file removes the definition. When you use the -define option, an #undef directive in one file has no effect on other source code files in the project. You can use symbols created by this option with #if, #else, #elif, and #endif to compile source files conditionally. The C# compiler itself defines no symbols or macros that you can use in your source code; all symbol definitions must be user-defined.\n\nLangVersion\n\nThe default language version for the C# compiler depends on the target framework for your application and the version of the SDK or Visual Studio installed. Those rules are defined in C# language versioning.\n\nThe LangVersion option causes the compiler to accept only syntax that is included in the specified C# language specification, for example:\n\n<LangVersion>9.0</LangVersion>\n\nThe following values are valid:\n\nValue Meaning preview The compiler accepts all valid language syntax from the latest preview version. latest The compiler accepts syntax from the latest released version of the compiler (including minor version). latestMajor\n\nor default The compiler accepts syntax from the latest released major version of the compiler. 13.0 The compiler accepts only syntax that is included in C# 13 or lower. 12.0 The compiler accepts only syntax that is included in C# 12 or lower. 11.0 The compiler accepts only syntax that is included in C# 11 or lower. 10.0 The compiler accepts only syntax that is included in C# 10 or lower. 9.0 The compiler accepts only syntax that is included in C# 9 or lower. 8.0 The compiler accepts only syntax that is included in C# 8.0 or lower. 7.3 The compiler accepts only syntax that is included in C# 7.3 or lower. 7.2 The compiler accepts only syntax that is included in C# 7.2 or lower. 7.1 The compiler accepts only syntax that is included in C# 7.1 or lower. 7 The compiler accepts only syntax that is included in C# 7.0 or lower. 6 The compiler accepts only syntax that is included in C# 6.0 or lower. 5 The compiler accepts only syntax that is included in C# 5.0 or lower. 4 The compiler accepts only syntax that is included in C# 4.0 or lower. 3 The compiler accepts only syntax that is included in C# 3.0 or lower. ISO-2\n\nor 2 The compiler accepts only syntax that is included in ISO/IEC 23270:2006 C# (2.0). ISO-1\n\nor 1 The compiler accepts only syntax that is included in ISO/IEC 23270:2003 C# (1.0/1.2).\n\nConsiderations\n\nTo ensure that your project uses the default compiler version recommended for your target framework, don't use the LangVersion option. You can update the target framework to access newer language features.\n\nSpecifying LangVersion with the default value is different from omitting the LangVersion option. Specifying default uses the latest version of the language that the compiler supports, without taking into account the target framework. For example, building a project that targets .NET 6 from Visual Studio version 17.6 uses C# 10 if LangVersion isn't specified, but uses C# 11 if LangVersion is set to default.\n\nMetadata referenced by your C# application isn't subject to the LangVersion compiler option.\n\nBecause each version of the C# compiler contains extensions to the language specification, LangVersion doesn't give you the equivalent functionality of an earlier version of the compiler.\n\nWhile C# version updates generally coincide with major .NET releases, the new syntax and features aren't necessarily tied to that specific framework version. Each specific feature has its own minimum .NET API or common language runtime requirements that may allow it to run on downlevel frameworks by including NuGet packages or other libraries.\n\nRegardless of which LangVersion setting you use, use the current version of the common language runtime to create your .exe or .dll. One exception is friend assemblies and ModuleAssemblyName, which work under -langversion:ISO-1.\n\nFor other ways to specify the C# language version, see C# language versioning.\n\nFor information about how to set this compiler option programmatically, see LanguageVersion.\n\nC# language specification\n\nVersion Link Description C# 8.0 and later download PDF C# Language Specification Version 7: .NET Foundation C# 7.3 download PDF Standard ECMA-334 7th Edition C# 6.0 download PDF Standard ECMA-334 6th Edition C# 5.0 Download PDF Standard ECMA-334 5th Edition C# 3.0 Download DOC C# Language Specification Version 3.0: Microsoft Corporation C# 2.0 Download PDF Standard ECMA-334 4th Edition C# 1.2 Download DOC Standard ECMA-334 2nd Edition C# 1.0 Download DOC Standard ECMA-334 1st Edition\n\nMinimum SDK version needed to support all language features\n\nThe following table lists the minimum versions of the SDK with the C# compiler that supports the corresponding language version:\n\nC# version Minimum SDK version C# 12 Microsoft Visual Studio/Build Tools 2022 version 17.8, or .NET 8 SDK C# 11 Microsoft Visual Studio/Build Tools 2022 version 17.4, or .NET 7 SDK C# 10 Microsoft Visual Studio/Build Tools 2022, or .NET 6 SDK C# 9.0 Microsoft Visual Studio/Build Tools 2019 version 16.8, or .NET 5 SDK C# 8.0 Microsoft Visual Studio/Build Tools 2019, version 16.3, or .NET Core 3.0 SDK C# 7.3 Microsoft Visual Studio/Build Tools 2017, version 15.7 C# 7.2 Microsoft Visual Studio/Build Tools 2017, version 15.5 C# 7.1 Microsoft Visual Studio/Build Tools 2017, version 15.3 C# 7.0 Microsoft Visual Studio/Build Tools 2017 C# 6 Microsoft Visual Studio/Build Tools 2015 C# 5 Microsoft Visual Studio/Build Tools 2012 or bundled .NET Framework 4.5 compiler C# 4 Microsoft Visual Studio/Build Tools 2010 or bundled .NET Framework 4.0 compiler C# 3 Microsoft Visual Studio/Build Tools 2008 or bundled .NET Framework 3.5 compiler C# 2 Microsoft Visual Studio/Build Tools 2005 or bundled .NET Framework 2.0 compiler C# 1.0/1.2 Microsoft Visual Studio/Build Tools .NET 2002 or bundled .NET Framework 1.0 compiler\n\nNullable\n\nThe Nullable option lets you specify the nullable context. It can be set in the project's configuration using the <Nullable> tag:\n\n<Nullable>enable</Nullable>\n\nThe argument must be one of enable, disable, warnings, or annotations. The enable argument enables the nullable context. Specifying disable will disable the nullable context. When you specify the warnings argument, the nullable warning context is enabled. When you specify the annotations argument, the nullable annotation context is enabled. The values are described and explained in the article on Nullable contexts. You can learn more about the tasks involved in enabling nullable reference types in an existing codebase in our article on nullable migration strategies.\n\nFlow analysis is used to infer the nullability of variables within executable code. The inferred nullability of a variable is independent of the variable's declared nullability. Method calls are analyzed even when they're conditionally omitted. For instance, Debug.Assert in release mode.\n\nInvocation of methods annotated with the following attributes will also affect flow analysis:"
    }
}