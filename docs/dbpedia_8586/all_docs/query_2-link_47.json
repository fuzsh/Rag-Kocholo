{
    "id": "dbpedia_8586_2",
    "rank": 47,
    "data": {
        "url": "https://spack.readthedocs.io/en/latest/build_systems/autotoolspackage.html",
        "read_more_link": "",
        "language": "en",
        "title": "Autotools — Spack 0.23.0.dev0 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://spack.readthedocs.io/en/latest/_static/spack-logo-white-text.svg",
            "https://spack.readthedocs.io/en/latest/_images/Autoconf-automake-process.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../_static/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Build system dependencies\n\nWhether or not your package requires Autotools to install depends on how the source code is distributed. Most of the time, when developers distribute tarballs, they will already contain the configure script necessary for installation. If this is the case, your package does not require any Autotools dependencies.\n\nHowever, a basic rule of version control systems is to never commit code that can be generated. The source code repository itself likely does not have a configure script. Developers typically write (or auto-generate) a configure.ac script that contains configuration preferences and a Makefile.am script that contains build instructions. Then, autoconf is used to convert configure.ac into configure, while automake is used to convert Makefile.am into Makefile.in. Makefile.in is used by configure to generate a platform-dependent Makefile for you. The following diagram provides a high-level overview of the process:\n\nIf a configure script is not present in your tarball, you will need to generate one yourself. Luckily, Spack already has an autoreconf phase to do most of the work for you. By default, the autoreconf phase runs:\n\n$ autoreconf --install --verbose --force -I <aclocal-prefix>/share/aclocal\n\nIn case you need to add more arguments, override autoreconf_extra_args in your package.py on class scope like this:\n\nautoreconf_extra_args = [\"-Im4\"]\n\nAll you need to do is add a few Autotools dependencies to the package. Most stable releases will come with a configure script, but if you check out a commit from the master branch, you would want to add:\n\ndepends_on(\"autoconf\", type=\"build\", when=\"@master\") depends_on(\"automake\", type=\"build\", when=\"@master\") depends_on(\"libtool\", type=\"build\", when=\"@master\")\n\nIt is typically redundant to list the m4 macro processor package as a dependency, since autoconf already depends on it.\n\nUsing a custom autoreconf phase\n\nIn some cases, it might be needed to replace the default implementation of the autoreconf phase with one running a script interpreter. In this example, the bash shell is used to run the autogen.sh script.\n\ndef autoreconf(self, spec, prefix): which(\"bash\")(\"autogen.sh\")\n\nIf the package.py has build instructions in a separate builder class, the signature for a phase changes slightly:\n\nclass AutotoolsBuilder(AutotoolsBuilder): def autoreconf(self, pkg, spec, prefix): which(\"bash\")(\"autogen.sh\")\n\npatching configure or Makefile.in files\n\nIn some cases, developers might need to distribute a patch that modifies one of the files used to generate configure or Makefile.in. In this case, these scripts will need to be regenerated. It is preferable to regenerate these manually using the patch, and then create a new patch that directly modifies configure. That way, Spack can use the secondary patch and additional build system dependencies aren’t necessary.\n\nforce_autoreconf\n\nIf for whatever reason you really want to add the original patch and tell Spack to regenerate configure, you can do so using the following setting:\n\nforce_autoreconf = True\n\nThis line tells Spack to wipe away the existing configure script and generate a new one. If you only need to do this for a single version, this can be done like so:\n\n@property def force_autoreconf(self): return self.version == Version(\"1.2.3\")\n\nHelper functions\n\nYou may have noticed that most of the Autotools flags are of the form --enable-foo, --disable-bar, --with-baz=<prefix>, or --without-baz. Since these flags are so common, Spack provides a couple of helper functions to make your life easier.\n\nenable_or_disable\n\nAutotools flags for simple boolean variants can be automatically generated by calling the enable_or_disable method. This is typically used to enable or disable some feature within the package.\n\nvariant( \"memchecker\", default=False, description=\"Memchecker support for debugging [degrades performance]\" ) config_args.extend(self.enable_or_disable(\"memchecker\"))\n\nIn this example, specifying the variant +memchecker will generate the following configuration options:\n\n--enable-memchecker\n\nwith_or_without\n\nAutotools flags for more complex variants, including boolean variants and multi-valued variants, can be automatically generated by calling the with_or_without method.\n\nvariant( \"schedulers\", values=disjoint_sets( (\"auto\",), (\"alps\", \"lsf\", \"tm\", \"slurm\", \"sge\", \"loadleveler\") ).with_non_feature_values(\"auto\", \"none\"), description=\"List of schedulers for which support is enabled; \" \"'auto' lets openmpi determine\", ) if not spec.satisfies(\"schedulers=auto\"): config_args.extend(self.with_or_without(\"schedulers\"))\n\nIn this example, specifying the variant schedulers=slurm,sge will generate the following configuration options:\n\n--with-slurm --with-sge\n\nenable_or_disable is actually functionally equivalent with with_or_without, and accepts the same arguments and variant types; but idiomatic autotools packages often follow these naming conventions.\n\nactivation_value\n\nAutotools parameters that require an option can still be automatically generated, using the activation_value argument to with_or_without (or, rarely, enable_or_disable).\n\nvariant( \"fabrics\", values=disjoint_sets( (\"auto\",), (\"psm\", \"psm2\", \"verbs\", \"mxm\", \"ucx\", \"libfabric\") ).with_non_feature_values(\"auto\", \"none\"), description=\"List of fabrics that are enabled; \" \"'auto' lets openmpi determine\", ) if not spec.satisfies(\"fabrics=auto\"): config_args.extend(self.with_or_without(\"fabrics\", activation_value=\"prefix\"))\n\nactivation_value accepts a callable that generates the configure parameter value given the variant value; but the special value prefix tells Spack to automatically use the dependenency’s installation prefix, which is the most common use for such parameters. In this example, specifying the variant fabrics=libfabric will generate the following configuration options:\n\n--with-libfabric=</path/to/libfabric>\n\nThe variant keyword\n\nWhen Spack variants and configure flags do not correspond one-to-one, the variant keyword can be passed to with_or_without and enable_or_disable. For example:\n\nvariant(\"debug_tools\", default=False) config_args += self.enable_or_disable(\"debug-tools\", variant=\"debug_tools\")\n\nOr when one variant controls multiple flags:\n\nvariant(\"debug_tools\", default=False) config_args += self.with_or_without(\"memchecker\", variant=\"debug_tools\") config_args += self.with_or_without(\"profiler\", variant=\"debug_tools\")\n\nConditional variants\n\nWhen a variant is conditional and its condition is not met on the concrete spec, the with_or_without and enable_or_disable methods will simply return an empty list.\n\nFor example:\n\nvariant(\"profiler\", when=\"@2.0:\") config_args += self.with_or_without(\"profiler\")\n\nwill neither add --with-profiler nor --without-profiler when the version is below 2.0.\n\nActivation overrides\n\nFinally, the behavior of either with_or_without or enable_or_disable can be overridden for specific variant values. This is most useful for multi-values variants where some of the variant values require atypical behavior.\n\ndef with_or_without_verbs(self, activated): # Up through version 1.6, this option was named --with-openib. # In version 1.7, it was renamed to be --with-verbs. opt = \"verbs\" if self.spec.satisfies(\"@1.7:\") else \"openib\" if not activated: return f\"--without-{opt}\" return f\"--with-{opt}={self.spec['rdma-core'].prefix}\"\n\nDefining with_or_without_verbs overrides the behavior of a fabrics=verbs variant, changing the configure-time option to --with-openib for older versions of the package and specifying an alternative dependency name:\n\n--with-openib=</path/to/rdma-core>"
    }
}