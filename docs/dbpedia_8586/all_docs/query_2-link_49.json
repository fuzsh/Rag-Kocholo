{
    "id": "dbpedia_8586_2",
    "rank": 49,
    "data": {
        "url": "https://medium.com/agoda-engineering/automating-versioning-and-releases-using-semantic-release-6ed355ede742",
        "read_more_link": "",
        "language": "en",
        "title": "Automating Versioning and Releases Using Semantic Release",
        "top_image": "https://miro.medium.com/v2/resize:fit:1200/1*_XyzR-4n2k1yXM-O4n7sMw.jpeg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1200/1*_XyzR-4n2k1yXM-O4n7sMw.jpeg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*8q5aDRnVR14Mo_YVktfLBg.jpeg",
            "https://miro.medium.com/v2/resize:fill:48:48/1*RlfBLA66c56WySDq2YMdcA.jpeg",
            "https://miro.medium.com/v2/resize:fill:144:144/1*8q5aDRnVR14Mo_YVktfLBg.jpeg",
            "https://miro.medium.com/v2/resize:fill:64:64/1*RlfBLA66c56WySDq2YMdcA.jpeg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Yasser Shaikh",
            "yrshaikh.medium.com"
        ],
        "publish_date": "2021-02-22T05:53:36.767000+00:00",
        "summary": "",
        "meta_description": "Moving away from a manual (semi-automated), repetitive, error-prone process.",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/agoda-engineering/automating-versioning-and-releases-using-semantic-release-6ed355ede742",
        "text": "Over the last few years with Agoda, I have been working with the SEO team of our Frontend Department. The SEO team is responsible for building APIs & libraries that are used by other teams and many small to medium sized services that talk to each other.\n\nWith so many existing projects and new ones coming up all the time, we ended up having multiple ways of versioning and releasing them. Eventually more than often we found ourselves unable to answer the following questions\n\nDid we pick the right version number for our new release?\n\nDid we git tag correctly? Hopefully, using the same version number.\n\nDid we write a correct changelog? and so on‚Ä¶\n\nIt had been a manual (semi-automated), repetitive, error-prone process that one had to do every time there is a release in any of these projects and libraries maintained by us.\n\nSo last year we started looking into unifying and automating our release process and stumbled upon Semantic Release.\n\nWe had a checklist, that we wanted to automate and Semantic Release seemed to fit the bill. Our checklist ‚Äî\n\nCalculate the new version number based on the commit messages\n\nCreate git tags for every release\n\nPublish a release to GitHub releases & NuGet (package manager for .NET)\n\nCreate release notes & changelogs automatically\n\nNotify maintainers and users of new releases\n\nIn this post, I would like to discuss our experiences with trying out Semantic Release and how it has helped us better manage our versioning and release process.\n\nSemantic Versioning & Conventional Commits\n\nNow before we jump into Semantic Release, there are 2 important things to know\n\nSemantic Versioning\n\nConventional Commits\n\nLet‚Äôs briefly understand what these two are here,\n\nSemantic Versioning\n\nSemantic Versioning (also called SemVer) is a specification, a simple set of rules that dictates how version numbers of your projects are assigned and incremented.\n\nAs per this specification, any version number should be complying with this structure ‚Äî MAJOR.MINOR.PATCH where,\n\nMAJOR version is incremented when you make any breaking change\n\nMINOR version is incremented when you add a new feature/functionality\n\nPATCH version is incremented when you make bug fixes\n\nTo sum up what Semantic versioning does in one line-\n\nConventional Commits\n\nConventional commit is a specification, a set of rules that have to be followed when writing commit messages. It is heavily inspired by Angular commit guidelines, and follows this structure ‚Äî\n\nOnly type and description are mandatory, rest everything is optional. The value of type is important and needs to be only one of the following ‚Äî\n\nfeat: A new feature\n\nfix: A bug fix\n\ndocs: Documentation only changes\n\nstyle: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc)\n\nrefactor: A code change that neither fixes a bug nor adds a feature\n\nperf: A code change that improves performance\n\ntest: Adding missing or correcting existing tests\n\nchore: Changes to the build process or auxiliary tools and libraries such as documentation generation\n\nBelow are some sample commits made using this specification ‚Äî\n\nfeat(logging): added logs for failed signups\n\nfix(homepage): fixed image gallery\n\ntest(homepage): updated tests\n\ndocs(readme): added new logging table information\n\nThere are tools like commitlint and commitizen to help enforce these conventions in your projects. If you are interested, I have written a more in-depth post about it here ‚Äî Automate and enforce conventional commits for .NET based projects\n\nSemantic Release\n\nNow that we know what SemVer & Conventional commits are, I am sure most of you already have got a hint of what semantic-release does with these two ‚Äî\n\nsemantic-release uses the commit messages to determine the type of changes in the codebase. Following formalized conventions for commit messages, semantic-release automatically determines the next semantic version number, generates a changelog and publishes the release.\n\nBelow, in yellow are different commit message, pay close attention to the type and body of the commit messages and based on them either MAJOR/MINOR/PATCH version is incremented.\n\nIf the body contains the text ‚ÄúBREAKING CHANGE‚Äù then MAJOR version is incremented.\n\nIf the type contains feat/feature, then MINOR version is incremented.\n\nIf the type contains fix, then PATCH version is incremented.\n\nAnd finally, if the type contains refactor/style/perf/doc/test/chore, then nothing is increment and no release is made.\n\nYou can find more details about semantic release here ‚Äî https://github.com/semantic-release/semantic-release\n\nEnough with the theory now, next, we‚Äôll dive in to see of all this in ‚Äúaction‚Äù üòÑ.\n\nConfiguring Semantic Release with GitHub actions.\n\nConfiguring semantic-release with GitHub actions is pretty straightforward, I am using cycjimmy/semantic-release-action@v2 action which supports a wide variety of optional features via its plugins ‚Äî git, exec, and changelog.\n\npublish:\n\nneeds: [ build ]\n\nruns-on: ubuntu-lateststeps:\n\n- name: Checkout\n\nuses: actions/checkout@v1\n\n- name: Semantic Release\n\nuses: cycjimmy/semantic-release-action@v2\n\nwith:\n\nextra_plugins: |\n\n@semantic-release/git\n\n@semantic-release/exec\n\n@semantic-release/changelog\n\nThe semantic-release/exec plugin allows us to execute any custom shell commands at the different stages of semantic release i.e prepare ,publish , notify etc.\n\nmodule.exports = {\n\nbranches: ['main'],\n\n\"verifyConditions\": [\"@semantic-release/github\"],\n\n\"prepare\": // INSERT-CUSTOM-COMMANDS-HERE-TO-RUN-ON-PREPARE,\n\n\"publish\": // INSERT-CUSTOM-COMMANDS-HERE-TO-RUN-ON-PUBLISH,\n\n\"notify\": // INSERT-CUSTOM-COMMANDS-HERE-TO-RUN-ON-NOTIFY\n\n}\n\nHere is where I use we use the familiar dotnet build, pack, and push commands to push new releases to NuGet (package manager for .NET), the generated version number and other release details are made available and easy to use under ${nextRelease.xxx}. This section can be used for doing so much more, the possibilities are limitless here.\n\nRevisiting our checklist\n\nNow that we have managed to set up semantic release, we can now go back to our original checklist and see how we fared ‚Äî\n\n‚úÖ Calculate the new version number based on the commit messages\n\n‚úÖ Create git tags for every release\n\n‚úÖ Publish a release to GitHub releases & NuGet (package manager for .NET)\n\n‚úÖ Create release notes & changelogs automatically\n\n‚úÖ Notify maintainers and users of new releases\n\nSummary\n\nWe have been using Semantic Release for over a year now and actively adopting the same for our other projects. With few easy steps, we can automate the entire release process and focus more on the things that matter i.e code.\n\nI would strongly recommend giving semantic-release a try, there are loads of both official and community-built plugins, my personal favorite is this one ‚Äî semantic-release-slack-bot which sends a slack message whenever a new release is made. Now, how cool is that! üòé\n\nReferences\n\nhttps://semver.org/\n\nhttps://www.conventionalcommits.org/en/v1.0.0/\n\nhttps://github.com/semantic-release/semantic-release\n\nBig thanks to Agodans, who helped review this article: Vlad Batushkov, Olivier Grenado, Max Panasenkov, Akshesh Doshi, and Jonah Periera\n\nJoin the team"
    }
}