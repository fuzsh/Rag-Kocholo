{
    "id": "dbpedia_8586_3",
    "rank": 7,
    "data": {
        "url": "https://docs.veracode.com/r/compilation_java",
        "read_more_link": "",
        "language": "en",
        "title": "Java packaging",
        "top_image": "https://docs.veracode.com/img/veracode-favicon.png",
        "meta_img": "https://docs.veracode.com/img/veracode-favicon.png",
        "images": [
            "https://docs.veracode.com/img/Veracode_Docs_Logo_Light_Mode.svg",
            "https://docs.veracode.com/img/Veracode_Docs_Logo_Dark_Mode.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-08-09T08:59:46+00:00",
        "summary": "",
        "meta_description": "Your Java applications must meet specific packaging and compilation requirements before you can submit them for scanning.",
        "meta_lang": "en",
        "meta_favicon": "/img/veracode-favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://docs.veracode.com/r/compilation_java",
        "text": "Your Java applications must meet specific packaging and compilation requirements before you can submit them for scanning.\n\nSee Supported languages and platforms for instructions for other platforms.\n\nYou can analyze applications using Veracode Static Analysis or Veracode Software Composition Analysis (SCA) upload and scan, if licensed. For SCA agent-based scan requirements, see Using Veracode SCA with Programming Languages.\n\nAuto-packaging simplifies the packaging process for Java projects.\n\nWatch the tutorial.\n\nLanguagePlatformsSupported versionsCompilersJavaJava SE, Java EE, Jakarta, JSPJRE 1.4–1.9, 10–22JDK and OpenJDK 1.3–1.9\n\n10–22\n\nIBM JDK 1.7–1.8\n\nTomcat Jasper 7\n\nWebLogic 12.x\n\nVeracode can analyze Java code with or without debug symbols. Providing debug builds of Java application code allows Veracode to provide source file and line number information about the location of findings found. For a successful scan, you cannot obfuscate Java applications.\n\nYou may mitigate certain findings in code compiled with an earlier compiler version when you run that code on a another runtime environment later. In such cases, the finding descriptions contain a note describing the version dependency.\n\nFramework/TechnologySupported versionsNotesAdobe Experience Manager6.4 and earlierVeracode supports compiled Java code for Sling Servlets, OSGi services, and AEM custom components, packaged as a JAR file.Apache AxiomApache Axis1.xApache Axis21.6.2Apache Chemistry1.1.0Apache CommonsIncludes:\n\nCommons Attributes\n\nCommons BeanUtils\n\nCommons ClassScan\n\nCommons CLI\n\nCommons Codec\n\nCommons Collections\n\nCommons Collections4\n\nCommons Crypto\n\nCommons CSV\n\nCommons Daemon\n\nCommons DBCP\n\nCommons DbUtils\n\nCommons Discovery\n\nCommons Email\n\nCommons FileUpload-\n\nCommons Lang-\n\nCommons Lang 3\n\nCommons Logging\n\nCommons Net\n\nCommons Performance\n\nCommons Pool\n\nCommons ThreadPool\n\nCommons TextApache CXF2.7.0Veracode only supports the parts of CXF that expand JAX-WS.Apache Jersey2.xApache Oro2.xApache Log4j1.x, 2.xApache Velocity1.7Veracode only supports the web rendering usage of the default Velocity servlet for binaries uploaded in a WAR file.Apache Xerces2.xApache XMLBeans2.xAWS SDK for Java1.11, 2.0Azure Functions2.x, 3.xGoogle App Engine1.9.24Google Web Toolkit (GWT)2.8.0Hibernate1.x, 2.x, 3.x, 4.x, 5.xJava Portlets1.0, 2.0Java Servlets3.xJAX-RS1.x, 2.xJAX-WS2.xJAXB2.xJDBC4.2 and earlierJDOM1.xJSF1.x, 2.xJSTL1.xLiferay6.xVeracode does not support Liferay applications if you customize them using Hook plugins.Micronaut3.8.xPlay2.0–2.7.xQuarkus2.x, 3.xServlets3.xSpring Boot1.x, 2.x, 3.xSupports executable JARs, also known as Uber FAT JARs, and JARs with dependenciesSpring Core1.x, 2.x , 3.x, 4.x, 5.x, 6.xSpring Data Access5.xSpring MVC2.x, 3.x, 4.x, 5.xSpring Security3.x, 4.x, 5.x, 6.xStruts1.x, 2.xTiles2.x\n\nNameSupported versionsThymeleaf2.x, 3.x\n\nUsing the standard Java compiler, run the javac command with the -g option to obtain debug symbols, for example:\n\nIf you develop the project with Eclipse:\n\nGo to Project > Properties.\n\nSelect the Java compiler properties.\n\nUnder Classfile Generation, select these options:\n\nAdd variable attributes to generated class files\n\nAdd line number attributes to generated class files\n\nAdd source file name to generated class files\n\nIf you build the project using Maven, include a directive to use the Maven compiler plugin in pom.xml, for example:\n\nAfter making this change, use mvn compile or mvn package to build and package the project. The project now includes debug symbols with the application.\n\nVeracode SCA upload scans are more accurate when the Fat JAR files include the JAR files of the project dependencies. To ensure you package your applications to include the dependency JAR files, Veracode recommends you add the OneJar Maven Plugin or, for Spring Boot, the Maven Spring Boot Plugin in the <build><plugins/></build> element of pom.xml. For example:\n\nOneJar Maven Plugin\n\n<plugin>\n\n<groupId>com.jolira</groupId>\n\n<artifactId>onejar-maven-plugin</artifactId>\n\n<version>1.4.4</version>\n\n<executions>\n\n<execution>\n\n<goals>\n\n<goal>one-jar</goal>\n\n</goals>\n\n</execution>\n\n</executions>\n\n</plugin>\n\nMaven Spring Boot Plugin\n\n<plugin>\n\n<groupId>org.springframework.boot</groupId>\n\n<artifactId>spring-boot-maven-plugin</artifactId>\n\n<version>2.3.4.RELEASE</version>\n\n<executions>\n\n<execution>\n\n<goals>\n\n<goal>repackage</goal>\n\n</goals>\n\n</execution>\n\n</executions>\n\n</plugin>\n\nIf you use Gradle to build the project, after applying the Java plugin, configure the build task to add line numbers and local variables in the build.gradle file. For example:\n\nIf you build the project using Ant, you must enable the debug property in the javac tasks, for example:\n\nVeracode expects you to submit Java web applications in a standard WAR or EAR format. Specifically, the WAR file must contain these directories with these structures:\n\n/WEB-INF/\n\n/WEB-INF/classes/: contains all class files\n\n/WEB-INF/lib/: contains all supporting libraries\n\n/WEB-INF/web.xml\n\nTo determine the scope of analysis, Veracode examines the contents of the WAR or EAR file. Ensure that all classes that you want to analyze exist in either:\n\nThe /WEB-INF/classes directory\n\nA non-third party library in /WEB-INF/lib\n\nVeracode recommends that EAR files contain a /META-INF/application.xml file. If an EAR file does not contain any WAR files, you do not need to include the /WEB-INF/ directory or the /WEB-INF/web.xml file.\n\nFor more information on how to prepare a WAR file, see the Java EE tutorial.\n\nVeracode can scan JAR files that contain a web.xml file in /WEB-INF/. Veracode scans these JAR files the same as WAR files to improve support for application servers and packaging methods that manage this deployment method, including OSGi.\n\nVeracode SCA upload and scan only analyzes JAR, WAR, and EAR files. It ignores Java build files, such as pom.xml and build.gradle. To return Veracode SCA results, either include third-party JAR files in /WEB-INF/lib inside a WAR file or upload them in a separate JAR file.\n\nSee Packaging Spring Boot applications.\n\nVeracode extracts client-side JavaScript from JSP files that are uploaded as part of a JAR, WAR, or EAR file, and creates a separate JavaScript module that is selectable for analysis.\n\nVeracode automatically compiles uploaded JSP files before performing analysis on them. Veracode uses either the Tomcat Jasper compiler version 7 or the WebLogic compiler version 12.x for WebLogic applications.\n\nJSP files that are part of the application must be included in a correctly structured WAR or EAR file. Veracode appends JARs under the directory containing the WAR or EAR file and its subdirectories to the classpath of the JSP compiler. If JSP or other source files must undergo preprocessing during the build process, you must perform this preprocessing before you can submit files for a static scan. However, if artifacts contain precompiled JSP classes, ensure that you also include the source. Veracode does not analyze precompiled JSP files. Ensure that any JSP files that you generate from templates or components, such as include files, have compiled successfully before submission.\n\nAt compilation time, the Veracode compiler attempts to force expressions to evaluate so that they can be scanned. This action can sometimes result in compilation errors. Two possible workarounds can prevent these errors:\n\nIn the TLD file included with the WAR, update the value of any <rtexprvalue> nodes to true.\n\nIn individual JSPs, set the taglib URIs to point to versions of the taglibs that explicitly support rt-expressions. For example, instead of pointing to the namespace http://java.sun.com/jstl/core, point to the namespace http://java.sun.com/jstl/core_rt.\n\nIf JSP files are dynamically generated at runtime, Veracode cannot analyze them. Veracode identifies these files as missing dependencies during prescan verification. To facilitate analysis, provide static instances of these files or stubs.\n\nVeracode cannot scan JSP files if you cannot compile those files. Veracode reports JSP compilation errors as part of the prescan verification process. You can submit an application that has JSP compilation errors for scanning, but Veracode does not analyze JSP files with compilation errors.\n\nBefore scanning VM files that you upload in a WAR archive, Veracode automatically compiles them using a custom compiler. Veracode does not scan VM files that are inside JAR files. Before submitting your application, ensure that you package these files within WAR or EAR archives. Veracode cannot scan VM files that an Apache Velocity engine cannot compile. Veracode does not scan any applications that do not meet these requirements.\n\nIf you include any Apache Axis web service code within your WAR file, you must make all WSDD files available in the /WEB-INF/ directory of the WAR file. For further information on the creation of WSDD files, see the Apache Axis documentation.\n\nYou must upload Axis2 modules in the MAR format and server-side Axis2 applications in the AAR format.\n\nMAR files must contain these directories with these structures:\n\n/META-INF/\n\n/META-INF/module.xml: contains all module files\n\n/class_files: contains all class files\n\nAAR files must contain these directories with these structures:\n\n/META-INF/\n\n/META-INF/services.xml: contains all services files\n\n/class_files: contains all class files\n\nFor applications that are deployed on WebSphere, a common cause of JSP compilation failure is missing standard WebSphere libraries that are in the WebSphere environment but not packaged with the application. In the event of JSP compilation failure combined with warnings about missing classes, you can check the standard WebSphere directories for your deployed version of the JAR containing these classes; this may include the <was>lib/app directory or the ws.ext.dirs.\n\nYou can use a resource such as FindJar.com to identify which JARs contain the classes that Veracode indicated as missing. You may use the JAR Class Finder Plugin for Eclipse.\n\nIn some cases, Veracode can substitute a stock library for libraries that are not provided with the application. It is generally better to provide the version of the library that your project uses to ensure that the application model accurately represents the functionality of your application.\n\nSpring Boot applications submitted as WAR files should be structured according to the guidance in the Packaging the Application as a WAR, EAR, or JAR section. Ensure that the WAR file contains these directories:\n\n/BOOT-INF/classes/: contains all class files\n\n/BOOT-INF/lib/: contains dependencies\n\nSee the Spring Boot documentation for additional details.\n\nVeracode requires you to submit applications built for AWS Lambda according to the AWS Lambda Deployment Package formats. For information, see https://docs.aws.amazon.com/ and search for AWS Lambda Deployment Package in Java.\n\nThe analysis of Lambda functions relies on the identification of Lambda Handler methods. Veracode uses this set of heuristics to identify methods that can be candidates for handler methods:\n\nClasses implementing com.amazonaws.services.lambda.runtime.RequestHandler:\n\nThe method handleRequest that overrides com.amazonaws.services.lambda.runtime.RequestHandler.handleRequest\n\nClasses implementing com.amazonaws.services.lambda.runtime.RequestStreamHandler.handleRequest:\n\nThe method com.amazonaws.services.lambda.runtime.RequestStreamHandler.handleRequest\n\nDeployment packages that reference AWS components or namespaces and classes that do not implement an AWS class:\n\nAll public functions that have up to two input parameters, where the second parameter is of type com.amazonaws.services.lambda.runtime.Context\n\nAll public functions that have up to two input parameters that the Lambda Deployment package does not reference\n\nAs part of the build process for typical Adobe Experience Manager projects, you can use mvn install. After the build completes, upload all ZIP files containing OSGi components or other compiled Java code. The Java code includes any code in the ui.apps ZIP archive, which is usually found in ui.apps/target/.\n\nUpload each package individually. Do not upload multiple packages in a ZIP file. Veracode does not support ZIP archives containing ZIP files."
    }
}