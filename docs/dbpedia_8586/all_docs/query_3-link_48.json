{
    "id": "dbpedia_8586_3",
    "rank": 48,
    "data": {
        "url": "https://veripool.org/verilog-mode/help/",
        "read_more_link": "",
        "language": "en",
        "title": "Mode Help Â· Veripool",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://veripool.org/img/veripool_top_min.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Wilson Snyder"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Veripool",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Verilog-Mode Help\n\nThis page contains documentation extracted from verilog-mode, revision 2024-07-09-b67436b-vpo. Functions are described here beginning with verilog-mode and verilog-auto, then alphabetically.\n\nSee also the other Verilog-mode Documentation\n\nYou may copy this document, but it will soon get out of date; you are thus better linking to &BASE;verilog-mode-help.html, or getting these pages from the Emacs help system.\n\nCopyright 2006, the Free Software Foundation. By Michael McNamara (mac@verilog.com). and Wilson Snyder (wsnyder@wsnyder.org).\n\nverilog-mode (function)\n\nVerilog\n\nverilog-auto (function)\n\nExpand AUTO statements. Look for any /*AUTO...*/ commands in the code, as used in instantiations or argument headers. Update the list of signals following the /*AUTO...*/ command.\n\nUse M-x verilog-delete-auto to remove the AUTOs.\n\nUse M-x verilog-diff-auto to see differences in AUTO expansion.\n\nUse M-x verilog-inject-auto to insert AUTOs for the first time.\n\nUse M-x verilog-faq for a pointer to frequently asked questions.\n\nFor new users, we recommend setting verilog-case-fold to nil and verilog-auto-arg-sort to t.\n\nThe hooks verilog-before-auto-hook and verilog-auto-hook are called before and after this function, respectively.\n\nFor example:\n\nmodule ExampModule (/*AUTOARG*/); /*AUTOINPUT*/ /*AUTOOUTPUT*/ /*AUTOWIRE*/ /*AUTOREG*/ InstMod instName #(/*AUTOINSTPARAM*/) (/*AUTOINST*/); endmodule\n\nYou can also update the AUTOs from the shell using:\n\nemacs --batch <filenames.v> -f verilog-batch-auto\n\nOr fix indentation with:\n\nemacs --batch <filenames.v> -f verilog-batch-indent\n\nLikewise, you can delete or inject AUTOs with:\n\nemacs --batch <filenames.v> -f verilog-batch-delete-auto emacs --batch <filenames.v> -f verilog-batch-inject-auto\n\nOr check if AUTOs have the same expansion\n\nemacs --batch <filenames.v> -f verilog-batch-diff-auto\n\nUsing M-x describe-function, see also:\n\nverilog-auto-arg for AUTOARG module instantiations verilog-auto-ascii-enum for AUTOASCIIENUM enumeration decoding verilog-auto-assign-modport for AUTOASSIGNMODPORT assignment to/from modport verilog-auto-inout for AUTOINOUT making hierarchy inouts verilog-auto-inout-comp for AUTOINOUTCOMP copy complemented i/o verilog-auto-inout-in for AUTOINOUTIN inputs for all i/o verilog-auto-inout-modport for AUTOINOUTMODPORT i/o from an interface modport verilog-auto-inout-module for AUTOINOUTMODULE copying i/o from elsewhere verilog-auto-inout-param for AUTOINOUTPARAM copying params from elsewhere verilog-auto-input for AUTOINPUT making hierarchy inputs verilog-auto-insert-lisp for AUTOINSERTLISP insert code from lisp function verilog-auto-insert-last for AUTOINSERTLAST insert code from lisp function verilog-auto-inst for AUTOINST instantiation pins verilog-auto-star for AUTOINST .* SystemVerilog pins verilog-auto-inst-param for AUTOINSTPARAM instantiation params verilog-auto-logic for AUTOLOGIC declaring logic signals verilog-auto-output for AUTOOUTPUT making hierarchy outputs verilog-auto-output-every for AUTOOUTPUTEVERY making all outputs verilog-auto-reg for AUTOREG registers verilog-auto-reg-input for AUTOREGINPUT instantiation registers verilog-auto-reset for AUTORESET flop resets verilog-auto-sense for AUTOSENSE or AS always sensitivity lists verilog-auto-tieoff for AUTOTIEOFF output tieoffs verilog-auto-undef for AUTOUNDEF `undef of local `defines verilog-auto-unused for AUTOUNUSED unused inputs/inouts verilog-auto-wire for AUTOWIRE instantiation wires\n\nverilog-read-defines for reading `define values verilog-read-includes for reading `includes\n\nIf you have bugs with these autos, please file an issue at URL `https://www.veripool.org/verilog-mode' or contact the AUTOAUTHOR Wilson Snyder (wsnyder@wsnyder.org).\n\nverilog-active-low-regexp (customizable variable)\n\nIf true, treat signals matching this regexp as active low. This is used for AUTORESET and AUTOTIEOFF. For proper behavior, you will probably also need verilog-auto-reset-widths set.\n\nverilog-after-save-font-hook (customizable variable)\n\nHook run after verilog-save-font-no-change-functions restores highlighting.\n\nverilog-align-assign-expr (customizable variable)\n\nNon-nil means align expressions of continuous assignments.\n\nverilog-align-comment-distance (customizable variable)\n\nDistance (in spaces) between longest declaration/expression and comments. Only works if verilog-align-decl-expr-comments is non-nil.\n\nverilog-align-decl-expr-comments (customizable variable)\n\nNon-nil means align declaration and expressions comments.\n\nverilog-align-ifelse (customizable variable)\n\nNon-nil means align `else' under matching `if'. Otherwise else is lined up with first character on line holding matching if.\n\nverilog-align-typedef-regexp (customizable variable)\n\nRegexp that matches user typedefs for declaration alignment.\n\nverilog-align-typedef-words (customizable variable)\n\nList of words that match user typedefs for declaration alignment.\n\nverilog-assignment-delay (customizable variable)\n\nText used for delays in delayed assignments. Add a trailing space if set.\n\nverilog-auto-arg (function)\n\nExpand AUTOARG statements. Replace the argument declarations at the beginning of the module with ones automatically derived from input and output statements. This can be dangerous if the module is instantiated using position-based connections, so use only name-based when instantiating the resulting module. Long lines are split based on the `fill-column', see M-x set-fill-column.\n\nLimitations:\n\nConcatenation and outputting partial buses is not supported.\n\nTypedefs must match verilog-typedef-regexp, which is disabled by default.\n\nFor example:\n\nmodule ExampArg (/*AUTOARG*/); input i; output o; endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampArg (/*AUTOARG*/ // Outputs o, // Inputs i); input i; output o; endmodule\n\nThe argument declarations may be printed in declaration order to best suit order based instantiations, or alphabetically, based on the verilog-auto-arg-sort variable.\n\nFormatting is controlled with verilog-auto-arg-format variable.\n\nAny ports declared between the ( and /*AUTOARG*/ are presumed to be predeclared and are not redeclared by AUTOARG. AUTOARG will make a conservative guess on adding a comma for the first signal, if you have any ifdefs or complicated expressions before the AUTOARG you will need to choose the comma yourself.\n\nAvoid declaring ports manually, as it makes code harder to maintain.\n\nverilog-auto-arg-format (customizable variable)\n\nFormatting to use for AUTOARG signal names. If `packed', then as many inputs and outputs that fit within `fill-column' will be put onto one line.\n\nIf `single', then a single input or output will be put onto each line.\n\nverilog-auto-arg-sort (customizable variable)\n\nNon-nil means AUTOARG signal names will be sorted, not in declaration order. Declaration order is advantageous with order based instantiations and is the default for backward compatibility. Sorted order reduces changes when declarations are moved around in a file, and it's bad practice to rely on order based instantiations anyhow.\n\nSee also verilog-auto-inst-sort.\n\nverilog-auto-ascii-enum (function)\n\nExpand AUTOASCIIENUM statements, as part of M-x verilog-auto. Create a register to contain the ASCII decode of an enumerated signal type. This will allow trace viewers to show the ASCII name of states.\n\nFirst, parameters are built into an enumeration using the synopsys enum comment. The comment must be between the keyword and the symbol. (Annoying, but that's what Synopsys's dc_shell FSM reader requires.)\n\nNext, registers which that enum applies to are also tagged with the same enum.\n\nFinally, an AUTOASCIIENUM command is used.\n\nThe first parameter is the name of the signal to be decoded.\n\nThe second parameter is the name to store the ASCII code into. For the signal foo, I suggest the name _foo__ascii, where the leading _ indicates a signal that is just for simulation, and the magic characters _ascii tell viewers like Dinotrace to display in ASCII format.\n\nThe third optional parameter is a string which will be removed from the state names. It defaults to \"\" which removes nothing.\n\nThe fourth optional parameter is \"onehot\" to force one-hot decoding. If unspecified, if and only if the first parameter width is 2^(number of states in enum) and does NOT match the width of the enum, the signal is assumed to be a one-hot decode. Otherwise, it's a normal encoded state vector.\n\nverilog-auto-wire-type may be used to change the datatype of the declarations.\n\n\"synopsys enum\" may be used in place of \"auto enum\".\n\nAn example:\n\n//== State enumeration parameter [2:0] // auto enum state_info SM_IDLE = 3\\='b000, SM_SEND = 3\\='b001, SM_WAIT1 = 3\\='b010; //== State variables reg [2:0] /* auto enum state_info */ state_r; /* auto state_vector state_r */ reg [2:0] /* auto enum state_info */ state_e1;\n\n/*AUTOASCIIENUM(\"state_r\", \"state_ascii_r\", \"SM_\")*/\n\nTyping M-x verilog-auto will make this into:\n\n... /*AUTOASCIIENUM(\"state_r\", \"state_ascii_r\", \"SM_\")*/ // Beginning of automatic ASCII enum decoding reg [39:0] state_ascii_r; // Decode of state_r always @(state_r) begin case ({state_r}) SM_IDLE: state_ascii_r = \"idle \"; SM_SEND: state_ascii_r = \"send \"; SM_WAIT1: state_ascii_r = \"wait1\"; default: state_ascii_r = \"%Erro\"; endcase end // End of automatics\n\nverilog-auto-assign-modport (function)\n\nExpand AUTOASSIGNMODPORT statements, as part of M-x verilog-auto. Take input/output/inout statements from the specified interface and modport and use to build assignments into the modport, for making verification modules that connect to UVM interfaces.\n\nThe first parameter is the name of an interface.\n\nThe second parameter is a regexp of modports to read from in that interface.\n\nThe third parameter is the instance name to use to dot reference into.\n\nThe optional fourth parameter is a regular expression, and only signals matching the regular expression will be included.\n\nThe optional fifth parameter is a prefix to add to the signals.\n\nLimitations:\n\nInterface names must be resolvable to filenames. See verilog-auto-inst.\n\nInouts are not supported, as assignments must be unidirectional.\n\nIf a signal is part of the interface header and in both a modport and the interface itself, it will not be listed. (As this would result in a syntax error when the connections are made.)\n\nSee the example in verilog-auto-inout-modport.\n\nverilog-auto-declare-nettype (customizable variable)\n\nNon-nil specifies the data type to use with verilog-auto-input etc. Set this to \"wire\" if the Verilog code uses \"`default_nettype none\". Note using `default_nettype none isn't recommended practice; this mode is experimental.\n\nverilog-auto-delete-trailing-whitespace (customizable variable)\n\nNon-nil means to `delete-trailing-whitespace' in verilog-auto.\n\nverilog-auto-endcomments (customizable variable)\n\nNon-nil means insert a comment /* ... */ after `end's. The name of the function or case will be set between the braces.\n\nverilog-auto-hook (customizable variable)\n\nHook run after verilog-mode updates AUTOs.\n\nverilog-auto-ignore-concat (customizable variable)\n\nNon-nil means ignore signals in {...} concatenations for AUTOWIRE etc. This will exclude signals referenced as pin connections in {...} or (...) from AUTOWIRE, AUTOOUTPUT and friends. See also AUTONOHOOKUP.\n\nverilog-auto-indent-on-newline (customizable variable)\n\nNon-nil means automatically indent line after newline.\n\nverilog-auto-inout (function)\n\nExpand AUTOINOUT statements, as part of M-x verilog-auto. Make inout statements for any inout signal in an /*AUTOINST*/ that isn't declared elsewhere inside the module.\n\nLimitations:\n\nThis ONLY detects inouts of AUTOINSTants (see verilog-read-sub-decls).\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nIf any concatenation, or bit-subscripts are missing in the AUTOINSTant's instantiation, all bets are off. (For example due to an AUTO_TEMPLATE).\n\nTypedefs must match verilog-typedef-regexp, which is disabled by default.\n\nTypes are added to declarations if an AUTOLOGIC or verilog-auto-wire-type is set to logic.\n\nSignals matching verilog-auto-inout-ignore-regexp are not included.\n\nAn example (see verilog-auto-inst for what else is going on here):\n\nmodule InstModule (inout io); endmodule\n\nmodule ExampInout ( /*AUTOINOUT*/ ); InstModule instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampInout ( /*AUTOINOUT*/ // Beginning of automatic inouts inout io // To/From instName of InstModule.v // End of automatics ); InstModule instName (/*AUTOINST*/ // Inouts .io (io)); endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included, or excluded if the regexp begins with ?! (question-mark exclamation-mark). For example the same expansion will result from only extracting inouts starting with i:\n\n/*AUTOINOUT(\"^i\")*/\n\nverilog-auto-inout-comp (function)\n\nExpand AUTOINOUTCOMP statements, as part of M-x verilog-auto. Take input/output/inout statements from the specified module and insert the inverse into the current module (inputs become outputs and vice-versa.) This is useful for making test and stimulus modules which need to have complementing I/O with another module. Any I/O which are already defined in this module will not be redefined. For the complement of this function, see verilog-auto-inout-module.\n\nLimitations:\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nConcatenation and outputting partial buses is not supported.\n\nModule names must be resolvable to filenames. See verilog-auto-inst.\n\nSignals are not inserted in the same order as in the original module, though they will appear to be in the same order to an AUTOINST instantiating either module.\n\nAn example:\n\nmodule ExampMain (input i, output o, inout io); endmodule\n\nmodule ExampBench (/*AUTOARG*/); /*AUTOINOUTCOMP(\"ExampMain\")*/ endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampShell (/*AUTOARG*/i, io, o); /*AUTOINOUTCOMP(\"ExampMain\")*/ // Beginning of automatic in/out/inouts output i; inout io; input o; // End of automatics endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included. For example the same expansion will result from only extracting signals starting with i:\n\n/*AUTOINOUTCOMP(\"ExampMain\",\"^i\")*/\n\nYou may also provide an optional third argument regular expression, in which case only signals which have that pin direction and data type matching that regular expression will be included. This matches against everything before the signal name in the declaration, for example against \"input\" (single bit), \"output logic\" (direction and type) or \"output [1:0]\" (direction and implicit type). You also probably want to skip spaces in your regexp.\n\nFor example, the below will result in matching the output \"o\" against the previous example's module:\n\n/*AUTOINOUTCOMP(\"ExampMain\",\"\",\"^output.*\")*/\n\nYou may also provide an optional fourth argument regular expression, which if not \"\" only signals which do NOT match that expression are included.\n\nverilog-auto-inout-ignore-regexp (customizable variable)\n\nIf non-nil, when creating AUTOINOUT, ignore signals matching this regexp. See the M-x verilog-faq for examples on using this.\n\nverilog-auto-inout-in (function)\n\nExpand AUTOINOUTIN statements, as part of M-x verilog-auto. Take input/output/inout statements from the specified module and insert them as all inputs into the current module. This is useful for making monitor modules which need to see all signals as inputs based on another module. Any I/O which are already defined in this module will not be redefined. See also verilog-auto-inout-module.\n\nLimitations:\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nConcatenation and outputting partial buses is not supported.\n\nModule names must be resolvable to filenames. See verilog-auto-inst.\n\nSignals are not inserted in the same order as in the original module, though they will appear to be in the same order to an AUTOINST instantiating either module.\n\nAn example:\n\nmodule ExampMain (input i, output o, inout io); endmodule\n\nmodule ExampInoutIn (/*AUTOARG*/); /*AUTOINOUTIN(\"ExampMain\")*/ endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampInoutIn (/*AUTOARG*/i, io, o); /*AUTOINOUTIN(\"ExampMain\")*/ // Beginning of automatic in/out/inouts input i; input io; input o; // End of automatics endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included, or excluded if the regexp begins with ?! (question-mark exclamation-mark). For example the same expansion will result from only extracting signals starting with i:\n\n/*AUTOINOUTIN(\"ExampMain\",\"^i\")*/\n\nverilog-auto-inout-modport (function)\n\nExpand AUTOINOUTMODPORT statements, as part of M-x verilog-auto. Take input/output/inout statements from the specified interface and modport and insert into the current module. This is useful for making verification modules that connect to UVM interfaces.\n\nThe first parameter is the name of an interface.\n\nThe second parameter is a regexp of modports to read from in that interface.\n\nThe optional third parameter is a regular expression, and only signals matching the regular expression will be included.\n\nThe optional fourth parameter is a prefix to add to the signals.\n\nLimitations:\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nInterface names must be resolvable to filenames. See verilog-auto-inst.\n\nAs with other autos, any inputs/outputs declared in the module will suppress the AUTO from redeclaring an inputs/outputs by the same name.\n\nAn example:\n\ninterface ExampIf ( input logic clk ); logic req_val; logic [7:0] req_dat; clocking mon_clkblk @(posedge clk); input req_val; input req_dat; endclocking modport mp(clocking mon_clkblk); endinterface\n\nmodule ExampMain ( input clk, /*AUTOINOUTMODPORT(\"ExampIf\", \"mp\")*/ );\n\nExampleIf i;\n\n/*AUTOASSIGNMODPORT(\"ExampIf\", \"mp\", \"i\")*/\n\nendmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampMain ( input clk, /*AUTOINOUTMODPORT(\"ExampIf\", \"mp\")*/ // Beginning of automatic in/out/inouts (from modport) input req_val, input [7:0] req_dat // End of automatics );\n\nExampleIf i;\n\n/*AUTOASSIGNMODPORT(\"ExampIf\", \"mp\", \"i\")*/ // Beginning of automatic assignments from modport assign i.req_dat = req_dat; assign i.req_val = req_val; // End of automatics\n\nendmodule\n\nIf the modport is part of a UVM monitor/driver class, this creates a wrapper module that may be used to instantiate the driver/monitor using AUTOINST in the testbench.\n\nverilog-auto-inout-module (function)\n\nExpand AUTOINOUTMODULE statements, as part of M-x verilog-auto. Take input/output/inout statements from the specified module and insert into the current module. This is useful for making null templates and shell modules which need to have identical I/O with another module. Any I/O which are already defined in this module will not be redefined. For the complement of this function, see verilog-auto-inout-comp, and to make monitors with all inputs, see verilog-auto-inout-in.\n\nLimitations:\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nConcatenation and outputting partial buses is not supported.\n\nModule names must be resolvable to filenames. See verilog-auto-inst.\n\nSignals are not inserted in the same order as in the original module, though they will appear to be in the same order to an AUTOINST instantiating either module.\n\nSignals declared as \"output reg\" or \"output wire\" etc will lose the wire/reg declaration so that shell modules may generate those outputs differently. However, \"output logic\" is propagated.\n\nAn example:\n\nmodule ExampMain (input i, output o, inout io); endmodule\n\nmodule ExampShell (/*AUTOARG*/); /*AUTOINOUTMODULE(\"ExampMain\")*/ endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampShell (/*AUTOARG*/o, io, o); /*AUTOINOUTMODULE(\"ExampMain\")*/ // Beginning of automatic in/out/inouts output o; inout io; input i; // End of automatics endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included, or excluded if the regexp begins with ?! (question-mark exclamation-mark). For example the same expansion will result from only extracting signals starting with i:\n\n/*AUTOINOUTMODULE(\"ExampMain\",\"^i\")*/\n\nYou may also provide an optional third argument regular expression, in which case only signals which have that pin direction and data type matching that regular expression will be included. This matches against everything before the signal name in the declaration, for example against \"input\" (single bit), \"output logic\" (direction and type) or \"output [1:0]\" (direction and implicit type). You also probably want to skip spaces in your regexp.\n\nFor example, the below will result in matching the output \"o\" against the previous example's module:\n\n/*AUTOINOUTMODULE(\"ExampMain\",\"\",\"^output.*\")*/\n\nYou may also provide an optional fourth argument regular expression, which if not \"\" only signals which do NOT match that expression are included.\n\nverilog-auto-inout-param (function)\n\nExpand AUTOINOUTPARAM statements, as part of M-x verilog-auto. Take input/output/inout statements from the specified module and insert into the current module. This is useful for making null templates and shell modules which need to have identical I/O with another module. Any I/O which are already defined in this module will not be redefined. For the complement of this function, see verilog-auto-inout-comp, and to make monitors with all inputs, see verilog-auto-inout-in.\n\nLimitations:\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nModule names must be resolvable to filenames. See verilog-auto-inst.\n\nParameters are inserted in the same order as in the original module.\n\nParameters do not have values, which is SystemVerilog 2009 syntax.\n\nAn example:\n\nmodule ExampMain (); parameter PARAM = 22; endmodule\n\nmodule ExampInoutParam (); /*AUTOINOUTPARAM(\"ExampMain\")*/ endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampInoutParam (); /*AUTOINOUTPARAM(\"ExampMain\")*/ // Beginning of automatic parameters (from specific module) parameter PARAM; // End of automatics endmodule\n\nYou may also provide an optional regular expression, in which case only parameters matching the regular expression will be included. For example the same expansion will result from only extracting parameters starting with i:\n\n/*AUTOINOUTPARAM(\"ExampMain\",\"^i\")*/\n\nverilog-auto-input (function)\n\nExpand AUTOINPUT statements, as part of M-x verilog-auto. Make input statements for any input signal into an /*AUTOINST*/ that isn't declared elsewhere inside the module. This is useful for modules which only instantiate other modules.\n\nLimitations:\n\nThis ONLY detects inputs of AUTOINSTants (see verilog-read-sub-decls).\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nIf any concatenation, or bit-subscripts are missing in the AUTOINSTant's instantiation, all bets are off. (For example due to an AUTO_TEMPLATE).\n\nTypedefs must match verilog-typedef-regexp, which is disabled by default.\n\nTypes are added to declarations if an AUTOLOGIC or verilog-auto-wire-type is set to logic.\n\nSignals matching verilog-auto-input-ignore-regexp are not included.\n\nAn example (see verilog-auto-inst for what else is going on here):\n\nmodule InstModule (input i); endmodule\n\nmodule ExampInput ( /*AUTOINPUT*/ ); InstModule instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampInput ( /*AUTOINPUT*/ // Beginning of automatic inputs (from unused autoinst inputs) input i // To instName of InstModule.v // End of automatics ); InstModule instName (/*AUTOINST*/ // Inputs .i (i)); endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included. or excluded if the regexp begins with ?! (question-mark exclamation-mark). For example the same expansion will result from only extracting inputs starting with i:\n\n/*AUTOINPUT(\"^i\")*/\n\nverilog-auto-input-ignore-regexp (customizable variable)\n\nIf non-nil, when creating AUTOINPUT, ignore signals matching this regexp. See the M-x verilog-faq for examples on using this.\n\nverilog-auto-insert-last (function)\n\nExpand AUTOINSERTLAST statements, as part of M-x verilog-auto. The Lisp code provided is called after all other AUTOS have been expanded, and the Lisp code generally will call `insert' to insert text into the current file beginning on the line after the AUTOINSERTLAST.\n\nOther than when called (after AUTOs are expanded), the functionality is otherwise identical to AUTOINSERTLISP and verilog-auto-insert-lisp which executes before (as opposed to after) other AUTOs.\n\nSee verilog-auto-insert-lisp for examples.\n\nverilog-auto-insert-lisp (function)\n\nExpand AUTOINSERTLISP statements, as part of M-x verilog-auto. The Lisp code provided is called before other AUTOS are expanded, and the Lisp code generally will call `insert' to insert text into the current file beginning on the line after the AUTOINSERTLISP.\n\nSee also AUTOINSERTLAST and verilog-auto-insert-last which executes after (as opposed to before) other AUTOs.\n\nSee also AUTO_LISP, which takes a Lisp expression and evaluates it during verilog-auto-inst but does not insert any text.\n\nAn example:\n\nmodule ExampInsertLisp; /*AUTOINSERTLISP(my-verilog-insert-hello \"world\")*/ endmodule\n\n// For this example we declare the function in the // module's file itself. Often you'd define it instead // in a site-start.el or init file. /* Local Variables: eval: (defun my-verilog-insert-hello (who) (insert (concat \"initial $write(\\\"hello \" who \"\\\");\\n\"))) End: */\n\nTyping M-x verilog-auto will call my-verilog-insert-hello and expand the above into:\n\n/*AUTOINSERTLISP(my-verilog-insert-hello \"world\")*/ // Beginning of automatic insert Lisp initial $write(\"hello world\"); // End of automatics\n\nYou can also call an external program and insert the returned text:\n\n/*AUTOINSERTLISP(insert (shell-command-to-string \"echo //hello\"))*/ // Beginning of automatic insert lisp //hello // End of automatics\n\nverilog-auto-inst (function)\n\nExpand AUTOINST statements, as part of M-x verilog-auto. Replace the pin connections to an instantiation or interface declaration with ones automatically derived from the module or interface header of the instantiated item.\n\nYou may also provide an optional regular expression, in which case only I/O matching the regular expression will be included, or excluded if the regexp begins with ?! (question-mark exclamation-mark).\n\nIf verilog-auto-star-expand is set, also expand SystemVerilog .* ports, and delete them before saving unless verilog-auto-star-save is set. See verilog-auto-star for more information.\n\nThe pins are printed in declaration order or alphabetically, based on the verilog-auto-inst-sort variable.\n\nTo debug what file a submodule comes from, in a buffer with AUTOINST, use M-x verilog-goto-defun to switch buffers to the point containing the given symbol (i.e. a submodule name)'s module definition.\n\nLimitations:\n\nModule names must be resolvable to filenames by adding a verilog-library-extensions, and being found in the same directory, or by changing the variable verilog-library-flags or verilog-library-directories. Macros `modname are translated through the vh-{name} Emacs variable, if that is not found, it just ignores the `.\n\nIn templates you must have one signal per line, ending in a ), or ));, and have proper () nesting, including a final ); to end the template.\n\nTypedefs must match verilog-typedef-regexp, which is disabled by default.\n\nSystemVerilog multidimensional input/output has only experimental support.\n\nSystemVerilog .name syntax is used if verilog-auto-inst-dot-name is set.\n\nParameters referenced by the instantiation will remain symbolic, unless verilog-auto-inst-param-value is set.\n\nGate primitives (and/or) may have AUTOINST for the purpose of AUTOWIRE declarations, etc. Gates are the only case when position based connections are passed.\n\nThe array part of arrayed instances are ignored; this may result in undesirable default AUTOINST connections; use a template instead.\n\nFor example, first take the submodule InstModule.v:\n\nmodule InstModule (o,i); output [31:0] o; input i; wire [31:0] o = {32{i}}; endmodule\n\nThis is then used in an upper level module:\n\nmodule ExampInst (o,i); output o; input i; InstModule instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampInst (o,i); output o; input i; InstModule instName (/*AUTOINST*/ // Outputs .o (o[31:0]), // Inputs .i (i)); endmodule\n\nWhere the list of inputs and outputs came from the inst module.\n\nExceptions:\n\nUnless you are instantiating a module multiple times, or the module is something trivial like an adder, DO NOT CHANGE SIGNAL NAMES ACROSS HIERARCHY. It just makes for unmaintainable code. To sanitize signal names, try vrename from URL `https://www.veripool.org'.\n\nWhen you need to violate this suggestion there are two ways to list exceptions, placing them before the AUTOINST, or using templates.\n\nAny ports defined before the /*AUTOINST*/ are not included in the list of automatics. This is similar to making a template as described below, but is restricted to simple connections just like you normally make. Also note that any signals before the AUTOINST will only be picked up by AUTOWIRE if you have the appropriate // Input or // Output comment, and exactly the same line formatting as AUTOINST itself uses.\n\nInstModule instName (// Inputs .i (my_i_dont_mess_with_it), /*AUTOINST*/ // Outputs .o (o[31:0]));\n\nTemplates:\n\nFor multiple instantiations based upon a single template, create a commented out template:\n\n/* InstModule AUTO_TEMPLATE ( .sig3 (sigz[]), ); */\n\nTemplates go ABOVE the instantiation(s). When an instantiation is expanded verilog-mode simply searches up for the closest template. Thus you can have multiple templates for the same module, just alternate between the template for an instantiation and the instantiation itself. (For backward compatibility if no template is found above, it will also look below, but do not use this behavior in new designs.)\n\nThe module name must be the same as the name of the module in the instantiation name, and the code \"AUTO_TEMPLATE\" must be in these exact words and capitalized. Only signals that must be different for each instantiation need to be listed.\n\nInside a template, a [] in a connection name (with nothing else inside the brackets) will be replaced by the same bus subscript as it is being connected to, or the [] will be removed if it is a single bit signal.\n\nInside a template, a [][] in a connection name will behave similarly to a [] for scalar or single-dimensional connection; for a multidimensional connection it will print a comment similar to that printed when a template is not used. Generally it is a good idea to do this for all connections in a template, as then they will work for any width signal, and with AUTOWIRE. See PTL_BUS becoming PTL_BUSNEW below.\n\nInside a template, a [] in a connection name (with nothing else inside the brackets) will be replaced by the same bus subscript as it is being connected to, or the [] will be removed if it is a single bit signal. Generally it is a good idea to do this for all connections in a template, as then they will work for any width signal, and with AUTOWIRE. See PTL_BUS becoming PTL_BUSNEW below.\n\nIf you have a complicated template, set verilog-auto-inst-template-numbers to see which regexps are matching. Don't leave that mode set after debugging is completed though, it will result in lots of extra differences and merge conflicts.\n\nIf a connection name does not match any template, it is connected to a net by the same name as the port (unless verilog-auto-inst-template-required is true).\n\nSetting verilog-auto-template-warn-unused will report errors if any template lines are unused.\n\nFor example:\n\n/* InstModule AUTO_TEMPLATE ( .ptl_bus (ptl_busnew[]), ); */ InstModule ms2m (/*AUTOINST*/);\n\nTyping M-x verilog-auto will make this into:\n\nInstModule ms2m (/*AUTOINST*/ // Outputs .NotInTemplate (NotInTemplate), .ptl_bus (ptl_busnew[3:0]), ....\n\nMultiple Module Templates:\n\nThe same template lines can be applied to multiple modules with the syntax as follows:\n\n/* InstModuleA AUTO_TEMPLATE InstModuleB AUTO_TEMPLATE InstModuleC AUTO_TEMPLATE InstModuleD AUTO_TEMPLATE ( .ptl_bus (ptl_busnew[]), ); */\n\nNote there is only one AUTO_TEMPLATE opening parenthesis.\n\n@ Templates:\n\nIt is common to instantiate a cell multiple times, so templates make it trivial to substitute part of the cell name into the connection name.\n\n/* InstName AUTO_TEMPLATE <optional \"REGEXP\"> ( .sig1 (sigx[@]), .sig2 (sigy[@\"(% (+ 1 @) 4)\"]), ); */\n\nIf no regular expression is provided immediately after the AUTO_TEMPLATE keyword, then the @ character in any connection names will be replaced with the instantiation number; the first digits found in the cell's instantiation name.\n\nIf a regular expression is provided, the @ character will be replaced with the first () grouping that matches against the cell name. Using a regexp of `\\([0-9]+\\)' provides identical values for @ as when no regexp is provided. If you use multiple layers of parenthesis, `test\\([^0-9]+\\)_\\([0-9]+\\)' would replace @ with non-number characters after test and before _, whereas `\\(test\\([a-z]+\\)_\\([0-9]+\\)\\)' would replace @ with the entire match.\n\nFor example:\n\n/* InstModule AUTO_TEMPLATE ( .ptl_mapvalidx (ptl_mapvalid[@]), .ptl_mapvalidp1x (ptl_mapvalid[@\"(% (+ 1 @) 4)\"]), ); */ InstModule ms2m (/*AUTOINST*/);\n\nTyping M-x verilog-auto will make this into:\n\nInstModule ms2m (/*AUTOINST*/ // Outputs .ptl_mapvalidx (ptl_mapvalid[2]), .ptl_mapvalidp1x (ptl_mapvalid[3]));\n\nNote the @ character was replaced with the 2 from \"ms2m\".\n\nAlternatively, using a regular expression for @:\n\n/* InstModule AUTO_TEMPLATE \"_\\([a-z]+\\)\" ( .ptl_mapvalidx (@_ptl_mapvalid), .ptl_mapvalidp1x (ptl_mapvalid_@), ); */ InstModule ms2_FOO (/*AUTOINST*/); InstModule ms2_BAR (/*AUTOINST*/);\n\nTyping M-x verilog-auto will make this into:\n\nInstModule ms2_FOO (/*AUTOINST*/ // Outputs .ptl_mapvalidx (FOO_ptl_mapvalid), .ptl_mapvalidp1x (ptl_mapvalid_FOO)); InstModule ms2_BAR (/*AUTOINST*/ // Outputs .ptl_mapvalidx (BAR_ptl_mapvalid), .ptl_mapvalidp1x (ptl_mapvalid_BAR));\n\nRegexp Templates:\n\nA template entry of the form\n\n.pci_req\\([0-9]+\\)_l (pci_req_jtag_[\\1]),\n\nwill apply an Emacs style regular expression search for any port beginning in pci_req followed by numbers and ending in _l and connecting that to the pci_req_jtag_[] net, with the bus subscript coming from what matches inside the first set of \\( \\). Thus pci_req2_l becomes pci_req_jtag_[2].\n\nSince \\([0-9]+\\) is so common and ugly to read, a @ in the port name does the same thing. (Note a @ in the connection/replacement text is completely different -- still use \\1 there!) Thus this is the same as the above template:\n\n.pci_req@_l (pci_req_jtag_[\\1]),\n\nHere's another example to remove the _l, useful when naming conventions specify _ alone to mean active low. Note the use of [] to keep the bus subscript:\n\n.\\(.*\\)_l (\\1_[]),\n\nLisp Templates:\n\nFirst any regular expression template is expanded.\n\nIf the syntax @\"( ... )\" is found in a connection, the expression in quotes will be evaluated as a Lisp expression, with @ replaced by the instantiation number. The MAPVALIDP1X example above would put @+1 modulo 4 into the brackets. Quote all double-quotes inside the expression with a leading backslash (\\\"...\\\"); or if the Lisp template is also a regexp template backslash the backslash quote (\\\\\"...\\\\\").\n\nThere are special variables defined that are useful in these Lisp functions:\n\nvl-name Name portion of the input/output port. vl-bits Bus bits portion of the input/output port (`[2:0]'). vl-mbits Multidimensional array bits for port (`[2:0][3:0]'). vl-width Width of the input/output port (`3' for [2:0]). May be a (...) expression if bits isn't a constant. vl-dir Direction of the pin input/output/inout/interface. vl-memory The unpacked array part of the I/O port (`[5:0]'). vl-modport The modport, if an interface with a modport. vl-cell-type Module name/type of the cell (`InstModule'). vl-cell-name Instance name of the cell (`instName').\n\nNormal Lisp variables may be used in expressions. See verilog-read-defines which can set vh-{definename} variables for use here. Also, any comments of the form:\n\n/*AUTO_LISP(setq foo 1)*/\n\nwill evaluate any Lisp expression inside the parenthesis between the beginning of the buffer and the point of the AUTOINST. This allows functions to be defined or variables to be changed between instantiations. (See also verilog-auto-insert-lisp if you want the output from your lisp function to be inserted.)\n\nNote that when using lisp expressions errors may occur when @ is not a number; you may need to use the standard Emacs Lisp functions `number-to-string' and `string-to-number'.\n\nAfter the evaluation is completed, @ substitution and [] substitution occur.\n\nIgnoring Hookup:\n\nAUTOWIRE and related AUTOs will read the signals created by a template. To specify that a signal should not be parsed to participate in this hookup, add a AUTONOHOOKUP comment to the template. For example:\n\n.pci_req_l (pci_req_not_to_wire), //AUTONOHOOKUP\n\nFor more information see the M-x verilog-faq and forums at URL `https://www.veripool.org'.\n\nverilog-auto-inst-column (customizable variable)\n\nIndent-to column number for net name part of AUTOINST created pin.\n\nverilog-auto-inst-dot-name (customizable variable)\n\nNon-nil means when creating ports with AUTOINST, use .name syntax. This will use \".port\" instead of \".port(port)\" when possible. This is only legal in SystemVerilog files, and will confuse older simulators. Setting verilog-auto-inst-vector to nil may also be desirable to increase how often .name will be used.\n\nverilog-auto-inst-interfaced-ports (customizable variable)\n\nNon-nil means include interfaced ports in AUTOINST expansions.\n\nverilog-auto-inst-param (function)\n\nExpand AUTOINSTPARAM statements, as part of M-x verilog-auto. Replace the parameter connections to an instantiation with ones automatically derived from the module header of the instantiated netlist.\n\nYou may also provide an optional regular expression, in which case only parameters matching the regular expression will be included, or excluded if the regexp begins with ?! (question-mark exclamation-mark).\n\nSee M-x verilog-auto-inst for limitations, and templates to customize the output.\n\nFor example, first take the submodule InstModule.v:\n\nmodule InstModule (o,i); parameter PAR; endmodule\n\nThis is then used in an upper level module:\n\nmodule ExampInstParam (o,i); parameter PAR; InstModule #(/*AUTOINSTPARAM*/) instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampInstParam (o,i); parameter PAR; InstModule #(/*AUTOINSTPARAM*/ // Parameters .PAR (PAR)) instName (/*AUTOINST*/); endmodule\n\nWhere the list of parameter connections come from the inst module.\n\nTemplates:\n\nYou can customize the parameter connections using AUTO_TEMPLATEs, just as you would with M-x verilog-auto-inst.\n\nverilog-auto-inst-param-value (customizable variable)\n\nNon-nil means AUTOINST will replace parameters with the parameter value. If nil, leave parameters as symbolic names.\n\nParameters must be in Verilog 2001 format #(...), and if a parameter is not listed as such there (as when the default value is acceptable), it will not be replaced, and will remain symbolic.\n\nFor example, imagine a submodule uses parameters to declare the size of its inputs. This is then used by an upper module:\n\nmodule InstModule (o,i); parameter WIDTH; input [WIDTH-1:0] i; parameter type OUT_t; output OUT_t o; endmodule\n\nmodule ExampParamVal1; /*AUTOOUTPUT*/ // Beginning of automatic outputs output OUT_t o; // End of automatics\n\nInstModule #(.WIDTH(10), ,.OUT_t(upper_t)) instName (/*AUTOINST*/ .o (o), .i (i[WIDTH-1:0])); endmodule\n\n// Local Variables: // verilog-typedef-regexp: \"_t$\" // End:\n\nNote even though WIDTH=10, the AUTOINST has left the parameter as a symbolic name. Likewise the OUT_t is preserved as the name from the instantiated module.\n\nIf verilog-auto-inst-param-value is set, this will instead expand to:\n\nmodule ExampParamVal1; /*AUTOOUTPUT*/ // Beginning of automatic outputs output upper_t o; // End of automatics\n\nInstModule #(.WIDTH(10), ,.OUT_t(upper_t)) instName (/*AUTOINST*/ .o (o), .i (i[9:0]));\n\nNote that the instantiation now has \"i[9:0]\" as the WIDTH was expanded. Likewise the data type of \"o\" in the AUTOOUTPUT is now upper_t, from the OUT_t parameter override. This second expansion of parameter types can be overridden with verilog-auto-inst-param-value-type.\n\nverilog-auto-inst-param-value-type (customizable variable)\n\nNon-nil means expand parameter type in instantiations. If nil, leave parameter types as symbolic names.\n\nSee verilog-auto-inst-param-value.\n\nverilog-auto-inst-sort (customizable variable)\n\nNon-nil means AUTOINST signals will be sorted, not in declaration order. Also affects AUTOINSTPARAM. Declaration order is the default for backward compatibility, and as some teams prefer signals that are declared together to remain together. Sorted order reduces changes when declarations are moved around in a file. Sorting is within input/output/inout groupings, there is intentionally no option to intermix between input/output/inouts.\n\nSee also verilog-auto-arg-sort.\n\nverilog-auto-inst-template-numbers (customizable variable)\n\nIf true, when creating templated ports with AUTOINST, add a comment.\n\nIf t, the comment will add the line number of the template that was used for that port declaration. This setting is suggested only for debugging use, as regular use may cause a large numbers of merge conflicts.\n\nIf `lhs', the comment will show the left hand side of the AUTO_TEMPLATE rule that is matched. This is less precise than numbering (t) when multiple rules have the same pin name, but won't merge conflict.\n\nverilog-auto-inst-template-required (customizable variable)\n\nIf non-nil, when creating a port with AUTOINST, require a template. Any port which does not have a template will be omitted from the instantiation.\n\nIf nil, if a port is not templated it will be inserted to connect to a net with the same name as the port.\n\nverilog-auto-inst-vector (customizable variable)\n\nNon-nil means when creating default ports with AUTOINST, use bus subscripts. If nil, skip the subscript when it matches the entire bus as declared in the module (AUTOWIRE signals always are subscripted, you must manually declare the wire to have the subscripts removed.) Setting this to nil may speed up some simulators, but is less general and harder to read, so avoid. If `unsigned', use vectors for unsigned types (like using true, otherwise no vectors if sizes match (like using nil).\n\nverilog-auto-lineup (customizable variable)\n\nType of statements to lineup across multiple lines. If `all' is selected, then all line ups described below are done.\n\nIf `declarations', then just declarations are lined up with any preceding declarations, taking into account widths and the like, so or example the code:\n\nreg [31:0] a; reg b;\n\nwould become\n\nreg [31:0] a; reg b;\n\nIf `assignment', then assignments are lined up with any preceding assignments, so for example the code\n\na_long_variable <= b + c; d = e + f;\n\nwould become\n\na_long_variable <= b + c; d = e + f;\n\nIn order to speed up editing, large blocks of statements are lined up only when a M-x verilog-pretty-expr is typed; and large blocks of declarations are lineup only when M-x verilog-pretty-declarations is typed.\n\nverilog-auto-logic (function)\n\nExpand AUTOLOGIC statements, as part of M-x verilog-auto. Make wire statements using the SystemVerilog logic keyword. This is currently equivalent to:\n\n/*AUTOWIRE*/\n\nwith the below at the bottom of the file\n\n// Local Variables: // verilog-auto-wire-type:\"logic\" // End:\n\nIn the future AUTOLOGIC may declare additional identifiers, while AUTOWIRE will not.\n\nverilog-auto-newline (customizable variable)\n\nNon-nil means automatically newline after semicolons.\n\nverilog-auto-output (function)\n\nExpand AUTOOUTPUT statements, as part of M-x verilog-auto. Make output statements for any output signal from an /*AUTOINST*/ that isn't an input to another AUTOINST. This is useful for modules which only instantiate other modules.\n\nLimitations:\n\nThis ONLY detects outputs of AUTOINSTants (see verilog-read-sub-decls).\n\nIf placed inside the parenthesis of a module declaration, it creates Verilog 2001 style, else uses Verilog 1995 style.\n\nIf any concatenation, or bit-subscripts are missing in the AUTOINSTant's instantiation, all bets are off. (For example due to an AUTO_TEMPLATE).\n\nTypedefs must match verilog-typedef-regexp, which is disabled by default.\n\nTypes are added to declarations if an AUTOLOGIC or verilog-auto-wire-type is set to logic.\n\nSignals matching verilog-auto-output-ignore-regexp are not included.\n\nAn example (see verilog-auto-inst for what else is going on here):\n\nmodule InstModule (output o); endmodule\n\nmodule ExampOutput (/*AUTOOUTPUT*/ ); InstModule instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampOutput (/*AUTOOUTPUT*/ // Beginning of automatic outputs output o // From instName of InstModule.v // End of automatics ); InstModule instName (/*AUTOINST*/ // Outputs .o (o)); endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included. For example the same expansion will result from only extracting outputs starting with ov:\n\n/*AUTOOUTPUT(\"^ov\")*/\n\nverilog-auto-output-every (function)\n\nExpand AUTOOUTPUTEVERY statements, as part of M-x verilog-auto. Make output statements for any signals that aren't primary inputs or outputs already. This makes every signal in the design an output. This is useful to get synthesis to preserve every signal in the design, since it won't optimize away the outputs.\n\nAn example:\n\nmodule ExampOutputEvery (o,i,tempa,tempb); output o; input i; /*AUTOOUTPUTEVERY*/ wire tempa = i; wire tempb = tempa; wire o = tempb; endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampOutputEvery ( /*AUTOOUTPUTEVERY*/ // Beginning of automatic outputs (every signal) output o, output tempa, output tempb, // End of automatics input i ); wire tempa = i; wire tempb = tempa; wire o = tempb; endmodule\n\nYou may also provide an optional regular expression, in which case only signals matching the regular expression will be included,or excluded if the regexp begins with ?! (question-mark exclamation-mark). For example the same expansion will result from only extracting outputs starting with ov:\n\n/*AUTOOUTPUTEVERY(\"^ov\")*/\n\nverilog-auto-output-ignore-regexp (customizable variable)\n\nIf non-nil, when creating AUTOOUTPUT, ignore signals matching this regexp. See the M-x verilog-faq for examples on using this.\n\nverilog-auto-read-includes (customizable variable)\n\nNon-nil means to automatically read includes before AUTOs. This will do a verilog-read-defines and verilog-read-includes before each AUTO expansion. This makes it easier to embed defines and includes, but can result in very slow reading times if there are many or large include files.\n\nverilog-auto-reg (function)\n\nExpand AUTOREG statements, as part of M-x verilog-auto. Make reg statements for any output that isn't already declared, and isn't a wire output from a block. verilog-auto-wire-type may be used to change the datatype of the declarations.\n\nLimitations:\n\nThis ONLY detects outputs of AUTOINSTants (see verilog-read-sub-decls).\n\nThis does NOT work on memories, declare those yourself.\n\nAn example:\n\nmodule ExampReg (o,i); output o; input i; /*AUTOREG*/ always o = i; endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampReg (o,i); output o; input i; /*AUTOREG*/ // Beginning of automatic regs reg o; // End of automatics always o = i; endmodule\n\nverilog-auto-reg-input (function)\n\nExpand AUTOREGINPUT statements, as part of M-x verilog-auto. Make reg statements instantiation inputs that aren't already declared or assigned to. This is useful for making a top level shell for testing the module that is to be instantiated.\n\nLimitations:\n\nThis ONLY detects inputs of AUTOINSTants (see verilog-read-sub-decls).\n\nThis does NOT work on memories, declare those yourself.\n\nAssignments cause the assigned-to variable not to be declared unless the name matches verilog-auto-reg-input-assigned-ignore-regexp.\n\nAn example (see verilog-auto-inst for what else is going on here):\n\nmodule InstModule (input i); endmodule\n\nmodule ExampRegInput (); /*AUTOREGINPUT*/ InstModule instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampRegInput (); /*AUTOREGINPUT*/ // Beginning of automatic reg inputs reg i; // To instName of InstModule.v // End of automatics InstModule instName (/*AUTOINST*/ // Inputs .i (i)); endmodule\n\nverilog-auto-reg-input-assigned-ignore-regexp (customizable variable)\n\nIf non-nil, when creating AUTOINPUTREG, ignore signals matching this regexp.\n\nverilog-auto-reset (function)\n\nExpand AUTORESET statements, as part of M-x verilog-auto. Replace the /*AUTORESET*/ comment with code to initialize all registers set elsewhere in the always block.\n\nLimitations:\n\nAUTORESET will not clear memories.\n\nAUTORESET uses <= if the signal has a <= assignment in the block, else it uses =.\n\nIf <= is used, all = assigned variables are ignored if verilog-auto-reset-blocking-in-non is nil; they are presumed to be temporaries.\n\n/*AUTORESET*/ presumes that any signals mentioned between the previous begin/case/if statement and the AUTORESET comment are being reset manually and should not be automatically reset. This includes omitting any signals used on the right hand side of assignments.\n\nBy default, AUTORESET will include the width of the signal in the autos, SystemVerilog designs may want to change this. To control this behavior, see verilog-auto-reset-widths. In some cases AUTORESET must use a \\='0 assignment and it will print NOWIDTH; use verilog-auto-reset-widths unbased to prevent this.\n\nAUTORESET ties signals to deasserted, which is presumed to be zero. Signals that match verilog-active-low-regexp will be deasserted by tying them to a one.\n\nAUTORESET may try to reset arrays or structures that cannot be reset by a simple assignment, resulting in compile errors. This is a feature to be taken as a hint that you need to reset these signals manually (or put them into a \"`ifdef NEVER signal<=\\='0; `endif\" so Verilog-Mode ignores them.)\n\nAn example:\n\nmodule ExampReset (); always @(posedge clk or negedge reset_l) begin if (!reset_l) begin c <= 1; /*AUTORESET*/ end else begin a <= in_a; b <= in_b; c <= in_c; end end endmodule\n\nTyping M-x verilog-auto will make this into:\n\n... c <= 1; /*AUTORESET*/ // Beginning of autoreset for uninitialized flops a <= 1'h0; b <= 1'h0; // End of automatics ...\n\nverilog-auto-reset-blocking-in-non (customizable variable)\n\nNon-nil means AUTORESET will reset blocking statements. When true, AUTORESET will reset in blocking statements those signals which were assigned with blocking assignments (=) even in a block with non-blocking assignments (<=).\n\nIf nil, all blocking assigned signals are ignored when any non-blocking assignment is in the AUTORESET block. This allows blocking assignments to be used for temporary values and not have those temporaries reset. See example in verilog-auto-reset.\n\nverilog-auto-reset-widths (customizable variable)\n\nNon-nil means AUTORESET should determine the width of signals. This is then used to set the width of the zero (32'h0 for example). This is required by some lint tools that aren't smart enough to ignore widths of the constant zero. This may result in ugly code when parameters determine the MSB or LSB of a signal inside an AUTORESET.\n\nIf nil, AUTORESET uses \"0\" as the constant.\n\nIf `unbased', AUTORESET used the unbased unsized literal \"\\='0\" as the constant. This setting is strongly recommended for SystemVerilog designs.\n\nverilog-auto-save-compile (function)\n\nUpdate automatics with M-x verilog-auto, save the buffer, and compile.\n\nverilog-auto-save-policy (customizable variable)\n\nNon-nil indicates action to take when saving a Verilog buffer with AUTOs. A value of `force' will always do a M-x verilog-auto automatically if needed on every save. A value of `detect' will do M-x verilog-auto automatically when it thinks necessary. A value of `ask' will query the user when it thinks updating is needed.\n\nYou should not rely on the `ask' or `detect' policies, they are safeguards only. They do not detect when AUTOINSTs need to be updated because a sub-module's port list has changed.\n\nverilog-auto-sense (function)\n\nExpand AUTOSENSE statements, as part of M-x verilog-auto. Replace the always (/*AUTOSENSE*/) sensitivity list (/*AS*/ for short) with one automatically derived from all inputs declared in the always statement. Signals that are generated within the same always block are NOT placed into the sensitivity list (see verilog-auto-sense-include-inputs). Long lines are split based on the `fill-column', see M-x set-fill-column.\n\nLimitations:\n\nVerilog does not allow memories (multidimensional arrays) in sensitivity lists. AUTOSENSE will thus exclude them, and add a /*memory or*/ comment.\n\nConstant signals:\n\nAUTOSENSE cannot always determine if a `define is a constant or a signal (it could be in an include file for example). If a `define or other signal is put into the AUTOSENSE list and is not desired, use the AUTO_CONSTANT declaration anywhere in the module (parenthesis are required):\n\n/* AUTO_CONSTANT( `this_is_really_constant_dont_autosense_it ) */\n\nBetter yet, use a parameter, which will be understood to be constant automatically.\n\nOOps!\n\nIf AUTOSENSE makes a mistake, please report it. (First try putting a begin/end after your always!) As a workaround, if a signal that shouldn't be in the sensitivity list was, use the AUTO_CONSTANT above. If a signal should be in the sensitivity list wasn't, placing it before the /*AUTOSENSE*/ comment will prevent it from being deleted when the autos are updated (or added if it occurs there already).\n\nAn example:\n\nalways @ (/*AS*/) begin /*AUTO_CONSTANT(`constant) */ outin = ina | inb | `constant; out = outin; end\n\nTyping M-x verilog-auto will make this into:\n\nalways @ (/*AS*/ina or inb) begin /*AUTO_CONSTANT(`constant) */ outin = ina | inb | `constant; out = outin; end\n\nNote in Verilog 2001, you can often get the same result from the new @* operator. (This was added to the language in part due to AUTOSENSE!)\n\nalways @* begin outin = ina | inb | `constant; out = outin; end\n\nverilog-auto-sense-defines-constant (customizable variable)\n\nNon-nil means AUTOSENSE should assume all defines represent constants. When true, the defines will not be included in sensitivity lists. To maintain compatibility with other sites, this should be set at the bottom of each Verilog file that requires it, rather than being set globally.\n\nverilog-auto-sense-include-inputs (customizable variable)\n\nNon-nil means AUTOSENSE should include all inputs. If nil, only inputs that are NOT output signals in the same block are included.\n\nverilog-auto-simplify-expressions (customizable variable)\n\nNon-nil means AUTOs will simplify expressions when calculating bit ranges. When nil, do not simply ranges, which may simplify the output, but may cause problems when there are multiple instantiations outputting to the same wire. To maintain compatibility with other sites, this should be set at the bottom of each Verilog file that requires it, rather than being set globally.\n\nverilog-auto-star (function)\n\nExpand SystemVerilog .* pins, as part of M-x verilog-auto.\n\nIf verilog-auto-star-expand is set, .* pins are treated if they were AUTOINST statements, otherwise they are ignored. For safety, Verilog mode will also ignore any .* that are not last in your pin list (this prevents it from deleting pins following the .* when it expands the AUTOINST.)\n\nOn writing your file, unless verilog-auto-star-save is set, any non-templated expanded pins will be removed. You may do this at any time with M-x verilog-delete-auto-star-implicit.\n\nIf you are converting a module to use .* for the first time, you may wish to use M-x verilog-inject-auto and then replace the created AUTOINST with .*.\n\nSee verilog-auto-inst for examples, templates, and more information.\n\nverilog-auto-star-expand (customizable variable)\n\nNon-nil means to expand SystemVerilog .* instance ports. They will be expanded in the same way as if there was an AUTOINST in the instantiation. See also verilog-auto-star and verilog-auto-star-save.\n\nverilog-auto-star-save (customizable variable)\n\nNon-nil means save to disk SystemVerilog .* instance expansions. A nil value indicates direct connections will be removed before saving. Only meaningful to those created due to verilog-auto-star-expand being set.\n\nInstead of setting this, you may want to use /*AUTOINST*/, which will always be saved.\n\nverilog-auto-template-warn-unused (customizable variable)\n\nNon-nil means report warning if an AUTO_TEMPLATE line is not used. This feature is not supported before Emacs 21.1 or XEmacs 21.4.\n\nverilog-auto-tieoff (function)\n\nExpand AUTOTIEOFF statements, as part of M-x verilog-auto. Replace the /*AUTOTIEOFF*/ comment with code to wire-tie all unused output signals to deasserted.\n\n/*AUTOTIEOFF*/ is used to make stub modules; modules that have the same input/output list as another module, but no internals. Specifically, it finds all outputs in the module, and if that input is not otherwise declared as a register or wire, nor comes from a AUTOINST submodule's output, creates a tieoff. AUTOTIEOFF does not examine assignments to determine what is already driven.\n\nAUTORESET ties signals to deasserted, which is presumed to be zero. Signals that match verilog-active-low-regexp will be deasserted by tying them to a one.\n\nYou can add signals you do not want included in AUTOTIEOFF with verilog-auto-tieoff-ignore-regexp.\n\nverilog-auto-wire-type may be used to change the datatype of the declarations.\n\nverilog-auto-reset-widths may be used to change how the tieoff value's width is generated.\n\nAn example of making a stub for another module:\n\nmodule ExampMain #(parameter P) (input i, output o, inout io); endmodule\n\nmodule ExampStub (/*AUTOARG*/); /*AUTOINOUTPARAM(\"ExampMain\")*/ /*AUTOINOUTMODULE(\"ExampMain\")*/\n\n/*AUTOTIEOFF*/\n\n// verilator lint_off UNUSED wire _unused_ok = &{1\\='b0, /*AUTOUNUSED*/ 1\\='b0}; // verilator lint_on UNUSED endmodule\n\nTyping M-x verilog-auto will make this into:\n\n... /*AUTOTIEOFF*/ // Beginning of automatic tieoffs wire [2:0] o = 3\\='b0; // End of automatics ...\n\nverilog-auto-tieoff-declaration (customizable variable)\n\nData type used for the declaration for AUTOTIEOFF. If \"wire\" then create a wire, if \"assign\" create an assignment, else the data type for variable creation.\n\nverilog-auto-tieoff-ignore-regexp (customizable variable)\n\nIf non-nil, when creating AUTOTIEOFF, ignore signals matching this regexp. See the M-x verilog-faq for examples on using this.\n\nverilog-auto-undef (function)\n\nExpand AUTOUNDEF statements, as part of M-x verilog-auto. Take any `defines since the last AUTOUNDEF in the current file and create `undefs for them. This is used to insure that file-local defines do not pollute the global `define name space.\n\nLimitations:\n\nAUTOUNDEF presumes any identifier following `define is the name of a define. Any `ifdefs are ignored.\n\nAUTOUNDEF suppresses creating an `undef for any define that was `undefed before the AUTOUNDEF. This may be used to work around the ignoring of `ifdefs as shown below.\n\nAn example:\n\n`define XX_FOO `define M_BAR(x) `define M_BAZ ... `ifdef NEVER `undef M_BAZ // Emacs will see this and not `undef M_BAZ `endif ... /*AUTOUNDEF*/\n\nTyping M-x verilog-auto will make this into:\n\n... /*AUTOUNDEF*/ // Beginning of automatic undefs `undef M_BAR `undef XX_FOO // End of automatics\n\nYou may also provide an optional regular expression, in which case only defines the regular expression will be undefed.\n\nverilog-auto-unused (function)\n\nExpand AUTOUNUSED statements, as part of M-x verilog-auto. Replace the /*AUTOUNUSED*/ comment with a comma separated list of all unused input and inout signals.\n\n/*AUTOUNUSED*/ is used to make stub modules; modules that have the same input/output list as another module, but no internals. Specifically, it finds all inputs and inouts in the module, and if that input is not otherwise used, adds it to a comma separated list.\n\nThe comma separated list is intended to be used to create a _unused_ok signal. Using the exact name \"_unused_ok\" for name of the temporary signal is recommended as it will insure maximum forward compatibility, it also makes lint warnings easy to understand; ignore any unused warnings with \"unused\" in the signal name.\n\nTo reduce simulation time, the _unused_ok signal should be forced to a constant to prevent wiggling. The easiest thing to do is use a reduction-and with 1\\='b0 as shown.\n\nThis way all unused signals are in one place, making it convenient to add your tool's specific pragmas around the assignment to disable any unused warnings.\n\nYou can add signals you do not want included in AUTOUNUSED with verilog-auto-unused-ignore-regexp.\n\nAn example of making a stub for another module:\n\nmodule ExampMain (input unused_input_a, input unused_input_b); endmodule\n\nmodule ExampStub2 (/*AUTOARG*/); /*AUTOINOUTPARAM(\"ExampMain\")*/ /*AUTOINOUTMODULE(\"ExampMain\")*/\n\n/*AUTOTIEOFF*/\n\n// verilator lint_off UNUSED wire _unused_ok = &{1\\='b0, /*AUTOUNUSED*/ 1\\='b0}; // verilator lint_on UNUSED endmodule\n\nTyping M-x verilog-auto will make this into:\n\n... // verilator lint_off UNUSED wire _unused_ok = &{1\\='b0, /*AUTOUNUSED*/ // Beginning of automatics unused_input_a, unused_input_b // End of automatics 1\\='b0}; // verilator lint_on UNUSED endmodule\n\nverilog-auto-unused-ignore-regexp (customizable variable)\n\nIf non-nil, when creating AUTOUNUSED, ignore signals matching this regexp. See the M-x verilog-faq for examples on using this.\n\nverilog-auto-wire (function)\n\nExpand AUTOWIRE statements, as part of M-x verilog-auto. Make wire statements for instantiations outputs that aren't already declared. verilog-auto-wire-type may be used to change the datatype of the declarations.\n\nLimitations:\n\nThis ONLY detects outputs of AUTOINSTants (see verilog-read-sub-decls), and all buses must have widths, such as those from AUTOINST, or using [] in AUTO_TEMPLATEs.\n\nThis does NOT work on memories or SystemVerilog .name connections, declare those yourself.\n\nVerilog mode will add \"Couldn't Merge\" comments to signals it cannot determine how to bus together. This occurs when you have ports with non-numeric or non-sequential bus subscripts. If Verilog mode mis-guessed, you'll have to declare them yourself.\n\nAn example (see verilog-auto-inst for what else is going on here):\n\nmodule ExampWire (i); input i; /*AUTOWIRE*/ InstModule instName (/*AUTOINST*/); endmodule\n\nTyping M-x verilog-auto will make this into:\n\nmodule ExampWire (i); input i; /*AUTOWIRE*/ // Beginning of automatic wires wire [31:0] o; // From instName of InstModule.v // End of automatics InstModule instName (/*AUTOINST*/ // Outputs .o (o[31:0]), // Inputs .i (i)); wire o = | ov; endmodule\n\nverilog-auto-wire-comment (customizable variable)\n\nNon-nil indicates to insert to/from comments with verilog-auto-wire etc.\n\nverilog-auto-wire-type (customizable variable)\n\nNon-nil specifies the data type to use with verilog-auto-wire etc. Set this to \"logic\" for SystemVerilog code, or use verilog-auto-logic. Set this to \"wire\" to force use of wire when logic is otherwise appropriate; this is generally only appropriate when making a non-SystemVerilog wrapper containing SystemVerilog cells.\n\nverilog-batch-diff-auto (function)\n\nFor use with --batch, perform automatic differences as a stand-alone tool. This sets up the appropriate Verilog mode environment, expand automatics with M-x verilog-diff-auto on all command-line files, and reports an error if any differences are observed. This is appropriate for adding to regressions to insure automatics are always properly maintained.\n\nverilog-before-auto-hook (customizable variable)\n\nHook run before verilog-mode updates AUTOs.\n\nverilog-before-delete-auto-hook (customizable variable)\n\nHook run before verilog-mode deletes AUTOs.\n\nverilog-before-getopt-flags-hook (customizable variable)\n\nHook run before verilog-getopt-flags determines the Verilog option lists.\n\nverilog-before-save-font-hook (customizable variable)\n\nHook run before verilog-save-font-no-change-functions removes highlighting.\n\nverilog-case-fold (customizable variable)\n\nNon-nil means verilog-mode regexps should ignore case. This variable is t for backward compatibility; nil is suggested.\n\nverilog-case-indent (customizable variable)\n\nIndentation for case statements.\n\nverilog-cexp-indent (customizable variable)\n\nIndentation of Verilog statements split across lines.\n\nverilog-compiler (customizable variable)\n\nProgram and arguments to use to compile Verilog source. Depending on the verilog-set-compile-command, this may be invoked when you type M-x compile. When the compile completes, M-x next-error will take you to the next lint error.\n\nverilog-coverage (customizable variable)\n\nProgram and arguments to use to annotate for coverage Verilog source. Depending on the verilog-set-compile-command, this may be invoked when you type M-x compile. When the compile completes, M-x next-error will take you to the next lint error.\n\nverilog-current-flags (function)\n\nConvert verilog-library-flags and similar variables to command line. Used for __FLAGS__ in verilog-expand-command.\n\nverilog-delete-auto (function)\n\nDelete the automatic outputs, regs, and wires created by M-x verilog-auto. Use M-x verilog-auto to re-insert the updated AUTOs.\n\nThe hooks verilog-before-delete-auto-hook and verilog-delete-auto-hook are called before and after this function, respectively.\n\nverilog-delete-auto-hook (customizable variable)\n\nHook run after verilog-mode deletes AUTOs.\n\nverilog-delete-auto-star-implicit (function)\n\nDelete all .* implicit connections created by verilog-auto-star. This function will be called automatically at save unless verilog-auto-star-save is set, any non-templated expanded pins will be removed.\n\nverilog-diff-auto (function)\n\nExpand AUTOs in a temporary buffer and indicate any change. Whitespace is ignored when detecting differences, but once a difference is detected, whitespace differences may be shown.\n\nTo call this from the command line, see M-x verilog-batch-diff-auto.\n\nThe action on differences is selected with verilog-diff-function. The default is verilog-diff-report which will report an error and run `ediff' in interactive mode, or `diff' in batch mode.\n\nverilog-diff-function (variable)\n\nFunction to run when verilog-diff-auto detects differences. Function takes three arguments, the original buffer, the difference buffer, and the point in original buffer with the first difference.\n\nverilog-diff-report (function)\n\nReport differences detected with verilog-diff-auto. Differences are between buffers B1 and B2, starting at point DIFFPT. This function is called via verilog-diff-function.\n\nverilog-expand-command (function)\n\nReplace meta-information in COMMAND and return it. Where __FLAGS__ appears in the string verilog-current-flags will be substituted. Where __FILE__ appears in the string, the current buffer's file-name, without the directory portion, will be substituted.\n\nverilog-faq (function)\n\nTell the user their current version, and where to get the FAQ etc.\n\nverilog-font-lock-grouping-keywords-face (variable)\n\nFont to use for Verilog Grouping Keywords (such as begin..end).\n\nverilog-font-lock-translate-off-face (variable)\n\nFont to use for translated off regions.\n\nverilog-fontify-variables (customizable variable)\n\nNon-nil means fontify declaration variables.\n\nverilog-getopt-flags (function)\n\nConvert verilog-library-flags into standard library variables.\n\nverilog-getopt-flags-hook (customizable variable)\n\nHook run after verilog-getopt-flags determines the Verilog option lists.\n\nverilog-goto-defun (function)\n\nMove to specified Verilog module/interface/task/function. The default is a name found in the buffer around point. If search fails, other files are checked based on verilog-library-flags.\n\nverilog-highlight-grouping-keywords (customizable variable)\n\nNon-nil means highlight grouping keywords more dramatically. If false, these words are in the `font-lock-type-face'; if True then they are in verilog-font-lock-grouping-keywords-face. Some find that special highlighting on these grouping constructs allow the structure of the code to be understood at a glance.\n\nverilog-highlight-includes (customizable variable)\n\nNon-nil means highlight module statements for verilog-load-file-at-point. When true, mousing over include file names will allow jumping to the file referenced. If false, this is not supported.\n\nverilog-highlight-max-lookahead (customizable variable)\n\nMaximum size of declaration statement that undergoes highlighting. Highlighting is performed only on the first verilog-highlight-max-lookahead characters in a declaration statement. Setting this variable to zero would remove this limit. Note that removing the limit can greatly slow down highlighting for very large files.\n\nverilog-highlight-modules (customizable variable)\n\nNon-nil means highlight module statements for verilog-load-file-at-point. When true, mousing over module names will allow jumping to the module definition. If false, this is not supported. Setting this is experimental, and may lead to bad performance.\n\nverilog-highlight-p1800-keywords (customizable variable)\n\nObsolete. Was non-nil means highlight SystemVerilog IEEE-1800 differently. All code is now highlighted as if SystemVerilog IEEE-1800.\n\nverilog-highlight-translate-off (customizable variable)\n\nNon-nil means background-highlight code excluded from translation. That is, all code between \"// synopsys translate_off\" and \"// synopsys translate_on\" is highlighted using a different background color (face verilog-font-lock-translate-off-face).\n\nNote: This will slow down on-the-fly fontification (and thus editing).\n\nNote: Activate the new setting in a Verilog buffer by re-fontifying it (menu entry \"Fontify Buffer\"). XEmacs: turn off and on font locking.\n\nverilog-indent-begin-after-if (customizable variable)\n\nNon-nil means indent begin statements following if, else, while, etc. Otherwise, line them up.\n\nverilog-indent-class-inside-pkg (customizable variable)\n\nNon-nil means indent classes inside packages. Otherwise, classes have zero indentation.\n\nverilog-indent-declaration-macros (customizable variable)\n\nHow to treat macro expansions in a declaration. If nil, indent as:\n\ninput [31:0] a; input `CP; output c;\n\nIf non-nil, treat as:\n\ninput [31:0] a; input `CP ; output c;\n\nverilog-indent-ignore-multiline-defines (customizable variable)\n\nNon-nil means ignore indentation on lines that are part of a multiline define.\n\nverilog-indent-ignore-regexp (customizable variable)\n\nRegexp that matches lines that should be ignored for indentation.\n\nverilog-indent-level (customizable variable)\n\nIndentation of Verilog statements with respect to containing block.\n\nverilog-indent-level-behavioral (customizable variable)\n\nAbsolute indentation of first begin in a task or function block. Set to 0 to get such code to start at the left side of the screen.\n\nverilog-indent-level-declaration (customizable variable)\n\nIndentation of declarations with respect to containing block. Set to 0 to get them list right under containing block.\n\nverilog-indent-level-directive (customizable variable)\n\nIndentation to add to each level of `ifdef declarations. Set to 0 to have all directives start at the left side of the screen.\n\nverilog-indent-level-module (customizable variable)\n\nIndentation of Module level Verilog statements (eg always, initial). Set to 0 to get initial and always statements lined up on the left side of your screen.\n\nverilog-indent-lists (customizable variable)\n\nHow to treat indenting items in a list. If t (the default), indent as:\n\nalways @( posedge a or reset ) begin\n\nIf nil, treat as:\n\nalways @( posedge a or reset ) begin\n\nverilog-inject-auto (function)\n\nExamine legacy non-AUTO code and insert AUTOs in appropriate places.\n\nAny always @ blocks with sensitivity lists that match computed lists will be replaced with /*AS*/ comments.\n\nAny cells will get /*AUTOINST*/ added to the end of the pin list. Pins with have identical names will be deleted.\n\nArgument lists will not be deleted, /*AUTOARG*/ will only be inserted to support adding new ports. You may wish to delete older ports yourself.\n\nFor example:\n\nmodule ExampInject (i, o); input i; input j; output o; always @ (i or j) o = i | j; InstModule instName (.foobar(baz), .j(j)); endmodule\n\nTyping M-x verilog-inject-auto (with an appropriate submodule not shown) will make this into:\n\nmodule ExampInject (i, o/*AUTOARG*/ // Inputs j); input i; output o; always @ (/*AS*/i or j) o = i | j; InstModule instName (.foobar(baz), /*AUTOINST*/ // Outputs j(j)); endmodule\n\nverilog-library-directories (customizable variable)\n\nList of directories when looking for files for /*AUTOINST*/. The directory may be relative to the current file, or absolute. Environment variables are also expanded in the directory names. Having at least the current directory is a good idea.\n\nYou might want these defined in each file; put at the *END* of your file something like:\n\n// Local Variables: // verilog-library-directories:(\".\" \"subdir\" \"subdir2\") // End:\n\nVerilog-mode attempts to detect changes to this local variable, but they are only insured to be correct when the file is first visited. Thus if you have problems, use M-x find-alternate-file RET to have these take effect.\n\nSee also verilog-library-flags, verilog-library-files and verilog-library-extensions.\n\nverilog-library-extensions (customizable variable)\n\nList of extensions to use when looking for files for /*AUTOINST*/. See also verilog-library-flags, verilog-library-directories.\n\nverilog-library-files (customizable variable)\n\nList of files to search for modules. AUTOINST will use this when it needs to resolve a module name. This is a complete path, usually to a technology file with many standard cells defined in it.\n\nYou might want these defined in each file; put at the *END* of your file something like:\n\n// Local Variables: // verilog-library-files:(\"/path/technology.v\" \"/path2/tech2.v\") // End:\n\nVerilog-mode attempts to detect changes to this local variable, but they are only insured to be correct when the file is first visited. Thus if you have problems, use M-x find-alternate-file RET to have these take effect.\n\nSee also verilog-library-flags, verilog-library-directories.\n\nverilog-library-flags (customizable variable)\n\nList of standard Verilog arguments to use for /*AUTOINST*/. These arguments are used to find files for verilog-auto, and match the flags accepted by a standard Verilog-XL simulator.\n\n-f filename Reads absolute verilog-library-flags from the filename. -F filename Reads relative verilog-library-flags from the filename. +incdir+dir Adds the directory to verilog-library-directories. -Idir Adds the directory to verilog-library-directories. -y dir Adds the directory to verilog-library-directories. +libext+.v Adds the extensions to verilog-library-extensions. -v filename Adds the filename to verilog-library-files.\n\nfilename Adds the filename to verilog-library-files. This is not recommended, -v is a better choice.\n\nYou might want these defined in each file; put at the *END* of your file something like:\n\n// Local Variables: // verilog-library-flags:(\"-y dir -y otherdir\") // End:\n\nVerilog-mode attempts to detect changes to this local variable, but they are only insured to be correct when the file is first visited. Thus if you have problems, use M-x find-alternate-file RET to have these take effect.\n\nSee also the variables mentioned above.\n\nverilog-linter (customizable variable)\n\nUnix program and arguments to call to run a lint checker on Verilog source. Depending on the verilog-set-compile-command, this may be invoked when you type M-x compile. When the compile completes, M-x next-error will take you to the next lint error.\n\nverilog-load-file-at-point (function)\n\nLoad file under point. If WARN, throw warning if not found. Files are checked based on verilog-library-flags.\n\nverilog-minimum-comment-distance (customizable variable)\n\nMinimum distance (in lines) between begin and end required before a comment. Setting this variable to zero results in every end acquiring a comment; the default avoids too many redundant comments in tight quarters.\n\nverilog-mode-hook (customizable variable)\n\nHook run after Verilog mode is loaded.\n\nverilog-preprocess (function)\n\nPreprocess the buffer, similar to `compile', but put output in Verilog-Mode. Takes optional COMMAND or defaults to verilog-preprocessor, and FILENAME to find directory to run in, or defaults to `buffer-file-name'.\n\nverilog-preprocessor (customizable variable)\n\nProgram and arguments to use to preprocess Verilog source. This is invoked with verilog-preprocess, and depending on the verilog-set-compile-command, may also be invoked when you type M-x compile. When the compile completes, M-x next-error will take you to the next lint error.\n\nverilog-pretty-declarations (function)\n\nLine up declarations around point. Be verbose about progress unless optional QUIET set.\n\nverilog-pretty-expr (function)\n\nLine up expressions around point. If QUIET is non-nil, do not print messages showing the progress of line-up.\n\nverilog-read-defines (function)\n\nRead `defines and parameters for the current file, or optional FILENAME. If the filename is provided, verilog-library-flags will be used to resolve it. If optional RECURSE is non-nil, recurse through `includes.\n\nLocalparams must be simple assignments to constants, or have their own \"localparam\" label rather than a list of localparams. Thus:\n\nlocalparam X = 5, Y = 10; // Ok localparam X = {1\\='b1, 2\\='h2}; // Ok localparam X = {1\\='b1, 2\\='h2}, Y = 10; // Bad, make into 2 localparam lines\n\nDefines must be simple text substitutions, one on a line, starting at the beginning of the line. Any ifdefs or multiline comments around the define are ignored.\n\nDefines are stored inside Emacs variables using the name vh-{definename}.\n\nLocalparams define what symbols are constants so that AUTOSENSE will not include them in sensitivity lists. However any parameters in the include file are not considered ports in the including file, thus will not appear in AUTOINSTPARAM lists for a parent module..\n\nThe file variables feature can be used to set defines that verilog-mode can see; put at the *END* of your file something like:\n\n// Local Variables: // vh-macro:\"macro_definition\" // End:\n\nIf macros are defined earlier in the same file and you want their values, you can read them automatically with:\n\n// Local Variables: // verilog-auto-read-includes:t // End:\n\nOr a more specific alternative example, which requires having `enable-local-eval' non-nil:\n\n// Local Variables: // eval:(verilog-read-defines) // eval:(verilog-read-defines \"group_standard_includes.v\") // End:\n\nNote these are only read when the file is first visited, you must use M-x find-alternate-file RET to have these take effect after editing them!\n\nIf you want to disable the \"Process `eval' or hook local variables\" warning message, you need to add to your init file:\n\n(setq enable-local-eval t)\n\nverilog-read-includes (function)\n\nRead `includes for the current file. This will find all of the `includes which are at the beginning of lines, ignoring any ifdefs or multiline comments around them. verilog-read-defines is then performed on the current and each included file.\n\nIt is often useful put at the *END* of your file something like:\n\n// Local Variables: // verilog-auto-read-includes:t // End:\n\nOr the equivalent longer version, which requires having `enable-local-eval' non-nil:\n\n// Local Variables: // eval:(verilog-read-defines) // eval:(verilog-read-includes) // End:\n\nNote includes are only read when the file is first visited, you must use M-x find-alternate-file RET to have these take effect after editing them!\n\nIt is good to get in the habit of including all needed files in each .v file that needs it, rather than waiting for compile time. This will aid this process, Verilint, and readability. To prevent defining the same variable over and over when many modules are compiled together, put a test around the inside each include file:\n\nfoo.v (an include file):\n\n`ifndef _FOO_V // include if not already included `define _FOO_V ... contents of file `endif // _FOO_V\n\nverilog-read-sub-decls (function)\n\nInternally parse signals going to modules under this module. Return an array of [ outputs inouts inputs ] signals for modules that are instantiated in this module. For example if declare A A (.B(SIG)) and SIG is an output, then SIG will be included in the list.\n\nThis only works on instantiations created with /*AUTOINST*/ converted by M-x verilog-auto-inst. Otherwise, it would have to read in the whole component library to determine connectivity of the design.\n\nOne work around for this problem is to manually create // Inputs and // Outputs comments above subcell signals, then have an empty AUTOINST, for example:\n\nsubmod SubModuleName ( // Outputs .out (out), // Inputs .in (in) /*AUTOINST*/);\n\nverilog-save-buffer-state (function)\n\nExecute BODY forms, saving state around insignificant change. Changes in text properties like `face' or `syntax-table' are considered insignificant. This macro allows text properties to be changed, even in a read-only buffer.\n\nA change is considered significant if it affects the buffer text in any way that isn't completely restored again. Any user-visible changes to the buffer must not be within a verilog-save-buffer-state.\n\nverilog-save-font-no-change-functions (function)\n\nExecute BODY forms, disabling all change hooks in BODY. Includes temporary disabling of `font-lock' to restore the buffer to full text form for parsing. Additional actions may be specified with verilog-before-save-font-hook and verilog-after-save-font-hook. For insignificant changes, see instead verilog-save-buffer-state.\n\nverilog-set-compile-command (function)\n\nFunction to compute shell command to compile Verilog.\n\nThis reads verilog-tool and sets `compile-command'. This specifies the program that executes when you type M-x compile or M-x verilog-auto-save-compile.\n\nBy default verilog-tool uses a Makefile if one exists in the current directory. If not, it is set to the verilog-linter, verilog-compiler, verilog-coverage, verilog-preprocessor, or verilog-simulator variables, as selected with the Verilog -> \"Choose Compilation Action\" menu.\n\nYou should set verilog-tool or the other variables to the path and arguments for your Verilog simulator. For example:\n\n\"vcs -p123 -O\"\n\nor a string like:\n\n\"(cd /tmp; surecov %s)\".\n\nIn the former case, the path to the current buffer is concat'ed to the value of verilog-tool; in the later, the path to the current buffer is substituted for the %s.\n\nWhere __FLAGS__ appears in the string verilog-current-flags will be substituted.\n\nWhere __FILE__ appears in the string, the variable `buffer-file-name' of the current buffer, without the directory portion, will be substituted.\n\nverilog-simulator (customizable variable)\n\nProgram and arguments to use to interpret Verilog source. Depending on the verilog-set-compile-command, this may be invoked when you type M-x compile. When the compile completes, M-x next-error will take you to the next lint error.\n\nverilog-tab-always-indent (customizable variable)\n\nNon-nil means TAB should always re-indent the current line. A nil value means TAB will only reindent when at the beginning of the line.\n\nverilog-tab-to-comment (customizable variable)\n\nNon-nil means TAB moves to the right hand column in preparation for a comment.\n\nverilog-tool (variable)\n\nWhich tool to use for building compiler-command. Either nil, verilog-linter, verilog-compiler, verilog-coverage, verilog-preprocessor, or verilog-simulator. Alternatively use the \"Choose Compilation Action\" menu. See verilog-set-compile-command for more information.\n\nverilog-typedef-regexp (customizable variable)\n\nIf non-nil, regular expression that matches Verilog-2001 typedef names. For example, \"_t$\" matches typedefs named with _t, as in the C language. See also verilog-case-fold.\n\nverilog-warn (function)\n\nPrint a warning with `format' using STRING and optional ARGS.\n\nverilog-warn-error (function)\n\nCall `error' using STRING and optional ARGS. If verilog-warn-fatal is non-nil, call verilog-warn instead.\n\nverilog-warn-fatal (customizable variable)"
    }
}