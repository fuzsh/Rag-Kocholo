{
    "id": "dbpedia_4953_2",
    "rank": 65,
    "data": {
        "url": "https://docs.python.org/3.13/whatsnew/3.13.html",
        "read_more_link": "",
        "language": "en",
        "title": "Whatâs New In Python 3.13",
        "top_image": "https://docs.python.org/3/_static/og-image.png",
        "meta_img": "https://docs.python.org/3/_static/og-image.png",
        "images": [
            "https://docs.python.org/3.13/_static/py.svg",
            "https://docs.python.org/3.13/_static/py.svg",
            "https://docs.python.org/3.13/_static/py.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Editor, Thomas Wouters,. This article explains the new features in Python 3.13, compared to 3.12. Python 3.13 will be released on October 1, 2024. For full details, see the changelog. Summary â Rel...",
        "meta_lang": "en",
        "meta_favicon": "../_static/py.svg",
        "meta_site_name": "Python documentation",
        "canonical_link": "https://docs.python.org/3/whatsnew/3.13.html",
        "text": "Summary â Release HighlightsÂ¶\n\nPython 3.13 will be the latest stable release of the Python programming language, with a mix of changes to the language, the implementation and the standard library. The biggest changes include a new interactive interpreter, experimental support for running in a free-threaded mode (PEP 703), and a Just-In-Time compiler (PEP 744).\n\nError messages continue to improve, with tracebacks now highlighted in color by default. The locals() builtin now has defined semantics for changing the returned mapping, and type parameters now support default values.\n\nThe library changes contain removal of deprecated APIs and modules, as well as the usual improvements in user-friendliness and correctness. Several legacy standard library modules have now been removed following their deprecation in Python 3.11 (PEP 594).\n\nThis article doesnât attempt to provide a complete specification of all new features, but instead gives a convenient overview. For full details refer to the documentation, such as the Library Reference and Language Reference. To understand the complete implementation and design rationale for a change, refer to the PEP for a particular new feature; but note that PEPs usually are not kept up-to-date once a feature has been fully implemented. See Porting to Python 3.13 for guidance on upgrading from earlier versions of Python.\n\nInterpreter improvements:\n\nA greatly improved interactive interpreter and improved error messages.\n\nPEP 667: The locals() builtin now has defined semantics when mutating the returned mapping. Python debuggers and similar tools may now more reliably update local variables in optimized scopes even during concurrent code execution.\n\nPEP 703: CPython 3.13 has experimental support for running with the global interpreter lock disabled. See Free-threaded CPython for more details.\n\nPEP 744: A basic JIT compiler was added. It is currently disabled by default (though we may turn it on later). Performance improvements are modest â we expect to improve this over the next few releases.\n\nColor support in the new interactive interpreter, as well as in tracebacks and doctest output. This can be disabled through the PYTHON_COLORS and NO_COLOR environment variables.\n\nPython data model improvements:\n\n__static_attributes__ stores the names of attributes accessed through self.X in any function in a class body.\n\n__firstlineno__ records the first line number of a class definition.\n\nSignificant improvements in the standard library:\n\nAdd a new PythonFinalizationError exception, raised when an operation is blocked during finalization.\n\nThe argparse module now supports deprecating command-line options, positional arguments, and subcommands.\n\nThe new functions base64.z85encode() and base64.z85decode() support encoding and decoding Z85 data.\n\nThe copy module now has a copy.replace() function, with support for many builtin types and any class defining the __replace__() method.\n\nThe dbm.sqlite3 module is now the default dbm backend.\n\nThe os module has a suite of new functions for working with Linuxâs timer notification file descriptors.\n\nSecurity improvements:\n\nssl.create_default_context() sets ssl.VERIFY_X509_PARTIAL_CHAIN and ssl.VERIFY_X509_STRICT as default flags.\n\nC API improvements:\n\nNew typing features:\n\nPlatform support:\n\nPEP 730: Appleâs iOS is now an officially supported platform, at tier 3. Official Android support (PEP 738) is in the works as well.\n\nwasm32-wasi is now a supported as a tier 2 platform.\n\nwasm32-emscripten is no longer an officially supported platform.\n\nImportant removals:\n\nPEP 594: The remaining 19 âdead batteriesâ have been removed from the standard library: aifc, audioop, cgi, cgitb, chunk, crypt, imghdr, mailcap, msilib, nis, nntplib, ossaudiodev, pipes, sndhdr, spwd, sunau, telnetlib, uu and xdrlib.\n\nRemove the !2to3 tool and lib2to3 module (deprecated in Python 3.11).\n\nRemove the tkinter.tix module (deprecated in Python 3.6).\n\nRemove locale.resetlocale().\n\nRemove typing.io and typing.re.\n\nRemove chained classmethod descriptors.\n\nRelease schedule changes:\n\nPEP 602 (âAnnual Release Cycle for Pythonâ) has been updated to extend the full support (âbugfixâ) period for new releases to two years. This updated policy means that:\n\nPython 3.9â3.12 have one and a half years of full support, followed by three and a half years of security fixes.\n\nPython 3.13 and later have two years of full support, followed by three years of security fixes.\n\nNew FeaturesÂ¶\n\nA Better Interactive InterpreterÂ¶\n\nOn Unix-like systems like Linux or macOS as well as Windows, Python now uses a new interactive shell. When the user starts the REPL from an interactive terminal the interactive shell now supports the following new features:\n\nColorized prompts.\n\nMultiline editing with history preservation.\n\nInteractive help browsing using F1 with a separate command history.\n\nHistory browsing using F2 that skips output as well as the >>> and â¦ prompts.\n\nâPaste modeâ with F3 that makes pasting larger blocks of code easier (press F3 again to return to the regular prompt).\n\nThe ability to issue REPL-specific commands like help, exit, and quit without the need to use call parentheses after the command name.\n\nIf the new interactive shell is not desired, it can be disabled via the PYTHON_BASIC_REPL environment variable.\n\nThe new shell requires curses on Unix-like systems.\n\nFor more on interactive mode, see Interactive Mode.\n\n(Contributed by Pablo Galindo Salgado, Åukasz Langa, and Lysandros Nikolaou in gh-111201 based on code from the PyPy project. Windows support contributed by Dino Viehland and Anthony Shaw.)\n\nImproved Error MessagesÂ¶\n\nThe interpreter now colorizes error messages when displaying tracebacks by default. This feature can be controlled via the new PYTHON_COLORS environment variable as well as the canonical NO_COLOR and FORCE_COLOR environment variables. See also Controlling color. (Contributed by Pablo Galindo Salgado in gh-112730.)\n\nA common mistake is to write a script with the same name as a standard library module. When this results in errors, we now display a more helpful error message:\n\n$ python random.py Traceback (most recent call last): File \"/home/random.py\", line 1, in <module> import random; print(random.randint(5)) ^^^^^^^^^^^^^ File \"/home/random.py\", line 1, in <module> import random; print(random.randint(5)) ^^^^^^^^^^^^^^ AttributeError: module 'random' has no attribute 'randint' (consider renaming '/home/random.py' since it has the same name as the standard library module named 'random' and the import system gives it precedence)\n\nSimilarly, if a script has the same name as a third-party module it attempts to import, and this results in errors, we also display a more helpful error message:\n\n$ python numpy.py Traceback (most recent call last): File \"/home/numpy.py\", line 1, in <module> import numpy as np; np.array([1,2,3]) ^^^^^^^^^^^^^^^^^^ File \"/home/numpy.py\", line 1, in <module> import numpy as np; np.array([1,2,3]) ^^^^^^^^ AttributeError: module 'numpy' has no attribute 'array' (consider renaming '/home/numpy.py' if it has the same name as a third-party module you intended to import)\n\n(Contributed by Shantanu Jain in gh-95754.)\n\nWhen an incorrect keyword argument is passed to a function, the error message now potentially suggests the correct keyword argument. (Contributed by Pablo Galindo Salgado and Shantanu Jain in gh-107944.)\n\n>>> \"better error messages!\".split(max_split=1) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> \"better error messages!\".split(max_split=1) ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^ TypeError: split() got an unexpected keyword argument 'max_split'. Did you mean 'maxsplit'?\n\nClasses have a new __static_attributes__ attribute, populated by the compiler, with a tuple of names of attributes of this class which are assigned through self.X from any function in its body. (Contributed by Irit Katriel in gh-115775.)\n\nDefined mutation semantics for locals()Â¶\n\nHistorically, the expected result of mutating the return value of locals() has been left to individual Python implementations to define.\n\nThrough PEP 667, Python 3.13 standardises the historical behaviour of CPython for most code execution scopes, but changes optimized scopes (functions, generators, coroutines, comprehensions, and generator expressions) to explicitly return independent snapshots of the currently assigned local variables, including locally referenced nonlocal variables captured in closures.\n\nThis change to the semantics of locals() in optimized scopes also affects the default behaviour of code execution functions that implicitly target locals() if no explicit namespace is provided (such as exec() and eval()). In previous versions, whether or not changes could be accessed by calling locals() after calling the code execution function was implementation dependent. In CPython specifically, such code would typically appear to work as desired, but could sometimes fail in optimized scopes based on other code (including debuggers and code execution tracing tools) potentially resetting the shared snapshot in that scope. Now, the code will always run against an independent snapshot of the local variables in optimized scopes, and hence the changes will never be visible in subsequent calls to locals(). To access the changes made in these cases, an explicit namespace reference must now be passed to the relevant function. Alternatively, it may make sense to update affected code to use a higher level code execution API that returns the resulting code execution namespace (e.g. runpy.run_path() when executing Python files from disk).\n\nTo ensure debuggers and similar tools can reliably update local variables in scopes affected by this change, FrameType.f_locals now returns a write-through proxy to the frameâs local and locally referenced nonlocal variables in these scopes, rather than returning an inconsistently updated shared dict instance with undefined runtime semantics.\n\nSee PEP 667 for more details, including related C API changes and deprecations. Porting notes are also provided below for the affected Python APIs and C APIs.\n\n(PEP and implementation contributed by Mark Shannon and Tian Gao in gh-74929. Documentation updates provided by Guido van Rossum and Alyssa Coghlan.)\n\nIncremental Garbage CollectionÂ¶\n\nThe cycle garbage collector is now incremental. This means that maximum pause times are reduced by an order of magnitude or more for larger heaps.\n\nSupport For Mobile PlatformsÂ¶\n\niOS is now a PEP 11 supported platform. arm64-apple-ios (iPhone and iPad devices released after 2013) and arm64-apple-ios-simulator (Xcode iOS simulator running on Apple Silicon hardware) are now tier 3 platforms.\n\nx86_64-apple-ios-simulator (Xcode iOS simulator running on older x86_64 hardware) is not a tier 3 supported platform, but will be supported on a best-effort basis.\n\nSee PEP 730: for more details.\n\n(PEP written and implementation contributed by Russell Keith-Magee in gh-114099.)\n\nExperimental JIT CompilerÂ¶\n\nWhen CPython is configured using the --enable-experimental-jit option, a just-in-time compiler is added which may speed up some Python programs.\n\nThe internal architecture is roughly as follows.\n\nWe start with specialized Tier 1 bytecode. See Whatâs new in 3.11 for details.\n\nWhen the Tier 1 bytecode gets hot enough, it gets translated to a new, purely internal Tier 2 IR, a.k.a. micro-ops (âuopsâ).\n\nThe Tier 2 IR uses the same stack-based VM as Tier 1, but the instruction format is better suited to translation to machine code.\n\nWe have several optimization passes for Tier 2 IR, which are applied before it is interpreted or translated to machine code.\n\nThere is a Tier 2 interpreter, but it is mostly intended for debugging the earlier stages of the optimization pipeline. The Tier 2 interpreter can be enabled by configuring Python with --enable-experimental-jit=interpreter.\n\nWhen the JIT is enabled, the optimized Tier 2 IR is translated to machine code, which is then executed.\n\nThe machine code translation process uses a technique called copy-and-patch. It has no runtime dependencies, but there is a new build-time dependency on LLVM.\n\nThe --enable-experimental-jit flag has the following optional values:\n\nno (default) â Disable the entire Tier 2 and JIT pipeline.\n\nyes (default if the flag is present without optional value) â Enable the JIT. To disable the JIT at runtime, pass the environment variable PYTHON_JIT=0.\n\nyes-off â Build the JIT but disable it by default. To enable the JIT at runtime, pass the environment variable PYTHON_JIT=1.\n\ninterpreter â Enable the Tier 2 interpreter but disable the JIT. The interpreter can be disabled by running with PYTHON_JIT=0.\n\n(On Windows, use PCbuild/build.bat --experimental-jit to enable the JIT or --experimental-jit-interpreter to enable the Tier 2 interpreter.)\n\nSee PEP 744 for more details.\n\n(JIT by Brandt Bucher, inspired by a paper by Haoran Xu and Fredrik Kjolstad. Tier 2 IR by Mark Shannon and Guido van Rossum. Tier 2 optimizer by Ken Jin.)\n\nFree-threaded CPythonÂ¶\n\nCPython will run with the global interpreter lock (GIL) disabled when configured using the --disable-gil option at build time. This is an experimental feature and therefore isnât used by default. Users need to either compile their own interpreter, or install one of the experimental builds that are marked as free-threaded. See PEP 703 âMaking the Global Interpreter Lock Optional in CPythonâ for more detail.\n\nFree-threaded execution allows for full utilization of the available processing power by running threads in parallel on available CPU cores. While not all software will benefit from this automatically, programs designed with threading in mind will run faster on multicore hardware.\n\nWork is still ongoing: expect some bugs and a substantial single-threaded performance hit.\n\nThe free-threaded build still supports optionally running with the GIL enabled at runtime using the environment variable PYTHON_GIL or the command line option -X gil.\n\nTo check if the current interpreter is configured with --disable-gil, use sysconfig.get_config_var(\"Py_GIL_DISABLED\"). To check if the GIL is actually disabled in the running process, the sys._is_gil_enabled() function can be used.\n\nC-API extension modules need to be built specifically for the free-threaded build. Extensions that support running with the GIL disabled should use the Py_mod_gil slot. Extensions using single-phase init should use PyUnstable_Module_SetGIL() to indicate whether they support running with the GIL disabled. Importing C extensions that donât use these mechanisms will cause the GIL to be enabled, unless the GIL was explicitly disabled with the PYTHON_GIL environment variable or the -X gil=0 option.\n\npip 24.1b1 or newer is required to install packages with C extensions in the free-threaded build."
    }
}