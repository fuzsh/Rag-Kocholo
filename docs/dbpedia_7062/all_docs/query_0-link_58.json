{
    "id": "dbpedia_7062_0",
    "rank": 58,
    "data": {
        "url": "https://stackoverflow.com/questions/71799332/how-to-check-if-values-in-first-dataframe-are-contained-or-match-values-in-anoth",
        "read_more_link": "",
        "language": "en",
        "title": "How to check if values in first dataframe are contained or match values in another dataframe",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://cdn.sstatic.net/Img/teams/teams-promo.svg?v=e507948b81bf",
            "https://i.sstatic.net/jbNmb.png?s=64",
            "https://lh3.googleusercontent.com/a/AATXAJz2VJMlTaQV3pxMyYkXAOo2IgH26PSG_QmOqluM=k-s64",
            "https://i.sstatic.net/jbNmb.png?s=64",
            "https://i.sstatic.net/tafbs.jpg?s=64",
            "https://www.gravatar.com/avatar/87d0df319eeb565854d5a4c75fae79a9?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/MEwgs.jpg?s=64",
            "https://i.sstatic.net/PxE8G.jpg?s=64",
            "https://i.sstatic.net/SuM0U.png?s=64",
            "https://www.gravatar.com/avatar/526b94176d266a140db6da51b82ba3f6?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f9fa170eac0c6ac139fdbad065ec1db1?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/a55d725cb5f90c78cd8ecf649714e184?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/71799332/ivc/cc5e?prg=4ff14191-53d7-48e0-b008-bf7c0bf2331d"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-04-08T15:08:47",
        "summary": "",
        "meta_description": "I am using R to work with some dataframes. My issue is related on how to check if values in a variable in a first dataframe match with values in another dataframe. The match is very different to th...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/71799332/how-to-check-if-values-in-first-dataframe-are-contained-or-match-values-in-anoth",
        "text": "In case the order of the names does not change .* could be inserted between the names and then use grep in both directions (df1$names in df2$names and df2$names in df1$names) and combine them with or |.\n\ntransform(df1, val = c(\"no\", \"yes\")[1+(sapply(gsub(\" +\", \".*\", df1$name), \\(x) any(grep(x, df2$name)), USE.NAMES = FALSE) | Reduce(\\(y, x) y | grepl(x, df1$name), gsub(\" +\", \".*\", df2$name), FALSE))]) # name val #1 JUAN GIRON yes #2 GINA OLEAS no #3 JUAN FERNANDO ELIZAGA yes #4 MARCO TORRES no #5 JUAN PABLO GONZALEZ yes #6 IRMA GOMEZ yes\n\nIn case no partly match of the names are allowed surround the names with \\b.\n\ntransform(df1, val = c(\"no\", \"yes\")[1+(sapply( gsub(\" *(\\\\b[^ ]+\\\\b)\", \".*\\\\\\\\b\\\\1\\\\\\\\b\", df1$name), \\(x) any(grep(x, df2$name)), USE.NAMES = FALSE) | Reduce(\\(y, x) y | grepl(x, df1$name), gsub(\" *(\\\\b[^ ]+\\\\b)\", \".*\\\\\\\\b\\\\1\\\\\\\\b\", df2$name), FALSE))])\n\nIn case the order can chaange make a positive look ahead by placing the name in (?=.*NAMME) or also surround the name with \\b (?=.*\\\\bNAME\\\\b).\n\ntransform(df1, val = c(\"no\", \"yes\")[1+(sapply( gsub(\" *(\\\\b[^ ]+\\\\b)\", \"(?=.*\\\\\\\\b\\\\1\\\\\\\\b)\", df1$name), \\(x) any(grep(x, df2$name, perl=TRUE)), USE.NAMES = FALSE) | Reduce(\\(y, x) y | grepl(x, df1$name, perl=TRUE), gsub(\" *(\\\\b[^ ]+\\\\b)\", \"(?=.*\\\\\\\\b\\\\1\\\\\\\\b)\", df2$name), FALSE))] )\n\nIts also possible to use agrepl and allow deletions which will be similar to the version assuming that the order of the names does not change and part matches of the name are allowed.\n\ntransform(df1, val = c(\"no\", \"yes\")[1+( sapply(df1$name, \\(x) any(agrepl(x, df2$name, list(cost=99, insertions=0, deletions=99, substitutions=0)))) | Reduce(\\(y, x) y | agrepl(x, df1$name, list(cost=99, insertions=0, deletions=99, substitutions=0)), df2$name, FALSE))])\n\nAnother option can be the usage of look up tables:\n\ns1 <- strsplit(df1$name, \" \", TRUE) lup1 <- list2env(split(rep(seq_along(s1), lengths(s1)), unlist(s1))) s2 <- strsplit(df2$name, \" \", TRUE) lup2 <- list2env(split(rep(seq_along(s2), lengths(s2)), unlist(s2))) `[<-`(sapply(s1, \\(x) any(Reduce(intersect, mget(x, lup2, ifnotfound = list(NULL))))), unlist(lapply(s2, \\(x) Reduce(intersect, mget(x, lup1, ifnotfound = list(NULL))))), TRUE) #[1] TRUE FALSE TRUE FALSE TRUE TRUE\n\nBenchmark:\n\nIts also possible to limit the comparisons only to those which didn't have a match (GKi1b) where maybe the usage of indices using which instead of using the logical vector twice could fuhrer improve and making an exit of the loop in case all have a hit. In case the names are not unique use unique on the names.\n\nlibrary(dplyr) bench::mark( Thomas = df1 %>% mutate(val = c(\"no\", \"yes\")[1 + (rowSums( outer( strsplit(name, \"\\\\s+\"), strsplit(df2$name, \"\\\\s+\"), Vectorize(function(x, y) all(x %in% y) | all(y %in% x)) ) ) > 0)]), GKi1 = transform(df1, val = c(\"no\", \"yes\")[1+(sapply(gsub(\" +\", \".*\", df1$name), \\(x) any(grep(x, df2$name)), USE.NAMES = FALSE) | Reduce(\\(y, x) y | grepl(x, df1$name), gsub(\" +\", \".*\", df2$name), FALSE))]), GKi1b = transform(df1, val = c(\"no\", \"yes\")[1 + Reduce(\\(i, x) `[<-`(i, !i, grepl(x, df1$name[!i])), gsub(\" +\", \".*\", df2$name), sapply(gsub(\" +\", \".*\", df1$name), \\(x) any(grep(x, df2$name)), USE.NAMES = FALSE)) ]), GKi1c = transform(df1, val = c(\"no\", \"yes\")[1+(sapply(gsub(\" +\", \".*\", df1$name), \\(x) any(grep(x, df2$name)), USE.NAMES = FALSE) | grepl(paste(gsub(\" +\", \".*\", df2$name), collapse = \"|\"), df1$name) )]), GKi2 = transform(df1, val = c(\"no\", \"yes\")[1+(sapply( gsub(\" *(\\\\b[^ ]+\\\\b)\", \".*\\\\\\\\b\\\\1\\\\\\\\b\", df1$name), \\(x) any(grep(x, df2$name)), USE.NAMES = FALSE) | Reduce(\\(y, x) y | grepl(x, df1$name), gsub(\" *(\\\\b[^ ]+\\\\b)\", \".*\\\\\\\\b\\\\1\\\\\\\\b\", df2$name), FALSE))]), GKi3 = transform(df1, val = c(\"no\", \"yes\")[1+(sapply( gsub(\" *(\\\\b[^ ]+\\\\b)\", \"(?=.*\\\\\\\\b\\\\1\\\\\\\\b)\", df1$name), \\(x) any(grep(x, df2$name, perl=TRUE)), USE.NAMES = FALSE) | Reduce(\\(y, x) y | grepl(x, df1$name, perl=TRUE), gsub(\" *(\\\\b[^ ]+\\\\b)\", \"(?=.*\\\\\\\\b\\\\1\\\\\\\\b)\", df2$name), FALSE))] ), GKi4 = transform(df1, val = c(\"no\", \"yes\")[1+( sapply(df1$name, \\(x) any(agrepl(x, df2$name, list(cost=99, insertions=0, deletions=99, substitutions=0)))) | Reduce(\\(y, x) y | agrepl(x, df1$name, list(cost=99, insertions=0, deletions=99, substitutions=0)), df2$name, FALSE))]), GKi5 = { s1 <- strsplit(df1$name, \" \", TRUE) lup1 <- list2env(split(rep(seq_along(s1), lengths(s1)), unlist(s1))) s2 <- strsplit(df2$name, \" \", TRUE) lup2 <- list2env(split(rep(seq_along(s2), lengths(s2)), unlist(s2))) transform(df1, val = c(\"no\", \"yes\")[1+`[<-`(sapply(s1, \\(x) any(Reduce(base::intersect, mget(x, lup2, ifnotfound = list(NULL))))), unlist(lapply(s2, \\(x) Reduce(base::intersect, mget(x, lup1, ifnotfound = list(NULL))))), TRUE)]) } )\n\nexpression min median `itr/sec` mem_alloc `gc/sec` n_itr n_gc total_time <bch:expr> <bch:tm> <bch:> <dbl> <bch:byt> <dbl> <int> <dbl> <bch:tm> 1 Thomas 863µs 894µs 919. 4.08KB 21.4 429 10 467ms 2 GKi1 211µs 218µs 3770. 0B 14.6 1803 7 478ms 3 GKi1b 211µs 226µs 3020. 0B 14.6 1448 7 479ms 4 GKi1c 183µs 200µs 3424. 0B 10.3 1667 5 487ms 5 GKi2 262µs 275µs 2755. 0B 12.4 1336 6 485ms 6 GKi3 391µs 409µs 2010. 0B 9.19 875 4 435ms 7 GKi4 374µs 386µs 2295. 0B 16.5 1110 8 484ms 8 GKi5 272µs 285µs 2570. 2.82KB 21.1 1220 10 475ms\n\nAll variants are more than 2 times faster than ThomasIsCoding using one CPU-core.\n\nI'm going for robust here, rather than speed or elegance. I am certain that it could be cleaned up and sped up, but this addresses all of the discussed concerns including the added specification in the comments about handling family and given name matches separately.\n\nFirst, here is updated data that has the family and given names split:\n\ndf1_split <- tibble( Given = c(\"JUAN\", \"GINA\", \"JUAN FERNANDO\" , \"MARCO\", \"JUAN PABLO\", \"IRMA\" , \"JUAN\", \"JUAN CARLOS\") , Family = c(\"GIRON\", \"OLEAS\", \"ELIZAGA\" , \"TORRES\", \"GONZALEZ\", \"GOMEZ\" , \"GOMEZ\", \"MARTINEZ\") ) df2_split <- tibble( Given = c(\"JUANA\", \"FERNANDO\", \"IRMA\", \"PABLO\", \"GINA\", \"MARK\", \"LETICIA\", \"JUAN PABLO\" , \"FERNANDO CARLOS\" , \"JUAN FERNANDO\") , Family = c(\"MARQUEZ\", \"ELIZAGA\", \"GOMEZ\", \"GONZALEZ\", \"LUCIO\", \"TORRES\", \"BLACIO\", \"GIRON BELTRAN\" , \"MARTINEZ\" , \"ELIZAGA\") )\n\nNote that I added a couple of names to highlight some of the problems with the doubled names.\n\nThen, this function will check any name set. It handles the names differently depending on whether they are single (e.g. \"Juan\") or dual-named (e.g., \"Juan Carlos\"). For single names to be checked, it just looks if they are present at all. For dual-named names, it checks that they are in the same order if the name to check against has two names as well or if either name is present if the name to check against only has one name.\n\ncheck_names <- function(to_check, against){ split_against <- str_split(against, \" \") str_split(to_check, \" \") %>% lapply(function(this_name){ if(length(this_name) == 1){ to_ret <- sapply(split_against, function(this_against){ any(this_name == this_against) }) %>% which } else if(length(this_name) == 2){ to_ret <- sapply(split_against, function(this_against){ if(length(this_against) == 2){ return(all(this_against == this_name)) } else if(length(this_against) == 1){ return(any(this_against == this_name)) } else{ stop(\"Names (against) cannot have three words: \" , this_against) } }) %>% which } else{ stop(\"Names (to_check) cannot have three words: \" , this_name) } }) }\n\nThen, we wrap that function together to pass the family and given names separately. The results are then checked to see if there are any indices that are matches for both the family and given names.\n\ncheck_both_simple <- function(to_check_given, to_check_family, against_given, against_family){ checked_given <- check_names(to_check_given, against_given) checked_family <- check_names(to_check_family, against_family) valid_matches <- lapply(1:length(checked_given), function(idx){ checked_given[[idx]][checked_given[[idx]] %in% checked_family[[idx]]] }) to_return <- ifelse(sapply(valid_matches, length) > 0 , \"yes\" , \"no\") return(to_return) }\n\nWe can then use this in a call from mutate to add the column:\n\ndf1_split %>% mutate(Match = check_both_simple(Given, Family , df2_split$Given , df2_split$Family))\n\nReturns:\n\n# A tibble: 8 × 3 Given Family Match <chr> <chr> <chr> 1 JUAN GIRON yes 2 GINA OLEAS no 3 JUAN FERNANDO ELIZAGA yes 4 MARCO TORRES no 5 JUAN PABLO GONZALEZ yes 6 IRMA GOMEZ yes 7 JUAN GOMEZ no 8 JUAN CARLOS MARTINEZ no\n\nAnd should handle all of the odd edge cases discussed in the comments as well.\n\nThe nice thing about this approach (and part of why I built it this robustly in the first place), is that you can also set the function to return the matching indices.\n\ncheck_both_idx <- function(to_check_given, to_check_family, against_given, against_family){ checked_given <- check_names(to_check_given, against_given) checked_family <- check_names(to_check_family, against_family) valid_matches <- lapply(1:length(checked_given), function(idx){ checked_given[[idx]][checked_given[[idx]] %in% checked_family[[idx]]] }) return(valid_matches) }\n\nUsing this, you can actually pull the matches that are found and manually inspect them. This would allow you to identify any additional edge cases where you didn't agree with a found match or where one match may be markedly better than another.\n\ndf1_split %>% mutate(Match_idx = check_both_idx(Given, Family , df2_split$Given , df2_split$Family) , Matches = sapply(Match_idx, function(this_idx_set){ paste(df2_split$Given[this_idx_set] , df2_split$Family[this_idx_set]) %>% paste(collapse = \"; \") }) , Match = ifelse(sapply(Match_idx, length) > 0 , \"yes\" , \"no\") , Match_idx = sapply(Match_idx, paste, collapse = \"; \") )\n\nReturns:\n\n# A tibble: 8 × 5 Given Family Match_idx Matches Match <chr> <chr> <chr> <chr> <chr> 1 JUAN GIRON \"8\" \"JUAN PABLO GIRON BELTRAN\" yes 2 GINA OLEAS \"\" \"\" no 3 JUAN FERNANDO ELIZAGA \"2; 10\" \"FERNANDO ELIZAGA; JUAN FERNANDO ELIZAGA\" yes 4 MARCO TORRES \"\" \"\" no 5 JUAN PABLO GONZALEZ \"4\" \"PABLO GONZALEZ\" yes 6 IRMA GOMEZ \"3\" \"IRMA GOMEZ\" yes 7 JUAN GOMEZ \"\" \"\" no 8 JUAN CARLOS MARTINEZ \"\" \"\" no\n\nEditing to add: The following two sets present some tricky examples that would currently be decided incorrectly by the other answers. These examples arose from the discussion in the comments to clarify what should match.\n\ntricky_1 <- tibble( Given = c(\"JUAN\", \"JUANITA GINA\" , \"JUAN CARLO\", \"GOMEZ\") , Family = c(\"GIRON BELTRAN\", \"OLEAS\" , \"MARTINEZ\", \"IRMA\") ) tricky_2 <- tibble( Given = c(\"JUAN PABLO\", \"GINA\" , \"CARLO JUAN\", \"IRMA\") , Family = c(\"GIRON\", \"OLEAS GIRON\" , \"MARTINEZ\", \"GOMEZ\") )\n\nWe can view them side by side like so:\n\nbind_cols( tricky_1 %>% setNames(paste0(\"toCheck_\", names(.))) , tricky_2 %>% setNames(paste0(\"against_\", names(.))) ) %>% mutate(shouldMatch = c(\"yes\", \"yes\", \"no\", \"no\"))\n\nreturns:\n\n# A tibble: 4 × 5 toCheck_Given toCheck_Family against_Given against_Family shouldMatch <chr> <chr> <chr> <chr> <chr> 1 JUAN GIRON BELTRAN JUAN PABLO GIRON yes 2 JUANITA GINA OLEAS GINA OLEAS GIRON yes 3 JUAN CARLO MARTINEZ CARLO JUAN MARTINEZ no 4 GOMEZ IRMA IRMA GOMEZ no\n\nThe first two should match because the family and given names each have a 1-2 match in each direction. However, that means that neither the name to check or the name to check against is completely contained in the other. The third shares all of the components, but I believe that \"JUAN CARLO\" should not match \"CARLO JUAN.\" The fourth has the family and given names reversed, so shouldn't return a match.\n\nThe code from my answer handles these cases:\n\ntricky_1 %>% mutate(Match_idx = check_both_idx(Given, Family , tricky_2$Given , tricky_2$Family) , Matches = sapply(Match_idx, function(this_idx_set){ paste(tricky_2$Given[this_idx_set] , tricky_2$Family[this_idx_set]) %>% paste(collapse = \"; \") }) , Match = ifelse(sapply(Match_idx, length) > 0 , \"yes\" , \"no\") , Match_idx = sapply(Match_idx, paste, collapse = \"; \") )\n\nReturns:\n\n# A tibble: 4 × 5 Given Family Match_idx Matches Match <chr> <chr> <chr> <chr> <chr> 1 JUAN GIRON BELTRAN \"1\" \"JUAN PABLO GIRON\" yes 2 JUANITA GINA OLEAS \"2\" \"GINA OLEAS GIRON\" yes 3 JUAN CARLO MARTINEZ \"\" \"\" no 4 GOMEZ IRMA \"\" \"\" no"
    }
}