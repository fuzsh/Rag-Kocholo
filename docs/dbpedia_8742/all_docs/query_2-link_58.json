{
    "id": "dbpedia_8742_2",
    "rank": 58,
    "data": {
        "url": "https://binfalse.de/2018/02/20/dockerising-a-contao-website-ii/",
        "read_more_link": "",
        "language": "en",
        "title": "Dockerising a Contao website II",
        "top_image": "https://binfalse.de/assets/ico/favicon.png",
        "meta_img": "https://binfalse.de/assets/ico/favicon.png",
        "images": [
            "https://binfalse.de/assets/ico/mainpic-2020.png",
            "https://binfalse.de/assets/ico/mainpic-2020.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Martin Scharm"
        ],
        "publish_date": "2018-02-20T00:00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "/assets/ico/favicon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "This article is based on Contao 3. There is a new version, see Dockerising Contao 4\n\nIn a previous post I explained how to run a Contao website in a Docker infrastructure. That was a good opening. However, after running that setup for some time I discovered a few issuesâ¦\n\nA central idea of Docker is to install the application in an image and mount persistent files into a running container. Thus, you can just throw away an instance of the app and start a new one very quickly (e.g. with an updated version of the app). Unfortunately, using Contao itâs not that straight-forward â at least when using the image decribed earlier.\n\nHere Iâm describing how I fought the issues:\n\nIssues with Cron\n\nThe first issue was Contaoâs Poor-Man-Cron. This cron works as follows:\n\nThe browser requests a file cron.txt, which is supposed to contain the timestamp of the last cron run.\n\nIf the timestamp is âtooâ old, the browser will also request a cron.php, which then runs overdue jobs.\n\nIf a job was run, the timestamp in cron.txt will be updated, so cron.php wonât be run every time.\n\nGood, but that means the cron.txt will only be written, if a cron job gets executed. But letâs assume the next job will only be run next week end!? The last cron-run-time is stored in the database, but the cron.txt wonât exist by default. That means, even if the cron.php is run, it will know that there is no cron job to execute and, therefore, exit without creating/updating the cron.txt. Especially when using Docker you will hit such a scenario every time when starting a new container.. Thus, every user creates a 404 error (as there is no cron.txt), which is of course ugly and spams the logs..\n\nI fixed the issue by extending the Contao source code. The patch is already merged into the official release of Contao 3.5.33. In addition, Iâm initialising the cron.txt in my Docker image with a time stamp of 0, see the Dockerfile.\n\nIssues with Proxies\n\nA typical Docker infrastructure (at least for me) consists of bunch containers orchestrated in various networks etc.. Usually, youâll have at least one (reverse) proxy, which distributes HTTP request to the container in charge. However, I experienced a few issues with my proxy setup:\n\nHTTPS vs HTTP\n\nWhile the connection between client (user, web browser) and reverse proxy is SSL-encrypted, the proxy and the webserver talk plain HTTP. As itâs the same machine, there is no big need to waste time on encryption. But Contao has a problem with that setup. Even though, the reverse proxy properly sends the HTTP_X_FORWARDED_PROTO, Contao only sees incomming HTTP traffic and uses http://-URLs in all documentsâ¦ Even if you ignore the mixed-content issue and/or implement a rewrite of HTTP to HTTPS at the web-server-layer, this will produce twice as much connections as necessary!\n\nThe solution is however not that difficult. Contao does not understand HTTP_X_FORWARDED_PROTO, but it recognises the $_SERVER['HTTPS'] variable. Thus, to fix that issue you just need to add the following to your system/config/initconfig.php (see also Issue 7542):\n\nIn addition, this will generate URLs including the port number (e.g. https://example.com:443/etc), but they are perfectly valid. (Not like https://example.com:80/etc or something that I saw during my testsâ¦ ;-)\n\nThis workaround doesnât work for Contao 4 anymore! To fix it see Dockerising Contao 4\n\nURL encodings in the Sitemap\n\nThe previous fix brought up just another issue: The URL encoding in the sitemap breaks when using the port component (:443).. Conato uses rawurlencode to encode all URLs before writing them to the sitemap. However, rawurlencode encodes quite a lot! Among others, it converts :s to %3A. Thus, all URLs in my sitemap looked like this: https://example.com%3A443/etc - which is obviously invalid.\n\nI proposed using htmlspecialchars instead to encode the URLs, but it was finally fixed by splitting the URLs and should be working in release 3.5.34.\n\nIssues with Cache and Assets etc\n\nA more delicate issue are cache and assets and sitemaps etc. Contaoâs backend comes with convenient buttons to clear/regenerate these files and to create the search index. Yet, you donât always want to login to the backend when recreating the Docker container.. Sometime you simply canât - for example, if the container needs to be recreated over night.\n\nBasically, that is not a big issue. Assets and cache will be regenerate once they are needed. But the sitemaps, for instance, will only be generated when interacting with the backend.\n\nThus, we need a solution to create these files as soon as possible, preferably in the background after a container is created. Most of the stuff can be done using the Automator tool, but I also have some personal scripts developed by a company, that require other mechanisms and are unfortunately not properly integrated into Contaoâs hooks landscape. And if we need to touch code anyways, we can also generate all assets and rebuild the search index manually (precreating necessary assets will later on speed up things for usersâ¦). To generate all assets (images and scripts etc), we just need to access every single page at the frontend. This will then trigger Contao to create the assets and cache, and subsequent requests from real-life users will be much faster!\n\nThe best hack that I came up with so far looks like the following script, that I uploaded to /files/initialiser.php to Contao instance:\n\nThe first 3 lines initialise the Contao environment. Here I assume that ../system/initialize.php exists (i.e. the script is saved in the files directory). The next few lines purge existing cache using the Automator tool and subsequently regenerate the cache â just to be clean ;-)\n\nFinally, the script (i) collects all âsearchable pagesâ using the Backend::findSearchablePages() functionality, (ii) enriches this set of pages with additional pages that may be hooked-in by plugins etc through $GLOBALS['TL_HOOKS']['getSearchablePages'], and then (iii) uses cURL to iteratively request each page.\n\nButâ¦\n\nThe first part should be reasonably fast, so clients may be willing to wait until the cache stuff is recreated. Accessing every frontend page, however, may require a significant amount of time! Especially for larger web pages.. Thus, I embedded everything in the following skeleton, which advises the browser to close the connection before we start the time-consuming tasks:\n\nHere, the browser is told to close the connection after a certain content size arrived. I buffer the content that I want to transfer using ob_start and ob_end_flush, so I know how big it is (using ob_get_length). Everything after ob_get_length can safely be ignored by the client, and the connection can be closed.\n\n(You cannot be sure that the browser really closes the connection. I saw curl doing it, but also some versions of Firefox still waiting for the script to finishâ¦ Nevertheless, the important content will be transferred quick enough).\n\nIn addition, I created some RewriteRules for mod_rewrite to automatically regenerate missing files. For example, for the sitemaps I added the following to the vhost config (or htaccess):\n\nThat means, if for example /share/sitemap.xml not yet exists, the user gets automagically redirected to our initialiser.php script! In addition, I added some request parameters (?target=sitemap&sitemap=$1), so that the initialiser.php knows which file was requested. It can then regenerate everything and immediately output the new content! :)\n\nFor example, my snippet to regenerate and serve the sitemap looks similar to this:\n\nThus, the request to /share/somesitemap.xml will never fail. If the file does not exist, the client will be redirected to /files/initialiser.php?target=sitemap&sitemap=somesitemap, the file /share/somesitemap.xml will be regenerated, and the new contents will immediately be served. So the client will eventually get the desired content :)\n\nPlease be aware, that this script is easily DOS-able! Attackers may produce a lot of load by accessing the file. Thus, I added some simple DOS protection to the beginning of the script, which makes sure the whole script is not run more than once per hour (3600 seconds):\n\nIf $dryrun is true, it wonât regenerate cache etc, but still serve the sitemap and other files if requested.. However, if there is also no $_GET['target'] defined, we donât know what to serve anyway and can die immediatelyâ¦\n\nYou could include the script at the footer of your webpage, e.g. using\n\n(you may want to make sure that the generated output, if any, is valid JavaScript. E.g. embed everything in /*...*/ or somethingâ¦)\n\nThis way you would make sure, that every request produces a fully initialised system. However, this will probably also create unnecessary load every hourâ¦ You could increase the time span in the DOS-protection-hack, but I guess it should be sufficient to run the script only if a missing file is requested. Earlier requests then need to wait for pending assets etc, but to be honest, that should not be too long (or you have a different problem anywayâ¦).\n\nAnd if your website provides an RSS feed, you could subscribe to it using your default reader, which will regularly make sure that the RSS feed is generated if missing.. (and thus trigger all the other stuff in our initialiser.php) â A feed reader as the poorest-man-cron ;-)\n\nShare\n\nAs I said earlier, my version of the script contains plenty of personalised stuff. Thatâs why I cannot easily share it with you.. :(\n\nHowever, if you have trouble implementing it yourself just let me know :)"
    }
}