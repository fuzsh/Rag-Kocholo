{
    "id": "dbpedia_8742_3",
    "rank": 6,
    "data": {
        "url": "https://docs.contao.org/manual/en/performance/http-caching/",
        "read_more_link": "",
        "language": "en",
        "title": "HTTP Caching :: Contao Manual",
        "top_image": "https://docs.contao.org/manual/images/favicon.png",
        "meta_img": "https://docs.contao.org/manual/images/favicon.png",
        "images": [
            "https://docs.contao.org/manual/images/manual/performance/en/cache-settings.316219d00a7933e29cdaa29748028e06e2a3a11b38ab48948d079a8f3feaa6a2.png?classes=shadow"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "HTTP Caching with Contao.",
        "meta_lang": "en",
        "meta_favicon": "https://docs.contao.org/manual/images/favicon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "HTTP Caching\n\nThe greatest performance gain in any application can be achieved by not having to start it at all. In other words: We want the output that Contao generates to be saved and delivered the next time it is called without having to even boot Contao at all.\n\nTo do so, Contao relies on the Hypertext Transfer Protocol (HTTP) - the backbone of the Internet.\n\nWhy should Contao reinvent the wheel when smart people thought about caching HTTP responses already when HTTP/1.1 was introduced back in 1999?\n\nHTTP\n\nBack to the basics, then. To understand how HTTP caching can be configured in Contao, let’s take a quick look at how HTTP, and therefore the entire Internet and the communication of many other devices, works:\n\nsequenceDiagram participant Client participant Server Client->>Server: Request Server->>Client: Response\n\nIn principle, any other intermediaries (so-called “proxies”) can be connected in between, which is not only conceivable but also very common:\n\nsequenceDiagram participant Client participant Proxy 1 participant Proxy 2 participant Server Client->>Proxy 1: Request Proxy 1->>Proxy 2: Request Proxy 2->>Server: Request Server->>Proxy 2: Response Proxy 2->>Proxy 1: Response Proxy 1->>Client: Response\n\nThese proxies can perform any tasks, including but not limited to\n\nLoad Balancing (distribute high load on different servers)\n\nCDN tasks (lower latency due to geographically shorter distances to the client)\n\nAuthentication/Authorization\n\nEncryption (SSL/TLS)\n\nApplying optimizations (e.g. compression)\n\nand of course: Caching!\n\nTo allow the client (in our case mostly the browser), the server and intermediaries to communicate with each other, every HTTP request and every HTTP response can be enhanced with metadata. These so called “HTTP headers” are standardized but it is up to every developer to invent and use additional headers. E.g. a typical request could look like this:\n\nIn this case the client would like to request the resource that is at /about-us.html and it tells the server that it understands the languages en and de (German) whereas it prefers de over en. It also requests the response from the host www.contao.org. Remember, the communication between client and server uses TCP/IP and one server can serve any number of domains so it is important to tell the server which one you’d like.\n\nA response to this could look like this:\n\nHere, the server tells us that everything was fine (200 OK). The response contains UTF-8 encoded HTML and is 42 bytes long. In addition, this response may be cached for 3600 seconds, i.e. one hour.\n\nThe HTTP Caching Headers\n\nThere are a number of HTTP headers that are relevant for HTTP caching. To explain them all would go beyond the scope of this documentation. The topic is also already extremely well documented on MDN, so you can learn more there if you are interested.\n\nThe regular user of Contao is mainly interested in the Cache-Control header and the three most important attributes:\n\nprivate or public\n\nTells a client whether the response is private or public. The browser, for example, may cache both private and public responses, since it does not pass on the response. A proxy, on the other hand, may not cache private responses, because it passes the response on. They cannot be combined. Something that can be cached publicly can also be cached privately, so a public (public) response implicitly means that multiple clients share the same cache entry. This is why we also speak of a “shared cache” in this case.\n\nmax-age\n\nContains the number of seconds any client may cache this response.\n\ns-maxage\n\nContains the number of seconds a public client is allowed to cache this response. This attribute is only used if the cache duration should be different for public and private clients.\n\nFor better understanding, let’s look at a few examples:\n\nHTTP headerInterpretationCache-Control: max-age=3600Only private clients may cache this response for one hour.Cache-Control: max-age=3600, privateOnly private clients may cache this response for one hour.Cache-Control: max-age=3600, publicBoth public and private clients may cache this response for one hour.Cache-Control: max-age=3600, s-maxage=7200, publicBoth public and private clients may cache this response. Private ones for one hour, public ones for two hours.\n\nAnd that is why you can find exactly these cache duration settings in the Contao page settings. The following configuration translates to Cache-Control: max-age=1800, s-maxage=3600, public:\n\nAdvantages of using standards\n\nThe Contao Managed Edition is shipped with a cache proxy that is written in PHP too and sits directly in front of Contao. This means that every response that Contao generates is sent through our caching proxy before it is delivered to the client and is cached (or not) according to the HTTP headers.\n\nThe big advantage we gain by using HTTP standards is the free choice of the caching proxy. Let’s say the number of visitors gets higher and higher and PHP slowly starts reaching its limits. Maybe you will want to try out a more powerful caching proxy which was explicitly designed for caching such as Varnish?\n\nHowever, this would go too far at this point.\n\nGood to know for you: Whatever settings you have configured in Contao, it follows the HTTP standards and just works out-of-the-box for you. And if one day, the requirements become more complex, Contao will not let you down!\n\nDoes the Cache Proxy cache?\n\nThis section is about what can be stored in the shared cache. We don’t talk about the private cache anymore, i.e. your personal browser cache, because we want to make sure that as many of our visitors as possible don’t have to wait for Contao to generate the response but can benefit from the shared cache instead.\n\nWe already know the most important criterion: The Cache-Control: public response header. If this header is missing, the shared cache can never cache this response. But there are other criteria as well:\n\nThe HTTP status code must either be 200 OK , 301 Permanent Redirector 404 Not Found (there are a number of other statuses, but they are not really relevant for us here).\n\nCache-Control must not contain no-store. This value prevents any caching.\n\nYou need to specify the cache duration, i.e max-age and optionally s-maxage in the Cache-Controlheader (there are additional headers here as well, but they are not relevant for us either)\n\nIn case of the included Contao cache proxy, you can easily check if caching works. All responses will have a Contao-Cache header that can take on three values:\n\nmiss\n\nThe Contao cache could not find a cache entry. Contao is started, generates the response but it cannot be stored in the cache.\n\nmiss/store\n\nThe Contao cache could not find a cache entry. Contao is started, generates the response and it is stored accordingly.\n\nfresh\n\nThe Contao cache has found the cache entry and the response is served directly from the cache. Ideally, you should have already noticed the speed. In case of Contao-Cache: fresh there is also the HTTP Age header. It tells you how many seconds the cache entry already exists. An Age: 120 means that this entry was created two minutes ago.\n\nIf the Contao Managed Edition runs in debug mode, the cache proxy is disabled entirely.\n\nWhen shared caching cannot work\n\nAs we have seen, there are some basic requirements for HTTP caching to work: In addition to the requirements mentioned above, there are other special reasons for Contao to enforce Cache-Control: private and thus exclude a response from the shared cache:\n\nIf the request contains an Authorization HTTP header\n\nThe Authorization header contains standard authentication details. For Contao this means that a module or content element may listen to this header and potentially deliver user-specific data. To ensure that private data is not stored in the shared cache and potentially delivered to a different visitor, Contao forces Cache-Control: private. Contao will also tell you about this: The Contao-Response-Private-Reason header contains authorization in this case.\n\nIt is very popular to protect installations using Basic Authentication during development. This means that the request contains an Authorization header and therefore the cache is always disabled. Keep this in mind when testing cache settings.\n\nIf the request contains a PHP session cookie or the response sets it\n\nThe most obvious case here is of course the PHP session, i.e. when a user logs into the back end or a member logs into the front end. In this case all responses are always private and the Contao-Response-Private-Reason header contains session-cookie.\n\nIf the response contains a cookie\n\nIf the response contains a cookie, it means that the developer wanted to personalize the response. The current response therefore potentially already contains personal data. The Contao-Response-Private-Reason header in this case contains response-cookies and includes a list of the affected cookie names.\n\nIf the request contains a cookie\n\nThis is by far the most likely, but also the most complex case. All request cookies can, but do not have to, disable the cache.\n\nThe rule is quite straightforward: Every cookie can potentially identify a visitor and therefore the application (i.e. Contao) could deliver personalized content (shopping carts, personal recommendations, logins etc.). Remember: The proxy is completely separate from the application, may even be located on another server in another part of the world and therefore has no way of knowing which cookies are relevant for the application. We have to tell it.\n\nThus, a cache proxy is not allowed to deliver anything from the cache if the request contains a cookie. Let’s repeat: Every single cookie implicitly means that the reverse proxy is bypassed. If we want to have a response generated from the cache, we have to make sure that not a single cookie finds its way to the cache proxy.\n\nHowever, there is a large number of cookies. Here are a few examples:\n\n_ga_* cookies by Google Analytics\n\n_pk_* cookies by Matomo\n\nCloudflare’s __cfduid cookie\n\nYour cookiebar_accepted cookie, to know if the cookie policy has been accepted\n\nthe list goes on…\n\nThe list is quite long and the attentive reader has already discovered a fundamental difference between the PHP session cookie and the _ga_* cookie: One of them is really relevant for the application (i.e. the PHP session) and the other one is responsible for client-side tracking (i.e. within the browser) of the user and is completely irrelevant for Contao.\n\nIn other words, if a request contains only a _ga_* cookie, we can still deliver the response from the cache, because this cookie does not generate any personal content. A smart cache proxy could therefore only consider relevant cookies and throw away all the others before deciding whether a response can be delivered from the cache.\n\nTo get the highest possible hit rate when caching out-of-the-box, Contao maintains a list of irrelevant cookies within the Contao cache proxy. These cookies are removed from the request before cache lookup and therefore do not reach the cache proxy or (in case of a cache miss) Contao itself.\n\nMore advanced users can override this list, see the section about configuring the Contao Cache Proxy.\n\nIn the case of request cookies, the Contao-Private-Response-Reason header contains request-cookies plus a list of all the cookies that have not been removed.\n\nConfiguration of the Contao Cache Proxy\n\nThe Contao Cache Proxy can be customized to a certain degree, just like Contao itself. Since Contao provides internal lists of irrelevant cookies, it has good default settings, but you can optimize it further by adjusting environment variables and tune it for performance.\n\nThe following environment variables allow you to further optimize the cache proxy:\n\nCOOKIE_ALLOW_LIST\n\nThis is a special environment variable related to the default caching proxy which is shipped with the Contao Managed Edition by default. Contao disables any HTTP caching as soon as there is either a Cookie or an Authorization header present in the request. That is because these headers can potentially authenticate a user and thus cause personalized content to be generated in which case, we never want to serve any content from the cache. However, unfortunately, the web consists of tons of different cookies. Most of which are completely irrelevant to the application itself and are only used in JavaScript (although there are better alternatives such as LocalStorage, SessionStorage or IndexedDB). You will find that e.g. Google Analytics, Matomo, Facebook etc. all set cookies your application (Contao in this case) is not interested in at all. However, because the HTTP cache has to decide whether to serve a response from the cache or not before the application is even started, there’s no way it can know which cookies are relevant and which ones are not. So, we have to tell it. The Contao Managed Edition ships with a list of irrelevant cookies that are ignored by default to increase the hit rate but if you want to optimize it even more, you can disable the default list by providing an explicit list of cookies you need. These are the cookies you know are relevant to the application and in this case, the cache must be omitted. By default, Contao only uses the PHP session ID cookie to authenticate users and members, the CSRF cookie to protect visitors from CSRF attacks when submitting forms, the trusted devices cookie for two-factor authentication and the remember me cookie to automatically log in users if desired. So in most cases, the following configuration will score the maximum cache hits but you may have to allow additional cookies of extensions you installed:\n\nCOOKIE_ALLOW_LIST=PHPSESSID,csrf_https-contao_csrf_token,csrf_contao_csrf_token,trusted_device,REMEMBERME\n\nCOOKIE_REMOVE_FROM_DENY_LIST\n\nIn case you don’t want to manage the whole COOKIE_ALLOW_LIST because you are unsure what your application needs but you want to disable one or more of the existing entries on the deny list that is managed by Contao, you can specify this using:\n\nCOOKIE_REMOVE_FROM_DENY_LIST=__utm.+,AMP_TOKEN\n\nQUERY_PARAMS_ALLOW_LIST\n\nFor the very same reason we strip irrelevant cookies, we also strip irrelevant query parameters. E.g. you might be familiar with the typical ?utm_*>=<randomtoken> query parameters that are added to links of your website. Because they change the URL every single time, they also generate new cache entries every single time, eventually maybe even flooding your cache.\n\nAs with the irrelevant cookies, Contao also manages a list of irrelevant query parameters which again, you may completely override by providing a list of allowed query parameters if you know all the query parameters your application ever needs. This is highly unlikely which is why there is also QUERY_PARAMS_REMOVE_FROM_DENY_LIST.\n\nQUERY_PARAMS_REMOVE_FROM_DENY_LIST\n\nAs with COOKIE_REMOVE_FROM_DENY_LIST, you can use QUERY_PARAMS_REMOVE_FROM_DENY_LIST to remove an entry from the default deny list shipped with Contao. If you e.g. need the Facebook click identifier (fbclid) in your server side code, you may update your list like so:\n\nQUERY_PARAMS_REMOVE_FROM_DENY_LIST=fbclid\n\nShared cache maintenance and cache tagging\n\nAt this point we need to explain yet another concept. As a user of Contao, you won’t even notice this, but it is an important part of the excellent caching framework of Contao and therefore a great sales argument.\n\nA key difference between the shared cache and private cache is that the location of the shared cache is known and can be accessed. So we can actively manage the shared cache and invalidate single cache entries or the whole cache. We cannot do this for the private cache.\n\nSo if you make changes to the content, you want to always make sure that the shared cache is emptied and visitors will receive the latest version of your website. To do so, use the “Purge the shared cache” option in the “Maintenance” menu.\n\nBut Contao would not be Contao if you had to do it yourself every time you applied a change, right?\n\nContao is equipped with a framework that allows developers to work with “cache tagging”. When the response is generated, it is tagged so that the cache proxy can store those tags as metadata alongside the cache entry. Based on this information, entries related to certain cache tags can then be invalidated.\n\nEvery response generated by Contao contains a lot of cache tags. A response could thus look like this:\n\nThe number of tags can grow to as many as you require. In this example, Contao has tagged the response with three cache tags and as you might have noticed, these tags contain the information that the response relates to the page with ID 18, using the page layout ID 16 and the content elements with ID 42 and 10 are used on it.\n\nAnd here’s the kicker: When you edit one of these elements in the Contao back end, Contao automatically invalidates all cache entries that are related to this element! For example, if the content element 42 was used in a news item, all cache entries of the detail page and potential list views would be deleted automatically. If you change the page layout 18 and select an additional CSS file to be loaded, all responses generated with this page layout will be invalidated automatically without any further action required.\n\nPretty smart, isn’t it?\n\nBasically, this means that we can set the cache duration for the shared cache relatively high, since the invalidation always takes place when we change anything. You should still be careful and test actively, because there may still be cases where the automatic invalidation of entries does not work as desired. For example, the developer of an extension or the Contao core itself might have failed to add the correct cache tags. However, such cases can certainly be improved, just contact the person responsible.\n\nFAQ"
    }
}