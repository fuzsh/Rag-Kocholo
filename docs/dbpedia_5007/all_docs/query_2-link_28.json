{
    "id": "dbpedia_5007_2",
    "rank": 28,
    "data": {
        "url": "https://objectcomputing.com/resources/publications/sett/june-2017-introduction-to-qt",
        "read_more_link": "",
        "language": "en",
        "title": "Introduction to Qt",
        "top_image": "https://objectcomputing.com/files/4716/4373/9454/favicon.png",
        "meta_img": "https://objectcomputing.com/files/4716/4373/9454/favicon.png",
        "images": [
            "https://objectcomputing.com/themes/objectcomputing/images/header-logo.svg",
            "https://objectcomputing.com/files/6314/9547/7017/windowskitselector.jpg",
            "https://objectcomputing.com/files/5414/9547/7012/linuxkitselector.jpg",
            "https://objectcomputing.com/files/6214/9547/7013/mackitselector.jpg",
            "https://objectcomputing.com/files/2114/9547/7016/t_windows_linux.jpg",
            "https://objectcomputing.com/files/8314/9547/7014/t_android_landscape.jpg",
            "https://objectcomputing.com/files/8314/9547/7596/t_android_portrait.jpg",
            "https://objectcomputing.com/files/6014/9547/7016/t_osx_ios.jpg",
            "https://objectcomputing.com/index.php/download_file/view_inline/1257/974",
            "https://objectcomputing.com/index.php/download_file/view_inline/1468/974",
            "https://objectcomputing.com/index.php/download_file/view_inline/1468/974",
            "https://objectcomputing.com/index.php/download_file/view_inline/1258/974",
            "https://objectcomputing.com/index.php/download_file/view_inline/5557/974",
            "https://objectcomputing.com/files/1214/8771/9866/twitter_social_icon.svg",
            "https://objectcomputing.com/files/6314/8771/9865/linkedin_social_icon.svg",
            "https://objectcomputing.com/files/6014/8771/9866/youtube_social_icon.svg",
            "https://objectcomputing.com/files/6314/8771/9865/github_socail_icon.svg",
            "https://objectcomputing.com/files/9516/9712/5686/Medium_social_icon-1_2.png",
            "https://objectcomputing.com/themes/objectcomputing/images/back-to-top.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Qt (pronounced \"cute\") is a cross-plaform framework for creating applications. It was originally conceived in 1990, with its first public release in 1995 for Linux. Over time, it developed support for embedded devices such as cell phones through desktop platforms such as Windows and Mac OS X. Using Qt, this article will describe the basics of creating a basic calculator application that can run on multiple devices.",
        "meta_lang": "en",
        "meta_favicon": "/files/4716/4373/9454/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://objectcomputing.com/resources/publications/sett/june-2017-introduction-to-qt",
        "text": "Introduction\n\nQt (pronounced \"cute\") is a cross-platform framework for creating applications. It was originally conceived in 1990, with its first public release in 1995 for Linux. Over time, it developed support for embedded devices, such as cell phones, through desktop platforms, such as Windows and Mac OS X. This article describes the basics of creating a basic calculator application using Qt that can run on multiple devices.\n\nObtaining Qt\n\nQt is available both in Open Source and commercial versions. While the Open Source version may be used to develop applications, a commercial license is required for the development of commercial software where compliance with the GNU Lesser Public License (LGPL) is not possible. The commercial distribution also provides more optimized code in certain circumstances, as well as additional Qt software components that are not available in the Open Source distribution.\n\nQt may be downloaded from https://www.qt.io/download/.\n\nTwo major flavors exist — Qt for desktop and mobile applications, and Qt for embedded devices. For this article, version 5.8 of Qt for desktop and mobile applications is used.\n\nWhile the source code for Qt may be downloaded and compiled manually, distributions of Qt may be obtained via a unified installer or by downloading platform-specific archives.\n\nArchives are selected by the host architecture, such as Windows or Linux, and then by the platform to compile for.\n\nA compiler toolchain is known as a kit, and multiple kits may be installed on the same machine. For instance, distributions available for a Windows host at the time of this writing include 32- and 64-bit distributions for Visual Studio 2013 and 2015, and 32-bit distributions for MinGW, WinRT with Visual Studio 2013 and 2015, and Android. With Mac OS X as the host, distributions that use Clang are available for Mac OS X, as well as iOS development. Linux distributions may use compilers such as GCC.\n\nThe main integrated development environment for Qt is Qt Creator, provided as part of the distribution. It provides an editor and debugger, as well as a kit management system to configure and allocate kits to the projects that they will compile.\n\nQt also provides a large library of example code and an extensive help system. Qt Creator's editor also provides helpful code editing features, such as method refactoring, underlining of unused variables, and other features expected from a modern editor.\n\nQML Calc\n\nTo illustrate Qt, in this article we'll develop a basic calculator, inspired by code written in Java by Fred Swartz.\n\nPrior to relatively recent versions of Qt, a Qt application had to be created completely in C++, but with the development of QML, the Qt Meta (or Markup) Language, the user interface may be developed independently in a special scripting language.\n\nUI constructs are declared in QML, and behavior is implemented in JavaScript, meaning a workable Qt application can be written almost entirely without the need for C++. Our first version of the calculator will be implemented in this manner.\n\nIn Qt Creator, a new QML-enabled project may be created by selecting New Project -> Application -> Qt Quick Application. For this example, we'll uncheck the checkbox in the project creation options and not generate a ui.qml file (useful for using a provided UI layout editor) in order to more easily view how QML operates. The QML skeleton code that is generated creates a clickable window containing a text field, as follows, in the file main.qml:\n\nQML code begins with import statements, each typically naming a Qt module and the version number of the module that is being imported. A difference in recent versions of Qt, for example, are version 1 vs. version 2 controls. While version 1 controls are still available for use, version 2 controls are richer and more performant and have a somewhat different syntax than version 1 controls.\n\nQML supports a number of GUI elements.\n\nA Window is one that represents a basic application window. QML, with respect to layout, is hierarchical; after properties such as size and visibility are set (using the property name : property value syntax), the next elements are GUI elements contained within the Window.\n\nA MouseArea represents a clickable area. GUI elements are positioned in various ways, with this one filling its parents by anchoring all four of its sides to the sides of its parent, using the .fill shortcut. So, no matter where one clicks in the Window, the onClicked handler will be invoked.\n\nHandlers are implemented in JavaScript, either inline, as in this case, or by calling a JavaScript function defined elsewhere. Here, clicking causes a message to be logged to the console.\n\nQt supports internationalization via the call qsTr(), although internationalization is not fully realized in this code skeleton.\n\nA TextEdit element provides a means for text entry.\n\nThe id property is used to identify an element for referencing elsewhere — here, the id is set to textEdit so its text property, the contents of the edit field, may be logged to the console on a mouse click.\n\nAs with the MouseArea element, the TextEdit element is also positioned via anchors; but instead of filling its parent, it is set such that the top of the edit control is 20 pixels below the top of the parent window (via the top and topMargin anchor properties), and is centered horizontally.\n\nThe Rectangle within the TextEdit element allows the look of the TextEdit element to be customized. Here, the rectangle is as large as the TextEdit element itself (via the anchors.fill: parent setting), and is drawn with a 1 pixel outline and transparent background.\n\nThe skeleton code generation also creates a minimal C++ file to load the QML in main.cpp:\n\nThis code creates a QGuiApplication, loads the QML file into a QQmlApplicationEngine, and then starts the application message loop by calling app.exec().\n\nFor the calculator example, we shall leave the C++ code unchanged, but erase the contents of main.qml and start fresh. The source code for this article is available in the accompanying code archive, and is described below.\n\nWe begin by importing various QML modules, and as the skeleton code did, we create a Window:\n\nNext, reminiscent of the original Java code, we create several variables to store the state of the calculator. We use the property syntax to define them as custom properties of the window.\n\nThe behavior of the calculator is implemented by a series of JavaScript functions that parallel the original Java, such as:\n\nIndividual methods perform the calculator mathematics, with applyOp() called when a user enters an operator, applyDigit() invoked when the user enters a digit, and other methods as appropriate.\n\nAs we want the calculator to consist of a display where one may see digits entered and the results of calculations above a set of buttons, we use a ColumnLayout to place the display field above the buttons. The ColumnLayout fills the entire parent window (the Window), and the display anchors itself to the left and right of the parent window so it will expand and contract as the window does. It does not need to anchor itself to the top of the window as the ColumnLayout manages its vertical position. The font is increased from the default via the font properties.\n\nBelow the display are the calculator buttons, arranged by using a GridLayout. That is, the ColumnLayout aligns two UI elements, a TextEdit above a GridLayout. The GridLayout is set to have four rows and four columns, and it, too, is anchored to the left and right sides of the display.\n\nThe GridLayout contains 16 different GridButtons, where a GridButton is a custom element.\n\nCustom elements may be defined by creating additional QML files that have the same name as the element that is being defined. In our case, the file GridButton.qml contains the following definition:\n\nThe file is written to be self-contained in that it, too, begins with import statements and contains QML elements.\n\nThe Button element represents a pushbutton, and as it is placed in a GridLayout, has Layout-related properties that can be set.\n\nThe fillHeight and fillWidth properties allow the buttons to expand to fill the grid cells, so as the window changes size, so do the grid buttons.\n\nThe contentItem of the button is Text, as the buttons will display numbers, operators, or other symbols.\n\nThe pointSize of the text adjusts based on the window size, but care must be taken to not resize the window too rapidly as the author has seen instances where the application will crash if the window refreshes too quickly. If the pointSize is set to a constant value, the crashes do not occur.\n\nReturning to main.qml, one sees that if every GridButton were the full Button definition, the code may become too complex and repetitive to maintain. Moving common settings out into user-defined objects makes the code much cleaner.\n\nProperties not specified in common, such as the text property representing the characters to show on the button, are set on each button individually. Incidentally, QML supports Unicode, so special characters, such as the left arrow symbol, may be represented.\n\nC++ Calc\n\nWhile much may be done in QML with JavaScript, applications often need functionality that may not be provided by the Javascript implementation. QML may interact with C++ in a relatively straightforward way. In this example, we move the functionality that was implemented in JavaScript to C++ in order to demonstrate the interactivity.\n\nQt's support for C++ is extensive. In order to provide its multi-platform capability, Qt includes many classes to isolate the application from the underlying operating system. These types range from basic entities such as QString and QList through more complex ones that manage Bluetooth connectivity, socket and serial port access, database queries, and the like.\n\nBy using what Qt provides, as well as portable C++ constructs, an application may compile on any Qt-supported platform without modification.\n\nWe need to create a C++ object which may be referenced by QML, and as the base class for many Qt objects is QObject, we must inherit from it as well. The Q_OBJECT macro must also be specified so various Qt support functions may be declared. Since the object we need to create supports calculator functions, we'll call it Calc, defined in calc.h and calc.cpp.\n\nOnly one variable is needed that must be in common between C++ and QML — the calculator display. It is defined as a Q_PROPERTY so the correct annotations may be made automatically to allow the field to be accessible.\n\nPart of the build process of a Qt application runs a preprocessor that generates additional code in files prefixed by moc_ based on macros, such as these to provide the runtime type support, message passing, and QML connectivity.\n\nA Q_PROPERTY need not always specify read, write, or notification methods. For example, a property may only have a read method and be declared CONSTANT if the property does not change during runtime of the application.\n\nFor this calculator example, the read and write methods are standard getters and setters implemented in calc.cpp, and displayFieldChanged() is a signal, a special Qt construct used for message passing, identified by the special signals: section in a class definition. A signal may be explicitly attached to a slot, a signal handler function, by the QObject::connect() method; or as happens here, is implicitly associated with QML where QML code that uses the property will automatically update when the signal is emitted. These methods are declared in calc.h as:\n\n...and in calc.cpp as:\n\nThe displayFieldChange() signal is not emitted (via the emit keyword) unless the value of the display field has actually changed.\n\nWhile Q_PROPERTY serves to create a variable that is seen by QML, Q_INVOKABLE marks a method that is callable from QML.\n\nIn our example, all of the methods that may be executed by button presses are marked in this way in the class definition in calc.h.\n\nIn calc.cpp they are implemented in a corresponding way to their implementation in JavaScript:\n\nTo make a Calc object available to QML, it is instantiated and set as a property in main.cpp:\n\ncalc may now be accessed from QML and its properties and methods referenced directly. Properties appear as variables, as with displayField used as the text contents of the TextEdit element in main.qml:\n\nMethods are referenced in a similar manner, but contain a parameter list:\n\nQt provides additional methods for C++/QML interaction, such as for referencing C++ types and enumerations from QML or for passing more advanced data structures, but the above is sufficient for many applications.\n\nBuilding on Multiple Platforms\n\nIn Qt Creator, clicking on the Build and Run Kit Selector button displays the kits configured for the current project. After selecting the kit to use and the type of build to create (debug, release or profiling), clicking the buttons below the selector will run, run with debugging, or just compile the project, respectively.\n\nMost kits do not require additional configuration; but some, such as the Android kit, allow additional properties to be specified if the project is fully set up, such as a keystore that contains a key used to produce a signed release build.\n\nThe images below depict the kits configured on the author's Windows, Linux and Mac OS X build systems, respectively."
    }
}