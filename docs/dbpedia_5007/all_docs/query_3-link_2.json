{
    "id": "dbpedia_5007_3",
    "rank": 2,
    "data": {
        "url": "https://doc.qt.io/qt-6/qmake-common-projects.html",
        "read_more_link": "",
        "language": "en",
        "title": "Building Common Project Types",
        "top_image": "https://d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon-32x32.png",
        "meta_img": "https://d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon-32x32.png",
        "images": [
            "https://doc.qt.io/style/qt-logo-documentation.svg",
            "https://doc.qt.io/images/qtgroup.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "//d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon.ico.gzip",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "This chapter describes how to set up qmake project files for three common project types that are based on Qt: application, library, and plugin. Although all project types use many of the same variables, each of them uses project-specific variables to customize output files.\n\nPlatform-specific variables are not described here. For more information, see Qt for Windows - Deployment and Qt for macOS.\n\nBuilding an Application\n\nThe app template tells qmake to generate a Makefile that will build an application. With this template, the type of application can be specified by adding one of the following options to the CONFIG variable definition:\n\nWhen using this template, the following qmake system variables are recognized. You should use these in your .pro file to specify information about your application. For additional platform-dependent system variables, you could have a look at the Platform Notes.\n\nHEADERS - A list of header files for the application.\n\nSOURCES - A list of C++ source files for the application.\n\nFORMS - A list of UI files for the application (created using Qt Designer).\n\nLEXSOURCES - A list of Lex source files for the application.\n\nYACCSOURCES - A list of Yacc source files for the application.\n\nTARGET - Name of the executable for the application. This defaults to the name of the project file. (The extension, if any, is added automatically).\n\nDESTDIR - The directory in which the target executable is placed.\n\nDEFINES - A list of any additional pre-processor defines needed for the application.\n\nINCLUDEPATH - A list of any additional include paths needed for the application.\n\nDEPENDPATH - The dependency search path for the application.\n\nVPATH - The search path to find supplied files.\n\nDEF_FILE - Windows only: A .def file to be linked against for the application.\n\nYou only need to use the system variables that you have values for. For example, if you do not have any extra INCLUDEPATHs then you do not need to specify any. qmake will add the necessary default values. An example project file might look like this:\n\nTEMPLATE = app DESTDIR = c:/helloapp HEADERS += hello.h SOURCES += hello.cpp SOURCES += main.cpp DEFINES += USE_MY_STUFF CONFIG += release\n\nFor items that are single valued, such as the template or the destination directory, we use \"=\"; but for multi-valued items we use \"+=\" to add to the existing items of that type. Using \"=\" replaces the variable value with the new value. For example, if we write DEFINES=USE_MY_STUFF, all other definitions are deleted.\n\nBuilding a Testcase\n\nA testcase project is an app project intended to be run as an automated test. Any app may be marked as a testcase by adding the value testcase to the CONFIG variable.\n\nFor testcase projects, qmake will insert a check target into the generated Makefile. This target will run the application. The test is considered to pass if it terminates with an exit code equal to zero.\n\nThe check target automatically recurses through SUBDIRS projects. This means it is possible to issue a make check command from within a SUBDIRS project to run an entire test suite.\n\nThe execution of the check target may be customized by certain Makefile variables. These variables are:\n\nTestcase projects may be further customized with the following CONFIG options:\n\nTest cases will often be written with QTest or TestCase, but it is not a requirement to make use of CONFIG+=testcase and make check. The only primary requirement is that the test program exit with a zero exit code on success, and a non-zero exit code on failure.\n\nBuilding a Library\n\nThe lib template tells qmake to generate a Makefile that will build a library. When using this template, the VERSION variable is supported, in addition to the system variables that the app template supports. Use the variables in your .pro file to specify information about the library.\n\nWhen using the lib template, the following options can be added to the CONFIG variable to determine the type of library that is built:\n\nThe following option can also be defined to provide additional information about the library.\n\nVERSION - The version number of the target library. For example, 2.3.1.\n\nThe target file name for the library is platform-dependent. For example, on X11, macOS, and iOS, the library name will be prefixed by lib. On Windows, no prefix is added to the file name.\n\nBuilding a Plugin\n\nPlugins are built using the lib template, as described in the previous section. This tells qmake to generate a Makefile for the project that will build a plugin in a suitable form for each platform, usually in the form of a library. As with ordinary libraries, the VERSION variable is used to specify information about the plugin.\n\nVERSION - The version number of the target library. For example, 2.3.1.\n\nBuilding a Qt Designer Plugin\n\nQt Designer plugins are built using a specific set of configuration settings that depend on the way Qt was configured for your system. For convenience, these settings can be enabled by adding designer to the QT variable. For example:\n\nSee the Qt Designer Examples for more examples of plugin-based projects.\n\nBuilding and Installing in Debug and Release Modes\n\nSometimes, it is necessary to build a project in both debug and release modes. Although the CONFIG variable can hold both debug and release options, only the option that is specified last is applied.\n\nBuilding in Both Modes\n\nTo enable a project to be built in both modes, you must add the debug_and_release option to the CONFIG variable:\n\nCONFIG += debug_and_release CONFIG(debug, debug|release) { TARGET = debug_binary } else { TARGET = release_binary }\n\nThe scope in the above snippet modifies the build target in each mode to ensure that the resulting targets have different names. Providing different names for targets ensures that one will not overwrite the other.\n\nWhen qmake processes the project file, it will generate a Makefile rule to allow the project to be built in both modes. This can be invoked in the following way:\n\nmake all\n\nThe build_all option can be added to the CONFIG variable in the project file to ensure that the project is built in both modes by default:\n\nCONFIG += build_all\n\nThis allows the Makefile to be processed using the default rule:\n\nmake\n\nInstalling in Both Modes\n\nThe build_all option also ensures that both versions of the target will be installed when the installation rule is invoked:\n\nmake install\n\nIt is possible to customize the names of the build targets depending on the target platform. For example, a library or plugin may be named using a different convention on Windows from the one used on Unix platforms:\n\nCONFIG(debug, debug|release) { mac: TARGET = $$join(TARGET,,,_debug) win32: TARGET = $$join(TARGET,,d) }"
    }
}