{
    "id": "correct_subsidiary_00027_0",
    "rank": 81,
    "data": {
        "url": "https://patents.google.com/patent/US5870308A/en",
        "read_more_link": "",
        "language": "en",
        "title": "US5870308A - Method and system for creating and validating low-level description of electronic design - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/a5/da/ec/8e2f38175ce85b/US5870308-drawings-page-4.png",
            "https://patentimages.storage.googleapis.com/31/95/ea/38885263cf5e2d/US5870308-drawings-page-5.png",
            "https://patentimages.storage.googleapis.com/d9/d5/a1/8fad0544abb985/US5870308-drawings-page-6.png",
            "https://patentimages.storage.googleapis.com/1f/4a/8b/d2f0eb98811c13/US5870308-drawings-page-7.png",
            "https://patentimages.storage.googleapis.com/b5/38/eb/2ad60c030c8e4f/US5870308-drawings-page-8.png",
            "https://patentimages.storage.googleapis.com/fa/c2/ed/e3734645c19146/US5870308-drawings-page-9.png",
            "https://patentimages.storage.googleapis.com/cd/53/d0/c5a9535704dc34/US5870308-drawings-page-10.png",
            "https://patentimages.storage.googleapis.com/a5/8c/25/b3feb1b9bd377f/US5870308-drawings-page-11.png",
            "https://patentimages.storage.googleapis.com/3b/94/93/09fe57c7f53d34/US5870308-drawings-page-12.png",
            "https://patentimages.storage.googleapis.com/11/be/66/f0a4c5da2744ee/US5870308-drawings-page-13.png",
            "https://patentimages.storage.googleapis.com/7b/52/3d/d49162307543b6/US5870308-drawings-page-14.png",
            "https://patentimages.storage.googleapis.com/ee/6b/25/b43f0e5de20168/US5870308-drawings-page-15.png",
            "https://patentimages.storage.googleapis.com/33/ed/0d/f7d65d2be9e7d5/US5870308-drawings-page-16.png",
            "https://patentimages.storage.googleapis.com/b2/6f/01/8e58c4903ef724/US5870308-drawings-page-17.png",
            "https://patentimages.storage.googleapis.com/bc/5e/23/50ef1a28f18a55/US5870308-drawings-page-18.png",
            "https://patentimages.storage.googleapis.com/d8/ec/a7/bab8b9b927127b/US5870308-drawings-page-19.png",
            "https://patentimages.storage.googleapis.com/12/83/88/a60d42f462e75f/US5870308-drawings-page-20.png",
            "https://patentimages.storage.googleapis.com/6e/f3/30/04f01aea36cd7a/US5870308-drawings-page-21.png",
            "https://patentimages.storage.googleapis.com/84/d9/91/a055fbb39e8c5e/US5870308-drawings-page-22.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1990-04-06T00:00:00",
        "summary": "",
        "meta_description": "A methodology for generating structural descriptions of complex digital devices from high-level descriptions and specifications is disclosed. The methodology uses a systematic technique to map and enforce consistency of the semantics imbedded in the intent of the original, high-level descriptions. The design activity is essentially a series of transformations operating upon various levels of design representations. At each level, the intended meaning (semantics) and formal software manipulations are captured to derive a more detailed level describing hardware meeting the design goals. Important features of the methodology are: capturing the users concepts, intent, specification, descriptions, constraints and trade-offs; architectural partitioning; what-if analysis at a high level; sizing estimation; timing estimation; architectural trade-off; conceptual design with implementation estimation; and timing closure. The methodology includes using estimators, based on data gathered over a number of realized designs, for partitioning and evaluating a design prior to logic synthesis. From the structural description, a physical implementation of the device is readily realized. Techniques are described for estimating ancillary parameters of the device (such as device cost, production speed, production lead time, etc.), at early, high level stages of the design process (e.g., at the system, behavioral, and register transfer level stages). The techniques can be applied to optimize the design characteristics other than measurable physical characteristics, such as those deriving from project time and cost constraints.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US5870308A/en",
        "text": "CROSS-REFERENCE TO RELATED APPLICATIONS\n\nThis application is a continuation of U.S. patent application Ser. No. 08/252,823, dated Jun. 2, 1994, now U.S. Pat. No. 5,572,436, which is a CIP of U.S. patent application Ser. No. 08/076,729 dated Jun. 14, 1993, now U.S. Pat. No. 5,544,066, U.S. patent application Ser. No. 08/076,738 dated Jun. 14, 1993, now U.S. Pat. No. 5,557,531, U.S. patent application Ser. No. 08/076,728 dated Jun. 14, 1993, now U.S. Pat. No. 5,541,849, and U.S. patent application Ser. No. 08/077,403 dated Jun. 14, 1993, now U.S. Pat. No. 5,553,002, U.S. patent application Ser. No. 08/076,729 dated Jun. 14, 1993, now U.S. Pat. No. 5,544,066, U.S. patent application Ser. No. 08/076,738 dated Jun. 14, 1993, now U.S. Pat. No. 5,557,531, U.S. patent application Ser. No. 08/076,728 dated Jun. 14, 1993, now U.S. Pat. No. 5,541,849, U.S. patent application Ser. No. 08/077,403 dated Jun. 14, 1993, now U.S. Pat. No. 5,553,002, are all a CIPs of U.S. patent application Ser. No. 08/054,053 dated Apr. 26, 1993, now abandoned which is a continuation of U.S. patent application Ser. No. 07/507,201 dated Apr. 6, 1990, now U.S. Pat. No. 5,222,030, U.S. patent application Ser. No. 08/076,729 dated Jun. 14, 1993, now U.S. Pat. No. 5,544,066, U.S. patent application Ser. No. 08/076,738 dated Jun. 14, 1993, now U.S. Pat. No. 5,557,531, U.S. patent application Ser. No. 08/076,728 dated Jun. 14, 1993, now U.S. Pat. No. 5,541,849, and U.S. patent application Ser. No. 08/077,403 dated Jun. 14, 1993, now U.S. Pat. No. 5,553,002, are CIPs of U.S. patent application Ser. No. 08/077,294 dated Jun. 14, 1993, now U.S. Pat. No. 5,544,067, which is a CIP of U.S. patent application Ser. No. 08/054,053 dated Apr. 26, 1993, now abandoned, and U.S. patent application Ser. No. 07/917,801 dated Jul. 20, 1992, which is now U.S. Pat. No. 5,220,512, which is a continuation of U.S. patent application Ser. No. 07/512,129 dated Apr. 19, 1990, now abandoned.\n\nTECHNICAL FIELD OF THE INVENTION\n\nThe present invention relates to computer-aided design tools and techniques for the design and implementation of complex circuits and systems, particularly digital devices.\n\nBACKGROUND OF THE INVENTION\n\nPresent day state-of-the-art design technique, logic synthesis, is really only a mapping between different levels of physical abstraction.\n\nOne of the most difficult problems in design automation is the inability to get timing closure at even the gate level effectively. This forces designers to do two designs: logic design and timing design. Otherwise, the designer simply over-designs the circuits, because the best case timing is much different from the worst case timing. In other cases, designers insist on control of device layout so that they can evaluate all of the tradeoffs between implementation and timing.\n\nPresent computer aided design (CAD) systems for the design of electronic circuits, referred to as ECAD or Electronic CAD systems, assist in the design of electronic circuits by providing a user with a set of software tools running on a digital computer with a graphical display device. Typically, five major software program functions run on the ECAD system: a schematic editor, a logic compiler, a logic simulator, a logic verifier, and a layout program. The schematic editor program allows the user of the system to enter and/or modify a schematic diagram using the display screen, generating a net list (summary of connections between components) in the process. The logic compiler takes the net list as an input, and using a component database puts all of the information necessary for layout, verification and simulation into a schematic object file or files whose format(s) is(are) optimized specifically for those functions. The logic verifier checks the schematic for design errors, such as multiple outputs connected together, overloaded signal paths, etc., and generates error indications if any such design problems exist. The logic simulator takes the schematic object file(s) and simulation models, and generates a set of simulation results, acting on instructions initial conditions and input signal values provided to it either in the form of a file or user input. The layout program generates data from which a semiconductor chip (or a circuit board) may be laid out and produced.\n\nThe Modular Design Environment (MDE) produced by LSI Logic Corporation of Milpitas, Calif., is a suite of software tools for computers running the UNIX operating system. MDE comprises a schematic editor (LSED) and a simulator (LDS), among other software programs, and provides an example of commercially available tools of the aforementioned type. Another example of a schematic editor, schematic compiler, and schematic simulator may be found in the SCALDstation produced by Valid Logic Systems, Inc. of Mountain View, Calif.\n\nVHDL, or VHSIC (Very High Speed Integrated Circuit) Hardware Description Language, is a recently developed, higher level language for describing complex devices. The form of a VHDL description is described by means of a context-free syntax together with context-dependent syntactic and semantic requirements expressed by narrative rules. VHDL is described in IEEE Standard VHDL Language Reference Manual (IEEE Std 1076-1987), and is also known as MIL-STD-454, Regulation 64.\n\nVHDL represents an important step forward in design specification languages because the semantics, or intent, of the language constructs are clearly specified. In theory, VHDL unambiguously describes a designer's intended system or circuit behavior, in syntactic terms. The \"design entity\" is the primary hardware abstraction in VHDL. It represents a portion of a hardware design that has well-defined inputs and outputs and performs a well-defined function. A design entity may represent an entire system, a sub-system, a board, a chip, a macro-cell, a logic gate, or any level of abstraction in between. A \"configuration\" can be used to describe how design entities are put together to form a complete design.\n\nVHDL supports three distinct styles for the description of hardware architectures. The first of these is \"structural\" description, wherein the architecture is expressed as a hierarchical arrangement of interconnected components. The second style is \"data-flow\" description, in which the architecture is broken down into a set of concurrent register assignments, each of which may be under the control of gating signals. This description subsumes the style of description embodied in register transfer level (RTL) descriptions. The third style is \"behavioral\" description, wherein the design is described in sequential program statements similar to a high-level programming language. In the main hereinafter, the behavioral description style is discussed. However, all three styles may be intermixed in a single architecture.\n\nA methodology for deriving a lower-level, physically-implementable description, such as a RTL description of the higher level (e.g. VHDL) description, via an intermediate rule-based tool such as Prolog, is disclosed herein.\n\nProlog is a programming language based on predicate logic. It can be used for \"intelligent\" tasks like mathematical theorem proving. A Prolog program is a set of rules which define the relationships among objects. The general form of a Prolog rule is a \"horn\" clause, in which a specified \"goal\" is true if certain conditions are true. Execution of a Prolog program involves finding a proof for the goal in question, using unification and resolution. An important aspect of Prolog employed in the present invention is \"term-- expansion\", which converts predefined rules into ordinary Prolog clauses.\n\nGenerally, there is a need to make improvements in the tools and techniques used to implement electronic designs (i.e., the designs of circuits and systems), in other words to assist the designer in the task of creating an efficient physical implementation (e.g., in silicon) of a concept (e.g., design specification). Some specific ones of these needs are discussed in greater detail hereinbelow.\n\nDISCLOSURE OF THE INVENTION\n\nIt is therefore an object of the present invention to provide a methodology for deriving a valid structural description of a circuit or system from a behavioral description thereof, thereby allowing a designer to work at higher levels of abstraction and with larger, more complex circuits and systems.\n\nIt is a further object of the present invention to provide a technique for automatically translating behavioral descriptions of a circuit or system into physical implementations thereof.\n\nIt is further object of the invention to raise the level of design validation from a structural (net list) level to a behavioral level.\n\nIt is a further object of the invention to provide a more standardized design environment, thereby alleviating the need for cross-training between different design platforms and allowing resources to be directed more towards synthesis and testability.\n\nIt is an additional object of the invention to provide an improved technique for design of complex systems from high-level semantic specifications and descriptions.\n\nIt is an additional object of the invention to provide an improved technique for partitioning electronic designs.\n\nIt is an additional object of the invention to provide a technique for accurately estimating, at high levels of abstraction, such as at the level of semantic specifications and descriptions, various constraints of a physical implementation of an electronic design, such as area and power requirements, timing parameters, and other relevant constraints of the design, particularly for use in the partitioning technique described hereinbelow.\n\nAccording to the invention, there is provided an electronic CAD system operated with a suite of software tools for enabling a designer to create and validate a structural description and physical implementation of a circuit or system (hereinafter, \"device\") from a behavior-oriented description using a high-level computer language. One skilled in the art to which the invention most nearly pertains will understand that the tools and techniques described herein are readily adapted to work on any suitable CAD system.\n\nThe methodology of the invention includes the following steps:\n\nFirst, the designer specifies the desired behavior of the device in a high-level language, such as VHDL. The description includes high-level timing goals.\n\nNext, in a \"behavioral simulation\" step, starting with the VHDL behavioral description of a design, the designer iterates through simulation and design changes until the desired behavior is obtained.\n\nNext, in a \"partitioning\" step, the design is partitioned into a number of architectural blocks. This step is effectively one of exploring the \"design space\" of architectural choices which can implement the design behavior. Links to the physical design system enable high level timing closure by constraining the feasible architectural choices to those which meet the high-level timing and area (size) goals. This is a key step because it represents the bridge between the conceptual level and the physical level. A second function of this step is to direct the various architectural blocks to the appropriate synthesis programs.\n\nAccording to an aspect of the invention, described in greater detail hereinbelow, in an embodiment of the invention, the partitioning technique is driven by constraints of the physical implementation of the electronic design (e.g., system, circuit, or the like).\n\nNext, in a \"logic synthesis\" step, a number of separate programs are used to efficiently synthesize the different architectural blocks identified in the partitioning step. Those blocks having highly regular structures or well understood functions are directed to specific synthesis tools (e.g. memory or function compilers). Those blocks with random or unstructured logic are directed to more general logic synthesis programs. The output of this step is a net list of the design.\n\nNext, in a \"physical simulation\" step, the gate-level design description is simulated, comparing the results with those from the initial behavioral simulation. This provides a check that the circuit implementation behaves as intended, and that the timing goals are achieved.\n\nOptionally, the design is back-annotated to ensure that other physical design limitations, such as capacitive loads and parasitics, are not exceeded.\n\nFinally the design is input to existing software systems which control the physical implementation of the design, such as in an ASIC (Application Specific Integrated Circuit) device.\n\nAn important feature of the present invention is that, as with all top-down design approaches, the foregoing is a process of architectural refinement in which design realization moves down through levels of abstraction. The characteristics of VHDL and the disclosed methodology enable this process to occur without losing the intent and meaning present at higher levels. This is the key to automating the process.\n\nAnother important feature is that the partitioning step, or partitioner, in effect, uses high-level timing information extracted from the chip floorplan to constrain the design into the feasible architectural choices which meet the high-level timing goals. These constraints are key to allowing the process to converge to specific physical embodiments.\n\nAnother important feature is that the methodology enables timing closure without going to actual layout, solving one of the most difficult problems in design automation today, namely the inability to get timing closure at even the gate level effectively which in the past has forced designers to create two designs: a logic design and a timing design. Using the methodology disclosed herein, timing closure can be obtained by using a form of back annotation which will extract timing data from floorplanning-level layouts and then incorporate this data into the I/O (Input/Output) ports of the VHDL behavioral description.\n\nAccording to an aspect of the invention, the behavioral (VHDL) description of the device is interpreted by attaching one or more semantic rules to each of the syntactic rules underlying the behavioral description. This is accomplished (such as via Prolog) using a \"syntax attributed tree\".\n\nFurther according to the invention, a top-down design methodology is disclosed, wherein a matrix of milestones (goals in the design activity) is defined by degree of complexity (level of abstraction) of a design and for progressive stages (levels) of design activity (from concept through implementation). The milestones are defined in a monotonic, unidirectional manner using continuous refinement, and the design activity proceeds towards subsequent milestones. As milestones are achieved, previous design activity becomes fixed and unalterable. Single level or multi-level estimators (predictors) determine the direction of the process. The methodology is scalable for increasing design complexity.\n\nFurther according to the invention, techniques are disclosed for constraint-driven partitioning of behavioral descriptions, and effective partitioning of high level descriptions for synthesis of multiple chips or blocks at the logic or register transfer levels. The partitioning technique is level-independent, and is integrated with the top-down design process, and takes into account constraints such as area, timing, power, package cost and testability. Iterative refinement is used to arrive at partitions that meet constraints imposed at high levels of abstraction.\n\nFurther according to the invention, techniques are disclosed for estimating constraints, particularly (i.e., as an example of constraints, generally) the power and area requirements, of the physical implementation of the device, at early, high level stages of the design process (e.g., at the system, behavioral, and register transfer level stages). The techniques are suited to the design of any semiconductor device, particularly CMOS devices.\n\nFurther according to the invention, techniques are disclosed for estimating constraints, particularly (i.e., as an example of constraints, generally) design performance, more particularly timing characteristics, from behavioral/functional descriptions. Given a behavioral or a block diagram description of data flow in a design, pin-to-pin timing and minimum clock cycle for the design can be estimated accurately. An RTL description may thus be synthesized from a behavioral description such that timing constraints imposed at the behavioral level are achieved. The timing of a synthesized design is estimated, and the design is re-synthesized until a design is arrived at that meets timing constraints imposed at a higher level.\n\nOther objects, features and advantages of the invention will become apparent in light of the following description thereof.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nFIGS. 1-7 are schematic representations of the methodology of the present invention.\n\nFIG. 8 is a block diagram of a suite of exemplary software tools for implementing the methodology disclosed in FIGS. 1-7.\n\nFIG. 9 is a block diagram of the methodology of the present invention.\n\nFIG. 10 is a block diagram of the Analyzer portion of the present invention.\n\nFIG. 11 is a block diagram showing the Analyzer.\n\nFIG. 12 is a block diagram of a generalized logic synthesis methodology, lacking critical features of the present invention.\n\nFIGS. 13-15 are exemplary screen displays generated by a computer system employing the methodology of the present invention.\n\nFIG. 16a is a chart of a generalized milestone matrix illustrating a top-down design methodology of the present invention.\n\nFIG. 16b is a chart of a specific milestone matrix directed to the design of an integrated circuit, according to the present invention.\n\nFIG. 17 is an exemplary screen display, similar to the display of FIG. 13, showing user interaction with a milestone matrix, such as that of FIG. 16b, according to the present invention.\n\nFIG. 18 is a block diagram of software modules (tools) operating in an ECAD system, according to the present invention.\n\nFIG. 19 is flowchart illustrating constraint-driven partitioning, according to the present invention.\n\nDETAILED DESCRIPTION OF THE INVENTION Introductory Comments\n\nIn modern digital systems, designs incorporating 70,000 logic gates or more are not uncommon. Also, in modern analog electronic systems, especially where the function being designed is intended to be incorporated into an integrated circuit, it is not uncommon to encounter designs comprising many hundreds of transistors and other electronic devices. These designs, due to their complexity, present a need for frequent simulation of the circuit being designed in small parts before it is simulated as a whole. This is necessary because errors in a small portion of the circuit are easy to detect when that small portion is simulated in isolation. On the other hand, when the entire circuit is simulated, compound errors may occur which mask other errors. Further the enormity of modern circuit complexity makes the errors in the small portion of the circuit difficult to recognize.\n\nIn the prior art, the process of designing an electronic circuit on a typical ECAD (Electronic CAD) system is done in several discrete steps. A schematic diagram of the circuit is entered interactively through the use of a schematic editor which produces a digital representation of the circuit elements and their interconnections. The user of the ECAD system then prepares a list of input stimuli (vectors) representing real input values to be applied to the simulation model of the circuit. This representation is then compiled by a schematic compiler and translated into a form which is best suited to simulation. This new, translated representation of the circuit is then operated upon by a simulator, which produces numerical outputs analogous to the response of a real circuit with the same inputs applied. This output is then usually presented to the user in a graphical fashion. By viewing the simulation results, the user may then determine if the represented circuit will perform correctly when it is constructed. If not, he may then re-edit the schematic of the circuit using the schematic editor, re-compile and re-simulate. This process is performed iteratively until the user is satisfied that the design of the circuit is correct.\n\nThe schematic editor of the ECAD system is usually an interactive software tool which enables the user to select from a number of circuit elements which will be graphically displayed upon a graphical/text display device, hereinafter referred to as the display screen, connected to the computer. These displayed elements may then be interconnected by lines representing wires drawn on the display screen by the user through interaction with the computer via a position input device, which may be a pointing device such as a mouse, trackball, joystick, graphic tablet, or keyboard used to enter coordinates on the display screen and commands to the software tool. The circuit elements and their interconnecting wires form a schematic diagram which is viewed either in whole or in part on the display screen. As the schematic diagram is constructed on the display screen, the computer represents these elements in a storage medium, which may be a memory or a mass storage device such a magnetic disk drive. These representations, taken as a group, form a numerical representation of the schematic which has been entered by the user in a standardized form which is understood by the schematic editor. Typically, this form has been optimized for the entry and modification of schematic information.\n\nOften, schematic editors allow for heirarchical design whereby a previously created and stored schematic may be recalled and viewed and used as a macro-level component in other circuits. Multiple instances of such macro-level components may be included in a higher-level schematic diagram. The schematic editor creates data structures effectively replicating the macro-level component. The higher-level schematic may further be incorporated as a macro-level component into yet higher-level schematic diagrams, and so on.\n\nFIG. 12\n\nFIG. 12 shows a generalized design methodology 1210. It should be understood that the descriptions contained herein are in terms of a suite of software \"blocks\" that can be run on any suitable computer system (not shown).\n\nA designer begins designing a circuit (or system) by formulating a behavioral description of a circuit's desired behavior in a high-level computer language, such as VHDL. This is represented in the block 1212, which shows exemplary high-level code describing a desired behavior.\n\nNext, the designer re-formulates the design as a register-transfer level (RTL) description of the circuit in terms of pre-designed functional blocks, such as memories and registers. This is represented in the block 1214.\n\nThe resulting RTL description is simulated, in a block 1216, to ensure that it equates to the original behavioral description. At that point, the design consists of synthesizable parts (combinational logic, registers and flip-flops) and non-synthesizable parts (pre-designed blocks).\n\nThe logic is then minimized in a block 1218, by finding common terms that can be used repeatedly, and maps the description into a specific technology (e.g., CMOS) in a block 1220. Further, the non-synthesizable parts are compiled in a block 1222.\n\nThe foregoing steps 1212 through 1222 are all technology independent (except for the step 1222, to the extent that it is technology dependent).\n\nThe design of at least the synthesizable parts is optimized in a block 1224 to produce a gate-level net list 1226.\n\nThe blocks 1218 through 1222 represent a typical logic synthesis tool.\n\nStrictly speaking, only the steps after the RTL description is produced constitute \"logic synthesis\", and such a bottom-up approach (re-formulating the behavioral description into a RTL description) tends to be flattened out and/or lose much of the intent of the original behavioral description, as well as being labor-intensive and error-prone.\n\nAccording to the present invention, described below, \"behavioral synthesis\" will bridge the gap between a behavioral description and a RTL description to produce a valid gate-level net list automatically from a high-level behavioral description. In a sense, behavioral (e.g., VHDL) and RTL circuit descriptions can both be considered \"high-level\" descriptions, since they do not deal with gate-level representations. The distinction between a behavioral description and a RTL description is primarily in the amount of structure that they specify and in the \"allocation\" or definition of structural components that will be used in the resulting gate-level implementations. Behavioral descriptions do not address the issue of what specific structural components (e.g. memory, functional blocks, etc.) are to be used. In an RTL description, structural components are explicitly identified and there is a direct mapping between this description and the resulting gate-level implementation.\n\nThe ability to synthesize behavioral and RTL descriptions is significantly impacted by this difference in structural content. RTL synthesis (\"low-level\" synthesis) is a relatively well-studied, and much implemented, technology. The ability to synthesize an RTL description into a gate-level implementation is well established. The present invention discloses a methodology for mapping a behavioral description with little or no structural content into a RTL level description with significant structural content. This is largely, but not entirely, a top-down design methodology.\n\nWhat is lacking in a strictly top-down design methodology is the use of detailed knowledge of lower level physical information of the modules (circuits, functional blocks, etc.) being designed. Typically, the decisions concerning the selection and placement of modules are deferred until the time the behavioral synthesis is complete and an RTL structure has been chosen for the implementation. The reason for this is that, typically, structural information is not available at the behavioral level, and hence the system is unable to employ criteria such as area and delays while exploring the design space. Details such as layout, module size and interconnect can have an enormous effect on the shape of the RTL design space.\n\nAs will become evident hereinafter, partitioning the design at a high level (behavioral description) into architectural blocks creates a \"vehicle\" for providing such structural information at the behavioral description level, thereby adding the ability to estimate lower-level physical parameters. Further, partitioning helps the designer explore other avenues such as operator level parallelism and process level concurrency in order to improve the design.\n\nFIGS. 1-8\n\nThere follows an exemplary embodiment of the invention described in the context of an ASIC design.\n\nFIG. 1\n\nFIG. 1 is a simplistic view of an ASIC chip 110, covering gate arrays and standard cells, in the context of synthesis. In general, an ASIC chip consists or all or some of the different functional entities shown in the Figure. Moreover, the Figure describes means for synthesis/compilation and optimization of these blocks. Not shown in the Figure are the chip's I/O buffers and periphery. Although synthesis tools are not meant to manipulate I/O buffers, nevertheless their timing description in the optimization environment can be beneficial for optimization of the chip's core part.\n\nThe exemplary chip 110 includes the following major functional blocks: memory 112, data path 114, mega-cells and mega-functions 116 and functional units 118 which may include regular blocks 120 such as adders and decoders and random logic 122.\n\nThe memory block 112 is generated by memory compilers using efficient technology-dependent building blocks. The output of the memory compiler is a net list of primitive transistors.\n\nThe data path block 114 is generated by providing the behavioral description in an HDL (Hardware Definition Language) language. The data paths can be synthesized through general purpose synthesis programs or specialized data path compilers. The output of the synthesis programs/compilers is the structural description of the design using ASIC macro-cells.\n\nThe mega-cell and mega-function block 116 is chosen from pre-designed building block libraries, which are already designed for optimal performance.\n\nThe regular functional units 120 are generated using regular blocks such as adders, decoders and multiplexers. These blocks can be further optimized, if desired.\n\nThe random logic blocks 122 includes random logic, glue logic and the state controller. The description of these units is provided in Boolean equations, truth table, data flow and HDL description. This part of the chip is designed around the other parts. This functional unit is partitioned into smaller chunks of functional units, and the process is recursively repeated. The atomic features are still functional units that are readily functionally verifiable. A general purpose synthesis/optimization tool is used to create these functional units, and to optimize the units according to the specified constraints and those imposed by memory, regular blocks and data path sections.\n\nFIGS. 2-5\n\nFIGS. 2-5 describe a synthesis design methodology that is independent of any particular design style or technology. The various steps (blocks) of this methodology are represented by the circled numerals 1-18, and are as follows:\n\nStep 1 is Design Specification. This consists of system (device) specification and may include functional specifications of subsystem elements, timing specifications and I/O requirements, and power, package and interface requirements.\n\nStep 2 is Design Description. This is the functional description of the design and all its subsystem elements. The description is, ideally, given in a high level description language, such as VHDL. Depending on the nature of the design, the description can be entirely at the behavioral level, or it may be intertwined wit with an RTL description.\n\nStep 3 is Partitioning. Given the behavioral description of the design, partitioning (the Partitioner) breaks the design into separate modules that will make the overall synthesis, analysis and verification tasks more manageable. In doing so, the Partitioner consults technology files (described hereinafter) containing packaging, I/O capabilities and other technology-dependent information to optimally partition the design. In addition to functionally partitioning the design, the Partitioner can help the designer (see FIGS. 13-15 showing representative screen displays of the CAE system) in choosing the optimal architecture that would optimize the design, e.g. in terms of area and speed.\n\nStep 4 is Module Description. Three modules are shown, but there could be many more modules involved. This is the RTL description of the partitioned design, in terms of an HDL (hardware definition language) description. Each module is accompanied with a set of timing and area constraints, which are related only to that module's domain (they are not automatically derived from the design description).\n\nStep 5 is Composition. Composition is the opposite of partitioning, and facilitates examination and verification of the partitioned design. The partitioned design is reconstructed in this step, the end product of which is an RTL description of the entire design.\n\nStep 6 is Functional Verification (Behavioral). Verification at the behavioral level is performed at two stages--while the design is being developed, and after the partitioning step. The former is source code debugging where the high level description of the design is verified for correctness of the intended functionality. The latter is to verify the architectural decisions that were made during partitioning, and to examine their impact on the functionality and performance of the entire design.\n\nIt will be noticed, in the above description of the steps shown in FIG. 2, that various \"loops\" are formed. A high level loop consists of behavioral verification (step 6) to debug the design description (step 2). A lower level loop consists of behavioral verification (step 6) of the partitioned (step 3) and composed (step 5) design. The partitioning process is guided by user interaction, and is driven by physical implementation factors such as technology, packaging, I/O capability and other information about the proposed device which is developed based on experience with similar devices.\n\nStep 7 is Module Description. This is the description of a functional entity that is produced by the Partitioner or developed independently by the designer. This is preferably given in one of the following formats: HDL, truth table, equations or net list. As used in this example, a \"module\" is a functional block with a complexity of less than 3000 cells (it is not a chip with I/O pads).\n\nStep 8 is Synthesis. Given the module description (step 7) and a target technology library, the design is mapped into the target technology. The synthesis process usually includes some form of logic optimization. This is the task of manipulating the logic expressions that define the functionality of the module (device). Minimization is done by removing redundancies, and adding or removing intermediate levels of logic (e.g., re-structuring of Boolean expressions).\n\nStep 9 is Structural Description. This is the gate-level, technology-dependent description of the module produced by the synthesis tool. It is usually given in the form of a net list, from which a device can be automatically physically created.\n\nStep 10 is Functional Verification (Structural). This is done to verify the correctness of the module against the intended functionality. This is only required if functional verification at the behavioral level (step 6) has not been performed. One assumes that the circuit generated by the synthesis tool complies (functionally) with the given module description. In case of discrepancies, the module description needs to be modified (debugged) at the top level, i.e. Design Description (step 2). This is necessary in order to preserve the integrity of the design and all of its subsystem elements.\n\nStep 11 deals with Timing/Area Constraints. These are used to customize the optimization process. Optimization is usually driven by area and speed (timing) constraints. These might instruct the tool to perform rudimentary area versus speed trade off on individual or small clusters of gates, or to perform comprehensive area and speed optimizations in combination with other constraints such as drive capability. A rich set of constraint constructs is required for meaningful design optimization, and are provided in the methodology of this invention. Timing constraints may include the following: maximum and minimum rise/fall delay, set-up and hold check, length of clock cycle and maximum transition time per net. The timing constraints may also include boundary conditions, such as signal skew at the module's inputs, drive capabilities of the modules outputs, etc., when such data is available.\n\nStep 12 is Optimization. Given the design constraints and the module's structural description, the optimization process tries to modify the module so that its area and timing characteristics comply with the specified constraints. Depending on the nature of the design and the strength of the constraints, some or all optimization goals will be achieved. When no boundary conditions are available, optimization may be general purpose, aimed at minimization of the overall module. With boundary conditions, the objective is to optimize each module so that the overall higher level module complies with the specified timing requirements.\n\nStep (block) 13 represents generating the Structural Description of the module after the optimization process.\n\nStep 14 is Timing Verification and Analysis. This is a process of examining the effects of the optimization process (step 12), and examining its global impact. Tools such as static timing analyzers and gate level simulators would be employed. If the optimized module (step 13) does not meet all of the timing and area requirements, further trade-offs have to be made at this point. The constraints are then modified to reflect these trade-offs, and the optimization process (step 12) is repeated.\n\nStep 15 represents a high level module, derived from the module's optimized Structural Description (step 13). A high level module consists of one or more sub-modules. Each sub-module has been optimized in its own domain. The high level module describes the interaction and connectivity between the sub-modules. When hierarchically applied, the target device itself is considered to be a high level module.\n\nStep 16 is Timing Simulation, Verification and Analysis. At this stage, the optimized modules are composed (see step 5) together and implement the intended functionality of the high level module, or target device. Here, analysis includes logic level simulation, static timing analysis, electrical rule checking, etc. For more accurate analysis, it might be necessary to use a floor-planner or placement and routing programs to estimate wire delays. The wire delays are then back annotated into the design database prior to simulation. If the overall timing characteristics of the modules do not meet the specified requirement,a the timing constraints of the sub-modules are modified and optimization is performed.\n\nStep 17 is Delay Back Annotation (DBA), which is optional. The inter-block wire delays can be more accurately estimated only after floor-planning of the sub-modules. More accurate intra-block and inter-block delays are determined after the placement and routing stage. Using these tools, the wire delays can be estimated more accurately. The delays can be back annotated to be used by the gate level Optimizer (step 12).\n\nStep 18 represents introducing Global Constraints. Using the results of the analysis performed, the sub-modules' timing/area constraints are modified to reflect the global timing requirements. Sub-modules with new constraints are then re-optimized.\n\nFIG. 6\n\nFIG. 6 illustrates the usage of exemplary synthesis and optimization tools, and the abstraction level for the exchange of design data between these tools and a Design Compiler. Each tool addresses the synthesis or compilation of one or more of the major functional blocks of an exemplary ASIC chip 600. The usage of these tools and their interaction with the Design Compiler are of particular interest.\n\nA Memory Compiler (MemComp) 602 takes the high level specification for memory mega-cells and produces logic and layout files for the purpose of simulation, testing and layout. The objective is to provide the Design Compiler (Optimizer) 604 with an accurate timing description of and drive capability information for the memory block. MemComp synthesizes high density or low power RAM or ROM blocks 606. As will become evident, the surrounding logic is optimized with respect to the memory block. The memory block created by MemComp 602 is provided in the same format as the internal macro-cells, i.e. a net list of primitive transistors, which cannot be read directly by the Design Compiler 604. Therefore, one of two possible intermediate steps is required: 1) (not shown) the data sheet generated by MemComp is used to manually extract the timing description of the memory block. This basically involves defining a set of \"set-- load\", \"set-- drive\" and \"set-- arrival\" constraints and associating them with the relevant pins of the surrounding logic at the start of the optimization process; or 2) a Memory Modeller (see FIG. 8) is used to generate a model 603 in Synopsys Library Language (SLL; available from LSI Logic Corporation). The Memory Modeller reads the memory description and generates a complete timing description of the memory block. This contains all of the setup and hold values and the timing arcs and I/O pin characteristics. This task is similar to that of the Synthesis Library Model (SLM; available from LSI Logic Corporation) generator.\n\nMega-cells and mega-functions 608 are treated as basic building blocks, similar to the macro-cells in the synthesis library. Both are generally developed beforehand for optimal performance, so no optimization is required on these blocks. They are presented to the Design Compiler 604 simply to provide timing information so that the surrounding blocks can be optimized. The mega-cells are modeled in the same manner as the macro-cells, i.e. by using the Synopsis (SLL) library format. The mega-functions are ported into the Design Compiler in Synopsys DataBase (SDB) format. (The netlist back plane 610 is used as the primary design representation medium). Generally, the mega-functions model industry-standard functions, thereby providing the designer with a set of popular and proven standard building blocks. In the case of certain, highly-specialized, user-defined mega-functions, it would be necessary to ensure appropriate capability in the Design Compiler.\n\nRandom logic 612, in other words the remaining modules that were not synthesized using the previously described tools and libraries, are synthesized by a general purpose logic synthesis tool 614 that optimizes the design for speed and area. It accepts hierarchical combinational and sequential design descriptions in equation, truth table, net list and/or VHDL formats. The optimization process is directed by specifying the \"goals\". Goals are represented as timing constraints. The optimization process makes trade-off evaluations and produces the best possible gate level implementation of the design for the specified constraints.\n\nSince the Design Compiler 604 provides an environment for synthesis and constraint-driven optimization, it can be used as the overall synthesizer/optimizer. Blocks created by other tools can be loaded into the Design Compiler, where the timing information from these blocks can be used to synthesize and optimize the surrounding logic. For example, knowing the drive capabilities and the skews of the memory blocks' outputs would allow for accurate optimization of the glue logic.\n\nOnce the memory blocks are synthesized, and the appropriate mega-cells and mega-functions are chosen, the remainder of the design can be synthesized by the Design Compiler. Optimization is then performed according to user-defined timing constraints (see User Interface; FIG. 8) and those dictated by existing blocks. This is an iterative process. Constraints need to be refined until the desired timing and area requirements are achieved.\n\nFIG. 7\n\nFIG. 7 shows a synthesis design framework. The objectives of the disclosed framework are: to provide a unified front end for a set of synthesis and optimization tools; to provide an integrated synthesis environment by incorporating specialized synthesis tools with the Design Compiler, which is the main synthesis and optimization tool; to provide the capability of constraints-driven gate-level optimization of both sequential and combinational designs; to provide back annotation of wire delays from the Modular Design Environment (MDE; available from LSI Logic Corporation, described hereinafter) to the Design Compiler to make the necessary timing/area trade-off evaluations based on more accurate wiring delays; to provide a window-based graphical interface between the synthesis tools and the MDE module to control the data flow between the Design Compiler, the other synthesis tools and the MDE; to provide VHDL debugging, and analysis capability to front-end synthesis from VHDL; and to provide VHDL pre-synthesis partitioning capability to front-end synthesis form VHDL.\n\nGenerally, the design framework illustrated in FIG. 7 follows from the design methodology described hereinbefore. The methodology includes the following important steps:\n\npartitioning the design into memory blocks, mega-functions, mega-cells and random logic;\n\nusing a layout tool, such as LSI's ChipSizer (see FIG. 8), to obtain the required die size, which is a function of the area, the number of pins and pads and other factors;\n\nchoosing the mega-cells and mega-functions to be used, and characterizing the cells for the Design Compiler;\n\ngenerating memory blocks, and characterizing them for the Design Compiler;\n\npartitioning the random logic into smaller functional units;\n\nusing the Design Compiler to synthesize the remaining blocks, in a \"bottom-up\" manner, starting with the lower level functional units, including: verifying the functionality of the block using functional verification tools or simulators; optimizing the design for area or, in general terms, for timing of some or all of the selected paths; composing the higher level functional blocks and, when a functional block interfaces with an existing building block (e.g. memory, mega-cells, mega-functions), optimizing the functional unit (and all or some of its lower level units) according to the timing/area constraints 702 imposed by the building block; and repeating these steps until all of the functional units are synthesized into a structural description 704. The resulting structural description 704 may be back annotated 706 as a structural description 708 (of timing/area constraints) to the Design Compiler. In the loop shown:\n\nfor larger functional blocks, a floor planner 710 is used for placements and more accurate wire delay prediction 712 and, with this information, using the more accurate block size provided by the floor planner to re-estimate the internal wire delays of the lower level functional units and back-annotating these delays into the Design Compiler to provide more meaningful internal timing optimization, and/or using the wire delays of the inter-block buses and wires to derive the appropriate boundary constraints for timing optimization, i.e. to specify inter-block delays through constraint constructs; and\n\nincorporating the timing delays and drive capabilities of I/O buffers into the timing constraints. (The I/O buffers should be selected as early in the design cycle as possible.)\n\nFIG. 8\n\nFIG. 8 provides an overview of the design framework, illustrating an exemplary suite of tools, many of which are commercially available (as individual units), for implementing the methodology of the present invention. Herein it is important to note that the methodology of the present invention augments many discrete software tools, such as those described herein, and provides enormously increased functionality in the context of behavioral synthesis, which otherwise would not be available by simply combining these tools.\n\nThe design framework, hereinafter termed the Co-Design Environment (CDE) 800 is divided into two sections: on-line design tools and off-line design tools. The on-line design tools are programs that are utilized directly or indirectly by the user during the design process, and are relatively generalized to handle a variety of design objectives. The off-line design tools are programs that generate libraries and models of the various building blocks for the Design Compiler, and may be very user-specific.\n\nA first group 802 of on-line tools, labeled CDE/SY, constitutes the dynamic part of the Co-Design Environment and includes the following:\n\nA Design Compiler Interface 804 (shown in two parts) controls the data flow and interactions between the MDE and the Design Compiler 604. It enables the user to follow the process of the design from one environment to the other, and interacts with the MDE programs via script shells and a command line. Interactions with the Design Compiler are achieved through the dc-shell script and constraints files.\n\nA Graphical User Interface (Graphical UI) 806 facilitates user interaction with the CDE by: abstracting out those steps of the design flow that do not require the designer's intervention, assisting and guiding the designer through the various stages of the design process as outlined by the synthesis framework, and assisting the designer in the composition of the constraints file for optimization.\n\nA Block Level Delay Estimator 808 provides the optimization tool with pessimistic wire delays which, in turn, causes the optimizer to compensate by placing buffers in and around the block or to use high power gates all over the design, and is especially applicable to small functional blocks. An advantage of using the Block Level Delay Estimator is that in pre-place and pre-layout stages of the design, both the synthesis and the analysis tools consider the wire delays to be a function of fan-out only. Although this might be a good estimate for the purposes of analysis, it has some undesirable side effects on the optimization process. Usually, in the present methodology, optimization is performed on a functional block of less than a few thousand gates, but most existing wire delay algorithms (based on fan-out) are geared towards much larger, die-sized blocks. Hence the Block Level Delay Estimator provides more realistic estimates of wire delays for the block size being manipulated through the system, and provides appropriate tables (wire-- loading) to be used by the Design Compiler.\n\nA Memory Modeller 810 reads the net list of a memory block created by MemComp (See 602, FIG. 6), and generates a timing model (in SLL) to be used by the Design Compiler. The objective is to provide the Design Compiler with accurate timing information about the memory block. This will help the optimization process as the drive capabilities, the capacitive loads, and the setup and hold time of the memory I/O will automatically define some of the constraints for the surrounding logic.\n\nA Delay Back Annotator (DBA) 812 comes into play after the floor planning stage, and provides more accurate wire delays into the optimization database. The DBA is used for two distinct purposes: 1) to back annotate wire delays for a block that is going to be re-optimized, using the latest (and most valid) delay values); and 2) to back annotate wire delays for a block that has been optimized and has met the design constraints, thereby providing the latest delay values for accurate modeling of the block so that surrounding blocks can better be optimized.\n\nA VHDL Analyzer 814 provides source code (VHDL) debugging and assists in functional verification of the VHDL description. The VHDL Analyzer is discussed in greater detail in FIGS. 10 and 11, and in the annexed code listing.\n\nA VHDL Pre-Synthesis Partitioner 816 partitions behavioral descriptions (VHDL code) into RTL descriptions of modules and sub-modules. During partitioning, appropriate architectural decisions are based on time/area analysis.\n\nThe off-line part of the CDE is a collection of libraries 818, which are either in SLL (Synopsis Library Language) or SDB (Synopsys Data Base) format. SLL is a dedicated language for modelling of cells or modules, and is most suitable for synthesis and timing (static) analysis. SDB (available from LSI Logic corporation) is the Design Compiler's database, and can contain a design description in a multitude of formats, including Boolean expressions, truth tables and net lists.\n\nA Macro-Cell Model Generator 820 reads the structural description of the macro-cells from the MDE libraries and generates the appropriate models in SLL. The behavior of sequential cells may be modeled by the Model Generator, subsequently to be manipulated by the Design Compiler.\n\nAn I/O Buffer Model Generator 822 provides timing and drive capability information on the I/O buffers, which are modeled as ordinary macro-cells in the CDE environment. Data derived therefrom is used for optimization of the logic inside the chip. The Optimizer (Design Compiler 604) is not expected to manipulate the I/O buffers. This Model Generator is capable of handling configurable buffers, which are modelled as \"n\" cells, where \"n\" is the number of all the possible configurations of that buffer.\n\nA Mega-Cell Model Generator 824 is similar to the Memory Modeler in the on-line portion of the CDE in that the objectives are generally the same. However, as mega-cells are static and do not change from one design to the other, this modelling can be performed in advance to create a synthesis mega-cell library.\n\nMega-Functions Support 826 provide the Design Compiler with timing information about the mega-functions. This helps the optimization process, since the drive capabilities, capacitive loads, and path delays of the mega-functions will define some constraints for the surrounding logic. Mega-functions are essentially \"black boxes\" from the user's point of view. Therefore, the Design Compiler is configured to prevent users from viewing or altering the mega-functions.\n\nThe various functions of the Design Compiler are shown in the block 604, and a VHDL Simulator (for behavioral and structural verification, discussed hereinbefore) is shown at 828.\n\nIllustrative tools (ChipSizer, MemComp, LCMP, LLINK, LVER, LDEL, LCAP, LSIM, LBOND and LPACE), commercially available within LSI Logic's Modular Design Environment 830 are shown. Generally, these tools consist of a set of programs that compile, link, simulate and verify digital logic at the chip (structural) level. Any number of other, commercially available programs could be employed at this level to perform similar functions.\n\nFIG. 9\n\nFIG. 9 shows a more generalized arrangement of the methodology of the present invention, in such terms that one skilled in the art to which the invention most nearly pertains could readily implement the methodology.\n\nAt the conceptual level, a behavioral description 902 of the target device is formulated in a high-level language, such as VHDL. The behavioral description is compiled and simulated 904 using test vectors 906 to verify the design description. The behaviorally-verified design is partitioned 908 into suitable architectural blocks, as described above. Partitioning allows for the critical link 910 to the physical implementation of the target device, incorporating critical size (area) constraints (i.e. floor planning) and critical timing (speed) information (i.e. back annotation).\n\nAt the structural level, the partitioned design is provided to logic synthesis tools 912 which formulate both structured and unstructured logic (functional blocks). Additional information regarding the functional blocks is derived from libraries 914. Importantly, the timing/area constraints introduced through the partitioner 908 are embedded at the logic synthesis stage. The output of the logic synthesizer 912 is a net list 916 for the target device, such as in VHDL, which is compiled and re-simulated 918 (904), using the test vectors 906 and pre-defined information about blocks contained in the libraries 914. If necessary, updated timing/area constraints are provided back through the partitioner 908 and the target device is re-synthesized 912 to meet the desired goals. By iteratively repeating this process, both the behavioral and structural descriptions of the target device can be fine tuned to meet and/or modify the design criteria.\n\nAt both the conceptual (behavioral) and structural levels, the design of the target device is technology (silicon) independent.\n\nAfter a valid, verified net list has been described, the structural description of the target device is provided to a suitable silicon compiler (Physical Implementation System) 920, such as LSI Logic's MDE, to create a working device 922. At this stage, the tools required are technology (silicon) dependent.\n\nFIGS. 10-11\n\nFIGS. 10 and 11 illustrate a hierarchical knowledge base approach to simulate hardware descriptions in a high-level Hardware Description Language (HDL). In this approach, a knowledge base is constructed corresponding to each functional block of the hardware description. The hierarchical relationships among the various blocks in the description is mapped on to the knowledge base corresponding to those blocks. The hierarchical knowledge base thus formed is used for simulating the hardware description. Unlike previous approaches to simulation and verification of digital circuits (devices) described in a HDL, there is no need for intermediate translation steps.\n\nIn the past, artificial intelligence techniques have been used in formal verification and hybrid simulation of digital hardware to address the problem of combinatorial explosion of exhaustive logic simulation. In one approach, structural and behavioral descriptions of a design are first translated into first order clauses in Prolog. This set of clauses asserted in a Prolog data base can be viewed as a \"flat\" knowledge base. The hierarchy in the design is enforced implicitly by suitable relationships among the assertions in the knowledge base. A theorem prover is then used to establish the equivalence between the structural specification and the behavioral description to formally verify the design as represented by the data base. This approach has the disadvantages of translating a HDL description of a design into first order clauses and maintaining a large knowledge base which is difficult to manage for complex, hierarchical systems. In another approach, hybrid simulation is used to verify digital designs. The design is described as an interconnection of functional modules in a first order language, such as Prolog. The design may be hierarchical with the lowest level being Boolean gates. It is then simulated with both numerical and symbolic input signal values. This, again, has the drawback of having to maintain a large Prolog description for complex hierarchical designs.\n\nThe present methodology differs from the previous approaches by not having to go through intermediate translation steps, and not having to maintain a Prolog description of the design. Generally there are three steps in the present methodology:\n\nAnalysis, wherein the input description is analyzed for syntactic and semantic correctness, and a parse tree is formed. Each node in the parse tree is associated with a semantic rule.\n\nConstruction of the hierarchical knowledge base, wherein the semantic rules associated with nodes of the parse tree are used to construct a knowledge base for each block of the description, and the hierarchical relationships among the knowledge bases are derived from the semantic rules. The knowledge bases contain simple assertions and methods to compute functions and procedures present in the source description. The also make up the basis for other design tools.\n\nSimulation, wherein using these simple assertions and computation methods contained in the knowledge bases, the output signal values are calculated for a given set of input signal values. The input stimulus can be either symbolic expressions or numerical values.\n\nFIG. 10 shows the steps in simulating a design description.\n\nBeginning with a design description 1002 written in a formal, high-level language, the description is analyzed (parsed) 1004 using, for instance, definite clause translation grammars (DCTG) to form a parse tree 1006. In the parse tree, semantic rules are attached to each node. Each syntactic rule for the formal (high-level) language is associated with one or more semantic rules. Preferably, two semantic rules are associated with each syntactic rule--one of the semantic rules is used to verify the semantic description of the description, and the other semantic rule is used to simulate the description. Each rule has a semantic and a syntactic part. The semantic part has two attributes, namely, \"check-- semantics\" and \"execute\". The semantic rules specify how these attributes are computed and verified. Using this technique, it is not necessary to go through intermediate translation steps to analyze and execute a description. Rather, the methods of analysis and execution are specified in conjunction with the syntactic rules of the language.\n\nAfter a successful parse of the given description, each node in the parse tree thus formed is associated with the attributes as specified in the DCTG rules of the language. The computation of an attribute attached to a node can be a recursive transversal of sub-trees associated with the node. For semantic analysis, one semantic attribute verifies whether any semantics of the language is violated, and error messages (see FIG. 11; 1012) would be generated. These violations include redefinition of objects within the same scope and incorrect argument types to a procedure. Only a correct description is passed on to the hierarchical knowledge base 1008. Thus the analysis of the description ensures that it conforms to the syntax and semantics of the HDL description, and leads to the construction of a valid hierarchical knowledge base.\n\nThe hierarchy in a design description can be of two kinds. One is imposed by the structural design description in which a design entity (component, process, function, architecture, configuration) is composed of several other design entities. The second relates to scoping and visibility rules of the language. The knowledge base 1008 is formed, i.e. one knowledge base for each design entity, after the syntax and semantic analysis of the input HDL description. Each knowledge base has a set of unit clauses which correspond to all the static declarations, default values of signals, variables and the data structures necessary for simulation corresponding to the design entity. The hierarchical relationships among the knowledge bases are automatically derived while analyzing the design description using the DCTG rules of the HDL. This corresponds to a direct mapping of the hierarchy in the hardware design description. The need for a hierarchical knowledge base also arises due to the scope and visibility rules of a formal language that is being analyzed. The scoping and visibility rules are also used to determine the relationships among the design entity knowledge bases. The hierarchical knowledge base 1008 makes up a simulable model of the design. Other design tools such as synthesis and partitioning tools (discussed hereinbefore) also use the knowledge bases for extracting design information.\n\nIn the past, because of the scope and visibility of the rules of a formal language, in both translation and compilation, every identifier is given a unique names. However, in the case of simulation, when the description is being executed directly, this technique is not feasible.\n\nThe description contained in the knowledge base may contain different levels of abstraction of hardware design, namely, behavioral, RTL and gate level descriptions. Simulation involves execution of all the functions, procedures and processes for generating transactions on the drivers. A driver is associated with every signal that appears in a signal assignment statement and is represented by a sequence of transactions (each transaction is a value/time pair). Generating transactions, ordering them according to certain constraints, and scheduling them at a certain time is the key to simulation. The input test vectors for simulation are asserted in the knowledge base corresponding to the design entity in which the input signal appears. The test vectors can be either symbolic expressions or numerical values. The DCTG rules are again applied to the simulation data structures stored in the knowledge bases, and a second semantic attribute (\"execute\") is computed. This set of semantic rules constitutes the simulation engine. It includes computation of values of arithmetic expressions, Boolean expressions, symbolic expressions, time expressions, execution of sequential and concurrent statements, and generation of transactions. The computation is ordered by the simulation semantics of the language in conjunction with the hierarchical relationships. After generating transactions for all drivers, they are ordered with regard to time, synchronicity and simultaneity. As simulation time advances, the drivers update the values of the associated signals. This causes events to occur on the signals which may cause certain processes to \"wake up\" and in turn lead to the occurrence of more events. The next step is to schedule the events on the signals. This is handled by a scheduler which looks at the event ordering and generates unit clauses related to the time, signal and value of a scheduled event. The final step is to assign the value to the signal at the appropriate time.\n\nIt may happen that there could be multiple drivers due to multiple signal assignments in the source description. For the same signal, multiple drivers might try to assign values at the same time. In such a case, the value is resolved by a resolution function associated with the signal, and the resolved value is assigned to the signal. This leads to unit clauses which give the final resolved values of every signal present in the design description, in the simulation results 1010.\n\nFIG. 11 is an overview of the types of rules, described above, for defining the correct relationship between objects in the constructed knowledge bases, for converging to correct structural representations of behaviorally-specified designs, and for enforcing a \"good\" style of VHDL code leading to the correct structural representations.\n\nProlog provides a useful tool for implementing the described methodology. Prolog grammars such as DCTG are useful in associating semantic rules with syntactic rules of the hardware description language (e.g. VHDL), and the inference engine contained in Prolog makes it straightforward to handle derivation of the inter-relationships between the different entities in the knowledge base.\n\nThe hierarchical knowledge base, described above, helps maintain the hierarchical nature of large hardware designs and permits large hardware descriptions to be directly simulated without having to go through intermediate translation steps. The knowledge base can be used by other tools, such as those set forth above.\n\nAn executable listing of the Analyzer/Interpreter, as described with respect to FIGS. 10 and 11, can be found in parent U.S. patent application No. 07/507,201, and is incorporated by reference herein.\n\nFIGS. 13-15\n\nFIGS. 13 through 15 show representative screen displays of the methodology of the present invention, as they would be presented to the user. In the main, the display of FIG. 13 is discussed.\n\nIn the lower left \"window\" of the display of FIG. 13 is shown a VHDL description of a counter (\"while x<a loop . . . \"), created by the user. The user then simulates the code, at the high-level, to ensure that it the description is correct, by providing operands (\"variables\").\n\nThe system then creates \"data flow\", relating to the sequencing of operations and the parallel or serial configuration of functional blocks required to realize the counter, and presents the results to the user in graphical and/or textual form. In this example, seven design alternatives are displayed in the upper left window (\"Design: 1! . . . \"). One of these design alternatives, selected by the user for viewing, is displayed in the upper right window (as interconnected circle and square primitives) In the lower right window is displayed the estimated area that would be required to implement the design, and is technology dependent. Also displayed in the upper left window are estimates of functional units (registers, muxes) that would be consumed by the various design alternatives. This all relates to exploring the design space, and allows the user to perform a \"what if\" analysis for choosing a preferred design in terms of size, speed, performed, technology and power. (In the upper left window of FIG. 15 are shown size estimates for particular functional blocks labelled \"8.1\", \"11.1\", etc.) All of the above is perfected prior to any synthesis, to allow the user to make intelligent trade-offs leading to a viable design, by interacting at the architectural level.\n\nBy partitioning, accurate timing estimates can be derived as discussed hereinbefore (not shown in the screen displays).\n\nSUMMARY\n\nA methodology is described for the implementation of complex digital systems. The methodology includes:\n\na) a mechanism for semantic capture of the specification and description of the digital hardware for which an implementation is desired;\n\nb) hardware descriptions embodied in a specification language, such as VHDL (or VHDL Intermediate Format), having well standardized semantics;\n\nc) utilization of an appropriate software language, such as Extended Definite Clause Grammar (EDCG) and Prolog, for formal capture of the semantics of b);\n\nd) direct execution of the semantics and of the behavior of the hardware described in a) and b);\n\ne) execution of the intent contained in the description of a) without a translation step, such as with Prolog and its predicate logic formalism (knowledge representation of the digital hardware is achieved via the imbedding provided by predicate logic, semantic description of EDCG, Prolog and the VHDL language);\n\nf) system level partitioning for creating optimized versions of hardware functional blocks for trade-off display, predicting for estimating hardware resources (sizes), speed and power, and mapping from one level of design representation to another;\n\ng) isomorphism among various levels of partitioned hardware (across semantics, structure, behavior, logic and functions);\n\nh) synthesis of hardware directly from semantics and intent contained in a) through f) into low level structural logic descriptions;\n\ni) methodology for closure between the timing goals of a) through g); and\n\nj) methods for displaying knowledge in a), d), e) and f).\n\nOne skilled in the art to which the present invention most nearly pertains will readily be able to implement the invention based on the description set forth above. The above-described embodiment is set forth in terms of exemplary, well known logic synthesis tools, especially for deriving the structural representation and physical implementation from the RTL description of the device being designed. Other implementations would largely be driven by the particular technologies and logic synthesis tools that may be employed.\n\nCode listings for the Partitioner program (441 pages), the Synthesis Controller program (\"SYN CONTROLR\") which is a background program that processes the functional calls from the VHDL description of blocks (see FIG. 6) to memory blocks, mega-cells, mega-functions and other arithmetic unit functions in MDE and replaces these blocks by a component that can be simulated and merged (443 pages), and the \"LIVE\" (LSI Intelligent VHDL Environment) program, which is the Analyzer referred to hereinbefore (178 pages), are appended to parent U.S. patent application Ser. No. 07/507,201 (now U.S. Pat. No. 5,222,030, issued Jun. 22, 1993), and are incorporated by reference herein. These listings are all in executable code converted into hex through a standard UNIX utility.\n\nWith regard to FIGS. 1-15, there has been described a methodology for generating structural descriptions of complex digital devices from high-level descriptions and specifications is disclosed. The methodology uses a systematic technique to map and enforce consistency of the semantics imbedded in the intent of the original, high-level descriptions. The design activity is essentially a series of transformations operating upon various levels of design representations. At each level, the intended meaning (semantics) and formal software manipulations are captured to derive a more detailed level describing hardware meeting the design goals. Important features of the methodology are: capturing the users concepts, intent, specification, descriptions, constraints and trade-offs; architectural partitioning; what-if analysis at a high level; sizing estimation; timing estimation; architectural trade-off; conceptual design with implementation estimation; and timing closure. The methodology includes using estimators, based on data gathered over a number of realized designs, for partitioning and evaluating a design prior to logic synthesis. From the structural description, a physical implementation of the device is readily realized.\n\nFurther refinements to the methodology disclosed in FIGS. 1-15 are described hereinbelow. One skilled in the art to which the invention most nearly pertains will recognize that, although these refinements are particularly well-suited to implementation in the methodology of FIGS. 1-15, they may more generally be applied to other design methodologies that operate at various levels of abstraction.\n\nTop-Down Design Methodology\n\nIn general, the system design of a chip (or other complex electronic system) requires that a number of milestones be completed during the design process. Some of these milestones are:\n\na) Architectural definition and design completion\n\nb) Behavior definition and design completion\n\nc) Functional definition and design completion\n\nd) Logic definition and design completion\n\ne) Timing definition and design completion\n\nf) Physical definition and design completion (area, topology, floorplanning routing)\n\ng) Power definition and design completion\n\nh) Test definition and design completion\n\ni) Package definition and design completion\n\nMany of the tasks involved in meeting these milestones are inter-dependent. To accomplish them it is necessary to iterate among them. Trade-offs among the various definitions need to be done against some of the design goals and design constraints.\n\nIt is an object of the present invention to provide a technique for top-down design which achieves convergence of all the design tasks associated with meeting the above design milestones to meet design goals, constraints and specifications.\n\nCurrent practice is to achieve the various design milestones a) through i) iteratively (i.e., by trial and error) with little or no direct information about the impact of the method used to achieve one milestone on the achievement of subsequent milestones. This \"hit-or-miss\" approach becomes extremely time consuming as system complexity increases.\n\nAccording to the invention, a matrix of project milestones versus hierarchical level of design is created, thereby creating an array of hierarchically-related compound milestones. Completion criteria are defined for each entry in the matrix. Assuming that project-related milestones (project phases) progress from left-to-right across the matrix, and that the highest hierarchical levels are at the top of the matrix and progress downward, the inventive technique seeks to achieve the compound milestones in the matrix generally from top-left to bottom-right in a monotonic, unidirectional fashion using continuous refinement. Single level or multi-level estimators (predictors) are used to indicate the direction of progress.\n\nIn a preferred embodiment of the present invention, levels of top-down design abstraction are mapped to stages of design development as shown in FIG. 16a. The horizontal rows in matrix 1601 represent various stages of the design process, and the vertical columns represent levels of design abstraction. Each matrix element corresponds to a milestone which must be completed in the progression from the system-level conceptualization of a design to the culmination of the design process with the verification of the lowest level of design abstraction.\n\nThe matrix 1601 is a generalized milestone matrix. All design processes (levels) have the six design stages 1613, 1615, 1617, 1619, 1621, and 1623 in common. The manifestation of the stages varies from discipline to discipline, but the fundamentals of the stages are the same across all disciplines.\n\nSimilarly, the top-down design methodology is common to most (if not all) design disciplines and applicable to most (if not all) design projects. Top-down design is characterized by the division of the solution to a problem into increasingly detailed, but smaller and therefore more manageable, sub-solutions. In FIG. 16a, divisions are mapped onto abstraction levels 1605, 1606, 1609 and 1611. Because matrix 1601 is a generic matrix, no discipline-specific labels have been given to the columns. Each column represents a refinement over the column to its immediate left.\n\nFIG. 16b shows a milestone matrix 1625 for an ASIC design system. Columns 1629, 1631 and 1633 all represent three different levels of system level abstraction. System level abstraction is the block diagram description of the system. Columns 1635 and 1637 represent different levels of behavior/architectural level abstraction. In the behavioral/architectural level, some interconnections between blocks are defined and the blocks are given some functional definition. Columns 1639 and 1641 represent different lower-level Micro-architecture levels of abstraction. Micro-architecture refers to the RT level of abstraction. Column 1643 represents logic level abstraction. Logic level is typically the same as gate level.\n\nRows 1645 through 1655 represent the conceptual stage, the specification stage, the feasibility analysis stage, the design stage, the implementation stage, and the verification stage, respectively.\n\nEach matrix element (matrix elements are referred to herein by an x,y coordinate composed of the reference numerals of their associated row and column in the matrix) represent a milestone which must be completed. The simultaneous satisfaction of the completion criteria for of all milestones in the matrix indicates the completion of the system design.\n\nAssociated with the milestones in the various matrix elements are transitions which cause the completion of adjacent milestones. The transitions are enabled when the source milestone is completed. For example, matrix element (1645, 1629) represents the System Block Diagram milestone. Upon completion of the milestone, the user interface (described below with respect to FIG. 17) indicates that the milestone has been completed by shading a representation of the matrix element associated with the milestone on an icon of the matrix.\n\nDefinitions for Milestone Matrix Example (ASIC Design)\n\nFIG. 16b illustrates the milestone matrix in the context of an Integrated Circuit Design. The following section defines the various stages of design development and their corresponding milestones. Traversing from left to right in each row (each stage), a given matrix element (milestone) is always a refinement of the matrix element which is to the left of the given matrix element. For example, in the first row, the first element is the system block diagram, which is a very abstract description of the system in terms of blocks. The element to its right, the architectural and functional description milestone, represents a first-level refinement of the high-level system block diagram into a more detailed form. Traversing from top to bottom in a column, each successive milestone represents a further step towards project \"completeness\".\n\nProject Stage Definitions\n\nConceptual stage (1645)\n\nAt the completion of the conceptual stage a system block diagram has been defined. It has been given an initial partitioning with some definition as to the behavior of each block, both in terms of inputs and outputs and in terms of behavior code. Furthermore, the blocks and ports have been given names and some attributes and decisions have been made on what will be implemented in memory and what will be implemented as logic. Finally, the decision has been made as to which elements can be reused from prior designs and which should be developed from the ground up.\n\nSpecification stage (1647)\n\nAt the completion of the Specification stage, the blocks which make up the system have been identified and given functional specification. Furthermore, the system constraints as well as some of the logic that the developer should use to implement the system have been specified.\n\nFeasibility stage (1649)\n\nThe Feasibility stage uses estimator tools to determine whether the concepts developed in the conceptual stage can be implemented using the specification which was defined in the specification stage. At the end of the feasibility stage, the design feasibility has been examined at all levels of design abstraction and certain optimizations and \"what-if\" analysis tradeoffs have been conducted. The result is a specification which has been deemed feasible. The advantage of employing a rigorous feasibility check at a high-level of abstraction at an early stage of design development is that it avoids pursuing designs that will never work.\n\nImplementation stage (1653)\n\nIn this stage, the design is reduced to practice. At the completion of this stage, there is a (hopefully) working system. The following stage, verification, is a check to make sure that the matrix of milestone operated as designed. If the matrix of milestones can be operated with 100% confidence, the verification stage is not necessary. However, while that is a desirable goal, the requirement for having system that have been rigorously tested makes it equally desirable to execute the verification stage.\n\nVerification stage (1655)\n\nIn the verification stage, all aspects of the working system are tested and verified. Upon completion of this stage, all project activities (excluding production) are complete.\n\nMilestone Definitions\n\nNOTE: Milestones elements (ME's) are identified by their stage/level coordinates in FIG. 16b (e.g., ME(1647,1639) is the Timing, Area and Power goals milestone).\n\nME(1645, 1629): System Diagram\n\nIn this milestone the developer creates an initial conceptual design of the system. It is a pictorial description of the system components in terms of blocks which have some function. In an example from computer systems, the system block diagram may contain a CPU, I/O units, a memory, memory controller, and a bus.\n\nME(1645, 1631): Architecture and Function\n\nFunction refers to that each block diagram is assigned a function and architecture means that the blocks are given some ports for communication with other blocks and with units external to the design.\n\nME(1645, 1633): Functional Partitioning and Chip Partitioning.\n\nCreate an initial partitioning of the system block diagrams. Using the design of a computer system as an example, the initial partitioning the system may be based upon a decision as to which blocks will be implemented in logic and which will be implemented as memory modules (e.g. ROM, EPROMS, FPGA). The system block diagram is refined into sub-component blocks. An example of chip partitioning could be a decision that certain of the blocks will be developed as ASICs (Application Specific Integrated Circuits) and standard modules will be used for certain other blocks.\n\nME(1645, 1635): Partition into logic and memory.\n\nFurther refinement of the block diagram. It is a partitioning into what is logic and what is memory.\n\nME(1645, 1637): Preliminary Functional System Vectors (Test Bench)\n\nThe relationship between inputs and outputs. This milestone is a functional definition of the system in terms of input and output, i.e., given a particular input the system should produce a corresponding output. An example is from MPEG (an industry standard for digital video compression and manipulation) wherein input definition would be a video image and the output another video image which would be the result of the manipulations done by the system.\n\nME(1645, 1639): Preliminary RTL Description\n\nIn this milestone each block, either from the system block diagram, or from the further refinements from columns 1631 through 1637, is given a behavioral description in a behavioral description language (e.g. VHDL) defining the functional behavior of the block.\n\nME(1645, 1641): Entity/Port/Interface Definition\n\nAssignment of names to the blocks and ports. Furthermore, certain attributes are assigned to the ports. For example, a given port may be given the name \"Port A\" and the definition that it is a 16-bit integer port. In other words, the block diagram is given some properties.\n\nME(1645, 1643):Existing modules or designs\n\nFor each block decisions are made on whether to import an existing design or whether to design it from scratch.\n\nME(1647, 1629): Block definition and Behavioral Description\n\nA more detailed description of the behavior of the blocks that were defined in milestone (1645, 1629). For example, if the developer is dealing with an MPEG system the block definition may be a few lines of MPEG code defining how pixels are to be manipulated by the blocks. However, this description does not achieve the detail on how to do that manipulation in terms of logic.\n\nME(1647, 1631): Block functional specification (behavioral)\n\nA detailed specification of the system behavior in functional terms. This is the reference point to which the design must conform in terms of function.\n\nME(1647, 1633): System Timing goals, constraints\n\nIn this milestone the developer definition of the system level goals for timing, circuit area and power consumption for the blocks defined in the block diagram. Furthermore, in this milestone boundary conditions are given for each block and interface signal.\n\nME(1647, 1635): System data and control flow specifications:\n\nThis milestone is a break down of data and control and control signals for all the blocks in the block diagram. It defines the flow of data and control signals between the various blocks.\n\nME(1647, 1637): Number of chips and packages, specification\n\nThis milestone represents the specification of the number of chips used to implement each block. Furthermore, it is a definition of how many packages to be used and the specifications for those packages. An example would be: \"chip number 3 includes blocks a, b, and c, and will have 64 pins and will fit into package X.\" This is a very important milestone in that from the definitions given herein it is possible to estimate the cost of thesystem.\n\nME(1647, 1639): Micro-architecture timing, area and power goals\n\nThis milestone is a first specification of the system at the RT level. It is a specification of the goals for timing, area and power. However, being at the specification stage, it is not yet determined whether those goals are achievable (feasible).\n\nME(1647, 1641): Block RTL specification (simulation), timing v. area specifications\n\nThe completion of this milestone represents that the RT level code has been completed, debugged and is stable. The code is verified as correct be RT level simulation. The timing and area specification for the various elements in the system design is also finalized in this milestone.\n\nME(1647, 1643): Logic Definition Cost Specification and Critical Path Specification\n\nOne possible transition to this milestone from the block RTL specification milestone is through logic synthesis (however, in the context of this milestone matrix, synthesis is more appropriate at the implementation stage). In this milestone, the developer does a logic definition of the system and a cost specification. This milestone is achievable from the previously completed milestones, because the developer has a good idea about which gates will be used and where they will be used. The logic definition places the specification in context of defining some aspects of the logic which will be used to implement the specification.\n\nME(1649, 1629): Block definition and Behavioral Description: ASIC Partition\n\nThere are many different options for developing a given design. At the extremes of the spectrum of options are, for example, the system will be implemented entirely in ASICs and the system will only use standard products, respectively. The ASIC partitioning milestone defines which blocks will be developed as ASICs and which blocks will be standard products. This decision is important because the degree of integration has an impact on the cost of the final product.\n\nME(1649, 1631): Board and package size and speed estimation\n\nThis milestone uses estimators to determine whether it is possible to achieve the specified board and package size and speed constraints. The estimators can also be used to determine what packages to be used, what speed to use and how much speed to trade-off for area.\n\nME(1649, 1633): \"What-if\"-analysis; system tradeoff analysis\n\nIn the \"what-if\"-analysis milestone, the developer uses, for example, the architectural exploration tool to determine how various design decisions impact various properties of the system. For example, the introduction of redundant functional units may improve speed but increases both area and cost, while potentially decreasing reliability.\n\nME(1649, 1635): Board floor planning\n\nThis milestone represents an estimation of the board area used by the design. The term \"board\" is used here in a broad sense and encompasses, for example, printed circuit boards, multi-chip modules (MCM) and ASICs. An MCM is a module in which ASICs are laid out on a common substrate. By placing the ASICs on a single substrate it is possible to reduce the output driving capacitances, because these were designed to drive at the board level. Thus, having the option of putting the ASICs on a common substrate provides the designer with an additional parameter which may be used in optimizing the design with the goal of satisfying some constraints.\n\nME(1649, 1637): ASIC cost, size, speed, power feasibility\n\nIn this milestone the developer analyzes the feasibility of all of the ASICs in the system.\n\nME(1649, 1639): ASICs area, speed, power feasibility\n\nWhile the preceding milestone deals with the determination of whether the design on the whole is feasible given the specification of the various ASICs in the design, the present milestone is focused on the feasibility of individual ASICs. Furthermore, the developer uses exploration tools to do what-if-analysis on the design of each ASIC.\n\nME(1649, 1641 ): RTL Synthesis-Optimization (estimation only)\n\nThe what-if-analysis of the preceding milestones may reveal that there is some problem with the design, e.g., some constraints have not been satisfied. In the RTL Synthesis-Optimization milestone, the developer looks to the preliminary RTL description of the design to find ways to optimize the design so that the constraints will be met in the final design.\n\nME(1649, 1643): Logic/function/technology feasibility\n\nIn the preceding milestones estimators are run at a high-level of design abstraction. These estimators have been some inaccuracies. For that reason, it is beneficial to estimate the same properties at lower levels of abstraction, where more parameters are defined, to verify the correctness of the results obtained at the higher levels, thereby obtaining a lower level verification of the feasibility of the specification.\n\nME(1651, 1629): Block definition and Behavior Description: ASIC(s) behavioral design\n\nThe inputs to the Design stage are the block diagrams, the partitioning, the behavioral code, ASICs behavior have been completed and stabilized. These are used in the Design stage to arrive at a completed functional design, which in turn will be used for the global net list generation.\n\nME(1651, 1631 ): ASIC(s) RT level design completion\n\nThis milestone represents the completion and stabilization of the RT level design of the ASIC(s).\n\nME(1651, 1633): System Function Design\n\nThe system functional design milestone is very important in that it represents the conclusion of the functional design of the system. At the conclusion of this milestone all the pieces of the system have been given complete functional descriptions. This functional description can then be used to generate the global net list.\n\nME(1651, 1635): Global Net list generation\n\nThis is a synthesis step from the functional description of the system. All the blocks for all the components are merged into one system and are interconnected. This is a key milestone in that having a global net list it is possible to simulate and emulate the system.\n\nME(1651, 1637): System-level emulation, simulation\n\nHaving a completed global net list of the system it is possible to emulate and simulate the design. Emulation is crucial because it enables software developers to begin developing programs for the system before the system has actually been physically implemented. Furthermore, at this milestone it is possible to execute the \"test bench\" defined in milestone (1645, 1637). At this level additional test may be run. The emulation/simulation may be used for regression testing.\n\nME(1651, 1639): ASIC re-partitioning (timing)\n\nThis milestone represents the beginning of the designing for timing. The prior milestones are directed towards designing for functionality. However, a completed system design must also be designed with timing in mind. In the ASIC partitioning milestone, a partitioning for timing is conducted. The purpose of this re-partitioning is to place blocks on the critical path close to each other or even inside the same partitions.\n\nME(1651, 1641 ): Critical Path analysis, constraints and design\n\nAt this milestone the developer examines the design at the gate level to do critical path analysis. Further, in this milestone the developer checks how well the critical path satisfies the constraints. The developer may further redesign elements on the critical path to improve the performance of the system.\n\nME(1651, 1643): Chip Design (area/speed) & test design\n\nIn this milestone, the developer begins designing for testability (design-for-test). Design-for-test signifies that logic is added to the design so that the finished product can be tested.\n\nME(1653, 1629): Behavioral technology binding\n\nThis milestone represents the completion of binding the behavioral functional description into particular operators.\n\nME(1653, 1631 ): RTL technology binding\n\nAt this milestone, specific control elements are assigned to the control logic in the RT level description of the system. Prior to this milestone a given multiplexer used to control the input to a register element may have been described as a 5-to-1 mux, a rather generic term. At this milestone the same 5-to-1 mux may be bound to be, for example, an MUX51H, a non-inverting 5-to-1 mux in the LCA100K/LEA100K technologies, from the LSI Logic Corp.\n\nME(1653, 1633): Optimization\n\nIn this milestone, the developer does some fine-tuning of the design.\n\nME(1653, 1635): Synthesis and optimization\n\nIn this milestone, optimization of the circuit is done through a synthesis. This synthesis is conducted without any redefinition of the functionality of the design, i.e., there is no change in the behavioral code or in the RT level code. At this stage and level, the gates are known and the critical path is known. So the synthesis process can be directed to attempt to rebind in such a way as to achieve a little bit better performance on the critical path. This optimization is a fine-tuning of the net list to achieve the goal.\n\nME(1653, 1637): Final schematics floorplan, placement and timing optimization\n\nThe input to this milestone is the final schematic. Having this schematic enables the ECAD system to do a final floor planning of the system. Also optimization is achieved by placing elements close to each other.\n\nME(1653, 1639): Chip timing implementation\n\nThe result from the previous milestone is a final chip timing implementation.\n\nME(1653, 1641 ): Critical path optimization and layout\n\nThis milestone represents further critical path analysis and layout. At this stage the layout has been created. The critical can depend on wire delays in the layout. Therefore, in this milestone the developer used the layout to optimize the critical path. The completion of the optimization by layout results in the final chip layout.\n\nME(1653, 1643): Chip(s) layout test generation\n\nHaving a finished chip layout (the sequence of the flip-flops, etc.) and the design for test from the design stage, it is now possible to do test generation, for example for scan testing.\n\nME(1655, 1629): Block definition and Behavioral Description\n\nVerification that the system functionality satisfies the goals specified in the specification.\n\nME(1655, 1631 ): System constraints\n\nVerification that the system constraints as defined in the specification are met by the final design.\n\nME(1655, 1633): System timing\n\nVerification that the timing goals are met and that timing convergence has been achieved.\n\nME(1655, 1635): Chip(s) function\n\nVerification that the functionality of individual ASIC chips meet the specifications and constraints set out in the specification.\n\nME(1655, 1637): Chip(s) timing constraints\n\nA verification that the timing constraints placed on the each chip in the design is met.\n\nME(1655, 1639): Critical Paths\n\nA final look at the critical paths to determine that there are no critical paths which fail to meet the timing constraints.\n\nME(1655, 1641 ): Chip level logic compared to layout polygons\n\nThe final chip level logic is compared to the layout polygons to determine if the polygons correspond as expected to the chip level logic.\n\nME(1655, 1643): Test coverage\n\nFor each block decisions are made on whether to import an existing or whether to design it from scratch.\n\nThe transitions between milestones only allow progression from top to bottom and from left to right. Thus, to work towards the completion of a milestone, the milestone above or to the left must already have been completed. This monotonic progression from the upper left matrix element to the lower right matrix element ensures an orderly progression in the design of the system. Furthermore, the matrix provides the developer with a visual road-map of the design process. Looking at the matrix, the developer can instantly determine which milestones have been completed, which remain and which milestones can be completed next.\n\nFIG. 17 is a view of an iconic representation 1625' of matrix 1625 displayed on an ECAD system's graphic display device at an instance in the design process (Matrix 1625' is a version of milestone 1625 at a given instance in the development cycle.) This instance in the design process corresponds to the screen illustrated in and discussed in conjunction with FIG. 13. Matrix elements (1645, 1629), (1645, 1631 ), (1645, 1633), (1647, 1629), (1647, 1631 ), (1647, 1633), (1649, 1629), (1649, 1631 ) are highlighted or shaded to indicate that their corresponding milestones have been completed. Matrix elements (1645, 1635), (1647, 1635), (1649, 1633), (1651, 1631 ), (1651, 1629) are differently highlighted or shaded to show that their corresponding milestones may be worked on next. The developer has selected to work on the milestone corresponding to matrix element (1649, 1633) (the reference numerals refer to FIG. 16b. Matrix element (1649, 1633) is labeled 1701 in FIG. 17: the \"What-if-analysis; System trade-off analysis\" milestone.\n\nIn the example of FIG. 17, the user of the ECAD system has caused a pop-up menu 1703 associated with milestone 1701 (corresponding to ME(1649,1633), FIG. 16b) to appear on a display unit. The user has further selected one of the menu items in menu 1703, the \"Create designs\" item 1705, by placing cursor 1707 over that item. The create designs menu item 1705 causes the architectural explorer tool (1831, FIG. 18) to be executed. Thus, in the example of FIG. 17, the selection of menu item 1705 has caused the alternative designs shown in windows 1709 and 1711 to be created. Additionally, several designs not explicitly shown have been created. The designs shown in windows 1709 and 1711, as well as other designs, are shown as items 1709' and 1711' and 1713-1719 in window 1713. By examining the results from architectural explorer tool, the developer may make a trade"
    }
}