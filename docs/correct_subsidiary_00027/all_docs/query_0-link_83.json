{
    "id": "correct_subsidiary_00027_0",
    "rank": 83,
    "data": {
        "url": "https://www.chipestimate.com/Platform-based-vs-Model-Driven-Design/blogs/1193",
        "read_more_link": "",
        "language": "en",
        "title": "Platform-based vs. Model-Driven Design",
        "top_image": "https://www.chipestimate.com/blogs/IPInsider/wp-content/uploads/2012/12/SLD_vsia-300x225.jpg",
        "meta_img": "",
        "images": [
            "https://www.chipestimate.com/images/chipEstimate-logo.png",
            "https://www.chipestimate.com/images/btn-arrow.png",
            "https://www.chipestimate.com/images/b1.png",
            "https://www.chipestimate.com/images/heading.jpg",
            "https://www.chipestimate.com/blogs/IPInsider/wp-content/uploads/2012/12/WSD_Aug02_cover_crop-219x300.jpg",
            "https://www.chipestimate.com/blogs/IPInsider/wp-content/uploads/2012/12/SLD_vsia-300x225.jpg",
            "https://www.chipestimate.com/blogs/IPInsider/wp-content/uploads/2012/12/Celeoxica_flow-300x225.jpg",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/images/arrow-down.png",
            "https://www.chipestimate.com/blogs/IPInsider/wp-content/plugins/user-avatar/user-avatar-pic.php?src=https://www.chipestimate.com/blogs/IPInsider/wp-content/uploads/avatars/2/1397197881-bpfull.jpg&w=80&id=2&random=1499410677"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Ten years ago, platform-based design was gaining traction for system development. Today, model-driven design may be a better choice. Does that affect IP usage?",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.chipestimate.com/Platform-based-vs-Model-Driven-Design/blogs/1193",
        "text": "Ten years ago, platform-based design was gaining traction for system development. Today, model-driven design may be a better choice. Does that affect IP usage?\n\nShortly after the turn of the last millennium, a new phrase became popular to describe system-level design. That catch-phrase was “platform-based design (PBD).” Leading semiconductor pundits and editors alike discussed the importance of the new approach to system development – including yours truly: “Platform-Based Design Continues To Evolve.”\n\nReaders may remember that a critical component of platform-based design was a new element called intellectual property (IP).\n\nI can no longer find my original story on the Internet, probably because the magazine for which I wrote back in August 2002 has long since ceased publication. (All the editors still miss WSD, Cheryl Ajluni!) For reference, I’ve posted that story below.\n\nWhy the need for a reference? The reason is that I want to compare – and ask readers to comment upon – the differences between yesterday’s platform-based design and today’s model-driven design approach. Both are aimed at system-level development, but each may affect IP design and integration in different ways.\n\nLook for my thoughts in an upcoming column.\n\n++++++++++++\n\nPlatform-Based Design Continues To Evolve\n\nSystem-Level Design Of Complex Hardware-Software SoCs Continues To Improve With Various Platform-Based Design Approaches\n\nBy John Blyler, Wireless Systems Design magazine, August 2002\n\nSystem-level design continues to be the mantra of the EDA world. But what is the status of system-level design today? Have the candidate solutions from the last decade been improved or replaced with new approaches? Most designers in the EDA community are familiar with the most prominent approaches, including system-level design, IP use, platform-based design, co-design, and co-verification. All of these approaches sought to close the economic and time-to-market gap caused by the differences in design flows between the hardware and software implementation of their projects.\n\nSystem-level design approaches tried to bring a systems perspective to the design of SoCs by raising the level of model abstraction to the highest level, before hardware or software partitioning of functionality had begun. The biggest stumbling block to system-level design was the lack of a universal, system design language, notes Serge Leef, general manager for Mentor Graphics SoC Verification Division. “Hardware-centric languages are not suitable for software and software-centric languages lack hardware semantics.” To date, system languages are still not fully accepted by either software or hardware designers.\n\nStill, he notes, the design environment for hardware prototyping is increasingly using higher level languages, like C and C++, to define complex hardware. These models can then interact with existing RTL and embedded software in the verification environment early on in the design. Seamless, Mentor’s leading co-verification tool, has recently been extended with the addition of C-Bridge to enable this high-level C, C++, and HDL modeling.\n\nReuse of IP aimed to create a library of reusable hardware blocks or code that could be inserted into a design as needed. While reuse has been most successful in-house, a lack of standardized interfaces and verification techniques has hindered its use.\n\nBoth system-level design and reuse have evolved into an approach known as system-level platform-based design (PBD) (see Figure 1). Here, an optimized pre-designed core platform is used as the baseline around which processor subsystems can be built. This allows designers to focus on the differentiated part of their designs. This constrains the system-level design by using inherited hardware and software that has been proven in previous designs.\n\nPBD is based on a Virtual Component (VC) reuse, mix and match design methodology. This allows for the creation of a family of derivative products that share a common hardware-software architecture.\n\nPBD is a type of integration platform that comes in four different classes, according to Frank Schirrmeister, Cadence Business Director for Systems and Functional Verification:\n\nFull Application platforms – These allow users to design full applications on top of hardware-software architectures. Examples include Philips nExperia, the TI OMAP, and the Infineon MGold platform.\n\nProcessor Centric Platforms – These tend to be centered around specific processors and focus on the software access to the processor. Examples include Improv JAXX and the ST StarCore platforms.\n\nCommunication Centric Platforms – Provides users with a communication platform optimized for a specific application domain. Examples include the SONICs and the PalmChip architectures.\n\nFully Programmable Platform – Add programmable logic to the platform, allowing users to customize the platform using both hardware and software. Examples include the Triscend, Altera Excalibur, and Xilinx P-FPGA platforms combining dedicated processors and programmable logic.\n\nFrank notes that platform users vary from those expecting “shrink wrapped” platforms with complete hardware and software configurations to users who added both software routines and specific hardware blocks that are tailored for a specific platform. Cadence covers the entire system-level design space with its Signal Processing Work (SPW) system – IP authoring for DSP algorithms – and VCC for all stages of IP integration.\n\nAlthough proving extremely useful in decreasing the typical design cycle and lowering the cost of many SoC designs, PBD approaches are not for everyone. Steve Carlson, vice president of marketing for Get2Chip, explains that products requiring hardware-derived differentiation rarely use the off-the-shelf building-block approach. But he does agree that, “evolutionary hardware platforms in systems that derive most of their value from software might be suitable for platform-based design.” Get2Chip has recently introduced a RTL Compiler for hardware code synthesis.\n\nSuccessful system-level design does require a variety of techniques. Sections of the system can be prototyped using existing hardware, others can be prototyped using FPGAs, and the remainder can be done using C-based models – like SystemC – or HDL simulators. Stefano, of Arc, notes that “using both simulation and prototyping allows developers to investigate the effects of caches, on-chip buses, peripheral activity, real-time operation, and processor loading to various extents.” This approach is often used in the design of next-generation wireless handsets, where DSP and general processing functions must be partitioned between software and hardware and multiple processors. Arc provides solutions like ARCtangent–reconfigurable processors, VUSAB, and VMAC – configurable peripherals, C/C++ compilers, and the Seecode Debugger.\n\nSystem-Level Language\n\nOne common element in almost any system-level design approach is the need for a comprehensive hardware-software design language. SystemC has emerged as perhaps the most prevalent languages for system-level design, with most companies developing SystemC-based models that can be used in the platforms. Originally created by Synopsys Inc. as a C-based hardware modeler with a library of HDL RTL extensions, SystemC simulators are available from both Synopsys and CoWare, as well as the SystemC website (www.systemc.org).\n\nSimulating designs in SystemC has many advantages, notes Paula Jones for CoWare: “It avoids the need to use the Verilog Program Language Interface (PLI) or VHDL Foreign Language Interface (FLI), both of which are used to hook C-based models or testbenches to HDL simulators.” PLI and FLI can become significant bottlenecks in large simulations. CoWare provides tools for high-level design exploration, starting with a functional description, performing tradeoff analysis between hardware and software, and then synthesizing a design.\n\nAnother major advantage in using a C-based simulator is that it provides an early simulation environment for software developers, before the design is locked into a particular hardware implementation. Mike Fazeli, EDA Director, Digital Application Specific and Wireless Products for TI, agrees that without good hardware-software design capabilities, the designer must sequentially implement hardware and software, then wait through long periods of software patching and redesign cycles.\n\nSimulating the design can be used to better understand overall system functionality and requirements. It can also be used to verify the design. Early software verification plays a critical role in removing uncertainty for the detailed RTL design process, observes Johannes Stahl, Director of Marketing and Applications, System-Level Design at Synopsys. CoCentric System Studio, the Synopsys SystemC simulator, executes SystemC transaction-level models of platforms including buses, multiple processors, memories, and peripherals.\n\nAnother variation on C-based language simulation is Celoxica Limited’s Handel-C (see Figure 2). Really a hardware programming language, Handel-C has the syntax and semantics of ANSI-C but also includes constructs for hardware programming, such as a ‘par’ for desequentialising code. Will Golby, Vice President of Communications for Celoxica, explains that Handel-C is a language from hardware implementation, rather than hardware simulation. Celoxica’s DK1 design suite allows developers to migrate C-language algorithm designs directly to hardware-based FPGAs without the need for intervening HDLs. This could be used in conjunction with a platform-based design tool like CoWare’s N2C design system, where Celoxica’s DK1 could speed the hardware design once hardware-software simulation and partitioning is complete.\n\nAlthough slow, progress is being made toward an acceptable system design language based on C. But that is only one part of the cycle. A system design tool must work with a system implementation tool before a complete solution is realized."
    }
}