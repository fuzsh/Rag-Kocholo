{
    "id": "dbpedia_8406_3",
    "rank": 87,
    "data": {
        "url": "https://stackoverflow.com/questions/439630/create-a-date-with-a-set-timezone-without-using-a-string-representation",
        "read_more_link": "",
        "language": "en",
        "title": "Create a Date with a set timezone without using a string representation",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/9a1b5488f926f818b9aac995be2995ec?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/0c405651ae367cc72fc219fdea0a8073?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/a1fdb10b4d2a95ee301fce0685f779f8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/9DgZy.jpg?s=64",
            "https://www.gravatar.com/avatar/834795ba6177e6a9a395a837d996bb92?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/5S2vI.jpg?s=64",
            "https://www.gravatar.com/avatar/3ebc40c7d85f022edf73f550b39d3501?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/YPWiu.png?s=64",
            "https://www.gravatar.com/avatar/1678377fcbe8f336ac0c70de21677c7b?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/fd411e976471f069af158f612097a80e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/514f1ad54850fe2533132fb56fe87536?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/02dc7dda2d875f4a434dbb417792693c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/57oqA.jpg?s=64",
            "https://www.gravatar.com/avatar/f5bd7b8b00b2195f6c45181e6eb66357?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2bf66c189db3158d827866a23a41940f?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/b43fc626c2f5a8548bf72cefc145a189?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/dae6581f076a6c56ffa092b76795249a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a1886050cd297602173e31c91f9432ab?s=64&d=identicon&r=PG",
            "https://lh3.googleusercontent.com/-6OIGibYBFss/AAAAAAAAAAI/AAAAAAAAAOY/g5XjODKtFH4/photo.jpg?sz=64",
            "https://i.sstatic.net/TDrKx8Jj.png?s=64",
            "https://www.gravatar.com/avatar/94135ca3f69229020662d4db11e9470d?s=64&d=identicon&r=PG",
            "https://lh3.googleusercontent.com/-zQxF9Z5UL6Q/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucnp2QEgFrwjb7vXjYcm1hejZe3eRg/photo.jpg?sz=64",
            "https://i.sstatic.net/pSzU4.jpg?s=64",
            "https://www.gravatar.com/avatar/d49fbb154b36039f4baf96ae2f5a943d?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/jfiJ1.png?s=64",
            "https://i.sstatic.net/WwblI.jpg?s=64",
            "https://www.gravatar.com/avatar/e59162395991372b714ecde2500c8b80?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/pSzU4.jpg?s=64",
            "https://lh3.googleusercontent.com/a-/AOh14Gg-nWnrJ249wBXJ-Gl5gb20QrBJhKqJ6UCctcOX=k-s64",
            "https://i.sstatic.net/9DgZy.jpg?s=64",
            "https://lh3.googleusercontent.com/a-/AAuE7mBweZUWv7DoZAQS0j8qPSwlSEqgLPP6PviFg1r2=k-s64",
            "https://lh3.googleusercontent.com/-y6Oqaxd1oWE/AAAAAAAAAAI/AAAAAAAAAAA/AMZuucl9j0wlCLYLzEDwo3m8y5XRa3sE0w/photo.jpg?sz=64",
            "https://i.sstatic.net/rgAj1.jpg?s=64",
            "https://www.gravatar.com/avatar/2fd1b4efcc3dcf2560ae4ac427c57577?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/5c72f51f688ac9fa0beead86a8f35486?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/720eaae26dde17e86a50910cf41324c0?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/2729f70d8c0372e1af8678dfe92beabf?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/439630/ivc/5cf9?prg=e2cbe8b9-b6ff-40b6-ac2c-17c82326fed1",
            "https://stackoverflow.com/js-false.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-01-13T16:18:35",
        "summary": "",
        "meta_description": "I have a web page with three dropdowns for day, month and year. If I use the JavaScript Date constructor that takes numbers, then I get a Date object for my current timezone:\n\nnew Date(xiYear, xiMo...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/439630/create-a-date-with-a-set-timezone-without-using-a-string-representation",
        "text": "using .setUTCHours() it would be possible to actually set dates in UTC-time, which would allow you to use UTC-times throughout the system.\n\nYou cannot set it using UTC in the constructor though, unless you specify a date-string.\n\nUsing new Date(Date.UTC(year, month, day, hour, minute, second)) you can create a Date-object from a specific UTC time.\n\nI don't believe this is possible - there is no ability to set the timezone on a Date object after it is created.\n\nAnd in a way this makes sense - conceptually (if perhaps not in implementation); per http://en.wikipedia.org/wiki/Unix_timestamp (emphasis mine):\n\nUnix time, or POSIX time, is a system for describing instants in time, defined as the number of seconds elapsed since midnight Coordinated Universal Time (UTC) of Thursday, January 1, 1970.\n\nOnce you've constructed one it will represent a certain point in \"real\" time. The time zone is only relevant when you want to convert that abstract time point into a human-readable string.\n\nThus it makes sense you would only be able to change the actual time the Date represents in the constructor. Sadly it seems that there is no way to pass in an explicit timezone - and the constructor you are calling (arguably correctly) translates your \"local\" time variables into GMT when it stores them canonically - so there is no way to use the int, int, int constructor for GMT times.\n\nOn the plus side, it's trivial to just use the constructor that takes a String instead. You don't even have to convert the numeric month into a String (on Firefox at least), so I was hoping a naive implementation would work. However, after trying it out it works successfully in Firefox, Chrome, and Opera but fails in Konqueror (\"Invalid Date\") , Safari (\"Invalid Date\") and IE (\"NaN\"). I suppose you'd just have a lookup array to convert the month to a string, like so:\n\nvar months = [ '', 'January', 'February', ..., 'December']; function createGMTDate(xiYear, xiMonth, xiDate) { return new Date(months[xiMonth] + ' ' + xiDate + ', ' + xiYear + ' 00:00:00 GMT'); }\n\nIf you want to deal with the slightly different, but related, problem of creating a Javascript Date object from year, month, day, ..., including timezone – that is, if you want to parse a string into a Date – then you apparently have to do an infuriatingly complicated dance:\n\n// parseISO8601String : string -> Date // Parse an ISO-8601 date, including possible timezone, // into a Javascript Date object. // // Test strings: parseISO8601String(x).toISOString() // \"2013-01-31T12:34\" -> \"2013-01-31T12:34:00.000Z\" // \"2013-01-31T12:34:56\" -> \"2013-01-31T12:34:56.000Z\" // \"2013-01-31T12:34:56.78\" -> \"2013-01-31T12:34:56.780Z\" // \"2013-01-31T12:34:56.78+0100\" -> \"2013-01-31T11:34:56.780Z\" // \"2013-01-31T12:34:56.78+0530\" -> \"2013-01-31T07:04:56.780Z\" // \"2013-01-31T12:34:56.78-0330\" -> \"2013-01-31T16:04:56.780Z\" // \"2013-01-31T12:34:56-0330\" -> \"2013-01-31T16:04:56.000Z\" // \"2013-01-31T12:34:56Z\" -> \"2013-01-31T12:34:56.000Z\" function parseISO8601String(dateString) { var timebits = /^([0-9]{4})-([0-9]{2})-([0-9]{2})T([0-9]{2}):([0-9]{2})(?::([0-9]*)(\\.[0-9]*)?)?(?:([+-])([0-9]{2})([0-9]{2}))?/; var m = timebits.exec(dateString); var resultDate; if (m) { var utcdate = Date.UTC(parseInt(m[1]), parseInt(m[2])-1, // months are zero-offset (!) parseInt(m[3]), parseInt(m[4]), parseInt(m[5]), // hh:mm (m[6] && parseInt(m[6]) || 0), // optional seconds (m[7] && parseFloat(m[7])*1000) || 0); // optional fraction // utcdate is milliseconds since the epoch if (m[9] && m[10]) { var offsetMinutes = parseInt(m[9]) * 60 + parseInt(m[10]); utcdate += (m[8] === '+' ? -1 : +1) * offsetMinutes * 60000; } resultDate = new Date(utcdate); } else { resultDate = null; } return resultDate; }\n\nThat is, you create a 'UTC time' using the date without timezone (so you know what locale it's in, namely the UTC 'locale', and it's not defaulted to the local one), and then manually apply the indicated timezone offset.\n\nWouldn't it have been nice if someone had actually thought about the Javascript date object for more than, oooh, five minutes....\n\nI was having a similar problem with a date picker. My research led to a very simple solution, without any extra libraries or hardcoded multipliers.\n\nKey info:\n\nISO is the Javascript preferred date standard. Assume date utilities will likely return date values in that format.\n\nMy date picker displays the date in a localized format: mm/dd/yyyy\n\nHowever, it returns the date value in the ISO format: yyyy-mm-dd\n\n//Select \"08/12/2020\" in Date Picker date_input var input = $('#date_input').val(); //input: 2020-08-12\n\nDate.getTimezoneOffset() returns the offset in minutes.\n\nExamples:\n\nIf you use the default returned date value without modifying the string format, the Date might not get set to your timezone. This can lead to unexpected results.\n\nvar input = $('#date_input').val(); //input: 2020-08-12 var date = new Date(input); //This get interpreted as an ISO date, already in UTC //date: Tue Aug 11 2020 20:00:00 GMT-0400 (Eastern Daylight Time) //date.toUTCString(): Wed, 12 Aug 2020 00:00:00 GMT //date.toLocaleDateString('en-US'): 8/11/2020\n\nUsing a different date string format than the ISO standard yyyy-mm-dd applies your timezone to the Date.\n\nvar date = new Date(\"08/12/2020\"); //This gets interpreted as local timezone //date: Wed Aug 12 2020 00:00:00 GMT-0400 (Eastern Daylight Time) //date.toUTCString(): Wed, 12 Aug 2020 04:00:00 GMT //date.toLocaleDateString('en-US'): 8/12/2020\n\nSolution:\n\nTo apply your timezone to the format-agnostic Date without doing string manipulation, use Date.getTimezoneOffset() with Minutes. This works with either original date string format (i.e. UTC dates or localized dates). It provides a consistent result which can then be converted accurately to UTC for storage or interacting with other code.\n\nvar input = $('#date_input').val(); var date = new Date(input); date.setMinutes(date.getMinutes() + date.getTimezoneOffset()); //date: Wed Aug 12 2020 00:00:00 GMT-0400 (Eastern Daylight Time) //date.toUTCString(): Wed, 12 Aug 2020 04:00:00 GMT //date.toLocaleDateString('en-US'): 8/12/2020\n\nIt's actually not very hard at all to do this, but it certainly isn't intuitive to come up with the solution. There are some really convoluted answers here (though also some nice ones). Here's what I came up with to make sure my server timestamps would match my local timestamps, no matter what timezone my deployed server happened to be in.\n\n(CET = Central European Timezone, which just happens to be my personal timezone; you can get the offset of any given timezone and calculate it and even make it an argument if you like, but for my purpose, I just needed to get my dates to all be the single desired consistent timezone.)\n\nconst convertDateToCET = function(date) { date = new Date(date) // let startTime = date.getTime(); const cetOffset = -120; // this is the number you get from running // `(new Date()).getTimezoneOffset()` if you're on a machine in CET const offsetFromCET = (date.getTimezoneOffset() - cetOffset); const cetMillsecondOffset = ( cetOffset* 60 * 1000); date = new Date( date.getTime() - cetMillsecondOffset ) // let endTime = date.getTime() // console.log(\"updated date from\",startTime,\"to\",endTime) return date; },\n\nUsing this, you just make a time the way you would expect, e.g.\n\nlet myDate = new Date(\"12-4-2021\") myDate.setHour(14) myDate.setMinute(30) // now myDate is 2:30pm, December 4th, 2021, in whatever the timezone the machine of code running happens to be in myDate = convertDateToCET(myDate) // now myDate will show up as 2:30pm, Dec 4th, 2021, mapped into your local timezone // so, if you're in the UK, and one hour behind CET, myDate is now 1:30pm, Dec 4th, 2021\n\nThe key here is date.getTimezoneOffset(). If you're actually in CET, that number will be -120, and so it cancels out, making no difference (so CET results in CET out). If you're in the UK, one hour behind CET, that output would be -60, which means -60 + 120 = +60 which results in us changing the input time by one hour, and so on.\n\nIt probably makes more sense to convert everything and use everything in UTC for a case like this, but given that all of my input time is in CET and I'd originally developed the system based on how things looked locally on my machine, this utility allowed me to convert the existing code by just making a call to this function in a few key places.\n\nCaution: Make sure not to apply this function call multiple times on the same date, as you'll be reapplying the offset multiple times, throwing it off!"
    }
}