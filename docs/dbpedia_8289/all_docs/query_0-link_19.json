{
    "id": "dbpedia_8289_0",
    "rank": 19,
    "data": {
        "url": "https://en.wikipedia.org/wiki/List_of_programming_languages_by_type",
        "read_more_link": "",
        "language": "en",
        "title": "List of programming languages by type",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Wiki_letter_w_cropped.svg/20px-Wiki_letter_w_cropped.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/d/db/Symbol_list_class.svg/16px-Symbol_list_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2002-11-05T02:38:25+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/List_of_programming_languages_by_type",
        "text": "This is a list of notable programming languages, grouped by type.\n\nThe groupings are overlapping; not mutually exclusive. A language can be listed in multiple groupings.\n\nMain article: Agent-oriented programming\n\nAgent-oriented programming allows the developer to build, extend and use software agents, which are abstractions of objects that can message other agents.\n\nClojure\n\nF#\n\nGOAL\n\nSARL\n\nMain category: Array programming languages\n\nArray programming (also termed vector or multidimensional) languages generalize operations on scalars to apply transparently to vectors, matrices, and higher-dimensional arrays.\n\nMain article: Aspect-oriented programming\n\nAspect-oriented programming enables developers to add new functionality to code, known as \"advice\", without modifying that code itself; rather, it uses a pointcut to implement the advice into code blocks.\n\nAda\n\nAspectJ\n\nGroovy\n\nNemerle\n\nRaku[2][3]\n\nMain article: Assembly language\n\nAssembly languages directly correspond to a machine language (see below), so machine code instructions appear in a form understandable by humans, although there may not be a one-to-one mapping between an individual statement and an individual instruction. Assembly languages let programmers use symbolic addresses, which the assembler converts to absolute or relocatable addresses. Most assemblers also support macros and symbolic constants.\n\nMain article: Authoring language\n\nAn authoring language is a programming language designed for use by a non-computer expert to easily create tutorials, websites, and other interactive computer programs.\n\nDarwin Information Typing Architecture (DITA)\n\nLasso\n\nPILOT\n\nTUTOR\n\nAuthorware\n\nCommand-line interface (CLI) languages are also called batch languages or job control languages. Examples:\n\nMain article: Compiled language\n\nThese are languages typically processed by compilers, though theoretically any language can be compiled or interpreted.\n\nMain article: Concatenative programming language\n\nA concatenative programming language is a point-free computer programming language in which all expressions denote functions, and the juxtaposition of expressions denotes function composition.[4] Concatenative programming replaces function application, which is common in other programming styles, with function composition as the default way to build subroutines.\n\nFactor\n\nForth\n\njq (function application is also supported)\n\nJoy\n\nPostScript\n\nRaku[5]\n\nMain category: Concurrent programming languages\n\nFor a more comprehensive list, see List of concurrent and parallel programming languages.\n\nMessage passing languages provide language constructs for concurrency. The predominant paradigm for concurrency in mainstream languages such as Java is shared memory concurrency. Concurrent languages that make use of message passing have generally been inspired by process calculi such as communicating sequential processes (CSP) or the π-calculus.\n\nMain article: Constraint programming\n\nA constraint programming language is a declarative programming language where relationships between variables are expressed as constraints. Execution proceeds by attempting to find values for the variables which satisfy all declared constraints.\n\nClaire\n\nConstraint Handling Rules\n\nCHIP\n\nECLiPSe\n\nKaleidoscope\n\nRaku[8]\n\nA curly bracket or curly brace language has syntax that defines a block as the statements between curly brackets, a.k.a. braces, {}. This syntax originated with BCPL (1966), and was popularized by C. Many curly bracket languages descend from or are strongly influenced by C. Examples:\n\nDataflow programming languages rely on a (usually visual) representation of the flow of data to specify the program. Frequently used for reacting to discrete events or for processing streams of data. Examples of dataflow languages include:\n\nData-oriented languages provide powerful ways of searching and manipulating the relations that have been described as entity relationship tables which map one set of things into other sets.[citation needed] Examples of data-oriented languages include:\n\nDecision tables can be used as an aid to clarifying the logic before writing a program in any language, but in the 1960s a number of languages were developed where the main logic is expressed directly in the form of a decision table, including:\n\nFiletab\n\nMain category: Declarative programming languages\n\nDeclarative languages express the logic of a computation without describing its control flow in detail. Declarative programming stands in contrast to imperative programming via imperative programming languages, where control flow is specified by serial orders (imperatives). (Pure) functional and logic-based programming languages are also declarative, and constitute the major subcategories of the declarative category. This section lists additional examples not in those subcategories.\n\nSource embeddable languages embed small pieces of executable code inside a piece of free-form text, often a web page.\n\nClient-side embedded languages are limited by the abilities of the browser or intended client. They aim to provide dynamism to web pages without the need to recontact the server.\n\nServer-side embedded languages are much more flexible, since almost any language can be built into a server. The aim of having fragments of server-side code embedded in a web page is to generate additional markup dynamically; the code itself disappears when the page is served, to be replaced by its output.\n\nPHP\n\nVBScript\n\nTcl – server-side in NaviServer and an essential component in electronics industry systems\n\nWebDNA – dedicated to database-driven websites\n\nThe above examples are particularly dedicated to this purpose. A large number of other languages, such as Erlang, Scala, Perl, Ring and Ruby can be adapted (for instance, by being made into Apache modules).\n\nActionScript\n\nJavaScript (aka ECMAScript or JScript)\n\nVBScript (Windows only)\n\nA wide variety of dynamic or scripting languages can be embedded in compiled executable code. Basically, object code for the language's interpreter needs to be linked into the executable. Source code fragments for the embedded language can then be passed to an evaluation function as strings. Application control languages can be implemented this way, if the source code is input by the user. Languages with small interpreters are preferred.\n\nFor a more comprehensive list, see List of educational programming languages.\n\nLanguages developed primarily for the purpose of teaching and learning of programming.\n\nMain category: Esoteric programming languages\n\nAn esoteric programming language is a programming language designed as a test of the boundaries of computer programming language design, as a proof of concept, or as a joke.\n\nExtension programming languages are languages embedded into another program and used to harness its features in extension scripts.\n\nMain category: Fourth-generation programming languages\n\nFourth-generation programming languages are high-level languages built around database systems. They are generally used in commercial environments.\n\nMain category: Functional languages\n\nFunctional programming languages define programs and subroutines as mathematical functions and treat them as first-class. Many so-called functional languages are \"impure\", containing imperative features. Many functional languages are tied to mathematical calculation tools. Functional languages include:\n\nFor a more comprehensive list, see List of hardware description languages.\n\nIn electronics, a hardware description language (HDL) is a specialized computer language used to describe the structure, design, and operation of electronic circuits, and most commonly, digital logic circuits. The two most widely used and well-supported HDL varieties used in industry are Verilog and VHDL. Hardware description languages include:\n\nVerilog-AMS (Verilog for Analog and Mixed-Signal)\n\nVHDL-AMS (VHDL with Analog/Mixed-Signal extension)\n\nImperative programming languages may be multi-paradigm and appear in other classifications. Here is a list of programming languages that follow the imperative paradigm:\n\nInteractive mode languages act as a kind of shell: expressions or statements can be entered one at a time, and the result of their evaluation is seen immediately. The interactive mode is also termed a read–eval–print loop (REPL).\n\nInterpreted languages are programming languages in which programs may be executed from source code form, by an interpreter. Theoretically, any language can be compiled or interpreted, so the term interpreted language generally refers to languages that are usually interpreted rather than compiled.\n\nIterative languages are built around or offering generators.\n\nGarbage Collection (GC) is a form of automatic memory management. The garbage collector attempts to reclaim memory that was allocated by the program but is no longer used.\n\nMain article: Garbage collection (computer science)\n\nC\n\nC++\n\nComponent Pascal\n\nForth\n\nFortran\n\nFreeBASIC\n\nModula-2\n\nOberon\n\nPascal\n\nPL/I\n\nZig\n\nAda implementations are not required to offer garbage collection, but the language semantics support it, and many implementations include it.\n\nBlitz BASIC (also known as BlitzMax) is usually reference-counted,[12] and also supports a garbage collector. However, it also ships with optional utilities for using pointers[13] and for directly allocating and freeing memory.[14]\n\nCOBOL supports pointers[15] and heap allocation[16] as of COBOL 2002, along with a garbage collector.[17]\n\nCython provides optional manual memory management by letting the user import malloc, realloc, and free from C, which they can then use in Python code.[18]\n\nD provides programmers with full control over its own garbage collector, including the ability to disable it outright.[19]\n\nNim is usually garbage-collected or reference-counted by default, depending on its configuration, but the programmer may use the switch --mm:none to deallocate memory manually.[20]\n\nObjective-C and Objective-C++ support optional reference counting and garbage collection as alternatives to manual memory management (Apple deprecated the garbage collector).\n\nPostScript originally required developers to manually reclaim memory using the save and restore operators. PostScript Level 2 introduced a garbage collector, but its usage is optional.[21]\n\nRust supports optional reference counting, but manual memory management is preferred.\n\nScala normally manages the memory automatically in its JVM and JavaScript targets. However, the LLVM-based Scala Native compiler supports the use of pointers, as well as C-style heap allocation (e.g. malloc, realloc, free) and stack allocation (stackalloc).[22]\n\nSwift normally uses reference counting, but also allows the user to manually manage the memory using malloc and free. On Apple platforms, these functions are imported from the C standard library (which is imported from Foundation, AppKit or UIKit); on Linux, the developer needs to import Glibc, and ucrt on Windows.\n\nV (Vlang) uses GC by default, for user convenience, which can be turned off (-gc none). Users are free to manage memory manually. Can also use autofree (-autofree) or arena allocation (-prealloc).\n\nVala uses reference counting by default, but the user is free to manage the memory manually if they wish.[23]\n\nAda\n\nC\n\nC++\n\nFortran\n\nPascal\n\nRust[24][25]\n\nObjective-C\n\nZig\n\nObjective-C\n\nPerl\n\nSwift\n\nVisual Basic\n\nXojo\n\nList-based languages are a type of data-structured language that are based on the list data structure.\n\nLittle languages[26] serve a specialized problem domain.\n\nawk – used for text file manipulation.\n\nsed – parses and transforms text\n\nSQL – has only a few keywords and not all the constructs needed for a full programming language[a] – many database management systems extend SQL with additional constructs as a stored procedure language\n\nMain category: Logic programming languages\n\nLogic-based languages specify a set of attributes that a solution must-have, rather than a set of steps to obtain a solution.\n\nNotable languages following this programming paradigm include:\n\nALF\n\nAlma-0\n\nCurry\n\nDatalog\n\nFril\n\nFlix (a functional programming language with first-class Datalog constraints)\n\nJanus\n\nλProlog (a logic programming language featuring polymorphic typing, modular programming, and higher-order programming)\n\nOz, and Mozart Programming System cross-platform Oz\n\nProlog (formulates data and the program evaluation mechanism as a special form of mathematical logic called Horn logic and a general proving mechanism called logical resolution)\n\nMercury (based on Prolog)\n\nVisual Prolog (object-oriented Prolog extension)\n\nROOP\n\nSoufflé\n\nMachine languages are directly executable by a computer's CPU. They are typically formulated as bit patterns, usually represented in octal or hexadecimal. Each bit pattern causes the circuits in the CPU to execute one of the fundamental operations of the hardware. The activation of specific electrical inputs (e.g., CPU package pins for microprocessors), and logical settings for CPU state values, control the processor's computation. Individual machine languages are specific to a family of processors; machine-language code for one family of processors cannot run directly on processors in another family unless the processors in question have additional hardware to support it (for example, DEC VAX processors included a PDP-11 compatibility mode). They are (essentially) always defined by the CPU developer, not by 3rd parties.[b] The symbolic version, the processor's assembly language, is also defined by the developer, in most cases. Some commonly used machine code instruction sets are:\n\nMain category: Macro programming languages\n\nMacro languages transform one source code file into another. A \"macro\" is essentially a short piece of text that expands into a longer one (not to be confused with hygienic macros), possibly with parameter substitution. They are often used to preprocess source code. Preprocessors can also supply facilities like file inclusion.\n\nMacro languages may be restricted to acting on specially labeled code regions (pre-fixed with a # in the case of the C preprocessor). Alternatively, they may not, but in this case it is still often undesirable to (for instance) expand a macro embedded in a string literal, so they still need a rudimentary awareness of syntax. That being the case, they are often still applicable to more than one language. Contrast with source-embeddable languages like PHP, which are fully featured.\n\ncpp (the C preprocessor)\n\nm4 (originally from AT&T, bundled with Unix)\n\nML/I (general-purpose macro processor)\n\nTTM (developed at the California Institute of Technology)\n\nScripting languages such as Tcl and ECMAScript (ActionScript, ECMAScript for XML, JavaScript, JScript) have been embedded into applications. These are sometimes called \"macro languages\", although in a somewhat different sense to textual-substitution macros like m4.\n\nMetaprogramming is the writing of programs that write or manipulate other programs, including themselves, as their data or that do part of the work that is otherwise done at run time during compile time. In many cases, this allows programmers to get more done in the same amount of time as they would take to write all the code manually.\n\nMultiparadigm languages support more than one programming paradigm. They allow a program to use more than one programming style. The goal is to allow programmers to use the best tool for a job, admitting that no one paradigm solves all problems in the easiest or most efficient way.\n\nSeveral general-purpose programming languages, such as C and Python, are also used for technical computing, this list focuses on languages almost exclusively used for technical computing.\n\nMain article: Non-English-based programming languages\n\nChinese BASIC (Chinese)\n\nFjölnir (Icelandic)\n\nLanguage Symbolique d'Enseignement (French)\n\nRapira (Russian)\n\nezhil (Tamil)\n\nClass-based object-oriented programming languages support objects defined by their class. Class definitions include member data. Message passing is a key concept, if not the main concept, in object-oriented languages.\n\nPolymorphic functions parameterized by the class of some of their arguments are typically called methods. In languages with single dispatch, classes typically also include method definitions. In languages with multiple dispatch, methods are defined by generic functions. There are exceptions where single dispatch methods are generic functions (e.g. Bigloo's object system).\n\nPrototype-based languages are object-oriented languages where the distinction between classes and instances has been removed:\n\nOff-side rule languages denote blocks of code by their indentation.\n\nProcedural programming languages are based on the concept of the unit and scope (the data viewing range) of an executable code statement. A procedural program is composed of one or more units or modules, either user coded or provided in a code library; each module is composed of one or more procedures, also called a function, routine, subroutine, or method, depending on the language. Examples of procedural languages include:\n\nMain article: Query language\n\nReflective programming languages let programs examine and possibly modify their high-level structure at runtime or compile-time. This is most common in high-level virtual machine programming languages like Smalltalk, and less common in lower-level programming languages like C. Languages and platforms supporting reflection:\n\nSee also: Aspect-oriented programming\n\nRule-based languages instantiate rules when activated by conditions in a set of data. Of all possible activations, some set is selected and the statements belonging to those rules execute. Rule-based languages include:[citation needed]\n\nMain article: Scripting language\n\nMain category: Stack-oriented programming languages\n\nStack-based languages are a type of data-structured language that are based on the stack data structure.\n\nMain category: Synchronous programming languages\n\nSynchronous programming languages are optimized for programming reactive systems, systems that are often interrupted and must respond quickly. Many such systems are also called realtime systems, and are used often in embedded systems.\n\nExamples:\n\nArgus\n\nAverest\n\nEsterel\n\nLustre\n\nSignal\n\nCéu (programming language)\n\nSee also: Category:Shading languages\n\nA shading language is a graphics programming language adapted to programming shader effects. Such language forms usually consist of special data types, like \"color\" and \"normal\". Due to the variety of target markets for 3D computer graphics.\n\nThey provide both higher hardware abstraction and a more flexible programming model than previous paradigms which hardcoded transformation and shading equations. This gives the programmer greater control over the rendering process and delivers richer content at lower overhead.\n\nShading languages used in offline rendering produce maximum image quality. Processing such shaders is time-consuming. The computational power required can be expensive because of their ability to produce photorealistic results.\n\nThese languages assist with generating lexical analyzers and parsers for context-free grammars.\n\nANTLR\n\nCoco/R (EBNF with semantics)\n\nGNU bison (FSF's version of Yacc)\n\nGNU Flex (FSF version of Lex)\n\nlex (Lexical Analysis, from Bell Labs)\n\nM4\n\nParsing expression grammar (PEG)\n\nProlog\n\nEmacs Lisp\n\nLisp\n\nRaku[32]\n\nSableCC\n\nScheme\n\nyacc (yet another compiler-compiler, from Bell Labs)\n\nJavaCC\n\nThe system programming languages are for low-level tasks like memory management or task management. A system programming language usually refers to a programming language used for system programming; such languages are designed for writing system software, which usually requires different development approaches when compared with application software.\n\nSystem software is computer software designed to operate and control the computer hardware, and to provide a platform for running application software. System software includes software categories such as operating systems, utility software, device drivers, compilers, and linkers. Examples of system languages include:\n\nLanguage Originator First appeared Influenced by Used for ESPOL Burroughs Corporation 1961 ALGOL 60 MCP PL/I IBM, SHARE 1964 ALGOL 60, FORTRAN, some COBOL Multics PL360 Niklaus Wirth 1968 ALGOL 60 ALGOL W C Dennis Ritchie 1969 BCPL Most operating system kernels, including Windows NT and most Unix-like systems PL/S IBM 196x PL/I OS/360 BLISS Carnegie Mellon University 1970 ALGOL-PL/I[33] VMS (portions) PL/8 IBM 197x PL/I AIX PL/MP and PL/MI IBM 197x PL/I CPF, OS/400 PL-6 Honeywell, Inc. 197x PL/I CP-6 SYMPL CDC 197x JOVIAL NOS subsystems, most compilers, FSE editor C++ Bjarne Stroustrup 1979 C, Simula See C++ Applications[34] Ada Jean Ichbiah, S. Tucker Taft 1983 ALGOL 68, Pascal, C++, Java, Eiffel Embedded systems, OS kernels, compilers, games, simulations, CubeSat, air traffic control, and avionics D Digital Mars 2001 C++ Multiple domains[35] Nim Andreas Rumpf 2008 Ada, Modula-3, Lisp, C++, Object Pascal, Python, Oberon OS kernels, compilers, games Rust Mozilla Research[36] 2010 C++, Haskell, Erlang, Ruby Servo layout engine, Redox OS Swift Apple Inc. 2014 C, Objective-C, Rust macOS, iOS app development[e] Zig Andrew Kelley 2016 C, C++, LLVM IR, Go, Rust, JavaScript As a replacement for C V (Vlang) Alexander Medvednikov 2019 C, Go, Oberon-2, Rust, Swift, Kotlin Vinix OS, OS kernels, compilers, games\n\nMain article: Transformation language\n\nTransformation languages serve the purpose of transforming (translating) source code specified in a certain formal language into a defined destination format code. It is most commonly used in intermediate components of more complex super-systems in order to adopt internal results for input into a succeeding processing routine.\n\nMain category: Visual programming languages\n\nVisual programming languages let users specify programs in a two-(or more)-dimensional way, instead of as one-dimensional text strings, via graphic layouts of various types. Some dataflow programming languages are also visual languages.\n\nComputer scientist Niklaus Wirth designed and implemented several influential languages.\n\nThese are languages based on or that operate on XML."
    }
}