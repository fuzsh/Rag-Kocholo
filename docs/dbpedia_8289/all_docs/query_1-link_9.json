{
    "id": "dbpedia_8289_1",
    "rank": 9,
    "data": {
        "url": "https://arduino.stackexchange.com/questions/816/c-vs-the-arduino-language",
        "read_more_link": "",
        "language": "en",
        "title": "C++ vs. The Arduino Language?",
        "top_image": "https://cdn.sstatic.net/Sites/arduino/Img/apple-touch-icon@2.png?v=e2363697b9de",
        "meta_img": "https://cdn.sstatic.net/Sites/arduino/Img/apple-touch-icon@2.png?v=e2363697b9de",
        "images": [
            "https://cdn.sstatic.net/Sites/arduino/Img/logo.svg?v=e410af66f1cb",
            "https://www.gravatar.com/avatar/4e25ae2f50a5badb4cc866fc2b27115c?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/yAGNQ.jpg?s=64",
            "https://i.sstatic.net/3SowA.jpg?s=64",
            "https://i.sstatic.net/w9p6Y.jpg?s=64",
            "https://www.gravatar.com/avatar/51301603f62b97a6fecdeeb3a5d41eca?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/abe4cd3066235d70b965152e1aba944f?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/esQni.jpg?s=64",
            "https://graph.facebook.com/100003523396831/picture?type=large",
            "https://i.sstatic.net/dtHFq.png?s=64",
            "https://i.sstatic.net/YopqX.png?s=64",
            "https://i.sstatic.net/0TMc4HCY.jpg?s=64",
            "https://arduino.stackexchange.com/posts/816/ivc/0c39?prg=beb3a733-b2d5-4c6c-84c4-b000237f3d06"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2014-03-19T14:34:30",
        "summary": "",
        "meta_description": "What are the advantages of each language when using the Arduino?\n\nI'm thinking this is a good general question, but I'll add a bit about why I'm asking if anyone wants to give me a tip.\n\nI'm experi...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/arduino/Img/favicon.ico?v=d333dc520c93",
        "meta_site_name": "Arduino Stack Exchange",
        "canonical_link": "https://arduino.stackexchange.com/questions/816/c-vs-the-arduino-language",
        "text": "My personal experience as professor (programming, mechatronics) is that if you have previous programming experience and you are aware of concepts as OOP, it is better to go for C/C++. The arduino language is really great for beginners, but have some limitations (e.g. you must have all your files in the same folder). And it is basically a simplification of C/C++ (you can practically copy&paste arduino code to a C/C++ file, and it will work). Also it makes sense that you can go and use a full well known IDE as eclipse:\n\nhttp://playground.arduino.cc/Code/Eclipse\n\nInitially it is required a bit more of setup and configuration of your dev environment, but IMHO it is worth it for programmers with experience in any other language.\n\nIn any case, it won't harm you to start using the arduino language and the arduino IDE for a few days to get familiar with the arduino hardware and then move to C/C++ with Eclipse for really developing your project.\n\nIn theory...\n\nThere isn't really an Arduino language as such. It's really just C++ with some domain-specific libraries. These add on various features, such as functions you can call to control the hardware. If you didn't have those functions, you'd need to fiddle directly with special registers to control everything. That's how embedded programming is usually done. It's fast, but it can be quite hard to learn and understand.\n\nIn addition to the functions, the libraries add alternative names for some types. For example, boolean and byte are not in the C++ standard. However, they are directly equivalent to bool and unsigned char.\n\nAll of these things mean you can probably port general C++ code directly to Arduino without difficulty. However, going back the other way may require some minor editing.\n\nBut note that not all features of modern C++ versions are available on all Arduino platforms. In some cases, they aren't realistically possible, such as std::thread on an 8-bit microcontroller. Others simply haven't been made available, such as std::array.\n\nIn practice...\n\nHaving said all of that, programming for Arduino isn't exactly the same as general C++ programming. A lot of the differences are common to all embedded programming though (such as limited memory and processing power).\n\nIt's also worth noting that if you're using the official Arduino IDE then there are all sorts of annoying quirks and limitations on how you setup your code. There are workarounds in all cases (as far as I'm aware), but they are sometimes quite frustrating.\n\nFor full flexibility, use a third-party IDE (such as Eclipse) with a plug-in to support Arduino. That should give you all the advantages of C++, along with the Arduino libraries.\n\nWhat are the advantages of C++ vs the Arduino language when using Arduino? I'm experienced in preprocessed languages like JavaScript, PHP, and have fiddled with languages like Java and Visual Basic.\n\nFirst, the Arduino compiler/IDE accepts C and C++ as-is. In fact many of the libraries are written in C++. Much of the underlying system is not object oriented, but it could be.\n\nThus, \"The arduino language\" is C++ or C.\n\nC++ is not garbage collected. It does manage variables in scope - if you write:\n\nint led = 13; void blinkTimes(int value) { int i; for(i=0;i<value;i++) { digitalWrite(led, HIGH); delay(1000); digitalWrite(led, LOW); delay(1000); } }\n\nThen you'll find that led and i don't grow or leak, no matter how many times you call blinkTimes.\n\nIf i were a class, it would similarly be disposed of once the function ended. So as long as you aren't using new or similar memory allocation functions to create new objects, then you won't have to worry about leaks.\n\nYou may still run out of memory, if you create huge classes and use a lot of them in deeply nested functions, but in general you aren't going to run into trouble until you start dealing with new and free functions.\n\nIf you are using new, then you'll have to call delete at appropriate times. C++, and by extension Arduino, has no automatic garbage collection, you have to explicitly manage your own memory.\n\n--- Update 170412\n\nI wrote my original answer three years ago from the perspective of there existing a distinct \"Arduino C++\". The language used in the IDE is standard C++, because it is implemented by the GNU C++ compiler. \"Apparent\" differences creep in because the IDE will do some pre-processing to help newcomers to the language avoid a couple of 'gotcha's, by filling in some #includes, f/ex. But you can - and I do - write correct C++ to it and get just what you expect to get.\n\n--- end update\n\nDo limit your use of C++ language features to those whose implementation you fully understand. There are some features that compile to more resource-intensive code than is obvious from reading the source code. The optionally generated .lss (merged source and assembly) listing can give you some good insight into what the C++ compiler did when you weren't looking.\n\nTo your question about memory: C++ does not garbage-collect. Stack-based languages like C and C++ do allocate temporary storage on the stack for automatic variables at function entry, which then gets released when the function returns, but this is not true garbage-collection. Objects created in heap- or global memory live until you explicitly delete them. Make sure you know where, when, and for how long different kinds of objects will be created. You really don't want your code new-ing and delete-ing objects willy-nilly. They will be built in heap memory, fragmenting it and causing it to grow up into the stack. That's when your code - and your nice 'copter - will crash.\n\nC does less for you so it can do less to you. It's not a bad choice. C with a few of C++'s features can be an even better choice, given you choose the extra features judiciously.C++, if those are your two choices:\n\n[Original answer] - C++ is a standardized language. It is widely deployed in many environments including embedded systems and therefore is more thoroughly tested than the very-like-C++ language that is \"Arduino\". This is especially important for mission-critical / safety-critical applications such as you are planning. Crashed code means a crashed 'copter and even if it doesn't hurt someone, it will break your expensive machine.\n\nBeing standard, C++ is portable. Need to upgrade your processor? Everything but silicon-specific code will port to the new one. Need to change your toolset, development system, host OS? C++ will be supported everywhere. Though Arduino IDE will run anywhere Java is supported, it is the only tool that uses Arduino C++ and it is a very limited tool. If you want to use Eclipse, the AVR tools, go barefoot on the command-line, develop within Emacs, or whatever other environment you prefer, standard C++ will be supported.\n\nThe Arduino IDE does things behind your back - specifically, it #includes .h files when it thinks you need them. Even if it is correct, you really want to write, or at least see and understand, everything the compiler is going to see. Programming languages aren't made for computers (computers eat bits for breakfast); they're made for people, specifically the people who follow you on the project, the most important of whom may be ... you!, when 6 months after you wrote a module, you have to come back to enhance it, or more likely, fix it. You really want to be able to see everything the compiler sees.\n\nThe Arduino language is C++, but it is very different from most C++ varieties. The Arduino language has a lot of abstraction built in, especially in the hardware interfaces, which makes it very simple to use. If you have a background in Java, C and C++ should be very similar.\n\nThe main differences between Arduino and C++ are in the memory storage. Usually a modern computer has more than 2GB of RAM, while the Arduino Uno has 2kB (1 million times less). The Arduino also uses 8-bit instructions in stead of the 32 bit ones a computer uses. This will mainly affect the amount of information you can store in a variable.\n\nIf you are very new to the Arduino world, you should look up a tutorial, as there are many good ones out there.\n\nAs mentioned in several answers, if you are programing an embedded system in general you should avoid new unless you are managing your own memory heap and you really know what your object life cycles will be. Static allocation or stack variables are much safer. That said, one common trick to manage things like variable length buffers allocated for the duration of a function is to have an automatic variable (on the stack) that is an object that calls new in its constructor, and then put the delete in the destructor so when the object goes out of scope the buffer is released back to the heap. Again, this is usually of limited use in little micros but it is a nice pattern to remember.\n\nIn addition to the comments above, I would like to further stress the problems with working RAM that you have on Arduino boards, particularly with the Uno (and others that share the same microcontroller). I recently wrote a simple Space Invaders game running on a 32x32 LED matrix and repeatedly ran into problems caused by low memory.\n\nThe Uno only has 2048 bytes of RAM. The library for my matrix took over 3/4 of that leaving me with around 400 bytes for the game. As it is my intention to \"upgrade\" the project at some point to run multiple games with the same program base on the more powerful Due, I designed the code with OO principals and a lot of class inheritance. (The game class was inherited with virtual update and draw calls, the game entities were all inherited).\n\nI pretty much ran out of memory just adding the invaders. I tried to save memory by bit-fielding their member variables but ran out again when adding the shield objects. After a bit more scraping I ran out adding the bombs/bullets. At this point I scoured the code and removed all \"virtual\" tags (all my class prototypes are built from a Visual Assist snippet and destructors are all virtual automatically). This halved my memory usage instantly, freeing enough to be able to complete the code.\n\nLong story short, the end result is C++ code that doesn't really use any C++ features. You might be as well just sticking to C and being very aware of your memory usage. You get no help if you exceed the 2KB - particularly if you are using any dynamic allocation, the code just stops working and you are left scratching your head for a while until you consider the possibility of memory overflow.\n\nPS - Bit fielding variables is bad. Very bad. Apart from adding processing overhead, I lost track of the number of times I'd add a new state to the game but the code wouldn't run and I couldn't understand why. My state variable was not wide enough to hold the new state value so I was getting some unexpected state.\n\nArduino is C and C++ (it is a mix of the two, linked together); there is no \"Arduino\" programming language\n\nThe Arduino language is C++ (albeit usually implemented in a style more like \"C with classes,\" which is actually fairly common in the embedded systems microcontroller world). End of story. Enough with people thinking it's a different language already! It uses the g++ compiler.\n\nProof:\n\nEnable verbose output during compilation in the Preferences and upload and you'll learn a lot just reading those lines.\n\nHere's some additional insight:\n\nMy own words:\n\nArduino code is C++. The Arduino core functions are simply a set of C++ classes and libraries you can use. It is built and compiled using the GNU gcc/g++ compiler. Your setup() and loop() functions are simply placed into the mandatory (meaning: required by both C and C++ in order to even be considered a valid program) main() function (right here actually--notice the file is main.cpp, which is a C++ source file) automatically for you and there is some extra preprocessing done to make sure it is a valid C++ program (ex: scanning for all function prototypes [aka: declarations] for you so you can use a function even though its prototype comes later in your .ino file). Much of Arduino is written in C, however, and therefore requires the # extern \"C\" {} braces around it to prevent C++ from \"name-mangling\" (also known as \"name decorating/name decoration\") function calls to C functions implemented by AVR-libc, which is the C implementation for the ATmega328 and other AVR-architecture microcontrollers.\n\nArduino's words:\n\n\"Can I program the Arduino board in C?\n\nIn fact, you already are; the Arduino language is merely a set of C/C++ functions that can be called from your code. Your sketch undergoes minor changes (e.g. automatic generation of function prototypes) and then is passed directly to a C/C++ compiler (avr-g++). All standard C and C++ constructs supported by avr-g++ should work in Arduino. For more details, see the page on the Arduino build process.\"\n\nSource: https://support.arduino.cc/hc/en-us/articles/360018448219-Can-I-program-the-Arduino-board-in-C-\n\nWhen to use the Arduino library vs pure C or C++?\n\nSo, use the Arduino language where it simplifies things, and write your own functions where you need more specialization. I do recommend getting away from the IDE quickly though for writing code--just use it for compilation. Set the IDE preferences to use \"External Editor.\" Then use a professional source code editor/IDE such as Sublime Text 3, Atom, Visual Studio Code, or Eclipse CDT to write your code. You can then click back to the Arduino IDE to compile and upload. If you go with Eclipse, there are ways to do that in Eclipse (see the other answers here, and see the Arduino playground Eclipse article here too) so consider using those techniques too.\n\nUpdate: Eclipse setup\n\nSee my answer here and my document here: Eclipse setup instructions on a new Linux (or other OS) computer. I wrote a detailed PDF to describe setup."
    }
}