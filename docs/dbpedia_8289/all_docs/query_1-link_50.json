{
    "id": "dbpedia_8289_1",
    "rank": 50,
    "data": {
        "url": "https://docs.oracle.com/cd/B13789_01/server.101/b10743/data_access.htm",
        "read_more_link": "",
        "language": "en",
        "title": "25 Overview of Application Development Languages",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/prodicon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/bookicon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/conticon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/indxicon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/mix.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/feedback.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/larrow.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/rarrow.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/larrow.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/rarrow.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/oracle.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/prodicon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/bookicon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/conticon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/indxicon.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/mix.gif",
            "https://docs.oracle.com/cd/B13789_01/dcommon/gifs/feedback.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Overview of Oracle Call Interface (OCI)\n\nThe Oracle Call Inte rface (OCI) is an application programming interface (API) that lets you create applications that use the native procedures or function calls of a third-generation language to access an Oracle database server and control all phases of SQL statement execution. OCI supports the datatypes, calling conventions, syntax, and semantics of C and C++. OCI can directly access data in Oracle tables or can enqueue and dequeue data into or out of Oracle Streams.\n\nOCI provides the following:\n\nImproved performance and scalability through the use of system memory and network connectivity.\n\nConsistent interfaces for dynamic session and transaction management in a two-tier client/server or multitier environment.\n\nN-tiered authentication.\n\nComprehensive support for application development using Oracle objects.\n\nAccess to external databases.\n\nApplications that can service an increasing number of users and requests without additional hardware investments.\n\nOCI lets you manipulate data and schemas in an Oracle database using a host programming language, such as C. It provides a library of standard database access and retrieval functions in the form of a dynamic runtime library (OCI library) that can be linked in an application at runtime. This eliminates the need to embed SQL or PL/SQL within 3GL programs.\n\nAn important component of OCI is a set of calls to allow application programs to use a workspace called the object cache. The object cache is a memory block on the client side that allows programs to store entire objects and to navigate among them without round trips to the server.\n\nThe object cache is completely under the control and management of the application programs using it. The Oracle database server has no access to it. The application programs using it must maintain data coherency with the server and protect the workspace against simultaneous conflicting access.\n\nOCI provides functions to:\n\nAccess objects on the server using SQL\n\nAccess, manipulate and manage objects in the object cache by traversing pointers or REFs\n\nConvert Oracle dates, strings and numbers to C datatypes\n\nManage the size of the object cache's memory\n\nCreate transient type descriptions. Transient type descriptions are not stored persistently in the database. Compatibility must be set to Oracle9i or higher.\n\nOCI improves concurrency by allowing individual objects to be locked. It improves performance by supporting complex object retrieval.\n\nOCI developers can use the object type translator to generate the C datatypes corresponding to a Oracle object types.\n\nSee Also:\n\nOverview of Oracle C++ Call Interface (OCCI)\n\nThe Oracle C+ + Call Interface (OCCI) is a C++ API that lets you use the object-oriented features, native classes, and methods of the C++ programing language to access the Oracle database. The OCCI interface is modeled on the JDBC interface and, like the JDBC interface, is easy to use. OCCI is built on top of OCI and provides the power and performance of OCI using an object-oriented paradigm.\n\nOCI supports the entire Oracle feature set and provides efficient access to both relational and object data, but it can be challenging to use--particularly if you want to work with complex, object datatypes. Object types are not natively supported in C, and simulating them in C is not easy. OCCI provides a simpler, object-oriented interface to the functionality of OCI. It does this by defining a set of wrappers for OCI. Developers can use the underlying power of OCI to manipulate objects in the server through an object-oriented interface that is significantly easier to program.\n\nOCCI Associative Relational and Object Interfaces\n\nThe asso ciative relational API and object classes provide SQL access to the database. Through these interfaces, SQL is run on the server to create, manipulate, and fetch object or relational data. Applications can access any dataype on the server, including the following:\n\nLarge objects\n\nObjects/structured types\n\nArrays\n\nReferences\n\nOCCI Navigational Interface\n\nThe navigation al interface is a C++ interface that lets you seamlessly access and modify object-relational data in the form of C++ objects without using SQL. The C++ objects are transparently accessed and stored in the database as needed.\n\nWith the OCCI navigational interface, you can retrieve an object and navigate through references from that object to other objects. Server objects are materialized as C++ class instances in the application cache. An application can use OCCI object navigational calls to perform the following functions on the server's objects:\n\nCreate, access, lock, delete, and flush objects\n\nGet references to the objects and navigate through them\n\nSee Also:\n\nOverview of Pro*C/C++ Precompiler\n\nAn Oracle precompiler is a p rogramming tool that lets you embed SQL statements in a high-level source program. The precompiler accepts the host program as input, translates the embedded SQL statements into standard Oracle run-time library calls, and generates a source program that you can compile, link, and run in the usual way. Oracle precompilers are available (but not on all systems) for C/C++, COBOL, and FORTRAN.\n\nThe Oracle Pro*C/C++ Precompiler lets you embed SQL statements in a C or C++ source file. Pro*C/C++ reads the source file as input and outputs a C or C++ source file that replaces the embedded SQL statements with Oracle runtime library calls, and is then compiled by the C or C++ compiler.\n\nUnlike many application development tools, Pro*C/C++ lets you create highly customized applications. For example, you can create user interfaces that incorporate the latest windowing and mouse technology. You can also create applications that run in the background without the need for user interaction.\n\nFurthermore, Pro*C/C++ helps you fine-tune your applications. It allows close monitoring of resource use, SQL statement execution, and various runtime indicators. With this information, you can change program parameters for maximum performance.\n\nAlthough precompiling adds a step to the application development process, it saves time. The precompiler, not you, translates each embedded SQL statement into calls to the Oracle runtime library (SQ LLIB). The Pro*C/C++ precompiler also analyzes host variables, defines mappings of structures into columns, and, with SQLCHECK=FULL, performs semantic analysis of the embedded SQL statements.\n\nThe Oracle Pro*C/C++ precompiler also allows programmers to use object datatypes in C and C++ programs. Pro*C developers can use the Object Type Translator to map Oracle object types and collections into C datatypes to be used in the Pro*C application.\n\nPro*C provides compile time type checking of object types and collections and automatic type conversion from database types to C datatypes. Pro*C includes an EXEC SQL syntax to create and destroy objects and offers two ways to access objects in the server:\n\nSQL statements and PL/SQL functions or procedures embedded in Pro*C programs\n\nA simple interface to the object cache, where objects can be accessed by traversing pointers, then modified and updated on the server\n\nDynamic Creation and Access of Type Descriptions\n\nOracle provides a C API to enable dynamic creation and access of type descriptions. Additionally, you can create transient type descriptions, type descriptions that are not stored persistently in the DBMS.\n\nThe C API enables creation and access of OCIAnyData and OCIAnyDataSet.\n\nThe OCIAnyData type models a self descriptive (with regard to type) data instance of a given type.\n\nThe OCIAnyDataSet type models a set of data instances of a given type.\n\nOracle also provides SQL datatypes (in Oracle's Open Type System) that correspond to these datatypes.\n\nSYS.ANYTYPE corresponds to OCIType\n\nSYS.ANYDATA corresponds to OCIAnyData\n\nSYS.ANYDATASET corresponds to OCIAnyDataSet\n\nYou can create database table columns and SQL queries on such data.\n\nThe C API uses the following terms:\n\nTransient types - Type descriptions (type metadata) that are not stored persistently in the database.\n\nPersistent types - SQL types created using the CREATE TYPE SQL statement. Their type descriptions are stored persistently in the database.\n\nSelf-descriptive data - Data encapsulating type information along with the actual contents. The ANYDATA type (OCIAnyData) models such data. A data value of any SQL type can be converted to an ANYDATA, which can be converted back to the old data value. An incorrect conversion attempt results in an exception.\n\nSelf-descriptive MultiSet - Encapsulation of a set of data instances (all of the same type), along with their type description.\n\nSee Also:\n\nOpen Database Connectivity\n\nOpen database co nnectivity (ODBC), is a database access protocol that lets you connect to a database and then prepare and run SQL statements against the database. In conjunction with an ODBC driver, an application can access any data source including data stored in spreadsheets, like Excel. Because ODBC is a widely accepted standard API, applications can be written to comply to the ODBC standard. The ODBC driver performs all mappings between the ODBC standard and the particular database the application is accessing. Using a data source-specific driver, an ODBC compliant program can access any data source without any more development effort.\n\nOracle provides the ODBC interface so that applications of any type that are ODBC compliant can access the Oracle database using the ODBC driver provided by Oracle. For example, an application written in Visual Basic can use ODBC to access the Oracle database.\n\nOverview of Oracle Objects for OLE\n\nOracle Objects for OLE (OO4O) allows easy access to data stored in Oracle databases with any programming or scripting language that supports the Microsoft COM Automation and ActiveX technology. This includes Visual Basic, Visual C++, Visual Basic For Applications (VBA), IIS Active Server Pages (VBScript and JavaScript), and others.\n\nOO4O consists of the following software layers:\n\nOO4O Automation Server\n\nOracle Data Control\n\nThe Oracle Objects for OLE C++ Class Library\n\nOO4O Automation Server\n\nThe OO 4O Automation Server is a set of COM Automation objects for connecting to Oracle database servers, executing SQL statements and PL/SQL blocks, and accessing the results.\n\nOO4O provides key features for accessing Oracle databases in environments ranging from the typical two-tier client/server applications, such as those developed in Visual Basic or Excel, to application servers deployed in multitiered application server environments, such as Web server applications in Microsoft Internet Information Server (IIS) or Microsoft Transaction Server (MTS).\n\nOracle Data Control\n\nThe Oracle Data Control (ODC) is an ActiveX Control designed to simplify the exchange of data between an Oracle database and visual controls, such edit, text, list, and grid controls in Visual Basic and other development tools that support custom controls.\n\nODC acts an agent to handle the flow of information from an Oracle database and a visual data-aware control, such as a grid control, that is bound to it. The data control manages various user interface (UI) tasks such as displaying and editing data. It also runs and manages the results of database queries.\n\nThe Oracle Objects for OLE C++ Class Library\n\nThe Oracle Objects for OLE C++ Class Library is a collection of C++ classes that provide programmatic access to the Oracle Object Server. Although the class library is implemented using OLE Automation, neither the OLE development kit nor any OLE development knowledge is necessary to use it. This library helps C++ developers avoid writing COM client code for accessing the OO4O interfaces."
    }
}