{
    "id": "dbpedia_8289_1",
    "rank": 92,
    "data": {
        "url": "https://www.artificialworlds.net/blog/2008/04/07/c-is-an-expert-language/",
        "read_more_link": "",
        "language": "en",
        "title": "C++ is an expert language – Andy Balaam's Blog",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://sfconservancy.org/img/supporter-badge.png",
            "https://www.artificialworlds.net/blog/prompt-black.png",
            "https://www.artificialworlds.net/blog/wp-content/themes/twentyfifteen-child/images/mastodon_24.png",
            "https://www.artificialworlds.net/blog/wp-content/themes/twentyfifteen-child/images/mastodon_24.png",
            "https://secure.gravatar.com/avatar/4c7cfbfaf33789fbea36bc5507c05c36?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/6a6e351ce0ac626c2df5f2b552d8a11f?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/f8252f6b892312c3f56cbc300360f064?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/260643b3c947a8f50a74779507ea48cd?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/357a20e8c56e69d6f9734d23ef9517e8?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/b4881d15649585c2e8fd03a541ad5b1b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/b4881d15649585c2e8fd03a541ad5b1b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/e0b7387f4ece354221d75f24f3f1e896?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/6df55b09adf6e85b1e76e7e13a1593d7?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/01822efaf66e4b81d6f947cba7e0613a?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/488cc2ffcb7c373e853100098b2ea5b8?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/4f41482ec0c8e0881424fdf511f86b7f?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/d31a2a2d43191b15ca4a1c7ec7d03038?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/f2e652670134a283ad523fc3c9b5ba95?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/b9999d0efacb366606545f4adeefc32b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/dbed214b809842ed28165ca6ca12dc98?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/bf5bb7b792f76e59addbfd931e0c31ee?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/fa09759e2032b165421a4847dfc3fe8f?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/fe9610067b97a0971f929b3a27fc0efc?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/081274a7a7bcacfba72a3bddf5002b1d?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/31a7151a7f3fc70ab2fdce4f5a0c9469?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/c1b6ef5800a2755f7aac1e766df51d51?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/c354d602ba135c01f6291e1b00e639ea?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/f7b90731b868909658f977f5f300f2c2?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/c4da5f22e56a1f6030267682bdaf947b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/f94f88675920ab3f789ffd1e4fff040e?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/5cc47d67207f05b6f0e580243328439b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/8600e8bb7ac3514b3222e698d3901c6b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/33aef298c2ce6ee5f6920a31da7e848a?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/8600e8bb7ac3514b3222e698d3901c6b?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/33aef298c2ce6ee5f6920a31da7e848a?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/31a7151a7f3fc70ab2fdce4f5a0c9469?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/31a7151a7f3fc70ab2fdce4f5a0c9469?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/d9bc736eb19b1990fc6cfaecec71cee9?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/31a7151a7f3fc70ab2fdce4f5a0c9469?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/a5e0615dc0a1770c29115a40fcf2eb11?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/2b1731fb3b904846c6b93eeeffb1da1a?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/d9bc736eb19b1990fc6cfaecec71cee9?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/4dff95285b640a12e9a81f67a49ec07e?s=56&d=mm&r=g",
            "https://secure.gravatar.com/avatar/af45da48d526ae3c59a7046fccfdd78b?s=56&d=mm&r=g"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Author Andy Balaam"
        ],
        "publish_date": "2008-04-07T00:00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.artificialworlds.net/blog/2008/04/07/c-is-an-expert-language/",
        "text": "Update: I should point out at the beginning that I love C++. Anything below which sounds bitter or critical is borne of a deep and growing love. C++ is a journey into worlds of beauty and strength.\n\nI assert that C++ is an expert language. What do I mean?\n\nYou shouldn’t be allowed to use C++ in anger unless you’ve used it for 2 years in anger.\n\nAside: what should we do about this?\n\nIn practice this means that no-one should recruit newbie C++ developers.\n\nThe only alternative is to have some kind of apprenticeship system, where all the code written by a newbie is re-written by their mentor for about 2 years. This is a great learning experience, and could weed out people with insufficient capacity for humility to be a C++ programmer. (Note I say capacity for humility, because the actual humility will be provided by the constant crushing of your spirit provided by someone tearing your code apart every day.)\n\nIn Java, to create an “array”, and add an object to it, you do this:\n\nMyObj obj = new MyObj(); ArrayList<MyObj> arr = new ArrayList<MyObj>(); arr.add( obj );\n\nIn Python, you do this:\n\nobj = MyObj() arr = [] arr.append( obj )\n\nIn C, you do this:\n\nMyStruct obj; MyStruct arr[50] = { obj };\n\nIn Perl, you do this:\n\nmy $obj = MyObj->new(); my @arr; push(@arr,$obj);\n\nIn Pascal, you do this:\n\nvar arr : ARRAY [1..50] of int; begin arr[1] := 7; end\n\nIn Haskell, you might do something like this (thanks to Neil Mitchell):\n\n[myObj]\n\nDon’t get het up about the fact that these examples do different things: my point is, they are reasonable ways of performing the task (add something to an array) in the languages chosen. (Please do send in corrections, though – none of these were checked and they are probably wrong.)\n\nNote that the C example hides a little more complexity because you need to make sure you tidy up your memory afterwards.\n\nNow, what do you do in C++? It’s just as easy, right?\n\nMyObj obj; std::vector<MyObj> arr; arr.push_back( obj );\n\nWRONG!\n\nIn the examples above, you don’t need to know what is going on under the covers.\n\nIn fact, in general I suggest there are broadly two types of programming language around at the moment: those where you have to know how things work, but where how things work is quite simple (e.g. C, assembly languages, maybe FORTRAN and COBOL) and those which isolate you from how things work (all the rest?).\n\nWhere does C++ fit in to this scheme? It is in the unique position of being a language which has incredibly complex things going on under the covers, and you have to know about it!\n\nWhat do I mean by saying you have to know what’s going on under the covers?\n\nLet’s look at our example again, and ask this question: what types of object can you put in the array? In the other programming languages above, you can essentially put any “normal” objects (where normal is different for each example) into the array.\n\nIn C++, here are some of the rules you need to understand about objects you can put into std::vector. You should understand these before you try using std::vector. If you can’t understand them, you should think hard until you do.\n\nDefault constructor\n\nIf you want to give the size of the vector when you create it (or resize it later), your object must have a default constructor [Stroustrup §16.3.4].\n\n(Note: if you don’t define any other constructors, the compiler will automatically define a default constructor for you (which may or may not do what you want). If you do, the default constructor is the one that can be called without any arguments [Stroustrup §10.4.2].\n\nExample:\n\n$ cat default_constructor_required.cpp #include <vector> class MyObject { public: MyObject( int num ) { } }; int main( int argc, const char* argv[] ) { std::vector<MyObject> arr( 5 ); } $ g++ default_constructor_required.cpp /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h: In constructor â€˜std::vector<_Tp, _Alloc>::vector(size_t) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™: default_constructor_required.cpp:12: instantiated from here /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h:219: error: no matching function for call to â€˜MyObject::MyObject()â€™ default_constructor_required.cpp:5: note: candidates are: MyObject::MyObject(int) default_constructor_required.cpp:4: note: MyObject::MyObject(const MyObject&)\n\nNice error message, eh?\n\n(Note: if your array contains a built-in type (e.g. int) it will be initialised to 0 in its default constructor [Stroustrup §4.9.5].\n\nIf you don’t want to give the size of the vector when you create it (not recommended), then you don’t need a default constructor in your object [Stroustrup §16.3.4].\n\nCopy constructor\n\nYour object must also have a copy constructor. Example:\n\n$ cat copy_constructor_required.cpp #include <vector> class MyObject { public: MyObject() { } private: MyObject( const MyObject& ); }; int main( int argc, const char* argv[] ) { std::vector<MyObject> arr( 5 ); } $ g++ copy_constructor_required.cpp /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h: In constructor â€˜std::vector<_Tp, _Alloc>::vector(size_t) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™: copy_constructor_required.cpp:15: instantiated from here copy_constructor_required.cpp:10: error: â€˜MyObject::MyObject(const MyObject&)â€™ is private /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h:219: error: within this context /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_construct.h: In function â€˜void std::_Construct(_T1*, const _T2&) [with _T1 = MyObject, _T2 = MyObject]â€™: /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_uninitialized.h:194: instantiated from â€˜void std::__uninitialized_fill_n_aux(_ForwardIterator, _Size, const _Tp&, __false_type) [with _ForwardIterator = MyObject*, _Size = unsigned int, _Tp = MyObject]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_uninitialized.h:218: instantiated from â€˜void std::uninitialized_fill_n(_ForwardIterator, _Size, const _Tp&) [with _ForwardIterator = MyObject*, _Size = unsigned int, _Tp = MyObject]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_uninitialized.h:310: instantiated from â€˜void std::__uninitialized_fill_n_a(_ForwardIterator, _Size, const _Tp&, std::allocator<_Tp2>) [with _ForwardIterator = MyObject*, _Size = unsigned int, _Tp = MyObject, _Tp2 = MyObject]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h:219: instantiated from â€˜std::vector<_Tp, _Alloc>::vector(size_t) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™ copy_constructor_required.cpp:15: instantiated from here copy_constructor_required.cpp:10: error: â€˜MyObject::MyObject(const MyObject&)â€™ is private /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_construct.h:81: error: within this context\n\n(Aside: this program is 181 bytes, and the error message is 1950 bytes.)\n\nAssignment operator\n\nYou also need operator=. Example:\n\n$ cat assignment_operator_required.cpp #include <vector> class MyObject { private: MyObject& operator=( const MyObject& ); }; int main( int argc, const char* argv[] ) { MyObject obj; std::vector<MyObject> arr; arr.push_back( obj ); } $ g++ assignment_operator_required.cpp /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/vector.tcc: In member function â€˜void std::vector<_Tp, _Alloc>::_M_insert_aux(__gnu_cxx::__normal_iterator<typename _Alloc::pointer, std::vector<_Tp, _Alloc> >, const _Tp&) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™: /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h:610: instantiated from â€˜void std::vector<_Tp, _Alloc>::push_back(const _Tp&) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™ assignment_operator_required.cpp:13: instantiated from here assignment_operator_required.cpp:6: error: â€˜MyObject& MyObject::operator=(const MyObject&)â€™ is private /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/vector.tcc:260: error: within this context /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_algobase.h: In static member function â€˜static _BI2 std::__copy_backward<_BoolType, std::random_access_iterator_tag>::copy_b(_BI1, _BI1, _BI2) [with _BI1 = MyObject*, _BI2 = MyObject*, bool _BoolType = false]â€™: /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_algobase.h:443: instantiated from â€˜_BI2 std::__copy_backward_aux(_BI1, _BI1, _BI2) [with _BI1 = MyObject*, _BI2 = MyObject*]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_algobase.h:482: instantiated from â€˜static _BI2 std::__copy_backward_normal<true, true>::copy_b_n(_BI1, _BI1, _BI2) [with _BI1 = __gnu_cxx::__normal_iterator<MyObject*, std::vector<MyObject, std::allocator<MyObject> > >, _BI2 = __gnu_cxx::__normal_iterator<MyObject*, std::vector<MyObject, std::allocator<MyObject> > >]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_algobase.h:517: instantiated from â€˜_BI2 std::copy_backward(_BI1, _BI1, _BI2) [with _BI1 = __gnu_cxx::__normal_iterator<MyObject*, std::vector<MyObject, std::allocator<MyObject> > >, _BI2 = __gnu_cxx::__normal_iterator<MyObject*, std::vector<MyObject, std::allocator<MyObject> > >]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/vector.tcc:257: instantiated from â€˜void std::vector<_Tp, _Alloc>::_M_insert_aux(__gnu_cxx::__normal_iterator<typename _Alloc::pointer, std::vector<_Tp, _Alloc> >, const _Tp&) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™ /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_vector.h:610: instantiated from â€˜void std::vector<_Tp, _Alloc>::push_back(const _Tp&) [with _Tp = MyObject, _Alloc = std::allocator<MyObject>]â€™ assignment_operator_required.cpp:13: instantiated from here assignment_operator_required.cpp:6: error: â€˜MyObject& MyObject::operator=(const MyObject&)â€™ is private /usr/lib/gcc/i486-linux-gnu/4.0.3/../../../../include/c++/4.0.3/bits/stl_algobase.h:412: error: within this context\n\n(Aside: program is 202 bytes, error is 2837 bytes.)\n\nExcuses\n\nDon’t give me that “the compiler will provide them for you” excuse. What the compiler provides is often wrong, unless you’ve been careful to ensure you don’t own any members by holding pointers to them: i.e. if you’ve fully understood the problem I am setting out and avoided the pitfalls.\n\nConclusion\n\nI assert that C++ is an expert language. Quite apart from the fact that the method names on STL objects use archane phrases like “push_back” rather than “add”, and the error messages you get from popular compilers are huge and almost incomprehensible, my main point is that you have to understand the basics of how the standard library is implemented, before you can use it. This is expert behaviour.\n\nI have illustrated this point by showing what you need to know to use the standard resizeable array type in C++. You need to know a lot.\n\nMore on whether the fact that C++ is an expert language is a bad thing, later.\n\nUpdate: simplified the C example thanks to Edmund’s suggestion.\n\nUpdate 2: corrected the Java example thanks to Anon’s comment."
    }
}