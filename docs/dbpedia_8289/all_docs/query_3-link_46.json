{
    "id": "dbpedia_8289_3",
    "rank": 46,
    "data": {
        "url": "https://www.haskell.org/",
        "read_more_link": "",
        "language": "en",
        "title": "Haskell Language",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.haskell.org/img/haskell-logo.svg",
            "https://www.haskell.org/img/haskell-uwu.png",
            "https://i1.ytimg.com/vi/re96UgMk6GQ/mqdefault.jpg",
            "https://i1.ytimg.com/vi/LnX3B9oaKzw/mqdefault.jpg",
            "https://i1.ytimg.com/vi/4RuLzL_q0zs/mqdefault.jpg",
            "https://i1.ytimg.com/vi/IzQTfh-Iuds/mqdefault.jpg",
            "https://i1.ytimg.com/vi/t1e8gqXLbsU/mqdefault.jpg",
            "https://i1.ytimg.com/vi/WHVMjMIJnB4/mqdefault.jpg",
            "https://www.haskell.org/testimonials/logos/bellroy.png",
            "https://www.haskell.org/testimonials/logos/bitnomial.png",
            "https://www.haskell.org/testimonials/logos/calabrio.png",
            "https://www.haskell.org/testimonials/logos/centralapp.png",
            "https://www.haskell.org/testimonials/logos/e-bot7.png",
            "https://www.haskell.org/testimonials/logos/finn.png",
            "https://www.haskell.org/testimonials/logos/fission.png",
            "https://www.haskell.org/testimonials/logos/foxhoundsystems.png",
            "https://www.haskell.org/testimonials/logos/hasura.png",
            "https://www.haskell.org/testimonials/logos/imagineai.png",
            "https://www.haskell.org/testimonials/logos/iohk.png",
            "https://www.haskell.org/testimonials/logos/mercury.png",
            "https://www.haskell.org/testimonials/logos/noredink.png",
            "https://www.haskell.org/testimonials/logos/scarf.png",
            "https://www.haskell.org/testimonials/logos/Scrive.png",
            "https://www.haskell.org/testimonials/logos/serokell.png",
            "https://www.haskell.org/testimonials/logos/stackbuilders.png",
            "https://www.haskell.org/img/EM-Horizontal-White.svg",
            "https://static.scarf.sh/a.png?x-pxid=7342a8f5-ceb0-403f-9ac8-72a94963320d"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "haskell",
            "functional",
            "pure",
            "programming",
            "lazy"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The Haskell purely functional programming language home page.",
        "meta_lang": "en",
        "meta_favicon": "./img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "All Haskell values have a type:\n\nchar = 'a' :: Char int = 123 :: Int fun = isDigit :: Char -> Bool\n\nYou have to pass the right type of values to functions, or the compiler will reject the program:\n\nType error\n\nisDigit 1\n\nYou can decode bytes into text:\n\nbytes = Crypto.Hash.SHA1.hash \"hello\" :: ByteString text = decodeUtf8 bytes :: Text\n\nBut you cannot decode Text, which is already a vector of Unicode points:\n\nType error\n\ndoubleDecode = decodeUtf8 (decodeUtf8 bytes)\n\nThe following function takes an integer and returns an integer. By the type it cannot do any side-effects whatsoever, it cannot mutate any of its arguments.\n\nsquare :: Int -> Int square x = x * x\n\nThe following string concatenation is okay:\n\n\"Hello: \" ++ \"World!\"\n\nThe following string concatenation is a type error:\n\nType error\n\n\"Name: \" ++ getLine\n\nBecause getLine has type IO String and not String, like \"Name: \" is. So by the type system you cannot mix and match purity with impurity.\n\nThis example has a type signature for every binding:\n\nmain :: IO () main = do line :: String <- getLine print (parseDigit line) where parseDigit :: String -> Maybe Int parseDigit ((c :: Char) : _) = if isDigit c then Just (ord c ord '0') else Nothing\n\nBut you can just write:\n\nmain = do line <- getLine print (parseDigit line) where parseDigit (c : _) = if isDigit c then Just (ord c ord '0') else Nothing\n\nYou can also use inference to avoid wasting time explaining what you want:\n\ndo ss <- decode \"[\\\"Hello!\\\",\\\"World!\\\"]\" is <- decode \"[1,2,3]\" return (zipWith (\\s i -> s ++ \" \" ++ show (i + 5)) ss is) => Just [\"Hello! 6\",\"World! 7\"]\n\nTypes give a parser specification for free, the following input is not accepted:\n\ndo ss <- decode \"[1,2,3]\" is <- decode \"[null,null,null]\" return (zipWith (\\s i -> s ++ \" \" ++ show (i + 5)) ss is) => Nothing\n\nEasily launch threads and communicate with the standard library:\n\nmain = do done <- newEmptyMVar forkIO (do putStrLn \"I'm one thread!\" putMVar done \"Done!\") second <- forkIO (do threadDelay 100000 putStrLn \"I'm another thread!\") killThread second msg <- takeMVar done putStrLn msg\n\nUse an asynchronous API for threads:\n\ndo a1 <- async (getURL url1) a2 <- async (getURL url2) page1 <- wait a1 page2 <- wait a2 ...\n\nAtomic threading with software transactional memory:\n\ntransfer :: Account -> Account -> Int -> IO () transfer from to amount = atomically (do deposit to amount withdraw from amount)\n\nAtomic transactions must be repeatable, so arbitrary IO is disabled in the type system:\n\nType error\n\nmain = atomically (putStrLn \"Hello!\")\n\nDefine control structures easily:\n\nwhen p m = if p then m else return () main = do args <- getArgs when (null args) (putStrLn \"No args specified!\")\n\nIf you notice a repeated expression pattern, like\n\nif c then t else False\n\nyou can give this a name, like\n\nand c t = if c then t else False\n\nand then use it with the same effect as the original expression.\n\nGet code re-use by composing lazy functions. It's quite natural to express the any function by reusing the map and or functions:\n\nany :: (a -> Bool) -> [a] -> Bool any p = or . map p\n\nReuse the recursion patterns in map, filter, foldr, etc."
    }
}