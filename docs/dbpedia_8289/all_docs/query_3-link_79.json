{
    "id": "dbpedia_8289_3",
    "rank": 79,
    "data": {
        "url": "https://www.sjsu.edu/faculty/watkins/prolog.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Introduction to the Programming Language PROLOG: A Language for Logic Programming and Symbolic Computation",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "applet-magic.com\n\nThayer Watkins\n\nSilicon Valley\n\n& Tornado Alley\n\nUSA\n\nAn Introduction to\n\nthe Programming Language\n\nPROLOG:\n\nA Language for Logic Programming\n\nand Symbolic Computation\n\nThere are primarily two computer languages used in artificial intelligence work, LISP and PROLOG. LISP, which is short for List Processing, was created by John McCarthy of Stanford University. It looks klutzy but it is based upon the lamba calculus and works quite well for computation associated with artificial intelligence. PROLOG has an elegant formulation but it does not have the range of application that LISP has. The Japanese when they formulated the Fifth Generation project chose PROLOG over LISP as the programming language. This was perhaps one of the factors that contributed to the failure of the Fifth Generation project. Nevertheless PROLOG is worth knowing for its power in solving questions about relationships.\n\nA PROLOG program consists of:\n\nDeclaration of the facts of the relations involved.\n\nDeclaration of rules concerning relations\n\nFormulation of questions to be answered.\n\nSpecifying Relationships\n\nRelations can be defined in several different ways. In PROLOG they are defined in a functional form with the name of the relation first and the object or objects involved in the relation being enclosed within parentheses. For example,\n\nbillionaire(bill_gates).\n\naunt(jessica,liam).\n\nThe first one means that bill_gates is a billionaire and the second that jessica is the aunt of liam. In the above the conventions of PROLOG have been adhered to; i.e.,\n\n1. all names of relations and objects are in lower case letters\n\n2. the objects are separated by commas\n\n3. the relationships end with a period (a full stop)\n\nThe first relation can be interpreted as a statement that the billionarity of bill_gates is true. Likewise the second relation says that it is true that jessica is the aunt of liam.\n\nA more complex relation is\n\nplay(joe,mike,tennis).\n\nwhich says that joe and mike play tennis together.\n\nA prolog program is run by typing in questions in the form\n\n?- aunt(jessica, liam).\n\nto which the computer would respond: Yes.\n\nIf the PROLOG program responds No to a question it does not mean that the statement involved in the question is false. It only means that it cannot be proved true with the data shown.\n\nA more sophisticated question can be formulated by means of Variables. Variables are unspecified objects wose names start a with capital letter. For example, if the question is\n\n?- aunt(jessica, N).\n\nthe computer would answer\n\nN=liam\n\nIf at this point the questioner presses return, the question is ended. If the questioner types semicolon (;) and then return the computer will search for any more objects for which jessica is an aunt.\n\nConsider this example:\n\nreads(jane, shakespeare).\n\nreads(henry, hemingway).\n\nreads(frank, falkner).\n\nreads(jake, shakespeare).\n\nThe question\n\n?- reads(Y,hemingway).\n\nwould get the response Y=henry. A semicolon and then return would be the response: no. The question\n\n?-reads(Y, shakespeare).\n\nwould get the response Y=jane. A semicolon plus return would get the response Y=jake. Another semicolon plus return would get the response no.\n\nThe question\n\n?- reads(frank, X).\n\nwould get the response X=falkner.\n\nConjoining Questions\n\nIf we want to know if the answers to two questions correspond all that needs to done is to conjoin two questions with a comma. Thus a coma in PROLOG is equivalent to a logical AND construction. For example, the conjoined questions\n\n?- reads(jane, X), reads(jake, X).\n\nbrings the response X=shakespeare.\n\nRules for Composing Relationships:\n\nUsing the PROLOG if Operation\n\nCombinations of relations can be created by special PROLOG operations. Suppose the following relations are defined:\n\nparent(joe,jane).\n\nparent(harry,carl).\n\nparent(meg,jane).\n\nparent(jane,anne).\n\nparent(carl,ralph).\n\nparent(hazel,harry).\n\nThe grandparent relation is defined using the if operation:\n\ngrandparent(X,Z) :- parent(X,Y), parent(Y,Z).\n\nThus a PROLOG program consists of the basic facts in terms of declarations and some rules for defining more complex relations from the basic relations.\n\n(To be continued.)\n\nSymbolic Computation\n\nA good example of symbolic computation and its problems is symbolic differentiation. Below is given a set of basic rules of differentiation in a PROLOG format.\n\nderiv(C,X,0) :- constant(C).\n\nderiv(X,X,1) :- !.\n\nderiv(-F,X,-G) :- deriv(F,X,G).\n\nderiv(F+G,X,H+I) :- deriv(F,X,H), deriv(G,X,I).\n\nderiv(F*G,X,H*G+F*I) :- deriv(F,X,H), deriv(G,X,I).\n\nderiv(F^C,X,c*F^(C-1)*G) :- const(C), deriv(F,X,G).\n\nderiv(F/G,X,H/G - (F/G^2)*I) :- deriv(F,X,H), deriv(G,X,I).\n\nderiv(log(F),X,H*(F^(-1)) :- deriv(F,X,H).\n\nThe rule that deriv(X,X,1) is always true. This is the meaning of \":- !.\" It could be read as \"if anything.\"\n\nThe output of a program run on the basis of the above data is not simplified. For example, the question\n\n?- deriv(X*X,X,A).\n\ngets the response\n\nA = 1*X+X*1\n\nThe derivative program needs to operate in conjunction with a simplification program. Some commands in such a simplification program would be:\n\nsimpl(1*F,F) :- !. simpl(F*1,F) :- !. simpl(F-F,0) :- !. simpl(F/F,1) :- F /=0. simpl(F+F,2*F) :- !. simpl(C*F+F,(C+1)*F) :- !. simpl(C*F+D*F,(C+D)*F) : simpl(F^0,1) :- F /= 0. simpl(0^C,0) :- C/=0.\n\nThere could of course be many more.\n\nWhen confronted with the expression (1*X+X*1) the system would convert it successively to (X+X*1), (X+X), (2*X)."
    }
}