{
    "id": "dbpedia_8289_0",
    "rank": 17,
    "data": {
        "url": "https://wordsandbuttons.online/logic_programming_in_cpp.html",
        "read_more_link": "",
        "language": "en",
        "title": "Logic programming in C++",
        "top_image": "https://cdn-images-1.medium.com/max/800/1*hBkznn2xgarqOZN90wpPeQ.png",
        "meta_img": "",
        "images": [
            "https://cdn-images-1.medium.com/max/800/1*hBkznn2xgarqOZN90wpPeQ.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "programming",
            "tutorials"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This shows that there is an invisible Prolog in every C++ compiler. It's up to you what to do with it but it's there.",
        "meta_lang": "en",
        "meta_favicon": "favicon.svg",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "C++ is a multi-paradigm language. It combines features from procedural, functional, object-oriented, and generic programming in an elegant arsenal of things to shoot your foot with.\n\nIt also kind of employs logic programming. But it doesn't expose its features directly. These features do not enrich your arsenal. They are never mentioned in C++ books and rarely discussed among C++ practitioners. They just work their ways silently making you less prone to metaphorical self-injuries.\n\nWhat is logic programming?\n\nLogic programming is about making computers deduce facts for you. You write down the things you know, write down the rules that hold true for these things, and then you ask questions. Like, âwho killed John F. Kennedyâ?\n\nOf course, computers can only juggle the facts you provide. They don't do surveillance or interrogation. They don't have intuition. They can only do logical operations very fast, that's all we can expect from machines.\n\nThe most popular logic programming language now is Prolog. It was invented in France, and its name stands for âprogrammation en logiqueâ, which is in itself quite logical.\n\nLet's take a peek at Prolog to see what we can learn from it.\n\nIn Prolog, you have terms to store data. Terms are:\n\natomâââany word or even a full sentence. Like: x, alice, or âyear 2016â.\n\nnumberâââfloating-point or integer.\n\ncompound termâââcomplex data type constructed of atoms and numbers. This includes lists and strings.\n\nYou build relations between data with rules and facts. When you want to say that âAlice likes Bobâ, Alice and Bob are the data and likes is the relation. In Prolog, you write it down like this.\n\nlikes(alice, bob).\n\nSuch relations are called facts. There are also rules which are conditional facts. Letâs say Alice likes someone who is kind, and intelligent and writes in C++. The rule for that would be:\n\nlikes(alice, Person) :- kind(Person), intelligent(Person), writes(Person, cpp).\n\nThe Person is a Prolog variable. Syntactically, variables always begin with a capital letter. Semantically, they denote all terms that fit the conditions.\n\nLogic programming is all about deduction. You have a set of terms, known facts, and rules. Then you can deduce something you didnât know before. For instance, if we're going to see if Alice likes Bob according to her own rule from above, we have to introduce Bob with a set of facts and then ask Prolog like this:\n\n?- likes(alice, bob).\n\nProlog programming is declarative. This means that we only write down facts and rules, but not the way they should be interpreted. Prolog finds the way for us.\n\nSo, given the following set of facts, does Alice like Bob or not?\n\nkind(bob). kind(george). kind(steven). intelligent(bob). intelligent(steven). writes(bob, cpp). writes(bob, assembly). writes(george, cpp). writes(steven, prolog). likes(alice, Person) :- kind(Person), intelligent(Person), writes(Person, cpp). ?- likes(alice, bob).\n\nOf course, she does. Bob is kind, intelligent and writes in C++. According to our facts and rules, Alice likes him.\n\nAnalogies in C++\n\nC++ doesn't have logic deduction as a language feature. But it has something conceptually similar. It has type deduction. Now let's translate our Prolog program into C++.\n\nClasses will be our atoms.\n\nPolymorphic functions will be our facts.\n\nAnd a template function will be our rule.\n\nNow if all the types are deducible, the program compiles. The very fact of compilation is the answer to our question.\n\nSo does Alice like Bob in C++?\n\nLogic programming v.s. type deduction\n\nWhile being similar, type deduction differs from logic programming in one crucial way. I guess it would be best to illustrate it with an example.\n\nI stole this idea from Bernardo Pires. If you got interested in Prolog and logic programming in general, please read his article. He uses Prolog to color the map of Germany in four colors. We will try to do the same with C++ and the map of Ukraine.\n\nFirst, we define colors.\n\n// colors class Yellow{}; class Blue{}; class Red{}; class Green{}; void color(Yellow); void color(Blue); void color(Red); void color(Green);\n\nWe need to generalize them to use in our rules, and that's one possible way to do that.\n\nUnlike C++, Prolog has an operator to declare data inequality. So when Bernardo wants to declare a rule stating that all the neighboring regions should have different colors, he writes this:\n\nneighbor(StateAColor, StateBColor) :- color(StateAColor), color(StateBColor), StateAColor \\= StateBColor.\n\nWe can techincally do the same in modern C++, but it gets needlessly tricky, so we'll define inequality as a plain set of facts instead.\n\nNext, we want every two adjacent regions to have different colors. Here's a rule for that.\n\n// neighborhood rule template <typename Region1Color, typename Region2Color> void neighbor(Region1Color, Region2Color) { color(Region1Color()); color(Region2Color()); different(Region1Color(), Region2Color()); }\n\nNow we program the map of Ukraine as pairs of adjacent regions.\n\nAnd finally, we write the function that starts type deduction for every region.\n\nGiven that there are no typos and we wrote down all our rules and facts correctly, will this program compile or not?\n\nConclusion\n\nWhen you write in C++ you actually write in two languages at once. First is C++, and the second one is the invisible Prolog.\n\nIf written properly, the second program is helpful. If you build your type relations right, every compilation will reassure you that your expectations about the entity relations are also correct. Type deduction will work just as the logic deduction. Pragmatically, this means fewer bugs and fewer surprises in general.\n\nHowever, if being neglected, it turns your code into an untangleable mess of incomprehencibles really-really fast. Every new rule multiplies the complexity, so the complexity tends to grow as a geometric progression. The other problem with the compile-time programming is that there are no compile-time debuggers, and error messages for templates are notoriously bad. Not only it gets ugly fast, but it is very hard to make it right again.\n\nAnd that's why acknowledging the invisible language is probably even more important than mastering the visible one.\n\nLinks\n\nTry Logic Programming. A Gentle Introduction to Prolog\n\nWill Computers Redefine the Roots of Math?\n\nThere's a Mathematician In Your Compiler"
    }
}