{
    "id": "dbpedia_6524_3",
    "rank": 20,
    "data": {
        "url": "https://github.com/ctford/leipzig",
        "read_more_link": "",
        "language": "en",
        "title": "ctford/leipzig: A music composition library for Clojure and Clojurescript.",
        "top_image": "https://opengraph.githubassets.com/29eb2f6db00ce05a155a3ef161c65375faa02e4a0e238a71746db79bfda9441a/ctford/leipzig",
        "meta_img": "https://opengraph.githubassets.com/29eb2f6db00ce05a155a3ef161c65375faa02e4a0e238a71746db79bfda9441a/ctford/leipzig",
        "images": [
            "https://camo.githubusercontent.com/55247932a06695127f0afcdd18a4cfaa3663697d1c621639dea30cd63b04fa39/68747470733a2f2f7472617669732d63692e6f72672f6374666f72642f6c6569707a69672e706e67"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "A music composition library for Clojure and Clojurescript. - ctford/leipzig",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/ctford/leipzig",
        "text": "A composition library for Clojure and Clojurescript by @ctford.\n\nInclude it as a dependency in your project.clj, along with Overtone:\n\nThere is a Leiningen template that creates a simple Leipzig project, ready to run.\n\nLeipzig models music as a sequence of notes, each of which is a map. They are ordered by :time:\n\nWhen using Leipzig, it's helpful to keep this model of notes in mind. Leipzig's functions are convenient ways of manipulating this basic structure, but there's nothing to stop you from building your own.\n\nYou can create a melody with the phrase function. Here's a simple melody:\n\nThe first argument to phrase is a sequence of durations. The second is a sequence of pitches. phrase builds a sequence of notes which we can transform with sequence functions, either from Leipzig or ones from Clojure's core libraries.\n\nTo play a melody, first define an arrangement. play-note is a multimethod that dispatches on the :part key of each note, so you can easily define an instrument responsible for playing notes of each part. Then, put the sequence of notes into a particular key and tempo and pass them along to play:\n\nThere's nothing magic about where. It just applies a function to a particular key of each note, like update-in for sequences.\n\nLet's define two other parts to go with the original melody:\n\nYou can then put multiple series of notes together:\n\nLeipzig features a number of namespaces, each containing functions pertaining to a particular area of composition.\n\nThis namespace contains the core functions for creating and manipulating melodies. In particular:\n\nphrase creates a melody from a sequence of durations and a sequence of pitches.\n\nwhere applies a function to a specified key of each note in a melody.\n\nFor example:\n\nHere are functions to send your melodies to Overtone:\n\nplay-note is a multimethod that dispatches on the :part a note has.\n\nplay plays the notes.\n\njam loops the notes, reloading the var each time.\n\nstop stops all running melodies.\n\nFor example:\n\nThis namespace contains functions for placing melodies within musical scales. In particular:\n\nmajor and minor are functions that place a pitch within a relative scale.\n\nA, B, C etc are functions that take a relative pitch, and place it in a specific absolute key.\n\nFor example:\n\nThe phrase function accepts chords as well as simple pitches. This namespace provides simple ways to manipulate them:\n\ntriad is the tonic, which can be manipulated to form other chords.\n\nroot scales the chord up to the specified root.\n\ninversion inverts the chord, leaving the root where it is.\n\nFor example, a fourth chord, then the second inversion of the fifth:\n\nThis namespace translates midi pitches into frequencies. Overtone's midi->hz will usually do just fine, but if you want to experiment with more exotic temperaments, there are plenty here.\n\nIn particular:\n\nequal is equivalent to midi->hz and translates frequencies into pitches like a piano is tuned.\n\njust uses pure ratios, and more closely models how singers interpret intervals into frequencies.\n\nFor example:\n\nIn addition to simple pitches, phrase can take maps representing chords or nils:\n\nThe maps generate a note for each value in the map - the keys are used only to enable chord-transforming functions such as root and inversion.\n\nThe nils generate notes without pitches, representing rests. This is convenient, because it allows melodies to have a duration extending beyond their last audible note. However, the play-note implementations and where invocations must be prepared to handle this, e.g. by using when and where's variation wherever:\n\nLeipzig supports Clojurescript for all of its namespaces save leipzig.live. The live namespace depends directly on Overtone, so it cannot be used in the browser. However the rest of Leipzig can be used so long as an alternative synthesis engine is present like the Web Audio API. Klangmeister is a good example of this.\n\nSee Row, row, row your boat or whelmed for examples.\n\nIn Leipzig from scratch, I demonstrate how to create a piece from lein new onwards.\n\nLeipzig came out of a talk I gave called Functional Composition, where I explain basic music theory using Overtone and Clojure.\n\nAPI documentation, generated by Codox.\n\nLeipzig is designed to play nicely with Clojure's standard sequence functions. Therefore, Leipzig's functions for transforming notes all take the sequence as a final argument so that they can be threaded with the ->> macro:\n\nThese sequence functions all exhibit \"closure\" i.e. their result is the same shape as their input. That allows them to be used and combined very flexibly. where for example, can raise the pitch, set the part or put the notes into a particular tempo:\n\nLeipzig aims to be a library rather than a framework or environment. It uses simple Clojure datastructures and strives to be as open as possible. A new timing scheme, tuning or tempo can be mixed with Leipzig's other functions just as easily as the ones that come with the library.\n\nTo run the unit tests without having to start Overtone's Supercollider server:"
    }
}