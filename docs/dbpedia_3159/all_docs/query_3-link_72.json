{
    "id": "dbpedia_3159_3",
    "rank": 72,
    "data": {
        "url": "https://cloud.google.com/storage/docs/objects",
        "read_more_link": "",
        "language": "en",
        "title": "About Cloud Storage objects",
        "top_image": "https://cloud.google.com/_static/cloud/images/social-icon-google-cloud-1200-630.png",
        "meta_img": "https://cloud.google.com/_static/cloud/images/social-icon-google-cloud-1200-630.png",
        "images": [
            "https://www.gstatic.com/devrel-devsite/prod/vd185cef2092d5507cf5d5de6d49d6afd8eb38fe69b728d88979eb4a70550ff03/cloud/images/cloud-logo.svg",
            "https://www.gstatic.com/devrel-devsite/prod/vd185cef2092d5507cf5d5de6d49d6afd8eb38fe69b728d88979eb4a70550ff03/cloud/images/cloud-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.gstatic.com/devrel-devsite/prod/vd185cef2092d5507cf5d5de6d49d6afd8eb38fe69b728d88979eb4a70550ff03/cloud/images/favicons/onecloud/favicon.ico",
        "meta_site_name": "Google Cloud",
        "canonical_link": "https://cloud.google.com/storage/docs/objects",
        "text": "This page describes objects, a resource in Cloud Storage. For a general overview of how Cloud Storage works, see the Cloud Storage product overview.\n\nObjects\n\nObjects are the individual pieces of data that you store in Cloud Storage. There is no limit on the number of objects that you can create in a bucket.\n\nObjects have two components: object data and object metadata. Object data is typically a file that you want to store in Cloud Storage and is completely opaque to Cloud Storage. Object metadata is a collection of name-value pairs that describe various object qualities.\n\nTwo important pieces of object metadata common to all objects are the object's name and its generation number. When you add an object to a Cloud Storage bucket, you specify the object name and Cloud Storage assigns the generation number. Together, the name and generation uniquely identify the object within that bucket.\n\nYou can use access control lists (ACLs) to control access to individual objects. You can also use Identity and Access Management (IAM) to control access to all the objects within a bucket or a managed folder.\n\nNaming considerations\n\nThe name you give to an object must meet the following requirements:\n\nObject names can contain any sequence of valid Unicode characters, of length 1-1024 bytes when UTF-8 encoded.\n\nObject names cannot contain Carriage Return or Line Feed characters.\n\nObject names cannot start with .well-known/acme-challenge/.\n\nObjects cannot be named . or ...\n\nIt is strongly recommended that you avoid the following in your object names:\n\nControl characters that are illegal in XML 1.0 (#x7F–#x84 and #x86–#x9F): these characters cause XML listing issues when you try to list your objects.\n\nThe # character: Google Cloud CLI commands interpret object names ending with #<numeric string> as version identifiers, so including # in object names can make it difficult or impossible to perform operations on such versioned objects using the gcloud CLI.\n\nThe [, ], *, or ? characters: Google Cloud CLI commands interpret these characters as wildcards, so including them in object names can make it difficult or impossible to perform wildcard operations. Additionally, * and ? are not valid characters for file names in Windows.\n\nThe :, \", <, >, or | characters: These are not valid characters for file names in Windows, so attempts to download an object that uses such characters in its name to a Windows file fail unless the download method includes renaming the resulting Windows file. The / character, while also not a valid character for file names in Windows, is typically OK to use in object names for mimicking a directory structure; tools such as the Google Cloud CLI automatically convert the character to \\ when downloading to a Windows environment.\n\nSensitive or personally identifiable information (PII): object names are more broadly visible than object data. For example, object names appear in URLs for the object and when listing objects in a bucket.\n\nExisting objects cannot be directly renamed, but you can indirectly rename an object by copying and deleting the original object.\n\nObject namespace\n\nObject names reside in a flat namespace within a bucket. This means that:\n\nDifferent buckets can have objects with the same name.\n\nObjects don't reside within subdirectories in a bucket.\n\nFor convenience, there are several ways that objects are treated as if they were stored in a folder hierarchy:\n\nManaged folders are a Cloud Storage resource which provides expanded access to groups of objects with a shared name prefix.\n\nTools such as the Google Cloud console and the Google Cloud CLI use the slash (/) character as a delimiter in order to simulate folders in a bucket.\n\nFor example, if you create an object named folder1/file.txt in the bucket your-bucket, the path to the object is your-bucket/folder1/file.txt, and Cloud Storage has no folder named folder1 stored within it. From the perspective of Cloud Storage, the string folder1/ is part of the object's name.\n\nHowever, because the object has a / in its name, some tools implement the appearance of folders. For example, when using the Google Cloud console, you would navigate to the object folder1/file1.txt as if it were an object named file1.txt in a folder named folder1. Similarly, you could create a managed folder named folder1, and then file1.txt would be subject to the access policy set by this managed folder.\n\nNote that because objects reside in a flat namespace, deeply nested, directory-like structures don't have the performance that a native filesystem has when listing deeply nested sub-directories.\n\nSee Request rate best practices for recommendations on how to optimize performance by avoiding sequential names during large-scale uploads. Objects uploaded with sequential names are likely to reach the same backend server and constrain performance.\n\nSimulated folders\n\nIn order to help you organize objects in your Cloud Storage buckets, some tools simulate folders, and both the JSON and XML APIs have capabilities that let you design your own naming scheme to simulate folders. Click the following tabs to see how different tools handle simulated folders.\n\nRemoving simulated folders\n\nBecause simulated folders don't actually exist, you can typically remove simulated folders by renaming objects so that the simulated folder is no longer a part of the object's name. For example, if you have an object named folder1/file, you can remove the simulated folder folder1/ by renaming the object to just file.\n\nHowever, if you have used a tool that creates zero-byte objects as folder placeholders, such as the Google Cloud console, you must delete the zero-byte object to remove the folder.\n\nObject immutability\n\nObjects are immutable, which means that an uploaded object cannot change throughout its storage lifetime. An object's storage lifetime is the time between successful object creation, such as uploading, and successful object deletion. In practice, this means that you cannot make incremental changes to objects, such as append operations or truncate operations. However, it is possible to replace objects that are stored in Cloud Storage, and doing so happens atomically: until the new upload completes, the old version of the object is served to readers, and after the upload completes, the new version of the object is served to readers. A single replacement operation marks the end of one immutable object's lifetime and the beginning of a new immutable object's lifetime.\n\nThe generation number for an object changes each time you replace the object's data. Thus, the generation number uniquely identifies an immutable object.\n\nNote that there is a once-per-second limit for rapidly replacing the same object. Replacing the same object more frequently might result in 429 Too Many Requests errors. You should design your application to upload data for a particular object no more than once per second and handle occasional 429 Too Many Requests errors using an exponential backoff retry strategy.\n\nWhat's next"
    }
}