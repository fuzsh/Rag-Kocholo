{
    "id": "dbpedia_3822_0",
    "rank": 25,
    "data": {
        "url": "https://developer.android.com/topic/performance/reduce-apk-size",
        "read_more_link": "",
        "language": "en",
        "title": "Reduce your app size",
        "top_image": "https://developer.android.com/static/images/social/android-developers.png",
        "meta_img": "https://developer.android.com/static/images/social/android-developers.png",
        "images": [
            "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/android/images/lockup.svg",
            "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/android/images/lockup.svg",
            "https://developer.android.com/_static/android/images/logo-x.svg",
            "https://www.gstatic.com/images/icons/material/product/2x/youtube_48dp.png",
            "https://developer.android.com/_static/android/images/logo-linkedin.svg",
            "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/android/images/lockup-google-for-developers.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.gstatic.com/devrel-devsite/prod/v4513918f2560a1fecca3cf64c2df2e8b263c90b977664567b98ccb062542a623/android/images/favicon.svg",
        "meta_site_name": "Android Developers",
        "canonical_link": "https://developer.android.com/topic/performance/reduce-apk-size",
        "text": "Users often avoid downloading apps that seem too large, particularly in emerging markets where devices connect to spotty 2G and 3G networks or work on plans with data limits. This page describes how to reduce your app's download size, which lets more users download your app.\n\nUpload your app with Android App Bundles\n\nUpload your app as an Android App Bundle to immediately save app size when you publish to Google Play. Android App Bundle is an upload format that includes all your app's compiled code and resources but defers APK generation and signing to Google Play.\n\nGoogle Play's app serving model then uses your app bundle to generate and serve optimized APKs for each user's device configuration so that they download only the code and resources they need to run your app. You don't have to build, sign, and manage multiple APKs to support different devices, and users get smaller, more optimized downloads.\n\nGoogle Play enforces a compressed download size restriction of 200 MB for apps published with app bundles. Larger sizes are possible using Play Feature Delivery and Play Asset Delivery but increasing your app's size can negatively impact install success and increase uninstalls, so we recommend you apply the guidelines described in this page to reduce your app's download size as much as possible.\n\nUnderstand the APK structure\n\nBefore reducing the size of your app, it's helpful to understand the structure of an app's APK. An APK file consists of a ZIP archive that contains all the files that comprise your app. These files include Java class files, resource files, and a file containing compiled resources.\n\nAn APK contains the following directories:\n\nMETA-INF/: contains the CERT.SF and CERT.RSA signature files, as well as the MANIFEST.MF manifest file.\n\nassets/: contains the app's assets, which the app can retrieve using an AssetManager object.\n\nres/: contains resources that aren't compiled into resources.arsc.\n\nlib/: contains the compiled code that is specific to the software layer of a processor. This directory contains a subdirectory for each platform type, such as armeabi, armeabi-v7a, arm64-v8a, x86, x86_64, and mips.\n\nAn APK also contains the following files. Only AndroidManifest.xml is mandatory:\n\nresources.arsc: contains compiled resources. This file contains the XML content from all configurations of the res/values/ folder. The packaging tool extracts this XML content, compiles it to binary form, and archives the content. This content includes language strings and styles, as well as paths to content that isn't included directly in the resources.arsc file, such as layout files and images.\n\nclasses.dex: contains the classes compiled in the DEX file format understood by the Dalvik or ART virtual machine.\n\nAndroidManifest.xml: contains the core Android manifest file. This file lists the name, version, access rights, and referenced library files of the app. The file uses Android's binary XML format.\n\nReduce resource count and size\n\nThe size of your APK has an impact on how fast your app loads, how much memory it uses, and how much power it consumes. You can make your APK smaller by reducing the number and size of the resources it contains. In particular, you can remove resources that your app no longer uses, and you can use scalable Drawable objects in place of image files. This section discusses these methods and other ways you can reduce the resources in your app to decrease the overall size of your APK.\n\nRemove unused resources\n\nThe lint tool—a static code analyzer included in Android Studio—detects resources in your res/ folder that your code doesn't reference. When the lint tool discovers a potentially unused resource in your project, it prints a message like the following example:\n\nres/layout/preferences.xml: Warning: The resource R.layout.preferences appears to be unused [UnusedResources]\n\nLibraries that you add to your code might include unused resources. Gradle can automatically remove resources on your behalf if you enable shrinkResources in your app's build.gradle.kts file.\n\nTo use shrinkResources, enable code shrinking. During the build process, R8 first removes unused code. Then, the Android Gradle plugin removes the unused resources.\n\nFor more information about code and resource shrinking, and other ways Android Studio reduces APK size, see Shrink, obfuscate, and optimize your app.\n\nIn Android Gradle Plugin 7.0 and later, you can declare the configurations that your app supports. Gradle passes this information to the build system using the resourceConfigurations flavor and the defaultConfig option. The build system then prevents resources from other unsupported configurations from appearing in the APK, reducing the APK's size. For more information about this feature, see Remove unused alternative resources.\n\nMinimize resource use from libraries\n\nWhen you develop an Android app, you usually use external libraries to improve your app's usability and versatility. For example, you might reference AndroidX to improve the user experience on earlier devices, or you can use Google Play Services to retrieve automatic translations for text within your app.\n\nIf a library is designed for a server or desktop, it can include many objects and methods that your app doesn't need. To include only the parts of the library that your app needs, you can edit the library's files if the license lets you modify the library. You can also use an alternative, mobile-friendly library to add specific functionality to your app.\n\nNative animated image decoding\n\nIn Android 12 (API level 31), the NDK ImageDecoder API is expanded to decode all frames and timing data from images that use the animated GIF and animated WebP file formats.\n\nUse ImageDecoder instead of third-party libraries to further decrease APK size and benefit from future updates related to security and performance.\n\nFor more details about the ImageDecoder API, refer to the API reference and the sample on GitHub.\n\nSupport only specific densities\n\nAndroid supports different screen densities, such as the following:\n\nldpi\n\nmdpi\n\ntvdpi\n\nhdpi\n\nxhdpi\n\nxxhdpi\n\nxxxhdpi\n\nAlthough Android supports the preceding densities, you don't need to export your rasterized assets to each density.\n\nIf you know that only a small percentage of your users have devices with specific densities, consider whether you need to bundle those densities into your app. If you don't include resources for a specific screen density, Android automatically scales existing resources originally designed for other screen densities.\n\nIf your app needs only scaled images, you can save even more space by having a single variant of an image in drawable-nodpi/. We recommend you include at least an xxhdpi image variant in your app.\n\nFor more information about screen densities, see Screen sizes and densities.\n\nUse drawable objects\n\nSome images don't require a static image resource. The framework can dynamically draw the image at runtime instead. Drawable objects—or <shape> in XML—can take up a tiny amount of space in your APK. In addition, XML Drawable objects produce monochromatic images compliant with Material Design guidelines.\n\nReuse resources\n\nYou can include a separate resource for variations of an image, such as tinted, shaded, or rotated versions of the same image. However, we recommend that you reuse the same set of resources and customizing them as needed at runtime.\n\nAndroid provides several utilities to change the color of an asset, either using the android:tint and tintMode attributes.\n\nYou can also omit resources that are only a rotated equivalent of another resource. The following code snippet provides an example of turning a \"thumb up\" into a \"thumb down\" by pivoting at the middle of the image and rotating it 180 degrees:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <rotate xmlns:android=\"http://schemas.android.com/apk/res/android\" android:drawable=\"@drawable/ic_thumb_up\" android:pivotX=\"50%\" android:pivotY=\"50%\" android:fromDegrees=\"180\" />\n\nRender from code\n\nYou can also reduce your APK size by procedurally rendering your images. Procedural rendering frees up space because you no longer store an image file in your APK.\n\nCrunch PNG files\n\nThe aapt tool can optimize the image resources placed in res/drawable/ with lossless compression during the build process. For example, the aapt tool can convert a true-color PNG that doesn't require more than 256 colors to an 8-bit PNG with a color palette. Doing so results in an image of equal quality but a smaller memory footprint.\n\nThe aapt has the following limitations:\n\nThe aapt tool doesn't shrink PNG files contained in the asset/ folder.\n\nImage files need to use 256 or fewer colors for the aapt tool to optimize them.\n\nThe aapt tool might inflate PNG files that are already compressed. To prevent this, you can use the isCrunchPngs flag to disable this process for PNG files:\n\nKotlin\n\nbuildTypes.all{isCrunchPngs=false}\n\nGroovy\n\nbuildTypes.all{isCrunchPngs=false}\n\nCompress PNG and JPEG files\n\nYou can reduce PNG file sizes without losing image quality using tools like pngcrush, pngquant, or zopflipng. All of these tools can reduce PNG file size while preserving the perceptive image quality.\n\nThe pngcrush tool is particularly effective. This tool iterates over PNG filters and zlib (Deflate) parameters, using each combination of filters and parameters to compress the image. It then chooses the configuration that yields the smallest compressed output.\n\nTo compress JPEG files, you can use tools like packJPG and guetzli.\n\nUse WebP file format\n\nInstead of using PNG or JPEG files, you can also use the WebP file format for your images. The WebP format provides lossy compression and transparency, like JPG and PNG, and it can provide better compression than either JPEG or PNG.\n\nYou can convert existing BMP, JPG, PNG or static GIF images to WebP format using Android Studio. For more information, see Create WebP images.\n\nUse vector graphics\n\nYou can use vector graphics to create resolution-independent icons and other scalable media. You can use these graphics to greatly reduce your APK footprint. Vector images are represented in Android as VectorDrawable objects. With a VectorDrawable object, a 100-byte file can generate a sharp image the size of the screen.\n\nHowever, it takes significantly more time for the system to render each VectorDrawable object, and larger images take even longer to appear on the screen. Therefore, consider using these vector graphics only when displaying small images.\n\nFor more information about working with VectorDrawable objects, see Drawables.\n\nUse vector graphics for animated images\n\nDon't use AnimationDrawable to create frame-by-frame animations, because doing so requires that you include a separate bitmap file for each frame of the animation, which drastically increases the size of your APK.\n\nInstead, use AnimatedVectorDrawableCompat to create animated vector drawables.\n\nReduce native and Java code\n\nYou can use the following methods to reduce the size of the Java and native codebase in your app.\n\nRemove unnecessary generated code\n\nMake sure to understand the footprint of any code which is automatically generated. For example, many protocol buffer tools generate an excessive number of methods and classes, which can double or triple the size of your app.\n\nAvoid enumerations\n\nA single enum can add about 1.0 to 1.4 KB to your app's classes.dex file. These additions can quickly accumulate for complex systems or shared libraries. If possible, consider using the @IntDef annotation and code shrinking to strip enumerations out and convert them to integers. This type conversion preserves all of the type safety benefits of enums.\n\nReduce the size of native binaries\n\nIf your app uses native code and the Android NDK, you can also reduce the size of the release version of your app by optimizing your code. Two useful techniques are removing debug symbols and not extracting native libraries.\n\nRemove debug symbols\n\nUsing debug symbols makes sense if your app is in development and still requires debugging. Use the arm-eabi-strip tool provided in the Android NDK to remove unnecessary debug symbols from native libraries. Afterwards, you can compile your release build.\n\nAvoid extracting native libraries\n\nWhen building the release version of your app, package uncompressed .so files in the APK by setting useLegacyPackaging to false in your app's build.gradle.kts file. Disabling this flag prevents PackageManager from copying .so files from the APK to the filesystem during installation. This method makes updates of your app smaller.\n\nMaintain multiple lean APKs\n\nYour APK might contain content that users download but never use, like additional language or per-screen-density resources. To help ensure a minimal download for your users, upload your app to Google Play using Android App Bundles. Uploading app bundles lets Google Play generate and serve optimized APKs for each user's device configuration so they download only the code and resources they need to run your app. You don't have to build, sign, and manage multiple APKs to support different devices, and users get smaller, more optimized downloads.\n\nIf you're not publishing your app to Google Play, you can segment your app into several APKs, differentiated by factors such as screen size or GPU texture support.\n\nWhen a user downloads your app, their device receives the correct APK based on the device's features and settings. This way, devices don't receive assets for features that the devices don't have. For example, if a user has a hdpi device, they don't need xxxhdpi resources that you might include for devices with higher density displays."
    }
}