{
    "id": "dbpedia_8285_3",
    "rank": 41,
    "data": {
        "url": "https://fastapi.tiangolo.com/tutorial/sql-databases/",
        "read_more_link": "",
        "language": "en",
        "title": "SQL (Relational) Databases ¶",
        "top_image": "https://fastapi.tiangolo.com/assets/images/social/tutorial/sql-databases.png",
        "meta_img": "https://fastapi.tiangolo.com/assets/images/social/tutorial/sql-databases.png",
        "images": [
            "https://fastapi.tiangolo.com/img/sponsors/cryptapi-banner.svg",
            "https://fastapi.tiangolo.com/img/sponsors/platform-sh-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/porter-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/bump-sh-banner.svg",
            "https://fastapi.tiangolo.com/img/sponsors/scalar-banner.svg",
            "https://fastapi.tiangolo.com/img/sponsors/propelauth-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/coherence-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/mongodb-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/kong-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/zuplo-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/fine-banner.png",
            "https://fastapi.tiangolo.com/img/sponsors/liblab-banner.png",
            "https://fastapi.tiangolo.com/img/icon-white.svg",
            "https://fastapi.tiangolo.com/img/icon-white.svg",
            "https://fastapi.tiangolo.com/img/tutorial/sql-databases/image01.png",
            "https://fastapi.tiangolo.com/img/tutorial/sql-databases/image02.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "FastAPI framework, high performance, easy to learn, fast to code, ready for production",
        "meta_lang": "en",
        "meta_favicon": "../../img/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://fastapi.tiangolo.com/tutorial/sql-databases/",
        "text": "SQL (Relational) Databases¶\n\nFastAPI doesn't require you to use a SQL (relational) database.\n\nBut you can use any relational database that you want.\n\nHere we'll see an example using SQLAlchemy.\n\nYou can easily adapt it to any database supported by SQLAlchemy, like:\n\nPostgreSQL\n\nMySQL\n\nSQLite\n\nOracle\n\nMicrosoft SQL Server, etc.\n\nIn this example, we'll use SQLite, because it uses a single file and Python has integrated support. So, you can copy this example and run it as is.\n\nLater, for your production application, you might want to use a database server like PostgreSQL.\n\nORMs¶\n\nFastAPI works with any database and any style of library to talk to the database.\n\nA common pattern is to use an \"ORM\": an \"object-relational mapping\" library.\n\nAn ORM has tools to convert (\"map\") between objects in code and database tables (\"relations\").\n\nWith an ORM, you normally create a class that represents a table in a SQL database, each attribute of the class represents a column, with a name and a type.\n\nFor example a class Pet could represent a SQL table pets.\n\nAnd each instance object of that class represents a row in the database.\n\nFor example an object orion_cat (an instance of Pet) could have an attribute orion_cat.type, for the column type. And the value of that attribute could be, e.g. \"cat\".\n\nThese ORMs also have tools to make the connections or relations between tables or entities.\n\nThis way, you could also have an attribute orion_cat.owner and the owner would contain the data for this pet's owner, taken from the table owners.\n\nSo, orion_cat.owner.name could be the name (from the name column in the owners table) of this pet's owner.\n\nIt could have a value like \"Arquilian\".\n\nAnd the ORM will do all the work to get the information from the corresponding table owners when you try to access it from your pet object.\n\nCommon ORMs are for example: Django-ORM (part of the Django framework), SQLAlchemy ORM (part of SQLAlchemy, independent of framework) and Peewee (independent of framework), among others.\n\nHere we will see how to work with SQLAlchemy ORM.\n\nIn a similar way you could use any other ORM.\n\nTip\n\nThere's an equivalent article using Peewee here in the docs.\n\nFile structure¶\n\nFor these examples, let's say you have a directory named my_super_project that contains a sub-directory called sql_app with a structure like this:\n\nThe file __init__.py is just an empty file, but it tells Python that sql_app with all its modules (Python files) is a package.\n\nNow let's see what each file/module does.\n\nInstall SQLAlchemy¶\n\nFirst you need to install SQLAlchemy:\n\nCreate the SQLAlchemy parts¶\n\nLet's refer to the file sql_app/database.py.\n\nImport the SQLAlchemy parts¶\n\nCreate a database URL for SQLAlchemy¶\n\nIn this example, we are \"connecting\" to a SQLite database (opening a file with the SQLite database).\n\nThe file will be located at the same directory in the file sql_app.db.\n\nThat's why the last part is ./sql_app.db.\n\nIf you were using a PostgreSQL database instead, you would just have to uncomment the line:\n\n...and adapt it with your database data and credentials (equivalently for MySQL, MariaDB or any other).\n\nTip\n\nThis is the main line that you would have to modify if you wanted to use a different database.\n\nCreate the SQLAlchemy engine¶\n\nThe first step is to create a SQLAlchemy \"engine\".\n\nWe will later use this engine in other places.\n\nNote¶\n\nThe argument:\n\n...is needed only for SQLite. It's not needed for other databases.\n\nCreate a SessionLocal class¶\n\nEach instance of the SessionLocal class will be a database session. The class itself is not a database session yet.\n\nBut once we create an instance of the SessionLocal class, this instance will be the actual database session.\n\nWe name it SessionLocal to distinguish it from the Session we are importing from SQLAlchemy.\n\nWe will use Session (the one imported from SQLAlchemy) later.\n\nTo create the SessionLocal class, use the function sessionmaker:\n\nCreate a Base class¶\n\nNow we will use the function declarative_base() that returns a class.\n\nLater we will inherit from this class to create each of the database models or classes (the ORM models):\n\nCreate the database models¶\n\nLet's now see the file sql_app/models.py.\n\nCreate SQLAlchemy models from the Base class¶\n\nWe will use this Base class we created before to create the SQLAlchemy models.\n\nImport Base from database (the file database.py from above).\n\nCreate classes that inherit from it.\n\nThese classes are the SQLAlchemy models.\n\nThe __tablename__ attribute tells SQLAlchemy the name of the table to use in the database for each of these models.\n\nCreate model attributes/columns¶\n\nNow create all the model (class) attributes.\n\nEach of these attributes represents a column in its corresponding database table.\n\nWe use Column from SQLAlchemy as the default value.\n\nAnd we pass a SQLAlchemy class \"type\", as Integer, String, and Boolean, that defines the type in the database, as an argument.\n\nCreate the relationships¶\n\nNow create the relationships.\n\nFor this, we use relationship provided by SQLAlchemy ORM.\n\nThis will become, more or less, a \"magic\" attribute that will contain the values from other tables related to this one.\n\nWhen accessing the attribute items in a User, as in my_user.items, it will have a list of Item SQLAlchemy models (from the items table) that have a foreign key pointing to this record in the users table.\n\nWhen you access my_user.items, SQLAlchemy will actually go and fetch the items from the database in the items table and populate them here.\n\nAnd when accessing the attribute owner in an Item, it will contain a User SQLAlchemy model from the users table. It will use the owner_id attribute/column with its foreign key to know which record to get from the users table.\n\nCreate the Pydantic models¶\n\nNow let's check the file sql_app/schemas.py.\n\nCreate initial Pydantic models / schemas¶\n\nCreate an ItemBase and UserBase Pydantic models (or let's say \"schemas\") to have common attributes while creating or reading data.\n\nAnd create an ItemCreate and UserCreate that inherit from them (so they will have the same attributes), plus any additional data (attributes) needed for creation.\n\nSo, the user will also have a password when creating it.\n\nBut for security, the password won't be in other Pydantic models, for example, it won't be sent from the API when reading a user.\n\nSQLAlchemy style and Pydantic style¶\n\nNotice that SQLAlchemy models define attributes using =, and pass the type as a parameter to Column, like in:\n\nwhile Pydantic models declare the types using :, the new type annotation syntax/type hints:\n\nKeep these in mind, so you don't get confused when using = and : with them.\n\nCreate Pydantic models / schemas for reading / returning¶\n\nNow create Pydantic models (schemas) that will be used when reading data, when returning it from the API.\n\nFor example, before creating an item, we don't know what will be the ID assigned to it, but when reading it (when returning it from the API) we will already know its ID.\n\nThe same way, when reading a user, we can now declare that items will contain the items that belong to this user.\n\nNot only the IDs of those items, but all the data that we defined in the Pydantic model for reading items: Item.\n\nUse Pydantic's orm_mode¶\n\nNow, in the Pydantic models for reading, Item and User, add an internal Config class.\n\nThis Config class is used to provide configurations to Pydantic.\n\nIn the Config class, set the attribute orm_mode = True.\n\nPydantic's orm_mode will tell the Pydantic model to read the data even if it is not a dict, but an ORM model (or any other arbitrary object with attributes).\n\nThis way, instead of only trying to get the id value from a dict, as in:\n\nit will also try to get it from an attribute, as in:\n\nAnd with this, the Pydantic model is compatible with ORMs, and you can just declare it in the response_model argument in your path operations.\n\nYou will be able to return a database model and it will read the data from it.\n\nTechnical Details about ORM mode¶\n\nSQLAlchemy and many others are by default \"lazy loading\".\n\nThat means, for example, that they don't fetch the data for relationships from the database unless you try to access the attribute that would contain that data.\n\nFor example, accessing the attribute items:\n\nwould make SQLAlchemy go to the items table and get the items for this user, but not before.\n\nWithout orm_mode, if you returned a SQLAlchemy model from your path operation, it wouldn't include the relationship data.\n\nEven if you declared those relationships in your Pydantic models.\n\nBut with ORM mode, as Pydantic itself will try to access the data it needs from attributes (instead of assuming a dict), you can declare the specific data you want to return and it will be able to go and get it, even from ORMs.\n\nCRUD utils¶\n\nNow let's see the file sql_app/crud.py.\n\nIn this file we will have reusable functions to interact with the data in the database.\n\nCRUD comes from: **C**reate, **R**ead, **U**pdate, and **D**elete.\n\n...although in this example we are only creating and reading.\n\nRead data¶\n\nImport Session from sqlalchemy.orm, this will allow you to declare the type of the db parameters and have better type checks and completion in your functions.\n\nImport models (the SQLAlchemy models) and schemas (the Pydantic models / schemas).\n\nCreate utility functions to:\n\nRead a single user by ID and by email.\n\nRead multiple users.\n\nRead multiple items.\n\nCreate data¶\n\nNow create utility functions to create data.\n\nThe steps are:\n\nCreate a SQLAlchemy model instance with your data.\n\nadd that instance object to your database session.\n\ncommit the changes to the database (so that they are saved).\n\nrefresh your instance (so that it contains any new data from the database, like the generated ID).\n\nWarning\n\nThis example is not secure, the password is not hashed.\n\nIn a real life application you would need to hash the password and never save them in plaintext.\n\nFor more details, go back to the Security section in the tutorial.\n\nHere we are focusing only on the tools and mechanics of databases.\n\nMain FastAPI app¶\n\nAnd now in the file sql_app/main.py let's integrate and use all the other parts we created before.\n\nCreate the database tables¶\n\nIn a very simplistic way create the database tables:\n\nAlembic Note¶\n\nNormally you would probably initialize your database (create tables, etc) with Alembic.\n\nAnd you would also use Alembic for \"migrations\" (that's its main job).\n\nA \"migration\" is the set of steps needed whenever you change the structure of your SQLAlchemy models, add a new attribute, etc. to replicate those changes in the database, add a new column, a new table, etc.\n\nYou can find an example of Alembic in a FastAPI project in the Full Stack FastAPI Template. Specifically in the alembic directory in the source code.\n\nCreate a dependency¶\n\nNow use the SessionLocal class we created in the sql_app/database.py file to create a dependency.\n\nWe need to have an independent database session/connection (SessionLocal) per request, use the same session through all the request and then close it after the request is finished.\n\nAnd then a new session will be created for the next request.\n\nFor that, we will create a new dependency with yield, as explained before in the section about Dependencies with yield.\n\nOur dependency will create a new SQLAlchemy SessionLocal that will be used in a single request, and then close it once the request is finished.\n\nAnd then, when using the dependency in a path operation function, we declare it with the type Session we imported directly from SQLAlchemy.\n\nThis will then give us better editor support inside the path operation function, because the editor will know that the db parameter is of type Session:\n\nCreate your FastAPI path operations¶\n\nNow, finally, here's the standard FastAPI path operations code.\n\nWe are creating the database session before each request in the dependency with yield, and then closing it afterwards.\n\nAnd then we can create the required dependency in the path operation function, to get that session directly.\n\nWith that, we can just call crud.get_user directly from inside of the path operation function and use that session.\n\nAbout def vs async def¶\n\nHere we are using SQLAlchemy code inside of the path operation function and in the dependency, and, in turn, it will go and communicate with an external database.\n\nThat could potentially require some \"waiting\".\n\nBut as SQLAlchemy doesn't have compatibility for using await directly, as would be with something like:\n\n...and instead we are using:\n\nThen we should declare the path operation functions and the dependency without async def, just with a normal def, as:\n\nMigrations¶\n\nBecause we are using SQLAlchemy directly and we don't require any kind of plug-in for it to work with FastAPI, we could integrate database migrations with Alembic directly.\n\nAnd as the code related to SQLAlchemy and the SQLAlchemy models lives in separate independent files, you would even be able to perform the migrations with Alembic without having to install FastAPI, Pydantic, or anything else.\n\nThe same way, you would be able to use the same SQLAlchemy models and utilities in other parts of your code that are not related to FastAPI.\n\nFor example, in a background task worker with Celery, RQ, or ARQ.\n\nReview all the files¶\n\nRemember you should have a directory named my_super_project that contains a sub-directory called sql_app.\n\nsql_app should have the following files:\n\nsql_app/__init__.py: is an empty file.\n\nsql_app/database.py:\n\nsql_app/models.py:\n\nsql_app/schemas.py:\n\nsql_app/crud.py:\n\nsql_app/main.py:\n\nCheck it¶\n\nYou can copy this code and use it as is.\n\nInfo\n\nIn fact, the code shown here is part of the tests. As most of the code in these docs.\n\nThen you can run it with Uvicorn:\n\nAnd then, you can open your browser at http://127.0.0.1:8000/docs.\n\nAnd you will be able to interact with your FastAPI application, reading data from a real database:\n\nInteract with the database directly¶\n\nIf you want to explore the SQLite database (file) directly, independently of FastAPI, to debug its contents, add tables, columns, records, modify data, etc. you can use DB Browser for SQLite.\n\nIt will look like this:\n\nYou can also use an online SQLite browser like SQLite Viewer or ExtendsClass.\n\nAlternative DB session with middleware¶\n\nIf you can't use dependencies with yield -- for example, if you are not using Python 3.7 and can't install the \"backports\" mentioned above for Python 3.6 -- you can set up the session in a \"middleware\" in a similar way.\n\nA \"middleware\" is basically a function that is always executed for each request, with some code executed before, and some code executed after the endpoint function.\n\nCreate a middleware¶\n\nThe middleware we'll add (just a function) will create a new SQLAlchemy SessionLocal for each request, add it to the request and then close it once the request is finished.\n\nAbout request.state¶\n\nrequest.state is a property of each Request object. It is there to store arbitrary objects attached to the request itself, like the database session in this case. You can read more about it in Starlette's docs about Request state.\n\nFor us in this case, it helps us ensure a single database session is used through all the request, and then closed afterwards (in the middleware).\n\nDependencies with yield or middleware¶\n\nAdding a middleware here is similar to what a dependency with yield does, with some differences:\n\nIt requires more code and is a bit more complex.\n\nThe middleware has to be an async function.\n\nIf there is code in it that has to \"wait\" for the network, it could \"block\" your application there and degrade performance a bit.\n\nAlthough it's probably not very problematic here with the way SQLAlchemy works.\n\nBut if you added more code to the middleware that had a lot of I/O waiting, it could then be problematic.\n\nA middleware is run for every request.\n\nSo, a connection will be created for every request.\n\nEven when the path operation that handles that request didn't need the DB."
    }
}