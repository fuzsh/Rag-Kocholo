{
    "id": "dbpedia_8285_3",
    "rank": 26,
    "data": {
        "url": "https://www.mongodb.com/resources/compare/mongodb-mysql",
        "read_more_link": "",
        "language": "en",
        "title": "Comparing The Differences - MongoDB Vs MySQL",
        "top_image": "http://s3.amazonaws.com/info-mongodb-com/_com_assets/cms/kuzt9r42or1fxvlq2-Meta_Generic.png",
        "meta_img": "http://s3.amazonaws.com/info-mongodb-com/_com_assets/cms/kuzt9r42or1fxvlq2-Meta_Generic.png",
        "images": [
            "https://webimages.mongodb.com/_com_assets/cms/kuyjf3vea2hg34taa-horizontal_default_slate_blue.svg?auto=format%252Ccompress",
            "https://webimages.mongodb.com/_com_assets/cms/lyj1z1iiimsre0lsz-search_updated_white.svg?auto=format%252Ccompress",
            "https://webimages.mongodb.com/_com_assets/icons/atlas_product_family.svg",
            "https://webimages.mongodb.com/_com_assets/icons/atlas_database.svg",
            "https://webimages.mongodb.com/_com_assets/icons/atlas_search.svg",
            "https://webimages.mongodb.com/_com_assets/icons/mdb_vector_search.svg",
            "https://webimages.mongodb.com/_com_assets/icons/atlas_stream_processing.svg",
            "https://webimages.mongodb.com/_com_assets/icons/enterprise_advanced_product family.svg",
            "https://webimages.mongodb.com/_com_assets/icons/community_edition_product_family.svg",
            "https://webimages.mongodb.com/_com_assets/icons/mdb_compass.svg",
            "https://webimages.mongodb.com/_com_assets/icons/atlas_integration.svg",
            "https://webimages.mongodb.com/_com_assets/icons/mdb_migrator.svg",
            "https://webimages.mongodb.com/_com_assets/icons/atlas_product_family.svg",
            "https://webimages.mongodb.com/_com_assets/icons/general_events_ask_the_experts.svg",
            "https://webimages.mongodb.com/_com_assets/icons/general_content_tutorial.svg",
            "https://webimages.mongodb.com/_com_assets/icons/general_events_session.svg",
            "https://webimages.mongodb.com/_com_assets/cms/lyekm5ifrkqjod0wu-search_updated.svg?auto=format%252Ccompress",
            "https://webimages.mongodb.com/_com_assets/cms/kuyjf3vea2hg34taa-horizontal_default_slate_blue.svg?auto=format%252Ccompress",
            "https://webimages.mongodb.com/_com_assets/cms/lyekm5ifrkqjod0wu-search_updated.svg?auto=format%252Ccompress",
            "https://webimages.mongodb.com/_com_assets/cms/kuyj3d95v5vbmm2f4-horizontal_white.svg?auto=format%252Ccompress"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Understand the differences between MongoDB and MySQL, the scalability and security options for each offering, and which database to use when.",
        "meta_lang": "en",
        "meta_favicon": "/assets/images/global/favicon.ico",
        "meta_site_name": "MongoDB",
        "canonical_link": "https://www.mongodb.com/resources/compare/mongodb-mysql",
        "text": "What are the main differences between MongoDB and MySQL?\n\nMySQL\n\nMySQL is a popular, free-to-use, and open-source relational database management system (RDBMS) developed by Oracle. As with other relational systems, MySQL stores data using tables and rows, enforces referential integrity, and uses structured query language (SQL) for data access. When users need to retrieve data from a MySQL database, they must construct an SQL query that joins multiple tables together to create the view on the data they require.\n\nDatabase schemas and data models need to be defined ahead of time, and data must match this schema to be stored in the database. This rigid approach to storing data offers some degree of safety, but trades this for flexibility. If a new type or format of data needs to be stored in the database, schema migration must occur, which can become complex and expensive as the size of the database grows.\n\nMongoDB\n\nMongoDB is also free to use and open source; however, its design principles differ from traditional relational systems. Often styled as a non-relational (or NoSQL) system, MongoDB adopts a significantly different approach to storing data, representing information as a series of JSON-like documents (actually stored as binary JSON, or BSON), as opposed to the table and row format of relational systems.\n\nMongoDB documents consist of a series of key/value pairs of varying types, including arrays and nested documents; however, the primary difference is that the structure of the key/value pairs in a given collection can vary from document to document. This more flexible approach is possible because documents are self-describing.\n\nWhen to use MongoDB vs. MySQL\n\nThe core differences between these two database systems are significant. Choosing which one to use is really a question of approach rather than purely a technical decision.\n\nMySQL is a mature relational database system, offering a familiar database environment for experienced IT professionals.\n\nMongoDB is a well-established, non-relational database system offering improved flexibility and horizontal scalability, but at the cost of some safety features of relational databases, such as referential integrity.\n\nWhich one should you choose?\n\nIn the following sections, we’re going to look at some of the different considerations when deciding between MongoDB and MySQL.\n\nMongoDB vs. MySQL user-friendliness\n\nMongoDB is an attractive option to developers. Its data storage philosophy is simple and immediately understandable to anybody with programming experience.\n\nMongoDB stores data in collections with no enforced schema. This flexible approach to storing data makes it particularly suitable for developers who may not be database experts, yet want to use a database to support the development of their applications.\n\nCompared to MySQL, this flexibility is a significant advantage: to get the best out of a relational database, you must first understand the principles of normalization, referential integrity, and relational database design.\n\nWith the ability to store documents of varying schemas, including unstructured data sets, MongoDB provides a flexible developer interface for teams that are building applications that don’t need all of the safety features offered by relational systems. A common example of such an application is a web application that doesn't depend on structured schemas; it can easily serve unstructured, semi-structured, or structured data, all from the same MongoDB collection.\n\nMySQL is a common choice for users who have extensive experience using traditional SQL scripting, designing solutions for relational databases, or who are modifying or updating existing applications that already work with a relational system. Relational databases may also be a better choice for applications that require very complex but rigid data structures and database schemas across a large number of tables.\n\nA common example of such a system could be a banking application that requires very strong referential integrity and transactional guarantees to be enforced to maintain exact point-in-time integrity of data.\n\nHowever, it is important to clarify that MongoDB also supports ACID properties of transactions (atomicity, consistency, isolation, and durability). This enables greater flexibility in building a transactional data model that can horizontally scale in a distributed environment and has no impact on performance for multi-document transactions.\n\nMongoDB vs. MySQL scalability\n\nA key benefit of the MongoDB design is that the database is extremely easy to scale. Configuring a sharded cluster allows a portion of the database, called a shard, to also be configured as a replica set. In a sharded cluster, data is distributed across many servers. This highly flexible approach allows MongoDB to horizontally scale both read and write performance to cater to applications of any scale.\n\nA replica set is the replication of a group of MongoDB servers that hold the same data, ensuring high availability and disaster recovery.\n\nWith a MySQL database system, options for scalability are much more limited. Typically, you have two choices: vertical scalability, or adding read replicas. Scaling vertically involves adding more resources to the existing database server, but this has an inherent upper limit.\n\nRead replication involves adding read-only copies of the database to other servers. However, this is typically limited to five replicas in total, which can only be used for read operations. This can cause issues with applications that are either write-heavy, or write and read regularly for the database, since it’s common for replicas to lag behind the write master. Multi-master replication support has been added to MySQL, but its implementation is more limited than the functionality available in MongoDB.\n\nMongoDB vs. MySQL performance\n\nAssessing the performance of two completely different database systems is very difficult, since both management systems approach the task for data storage and retrieval in completely different ways. While it’s possible to directly compare two SQL databases with a set of standard SQL benchmarks, achieving the same across non-relational and relational databases is much more difficult and subjective.\n\nFor example: MySQL is optimized for high performance joins across multiple tables that have been appropriately indexed. In MongoDB, joins are supported with the $lookup operation, but they are less needed due to the way MongoDB documents tend to be used; they follow a hierarchical data model and keep most of the data in one document, therefore eliminating the need for joins across multiple documents.\n\nMongoDB is also optimized for write performance, and features a specific insertMany() API for rapidly inserting data, prioritizing speed over transaction safety wherein MySQL data needs to be inserted row by row.\n\nObserving some of the high-level query behaviors of the two systems, we can see that MySQL is faster at selecting a large number of records, while MongoDB is significantly faster at inserting or updating a large number of records.\n\nMongoDB vs. MySQL flexibility\n\nThis is an easy one, and a hands-down win for MongoDB. The schemaless design of MongoDB documents makes it extremely easy to build and enhance applications over time, without needing to run complex and expensive schema migration processes as you would with a relational database.\n\nWith MongoDB, there are more dynamic options for updating the schema of a collection, such as creating new fields based on an aggregation pipeline or updating nested array fields. This benefit is particularly important as databases grow in size. In contrast, larger MySQL databases are slower to migrate schemas and stored procedures that can be dependent on the updated schemas. MongoDB’s flexible design makes this much less of a concern.\n\nIt’s worth pointing out that both databases have a lot in common. Both are free to get started with, both are easy to install on Linux and Windows, and both have wide programming language support for popular languages like Java, node.js, and Python.\n\nIn addition, MongoDB offers MongoDB Atlas, a managed cloud solution which is also forever free to use for exploratory purposes, while for a MySQL managed cloud version, you would need to have an account with one of the major public cloud providers and fall within their free tier terms in order to not pay.\n\nMongoDB vs. MySQL security\n\nMongoDB leverages the popular role-based access control model with a flexible set of permissions. Users are assigned to a role, and that role grants them specific permissions over datasets and database operations. All communication is encrypted with TLS, and it’s possible to write encrypted documents to MongoDB data collections using a master key which is never available to MongoDB, achieving encryption of data at rest. Introduced in MongoDB 7.0, Queryable Encryption allows users to apply randomized encryption to sensitive fields, store the encrypted values in the database and run expressive queries against those fields without decrypting them. This allows to protect sensitive data during its entire lifecycle.\n\nMySQL supports many of MongoDB's encryption features; its authentication model is also similar. Users can be granted roles but also privileges, giving them permissions over particular database operations and against particular datasets.\n\nConclusion\n\nIn this article, we have talked about the main differences between MongoDB and MySQL, a schemaless non-relational database system and a relational database system, respectively. We have explained when it is better to use one over the other. We have discussed the scalability, performance, and user-friendliness for each system. Finally, we have also explained the flexibility and security features for both database systems from a comparison point of view.\n\nIf MongoDB is the right solution for you and you’re currently using MySQL, check out our migration guide and MongoDB's Relational Migrator - a tool that simplifies migrating and transforming data from a relational database to MongoDB, de-risking your transition to MongoDB while helping you take full advantage of the document model.\n\nAnother option to consider is a hybrid deployment approach — giving you the benefit of both worlds, and the flexibility to choose the tool that works for you. Check out this hybrid deployment guide for more details.\n\nTo get started for free, try MongoDB Atlas.\n\nWhy is using MongoDB better than using MySQL?\n\nOrganizations of all sizes are adopting MongoDB, especially as a cloud database, because it enables them to build applications faster, handle highly diverse data types, and manage applications more efficiently at scale.\n\nDevelopment is simplified as MongoDB documents map naturally to modern, object-oriented programming languages. Using MongoDB removes the complex object-relational mapping (ORM) layer that translates objects in code to relational tables. MongoDB’s flexible data model also means that your database schema can evolve with business requirements. MySQL's rigid relational structure adds overhead to applications and slows developers down as they must adapt objects in code to a relational structure.\n\nMongoDB can also be scaled within and across multiple distributed data centers, providing new levels of availability and scalability previously unachievable with relational databases like MySQL. As your deployments grow in terms of data volume and throughput, MongoDB scales easily with no downtime, and without changing your application. In contrast, achieving scale with MySQL often requires significant custom engineering work."
    }
}