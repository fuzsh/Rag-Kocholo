{
    "id": "dbpedia_8285_3",
    "rank": 47,
    "data": {
        "url": "https://blog.logrocket.com/build-rest-api-node-express-mysql/",
        "read_more_link": "",
        "language": "en",
        "title": "Build a REST API with Node.js, Express, and MySQL",
        "top_image": "https://blog.logrocket.com/wp-content/uploads/2022/01/build-rest-api-node-express-mysql.png",
        "meta_img": "https://blog.logrocket.com/wp-content/uploads/2022/01/build-rest-api-node-express-mysql.png",
        "images": [
            "https://blog.logrocket.com/wp-content/themes/logrocket/assets/logrocket-logo.png",
            "https://blog.logrocket.com/wp-content/uploads/2021/01/geshan-manandhar.jpg?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2023/12/GalileoAIPreview.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/build-rest-api-node-express-mysql.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/db4free-signup-page.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/db3free-registration-options.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/creating-programming-languages-table.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/adding-rows-programming-languages-table.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/node-project-folder-structure-layout.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/11/Screen-Shot-2022-09-22-at-12.55.13-PM.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/08/rocket-button-icon.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/01/GET-endpint-node-index-output.png",
            "https://paper-attachments.dropboxusercontent.com/s_27FB886BA50556148F338C92670E94A3F9E14F47E273809FB937123D341A942B_1689337779929_image.png",
            "https://blog.logrocket.com/wp-content/uploads/2019/10/green-check.png",
            "https://blog.logrocket.com/wp-content/uploads/2019/12/network-request-filter-2-1.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/06/footer-cta-dots-left.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/06/footer-cta-dots-right.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/09/logrocket-logo-frontend-analytics.png",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Visualize-JSON-data-popular-tools.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2022/03/ukeje-goodness.jpeg?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Supabase-adoption-guide.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2022/08/isaac-junior.jpg?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Resolving-hydration-mismatch-errors-Nextjs.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2022/02/pelumi-akintokun.jpg?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Optimizing-CSS-time-based-animations-new-CSS-functions.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2022/05/emanuel-odioko.png?w=150&h=150&crop=1",
            "https://secure.gravatar.com/avatar/fa4c9d0d7901a090539bcc60f4ace024?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/caaba5c23bd71667506bc16e22a9363a?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/86aaa3542c078e79c807b491960d9265?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/caaba5c23bd71667506bc16e22a9363a?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/0b9d639627fd12bd8851953e90710ed3?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/0b9d639627fd12bd8851953e90710ed3?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/8aed3cfc5ece89198cbccd3397414795?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/f1a324b7cf0e3ec13a3490240b5a8321?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/9cba7fbacc5c882af229dfd83683cf16?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/f6938f108b381d1d5bbec06b96bd9492?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/caaba5c23bd71667506bc16e22a9363a?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/c8487de40dba8c5e938bd68f9542ca41?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/4f7f3a2af11157051561eb39feb5e287?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/d987c8c5a3a9579fdf39e1fc4e52a32a?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/ba8a5d76ba1ecbc86817f059d07c3167?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/0a2bc1b03fb618191ee6bfcd7df0aa37?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/47d3c0121e2d0f49896faee5a40d04f4?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/a05bbf79d00f5f332138b72cbddeadf7?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/6e5e8e105eedadf6ed336b9d9d4ba42a?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/c3a3321f73f550d6f4451516208a2518?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/fccfc6a91b8937b3b6b8628bae195302?s=36&d=mm&r=g",
            "https://secure.gravatar.com/avatar/c2c580e16e4b39fe4a6dff93905f2781?s=36&d=mm&r=g"
        ],
        "movies": [
            "https://open.spotify.com/embed/playlist/5hnQVGbOW4OByGmTOdNREp?utm_source=generator"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Geshan Manandhar"
        ],
        "publish_date": "2023-07-27T17:30:26+00:00",
        "summary": "",
        "meta_description": "Build a REST API using MySQL as a database and Node.js as a language to track the most popular programming languages.",
        "meta_lang": "",
        "meta_favicon": "https://blog.logrocket.com/wp-content/uploads/2019/06/cropped-cropped-favicon-196x196.png?w=32",
        "meta_site_name": "LogRocket Blog",
        "canonical_link": "https://blog.logrocket.com/build-rest-api-node-express-mysql/",
        "text": "Editor’s note: This tutorial was last updated on 27 July 2023 to provide advanced use cases for the REST API, such as using store procedures instead of inline SQL statements.\n\nGenerally, Node.js is coupled with MongoDB and other NoSQL databases, but Node.js also performs well with relational databases like MySQL. If you want to write a new microservice with Node.js for an existing database, you’ll likely use MySQL, one of the world’s most popular open source databases.\n\nIn this tutorial, we’ll learn how to build a REST API using MySQL as our database and Node.js as our language. We’ll also use the Express.js framework to make our task easier. Our example REST API will track the most popular programming languages.\n\nWe’ll cover the following:\n\nWhat is MySQL?\n\nSetting up our MySQL database\n\nWhat is REST API?\n\nSetting up Express.js for our REST API\n\nREST API project structure\n\nGET popular programming languages\n\nPOST a new programming language\n\nPUT to update an existing programming language\n\nDELETE a programming language\n\nTesting our APIs\n\nAdvanced example: Using store procedures\n\nWhy not just use an ORM?\n\nPrerequisites\n\nTo follow along with this article, you should have the following:\n\nUnderstanding of how MySQL and relational databases work in general\n\nBasic knowledge of Node.js and Express.js\n\nUnderstanding of what REST (representational state transfer) APIs are and how they function\n\nKnowledge of what CRUD (create, read, update, delete) is and how it relates to the HTTP GET, POST, PUT, and DELETE methods\n\nThe code in this tutorial is performed on a Mac with Node 14 LTS installed. You can use Node.js, Docker, and Docker Compose to improve your developer experience. You can also access the full code at the GitHub repository. Now, let’s get started!\n\nWhat is MySQL?\n\nMySQL is one of the most popular databases worldwide. Per the 2022 Stack Overflow survey, MySQL was the most-loved database, with more than 46 percent of respondents using it. The community edition is available for free, and supported by a large and active community.\n\nMySQL is a feature-packed relational database first released in 1995. It runs on all major operating systems, like Linux, Windows, and macOS. Because of its features and its cost-effectiveness, MySQL is used by big enterprises and new startups alike. For our example REST API, we’ll use a free MySQL service instead of setting up a local MySQL server.\n\nSetting up our MySQL database\n\nTo host our testing MySQL 8.0 database, we’ll use db4free.net. First, go to the db4free signup page, then fill out the required details by choosing your database name and username:\n\nClick on Signup, and you should receive a confirmation email. Confirm your account by clicking on the link in the email. Next, on the sidebar, click on phpMyAdmin. In the phpMyAdmin login, enter the username and password you chose and click Go:\n\nNow, we have an empty database. Let’s add the programming_languages table. First, click on the database name on the left; for me, it was restapitest123. Then, click SQL on the top menu, and put the following code for CREATE TABLE in the text area:\n\nCREATE TABLE `programming_languages` ( `id` INT(11) NOT NULL auto_increment , `name` VARCHAR(255) NOT NULL , `released_year` INT NOT NULL , `githut_rank` INT NULL , `pypl_rank` INT NULL , `tiobe_rank` INT NULL , `created_at` DATETIME NOT NULL DEFAULT CURRENT_TIMESTAMP , `updated_at` DATETIME on UPDATE CURRENT_TIMESTAMP NOT NULL DEFAULT CURRENT_TIMESTAMP , PRIMARY KEY (`id`), UNIQUE `idx_name_unique` (`name`(255)) ) engine = innodb charset=utf8mb4 COLLATE utf8mb4_general_ci;\n\nClick the Go button, as shown below:\n\nThe code will return with a green check box and a message along the lines of MySQL returned an empty result set (i.e. zero rows). With that, we’ve created a table called programming_languages with eight columns and a primary key called id, an internet and auto-increment. The name column is unique, and we also added released_year for the programming language. We have three columns to input the rank of the programming language, sourced from the following resources:\n\nGitHut: GitHub language stats for Q4 2020\n\nPYPL: The Popularity of Programming Language Index\n\nTIOBE index\n\nThe created_at and updated_at columns store dates to keep track of when the rows were created and updated.\n\nAdding demo rows for programming languages\n\nNext, we’ll add 16 popular programming languages to our programming_languages table. Click the same SQL link on the top of the page and copy and paste the code below:\n\nINSERT INTO programming_languages(id,name,released_year,githut_rank,pypl_rank,tiobe_rank) VALUES (1,'JavaScript',1995,1,3,7), (2,'Python',1991,2,1,3), (3,'Java',1995,3,2,2), (4,'TypeScript',2012,7,10,42), (5,'C#',2000,9,4,5), (6,'PHP',1995,8,6,8), (7,'C++',1985,5,5,4), (8,'C',1972,10,5,1), (9,'Ruby',1995,6,15,15), (10,'R',1993,33,7,9), (11,'Objective-C',1984,18,8,18), (12,'Swift',2015,16,9,13), (13,'Kotlin',2011,15,12,40), (14,'Go',2009,4,13,14), (15,'Rust',2010,14,16,26), (16,'Scala',2004,11,17,34);\n\nYou should receive a message like “16 rows inserted.” Then, the data from our three sources is collected and added to the table in bulk by the INSERT statement, creating 16 rows, one for each programming language. We’ll return to this when we fetch data for the GET API endpoint.\n\nIf we click on the programming_languages table, visible on the left, we’ll see the rows that we just added:\n\nNext, we’ll set up Express.js for our REST API with Node.js and MySQL.\n\nWhat is REST API?\n\nREST API, short for Representational State Transfer API, is a popular architectural style for designing web services and APIs. REST API allows communication between the client and server through standard HTTP methods like GET, POST, PUT, and DELETE, using the principles of statelessness and resource-based interactions.\n\nSome of the important guidelines of REST API include:\n\nClient-server architecture: REST API is divided into client and server components, allowing them to evolve independently\n\nStatelessness: Client requests contain all the necessary information to understand and fulfill the request. The server doesn’t store any client state between requests\n\nCacheability: REST API can utilize caching mechanisms to improve performance and reduce the load on the server\n\nUniform interface: REST API has a consistent and uniform interface, including using standard HTTP methods (GET, POST, PUT, DELETE) to perform operations on resources\n\nSetting up Express.js for our REST API\n\nTo set up a Node.js app with an Express.js server, we’ll first create a directory for our project to reside in:\n\nmkdir programming-languages-api && cd programming-languages-api\n\nThen, we can create a package.json file with npm init -y as follows:\n\n{ \"name\": \"programming-languages-api\", \"version\": \"1.0.0\", \"description\": \"\", \"main\": \"index.js\", \"scripts\": { \"test\": \"echo \\\"Error: no test specified\\\" && exit 1\" }, \"keywords\": [], \"author\": \"\", \"license\": \"ISC\" }\n\nTo install Express, we’ll run npm i express, adding Express as a dependency in the package.json file. Next, we’ll create a slim server in the index.js file. It will print an ok message on the main path /:\n\nconst express = require(\"express\"); const app = express(); const port = 3000; app.use(express.json()); app.use( express.urlencoded({ extended: true, }) ); app.get(\"/\", (req, res) => { res.json({ message: \"ok\" }); }); app.listen(port, () => { console.log(`Example app listening at http://localhost:${port}`); });\n\nThere are a few important things to note in the code above. For one, we’ll use the built-in Express JSON parser middleware to parse JSON in the next steps. We’ll also use the express.urlencoded() middleware to parse the URL encoded body.\n\nIf PORT is not provided as an environment variable, our app will run on port number 3000. We can run the server with node index.js and hit http://localhost:3000 to see {message: \"ok\"} as the output.\n\nREST API project structure\n\nWe’ll structure our project in the following manner to arrange our files logically in folders:\n\nconfig.js will contain configuration for information like the database credentials and the rows we want to show per page when we paginate results. helper.js is the home for any helper functions, like calculating offset for pagination.\n\nThe routes/programmingLanguages.js file will be the glue between the URI and the corresponding function in the services/programmingLanguages.js service. The services folder will house all our services. One of them is db.js, which we use to talk with the MySQL database.\n\nAnother service is programmingLanguages.js, which will have methods like getMultiple, create, etc., to get and create the programming language resource. Basic mapping of the URI and the related service function will look like the code below:\n\nGET /programming-languages → getMultiple() POST /programming-languages → create() PUT /programming-languages/:id → update() DELETE /programming-languages/:id → remove()\n\nNow, let’s code our GET programming languages API with pagination.\n\nGET popular programming languages\n\nWe will need to link our Node.js server with MySQL to create our GET programming languages API. We’ll use the mysql2 package to interact with the MySQL database.\n\nFirst, we need to install mysql2 using the command below at the project root directory:\n\nnpm i mysql2\n\nNext, we’ll create the config file on the root of the project with the following contents:\n\nconst config = { db: { /* don't expose password or any sensitive info, done only for demo */ host: \"db4free.net\", user: \"restapitest123\", password: \"restapitest123\", database: \"restapitest123\", connectTimeout: 60000 }, listPerPage: 10, }; module.exports = config;\n\nIt is worth noting that we set the connectTimeout to 60 seconds. The default is ten seconds, which may not be enough. Consequently, we’ll create the helper.js file with the code below:\n\nfunction getOffset(currentPage = 1, listPerPage) { return (currentPage - 1) * [listPerPage]; } function emptyOrRows(rows) { if (!rows) { return []; } return rows; } module.exports = { getOffset, emptyOrRows }\n\nFor the fun part, we’ll add the route and link it to the services. First, we’ll connect to the database and enable running queries on the database in the services/db.js file:\n\nconst mysql = require('mysql2/promise'); const config = require('../config'); async function query(sql, params) { const connection = await mysql.createConnection(config.db); const [results, ] = await connection.execute(sql, params); return results; } module.exports = { query }\n\nNow, we’ll write up the services/programmingLanguages.js file that acts as the bridge between the route and the database:\n\nconst db = require('./db'); const helper = require('../helper'); const config = require('../config'); async function getMultiple(page = 1){ const offset = helper.getOffset(page, config.listPerPage); const rows = await db.query( `SELECT id, name, released_year, githut_rank, pypl_rank, tiobe_rank FROM programming_languages LIMIT ${offset},${config.listPerPage}` ); const data = helper.emptyOrRows(rows); const meta = {page}; return { data, meta } } module.exports = { getMultiple }\n\nAfter that, we’ll create the routes file in routes/programmingLanguages.js, which looks like the following:\n\nconst express = require('express'); const router = express.Router(); const programmingLanguages = require('../services/programmingLanguages'); /* GET programming languages. */ router.get('/', async function(req, res, next) { try { res.json(await programmingLanguages.getMultiple(req.query.page)); } catch (err) { console.error(`Error while getting programming languages `, err.message); next(err); } }); module.exports = router;\n\nFor the final piece of our GET endpoint, we need to wire up the route in the index.js file as follows:\n\nconst express = require(\"express\"); const app = express(); const port = 3000; const programmingLanguagesRouter = require(\"./routes/programmingLanguages\"); app.use(express.json()); app.use( express.urlencoded({ extended: true, }) ); app.get(\"/\", (req, res) => { res.json({ message: \"ok\" }); }); app.use(\"/programming-languages\", programmingLanguagesRouter); /* Error handler middleware */ app.use((err, req, res, next) => { const statusCode = err.statusCode || 500; console.error(err.message, err.stack); res.status(statusCode).json({ message: err.message }); return; }); app.listen(port, () => { console.log(`Example app listening at http://localhost:${port}`); });\n\nWe made two important changes in our entry point index.js file. First, we added the code below:\n\nconst programmingLanguagesRouter = require('./routes/programmingLanguages');\n\nThen, we linked up the /programming-languages route to the router we just created:\n\napp.use('/programming-languages', programmingLanguagesRouter);\n\nWe also added an error handler middleware to handle errors and provide a proper status code and message. After adding the GET endpoint, when we run our app again with node index.js and hit the browser with http://localhost:3000/programming-languages, we’ll see an output like this:\n\nDepending on the extensions you have installed on your browser, your output might look a bit different. Note that we’ve already implemented pagination for our GET API, which is possible because of the getOffset function in helper.js and how we run the SELECT query in services/programmingLanguage.js. Try http://localhost:3000/programming-languages?page=2 to see languages 11–16.\n\nPOST a new programming language\n\nOur POST API will allow us to create a new programming language in our table. To create a POST programming language API in the /programming-languages endpoint, we’ll add code to the service and the routes files. In the service method, we’ll get the name, the release year, and other ranks from the request body, then insert them into the programming_languages table.\n\nAppend the following code to the services/programmingLanguages.js file:\n\nasync function create(programmingLanguage){ const result = await db.query( `INSERT INTO programming_languages (name, released_year, githut_rank, pypl_rank, tiobe_rank) VALUES ('${programmingLanguage.name}', ${programmingLanguage.released_year}, ${programmingLanguage.githut_rank}, ${programmingLanguage.pypl_rank}, ${programmingLanguage.tiobe_rank})` ); let message = 'Error in creating programming language'; if (result.affectedRows) { message = 'Programming language created successfully'; } return {message}; }\n\nMake sure you also export the following function:\n\nmodule.exports = { getMultiple, create }\n\nFor the function above to be accessible, we need to add a route to link it up in the routes/programmingLanguages.js file:\n\n/* POST programming language */ router.post('/', async function(req, res, next) { try { res.json(await programmingLanguages.create(req.body)); } catch (err) { console.error(`Error while creating programming language`, err.message); next(err); } });\n\nWe’ll use the /programming-languages/:id endpoint to update an existing programming language, where we’ll get the data to update the language. To update a programming language, we’ll run the UPDATE query based on the data we got in the request.\n\nPUT is an idempotent action, meaning that if the same call is made over and over again, it will produce the same results. To enable updating existing records, we’ll add the following code to the programming language service:\n\nasync function update(id, programmingLanguage){ const result = await db.query( `UPDATE programming_languages SET name=\"${programmingLanguage.name}\", released_year=${programmingLanguage.released_year}, githut_rank=${programmingLanguage.githut_rank}, pypl_rank=${programmingLanguage.pypl_rank}, tiobe_rank=${programmingLanguage.tiobe_rank} WHERE id=${id}` ); let message = 'Error in updating programming language'; if (result.affectedRows) { message = 'Programming language updated successfully'; } return {message}; }\n\nMake sure you also export this function, as we did before:\n\nmodule.exports = { getMultiple, create, update, };\n\nTo wire up the code with the PUT endpoint, we’ll add the code below to the programming languages route file, just above module.exports = router;:\n\n/* PUT programming language */ router.put('/:id', async function(req, res, next) { try { res.json(await programmingLanguages.update(req.params.id, req.body)); } catch (err) { console.error(`Error while updating programming language`, err.message); next(err); } });\n\nNow, we can update any existing programming language. For instance, we can update a language’s name if we see a typo.\n\nDELETE a programming language\n\nWe’ll use the /programming-languages/:id path with the HTTP DELETE method to add the functionality to delete a programming language. Go ahead and run the code below:\n\nasync function remove(id){ const result = await db.query( `DELETE FROM programming_languages WHERE id=${id}` ); let message = 'Error in deleting programming language'; if (result.affectedRows) { message = 'Programming language deleted successfully'; } return {message}; }\n\nDon’t forget to export this function as well. Once again, to link up the service with the route, we’ll add the following code to the routes/programmingLanguages.js file:\n\n/* DELETE programming language */ router.delete('/:id', async function(req, res, next) { try { res.json(await programmingLanguages.remove(req.params.id)); } catch (err) { console.error(`Error while deleting programming language`, err.message); next(err); } });\n\nTesting our APIs\n\nAfter running the Node.js Express server with node index.js, you can test all the API endpoints. To create a new programming language, let’s go with Dart, and run the following cURL command. Alternatively, you can use Postman or any other HTTP client:\n\ncurl -i -X POST -H 'Accept: application/json' \\ -H 'Content-type: application/json' http://localhost:3000/programming-languages \\ --data '{\"name\":\"dart\", \"released_year\": 2011, \"githut_rank\": 13, \"pypl_rank\": 20, \"tiobe_rank\": 25}'\n\nThe code above will result in the following output:\n\nHTTP/1.1 200 OK X-Powered-By: Express Content-Type: application/json; charset=utf-8 Content-Length: 55 ETag: W/\"37-3mETlnRrtfrms6wlAjdgAXKq9GE\" Date: Mon, 01 Feb 2021 11:20:07 GMT Connection: keep-alive {\"message\":\"Programming language created successfully\"}\n\nYou can remove the X-Powered-By header and add other security response headers using Express.js Helmet, which will greatly improving the API’s security. For now, let’s update the GitHut rank of Dart from 13 to 12:\n\ncurl -i -X PUT -H 'Accept: application/json' \\ -H 'Content-type: application/json' http://localhost:3000/programming-languages/17 \\ --data '{\"name\":\"dart\", \"released_year\": 2011, \"githut_rank\": 12, \"pypl_rank\": 20, \"tiobe_rank\": 25}'\n\nThe code above will generate an output like the one below:\n\nHTTP/1.1 200 OK X-Powered-By: Express Content-Type: application/json; charset=utf-8 Content-Length: 55 ETag: W/\"37-0QPAQsRHsm23S9CNV3rPa+AFuXo\" Date: Mon, 01 Feb 2021 11:40:03 GMT Connection: keep-alive {\"message\":\"Programming language updated successfully\"}\n\nTo test out the DELETE API, you can use the following cURL to delete Dart with ID 17:\n\ncurl -i -X DELETE -H 'Accept: application/json' \\ -H 'Content-type: application/json' http://localhost:3000/programming-languages/17\n\nThe code above will result in the following output:\n\nHTTP/1.1 200 OK X-Powered-By: Express Content-Type: application/json; charset=utf-8 Content-Length: 55 ETag: W/\"37-aMzd+8NpWQ09igvHbNLorsXxGFo\" Date: Mon, 01 Feb 2021 11:50:17 GMT Connection: keep-alive {\"message\":\"Programming language deleted successfully\"}\n\nIf you’re more used to a visual interface for testing, such as Postman, you can import the cURL commands into Postman.\n\nIn this tutorial, we kept our example fairly simple. However, if this were a real-life API and not a demo, I’d highly recommend the following:\n\nUse a robust validation library like Joi to validate the input precisely, for example, to ensure the programming language’s name is required. It doesn’t already exist in the database\n\nImprove security by adding Helmet.js to Express.js\n\nStreamline logs in a more manageable way using a Node.js logging library like Winston\n\nUse Docker for the Node.js application\n\nAdvanced example: Using store procedures\n\nIn this tutorial, we use inline SQL statements for simplicity. We should consider using store procedures in real-world projects. Using store procedures instead of inline SQL has several advantages: improved performance, easier maintainability, and, more importantly, better security.\n\nLet’s add a new route GET /programming-languages/:id in our app to use a store procedure. First, we need to create it in the database. Run the following SQL script to create a store procedure for searching the programming language by id:\n\nDELIMITER $$ CREATE PROCEDURE `sp_search_programming_languages_by_id`(in langid int) BEGIN SELECT name, githut_rank, pypl_rank, tiobe_rank, created_at FROM programming_languages where id = langid; END $$\n\nTo use the newly created store procedure, we need to add this setting to the config.js:\n\nconst config = { db: { ... multipleStatements: true },\n\nThen, we can add a new helper function to db.js:\n\nasync function callSpSearch(id) { const connection = await mysql.createConnection(config.db); const [results, ] = await connection.query('CALL sp_search_programming_languages_by_id(' + id + ')'); return results; }\n\nThe new function needs to be exported as well:\n\nmodule.exports = { query, callSpSearch }\n\nNext, add this function to the services/programmingLanguages.js, and add it to the exports:\n\nasync function search(id){ const rows = await db.callSpSearch(id); const data = helper.emptyOrRows(rows); return { data } } module.exports = { getMultiple, create, update, remove, search }\n\nThe last step is to add a new route into routes/programmingLanguages.js:\n\nrouter.get('/:id', async function(req, res, next) { try { res.json(await programmingLanguages.search(req.params.id)); } catch (err) { console.error(`Error while searching programming languages `, err.message); next(err); } });\n\nThat’s it! Now, we can restart the server and give it a go. Enter the browser with http://localhost:3000/programming-languages/1, and we should see an output similar to the one below:\n\nCheck out the full source code in this CodeSandbox editor.\n\nWhy not just use an ORM?\n\nAn ORM (Object-Relational Mapping) is a library connecting object-oriented code with relational databases. It lets developers interact with the database using programming language concepts instead of writing raw SQL queries.\n\nWhile using an ORM has its advantages, it also has limitations and disadvantages compared to the vanilla approach:\n\nORMs add an additional layer of abstraction between the app and the database. It could lead to suboptimal performance in some use cases\n\nUsing an ORM can introduce significant complexity to the app and may need a fair bit of a learning curve for developers to understand the framework and its conventions. For a small project, those overheads might outweigh the benefits\n\nORMs are designed to be database agnostic, providing a consistent interface across several different databases. This abstraction can lead to limitations to certain database-specific features. If our app depends on some database-specific features unsupported by the ORM, the vanilla approach will be a better option\n\nIn summary, whether to use an ORM depends on many factors, including application requirements, performance considerations, project size, complexity, and team skillset.\n\nConclusion\n\nWe now have a functioning API server that uses Node.js and MySQL. This tutorial taught us how to set up MySQL as a free service. We then created an Express.js server that can handle various HTTP methods concerning how it translates to SQL queries.\n\nThe example REST API in this tutorial is a good starting point and foundation for building real-world, production-ready REST APIs where you can practice the additional considerations described above. I hope you enjoyed this article. Happy coding!"
    }
}