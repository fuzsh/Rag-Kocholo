{
    "id": "dbpedia_8285_0",
    "rank": 71,
    "data": {
        "url": "https://graphql.org/community/tools-and-libraries/",
        "read_more_link": "",
        "language": "en",
        "title": "Tools and Libraries",
        "top_image": "https://graphql.org/img/og-image.png",
        "meta_img": "https://graphql.org/img/og-image.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "To run a hello world server with Apollo Server:\n\nnpm install @apollo/server graphql\n\nThen run node server.js with this code in server.js:\n\nimport { ApolloServer } from \"@apollo/server\" import { startStandaloneServer } from \"@apollo/server/standalone\" const server = new ApolloServer({ typeDefs, resolvers, }) const { url } = await startStandaloneServer(server) console.log(`üöÄ Server ready at ${url}`)\n\nApollo Server has a built in standalone HTTP server and middleware for Express, and has an framework integration API that supports all Node.js HTTP server frameworks and serverless environments via community integrations.\n\nApollo Server has a plugin API, integration with Apollo Studio, and performance and security features such as caching, automatic persisted queries, and CSRF prevention.\n\nTo run a Graphene hello world script:\n\npip install graphene\n\nThen run python hello.py with this code in hello.py:\n\nimport graphene class Query(graphene.ObjectType): hello = graphene.String(name=graphene.String(default_value=\"World\")) def resolve_hello(self, info, name): return 'Hello ' + name schema = graphene.Schema(query=Query) result = schema.execute('{ hello }') print(result.data['hello']) # \"Hello World\"\n\nThere are also nice bindings for Relay, Django, SQLAlchemy, and Google App Engine.\n\nHere‚Äôs an example of a Strawberry hello world, first install the library:\n\npip install strawberry-graphql\n\nCreate an app.py file with this content:\n\nimport strawberry @strawberry.type class Query: @strawberry.field def hello(self, name: str = \"World\") -> str: return f\"Hello {name}\" schema = strawberry.Schema(query=Query)\n\nThen run strawberry server app and you will have a basic schema server running on http://localhost:8000.\n\nStrawberry also has views for ASGI, Flask and Django and provides utilities like dataloaders and tracing.\n\nGraphQL Shield helps you create a permission layer for your application. Using an intuitive rule-API, you‚Äôll gain the power of the shield engine on every request and reduce the load time of every request with smart caching. This way you can make sure your application will remain quick, and no internal data will be exposed.\n\nimport { rule, shield, and, or, not } from \"graphql-shield\" // Rules const isAuthenticated = rule({ cache: \"contextual\" })(async ( parent, args, ctx, info, ) => { return ctx.user !== null }) const isAdmin = rule({ cache: \"contextual\" })(async ( parent, args, ctx, info, ) => { return ctx.user.role === \"admin\" }) const isEditor = rule({ cache: \"contextual\" })(async ( parent, args, ctx, info, ) => { return ctx.user.role === \"editor\" }) // Permissions const permissions = shield({ Query: { frontPage: not(isAuthenticated), fruits: and(isAuthenticated, or(isAdmin, isEditor)), customers: and(isAuthenticated, isAdmin), }, Mutation: { addFruitToBasket: isAuthenticated, }, Fruit: isAuthenticated, Customer: isAdmin, }) // Server const server = new GraphQLServer({ typeDefs, resolvers, middlewares: [permissions], context: req => ({ ...req, user: getUser(req), }), })\n\nWunderGraph composes all your APIs into a single unified GraphQL API and allows you to expose your Graph as a secure and type-safe JSON-RPC API.\n\nTo get started with WunderGraph, you can use create-wundergraph-app to bootstrap a new project:\n\nnpx create-wundergraph-app my-project -E nextjs-swr\n\nOn the client side, WunderGraph‚Äôs JSON-RPC API integrates very well with frameworks like Next.js, SWR and React Query, while one the backend, we‚Äôre able to leverage the power of ‚ÄúServer-Side-Only GraphQL‚Äù. Handle authentication, authorization, validation, joins and more right in the Query Layer.\n\nmutation ( $name: String! @fromClaim(name: NAME) $email: String! @fromClaim(name: EMAIL) $message: String! @jsonSchema(pattern: \"^[a-zA-Z 0-9]+$\") ) { createOnepost( data: { message: $message user: { connectOrCreate: { where: { email: $email } create: { email: $email, name: $name } } } } ) { id message user { id name } } }\n\nThe Query above requires the user to be authenticated, injects the user‚Äôs name and email from the JWT token and validates the message against a JSON Schema.\n\nHere‚Äôs another example showcasing how we can use Server-Side GraphQL with WunderGraph‚Äôs unique join capabilities, composing data from two different APIs into a single GraphQL response.\n\nquery ( $continent: String! # the @internal directive removes the $capital variable from the public API # this means, the user can't set it manually # this variable is our JOIN key $capital: String! @internal ) { countries_countries(filter: { continent: { eq: $continent } }) { code name # using the @export directive, we can export the value of the field `capital` into the JOIN key ($capital) capital @export(as: \"capital\") # the _join field returns the type Query! # it exists on every object type so you can everywhere in your Query documents _join { # once we're inside the _join field, we can use the $capital variable to join the weather API weather_getCityByName(name: $capital) { weather { temperature { max } summary { title description } } } } } }\n\nThe full example can be found on GitHub.\n\nRun Schemathesis via Docker against your GraphQL endpoint:\n\ndocker run schemathesis/schemathesis \\ run https://your.app.com/graphql\n\nSchemathesis will generate queries matching your GraphQL schema and catch server crashes automatically. Generated queries have arbitrary depth and may contain any subset of GraphQL types defined in the input schema. They expose edge cases in your code that are unlikely to be found otherwise.\n\nNote that you can write your app in any programming language; the tool will communicate with it over HTTP.\n\nFor example, running the command above against https://bahnql.herokuapp.com/graphql uncovers that running the { search(searchTerm: \"\") { stations { name } } } query leads to a server error:\n\n{ \"errors\": [ { \"message\": \"Cannot read property 'city' of undefined\", \"locations\": [ { \"line\": 1, \"column\": 28 } ], \"path\": [\"search\", \"stations\"] } ], \"data\": null }\n\nGraphQL Kotlin provides a set of lightweight type-safe GraphQL HTTP clients. The library provides Ktor HTTP client and Spring WebClient based reference implementations as well as allows for custom implementations using other engines. Jackson and kotlinx-serialization type-safe data models are generated at build time by the provided Gradle and Maven plugins.\n\nTo generate Jackson models that will be used with GraphQL Kotlin Spring WebClient, add following to your Gradle build file:\n\n// build.gradle.kts import com.expediagroup.graphql.plugin.gradle.graphql plugins { id(\"com.expediagroup.graphql\") version $latestGraphQLKotlinVersion } dependencies { implementation(\"com.expediagroup:graphql-kotlin-spring-client:$latestGraphQLKotlinVersion\") } graphql { client { // target GraphQL endpoint endpoint = \"http://localhost:8080/graphql\" // package for generated client code packageName = \"com.example.generated\" } }\n\nBy default, GraphQL Kotlin plugins will look for query files under src/main/resources. Given HelloWorldQuery.graphql sample query:\n\nquery HelloWorldQuery { helloWorld }\n\nPlugin will generate classes that are simple POJOs implementing GraphQLClientRequest interface and represent a GraphQL request.\n\npackage com.example.generated import com.expediagroup.graphql.client.types.GraphQLClientRequest import kotlin.String import kotlin.reflect.KClass const val HELLO_WORLD_QUERY: String = \"query HelloWorldQuery {\\n helloWorld\\n}\" class HelloWorldQuery: GraphQLClientRequest<HelloWorldQuery.Result> { override val query: String = HELLO_WORLD_QUERY override val operationName: String = \"HelloWorldQuery\" override fun responseType(): KClass<HelloWorldQuery.Result> = HelloWorldQuery.Result::class data class Result( val helloWorld: String } }\n\nWe can then execute our queries using target client.\n\npackage com.example.client import com.expediagroup.graphql.client.spring.GraphQLWebClient import com.expediagroup.graphql.generated.HelloWorldQuery import kotlinx.coroutines.runBlocking fun main() { val client = GraphQLWebClient(url = \"http://localhost:8080/graphql\") runBlocking { val helloWorldQuery = HelloWorldQuery() val result = client.execute(helloWorldQuery) println(\"hello world query result: ${result.data?.helloWorld}\") } }\n\nSee graphql-kotlin client docs for additional details.\n\nGraphQL Kotlin follows a code first approach for generating your GraphQL schemas. Given the similarities between Kotlin and GraphQL, such as the ability to define nullable/non-nullable types, a schema can be generated from Kotlin code without any separate schema specification. To create a reactive GraphQL web server add following dependency to your Gradle build file:\n\n// build.gradle.kts implementation(\"com.expediagroup\", \"graphql-kotlin-spring-server\", latestVersion)\n\nWe also need to provide a list of supported packages that can be scanned for exposing your schema objects through reflections. Add following configuration to your application.yml file:\n\ngraphql: packages: - \"com.your.package\"\n\nWith the above configuration we can now create our schema. In order to expose your queries, mutations and/or subscriptions in the GraphQL schema you simply need to implement corresponding marker interface and they will be automatically picked up by graphql-kotlin-spring-server auto-configuration library.\n\n@Component class HelloWorldQuery : Query { fun helloWorld() = \"Hello World!!!\" }\n\nThis will result in a reactive GraphQL web application with following schema:\n\ntype Query { helloWorld: String! }\n\nSee graphql-kotlin docs for additial details.\n\nGraphQL Middleware is a schema wrapper which allows you to manage additional functionality across multiple resolvers efficiently.\n\nFeatures\n\nüí° Easy to use: An intuitive, yet familiar API that you will pick up in a second. üí™ Powerful: Allows complete control over your resolvers (Before, After). üåà Compatible: Works with any GraphQL Schema.\n\nExample\n\nconst { ApolloServer } = require(\"apollo-server\") const { makeExecutableSchema } = require(\"@graphql-tools/schema\") const typeDefs = ` type Query { hello(name: String): String bye(name: String): String } ` const resolvers = { Query: { hello: (root, args, context, info) => { console.log(`3. resolver: hello`) return `Hello ${args.name ? args.name : \"world\"}!` }, bye: (root, args, context, info) => { console.log(`3. resolver: bye`) return `Bye ${args.name ? args.name : \"world\"}!` }, }, } const logInput = async (resolve, root, args, context, info) => { console.log(`1. logInput: ${JSON.stringify(args)}`) const result = await resolve(root, args, context, info) console.log(`5. logInput`) return result } const logResult = async (resolve, root, args, context, info) => { console.log(`2. logResult`) const result = await resolve(root, args, context, info) console.log(`4. logResult: ${JSON.stringify(result)}`) return result } const schema = makeExecutableSchema({ typeDefs, resolvers }) const schemaWithMiddleware = applyMiddleware(schema, logInput, logResult) const server = new ApolloServer({ schema: schemaWithMiddleware, }) await server.listen({ port: 8008 })\n\nSpectaQL is a Node.js library that generates static documentation for a GraphQL schema using a variety of options:\n\nFrom a live endpoint using the introspection query.\n\nFrom a file containing an introspection query result.\n\nFrom a file, files or glob leading to the schema definitions in SDL.\n\nOut of the box, SpectaQL generates a single 3-column HTML page and lets you choose between a couple built-in themes. A main goal of the project is to be easily and extremely customizable‚Äîit is themeable and just about everything can be overridden or customized.\n\nnpm install --dev spectaql # OR yarn add -D spectaql # Then generate your docs npm run spectaql my-config.yml # OR yarn spectaql my-config.yml\n\ngraphql-go-tools implements all basic blocks for building GraphQL Servers, Gateways and Proxy Servers. From lexing, parsing, validation, normalization, all the way up to query planning and execution.\n\nIt can also be understood as a GraphQL Compiler, with the ability to add your own backends. Just by implementing a few interfaces, you‚Äôre able to teach the compiler how to talk GraphQL to any backend.\n\nThe following backends are already implemented: GraphQL, with support for Apollo Federation / Supergraph. Databases: PostgreSQL, MySQL, SQLite, CockroachDB, MongoDB, SQLServer, OpenAPI / REST and Kafka.\n\nTo get a sense on how to implement a new backend, check out the Static Data Source, as it‚Äôs the simplest one.\n\nIt‚Äôs used in production by many enterprises for multiple years now, battle tested and actively maintained.\n\nSwiftGraphQL is a Swift code generator and a lightweight GraphQL client. It lets you create queries using Swift, and guarantees that every query you create is valid.\n\nThe library is centered around three core principles:\n\nüöÄ If your project compiles, your queries work. ü¶â Use Swift in favour of GraphQL wherever possible. üå≥ Your application model should be independent of your schema.\n\nHere‚Äôs a short preview of the SwiftGraphQL code\n\nimport SwiftGraphQL // Define a Swift model. struct Human: Identifiable { let id: String let name: String let homePlanet: String? } // Create a selection. let human = Selection.Human { Human( id: try $0.id(), name: try $0.name(), homePlanet: try $0.homePlanet() ) } // Construct a query. let query = Selection.Query { try $0.humans(human.list) } // Perform the query. send(query, to: \"http://swift-graphql.heroku.com\") { result in if let data = try? result.get() { print(data) // [Human] } }\n\nHere‚Äôs an example on how to create a simple schema based on a kotlin data class plus a property resolver that gets applied onto your class.\n\ndata class Article(val id: Int, val text: String) fun main() { val schema = KGraphQL.schema { query(\"article\") { resolver { id: Int?, text: String -> Article(id ?: -1, text) } } type<Article> { property<String>(\"fullText\") { resolver { article: Article -> \"${article.id}: ${article.text}\" } } } } schema.execute(\"\"\" { article(id: 5, text: \"Hello World\") { id fullText } } \"\"\").let(::println) }\n\nKGraphQL is using coroutines behind the scenes to provide great asynchronous performance.\n\nSee KGraphQL docs for more in depth usage.\n\nKtor Plugin\n\nKGraphQL has a Ktor plugin which gives you a fully functional GraphQL server with a single install function call. Example below shows how to set up a GraphQL server within Ktor and it will give you a GraphQL Playground out of the box by entering localhost:8080/graphql.\n\nfun Application.module() { install(GraphQL) { playground = true schema { query(\"hello\") { resolver { -> \"World!\" } } } } }\n\nYou can follow the Ktor tutorial to set up a KGraphQL server with ktor from scratch up.\n\nThe ZeroQL is a high-performance C#-friendly GraphQL client. It supports Linq-like syntax, and doesn‚Äôt require Reflection.Emit or expressions. As a result, at runtime provides performance very close to a raw HTTP call.\n\nYou can use ZeroQL to:\n\nGenerate a C# client from GraphQL schema.\n\nGenerate and execute graphql queries from your C# code.\n\nDon‚Äôt require writing GraphQL manually.\n\nSupports .Net Core, .Net Framework, Xamarin, Unity apps.\n\nvar userId = 10; var response = await qlClient.Query(q => q .User(userId, o => new { o.Id, o.FirstName, o.LastName }));\n\nGraphQL Calculator is a lightweight graphql calculation engine, which is used to alter execution behavior of graphql query.\n\nHere are some examples on how to use GraphQL Calculator on graphql query.\n\nquery basicMapValue($userIds: [Int]) { userInfoList(userIds: $userIds) { id age firstName lastName fullName: stringHolder @map(mapper: \"firstName + lastName\") } } query filterUserByAge($userId: [Int]) { userInfoList(userIds: $userId) @filter(predicate: \"age>=18\") { userId age firstName lastName } } query parseFetchedValueToAnotherFieldArgumentMap($itemIds: [Int]) { itemList(itemIds: $itemIds) { # save sellerId as List<Long> with unique name \"sellerIdList\" sellerId @fetchSource(name: \"sellerIdList\") name saleAmount salePrice } userInfoList(userIds: 1) # transform the argument of \"userInfoList\" named \"userIds\" according to expression \"sellerIdList\" and expression argument, # which mean replace userIds value by source named \"sellerIdList\" @argumentTransform( argumentName: \"userIds\" operateType: MAP expression: \"sellerIdList\" dependencySources: [\"sellerIdList\"] ) { userId name age } }\n\nSee graphql-calculator README for more information.\n\nMicroProfile GraphQL is a GraphQL server and client specification for building GraphQL applications. It‚Äôs unique annotation-based API approach enables rapid application development. Applications coded to the MP GraphQL APIs are portable, and can be deployed into Java server runtimes such as Open Liberty, Quarkus, Helidon and Wildfly. This means that your applications can make use of other Jakarta and MicroProfile technologies.\n\nMP GraphQL features include:\n\nAnnotation-based APIs\n\nIntegration with Jakarta CDI\n\nType-safe and dynamic client APIs\n\nException handling\n\nEasy integration with Jakarta and MicroProfile technologies\n\nWant to get started? Check out these resources:\n\nLearn how to create and deploy a server side app in Open Liberty.\n\nLearn how to create a client application in Open Liberty.\n\nLearn how to create and deploy a server side app in Quarkus.\n\nQuick tutorial to build a simple sample weather application.\n\nOr these videos:\n\nIntegrating GraphQL and JPA\n\nWriting Queryable APIs with MP GraphQL\n\nCore Library - The GORM GraphQL library provides functionality to generate a GraphQL schema based on your GORM entities. In addition to mapping domain classes to a GraphQL schema, the core library also provides default implementations of ‚Äúdata fetchers‚Äù to query, update, and delete data through executions of the schema.\n\nGrails Plugin - In a addition to the Core Library, the GORM GraphQL Grails Plugin:\n\nProvides a controller to receive and respond to GraphQL requests through HTTP, based on their guidelines.\n\nGenerates the schema at startup with spring bean configuration to make it easy to extend.\n\nIncludes a GraphiQL browser enabled by default in development. The browser is accessible at /graphql/browser.\n\nOverrides the default data binder to use the data binding provided by Grails\n\nProvides a trait to make integration testing of your GraphQL endpoints easier\n\nSee the documentation for more information.\n\ngraphql_query is complete GraphQL query string builder for python. With graphql_query you can The documentation for graphql_query can be found at https://denisart.github.io/graphql-query.\n\n$ pip install graphql_query\n\nCode for the simple query\n\n{ hero { name } }\n\nit is\n\nfrom graphql_query import Operation, Query hero = Query(name=\"hero\", fields=[\"name\"]) operation = Operation(type=\"query\", queries=[hero]) print(operation.render()) \"\"\" query { hero { name } } \"\"\"\n\nFor generation of the following query\n\nquery Hero($episode: Episode, $withFriends: Boolean!) { hero(episode: $episode) { name friends @include(if: $withFriends) { name } } }\n\nwe have\n\nfrom graphql_query import Argument, Directive, Field, Operation, Query, Variable episode = Variable(name=\"episode\", type=\"Episode\") withFriends = Variable(name=\"withFriends\", type=\"Boolean!\") arg_episode = Argument(name=\"episode\", value=episode) arg_if = Argument(name=\"if\", value=withFriends) hero = Query( name=\"hero\", arguments=[arg_episode], fields=[ \"name\", Field( name=\"friends\", fields=[\"name\"], directives=[Directive(name=\"include\", arguments=[arg_if])] ) ] ) operation = Operation( type=\"query\", name=\"Hero\", variables=[episode, withFriends], queries=[hero] ) print(operation.render()) \"\"\" query Hero( $episode: Episode $withFriends: Boolean! ) { hero( episode: $episode ) { name friends @include( if: $withFriends ) { name } } } \"\"\"\n\nThe purpose of Eggql is to make it as simple as possible to create a GraphQL server. You don‚Äôt need to create GraphQL schema (though you can view the schema that is created if interested). It is currently in beta release but is a complete implementation of a GraphQL server apart from subscriptions.\n\nJust to be clear it supports all of these GraphQL features: arguments (including defaults), objects/lists/enums/input/interface/union types, aliases, fragments, variables, directives, mutations, inline fragments, descriptions, introspection and custom scalars.\n\nTests (jMeter) show that it is as fast or faster than other Go implementations for simple queries. We‚Äôre working on enhancements for performance including caching, data-loader, complexity-limits, etc.\n\nTo run an eggql hello world server just build and run this Go program:\n\npackage main import \"github.com/andrewwphillips/eggql\" func main() { http.Handle(\"/graphql\", eggql.New(struct{ Message string }{Message: \"hello, world\"})) http.ListenAndServe(\":80\", nil) }\n\nThis creates a root Query object with a single message field. To test it send a query with curl:\n\n$ curl -XPOST -d '{\"query\": \"{ message }\"}' localhost:80/graphql\n\nand you will get this response:\n\n{ \"data\": { \"message\": \"hello, world\" } }\n\nYou can install the package with pip\n\npip install graphene-django-cruddals\n\nTo use it, simply create a new class that inherits ‚ÄúDjangoModelCruddals‚Äù Suppose we have the following models.\n\nfrom django.db import models class Question(models.Model): question_text = models.CharField(max_length=200) pub_date = models.DateTimeField('date published') is_active = models.BooleanField(default=True)\n\nThen we can create a complete CRUD+DALS for the models Question with the following code\n\nfrom graphene_django_cruddals import DjangoModelCruddals class CruddalsQuestion(DjangoModelCruddals): class Meta: model = Question\n\nNow you can use the schema that was generated for you,\n\nschema = CruddalsQuestion.Schema\n\nor use in your existing schema root Query and Mutation\n\nclass Query( # ... your others queries CruddalsQuestion.Query, graphene.ObjectType, ): pass class Mutation( # ... your others mutations CruddalsQuestion.Mutation, graphene.ObjectType, ): pass schema = graphene.Schema( query=Query, mutation=Mutation, )\n\nThat‚Äôs it! You can test in graphiql or any other client that you use to test your GraphQL APIs..\n\nFind more information in the official documentation."
    }
}