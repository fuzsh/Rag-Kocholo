{
    "id": "dbpedia_8285_3",
    "rank": 73,
    "data": {
        "url": "https://www.digitalocean.com/community/tutorials/sqlite-vs-mysql-vs-postgresql-a-comparison-of-relational-database-management-systems",
        "read_more_link": "",
        "language": "en",
        "title": "SQLite vs MySQL vs PostgreSQL: A Comparison Of Relational Database Management Systems",
        "top_image": "https://www.digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg",
        "meta_img": "https://www.digitalocean.com/_next/static/media/intro-to-cloud.d49bc5f7.jpeg",
        "images": [
            "https://www.gravatar.com/avatar/1fb56884c78049737aa16ec1ec7d268d336c2bfc43b12fd453fdace21fa36ed5?default=retro 1x, https://www.gravatar.com/avatar/1fb56884c78049737aa16ec1ec7d268d336c2bfc43b12fd453fdace21fa36ed5?default=retro 2x",
            "https://www.gravatar.com/avatar/4dfb614b1cd031250f1f9bfc8bbe9bfab4a98ea184aa6d7f633873b75f8f7d39?default=retro 1x, https://www.gravatar.com/avatar/4dfb614b1cd031250f1f9bfc8bbe9bfab4a98ea184aa6d7f633873b75f8f7d39?default=retro 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fintro-to-cloud.d49bc5f7.jpeg&width=828 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fintro-to-cloud.d49bc5f7.jpeg&width=1920 2x",
            "https://assets.digitalocean.com/articles/sqlite_vs_mysql_vs_postgres/tupleschart_2.png",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=64 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=128 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=64 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fdefault-avatar.14b0d31d.jpeg&width=128 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fcreativecommons.c0a877f1.png&width=128 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fcreativecommons.c0a877f1.png&width=256 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FnewsLetter.c1eb26e3.jpeg&width=750 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FnewsLetter.c1eb26e3.jpeg&width=1920 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FhollieHub4Good.90285377.jpeg&width=750 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2FhollieHub4Good.90285377.jpeg&width=1920 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fwrite4DO.6a167f0c.jpeg&width=750 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fwrite4DO.6a167f0c.jpeg&width=1920 2x",
            "https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fconsole-static.1b14cc64.svg&width=640 1x, https://www.digitalocean.com/api/static-content/v1/images?src=%2F_next%2Fstatic%2Fmedia%2Fconsole-static.1b14cc64.svg&width=1080 2x"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This article compares and contrasts three of the most widely implemented open-source RDBMSs: SQLite, MySQL, and PostgreSQL. Specifically, it explores the datâ¦",
        "meta_lang": "en",
        "meta_favicon": "/_next/static/media/apple-touch-icon.d7edaa01.png",
        "meta_site_name": "",
        "canonical_link": "https://www.digitalocean.com/community/tutorials/sqlite-vs-mysql-vs-postgresql-a-comparison-of-relational-database-management-systems",
        "text": "Introduction\n\nThe relational data model, which organizes data in tables of rows and columns, predominates in database management tools. Today there are other data models, including NoSQL and NewSQL, but relational database management systems (RDBMSs) remain dominant for storing and managing data worldwide.\n\nThis article compares and contrasts three of the most widely implemented open-source RDBMSs: SQLite, MySQL, and PostgreSQL. Specifically, it will explore the data types that each RDBMS uses, their advantages and disadvantages, and situations where they are best optimized.\n\nA Bit About Database Management Systems\n\nDatabases are logically modelled clusters of information, or data. A database management system (DBMS), on the other hand, is a computer program that interacts with a database. A DBMS allows you to control access to a database, write data, run queries, and perform any other tasks related to database management.\n\nAlthough database management systems are often referred to as âdatabases,â the two terms are not interchangeable. A database can be any collection of data, not just one stored on a computer. In contrast, a DBMS specifically refers to the software that allows you to interact with a database.\n\nAll database management systems have an underlying model that structures how data is stored and accessed. A relational database management system is a DBMS that employs the relational data model. In this relational model, data is organized into tables. Tables, in the context of RDBMSs, are more formally referred to as relations. A relation is a set of tuples, which are the rows in a table, and each tuple shares a set of attributes, which are the columns in a table:\n\nMost relational databases use structured query language (SQL) to manage and query data. However, many RDBMSs use their own particular dialect of SQL, which may have certain limitations or extensions. These extensions typically include extra features that allow users to perform more complex operations than they otherwise could with standard SQL.\n\nData Types and Constraints\n\nEach column is assigned a data type which dictates what kind of entries are allowed in that column. Different RDBMSs implement different data types, which arenât always directly interchangeable. Some common data types include dates, strings, integers, and Booleans.\n\nStoring integers in a database is more nuanced than putting numbers in a table. Numeric data types can either be signed, meaning they can represent both positive and negative numbers, or unsigned, which means they can only represent positive numbers. For example, MySQLâs tinyint data type can hold 8 bits of data, which equates to 256 possible values. The signed range of this data type is from -128 to 127, while the unsigned range is from 0 to 255.\n\nBeing able to control what data is allowed into a database is important. Sometimes, a database administrator will impose a constraint on a table to limit what values can be entered into it. A constraint typically applies to one particular column, but some constraints can also apply to an entire table. Here are some constraints that are commonly used in SQL:\n\nUNIQUE: Applying this constraint to a column ensures that no two entries in that column are identical.\n\nNOT NULL: This constraint ensures that a column doesnât have any NULL entries.\n\nPRIMARY KEY: A combination of UNIQUE and NOT NULL, the PRIMARY KEY constraint ensures that no entry in the column is NULL and that every entry is distinct.\n\nFOREIGN KEY: A FOREIGN KEY is a column in one table that refers to the PRIMARY KEY of another table. This constraint is used to link two tables together. Entries to the FOREIGN KEY column must already exist in the parent PRIMARY KEY column for the write process to succeed.\n\nCHECK: This constraint limits the range of values that can be entered into a column. For example, if your application is intended only for residents of Alaska, you could add a CHECK constraint on a ZIP code column to only allow entries between 99501 and 99950.\n\nIf youâd like to learn more about database management systems, check out our article on A Comparison of NoSQL Database Management Systems and Models.\n\nNow that weâve covered relational database management systems generally, letâs move onto the first of the three open-source relational databases this article will cover: SQLite.\n\nSQLite\n\nSQLite is a self-contained, file-based, and fully open-source RDBMS known for its portability, reliability, and strong performance even in low-memory environments. Its transactions are ACID-compliant, even in cases where the system crashes or undergoes a power outage.\n\nThe SQLite projectâs website describes it as a âserverlessâ database. Most relational database engines are implemented as a server process in which programs communicate with the host server through an interprocess communication that relays requests. In contrast, SQLite allows any process that accesses the database to read and write to the database disk file directly. This simplifies SQLiteâs setup process, since it eliminates any need to configure a server process. Likewise, thereâs no configuration necessary for programs that will use the SQLite database: all they need is access to the disk.\n\nSQLite is free and open-source software, and no special license is required to use it. However, the project does offer several extensions â each for a one-time fee â that help with compression and encryption. Additionally, the project offers various commercial support packages, each for an annual fee.\n\nSQLiteâs Supported Data Types\n\nSQLite allows a variety of data types, organized into the following storage classes:\n\nIn the context of SQLite, the terms âstorage classâ and âdata typeâ are considered interchangeable. If youâd like to learn more about SQLiteâs data types and SQLite type affinity, check out SQLiteâs official documentation on the subject.\n\nAdvantages of SQLite\n\nSmall footprint: As its name implies, the SQLite library is very lightweight. Although the space it uses varies depending on the system where itâs installed, it can take up less than 600KiB of space. Additionally, itâs fully self-contained, meaning there arenât any external dependencies you have to install on your system for SQLite to work.\n\nUser-friendly: SQLite is sometimes described as a âzero-configurationâ database thatâs ready for use out of the box. SQLite doesnât run as a server process, which means that it never needs to be stopped, started, or restarted and doesnât come with any configuration files that need to be managed. These features help to streamline the path from installing SQLite to integrating it with an application.\n\nPortable: Unlike other database management systems, which typically store data as a large batch of separate files, an entire SQLite database is stored in a single file. This file can be located anywhere in a directory hierarchy, and can be shared via removable media or file transfer protocol.\n\nDisadvantages of SQLite\n\nLimited concurrency: Although multiple processes can access and query an SQLite database at the same time, only one process can make changes to the database at any given time. This means that while SQLite supports greater concurrency than most other embedded database management systems, it cannot support as much as client/server RDBMSs like MySQL or PostgreSQL.\n\nNo user management: Database systems often come with support for users, or managed connections with predefined access privileges to the database and tables. Because SQLite reads and writes directly to an ordinary disk file, the only applicable access permissions are the typical access permissions of the underlying operating system. This makes SQLite a poor choice for applications that require multiple users with special access permissions.\n\nSecurity: A database engine that uses a server can, in some instances, provide better protection from bugs in the client application than a serverless database like SQLite. For example, stray pointers in a client cannot corrupt memory on the server. Also, because a server is a single persistent process, a client-server database can control data access with more precision than a serverless database. This allows for more fine-grained locking and better concurrency.\n\nWhen To Use SQLite\n\nEmbedded applications: SQLite is a great choice of database for applications that need portability and donât require future expansion. Examples include single-user local applications, mobile applications, or games.\n\nDisk access replacement: In cases where an application needs to read and write files to disk directly, it can be beneficial to use SQLite for the additional functionality and simplicity that comes with using SQL.\n\nTesting: For many applications it can be overkill to test their functionality with a DBMS that uses an additional server process. SQLite has an in-memory mode which can be used to run tests quickly without the overhead of actual database operations, making it an ideal choice for testing.\n\nWhen Not To Use SQLite\n\nWorking with lots of data: SQLite can technically support a database up to 140TB in size, as long as the disk drive and file system also support the databaseâs size requirements. However, the SQLite website recommends that any database approaching 1TB be housed on a centralized client-server database, as an SQLite database of that size or larger would be difficult to manage.\n\nHigh write volumes: SQLite allows only one write operation to take place at any given time, which significantly limits its throughput. If your application requires lots of write operations or multiple concurrent writers, SQLite may not be adequate for your needs.\n\nNetwork access is required: Because SQLite is a serverless database, it doesnât provide direct network access to its data. This access is built into the application. If the data in SQLite is located on a separate machine from the application, it will require a high bandwidth engine-to-disk link across the network. This is an expensive, inefficient solution, and in such cases a client-server DBMS may be a better choice.\n\nMySQL\n\nAccording to the DB-Engines Ranking, MySQL has been the most popular open-source RDBMS since the site began tracking database popularity in 2012. It is a feature-rich product that powers many of the worldâs largest websites and applications, including Twitter, Facebook, Netflix, and Spotify. Getting started with MySQL is relatively straightforward, thanks in large part to its exhaustive documentation and large community of developers, as well as the abundance of MySQL-related resources online.\n\nMySQL was designed for speed and reliability, at the expense of full adherence to standard SQL. The MySQL developers continually work towards closer adherence to standard SQL, but it still lags behind other SQL implementations. It does, however, come with various SQL modes and extensions that bring it closer to compliance.\n\nUnlike applications using SQLite, applications using a MySQL database access it through a separate daemon process. Because the server process stands between the database and other applications, it allows for greater control over who has access to the database.\n\nMySQL has inspired a wealth of third-party applications, tools, and integrated libraries that extend its functionality and help make it easier to work with. Some of the more widely-used of these third-party tools are phpMyAdmin, DBeaver, and HeidiSQL.\n\nMySQLâs Supported Data Types\n\nMySQLâs data types can be organized into three broad categories: numeric types, date and time types, and string types.\n\nNumeric types:\n\nDate and time types:\n\nString types:\n\nAdvantages of MySQL\n\nPopularity and ease of use: As one of the worldâs most popular database systems, thereâs no shortage of database administrators who have experience working with MySQL. Likewise, thereâs an abundance of documentation in print and online on how to install and manage a MySQL database. This includes a number of third-party tools â such as phpMyAdmin â that aim to simplify the process of getting started with the database.\n\nSecurity: MySQL comes installed with a script that helps you to improve the security of your database by setting the installationâs password security level, defining a password for the root user, removing anonymous accounts, and removing test databases that are, by default, accessible to all users. Also, unlike SQLite, MySQL does support user management and allows you to grant access privileges on a user-by-user basis.\n\nSpeed: By choosing not to implement certain features of SQL, the MySQL developers were able to prioritize speed. While more recent benchmark tests show that other RDBMSs like PostgreSQL can match or at least come close to MySQL in terms of speed, MySQL still holds a reputation as an exceedingly fast database solution.\n\nReplication: MySQL supports a number of different types of replication, which is the practice of sharing information across two or more hosts to help improve reliability, availability, and fault-tolerance. This is helpful for setting up a database backup solution or horizontally scaling oneâs database.\n\nDisadvantages of MySQL\n\nKnown limitations: Because MySQL was designed for speed and ease of use rather than full SQL compliance, it comes with certain functional limitations. For example, it lacks support for FULL JOIN clauses.\n\nLicensing and proprietary features: MySQL is dual-licensed software, with a free and open-source community edition licensed under GPLv2 and several paid commercial editions released under proprietary licenses. Because of this, some features and plugins are only available for the proprietary editions.\n\nSlowed development: Since the MySQL project was acquired by Sun Microsystems in 2008, and later by Oracle Corporation in 2009, there have been complaints from users that the development process for the DBMS has slowed down significantly, as the community no longer has the agency to quickly react to problems and implement changes.\n\nWhen To Use MySQL\n\nDistributed operations: MySQLâs replication support makes it a great choice for distributed database setups like primary-secondary or primary-primary architectures.\n\nWebsites and web applications: MySQL powers many websites and applications across the internet. This is, in large part, thanks to how easy it is to install and set up a MySQL database, as well as its overall speed and scalability in the long run.\n\nExpected future growth: MySQLâs replication support can help facilitate horizontal scaling. Additionally, itâs a relatively straightforward process to upgrade to a commercial MySQL product, like MySQL Cluster, which supports automatic sharding, another horizontal scaling process.\n\nWhen Not To Use MySQL\n\nSQL compliance is necessary: Since MySQL does not try to implement the full SQL standard, this tool is not completely SQL compliant. If complete or even near-complete SQL compliance is a must for your use case, you may want to use a more fully compliant DBMS.\n\nConcurrency and large data volumes: Although MySQL generally performs well with read-heavy operations, concurrent read-writes can be problematic. If your application will have many users writing data to it at once, another RDBMS like PostgreSQL might be a better choice of database.\n\nPostgreSQL\n\nPostgreSQL, also known as Postgres, bills itself as âthe most advanced open-source relational database in the world.â It was created with the goal of being highly extensible and standards compliant. PostgreSQL is an object-relational database, meaning that although itâs primarily a relational database it also includes features â like table inheritance and function overloading â that are more often associated with object databases.\n\nPostgres is capable of efficiently handling multiple tasks at the same time, a characteristic known as concurrency. It achieves this without read locks thanks to its implementation of Multiversion Concurrency Control (MVCC), which ensures the atomicity, consistency, isolation, and durability of its transactions, also known as ACID compliance.\n\nPostgreSQL isnât as widely used as MySQL, but there are still a number of third-party tools and libraries designed to simplify working with with PostgreSQL, including pgAdmin and Postbird.\n\nPostgreSQLâs Supported Data Types\n\nPostgreSQL supports numeric, string, and date and time data types like MySQL. In addition, it supports data types for geometric shapes, network addresses, bit strings, text searches, and JSON entries, as well as several idiosyncratic data types.\n\nNumeric types:\n\nCharacter types:\n\nDate and time types:\n\nGeometric types:\n\nNetwork address types:\n\nBit string types:\n\nText search types:\n\nJSON types:\n\nOther data types:\n\nAdvantages of PostgreSQL\n\nSQL compliance: More so than SQLite or MySQL, PostgreSQL aims to closely adhere to SQL standards. According to the official PostgreSQL documentation, PostgreSQL supports 160 out of the 179 features required for full core SQL:2011 compliance, in addition to a long list of optional features.\n\nOpen-source and community-driven: A fully open-source project, PostgreSQLâs source code is developed by a large and devoted community. Similarly, the Postgres community maintains and contributes to numerous online resources that describe how to work with the DBMS, including the official documentation, the PostgreSQL wiki, and various online forums.\n\nExtensible: Users can extend PostgreSQL programmatically and on the fly through its catalog-driven operation and its use of dynamic loading. One can designate an object code file, such as a shared library, and PostgreSQL will load it as necessary.\n\nDisadvantages of PostgreSQL\n\nMemory performance: For every new client connection, PostgreSQL forks a new process. Each new process is allocated about 10MB of memory, which can add up quickly for databases with lots of connections. Accordingly, for simple read-heavy operations, PostgreSQL is typically less performant than other RDBMSs, like MySQL.\n\nPopularity: Although more widely used in recent years, PostgreSQL has historically lagged behind MySQL in terms of popularity. One consequence of this is that there are still fewer third-party tools that can help manage a PostgreSQL database. Similarly, there arenât as many database administrators with experience managing a Postgres database compared to those with MySQL experience.\n\nWhen To Use PostgreSQL\n\nData integrity is important: PostgreSQL has been fully ACID-compliant since 2001 and implements multiversion currency control to ensure that data remains consistent, making it a strong choice of RDBMS when data integrity is critical.\n\nIntegration with other tools: PostgreSQL is compatible with a wide array of programming languages and platforms. This means that if you ever need to migrate your database to another operating system or integrate it with a specific tool, it will likely be easier with a PostgreSQL database than with another DBMS.\n\nComplex operations: Postgres supports query plans that can leverage multiple CPUs in order to answer queries with greater speed. This, coupled with its strong support for multiple concurrent writers, makes it a great choice for complex operations like data warehousing and online transaction processing.\n\nWhen Not To Use PostgreSQL\n\nSpeed is imperative: At the expense of speed, PostgreSQL was designed with extensibility and compatibility in mind. If your project requires the fastest read operations possible, PostgreSQL may not be the best choice of DBMS.\n\nSimple setups: Because of its large feature set and strong adherence to standard SQL, Postgres can be overkill for simple database setups. For read-heavy operations where speed is required, MySQL is typically a more practical choice.\n\nComplex replication: Although PostgreSQL does provide strong support for replication, itâs still a relatively new feature. Some configurations â like a primary-primary architecture â are only possible with extensions. Replication is a more mature feature on MySQL and many users see MySQLâs replication to be easier to implement, particularly for those who lack the requisite database and system administration experience.\n\nConclusion\n\nToday, SQLite, MySQL, and PostgreSQL are the three most popular open-source relational database management systems in the world. Each has its own unique features and limitations, and excels in particular scenarios. There are quite a few variables at play when deciding on an RDBMS, and the choice is rarely as simple as picking the fastest one or the one with the most features. The next time youâre in need of a relational database solution, be sure to research these and other tools in depth to find the one that best suits your needs.\n\nIf youâd like to learn more about SQL and how to use it to manage a relational database, we encourage you to refer to our How To Manage an SQL Database cheat sheet. On the other hand, if youâd like to learn about non-relational (or NoSQL) databases, check out our Comparison Of NoSQL Database Management Systems.\n\nReferences"
    }
}