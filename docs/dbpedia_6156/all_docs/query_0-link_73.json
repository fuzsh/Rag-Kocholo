{
    "id": "dbpedia_6156_0",
    "rank": 73,
    "data": {
        "url": "https://blog.lambda.cx/posts/how-bsd-authentication-works/",
        "read_more_link": "",
        "language": "en",
        "title": "How BSD Authentication Works",
        "top_image": "https://blog.lambda.cx/favicon-32x32.png",
        "meta_img": "https://blog.lambda.cx/favicon-32x32.png",
        "images": [
            "https://blog.lambda.cx/posts/how-bsd-authentication-works/openbsd_internals.gif",
            "https://blog.lambda.cx/posts/how-bsd-authentication-works/graph.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "openbsd",
            "security"
        ],
        "tags": null,
        "authors": [
            "Dante Catalfamo"
        ],
        "publish_date": "2021-10-18T17:27:13-04:00",
        "summary": "",
        "meta_description": "A walkthrough of OpenBSD's BSD Authentication framework",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": "https://blog.lambda.cx/posts/how-bsd-authentication-works/",
        "text": "The way OpenBSD authenticates users is quite different from other Unix-like operating systems. Most other systems like AIX, Solaris, Linux, the other BSDs, and MacOS, use a framework called Pluggable Authentication Module (PAM). The two main implementations are Linux PAM and OpenPAM. PAM modules are created as dynamically loaded shared objects, which communicate using a combination of common and implementation specific interfaces (Linux-PAM and OpenPAM). It's configured using the pam.d directory and pam.conf file. While it can be flexible, it's highly complex and very easy to mis-configure, leaving you open to strange and hard to track down authentication bugs. On top of that, the fact that it's a shared library means that any vulnerability in a poorly vetted authentication module gives attackers direct access to the internals of your application. Author Michael W. Lucas said it best when he described PAM as unstandardized black magic.\n\nOpenBSD on the other hand uses a mechanism called BSD Authentication. It was originally developed for a now-defunct proprietary operating system called BSD/OS by Berkeley Software Design Inc., who later donated the system. It was then adopted by OpenBSD in release 2.9. BSD Auth is comparatively much simpler than PAM. Modules or, authentication \"styles\", are instead stand alone applications or scripts that communicate over IPC. The module has no ability to interfere with the parent and can very easily revoke permissions using pledge(2) or unveil(2). The BSD Authentication system of configured through login.conf(5).\n\nauth_session_t *auth_usercheck(char *name, char *style, char *type, char *password)\n\n{ char namebuf[LOGIN_NAME_MAX + 1 + NAME_MAX + 1]; char pwbuf[_PW_BUF_LEN]; auth_session_t *as; login_cap_t *lc; struct passwd pwstore, *pwd = NULL; char *slash; if (!_auth_validuser(name)) return (NULL); if (strlcpy(namebuf, name, sizeof(namebuf)) >= sizeof(namebuf)) return (NULL); name = namebuf; /* ,* Split up user:style names if we were not given a style ,*/ if (style == NULL && (style = strchr(name, ':')) != NULL) ,*style++ = '\\0'; /* ,* Cope with user/instance. We are only using this to get ,* the class so it is okay if we strip a /root instance ,* The actual login script will pay attention to the instance. ,*/ getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd); if (pwd == NULL) { if ((slash = strchr(name, '/')) != NULL) { ,*slash = '\\0'; getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd); ,*slash = '/'; } } if ((lc = login_getclass(pwd ? pwd->pw_class : NULL)) == NULL) return (NULL); if ((style = login_getstyle(lc, style, type)) == NULL) { login_close(lc); return (NULL); } if (password) { if ((as = auth_open()) == NULL) { login_close(lc); return (NULL); } auth_setitem(as, AUTHV_SERVICE, \"response\"); auth_setdata(as, \"\", 1); auth_setdata(as, password, strlen(password) + 1); explicit_bzero(password, strlen(password)); } else as = NULL; as = auth_verify(as, style, name, lc->lc_class, (char *)NULL); login_close(lc); return (as); }\n\nauth_usercheck is very similar to auth_userokay. It takes the same arguments, except it returns the auth_session_t struct instead of just the status.\n\nIt first checks that name is valid according to _auth_validuser.\n\nIf style is NULL, it checks if name is in the user:style format, and splits it accordingly.\n\nIt then gets the user's password database entry through getpwman_r(3), which operates on the passwd(5) database. After it uses that to retrieve the user's login class using login_getclass(3), which returns a login_cap_t. Login classes are stored in the login.conf(5) database.\n\nThat struct is then passed into login_getstyle(3), which also received the style and type. If type is NULL, it returns the first available login style for that class. If style is specified, it is returned if available, otherwise NULL is returned, which causes auth_usercheck to return NULL as well.\n\nIt then creates a pointer as of type auth_session_t, and handles it differently based on whether password is NULL.\n\nIf the password is a string, it creates a new session using auth_open and assigns it to as. It then sets the session service to \"response\", and adds the password string to the session's data.\n\nauth_setitem(as, AUTHV_SERVICE, \"response\"); auth_setdata(as, \"\", 1); auth_setdata(as, password, strlen(password) + 1);\n\nIf password is NULL, it sets as to NULL.\n\nIt then passes the auth_session_t pointer (as), name, style, login class (lc->lc_class), and a NULL char pointer to auth_verify. Finally it returns the auth session pointer.\n\nas = auth_verify(as, style, name, lc->lc_class, (char *)NULL); // [...] some cleanup return (as);\n\nint auth_call(auth_session_t *as, char *path, ...)\n\n{ char *line; struct authdata *data; struct authopts *opt; pid_t pid; int status; int okay; int pfd[2]; int argc; char *argv[64]; /* 64 args should be more than enough */ #define Nargc (sizeof(argv)/sizeof(argv[0])) va_start(as->ap0, path); argc = 0; if ((argv[argc] = _auth_next_arg(as)) != NULL) ++argc; if (as->fd != -1) { argv[argc++] = \"-v\"; argv[argc++] = \"fd=4\"; /* AUTH_FD, see below */ } /* XXX - fail if out of space in argv */ for (opt = as->optlist; opt != NULL; opt = opt->next) { if (argc < Nargc - 2) { argv[argc++] = \"-v\"; argv[argc++] = opt->opt; } else { syslog(LOG_ERR, \"too many authentication options\"); goto fail; } } while (argc < Nargc - 1 && (argv[argc] = _auth_next_arg(as))) ++argc; if (argc >= Nargc - 1 && _auth_next_arg(as)) { if (memcmp(&nilap, &(as->ap0), sizeof(nilap)) != 0) { va_end(as->ap0); explicit_bzero(&(as->ap0), sizeof(as->ap0)); } if (memcmp(&nilap, &(as->ap), sizeof(nilap)) != 0) { va_end(as->ap); explicit_bzero(&(as->ap), sizeof(as->ap)); } syslog(LOG_ERR, \"too many arguments\"); goto fail; } argv[argc] = NULL; if (socketpair(PF_LOCAL, SOCK_STREAM, 0, pfd) == -1) { syslog(LOG_ERR, \"unable to create backchannel %m\"); warnx(\"internal resource failure\"); goto fail; } switch (pid = fork()) { case -1: syslog(LOG_ERR, \"%s: %m\", path); warnx(\"internal resource failure\"); close(pfd[0]); close(pfd[1]); goto fail; case 0: #define COMM_FD 3 #define AUTH_FD 4 if (dup2(pfd[1], COMM_FD) == -1) err(1, \"dup of backchannel\"); if (as->fd != -1) { if (dup2(as->fd, AUTH_FD) == -1) err(1, \"dup of auth fd\"); closefrom(AUTH_FD + 1); } else closefrom(COMM_FD + 1); execve(path, argv, auth_environ); syslog(LOG_ERR, \"%s: %m\", path); err(1, \"%s\", path); default: close(pfd[1]); if (as->fd != -1) { close(as->fd); /* so child has only ref */ as->fd = -1; } while ((data = as->data) != NULL) { as->data = data->next; if (data->len > 0) { write(pfd[0], data->ptr, data->len); explicit_bzero(data->ptr, data->len); } free(data); } as->index = 0; _auth_spool(as, pfd[0]); close(pfd[0]); do { if (waitpid(pid, &status, 0) != -1) { if (!WIFEXITED(status)) goto fail; break; } /* ,* could get ECHILD if it was waited for by ,* another thread or from a signal handler ,*/ } while (errno == EINTR); } /* ,* Now scan the spooled data ,* It is easier to wait for all the data before starting ,* to scan it. ,*/ for (line = as->spool; line < as->spool + as->index;) { if (!strncasecmp(line, BI_REJECT, sizeof(BI_REJECT)-1)) { line += sizeof(BI_REJECT) - 1; if (!*line || *line == ' ' || *line == '\\t') { while (*line == ' ' || *line == '\\t') ++line; if (!strcasecmp(line, \"silent\")) { as->state = AUTH_SILENT; break; } if (!strcasecmp(line, \"challenge\")) { as->state = AUTH_CHALLENGE; break; } if (!strcasecmp(line, \"expired\")) { as->state = AUTH_EXPIRED; break; } if (!strcasecmp(line, \"pwexpired\")) { as->state = AUTH_PWEXPIRED; break; } } break; } else if (!strncasecmp(line, BI_AUTH, sizeof(BI_AUTH)-1)) { line += sizeof(BI_AUTH) - 1; if (!*line || *line == ' ' || *line == '\\t') { while (*line == ' ' || *line == '\\t') ++line; if (*line == '\\0') as->state |= AUTH_OKAY; else if (!strcasecmp(line, \"root\")) as->state |= AUTH_ROOTOKAY; else if (!strcasecmp(line, \"secure\")) as->state |= AUTH_SECURE; } } else if (!strncasecmp(line, BI_REMOVE, sizeof(BI_REMOVE)-1)) { line += sizeof(BI_REMOVE) - 1; while (*line == ' ' || *line == '\\t') ++line; if (*line) _add_rmlist(as, line); } while (*line++) ; } if (WEXITSTATUS(status)) as->state &= ~AUTH_ALLOW; okay = as->state & AUTH_ALLOW; if (!okay) auth_clrenv(as); if (0) { fail: auth_clrenv(as); as->state = 0; okay = -1; } while ((data = as->data) != NULL) { as->data = data->next; free(data); } if (memcmp(&nilap, &(as->ap0), sizeof(nilap)) != 0) { va_end(as->ap0); explicit_bzero(&(as->ap0), sizeof(as->ap0)); } if (memcmp(&nilap, &(as->ap), sizeof(nilap)) != 0) { va_end(as->ap); explicit_bzero(&(as->ap), sizeof(as->ap)); } return (okay); }\n\nauth_call is responsible for setting up the environment, calling the modules, and communicating with them.\n\nAn array of char pointers called argv is allocated to hold the arguments for the auth module.\n\nchar *argv[64]; /* 64 args should be more than enough */\n\nFirst, the variable arguments are placed in as->ap0.\n\n_auth_next_arg is called once, with the result being set as the first element in argv. If as->fd is set, adds -v and fd=4 to argv.\n\nThen it loops through the optlist and appends -v followed the option for each of them.\n\nAfter that the rest of the arguments are retrieved from _auth_next_arg and added to the end of argv. Finally a NULL is added to the end of argv.\n\nNext a socket pair of type PF_LOCAL, SOCK_STREAM is created. This is called the \"back channel\", and is used to communicate with the authentication module.\n\nThe process then calls fork(2).\n\nHere two constants are set for the back channel and optional authentication file descriptors.\n\n#define COMM_FD 3 #define AUTH_FD 4\n\nIn the child process, the back channel is set to file descriptor 3, or COMM_FD using dup2(3). If as->fd, is not -1, it is set to file descriptor 4, or AUTH_FD, also using dup2(3). The remainder of the file descriptors are closed using closefrom(2) by calling either closefrom(COMM_FD + 1) or closefrom(AUTH_FD + 1), depending on whether or not AUTH_FD is used.\n\nThe child process then executes the module.\n\nexecve(path, argv, auth_environ);\n\nauth_environ is defined at the top of the file as a very minimal environment.\n\nstatic char *auth_environ[] = { \"PATH=\" _PATH_DEFPATH, \"SHELL=\" _PATH_BSHELL, NULL, };\n\nWhere both constants are defined in /include/paths.h.\n\n#define _PATH_DEFPATH \"/usr/bin:/bin:/usr/sbin:/sbin:/usr/X11R6/bin:/usr/local/bin:/usr/local/sbin\" #define _PATH_BSHELL \"/bin/sh\"\n\nIn the parent process, the child's end of the back channel is closed, and so is the parent's copy of as->fd if it exists.\n\nThe data from as->data is then written to the back channel sequentially, zeroed, and freed.\n\nNext as->index is set to 0.\n\nThe response from the authentication module is then read from the back channel and put into as->spool with an optional received file descriptor placed in as->fd, using _auth_spool.\n\n_auth_spool(as, pfd[0]);\n\nOnce the back channel data has finished spooling, it is scanned for key words defined in login_cap.h.\n\n#define BI_AUTH \"authorize\" /* Accepted authentication */#define BI_REJECT \"reject\" /* Rejected authentication */#define BI_CHALLENGE \"reject challenge\" /* Reject with a challenge */#define BI_SILENT \"reject silent\" /* Reject silently */#define BI_REMOVE \"remove\" /* remove file on error */#define BI_ROOTOKAY \"authorize root\" /* root authenticated */#define BI_SECURE \"authorize secure\" /* okay on non-secure line */#define BI_SETENV \"setenv\" /* set environment variable */#define BI_UNSETENV \"unsetenv\" /* unset environment variable */#define BI_VALUE \"value\" /* set local variable */#define BI_EXPIRED \"reject expired\" /* account expired */#define BI_PWEXPIRED \"reject pwexpired\" /* password expired */#define BI_FDPASS \"fd\" /* child is passing an fd */\n\nThe login.conf(5) man page once again goes into greater detail on these values.\n\nauthorize The user has been authorized. authorize secure The user has been authorized and root should be allowed to login even if this is not a secure terminal. This should only be sent by authentication styles that are secure over insecure lines. reject Authorization is rejected. This overrides any indication that the user was authorized (though one would question the wisdom in sending both a reject and an authorize command). reject challenge Authorization was rejected and a challenge has been made available via the value challenge. reject silent Authorization is rejected, but no error messages should be generated. remove file If the login session fails for any reason, remove file before termination. setenv name value If the login session succeeds, the environment variable name should be set to the specified value. unsetenv name If the login session succeeds, the environment variable name should be removed. value name value Set the internal variable name to the specified value. The value should only contain printable characters. Several \\ sequences may be used to introduce non printing characters. These are: \\n A newline. \\r A carriage return. \\t A tab. \\xxx The character represented by the octal value xxx. The value may be one, two, or three octal digits. \\c The string is replaced by the value of c. This allows quoting an initial space or the \\ character itself. The following values are currently defined: challenge See section on challenges below. errormsg If set, the value is the reason authentication failed. The calling program may choose to display this when rejecting the user, but display is not required.\n\nThe scanner is looking for lines that begin with BI_AUTH, BI_REJECT, or BI_REMOVE.\n\nHere as->state is set according to the values defined on login_cap.h.\n\n/* * bits which can be returned by authenticate()/auth_scan() */ #define AUTH_OKAY 0x01 /* user authenticated */#define AUTH_ROOTOKAY 0x02 /* authenticated as root */#define AUTH_SECURE 0x04 /* secure login */#define AUTH_SILENT 0x08 /* silent rejection */#define AUTH_CHALLENGE 0x10 /* a challenge was given */#define AUTH_EXPIRED 0x20 /* account expired */#define AUTH_PWEXPIRED 0x40 /* password expired */\n\nIf a rejection is received (any line starting with BI_REJECT), as->state is set according to the rejection, and the scanning is stopped. Rejections are final and take precedence over any authorizations.\n\nIf an authorization is received (any line starting with BI_AUTH), the appropriate state is bitwise or-ed onto as->state. This allows multiple authorizations, such as a case where both BI_ROOTOKAY and BI_SECURE are sent. This would result in a state of AUTH_OKAY || AUTH_ROOTOKAY || AUTH_SECURE.\n\nFor any lines beginning with BI_REMOVE, the file names after the key word are sent to _add_rmlist.\n\n_add_rmlist(as, line);\n\nAfter scanning is complete, the exit status of the process is checked. A non-zero exit status means the request will get denied.\n\nAn okay value is then defined by masking the state with the value AUTH_ALLOW.\n\nokay = as->state & AUTH_ALLOW;\n\nAUTH_ALLOW is defined in login_cap.h.\n\n#define AUTH_ALLOW (AUTH_OKAY | AUTH_ROOTOKAY | AUTH_SECURE)\n\nIf the status results in a rejection, auth_clrenv is called with as. This removes any requests the login script has made to set environment variables from as->spool.\n\nokay is then returned to the caller.\n\n_auth_next_arg\n\nstatic char *_auth_next_arg(auth_session_t *as)\n\n{ char *arg; if (memcmp(&nilap, &(as->ap0), sizeof(nilap)) != 0) { if ((arg = va_arg(as->ap0, char *)) != NULL) return (arg); va_end(as->ap0); explicit_bzero(&(as->ap0), sizeof(as->ap0)); } if (memcmp(&nilap, &(as->ap), sizeof(nilap)) != 0) { if ((arg = va_arg(as->ap, char *)) != NULL) return (arg); va_end(as->ap); explicit_bzero(&(as->ap), sizeof(as->ap)); } return (NULL); }\n\nLoops through as->ap0 then as->ap, returning one argument per call. Calls va_end on each list once it finishes with them, then explicit_bzero(3)'s them.\n\nFinally when it's gone through both lists, returns NULL\n\n_auth_spool\n\nstatic void _auth_spool(auth_session_t *as, int fd)\n\n{ ssize_t r; char *b, *s; for (s = as->spool + as->index; as->index < sizeof(as->spool) - 1; ) { r = read(fd, as->spool + as->index, sizeof(as->spool) - as->index); if (r <= 0) { as->spool[as->index] = '\\0'; return; } b = as->spool + as->index; as->index += r; /* ,* Convert newlines into NULs to allow easy scanning of the ,* file and receive an fd if there is a BI_FDPASS message. ,* XXX - checking for BI_FDPASS here is annoying but ,* we need to avoid the read() slurping in control data. ,*/ while (r-- > 0) { if (*b++ == '\\n') { b[-1] = '\\0'; if (strcasecmp(s, BI_FDPASS) == 0) _recv_fd(as, fd); s = b; } } } syslog(LOG_ERR, \"Overflowed backchannel spool buffer\"); errx(1, \"System error in authentication program\"); }\n\n_auth_spool's job is to read data from fd and place it in as->spool, and to update as->index with the length of the data on the spool. While spooling it converts newlines to NUL's in order to parse the output more easily. It also handles any file descriptors passed through the back channel by sending them to _recv_fd.\n\n// [...] if (strcasecmp(s, BI_FDPASS) == 0) _recv_fd(as, fd);\n\n_recv_fd\n\nstatic void _recv_fd(auth_session_t *as, int fd)\n\n{ struct msghdr msg; struct cmsghdr *cmp; union { struct cmsghdr hdr; char buf[CMSG_SPACE(sizeof(int))]; } cmsgbuf; memset(&msg, 0, sizeof(msg)); msg.msg_control = &cmsgbuf.buf; msg.msg_controllen = sizeof(cmsgbuf.buf); if (recvmsg(fd, &msg, 0) == -1) syslog(LOG_ERR, \"recvmsg: %m\"); else if (msg.msg_flags & MSG_TRUNC) syslog(LOG_ERR, \"message truncated\"); else if (msg.msg_flags & MSG_CTRUNC) syslog(LOG_ERR, \"control message truncated\"); else if ((cmp = CMSG_FIRSTHDR(&msg)) == NULL) syslog(LOG_ERR, \"missing control message\"); else { if (cmp->cmsg_level != SOL_SOCKET) syslog(LOG_ERR, \"unexpected cmsg_level %d\", cmp->cmsg_level); else if (cmp->cmsg_type != SCM_RIGHTS) syslog(LOG_ERR, \"unexpected cmsg_type %d\", cmp->cmsg_type); else if (cmp->cmsg_len != CMSG_LEN(sizeof(int))) syslog(LOG_ERR, \"bad cmsg_len %d\", cmp->cmsg_len); else { if (as->fd != -1) close(as->fd); as->fd = *(int *)CMSG_DATA(cmp); } } }\n\n_recv_fd reads control messages, also called ancillary data, from fd and tries to receive a file descriptor. It does this using the control message API.\n\nIf it receives one and as->fd is equal to -1, it sets it to the received file descriptor. Otherwise it closes the received file descriptor.\n\n_add_rmlist\n\nstatic void _add_rmlist(auth_session_t *as, char *file)\n\n{ struct rmfiles *rm; size_t i = strlen(file) + 1; // XXX should rangecheck i since we are about to add? if ((rm = malloc(sizeof(struct rmfiles) + i)) == NULL) { syslog(LOG_ERR, \"Failed to allocate rmfiles: %m\"); return; } rm->file = (char *)(rm + 1); rm->next = as->rmlist; strlcpy(rm->file, file, i); as->rmlist = rm; }\n\n_add_rmlist is used to add to the list of files to be removed after authentication is complete\n\nA rmfiles struct is allocated and appended to the end of the as->rmlist linked list.\n\nchar *auth_challenge(auth_session_t *as)\n\n{ char path[PATH_MAX]; int len; if (as == NULL || as->style == NULL || as->name == NULL || !_auth_validuser(as->name)) return (NULL); len = snprintf(path, sizeof(path), _PATH_AUTHPROG \"%s\", as->style); if (len < 0 || len >= sizeof(path)) return (NULL); as->state = 0; free(as->challenge); as->challenge = NULL; auth_call(as, path, as->style, \"-s\", \"challenge\", \"--\", as->name, as->class, (char *)NULL); if (as->state & AUTH_CHALLENGE) as->challenge = auth_getvalue(as, \"challenge\"); as->state = 0; as->index = 0; /* toss our data */ return (as->challenge); }\n\nauth_challenge, much like auth_verify is a function that acts as a front-end for auth_call, except used specifically for challenges.\n\nFirst the session as is checked. If it's NULL, or as->style is NULL, as->name is NULL, or if the username begins with a hyphen, or has a length of zero, the function returns NULL.\n\nThen the path to the auth module is created.\n\nsnprintf(path, sizeof(path), _PATH_AUTHPROG \"%s\", as->style);\n\nas->state and as->challenge are then reset, in case they were already set.\n\nThen auth_call is called, with the challenge style set.\n\nauth_call(as, path, as->style, \"-s\", \"challenge\", \"--\", as->name, as->class, (char *)NULL);\n\nas->state is checked for the AUTH_CHALLENGE bit, indicating the auth module has returned a challenge. If it's present, the challenge is extracted from the back channel output, and used to set as->challenge.\n\nif (as->state & AUTH_CHALLENGE) as->challenge = auth_getvalue(as, \"challenge\");\n\nas->state and as->index are then set to zero, discarding the data.\n\nas->challenge is then returned.\n\nint auth_userresponse(auth_session_t *as, char *response, int more)\n\n{ char path[PATH_MAX]; char *style, *name, *challenge, *class; int len; if (as == NULL) return (0); auth_setstate(as, 0); if ((style = auth_getitem(as, AUTHV_STYLE)) == NULL || (name = auth_getitem(as, AUTHV_NAME)) == NULL || !_auth_validuser(name)) { if (more == 0) return (auth_close(as)); return(0); } len = snprintf(path, sizeof(path), _PATH_AUTHPROG \"%s\", style); if (len < 0 || len >= sizeof(path)) { if (more == 0) return (auth_close(as)); return (0); } challenge = auth_getitem(as, AUTHV_CHALLENGE); class = auth_getitem(as, AUTHV_CLASS); if (challenge) auth_setdata(as, challenge, strlen(challenge) + 1); else auth_setdata(as, \"\", 1); if (response) { auth_setdata(as, response, strlen(response) + 1); explicit_bzero(response, strlen(response)); } else auth_setdata(as, \"\", 1); auth_call(as, path, style, \"-s\", \"response\", \"--\", name, class, (char *)NULL); /* * If they authenticated then make sure they did not expire */ if (auth_getstate(as) & AUTH_ALLOW) auth_check_expire(as); if (more == 0) return (auth_close(as)); return (auth_getstate(as) & AUTH_ALLOW); }\n\nauth_userresponse is used to pass the user's session and response from auth_userchallenge back to the authentication module. Similar to auth_userchallenge, it is also a front-end for auth_call.\n\nIf as is NULL, 0 is returned.\n\nThe state of as is then set to 0.\n\nauth_setstate(as, 0);\n\nas is then checked to ensure all the required items are set. It checks if as->style or as->name are NULL, or if the username is invalid using _auth_validuser. If any of those checks fail, and more is equal to 0, then the session is closed using auth_close, and the return value of that returned. Otherwise 0 is returned.\n\nThen the path to the auth module is created similarly to how it is created in auth_verify.\n\nThe challenge and class of the session are extracted and stored in variables challenge and class respectively.\n\nIf challenge contains data, its contents are added to the as->data spool, otherwise an empty string is added to the spool.\n\nIf response contains data, it is added to the data spool as well, and then respose is explicit_bzero'd. Otherwise an empty string is added to the data spool.\n\nNext auth_call is used to call the auth module with service type response.\n\nauth_call(as, path, style, \"-s\", \"response\", \"--\", name, class, (char *)NULL);\n\nIf the request is allowed, it's checked to make sure it's not expired using auth_check_expire.\n\nIf more is equal to 0, the session is closed using auth_close and the return value from it is returned.\n\nThe allow state of the session is then returned.\n\nreturn (auth_getstate(as) & AUTH_ALLOW);\n\nint auth_approval(auth_session_t *as, login_cap_t *lc, char *name, char *type)\n\n{ int close_on_exit, close_lc_on_exit, len; struct passwd pwstore, *pwd; char *approve, *s, path[PATH_MAX], pwbuf[_PW_BUF_LEN]; pwd = NULL; close_on_exit = as == NULL; close_lc_on_exit = lc == NULL; if (as != NULL && name == NULL) name = auth_getitem(as, AUTHV_NAME); if (as != NULL) pwd = auth_getpwd(as); if (pwd == NULL) { if (name != NULL) { if (!_auth_validuser(name)) { warnx(\"cannot approve who we don't recognize\"); return (0); } getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd); } else { getpwuid_r(getuid(), &pwstore, pwbuf, sizeof(pwbuf), &pwd); if (pwd == NULL) { syslog(LOG_ERR, \"no such user id %u\", getuid()); warnx(\"cannot approve who we don't recognize\"); return (0); } name = pwd->pw_name; } } if (name == NULL) name = pwd->pw_name; if (lc == NULL) { if (strlen(name) >= PATH_MAX) { syslog(LOG_ERR, \"username to login %.*s...\", PATH_MAX, name); warnx(\"username too long\"); return (0); } if (pwd == NULL && (approve = strchr(name, '.')) != NULL) { strlcpy(path, name, sizeof path); path[approve - name] = '\\0'; getpwnam_r(name, &pwstore, pwbuf, sizeof(pwbuf), &pwd); } lc = login_getclass(pwd ? pwd->pw_class : NULL); if (lc == NULL) { warnx(\"unable to classify user\"); return (0); } } if (!type) type = LOGIN_DEFSERVICE; else { if (strncmp(type, \"approve-\", 8) == 0) type += 8; len = snprintf(path, sizeof(path), \"approve-%s\", type); if (len < 0 || len >= sizeof(path)) { if (close_lc_on_exit) login_close(lc); syslog(LOG_ERR, \"approval path too long %.*s...\", PATH_MAX, type); warnx(\"approval script path too long\"); return (0); } } if ((approve = login_getcapstr(lc, s = path, NULL, NULL)) == NULL) approve = login_getcapstr(lc, s = \"approve\", NULL, NULL); if (approve && approve[0] != '/') { if (close_lc_on_exit) login_close(lc); syslog(LOG_ERR, \"Invalid %s script: %s\", s, approve); warnx(\"invalid path to approval script\"); free(approve); return (0); } if (as == NULL && (as = auth_open()) == NULL) { if (close_lc_on_exit) login_close(lc); syslog(LOG_ERR, \"%m\"); warn(NULL); free(approve); return (0); } auth_setstate(as, AUTH_OKAY); if (auth_setitem(as, AUTHV_NAME, name) < 0) { syslog(LOG_ERR, \"%m\"); warn(NULL); goto out; } if (auth_check_expire(as) < 0) /* is this account expired */ goto out; if (_auth_checknologin(lc, auth_getitem(as, AUTHV_INTERACTIVE) != NULL)) { auth_setstate(as, (auth_getstate(as) & ~AUTH_ALLOW)); goto out; } if (login_getcapbool(lc, \"requirehome\", 0) && pwd && pwd->pw_dir && pwd->pw_dir[0]) { struct stat sb; if (stat(pwd->pw_dir, &sb) == -1 || !S_ISDIR(sb.st_mode) || (pwd->pw_uid && sb.st_uid == pwd->pw_uid && (sb.st_mode & S_IXUSR) == 0)) { auth_setstate(as, (auth_getstate(as) & ~AUTH_ALLOW)); goto out; } } if (approve) auth_call(as, approve, strrchr(approve, '/') + 1, \"--\", name, lc->lc_class, type, (char *)NULL); out: free(approve); if (close_lc_on_exit) login_close(lc); if (close_on_exit) return (auth_close(as)); return (auth_getstate(as) & AUTH_ALLOW); }\n\nauth_approval is used to check a user against the approval script for service type. It is a front end for auth_call. Approval script types all begin with approval-.\n\nBefore running the scripts, first the validity of the account is checked. This is done first using auth_check_expired, then _auth_checknologin, and finally login_getcapbool to ensure the user has a home directory if one is required by their login class.\n\nIf type doesn't begin with approval- it will be prepended internally.\n\nif as is NULL, an auth session will be created and destroyed inside the function.\n\nIf lc is NULL, it will be retrieved internally by looking up name.\n\nIf type is NULL, the default of LOGIN_DEFSERVICE is used. This is defined in login_cap.h as login. This should call the default approval script, according to the CAPABILITIES section of the login.conf man page.\n\nIt returns either 0 for disapproval, or non-zero for approval."
    }
}