{
    "id": "dbpedia_6156_3",
    "rank": 38,
    "data": {
        "url": "http://lambda-the-ultimate.org/node/1243",
        "read_more_link": "",
        "language": "en",
        "title": "Lambda the Ultimate",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://lambda-the-ultimate.org/node/themes/chameleon/ltu/tagline.png",
            "http://lambda-the-ultimate.org/misc/xml.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "My problem with people like him is that they are too evangelical...\n\nMaybe that's because they've found something that was very liberating and they want others to experience the same feeling?\n\nThat said, I agree with your sentiments. I've never really understood why people consider Java/C# to be \"languages for the masses\" or \"languages for the mediocre\" and Lisp/Scheme to be \"languages for the elite.\" Scheme and Common Lisp are arguably much simpler than C#. In fact, when I first learned Lisp, my first thought was \"This is so simple, you don't even have to hardly think about how to write a solution: you just write down what your thinking.\" When I program in Common Lisp and especially Scheme I rarely have to think about syntax, instead I focus on the problem at hand; this makes my life simpler: I just do it. (Side note: there are some features of Common Lisp I really like, but some need to removed: Scheme code always feels so much more simple and elegant to me.) C#, however, is a different story. When I code in C#, I am always concerned with two things: syntax, and how to convert the problem from a natural (for me) solution in to one that C# will understand (since Scheme and especially Common Lisp support multiple ways of thinking problems can generally be expressed close to their \"natural\" form in these languages). In fact, C# is so complicated that I wouldn't even think about writing a program without Visual Studio: doing so is pretty much impossible. Now granted with Visual Studio, C# is a fairly simple language but, my question is: how much simpler and more productive could languages like Scheme and Common Lisp be in a similar environment? (Dr. Scheme is a really cool Scheme environment that is fairly powerful.) The major problem with Scheme and Common Lisp (and many languages with non-imperative features/ideas) is the learning curve. Once you get past the fundamental ideas (functions as first class objects, the parenthesis, functional programming style, etc.) it's easy, and youâ€™ll find yourself thinking in that mode, at which point you find yourself able to just write down the solution much easier than you could with a more syntax bound language). Until then, you might find the language difficult if you've trained yourself in a different paradigm.\n\nI wasn't joking, trolling, or playing any other games. I was dead serious.\n\nlike \"set foo=2\" (DOS) vs \"foo=2\" (bash)?\n\nExplanations like that are useless to me, because the poster didn't first tell me how to determine if I was using bash. Nor did the poster tell me what the syntax would be for a non-bash shell.\n\nAn aside, how would I find that information? The man pages assume that you already know the name of the command you want to use, and some (i.e. this example) donâ€™t even really have a name. With Windows, I can at least to type Help to see a list of common commands.\n\nAs for vi and emacs, why don't they have the same capabilities as DOS edit?\n\nThis is a real issue many facing many products. Why did the developers spend so much time of the advanced stuff, while neglecting the basics that would have made them accessible to the majority of users? I can see no reason why vi or emacs cannot have the same features as DOS edit in addition to their advanced capabilities.\n\n\"If the average user cannot figure out how to use a feature, that feature doesn't exist for the average user. Thus for the average user, Unix has less features than a typewriter without a backspace key.\"\n\nthe average user is average for a reason.\n\nI find this sort of attitude to be very juvenile and unprofessional. Average implies 50%; if 50% of my target audience finds that my program is too hard to use, then I did something seriously wrong.\n\nOperating systems like UNIX and Linux donâ€™t have chance in the general marketplace because the developers are too lazy to make their programs easy to use. Ease of use is a hard problem, and frankly not very interesting, so I understand why it is often neglected. But for professionals, that is not a valid reason for not doing the right thing. They are getting better, but the command line interface still needs a complete overhaul before the average user can touch it.\n\nAgain, that is the kind of attitude I find to be very detrimental.\n\nThere are lots of cases where the more powerful choice is the more difficult to learn. A manual transmission gives you more power (because it gives you more control) than an automatic. Thats not a bad thing, its just different.\n\nIn computing, a program (or programming language---the off topic thread comes full circle and is now on topic for LTU!) is powerful when it lets you do what you need to do, but that requires learning how to use the program. Sure, given two equally powerful programs it is perfectly reasonable that one might be easier to use than the other (in which case the easier one might be the better choice). To be so easy that a person could use it without having to learn a whole system, requires that the program do what you desire of it for you. That requires the program to know what you want. Unfortunately, it is very difficult (I argue impossible) to foresee every possible use of a particular program, hence that program will be less powerful than one that gives you more power via what is essentially a DSL (even if it is a graphical one).\n\nIn regards to the audience, a text editor is one of the core utilities in any operating system that every person has to use on a regular basis.\n\nYes.\n\nTherefore, any text editor should be usable by every person.\n\nNo.\n\nI agree that there should be a text editor on the system usable by every person, but not that every text editor be usable by every person. Earlier you were complaining about vi and emacs. Now, if those were the only options, you might have a point, but their not. Most UNIX systems have alternatives to vi and emacs, for example: cat and ed (I kid! I kid!). Seriously, there are more user friendly alternatives out there besides vi and emacs. Personally, for quick and dirty editing, I like to use vim. (I'm an oxymoron: I like vim better than emacs, and I like Lisp too!) Now, most people who know how to use vim and emacs can tell you that they are more powerful than a plain old text editor. To make them usable by every person would require that most of that power be taken away. For example, one of my favorite things about vim is its easy navigation and editing commands (hjkl for moving around, p for paste, etc.). I like these commands much better than the ctrl-this ctrl-that of some editors (ehem...emacs) and the mouse driven commands of other editors. Now, in order for this to work properly, vim has to have different modes of operations. At this point we've gone past the point of usability of the average user. But you take away the modes to make it usable by the average user, and you take away one of the most powerful features of vim.\n\nEarlier it was stated that the average user is average for a reason. This is true, but not in the sense you might think. Its not me being arrogant or anything. The average user isn't stupid. They are more than intelligent enough to learn vim. Its just that they are uninterested. They are mentally lazy. They don't want to learn how to use a program, they just want to use it.\n\nI'll tell you a secret, okay? I didn't learn how to drive until I was 20 years old. Now, I'm not stupid. I'm not of such low intelligence that I couldn't figure out how to drive until I was 20 years old. No, I was simply uninterested. I learned how to drive, not because I had a burning desire to drive across the country, but out of necessity. I don't like to drive to this very day. I do it because it is a necessary part of the modern life, especially where I live: a fairly rural area with no public transportation. But you know what? I had a desire (I wanted have the ability to go to work, the store, and other places without having to rely on other people), but in order to meet that desire, I had to get a car. Now, what do you suppose an honest car dealer would tell me if I said to him, â€œI need a car that is easy to drive, one that will just work.â€? It sounds like such a reasonable request, but anybody who owns a car can tell you such a request is impossible to satisfy. If I want a car, I'll first have to learn how to use it. Driving is hard. I would argue it is much harder to learn how to drive than it is to learn the basics of text editing with vim. Driving requires coordination and you have to have an ability to focus on the road while at the same time watching around the vehicle for dangers. Now if I simply learned how to drive, I would be partly there, but I still might be surprised to learn that I was suppose to periodically get my oil changed when my engine goes bad, or that I was suppose to keep an eye out for bad/low tires, when one blows on the highway.\n\nAs far as tools go, some tools are for professionals, and some are not. I am an average cook. I'm average for a reason (You guessed it: I haven't put forth the effort to become better than average!). I would be lost if you put me in a professional chef's kitchen. I wouldn't know the first thing about how to use the equipment, but there is no doubt in my mind that the equipment is much more powerful than the equipment I have in my kitchen. You wouldn't expect that a professional chef use the same tools that I use, would you? Or that his tools be easy enough for me to just walk in there and start using them? No, that would be absurd! There is no way his tools could be that simple, unless if they were preset to do certain things that I understood. But, if they did that, then they would no longer be powerful tools, because they could only do what the builder of the tool envisioned, and not what the chef envisioned.\n\n\"Nor did the poster tell me what the syntax would be for a non-bash shell.\"\n\nAnd how did you know what was the DOS syntax in the first place?\n\n\"An aside, how would I find that information? ...With Windows, I can at least to type Help to see a list of common commands.\"\n\nSo, you never used a computer before and it shows you nothing more than a black screen and a blinking text cursor. You type \"hello\". Nothing happens. \"hi\" doesn't work either. \"obbey my commands, stupid machine\", nothing yet. \"aaaaarrrgggh\" is no use.\n\nFinally, in total despair, you type \"help\"Â´and the few DOS commands are available to you, in alphabetic order. Yeah, definately better than \"man\" and its \"What manual page do you want?\" and not accepting page \"numbers\".\n\nThat's why, i guess, the FSF opted for the much more approachable \"info\" documentation system. I guess it could be the guy's second choice after \"help\".\n\n\"As for vi and emacs, why don't they have the same capabilities as DOS edit?\"\n\nNow, you either is really trolling or just playing dumb. I imagine you're talking about drop-down menus? Both emacs and gvim provide them for the novice.\n\n\"Why did the developers spend so much time of the advanced stuff, while neglecting the basics that would have made them accessible to the majority of users?\"\n\nThe original Unix command set was not created with \"the majority of users\" in mind. Actually, they were developed way before computers went mainstream among the general non-technical population and \"the majority of users\" were computer technicians indeed.\n\nMost modern *nix projects, like KDE, GNOME and othersm though, are far more approacheable for non-technical people.\n\n\"Average implies 50%; if 50% of my target audience finds that my program is too hard to use, then I did something seriously wrong.\"\n\nDo not suffer this much. If you were designing an intercontinental plane, you're not supposed to make it so that _any_ person can pilot it. Sometimes, the goal is to have power at the expense of ease of use. Those who wish to harness such power will have to train themselves at it, study it.\n\n\"the command line interface still needs a complete overhaul before the average user can touch it.\"\n\nIt will happen when AI is advanced enough so that it can disabiguate human language phrases. But then, people will likely feel better talking to their machine rather than typing at a keyboard, so that the command-line interface will always be better enjoyed by technical people anyway, who wants their stuff done directly without much intervention from an eletronic nanny..."
    }
}