{
    "id": "correct_subsidiary_00029_2",
    "rank": 87,
    "data": {
        "url": "https://gektor650.medium.com/underwater-drone-the-story-of-the-madness-355d1c53ddc9",
        "read_more_link": "",
        "language": "en",
        "title": "DIY. Underwater drone. The story of the madness",
        "top_image": "https://miro.medium.com/v2/resize:fit:920/1*_EriExQzFfFCDQw0PRt8ow.jpeg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:920/1*_EriExQzFfFCDQw0PRt8ow.jpeg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/2*4B5lwJs6kSkP6N5k20tO8w.jpeg",
            "https://miro.medium.com/v2/resize:fill:144:144/2*4B5lwJs6kSkP6N5k20tO8w.jpeg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Ievgenii Tkachenko"
        ],
        "publish_date": "2019-02-03T13:03:05.288000+00:00",
        "summary": "",
        "meta_description": "I’ve watched a lot of programs about inventors on Discovery channel and once I decided to do something interesting by myself so that it could be really impressive and difficult at a time: some…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/1*m-R_BkNf1Qjr1YbyOIJY2w.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://gektor650.medium.com/underwater-drone-the-story-of-the-madness-355d1c53ddc9",
        "text": "I’ve watched a lot of programs about inventors on Discovery channel and once I decided to do something interesting by myself so that it could be really impressive and difficult at a time: some electric motors, controllers, handling, camera. After buying a lot of useful (and not very useful) stuff, I began to think what kind of project should I start. Finally, I came to the conclusion that there are a lot of flying and driving drones, but it’s not about underwater drones (haha, but as I understand now, I was terribly wrong then).\n\nAfter surfing the Internet, I found several interesting projects, but most of them were either in the development stage or they were not to come cheap (3k++ dollars). Those who are interested in these projects can find some here.\n\nLooking ahead, I can say that I’ve got a working prototype that can swim several meters deep, although it has its pros and cons. I can’t assert that finally, I’ve got easy-to-control stuff or stuff that can do more than just to calm down my engineer enthusiasm. But all the units of this stuff work properly, and it is very important that my mistakes and experience can help someone to create something really significant (even if it will be significant only for himself\\herself).\n\nAs there was done a good deal of work, this article can be divided into the following chapters:\n\nCrazy idea (teaser)\n\nChoosing the components\n\nESC programming\n\nRaspberry PI Server configuration\n\nElectric motor handling using Raspberry PI\n\nGyroscope\n\nRaspberry PI Flashlight control\n\nClient-server communication protocol\n\nApplication for Android\n\nVideo stream\n\nScreen and joystick control\n\nConstruction assembling and testing\n\nConclusions\n\nCrazy idea (teaser)\n\nWell, Firstly I want to say that I am an amateur, and most of things I did, were done by scientific trial and error, because it is fun for me to construct something and test it, than to allow for all possibilities and understand, that it won’t work in theory. There was a variety of possible projects and ideas, and among them, there were really absurd ideas (one of them will be described below, just for fun). The first and the main task for me was to construct sealed housing in domestic conditions and at the same time to transmit torque to the driving propeller. As it usually happens, the ideas, in the beginning, are not the smartest one (and I’m not used to thinking twice), so I tried an experiment with transmitting the torque using magnets. I’ve chosen the simplest design and constructed such a “high-tech” device:\n\nTwo magnets were screwed in gear and connected to the electric motors (respecting the polarities of the magnets), there is a plate between the gears which imitates the walls of the housing. If you have a desire to close the article and poke out your eyes after seeing this, this is a normal reaction, but I warned you at the beginning :) Despite some defects, after launching the model, you can surely say: “And yet it moves” ©.\n\nThe torque is transmitted, the parts rotate, but magnetism increases friction. One more drawback, apart from dozens of others, is that if you stop an imaginary screw, then the magnets will lose their contact and won’t stick together one more time due to the speed difference\n\nIt won’t be the best idea even if you assemble such a model using bearings, gears and magnets, because efficiency, ease of implementation and just common sense are weak points of this model.\n\nFinally, it was decided not to rack brains and take the brushless motor, and if necessary, cover the motor winding with varnish. So the idea was to put the wires out of the housing right into the water and just to seal them. It would be much easier than to construct a model with oil and oil seals or some other complicated mechanism in order to keep mechanic and electronic parts away from water.\n\nSo let’s move on to more important things.\n\nChoosing the components\n\nBelow you’ll find a list of different stuff that was used to create the device.\n\nMotherboard\n\nAmong the variety of controllers, I’ve chosen Raspberry PI 3B. I would not recommend Arduino-like boards for this project, because it won’t manage such a complex task, as it is necessary to control at least 4 motors, diodes, gyroscope, send video stream from the camera and at the same time receive and process commands from control devices. Raspberry PI 3B comes with built-in Wi-Fi and Ethernet for RJ-45 connector, what will undoubtedly help you with all these operations.\n\nCommunication channel\n\nWell, yes, you are right, a twisted-pair wire. It was always difficult to transfer the data under the water. Water is an excellent shield, and, therefore, you can forget about any wireless data transfer (fans of “and what about submarines” — please find out what is the size of the antenna for implementation of such a transfer and the cost of technology, complexity and width of the transmission channel). So there was no other way out. There was a checklist that was successfully passed:\n\nThe ability to transfer data under the water.\n\nThe speed of data transfer under the water.\n\nUniversalism (it perfectly fits Raspberry PI 3B and the transmitter).\n\nThere is a special cable for water with neutral floating and, but you can’t buy 100 meters separately, and I did not want to spend 500+ dollars on a reel.\n\nBase transmitter\n\nNEXX mini router There were 3 main options of transfer:\n\nTry to wire a Wi-Fi antenna from water to land (in this case instead of a twisted-pair wire a solid wire should be used), but there were a lot of controversial points.\n\nCreate a client-server bridge connection between two Raspberry PI 3B (it would be appropriate, but more expensive and troubling).\n\nConnect a mini-router with Raspberry using a twisted-pair wire. This option was taken as the basis, as it is the most reliable, fast and cheap. Experience has proven that this is quite a good option.\n\nElectric motor\n\nN2830/2212 1000KV\n\nAfter testing 3 different motors, I chose this model. You may ask why? Well, it is powerful enough, it has a second axis so you can use 2 propellers. In general, all motors operate normally in water until the algae or sand get inside the motor. If you choose high-speed and less powerful one, you’ll find out that these types of motors are not the best fit for water. Cheaper motors also fell short of expectations. Well, the quality meets the price.\n\nControl board (ESC)\n\nAfro ESC (30A)\n\nIt’s also pretty simple. It can be programmed to switch forward/reverse, and the power of 30 amps should be enough for the tested motors. Besides, I did not have to wait for it for a month or two to deliver it from China (but, of course, there is one catch :) ).\n\nAfro ESC USB programming tool\n\nProgramming tool for ESC. With this device you can upload the necessary firmware. But actually, this is the catch. I had to wait a month and a half for it.\n\nLED\n\nCREE XHP50\n\nThis model is intended to burn out everything with its light. So, this was the goal.\n\nLED pulse driver\n\n7–30В 3А or similar\n\nThis is a perfect fit for our purposes — it holds two above-mentioned LEDs, and it also connects to the Raspberry and allows you to adjust the brightness of the LED.\n\nGyroscope\n\nMPU-6050\n\nA three-axis gyroscope/accelerometer that will send location data to the Raspberry. There was some data, but it was not very useful ☺.\n\nCamera\n\nRPi Camera F\n\nYou can use any other native Raspberry PI camera. The main condition is that it should be connected via FFC, not USB. Video streaming always was a big problem (delays, coding), or rather, it’s not a problem, it just needs a lot of time to get started.\n\nJoystick\n\niPega PG-9055 — additional control assistant, in case your hands are wet, and believe me, they will be wet, you can control the drone using this device.\n\nBattery\n\nTurnigy 2200mAh 3S 30C\n\nAnd again there was a lot of tests. 18650 battery did not fit, because the controller had a 25A discharge rate, which was not enough for the entire system during peak load conditions (yes, a couple of batteries died a hero’s death after use). It was possible to try using 6 batteries and get 50A, but it is more difficult. Such a DC power cannot be transmitted using the wire (don’t forget about 100 m distance). So I bought Li-Po, which elegantly coped with its tasks and perfectly fitted into the housing.\n\n…And other stuff\n\nDriving propellers (one of the main problems)\n\nCable Gland\n\nHousing\n\nHousing\n\nAnd also housings, connectors, wires and other stuff.\n\nESC programming\n\nUnfortunately, a brand new Afro ESC rotates only in one direction, so you need to update a firmware. The problem is that you have to wait for linker to be delivered from China, everything else is not so important. Let’s suppose that you already have it :) Surfing the Internet I have found one good advice — not to damage your laptop in case of short circuit you can buy a USB hub. But it is for you to decide ☺. We need to download the firmware file to the disk and the KKMulticopter Flashtool for firmware update.\n\nNow it is important to connect wires correctly, otherwise one of devices can break down.\n\nHere you’ll find some short instructions on how to connect wires correctly:\n\nA pair of red and black thick wires with a male connector on its end. It is a general power supply. In this case, provided power will be 12V and the amperage which is needed for it.\n\nRed — Input port “+”.\n\nBlack — Input port “-“.\n\nA the of kind thick red-black-yellow wires are in charge of a motor power supply. We won’t connect them now, but later we will connect these wires to the wires of the electric motor with similar colors.\n\nThin wires are in charge of control the board.\n\nA control signal is transmitted via a yellow wire.\n\nA red wire is output 5v (I did not use it). There are several different types of them, you can learn more about it here.\n\nThe black wire should be connected to port “-”.\n\nSo let’s connect thin wires to the Linker: connect black wires together (minus) and yellow wires (signal). Don’t touch or connect together red wires. The next step — provide power supply to the board (black and red thick inputs). I used this static power supply unit, but any other with similar characteristics will do (12V, 2+A).\n\nOpen the tool for firmware update and select:\n\nProgrammer: Turnigy USB Linker or Afro USB Linker (depending on what stuff you have).\n\nPort: choose the connected USB port. Fortunately, there are only few options.\n\nBaud rate: 9600.\n\nController: atmega 8-based brushless ESC (8kB flash).\n\nSelect the downloaded firmware file. Click the “Run” button and pray :)\n\nSoon the firmware will be successfully uploaded to ESC, and everything will be ready.\n\nYou can watch the whole process here:\n\nOnly one out of the 8 ESCs that I programmed has died :)\n\nRaspberry PI Server configuration\n\nNow let’s move on to the Raspberry PI configuring.\n\nDownload the latest system installation package here.\n\nDownload and install Etcher.\n\nInsert formatted micro SD flash drive into the card reader.\n\nOpen Etcher and select zip or img Raspbian, which you downloaded during the first step.\n\nClick the “Flash” button.\n\nWait for the installation to be completed and remove the micro SD.\n\nInsert the USB flash drive into your Raspberry.\n\nTo perform the tests we will need Raspberry, any Android smartphone and Wi-Fi router with the access to the Internet. If you are a console communication fan, then I don’t need to explain you anything, you can do it yourself. For those who don’t know how to do it: connect the monitor, the keyboard (HDMI and USB port) and provide power supply from any USB-micro-USB and boot the system. It is important to remember that for all motors the power supply should be 12V, and for Raspberry — 5V. It is also important to remember that if you turn off the power on the Raspberry, the operating system can be damaged (this is related to device memory). So I would advise you to think about the power supply unit for Raspberry.\n\nThen connect to the Wi-Fi network, and after that the system will be ready. I would advise you to configure your router and provide a static IP address for the Raspberry, because the connection should be maintained via IP. If you have some experience of working with Linux, then you should know what will be the next steps.\n\nThe easiest way to create a server application is NodeJS. I won’t be difficult, as all the necessary info can be found using Google Search.\n\nOpen the terminal and type:\n\nsudo apt-get update\n\nsudo apt-get dist-upgrade\n\nsudo apt-get install -y nodejs\n\nAnd then start node -v, in order to understand that everything works properly. I can leak the whole project from the repository and run it (you’ll find a link below) but it would not be intriguingly. Now you should create the folder for your project:\n\nmkdir ~ /drone\n\nand open it:\n\ncd ~ /drone\n\nand then initialize the project:\n\nnpm init\n\nAt the end of the installation process, the installer will ask you to enter the name and the index file — it should be app.js. After initialization, you should install set express:\n\nnpm install express\n\nCreate the file app.js:\n\ntouch app.js\n\nFor those who used to work with the GUI (monitor and keyboard), I would advise you to install Atom. It is very convenient to write js-code using it. For the others, there are a lot of other tools: Vim, Nano, MCEdit.\n\nNext step: add the code to app.js and save the file:\n\n'use strict';\n\nconst express = require('express');\n\nconst net = require('net');\n\nconst app = express();\n\nconst server = net.createServer((socket) => {\n\nsocket.on('data', (data) => {\n\nvar command = data.toString();\n\nconsole.log(err);\n\n});\n\n}).on('error', (err) => {\n\nconsole.log(err);\n\n// handle errors here\n\n// throw err;\n\n});\n\nserver.timeout = 0;\n\n// grab an arbitrary unused port.\n\nserver.listen(49655, () => {\n\nconsole.log('opened server on', server.address());\n\n});\n\nThen you should run node app.js in the folder “drone” using console.\n\nNow you have an operating server which works with 49655 port. Remember your local IP (ifconfig in console) and all the connections will be performed in IP:49655.\n\nNow let’s do something more difficult.\n\nElectric motor handling using Raspberry PI\n\nSo, let’s begin the most interesting part of our work — we should write a code for Raspberry PI control. Find the project folder ~ /drone and install the PiGpio library there:\n\nsudo apt-get update\n\nsudo apt-get install pigpio\n\nnpm install pigpio\n\nNow I will provide you with some short information on ESC control. We should transfer a certain frequency to the thin yellow wire (control) (see section “ESC programming”). The afro_nfet_besc30_r1 firmware has a range of 1100–1900, where the value 1500 is a calm state, 1100 maximum reverse, 1900 maximum forward. Create the file engines.js and add the JS code into it:\n\n//Calm state constant\n\nconst SERVO_ZERO = 1500;\n\n//Connect 'pigpio' library\n\nconst Gpio = require('pigpio').Gpio;\n\n// Define 4 motors using Raspberry pins (this process will be described below)\n\nconst servo1 = new Gpio(22, {mode: Gpio.OUTPUT});\n\nconst servo2 = new Gpio(10, {mode: Gpio.OUTPUT});\n\nconst servo3 = new Gpio(9, {mode: Gpio.OUTPUT});\n\nconst servo4 = new Gpio(27, {mode: Gpio.OUTPUT});\n\n//Set each board into the state of \"calm\"\n\nservo1.servoWrite(SERVO_ZERO);\n\nservo2.servoWrite(SERVO_ZERO);\n\nservo3.servoWrite(SERVO_ZERO);\n\nservo4.servoWrite(SERVO_ZERO);\n\n//After that you should enter the value into ESC\n\nmodule.exports.engines = {\n\nleftEsc: (value) => {\n\nservo1.servoWrite(value);\n\n},\n\nrightEsc: (value) => {\n\nservo2.servoWrite(value);\n\n},\n\ntopLeftEsc: (value) => {\n\nservo3.servoWrite(value);\n\n},\n\ntopRightEsc: (value) => {\n\nservo4.servoWrite(value);\n\n}\n\n}\n\nIn order to use this code, you should write in app.js:\n\nconst engines = require('./engines.js').engines;\n\nengines.leftEsc(VALUE[1100;1900]);\n\nActually this part of code servo1.servoWrite() is in charge for control. 1100 — the motor turns in the reverse direction, 1900 — maximum forward.\n\nAnd here you can find the Raspberry pin scheme:\n\nIn short, you should use orange GPIO. One pair consists of GPIO 10 and GPIO 22, the second is GPIO 9 and GPIO 27 (it would be more logical to use 27, 22 and 10 -9, but I did not take it into account when soldering, so I had to change it). If taking into account ordinal numbers (they are grey), then these are 13, 15 and 19, 21 contacts. You should connect yellow wires from ESC to each of them, and minus should be connected into one GND, for example, 39 contact. And now let’s connect the other stuff.\n\nConnect the power supply wires (red and black) from Afro ESC to a separate power supply unit (12v), connect the motors to the yellow-red-black thick wires and can now you can try how it works.\n\nHere you can find some video of the process described above:\n\nHowever, the control in this video is performed using Android smartphone, but I will describe this later.\n\nGyroscope\n\nThis is how do you should connect:\n\nVCC to the pin 1 (3.3V PWR)\n\nGND to any minus\n\nSCL to pin 5 (GPIO 3)\n\nSDA to pin 3 (GPIO 2)\n\nIt won’t be difficult to connect everything correctly, and if talking about software — it would be even simpler — all the information can be easily found in the Internet. Here you should use i2c-bus и i2c-mpu6050 libraries. Install them into the project:\n\nnpm install i2c-bus\n\nnpm install i2c-mpu6050\n\nCreate the file gyroscope.js and add:\n\nconst i2c = require('i2c-bus');\n\nconst MPU6050 = require('i2c-mpu6050');\n\nconst address = 0x68;\n\nconst i2c1 = i2c.openSync(1);\n\nconst sensor = new MPU6050(i2c1, address);\n\nvar reading = false;\n\nvar sensorData = {};\n\nmodule.exports.gyroscope = {\n\ngetData : () => {\n\nreturn JSON.stringify(sensorData);\n\n},\n\nreadRotation : () => {\n\nsensor.readRotation(function (err, rot) {\n\nif (err) {\n\nconsole.log(e);\n\nreturn;\n\n}\n\nconsole.log(rot);\n\n});\n\n},\n\nreadSensor : () => {\n\nif (!reading) {\n\nreading = true;\n\n}\n\nsensor.read(function (err, data) {\n\nreading = false;\n\nif (err) {\n\nconsole.log(err);\n\n} else {\n\nsensorData = data;\n\n}\n\n});\n\n}\n\n}\n\nRun the readSensor method with some frequency and get the data of the last survey from getData. There will be many position components (x, y, z, a). I didn’t have enough time to define the meaning of this components, as I had more important task — handling. I know that it would be better to investigate it, but the relevance of the result is not very important for this project in that time.\n\nRaspberry PI flashlight control\n\nSo, let’s continue to increase the functionality of our drone and now I will tell you about LEDs. I have two XHP-50 LEDs and LED pulse driver (see the table above). They can be easily overheated, so I would recommend you to use them together with radiators. You can find them in the same online shop, the main thing is not to forget about dimensions. So, attach the LEDs to the radiators, solder the minus of one LED to the plus of the other LED (they are marked) using wire and solder the — and + wires:\n\nThen you should look at your controller and solder:\n\nPower supply — 12V plus and minus, you can use the same input as for the motors. LED connectors should be connected to the previously soldered connectors, L- to minus, L+ to plus. In this situation we don’t need the analog contact (A), so don’t connect it.\n\nNow we are interested in digital input (D) and earth input (G). Now you should connect the digital input (D) with the GPIO11 and ground input (G) with GND (you can choose any you want on the Raspberry).\n\nNow let’s return to Raspberry PI, create a file light.js and add the following:\n\n//Again the same library\n\nconst Gpio = require('pigpio').Gpio;\n\n//Create Gpio for your pin\n\nconst light = new Gpio(11, {mode: Gpio.OUTPUT});\n\n// You can set the value starting from 0 to 255 (I have found this info in the LED driver instructions)\n\nconst LIGHT_MIN = 0;\n\nconst LIGHT_MAX = 255;\n\n//It will be needed for calculations\n\nconst LIGHT_DIAPASONE = LIGHT_MAX - LIGHT_MIN;\n\n// Turn off the LED (the system starts with the LEDs turned on to maximum)\n\nlight.pwmWrite(LIGHT_MIN);\n\n//Export work methods\n\nmodule.exports.light = {\n\non: () => {\n\n//Transmit the value 255 to the driver\n\nlight.pwmWrite(LIGHT_MAX);\n\n},\n\noff: () => {\n\n// Transmit the value 0 to the driver\n\nlight.pwmWrite(LIGHT_MIN);\n\n},\n\n//Here will be the percent value from 0 to 100\n\nset: (val) => {\n\nif(val < 0 || val > 100) return;\n\n//Calculate the value based on the percentage\n\nval = Math.round(LIGHT_MIN + LIGHT_DIAPASONE / 100 * val);\n\nconsole.log(\"Light:\"+val);\n\n//Transmit the value to the driver\n\nlight.pwmWrite(val);\n\n}\n\n}\n\nWe can run it using app.js or using engines:\n\nconst light = require('./light.js').light;\n\nlight.on();\n\nlight.off();\n\nlight.set(50);\n\nVideo of what I’ve got:\n\nWhen you get the main idea, then everything becomes extremely simple: connect, give a signal, observe the result. Loosely speaking, this is the functionality that we need to activate the elements. But all this is useless without some kind of controller, which will turn on/regulate all this stuff, and this suggests that it is necessary to build communication between the server and the client. So we should invent a protocol :)\n\nClient-server communication protocol\n\nAs you understand from the initial configuration of Raspberry PI, communication will be performed using socket connection. And you will also need some set of commands that will be hard-coded in the server and client. And as I do everything by myself, I decided to use my own format, because the options that exist do not quite match the weight/readability criterion. So let’s build up taking into account the control model, and in this case it would be Android smartphone.\n\nHere you can find the model itself (the app will be described below).\n\nThe screen is divided into two parts. The left part stands for the horizontal axis (back and forth), the right part stands for the vertical axis. If you put your finger in some area this will be considered a reference point and control by a pair of motors, but it is also a “calm” point.\n\nIf you slide your finger vertically up, the rotational speed of both motors in the forward direction will slowly increase with power from 0 to the maximum (depending on the distance from the contact point to the current point).\n\nIf you slide your finger down, both motors will rotate in the reverse direction at a speed, which depends on the distance from the contact point.\n\nIf you slide your finger right, the left motor will spin forward and the right motor in the reverse direction. So, in fact, we need to know the angle of deviation from the contact point (where top = 90, bottom = 90, right= 0, left=180) and the speed ratio — the distance of the finger from the contact point (from 0 to 100). Object commands should look like this:\n\nC:L;A:45;V:35;\n\nC:R;A:0;V:100;\n\nC:LIGHT;V:50;\n\nС — (command), any command should start from this letter;\n\n: — a separator for key-value;\n\n; — a separator for key-value pairs;\n\nL — means that the touch was performed in the left part of the screen;\n\nR — means that the touch was performed in the right part of the screen;\n\nLIGHT — stands for light :)\n\nA — ANGLE, an angle of deviation;\n\nV — value, a value of something.\n\nSo, the first command sounds like: “A horizontal pair of motors, direction — 45 degrees (left motor at maximum speed (but the maximum is 35%, based on V), right motor stops), with a rotation speed of 35% from maximum”.\n\nThe second command: “Vertical pair of motors, direction — 0 degrees (left motor at maximum speed, right motor at maximum speed in reverse direction), with maximum rotation speed”.\n\nThe third command: “Turn on the light at 50% brightness”.\n\nThis is how it works when you send separate commands in key-value blocks via socket for every value change. Then magically it turns into commands on the control board. Explaining of the conversion of this data will be very boring. So everyone can try to study it out by himself/herself and get a grasp on controller.\n\nApplication for Android\n\nFinally, we’ve reached the moment when we will try to create a controller. In general, the communication means: “clicked on something on the screen — transmitted the value to the server”. I’ll write a few words about the application. There is nothing unusual or exceptionally challenging, so I will not post all the code. If you wish, you can visit the repository and find the needed information. I also want to note that I didn’t use any of the newfangled patterns like MVVM, MVP, VIPER, etc., as I needed a working app in the shortest time. UI is as simple as possible.\n\nFirst of all you should create an activity with status display views. The layoutwill be the following:\n\nVideo display layer (player encapsulated in a fragment).\n\nThe JoystickView layer is a custom view in which the dispatchTouchEventmethod is overridden and it processes the pressing and moving of fingers on the screen. It draws UI-lines from the pressing point to the current state. A multitouch support is mandatory, since the control is performed with two fingers.\n\nA layer with the TextView of the current temperature of the Raspberry PI (if something goes wrong and it starts to overheat, you can stop using it before it turns off/burns). Fortunately, this haven’t happened with my Raspberry.\n\nLayer of data displaying from the gyroscope. The TextView set in label-value pairs. It displays “raw data” from the gyroscope. It was planned to process this data, but I haven’t enough time to do it and to invent a cool displaying of it.\n\nA SeekBar layer — LED control, a simple element, it changes the value from 0 to 100 when dragging it.\n\nVideo stream\n\nI’ve tested a lot of methods of video streaming. I’ve dropped HLS, because of 10 seconds delay. it was possible to achieve 5 seconds delay, but it was far from satisfactory. When controlling the underwater drone, it is critical to stream video with minimal delay. But it is not so difficult to stream the video as from the Raspberry side and also to Android. RTMP would be more difficult. But the problem is that there was no particularly simple way to implement it on Android platform (as of the end of 2017). There were many fee-based analogs, which also required much time and efforts, there was the VLC, which needed to be compiled using C++ and needed configuring, there was also a compiled VLC library, which was not working properly. And if I would mention that it was like a hobby and it was done in the evening after work hours, when I was tired a little bit and I had + -2 hours, so I discarded these options. So I found a very good solution that suited all parameters. RPi Camera Viewer for Android is an app that receives Raw H.264 stream from the camera and displays it on TextureView using native MediaCodec. To be honest, I did not completely learn the whole display logic, but I’ve modified it for my convenience. Actually, the main part in Android is DecoderThread. It connects via IP and port, decodes the stream and transmits it to Surface, and in case of a break or error, it attempts to reconnect every 2 seconds. For Raspberry the stream start command will be the following:\n\nraspivid -t 0 -w 1280 -h 720 -hf -ih -fps 10 -o - | nc -k -l 2222\n\nRaspivid is a command that “captures” video from a connected camera (connected not via USB, but via FFC cable). I’ve chosen the parameters by scientific trial and error. Video quality 1280×720, frame rate 10fps. It’s too bad, but with minimum delay. And the stream that is transmitted from the camera is transmitted unchanged by the command Netcat to the port 2222. An Android app connects to it and processes the video, displaying it on the screen. So I’ve spent seven evenings to find and test such simple options, since communication with Raspberry was new to me, the same as Unix system streaming.\n\nScreen and joystick control\n\nAs I mentioned above, JoystickView transfers the angle and the touch value from the screen to the socket in the form of command: C: L; A: 45; V: 35;\n\nThere is a connection stream to the socket (with reconnects, callbacks, etc.) where a command queue can be found, and commands are repeatedly sent to the server. To improve the control I’ve implemented joystick control.\n\nThis device can be connected via Bluetooth and works as a keyboard. Therefore, all data is processed by the MainActivityonKeyDown and onGenericMotionEvent methods.\n\nThere is a good manual from Android developers, which helped a lot with the whole process.\n\nEverything was very easy, so I won’t explain it once again. You can find the results here.\n\nControlling test:\n\nIt seems that I’ve explained all the necessary thing concerning Android, but if you won’t understand something or you’ll need more info — you can contact me and I’ll provide the necessary information.\n\nConstruction assembling and testing\n\nNow we’ve reached the next step — we need to find something, where we can place all the above-mentioned stuff (haha). At the design and assembly stage my friend Sergey helped me a lot. Actually, he found a housing, made an iron platform, where we could mount the motors in different positions, and put it all together:\n\nI’ll run ahead and say that the prototype with 6 motors would be more productive, but for me it was hard to support the prototype even with 4 motors, that’s why it was decided to test the prototype with 4 motors.\n\nFirst of all, we decided to test the construction of housing, that’s why we didn’t put all the electronics into the housing, but simply attached the motors to the platform, and two twisted pairs of wires sent a signal from ESC to each of them (the ESC remained inland all the time during the test).\n\nHere you can see what a mess we’ve got. We didn’t care about transmission loss (as we used 10 meters of wires) and all the other blunders as our main aim was to test several things:\n\nWill it work with 4 motors?\n\nCan it be controlled via smartphone?\n\nWill the water leak into the housing?\n\nBut I missed one important point which Sergey warned me about. After the test in the bathroom, I had to dry thoroughly all these contacts, because they are the weakest spot. But I didn’t do it and finally got a combo of 48 connections that can lose contact.\n\nAs it is in all memes, the expectation, and the reality.\n\nTest in the bathroom:\n\nThe prototype doesn’t work properly because of the wires, but it is moving. And one more problem is that it is overloaded, as I had to put some things inside because the housing was empty and would not dip into the water.\n\nAnd the next test in the lake was even worse:\n\nThe motors and the contacts were corroded, the cable lost it’s plasticity because of the low temperature, and everything did not work properly, and the driving propellers were too small. But the most important thing was that I understood what should be improved and what changes should be done. Initially, I tried to locate the power supply unit out of the prototype, but tests showed that it was impossible. Huge DC losses showed that I should either use a cable as thick as an arm or just put the batteries inside.\n\nSince no one was sure that at a depth of 10+ meters this housing would not leak and destroy all the electronics inside — we decided to make an enhanced housing — “housing in case”. We ordered everything from China and proceeded with further assembling:\n\nI drilled the holes in the housing for wires that went outside through cable glands. I’ve additionally attached the housing for LEDs and camera using the rubber gasket and screw it up tightly. The next step — soldering of connection board, with separate connectors for each ESC, LED driver and gyroscope.\n\nIn order to simplify the already built-up structures, I’ve put only one power supply unit for all prototype units — the LiPO battery, since only this battery can provide enough current for Raspberry, LEDs and motors. But I’ve additionally added a voltage reduction board from 12V to 5V for Raspberry.\n\n“Work on” ©\n\nAs a result, I’ve got this internal data box. 4 motor outputs, 2 LEDs and a video cable. The last one was the most difficult. But at the very last moment the camera did not turn on (everything was ok during the tests) — it is possible that I’ve broken a video cable during the endless dismantling and assembling of the prototype. Since I didn’t want to reassemble everything again, I decided to attach an action camera in a waterproof case using adhesive tape and conduct new tests. By the way, I’ve replaced driving propellers with the largest which I could get, and the motors were replaced with more powerful ones. I attached 2 additional driving propellers to each electric motor that was responsible for the horizontal axis, because of some extra driving propellers :)\n\nI used a NEXX router. So a twisted wires pair comes out of the Raspberry PI and is connected via RJ-45 to the router. The router distributes Wi-Fi for Android smartphone. The Raspberry uses static IP, so you don’t have to configure the connection every time after reconnect. But there are problems with the connection — if there is no network coverage, the phone cannot connect via IP. So I had to turn off the mobile Internet and tried to connect several times. After the connection was established, I opened SSH on the phone and started the commands to start the node server (and after all test- the system shutdown command).\n\nThe time has come for new tests and I thought, what else can go wrong?\n\nEverything can go wrong ☺\n\nUpon arrival at the Kiev reservoir, I’ve discovered large waves (this is how I console myself):\n\nAnd the consequences of such tests:\n\nThe motors were clogged by different things like algae and sand.\n\nThe test failed again.\n\nThe third and the most successful test was performed on a calm lake, which was a great progress comparing with the previous 2 tests:\n\nConclusions\n\nThe main thing that comes out of all this is that I’ve gained is a great experience in building up such units and systems. A significant number of different devices were used during the development process, and its management turned out to be much easier than it would seem. Four motors prototype isn’t as good as it was expected — it’s extremely difficult to control such a device. It would be much better to use four vertical motors and at least two horizontal motors. At the same time, it should be stabilized with a gyroscope, because for a human it is hard to control it perfectly, and the help is needed (the same situation with the flying drones). Also, all the motors that are on sale get clogged with sand and other things, all the units can be damaged by corrosion (which is logical) and are not suitable for such projects. I did not find the underwater motors (it can be indicated that it is waterproof, but it works properly only at depths down to 1–2 meter). After this project, any smart home does not seem so complicated. Server, relay commands, and that’s all. The main thing that you need is to have time and desire to do it. The rest will follow.\n\nAnd what’s the point?\n\nThere is no point in it :)\n\nPromised links:\n\nhttps://bitbucket.org/gektor650/underwaterandroid — Android\n\nhttps://bitbucket.org/gektor650/underwaterserver — NodeJS\n\nTo run the app use the file app.js.\n\nBest wishes to everybody."
    }
}