{
    "id": "dbpedia_8578_3",
    "rank": 8,
    "data": {
        "url": "https://docs.geotools.org/stable/userguide/welcome/use.html",
        "read_more_link": "",
        "language": "en",
        "title": "How to Use GeoTools — GeoTools 31",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Classes for ImplementationÂ¶\n\nWhile interfaces are used to represent the data structures employed by GeoTools, we also provide public classes to get the job done.\n\nPublic classes are provided for the purpose of:\n\nUtility classes to make things easier to work with. Examples are the CQL, DataUtilities and JTS classes. Each of these provide public methods to help you make the most of the services provided by GeoTools.\n\nHelping glue the library together at runtime - an example is the FactoryFinders which allow you to look up available implementations on the CLASSPATH.\n\nGeoTools âExtensionsâ provide additional services on top of the library and require additional public classes to make this happen. An example is the ColorBrewer class provided by gt-brewer.\n\nYou can make use of public classes in these modules directly, in all cases they are utilities to get the job done. These classes are suitable for use in your import section. There is no need to use these classes in your method signatures as they do not represent data structures.\n\nFactories for CreationÂ¶\n\nInterfaces only define what a data structure should look like, and do not provide a way to create an object. In Java the work around is to provide a âfactoryâ that provides âcreateâ methods which you can use instead of new.\n\nGeoTools provides Factory classes allowing you to create the various objects used by the library, such as Features, Styles, Filters, CoordinateReferencingSystems, and DataStores.\n\nGeoTools provides a FactoryFinder system to locate the available factory implementations on the CLASSPATH. By using a FactoryFinder your code can be built to function using only interfaces.\n\nFor more information review the page How to Create Something which outlines how to locate an appropriate implementation at runtime.\n\nSeparation of ConcernsÂ¶\n\nWhile you could find and use each of the various Factory implementations directly this would introduce a dependency between your code and that exact implementation. This idea of depending on a specific implementation makes your code brittle with respect to change, and prevents you from taking advantage of a better implementation when it is made available in the future.\n\nBad practice with direct dependency on ShapeFileDataStoreFactory:\n\nShapefileDataStoreFactory factory = new ShapefileDataStoreFactory(); ShapeFileDataStore = factory.createDataStore( file );\n\nThis code example would have been fine for GeoTools 2.1, however for GeoTools 2.2 an âindexedâ shapefile datastore was created with far better performance.\n\nHere is a replacement that allows GeoTools to return an indexed datastore if one is available:\n\nDataStore dataStore = DataStoreFinder.getDataStore( file );\n\nThe DataStoreFinder class looks up all the DataStoreFactory implementations available on the CLASSPATH and sorts out which one can make a DataStore to access the provided file.\n\nFactoryFinderÂ¶\n\nWhile the use of Factories has become common place (especially in development environments like Spring). GeoTools has its own FactoryFinder classes, unique to project, which is how the library looks up what plugins are available for use.\n\nThese facilities are also available for use in your own application.\n\nFactoryFinder uses the âbuilt-inâ Java plug-in system known as Factory Service Provide Interface. This technique allows a jar to indicate what services it makes available (in this case implementations of a factory interface).\n\nTo make this easier to use we have a series of utility classes called FactoryFinders. These classes work as a match maker - looking around at what is available on the CLASSPATH. They will perform the âsearchâ and locate the implementation you need.\n\nHere is an example:\n\nFilterFactory filterFactory = CommonFactoryFinder.getFilterFactory( null );\n\nAbout FactorySPIÂ¶\n\nThe FactorySPI system is the out of the box plug in system that ships with Java. That is why we like it - we are sure you already are using the Java software after all. The SPI part is pronounced âspyâ and stands for Service, Provider, Interface.\n\nThe FactorySPI system has a look on your CLASSPATH and locates implementations of a requested service scattered around all the jars you have. It does this by looking in the jar MANIFEST folder in a services directory.\n\nFactory SPI is a runtime plugin system; so your application can âdiscoverâ and use new abilities that GeoTools provides over time. As our shapefile support gets better and better your application will notice and make use of the best implementation for the job.\n\nIf you are curious you can make use of the FactorySPI system yourself to locate anything we got going on in GeoTools:\n\nHints hints = GeoTools.getDefaultHints(); FactoryRegistry registry = new FactoryCreator(Arrays.asList(new Class[] {FilterFactory.class,})); Iterator i = registry.getServiceProviders( FilterFactory.class, null, hints ); while( i.hasNext() ){ FilterFactory factory = (FilterFactory) i.next(); }\n\nNotes:\n\nkeep your FactoryRegistry around, hold it in a static field or global lookup service such as JNDI.\n\nThe registry usually creates one instance (the first time you ask) and will return it to you again next time\n\nSpecifically it will create you one instance per configuration (i.e. that Hints object), so if you ask again using the same hints you will get the same instance back\n\nThink of FactoryRegistry keeping instances as singletons for you. In the same manner as it is a Java best practice (when making a singleton) to âpartitionâ by ThreadGroup (so different applets use different singletons). FactoryRegistry does not follow this practice - it uses Hints to âpartitionâ - so two applets that are configured the same will end up using the same FilterFactory.\n\nApplication specific AlternativesÂ¶\n\nHere are a couple of alternatives for stitching together your application.\n\nContainerÂ¶\n\nA container is a great way to take care of a lot of the boiler plate code involved in working with factories. Much of this documentation will use PicoContainer (just because it is small), while many real world applications use the Spring container.\n\nA container is basically a Map where you can look up instances. In common use the instances are factories, and what makes a container valuable is its ability automate the process of âwiring upâ the factories together.\n\nPopular techniques:\n\nreflection - picocontainer looks the constructors using reflection to see if any of the required parameters are available\n\nconfiguration - Spring uses a big XML file marking how each factory is created\n\nThe other nice thing is the container can put off creating the factories until you actually ask for them.:\n\ncontainer.registerImplementationClass( PositionFactory.class, PositionFactoryImpl.class ); container.registerImplementationClass( CoordinateFactory.class, CoordinateFactoryImpl.class ); container.registerImplementationClass( PrimitiveFactory.class, PrimitiveFactoryImpl.class ); container.registerImplementationClass( ComplexFactory.class, ComplexFactoryImpl.class ); container.registerImplementationClass( AggregateFactory.class AggregateFactoryImpl.class ); container.registerInstance( CoordinateReferenceSystem.class, CRS.decode(\"EPSG:4326\") ); WKTParser parser = (WKTParser) container.newInstance( WKTParser.class );\n\nIn the above example the WKTParser needs to be constructed with a PositionFactory, CoordinateFactory, PrimitiveFactory and ComplexFactory. Each one of these factories can only be constructed for a specific CoordinateReferenceSystem.\n\nIf we were not using a container to manage our factories it would of taken three times the number of lines of code just to set up a WKTParser.\n\nJNDIÂ¶\n\nIf you are writing a Java EE Application there is a big global map in the sky called InitialContext. Literally this is a map you can do look up by name and find Java instances in. It is so global in fact that the instances will be shared between applications.\n\nThis idea of a global cross application map is great for configuration and common services. If you are working with a Java EE application you will often find such things as:\n\na CRSAuthorityFactory registered for any code wanting to use the referencing module\n\na database listed under the Name âjdbc/EPSGâ used to hold the EPSG tables\n\na GeometryFactory, or FeatureTypeFactory and so on â¦\n\nHere is the GeoTools code that looks up a DataSource for an EPSG authority:\n\nContext context = JNDI.getInitialContext(null); DataSource source = (DataSource) context.lookup(\"jdbc/EPSG\");\n\nThe JNDI interfaces are shipped with Java; and two implementations are provided (one to talk to LDAP directories such as organizations deploy for email address information, and another for configuration information stored on the file system with your JRE).\n\nThe difference between JNDI and a Container:\n\nJNDI is not a container - it is an interface that ships with Java that lets you ask things of a âdirectory serviceâ.\n\nA Java EE Application Server runs programs in a âcontainerâ and part of the âcontainer configurationâ is making sure that JNDI is set up and pointing to the Services (i.e. global variables) that the Application Server makes available to all applications.\n\nThis same directory service can be used by you to share global variables between applications. Some things like the CRSAuthority can be treated as a âutilityâ and it makes sense to only have one of them for use from several applications at once.\n\nBecause making use of an application container is a good idea, and too hard to set up. There are a lot of alternative âlight weightâ containers available. Examples include picocontainer, JBoss container, Spring container and many many more. These containers focus on the storing of global variables (and making a lot of the difficult configuration automatic - like what factory needs to be created first).\n\nDirect use of FactoryÂ¶\n\nSometimes you just need to go ahead and code it like you mean it. The GeoTools plugin system does have its place and purpose; but if you know exactly what you are doing; or want to test an exact situation you can dodge the plugin system and do the work by hand.\n\nYou can just use a specific factory that is known to you:\n\nDataStoreFactorySpi factory = new ShapefileDataStoreFactory(); File file = new File(\"example.shp\"); Map map = Collections.singletonMap( \"url\", file.toURL() ); DataStore dataStore = factory.createDataStore( map );\n\nYou are depending on a specific class here (so it is not a real plug-in based solution in which GeoTools can find you the best implementation for the job). There is a good chance however that the factory will set you up with a pretty good implementation.\n\nFactory classes are Public in Name Only\n\nFactory classes are only public because we have to (so the factory finders can call them) - some programming environments such as OSGi will take special care to prevent you making direct use of these classes.\n\nIf you are working on the uDig project you may find that class loader settings have prevented you from directly referring to one of these factory classes.\n\nYou can provide a âhintâ asking the Factory Finder to retrieve you a specific instance:\n\nHints hints = new Hints( Hints.FILTER_FACTORY, \"org.geotools.filter.StrictFactory\" ); FilterFactory filterFactory = CommonFactoryFinder.getFilterFactory( hints );\n\nYou can skip the whole Factory madness and just do normal Java coding:\n\nFile file = new File(\"example.shp\"); URI namespace = new URI(\"refractions\"); ShapefileDataStore shapefile = new ShapefileDataStore( example.toURL()); shapefile.setNamespace(namespace); shapefile.setMemoryMapped(true);\n\nYou are depending on a exact class here, violating the plug-in system and so on. Chances are that GeoTools should not let you do this (by making the constructor package visible and forcing you to use the associated DataStoreFactory instead).\n\nThis option is fine for quick hacks, you may find that the ShapefileDataStore has additional methods (to handle such things as forcing the prj file to be rewritten):\n\nshapefile.forceSchemaCRS( CRS.decode( \"EPSG:4326\" ) );"
    }
}