{
    "id": "dbpedia_8578_1",
    "rank": 39,
    "data": {
        "url": "http://lin-ear-th-inking.blogspot.com/2021/",
        "read_more_link": "",
        "language": "en",
        "title": "Lin.ear th.inking",
        "top_image": "http://lin-ear-th-inking.blogspot.com/favicon.ico",
        "meta_img": "http://lin-ear-th-inking.blogspot.com/favicon.ico",
        "images": [
            "https://blogger.googleusercontent.com/img/a/AVvXsEiNzyFQkyhgyWrxPfR97frESMwCEdTFmaG3kyhDp6ai5g4jxI5djtP8wIXBv4W_2KKYSTklzD91-dandHsg-HobXV0bdrg57fbdQFcFENLmNWjnfcWk1oAcWw7VpC2M3bwzUOO3k5LzvWi9mWyLvSvjktq3VBM-6HbEqsCy3D3c8ZHH1jOkWZFj3SN7=w400-h396",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiCPgm3x9y0NFss6qn0-KV0yFmiI0J5EUF4zwn4vY34xuD51H2bgcWlc_w4QpPPacP7hKwsBd1CD8WrMxb2z7xP7EzWOfqQmf2s2MoGVFDYsXCS7-RogesSo9KIYTRSdSaP3ZujSwujokc/w400-h214/superior-tri.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi-Pg5KBhd1fEqyeMer_92GHebJfBJy8pyWQjSW0gfS0zxQ0GdOezUKoYXDqN4tt2uiYxzS8xwW_R78T_sXLCJdtwaYLPJNGGlpigzfAdUg2SCHkVGRU8Oes4E1EtiIW3s44IQ9GGvO1yM/w400-h211/superior-cdt.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgq35p2TTqTj_AhfCDJzzF-J9Vto_k1IiYdfZ7yBJlIqY66L1NtF91sN6P4PbH9r9xvsC4VRQSaV6ZHoMeT9PVufMMxSfAbcXK1kM8hvacBomQEh1Z0shVOSAY0JYXkJuywcGmMpOjnLhc/w67-h200/kdtree-unbalanced-full.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBS2GC3A-X0bRgUNL9etZHFodokvDqSUq9ZSi9A_8Ywmk1vZNY6n5O5jnN9HycZ96sedhE_r8buxPlbfgtDVx1vyZ-1o7TnWbmT_X50wLkNWEjCGwK2QSd50HydFHHyW38iuRYAGVOA48/w320-h207/kdtree-unbalanced.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEj5YKxebnR9wL9D0MZ4CU6RXbYItD3VYPn8Kcx-vjuCTsEHtjBPycoeUX7ZgyoE8fXhE7rgSflc95OGEtuZt4OmPPOZFCsFdo4By6OzOVs9K3mLykqokOT2sutoj-7i8uW0LFyQmuTi-4Y/w306-h400/kdtree-balanced.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgrK8g0zyct6pEXDGpZ1kC5Zn0QQ2DKRK92x3dhp3Y3JDk1tTozfJ9SySfq5KAMz166Wj-Y6mt7ZFN3QzFAl6bfbFbJf5XRLaFz_wiivuv_-D4SmFTzNC7NyVsCDsYPgrQtSCrgsb13ZDs/s320/invalid-intersections.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBQAvH0ZqSgrv1V9XI9-1EhYRQP5MSDJKnBvcGdlQGz1NgKrDF1ERJb9ODJzUtGtXymB54tfskaW5Q111HFSnUvANs0_W7Oakh1jgi53g7amFdM4mU0NkDeYFyLrpunmOJ9OcA4OCgpE8/s320/polygon-touch-all-vertices.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh2FXm2UNV6MpuslctajJVdSuNlxBR79FP100V0WlfW7nNqCLN4Y4Uuhi-0E0PVWge7hmrGuLM2ZL9YetL7iE6rCpM60WJK0rGfQNdQPj1L8zJC1z0PbOH3_c1RWJDLkm2HU-qYemH2vXA/s320/disconnected-polygon.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiymLSbJL0jD8DH7WY_OM8yz_wJnLGdvWB3ko-si-19OWeYhOEu-U8FxeFS6AfBj8fd18ieYo3pwLMu0_OOWlZREXSXeq3TBdplFx9Yh-KiqWroeTp8Jq4cNYT-TPVr0KcTEN_nXkzuvOk/w400-h180/inverted-exverted.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjc2VgW5lTkKpo3iPl3n9ba7pSJFrZ2OPXU0UcraQt-C5KxzHy7H5wpSmIub-ybs0L7hmEKKtcN2sWz4mwG3lCDlv5KhFpATB0khNJAjT-kXA7WzO-QZPLrfNt5AAZ870Z1q4StZek5ank/s320/australia-islands.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjOl7PurP3HbJ48NJmn_vLZ6aWiT7wAlLs5X4mds6jIf1RSDyNVaU0mjUwtZS_J0ADPXl8veFmpC3dTioJR1RJ30HU1vsGu0iID2l-WDauKGDwoeMCNUDSFNSYtNw9oPcjLi2eerJ5hHVQ/s320/non-simple+network.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgH-9AdKshusxgIh0XLIZoSHtFPReu6S83noc5E1UgXXfQsiTekZw482cYIXTCkpMzdxAKk7ixEZ4aByX4YkM-O05OH-CdWaO8XzCnBu5_BEhJWifpdPR9gxx9d4n-fwZiRuQSFlYKIi3A/w400-h198/us-rivers-non-simple-locs.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiXSkulrfLMA31CExLDdNg3l_b8B2R5lRfqraztA9SDhoFZcQ7gvDa6uz4-Qangn1qcHijEZA-BJugOrv0LiMlqs6ez6LjokA6xAs5dYVVJ0ZUbWRzxOE1WjbEQO4D87U4wH_1rmX6rzoE/s320/non-simple-rivers-1.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjUEx0SiX4FZOVHWreEBa1dJB2DvQtiZq_JUz-2Sywin5OtlP5n4HvE5x3elVPGLxlm5ym4tCQ1g7w3oyk5EdqszAvdCAptoNzFFTh5HG96Ye5ENOqMdyYkmhgU4DkVqeIMI1CThGtUykk/s320/non-simple-rivers-2.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi01sDZyQLxaMR9t4DRCnitNta7_NP_XXIsId5XekJBsrmm0PpKvy1k32cK7shTKYwYmKspJ00c6AktWcCIIGBK-Q55OBqM17v8clKdNEB-XiPwnqtdYyzcGgdV83L027c1pid4SIIVUEM/w400-h132/valid-polygons.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgBn2OWlQbUnfdqcH8pvdGFLXU8r_jiG0vzzqUJhcMIFrr4ZAoyzMjUDDvG4rAilJr_iSwLqoaf1BdUimCm6wgawRVO2RkLaVtMERA4YtC8v-K_KVLm5f_9IIuux8041k9Ek67B32FAJZo/w400-h169/figure-8-buffer-0.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjhQMD4XO_xZ_E6tZjLOa7VxJ7zTZTE1_LALi2q1g2WH2THSo0yxCTvsdBCq2dfwr65G7z5SJhDq8S-AzhaMJfZQdOPjrRKvkNG6d-jogvn5F516xmQWNSCVW_rOFpvJeDIGdX3NuDNU7c/w400-h183/makeValid-complex-2.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhLZOvxfQfcWGs6yhi2RQfvGHrbIUk3_cTdAHTiR5dDOWERt1b5lCo0Wa1WzUBekoU2abN1MnOCkiaYjKrauJWJrt7omHSgTr9YirUKyFbTJvVtJOPSU-Tz025l00AOEQSoUoxPk90NdQA/w400-h185/geomfixer-complex-2.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjwp7xisN2MWXYBuDrTbQg0b-R69G66NbqooeG5SzTKMV13u7ahG3dtfVVQWIlrdc91Uj8mOvTRpU9G5Q6p9-kw49-h_AKkF4xtstkWN6MchlKvtNAKZISBlRFyjFGnL_DmEU8AlTPdMuw/w400-h185/geomfixer-figure-8.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEik6uZcxLWfCsUB3GlU7-bSbO7d7PBqYjvbt-ZSX81wV2XUiN8SL_c_cJ5Z0BFkCHGFc2UX1K0GgCKuH-HAP9wVZX1tlv8W40wWuIUipifISxn6dPkanYSzR43mJXRccHROU97T0sGvUY4/w400-h188/geomfixer-self-overlap.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEi3_miH5TVP1NMZM8hIeLDcVrgRB6qN4PG3lgzSvdSYy-7r4XlsUy0b7zstwameU7ToLEscwyTSx1EaacwvG0cqB4TOpr_pzKHZbbHYVzk0U-fOsijiRh74EdHGD3XNmMaHFBZbACTmLJM/w400-h386/geomfixer-TestBuilder.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjSReC3bYpyC2Yqx0V8ZX1ej0RB-6y1rSPLrpxj_u7ItUu1Nypj9lva88KWW0u3NPhUrjtdX9W_uC_Q8cHT7ORvUmnrCYCDWZNrWOKoe2Tuz85zKy-skRg3I6d1hTQXUF7MJ_Hr7kllT4Y/s320/2021-04-25.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjDfGEJ2pwfmq45ztaLJZm6ggrX1Cs1KdaBaB1ipAhrJV_D13DbCqCCKAZfYcP5169WkH5g8edE54_JgrS4BI0X3NCufiQgA5U0PKWYyvoQc_2VjhgSuLSRYu5hDEVhfQ_Gaez4yzpZp_E/s0/marvin-gun.jpeg",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhu5W1Qcc-r3e4KCczmkHv6hIDp3ppYKx50dgFKmjq7pP_DYpePFtUB7IVGhJZS_XsPSrAwNF2m8JjpvpvDJmnk3x-vvFYGwosExDD7xCv7WIVvxBDsisziKJePCkBVcFoHiFKSoQNKUNY/s320/gdos-pinch.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh1feaQkDoJ0VLmYJtZJpNY3hvTgkNe09meQux25uyyB4B-q8JOyKwmyTWJe0IW2lYTKl9E7X2x-dUOui9qZ_6GNi6WLmmmc_QlH2v95RNemf_NWN7a4_p-F7ICMJItCQ6X4I-P_RCG6SQ/s320/gdos-zero-width-gore.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhrxO-s4Vr9KC1CnuqxZszwUGk5HOYea-J1_zm_jT7h51HIA5nHI_ocdCENdyqXVg-f7m8-XcnHmLo1azM4KxPogVlaugXU8yzqXVvKXXnuDdAY2yEfDbLnlbD5140zyX16ACpVrzO1xjo/s320/gdos-bowtie.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiYyBOxV_h8VSwP_krNWuvHJl6UFeCf-y1FpLWtUPda2bDWosdY0qNnkgkRveMisuIF_6lOCmIc97_i8d1pjM8jyatlv2YwbynoId5O_RAqA5TWBL6hO8Op1YhEpjhBiyCahTLko0gifus/s320/gdos-wild-2.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiLABWmqAbObU8S9tl3KpztzZwsEyrSEOFSZCrI_LRLGeIiEZ79RoXl0PiRqoJrrEsEgX4SdBpjMO3fi_MNiep_u6SrLL-fgPX3AeaCCe6LsLL0SFWdoSaktMrbp266IXRF1CTMoT44SPQ/s320/gdos-wild-invalid-1.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgM-48B18euFMEFCafR0Xhah-qMv1-e76X3PmDPNF0y5jSRnDEtBoXBHAP53NYadqOFJqcVOhKxEPdNqr-C6PvoVbtYx1k2B2rR1-1a6tS5ejuRpTVH_eO6km_r5ux7wUwXNmSYH4-SFfM/w342-h398/uk-voronoi.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjJ1gEFkiOHhWqTB8LxIGWs26UpyVqp4xk4OTCwmA5Lmq1Lh_DNCs3FiPr3NLOAFlCAYqdu-CDG5YShRH68LPNLlqB6gXTAvtpxdPJTvk0CkjrmOmwCIlCrkU0LvOosw-85MQuIZTX31zk/w419-h208/world-interiorPoint.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgGgXVoLU3GNIZ0HhdhYzzP9M563UiZXSJVWS0YPGGFqL8pPHMv06-QafDdSu68tA0DxUItBc2R0e9LQKAhKHZUsQaqUPxV6SXm1SDplwuYKW17xG38NXH94ywrWnLPr2Xb5U5LvbsYyd4/w417-h297/europe-union.png",
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgWp2Q_-RyV0nv5mthgxzsoogVrLcr3X74exGMOxopNrPzJ4VPliS-IN0J3Ad8QNeB6veXmiVW7yRFRefUeM0YXXsa7W2F7BP-Z42NGP8R-9RGOn7ab2ltWb7gs8bpGot4Klifg1DOdu1U/s1600/martin_davis_small.jpg",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhSmFeaYPuQLXCc98HVc_NxM0EVZnHsmZm_XMqjnXrVojopYJHuaR29nJO83f_hPNEZlhFI86XRTaWvjBUDO0DDHX1uNQ2sv6LSuYnyiPXi0-NqFP4K8WQ5MH1vPWmL4WT1pBIT5smlZmk/w72-h72-p-k-no-nu/cascadedUnion.png",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_tnGYjVn7RmhdIP-IRFlqd0zYs6mU3pvm4pFvD9W9JHN8UQGyutnL__MkH0YfxqtqkWhcuseY9zTvPbtt8WtbUEioGl3khpjsoiyV1afvmlSRaHJTnxkxw9dkr9iQYTbfm61Q=w72-h72-p-k-no-nu",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhcP5TOZySOotC15jt5E7yG4ZJrxEQK14lgNqPF9DcqYgnLnxFHydTkHO9RoIzitO0ftsCYMtYGq_Rc4otQFzb-cD-_E7L-gNPhAXRqd9qhVD2hOQHxsSfQ0Q66nK7JbMIrRYkRNLGWAYw/w72-h72-p-k-no-nu/bigpoly_noimprove.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgMMXmeVsTTInsYKjWalulH-n97pp4_9xhf7OeRfX8Fe94v85qluxTTYuWL0RRwwuH4wm93x929W9Sh2snLy_xnGavzapfP3wFgFmtIyS6V7DO4wUF2IOicwGOmUOEhxjAWSL0gSTCNIWo/w72-h72-p-k-no-nu/GTFS_data_model_diagram.PNG",
            "https://blogger.googleusercontent.com/img/a/AVvXsEhTsfTJAsSKAscvZpIr8bVlodUAyTswzjzdCpat2TswDnV6AYdkYDly3T934T8SHlfaBowVpNwlgyY2jMNCMwc_FTiNrJQFvH2JnXWBClRDeuLqYwb4zZKpCrNugxVQBAwK_E2Q27jLtVOn1O9asYOYja8feDScJVC8nv8vzcJkhQlNsSkD7jYQ0Kg3=w72-h72-p-k-no-nu",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEhu5W1Qcc-r3e4KCczmkHv6hIDp3ppYKx50dgFKmjq7pP_DYpePFtUB7IVGhJZS_XsPSrAwNF2m8JjpvpvDJmnk3x-vvFYGwosExDD7xCv7WIVvxBDsisziKJePCkBVcFoHiFKSoQNKUNY/w72-h72-p-k-no-nu/gdos-pinch.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEiS5c8lcxsTJld5MG692-JtaTChUkfbaHnncI0WMUgnhuKtjCIXt50wDlb86TZ6dCAJFFBsaSFe66laHUfBrGC_FRDxwfmanKnPvxTERfbxajbmqvIk2u7xwXTmckSCMe7jKOKPTP1y7TU/w72-h72-p-k-no-nu/interiorpoint-ebc-va.png",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_v8sJm0QGBEeljri27v6_zjvJ30Sv6pZEIskOakohppsYjKmo3IWalUShemAIEAZeNa6Hui3cuhWXoqDkh7nqfVipxnKsXd=s16-w16-h16",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_vEIhI--j78yW6bl4Rin3h85p3jZX0woKB3fWcuhU8WtTON2nENJrAd4wjO4BHKIw5tiQfU1YU6p4tOOOlwaNo7aoAaDCJV4xRwclMQbvbxtWG3=s16-w16-h16",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_uM5kHgRIlyDXGL3sOJcGUJ3Wcg5VL0FfycnuHOXWJsOg2sCG8SdGNacqm5F6nE9547FJx3yznmRTYTt5FZWTpMT6uwAucWXvXsZaIN-xuLkQ=s16-w16-h16",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_snWTdaukjOptEw7BhZSUcIxXz06o5i3C7jfHsjt-2LmXmNKWlCwfCVm4BfiVLfA-kpWYRb6P2PLFZjNCntRaoawtUmv-zOfZ6hac8EiVMLPwvyzA=s16-w16-h16",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_snWTdaukjOptEw7BhZSUcIxXz06o5i3C7jfHsjt-2LmXmNKWlCwfCVm4BfiVLfA-kpWYRb6P2PLFZjNCntRaoawtUmv-zOfZ6hac8EiVMLPwvyzA=s16-w16-h16",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_t1yrH-TGu086qowswxMcuJKt_b7uedPrcptF9OLKrTmY8RWsu7ZKK3qFQjEDkFl92OZo1z578bF2yUuDj4TQruXIC2XLxlxa5Ar3I=s16-w16-h16"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Dr JTS",
            "View my complete profile"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Because the shortest distance between two thoughts is a straight line",
        "meta_lang": "",
        "meta_favicon": "http://lin-ear-th-inking.blogspot.com/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "http://lin-ear-th-inking.blogspot.com/2021/",
        "text": "A (long) while ago I posted about \"soon-to-be-released\" JTS code for polygon triangulation using Ear Clipping. It turned out it was actually in the category of \"never-to-be-released\". However, later I worked with a student, Dan Tong, on a coding exercise sponsored by Facebook. We decided to tackle polygon triangulation. By the end of the project he implemented a functional algorithm, including handling holes (via the hole-joining technique described by Eberly). To make it release-ready the code needed performance and structural improvements. This has finally happened and the code is out!\n\nPolygon Triangulation\n\nThe new codebase has been substantially rewritten to improve modularity and the API. A new data structure to represent triangulations has been introduced, called a Tri It is simpler, more memory efficient, and easier to work with than the QuadEdge data structure previously used in JTS. It provides an excellent basis for developing further algorithms based on triangulations (of which more below)\n\nMost of the reworking involved implementing key performance optimizations, utilizing existing and new JTS spatial index structures:\n\nthe Hole Joining phase now uses a spatial index to optimize the test for whether a join line is internal to a polygon\n\nthe Ear-Clipping phase has to check whether a candidate ear contains any vertices of the polygon shell being clipped. This has been made performant by using a new spatial index structure called the VertexSequencePackedRtree\n\nPerformance must be benchmarked against an existing implementation. Geometry maestro Vladimir Agafonkin has developed an Ear Clipping algorithm in Javascript called Earcut. It's claimed to be the fastest implementation in Javascript. Indeed the performance comparison shows Earcut to be over 4 times faster than some other Javascript triangulation implementations. Earcut has been ported to Java as earcut4j, which allows comparing JTS to it.\n\nDatasetSizeJTS TimeEarcut4j Time Lake Superior3,478 vertices / 28 holes18 ms13 ms Canada10,522 vertices35 ms26 ms Complex polygon44,051 vertices / 125 holes1.1 s0.64 s North America with Lakes115,206 vertices / 1,660 holes13.3 s5.4 s\n\nSo JTS ear clipping is not quite as fast as Earcut4j. But it's still plenty fast enough for production use!\n\nThe triangulation algorithm is exposed as the PolygonTriangulator class (deliberately named after the effect, rather than the algorithm producing it). Here's an example of the output:\n\nEar-Clipping Triangulation of Lake Superior\n\nConstrained Delaunay Triangulation\n\nThe output of PolygonTriangulator is guaranteed to be a valid triangulation, but in the interests of performance it does not attempt to produce a high-quality one. Triangulation quality is measured in terms of minimizing the number of \"skinny\" triangles (or equivalently, maximizing the sum of the interior angles). Optimal quality is provided by Constrained Delaunay Triangulation (CDT). In addition to being optimal in terms of triangle shape, the CDT has the nice properties of being (essentially) unique, and of accurately representing the structure of the input polygon. It also removes the influence that Hole Joining holes has on the raw triangulation provided by Ear-Clipping.\n\nI originally proposed that a CDT can be achieved by a Delaunay Improvement algorithm based on iterated triangle flipping. It turned out that this technique is not only effective, but also pleasingly performant. This is implemented in the ConstrainedDelaunayTriangulator class. Running it on the example above shows the improvement obtained. Note how there are fewer narrow triangles, and their arrangement more closely represents the structure of the polygon.\n\nConstrained Delaunay Triangulation of Lake Superior\n\nThis code will appear in the next JTS version (1.18.3 or 1.19), and has already been released in GEOS 3.10.\n\nFuture Work\n\nIt seems possible to adapt the machinery for Ear Clipping to provide two other useful constructions:\n\nPolygon Concave Hull (\"Outer Hull\") - this requires a triangulation of the area between the polygon and its convex hull. That can be obtained by running Ear Clipping outwards, rather than inwards. A Concave Hull can be constructed by limiting the number of triangles generated based on some criteria such as area, longest edge, or number of vertices. The result is a simplified polygon with fewer vertices which is guaranteed to contain the original polygon.\n\nPolygon Inner Hull - the triangulation constructed by Ear Clipping can be \"eroded\" to provide a simpler polygon which is guaranteed to be contained in the original.\n\nThe property of the Constrained Delaunay Triangulation of representing the structure of the input polygon could provide a basis for computing the following constructions:\n\nApproximate Skeleton construction (also known as the Medial Axis) by creating edges through the CDT triangles\n\nEqual-Area Polygon Subdivision, by partitioning the graph induced by the CDT\n\nThe Tri data structure provides a simple representation of a triangulation. I expect that it will facilitate the development of further JTS triangulation algorithms, such as:\n\nConcave Hull of Point Set\n\nConstrained Delaunay Triangulation of Lines and Points\n\nRecently a GEOS patch was contributed to change the KdTree query implementation to use an explicit stack rather than recursion. This has been ported to JTS as PR #779 (along with some refactoring).\n\nThe change was motivated by a QGIS issue in which a union of some large polygons caused a stack overflow during a KdTree query. The reason is that the poor vertex alignment of the input polygons causes the union overlay process to invoke the SnappingNoder. (For background about why this occurs see the post OverlayNG - Noding Strategies). The snapping noder snaps vertices using a KdTree with a tolerance. The polygon boundaries contain runs of coherent (nearly-monotonic) vertices (which is typical for high-resolution polygons delineating natural areas). When these are loaded directly into a KdTree the tree can become unbalanced.\n\nAn unbalanced tree has a relatively large depth for its size. The diagrams below shows the graph of the KdTree for a polygon containing 10,552 vertices. The unbalanced nature of the tree is evident from the few subtrees extending much deeper than the rest of the tree. The tree depth is 282, but most of that occurs in a single subtree.\n\nAn unbalanced KD-tree (size = 10,552, depth = 282)\n\nLeft: full graph. Right: close-up of graph structure\n\nFor large inputs querying such a deep subtree causes the recursive tree traversal to exceed the available call stack. Switching to an iterative implementation eliminates the stack overflow error, since the memory-based stack can grow to whatever size is needed.\n\nHowever, stack overflow is not the only problem! Unbalanced KD-trees also exhibit poor query performance. This is because deep tree traversals make the search runtime more linear than logarithmic. Increasing the size of the query stack increases robustness, but does not improve the performance problem. The best solution is to build the KD-tree in a balanced way in the first place.\n\nOne way to do this is to to break up monotonic runs by randomizing the order of vertex insertion. This is actually implemented in the OverlayNG SnapRoundingNoder, as discussed in the post Randomization to the Rescue. However, using this approach in the SnappingNoder would effectively query the tree twice for each vertex. And in fact it's not necessary to randomize all the inserted points. A better-balanced tree can be produced by \"seeding\" it with a small set of well-chosen points.\n\nBut how can the points be chosen? They could be selected randomly, but true randomness can be quite \"clumpy\". Also, a non-deterministic algorithm is undesirable for repeatability. Both of these issues can be avoided by using a low-discrepancy quasi-random sequence. This concept has a fascinating theory, with many approaches available. The simplest to implement is an additive recurrence sequence with a constant α (the notation {...} means \"fractional value of\"):\n\nR(α) : tn = { t0 + n * α }, n = 1,2,3,...\n\nIf α is irrational the sequence never repeats (within the limits of finite-precision floating point). The excellent article The Unreasonable Effectiveness of Quasirandom Sequences suggests that the lowest possible discrepancy occurs when α is the reciprocal of the Golden Ratio φ.\n\n1 / φ = 0.6180339887498949...\n\nImplementing this is straightforward, and it is remarkably effective. For the example above, the resulting KD-tree graph is significantly better-balanced, with lower depth (85 versus 282):\n\nBetter-balanced KD-tree (size = 10,552, depth = 85)\n\nAdding KD-tree seeding to the SnappingNoder gives a huge performance boost to the QGIS test case. For the 526,466 input vertices the tree depth is reduced from 17,776 to 183 and the snapping time is improved by about 100 times, from ~80 s to ~800 ms! (In this case the overall time for the union operation is reduced by only about 50%, since the remainder of the overlay process is time-consuming due to the large number of holes in the output.)\n\nIn GEOS the performance difference is smaller, but still quite significant. The snapping time improves 14x, from 12.2 s to 0.82 s, with the union operation time decreasing by 40%, from 31 to 18 secs.\n\nThis improvement will be merged into JTS and GEOS soon.\n\nIn a previous post I described how the JTS Topology Suite operation IsSimpleOp has been completely rewritten to reduce code dependencies, improve performance, and provide a simpler, more understandable implementation. The post points out that the IsValidOp implementation would benefit from the same treatment. This work has now been carried out, with similar benefits achieved.\n\nThe original IsValidOp code used the GeometryGraph framework to represent the topology of geometries. This code reuse reduced development effort, but it carried some serious drawbacks:\n\nThe GeometryGraph structure was used for many JTS operations, including overlay, buffer, and spatial predicate evaluation. This made the code complex, hard to understand, and difficult to maintain and enhance\n\nThe GeometryGraph structure computes the full topology graph of the input geometry, in order to support constructive operations such as overlay and buffer. This makes it slower and more subject to robustness problems. Non-constructive operations such as IsValidOp and IsSimpleOp can compute topology \"on-the-fly\", which allows short-circuiting processing as soon as an invalidity is found.\n\nThe new IsValidOp implementation is more self-contained, relying only on the noding framework and some basic spatial predicates. Using the MCIndexNoder allows short-circuited detection of some kinds of invalidity, which improves performance. And it will be easy to switch to a different noding strategy should a superior one arise.\n\nHowever, dropping GeometryGraph means that the topology information required to confirm validity needs to be computed some other way. The goal is to compute just enough topological structure to evaluate validity, and do that efficiently on an as-needed basis. This required some deep thinking about validity to pare the topology information required down to a minimum. This was assisted by the extensive set of unit tests for IsValidOp, which ensured that all possible situations were handled by the new logic (although there was an untested situation which uncovered a bug late in development.) The resulting algorithm uses some elegant logic and data structures, which are explained in detail below.\n\nOGC Validity\n\nJTS implements the OGC Simple Features geometry model. To understand the validity algorithm, it helps to review the rules of geometry validity in the OGC specification:\n\nFor non-polygonal geometry types, the validity rules are simple;\n\nCoordinates must contain valid numbers\n\nLineStrings must not be zero-length\n\nLinearRings must be simple (have no self-intersections)\n\nFor polygonal geometry, on the other hand, the validity rules are quite stringent (sometimes considered too much so!). The rules are:\n\nRings must be simple (have no self-intersections)\n\nRings must not cross, and can touch only at discrete points\n\nHoles must lie inside their shell\n\nHoles must not lie inside another hole of their polygon\n\nThe interiors of polygons must be connected\n\nIn a MultiPolygon, the element interiors must not intersect (so polygons cannot overlap)\n\nIn a MultiPolygon, the element boundaries may intersect only at a finite number of points\n\nValidity Algorithm for Polygonal Geometry\n\nThe new IsValidOp uses an entirely new algorithm to validate polygonal geometry. It has the following improvements:\n\nIt supports short-circuiting when an invalid situation is found, to improve performance\n\nSpatial indexing is used in more places\n\nThe code is simpler and more modular. This makes it easier to understand, and easier to adapt to new requirements (e.g. such as the ability to validate self-touching rings described below)\n\nThe algorithm consists of a sequence of checks for different kinds of invalid situations. The order of the checks is important, since the logic for some checks depends on previous checks passing.\n\n1. Check Ring Intersections\n\nThe first check determines if the rings in the geometry have any invalid intersections. This includes the cases of a ring crossing itself or another ring, a ring intersecting itself or another ring in a line segment (a collinear intersection), and a ring self-touching (which is invalid in the OGC polygon model). This check can use the robust and performant machinery in the JTS noding package. If an invalid intersection is found, the algorithm can return that result immediately.\n\nKinds of invalid intersections:\n\n(i) a self-touch; (ii) collinear; (iii) segment crossing; (iv) vertex crossing\n\nThis check is an essential precursor to all the remaining checks. If a geometry has no invalid intersections this confirms that its rings do not self-cross or partially overlap. This means that the results of orientation and point-in-polygon computations are reliable. It also indicates that the rings are properly nested (although it remains to be determined if the nesting of shells and holes is valid).\n\nIntersection search is the most computationally expensive phase of the algorithm. Because of this, information about the locations where rings touch is saved for use in the final phase of checking connected interiors.\n\n2. Check Shell and Hole nesting\n\nIf no invalid intersections are found, then the rings are properly nested. Now it is necessary to verify that shells and holes are correctly positioned relative to each other:\n\nA hole must lie inside its shell\n\nA hole may not lie inside another hole.\n\nIn MultiPolygons, a shell may not lie inside another shell, unless the inner shell lies in a hole of the outer one.\n\nRing position can often be tested using a simple Point-In-Polygon test. But it can happen that the ring point tested lies on the boundary of the other ring. In fact, it is possible that all points of a ring lie on another ring. In this case the Point-In-Polygon test is not sufficient to provide information about the relative position of the rings. Instead, the topology of the incident segments at the intersection is used to determine the relative position. Since the rings are known to not cross, it is sufficient to test whether a single segment of one ring lies in the interior or exterior of the other ring.\n\nMultiPolygon with an element where all vertices lie on the boundary\n\nChecking nesting of holes and shells requires comparing all interacting pairs of rings. A simple looping algorithm has quadratic complexity, which is too slow for large geometries. Instead, spatial indexes (using the STRtree) are used to make this process performant.\n\n3. Check Connected Interior\n\nThe final check is that the interior of each polygon is connected. In a polygon with no self-touching rings, there are two ways that interior disconnection can happen:\n\na chain of one or more touching holes touches the shell at both ends, thus splitting the polygon in two\n\na chain of of two or more touching holes forms a loop, thus enclosing a portion of the polygon interior\n\nTo check that these conditions do not occur, the only information needed is the set of locations where two rings touch. These induce the structure of an undirected graph, with the rings being the graph vertices, and the touches forming the edges. The situations above correspond to the touch graph containing a cycle (the splitting situation is a cycle because the shell ring is also a graph vertex). (Equivalently, the touch graph of a valid polygon is a tree, or more accurately a forest, since there may be sets of holes forming disconnected subgraphs.) So a polygon can be verified to have a connected interior by checking that its touch graph has no cycles. This is done using a simple graph traversal, detecting vertices (rings) which are visited twice.\n\nSituations causing a disconnected interior:\n\n(i) a chain of holes; (ii) a cycle of holes\n\nIf no invalid situations are discovered during the above checks, the polygonal geometry is valid according to the OGC rules.\n\nValidity with Self-touching Rings\n\nSome spatial systems allow a polygon model in which \"inverted shells\" are valid. These are polygon shells which contain a self-touch in a way that encloses some exterior area. They also allow \"exverted holes\", which contain self-touches that disconnect the hole into two or more lobes. A key point is that they do not allow \"exverted shells\" or \"inverted holes\"; self-touches may disconnect the polygon exterior, but not the interior. Visually this looks like:\n\nLeft: Inverted shell and exverted hole (valid)\n\nRight: Exverted shell and inverted hole (invalid)\n\nThis kind of topology is invalid under the OGC polygon model, which prohibits all ring self-intersections. However, the more lenient model still provides unambiguous topology, and most spatial algorithms can handle geometry of this form perfectly well. So there is a school of thought that considers the OGC model to be overly restrictive.\n\nTo support these systems JTS provides the setSelfTouchingRingFormingHoleValid option for IsValidOp to allow this topology model to be validated. Re-implementing this functionality in the new codebase initially presented a dilemma. It appeared that building the touch graph to check connectivity required computing the geometry of the additional rings formed by the inversions and exversions. This needed a significant amount of additional code and data structures, eliminating the simplicity of the graph-based approach.\n\nHowever, it turns out that the solution is much simpler. It relies on the fact that valid self-touches can only disconnect the exterior, not the interior. This means that self-touches of inverted shells and exverted holes can be validated by the local topology at the self-intersection node. This condition can be tested by the same logic already used to test for nested touching shells. Even better, if the self-touches are valid, then the touch-graph algorithm to check connectivity still works. (This is the same phenomenon that allows most spatial algorithms to work correctly on the inverted/exverted ring model.)\n\nPerformance\n\nAs expected, the new codebase provides better performance, due to simpler code and the ability to short-circuit when an invalidity is found. Here's some performance comparisons for various datasets:\n\nDataSizeNew (ms)Old (ms)Improvement world 244 Polygons, 366K vertices 3401250 3.7 x invalid-polys 640 Polygons, 455K vertices 126334 2.6 x valid-polys 640 Polygons, 455K vertices 244487 2 x australia 1 MultiPolygon, 1,222K vertices 132169026 52 x\n\nworld is the standard dataset of world country outlines\n\ninvalid-polys is a dataset of all invalid polygons. valid-polys is the same dataset processed by GeometryFixer. The timings show the effect of short-circuiting invalidity to improve performance.\n\naustralia is a geometry of the Australian coastline and near-shore islands, with 6,697 polygon elements. The dramatic difference in performance reflects the addition of a spatial index for checking nested shells.\n\nAustralia and 6,696 islands\n\nNext Steps\n\nThe improved IsValidOp will appear in JTS version 1.19. It has already been ported to GEOS, providing similar performance improvements. And since GEOS backs the PostGIS ST_IsValid function, that will become faster as well.\n\nThere is one remaining use of GeometryGraph in JTS for a non-constructive operation: the RelateOp class, used to compute all topological spatial predicates. Converting it should provide the same benefits of simpler code and improved performance. It should also improve robustness, and allow more lenient handling of invalid inputs. Watch this space!\n\nHard to believe that the JTS Topology Suite is almost 20 years old. That's 140 in dog years! Despite what they say about old dogs, one of the benefits of longevity is that you have the opportunity to learn a trick or two along the way. One of the key lessons learned after the initial release of JTS is that intersection (node) detection is a fundamental part of many spatial algorithms, and critical in terms of performance. This resulted in the development of the noding package to provide an API supporting many different kinds of intersection detection and insertion.\n\nPrior to this, intersection detection was performed as part of the GeometryGraph framework, which combined it with topology graph formation and analysis. At the time this seemed like an elegant way to maximize code reuse across many JTS operations, including overlay, buffering, spatial predicates and validation. But as often the case, there are significant costs to such general-purpose code:\n\nThe overall codebase is substantially more complex\n\nA performance penalty is imposed on algorithms which don't require topology construction\n\nAlgorithms are harder to read and understand.\n\nThe code is brittle, and so hard to modify\n\nPorting the code is more difficult\n\nBecause of this, a focus of JTS development is to free operations from their dependency on GeometryGraph - with the ultimate goal of expunging it from the JTS codebase. A major step along this road was the rewrite of the overlay operations.\n\nAnother operation that relies on GeometryGraph is the IsSimpleOp class, which implements the OGC Simple Features isSimple predicate. The algorithm for isSimple essentially involves determining if the geometry linework contains a self-intersection. GeometryGraph is unnecessarily complex for this particular task, since there is no need to compute the entire topology graph in order to find a single self-intersection. Reworking the code to use the the MCIndexNoder class in the noding API produces a much simpler and more performant implementation. I also took the opportunity to move the code to the operation.valid package, since the operations of isSimple and isValid are somewhat complementary.\n\nNow, isSimple is probably the least-used OGC operation. Its only real use is to test for self-intersections in lines or collections of lines, and that is not a critical issue for many workflows. However, there is one situation where it is quite useful: testing that linear network datasets are \"vector-clean\" - i.e. contain LineStrings which touch only at their endpoints.\n\nA linear network containing non-simple intersections (isSimple == false)\n\nTo demonstrate the performance improvement, I'll use a dataset for Rivers of the US maintained by the US National Weather Service. It supplies two datasets: a full dataset of all rivers, and a subset of major rivers only. You might expect a hydrographic network to be \"vector-clean\", but in fact both of these datasets contain numerous instances of self-intersections and coincident linework.\n\nHere's the results of running the isSimple predicate on the datasets. On the larger dataset the new implementation provides a 20x performance boost!\n\nDataset New time Old time Subset (909,865 pts) 0.25 s 1 s Full (5,212,102 pts) 2 s 30 s\n\nFinding Non-Simple Locations\n\nThe new codebase made it easy to add a functionality enhancement that computes the locations of all places where lines self-intersect. This can be used to for visual confirmation that the operation is working as expected, and to indicate places where data quality needs to be improved. Here's the non-simple intersection points found in the river network subset:\n\nCloseups of some non-simple intersection locations:\n\nIsSimpleOp is the easiest algorithm to convert over from using GeometryGraph. As such it serves as a good proof-of-viability, and establishes useful code patterns for further conversions.\n\nNext up is to give IsValidOp the same treatment. This should provide similar benefits of simplicity and performance. And as always, porting the improved code to GEOS.\n\nTLDR: JTS can now fix invalid geometry!\n\nThe JTS Topology Suite implements the Geometry model defined in the OGC Simple Features specification. An important part of the specification is the definition of what constitutes valid geometry. These are defined by rules about the structural and geometric characteristics of geometry objects. Some validity rules apply to all geometry; e.g. vertices must be defined by coordinates with finite numeric values (so that NaN and Inf ordinates are not valid). In addition, each geometric subtype (Point, LineString, LinearRing, Polygon, and Multi-geometry collections) has its own specific rules for validity.\n\nThe rules for Polygons and MultiPolygons are by far the most restrictive. They include the following constraints:\n\nPolygons rings must not self-intersect\n\nRings may touch at only a finite number of points, and must not cross\n\nA Polygon interior must be connected (i.e. holes must not split a polygon into two parts)\n\nMultiPolygon elements may touch at only a finite number of points, and must not overlap\n\nThese rules guarantee that:\n\na given area is represented unambiguously by a polygonal geometry\n\nalgorithms operating on polygonal geometry can make assumptions which provide simpler implementation and more efficient processing\n\nValid polygonal geometry is well-behaved\n\nGiven the highly-constrained definition of polygonal validity, it is not uncommon that real-world datasets contain polygons which do not satisfy all the rules, and hence are invalid. This occurs for various reasons:\n\nData is captured using tools which do not check validity, or which use a looser or different definition than the OGC standard\n\nData is imported from systems with different polygonal models\n\nData is erroneous or inaccurate\n\nBecause of this, JTS does not enforce validity on geometry creation, apart from a few simple structural constraints (such as rings having identical first and last points). This allows invalid geometry to be represented as JTS geometry objects, and processed using JTS code. Some kinds of spatial algorithms can execute correctly on invalid geometry (e.g. determining the convex hull). But most algorithms require valid input in order to ensure correct results (e.g. the spatial predicates) or to avoid throwing exceptions (e.g. overlay operations). So the main reason for representing invalid geometry is to allow validity to be tested, to take appropriate action on failure.\n\nOften users would like \"appropriate action\" to be Just Make It Work. This requires converting invalid geometry to be valid. Many spatial systems provide a way to do this:\n\nPostGIS has the ST_MakeValid function (which is backed by an implementation in GEOS)\n\nQGIS has a Fix Geometries process.\n\nOpenJUMP has MakeValidOp\n\nThe ESRI Java Geometry API has an operation called (confusingly) makeSimple.\n\nBut this has a been a conspicuous gap in the JTS API. While it is possible to test for validity, there has never been a way to fix an invalid geometry. To be fair, JTS has always had an unofficial way to make polygonal geometry valid. This is the well-known trick of computing geometry.buffer(0), which creates a valid output which often is a good match to the input. This has worked as a stop-gap for years (in spite of an issue which caused some problems, now fixed - see the post Fixing Buffer for fixing Polygons). However, using buffer(0) on self-intersecting \"figure-8\" polygons produces a \"lossy\" result. Specifically, it retains only the largest lobes of the input linework. This is undesirable for some uses (although it is advantageous in other situations, such as trimming off small self-intersections after polygon simplification).\n\nBuffer(0) of Figure-8 is lossy\n\nSo, it's about time that JTS stepped up to provide a supported, guaranteed way of fixing invalid geometry. This should handle all geometry, although polygonal geometry repair is the most critical requirement.\n\nThis raises the question of what exactly the semantics of repairing polygons should be. While validity is well-specified, there are no limits to the complexity of invalid polygons, and a variety of possible approaches to fixing them. The most significant decision is how to determine the interior and exterior of a polygonal geometry with self-intersections or overlaps. (This is the classic \"bow-tie\" or \"figure-8\" - although self-intersecting polygons can be far more complex.) The question comes down to whether the geometry linework or structure is used to determine interior areas.\n\nIf linework is used to create validity, to node the constituent linework to form a topologically-valid coverage. This coverage is then scanned with an alternating even-odd strategy to assign areas as interior or exterior. This may result in adjacent interior or exterior areas, in which case these are merged.\n\nAlternatively, the structure of the polygonal geometry can be taken as determinative. The shell and hole rings are assumed to accurately specify the nature of the area they enclose (interior or exterior). Likewise, the (potentially overlapping or adjacent) elements of a MultiPolygon are assumed to enclose interior area. The repair operation processes each ring and polygon separately. Holes are subtracted from shells. Finally, if required the repaired polygons are unioned to form the valid result.\n\nPostGIS MakeValid and the ESRI Java Geometry API makeSimple both use the linework approach. However, for some relatively simple invalid geometries this produces results which seem overly complex.\n\nComplex output from ST_MakeValid\n\nFor this reason I have implemented the structure-based approach in JTS. It provides results that are closer to the existing buffer(0) technique (and conveniently allows using the existing buffer code). This made it a relatively simple matter to implement the repair algorithm as the GeometryFixer class.\n\nHere's some examples of how GeometryFixer works. First, the example above, showing the (arguably) simpler result that arises from using the structure information:\n\nFigure-8s are handled as desired (keeping all area):\n\nSelf-overlapping shells have all interior area preserved:\n\nOf course, the GeometryFixer also handles simple fixes for all geometry types, such as removing invalid coordinates.\n\nOne further design decision is how to handle geometries which are invalid due to collapse (e.g. a line with a single point, or a ring which has only two unique vertices). GeometryFixer provides an option to either remove collapses, or to return them as equivalent lower dimensional geometry.\n\nTo see the full range of effects of GeometryFixer, the JTS TestBuilder can be used to view and run the GeometryFixer on the set of 75 test cases for invalid polygonal geometry in the file TestInvalidA.xml.\n\nIt's been a long time coming, but finally JTS can function as a full-service repair shop for geometry, no matter how mangled it might be.\n\nA recent blog post by Elephant Tamer gives a critical appraisal of the improvements to overlay processing shipped in PostGIS 3.1 with GEOS 3.9. The author is disappointed that PostGIS still reports errors when overlay is used on invalid geometry. However, this is based on a misunderstanding of the technology.\n\nGEOS 3.9 includes OverlayNG, ported from the JTS Topology Suite). It brings a major advance in overlay robustness, along with other improvements (described here and here). Previously, robustness limitations in the overlay algorithm could sometimes cause errors even for inputs which were topologically valid. This was doubly problematic because there was no fully effective way to process the input geometries to avoid the errors. Now, OverlayNG solves this problem completely. Valid inputs will always produce a valid and essentially correct(*) output.\n\n(*) \"Essentially\" correct, because in order to achieve full robustness a snapping heuristic may be applied to the input geometry. However, this is done with a very fine tolerance, so should not appreciably alter the output from the theoretically correct value.\n\nBut for invalid inputs, OverlayNG will still report errors. The reason is that there is a wide variety of gruesome ways in which geometry can be invalid. Automated handling of invalidity would involve expensive extra processing, and also require making assumptions about what area a corrupt geometry is intended to represent. Rather than silently repairing invalid geometry and returning potentially incorrect results, the design decision is to report this situation as an error.\n\nIn fact, OverlayNG is able to handle \"mildly\" invalid polygons, as described in this post. This covers situations which are technically invalid according to the OGC SFS specification, but which still have well-defined topology. This includes self-touching rings (sometimes called \"inverted polygons\" or \"exverted holes\"), and zero-width gores and spikes.\n\nTaking a detailed look at the data used in the blog post, we can see these improvements at work. The dataset is the ecology polygons obtained from the GDOS WFS server. This contains 7662 geometries, of which 10 are invalid. Using the old overlay algorithm, 9 of these invalid polygons cause TopologyException errors. Using OverlayNG, only 4 of them cause errors.\n\nThe polygons that can now be processed successfully are typical \"OGC-invalid\" situations, which do not materially affect the polygonal topology. These include self-touching rings with pinch points:\n\nand zero-width gores:\n\nOf the cases that still cause errors, two are classic small bow-tie errors:\n\nAnd two are wildly invalid self-crossing rings:\n\nThe last two are good examples of geometry which is so invalid that it is impossible to unambiguously decide what area is represented (although ST_MakeValid will happily grind them into something that is technically valid).\n\nUltimately it is the user's responsibility to ensure that geometries to be processed by overlay (and many other PostGIS functions) have valid topology (as reported by ST_IsValid). Ideally this is done by correcting the data at source. But it can also be done a posteriori in the database itself, by either the ST_MakeValid function, or the well-known buffer(0) trick. (Which to use is a topic for another blog post...)\n\nOne improvement that could be made is to check for input validity when OverlayNG throws an error. Then PostGIS can report definitively that an overlay error is caused by invalid input. If there is an overlay error that is not caused by invalidity, the PostGIS team wants to hear about it!\n\nAnd perhaps there is a case to be made for repairing invalid geometry automatically, even if the repair is suspect. Possibly this could be invoked via a flag parameter on the overlay functions. More research is required - feedback is welcome!\n\nThe GEOS geometry API is used by many, many projects to do their heavy geometric lifting. But GEOS has always had a bit of a PR problem. Most of those projects provide a more accessible interface to perform GEOS operations. Some offer a high-level language like Python, R, or SQL (and these typically come with a REPL to make things even easier). Or there are GUIs like QGIS, or a command-line interface (CLI) like GDAL/OGR.\n\nBut you can't do much with GEOS on its own. It is a C/C++ library, and to use it you need to break out the compiler and start cutting code. It's essentially \"headless\". Even for GEOS developers, writing an entire C program just to try out a geometry operation on a dataset is painful, to say the least.\n\nThere is the GEOS XMLTester utility, of course. It processes carefully structured XML files, but that is hardly convenient. (And in case this brings to mind a snide comment like \"2001 called and wants its file format back\", XML actually works very well in JTS and GEOS as a portable and readable format for geometry tests. But I digress.)\n\nJTS (on which GEOS is based) has the TestBuilder GUI, which works well for testing out and visualizing the results of JTS operations. JTS also has a CLI called JtsOp. Writing a GUI for GEOS would be a tall order. But a command-line interface (CLI) is much simpler to code, and has significant utility. In fact there is an interesting project called geos-cli that provides a simple CLI for GEOS. But it's ideal to have the CLI code as part of the GEOS project, since it ensures being up-to-date with the library code, and makes it easy to add operations to test new functionality.\n\nThis need has led to the development of geosop. It is a CLI for GEOS which performs a range of useful tasks:\n\nRun GEOS operations to confirm their semantics\n\nTest the behaviour of GEOS on specific geometric data\n\nTime the performance of operation execution\n\nProfile GEOS code to find hotspots\n\nCheck memory usage characteristics of GEOS code\n\nGenerate spatial data for use in visualization or testing\n\nConvert datasets between WKT and WKB\n\ngeosop has the following capabilities:\n\nRead WKT and WKB from files, standard input, or command-line literals\n\nExecute GEOS operations on the list(s) of input geometries. Binary operations are executed on every pair of input geometries (i.e. the cross join aka Cartesian product)\n\nOutput geometry results in WKT or WKB (or text, for non-geometric results)\n\nDisplay the execution time of data input and operations\n\nDisplay a full log of the command processing\n\nHere's a look at how it works.\n\ngeosop -h gives a list of the options and operations available:\n\ngeosop - GEOS v. 3.10.0dev\n\nExecutes GEOS geometry operations\n\nUsage:\n\ngeosop [OPTION...] opName opArg\n\n-a arg source for A geometries (WKT, WKB, file, stdin,\n\nstdin.wkb)\n\n-b arg source for B geometries (WKT, WKB, file, stdin,\n\nstdin.wkb)\n\n--alimit arg Limit number of A geometries read\n\n-c, --collect Collect input into single geometry\n\n-e, --explode Explode result\n\n-f, --format arg Output format\n\n-h, --help Print help\n\n-p, --precision arg Sets number of decimal places in WKT output\n\n-r, --repeat arg Repeat operation N times\n\n-t, --time Print execution time\n\n-v, --verbose Verbose output\n\nOperations:\n\narea A - computes area for geometry A\n\nboundary A - computes boundary for geometry A\n\nbuffer A N - cmputes the buffer of geometry A\n\ncentroid A - computes centroid for geometry A\n\ncontains A B - tests if geometry A contains geometry B\n\ncontainsPrep A B - tests if geometry A contains geometry B, using PreparedGeometry\n\ncontainsProperlyPrep A B - tests if geometry A properly contains geometry B using PreparedGeometry\n\nconvexHull A - computes convexHull for geometry A\n\ncopy A - computes copy for geometry A\n\ncovers A B - tests if geometry A covers geometry B\n\ncoversPrep A B - tests if geometry A covers geometry B using PreparedGeometry\n\ndifference A B - computes difference of geometry A from B\n\ndifferenceSR A B - computes difference of geometry A from B rounding to a precision scale factor\n\ndistance A B - computes distance between geometry A and B\n\ndistancePrep A B - computes distance between geometry A and B using PreparedGeometry\n\nenvelope A - computes envelope for geometry A\n\ninteriorPoint A - computes interiorPoint for geometry A\n\nintersection A B - computes intersection of geometry A and B\n\nintersectionSR A B - computes intersection of geometry A and B\n\nintersects A B - tests if geometry A and B intersect\n\nintersectsPrep A B - tests if geometry A intersects B using PreparedGeometry\n\nisValid A - tests if geometry A is valid\n\nlength A - computes length for geometry A\n\nmakeValid A - computes makeValid for geometry A\n\nnearestPoints A B - computes nearest points of geometry A and B\n\nnearestPointsPrep A B - computes nearest points of geometry A and B using PreparedGeometry\n\npolygonize A - computes polygonize for geometry A\n\nreducePrecision A N - reduces precision of geometry to a precision scale factor\n\nrelate A B - computes DE-9IM matrix for geometry A and B\n\nsymDifference A B - computes symmetric difference of geometry A and B\n\nsymDifferenceSR A B - computes symmetric difference of geometry A and B\n\nunaryUnion A - computes unaryUnion for geometry A\n\nunion A B - computes union of geometry A and B\n\nunionSR A B - computes union of geometry A and B\n\nMost GEOS operations are provided, and the list will be completed soon.\n\nSome examples of using geosop are below.\n\nCompute the interior point for each country in a world polygons dataset, and output them as WKT:\n\ngeosop -a world.wkt -f wkt interiorPoint\n\nDetermine the time required to compute buffers of distance 1 for each country in the world:\n\ngeosop -a world.wkt --time buffer 1\n\nCompute the union of all countries in Europe:\n\ngeosop -a europe.wkb --collect -f wkb unaryUnion\n\nThe README gives many more examples of how to use the various command-line options. In a subsequent post I'll give some demonstrations of using geosop for various tasks including GEOS testing, performance tuning, and geoprocessing.\n\nFuture Work\n\nThere's potential to make geosop even more useful:\n\nGeoJSON is a popular format for use in spatial toolchains. Adding GeoJSON reading and writing would allow geosop to be more widely used for geo-processing.\n\nAdding SVG output would provide a way to visualize the results of GEOS operations.\n\nImprove support for performance testing by adding operations to generate various kinds of standard test datasets (such as point grids, polygon grids, and random point fields).\n\nAnd of course, work will be ongoing to keep geosop up-to-date as new operations and functionality are added to GEOS."
    }
}