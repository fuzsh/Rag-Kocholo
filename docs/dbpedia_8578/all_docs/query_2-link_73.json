{
    "id": "dbpedia_8578_2",
    "rank": 73,
    "data": {
        "url": "https://shapely.readthedocs.io/en/stable/manual.html",
        "read_more_link": "",
        "language": "en",
        "title": "The Shapely User Manual — Shapely 2.0.5 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://shapely.readthedocs.io/en/stable/_images/linestring.png",
            "https://shapely.readthedocs.io/en/stable/_images/linearring.png",
            "https://shapely.readthedocs.io/en/stable/_images/polygon.png",
            "https://shapely.readthedocs.io/en/stable/_images/polygon2.png",
            "https://shapely.readthedocs.io/en/stable/_images/geometrycollection.png",
            "https://shapely.readthedocs.io/en/stable/_images/multilinestring.png",
            "https://shapely.readthedocs.io/en/stable/_images/multipolygon.png",
            "https://shapely.readthedocs.io/en/stable/_images/difference.png",
            "https://shapely.readthedocs.io/en/stable/_images/intersection-sym-difference.png",
            "https://shapely.readthedocs.io/en/stable/_images/union.png",
            "https://shapely.readthedocs.io/en/stable/_images/buffer.png",
            "https://shapely.readthedocs.io/en/stable/_images/buffer_single_side.png",
            "https://shapely.readthedocs.io/en/stable/_images/convex_hull.png",
            "https://shapely.readthedocs.io/en/stable/_images/minimum_rotated_rectangle.png",
            "https://shapely.readthedocs.io/en/stable/_images/parallel_offset.png",
            "https://shapely.readthedocs.io/en/stable/_images/parallel_offset_mitre.png",
            "https://shapely.readthedocs.io/en/stable/_images/simplify.png",
            "https://shapely.readthedocs.io/en/stable/_images/rotate.png",
            "https://shapely.readthedocs.io/en/stable/_images/scale.png",
            "https://shapely.readthedocs.io/en/stable/_images/skew.png",
            "https://shapely.readthedocs.io/en/stable/_images/unary_union.png",
            "https://shapely.readthedocs.io/en/stable/_images/triangulate.png",
            "https://shapely.readthedocs.io/en/stable/_images/voronoi_diagram.png",
            "https://shapely.readthedocs.io/en/stable/_images/make_valid_multipolygon.png",
            "https://shapely.readthedocs.io/en/stable/_images/make_valid_geometrycollection.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Introduction#\n\nDeterministic spatial analysis is an important component of computational approaches to problems in agriculture, ecology, epidemiology, sociology, and many other fields. What is the surveyed perimeter/area ratio of these patches of animal habitat? Which properties in this town intersect with the 50-year flood contour from this new flooding model? What are the extents of findspots for ancient ceramic wares with maker’s marks “A” and “B”, and where do the extents overlap? What’s the path from home to office that best skirts identified zones of location based spam? These are just a few of the possible questions addressable using non-statistical spatial analysis, and more specifically, computational geometry.\n\nShapely is a Python package for set-theoretic analysis and manipulation of planar features using functions from the well known and widely deployed GEOS library. GEOS, a port of the Java Topology Suite (JTS), is the geometry engine of the PostGIS spatial extension for the PostgreSQL RDBMS. The designs of JTS and GEOS are largely guided by the Open Geospatial Consortium’s Simple Features Access Specification and Shapely adheres mainly to the same set of standard classes and operations. Shapely is thereby deeply rooted in the conventions of the geographic information systems (GIS) world, but aspires to be equally useful to programmers working on non-conventional problems.\n\nThe first premise of Shapely is that Python programmers should be able to perform PostGIS type geometry operations outside of an RDBMS. Not all geographic data originate or reside in a RDBMS or are best processed using SQL. We can load data into a spatial RDBMS to do work, but if there’s no mandate to manage (the “M” in “RDBMS”) the data over time in the database we’re using the wrong tool for the job. The second premise is that the persistence, serialization, and map projection of features are significant, but orthogonal problems. You may not need a hundred GIS format readers and writers or the multitude of State Plane projections, and Shapely doesn’t burden you with them. The third premise is that Python idioms trump GIS (or Java, in this case, since the GEOS library is derived from JTS, a Java project) idioms.\n\nIf you enjoy and profit from idiomatic Python, appreciate packages that do one thing well, and agree that a spatially enabled RDBMS is often enough the wrong tool for your computational geometry job, Shapely might be for you.\n\nSpatial Data Model#\n\nThe fundamental types of geometric objects implemented by Shapely are points, curves, and surfaces. Each is associated with three sets of (possibly infinite) points in the plane. The interior, boundary, and exterior sets of a feature are mutually exclusive and their union coincides with the entire plane .\n\nA Point has an interior set of exactly one point, a boundary set of exactly no points, and an exterior set of all other points. A Point has a topological dimension of 0.\n\nA Curve has an interior set consisting of the infinitely many points along its length (imagine a Point dragged in space), a boundary set consisting of its two end points, and an exterior set of all other points. A Curve has a topological dimension of 1.\n\nA Surface has an interior set consisting of the infinitely many points within (imagine a Curve dragged in space to cover an area), a boundary set consisting of one or more Curves, and an exterior set of all other points including those within holes that might exist in the surface. A Surface has a topological dimension of 2.\n\nThat may seem a bit esoteric, but will help clarify the meanings of Shapely’s spatial predicates, and it’s as deep into theory as this manual will go. Consequences of point-set theory, including some that manifest themselves as “gotchas”, for different classes will be discussed later in this manual.\n\nThe point type is implemented by a Point class; curve by the LineString and LinearRing classes; and surface by a Polygon class. Shapely implements no smooth (i.e. having continuous tangents) curves. All curves must be approximated by linear splines. All rounded patches must be approximated by regions bounded by linear splines.\n\nCollections of points are implemented by a MultiPoint class, collections of curves by a MultiLineString class, and collections of surfaces by a MultiPolygon class. These collections aren’t computationally significant, but are useful for modeling certain kinds of features. A Y-shaped line feature, for example, is well modeled as a whole by a MultiLineString.\n\nThe standard data model has additional constraints specific to certain types of geometric objects that will be discussed in following sections of this manual.\n\nSee also https://web.archive.org/web/20160719195511/http://www.vividsolutions.com/jts/discussion.htm for more illustrations of this data model.\n\nRelationships#\n\nThe spatial data model is accompanied by a group of natural language relationships between geometric objects – contains, intersects, overlaps, touches, etc. – and a theoretical framework for understanding them using the 3x3 matrix of the mutual intersections of their component point sets : the DE-9IM. A comprehensive review of the relationships in terms of the DE-9IM is found in and will not be reiterated in this manual.\n\nOperations#\n\nFollowing the JTS technical specs , this manual will make a distinction between constructive (buffer, convex hull) and set-theoretic operations (intersection, union, etc.). The individual operations will be fully described in a following section of the manual.\n\nCoordinate Systems#\n\nEven though the Earth is not flat – and for that matter not exactly spherical – there are many analytic problems that can be approached by transforming Earth features to a Cartesian plane, applying tried and true algorithms, and then transforming the results back to geographic coordinates. This practice is as old as the tradition of accurate paper maps.\n\nShapely does not support coordinate system transformations. All operations on two or more features presume that the features exist in the same Cartesian plane.\n\nGeometric Objects#\n\nGeometric objects are created in the typical Python fashion, using the classes themselves as instance factories. A few of their intrinsic properties will be discussed in this sections, others in the following sections on operations and serializations.\n\nInstances of Point, LineString, and LinearRing have as their most important attribute a finite sequence of coordinates that determines their interior, boundary, and exterior point sets. A line string can be determined by as few as 2 points, but contains an infinite number of points. Coordinate sequences are immutable. A third z coordinate value may be used when constructing instances, but has no effect on geometric analysis. All operations are performed in the x-y plane.\n\nIn all constructors, numeric values are converted to type float. In other words, Point(0, 0) and Point(0.0, 0.0) produce geometrically equivalent instances. Shapely does not check the topological simplicity or validity of instances when they are constructed as the cost is unwarranted in most cases. Validating factories are easily implemented using the :attr:is_valid predicate by users that require them.\n\nNote\n\nShapely is a planar geometry library and z, the height above or below the plane, is ignored in geometric analysis. There is a potential pitfall for users here: coordinate tuples that differ only in z are not distinguished from each other and their application can result in surprisingly invalid geometry objects. For example, LineString([(0, 0, 0), (0, 0, 1)]) does not return a vertical line of unit length, but an invalid line in the plane with zero length. Similarly, Polygon([(0, 0, 0), (0, 0, 1), (1, 1, 1)]) is not bounded by a closed ring and is invalid.\n\nGeneral Attributes and Methods#\n\nobject.area#\n\nReturns the area (float) of the object.\n\nobject.bounds#\n\nReturns a (minx, miny, maxx, maxy) tuple (float values) that bounds the object.\n\nobject.length#\n\nReturns the length (float) of the object.\n\nobject.minimum_clearance#\n\nReturns the smallest distance by which a node could be moved to produce an invalid geometry.\n\nThis can be thought of as a measure of the robustness of a geometry, where larger values of minimum clearance indicate a more robust geometry. If no minimum clearance exists for a geometry, such as a point, this will return math.infinity.\n\nNew in Shapely 1.7.1\n\nRequires GEOS 3.6 or higher.\n\n>>> from shapely import Polygon >>> Polygon([[0, 0], [1, 0], [1, 1], [0, 1], [0, 0]]).minimum_clearance 1.0\n\nobject.geom_type#\n\nReturns a string specifying the Geometry Type of the object in accordance with .\n\n>>> from shapely import Point, LineString >>> Point(0, 0).geom_type 'Point'\n\nobject.distance(other)#\n\nReturns the minimum distance (float) to the other geometric object.\n\n>>> Point(0,0).distance(Point(1,1)) 1.4142135623730951\n\nobject.hausdorff_distance(other)#\n\nReturns the Hausdorff distance (float) to the other geometric object. The Hausdorff distance between two geometries is the furthest distance that a point on either geometry can be from the nearest point to it on the other geometry.\n\nNew in Shapely 1.6.0\n\n>>> point = Point(1, 1) >>> line = LineString([(2, 0), (2, 4), (3, 4)]) >>> point.hausdorff_distance(line) 3.605551275463989 >>> point.distance(Point(3, 4)) 3.605551275463989\n\nobject.representative_point()#\n\nReturns a cheaply computed point that is guaranteed to be within the geometric object.\n\nNote\n\nThis is not in general the same as the centroid.\n\n>>> donut = Point(0, 0).buffer(2.0).difference(Point(0, 0).buffer(1.0)) >>> donut.centroid <POINT (0 0)> >>> donut.representative_point() <POINT (1.498 0.049)>\n\nPoints#\n\nclassPoint(coordinates)#\n\nThe Point constructor takes positional coordinate values or point tuple parameters.\n\n>>> from shapely import Point >>> point = Point(0.0, 0.0) >>> q = Point((0.0, 0.0))\n\nA Point has zero area and zero length.\n\n>>> point.area 0.0 >>> point.length 0.0\n\nIts x-y bounding box is a (minx, miny, maxx, maxy) tuple.\n\n>>> point.bounds (0.0, 0.0, 0.0, 0.0)\n\nCoordinate values are accessed via coords, x, y, and z properties.\n\n>>> list(point.coords) [(0.0, 0.0)] >>> point.x 0.0 >>> point.y 0.0\n\nCoordinates may also be sliced. New in version 1.2.14.\n\n>>> point.coords[:] [(0.0, 0.0)]\n\nThe Point constructor also accepts another Point instance, thereby making a copy.\n\n>>> Point(point) <POINT (0 0)>\n\nLineStrings#\n\nclassLineString(coordinates)#\n\nThe LineString constructor takes an ordered sequence of 2 or more (x, y[, z]) point tuples.\n\nThe constructed LineString object represents one or more connected linear splines between the points. Repeated points in the ordered sequence are allowed, but may incur performance penalties and should be avoided. A LineString may cross itself (i.e. be complex and not simple).\n\n(Source code, png, hires.png, pdf)\n\nFigure 1. A simple LineString on the left, a complex LineString on the right. The (MultiPoint) boundary of each is shown in black, the other points that describe the lines are shown in grey.\n\nA LineString has zero area and non-zero length.\n\n>>> from shapely import LineString >>> line = LineString([(0, 0), (1, 1)]) >>> line.area 0.0 >>> line.length 1.4142135623730951\n\nIts x-y bounding box is a (minx, miny, maxx, maxy) tuple.\n\n>>> line.bounds (0.0, 0.0, 1.0, 1.0)\n\nThe defining coordinate values are accessed via the coords property.\n\n>>> len(line.coords) 2 >>> list(line.coords) [(0.0, 0.0), (1.0, 1.0)]\n\nCoordinates may also be sliced. New in version 1.2.14.\n\n>>> line.coords[:] [(0.0, 0.0), (1.0, 1.0)] >>> line.coords[1:] [(1.0, 1.0)]\n\nThe constructor also accepts another LineString instance, thereby making a copy.\n\n>>> LineString(line) <LINESTRING (0 0, 1 1)>\n\nA LineString may also be constructed using a sequence of mixed Point instances or coordinate tuples. The individual coordinates are copied into the new object.\n\n>>> LineString([Point(0.0, 1.0), (2.0, 3.0), Point(4.0, 5.0)]) <LINESTRING (0 1, 2 3, 4 5)>\n\nLinearRings#\n\nclassLinearRing(coordinates)#\n\nThe LinearRing constructor takes an ordered sequence of (x, y[, z]) point tuples.\n\nThe sequence may be explicitly closed by passing identical values in the first and last indices. Otherwise, the sequence will be implicitly closed by copying the first tuple to the last index. As with a LineString, repeated points in the ordered sequence are allowed, but may incur performance penalties and should be avoided. A LinearRing may not cross itself, and may not touch itself at a single point.\n\n(Source code, png, hires.png, pdf)\n\nFigure 2. A valid LinearRing on the left, an invalid self-touching LinearRing on the right. The points that describe the rings are shown in grey. A ring’s boundary is empty.\n\nNote\n\nShapely will not prevent the creation of such rings, but exceptions will be raised when they are operated on.\n\nA LinearRing has zero area and non-zero length.\n\n>>> from shapely import LinearRing >>> ring = LinearRing([(0, 0), (1, 1), (1, 0)]) >>> ring.area 0.0 >>> ring.length 3.414213562373095\n\nIts x-y bounding box is a (minx, miny, maxx, maxy) tuple.\n\n>>> ring.bounds (0.0, 0.0, 1.0, 1.0)\n\nDefining coordinate values are accessed via the coords property.\n\n>>> len(ring.coords) 4 >>> list(ring.coords) [(0.0, 0.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)]\n\nThe LinearRing constructor also accepts another LineString or LinearRing instance, thereby making a copy.\n\n>>> LinearRing(ring) <LINEARRING (0 0, 1 1, 1 0, 0 0)>\n\nAs with LineString, a sequence of Point instances is not a valid constructor parameter.\n\nPolygons#\n\nclassPolygon(shell[, holes=None])#\n\nThe Polygon constructor takes two positional parameters. The first is an ordered sequence of (x, y[, z]) point tuples and is treated exactly as in the LinearRing case. The second is an optional unordered sequence of ring-like sequences specifying the interior boundaries or “holes” of the feature.\n\nRings of a valid Polygon may not cross each other, but may touch at a single point only. Again, Shapely will not prevent the creation of invalid features, but exceptions will be raised when they are operated on.\n\n(Source code, png, hires.png, pdf)\n\nFigure 3. On the left, a valid Polygon with one interior ring that touches the exterior ring at one point, and on the right a Polygon that is invalid because its interior ring touches the exterior ring at more than one point. The points that describe the rings are shown in grey.\n\n(Source code, png, hires.png, pdf)\n\nFigure 4. On the left, a Polygon that is invalid because its exterior and interior rings touch along a line, and on the right, a Polygon that is invalid because its interior rings touch along a line.\n\nA Polygon has non-zero area and non-zero length.\n\n>>> from shapely import Polygon >>> polygon = Polygon([(0, 0), (1, 1), (1, 0)]) >>> polygon.area 0.5 >>> polygon.length 3.414213562373095\n\nIts x-y bounding box is a (minx, miny, maxx, maxy) tuple.\n\n>>> polygon.bounds (0.0, 0.0, 1.0, 1.0)\n\nComponent rings are accessed via exterior and interiors properties.\n\n>>> list(polygon.exterior.coords) [(0.0, 0.0), (1.0, 1.0), (1.0, 0.0), (0.0, 0.0)] >>> list(polygon.interiors) []\n\nThe Polygon constructor also accepts instances of LineString and LinearRing.\n\n>>> coords = [(0, 0), (1, 1), (1, 0)] >>> r = LinearRing(coords) >>> s = Polygon(r) >>> s.area 0.5 >>> t = Polygon(s.buffer(1.0).exterior, [r]) >>> t.area 6.5507620529190325\n\nRectangular polygons occur commonly, and can be conveniently constructed using the shapely.geometry.box() function.\n\nshapely.geometry.box(minx, miny, maxx, maxy, ccw=True)#\n\nMakes a rectangular polygon from the provided bounding box values, with counter-clockwise order by default.\n\nNew in version 1.2.9.\n\nFor example:\n\n>>> from shapely import box >>> b = box(0.0, 0.0, 1.0, 1.0) >>> b <POLYGON ((1 0, 1 1, 0 1, 0 0, 1 0))> >>> list(b.exterior.coords) [(1.0, 0.0), (1.0, 1.0), (0.0, 1.0), (0.0, 0.0), (1.0, 0.0)]\n\nThis is the first appearance of an explicit polygon handedness in Shapely.\n\nTo obtain a polygon with a known orientation, use shapely.geometry.polygon.orient():\n\nshapely.geometry.polygon.orient(polygon, sign=1.0)#\n\nReturns a properly oriented copy of the given polygon. The signed area of the result will have the given sign. A sign of 1.0 means that the coordinates of the product’s exterior ring will be oriented counter-clockwise and the interior rings (holes) will be oriented clockwise.\n\nNew in version 1.2.10.\n\nCollections#\n\nHeterogeneous collections of geometric objects may result from some Shapely operations. For example, two LineStrings may intersect along a line and at a point. To represent these kind of results, Shapely provides frozenset-like, immutable collections of geometric objects. The collections may be homogeneous (MultiPoint etc.) or heterogeneous.\n\n>>> a = LineString([(0, 0), (1, 1), (1,2), (2,2)]) >>> b = LineString([(0, 0), (1, 1), (2,1), (2,2)]) >>> x = a.intersection(b) >>> x <GEOMETRYCOLLECTION (LINESTRING (0 0, 1 1), POINT (2 2))> >>> list(x.geoms) [<LINESTRING (0 0, 1 1)>, <POINT (2 2)>]\n\n(Source code, png, hires.png, pdf)\n\nFigure 5. a) a green and a yellow line that intersect along a line and at a single point; b) the intersection (in blue) is a collection containing one LineString and one Point.\n\nMembers of a GeometryCollection are accessed via the geoms property.\n\n>>> list(x.geoms) [<LINESTRING (0 0, 1 1)>, <POINT (2 2)>]\n\nNote\n\nWhen possible, it is better to use one of the homogeneous collection types described below.\n\nCollections of Points#\n\nclassMultiPoint(points)#\n\nThe MultiPoint constructor takes a sequence of (x, y[, z ]) point tuples.\n\nA MultiPoint has zero area and zero length.\n\n>>> from shapely import MultiPoint >>> points = MultiPoint([(0.0, 0.0), (1.0, 1.0)]) >>> points.area 0.0 >>> points.length 0.0\n\nIts x-y bounding box is a (minx, miny, maxx, maxy) tuple.\n\n>>> points.bounds (0.0, 0.0, 1.0, 1.0)\n\nMembers of a multi-point collection are accessed via the geoms property.\n\n>>> list(points.geoms) [<POINT (0 0)>, <POINT (1 1)>]\n\nThe constructor also accepts another MultiPoint instance or an unordered sequence of Point instances, thereby making copies.\n\n>>> MultiPoint([Point(0, 0), Point(1, 1)]) <MULTIPOINT (0 0, 1 1)>\n\nCollections of Polygons#\n\nclassMultiPolygon(polygons)#\n\nThe MultiPolygon constructor takes a sequence of exterior ring and hole list tuples: [((a1, …, aM), [(b1, …, bN), …]), …].\n\nMore clearly, the constructor also accepts an unordered sequence of Polygon instances, thereby making copies.\n\n>>> from shapely import MultiPolygon >>> polygons = MultiPolygon([polygon, s, t]) >>> len(polygons.geoms) 3\n\n(Source code, png, hires.png, pdf)\n\nFigure 7. On the left, a valid MultiPolygon with 2 members, and on the right, a MultiPolygon that is invalid because its members touch at an infinite number of points (along a line).\n\nIts x-y bounding box is a (minx, miny, maxx, maxy) tuple.\n\n>>> polygons.bounds (-1.0, -1.0, 2.0, 2.0)\n\nIts members are instances of Polygon and are accessed via the geoms property.\n\n>>> len(polygons.geoms) 3\n\nEmpty features#\n\nAn “empty” feature is one with a point set that coincides with the empty set; not None, but like set([]). Empty features can be created by calling the various constructors with no arguments. Almost no operations are supported by empty features.\n\n>>> line = LineString() >>> line.is_empty True >>> line.length 0.0 >>> line.bounds (nan, nan, nan, nan) >>> list(line.coords) []\n\nCoordinate sequences#\n\nThe list of coordinates that describe a geometry are represented as the CoordinateSequence object. These sequences should not be initialised directly, but can be accessed from an existing geometry as the Geometry.coords property.\n\n>>> line = LineString([(0, 1), (2, 3), (4, 5)]) >>> line.coords <shapely.coords.CoordinateSequence object at ...>\n\nCoordinate sequences can be indexed, sliced and iterated over as if they were a list of coordinate tuples.\n\n>>> line.coords[0] (0.0, 1.0) >>> line.coords[1:] [(2.0, 3.0), (4.0, 5.0)] >>> for x, y in line.coords: ... print(\"x={}, y={}\".format(x, y)) ... x=0.0, y=1.0 x=2.0, y=3.0 x=4.0, y=5.0\n\nPolygons have a coordinate sequence for their exterior and each of their interior rings.\n\n>>> poly = Polygon([(0, 0), (0, 1), (1, 1), (0, 0)]) >>> poly.exterior.coords <shapely.coords.CoordinateSequence object at ...>\n\nMultipart geometries do not have a coordinate sequence. Instead the coordinate sequences are stored on their component geometries.\n\n>>> p = MultiPoint([(0, 0), (1, 1), (2, 2)]) >>> p.geoms[2].coords <shapely.coords.CoordinateSequence object at ...>\n\nLinear Referencing Methods#\n\nIt can be useful to specify position along linear features such as LineStrings and MultiLineStrings with a 1-dimensional referencing system. Shapely supports linear referencing based on length or distance, evaluating the distance along a geometric object to the projection of a given point, or the point at a given distance along the object.\n\nobject.interpolate(distance[, normalized=False])#\n\nReturn a point at the specified distance along a linear geometric object.\n\nIf the normalized arg is True, the distance will be interpreted as a fraction of the geometric object’s length.\n\n>>> ip = LineString([(0, 0), (0, 1), (1, 1)]).interpolate(1.5) >>> ip <POINT (0.5 1)> >>> LineString([(0, 0), (0, 1), (1, 1)]).interpolate(0.75, normalized=True) <POINT (0.5 1)>\n\nobject.project(other[, normalized=False])#\n\nReturns the distance along this geometric object to a point nearest the other object.\n\nIf the normalized arg is True, return the distance normalized to the length of the object. The project() method is the inverse of interpolate().\n\n>>> LineString([(0, 0), (0, 1), (1, 1)]).project(ip) 1.5 >>> LineString([(0, 0), (0, 1), (1, 1)]).project(ip, normalized=True) 0.75\n\nFor example, the linear referencing methods might be used to cut lines at a specified distance.\n\ndef cut(line, distance): # Cuts a line in two at a distance from its starting point if distance <= 0.0 or distance >= line.length: return [LineString(line)] coords = list(line.coords) for i, p in enumerate(coords): pd = line.project(Point(p)) if pd == distance: return [ LineString(coords[:i+1]), LineString(coords[i:])] if pd > distance: cp = line.interpolate(distance) return [ LineString(coords[:i] + [(cp.x, cp.y)]), LineString([(cp.x, cp.y)] + coords[i:])]\n\n>>> line = LineString([(0, 0), (1, 0), (2, 0), (3, 0), (4, 0), (5, 0)]) >>> print([list(x.coords) for x in cut(line, 1.0)]) [[(0.0, 0.0), (1.0, 0.0)], [(1.0, 0.0), (2.0, 0.0), (3.0, 0.0), (4.0, 0.0), (5.0, 0.0)]] >>> print([list(x.coords) for x in cut(line, 2.5)]) [[(0.0, 0.0), (1.0, 0.0), (2.0, 0.0), (2.5, 0.0)], [(2.5, 0.0), (3.0, 0.0), (4.0, 0.0), (5.0, 0.0)]]\n\nPredicates and Relationships#\n\nObjects of the types explained in Geometric Objects provide standard predicates as attributes (for unary predicates) and methods (for binary predicates). Whether unary or binary, all return True or False.\n\nUnary Predicates#\n\nStandard unary predicates are implemented as read-only property attributes. An example will be shown for each.\n\nobject.has_z#\n\nReturns True if the feature has not only x and y, but also z coordinates for 3D (or so-called, 2.5D) geometries.\n\n>>> Point(0, 0).has_z False >>> Point(0, 0, 0).has_z True\n\nobject.is_ccw#\n\nReturns True if coordinates are in counter-clockwise order (bounding a region with positive signed area). This method applies to LinearRing objects only.\n\nNew in version 1.2.10.\n\n>>> LinearRing([(1,0), (1,1), (0,0)]).is_ccw True\n\nA ring with an undesired orientation can be reversed like this:\n\n>>> ring = LinearRing([(0,0), (1,1), (1,0)]) >>> ring.is_ccw False >>> ring2 = LinearRing(list(ring.coords)[::-1]) >>> ring2.is_ccw True\n\nobject.is_empty#\n\nReturns True if the feature’s interior and boundary (in point set terms) coincide with the empty set.\n\n>>> Point().is_empty True >>> Point(0, 0).is_empty False\n\nNote\n\nWith the help of the operator module’s attrgetter() function, unary predicates such as is_empty can be easily used as predicates for the built in filter().\n\n>>> from operator import attrgetter >>> empties = filter(attrgetter('is_empty'), [Point(), Point(0, 0)]) >>> len(list(empties)) 1\n\nobject.is_ring#\n\nReturns True if the feature is a closed and simple LineString. A closed feature’s boundary coincides with the empty set.\n\n>>> LineString([(0, 0), (1, 1), (1, -1)]).is_ring False >>> LinearRing([(0, 0), (1, 1), (1, -1)]).is_ring True\n\nThis property is applicable to LineString and LinearRing instances, but meaningless for others.\n\nobject.is_simple#\n\nReturns True if the feature does not cross itself.\n\nNote\n\nThe simplicity test is meaningful only for LineStrings and LinearRings.\n\n>>> LineString([(0, 0), (1, 1), (1, -1), (0, 1)]).is_simple False\n\nOperations on non-simple LineStrings are fully supported by Shapely.\n\nobject.is_valid#\n\nReturns True if a feature is “valid” in the sense of .\n\nNote\n\nThe validity test is meaningful only for Polygons and MultiPolygons. True is always returned for other types of geometries.\n\nA valid Polygon may not possess any overlapping exterior or interior rings. A valid MultiPolygon may not collect any overlapping polygons. Operations on invalid features may fail.\n\n>>> MultiPolygon([Point(0, 0).buffer(2.0), Point(1, 1).buffer(2.0)]).is_valid False\n\nThe two points above are close enough that the polygons resulting from the buffer operations (explained in a following section) overlap.\n\nNote\n\nThe is_valid predicate can be used to write a validating decorator that could ensure that only valid objects are returned from a constructor function.\n\nfrom functools import wraps def validate(func): @wraps(func) def wrapper(*args, **kwargs): ob = func(*args, **kwargs) if not ob.is_valid: raise TopologicalError( \"Given arguments do not determine a valid geometric object\") return ob return wrapper\n\n>>> @validate ... def ring(coordinates): ... return LinearRing(coordinates) ... >>> coords = [(0, 0), (1, 1), (1, -1), (0, 1)] >>> ring(coords) Traceback (most recent call last): File \"<stdin>\", line 1, in <module> File \"<stdin>\", line 7, in wrapper shapely.geos.TopologicalError: Given arguments do not determine a valid geometric object\n\nBinary Predicates#\n\nStandard binary predicates are implemented as methods. These predicates evaluate topological, set-theoretic relationships. In a few cases the results may not be what one might expect starting from different assumptions. All take another geometric object as argument and return True or False.\n\nobject.__eq__(other)#\n\nReturns True if the two objects are of the same geometric type, and the coordinates of the two objects match precisely.\n\nobject.equals(other)#\n\nReturns True if the set-theoretic boundary, interior, and exterior of the object coincide with those of the other.\n\nThe coordinates passed to the object constructors are of these sets, and determine them, but are not the entirety of the sets. This is a potential “gotcha” for new users. Equivalent lines, for example, can be constructed differently.\n\n>>> a = LineString([(0, 0), (1, 1)]) >>> b = LineString([(0, 0), (0.5, 0.5), (1, 1)]) >>> c = LineString([(0, 0), (0, 0), (1, 1)]) >>> a.equals(b) True >>> a == b False >>> b.equals(c) True >>> b == c False\n\nobject.equals_exact(other, tolerance)#\n\nReturns True if the object is within a specified tolerance.\n\nobject.contains(other)#\n\nReturns True if no points of other lie in the exterior of the object and at least one point of the interior of other lies in the interior of object.\n\nThis predicate applies to all types, and is inverse to within(). The expression a.contains(b) == b.within(a) always evaluates to True.\n\n>>> coords = [(0, 0), (1, 1)] >>> LineString(coords).contains(Point(0.5, 0.5)) True >>> Point(0.5, 0.5).within(LineString(coords)) True\n\nA line’s endpoints are part of its boundary and are therefore not contained.\n\n>>> LineString(coords).contains(Point(1.0, 1.0)) False\n\nNote\n\nBinary predicates can be used directly as predicates for filter() or itertools.ifilter().\n\n>>> line = LineString(coords) >>> contained = list(filter(line.contains, [Point(), Point(0.5, 0.5)])) >>> len(contained) 1 >>> contained [<POINT (0.5 0.5)>]\n\nobject.covers(other)#\n\nReturns True if every point of other is a point on the interior or boundary of object. This is similar to object.contains(other) except that this does not require any interior points of other to lie in the interior of object.\n\nobject.covered_by(other)#\n\nReturns True if every point of object is a point on the interior or boundary of other. This is equivalent to other.covers(object).\n\nNew in version 1.8.\n\nobject.crosses(other)#\n\nReturns True if the interior of the object intersects the interior of the other but does not contain it, and the dimension of the intersection is less than the dimension of the one or the other.\n\n>>> LineString(coords).crosses(LineString([(0, 1), (1, 0)])) True\n\nA line does not cross a point that it contains.\n\n>>> LineString(coords).crosses(Point(0.5, 0.5)) False\n\nobject.disjoint(other)#\n\nReturns True if the boundary and interior of the object do not intersect at all with those of the other.\n\n>>> Point(0, 0).disjoint(Point(1, 1)) True\n\nThis predicate applies to all types and is the inverse of intersects().\n\nobject.intersects(other)#\n\nReturns True if the boundary or interior of the object intersect in any way with those of the other.\n\nIn other words, geometric objects intersect if they have any boundary or interior point in common.\n\nobject.overlaps(other)#\n\nReturns True if the geometries have more than one but not all points in common, have the same dimension, and the intersection of the interiors of the geometries has the same dimension as the geometries themselves.\n\nobject.touches(other)#\n\nReturns True if the objects have at least one point in common and their interiors do not intersect with any part of the other.\n\nOverlapping features do not therefore touch, another potential “gotcha”. For example, the following lines touch at (1, 1), but do not overlap.\n\n>>> a = LineString([(0, 0), (1, 1)]) >>> b = LineString([(1, 1), (2, 2)]) >>> a.touches(b) True\n\nobject.within(other)#\n\nReturns True if the object’s boundary and interior intersect only with the interior of the other (not its boundary or exterior).\n\nThis applies to all types and is the inverse of contains().\n\nUsed in a sorted() key, within() makes it easy to spatially sort objects. Let’s say we have 4 stereotypic features: a point that is contained by a polygon which is itself contained by another polygon, and a free spirited point contained by none\n\n>>> a = Point(2, 2) >>> b = Polygon([[1, 1], [1, 3], [3, 3], [3, 1]]) >>> c = Polygon([[0, 0], [0, 4], [4, 4], [4, 0]]) >>> d = Point(-1, -1)\n\nand that copies of these are collected into a list\n\n>>> features = [c, a, d, b, c]\n\nthat we’d prefer to have ordered as [d, c, c, b, a] in reverse containment order. As explained in the Python Sorting HowTo, we can define a key function that operates on each list element and returns a value for comparison. Our key function will be a wrapper class that implements __lt__() using Shapely’s binary within() predicate.\n\n>>> class Within: ... def __init__(self, o): ... self.o = o ... def __lt__(self, other): ... return self.o.within(other.o)\n\nAs the howto says, the less than comparison is guaranteed to be used in sorting. That’s what we’ll rely on to spatially sort. Trying it out on features d and c, we see that it works.\n\n>>> Within(d) < Within(c) False\n\nIt also works on the list of features, producing the order we want.\n\n>>> [d, c, c, b, a] == sorted(features, key=Within, reverse=True) True\n\nDE-9IM Relationships#\n\nThe relate() method tests all the DE-9IM relationships between objects, of which the named relationship predicates above are a subset.\n\nobject.relate(other)#\n\nReturns a string representation of the DE-9IM matrix of relationships between an object’s interior, boundary, exterior and those of another geometric object.\n\nThe named relationship predicates (contains(), etc.) are typically implemented as wrappers around relate().\n\nTwo different points have mainly F (false) values in their matrix; the intersection of their external sets (the 9th element) is a 2 dimensional object (the rest of the plane). The intersection of the interior of one with the exterior of the other is a 0 dimensional object (3rd and 7th elements of the matrix).\n\n>>> Point(0, 0).relate(Point(1, 1)) 'FF0FFF0F2'\n\nThe matrix for a line and a point on the line has more “true” (not F) elements.\n\n>>> Point(0, 0).relate(LineString([(0, 0), (1, 1)])) 'F0FFFF102'\n\nobject.relate_pattern(other, pattern)#\n\nReturns True if the DE-9IM string code for the relationship between the geometries satisfies the pattern, otherwise False.\n\nThe relate_pattern() compares the DE-9IM code string for two geometries against a specified pattern. If the string matches the pattern then True is returned, otherwise False. The pattern specified can be an exact match (0, 1 or 2), a boolean match (T or F), or a wildcard (*). For example, the pattern for the within predicate is T*****FF*.\n\n>>> point = Point(0.5, 0.5) >>> square = Polygon([(0, 0), (0, 1), (1, 1), (1, 0)]) >>> square.relate_pattern(point, 'T*****FF*') True >>> point.within(square) True\n\nNote that the order or the geometries is significant, as demonstrated below. In this example the square contains the point, but the point does not contain the square.\n\n>>> point.relate(square) '0FFFFF212' >>> square.relate(point) '0F2FF1FF2'\n\nFurther discussion of the DE-9IM matrix is beyond the scope of this manual. See and https://pypi.org/project/de9im/.\n\nSpatial Analysis Methods#\n\nAs well as boolean attributes and methods, Shapely provides analysis methods that return new geometric objects.\n\nSet-theoretic Methods#\n\nAlmost every binary predicate method has a counterpart that returns a new geometric object. In addition, the set-theoretic boundary of an object is available as a read-only attribute.\n\nNote\n\nThese methods will always return a geometric object. An intersection of disjoint geometries for example will return an empty GeometryCollection, not None or False. To test for a non-empty result, use the geometry’s is_empty property.\n\nobject.boundary#\n\nReturns a lower dimensional object representing the object’s set-theoretic boundary.\n\nThe boundary of a polygon is a line, the boundary of a line is a collection of points. The boundary of a point is an empty collection.\n\n>>> coords = [((0, 0), (1, 1)), ((-1, 0), (1, 0))] >>> lines = MultiLineString(coords) >>> lines.boundary <MULTIPOINT (-1 0, 0 0, 1 0, 1 1)> >>> list(lines.boundary.geoms) [<POINT (-1 0)>, <POINT (0 0)>, <POINT (1 0)>, <POINT (1 1)>] >>> lines.boundary.boundary <GEOMETRYCOLLECTION EMPTY>\n\nSee the figures in LineStrings and Collections of Lines for the illustration of lines and their boundaries.\n\nobject.centroid#\n\nReturns a representation of the object’s geometric centroid (point).\n\n>>> LineString([(0, 0), (1, 1)]).centroid <POINT (0.5 0.5)>\n\nNote\n\nThe centroid of an object might be one of its points, but this is not guaranteed.\n\nobject.difference(other)#\n\nReturns a representation of the points making up this geometric object that do not make up the other object.\n\n>>> a = Point(1, 1).buffer(1.5) >>> b = Point(2, 1).buffer(1.5) >>> a.difference(b) <POLYGON ((1.435 -0.435, 1.293 -0.471, 1.147 -0.493, 1 -0.5, 0.853 -0.493, 0...>\n\nNote\n\nThe buffer() method is used to produce approximately circular polygons in the examples of this section; it will be explained in detail later in this manual.\n\n(Source code, png, hires.png, pdf)\n\nFigure 8. Differences between two approximately circular polygons.\n\nNote\n\nShapely can not represent the difference between an object and a lower dimensional object (such as the difference between a polygon and a line or point) as a single object, and in these cases the difference method returns a copy of the object named self.\n\nobject.intersection(other)#\n\nReturns a representation of the intersection of this object with the other geometric object.\n\n>>> a = Point(1, 1).buffer(1.5) >>> b = Point(2, 1).buffer(1.5) >>> a.intersection(b) <POLYGON ((2.493 0.853, 2.471 0.707, 2.435 0.565, 2.386 0.426, 2.323 0.293, ...>\n\nSee the figure under symmetric_difference() below.\n\nobject.symmetric_difference(other)#\n\nReturns a representation of the points in this object not in the other geometric object, and the points in the other not in this geometric object.\n\n>>> a = Point(1, 1).buffer(1.5) >>> b = Point(2, 1).buffer(1.5) >>> a.symmetric_difference(b) <MULTIPOLYGON (((1.574 -0.386, 1.707 -0.323, 1.833 -0.247, 1.952 -0.16, 2.06...>\n\n(Source code, png, hires.png, pdf)\n\nobject.union(other)#\n\nReturns a representation of the union of points from this object and the other geometric object.\n\nThe type of object returned depends on the relationship between the operands. The union of polygons (for example) will be a polygon or a multi-polygon depending on whether they intersect or not.\n\n>>> a = Point(1, 1).buffer(1.5) >>> b = Point(2, 1).buffer(1.5) >>> a.union(b) <POLYGON ((1.435 -0.435, 1.293 -0.471, 1.147 -0.493, 1 -0.5, 0.853 -0.493, 0...>\n\nThe semantics of these operations vary with type of geometric object. For example, compare the boundary of the union of polygons to the union of their boundaries.\n\n>>> a.union(b).boundary <LINESTRING (1.435 -0.435, 1.293 -0.471, 1.147 -0.493, 1 -0.5, 0.853 -0.493,...> >>> a.boundary.union(b.boundary) <MULTILINESTRING ((2.5 1, 2.493 0.853, 2.471 0.707, 2.435 0.565, 2.386 0.426...>\n\n(Source code, png, hires.png, pdf)\n\nNote\n\nunion() is an expensive way to find the cumulative union of many objects. See shapely.unary_union() for a more effective method.\n\nSeveral of these set-theoretic methods can be invoked using overloaded operators:\n\nintersection can be accessed with and, &\n\nunion can be accessed with or, |\n\ndifference can be accessed with minus, -\n\nsymmetric_difference can be accessed with xor, ^\n\n>>> from shapely import wkt >>> p1 = wkt.loads('POLYGON((0 0, 1 0, 1 1, 0 1, 0 0))') >>> p2 = wkt.loads('POLYGON((0.5 0, 1.5 0, 1.5 1, 0.5 1, 0.5 0))') >>> p1 & p2 <POLYGON ((0.5 0, 0.5 1, 1 1, 1 0, 0.5 0))> >>> p1 | p2 <POLYGON ((0 0, 0 1, 0.5 1, 1 1, 1.5 1, 1.5 0, 1 0, 0.5 0, 0 0))> >>> p1 - p2 <POLYGON ((0 0, 0 1, 0.5 1, 0.5 0, 0 0))> >>> (p1 ^ p2).wkt 'MULTIPOLYGON (((0 0, 0 1, 0.5 1, 0.5 0, 0 0)), ((1 1, 1.5 1, 1.5 0, 1 0, 1 1)))'\n\nConstructive Methods#\n\nShapely geometric object have several methods that yield new objects not derived from set-theoretic analysis.\n\nobject.buffer(distance, quad_segs=16, cap_style=1, join_style=1, mitre_limit=5.0, single_sided=False)#\n\nReturns an approximate representation of all points within a given distance of the this geometric object.\n\nThe styles of caps are specified by integer values: 1 (round), 2 (flat), 3 (square). These values are also enumerated by the object shapely.BufferCapStyle (see below).\n\nThe styles of joins between offset segments are specified by integer values: 1 (round), 2 (mitre), and 3 (bevel). These values are also enumerated by the object shapely.BufferJoinStyle (see below).\n\nshapely.BufferCapStyle#\n\nAttribute\n\nValue\n\nround\n\n1\n\nflat\n\n2\n\nsquare\n\n3\n\nshapely.BufferJoinStyle#\n\nAttribute\n\nValue\n\nround\n\n1\n\nmitre\n\n2\n\nbevel\n\n3\n\n>>> from shapely import BufferCapStyle, BufferJoinStyle >>> BufferCapStyle.flat.value 2 >>> BufferJoinStyle.bevel.value 3\n\nA positive distance has an effect of dilation; a negative distance, erosion. The optional quad_segs argument determines the number of segments used to approximate a quarter circle around a point.\n\n>>> line = LineString([(0, 0), (1, 1), (0, 2), (2, 2), (3, 1), (1, 0)]) >>> dilated = line.buffer(0.5) >>> eroded = dilated.buffer(-0.3)\n\n(Source code, png, hires.png, pdf)\n\nFigure 9. Dilation of a line (left) and erosion of a polygon (right). New object is shown in blue.\n\nThe default (quad_segs of 16) buffer of a point is a polygonal patch with 99.8% of the area of the circular disk it approximates.\n\n>>> p = Point(0, 0).buffer(10.0) >>> len(p.exterior.coords) 65 >>> p.area 313.6548490545941\n\nWith a quad_segs of 1, the buffer is a square patch.\n\n>>> q = Point(0, 0).buffer(10.0, 1) >>> len(q.exterior.coords) 5 >>> q.area 200.0\n\nYou may want a buffer only on one side. You can achieve this effect with single_sided option.\n\nThe side used is determined by the sign of the buffer distance:\n\na positive distance indicates the left-hand side\n\na negative distance indicates the right-hand side\n\n>>> line = LineString([(0, 0), (1, 1), (0, 2), (2, 2), (3, 1), (1, 0)]) >>> left_hand_side = line.buffer(0.5, single_sided=True) >>> right_hand_side = line.buffer(-0.3, single_sided=True)\n\n(Source code, png, hires.png, pdf)\n\nFigure 10. Single sided buffer of 0.5 left hand (left) and of 0.3 right hand (right).\n\nThe single-sided buffer of point geometries is the same as the regular buffer. The End Cap Style for single-sided buffers is always ignored, and forced to the equivalent of BufferCapStyle.flat.\n\nPassed a distance of 0, buffer() can sometimes be used to “clean” self-touching or self-crossing polygons such as the classic “bowtie”. Users have reported that very small distance values sometimes produce cleaner results than 0. Your mileage may vary when cleaning surfaces.\n\n>>> coords = [(0, 0), (0, 2), (1, 1), (2, 2), (2, 0), (1, 1), (0, 0)] >>> bowtie = Polygon(coords) >>> bowtie.is_valid False >>> clean = bowtie.buffer(0) >>> clean.is_valid True >>> clean <MULTIPOLYGON (((0 0, 0 2, 1 1, 0 0)), ((1 1, 2 2, 2 0, 1 1)))> >>> len(clean.geoms) 2 >>> list(clean.geoms[0].exterior.coords) [(0.0, 0.0), (0.0, 2.0), (1.0, 1.0), (0.0, 0.0)] >>> list(clean.geoms[1].exterior.coords) [(1.0, 1.0), (2.0, 2.0), (2.0, 0.0), (1.0, 1.0)]\n\nBuffering splits the polygon in two at the point where they touch.\n\nobject.convex_hull#\n\nReturns a representation of the smallest convex Polygon containing all the points in the object unless the number of points in the object is less than three. For two points, the convex hull collapses to a LineString; for 1, a Point.\n\n>>> Point(0, 0).convex_hull <POINT (0 0)> >>> MultiPoint([(0, 0), (1, 1)]).convex_hull <LINESTRING (0 0, 1 1)> >>> MultiPoint([(0, 0), (1, 1), (1, -1)]).convex_hull <POLYGON ((1 -1, 0 0, 1 1, 1 -1))>\n\n(Source code, png, hires.png, pdf)\n\nFigure 11. Convex hull (blue) of 2 points (left) and of 6 points (right).\n\nobject.envelope#\n\nReturns a representation of the point or smallest rectangular polygon (with sides parallel to the coordinate axes) that contains the object.\n\n>>> Point(0, 0).envelope <POINT (0 0)> >>> MultiPoint([(0, 0), (1, 1)]).envelope <POLYGON ((0 0, 1 0, 1 1, 0 1, 0 0))>\n\nobject.minimum_rotated_rectangle#\n\nReturns the general minimum bounding rectangle that contains the object. Unlike envelope this rectangle is not constrained to be parallel to the coordinate axes. If the convex hull of the object is a degenerate (line or point) this degenerate is returned.\n\nNew in Shapely 1.6.0\n\n>>> Point(0, 0).minimum_rotated_rectangle <POINT (0 0)> >>> MultiPoint([(0,0),(1,1),(2,0.5)]).minimum_rotated_rectangle <POLYGON ((1.824 1.206, -0.176 0.706, 0 0, 2 0.5, 1.824 1.206))>\n\n(Source code, png, hires.png, pdf)\n\nFigure 12. Minimum rotated rectangle for a multipoint feature (left) and a linestring feature (right).\n\nobject.parallel_offset(distance, side, resolution=16, join_style=1, mitre_limit=5.0)#\n\nReturns a LineString or MultiLineString geometry at a distance from the object on its right or its left side.\n\nOlder alternative method to the offset_curve() method, but uses resolution instead of quad_segs and a side keyword (‘left’ or ‘right’) instead of sign of the distance. This method is kept for backwards compatibility for now, but is is recommended to use offset_curve() instead.\n\nobject.offset_curve(distance, quad_segs=16, join_style=1, mitre_limit=5.0)#\n\nReturns a LineString or MultiLineString geometry at a distance from the object on its right or its left side.\n\nThe distance parameter must be a float value.\n\nThe side is determined by the sign of the distance parameter (negative for right side offset, positive for left side offset). Left and right are determined by following the direction of the given geometric points of the LineString.\n\nNote: the behaviour regarding orientation of the resulting line depends on the GEOS version. With GEOS < 3.11, the line retains the same direction for a left offset (positive distance) or has reverse direction for a right offset (negative distance), and this behaviour was documented as such in previous Shapely versions. Starting with GEOS 3.11, the function tries to preserve the orientation of the original line.\n\nThe resolution of the offset around each vertex of the object is parameterized as in the buffer() method (using quad_segs).\n\nThe join_style is for outside corners between line segments. Accepted integer values are 1 (round), 2 (mitre), and 3 (bevel). See also shapely.BufferJoinStyle.\n\nSeverely mitered corners can be controlled by the mitre_limit parameter (spelled in British English, en-gb). The corners of a parallel line will be further from the original than most places with the mitre join style. The ratio of this further distance to the specified distance is the miter ratio. Corners with a ratio which exceed the limit will be beveled.\n\nNote\n\nThis method may sometimes return a MultiLineString where a simple LineString was expected; for example, an offset to a slightly curved LineString.\n\nNote\n\nThis method is only available for LinearRing and LineString objects.\n\n(Source code, png, hires.png, pdf)\n\nFigure 13. Three styles of parallel offset lines on the left side of a simple line string (its starting point shown as a circle) and one offset on the right side, a multipart.\n\nThe effect of the mitre_limit parameter is shown below.\n\n(Source code, png, hires.png, pdf)\n\nFigure 14. Large and small mitre_limit values for left and right offsets.\n\nobject.simplify(tolerance, preserve_topology=True)#\n\nReturns a simplified representation of the geometric object.\n\nAll points in the simplified object will be within the tolerance distance of the original geometry. By default a slower algorithm is used that preserves topology. If preserve topology is set to False the much quicker Douglas-Peucker algorithm is used.\n\n>>> p = Point(0.0, 0.0) >>> x = p.buffer(1.0) >>> x.area 3.1365484905459398 >>> len(x.exterior.coords) 65 >>> s = x.simplify(0.05, preserve_topology=False) >>> s.area 3.061467458920719 >>> len(s.exterior.coords) 17\n\n(Source code, png, hires.png, pdf)\n\nFigure 15. Simplification of a nearly circular polygon using a tolerance of 0.2 (left) and 0.5 (right).\n\nNote\n\nInvalid geometric objects may result from simplification that does not preserve topology and simplification may be sensitive to the order of coordinates: two geometries differing only in order of coordinates may be simplified differently."
    }
}