{
    "id": "dbpedia_8578_0",
    "rank": 57,
    "data": {
        "url": "https://www.baeldung.com/hibernate-spatial",
        "read_more_link": "",
        "language": "en",
        "title": "Introduction to Hibernate Spatial",
        "top_image": "https://www.baeldung.com/wp-content/uploads/2016/10/social-Persistence-On-Baeldung-1.jpg",
        "meta_img": "https://www.baeldung.com/wp-content/uploads/2016/10/social-Persistence-On-Baeldung-1.jpg",
        "images": [
            "https://www.facebook.com/tr?id=512471148948613&ev=PageView&noscript=1",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://secure.gravatar.com/avatar/dc417739e22ae675b0e1f7012bbddaa5?s=50&r=g",
            "https://secure.gravatar.com/avatar/629fdde67cb23f9d3799635d89c7b250?s=50&r=g",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-persistence-post-footer-main-1.2.0.jpg",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-persistence-post-footer-icn-1.0.0.png",
            "https://www.baeldung.com/wp-content/uploads/2024/01/book-cover-mockito-guide-lg-1.png",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-security-widget-main-1.2.0-300x235.jpg",
            "https://www.baeldung.com/wp-content/uploads/2024/08/persistence-with-spring-ebook-sidebar-widget.jpg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/whiteleaf.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2017-12-12T13:42:41+02:00",
        "summary": "",
        "meta_description": "A quick and practical introduction to Hibernate Spatial",
        "meta_lang": "en",
        "meta_favicon": "https://www.baeldung.com/wp-content/themes/baeldung/favicon/apple-touch-icon-57x57.png",
        "meta_site_name": "Baeldung",
        "canonical_link": "https://www.baeldung.com/hibernate-spatial",
        "text": "1. Introduction\n\nIn this article, we’ll have a look a the spatial extension of Hibernate, hibernate-spatial.\n\nStarting with version 5, Hibernate Spatial provides a standard interface for working with geographic data.\n\n2. Background on Hibernate Spatial\n\nGeographic data includes representation of entities like a Point, Line, Polygon. Such data types aren’t a part of the JDBC specification, hence the JTS (JTS Topology Suite) has become a standard for representing spatial data types.\n\nApart from JTS, Hibernate spatial also supports Geolatte-geom – a recent library that has some features that aren’t available in JTS.\n\nBoth libraries are already included in the hibernate-spatial project. Using one library over other is simply a question of from which jar we’re importing data types.\n\nAlthough Hibernate spatial supports different databases like Oracle, MySQL, PostgreSQLql/PostGIS, and a few others, the support for the database specific functions isn’t uniform.\n\nIt’s better to refer to the latest Hibernate documentation to check the list of functions for which hibernate provides support for a given database.\n\nIn this article, we’ll be using an in-memory Mariadb4j – which maintains the full functionality of MySQL.\n\nThe configuration for Mariadb4j and MySql are similar, even the mysql-connector library works for both of these databases.\n\n3. Maven Dependencies\n\nLet’s have a look at the Maven dependencies required for setting up a simple hibernate-spatial project:\n\n<dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-core</artifactId> <version>6.5.2.Final</version> </dependency> <dependency> <groupId>org.hibernate</groupId> <artifactId>hibernate-spatial</artifactId> <version>6.4.2.Final</version> </dependency> <dependency> <groupId>mysql</groupId> <artifactId>mysql-connector-java</artifactId> <version>8.0.32</version> </dependency> <dependency> <groupId>ch.vorburger.mariaDB4j</groupId> <artifactId>mariaDB4j</artifactId> <version>2.6.0</version> </dependency>\n\nThe hibernate-spatial dependency is the one that will provide support for the spatial data types. The latest versions of hibernate-core, hibernate-spatial, mysql-connector-java, and mariaDB4j can be obtained from Maven Central.\n\n4. Configuring Hibernate Spatial\n\nThe first step is to create a hibernate.properties in the resources directory:\n\nhibernate.dialect=org.hibernate.dialect.H2Dialect // ...\n\nWe will use the same dialect for the usual H2 database which is H2Dialect. This by default provides additional functionality related to the spatial data types.\n\nThe code specific to loading the property file, creating a SessionFactory, and instantiating a Mariadb4j instance, is same as in a standard hibernate project.\n\n5. Understanding the Geometry Type\n\nGeometry is the base type for all the spatial types in JTS. This means that other types like Point, Polygon, and others extend from Geometry. The Geometry type in java corresponds to the GEOMETRY type in MySql as well.\n\nBy parsing a String representation of the type, we get an instance of Geometry. A utility class WKTReader provided by JTS can be used to convert any well-known text representation to a Geometry type:\n\npublic Geometry wktToGeometry(String wellKnownText) throws ParseException { return new WKTReader().read(wellKnownText); }\n\nNow, let’s see this method in action:\n\n@Test public void shouldConvertWktToGeometry() { Geometry geometry = wktToGeometry(\"POINT (2 5)\"); assertEquals(\"Point\", geometry.getGeometryType()); assertTrue(geometry instanceof Point); }\n\nAs we can see, even if the return type of the method is read() method is Geometry, the actual instance is that of a Point.\n\n6. Storing a Point in DB\n\nNow that we have a good idea of what a Geometry type is and how to get a Point out of a String, let’s have a look at the PointEntity:\n\n@Entity public class PointEntity { @Id @GeneratedValue private Long id; private Point point; // standard getters and setters }\n\nNote that the entity PointEntity contains a spatial type Point. As demonstrated earlier, a Point is represented by two coordinates:\n\npublic void insertPoint(String point) { PointEntity entity = new PointEntity(); entity.setPoint((Point) wktToGeometry(point)); session.persist(entity); }\n\nThe method insertPoint() accepts a well-known text (WKT) representation of a Point, converts it to a Point instance, and saves in the DB.\n\nAs a reminder, the session isn’t specific to hibernate-spatial and is created in a way similar to another hibernate project.\n\nWe can notice here that once we have an instance of Point created, the process of storing PointEntity is similar to any regular entity.\n\nLet’s look at some tests:\n\n@Test public void shouldInsertAndSelectPoints() { PointEntity entity = new PointEntity(); entity.setPoint((Point) wktToGeometry(\"POINT (1 1)\")); session.persist(entity); PointEntity fromDb = session .find(PointEntity.class, entity.getId()); assertEquals(\"POINT (1 1)\", fromDb.getPoint().toString()); assertTrue(geometry instanceof Point); }\n\nCalling toString() on a Point returns the WKT representation of a Point. This is because the Geometry class overrides the toString() method and internally uses WKTWriter, a complimentary class to WKTReader that we saw earlier.\n\nOnce we run this test, hibernate will create PointEntity table for us.\n\nLet’s have a look at that table:\n\ndesc PointEntity; Field Type Null Key id bigint(20) NO PRI point geometry YES\n\nAs expected, the Type of Field Point is GEOMETRY. Because of this, while fetching the data using our SQL editor (like MySql workbench), we need to convert this GEOMETRY type to human-readable text:\n\nselect id, astext(point) from PointEntity; id astext(point) 1 POINT(2 4)\n\nHowever, as hibernate already returns WKT representation when we call toString() method on Geometry or any of its subclasses, we don’t need to bother about this conversion.\n\n7. Using Spatial Functions\n\n7.1. ST_WITHIN() Example\n\nWe’ll now have a look at the usage of database functions that work with spatial data types.\n\nOne of such function in MySQL is ST_WITHIN() that tells whether one Geometry is within another. A good example here would be to find out all the points within a given radius.\n\nLet’s start by looking at how to create a circle:\n\npublic Geometry createCircle(double x, double y, double radius) { GeometricShapeFactory shapeFactory = new GeometricShapeFactory(); shapeFactory.setNumPoints(32); shapeFactory.setCentre(new Coordinate(x, y)); shapeFactory.setSize(radius * 2); return shapeFactory.createCircle(); }\n\nA circle is represented by a finite set of points specified by the setNumPoints() method. The radius is doubled before calling the setSize() method as we need to draw the circle around the center, in both the directions.\n\nLet’s now move forward and see how to fetch the points within a given radius:\n\n@Test public void shouldSelectAllPointsWithinRadius() throws ParseException { insertPoint(\"POINT (1 1)\"); insertPoint(\"POINT (1 2)\"); insertPoint(\"POINT (3 4)\"); insertPoint(\"POINT (5 6)\"); Query query = session.createQuery(\"select p from PointEntity p where within(p.point, :circle) = true\", PointEntity.class); query.setParameter(\"circle\", createCircle(0.0, 0.0, 5)); assertThat(query.getResultList().stream() .map(p -> ((PointEntity) p).getPoint().toString())) .containsOnly(\"POINT (1 1)\", \"POINT (1 2)\"); }\n\nHibernate maps its within() function to the ST_WITHIN() function of MySql.\n\nAn interesting observation here is that the Point (3, 4) falls exactly on the circle. Still, the query doesn’t return this point. This is because the within() function returns true only if the given Geometry is completely within another Geometry.\n\n7.2. ST_TOUCHES() Example\n\nHere, we’ll present an example that inserts a set of Polygons in the database and select the Polygons that are adjacent to a given Polygon. Let’s have a quick look at the PolygonEntity class:\n\n@Entity public class PolygonEntity { @Id @GeneratedValue private Long id; private Polygon polygon; // standard getters and setters }\n\nThe only thing different here from the previous PointEntity is that we’re using the type Polygon instead of the Point.\n\nLet’s now move towards the test:\n\n@Test public void shouldSelectAdjacentPolygons() throws ParseException { insertPolygon(\"POLYGON ((0 0, 0 5, 5 5, 5 0, 0 0))\"); insertPolygon(\"POLYGON ((3 0, 3 5, 8 5, 8 0, 3 0))\"); insertPolygon(\"POLYGON ((2 2, 3 1, 2 5, 4 3, 3 3, 2 2))\"); Query query = session.createQuery(\"select p from PolygonEntity p where touches(p.polygon, :polygon) = true\", PolygonEntity.class); query.setParameter(\"polygon\", wktToGeometry(\"POLYGON ((5 5, 5 10, 10 10, 10 5, 5 5))\")); assertThat(query.getResultList().stream() .map(p -> ((PolygonEntity) p).getPolygon().toString())).containsOnly( \"POLYGON ((0 0, 0 5, 5 5, 5 0, 0 0))\", \"POLYGON ((3 0, 3 5, 8 5, 8 0, 3 0))\"); }\n\nThe insertPolygon() method is similar to the insertPoint() method that we saw earlier. The source contains the full implementation of this method.\n\nWe’re using the touches() function to find the Polygons adjacent to a given Polygon. Clearly, the third Polygon is not returned in the result as there is not edge touching the given Polygon.\n\n8. Conclusion\n\nIn this article, we’ve seen that hibernate-spatial makes dealing with spatial datatypes a lot simpler as it takes care of the low-level details.\n\nEven though this article uses Mariadb4j, we can replace it with MySql without modifying any configuration."
    }
}