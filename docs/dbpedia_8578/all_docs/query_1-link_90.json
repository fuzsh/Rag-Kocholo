{
    "id": "dbpedia_8578_1",
    "rank": 90,
    "data": {
        "url": "https://qupath.readthedocs.io/en/stable/docs/scripting/overview.html",
        "read_more_link": "",
        "language": "en",
        "title": "Custom scripts — QuPath 0.5.1 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://qupath.readthedocs.io/en/stable/_static/qupath_128.png",
            "https://qupath.readthedocs.io/en/stable/_images/friendly_script.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Custom scripts\n\nYou can enter a custom script in QuPath via Automate ‣ Show script editor, and run it by choosing Run ‣ Run (or pressing Ctrl + R with the script editor in focus).\n\nThe user forum is a good source for scripts; scripts are often posted there in response to questions that require a feature QuPath doesn’t quite have yet.\n\nThis section provides an overview of some of the main ideas needed to start writing custom scripts in QuPath yourself.\n\nIt is based initially on this blog post but should be kept updated as QuPath develops. It assumes you are familiar with the main QuPath concepts.\n\nAPI docs\n\nYou can find QuPath’s API docs at http://qupath.github.io/javadoc/docs/\n\nDefault imports\n\nIn the Script Editor, there is an option Run ‣ Include default imports.\n\nIf this is selected, QuPath will add the following line to the top of your script:\n\nimportstaticqupath.lib.gui.scripting.QPEx.*\n\nThis means you’ve access to all the static methods in QPEx and QP directly. These are used extensively by QuPath when converting workflows to scripts for batch processing.\n\nAll the examples below assume that QPEx is imported one way or another. If you don’t want to rely on the default import, just put that line at the top of your scripts explicitly.\n\nProjects\n\nThe following simple script prints the names of all images in a project:\n\ndefproject=getProject() for(entryinproject.getImageList()){ printentry.getImageName() }\n\nThe script below is rather more interesting; it will\n\nOpen each image in turn\n\nExtract the annotations from the hierarchy\n\nPrint the image name & annotation count per image\n\ndefproject=getProject() for(entryinproject.getImageList()){ defimageData=entry.readImageData() defhierarchy=imageData.getHierarchy() defannotations=hierarchy.getAnnotationObjects() printentry.getImageName()+'\\t'+annotations.size() }\n\nThe extra logging messages generated when opening each image can be annoying, so you might want to print everything at the end instead. Creating a StringBuilder can help:\n\ndefsb=newStringBuilder() defproject=getProject() for(entryinproject.getImageList()){ defimageData=entry.readImageData() defhierarchy=imageData.getHierarchy() defannotations=hierarchy.getAnnotationObjects() sb<<entry.getImageName()+'\\t'+annotations.size()<<'\\n' } printsb.toString()\n\nBoth options are rather a lot slower than they need to be, because QuPath will go to the bother of constructing the full ImageData (including ImageServer) for every image - even though it never needs to actually access pixels.\n\nYou can avoid this as follows:\n\ndefproject=getProject() for(entryinproject.getImageList()){ defhierarchy=entry.readHierarchy() defannotations=hierarchy.getAnnotationObjects() printentry.getImageName()+'\\t'+annotations.size() }\n\nNote\n\nThese scripts won’t work in v0.1.2, where the process was much more awkward…\n\nAccessing the current image\n\nThe above scripts can access images in a project, regardless of whether they are open in the GUI or not.\n\nOften, you only need to access the image currently open. In that case, just use\n\ndefimageData=getCurrentImageData() printimageData\n\nThis gets the image from the current viewer. It is equivalent to:\n\ndefviewer=getCurrentViewer() defimageData=viewer.getImageData() printimageData\n\nIn conjunction with Run ‣ Run for project you often don’t need to loop through project images directly - just write a script for the current image, then run that script for all images with Run for project.\n\nAccessing image metadata\n\nTo get image metadata, you’ll need the ImageServer:\n\ndefimageData=getCurrentImageData() defserver=imageData.getServer() printserver\n\nIn recent QuPath milestones, this is equivalent to:\n\ndefserver=getCurrentServer() printserver\n\nYou can then query properties of the image. Simple ones can be accessed directly, e.g.\n\ndefserver=getCurrentServer() printserver.getWidth()+' x '+server.getHeight()\n\nAll the key metadata exists in an ImageServerMetadata object:\n\ndefserver=getCurrentServer() printserver.getMetadata()\n\nPixel sizes are in a PixelCalibrationObject (different from v0.1.2, where you got them directly from the server!):\n\ndefserver=getCurrentServer() defcal=server.getMetadata().getPixelCalibration() printcal\n\nAs a shortcut, you can also use\n\ndefserver=getCurrentServer() defcal=server.getPixelCalibration() printcal\n\nIn the past, pixels were either in microns or uncalibrated. In the future, QuPath might need to support other pixel units and so this assumption is a bit less critical than it was before. It is tempting to make pixel size requests more general and elaborate (always asking for units), but for now the need to request pixel sizes in microns is so common that there remain helper methods to do this:\n\ndefserver=getCurrentServer() defcal=server.getPixelCalibration() printcal.getPixelWidthMicrons() printcal.getPixelHeightMicrons() printcal.getAveragedPixelSizeMicrons()\n\nYou can expect the result to be Double.NaN if the size information is not available. You can check for this using ‘standard’ Java/Groovy.\n\ndoublemyNaN=Double.NaN // Two Java/Groovy-friendly ways to check values are 'usable' printDouble.isNaN(myNaN) printDouble.isFinite(myNaN) // A bad way to check for NaN - confusing because Java & Groovy handle == differently print(myNaN==Double.NaN)// Don't do this!\n\nAccessing pixels\n\nIf you want pixels, you’ll get them as a Java BufferedImage.\n\nTo do so, you need to request them from a server with a RegionRequest. This includes the server path, a downsample factor and bounding box coordinates (defined in full resolution pixel units, with the origin at the top left of the image):\n\nimportqupath.lib.regions.* defserver=getCurrentServer() defpath=server.getPath() doubledownsample=4.0 intx=100 inty=200 intwidth=1000 intheight=2000 defrequest=RegionRequest.createInstance(path,downsample,x,y,width,height) defimg=server.readRegion(request) printimg\n\nThere are two reasons why QuPath uses RegionRequest objects:\n\nYou’d otherwise need to pass a lot of parameters to the readRegion method\n\nRegionRequests can be (and are) used as keys for an image cache\n\nIn any case, the above script assumes a single-plane image. If you may have a z-stack, you can define the z-slice and time point in your request:\n\nimportqupath.lib.regions.* defserver=getCurrentServer() defpath=server.getPath() doubledownsample=4.0 intx=100 inty=200 intwidth=1000 intheight=2000 intz=0 intt=0 defrequest=RegionRequest.createInstance(path,downsample,x,y,width,height,z,t) defimg=server.readRegion(request) printimg\n\nIf you have a selected object with a ROI in the image, you can also use that to create the request:\n\nimportqupath.lib.regions.* defserver=getCurrentServer() defroi=getSelectedROI() doubledownsample=4.0 defrequest=RegionRequest.createInstance(server.getPath(),downsample,roi) defimg=server.readRegion(request) printimg\n\nNote\n\nThe server path previously was an image path and it could be used to construct a new server… but this is no longer the case. Rather, the key thing now is that it must be unique for a server, since it is used for caching.\n\nserver.getPath() may be renamed to server.getID() or similar in the future to reflect this.\n\nSetting pixel size\n\nThe following script sets the pixel size of the currently opened image:\n\n// Set pixel width and height to 0.5 microns setPixelSizeMicrons(0.5,0.5)\n\nZ-spacing, alongside width and height, can also be set with the following script:\n\n// Set pixel width & height to 0.5 microns and Z-spacing to 1.0 micron setPixelSizeMicrons(0.5,0.5,1.0)\n\nCreating ROIs\n\nWarning\n\nPreviously, there were public constructors for ROIs. You shouldn’t use these now!\n\nYou can create new ROIs using the static methods in the ROIs class.\n\nThis will require specifying the z-slice and timepoint. To avoid passing lots of parameters (and getting the order mixed up), you should instead use an ImagePlane object:\n\nimportqupath.lib.roi.ROIs importqupath.lib.regions.ImagePlane intz=0 intt=0 defplane=ImagePlane.getPlane(z,t) defroi=ROIs.createRectangleROI(0,0,100,100,plane) printroi\n\nThere are various different kinds of ROI that can be created, including with createEllipseROI, createPolygonROI, createLineROI.\n\nCreating objects\n\nTo actually make a ROI visible, it needs to be part of an object.\n\nThe PathObjects class helps in a similar way to ROIs - again, you shouldn’t create objects using constructors directly.\n\nThis script creates a new annotation with an ellipse ROI, and adds it to the hierarchy for the current image (using the QPEx.addObject() method):\n\nimportqupath.lib.objects.PathObjects importqupath.lib.roi.ROIs importqupath.lib.regions.ImagePlane intz=0 intt=0 defplane=ImagePlane.getPlane(z,t) defroi=ROIs.createEllipseROI(0,0,100,100,plane) defannotation=PathObjects.createAnnotationObject(roi) addObject(annotation)\n\nTo create a detection rather than an annotation, you’d use createDetectionObject.\n\nPutting it together with previous sections, to create square tiles across an entire image for the current ImagePlane we could use:\n\nimportqupath.lib.objects.PathObjects importqupath.lib.roi.ROIs importqupath.lib.regions.ImagePlane defimageData=getCurrentImageData() defplane=getCurrentViewer().getImagePlane() defserver=imageData.getServer() inttileSize=1024 deftiles=[] for(inty=0;y<server.getHeight()-tileSize;y+=tileSize){ for(intx=0;x<server.getWidth()-tileSize;x+=tileSize){ defroi=ROIs.createRectangleROI(x,y,tileSize,tileSize,plane) tiles<<PathObjects.createAnnotationObject(roi) } } addObjects(tiles)\n\nWorking with BufferedImages\n\nOnce you have a BufferedImage, you are already in Java-land and don’t need QuPath-specific documentation for most things.\n\nScripts like this one to create binary images can then help with one major change. Previously, you had to do some awkward gymnastics to convert a ROI into a java.awt.Shape object. That’s now easier:\n\ndefroi=getSelectedROI() defshape=roi.getShape() printshape\n\nHere’s a script applying this to pull out a region from an RGB image for a selected ROI, and show that region in ImageJ along with a new binary mask:\n\nimportqupath.lib.regions.* importij.* importjava.awt.Color importjava.awt.image.BufferedImage // Read RGB image & show in ImageJ (won't work for multichannel!) defserver=getCurrentServer() defroi=getSelectedROI() doubledownsample=4.0 defrequest=RegionRequest.createInstance(server.getPath(),downsample,roi) defimg=server.readRegion(request) newImagePlus(\"Image\",img).show() // Create a binary mask & show in ImageJ defshape=roi.getShape() defimgMask=newBufferedImage(img.getWidth(),img.getHeight(),BufferedImage.TYPE_BYTE_GRAY) defg2d=imgMask.createGraphics() g2d.scale(1.0/request.getDownsample(), 1.0/request.getDownsample()) g2d.translate(-request.getX(),-request.getY()) g2d.setColor(Color.WHITE) g2d.fill(shape) g2d.dispose() newImagePlus(\"Mask\",imgMask).show()\n\nThe mask is generated using Java’s built-in rendering of Shapes.\n\nWorking with ImageJ\n\nThe above is fine for simple cases, but fails to make the most of ImageJ. It doesn’t set the image metadata, so there’s no way to relate back extracted regions to where they were originally in the whole slide image. It also doesn’t work in general for multichannel images.\n\nIf you want to apply ImageJ scripting in QuPath, it is best to let QuPath take care of the conversion. IJTools is the new class that helps with that (or IJExtension to interact directly with the GUI).\n\nThe following script is similar to that above, but works for multichannel images and sets ImageJ properties. It also doesn’t create a mask directly, but rather converts the QuPath ROI so that further processing (e.g. to generate the mask) can be performed in ImageJ.\n\nimportqupath.lib.regions.* importqupath.imagej.tools.IJTools importqupath.imagej.gui.IJExtension importij.* // Request an ImageJ instance - this will open the GUI if necessary // This isn't essential, but makes it it possible to interact with any image that is shown IJExtension.getImageJInstance() // Read image & show in ImageJ defserver=getCurrentServer() defroi=getSelectedROI() doubledownsample=4.0 defrequest=RegionRequest.createInstance(server.getPath(),downsample,roi) defpathImage=IJTools.convertToImagePlus(server,request) defimp=pathImage.getImage() imp.show() // Convert QuPath ROI to ImageJ Roi & add to open image defroiIJ=IJTools.convertToIJRoi(roi,pathImage) imp.setRoi(roiIJ)\n\nThis introduces another class: PathImage.\n\nThis is basically a wrapper for an image of some kind (here, an ImageJ ImagePlus) along with some calibration information.\n\nOften we don’t need the PathImage wrapper, but here we keep it so that we can pass it to IJTools.convertToIJRoi(roi, pathImage) later.\n\nWorking with OpenCV\n\nRather than BufferedImage or ImagePlus objects, perhaps you prefer to write your processing code using OpenCV.\n\nIn v0.1.2, QuPath used the default OpenCV Java bindings - which were troublesome in multiple ways. Now, it uses JavaCPP.\n\nHowever, although OpenCV can be nice to code with it can also be hard to code with interactively. Therefore in QuPath there are helper functions to help convert from OpenCV to ImageJ when necessary. The following shows this in action:\n\nimportqupath.lib.regions.* importqupath.imagej.tools.IJTools importqupath.opencv.tools.OpenCVTools importorg.bytedeco.opencv.opencv_core.Size importstaticorg.bytedeco.opencv.global.opencv_core.* importstaticorg.bytedeco.opencv.global.opencv_imgproc.* importij.* // Read BufferedImage region defserver=getCurrentServer() defroi=getSelectedROI() doubledownsample=4.0 defrequest=RegionRequest.createInstance(server.getPath(),downsample,roi) defimg=server.readRegion(request) // Convert to an OpenCV Mat, then apply a difference of Gaussians filter defmat=OpenCVTools.imageToMat(img) mat2=mat.clone() GaussianBlur(mat,mat2,newSize(15,15),2.0) GaussianBlur(mat,mat,newSize(15,15),1.0) subtract(mat,mat2,mat) mat2.close() // Convert Mat to an ImagePlus, setting pixel calibration info & then show it defimp=OpenCVTools.matToImagePlus(mat,\"My image\") IJTools.calibrateImagePlus(imp,request,server) imp.show()\n\nManipulating ROIs\n\nHaving met IJTools and OpenCVTools, it may be nice to know there are also RoiTools and PathObjectTools classes. In all cases, these contain static methods that may be useful.\n\nHere, we see how to create and merge two ROIs:\n\nimportqupath.lib.roi.ROIs importqupath.lib.roi.RoiTools importqupath.lib.objects.PathObjects importqupath.lib.regions.ImagePlane defplane=ImagePlane.getDefaultPlane() defroi1=ROIs.createRectangleROI(0,0,100,100,plane) defroi2=ROIs.createEllipseROI(80,0,100,100,plane) defroi3=RoiTools.combineROIs(roi1,roi2,RoiTools.CombineOp.ADD) defannotation=PathObjects.createAnnotationObject(roi3) addObject(annotation)\n\nWorking with Java Topology Suite\n\nIt’s quite possible that your ROI manipulation wishes extend beyond what QuPath ROIs support directly.\n\nFortunately, you can shift to the fabulous Java Topology Suite - rather easily. Here’s an example that will convert a QuPath ROI to a JTS Geometry, expand it, and then create a new annotation from the result:\n\nimportqupath.lib.objects.PathObjects importqupath.lib.roi.jts.ConverterJTS; defroi=getSelectedROI() defgeometry=roi.getGeometry() geometry=geometry.buffer(100) defroi2=ConverterJTS.convertGeometryToROI(geometry,roi.getImagePlane()) defannotation=PathObjects.createAnnotationObject(roi2) addObject(annotation)\n\nSerialization & JSON\n\nQuPath v0.1.2 uses Java’s built-in serialization quite a lot for saving/reloading things.\n\nThis is quite compact and easy to use, but horrendous to maintain and impractical for sharing data with anything written in another programming language. Still, it lives on in .qpdata files… for now.\n\nJSON, by contrast, is text-based and readable. v0.1.2 already used JSON for project files (.qpproj), but now uses it increasingly where possible.\n\nJSON is not always appropriate (e.g. attempting to represent a full object hierarchy containing a million objects as JSON would be horribly slow, complex and memory-hungry) but it is generally more maintainable and portable compared to Java serialization.\n\nThe library QuPath uses to help with JSON is Gson. Gson makes it beautifully straightforward to turn almost anything into a JSON representation and back… if you know exactly what Java class is involved.\n\nHere’s a Groovy example that doesn’t rely on anything QuPath-specific:\n\nimportcom.google.gson.GsonBuilder defgson=newGsonBuilder() .setPrettyPrinting() .create() defmyMap=['Hello':1,'I am a map':2] printmyMap defjson=gson.toJson(myMap) printjson defmyMap2=gson.fromJson(json,Map.class) printmyMap2\n\nYou may notice that the map you get back doesn’t look exactly the same when printed… what looked like an integer may now look like a floating point value. But otherwise they match.\n\nIn practice, when working with generic classes and subclasses things can rapidly become a lot more complex, bringing in the world of type hierarchy adapters and the like.\n\nI have spent a long time battling with these things in the hope that you won’t have to. Rather than creating your own Gson object, you can request one from QuPath that is pre-initialized to work with a lot of the kind of structures you’ll meet in QuPath.\n\nimportqupath.lib.io.GsonTools booleanprettyPrint=true defgson=GsonTools.getInstance(prettyPrint) println'My ROI' printlngson.toJson(getSelectedROI()) println() println'My object' printlngson.toJson(getSelectedObject()) println() println'My server' printlngson.toJson(getCurrentServer())\n\nTo convert back, you’ll need to supply the appropriate QuPath class. Because of the magic GsonTools does for you, this doesn’t need to be the exact class - you can use PathObject and get a detection or annotation as appropriate.\n\nimportqupath.lib.objects.PathObject importqupath.lib.io.GsonTools booleanprettyPrint=true defgson=GsonTools.getInstance(prettyPrint) // Get the selected object & convert to JSON defpathObject=getSelectedObject() defjson=gson.toJson(pathObject) printjson // Create a NEW object from the JSON representation defpathObject2=gson.fromJson(json,PathObject) printpathObject2 // Confirm that we really do have a *different* object if(pathObject==pathObject2) print'Objects are the same' else print'Objects are NOT the same' // Add the object to the hierarchy to check it matches, with a name to help pathObject2.setName('The one from JSON') addObject(pathObject2)\n\nThis should also work for an ImageServer:\n\nimportqupath.lib.images.servers.ImageServer importqupath.lib.io.GsonTools booleanprettyPrint=true defgson=GsonTools.getInstance(prettyPrint) defserver=getCurrentServer() defjson=gson.toJson(getCurrentServer()) defserver2=gson.fromJson(json,ImageServer) printserver printserver.class printserver2 printserver2.class if(server==server2) print'Servers ARE the same' else print'Servers ARE NOT the same' if(server.getMetadata()==server2.getMetadata()) print'Metadata IS the same' else print'Metadata IS NOT the same'\n\nFiguring out a JSON way to represent ImageServers has taken up rather a lot of my time recently… but so far this seems to be working.\n\nNote however that not everything can be converted to JSON. For example, you can’t do this with an object hierarchy or an ImageData. You also probably don’t/shouldn’t want to, given the efficiency issues mentioned above.\n\nNevertheless, where possible QuPath tries to use a representation that may be used elsewhere.\n\nFor example, for ROIs and objects, QuPath follows the GeoJSON specification. This should (although I haven’t tried…) make it possible to exchange regions with other software, e.g. get them into Python via Shapely.\n\nNote\n\nUsing GeoJSON does impose some limitations; notably, ellipses become polygons.\n\nGsonTools also aims to wrap around OpenCV’s JSON serialization, e.g.\n\nimportorg.bytedeco.opencv.global.opencv*core importorg.bytedeco.opencv.opencv*core.Mat importqupath.lib.io.GsonTools booleanprettyPrint=true defgson=GsonTools.getInstance(prettyPrint) defmat=Mat.eye(3,3,opencv*core.CV*32FC1).asMat() printgson.toJson(mat)\n\nEventually this will make OpenCV classifiers JSON-serializable within QuPath and finally avoid needing to retrain existing classifiers when reloading them.\n\nWhat next?\n\nThis post gives an overview of QuPath scripting for v0.2.0. The API has changed considerably before… albeit with quite a lot of resemblance.\n\nThe goal is to make everything more logical and easier to extend. Scripting should be intuitive, and allow you do interact with the data in whatever way you like. Admittedly there is more work to do to achieve this… but it’s a start.\n\nFor the main classes you’ll need, it should be possible to at least guess their names. For example, you should avoid using direct constructors for PathObjects and ROIs and use the static classes instead. Similarly, if you see Tools and the end of a classname you can be fairly sure it contains more static methods useful for manipulating objects of whatever type the classname begins with.\n\nHere’s a list of some classes you might want to import, and their current locations:\n\nimportqupath.imagej.gui.IJExtension importqupath.imagej.tools.IJTools importqupath.lib.gui.scripting.QPEx importqupath.lib.images.servers.ImageServer importqupath.lib.io.GsonTools importqupath.lib.objects.PathObjects importqupath.lib.objects.classes.PathClassFactory importqupath.lib.objects.classes.PathClassTools importqupath.lib.regions.ImagePlane importqupath.lib.regions.RegionRequest importqupath.lib.roi.ROIs importqupath.lib.roi.jts.ConverterJTS importqupath.opencv.tools.OpenCVTools\n\nLest they move again or you need others, you can find them by searching on GitHub or (much easier) setting up QuPath with an IDE like IntelliJ.\n\nIn writing this post, I already see things in the API that I don’t like and want to refactor soon… and probably will. When I do, I’ll try to remember to update these scripts.\n\nAll of this remains a work-in-progress, but at least now there is some documentation for anyone who wants to script in the meantime."
    }
}