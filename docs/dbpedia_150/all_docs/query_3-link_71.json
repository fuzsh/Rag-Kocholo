{
    "id": "dbpedia_150_3",
    "rank": 71,
    "data": {
        "url": "https://community.st.com/t5/st25-nfc-rfid-tags-and-readers/halt-only-single-tag-in-field/td-p/583050",
        "read_more_link": "",
        "language": "en",
        "title": "HALT only single tag in field",
        "top_image": "https://community.st.com/t5/image/serverpage/image-id/52884iF22B0C6849433F8C?v=v2",
        "meta_img": "https://community.st.com/t5/image/serverpage/image-id/52884iF22B0C6849433F8C?v=v2",
        "images": [
            "https://community.st.com/legacyfs/online/avatars/005",
            "https://community.st.com/t5/image/serverpage/image-id/49568i1904305D9AFBA491/image-dimensions/150x150/image-coordinates/0%2C0%2C200%2C200/constrain-image/false?v=v2",
            "https://community.st.com/t5/image/serverpage/image-id/49568i1904305D9AFBA491/image-dimensions/150x150/image-coordinates/0%2C0%2C200%2C200/constrain-image/false?v=v2",
            "https://community.st.com/legacyfs/online/avatars/005",
            "https://community.st.com/t5/image/serverpage/image-id/49568i1904305D9AFBA491/image-dimensions/150x150/image-coordinates/0%2C0%2C200%2C200/constrain-image/false?v=v2",
            "https://community.st.com/legacyfs/online/avatars/005",
            "https://community.st.com/t5/image/serverpage/image-id/49568i1904305D9AFBA491/image-dimensions/150x150/image-coordinates/0%2C0%2C200%2C200/constrain-image/false?v=v2",
            "https://community.st.com/legacyfs/online/avatars/005",
            "https://community.st.com/t5/image/serverpage/image-id/52884iF22B0C6849433F8C/image-size/medium/is-moderation-mode/true?v=v2&px=400",
            "https://community.st.com/t5/image/serverpage/image-id/49568i1904305D9AFBA491/image-dimensions/150x150/image-coordinates/0%2C0%2C200%2C200/constrain-image/false?v=v2",
            "https://community.st.com/legacyfs/online/avatars/005",
            "https://community.st.com/t5/image/serverpage/image-id/52916i3BEB174FB90FBF79/image-size/medium/is-moderation-mode/true?v=v2&px=400",
            "https://community.st.com/t5/image/serverpage/image-id/49568i1904305D9AFBA491/image-dimensions/150x150/image-coordinates/0%2C0%2C200%2C200/constrain-image/false?v=v2",
            "https://community.st.com/skins/images/A19B6D4B29AC54D33C48C920859B1F65/responsive_peak/images/icon_anonymous_message.png",
            "https://community.st.com/html/@BD84A24F6C33B4216F5F2C3226885C95/assets/stmicro-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "community.st.com",
            "user-id"
        ],
        "publish_date": "2023-08-17T16:40:56.702000+00:00",
        "summary": "",
        "meta_description": "Solved: Hi! I have a case where I want to read all tags in area one by one. Issue is that if I call `HLTA` command, even after selecting a tag, all",
        "meta_lang": "en",
        "meta_favicon": "https://community.st.com/html/@69F73FA73CBA8CB0B32F49AC59A3C841/assets/favicon-32.png",
        "meta_site_name": "",
        "canonical_link": "https://community.st.com/t5/st25-nfc-rfid-tags-and-readers/halt-only-single-tag-in-field/td-p/583050",
        "text": "Hi!\n\nI have a case where I want to read all tags in area one by one. Issue is that if I call `HLTA` command, even after selecting a tag, all tags in area go to sleep. Is this intended behavior in ISO 14443A protocol or I am doing something wrong?\n\nHlta -> https://github.com/jspngh/st25r3911b/blob/master/src/lib.rs#L275\n\nSelect -> https://github.com/xpresshd/st25r3911b/blob/master/src/lib.rs#L575\n\nThanks!\n\nHi,\n\nThanks for the trace. If I understand properly,\n\nyou just want to retrieve the various UID i.e. you do not want to read the content of the physical memory of the the tags, right? And you don't want to do individual tag activation to read/write the memory of the various tag, right?\n\nyou just want to repeat UID retrieval activity regularly (timer based or gun machine).\n\nIn that case, the Field has to be set to the off condition for a duration of tFIELD_OFF (5.1ms) before repeating the UID retrieval.\n\nIf you repeat twice the collision resolution activity without a field reset between the 2 collision resolution, the first time all tags will be found (because all tags are initially in Idle state), the second time only one tag will be found (because all tags are in SLEEP_A, then move to READY_A* when the ALL_REQ/WUPA is issued and as soon as a SEL_REQ is sent to a given tag, the other tags returns to SLEEP_A).\n\nRgds\n\nBT\n\nIn order to give better visibility on the answered topics, please click on Accept as Solution on the reply which solved your issue or answered your question.\n\nHi,\n\ntags enter in SLEEP_A or SLEEP_AF state only\n\nafter receiving HLTA/SLP_REQ in ACTIVE_A/ACTIVE_A* states\n\nor after receiving a DESELECT COMMAND in CARD EMULATOR 4A state (ISO_DEP case)\n\nor after receiving a DSL_REQ in ATR_READY_A/TARGET_A states (NFC_DEP case)\n\nCan you elaborate on \" if I call `HLTA` command, even after selecting a tag, all tags in area go to sleep\"?\n\nIf you want to \"read\" all tags in the operating field, I would suggest\n\nto perform the NFC Forum Collision Resolution Activity to detects the presence of multiple devices and enumerates the different identifiers\n\nthen to perform the NFC Forum Device Activation Activity to activate a particular device and read its content\n\nthen to perform the NFC Forum Device Deactivation Activity to deactivate this device to end communication and to enable possible activation of another device\n\nThe Collision Resolution Activity is a loop that selects one device after the other. Multiple devices can be identified by selecting all cascade levels of one device before restarting the algorithm to select the next device. Before restarting the algorithm, the device identified is sent to SLEEP_A State to exclude it from the remaining collision resolution process.\n\nThe Device Activation Activity activates one device out of the set of devices identified during the Collision Resolution Activity. Other identified NFC-A devices stay in SLEEP_A.\n\nRgds\n\nBT\n\nIn order to give better visibility on the answered topics, please click on Accept as Solution on the reply which solved your issue or answered your question.\n\nThanks for a response!\n\n> Can you elaborate on \" if I call `HLTA` command, even after selecting a tag, all tags in area go to sleep\"?\n\nI want to read all tags in area. If I don't use `HLTA` call then there is a chance that I will be stuck in loop reading just few tags. Now if I send `HLTA` then all of tags in area don't respond to my `REQA` request anymore.\n\nto perform the NFC Forum Collision Resolution Activity to detects the presence of multiple devices and enumerates the different identifiers\n\nthen to perform the NFC Forum Device Activation Activity to activate a particular device and read its content\n\nthen to perform the NFC Forum Device Deactivation Activity to deactivate this device to end communication and to enable possible activation of another device\n\nSo I do 1. step and using anticollision find 1 tag identifier. What do you mean by \"NFC Forum Device Activation Activity\"? Do I need to read its content for it to be selected?\n\nFrom what I understand I miss a step between running my anticollision loop and calling a hlta instruction. But what is this step?\n\nHi,\n\nYou can find a C implementation of those activities inside X-CUBE-NFC5 Firmware package (functions rfalNfcaPollerStartFullCollisionResolution/rfalNfcaPollerGetFullCollisionResolutionStatus and rfalNfcaPollerStartSelect/rfalNfcaPollerGetSelectStatus). This can be a basis for your own implementation in Rust Programming Language.\n\nBasically, for the Collision Resolution:\n\nsend a WUPA/ALL_REQ\n\nloop on sending the Anticollision frame (SDD_REQ) until there is no collision (in case of collision, use the valid bits received before the collision, followed by 1)\n\nsend the select command (SEL_REQ). If the UID is not complete, perform step 2 with the next cascade level (2 and then if needed 3)\n\nstore the UID\n\nsend HLTA/SLP_REQ to move the current selected tag into SLEEP state\n\nsend REQA/SENS_REQ and perform step 2 starting with cascade level 1 to find the next tag until there is no other tag (or until you have reached the maximun number of tags in your application)\n\nAt the end of the collision resolution, you will have a list of tag with their UID/NFCID1. All those tags will be in SLEEP state (except maybe the last one if you skip the step #5 for the last tag). So, none of those tags will reply to REQA/SENS_REQ.\n\nFor the activation of a given tag from the list of sleeping tags:\n\nsend a WUPA/ALL_REQ\n\nsend the select command (SEL_REQ) using the known UID of the tag with the various cascade level until the UID is complete\n\nsend the RATS command if using a T4T tag\n\nThen you can send your commands to read the tag.\n\nTo deactivate a tag:\n\nsend a HLTA/SLP_REQ if using a T2T tag or a DESELECT is using a T4T tag\n\nRgds\n\nBT\n\nIn order to give better visibility on the answered topics, please click on Accept as Solution on the reply which solved your issue or answered your question.\n\n6 steps listed is what I do now in Rust library.\n\nIssue is that if I have 2+ tags in field and I do WUPA -> select with anti collision -> get UID -> HLTA -> REQA -> select with anti collision -> no response ( Here I would expect to get next tag UID)\n\nSo it seems to me that HLTA put all tags in sleep state."
    }
}