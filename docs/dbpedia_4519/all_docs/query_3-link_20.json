{
    "id": "dbpedia_4519_3",
    "rank": 20,
    "data": {
        "url": "https://langdev.stackexchange.com/questions/3484/why-is-almost-every-programming-language-made-in-english",
        "read_more_link": "",
        "language": "en",
        "title": "Why is almost every programming language made in English?",
        "top_image": "https://cdn.sstatic.net/Sites/langdev/Img/apple-touch-icon@2.png?v=9f1dac205d5e",
        "meta_img": "https://cdn.sstatic.net/Sites/langdev/Img/apple-touch-icon@2.png?v=9f1dac205d5e",
        "images": [
            "https://i.sstatic.net/0pja9.png?s=64",
            "https://i.sstatic.net/Z4JqVg1m.png?s=64",
            "https://i.sstatic.net/MBRE7.jpg?s=64",
            "https://www.gravatar.com/avatar/46ac2ffdab439207d4a590f00da53096?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/tB5AG.png?s=64",
            "https://www.gravatar.com/avatar/098e1ec0fd1f2c04a679bba9e2985647?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/fd3e95077628f62ea424c232605c7768?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/135a97c4150691234931a93f3a27a52f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f74df4a6e7f7502e0f99a8d966612cb3?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/ulVTa.png?s=64",
            "https://langdev.stackexchange.com/posts/3484/ivc/3938?prg=a845173d-0b07-4ad3-a8a7-ff53681c5414"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-01-28T03:01:13",
        "summary": "",
        "meta_description": "Every programming language I know (Java, C++, C#, Python, etc.) are all made in English. That is, you can't, for example, type imprimir(&quot;hola&quot;) instead of print(&quot;hi&quot;). You have ...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/langdev/Img/favicon.ico?v=9c9246580b4a",
        "meta_site_name": "Programming Language Design and Implementation Stack Exchange",
        "canonical_link": "https://langdev.stackexchange.com/questions/3484/why-is-almost-every-programming-language-made-in-english",
        "text": "I think the primary reason for this is the same that motivates any other lingua franca: the desire to exchange ideas across different groups.\n\nWe can group the places where natural language is used in programming into a few different categories:\n\nKeywords - terms baked into the syntax of the language (\"if\", \"return\", \"while\", etc). These are what linguists would call a \"closed word class\"; they may be reserved from use as identifiers, or marked out with stropping.\n\nBuilt-in identifiers - names of functions, namespaces, classes, etc, which are part of the \"standard library\" of the language. These are generally an \"open class\", in the sense that new items are added reasonably regularly, and can move somewhat freely between this and the next category.\n\nUser-defined identifiers - this is the much largest list, and also the one over which languages designers have least direct influence. The main limitation placed is the available character set - if identifiers can only use the Latin letters in ASCII, some languages will be harder to use (though not impossible).\n\nError messages and other output. This generally depends not on the design of the language, but its implementation. These may be the same thing (e.g. PHP has only one widely used implementation), or entirely separate and widely varied (e.g. C compilers).\n\nDocumentation. On the face of it, this is the easiest to translate, and for example the PHP manual is currently \"fully\" translated into 9 languages.\n\nOf these, the vast majority of code that looks like language is user-defined identifiers. These can be, and regularly are, written in the user's first language - except when they're shared. If a new online service wants to publish an SDK on a package repository such as CPAN, NPM, Packagist, Nuget, etc, they need to define a public API for that package, and that involves choosing identifiers. If the majority of packages on that repository use identifiers in the same language, that is a lingua franca in exactly the same way as the trade languages of the ancient Mediterranean, or the Latin of Renaissance scientists.\n\nThis then leads back to the choice of built-in identifiers. The language designer could, in principle, provide multiple aliases for every built in function, giving the user a choice of languages. However, this becomes a wasted effort if the user community picks one as the lingua franca for sharing code samples and libraries.\n\nAs we get deeper into the core of the language, and particularly with keywords, we get a similar effect between languages: if you want new users to pick up your language, there is an advantage to them recognising parts of it. This leads to certain terms becoming somewhat standardised in their meaning - the lingua franca is based on a particular natural language, but becomes its own thing. For instance, the \"return\" keyword originated from the intransitive English verb meaning \"go back\", but has acquired programming-specific meanings: \"returned value\", \"return type\", and so on.\n\nTo circle back to error messages and documentation, like private identifiers these can be and often are translated; but they will still have to incorporate large parts of the lingua franca, to mention keywords and identifiers which are not translated.\n\nAll of that leaves us with a few situations where not using the lingua franca would be reasonable:\n\nWhere the language has no \"open word class\". For instance, Microsoft Excel has localized names for all its built-in formula functions.\n\nWhere the language isn't intended for writing code to share. The biggest example of this is educational languages: the main aim is to make it easy for users to write their own programs, to learn programming concepts.\n\nWhere the audience for the language is limited to a particular community. The macro language of an internal tool might exclusively use the local language of its developers, although the draw of the lingua franca will still be there from exposure to other languages.\n\nThroughout this, I've deliberately talked about the lingua franca in the abstract, because the fact that it is based on English is largely historical accident: English was the language in the UK and USA where major early computer science work happened; and it's also a lingua franca in other contexts, meaning it is accessible to a lot of users as a second language.\n\nFor English I assume it means a global language. For why English has become a global language, I think it's more of a question about history, instead of PLDI. Here I answer why a programming language would choose keywords from a global language.\n\nFirstly, as Seggan commented, there are a lot of programming languages using other natural languages. But it is much less likely someone would get to know a programming language not in either English or their first language. If you use English, you have a much broader user base, that could potentially get your language much more popular. If someone wants a broader user base, they would also choose English. So, in the end, the most popular programming languages you have known are in English.\n\nI think there are only two alternatives for this purpose. One is to make it multilingual.\n\nThere were some animation makers and game designers that had a way to make easy programs using a GUI list of commands, and the commands tend to be translated. It's easy because the translation doesn't change how the code is stored, but only how they are displayed. But users switch to the traditional way quickly, because the graphical way usually only support a restricted set of features, and the editor isn't very easy to use. Better examples on this direction would be Scratch-like languages. I don't know Scratch much, but I think it's much more powerful than the GUI lists, but still not as powerful as modern advanced languages.\n\nThe obvious problem of supporting multiple languages in traditional text programs, is the identifier names could easily conflict with keywords or system libraries in a language that the programmer doesn't know, or not even existed before the program has created. It might be better if the programmer chooses the language. But there is another problem, that translations tends to be slower than the original release, and if it's not the original developer making all the decisions, sometimes translations are bad and are subject to change, which would be very undesirable to use in a programming language. The programmers could use English before the translations are stable, but they would still have to learn the English version, adding more difficulty to just use English, and they would need an automatic translator to change the language afterwards. A potentially better way would be like the GUI lists, that only translate the words in the editor. In either case, I think they are not considered reliable operations for program source code, especially with eval and homonyms in consideration.\n\nBut I don't think these difficulties are absolutely unsolvable. Maybe someone could come up with some clever ideas. And they could start from languages that least likely conflict with English. I think the real problem is, keywords are not the only thing in a programming language. Documentation and libraries matter more. A translated programming language is of no use, if there are not documentations at all. And not many language designers had the resources to maintain documentations in that many languages. Library writers usually had less resources. That also answers why there had to be a popular programming language, instead of everyone using their own programming language in their own country: Actually there is not much reason for a programming language. You could do it if you had enough funds. But the reason is strong for libraries, and languages don't affect that much without libraries. A possible middle ground is, make everyone use their own language internally in a project, and export the symbols in English, to make a library popular, cost-effective, and non-English. But it might be difficult for us to know it is the case.\n\nTL; DR: The majority of libraries would support only one language, and you'll not know it if it is not English. Programming languages doesn't contribute much to the whole picture, but have extra difficulties, that may not worth it.\n\nAnother way is to use symbols, like APL. But that only applies for a small set of builtins. They still have to use words in natural languages if there are a lot of libraries.\n\nAlso note that while programming languages borrow words from natural languages, they are not the same. Some words like \"for\" \"yield\" are too generic but have gained much more specific meaning. But they may not affect translation.\n\nSurvey about the documentation languages in some programming language's homepage\n\nPython has English, Spanish, French, Japanese, Korean, Brazilian Portuguese, Turkish, Simplified Chinese, Traditional Chinese, 8 or 9 languages\n\nPHP has English, Brazilian Portuguese, Chinese (Simplified), French, German, Japanese, Russian, Spanish, Turkish, 9 languages\n\nRust has English (en-US), Español (es), Français (fr), Italiano (it), 日本語 (ja), Português (pt-BR), Русский (ru), Türkçe (tr), 简体中文 (zh-CN), 正體中文 (zh-TW), 9 or 10 languages\n\nRuby has Български, Deutsch, English, Español, Français, Bahasa Indonesia, Italiano, 日本語, 한국어, polski, Português, Русский, Türkçe, Tiếng Việt, 简体中文, 繁體中文, 15 or 16 languages\n\nC# has Bahasa Indonesia, Bahasa Melayu, Bosanski, Català, Čeština, Dansk, Deutsch (Österreich), Deutsch (Schweiz), Deutsch, Eesti, English (Australia), English (Canada), English (India), English (Ireland), English (Malaysia), English (New Zealand), English (Singapore), English (South Africa), English (United Kingdom), English (United States), Español (México), Español, Euskara, Filipino, Français (Belgique), Français (Canada), Français (Suisse), Français, Gaeilge, Galego, ქართული, Hrvatski, Íslenska, Italiano (Svizzera), Italiano, Latviešu, Lëtzebuergesch, Lietuvių, Magyar, Malti, Nederlands (België), Nederlands, Norsk Bokmål, Polski, Português (Brasil), Português (Portugal), Română, Slovenčina, Slovenski, Srbija - Srpski, Suomi, Svenska, TiếngViệt, Türkçe, Ελληνικά, Български, қазақ тілі, Русский, Српски, Українська, עברית‏,‎ العربية, हिंदी, ไทย, 한국어, 中文 (简体), 中文 (繁體), 中文 (繁體 香港特別行政區), 日本語, 48 or 69 languages\n\nScratch (user languages) has Аҧсшәа, Afrikaans, العربية, አማርኛ, Aragonés, Asturianu, Azeri, Bahasa Indonesia, বাংলা, Беларуская, Български, Català, Česky, Cymraeg, Dansk, Deutsch, Eesti, Ελληνικά, English, Español (España), Español Latinoamericano, Esperanto, Euskara, فارسی, Filipino, Français, Frysk, Gaeilge, Gàidhlig, Galego, 한국어, Hausa, Հայերեն, עִבְרִית, हिंदी, Hrvatski, isiXhosa, isiZulu, Íslenska, Italiano, ქართული ენა, қазақша, Kichwa, Kiswahili, Kreyòl ayisyen, Kurdî, کوردیی ناوەندی, Latviešu, Lietuvių, Magyar, Māori, Монгол хэл, Nederlands, 日本語, にほんご, Norsk Bokmål, Norsk Nynorsk, Occitan, ଓଡ଼ିଆ, Oʻzbekcha, ไทย, ភាសាខ្មែរ, Polski, Português, Português Brasileiro, Rapa Nui, Română, Русский, Sepedi, Setswana, Slovenčina, Slovenščina, Српски, Suomi, Svenska, Tiếng Việt, Türkçe, Українська, 简体中文, 繁體中文, 76 or 80 languages\n\nThe basic explanation is firstly that English is a widely spoken language around the world, and secondly that most computer technology has originated and continues to originate from America, where they speak English.\n\nMoreover, post-WW2 America became a centre in the world for scientific research of all kinds, so that the technology doesn't just originate in America but so do a lot of the ideas, terminology, and standards, and the academic institutions that gestate them.\n\nScale is important too. Not only does America itself speak English, but so do a number of its major allies and trading partners who have equally advanced economies with demand for computerisation. This means that a large mass of English-speaking professional workers, and technical artefacts and tooling in English, have already been accumulated, completely dwarfing what was ever available in any other language.\n\nSo if a company wants development done today, the biggest pool of resources are in English. Even if you hire developers who speak a local language, they are likely to have to also speak English to access the existing resources just to learn their trade in the first place, let alone continue to practise it commercially.\n\nSince the internet, there is also a huge \"hive mind\" of practitioners worldwide who can be consulted on difficult problems. These practitioners are either native English, or speak English as a lingua franca. This means practitioners have to carry on speaking proficient English regularly in order to consult with this hive mind.\n\nOnce all that investment is sunk in English-centric learning and speaking, there's usually very little to be gained, commercially, from diverting things back to the local language.\n\nOnly nation states with a political policy on language, and with an enormous commitment of economic resources, could really hope to challenge this dominance of English, but none yet have seen fit to do so."
    }
}