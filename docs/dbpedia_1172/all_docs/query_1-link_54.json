{
    "id": "dbpedia_1172_1",
    "rank": 54,
    "data": {
        "url": "https://stackoverflow.com/questions/2185252/reshaping-data-frame-from-wide-to-long-format",
        "read_more_link": "",
        "language": "en",
        "title": "Reshaping data.frame from wide to long format",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://cdn.sstatic.net/Img/teams/teams-promo.svg?v=e507948b81bf",
            "https://i.sstatic.net/NbeL9.jpg?s=64",
            "https://www.gravatar.com/avatar/abf12c6d5f0f19af932480a3e408063d?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/db14104bbdd70cf76290a15f77d88095?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/DlX7B.jpg?s=64",
            "https://i.sstatic.net/DlX7B.jpg?s=64",
            "https://www.gravatar.com/avatar/94cc201a0dd0cba1cbdbf05b195e17a1?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/4WkGW.jpg?s=64",
            "https://www.gravatar.com/avatar/73fd13cfacc3a0a0fc0a8c95f50d8a3f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/0cee97ffd90277bf4ac753331d50af60?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/KTfkF.png?s=64",
            "https://i.sstatic.net/SuM0U.png?s=64",
            "https://i.sstatic.net/BlsdV.jpg?s=64",
            "https://i.sstatic.net/4zKFL.png?s=64",
            "https://www.gravatar.com/avatar/c3cb1645dbbf14f423a06cdc9e1c229b?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/tGgv6.jpg?s=64",
            "https://stackoverflow.com/posts/2185252/ivc/9078?prg=04ba6ecf-9de2-411f-8144-c20dcb261bb1"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2010-02-02T15:36:12",
        "summary": "",
        "meta_description": "I have some trouble to convert my data.frame from a wide table to a long table.\nAt the moment it looks like this:\n\nCode Country        1950    1951    1952    1953    1954\nAFG  Afghanistan    20,24...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/2185252/reshaping-data-frame-from-wide-to-long-format",
        "text": "Two alternative solutions:\n\n1) With data.table:\n\nYou can use the melt function:\n\nlibrary(data.table) long <- melt(setDT(wide), id.vars = c(\"Code\",\"Country\"), variable.name = \"year\")\n\nwhich gives:\n\n> long Code Country year value 1: AFG Afghanistan 1950 20,249 2: ALB Albania 1950 8,097 3: AFG Afghanistan 1951 21,352 4: ALB Albania 1951 8,986 5: AFG Afghanistan 1952 22,532 6: ALB Albania 1952 10,058 7: AFG Afghanistan 1953 23,557 8: ALB Albania 1953 11,123 9: AFG Afghanistan 1954 24,555 10: ALB Albania 1954 12,246\n\nSome alternative notations:\n\nmelt(setDT(wide), id.vars = 1:2, variable.name = \"year\") melt(setDT(wide), measure.vars = 3:7, variable.name = \"year\") melt(setDT(wide), measure.vars = as.character(1950:1954), variable.name = \"year\")\n\n2) With tidyr:\n\nUse pivot_longer():\n\nlibrary(tidyr) long <- wide %>% pivot_longer( cols = `1950`:`1954`, names_to = \"year\", values_to = \"value\" )\n\nNote:\n\nnames_to and values_to default to \"name\" and \"value\", respectively, so you could write this extra-succinctly as wide %>% pivot_longer(`1950`:`1954`).\n\nThe cols argument uses the highly flexible tidyselect DSL, so you can select the same columns using a negative selection (!c(Code, Country)), a selection helper(starts_with(\"19\"); matches(\"^\\\\d{4}$\")), numeric indices (3:7), and more.\n\ntidyr::pivot_longer() is the successor to tidyr::gather() and reshape2::melt(), which are no longer under development.\n\nTransforming values\n\nAnother problem with the data is that the values will be read by R as character-values (as a result of the , in the numbers). You can repair with gsub and as.numeric, either before reshaping:\n\nlong$value <- as.numeric(gsub(\",\", \"\", long$value))\n\nOr during reshaping, with data.table or tidyr:\n\n# data.table long <- melt(setDT(wide), id.vars = c(\"Code\",\"Country\"), variable.name = \"year\")[, value := as.numeric(gsub(\",\", \"\", value))] # tidyr long <- wide %>% pivot_longer( cols = `1950`:`1954`, names_to = \"year\", values_to = \"value\", values_transform = ~ as.numeric(gsub(\",\", \"\", .x)) )\n\nData:\n\nwide <- read.table(text=\"Code Country 1950 1951 1952 1953 1954 AFG Afghanistan 20,249 21,352 22,532 23,557 24,555 ALB Albania 8,097 8,986 10,058 11,123 12,246\", header=TRUE, check.names=FALSE)\n\nWith tidyr_1.0.0, another option is pivot_longer\n\nlibrary(tidyr) pivot_longer(df1, -c(Code, Country), values_to = \"Value\", names_to = \"Year\") # A tibble: 10 x 4 # Code Country Year Value # <fct> <fct> <chr> <fct> # 1 AFG Afghanistan 1950 20,249 # 2 AFG Afghanistan 1951 21,352 # 3 AFG Afghanistan 1952 22,532 # 4 AFG Afghanistan 1953 23,557 # 5 AFG Afghanistan 1954 24,555 # 6 ALB Albania 1950 8,097 # 7 ALB Albania 1951 8,986 # 8 ALB Albania 1952 10,058 # 9 ALB Albania 1953 11,123 #10 ALB Albania 1954 12,246\n\ndata\n\ndf1 <- structure(list(Code = structure(1:2, .Label = c(\"AFG\", \"ALB\"), class = \"factor\"), Country = structure(1:2, .Label = c(\"Afghanistan\", \"Albania\" ), class = \"factor\"), `1950` = structure(1:2, .Label = c(\"20,249\", \"8,097\"), class = \"factor\"), `1951` = structure(1:2, .Label = c(\"21,352\", \"8,986\"), class = \"factor\"), `1952` = structure(2:1, .Label = c(\"10,058\", \"22,532\"), class = \"factor\"), `1953` = structure(2:1, .Label = c(\"11,123\", \"23,557\"), class = \"factor\"), `1954` = structure(2:1, .Label = c(\"12,246\", \"24,555\"), class = \"factor\")), class = \"data.frame\", row.names = c(NA, -2L))\n\nSince this answer is tagged with r-faq, I felt it would be useful to share another alternative from base R: stack.\n\nNote, however, that stack does not work with factors--it only works if is.vector is TRUE, and from the documentation for is.vector, we find that:\n\nis.vector returns TRUE if x is a vector of the specified mode having no attributes other than names. It returns FALSE otherwise.\n\nI'm using the sample data from @Jaap's answer, where the values in the year columns are factors.\n\nHere's the stack approach:\n\ncbind(wide[1:2], stack(lapply(wide[-c(1, 2)], as.character))) ## Code Country values ind ## 1 AFG Afghanistan 20,249 1950 ## 2 ALB Albania 8,097 1950 ## 3 AFG Afghanistan 21,352 1951 ## 4 ALB Albania 8,986 1951 ## 5 AFG Afghanistan 22,532 1952 ## 6 ALB Albania 10,058 1952 ## 7 AFG Afghanistan 23,557 1953 ## 8 ALB Albania 11,123 1953 ## 9 AFG Afghanistan 24,555 1954 ## 10 ALB Albania 12,246 1954\n\nHere is another example showing the use of gather from tidyr. You can select the columns to gather either by removing them individually (as I do here), or by including the years you want explicitly.\n\nNote that, to handle the commas (and X's added if check.names = FALSE is not set), I am also using dplyr's mutate with parse_number from readr to convert the text values back to numbers. These are all part of the tidyverse and so can be loaded together with library(tidyverse)\n\nwide %>% gather(Year, Value, -Code, -Country) %>% mutate(Year = parse_number(Year) , Value = parse_number(Value))\n\nReturns:\n\nCode Country Year Value 1 AFG Afghanistan 1950 20249 2 ALB Albania 1950 8097 3 AFG Afghanistan 1951 21352 4 ALB Albania 1951 8986 5 AFG Afghanistan 1952 22532 6 ALB Albania 1952 10058 7 AFG Afghanistan 1953 23557 8 ALB Albania 1953 11123 9 AFG Afghanistan 1954 24555 10 ALB Albania 1954 12246\n\nHere's a sqldf solution:\n\nsqldf(\"Select Code, Country, '1950' As Year, `1950` As Value From wide Union All Select Code, Country, '1951' As Year, `1951` As Value From wide Union All Select Code, Country, '1952' As Year, `1952` As Value From wide Union All Select Code, Country, '1953' As Year, `1953` As Value From wide Union All Select Code, Country, '1954' As Year, `1954` As Value From wide;\")\n\nTo make the query without typing in everything, you can use the following:\n\nThanks to G. Grothendieck for implementing it.\n\nValCol <- tail(names(wide), -2) s <- sprintf(\"Select Code, Country, '%s' As Year, `%s` As Value from wide\", ValCol, ValCol) mquery <- paste(s, collapse = \"\\n Union All\\n\") cat(mquery) #just to show the query #> Select Code, Country, '1950' As Year, `1950` As Value from wide #> Union All #> Select Code, Country, '1951' As Year, `1951` As Value from wide #> Union All #> Select Code, Country, '1952' As Year, `1952` As Value from wide #> Union All #> Select Code, Country, '1953' As Year, `1953` As Value from wide #> Union All #> Select Code, Country, '1954' As Year, `1954` As Value from wide sqldf(mquery)\n\n#> Code Country Year Value #> 1 AFG Afghanistan 1950 20,249 #> 2 ALB Albania 1950 8,097 #> 3 AFG Afghanistan 1951 21,352 #> 4 ALB Albania 1951 8,986 #> 5 AFG Afghanistan 1952 22,532 #> 6 ALB Albania 1952 10,058 #> 7 AFG Afghanistan 1953 23,557 #> 8 ALB Albania 1953 11,123 #> 9 AFG Afghanistan 1954 24,555 #> 10 ALB Albania 1954 12,246\n\nUnfortunately, I don't think that PIVOT and UNPIVOT would work for R SQLite. If you want to write up your query in a more sophisticated manner, you can also take a look at these posts:\n\nUsing sprintf writing up sql queries\n\nPass variables to sqldf\n\nHere's two options in base R (use x=unlist(df) instead of x=c(m) when the input is a dataframe and not a matrix):\n\n> m=matrix(sample(1:100,6),3,dimnames=list(2021:2023,c(\"male\",\"female\"))) > m male female 2021 89 42 2022 39 96 2023 26 40 > cbind(expand.grid(dimnames(m)),x=c(m)) Var1 Var2 x 1 2021 male 89 2 2022 male 39 3 2023 male 26 4 2021 female 42 5 2022 female 96 6 2023 female 40 > data.frame(row=rownames(m),col=colnames(m)[col(m)],x=c(m)) row col x 1 2021 male 89 2 2022 male 39 3 2023 male 26 4 2021 female 42 5 2022 female 96 6 2023 female 40\n\nA third option is to use as.table followed by as.data.frame, but it converts the row and column names to factors, and if your input is a dataframe then you have to convert it to a matrix first:\n\n> as.data.frame(as.table(m)) Var1 Var2 Freq 1 2021 male 89 2 2022 male 39 3 2023 male 26 4 2021 female 42 5 2022 female 96 6 2023 female 40 > as.data.frame(as.table(m))|>sapply(class) Var1 Var2 Freq \"factor\" \"factor\" \"integer\" > d=as.data.frame(m) > as.data.frame(as.table(d)) Error in h(simpleError(msg, call)) : error in evaluating the argument 'x' in selecting a method for function 'as.data.frame': cannot coerce to a table > as.data.frame(as.table(as.matrix(d))) Var1 Var2 Freq 1 2021 male 89 2 2022 male 39 3 2023 male 26 4 2021 female 42 5 2022 female 96 6 2023 female 40\n\nA fourth option is to use stack, but it converts the rownames and column names to factors, and the column names get converted to an Rle factor when the input is a matrix (but not when the input is a dataframe):\n\n> stack(m) DataFrame with 6 rows and 3 columns row col value <factor> <Rle> <integer> 1 2021 male 89 2 2022 male 39 3 2023 male 26 4 2021 female 42 5 2022 female 96 6 2023 female 40\n\nWhen the input for stack is a dataframe, the rownames don't get included as a column so you have to cbind them:\n\n> d=as.data.frame(m);cbind(row=rownames(d),stack(d)) row values ind 1 2021 89 male 2 2022 39 male 3 2023 26 male 4 2021 42 female 5 2022 96 female 6 2023 40 female"
    }
}