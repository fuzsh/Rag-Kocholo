{
    "id": "dbpedia_1587_1",
    "rank": 53,
    "data": {
        "url": "https://stackoverflow.com/questions/1364561/has-agile-really-worked-for-you-as-a-developer",
        "read_more_link": "",
        "language": "en",
        "title": "Has Agile really worked for you as a Developer?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://stackoverflow.com/posts/1364561/ivc/524b?prg=0cd01067-cf68-4666-9abf-c9de15303390"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-09-01T20:46:54",
        "summary": "",
        "meta_description": "I have met a lot of people for whom Agile has worked really well, and most of them tend to be managers and architects who plan and delegate the work. However I really haven't found much good develo...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/1364561/has-agile-really-worked-for-you-as-a-developer",
        "text": "At my first job, we had daily scrums, wrote automated tests, had automated builds, pair programmed, etc. We had been in the agile groove for several years. And for our efforts, we were rewarded with software that I wouldn't touch with 20ft pole. The quality of our product was atrocious: I'd describe as the piecemeal hacking of 100 amateur developers.\n\nWhat went wrong:\n\nThe company I worked at had a notorious reputation for hiring entry-level developers for the lowest pay ($25-27K/yr was the norm), and frequently we'd outsource work to the lowest offshore bidder. I've heard that agile just doesn't work on inexperienced developers, and I think it showed through the code and our turnover rate.\n\nNo documentation of any sort. No functional documentation, no technical documentation, no requirements, no bug tracking. No one ever wrote things down on persistent media: all requirements and bugs were communicated by email, word of mouth, and psychic mindreading.\n\nLousy testing: our automated tests were invaluable, but QA and UAT testing was a disaster. Since we didn't have any formal requirements documentation, QA users didn't know what new functionality they were testing, so all QA consisted more or less of haphazard end-to-end testing. User acceptance testing was performed in production: we installed the product on our customers servers and reported bugs as they occurred in production.\n\nCrisis-driven development: bugs were handled by using the \"OMG WE HAVE TO FIX THIS AND REDEPLOY PRONTO! NOW NOW NOW! NO TIME FOR TESTING JUST FIX IT!\" management methodology.\n\nAlthough we did everything right and really adhered to agile principles by the book, the methodology failed harder than anything else I've ever seen.\n\nIn contrast, the company that I work for now uses a waterfall-like methodology, produces a few hundred pages of documentation for each project, has few automated tests but a sizable QA team. Interestingly, the quality of our product is through the roof, and the work environment is orders of magnitude above and beyond the other company.\n\nI know many people have had the opposite experience. As is usually the case, methodologies are not a golden hammer --- you can probably start a successful project no matter what methodology you choose. In my experience on successful and unsuccessful projects, I get the feeling that methodology doesn't matter as much as environment: comfortable, happy developers and sane project managers are all it takes make a project work.\n\nAt my company, we made a wholesale switch to agile practices about 4 years ago when a new VP came in. This VP had experienced success with Agile in the past, and decided it was what we needed.\n\nAs it turns out, he was right. I was a developer at the time (albeit a somewhat junior one), and I loved the practices. Pair programming really aided knowledge transfer and prevented the formation of knowledge silos. Unit testing, test driven development, and test emphasis in general made for more robust code that wasn't over-engineered. No Big Design Up Front meant that instead of spending 6 months writing requirements documents (by which time the market had passed us by), we were prototyping and delivering real value to customers in a timely matter. Working closely with a customer surrogate (in our case, a technical product manager) greatly shortened cycle feedback time, which helped us deliver what the customer actually wanted.\n\nOur organization had quite a few talented developers, but we were very prone to cowboy coding. A few developers didn't like the new practices (\"What do you mean, write tests? I'm a developer!\"), but generally everyone loved the changes. Defect rates went down, customer satisfaction rates went up, and our office became very well regarded in our company.\n\nAbout a year ago I became a manager, and I heavily use Agile practices, incorporating some Lean principles as well (value stream analysis, waste elimination, kanban). Tightening up release cycles has been an ongoing activity, and my team now releases as often as possible (with quality!) - often every two weeks. We have no field reported defects from my team in the past year, and the sales people and product management love the shorter release cycles.\n\nAs a developer, Agile really increased my confidence in working with various areas of code (I now feel nervous whenever I'm changing anything in a package that DOESN'T have 100% unit test coverage!), taught me to be a more well-rounded programmer (thinking of test implications, business impacts, etc.), and helped me write simple, self-documenting code. As a manager, Agile and kanban gives me predictability, lower lead times, lower defect rates, and an empowered team. This is not theory, or speculation, or hand waving - our team morale, defect rate, customer satisfaction, and balance sheet have proven that Agile can do wonderful things for an organization.\n\nTo comment on the Principles of the Agile Manifesto from my experience at a site that tried it.\n\nOur highest priority is to satisfy the customer through early and continuous delivery of valuable software.\n\nThis was a double-edged sword for my last site -- valuable was taken to mean 100% perfect and bug-free.\n\nWelcome changing requirements, even late in development. Agile processes harness change for the customer's competitive advantage.\n\nI still communicate with that site and just today, their rock-hard deadline date, they were given a requirement change. That was just the way things were there; it's almost as if they wanted failure.\n\nDeliver working software frequently, from a couple of weeks to a couple of months, with a preference to the shorter timescale.\n\nThe norm for many years was basically build and deploy daily, hourly, near real-time...\n\nBusiness people and developers must work together daily throughout the project.\n\nSome of the meetings/reviews with respect to this were hilarious. We were reprimanded for not working with the people (because they asked us not to because they were already working 9-10 hour days) and then for bothering them because they were busy.\n\nBuild projects around motivated individuals. Give them the environment and support they need, and trust them to get the job done.\n\nAhh, here's our problem... We had top-of-the-line PCs but the business side wasn't supportive. The positive morale essentially got beaten out of you after about a year or so... This also negates your micromanagement concern (if implemented correctly).\n\nThe most efficient and effective method of conveying information to and within a development team is face-to-face conversation.\n\nThis worked out well. Personally I prefer email because I hate taking notes.\n\nWorking software is the primary measure of progress.\n\nNo doubt here.\n\nAgile processes promote sustainable development. The sponsors, developers, and users should be able to maintain a constant pace indefinitely.\n\nI agree with this 100%; the problem with the last business team I worked with was the expectation of 30-hour days, 10-day weeks, and 400-day years was not a pace I agreed with.\n\nContinuous attention to technical excellence and good design enhances agility.\n\nThis is where some developer morale & education was needed.\n\nSimplicity--the art of maximizing the amount of work not done--is essential.\n\nI love this one and it's long been one of my goals. However, there was a \"if you're not typing, you're not working\" attitude that was tough to overcome.\n\nThe best architectures, requirements, and designs emerge from self-organizing teams.\n\nI agree with this about 90% -- my only caveat is that they must be well-educated and well-informed teams.\n\nAt regular intervals, the team reflects on how to become more effective, then tunes and adjusts its behavior accordingly.\n\nWe just failed here and it likely caused a lot of other problems we had. The business side was really good at saying \"you need to do what we say needs to be done.\"\n\nTo wrap it up, if you're working somewhere where everyone is informed and on board with an Agile methodology, it should be a great place to work. When the goal is great software, momentum alone will carry any project.\n\nFrom my personal experience, Agile methodology tends to create a huge technical debt in the long term, and while it might save you (as a business owner/management) a couple of bucks short term, in the long term it will come back and bite you. Whatever you do not fix now will eventually cost you many hours of work to fix at a much higher cost than it would have cost you to invest some more hours into the original problem.\n\nAgile is always great from the point of view of beginners and management, but I do not know one experienced programmer who actually loves it. The whole point of Agile is to save development money for a company, it has nothing to do with actual product quality. In fact most of the methodology promotes bad code done quick over well-engineered code. The difference is that a few years down the road, you have to do the whole work all over again whereas the well-engineered code can last decades without corrections. Good programmers do not need Agile methodology most of the time.\n\nWe have a business logic library written 22 years ago here by a single team of 3 programmers using waterfall methodology, and that code hasn't needed a single correction since. Because it was tought properly, was well-engineered, and the three programmers took their time and were careful with their implementation. Agile methodology would instead ask of those three to do the strict minimum to make sure some ill-defined tests passed, and then wait until the next time you hit a wall to add some more duct tape code. It's a ridiculous way to work and goes against every engineer fiber in my body.\n\nTo this day I refuse to work in an Agile environment, because frankly I do not need it, and I do not need an employer who thinks I do need it.\n\nI'm a developer and a manager at the same time, so I either have special insight or my opinion is totally invalid. ;)\n\nI will say that Agile means a lot of things. It's actually a whole family of methodologies and guidelines at this point.\n\nExposing yourself to all these interesting ideas is really the thing. As a manager, it's very hard for me to decree that a whole team suddenly adopt a whole methodology, but if they see me constantly trying to improve every aspect of my game, I think they appreciate that. And hopefully, if they like what they see, they follow my example.\n\nI've managed to slowly implement a bunch of things from Scrum without (hopefully) coming off as a tool. Burn down reports, stand-up meetings, and story cards on the whiteboard have really made us better at shipping software. For instance, on any project tasks are constantly being done ahead of schedule or late. In a really big project, it can become very difficult to tell what that's doing to your ship date. With burn down reports, I can tell what a slip does to our ship date, and if we need to just start cutting features in order to meet a deadline.\n\nThat's more of a management thing, but the other devs here care about it because it might mean they get to keep their jobs or avoid a death march. :)\n\nBut it's not just management stuff. There's tons in Agile about best practices for source control, unit testing, etc. Just good solid best practices. As an industry, we are pretty terrible about mentoring, so it's good that this information is out there.\n\nI guess what makes an \"agile\" project agile, is the methodology: \"Design for today not for tomorrow\".\n\nFor any not life-critical software systems this is a way to keep programmers coding in stead of discussing ages about design. Please note that design is not scrapped, it is just done in smaller and therefore more overseeable chunks.\n\nAll other techniques that are associated with agile, like pair programming, are more borrowed ideas that could also be used effectively in any other methodology.\n\nNow, does this technique 'work'? Yes! If applied correctly, the technique promotes that the software product will be ready for shipping at any time to react to competition.\n\nOn the other hand, because programmers are feeling they are coding more, they are generally happier. And they are less irritated by writing specs because this phase is inherently always small.\n\nBut again, if you know exactly what your product is going to be and especially if it is life-critical like the space shuttle, agile development is not what you want.\n\nNearly every management is aware of \"Agile\" by now: It's this thing, you know? Alone by your initial question I would assume that something is really going wrong. I really recommend you reading a book like Practices of an Agile Developer (as the title suggests - it's about what's in for you).\n\nSome managers read a book and then will know what agile is all about. They are telling you what to do and everything is fine, isn't it?\n\nIf you look around, there are a lot of developers (in Agile companies) who can't tell you within a second what the purpose of a stand-up is - and that's an issue. If you (and maybe even nobody else) don't know the why the StandUp won't make things better.\n\nTake a look at time tracking (and time estimation) - there are some managers who think it's about measuring how much work you do: Hey, you have a 40h contract but the time tracking tool says that you have only be working for 38h this week! That's not how it was meant to be used.\n\nThe only thing you can do about that: you need to learn what agile methods are out there. Mediocre managers will pick the ones they find interesting. Good managers will grasp the why and not only choose the methods for their direct benefit - but also those which will make the team more happy / efficient / teamish (Team vs Workgroup).\n\nP.S. Something you really need to take care of: In agile there is no place for slackers. Everybody has to do stuff on their own. You have to put personal interest into the success of the product. If you don't do things on your own, somebody will tell you what to do (and then there's micromanagement)."
    }
}