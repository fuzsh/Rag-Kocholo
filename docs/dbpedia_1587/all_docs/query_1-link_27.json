{
    "id": "dbpedia_1587_1",
    "rank": 27,
    "data": {
        "url": "https://railsware.com/blog/what-is-agile-product-development/",
        "read_more_link": "",
        "language": "en",
        "title": "Agile Product Development - Agile Methodology Fundamentals",
        "top_image": "https://railsware.com/blog/wp-content/uploads/2021/09/agile-product-development.png",
        "meta_img": "https://railsware.com/blog/wp-content/uploads/2021/09/agile-product-development.png",
        "images": [
            "https://railsware.com/blog/wp-content/uploads/2021/09/agile-product-development-180x180.png",
            "https://railsware.com/blog/wp-content/uploads/2021/06/piotr-malek-68x68.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/agile-product-development-guide-1024x538.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/traditional-vs-agile-product-development-1024x1024.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/agile-development-flow-1024x1024.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/dynamic-systems-development-method-agile-1024x1024.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/adaptive-software-development-agile-1024x1024.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/agile-lean-software-development-principles-1024x1024.jpg",
            "https://railsware.com/blog/wp-content/uploads/2020/03/Scrum-Alternatives-XP-1024x505.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/09/scrum-process-agile-1024x700.jpg",
            "https://railsware.com/blog/wp-content/uploads/2021/11/bridges-banner-1024x536.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Piotr Małek"
        ],
        "publish_date": "2021-09-02T13:30:45+03:00",
        "summary": "",
        "meta_description": "Applications and benefits of Agile product development methodology: exploring fundamental principles and comparing against traditional waterfall methods.",
        "meta_lang": "en",
        "meta_favicon": "https://railsware.com/blog/wp-content/themes/railsware/images/favicon.ico",
        "meta_site_name": "Blog by Railsware | Blog on Engineering, Product Management, Transparency, Culture and many more...",
        "canonical_link": "https://railsware.com/blog/what-is-agile-product-development/",
        "text": "There is some mystique surrounding agile product development. In this article, we aim to strip that away by explaining the key features and benefits of the Agile methodology. Then we compare them against more traditional approaches. To conclude, we explore how Agile helps to deliver complex product development projects.\n\nThe basics of Agile methodology\n\nAgile is a term that has gained considerable traction in recent years. Agile software development, Agile project management, Agile marketing – Agile “you name it” – have all gained prominence. Nearly everyone these days does something Agile, and they do it for a reason – because it works for many modern projects.\n\nThe core of any discussion on Agile is the Agile Manifesto, popularized many years ago and still very much up-to-date in the third decade of the century.\n\nAgile Product Development delivers (predominantly) digital products that emphasize flexibility, communication, and adaptability. It’s an excellent choice when there are many unknowns, and the project relies on a set of hypotheses. Unsurprisingly, that’s the reality of the vast majority of products in the early development stages.\n\nThe Agile methodology allows teams to deliver quick results, adapt to ever-changing circumstances, and save valuable resources.\n\nProject delivery with short iterations\n\nRather than planning and executing the entire project, the first stage of the product lifecycle is done differently. It is broken down into a series of much shorter phases, known as sprints, where progress is examined more regularly.\n\nHaving the timeboxed iterations helps to concentrate on what’s most important. Some requirements may not get addressed because of the time limits. However, what gets developed is the most essential of the required features.\n\nTimeboxing minimizes the effort and resources required to achieve the expected goal. It also helps prevent “feature creep,” where features are constantly added to the products without accessing their relevance or need.\n\nPhase by phase building, testing and reviewing\n\nContrary to the sequential nature of traditional product development, agile teams deliver nearly all the time. Towards the end of every sprint, deliverables are tested, assessed, and reviewed. Then, the adjusted plans are made for the following sprint.\n\nThis forces agile teams to efficiently use their time, effort, and resources to create working MVPs. This, in turn, helps to adjust the plan for every cycle that follows until the project is completed.\n\nFeedback\n\nFeedback is used to fix problems or refine improvements before moving on to the next iteration of development work. It’s also an essential part of product discovery – it helps the team understand if the idea makes sense and if the team is moving in the right direction.\n\nThis works well with the incremental nature of agile. After each new iteration is shipped, agile teams rush to gather feedback from users, beta testers, and virtually whoever agrees to give the product a try. In this, they’re trying to figure out:\n\nwhich features solve business and customer problems in a satisfactory manner\n\nwhich features require further attention\n\nwhich desired features have been overlooked\n\nwhich features are critical in the customers’ purchasing decision\n\nwhether the design helps users achieve their goals or, quite contrary, detracts them from it\n\nAll the feedback they can acquire this way, they can then process, validate against their hypotheses, and build future sprints based on all the information currently at their disposal.\n\nThis approach gives the product teams a much better chance of finding the right match. It lets them see their work results first-hand, keeping them engaged and connected to the outside world.\n\nTraditional vs. Agile product development – pitfalls and benefits\n\nThe traditional approach to product development (waterfall methodology) relies on different principles. It emphasizes careful planning, structure, and clear responsibilities. Waterfall is a sequential product development model – meaning that teams move from one stage of the process only after they’ve completed the previous one.\n\nTo understand the difference between the two, let’s look at the example. Suppose you came up with a revolutionary idea for an app that would match pets living in a nearby shelter with people willing to adopt them. Let’s call it PetMatch.\n\nPetMatch uses advanced ML and AI techniques to analyze your social profiles, interests, past behaviors and does all sorts of creepy stuff to ensure a perfect match.\n\nIf you were a waterfall person, you would write down your hypotheses, do deep research on similar apps, measure the demand for that kind of solution and assemble a team. Together, you would draw the first designs of the app and build a product roadmap, detailing everything that needs to be done to complete the app. This process can be streamlined significantly with the use of a white label app builder, which offers customizable features, enabling a more efficient and cost-effective development journey.\n\nThe team would then split responsibilities and tackle the epics, one by one, until all required features are taken care of. Once you’re finished, you would then test the app, fixing any bugs and eventually releasing the app to the first users.\n\nAs a part of an agile team, you would also start similarly. You would write down hypotheses, research the topic, and perhaps visit a few shelters in the area. You would run the idea by as many people as you could encounter, diligently noting their inputs and adjusting your assumptions accordingly.\n\nYou would then build a very basic version of your app and head back to the very same people to gather their feedback. You would repeat it with each new iteration, heavily iterating, possibly even pivoting at some point, and testing each new version on the spot. Eventually, you would release the app’s final version and rush back to the users to gather their feedback.\n\nWhen waterfall works well\n\nSequential methodologies such as waterfall work well when:\n\nSystems can be described in detail beforehand.\n\nRequirements are known and most likely won’t change throughout the project.\n\nIt’s safe to plan the roadmap and then execute it.\n\nThis is the case in many traditional industries – for example, enormous energy and construction infrastructure projects. These activities generally must occur in sequence and with a model that’s well-tried and tested. Although small internal tests and early feedback obtained this way are possible, these organizations tend to be too bureaucratic to allow changes on the fly. As a result, the iterative approach and feedback gained this way are not the focus.\n\nSame way, a waterfall works excellent when your plan is based on facts rather than assumptions – in other words, when you’re about to build something that has been made before, in the same or a similar way. This can be launching a new restaurant, designing a new mobile phone, developing a system that already exists but will now be targeted at a different niche. In all these cases, waterfall could be a faster way of completing a project.\n\nThe problem with waterfall\n\nHowever, more often than not, in our fast-changing world, precisely defining a project at its start is difficult at best. A lot of our ideas are based on assumptions that eventually need to be validated. And it’s far easier to validate them early in the product development process.\n\nDuring the final product testing phases, a considerable amount of time, effort, and resources have already been spent. So the potential for waste is enormous. Fundamental mistakes noticed at the last minute are likely to be costly and have serious consequences.\n\nThis creates long delays in launching new products in the market. The result is disappointed customers and losing out to your competitors. With the waterfall approach, the risk often outweighs the reward.\n\nValidating our assumptions fast mitigates the risks of building the wrong product. As founders or product people, we assume that people would use different features or that a product would immediately gain traction. The reality is that without any viable evidence of the market demand, our assumptions will remain what they are – just assumptions.\n\nAgile Product Development\n\nAgile product development alleviates issues by identifying them at various project stages – not just at the end.\n\nIdeally, each phase or iteration will produce a part of the envisaged new product that can be tested before moving on to the project’s next step. Sprints, commonly referred to in Scrum terminology, can vary in length but average at around two weeks and no more than one month.\n\nAs the sprint comes to an end, ideally, new user data flows in, and an agile team can quickly adapt – focus on a more prospective feature, expand user testing to confirm or discard a particular assumption, etc. This gives them a distinct advantage over waterfall teams because they know about any issues firsthand and have the flexibility to react to them.\n\nContinuing with our previous agile example – early in the product lifecycle, we realized something is wrong with PetMatch. Users sign up but don’t even complete their profiles. Advanced matching algorithms are there, and they work like a charm but don’t bring much value to a user. The design gets better with each new release, but the results don’t follow.\n\nHad we been taking this the waterfall way, we would have been already sitting in the AppStore with a complete app but no users, wondering what went wrong.\n\nBeing agile, we’ve spotted what’s coming early in the cycle. We’ve since simplified the user questionnaire and cut the features no one would use, one by one. Since none of these brought the expected results, we’ve made a pivot and reshaped our initial assumptions. Eventually, we got rid of the whole matching thing and built a fantastic app for dog owners to meet and hang out together. And it became an instant hit.\n\nDon’t get us wrong. Agile is not the magical solution for building the next unicorns, just like that. But it works so much better in such an unpredictable, dynamic environment than the typical waterfall approach.\n\nMinimum viable product\n\nAnother common term associated with Agile is MVP (minimum viable product). MVP is the version of a product that requires the smallest amount of effort possible to create just enough features that can be tested with real users.\n\nIt might take one or several sprints to create an MVP, and it is an efficient way to test the technical merits of a new product and test the market. This is the best way to see whether there is enough customer interest to justify further product development.\n\nProduct development strategy components\n\nThe most crucial parts of the product development strategy should be followed through with an MVP, which will be implemented in miniature. The process should include the following stages:\n\ncustomer research\n\ncompetitor analysis\n\nbusiness model review\n\nmarket/macro research\n\nAt each stage, we’re trying to gauge the interest in certain features of our product and understand their overall impression of the product to potential customers (and stakeholders – in some cases). This helps the project team shape the product and further improve or ditch features. It’s also beneficial for validating ideas and adjusting the strategy.\n\nWhen the release candidate is finally prepared, you launch with far greater confidence. The earlier feedback gave you proof that the investment was worth it, and if you were agile enough, you invested resources just in the right features.\n\nAgile cyclical iteration workflow applied to software development\n\nEach agile cycle has the same or a similar workflow. The end of one always means the beginning of the following one, continuing until the product is developed.\n\nA typical agile flow looks like this:\n\nRequirements – based on project objectives and customer/stakeholder feedback, define the iteration requirements or scope to be addressed.\n\nDevelopment – design and develop software based on the defined requirements.\n\nTesting – product testing and quality assurance, the development of documentation, and knowledge sharing.\n\nDelivery – taking the working iteration into production or showing it to the early adopters.\n\nFeedback – obtaining detailed customer/stakeholder feedback – assessing whether the product met their expectations, solved their problems, and if it was clear how to use it.\n\nAs the feedback is gathered, it’s prioritized and used to plan the next iteration. And then it goes again, starting with requirements for the next sprint.\n\nAgile product development teams\n\nSince each iteration requires several activities to be performed, including (but not limited to) design, marketing, development, and testing, agile teams are cross-functional. Different specialists have the same goal, and they need to work with other teammates to achieve it.\n\nThis is different from a traditional process, where specialists hand over work to each other – e.g., the implementation team finishes their part of work and hands it over to the QA team. In Agile, the whole team is responsible for the delivery, and no hand-offs are assumed, which results in high productivity and engagement.\n\nWhilst some members of the project team focus on specialist tasks that require expert knowledge and skills, others perform more of a general role. They devote more attention to project road-mapping, facilitating communication, or progress tracking.\n\nSpecialists are typically designers, developers, QAs, and customer satisfaction researchers, and the more general roles would be business analysts and project managers.\n\nIt’s important to note that the structure of teams can change throughout the process. There are no fixed roles, no “my tasks” and “someone else’s tasks.” The key is getting the job done, and the structure needs to be flexible enough to help achieve this goal.\n\nProduct teams can have different structures depending on the product domain, the development phase, and the agile framework used.\n\nAn efficient team should be able to:\n\nDefine: set the goal of iteration and outline its scope\n\nBuild: there should be specialists who can deliver the required product increment\n\nTest: make sure that the created increments meets the goal and have the correct scope\n\nDeploy/Analyze: be able to deliver and analyze the results\n\nAgile teams are meant to be self-organized. The role of a manager is to remove the obstacles and provide the missing information rather than instruct individual team members on what they should do.\n\nThe common approaches to agile\n\nThere are various methods of running an agile team. Some are very different from each other, while others have small differences between them. It’s common to combine practices from several approaches and adapt them to the teams’ needs.\n\nFeature Driven Development (FDD)\n\nAn iterative and incremental software development process, FDD is another Agile method for developing software.\n\nIt consists of five basic activities and is used to deliver “feature projects.”\n\nDevelop an overall model\n\nBuild a features list\n\nPlan by feature\n\nDesign by feature\n\nBuild by feature\n\nFDD is used when you need to scale agile processes to larger teams.\n\nDynamic Systems Development Method\n\nAnother iterative, incremental approach, DSDM, is an agile software development methodology largely based on the Rapid Application Development (RAD) methodology.\n\nAdaptive Software Development (ASD)\n\nPioneered by the work of Sam Bayer and Jim Highsmith on rapid application development, adaptive software development is a process that encapsulates the idea that continuous adaptation of a process to the task at hand is the norm.\n\nCrystal\n\nInstead of focusing on processes and tools, the Crystal methodology focuses primarily on people and their interactions in project work.\n\nLean Software Development (LSD)\n\nAdapted from the Toyota Production System, lean software development represents applying lean manufacturing principles and practices to software development.\n\neXtreme Programming (XP)\n\neXtreme Programming (XP) software development methodology is intended to improve software quality and responsiveness to changing customer requirements.\n\nXP is often used in conjunction with scrum. It puts the focus on testing and assessing customer satisfaction at each iteration. It also provides the team with regular and speedy feedback in short development cycles, using:\n\ncode review\n\npair programming\n\nunit-testing\n\nfrequent customer interaction\n\nScrum\n\nScrum is the go-to framework for developing, delivering, and sustaining complex products. Initially focused on software development, it can also be used in research, marketing, and sales.\n\nScrum is the most used Agile approach. And the most crucial element of this principle is employing a small and effective cross-functional team. The team members work closely together during each sprint.\n\nThere are frequent review and planning meetings, and each iteration runs a fixed amount of time. There are four components of a typical scrum: the product owner, the scrum master, the development team, and the stakeholders.\n\nThe role of product owners is both strategic and tactical. And this encompasses setting objectives and planning activities, and hands-on involvement. At a strategic level, the product vision is created based on the following:\n\ntarget group (who are your customers)\n\ntheir needs (what problem your product solves)\n\ncompetitive advantages (what makes your product stand out)\n\nbusiness goals (benefits for the company)\n\nTactical planning activities include backlog management, prioritization, pivoting (when necessary), and data-driven decision-making. Product managers or dedicated product owners usually perform them.\n\nScrum master\n\nThe role of the scrum master could be described as the oil which keeps the wheels turning. This role provides guidance and facilitation to the work of the development team. It ensures that the right tasks are completed on time and any potential obstacles removed.\n\nDevelopment team\n\nThe “development team” is a cross-functional and self-organized group of specialists. They have the technical knowledge and skills to design, produce, test, and deliver new product or software phases.\n\nStakeholders\n\nStakeholders are also part of the scrum framework. These cover a range of different participants in a software development project. Examples are end-users, company management and investors, customer researchers, market researchers, operations managers, and support.\n\nSee more Scrum alternatives in our dedicated article.\n\nA big challenge with overseeing Agile teams is managing the iteration scope, tracking the progress, and staying focused on the goal. After all, we want to encourage freedom, innovation, creativity, and self-management among the project specialists.\n\nIn the past, most managers used a combination of spreadsheets, presentations, and whiteboards to communicate their product strategy and roadmap. Then, they would use rigid project management systems to distribute the tasks between team members and deliver the fixed scope.\n\nBut as the application of Agile methodology evolved, another way emerged. It became clear that we needed purpose-built software tools for effective project coordination and communication. Many tools were born, and the vast majority of them work well with agile methodology.\n\nHere are some that we frequently use for product development purposes at Railsware. They help us with management, product discovery, as well as things like requirements and documentation:\n\nFigma – for crafting interfaces and collaborating on them\n\nJira – for managing and tracking complex projects, encompassing several teams\n\nTrello – for smaller projects and cross-team collaboration\n\nCoda – for team collaboration on ideas, solutions, and research\n\nMural – for complex planning sessions and agile product inceptions\n\nClickUp – for tracking bugs and prioritizing work\n\nSlack – for seamless communication within the team and with external stakeholders\n\nGoogle Hangouts – for video calls because nothing feels better than finally seeing your remote colleagues :)\n\nBRIDGeS – a flexible decision-making framework for product discovery and problem-solving. After years of experimenting with a host of similar tools, we decided to create our own — BRIDGeS — inspired by Pivotal Lab’s Inception framework. Since then, we have used this tool to develop ideas and solutions for countless in-house and client products.\n\nWrapping up\n\nWhen comparing agile with a traditional approach, the former is often more challenging than the two. That’s often the case because:\n\neach team member is responsible for the feature, not only for their part of the work\n\nself-organization is required\n\nhigh-qualified specialists are needed\n\nability to work in a team is crucial\n\nconstant learning is a must.\n\nHowever, it’s a practical approach to building products that clients will love with the right vision, tools, and people.\n\nIf you’re interested in exploring more about product development and discovery, be sure to explore our blog and BRIDGeS page, where we cover different techniques in detail and share a lot of our knowledge.\n\nThanks for reading!"
    }
}