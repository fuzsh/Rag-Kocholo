{
    "id": "dbpedia_1587_1",
    "rank": 54,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/220/agile-for-the-solo-developer",
        "read_more_link": "",
        "language": "en",
        "title": "Agile for the Solo Developer",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://i.sstatic.net/e5e04.jpg?s=64",
            "https://www.gravatar.com/avatar/ebfb21aa4b5009a1add8585c35d9f3c6?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Fp3hB.jpg?s=64",
            "https://i.sstatic.net/WVlfv.jpg?s=64",
            "https://i.sstatic.net/SHNzv.jpg?s=64",
            "https://i.sstatic.net/O0uxL.jpg?s=64",
            "https://www.gravatar.com/avatar/22ac2ff7313d8e523a5950a687670d0c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/c8b7b57bb9158cb28378ef5310c3ff6b?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/1f85bf8f6857fa38b87ec4ecc4a67d3e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/AJ6tP.png?s=64",
            "https://www.gravatar.com/avatar/677d7d18fb64c1e250ac5b7c4a2f76d5?s=64&d=identicon&r=PG",
            "https://softwareengineering.stackexchange.com/posts/220/ivc/524b?prg=f95480fe-de70-4529-9385-3cad3b7e8bab"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2010-09-01T21:56:06",
        "summary": "",
        "meta_description": "How would someone implement Agile process concepts as a solo developer?  Agile seems useful for getting applications developed at a faster pace, but it also seems very team oriented...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/220/agile-for-the-solo-developer",
        "text": "Limit work in progress (in addition to time-boxing). Even if you use an iterative method (as opposed to Kanban), let's say your velocity is 8 points per iteration. Don't start working on all 8 at once. Limiting WIP by either the number of stories or story points is fine.\n\nHave automated acceptance tests for all of your user stories. Automate as much as you can in general.\n\nErr on the side of making user stories too small. As a rule of thumb, make the ratio of biggest to smallest story 3:1. If you underestimate a story in Scrum and it turns out too big, multiple developers can swarm it to get it back on track. But you don't have enough people.\n\nIf, in a regular-sized-team context, you would hesitate whether to split a spike off a user story - in the solo or small-team context, do the spike without hesitation. This helps to keep stories smaller and more predictable.\n\nRetrospectives are important in agile in general, so Kanban (that would be Personal Kanban) scores extra points here, because its retrospective process is more data-driven. It's hard to play Triple Nickels when you don't have enough people.\n\nThese things apply probably to both solo and small-team (2 or 3 developers) situations.\n\nADDED: sometime after I wrote this answer, I found this conference talk and was very impressed: Personal Kanban: Optimizing the Individual Coder\n\nAgile works just as well for individuals as it does for teams. It's about finding a process that works for you, and allowing you to adapt to changing circumstances once your project has already started. It's also about delivering value to your customer regularly, regardless of whether or not the software is actually \"finished\".\n\nAgile processes are highly iterative. Work is done in short TimeBoxes/sprints/cycles/iterations. Some design work may be required up front, but can be refactored as you learn more about what it is you need a system to do. Unit testing is the backbone of nearly all Agile development methods, giving you an indication of whether your software is working, and if additions/changes to your software will break the existing code base.\n\nIf you adhere to BDD/TDD, allow your requirements to change with the wind and can adjust your feature priorities accordingly, if you build your entire system and run all of the tests often, and if you deliver working code at the end of each sprint, you are already Agile.\n\nRecently, I wrote on how a single developer can use agile and other techniques in work and I named it as The solo developers Manifesto, which is available at this Github Repo\n\nI then created Free Currency Exchange API using this manifesto and it took me 2 days to complete, so I would say this manifesto is pretty much practical\n\nHere is the Complete Manifesto:\n\nThe Solo Developers Manifesto\n\nThis guide will help solo developers achieve what could be achieved by teams by God's mercy\n\nPhases:\n\nEach Phase should be timeboxed\n\n1. Planning:\n\nDefine objectives/ from users' perspective (what user problem it solves, what user wants etc) and not from Devs perspective (Extra features, fancy looking etc), also write basic user acceptance test\n\nStart this Phase ASAP to avoid going beyond deadline\n\nGood Research for best simplest design (Includes learning new things)\n\nGood upfront design (avoids future blocking issues)\n\nDivide this phase into subphases i.e. Research, Designing, Estimation and timebox each one\n\nSubdivide the work recursively till you get the smallest task unit, this helps in proper estimation\n\nStory -> Features -> Task -> Sub Task\n\nAdd the tasks in backlog & group tasks into meaningful group & Sort the group by priority/MoSCoW (Must have, should have, could have, and Won't have, use users POV during prioritization) & story points (Reprioritization/Re-estimation/Redo Dead lining if new feature is added to backlog)\n\nTimebox each Sub Task and keep daily tasks to do list\n\n1.1 Designing :\n\ncomplicated user interactions/simple requirements interaction with simple use case design (draw.io)\n\nsimple UI design with MS paint, use tested UI design patterns (e.g. Want to add search bar? use Google search bar design)\n\nSpike solution (small experiment/program to research the answer to a problem)\n\nsimplest design (no fancy features etc, don't worry about future requirements)\n\nworse is better, Software that is limited, but simple to use is better, than buggy or complex software with complex features (less features, more quality)\n\nDon't program features until they are actually needed (YAGNI)\n\nWrite programs that do one thing and do it well and work with other programs\n\ncomplete design: The design must cover as many important situations as is practical. All reasonably expected cases must be covered. Simplicity is not allowed to overly reduce completeness.\n\nUse software standards for everything (e.g. semantic versioning etc)\n\n1.2 Estimation:\n\n10-20% buffer time while estimating deadline (E.g. 1-day buffer means, release date 29th-30th) (avoids stress & frustrations)\n\noverestimation-Parkinson's law, underestimation-no work/feature get done\n\nProper estimation is very important for highest productivity (No time limit/deadline - Low productivity)\n\n2. Implementation:\n\nMake sure I am following the manifesto properly\n\nStart day by observing/tracking yesterday's task and deadline, things TODO today, and any blocking issue to fix it\n\nTrack the work daily to meet deadline (Zen Hub-burndown chart, Kanban board) & correct productivity/blocking issue if any and prioritize accordingly\n\nUse pomodoro Timer Technique for Time Management -&gt; work for n tasks for x mins(30-90mins,depending on estimated time), small break(3-5mins) if fewer than n task completed else large break(10-15mins), pomodoro is indivisible and cannot be interrupted, other things should be done after pomodoro or else abandon pomodoro. After task completion any remaining time used for Reviewing the work and also seeing from learning POV (What I learned? What could be done better etc)\n\nUse Test-driven development (TDD) during coding:\n\nConvert software feature/requirement -&gt; test case (concise, note it down for future unit testing),\n\nrun test and see it fail,\n\nwrite code to only pass the test (No refactoring)\n\nrun test and see it pass (the code should not break any existing feature) (if it's gotten hard to pass the above code, then revert the above code to avoid excessive debugging) & commit,\n\nrefactor the new code and the whole code & commit (deepcode/standardjs --fix)\n\n2.1 Testing:\n\nUnit Test, Total feature test, acceptance test (users POV), stability test(stressing)\n\n2.2 Documentation & PR:\n\nMinimal documentation for users and also about how the code works (for myself & future Devs) (Code comments, unit test cases above function, etc)\n\nPR/Marketing (Write Medium/dev.to/LinkedIn Article, Answering SO, Quora etc, 4P's-Price, Product, Place, Promotion, Market Targeting/Segmentation message with differentiation & positioning) (Refer similar software to make marketing message), use good GFX(pixabay)\n\n3. Measurement:\n\nMeasure & document the estimated time vs actual time taken for subtask, to help in future estimation using my historical values (by seeing time taken previous for similar subtask) and also for retrospective to make things better\n\nGoogle Timer to measure task and then use Google stopwatch to measure extra time taken (This helps in future estimation by comparing estimated time vs actual time)\n\n4. Retrospective:\n\nHappens at end of sprint, involves looking back at how the sprint went\n\nwhat things I can use? where I can make things better?\n\nSee why I am taking more time than estimated time for different task etc\n\nTry Sheets/Excel Charts to analyse my historical data(ZenHub provides great reports)\n\nPlot estimation vs actual time for task on a graph to see your personal time estimate accuracy trend\n\nLearn from mistakes (Unnecessarily complex solutions, being perfectionist, using unstable libraries effects quality/stability)\n\nLearn from customer question/feedback? Why is customer/user asking/saying that, is there a lacking doc/feature\n\nRules:\n\nTime/Deadline & quality (no compromise)\n\nScope (features etc, high impact features first), cost (overtime, etc)\n\nShorter Sprint (1-2 weeks) release product\n\nThings to Remember:\n\nEliminate waste (partial work, multitasking, task switching, bugs, extra features, relearning, unnecessarily complex solution, unnecessary stress, building wrong feature, rework)\n\nImplement new learnings\n\nDecide as late as possible (so that to know more about problem and not waste time on things that's not required)\n\nDeliver ASAP\n\nDuring major blocking issue during operations use stop the line technique -&gt; stop everything (Give importance/resources to issue), assess the issue, and resolve the issue, and learn how to prevent it\n\nDon't beg for help, learn & do things yourself\n\nIf stuck somewhere, then google search in Stack Overflow (& its sister sites) and GitHub issue\n\nIf stuck, Explain the problem out loud to someone (I prefer God)\n\nConsider asking question at Stack Overflow as last resort (Not advisable)\n\ncommits on one main branch to avoid merge hell (don't keep multiple feature branch)\n\nWhen a bug is found, tests are created before the bug is addressed (a bug is not an error in logic; it is a test that was not written)\n\nembrace change (new features etc)\n\nDuring sprint you might have personal ideas (Urge to Google search something), project related ideas (new features), just write those into personal notes/to-do list to refer it back in personal time. This will reduce stress and help us to be focused (GTD Method)\n\nAutomated testing (unit etc), CI/CD is great for software which have to be maintained for long time/always and not for small GitHub hobby projects which are onetime thing\n\nHigh cohesion in function (only does one simple task) and low coupling (low dependency on other function)\n\nTake longer break(30-60mins) when no longer productive/frustrated, if doesn't work, then do the work next day\n\nBatch Check everything one time daily (emails, messages, SMS, calls, news, sites etc) (Don't check again & again) and mark imp emails to reply at end of work time\n\nHeadphones (inc conc.mp3) to avoid distraction\n\nProductivity Tools:\n\nG Suite (Calendar, sheets etc), code time (Time tracker metrics)\n\nAsana (Kanban boards)\n\nProwritingaid, Hemingwayapp (Documentation/Marketing message simplification)\n\nGitHub Projects with ZenHub (Agile Project Management)\n\nGitHub Actions (CI/CD)\n\nDeepCode(code review), StandardJS(Consistent code style)\n\nWhy Solo is Great:\n\nBe humble & happy & be thankful to God for being solo developer, as you are saved from Ideocracies of a team\n\nNo Difference of opinion\n\nNo rework due to communication gap\n\nNo need to show off work to someone\n\nNo status updates\n\nNo conflicts\n\nNo junk office timings\n\nNo begging for your rights (leaves etc)\n\nNo need to lie\n\nNo need to bow to someone\n\nNo need to compete\n\nNo rules you make the rules,\n\nNo waste time travelling\n\nGreat work/life balance being solo\n\nYour God is your boss\n\nDaily Routine:\n\nProphet Muhammad (May God's Peace be on him) has been guiding example for this daily routine.\n\nBecause God says:\n\nIndeed, in the Messenger of God you have an excellent example ... - Quran 33:21\n\nDivide your daily routine into three different parts\n\nWork Time\n\nPersonal Time\n\nFamily/Social Time\n\nYou should give equal importance to each. Some people work whole day without giving time to themselves or their family/Other people. Use this manifesto or Note-Taking app (Google keep-TODO List) or Kanban boards (Asana) to manage personal & Social Time\n\nWork Time:\n\nThis is the time you work\n\n8-9 Hours/Daily\n\nPrefer working after waking up\n\n1-day rest after every iteration/sprint/release\n\nTake 15-30min nap 6-7 hrs after waking up (Increases Productivity)\n\nHave ergonomics Computer chair & table and take 20sec break every 15mins (Use strechly, stand up and move during break & stretch your body) (Prevents Computer related injuries)\n\nPersonal Time:\n\nThis is the time you give to yourself, for example looking your health, clothes, hygiene, ID renewal etc (For example torn shoes, repair it or get it repaired from cobbler or buy new one)\n\nExercise weekly twice (e.g.: Rope skipping 10mins for healthy heart)(Sat,Tue Fixed Date)\n\nBe physically active by performing household chores\n\nStart working on tasks in here after work time\n\nFamily/Social Time:\n\nThis is the time you give to your family and other people, such as bringing grocery for family, giving time to wife, parents etc, taking family member to doctor when they are sick, helping in household chores etc\n\nStart working on tasks in here after work time\n\nManifesto Implementation:\n\nThe Free Currency Exchange API was made by following this manifesto by a single developer in 2 days time\n\nRefer The Solo Developers Manifesto for updated manifesto"
    }
}