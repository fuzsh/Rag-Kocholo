{
    "id": "dbpedia_124_0",
    "rank": 39,
    "data": {
        "url": "https://pkg.go.dev/crypto/cipher",
        "read_more_link": "",
        "language": "en",
        "title": "cipher package",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://pkg.go.dev/static/shared/logo/go-white.svg",
            "https://pkg.go.dev/static/shared/icon/search_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/search_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/arrow_drop_down_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/arrow_drop_down_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/arrow_drop_down_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/launch_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/launch_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/logo/social/google-groups.svg",
            "https://pkg.go.dev/static/shared/logo/social/github.svg",
            "https://pkg.go.dev/static/shared/logo/social/twitter.svg",
            "https://pkg.go.dev/static/shared/logo/social/reddit.svg",
            "https://pkg.go.dev/static/shared/logo/social/slack.svg",
            "https://pkg.go.dev/static/shared/logo/social/stack-overflow.svg",
            "https://pkg.go.dev/static/shared/logo/go-blue.svg",
            "https://pkg.go.dev/static/shared/icon/navigate_next_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/navigate_before_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/navigate_next_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/navigate_before_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/navigate_next_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/navigate_before_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/launch_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/launch_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/logo/social/google-groups.svg",
            "https://pkg.go.dev/static/shared/logo/social/github.svg",
            "https://pkg.go.dev/static/shared/logo/social/twitter.svg",
            "https://pkg.go.dev/static/shared/logo/social/reddit.svg",
            "https://pkg.go.dev/static/shared/logo/social/slack.svg",
            "https://pkg.go.dev/static/shared/logo/social/stack-overflow.svg",
            "https://pkg.go.dev/static/shared/icon/content_copy_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/logo/go-blue.svg",
            "https://pkg.go.dev/static/shared/icon/content_copy_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/alert_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/check_circle_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/help_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/check_circle_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/help_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/check_circle_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/help_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/check_circle_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/help_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/security_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/code_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/insert_drive_file_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/gopher/pilot-bust-1431x901.svg",
            "https://pkg.go.dev/static/shared/icon/brightness_6_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/brightness_2_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/light_mode_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/keyboard_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/logo/google-white.svg",
            "https://pkg.go.dev/static/shared/icon/close_gm_grey_24dp.svg",
            "https://pkg.go.dev/static/shared/icon/close_gm_grey_24dp.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/shared/icon/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://pkg.go.dev/crypto/cipher",
        "text": "package main import ( \"crypto/aes\" \"crypto/cipher\" \"encoding/hex\" \"fmt\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // Seal/Open calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. // When decoded the key should be 16 bytes (AES-128) or 32 (AES-256). key, _ := hex.DecodeString(\"6368616e676520746869732070617373776f726420746f206120736563726574\") ciphertext, _ := hex.DecodeString(\"c3aaa29f002ca75870806e44086700f62ce4d43e902b3888e23ceff797a7a471\") nonce, _ := hex.DecodeString(\"64a9433eae7ccceee2fc0eda\") block, err := aes.NewCipher(key) if err != nil { panic(err.Error()) } aesgcm, err := cipher.NewGCM(block) if err != nil { panic(err.Error()) } plaintext, err := aesgcm.Open(nil, nonce, ciphertext, nil) if err != nil { panic(err.Error()) } fmt.Printf(\"%s\\n\", plaintext) }\n\nOutput: exampleplaintext\n\npackage main import ( \"crypto/aes\" \"crypto/cipher\" \"crypto/rand\" \"encoding/hex\" \"fmt\" \"io\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // Seal/Open calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. // When decoded the key should be 16 bytes (AES-128) or 32 (AES-256). key, _ := hex.DecodeString(\"6368616e676520746869732070617373776f726420746f206120736563726574\") plaintext := []byte(\"exampleplaintext\") block, err := aes.NewCipher(key) if err != nil { panic(err.Error()) } // Never use more than 2^32 random nonces with a given key because of the risk of a repeat. nonce := make([]byte, 12) if _, err := io.ReadFull(rand.Reader, nonce); err != nil { panic(err.Error()) } aesgcm, err := cipher.NewGCM(block) if err != nil { panic(err.Error()) } ciphertext := aesgcm.Seal(nil, nonce, plaintext, nil) fmt.Printf(\"%x\\n\", ciphertext) }\n\nOutput:\n\npackage main import ( \"crypto/aes\" \"crypto/cipher\" \"encoding/hex\" \"fmt\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // NewCipher calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. key, _ := hex.DecodeString(\"6368616e676520746869732070617373\") ciphertext, _ := hex.DecodeString(\"73c86d43a9d700a253a96c85b0f6b03ac9792e0e757f869cca306bd3cba1c62b\") block, err := aes.NewCipher(key) if err != nil { panic(err) } // The IV needs to be unique, but not secure. Therefore it's common to // include it at the beginning of the ciphertext. if len(ciphertext) < aes.BlockSize { panic(\"ciphertext too short\") } iv := ciphertext[:aes.BlockSize] ciphertext = ciphertext[aes.BlockSize:] // CBC mode always works in whole blocks. if len(ciphertext)%aes.BlockSize != 0 { panic(\"ciphertext is not a multiple of the block size\") } mode := cipher.NewCBCDecrypter(block, iv) // CryptBlocks can work in-place if the two arguments are the same. mode.CryptBlocks(ciphertext, ciphertext) // If the original plaintext lengths are not a multiple of the block // size, padding would have to be added when encrypting, which would be // removed at this point. For an example, see // https://tools.ietf.org/html/rfc5246#section-6.2.3.2. However, it's // critical to note that ciphertexts must be authenticated (i.e. by // using crypto/hmac) before being decrypted in order to avoid creating // a padding oracle. fmt.Printf(\"%s\\n\", ciphertext) }\n\nOutput: exampleplaintext\n\npackage main import ( \"crypto/aes\" \"crypto/cipher\" \"crypto/rand\" \"encoding/hex\" \"fmt\" \"io\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // NewCipher calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. key, _ := hex.DecodeString(\"6368616e676520746869732070617373\") plaintext := []byte(\"exampleplaintext\") // CBC mode works on blocks so plaintexts may need to be padded to the // next whole block. For an example of such padding, see // https://tools.ietf.org/html/rfc5246#section-6.2.3.2. Here we'll // assume that the plaintext is already of the correct length. if len(plaintext)%aes.BlockSize != 0 { panic(\"plaintext is not a multiple of the block size\") } block, err := aes.NewCipher(key) if err != nil { panic(err) } // The IV needs to be unique, but not secure. Therefore it's common to // include it at the beginning of the ciphertext. ciphertext := make([]byte, aes.BlockSize+len(plaintext)) iv := ciphertext[:aes.BlockSize] if _, err := io.ReadFull(rand.Reader, iv); err != nil { panic(err) } mode := cipher.NewCBCEncrypter(block, iv) mode.CryptBlocks(ciphertext[aes.BlockSize:], plaintext) // It's important to remember that ciphertexts must be authenticated // (i.e. by using crypto/hmac) as well as being encrypted in order to // be secure. fmt.Printf(\"%x\\n\", ciphertext) }\n\nOutput:\n\npackage main import ( \"crypto/aes\" \"crypto/cipher\" \"encoding/hex\" \"fmt\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // NewCipher calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. key, _ := hex.DecodeString(\"6368616e676520746869732070617373\") ciphertext, _ := hex.DecodeString(\"7dd015f06bec7f1b8f6559dad89f4131da62261786845100056b353194ad\") block, err := aes.NewCipher(key) if err != nil { panic(err) } // The IV needs to be unique, but not secure. Therefore it's common to // include it at the beginning of the ciphertext. if len(ciphertext) < aes.BlockSize { panic(\"ciphertext too short\") } iv := ciphertext[:aes.BlockSize] ciphertext = ciphertext[aes.BlockSize:] stream := cipher.NewCFBDecrypter(block, iv) // XORKeyStream can work in-place if the two arguments are the same. stream.XORKeyStream(ciphertext, ciphertext) fmt.Printf(\"%s\", ciphertext) }\n\nOutput: some plaintext\n\npackage main import ( \"crypto/aes\" \"crypto/cipher\" \"crypto/rand\" \"encoding/hex\" \"fmt\" \"io\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // NewCipher calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. key, _ := hex.DecodeString(\"6368616e676520746869732070617373\") plaintext := []byte(\"some plaintext\") block, err := aes.NewCipher(key) if err != nil { panic(err) } // The IV needs to be unique, but not secure. Therefore it's common to // include it at the beginning of the ciphertext. ciphertext := make([]byte, aes.BlockSize+len(plaintext)) iv := ciphertext[:aes.BlockSize] if _, err := io.ReadFull(rand.Reader, iv); err != nil { panic(err) } stream := cipher.NewCFBEncrypter(block, iv) stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext) // It's important to remember that ciphertexts must be authenticated // (i.e. by using crypto/hmac) as well as being encrypted in order to // be secure. fmt.Printf(\"%x\\n\", ciphertext) }\n\nOutput:\n\npackage main import ( \"crypto/aes\" \"crypto/cipher\" \"crypto/rand\" \"encoding/hex\" \"fmt\" \"io\" ) func main() { // Load your secret key from a safe place and reuse it across multiple // NewCipher calls. (Obviously don't use this example key for anything // real.) If you want to convert a passphrase to a key, use a suitable // package like bcrypt or scrypt. key, _ := hex.DecodeString(\"6368616e676520746869732070617373\") plaintext := []byte(\"some plaintext\") block, err := aes.NewCipher(key) if err != nil { panic(err) } // The IV needs to be unique, but not secure. Therefore it's common to // include it at the beginning of the ciphertext. ciphertext := make([]byte, aes.BlockSize+len(plaintext)) iv := ciphertext[:aes.BlockSize] if _, err := io.ReadFull(rand.Reader, iv); err != nil { panic(err) } stream := cipher.NewCTR(block, iv) stream.XORKeyStream(ciphertext[aes.BlockSize:], plaintext) // It's important to remember that ciphertexts must be authenticated // (i.e. by using crypto/hmac) as well as being encrypted in order to // be secure. // CTR mode is the same for both encryption and decryption, so we can // also decrypt that ciphertext with NewCTR. plaintext2 := make([]byte, len(plaintext)) stream = cipher.NewCTR(block, iv) stream.XORKeyStream(plaintext2, ciphertext[aes.BlockSize:]) fmt.Printf(\"%s\\n\", plaintext2) }\n\nOutput: some plaintext"
    }
}