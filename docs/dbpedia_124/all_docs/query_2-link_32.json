{
    "id": "dbpedia_124_2",
    "rank": 32,
    "data": {
        "url": "https://learn.microsoft.com/en-us/aspnet/core/blazor/components/%3Fview%3Daspnetcore-8.0",
        "read_more_link": "",
        "language": "en",
        "title": "ASP.NET Core Razor components",
        "top_image": "https://learn.microsoft.com/dotnet/media/dotnet-logo.png",
        "meta_img": "https://learn.microsoft.com/dotnet/media/dotnet-logo.png",
        "images": [
            "https://learn.microsoft.com/media/logos/logo_net.svg",
            "https://learn.microsoft.com/media/logos/logo_net.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-07-19T08:00:00+00:00",
        "summary": "",
        "meta_description": "Learn how to create and use Razor components in Blazor apps, including guidance on Razor syntax, component naming, namespaces, and component parameters.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://learn.microsoft.com/en-us/aspnet/core/blazor/components/?view=aspnetcore-8.0",
        "text": "This article explains how to create and use Razor components in Blazor apps, including guidance on Razor syntax, component naming, namespaces, and component parameters.\n\nRazor components\n\nBlazor apps are built using Razor components, informally known as Blazor components or only components. A component is a self-contained portion of user interface (UI) with processing logic to enable dynamic behavior. Components can be nested, reused, shared among projects, and used in MVC and Razor Pages apps.\n\nComponents render into an in-memory representation of the browser's Document Object Model (DOM) called a render tree, which is used to update the UI in a flexible and efficient way.\n\nAlthough \"Razor components\" shares some naming with other ASP.NET Core content-rendering technologies, Razor components must be distinguished from the following different features in ASP.NET Core:\n\nRazor views, which are Razor-based markup pages for MVC apps.\n\nView components, which are for rendering chunks of content rather than whole responses in Razor Pages and MVC apps.\n\nComponent classes\n\nComponents are implemented using a combination of C# and HTML markup in Razor component files with the .razor file extension.\n\nBy default, ComponentBase is the base class for components described by Razor component files. ComponentBase implements the lowest abstraction of components, the IComponent interface. ComponentBase defines component properties and methods for basic functionality, for example, to process a set of built-in component lifecycle events.\n\nComponentBase in dotnet/aspnetcore reference source: The reference source contains additional remarks on the built-in lifecycle events. However, keep in mind that the internal implementations of component features are subject to change at any time without notice.\n\nNote\n\nDocumentation links to .NET reference source usually load the repository's default branch, which represents the current development for the next release of .NET. To select a tag for a specific release, use the Switch branches or tags dropdown list. For more information, see How to select a version tag of ASP.NET Core source code (dotnet/AspNetCore.Docs #26205).\n\nDevelopers typically create Razor components from Razor component files (.razor) or base their components on ComponentBase, but components can also be built by implementing IComponent. Developer-built components that implement IComponent can take low-level control over rendering at the cost of having to manually trigger rendering with events and lifecycle methods that the developer must create and maintain.\n\nRazor syntax\n\nComponents use Razor syntax. Two Razor features are extensively used by components, directives and directive attributes. These are reserved keywords prefixed with @ that appear in Razor markup:\n\nDirectives: Change the way component markup is compiled or functions. For example, the @page directive specifies a routable component with a route template that can be reached directly by a user's request in the browser at a specific URL.\n\nBy convention, a component's directives at the top of a component definition (.razor file) are placed in a consistent order. For repeated directives, directives are placed alphabetically by namespace or type, except @using directives, which have special second-level ordering.\n\nThe following order is adopted by Blazor sample apps and documentation. Components provided by a Blazor project template may differ from the following order and use a different format. For example, Blazor framework Identity components include blank lines between blocks of @using directives and blocks of @inject directives. You're free to use a custom ordering scheme and format in your own apps.\n\nDocumentation and sample app Razor directive order:\n\n@page\n\n@rendermode (.NET 8 or later)\n\n@using\n\nSystem namespaces (alphabetical order)\n\nMicrosoft namespaces (alphabetical order)\n\nThird-party API namespaces (alphabetical order)\n\nApp namespaces (alphabetical order)\n\nOther directives (alphabetical order)\n\nNo blank lines appear among the directives. One blank line appears between the directives and the first line of Razor markup.\n\nExample:\n\n@page \"/doctor-who-episodes/{season:int}\" @rendermode InteractiveWebAssembly @using System.Globalization @using System.Text.Json @using Microsoft.AspNetCore.Localization @using Mandrill @using BlazorSample.Components.Layout @attribute [Authorize] @implements IAsyncDisposable @inject IJSRuntime JS @inject ILogger<DoctorWhoEpisodes> Logger <PageTitle>Doctor Who Episode List</PageTitle> ...\n\nDirective attributes: Change the way a component element is compiled or functions.\n\nExample:\n\n<input @bind=\"episodeId\" />\n\nYou can prefix directive attribute values with the at symbol (@) for non-explicit Razor expressions (@bind=\"@episodeId\"), but we don't recommend it, and the docs don't adopt the approach in examples.\n\nDirectives and directive attributes used in components are explained further in this article and other articles of the Blazor documentation set. For general information on Razor syntax, see Razor syntax reference for ASP.NET Core.\n\nComponent name, class name, and namespace\n\nPartial class support\n\nComponents are generated as C# partial classes and are authored using either of the following approaches:\n\nA single file contains C# code defined in one or more @code blocks, HTML markup, and Razor markup. Blazor project templates define their components using this single-file approach.\n\nHTML and Razor markup are placed in a Razor file (.razor). C# code is placed in a code-behind file defined as a partial class (.cs).\n\nThe following example shows the default Counter component with an @code block in an app generated from a Blazor project template. Markup and C# code are in the same file. This is the most common approach taken in component authoring.\n\nCounter.razor:\n\n@page \"/counter\" <PageTitle>Counter</PageTitle> <h1>Counter</h1> <p role=\"status\">Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\n@page \"/counter\" <PageTitle>Counter</PageTitle> <h1>Counter</h1> <p role=\"status\">Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\n@page \"/counter\" <PageTitle>Counter</PageTitle> <h1>Counter</h1> <p role=\"status\">Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\n@page \"/counter\" <h1>Counter</h1> <p>Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\n@page \"/counter\" <h1>Counter</h1> <p>Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button> @code { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\nThe following Counter component splits presentation HTML and Razor markup from the C# code using a code-behind file with a partial class. Splitting the markup from the C# code is favored by some organizations and developers to organize their component code to suit how they prefer to work. For example, the organization's UI expert can work on the presentation layer independently of another developer working on the component's C# logic. The approach is also useful when working with automatically-generated code or source generators. For more information, see Partial Classes and Methods (C# Programming Guide).\n\nCounterPartialClass.razor:\n\n@page \"/counter-partial-class\" <PageTitle>Counter</PageTitle> <h1>Counter</h1> <p role=\"status\">Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button>\n\n@page \"/counter-partial-class\" <PageTitle>Counter</PageTitle> <h1>Counter</h1> <p role=\"status\">Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button>\n\n@page \"/counter-partial-class\" <PageTitle>Counter</PageTitle> <h1>Counter</h1> <p role=\"status\">Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button>\n\n@page \"/counter-partial-class\" <h1>Counter</h1> <p>Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button>\n\n@page \"/counter-partial-class\" <h1>Counter</h1> <p>Current count: @currentCount</p> <button class=\"btn btn-primary\" @onclick=\"IncrementCount\">Click me</button>\n\nCounterPartialClass.razor.cs:\n\nnamespace BlazorSample.Components.Pages; public partial class CounterPartialClass { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\nnamespace BlazorSample.Pages; public partial class CounterPartialClass { private int currentCount = 0; private void IncrementCount() { currentCount++; } }\n\nnamespace BlazorSample.Pages { public partial class CounterPartialClass { private int currentCount = 0; private void IncrementCount() { currentCount++; } } }\n\n@using directives in the _Imports.razor file are only applied to Razor files (.razor), not C# files (.cs). Add namespaces to a partial class file as needed.\n\nTypical namespaces used by components:\n\nusing System.Net.Http; using System.Net.Http.Json; using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Components.Authorization; using Microsoft.AspNetCore.Components.Forms; using Microsoft.AspNetCore.Components.Routing; using Microsoft.AspNetCore.Components.Sections using Microsoft.AspNetCore.Components.Web; using static Microsoft.AspNetCore.Components.Web.RenderMode; using Microsoft.AspNetCore.Components.Web.Virtualization; using Microsoft.JSInterop;\n\nTypical namespaces also include the namespace of the app and the namespace corresponding to the app's Components folder:\n\nusing BlazorSample; using BlazorSample.Components;\n\nAdditional folders can also be included, such as the Layout folder:\n\nusing BlazorSample.Components.Layout;\n\nusing System.Net.Http; using System.Net.Http.Json; using Microsoft.AspNetCore.Authorization; using Microsoft.AspNetCore.Components.Authorization; using Microsoft.AspNetCore.Components.Forms; using Microsoft.AspNetCore.Components.Routing; using Microsoft.AspNetCore.Components.Web; using Microsoft.AspNetCore.Components.Web.Virtualization; using Microsoft.JSInterop;\n\nTypical namespaces also include the namespace of the app and the namespace corresponding to the app's Shared folder:\n\nusing BlazorSample; using BlazorSample.Shared;\n\nusing System.Net.Http; using Microsoft.AspNetCore.Components.Forms; using Microsoft.AspNetCore.Components.Routing; using Microsoft.AspNetCore.Components.Web; using Microsoft.JSInterop;\n\nTypical namespaces also include the namespace of the app and the namespace corresponding to the app's Shared folder:\n\nusing BlazorSample; using BlazorSample.Shared;\n\nSpecify a base class\n\nThe @inherits directive is used to specify a base class for a component. Unlike using partial classes, which only split markup from C# logic, using a base class allows you to inherit C# code for use across a group of components that share the base class's properties and methods. Using base classes reduce code redundancy in apps and are useful when supplying base code from class libraries to multiple apps. For more information, see Inheritance in C# and .NET.\n\nIn the following example, the BlazorRocksBase1 base class derives from ComponentBase.\n\nBlazorRocks1.razor:\n\n@page \"/blazor-rocks-1\" @inherits BlazorRocksBase1 <PageTitle>Blazor Rocks!</PageTitle> <h1>Blazor Rocks! Example 1</h1> <p> @BlazorRocksText </p>\n\n@page \"/blazor-rocks-1\" @inherits BlazorRocksBase1 <PageTitle>Blazor Rocks!</PageTitle> <h1>Blazor Rocks! Example 1</h1> <p> @BlazorRocksText </p>\n\n@page \"/blazor-rocks-1\" @inherits BlazorRocksBase1 <PageTitle>Blazor Rocks!</PageTitle> <h1>Blazor Rocks! Example 1</h1> <p> @BlazorRocksText </p>\n\n@page \"/blazor-rocks-1\" @inherits BlazorRocksBase1 <h1>Blazor Rocks! Example 1</h1> <p> @BlazorRocksText </p>\n\n@page \"/blazor-rocks-1\" @inherits BlazorRocksBase1 <h1>Blazor Rocks! Example 1</h1> <p> @BlazorRocksText </p>\n\nBlazorRocksBase1.cs:\n\nusing Microsoft.AspNetCore.Components; namespace BlazorSample; public class BlazorRocksBase1 : ComponentBase { public string BlazorRocksText { get; set; } = \"Blazor rocks the browser!\"; }\n\nusing Microsoft.AspNetCore.Components; namespace BlazorSample; public class BlazorRocksBase1 : ComponentBase { public string BlazorRocksText { get; set; } = \"Blazor rocks the browser!\"; }\n\nusing Microsoft.AspNetCore.Components; namespace BlazorSample; public class BlazorRocksBase1 : ComponentBase { public string BlazorRocksText { get; set; } = \"Blazor rocks the browser!\"; }\n\nusing Microsoft.AspNetCore.Components; namespace BlazorSample; public class BlazorRocksBase1 : ComponentBase { public string BlazorRocksText { get; set; } = \"Blazor rocks the browser!\"; }\n\nusing Microsoft.AspNetCore.Components; namespace BlazorSample; public class BlazorRocksBase1 : ComponentBase { public string BlazorRocksText { get; set; } = \"Blazor rocks the browser!\"; }\n\nRouting\n\nRouting in Blazor is achieved by providing a route template to each accessible component in the app with an @page directive. When a Razor file with an @page directive is compiled, the generated class is given a RouteAttribute specifying the route template. At runtime, the router searches for component classes with a RouteAttribute and renders whichever component has a route template that matches the requested URL.\n\nThe following HelloWorld component uses a route template of /hello-world, and the rendered webpage for the component is reached at the relative URL /hello-world.\n\nHelloWorld.razor:\n\n@page \"/hello-world\" <PageTitle>Hello World!</PageTitle> <h1>Hello World!</h1>\n\n@page \"/hello-world\" <h1>Hello World!</h1>\n\n@page \"/hello-world\" <h1>Hello World!</h1>\n\n@page \"/hello-world\" <h1>Hello World!</h1>\n\n@page \"/hello-world\" <h1>Hello World!</h1>\n\nThe preceding component loads in the browser at /hello-world regardless of whether or not you add the component to the app's UI navigation. Optionally, components can be added to the NavMenu component so that a link to the component appears in the app's UI-based navigation.\n\nFor the preceding HelloWorld component, you can add a NavLink component to the NavMenu component. For more information, including descriptions of the NavLink and NavMenu components, see ASP.NET Core Blazor routing and navigation.\n\nMarkup\n\nA component's UI is defined using Razor syntax, which consists of Razor markup, C#, and HTML. When an app is compiled, the HTML markup and C# rendering logic are converted into a component class. The name of the generated class matches the name of the file.\n\nMembers of the component class are defined in one or more @code blocks. In @code blocks, component state is specified and processed with C#:\n\nProperty and field initializers.\n\nParameter values from arguments passed by parent components and route parameters.\n\nMethods for user event handling, lifecycle events, and custom component logic.\n\nComponent members are used in rendering logic using C# expressions that start with the @ symbol. For example, a C# field is rendered by prefixing @ to the field name. The following Markup component evaluates and renders:\n\nheadingFontStyle for the CSS property value font-style of the heading element.\n\nheadingText for the content of the heading element.\n\nMarkup.razor:\n\n@page \"/markup\" <PageTitle>Markup</PageTitle> <h1>Markup Example</h1> <h2 style=\"font-style:@headingFontStyle\">@headingText</h2> @code { private string headingFontStyle = \"italic\"; private string headingText = \"Put on your new Blazor!\"; }\n\n@page \"/markup\" <h1 style=\"font-style:@headingFontStyle\">@headingText</h1> @code { private string headingFontStyle = \"italic\"; private string headingText = \"Put on your new Blazor!\"; }\n\n@page \"/markup\" <h1 style=\"font-style:@headingFontStyle\">@headingText</h1> @code { private string headingFontStyle = \"italic\"; private string headingText = \"Put on your new Blazor!\"; }\n\n@page \"/markup\" <h1 style=\"font-style:@headingFontStyle\">@headingText</h1> @code { private string headingFontStyle = \"italic\"; private string headingText = \"Put on your new Blazor!\"; }\n\n@page \"/markup\" <h1 style=\"font-style:@headingFontStyle\">@headingText</h1> @code { private string headingFontStyle = \"italic\"; private string headingText = \"Put on your new Blazor!\"; }\n\nThe Blazor framework processes a component internally as a render tree, which is the combination of a component's DOM and Cascading Style Sheet Object Model (CSSOM). After the component is initially rendered, the component's render tree is regenerated in response to events. Blazor compares the new render tree against the previous render tree and applies any modifications to the browser's DOM for display. For more information, see ASP.NET Core Razor component rendering.\n\nRazor syntax for C# control structures, directives, and directive attributes are lowercase (examples: @if, @code, @bind). Property names are uppercase (example: @Body for LayoutComponentBase.Body).\n\nAsynchronous methods (async) don't support returning void\n\nThe Blazor framework doesn't track void-returning asynchronous methods (async). As a result, exceptions aren't caught if void is returned. Always return a Task from asynchronous methods.\n\nNested components\n\nComponents can include other components by declaring them using HTML syntax. The markup for using a component looks like an HTML tag where the name of the tag is the component type.\n\nConsider the following Heading component, which can be used by other components to display a heading.\n\nHeading.razor:\n\n<h1 style=\"font-style:@headingFontStyle\">Heading Example</h1> @code { private string headingFontStyle = \"italic\"; }\n\n<h1 style=\"font-style:@headingFontStyle\">Heading Example</h1> @code { private string headingFontStyle = \"italic\"; }\n\n<h1 style=\"font-style:@headingFontStyle\">Heading Example</h1> @code { private string headingFontStyle = \"italic\"; }\n\n<h1 style=\"font-style:@headingFontStyle\">Heading Example</h1> @code { private string headingFontStyle = \"italic\"; }\n\n<h1 style=\"font-style:@headingFontStyle\">Heading Example</h1> @code { private string headingFontStyle = \"italic\"; }\n\nThe following markup in the HeadingExample component renders the preceding Heading component at the location where the <Heading /> tag appears.\n\nHeadingExample.razor:\n\n@page \"/heading-example\" <PageTitle>Heading</PageTitle> <h1>Heading Example</h1> <Heading />\n\n@page \"/heading-example\" <Heading />\n\n@page \"/heading-example\" <Heading />\n\n@page \"/heading-example\" <Heading />\n\n@page \"/heading-example\" <Heading />\n\nIf a component contains an HTML element with an uppercase first letter that doesn't match a component name within the same namespace, a warning is emitted indicating that the element has an unexpected name. Adding an @using directive for the component's namespace makes the component available, which resolves the warning. For more information, see the Component name, class name, and namespace section.\n\nThe Heading component example shown in this section doesn't have an @page directive, so the Heading component isn't directly accessible to a user via a direct request in the browser. However, any component with an @page directive can be nested in another component. If the Heading component was directly accessible by including @page \"/heading\" at the top of its Razor file, then the component would be rendered for browser requests at both /heading and /heading-example.\n\nComponent parameters\n\nComponent parameters pass data to components and are defined using public C# properties on the component class with the [Parameter] attribute. In the following example, a built-in reference type (System.String) and a user-defined reference type (PanelBody) are passed as component parameters.\n\nPanelBody.cs:\n\nnamespace BlazorSample; public class PanelBody { public string? Text { get; set; } public string? Style { get; set; } }\n\npublic class PanelBody { public string? Text { get; set; } public string? Style { get; set; } }\n\npublic class PanelBody { public string? Text { get; set; } public string? Style { get; set; } }\n\npublic class PanelBody { public string Text { get; set; } public string Style { get; set; } }\n\npublic class PanelBody { public string Text { get; set; } public string Style { get; set; } }\n\nParameterChild.razor:\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">@Title</div> <div class=\"card-body\" style=\"font-style:@Body.Style\"> @Body.Text </div> </div> @code { [Parameter] public string Title { get; set; } = \"Set By Child\"; [Parameter] public PanelBody Body { get; set; } = new() { Text = \"Card content set by child.\", Style = \"normal\" }; }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">@Title</div> <div class=\"card-body\" style=\"font-style:@Body.Style\"> @Body.Text </div> </div> @code { [Parameter] public string Title { get; set; } = \"Set By Child\"; [Parameter] public PanelBody Body { get; set; } = new() { Text = \"Set by child.\", Style = \"normal\" }; }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">@Title</div> <div class=\"card-body\" style=\"font-style:@Body.Style\"> @Body.Text </div> </div> @code { [Parameter] public string Title { get; set; } = \"Set By Child\"; [Parameter] public PanelBody Body { get; set; } = new() { Text = \"Set by child.\", Style = \"normal\" }; }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">@Title</div> <div class=\"card-body\" style=\"font-style:@Body.Style\"> @Body.Text </div> </div> @code { [Parameter] public string Title { get; set; } = \"Set By Child\"; [Parameter] public PanelBody Body { get; set; } = new() { Text = \"Set by child.\", Style = \"normal\" }; }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">@Title</div> <div class=\"card-body\" style=\"font-style:@Body.Style\"> @Body.Text </div> </div> @code { [Parameter] public string Title { get; set; } = \"Set By Child\"; [Parameter] public PanelBody Body { get; set; } = new PanelBody() { Text = \"Set by child.\", Style = \"normal\" }; }\n\nWarning\n\nProviding initial values for component parameters is supported, but don't create a component that writes to its own parameters after the component is rendered for the first time. For more information, see Avoid overwriting parameters in ASP.NET Core Blazor.\n\nThe Title and Body component parameters of the ParameterChild component are set by arguments in the HTML tag that renders the instance of the component. The following ParameterParent component renders two ParameterChild components:\n\nThe first ParameterChild component is rendered without supplying parameter arguments.\n\nThe second ParameterChild component receives values for Title and Body from the ParameterParent component, which uses an explicit C# expression to set the values of the PanelBody's properties.\n\nParameter1.razor:\n\n@page \"/parameter-1\" <PageTitle>Parameter 1</PageTitle> <h1>Parameter Example 1</h1> <h1>Child component (without attribute values)</h1> <ParameterChild /> <h1>Child component (with attribute values)</h1> <ParameterChild Title=\"Set by Parent\" Body=\"@(new PanelBody() { Text = \"Set by parent.\", Style = \"italic\" })\" />\n\nParameterParent.razor:\n\n@page \"/parameter-parent\" <h1>Child component (without attribute values)</h1> <ParameterChild /> <h1>Child component (with attribute values)</h1> <ParameterChild Title=\"Set by Parent\" Body=\"@(new PanelBody() { Text = \"Set by parent.\", Style = \"italic\" })\" />\n\nParameterParent.razor:\n\n@page \"/parameter-parent\" <h1>Child component (without attribute values)</h1> <ParameterChild /> <h1>Child component (with attribute values)</h1> <ParameterChild Title=\"Set by Parent\" Body=\"@(new PanelBody() { Text = \"Set by parent.\", Style = \"italic\" })\" />\n\nParameterParent.razor:\n\n@page \"/parameter-parent\" <h1>Child component (without attribute values)</h1> <ParameterChild /> <h1>Child component (with attribute values)</h1> <ParameterChild Title=\"Set by Parent\" Body=\"@(new PanelBody() { Text = \"Set by parent.\", Style = \"italic\" })\" />\n\nParameterParent.razor:\n\n@page \"/parameter-parent\" <h1>Child component (without attribute values)</h1> <ParameterChild /> <h1>Child component (with attribute values)</h1> <ParameterChild Title=\"Set by Parent\" Body=\"@(new PanelBody() { Text = \"Set by parent.\", Style = \"italic\" })\" />\n\nThe following rendered HTML markup from the ParameterParent component shows ParameterChild component default values when the ParameterParent component doesn't supply component parameter values. When the ParameterParent component provides component parameter values, they replace the ParameterChild component's default values.\n\nNote\n\nFor clarity, rendered CSS style classes aren't shown in the following rendered HTML markup.\n\n<h1>Child component (without attribute values)</h1> <div> <div>Set By Child</div> <div>Set by child.</div> </div> <h1>Child component (with attribute values)</h1> <div> <div>Set by Parent</div> <div>Set by parent.</div> </div>\n\nAssign a C# field, property, or result of a method to a component parameter as an HTML attribute value. The value of the attribute can typically be any C# expression that matches the type of the parameter. The value of the attribute can optionally lead with a Razor reserved @ symbol, but it isn't required.\n\nIf the component parameter is of type string, then the attribute value is instead treated as a C# string literal by default. If you want to specify a C# expression instead, then use the @ prefix.\n\nThe following ParameterParent2 component displays four instances of the preceding ParameterChild component and sets their Title parameter values to:\n\nThe value of the title field.\n\nThe result of the GetTitle C# method.\n\nThe current local date in long format with ToLongDateString, which uses an implicit C# expression.\n\nThe panelData object's Title property.\n\nQuotes around parameter attribute values are optional in most cases per the HTML5 specification. For example, Value=this is supported, instead of Value=\"this\". However, we recommend using quotes because it's easier to remember and widely adopted across web-based technologies.\n\nThroughout the documentation, code examples:\n\nAlways use quotes. Example: Value=\"this\".\n\nDon't use the @ prefix with nonliterals unless required. Example: Count=\"ct\", where ct is a number-typed variable. Count=\"@ct\" is a valid stylistic approach, but the documentation and examples don't adopt the convention.\n\nAlways avoid @ for literals, outside of Razor expressions. Example: IsFixed=\"true\". This includes keywords (for example, this) and null, but you can choose to use them if you wish. For example, IsFixed=\"@true\" is uncommon but supported.\n\nParameter2.razor:\n\n@page \"/parameter-2\" <PageTitle>Parameter 2</PageTitle> <h1>Parameter Example 2</h1> <ParameterChild Title=\"@title\" /> <ParameterChild Title=\"@GetTitle()\" /> <ParameterChild Title=\"@DateTime.Now.ToLongDateString()\" /> <ParameterChild Title=\"@panelData.Title\" /> @code { private string title = \"From Parent field\"; private PanelData panelData = new(); private string GetTitle() { return \"From Parent method\"; } private class PanelData { public string Title { get; set; } = \"From Parent object\"; } }\n\nParameterParent2.razor:\n\n@page \"/parameter-parent-2\" <ParameterChild Title=\"@title\" /> <ParameterChild Title=\"@GetTitle()\" /> <ParameterChild Title=\"@DateTime.Now.ToLongDateString()\" /> <ParameterChild Title=\"@panelData.Title\" /> @code { private string title = \"From Parent field\"; private PanelData panelData = new(); private string GetTitle() { return \"From Parent method\"; } private class PanelData { public string Title { get; set; } = \"From Parent object\"; } }\n\nParameterParent2.razor:\n\n@page \"/parameter-parent-2\" <ParameterChild Title=\"@title\" /> <ParameterChild Title=\"@GetTitle()\" /> <ParameterChild Title=\"@DateTime.Now.ToLongDateString()\" /> <ParameterChild Title=\"@panelData.Title\" /> @code { private string title = \"From Parent field\"; private PanelData panelData = new(); private string GetTitle() { return \"From Parent method\"; } private class PanelData { public string Title { get; set; } = \"From Parent object\"; } }\n\nParameterParent2.razor:\n\n@page \"/parameter-parent-2\" <ParameterChild Title=\"@title\" /> <ParameterChild Title=\"@GetTitle()\" /> <ParameterChild Title=\"@DateTime.Now.ToLongDateString()\" /> <ParameterChild Title=\"@panelData.Title\" /> @code { private string title = \"From Parent field\"; private PanelData panelData = new PanelData(); private string GetTitle() { return \"From Parent method\"; } private class PanelData { public string Title { get; set; } = \"From Parent object\"; } }\n\nNote\n\nWhen assigning a C# member to a component parameter, don't prefix the parameter's HTML attribute with @.\n\nCorrect (Title is a string parameter, Count is a number-typed parameter):\n\n<ParameterChild Title=\"@title\" Count=\"ct\" />\n\n<ParameterChild Title=\"@title\" Count=\"@ct\" />\n\nIncorrect:\n\n<ParameterChild @Title=\"@title\" @Count=\"ct\" />\n\n<ParameterChild @Title=\"@title\" @Count=\"@ct\" />\n\nUnlike in Razor pages (.cshtml), Blazor can't perform asynchronous work in a Razor expression while rendering a component. This is because Blazor is designed for rendering interactive UIs. In an interactive UI, the screen must always display something, so it doesn't make sense to block the rendering flow. Instead, asynchronous work is performed during one of the asynchronous lifecycle events. After each asynchronous lifecycle event, the component may render again. The following Razor syntax is not supported:\n\n<ParameterChild Title=\"await ...\" /> <ParameterChild Title=\"@await ...\" />\n\nThe code in the preceding example generates a compiler error when the app is built:\n\nThe 'await' operator can only be used within an async method. Consider marking this method with the 'async' modifier and changing its return type to 'Task'.\n\nTo obtain a value for the Title parameter in the preceding example asynchronously, the component can use the OnInitializedAsync lifecycle event, as the following example demonstrates:\n\n<ParameterChild Title=\"@title\" /> @code { private string? title; protected override async Task OnInitializedAsync() { title = await ...; } }\n\nFor more information, see ASP.NET Core Razor component lifecycle.\n\nUse of an explicit Razor expression to concatenate text with an expression result for assignment to a parameter is not supported. The following example seeks to concatenate the text \"Set by \" with an object's property value. Although this syntax is supported in a Razor page (.cshtml), it isn't valid for assignment to the child's Title parameter in a component. The following Razor syntax is not supported:\n\n<ParameterChild Title=\"Set by @(panelData.Title)\" />\n\nThe code in the preceding example generates a compiler error when the app is built:\n\nComponent attributes do not support complex content (mixed C# and markup).\n\nTo support the assignment of a composed value, use a method, field, or property. The following example performs the concatenation of \"Set by \" and an object's property value in the C# method GetTitle:\n\nParameter3.razor:\n\n@page \"/parameter-3\" <PageTitle>Parameter 3</PageTitle> <h1>Parameter Example 3</h1> <ParameterChild Title=\"@GetTitle()\" /> @code { private PanelData panelData = new(); private string GetTitle() => $\"Set by {panelData.Title}\"; private class PanelData { public string Title { get; set; } = \"Parent\"; } }\n\nParameterParent3.razor:\n\n@page \"/parameter-parent-3\" <ParameterChild Title=\"@GetTitle()\" /> @code { private PanelData panelData = new(); private string GetTitle() => $\"Set by {panelData.Title}\"; private class PanelData { public string Title { get; set; } = \"Parent\"; } }\n\nParameterParent3.razor:\n\n@page \"/parameter-parent-3\" <ParameterChild Title=\"@GetTitle()\" /> @code { private PanelData panelData = new(); private string GetTitle() => $\"Set by {panelData.Title}\"; private class PanelData { public string Title { get; set; } = \"Parent\"; } }\n\nParameterParent3.razor:\n\n@page \"/parameter-parent-3\" <ParameterChild Title=\"@GetTitle()\" /> @code { private PanelData panelData = new(); private string GetTitle() => $\"Set by {panelData.Title}\"; private class PanelData { public string Title { get; set; } = \"Parent\"; } }\n\nParameterParent3.razor:\n\n@page \"/parameter-parent-3\" <ParameterChild Title=\"@GetTitle()\" /> @code { private PanelData panelData = new PanelData(); private string GetTitle() => $\"Set by {panelData.Title}\"; private class PanelData { public string Title { get; set; } = \"Parent\"; } }\n\nFor more information, see Razor syntax reference for ASP.NET Core.\n\nWarning\n\nProviding initial values for component parameters is supported, but don't create a component that writes to its own parameters after the component is rendered for the first time. For more information, see Avoid overwriting parameters in ASP.NET Core Blazor.\n\nComponent parameters should be declared as auto-properties, meaning that they shouldn't contain custom logic in their get or set accessors. For example, the following StartData property is an auto-property:\n\n[Parameter] public DateTime StartData { get; set; }\n\nDon't place custom logic in the get or set accessor because component parameters are purely intended for use as a channel for a parent component to flow information to a child component. If a set accessor of a child component property contains logic that causes rerendering of the parent component, an infinite rendering loop results.\n\nTo transform a received parameter value:\n\nLeave the parameter property as an auto-property to represent the supplied raw data.\n\nCreate a different property or method to supply the transformed data based on the parameter property.\n\nOverride OnParametersSetAsync to transform a received parameter each time new data is received.\n\nWriting an initial value to a component parameter is supported because initial value assignments don't interfere with the Blazor's automatic component rendering. The following assignment of the current local DateTime with DateTime.Now to StartData is valid syntax in a component:\n\n[Parameter] public DateTime StartData { get; set; } = DateTime.Now;\n\nAfter the initial assignment of DateTime.Now, do not assign a value to StartData in developer code. For more information, see Avoid overwriting parameters in ASP.NET Core Blazor.\n\nRoute parameters\n\nComponents can specify route parameters in the route template of the @page directive. The Blazor router uses route parameters to populate corresponding component parameters.\n\nRouteParameter1.razor:\n\n@page \"/route-parameter-1/{text}\" <PageTitle>Route Parameter 1</PageTitle> <h1>Route Parameter Example 1</h1> <p>Blazor is @Text!</p> @code { [Parameter] public string? Text { get; set; } }\n\n@page \"/route-parameter-1/{text}\" <h1>Blazor is @Text!</h1> @code { [Parameter] public string? Text { get; set; } }\n\n@page \"/route-parameter-1/{text}\" <h1>Blazor is @Text!</h1> @code { [Parameter] public string? Text { get; set; } }\n\n@page \"/route-parameter-1/{text}\" <h1>Blazor is @Text!</h1> @code { [Parameter] public string Text { get; set; } }\n\n@page \"/route-parameter-1/{text}\" <h1>Blazor is @Text!</h1> @code { [Parameter] public string Text { get; set; } }\n\nFor more information, see the Route parameters section of ASP.NET Core Blazor routing and navigation. Optional route parameters are also supported and covered in the same section. For information on catch-all route parameters ({*pageRoute}), which capture paths across multiple folder boundaries, see the Catch-all route parameters section of ASP.NET Core Blazor routing and navigation.\n\nChild content render fragments\n\nComponents can set the content of another component. The assigning component provides the content between the child component's opening and closing tags.\n\nIn the following example, the RenderFragmentChild component has a ChildContent component parameter that represents a segment of the UI to render as a RenderFragment. The position of ChildContent in the component's Razor markup is where the content is rendered in the final HTML output.\n\nRenderFragmentChild.razor:\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">Child content</div> <div class=\"card-body\">@ChildContent</div> </div> @code { [Parameter] public RenderFragment? ChildContent { get; set; } }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">Child content</div> <div class=\"card-body\">@ChildContent</div> </div> @code { [Parameter] public RenderFragment? ChildContent { get; set; } }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">Child content</div> <div class=\"card-body\">@ChildContent</div> </div> @code { [Parameter] public RenderFragment? ChildContent { get; set; } }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">Child content</div> <div class=\"card-body\">@ChildContent</div> </div> @code { [Parameter] public RenderFragment ChildContent { get; set; } }\n\n<div class=\"card w-25\" style=\"margin-bottom:15px\"> <div class=\"card-header font-weight-bold\">Child content</div> <div class=\"card-body\">@ChildContent</div> </div> @code { [Parameter] public RenderFragment ChildContent { get; set; } }\n\nImportant\n\nThe property receiving the RenderFragment content must be named ChildContent by convention.\n\nEvent callbacks aren't supported for RenderFragment.\n\nThe following component provides content for rendering the RenderFragmentChild by placing the content inside the child component's opening and closing tags.\n\nRenderFragments.razor:\n\n@page \"/render-fragments\" <PageTitle>Render Fragments</PageTitle> <h1>Render Fragments Example</h1> <RenderFragmentChild> Content of the child component is supplied by the parent component. </RenderFragmentChild>\n\nRenderFragmentParent.razor:\n\n@page \"/render-fragment-parent\" <h1>Render child content</h1> <RenderFragmentChild> Content of the child component is supplied by the parent component. </RenderFragmentChild>\n\nRenderFragmentParent.razor:\n\n@page \"/render-fragment-parent\" <h1>Render child content</h1> <RenderFragmentChild> Content of the child component is supplied by the parent component. </RenderFragmentChild>\n\nRenderFragmentParent.razor:\n\n@page \"/render-fragment-parent\" <h1>Render child content</h1> <RenderFragmentChild> Content of the child component is supplied by the parent component. </RenderFragmentChild>\n\nRenderFragmentParent.razor:\n\n@page \"/render-fragment-parent\" <h1>Render child content</h1> <RenderFragmentChild> Content of the child component is supplied by the parent component. </RenderFragmentChild>\n\nDue to the way that Blazor renders child content, rendering components inside a for loop requires a local index variable if the incrementing loop variable is used in the RenderFragmentChild component's content. The following example can be added to the preceding parent component:\n\n<h1>Three children with an index variable</h1> @for (int c = 0; c < 3; c++) { var current = c; <RenderFragmentChild> Count: @current </RenderFragmentChild> }\n\nAlternatively, use a foreach loop with Enumerable.Range instead of a for loop. The following example can be added to the preceding parent component:\n\n<h1>Second example of three children with an index variable</h1> @foreach (var c in Enumerable.Range(0,3)) { <RenderFragmentChild> Count: @c </RenderFragmentChild> }\n\nRender fragments are used to render child content throughout Blazor apps and are described with examples in the following articles and article sections:\n\nBlazor layouts\n\nPass data across a component hierarchy\n\nTemplated components\n\nGlobal exception handling\n\nNote\n\nBlazor framework's built-in Razor components use the same ChildContent component parameter convention to set their content. You can see the components that set child content by searching for the component parameter property name ChildContent in the API documentation (filters API with the search term \"ChildContent\").\n\nRender fragments for reusable rendering logic\n\nYou can factor out child components purely as a way of reusing rendering logic. In any component's @code block, define a RenderFragment and render the fragment from any location as many times as needed:\n\n@RenderWelcomeInfo <p>Render the welcome info a second time:</p> @RenderWelcomeInfo @code { private RenderFragment RenderWelcomeInfo = @<p>Welcome to your new app!</p>; }\n\nFor more information, see Reuse rendering logic.\n\nCapture references to components\n\nComponent references provide a way to reference a component instance for issuing commands. To capture a component reference:\n\nAdd an @ref attribute to the child component.\n\nDefine a field with the same type as the child component.\n\nWhen the component is rendered, the field is populated with the component instance. You can then invoke .NET methods on the instance.\n\nConsider the following ReferenceChild component that logs a message when its ChildMethod is called.\n\nReferenceChild.razor:\n\n@inject ILogger<ReferenceChild> Logger @if (value > 0) { <p> <code>value</code>: @value </p> } @code { private int value; public void ChildMethod(int value) { Logger.LogInformation(\"Received {Value} in ChildMethod\", value); this.value = value; StateHasChanged(); } }\n\n@using Microsoft.Extensions.Logging @inject ILogger<ReferenceChild> Logger @code { public void ChildMethod(int value) { Logger.LogInformation(\"Received {Value} in ChildMethod\", value); } }\n\n@using Microsoft.Extensions.Logging @inject ILogger<ReferenceChild> Logger @code { public void ChildMethod(int value) { Logger.LogInformation(\"Received {Value} in ChildMethod\", value); } }\n\n@using Microsoft.Extensions.Logging @inject ILogger<ReferenceChild> Logger @code { public void ChildMethod(int value) { Logger.LogInformation(\"Received {Value} in ChildMethod\", value); } }\n\n@using Microsoft.Extensions.Logging @inject ILogger<ReferenceChild> Logger @code { public void ChildMethod(int value) { Logger.LogInformation(\"Received {Value} in ChildMethod\", value); } }\n\nA component reference is only populated after the component is rendered and its output includes ReferenceChild's element. Until the component is rendered, there's nothing to reference. Don't attempt to call a referenced component method to an event handler directly (for example, @onclick=\"childComponent!.ChildMethod(5)\") because the reference variable may not be assigned at the time the click event is assigned.\n\nTo manipulate component references after the component has finished rendering, use the OnAfterRender or OnAfterRenderAsync methods.\n\nThe following example uses the preceding ReferenceChild component.\n\nReferenceParent.razor:\n\n@page \"/reference-parent\" <div> <button @onclick=\"@(() => childComponent1!.ChildMethod(5))\"> Call <code>ReferenceChild.ChildMethod</code> (first instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent1\" /> </div> <div> <button @onclick=\"CallChildMethod\"> Call <code>ReferenceChild.ChildMethod</code> (second instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent2\" /> </div> @code { private ReferenceChild? childComponent1; private ReferenceChild? childComponent2; private void CallChildMethod() { childComponent2!.ChildMethod(5); } }\n\n@page \"/reference-parent\" <div> <button @onclick=\"@(() => childComponent1!.ChildMethod(5))\"> Call <code>ReferenceChild.ChildMethod</code> (first instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent1\" /> </div> <div> <button @onclick=\"CallChildMethod\"> Call <code>ReferenceChild.ChildMethod</code> (second instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent2\" /> </div> @code { private ReferenceChild? childComponent1; private ReferenceChild? childComponent2; private void CallChildMethod() { childComponent2!.ChildMethod(5); } }\n\n@page \"/reference-parent\" <div> <button @onclick=\"@(() => childComponent1!.ChildMethod(5))\"> Call <code>ReferenceChild.ChildMethod</code> (first instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent1\" /> </div> <div> <button @onclick=\"CallChildMethod\"> Call <code>ReferenceChild.ChildMethod</code> (second instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent2\" /> </div> @code { private ReferenceChild? childComponent1; private ReferenceChild? childComponent2; private void CallChildMethod() { childComponent2!.ChildMethod(5); } }\n\n@page \"/reference-parent\" <div> <button @onclick=\"@(() => childComponent1!.ChildMethod(5))\"> Call <code>ReferenceChild.ChildMethod</code> (first instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent1\" /> </div> <div> <button @onclick=\"CallChildMethod\"> Call <code>ReferenceChild.ChildMethod</code> (second instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent2\" /> </div> @code { private ReferenceChild childComponent1; private ReferenceChild childComponent2; private void CallChildMethod() { childComponent2!.ChildMethod(5); } }\n\n@page \"/reference-parent\" <div> <button @onclick=\"@(() => childComponent1!.ChildMethod(5))\"> Call <code>ReferenceChild.ChildMethod</code> (first instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent1\" /> </div> <div> <button @onclick=\"CallChildMethod\"> Call <code>ReferenceChild.ChildMethod</code> (second instance) with an argument of 5 </button> <ReferenceChild @ref=\"childComponent2\" /> </div> @code { private ReferenceChild childComponent1; private ReferenceChild childComponent2; private void CallChildMethod() { childComponent2!.ChildMethod(5); } }\n\nWhile capturing component references use a similar syntax to capturing element references, capturing component references isn't a JavaScript interop feature. Component references aren't passed to JavaScript code. Component references are only used in .NET code.\n\nImportant\n\nDo not use component references to mutate the state of child components. Instead, use normal declarative component parameters to pass data to child components. Use of component parameters result in child components that rerender at the correct times automatically. For more information, see the component parameters section and the ASP.NET Core Blazor data binding article.\n\nApply an attribute\n\nAttributes can be applied to components with the @attribute directive. The following example applies the [Authorize] attribute to the component's class:\n\n@page \"/\" @attribute [Authorize]\n\nConditional HTML element attributes and DOM properties\n\nBlazor adopts the following general behaviors:\n\nFor HTML attributes, Blazor sets or removes the attribute conditionally based on the .NET value. If the .NET value is false or null, the attribute isn't set or is removed if it was previously set.\n\nFor DOM properties, such as checked or value, Blazor sets the DOM property based on the .NET value. If the .NET value is false or null, the DOM property is reset to a default value.\n\nWhich Razor syntax attributes correspond to HTML attributes and which ones correspond to DOM properties remains undocumented because it's an implementation detail that might change without notice.\n\nRaw HTML\n\nStrings are normally rendered using DOM text nodes, which means that any markup they may contain is ignored and treated as literal text. To render raw HTML, wrap the HTML content in a MarkupString value. The value is parsed as HTML or SVG and inserted into the DOM.\n\nWarning\n\nRendering raw HTML constructed from any untrusted source is a security risk and should always be avoided.\n\nThe following example shows using the MarkupString type to add a block of static HTML content to the rendered output of a component.\n\nMarkupStrings.razor:\n\n@page \"/markup-strings\" <PageTitle>Markup Strings</PageTitle> <h1>Markup Strings Example</h1> @((MarkupString)myMarkup) @code { private string myMarkup = \"<p class=\\\"text-danger\\\">This is a dangerous <em>markup string</em>.</p>\"; }\n\nMarkupStringExample.razor:\n\n@page \"/markup-string-example\" @((MarkupString)myMarkup) @code { private string myMarkup = \"<p class=\\\"text-danger\\\">This is a dangerous <em>markup string</em>.</p>\"; }\n\nMarkupStringExample.razor:\n\n@page \"/markup-string-example\" @((MarkupString)myMarkup) @code { private string myMarkup = \"<p class=\\\"text-danger\\\">This is a dangerous <em>markup string</em>.</p>\"; }\n\nMarkupStringExample.razor:\n\n@page \"/markup-string-example\" @((MarkupString)myMarkup) @code { private string myMarkup = \"<p class=\\\"text-danger\\\">This is a dangerous <em>markup string</em>.</p>\"; }\n\nMarkupStringExample.razor:\n\n@page \"/markup-string-example\" @((MarkupString)myMarkup) @code { private string myMarkup = \"<p class=\\\"text-danger\\\">This is a dangerous <em>markup string</em>.</p>\"; }\n\nRazor templates\n\nRender fragments can be defined using Razor template syntax to define a UI snippet. Razor templates use the following format:\n\n@<{HTML tag}>...</{HTML tag}>\n\nThe following example illustrates how to specify RenderFragment and RenderFragment<TValue> values and render templates directly in a component. Render fragments can also be passed as arguments to templated components.\n\nRazorTemplate.razor:\n\n@page \"/razor-template\" <PageTitle>Razor Template</PageTitle> <h1>Razor Template Example</h1> @timeTemplate @petTemplate(new Pet { Name = \"Nutty Rex\" }) @code { private RenderFragment timeTemplate = @<p>The time is @DateTime.Now.</p>; private RenderFragment<Pet> petTemplate = (pet) => @<p>Pet: @pet.Name</p>; private class Pet { public string? Name { get; set; } } }\n\n@page \"/razor-template\" @timeTemplate @petTemplate(new Pet { Name = \"Nutty Rex\" }) @code { private RenderFragment timeTemplate = @<p>The time is @DateTime.Now.</p>; private RenderFragment<Pet> petTemplate = (pet) => @<p>Pet: @pet.Name</p>; private class Pet { public string? Name { get; set; } } }\n\n@page \"/razor-template\" @timeTemplate @petTemplate(new Pet { Name = \"Nutty Rex\" }) @code { private RenderFragment timeTemplate = @<p>The time is @DateTime.Now.</p>; private RenderFragment<Pet> petTemplate = (pet) => @<p>Pet: @pet.Name</p>; private class Pet { public string? Name { get; set; } } }\n\n@page \"/razor-template\" @timeTemplate @petTemplate(new Pet { Name = \"Nutty Rex\" }) @code { private RenderFragment timeTemplate = @<p>The time is @DateTime.Now.</p>; private RenderFragment<Pet> petTemplate = (pet) => @<p>Pet: @pet.Name</p>; private class Pet { public string Name { get; set; } } }\n\n@page \"/razor-template\" @timeTemplate @petTemplate(new Pet { Name = \"Nutty Rex\" }) @code { private RenderFragment timeTemplate = @<p>The time is @DateTime.Now.</p>; private RenderFragment<Pet> petTemplate = (pet) => @<p>Pet: @pet.Name</p>; private class Pet { public string Name { get; set; } } }\n\nRendered output of the preceding code:\n\n<p>The time is 4/19/2021 8:54:46 AM.</p> <p>Pet: Nutty Rex</p>\n\nStatic assets\n\nBlazor follows the convention of ASP.NET Core apps for static assets. Static assets are located in the project's web root (wwwroot) folder or folders under the wwwroot folder.\n\nUse a base-relative path (/) to refer to the web root for a static asset. In the following example, logo.png is physically located in the {PROJECT ROOT}/wwwroot/images folder. {PROJECT ROOT} is the app's project root.\n\n<img alt=\"Company logo\" src=\"/images/logo.png\" />\n\nComponents do not support tilde-slash notation (~/).\n\nFor information on setting an app's base path, see Host and deploy ASP.NET Core Blazor.\n\nTag Helpers aren't supported in components\n\nTag Helpers aren't supported in components. To provide Tag Helper-like functionality in Blazor, create a component with the same functionality as the Tag Helper and use the component instead.\n\nScalable Vector Graphics (SVG) images\n\nSince Blazor renders HTML, browser-supported images, including Scalable Vector Graphics (SVG) images (.svg), are supported via the <img> tag:\n\n<img alt=\"Example image\" src=\"image.svg\" />\n\nSimilarly, SVG images are supported in the CSS rules of a stylesheet file (.css):\n\n.element-class { background-image: url(\"image.svg\"); }\n\nWhitespace rendering behavior\n\nRoot component\n\nA root Razor component (root component) is the first component loaded of any component hierarchy created by the app.\n\nIn an app created from the Blazor Server project template, the App component (App.razor) is specified as the default root component in Pages/_Host.cshtml using the Component Tag Helper:\n\n<component type=\"typeof(App)\" render-mode=\"ServerPrerendered\" />\n\nIn an app created from the Blazor WebAssembly project template, the App component (App.razor) is specified as the default root component in the Program file:\n\nbuilder.RootComponents.Add<App>(\"#app\");\n\nIn the preceding code, the CSS selector, #app, indicates that the App component is specified for the <div> in wwwroot/index.html with an id of app:\n\n<div id=\"app\">...</app>\n\nMVC and Razor Pages apps can also use the Component Tag Helper to register statically-rendered Blazor WebAssembly root components:\n\n<component type=\"typeof(App)\" render-mode=\"WebAssemblyPrerendered\" />\n\nStatically-rendered components can only be added to the app. They can't be removed or updated afterwards.\n\nFor more information, see the following resources:"
    }
}