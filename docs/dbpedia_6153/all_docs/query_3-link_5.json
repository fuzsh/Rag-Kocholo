{
    "id": "dbpedia_6153_3",
    "rank": 5,
    "data": {
        "url": "https://developer.gimp.org/core/coding_style/",
        "read_more_link": "",
        "language": "en",
        "title": "GIMP Coding Style",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "icon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Table of Contents\n\nThis document describes the preferred coding style for the GIMP source code. It was originally inspired by GNU’s coding style and developed from there across the years.\n\nCoding style is completely arbitrary as it is a a matter of consistency, readability and maintenance, not taste. Therefore it doesn’t matter what you prefer (we all have some part of the rules we would like different, and we can apply these to our personal projects), just follow these rules so that we can work together efficiently.\n\nThis document will use examples at the very least to provide authoritative and consistent answers to common questions regarding the coding style and will also try to identify the allowed exceptions.\n\nDealing with the old code\n\nThe new GIMP code should adhere to the style explained below. The existing GIMP code largely follows these conventions, but there are some differences like extra or missing whitespace, tabs instead of space, wrong formatting, etc.\n\nOur policy is to update the style of a code block or function if and only if you happen to touch that code.\n\nPlease don’t waste your time and reviewers’ time with merge requests or patches with only code style fixes unless you have push rights to the GIMP’s repository.\n\nGit usage\n\nCommit messages\n\nCommit messages should follow the following rules:\n\nAlways provide informative titles. No one-word commits saying nothing like “bug fix”, so that we can at least search through the git history if needed. It can still be short messages for very simple fixes: for instance “Fix typo” or “Fix small memory leak” are informative of the type of fix.\n\nPrefix the title with the codebase section (i.e. the root folder usually) which was changed. For instance: libgimpbase: fix memory leak immediately tells us it was a memory leak fix in the libgimpbase library. If several sections are touched, list them with comma-separation.\n\nAlternatively, when the change is a response to a bug report, you may prefix with Issue #123: (where #123 is the report ID) instead.\n\nIf the changed code itself is not self-explanatory enough, you can add longer change description (2 lines after the title) to explain more. It is not mandatory, but it is never unwelcome because old code exploration to understand why things were done (possibly years before by people long gone) is a real thing we do all the time. So if it’s not obvious, explain us.\n\nExplanations can also be made in the shape of links to a bug report (ours, or a third-party project tracker, or some manual), even though additional text explanations may still be useful (unfortunately URLs may change or disappear). If the link is to our own bug tracker, usually giving the ID is enough.\n\nSame as for code, wrap your commit message to reasonable line widths, i.e. 80 characters maximum so that other contributors don’t have to scroll horizontally on narrow vizualisation. There may be exceptions, for instance when pasting some error messages which may end up confusing when wrapped. But other than this, wrap your text (most git client would have a feature to do it for you).\n\nIf the title is too long because of the max-width settings, a common format is to break it with ‘…’ and to continue the title 2 lines below. Then the description goes again 2 lines below.\n\nHere is an example of a well formatted fix in the plug-ins/ section:\n\nHere is another as a response to a bug report and a long title:\n\nIf you want to see more good examples, this git command will list commits whose messages are generally well formatted: git log --author=\"Jehan\\|mitch\\|Jacob Boerema\"\n\nLinear git log\n\nNearly all our repositories (gimp-web being the exception) have a fully linear history. The “merge commit” workflow is definitely good and useful in some projects’ workflow, especially with bigger projects with many contributors and subdivided maintenance roles (where the main tree is mostly about merging public trees of several submaintainers’ public trees, who themselves applied contributed commits by individuals).\n\nThis doesn’t work well with GIMP’s current workflow and our number of contributors. This is even worse with the completely useless merge commits created by hosting tools which completely misused (or even misunderstood) the merge concept.\n\nThis is why our Gitlab projects are configured to only push commits linearly. This means that when a contributed tree is behind, you must first rebase it through the “Rebase” button in the merge request (which requires contributors to check the “Allow commits from members who can merge to the target branch” option) or by rebasing in the tree then force-pushing when Gitlab is unable to merge.\n\nWhen you push directly (for contributors with push rights), you are also expected to never push a merge commit.\n\nMultiple or single commits?\n\nWhen contributing merge requests or patch files, you should break your work into logical changes, not into review timelines.\n\nE.g. after a review, instead of pushing fixes as an additional commit, amend your commits to rewrite your local git history as though reviewed bugs never existed.\n\nOn the other hand, we appreciate separate commits when they are logical units. For instance, you could have 1 commit adding a GUI feature, then 1 commit adding a libgimp API to manipulate the new feature and 1 commit for a plug-in to use this new API. It makes perfect sense to separate these 3 changes into their own commits and even help for review and later dig through development logs.\n\nC code\n\nLine width\n\nThe recommended line width for source files is 80 characters whenever possible. Longer lines are usually an indication that you either need a function or a pre-processor macro.\n\nThe point is to have clear code to read and not overly long lines. Don’t break code into ugly and choppy parts to blindly follow this rule.\n\nFunction definitions in the function forward declaration block don’t have to obey the 80 characters limit. The only general rule for headers is to align the function definitions vertically in three columns. See more information in Functions section\n\nWhitespaces\n\nIndentation\n\nEach new level is indented 2 or more spaces than the previous level:\n\nUse only space characters to achieve this. Code indented with tabs will not be accepted into the GIMP codebase.\n\nEven if two spaces for each indentation level allow deeper nesting, GIMP favors self-documenting function names that can be quite long. For this reason, you should avoid deeply nested code.\n\nNote: the only place where we use Tab indentation and alignment is the Makefiles. In there, Tab are expected to be displayed as 8 characters for proper display\n\nVertical spaces (new lines)\n\nExcept for one single newline at the end of the file, other empty lines (at the beginning and the end) of a file are not allowed.\n\nOn the other hand, empty lines in the middle of code are very encouraged for well-ventilated code. For instance gathering and separating code by logical parts making it easy to read and understand.\n\nHorizontal spaces\n\nAlways put a space before an opening parenthesis but never after:\n\nDo not eliminate whitespace and newlines just because something would fit on 80 characters:\n\nTab characters in strings\n\nUse \\t instead of literal tab inside the source code strings.\n\nBraces\n\nIf-else\n\nDon’t use curly braces for single statement blocks:\n\nIn the case of multiple statements, put curly braces on another indentation level:\n\nThe “no block for single statements” rule has only three exceptions:\n\n① Both sides of the if-else statement must have curly braces when either side of this if-else statement has braces or when the single statement covers multiple lines, and it’s followed by else or else if (e.g., for functions with many arguments).\n\n② if the condition is composed of many lines:\n\n③ In the case of nested if’s, the block should be placed on the outermost if:\n\nSwitch\n\nA switch() should open a block on a new indentation level, and each case should start on the same indentation level as the curly braces, with the case block on a new indentation level:\n\nIt is preferable, though not mandatory, to separate the various cases with a newline:\n\nIf a case block needs to declare new variables, the same rules as the inner blocks (see above) apply; place the break statement outside of the inner block:\n\nDo not add default: case if your switch () is supposed to handle all cases.\n\nRandom blocks\n\nUsing blocks to group code is discouraged and must not be used in newly written code.\n\nConditions\n\nDo not check boolean values for equality:\n\nEven if C handles NULL equality like a boolean, be explicit:\n\nWhen conditions split over multiple lines, the logical operators should always go at the end of the line. Align the same level boolean operators to show explicitly which are on the same level and which are not:\n\nVariables declaration and definition\n\nPlace each variable on a new line. The variable name must be left-aligned, taking into account pointers:\n\nBlocks of variable declaration/initialization should align the variable names, allowing quick skimming of the variable list.\n\nFunctions\n\nFunction header has the return type on one line; the name starting in the first column of the following line. Prototype each parameter and place each on a new line.\n\nIn function names, each word must be lowercase and separated by an underscore.\n\nIn the function definition, place the return value on a separate line from the function name:\n\nThe parameters list must be broken into a new line for each parameter, with the parameter names left-aligned, taking into account pointers:\n\nWhile curly braces for function definitions should rest on a new line they should not add an indentation level:\n\nThe alignment also holds when invoking a function, except that we align full expressions, not variables:\n\nIf your function name is very long, it’s always better to extract arguments into separate variables to improve readability:\n\nKeep the function name and the arguments on the same line. Otherwise, it will hurt readability.\n\nMacros\n\nTry to avoid private macros unless strictly necessary. Remember to #undef them at the end of a block or a series of functions needing them.\n\nUse inline functions instead of private macro definitions. Do not use public macros unless they evaluate to a constant.\n\nIncludes\n\nGIMP source files should never include the global gimp.h header, but instead include the individual headers that are needed.\n\nIncludes must be in the following order:\n\nconfig.h first;\n\nSystem and third-party headers;\n\nGIMP library headers (libgimp* headers);\n\nGIMP core/app headers that it needs including its own;\n\nSort alphabetically the includes within the blocks.\n\nStructures\n\nWhen declaring a structure type use newlines to separate logical sections:\n\nWhen initializing a structure variable with constants, shortly enough that it can be done on a single line, then you should add a space after the opening curly brace and before the closing one, such as:\n\nMemory management\n\nTo dynamically allocate data on the heap, use g_new(). To allocate memory for multiple small data structures, g_slice_new().\n\nWhen possible, all public structure types should be returned fully initialized, either explicitly for each member or by using g_new0() or g_slice_new0().\n\nAs a general programming rule, it is better to allocate and free data on the same level. It is much easier to review code because you know that when you allocate something there, then you also free it there.\n\nWhen a transfer of ownership is unavoidable make it clear in the function documentation.\n\nIn-code explanation\n\nThe only allowed style is C-style comments /* */. In particular C++ comments // are strictly forbidden from our source.\n\nWe are not asking contributors to over-comment their code, yet we highly value quality comments to explain complicated algorithms or non-obvious code. Just ask yourself this: what if someone sees my code 5 years later (another contributor or even your future self)…\n\nwill one easily understand what you meant to do?\n\nIn particular: if it needs to be removed later, won’t one be scared to delete now-useless code by fear of unexpected side-effects?\n\nOr oppositely: won’t someone delete the code by mistake because it looks useless while it was actually dealing with a very particular (yet absolutely non-obvious) issue?\n\nAdding links which explain well a problem or the reason for some non-obvious code is also permitted. For instance a link to a bug report (ours or some other projects’) can sometimes be a good complement to a comment. Nevertheless it should not be overdone and in particular not for links likely to disappear (personal blog posts, forums, corporate websites which often revamp their design, breaking URLs, etc.).\n\nPublic API Documentation\n\nAll public APIs (i.e. any function exported in a header inside libgimp*/ folders) MUST have proper GObject-introspection (GIR) comments. For functions, these should be placed in the source file directly above.\n\nThese annotations are also relevant for GObject Introspection to generate bindings for other languages.\n\nDoc comments for macros, function types, class structs, etc., should be placed next to the definitions, typically in headers.\n\nNon-public API documentation\n\nProject-only code (for instance any code from the app/ folder) can be less documented. For instance when a function has obvious naming, not explaining it is perfectly acceptable.\n\nNevertheless adding documentation even for these private APIs is welcome, especially when the usage is not as obvious as it looks, or to make sure to advertize the proper memory handling (does it allocate new memory? Which function to free it with? Or shouldn’t the returned memory be freed?), avoiding silly bugs and not wasting developer times (when we have to look at the implementation to verify each time we use a function).\n\nIn such a case, using gtk-docs syntax is still a nice idea as we will understand it directly (even though we won’t generate any docs from it).\n\nPublic API\n\nNo variables\n\nAvoid exporting variables as public API since this is cumbersome on some platforms. It is always preferable to add getters and setters instead.\n\nDef files for Windows\n\nList all public functions alphabetically in the corresponding .def file.\n\napp/gimpcore.def\n\nlibgimp/gimp.def\n\nlibgimpbase/gimpbase.def\n\netc\n\nNatural language text\n\nBase rules\n\nAny text in GIMP source should follow these base rules:\n\nOur base language is US English, both for historical reason and because this is the usual expectation with gettext, the localization tool used by GIMP. In particular when variants of words or idioms exist in several native English countries, we should choose the US variant. Other English variants can be used in specific locales (such as en_GB or en_CA…).\n\nText meant for technical people, such as API documentation (in-code comments, in-repository documentation, or gtk-doc/docgen style comments for generated docs…) usually does not need localization, and therefore can just be written in US English.\n\nText meant to be viewed by all users should be translatable. In particular in GIMP source code, it means that we need to use gettext API.\n\nUse gender-neutral terms, in particular not using words such as “she/he” or “her/his” is better. We should not use over-complicated wording to achieve this and should look for simpler writing if necessary.\n\nBe nice and open-minded in all text, even in code comments. Remember these will be read by others and that we are here to have fun together, not fight.\n\nUser-visible text in C code\n\nAs explained, C code uses the gettext API. Any text which might appear in front of people should be translatable, with the following exceptions:\n\nError or warning output in stderr might often be untranslated (because we assume these are mostly used for debugging and people who will see these would be more comfortable with digging into issue causes; also it makes debugging and searches in code easier).\n\nTechnical error text in the graphical interface when it is made to be reported to developers. Basically error messages meant for users themselves should still be translatable. For instance, if one tries to draw on a layer group, we’d display:\n\n_(\"Cannot modify the pixels of layer groups.\")\n\nIndeed this is an error message to give an information to the user. It’s not a bug. Now when a crash happens, we add a translated header message to explain a problem occured, but the core information stays in English because we are not asking people to understand it, only report it to us.\n\nThe most common variant of gettext API is the underscore _() (alias of gettext()) for simple text:\n\nWhen used in some widgets, we may want to add mnemonics for accessibility. This is done with the underscore:\n\nNote that it is a good idea to not change well-known mnemonics, such as _(\"_OK\"), _(\"_Cancel\") or _(\"_Reset\"). Also you should avoid using the same mnemonics in 2 widgets on the same interface (even though GTK has some way to handle mnemonic duplicate, but it’s not a really good implementation accessibility-wise).\n\nTranslators may (and often will) change mnemonics. It is therefore up to them to take care of not having the same mnemonics on a same interface in their specific locale.\n\nWhen some messages cannot be translated at initialization, you must use the no-op variant N_(). For instance, when we declare and initialize a struct:\n\nThe normal gettext _() would not compile because you must initialize struct elements with constants. N_() allows the gettext tools to detect the strings which will need to go into the translator files. Note though that these strings will still need to be translated when used at runtime:\n\nFinally note that for any strings which depends on a variable number, you must use the ngettext variant:\n\nIt is important to use ngettext() even in cases where there will always be a count bigger than 1. Say our indexed image do not support the monochrome (1 color) case, and even less 0 colors, then this seems useless because we will always use the second string only:\n\nYet it’s actually not useless as it allows translators for languages with more plural forms to translate GIMP correctly. For instance, gettext documentation mentions the Polish language has different grammatical agreements for 2,3,4 and 5-21 or again 22-24 and so on. If we were to use solely _(\"Indexed color (%d colors)\"), Polish translators would not be able to list all these cases (therefore GIMP would have a crappy Polish localization), so we have to use ngettext() even when sometimes, it feels useless in English.\n\nFinally when you add translated strings in a file which had none until now, for it to be processed by gettext, you need to add its path in alphabetical order in po/POTFILES.in for core files (or other POTFILES.in, for instance po-plug-ins/POTFILES.in for plug-ins). We have a test checking this, so the make distcheck step will fail anyway when you forgot to add a new file with translation. Yet as developers don’t always run this step locally, the bug may be discovered during CI builds. It is obviously prefered to not forget it hence not push code which breaks the CI (and localization).\n\nGit\n\nWe recommend enabling the default git pre-commit hook that detects trailing whitespace and non-ASCII filenames for you and helps you to avoid corrupting GIMP’s tree with it.\n\nIn the terminal, navigate into your GIMP source code folder. Then do that as follows (one command at a time):\n\nIf any command above fails, visit your .git/hooks/ folder and check for the existence of pre-commit.sample or pre-commit files.\n\nYou might also find the git-stripspace utility helpful, which acts as a filter to remove trailing whitespace as well as initial, final, and duplicate blank lines.\n\nCode editor / Integrated Development Environment (IDE)\n\nGIMP’s codebase is not tied to a specific editor or IDE. The whole build can be performed from anywhere, and we don’t care what you write your code with (as long as it follows syntax rules from this document).\n\nSeveral configuration files were contributed across the years to configure your favorite software to follow our coding style. You are very welcome to use them (or improve them and contribute the change when they are not perfect):\n\n.dir-locals.el for Emacs;\n\n.kateconfig for Kate;\n\nc.vim for Vim (check the top comments to see how to enable it automatically when opening a file in the GIMP tree);\n\nsettings.json for VS Code.\n\nNote: all config files should work out-of-the-box, but the Vim one needs to be enabled explicitly because it is too powerful, hence is basically unsafe.\n\nIf you use another software to write code, you are welcome to contribute coding style files implementing our coding style.\n\nCode Formatter\n\nOur project contains a .clang-format in the repository root.\n\nA good way to test your code is with the following command while it’s not committed yet:\n\nNote that we are not considering these format rules as perfect, because it seems the tool still cannot handle several special cases we have in our coding style. Also we are not perfectly fond of the way it handles long lines (when to accept lines a bit longer than the max line width or not) as well as other rules. Therefore the current document remains the ultimate one to verify when unsure of how to format something."
    }
}