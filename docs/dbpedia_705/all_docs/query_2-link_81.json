{
    "id": "dbpedia_705_2",
    "rank": 81,
    "data": {
        "url": "https://www.edureka.co/blog/interview-questions/java-interview-questions/",
        "read_more_link": "",
        "language": "en",
        "title": "Top Core Java Interview Questions and Answers (2024)",
        "top_image": "http://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/Java-Interview-Question.png",
        "meta_img": "http://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/05/Java-Interview-Question.png",
        "images": [
            "https://googleads.g.doubleclick.net/pagead/viewthroughconversion/977137586/?value=0&guid=ON&script=0",
            "https://d1jnx9ba8s6j9r.cloudfront.net/img/Edureka_Ver_Logo.webp",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/whatsapp.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/linkedin.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/twitter.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/facebook.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/reddit.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/feather_link.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/content/ver.1554115042/uploads/2019/04/Aayushi-Johari_avatar-96x96.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/whatsapp.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/linkedin.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/twitter.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/facebook.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/reddit.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/feather_link.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/new-banner-images/trending-technlogy-1_1716292199.webp",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/new-banner-images/trending-technology_1716292198.webp",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/04/String-pool.png 941w, https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/04/String-pool-150x89.png 150w, https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/04/String-pool-300x179.png 300w, https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/04/String-pool-768x458.png 768w, https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/04/String-pool-503x300.png 503w, https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2019/04/String-pool-302x180.png 302w",
            "https://www.edureka.co/blog/wp-content/uploads/2017/05/Collection-framework-hierarchy.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Polymorphism-483x300.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/MultipleInheritance-Java-240x300.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Servlet-Java-340x300.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Forward-Method.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Include-Method.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Life-Cycle-Servlet-300x284.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Session-management.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/JDBC.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Connection-interface.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Spring-Framework-Java.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Scopes-of-bean.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Dispatcher-Servlet.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/ContextloaderListener-528x201.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Hibernate-Architecture.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Exception-hierarchy-516x300.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/04/Synchronization.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/04/hibernate-mapping-on-the-fly.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/02/portal-development-and-text-searching-with-hibernate.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2014/08/JAVA-J2EE-WEBINAR-600x3501_-300x175.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2014/11/php-mysql-server-side-scripting-language-for-web-development.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2014/11/microsoft-net-framework-an-intellisense-way-of-web-development.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2014/11/spring-framework-introduction-to-spring-web-mvc-spring-with-bigdata.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/07/rapid-development-with-cakephp.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/05/node-js-express-steps-to-create-restful-web-app.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/06/php-and-mysql-server-side-scripting-for-web-development.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2014/08/introduction-to-javaj2ee-soa.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/03/microsoft-sharepoint-the-ultimate-enterprise-collaboration-platform.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2014/12/hibernate-the-ultimate-orm-framework.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/07/building-application-with-ruby-on-rails-framework.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/06/create-restful-web-application-with-node-js-express.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/06/effective-persistence-using-orm-with-hibernate.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/07/implementing-web-services-in-java.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/05/microsoft-sharepoint-2013-the-ultimate-enterprise-collaboration-platform.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/06/ms-net-an-intellisense-way-of-web-development.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/05/responsive-web-app-using-cakephp.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2015/05/service-oriented-architecture-with-java.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/09/clone-in-java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/08/keyword-in-Java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2018/10/Java-Exceptions-300x175.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/01/JavaScript-interview-questions-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/08/Treeset-In-Java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/08/Identifiers-in-java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2018/09/Top-10-JavaScript-Frameworks-300x175.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/08/Volatile-Keyword-in-Java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/08/CSS-INT-blg-300x175.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/07/DATE-FORMAT-IN-JAVA-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/09/executor-in-Java-300x175.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/09/magic-methods-in-php-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/07/Wrapper-Class-In-Java-Blog-Feature-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/10/Why-java-300x175.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/10/Difference-between-Class-and-Interface-1-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/07/Assertion-In-Java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/06/Java-Programs-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/09/Wait-Notify-in-Java-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/09/Structure-Of-A-Java-Program-1-300x175.jpg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/lqip/wp-content/uploads/2019/06/Reverse-a-String-in-Java-300x175.jpg",
            "https://secure.gravatar.com/avatar/7fcf5ecf87f61db8b2556a9d4b966cf0?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/4f1236f03f4e0099453f86239dbb8146?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/c2a39b8a7b34ca6d55f582f03757f9af?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/fdb20dd4506749fa59e73a2b1bfea433?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/c2a39b8a7b34ca6d55f582f03757f9af?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/ab89ffcf6a50b81a1902a71227bfb247?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/0f5135fd22143cffd076c002307d8ab9?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/c2a39b8a7b34ca6d55f582f03757f9af?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/b7addf1cebed5e834c5a284cae8bf457?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/525d7649fe0bcf65b03dfa34dee09639?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/7317ffd090fdc3cc1282f3908a68635f?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/f6b4c7c13ba5a8ca51d7e2377e42ab48?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/c299de2d3924c50936657faf7cbb5f03?s=64&d=mm&r=g 2x",
            "https://secure.gravatar.com/avatar/c299de2d3924c50936657faf7cbb5f03?s=64&d=mm&r=g 2x",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_2590_1706670842.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_44_1695898528.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_777_1695896960.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_2235_1676961822.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/mastering-java-programming-pwc-img-1720499821.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_62_1695898316.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_1905_1658912580.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_193_1504782213.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_90_1504780962.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/imgver.2406171543/img/co_img_14_1504781846.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/blog-001.svg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/blog-tick.svg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/assets/ver.2406171543/img/google-icon.svg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/assets/ver.2406171543/img/facebook-icon.svg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/assets/ver.2406171543/img/loader.gif",
            "https://d1jnx9ba8s6j9r.cloudfront.net/img/Edureka_Ver_Enter_Logo.webp",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/applestore_img.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/playstore_img.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/multimedia-option.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/cart-icon.svg",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/close.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/whatsapp.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/linkedin.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/twitter.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/facebook.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/reddit.png",
            "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/themes/edu-new/img/feather-link-black.png"
        ],
        "movies": [
            "https://www.youtube.com/embed/oYXivKMSEqM?rel=0&controls=0&showinfo=0",
            "https://www.youtube.com/embed/vaLXPv0ewHU",
            "https://www.youtube.com/embed/hxcnrK2U13Y?rel=0&controls=0&showinfo=0"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Aayushi Johari"
        ],
        "publish_date": "2017-05-08T14:15:58+00:00",
        "summary": "",
        "meta_description": "Our expert-curated Java Interview questions and answers for freshers & experienced will help to crack Core Java, coding, and programming interviews.",
        "meta_lang": "en",
        "meta_favicon": "https://d1jnx9ba8s6j9r.cloudfront.net/blog/wp-content/uploads/2017/09/ic_logo_icon.png",
        "meta_site_name": "Edureka",
        "canonical_link": "https://www.edureka.co/blog/interview-questions/java-interview-questions/",
        "text": "In this blog, I am going to list some of the most important Java programming Interview Questions that will set you apart in the interview process. Java is used by approximately 10 Million developers worldwide to develop applications for 15 Billion devices supporting Java. It is also used to create applications for trending technologies like Big Data on household devices like Mobiles and DTH boxes. And hence, today, Java is used everywhere! This is the reason why Java is the most in-demand certification in the programming domain. Enroll for the Java course and get your certification today!\n\nThis Edureka Java Interview Questions and Answers video will help you to prepare yourself to clear Java Interviews on your first attempt\n\nLet us start by taking a look at some of the most frequently asked Java interview questions,\n\nQ1. What is Java?\n\nQ2. List the features of Java programming language\n\nQ3. How is Java different from C++?\n\nQ4. Explain JDK, JRE and JVM?\n\nQ5. Explain public static void main(String args[]) in Java.\n\nQ6. What is classLoader in Java?\n\nQ7. Why Java is platform independent?\n\nQ8. Why Java is not 100% Object-oriented?\n\nQ9. What are wrapper classes in Java?\n\nQ10. What are constructors in Java?\n\nWe have compiled a list of top Java interview questions which are classified into 8 sections, namely:\n\nBasic Java Interview Questions\n\nJava OOPs Interview Questions\n\nJDBC Interview Questions\n\nSpring Interview Questions\n\nHibernate Interview Questions\n\nJSP Interview Questions\n\nJava Exception and Thread Interview Questions\n\nJava Coding Interview Questions\n\nAs a Java professional, it is essential to know the right buzzwords, learn the right technologies and prepare the right answers to commonly asked Java Programming Interview Questions. Here’s a definitive list of top Java Interview Questions that will guarantee a breeze-through to the next level.\n\nIn case you attended any Java interview recently, or have additional questions beyond what we covered, we encourage you to post them in our Java community questions. Our expert team will get back to you at the earliest.\n\nSo let’s get started with the first set.\n\nBasic Java Interview Questions for Freshers\n\nQ1. What is Java?\n\nJava is a class-based, object-oriented programming language with minimal implementation dependencies. A general-purpose programming language, Java allows programmers to write once and run anywhere (WORA), meaning compiled Java code can execute on all Java-supported platforms without recompilation. Java applications are usually compiled to bytecode that works on any JVM, regardless of computer architecture.\n\nQ2. List the features of Java programming language\n\nJava is a language that is considered simple to learn. One fundamental notion of OOP Java must be understood.\n\nJava offers a secure feature that aids in the development of a virus-free and tamper-proof system for users.\n\nOOP is an abbreviation for Object-Oriented Programming language. OOP denotes that everything in Java is considered an object.\n\nJava is not compiled into a platform-specific machine; rather, it is compiled into platform-independent bytecode. The Virtual Machine that\n\noperates the platform interprets this code.\n\nQ3. How is Java different from C++?\n\nJava and C++ are both object-oriented programming languages, but they have some key differences.\n\nPlatform independence: Java is a platform-independent language, while C++ is a platform-dependent language. This means that Java code can run on any platform that has a Java virtual machine (JVM), while C++ code can only run on the platform that it was compiled for.\n\nMemory management: Java uses automatic memory management, while C++ requires manual memory management. This means that Java programmers do not need to worry about allocating and freeing memory, while C++ programmers need to be careful to manage memory correctly to avoid memory leaks.\n\nSafety: Java is a safer language than C++. This is because Java has built-in security features that help to protect applications from malicious code. For example, Java does not allow direct access to the operating system, which makes it more difficult for attackers to exploit security vulnerabilities.\n\nPerformance: Java is typically not as fast as C++. This is because Java uses a virtual machine, which adds an extra layer of abstraction between the code and the hardware. However, Java applications are typically more portable and secure than C++ applications.\n\nIn general, Java is a good choice for developing portable, secure, and easy-to-maintain applications. C++ is a good choice for developing high-performance applications that require direct access to the operating system.\n\nQ4. Explain JDK, JRE and JVM?\n\nJDK vs JRE vs JVM\n\nJDKJREJVMIt stands for Java Development Kit.It stands for Java Runtime Environment.It stands for Java Virtual Machine.It is the tool necessary to compile, document and package Java programs.JRE refers to a runtime environment in which Java bytecode can be executed.It is an abstract machine. It is a specification that provides a run-time environment in which Java bytecode can be executed.It contains JRE + development tools.It’s an implementation of the JVM which physically exists.JVM follows three notations: Specification, Implementation, and Runtime Instance.\n\nQ5. Explain public static void main(String args[]) in Java.\n\nmain() in Java is the entry point for any Java program. It is always written as public static void main(String[] args).\n\npublic: Public is an access modifier, which is used to specify who can access this method. Public means that this Method will be accessible by any Class.\n\nstatic: It is a keyword in java which identifies it is class-based. main() is made static in Java so that it can be accessed without creating the instance of a Class. In case, main is not made static then the compiler will throw an error as main() is called by the JVM before any objects are made and only static methods can be directly invoked via the class.\n\nvoid: It is the return type of the method. Void defines the method which will not return any value.\n\nmain: It is the name of the method which is searched by JVM as a starting point for an application with a particular signature only. It is the method where the main execution occurs.\n\nString args[]: It is the parameter passed to the main method.\n\nQ6. What is classLoader in Java?\n\nThe Java ClassLoader subset of JVM loads class files. The classloader loads Java programs first. Three classloaders are built into Java:\n\nBootstrap ClassLoader\n\nExtension ClassLoader\n\nSystem/Application ClassLoader\n\nQ7. Why Java is platform independent?\n\nJava is called platform independent because of its byte codes which can run on any system irrespective of its underlying operating system.\n\nUpskill for Higher Salary with Java certification training course\n\nCourse NameUpcoming BatchesFeesJava certification training27th April,2024 (Weekend Batch)₹19,995Java certification training18th May,2024 (Weekend Batch)₹19,995\n\nQ8. Why Java is not 100% Object-oriented?\n\nJava is not 100% Object-oriented because it makes use of eight primitive data types such as boolean, byte, char, int, float, double, long, short which are not objects.\n\nQ9. What are wrapper classes in Java?\n\nWrapper classes convert the Java primitives into the reference types (objects). Every primitive data type has a class dedicated to it. These are known as wrapper classes because they “wrap” the primitive data type into an object of that class. Refer to the below image which displays different primitive type, wrapper class and constructor argument.\n\nQ10. What are constructors in Java?\n\nIn Java, constructor refers to a block of code which is used to initialize an object. It must have the same name as that of the class. Also, it has no return type and it is automatically called when an object is created.\n\nThere are two types of constructors:\n\nDefault Constructor: In Java, a default constructor is the one which does not take any inputs. In other words, default constructors are the no argument constructors which will be created by default in case you no other constructor is defined by the user. Its main purpose is to initialize the instance variables with the default values. Also, it is majorly used for object creation.\n\nParameterized Constructor: The parameterized constructor in Java, is the constructor which is capable of initializing the instance variables with the provided values. In other words, the constructors which take the arguments are called parameterized constructors.\n\nQ11. What is singleton class in Java and how can we make a class singleton?\n\nSingleton class is a class whose only one instance can be created at any given time, in one JVM. A class can be made singleton by making its constructor private.\n\nQ12. What is the difference between Array list and vector in Java?\n\nQ14. What is the difference between equals() and == in Java?\n\nEquals() method is defined in Object class in Java and used for checking equality of two objects defined by business logic.\n\n“==” or equality operator in Java is a binary operator provided by Java programming language and used to compare primitives and objects. public boolean equals(Object o) is the method provided by the Object class. The default implementation uses == operator to compare two objects. For example: method can be overridden like String class. equals() method is used to compare the values of two objects.\n\nQ15. Implement Binary Search in Java using recursion.\n\nHere’s an example Java program that implements the binary search algorithm using recursion:\n\npublic class BinarySearchRecursive { public static void main(String[] args) { int[] arr = { 2, 5, 8, 12, 16, 23, 38, 56, 72, 91 }; int target = 23; int result = binarySearch(arr, target); if (result == -1) { System.out.println(\"Element not found in the array.\"); } else { System.out.println(\"Element found at index \" + result); } } // Binary search using recursion public static int binarySearch(int[] arr, int target) { return binarySearchRecursive(arr, target, 0, arr.length - 1); } private static int binarySearchRecursive(int[] arr, int target, int low, int high) { if (low &gt; high) { return -1; // Element not found } int mid = (low + high) / 2; if (arr[mid] == target) { return mid; // Element found at mid index } else if (arr[mid] &gt; target) { // Search in the left half return binarySearchRecursive(arr, target, low, mid - 1); } else { // Search in the right half return binarySearchRecursive(arr, target, mid + 1, high); } } }\n\nThis program uses binary search to find a target value `target` in a sorted array `arr`. Calling the `binarySearch` function triggers the `binarySearchRecursive` function. The `binarySearchRecursive` function executes the binary search algorithm through the utilization of recursion.\n\nThe `binarySearchRecursive` function takes the array, target value, and indices for the low and high boundaries of the search range. It compares the target value with the middle element of the current range. If they match, the function returns the index. If the target is smaller, it recursively calls itself with the left half of the range. If the target is larger, it recursively calls itself with the right half of the range. The process continues until the element is found or the low index becomes greater than the high index.\n\nThe program outputs the index where the element is found or a message indicating that the element was not found in the array.\n\nNote: The program assumes that the array is sorted in ascending order.\n\nQ16. When can you use the super keyword?\n\nIn Java, the super keyword is a reference variable that refers to an immediate parent class object.\n\nWhen you create a subclass instance, you’re also creating an instance of the parent class, which is referenced to by the super reference variable.\n\nThe uses of the Java super Keyword are-\n\nTo refer to an immediate parent class instance variable, use super.\n\nThe keyword super can be used to call the method of an immediate parent class.\n\nSuper() can be used to call the constructor of the immediate parent class.\n\nQ17. What makes a HashSet different from a TreeSet?\n\nHashSetTreeSetIt is implemented through a hash table.TreeSet implements SortedSet Interface that uses trees for storing data.It permits the null object.It does not allow the null object.It is faster than TreeSet especially for search, insert, and delete operations.It is slower than HashSet for these operations.It does not maintain elements in an ordered way.The elements are maintained in a sorted order.It uses equals() method to compare two objects.It uses compareTo() method for comparing two objects.It does not permit a heterogenous object.It permits a heterogenous object.\n\nQ18. What are the differences between HashMap and HashTable in Java?\n\nHashMapHashtableIt is non synchronized. It cannot be shared between many threads without proper synchronization code.It is synchronized. It is thread-safe and can be shared with many threads.It permits one null key and multiple null values.It does not permit any null key or value.is a new class introduced in JDK 1.2.It was present in earlier versions of java as well.It is faster.It is slower.It is traversed through the iterator.It is traversed through Enumerator and Iterator.It uses fail fast iterator.It uses an enumerator which is not fail fast.It inherits AbstractMap class.It inherits Dictionary class.\n\nQ19. How does HashMap work in Java?\n\nA HashMap in Java stores key-value pairs. The HashMap requires a hash function and uses hashCode and equals methods in order to put and retrieve elements to and from the collection. When the put method is invoked, the HashMap calculates the hash value of the key and stores the pair in the appropriate index inside the collection. If the key exists then its value is updated with the new value. Some important characteristics of a HashMap are its capacity, its load factor and the threshold resizing.\n\nQ20. What are the differences between wait() and sleep()?\n\nWait() is a method of Object class. Sleep() is a method of Thread class.\n\nSleep() allows the thread to go to sleep state for x milliseconds. When a thread goes into sleep state it doesn’t release the lock.\n\nWait() allows the thread to release the lock and go to suspended state. The thread is only active when a notify() or notifAll() method is called for the same object.\n\nQ21. What are the uses of synchronized keywords?\n\nSynchronized keyword can be applied to static/non-static methods or a block of code. Only one thread at a time can access synchronized methods and if there are multiple threads trying to access the same method then other threads have to wait for the execution of method by one thread. Synchronized keyword provides a lock on the object and thus prevents race condition.\n\nQ22. What does the ‘static’ keyword mean? Is it possible to override private or static method in Java?\n\nThe static keyword denotes that a member variable or method can be accessed, without requiring an instantiation of the class to which it belongs. You cannot override static methods in Java, because method overriding is based upon dynamic binding at runtime and static methods are statically binded at compile time. A static method is not associated with any instance of a class, so the concept is not applicable.\n\nQ23. What is the default value of the local variables?\n\nThe local variables are not initialized to any default value; neither primitives nor object references.\n\nQ24. What is the importance of reflection in Java?\n\nReflection is a runtime API for inspecting and changing the behavior of methods, classes, and interfaces. Java Reflection is a powerful tool that can be really beneficial. Java Reflection allows you to analyze classes, interfaces, fields, and methods during runtime without knowing what they are called at compile time. Reflection can also be used to create new objects, call methods, and get/set field values. External, user-defined classes can be used by creating instances of extensibility objects with their fully-qualified names. Debuggers can also use reflection to examine private members of classes.\n\nQ25. How to not allow serialization of attributes of a class in Java?\n\nThe Non-Serialized attribute can be used to prevent member variables from being serialized.\n\nYou should also make an object that potentially contains security-sensitive data non-serializable if possible. Apply the Non-Serialized attribute to certain fields that store sensitive data if the object must be serialized. If you don’t exclude these fields from serialization, the data they store will be visible to any programs with serialization permission.\n\nQ26. Can you call a constructor of a class inside another constructor?\n\nYes, we can call a constructor of a class inside another constructor. This is also called as constructor chaining. Constructor chaining can be done in 2 ways-\n\nWithin the same class: For constructors in the same class, the this() keyword can be used.\n\nFrom the base class: The super() keyword is used to call the constructor from the base class.\n\nThe constructor chaining follows the process of inheritance. The constructor of the sub class first calls the constructor of the super class. Due to this, the creation of sub class’s object starts with the initialization of the data members of the super class. The constructor chaining works similarly with any number of classes. Every constructor keeps calling the chain till the top of the chain.\n\nQ27. Write a Java program to reverse a string.\n\nHere’s an example Java program that reverses a string:\n\nimport java.util.Scanner; public class StringReversal { public static void main(String[] args) { Scanner scanner = new Scanner(System.in); // Get the string from the user System.out.print(\"Enter a string: \"); String input = scanner.nextLine(); // Reverse the string String reversedString = reverseString(input); // Print the reversed string System.out.println(\"Reversed string: \" + reversedString); } // Function to reverse a string public static String reverseString(String str) { StringBuilder reversed = new StringBuilder(str); reversed.reverse(); return reversed.toString(); } }\n\nThis program prompts the user to enter a string. It then calls the `reverseString` function to reverse the string using the `reverse()` method of the `StringBuilder` class. The reversed string is then printed to the console.\n\nHere’s a sample output of the program:\n\nEnter a string: Hello, World!\n\nReversed string: !dlroW ,olleH\n\nQ28. Contiguous memory locations are usually used for storing actual values in an array but not in ArrayList. Explain.\n\nAn array generally contains elements of the primitive data types such as int, float, etc. In such cases, the array directly stores these elements at contiguous memory locations. While an ArrayList does not contain primitive data types. An arrayList contains the reference of the objects at different memory locations instead of the object itself. That is why the objects are not stored at contiguous memory locations.\n\nQ29. How is the creation of a String using new() different from that of a literal?\n\nWhen we create a string using new(), a new object is created. Whereas, if we create a string using the string literal syntax, it may return an already existing object with the same name.\n\nQ30. Why is synchronization necessary? Explain with the help of a relevant example.\n\nJava allows multiple threads to execute. They may be accessing the same variable or object. Synchronization helps to execute threads one after another.\n\nIt is important as it helps to execute all concurrent threads while being in sync. It prevents memory consistency errors due to access to shared memory. An example of synchronization code is-\n\npublic synchronized void increment() { a++; }\n\nAs we have synchronized this function, this thread can only use the object after the previous thread has used it.\n\nQ31. Explain the term “Double Brace Initialization” in Java?\n\nDouble Brace Initialization is a Java term that refers to the combination of two independent processes. There are two braces used in this. The first brace creates an anonymous inner class. The second brace is an initialization block. When these both are used together, it is known as Double Brace Initialization. The inner class has a reference to the enclosing outer class, generally using the ‘this’ pointer. It is used to do both creation and initialization in a single statement. It is generally used to initialize collections. It reduces the code and also makes it more readable.\n\nQ32. Why is it said that the length() method of String class doesn’t return accurate results?\n\nThe length() method of String class doesn’t return accurate results because\n\nit simply takes into account the number of characters within in the String. In other words, code points outside of the BMP (Basic Multilingual Plane), that is, code points having a value of U+10000 or above, will be ignored.\n\nThe reason for this is historical. One of Java’s original goals was to consider all text as Unicode; yet, Unicode did not define code points outside of the BMP at the time. It was too late to modify char by the time Unicode specified such code points.\n\nQ33. What are the differences between Heap and Stack Memory in Java?\n\nThe major difference between Heap and Stack memory are:\n\nQ34. What is a package in Java? List down various advantages of packages.\n\nPackages in Java, are the collection of related classes and interfaces which are bundled together. By using packages, developers can easily modularize the code and optimize its reuse. Also, the code within the packages can be imported by other classes and reused. Below I have listed down a few of its advantages:\n\nPackages help in avoiding name clashes\n\nThey provide easier access control on the code\n\nPackages can also contain hidden classes which are not visible to the outer classes and only used within the package\n\nCreates a proper hierarchical structure which makes it easier to locate the related classes\n\nQ35. Why pointers are not used in Java?\n\nJava doesn’t use pointers because they are unsafe and increases the complexity of the program. Since, Java is known for its simplicity of code, adding the concept of pointers will be contradicting. Moreover, since JVM is responsible for implicit memory allocation, thus in order to avoid direct access to memory by the user, pointers are discouraged in Java.\n\nQ36. What is JIT compiler in Java?\n\nJIT stands for Just-In-Time compiler in Java. It is a program that helps in converting the Java bytecode into instructions that are sent directly to the processor. By default, the JIT compiler is enabled in Java and is activated whenever a Java method is invoked. The JIT compiler then compiles the bytecode of the invoked method into native machine code, compiling it “just in time” to execute. Once the method has been compiled, the JVM summons the compiled code of that method directly rather than interpreting it. This is why it is often responsible for the performance optimization of Java applications at the run time.\n\nQ37. What are access modifiers in Java?\n\nIn Java, access modifiers are special keywords which are used to restrict the access of a class, constructor, data member and method in another class. Java supports four types of access modifiers:\n\nDefault\n\nPrivate\n\nProtected\n\nPublic\n\nModifierDefaultPrivateProtectedPublicSame classYESYESYESYESSame Package subclassYESNOYESYESSame Package non-subclassYESNOYESYESDifferent package subclassNONOYESYESDifferent package non-subclassNONONOYES\n\nQ38. Define a Java Class.\n\nA class in Java is a blueprint which includes all your data. A class contains fields (variables) and methods to describe the behavior of an object. Let’s have a look at the syntax of a class.\n\nclass Abc { member variables // class body methods}\n\nQ41. What are the main concepts of OOPs in Java?\n\nObject-Oriented Programming or OOPs is a programming style that is associated with concepts like:\n\nInheritance: Inheritance is a process where one class acquires the properties of another.\n\nEncapsulation: Encapsulation in Java is a mechanism of wrapping up the data and code together as a single unit.\n\nAbstraction: Abstraction is the methodology of hiding the implementation details from the user and only providing the functionality to the users.\n\nPolymorphism: Polymorphism is the ability of a variable, function or object to take multiple forms.\n\nQ42. What is the difference between a local variable and an instance variable?\n\nIn Java, a local variable is typically used inside a method, constructor, or a block and has only local scope. Thus, this variable can be used only within the scope of a block. The best benefit of having a local variable is that other methods in the class won’t be even aware of that variable.\n\nExample\n\nif(x &gt; 100) { String test = \"Edureka\"; }\n\nWhereas, an instance variable in Java, is a variable which is bounded to its object itself. These variables are declared within a class, but outside a method. Every object of that class will create it’s own copy of the variable while using it. Thus, any changes made to the variable won’t reflect in another instances of that class and will be bound to that particular instance only.\n\nclass Test{ public String EmpName; public int empAge; }\n\nQ43. Differentiate between the constructors and methods in Java?\n\nMethodsConstructors1. Used to represent the behavior of an object1. Used to initialize the state of an object2. Must have a return type2. Do not have any return type3. Needs to be invoked explicitly3. Is invoked implicitly4. No default method is provided by the compiler4. A default constructor is provided by the compiler if the class has none5. Method name may or may not be same as class name5. Constructor name must always be the same as the class name\n\nQ44. What is final keyword in Java?\n\nfinal is a special keyword in Java that is used as a non-access modifier. A final variable can be used in different contexts such as:\n\nfinal variable\n\nWhen the final keyword is used with a variable then its value can’t be changed once assigned. In case the no value has been assigned to the final variable then using only the class constructor a value can be assigned to it.\n\nfinal method\n\nWhen a method is declared final then it can’t be overridden by the inheriting class.\n\nfinal class\n\nWhen a class is declared as final in Java, it can’t be extended by any subclass class but it can extend other class.\n\nQ45. What is the difference between break and continue statements?\n\nbreakcontinue1. Can be used in switch and loop (for, while, do while) statements1. Can be only used with loop statements2. It causes the switch or loop statements to terminate the moment it is executed2. It doesn’t terminate the loop but causes the loop to jump to the next iteration3. It terminates the innermost enclosing loop or switch immediately3. A continue within a loop nested with a switch will cause the next loop iteration to execute\n\nfor (int i = 0; i &lt; 5; i++) { if (i == 3) { break; } System.out.println(i); }\n\nfor (int i = 0; i &lt; 5; i++) { if(i == 2) { continue; } System.out.println(i); }\n\nQ46. What is an infinite loop in Java? Explain with an example.\n\nAn infinite loop is an instruction sequence in Java that loops endlessly when a functional exit isn’t met. This type of loop can be the result of a programming error or may also be a deliberate action based on the application behavior. An infinite loop will terminate automatically once the application exits.\n\nFor example:\n\npublic class InfiniteForLoopDemo { public static void main(String[] arg) { for(;;) System.out.println(\"Welcome to Edureka!\"); // To terminate this program press ctrl + c in the console. } }\n\nQ47. What is the difference between this() and super() in Java?\n\nIn Java, super() and this(), both are special keywords that are used to call the constructor.\n\nthis()super()1. this() represents the current instance of a class1. super() represents the current instance of a parent/base class2. Used to call the default constructor of the same class2. Used to call the default constructor of the parent/base class3. Used to access methods of the current class3. Used to access methods of the base class4. Used for pointing the current class instance4. Used for pointing the superclass instance5. Must be the first line of a block5. Must be the first line of a block\n\nFactorStringStringBuilderStringBufferStorage AreaConstant String PoolHeap AreaHeap AreaMutabilityImmutableMutableMutableThread SafetyYesNoYesPerformanceFastMore efficientLess efficient\n\nIf you think this article is helpful, you can check out Edureka’s Java Training in Chennai as well.\n\nJava OOPS Interview Questions\n\nQ56. What is Polymorphism?\n\nPolymorphism is briefly described as “one interface, many implementations”. Polymorphism is a characteristic of being able to assign a different meaning or usage to something in different contexts – specifically, to allow an entity such as a variable, a function, or an object to have more than one form. There are two types of polymorphism:\n\nCompile time polymorphism\n\nRun time polymorphism\n\nCompile time polymorphism is method overloading whereas Runtime time polymorphism is done using inheritance and interface.\n\nQ57. What is runtime polymorphism or dynamic method dispatch?\n\nIn Java, runtime polymorphism or dynamic method dispatch is a process in which a call to an overridden method is resolved at runtime rather than at compile-time. In this process, an overridden method is called through the reference variable of a superclass. Let’s take a look at the example below to understand it better.\n\nclass Car { void run() { System.out.println(\"Car is running\"); } } class Audi extends Car { void run() { System.out.prinltn(\"Audi is running safely at 100km/h\"); } public static void main(String args[]) { Car b= new Audi(); //upcasting b.run(); } }\n\nQ58. What is abstraction in Java?\n\nAbstraction refers to the quality of dealing with ideas rather than events. It basically deals with hiding the details and showing the essential things to the user. Thus you can say that abstraction in Java is the process of hiding the implementation details from the user and revealing only the functionality to them. Abstraction can be achieved in two ways:\n\nAbstract Classes (0-100% of abstraction can be achieved)\n\nInterfaces (100% of abstraction can be achieved)\n\nQ59. What do you mean by an interface in Java?\n\nAn interface in Java is a blueprint of a class or you can say it is a collection of abstract methods and static constants. In an interface, each method is public and abstract but it does not contain any constructor. Thus, interface basically is a group of related methods with empty bodies. Example:\n\npublic interface Animal { public void eat(); public void sleep(); public void run(); }\n\nQ60. What is the difference between abstract classes and interfaces?\n\nQ61. What is inheritance in Java?\n\nInheritance in Java is the concept where the properties of one class can be inherited by the other. It helps to reuse the code and establish a relationship between different classes. Inheritance is performed between two types of classes:\n\nParent class (Super or Base class)\n\nChild class (Subclass or Derived class)\n\nA class which inherits the properties is known as Child Class whereas a class whose properties are inherited is known as Parent class.\n\nQ62. What are the different types of inheritance in Java?\n\nJava supports four types of inheritance which are:\n\nSingle Inheritance: In single inheritance, one class inherits the properties of another i.e there will be only one parent as well as one child class.\n\nMultilevel Inheritance: When a class is derived from a class which is also derived from another class, i.e. a class having more than one parent class but at different levels, such type of inheritance is called Multilevel Inheritance.\n\nHierarchical Inheritance: When a class has more than one child classes (subclasses) or in other words, more than one child classes have the same parent class, then such kind of inheritance is known as hierarchical.\n\nHybrid Inheritance: Hybrid inheritance is a combination of two or more types of inheritance.\n\nQ63. What is method overloading and method overriding?\n\nMethod Overloading :\n\nIn Method Overloading, Methods of the same class shares the same name but each method must have a different number of parameters or parameters having different types and order.\n\nMethod Overloading is to “add” or “extend” more to the method’s behavior.\n\nIt is a compile-time polymorphism.\n\nThe methods must have a different signature.\n\nIt may or may not need inheritance in Method Overloading.\n\nLet’s take a look at the example below to understand it better.\n\nclass Adder { Static int add(int a, int b) { return a+b; } Static double add( double a, double b) { return a+b; } public static void main(String args[]) { System.out.println(Adder.add(11,11)); System.out.println(Adder.add(12.3,12.6)); }}\n\nMethod Overriding:\n\nIn Method Overriding, the subclass has the same method with the same name and exactly the same number and type of parameters and same return type as a superclass.\n\nMethod Overriding is to “Change” existing behavior of the method.\n\nIt is a run time polymorphism.\n\nThe methods must have the same signature.\n\nIt always requires inheritance in Method Overriding.\n\nLet’s take a look at the example below to understand it better.\n\nclass Car { void run(){ System.out.println(\"Car is running\"); } Class Audi extends Car{ void run() { System.out.prinltn(\"Audi is running safely at 100 km/h\"); } public static void main( String args[]) { Car b=new Audi(); b.run(); } }\n\nQ64. Can you override a private or static method in Java?\n\nYou cannot override a private or static method in Java. If you create a similar method with the same return type and same method arguments in child class then it will hide the superclass method; this is known as method hiding. Similarly, you cannot override a private method in subclass because it’s not accessible there. What you can do is create another private method with the same name in the child class. Let’s take a look at the example below to understand it better.\n\nclass Base { private static void display() { System.out.println(\"Static or class method from Base\"); } public void print() { System.out.println(\"Non-static or instance method from Base\"); } class Derived extends Base { private static void display() { System.out.println(\"Static or class method from Derived\"); } public void print() { System.out.println(\"Non-static or instance method from Derived\"); } public class test { public static void main(String args[]) { Base obj= new Derived(); obj1.display(); obj1.print(); } }\n\nQ65. What is multiple inheritance? Is it supported by Java?\n\nIf a child class inherits the property from multiple classes is known as multiple inheritance. Java does not allow to extend multiple classes.\n\nThe problem with multiple inheritance is that if multiple parent classes have the same method name, then at runtime it becomes difficult for the compiler to decide which method to execute from the child class.\n\nTherefore, Java doesn’t support multiple inheritance. The problem is commonly referred to as Diamond Problem.\n\nforward() methodSendRedirect() methodforward() sends the same request to another resource.sendRedirect() method sends new request always because it uses the URL bar of the browser. forward() method works at server side. sendRedirect() method works at client side. forward() method works within the server only.sendRedirect() method works within and outside the server.\n\nQ78. What is the life-cycle of a servlet?\n\nThere are 5 stages in the lifecycle of a servlet:\n\nServlet is loaded\n\nServlet is instantiated\n\nServlet is initialized\n\nService the request\n\nServlet is destroyed\n\nQ79. How does cookies work in Servlets?\n\nCookies are text data sent by server to the client and it gets saved at the client local machine.\n\nServlet API provides cookies support through javax.servlet.http.Cookie class that implements Serializable and Cloneable interfaces.\n\nHttpServletRequest getCookies() method is provided to get the array of Cookies from request, since there is no point of adding Cookie to request, there are no methods to set or add cookie to request.\n\nSimilarly HttpServletResponse addCookie(Cookie c) method is provided to attach cookie in response header, there are no getter methods for cookie.\n\nQ80. What are the differences between ServletContext vs ServletConfig?\n\nThe difference between ServletContext and ServletConfig in Servlets JSP is in below tabular format.\n\nQ81. What are the different methods of session management in servlets?\n\nSession is a conversational state between client and server and it can consists of multiple request and response between client and server. Since HTTP and Web Server both are stateless, the only way to maintain a session is when some unique information about the session (session id) is passed between server and client in every request and response.\n\nSome of the common ways of session management in servlets are:\n\nUser Authentication\n\nHTML Hidden Field\n\nCookies\n\nURL Rewriting\n\nSession Management API\n\nApart from this blog, if you want to get trained by professionals on this technology, you can opt for structured training from edureka! Click below to know more.\n\nJDBC – Java Basic Interview Questions\n\nQ82. What is JDBC Driver?\n\nJDBC Driver is a software component that enables java application to interact with the database. There are 4 types of JDBC drivers:\n\nJDBC-ODBC bridge driver\n\nNative-API driver (partially java driver)\n\nNetwork Protocol driver (fully java driver)\n\nThin driver (fully java driver)\n\nQ83. What are the steps to connect to a database in java?\n\nRegistering the driver class\n\nCreating connection\n\nCreating statement\n\nExecuting queries\n\nClosing connection\n\nQ84. What are the JDBC API components?\n\nThe java.sql package contains interfaces and classes for JDBC API.\n\nInterfaces:\n\nConnection\n\nStatement\n\nPreparedStatement\n\nResultSet\n\nResultSetMetaData\n\nDatabaseMetaData\n\nCallableStatement etc.\n\nClasses:\n\nDriverManager\n\nBlob\n\nClob\n\nTypes\n\nSQLException etc.\n\nQ85. What is the role of JDBC DriverManager class?\n\nThe DriverManager class manages the registered drivers. It can be used to register and unregister drivers. It provides factory method that returns the instance of Connection.\n\nQ86. What is JDBC Connection interface?\n\nThe Connection interface maintains a session with the database. It can be used for transaction management. It provides factory methods that returns the instance of Statement, PreparedStatement, CallableStatement and DatabaseMetaData.\n\nQ87. What is the purpose of JDBC ResultSet interface?\n\nThe ResultSet object represents a row of a table. It can be used to change the cursor pointer and get the information from the database.\n\nQ88. What is JDBC ResultSetMetaData interface?\n\nThe ResultSetMetaData interface returns the information of table such as total number of columns, column name, column type etc.\n\nQ89. What is JDBC DatabaseMetaData interface?\n\nThe DatabaseMetaData interface returns the information of the database such as username, driver name, driver version, number of tables, number of views etc.\n\nQ90. What do you mean by batch processing in JDBC?\n\nBatch processing helps you to group related SQL statements into a batch and execute them instead of executing a single query. By using batch processing technique in JDBC, you can execute multiple queries which makes the performance faster.\n\nQ91. What is the difference between execute, executeQuery, executeUpdate?\n\nStatement execute(String query) is used to execute any SQL query and it returns TRUE if the result is an ResultSet such as running Select queries. The output is FALSE when there is no ResultSet object such as running Insert or Update queries. We can use getResultSet() to get the ResultSet and getUpdateCount() method to retrieve the update count.\n\nStatement executeQuery(String query) is used to execute Select queries and returns the ResultSet. ResultSet returned is never null even if there are no records matching the query. When executing select queries we should use executeQuery method so that if someone tries to execute insert/update statement it will throw java.sql.SQLException with message “executeQuery method can not be used for update”.\n\nStatement executeUpdate(String query) is used to execute Insert/Update/Delete (DML) statements or DDL statements that returns nothing. The output is int and equals to the row count for SQL Data Manipulation Language (DML) statements. For DDL statements, the output is 0.\n\nYou should use execute() method only when you are not sure about the type of statement else use executeQuery or executeUpdate method.\n\nQ92. What do you understand by JDBC Statements?\n\nJDBC statements are basically the statements which are used to send SQL commands to the database and retrieve data back from the database. Various methods like execute(), executeUpdate(), executeQuery, etc. are provided by JDBC to interact with the database.\n\nJDBC supports 3 types of statements:\n\nStatement: Used for general purpose access to the database and executes a static SQL query at runtime.\n\nPreparedStatement: Used to provide input parameters to the query during execution.\n\nCallableStatement: Used to access the database stored procedures and helps in accepting runtime parameters.\n\nSpring Framework Java Interview Questions\n\nQ93. What is Spring?\n\nWikipedia defines the Spring framework as “an application framework and inversion of control container for the Java platform. The framework’s core features can be used by any Java application, but there are extensions for building web applications on top of the Java EE platform.” Spring is essentially a lightweight, integrated framework that can be used for developing enterprise applications in java.\n\nQ94. Name the different modules of the Spring framework.\n\nSome of the important Spring Framework modules are:\n\nSpring Context – for dependency injection.\n\nSpring AOP – for aspect oriented programming.\n\nSpring DAO – for database operations using DAO pattern\n\nSpring JDBC – for JDBC and DataSource support.\n\nSpring ORM – for ORM tools support such as Hibernate\n\nSpring Web Module – for creating web applications.\n\nSpring MVC – Model-View-Controller implementation for creating web applications, web services etc.\n\nQ95. List some of the important annotations in annotation-based Spring configuration.\n\nThe important annotations are:\n\n@Required\n\n@Autowired\n\n@Qualifier\n\n@Resource\n\n@PostConstruct\n\n@PreDestroy\n\nQ96. Explain Bean in Spring and List the different Scopes of Spring bean.\n\nBeans are objects that form the backbone of a Spring application. They are managed by the Spring IoC container. In other words, a bean is an object that is instantiated, assembled, and managed by a Spring IoC container.\n\nThere are five Scopes defined in Spring beans.\n\nSingleton: Only one instance of the bean will be created for each container. This is the default scope for the spring beans. While using this scope, make sure spring bean doesn’t have shared instance variables otherwise it might lead to data inconsistency issues because it’s not thread-safe.\n\nPrototype: A new instance will be created every time the bean is requested.\n\nRequest: This is same as prototype scope, however it’s meant to be used for web applications. A new instance of the bean will be created for each HTTP request.\n\nSession: A new bean will be created for each HTTP session by the container.\n\nGlobal-session: This is used to create global session beans for Portlet applications.\n\nQ97. How we can set the spring bean scope? And what supported scopes does it have?\n\nIn Spring framework, the scope of a bean determines the lifecycle and visibility of the bean instance within the container. You can set the scope of a Spring bean using the `@Scope` annotation or the XML configuration.\n\nTo set the scope using the `@Scope` annotation, you can specify it on the bean class or the bean definition method within a configuration class. Here’s an example:\n\nimport org.springframework.context.annotation.Bean; import org.springframework.context.annotation.Configuration; import org.springframework.context.annotation.Scope; @Configuration public class MyConfig { @Bean @Scope(\"singleton\") public MyBean singletonBean() { return new MyBean(); 8 @Bean @Scope(\"prototype\") public MyBean prototypeBean() { return new MyBean(); } }\n\nIn this example, the `singletonBean` method is annotated with `@Scope(“singleton”)`, indicating that the bean will have a singleton scope. The `prototypeBean` method is annotated with `@Scope(“prototype”)`, specifying a prototype scope.\n\nAlternatively, you can configure bean scopes using XML configuration. Here’s an example:\n\n&lt;bean id=\"singletonBean\" class=\"com.example.MyBean\" scope=\"singleton\"&gt; &lt;bean id=\"prototypeBean\" class=\"com.example.MyBean\" scope=\"prototype\"&gt;\n\nThe supported bean scopes in Spring are:\n\nSingleton (default): Only one instance of the bean is created per Spring container. It is cached and reused for subsequent requests.\n\nPrototype: A new instance of the bean is created every time it is requested.\n\nRequest: A new instance of the bean is created for each HTTP request in a web application context.\n\nSession: A new instance of the bean is created for each HTTP session in a web application context.\n\nGlobal session: Similar to the session scope, but used in a Portlet context (not commonly used).\n\nApplication: A single instance of the bean is created per ServletContext in a web application context (not commonly used).\n\nWebsocket: A new instance of the bean is created for each WebSocket connection in a web application context.\n\nNote that the availability of certain scopes depends on the type of application context you are using (e.g., web application context).\n\nQ98. Explain the role of DispatcherServlet and ContextLoaderListener.\n\nDispatcherServlet is basically the front controller in the Spring MVC application as it loads the spring bean configuration file and initializes all the beans that have been configured. If annotations are enabled, it also scans the packages to configure any bean annotated with @Component, @Controller, @Repository or @Service annotations.\n\nContextLoaderListener, on the other hand, is the listener to start up and shut down the WebApplicationContext in Spring root. Some of its important functions includes tying up the lifecycle of Application Context to the lifecycle of the ServletContext and automating the creation of ApplicationContext.\n\nQ99. What is the best way to inject dependency? Also, state the reason\n\nThe best way to inject dependencies in an application is through constructor injection. Constructor injection involves passing dependencies as parameters to a class’s constructor. Here are the reasons why constructor injection is considered the best approach:\n\nExplicit dependencies: Constructor injection makes dependencies explicit, as they are clearly defined as constructor parameters. This improves code readability and makes it easier to understand the class’s dependencies.\n\nCompile-time safety: With constructor injection, dependencies are resolved at compile-time rather than runtime. This allows for early detection of missing or incorrect dependencies, reducing the chances of runtime errors.\n\nTestability: Constructor injection facilitates easy testing of classes by allowing for the injection of mock or stub dependencies during unit testing. By providing test doubles through the constructor, you can isolate the class under test and verify its behavior without relying on real dependencies.\n\nImmutability: Constructor injection promotes immutability as dependencies can be declared as final or read-only. Immutable objects are generally easier to reason about and less prone to bugs related to state changes.\n\nDependency inversion principle: Constructor injection adheres to the Dependency Inversion Principle (DIP) of the SOLID principles. DIP states that high-level modules should not depend on low-level modules, but both should depend on abstractions. Constructor injection allows for the injection of abstractions rather than concrete implementations, enabling flexibility and loose coupling between classes.\n\nWhile other dependency injection techniques like setter injection and field injection exist, they have certain drawbacks compared to constructor injection. Setter injection can lead to optional dependencies or unexpected null values, while field injection tightly couples classes and makes it harder to identify dependencies. Hence, constructor injection is generally recommended as the best way to inject dependencies.\n\nQ100. What are the differences between constructor injection and setter injection?\n\nNo.Constructor InjectionSetter Injection 1) No Partial Injection Partial Injection 2) Doesn’t override the setter property Overrides the constructor property if both are defined. 3)Creates a new instance if any modification occursDoesn’t create a new instance if you change the property value 4) Better for too many properties Better for a few properties.\n\nQ101. What is autowiring in Spring? What are the autowiring modes?\n\nAutowiring enables the programmer to inject the bean automatically. We don’t need to write explicit injection logic. Let’s see the code to inject bean using dependency injection.\n\n<bean id=“emp” class=“com.javatpoint.Employee” autowire=“byName” />\n\nThe autowiring modes are given below:\n\nNo.ModeDescription 1) no this is the default mode, it means autowiring is not enabled. 2) byName Injects the bean based on the property name. It uses setter method. 3) byType Injects the bean based on the property type. It uses setter method. 4) constructor It injects the bean using constructor\n\nQ102. How to handle exceptions in Spring MVC Framework?\n\nSpring MVC Framework provides the following ways to help us achieving robust exception handling.\n\nController Based:\n\nWe can define exception handler methods in our controller classes. All we need is to annotate these methods with @ExceptionHandler annotation.\n\nGlobal Exception Handler:\n\nException Handling is a cross-cutting concern and Spring provides @ControllerAdvice annotation that we can use with any class to define our global exception handler.\n\nHandlerExceptionResolver implementation:\n\nFor generic exceptions, most of the times we serve static pages. Spring Framework provides HandlerExceptionResolver interface that we can implement to create global exception handler. The reason behind this additional way to define global exception handler is that Spring framework also provides default implementation classes that we can define in our spring bean configuration file to get spring framework exception handling benefits.\n\nQ103. What are some of the important Spring annotations which you have used?\n\nSome of the Spring annotations that I have used in my project are:\n\n@Controller – for controller classes in Spring MVC project.\n\n@RequestMapping – for configuring URI mapping in controller handler methods. This is a very important annotation, so you should go through Spring MVC RequestMapping Annotation Examples\n\n@ResponseBody – for sending Object as response, usually for sending XML or JSON data as response.\n\n@PathVariable – for mapping dynamic values from the URI to handler method arguments.\n\n@Autowired – for autowiring dependencies in spring beans.\n\n@Qualifier – with @Autowired annotation to avoid confusion when multiple instances of bean type is present.\n\n@Service – for service classes.\n\n@Scope – for configuring the scope of the spring bean.\n\n@Configuration, @ComponentScan and @Bean – for java based configurations.\n\nAspectJ annotations for configuring aspects and advices , @Aspect, @Before, @After, @Around, @Pointcut, etc.\n\nCheck out JavaScript Interview Questions as well.\n\nQ104. How to integrate Spring and Hibernate Frameworks?\n\nWe can use Spring ORM module to integrate Spring and Hibernate frameworks if you are using Hibernate 3+ where SessionFactory provides current session, then you should avoid using HibernateTemplate or HibernateDaoSupport classes and better to use DAO pattern with dependency injection for the integration.\n\nAlso, Spring ORM provides support for using Spring declarative transaction management, so you should utilize that rather than going for hibernate boiler-plate code for transaction management.\n\nQ105. Name the types of transaction management that Spring supports.\n\nTwo types of transaction management are supported by Spring. They are:\n\nProgrammatic transaction management: In this, the transaction is managed with the help of programming. It provides you extreme flexibility, but it is very difficult to maintain.\n\nDeclarative transaction management: In this, transaction management is separated from the business code. Only annotations or XML based configurations are used to manage the transactions.\n\nHibernate – Java Interview Questions for Experienced Professionals\n\nQ106. What is Hibernate Framework?\n\nObject-relational mapping or ORM is the programming technique to map application domain model objects to the relational database tables. Hibernate is Java-based ORM tool that provides a framework for mapping application domain objects to the relational database tables and vice versa.\n\nHibernate provides a reference implementation of Java Persistence API, that makes it a great choice as ORM tool with benefits of loose coupling. We can use the Hibernate persistence API for CRUD operations. Hibernate framework provide option to map plain old java objects to traditional database tables with the use of JPA annotations as well as XML based configuration.\n\nSimilarly, hibernate configurations are flexible and can be done from XML configuration file as well as programmatically.\n\nQ107. What are the important benefits of using Hibernate Framework?\n\nSome of the important benefits of using hibernate framework are:\n\nHibernate eliminates all the boiler-plate code that comes with JDBC and takes care of managing resources, so we can focus on business logic.\n\nHibernate framework provides support for XML as well as JPA annotations, that makes our code implementation independent.\n\nHibernate provides a powerful query language (HQL) that is similar to SQL. However, HQL is fully object-oriented and understands concepts like inheritance, polymorphism, and association.\n\nHibernate is an open source project from Red Hat Community and used worldwide. This makes it a better choice than others because learning curve is small and there are tons of online documentation and help is easily available in forums.\n\nHibernate is easy to integrate with other Java EE frameworks, it’s so popular that Spring Framework provides built-in support for integrating hibernate with Spring applications.\n\nHibernate supports lazy initialization using proxy objects and perform actual database queries only when it’s required.\n\nHibernate cache helps us in getting better performance.\n\nFor database vendor specific feature, hibernate is suitable because we can also execute native sql queries.\n\nOverall hibernate is the best choice in current market for ORM tool, it contains all the features that you will ever need in an ORM tool.\n\nQ108. Explain Hibernate architecture.\n\nHibernate has a layered architecture which helps the user to operate without having to know the underlying APIs. Hibernate makes use of the database and configuration data to provide persistence services (and persistent objects) to the application. It includes many objects such as persistent object, session factory, transaction factory, connection factory, session, transaction etc.\n\nThe Hibernate architecture is categorized in four layers.\n\nJava application layer\n\nHibernate framework layer\n\nBackhand API layer\n\nDatabase layer\n\nQ109. What are the differences between get and load methods?\n\nThe differences between get() and load() methods are given below.\n\nNo.get()load() 1) Returns null if object is not found.Throws ObjectNotFoundException if an object is not found. 2) get() method always hit the database. load() method doesn’t hit the database. 3) It returns a real object, not a proxy. It returns a proxy object. 4)It should be used if you are not sure about the existence of instance.It should be used if you are sure that the instance exists.\n\nQ103. What are the advantages of Hibernate over JDBC?\n\nSome of the important advantages of Hibernate framework over JDBC are:\n\nHibernate removes a lot of boiler-plate code that comes with JDBC API, the code looks cleaner and readable.\n\nHibernate supports inheritance, associations, and collections. These features are not present with JDBC API.\n\nHibernate implicitly provides transaction management, in fact, most of the queries can’t be executed outside transaction. In JDBC API, we need to write code for transaction management using commit and rollback.\n\nJDBC API throws SQLException that is a checked exception, so we need to write a lot of try-catch block code. Most of the times it’s redundant in every JDBC call and used for transaction management. Hibernate wraps JDBC exceptions and throw JDBCException or HibernateException un-checked exception, so we don’t need to write code to handle it. Hibernate built-in transaction management removes the usage of try-catch blocks.\n\nHibernate Query Language (HQL) is more object-oriented and close to Java programming language. For JDBC, we need to write native SQL queries.\n\nHibernate supports caching that is better for performance, JDBC queries are not cached hence performance is low.\n\nHibernate provides option through which we can create database tables too, for JDBC tables must exist in the database.\n\nHibernate configuration helps us in using JDBC like connection as well as JNDI DataSource for the connection pool. This is a very important feature in enterprise application and completely missing in JDBC API.\n\nHibernate supports JPA annotations, so the code is independent of the implementation and easily replaceable with other ORM tools. JDBC code is very tightly coupled with the application.\n\nJSP – Core Java Interview Questions\n\nQ110. What are the life-cycle methods for a jsp?\n\nMethodsDescription public void jspInit()It is invoked only once, same as init method of servlet.public void _jspService(ServletRequest request,ServletResponse)throws ServletException,IOExceptionIt is invoked at each request, same as service() method of servlet. public void jspDestroy()It is invoked only once, same as destroy() method of servlet.\n\nQ111. What are the JSP implicit objects?\n\nJSP provides 9 implicit objects by default. They are as follows:\n\nObjectType1) out JspWriter2) request HttpServletRequest3) response HttpServletResponse4) config ServletConfig5) session HttpSession6) application ServletContext7) pageContext PageContext8) page Object9) exception Throwable\n\nQ112. What are the differences between include directive and include action?\n\ninclude directiveinclude actionThe include directive includes the content at page translation time.The include action includes the content at request time.The include directive includes the original content of the page so page size increases at runtime.The include action doesn’t include the original content rather invokes the include() method of Vendor provided class. It’s better for static pages. It’s better for dynamic pages.\n\nQ113. How to disable caching on back button of the browser?\n\n&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;lt;% response.setHeader(\"Cache-Control\", \"no-store\"); response.setHeader(\"Pragma\", \"no-cache\"); response.setHeader(\"Expires\", \"0\"); // Prevents caching at the proxy server %&amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;amp;gt;\n\nQ114. What are the different tags provided in JSTL?\n\nThere are 5 type of JSTL tags.\n\ncore tags\n\nsql tags\n\nxml tags\n\ninternationalization tags\n\nfunctions tags\n\nQ115. How to disable session in JSP?\n\n<%@ page session=“false” %>\n\nQ116. How to delete a Cookie in a JSP?\n\nThe following code explains how to delete a Cookie in a JSP :\n\nCookie mycook = new Cookie(\"name1\",\"value1\"); response.addCookie(mycook1); Cookie killmycook = new Cookie(\"mycook1\",\"value1\"); killmycook . set MaxAge ( 0 ); killmycook . set Path (\"/\"); killmycook . addCookie ( killmycook 1 );\n\nQ117. Explain the jspDestroy() method.\n\njspDestry() method is invoked from javax.servlet.jsp.JspPage interface whenever a JSP page is about to be destroyed. Servlets destroy methods can be easily overridden to perform cleanup, like when closing a database connection.\n\nQ118. How is JSP better than Servlet technology?\n\nJSP is a technology on the server’s side to make content generation simple. They are document-centric, whereas servlets are programs. A Java server page can contain fragments of Java program, which execute and instantiate Java classes. However, they occur inside an HTML template file. It provides the framework for the development of a Web Application.\n\nQ119. What are the different categories of Java Design patterns?\n\nJava Design patterns can be broadly categorized into three main categories: creational patterns, structural patterns, and behavioral patterns. Let’s explore each category in more detail:\n\nCreational Patterns: These patterns deal with object creation mechanisms, providing ways to create objects in a flexible and reusable manner. Some common creational patterns include:\n\n– Singleton: Ensures that only one instance of a class is created and provides a global point of access to it.\n\n– Factory Method: Defines an interface for creating objects, but lets subclasses decide which class to instantiate.\n\n– Abstract Factory: Provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\nStructural Patterns: These patterns focus on the composition of classes and objects, defining how they can be structured to form larger structures while keeping the system flexible and efficient. Some examples of structural patterns include:\n\n– Adapter: Converts the interface of a class into another interface that clients expect.\n\n– Decorator: Dynamically adds new behaviors or responsibilities to an object.\n\n– Composite: Treats a group of objects as a single object, allowing clients to treat individual objects and compositions uniformly.\n\nBehavioral Patterns: These patterns address the interaction and communication between objects, defining how they collaborate and fulfill their responsibilities. Some common behavioral patterns are:\n\n– Observer: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\n\n– Strategy: Defines a family of algorithms, encapsulates each one, and makes them interchangeable at runtime.\n\n– Command: Encapsulates a request as an object, allowing you to parameterize clients with queues, requests, and operations.\n\nThese divisions offer a methodical approach to categorize and comprehend many Java design patterns. It is noteworthy that certain design patterns might fall into more than one category or have variants and combinations, and that these categories are not exclusive of one another. Other design patterns that fall outside of these categories include concurrency patterns and architectural patterns, both of which are applicable to Java programming.\n\nQ120. Why should we not configure JSP standard tags in web.xml?\n\nWe don’t need to configure JSP standard tags in web.xml because when container loads the web application and find TLD files, it automatically configures them to be used directly in the application JSP pages. We just need to include it in the JSP page using taglib directive.\n\nQ121. How will you use JSP EL in order to get the HTTP method name?\n\nUsing pageContext JSP EL implicit object you can get the request object reference and make use of the dot operator to retrieve the HTTP method name in the JSP page. The JSP EL code for this purpose will look like ${pageContext.request.method}.\n\nException and Thread Java Interview Questions for Experienced Professionals\n\nQ122. What is the difference between Error and Exception?\n\nAn error is an irrecoverable condition occurring at runtime. Such as OutOfMemory error. These JVM errors you cannot repair them at runtime. Though error can be caught in the catch block but the execution of application will come to a halt and is not recoverable.\n\nWhile exceptions are conditions that occur because of bad input or human error etc. e.g. FileNotFoundException will be thrown if the specified file does not exist. Or a NullPointerException will take place if you try using a null reference. In most of the cases it is possible to recover from an exception (probably by giving the user feedback for entering proper values etc.\n\nQ123. How can you handle Java exceptions?\n\nThere are five keywords used to handle exceptions in Java:\n\ntry\n\ncatch\n\nfinally\n\nthrow\n\nthrows\n\nQ124. What are the differences between Checked Exception and Unchecked Exception?\n\nChecked Exception\n\nThe classes that extend Throwable class except RuntimeException and Error are known as checked exceptions.\n\nChecked exceptions are checked at compile-time.\n\nExample: IOException, SQLException etc.\n\nUnchecked Exception\n\nThe classes that extend RuntimeException are known as unchecked exceptions.\n\nUnchecked exceptions are not checked at compile-time.\n\nExample: ArithmeticException, NullPointerException etc.\n\nQ125. What are the different ways of thread usage?\n\nThere are two ways to create a thread:\n\nExtending Thread class\n\nThis creates a thread by creating an instance of a new class that extends the Thread class. The extending class must override the run() function, which is the thread’s entry point.\n\nImplementing Runnable interface\n\nThis is the easiest way to create a thread, by creating a class that implements the runnable interface. After implementing the runnable interface, the class must implement the public void run() method ()\n\nThe run() method creates a parallel thread in your programme. When run() returns, the thread will come to an end.\n\nThe run() method creates a parallel thread in your programme. When run() returns, the thread will come to an end.\n\nWithin the run() method, you must specify the thread’s code.\n\nLike any other method, the run() method can call other methods, use other classes, and define variables.\n\nQ126. Java works as “pass by value” or “pass by reference” phenomenon?\n\nJava is always pass-by-value. This means that it creates a copy of the contents of the parameter in memory. In Java, object variables always refer to the memory heap’s real object.\n\nQ126. Will the finally block get executed when the return statement is written at the end of try block and catch block as shown below?\n\nThe finally block always gets executed even hen the return statement is written at the end of the try block and the catch block. It always executes , whether there is an exception or not. There are only a few situations in which the finally block does not execute, such as VM crash, power failure, software crash, etc. If you don’t want to execute the finally block, you need to call the System.exit() method explicitly in the finally block.\n\nQ127. How does an exception propagate in the code?\n\nIf an exception is not caught, it is thrown from the top of the stack and falls down the call stack to the previous procedure. If the exception isn’t caught there, it falls back to the previous function, and so on, until it’s caught or the call stack reaches the bottom. The term for this is Exception propagation.\n\nQ128. Can you explain the Java thread lifecycle?\n\nThe java thread lifecycle has the following states-\n\nNew-\n\nWhen a thread is created, and before the program starts the thread, it is in the new state. It is also referred to as a born thread.\n\nRunnable\n\nWhen a thread is started, it is in the Runnable state. In this state, the thread is executing its task.\n\nWaiting\n\nSometimes, a thread goes to the waiting state, where it remains idle because another thread is executing. When the other thread has finished, the waiting thread again comes into the running state.\n\nTimed Waiting\n\nIn timed waiting, the thread goes to waiting state. But, it remains in waiting state for only a specified interval of time after which it starts executing.It remains waiting either till the time interval ends or till the other thread has finished.\n\nTerminated\n\nA thread is said to be in this state once it terminates. It may be because the thread has completed its task or due to any other reason.\n\nQ129. What purpose do the keywords final, finally, and finalize fulfill?\n\nFinal:\n\nFinal is used to apply restrictions on class, method, and variable. A final class can’t be inherited, final method can’t be overridden and final variable value can’t be changed. Let’s take a look at the example below to understand it better.\n\nclass FinalVarExample { public static void main( String args[]) { final int a=10; // Final variable a=50; //Error as value can't be changed }\n\nFinally\n\nFinally is used to place important code, it will be executed whether the exception is handled or not. Let’s take a look at the example below to understand it better.\n\nclass FinallyExample { public static void main(String args[]){ try { int x=100; } catch(Exception e) { System.out.println(e); } finally { System.out.println(\"finally block is executing\");} }} }\n\nFinalize\n\nFinalize is used to perform clean up processing just before the object is garbage collected. Let’s take a look at the example below to understand it better.\n\nclass FinalizeExample { public void finalize() { System.out.println(\"Finalize is called\"); } public static void main(String args[]) { FinalizeExample f1=new FinalizeExample(); FinalizeExample f2=new FinalizeExample(); f1= NULL; f2=NULL; System.gc(); } }\n\nQ130. What are the differences between throw and throws?\n\nthrow keywordthrows keywordThrow is used to explicitly throw an exception.Throws is used to declare an exception.Checked exceptions can not be propagated with throw only.Checked exception can be propagated with throws.Throw is followed by an instance.Throws is followed by class.Throw is used within the method.Throws is used with the method signature.You cannot throw multiple exceptionYou can declare multiple exception e.g. public void method()throws IOException,SQLException.\n\nQ131. What is exception hierarchy in java?\n\nThe hierarchy is as follows:\n\nThrowable is a parent class of all Exception classes. There are two types of Exceptions: Checked exceptions and UncheckedExceptions or RunTimeExceptions. Both type of exceptions extends Exception class whereas errors are further classified into Virtual Machine error and Assertion error.\n\nQ132. How to create a custom Exception?\n\nTo create you own exception extend the Exception class or any of its subclasses.\n\nclass New1Exception extends Exception { } // this will create Checked Exception\n\nclass NewException extends IOException { } // this will create Checked exception\n\nclass NewException extends NullPonterExcpetion { } // this will create UnChecked exception\n\nQ133. What are the important methods of Java Exception Class?\n\nException and all of it’s subclasses doesn’t provide any specific methods and all of the methods are defined in the base class Throwable.\n\nString getMessage() – This method returns the message String of Throwable and the message can be provided while creating the exception through it’s constructor.\n\nString getLocalizedMessage() – This method is provided so that subclasses can override it to provide locale specific message to the calling program. Throwable class implementation of this method simply use getMessage() method to return the exception message.\n\nSynchronized Throwable getCause() – This method returns the cause of the exception or null id the cause is unknown.\n\nString toString() – This method returns the information about Throwable in String format, the returned String contains the name of Throwable class and localized message.\n\nvoid printStackTrace() – This method prints the stack trace information to the standard error stream, this method is overloaded and we can pass PrintStream or PrintWriter as an argument to write the stack trace information to the file or stream.\n\nQ134. What are the differences between processes and threads?\n\nPointsProcessThreadDefinitionAn executing instance of a program is called a process.A thread is a subset of the process.CommunicationProcesses must use inter-process communication to communicate with sibling processes.Threads can directly communicate with other threads of its process.ControlProcesses can only exercise control over child processes.Threads can exercise considerable control over threads of the same process.ChangesAny change in the parent process does not affect child processes.Any change in the main thread may affect the behavior of the other threads of the process.MemoryRun in separate memory spaces.Run in shared memory spaces.Controlled byProcess is controlled by the operating system.Threads are controlled by programmer in a program.DependenceProcesses are independent.Threads are dependent.\n\nQ135. What is a finally block? Is there a case when finally will not execute?\n\nFinally block is a block which always executes a set of statements. It is always associated with a try block regardless of any exception that occurs or not.\n\nYes, finally will not be executed if the program exits either by calling System.exit() or by causing a fatal error that causes the process to abort.\n\nQ136. What is synchronization?\n\nSynchronization refers to multi-threading. A synchronized block of code can be executed by only one thread at a time. As Java supports execution of multiple threads, two or more threads may access the same fields or objects. Synchronization is a process which keeps all concurrent threads in execution to be in sync. Synchronization avoids memory consistency errors caused due to inconsistent view of shared memory. When a method is declared as synchronized the thread holds the monitor for that method’s object. If another thread is executing the synchronized method the thread is blocked until that thread releases the monitor.\n\nQ137. Can we write multiple catch blocks under single try block?\n\nYes we can have multiple catch blocks under single try block but the approach should be from specific to general. Let’s understand this with a programmatic example.\n\npublic class Example { public static void main(String args[]) { try { int a[]= new int[10]; a[10]= 10/0; } catch(ArithmeticException e) { System.out.println(\"Arithmetic exception in first catch block\"); } catch(ArrayIndexOutOfBoundsException e) { System.out.println(\"Array index out of bounds in second catch block\"); } catch(Exception e) { System.out.println(\"Any exception in third catch block\"); } }\n\nQ133. What are the important methods of Java Exception Class?\n\nMethods are defined in the base class Throwable. Some of the important methods of Java exception class are stated below.\n\nString getMessage() – This method returns the message String about the exception. The message can be provided through its constructor.\n\npublic StackTraceElement[] getStackTrace() – This method returns an array containing each element on the stack trace. The element at index 0 represents the top of the call stack whereas the last element in the array represents the method at the bottom of the call stack.\n\nSynchronized Throwable getCause() – This method returns the cause of the exception or null id as represented by a Throwable object.\n\nString toString() – This method returns the information in String format. The returned String contains the name of Throwable class and localized message.\n\nvoid printStackTrace() – This method prints the stack trace information to the standard error stream.\n\nQ138. What is OutOfMemoryError in Java?\n\nOutOfMemoryError is the subclass of java.lang.Error which generally occurs when our JVM runs out of memory.\n\nQ139. What is a Thread?\n\nA thread is the smallest piece of programmed instructions which can be executed independently by a scheduler. In Java, all the programs will have at least one thread which is known as the main thread. This main thread is created by the JVM when the program starts its execution. The main thread is used to invoke the main() of the program.\n\nSo this brings us to the end of the blog. The topics that you learned in this Core Java Interview Questions blog are the most sought-after skill sets that recruiters look for in a Java Professional. This set of Interview Questions will definitely help you ace your job interview. Good luck with your interview!\n\nGot a question for us? Please mention it in the comments section of this and we will get back to you as soon as possible."
    }
}