{
    "id": "dbpedia_705_2",
    "rank": 43,
    "data": {
        "url": "https://www.wireshark.org/docs/wsug_html/",
        "read_more_link": "",
        "language": "en",
        "title": "Wireshark User’s Guide",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.wireshark.org/docs/wsug_html/images/warning.svg",
            "https://www.wireshark.org/docs/wsug_html/images/caution.svg",
            "https://www.wireshark.org/docs/wsug_html/images/important.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-main.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/warning.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-main.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-file-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-edit-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-view-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-go-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-analyze-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-statistics-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-telephony-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-wireless-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tools-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-help-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-main-toolbar.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-start.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-stop.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-restart.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-options.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/document-open.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-file-save.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-file-close.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-file-reload.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/edit-find.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/go-previous.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/go-next.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/go-jump.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/go-first.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/go-last.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-stay-last.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-colorize-packets.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/zoom-in.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/zoom-out.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/zoom-original.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-resize-columns.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-reset-layout_2.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-filter-toolbar.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-bookmark.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-input.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-clear.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-apply.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-recent.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-add.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-list-pane.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-first.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-current.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-other.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-last.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-request.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-response.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-ack.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-dup-ack.png",
            "https://www.wireshark.org/docs/wsug_html/images/related-segment.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-details-pane.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-bytes-pane.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-bytes-pane-tabs.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-diagram-pane.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-statusbar-empty.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-statusbar-loaded.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-statusbar-profile.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-statusbar-selected.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-statusbar-filter.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-interfaces-main-win32.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-interfaces-main-macos.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-options.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-options.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/x-capture-options.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-options-output.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-options-options.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-manage-interfaces.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-options-compile-selected-bpfs.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-options-output.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-info.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-open-win32.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-open-qt5.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-save-as-win32.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-save-as-qt5.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-merge-win32.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-merge-qt5.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-file-import.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-file-import-regex.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-file-set-dialog.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-export-specified-packets.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-export-packet-dissections.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-export-selected.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-export-pdus-to-file.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tls-session-keys.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-export-objects.png",
            "https://www.wireshark.org/docs/wsug_html/images/warning.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-print.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-packet-range.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-packet-format.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-packet-selected.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-packet-sep-win.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-column-header-popup-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-packet-pane-popup-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-details-pane-popup-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-bytes-pane-popup-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-diagram-pane-popup-menu.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-display-filter-tcp.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-filter-add-expression.png",
            "https://www.wireshark.org/docs/wsug_html/images/toolbar/filter-toolbar-bookmark.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-filters.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-filter-macros.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-find-packet.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-goto-packet.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-time-reference.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-time-shift.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-time-shift-details.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-follow-stream.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-follow-http2-stream.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-follow-sip-stream.png",
            "https://www.wireshark.org/docs/wsug_html/images/warning.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-expert-information.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-expert-colored-tree.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-expert-column.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tcp-analysis.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-bytes-pane-tabs.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-capture-file-properties.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-resolved-addr.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-hierarchy.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-conversations.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-endpoints.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-packet-lengths.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-iographs.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-srt-smb2.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-netperfmeter-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-dns.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-flow-graph.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-seq-dialog.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-http-requestsequences.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-udp-multicast-stream.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-asap-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-enrp-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-csp-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-calcappprotocol-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-fgp-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pingpongprotocol-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-ssp-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-about-codecs.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtp-player_button.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-playlist.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-voip-calls.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-lte-mac-traffic.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-rlc-graph.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-lte-rlc-traffic.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtp-streams.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtpstream-analysis_1.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtpstream-analysis_3.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtpstream-analysis_2.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtp-player_1.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtp-player_3.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-tel-rtp-player_2.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-sctp-1-association.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-sctp.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-bluetooth-devices.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-bt-hci-summary.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-stats-wlan-traffic.png",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-coloring-rules-dialog.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-choose-color-rule.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-coloring-fields.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-enabled-protocols.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-decode-as.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-appearance.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-appearance-columns.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-appearance-fonts-and-colors.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-appearance-layout.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-capture.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-expert.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-filter-buttons.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-name-resolution.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-protocols.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-rsa-keys.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-statistics.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-pref-advanced.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-gui-config-profiles.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-wireless-ieee-80211-pref.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-wireless-key-type.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/warning.svg",
            "https://www.wireshark.org/docs/wsug_html/images/ws-wireless-key-examples.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-tcp-output.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-analysis.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-dns_pane.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-dns_pdu.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-isup_over_mtp3_over_ip.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-ftp_over_gre.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-mmse_over_http.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-pdu_analysis.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-gop_analysis.png",
            "https://www.wireshark.org/docs/wsug_html/images/ws-mate-transform.png",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/tip.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg",
            "https://www.wireshark.org/docs/wsug_html/images/note.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Richard Sharpe",
            "Ed Warnicke",
            "Ulf Lamping"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Chapter 7. Advanced Topics\n\nTable of Contents\n\n7.1. Introduction\n\n7.2. Following Protocol Streams\n\n7.3. Show Packet Bytes\n\n7.4. Expert Information\n\n7.4.1. Expert Information Entries\n\n7.4.2. The “Expert Information” Dialog\n\n7.4.3. “Colorized” Protocol Details Tree\n\n7.4.4. “Expert” Packet List Column (Optional)\n\n7.5. TCP Analysis\n\n7.6. Time Stamps\n\n7.6.1. Wireshark Internals\n\n7.6.2. Capture File Formats\n\n7.6.3. Accuracy\n\n7.7. Time Zones\n\n7.7.1. Wireshark and Time Zones\n\n7.8. Packet Reassembly\n\n7.8.1. What Is It?\n\n7.8.2. How Wireshark Handles It\n\n7.8.3. TCP Reassembly\n\n7.9. Name Resolution\n\n7.9.1. Name Resolution Drawbacks\n\n7.9.2. Ethernet Name Resolution (MAC Layer)\n\n7.9.3. IP Name Resolution (Network Layer)\n\n7.9.4. TCP/UDP Port Name Resolution (Transport Layer)\n\n7.9.5. VLAN ID Resolution\n\n7.9.6. SS7 Point Code Resolution\n\n7.10. Checksums\n\n7.10.1. Wireshark Checksum Validation\n\n7.10.2. Checksum Offloading\n\n7.10.3. Partial Checksums\n\n7.1. Introduction\n\nThis chapter will describe some of Wireshark’s advanced features.\n\n7.2. Following Protocol Streams\n\nIt can be very helpful to see a protocol in the way that the application layer sees it. Perhaps you are looking for passwords in a Telnet stream, or you are trying to make sense of a data stream. Maybe you just need a display filter to show only the packets in a TLS or SSL stream. If so, Wireshark’s ability to follow protocol streams will be useful to you.\n\nTo filter to a particular stream, select a TCP, UDP, DCCP, TLS, HTTP, HTTP/2, QUIC or SIP packet in the packet list of the stream/connection you are interested in and then select the menu item Analyze → Follow → TCP Stream (or use the context menu in the packet list). Wireshark will set an appropriate display filter and display a dialog box with the data from the stream laid out, as shown in Figure 7.1, “The “Follow TCP Stream” dialog box”.\n\nFigure 7.1. The “Follow TCP Stream” dialog box\n\nThe stream content is displayed in the same sequence as it appeared on the network. Non-printable characters are replaced by dots. Traffic from the client to the server is colored red, while traffic from the server to the client is colored blue. These colors can be changed by opening Edit → Preferences and under Appearance → Font and Colors, selecting different colors for the Sample \"Follow Stream\" client text and Sample \"Follow Stream\" server text options.\n\nThe stream content won’t be updated while doing a live capture. To get the latest content you’ll have to reopen the dialog.\n\nYou can choose from the following actions:\n\nHelp\n\nShow this help.\n\nFilter out this stream\n\nApply a display filter removing the current stream data from the display.\n\nPrint\n\nPrint the stream data in the currently selected format.\n\nSave as…​\n\nSave the stream data in the currently selected format.\n\nBack\n\nClose this dialog box and restore the previous display filter.\n\nClose\n\nClose this dialog box, leaving the current display filter in effect.\n\nBy default, Wireshark displays both client and server data. You can select the Entire conversation to switch between both, client to server, or server to client data.\n\nYou can choose to view the data in one of the following formats:\n\nASCII\n\nIn this view you see the data from each direction in ASCII. Obviously best for ASCII based protocols, e.g., HTTP.\n\nC Arrays\n\nThis allows you to import the stream data into your own C program.\n\nEBCDIC\n\nFor the big-iron freaks out there.\n\nHEX Dump\n\nThis allows you to see all the data. This will require a lot of screen space and is best used with binary protocols.\n\nUTF-8\n\nLike ASCII, but decode the data as UTF-8.\n\nUTF-16\n\nLike ASCII, but decode the data as UTF-16.\n\nYAML\n\nThis allows you to load the stream as YAML.\n\nThe YAML output is divided into 2 main sections:\n\nThe peers section where for each peer you found the peer index, the host address and the port number.\n\nThe packets section where for each packet you found the packet number in the original capture, the peer index, the packet index for this peer, the timestamp in seconds and the data in base64 encoding.\n\nExample 7.1. Follow Stream YAML output\n\npeers: - peer: 0 host: 127.0.0.1 port: 54048 - peer: 1 host: 127.0.10.1 port: 5000 packets: - packet: 1 peer: 0 index: 0 timestamp: 1599485409.693955274 data: !!binary | aGVsbG8K - packet: 3 peer: 1 index: 0 timestamp: 1599485423.885866692 data: !!binary | Ym9uam91cgo=\n\nThe same example but in old YAML format (before version 3.5):\n\n# Packet 1 peer0_0: !!binary | aGVsbG8K # Packet 3 peer1_0: !!binary | Ym9uam91cgo=\n\nHow the old format data can be found in the new format:\n\nNew YAML format Old YAML format\n\nRaw\n\nThis allows you to load the unaltered stream data into a different program for further examination. The display will show the data as strings of hex characters with each frame on a separate line, but “Save As” will result in a binary file without any added line separators.\n\nYou can optionally show the delta time each time the direction changes (turns) or for every packet or event.\n\nYou can switch between streams using the “Stream” selector.\n\nYou can search for text by entering it in the “Find” entry box and pressing Find Next.\n\nFigure 7.2. The “Follow HTTP/2 Stream” dialog box\n\nThe HTTP/2 Stream dialog is similar to the \"Follow TCP Stream\" dialog, except for an additional \"Substream\" dialog field. HTTP/2 Streams are identified by a HTTP/2 Stream Index (field name http2.streamid) which are unique within a TCP connection. The “Stream” selector determines the TCP connection whereas the “Substream” selector is used to pick the HTTP/2 Stream ID.\n\nThe QUIC protocol is similar, the first number selects the QUIC connection number while the \"Substream\" field selects the QUIC Stream ID.\n\nFigure 7.3. The “Follow SIP Call” dialog box\n\nThe SIP call is shown with same dialog, just filter is based on sip.Call-ID field. Count of streams is fixed to 0 and the field is disabled.\n\n7.3. Show Packet Bytes\n\nIf a selected packet field does not show all the bytes (i.e., they are truncated when displayed) or if they are shown as bytes rather than string or if they require more formatting because they contain an image or HTML then this dialog can be used.\n\nThis dialog can also be used to decode field bytes from base64, various compressed formats or quoted-printable and show the decoded bytes as configurable output. It’s also possible to select a subset of bytes setting the start byte and end byte.\n\nYou can choose from the following actions:\n\nHelp\n\nShow this help.\n\nPrint\n\nPrint the bytes in the currently selected format.\n\nCopy\n\nCopy the bytes to the clipboard in the currently selected format.\n\nSave As\n\nSave the bytes in the currently selected format.\n\nClose\n\nClose this dialog box.\n\nYou can choose to decode the data from one of the following formats:\n\nNone\n\nThis is the default which does not decode anything.\n\nBase64\n\nThis will decode from Base64 or Base64Url.\n\nCompressed\n\nThis will decompress the buffer using lz77, lz77huff, lznt1, snappy, zlib or zstd.\n\nHex Digits\n\nThis will decode from a string of hex digits. Non-hex characters are skipped.\n\nPercent-Encoding\n\nThis will decode from a Percent-Encoded string.\n\nQuoted-Printable\n\nThis will decode from a Quoted-Printable string.\n\nROT-13\n\nThis will decode ROT-13 encoded text.\n\nYou can choose to view the data in one of the following formats:\n\nASCII\n\nIn this view you see the bytes as ASCII. All control characters and non-ASCII bytes are replaced by dot.\n\nASCII & Control\n\nIn this view all control characters are shown using a UTF-8 symbol and all non-ASCII bytes are replaced by dot.\n\nC Array\n\nThis allows you to import the field data into your own C program.\n\nEBCDIC\n\nFor the big-iron freaks out there.\n\nHex Dump\n\nThis allows you to see all the data. This will require a lot of screen space and is best used with binary protocols.\n\nHTML\n\nThis allows you to see all the data formatted as a HTML document. The HTML supported is what’s supported by the Qt QTextEdit class.\n\nImage\n\nThis will try to convert the bytes into an image. Most popular formats are supported including PNG, JPEG, GIF, and BMP.\n\nISO 8859-1\n\nIn this view you see the bytes as ISO 8859-1.\n\nRaw\n\nThis allows you to load the bytes into a different program for further examination. The display will show HEX data, but “Save As” will result in a binary file.\n\nUTF-8\n\nIn this view you see the bytes as UTF-8.\n\nUTF-16\n\nIn this view you see the bytes as UTF-16.\n\nYAML\n\nThis will show the bytes as a YAML binary dump.\n\nYou can search for text by entering it in the “Find” entry box and pressing Find Next.\n\n7.4. Expert Information\n\nWireshark keeps track of any anomalies and other items of interest it finds in a capture file and shows them in the Expert Information dialog. The goal is to give you a better idea of uncommon or notable network behavior and to let novice and expert users find network problems faster than manually scanning through the packet list.\n\nThe amount of expert information largely depends on the protocol being used. While dissectors for some common protocols like TCP and IP will show detailed information, other dissectors will show little or none.\n\nThe following describes the components of a single expert information entry along with the expert user interface.\n\n7.4.1. Expert Information Entries\n\nExpert information entries are grouped by severity level (described below) and contain the following:\n\nTable 7.1. Example expert information items\n\nPacket # Summary Group Protocol\n\n592\n\nTCP: [TCP Out-Of-Order] …​\n\nMalformed\n\nTCP\n\n1202\n\nDNS: Standard query response …​\n\nProtocol\n\nDNS\n\n443\n\nTCP: 80 → 59322 [RST] Seq=12761 Win=0 Len=0\n\nSequence\n\nTCP\n\n7.4.1.1. Severity\n\nEvery expert information item has a severity level. The following levels are used, from lowest to highest. Wireshark marks them using different colors, which are shown in parentheses:\n\nChat (blue)\n\nInformation about usual workflow, e.g., a TCP packet with the SYN flag set.\n\nNote (cyan)\n\nNotable events, e.g., an application returned a common error code such as HTTP 404.\n\nWarn (yellow)\n\nWarnings, e.g., application returned an unusual error code like a connection problem.\n\nError (red)\n\nSerious problems, such as malformed packets.\n\n7.4.1.2. Summary\n\nShort explanatory text for each expert information item.\n\n7.4.1.3. Group\n\nAlong with severity levels, expert information items are categorized by group. The following groups are currently implemented:\n\nAssumption\n\nThe protocol field has incomplete data and was dissected based on assumed value.\n\nChecksum\n\nA checksum was invalid.\n\nComment\n\nPacket comment.\n\nDebug\n\nDebugging information. You shouldn’t see this group in release versions of Wireshark.\n\nDecryption\n\nA decryption issue.\n\nDeprecated\n\nThe protocol field has been deprecated.\n\nMalformed\n\nMalformed packet or dissector has a bug. Dissection of this packet aborted.\n\nProtocol\n\nViolation of a protocol’s specification (e.g., invalid field values or illegal lengths). Dissection of this packet probably continued.\n\nReassemble\n\nProblems while reassembling, e.g., not all fragments were available or an exception happened during reassembly.\n\nRequest Code\n\nAn application request (e.g., File Handle == x). Usually assigned the Chat severity level.\n\nResponse Code\n\nAn application response code indicates a potential problem, e.g., HTTP 404 page not found.\n\nSecurity\n\nA security problem, e.g., an insecure implementation.\n\nSequence\n\nA protocol sequence number was suspicious, e.g., it wasn’t continuous or a retransmission was detected.\n\nUndecoded\n\nDissection incomplete or data can’t be decoded for other reasons.\n\nIt’s possible that more groups will be added in the future.\n\n7.4.1.4. Protocol\n\nThe protocol dissector that created the expert information item.\n\n7.4.2. The “Expert Information” Dialog\n\nYou can open the expert info dialog by selecting Analyze → Expert Info or by clicking the expert level indicator in the main status bar.\n\nRight-clicking on an item will allow you to apply or prepare a filter based on the item, copy its summary text, and other tasks.\n\nFigure 7.4. The “Expert Information” dialog box\n\nYou can choose from the following actions:\n\nLimit to display filter\n\nOnly show expert information items present in packets that match the current display filter.\n\nGroup by summary\n\nGroup items by their summary instead of the groups described above.\n\nSearch\n\nOnly show items that match the search string, such as “dns”. Regular expressions are supported.\n\nShow…​\n\nLets you show or hide each severity level. For example, you can deselect Chat and Note severities if desired.\n\nHelp\n\nTakes you to this section of the User’s Guide.\n\nClose\n\nCloses the dialog\n\n7.4.3. “Colorized” Protocol Details Tree\n\nFigure 7.5. The “Colorized” protocol details tree\n\nThe packet detail tree marks fields with expert information based on their severity level color, e.g., “Warning” severities have a yellow background. This color is propagated to the top-level protocol item in the tree in order to make it easy to find the field that created the expert information.\n\nFor the example screenshot above, the IP “Time to live” value is very low (only 1), so the corresponding protocol field is marked with a cyan background. To make it easier find that item in the packet tree, the IP protocol toplevel item is marked cyan as well.\n\n7.4.4. “Expert” Packet List Column (Optional)\n\nFigure 7.6. The “Expert” packet list column\n\nAn optional “Expert Info Severity” packet list column is available that displays the most significant severity of a packet or stays empty if everything seems OK. This column is not displayed by default but can be easily added using the Preferences Columns page described in Section 11.5, “Preferences”.\n\n7.5. TCP Analysis\n\nBy default, Wireshark’s TCP dissector tracks the state of each TCP session and provides additional information when problems or potential problems are detected. Analysis is done once for each TCP packet when a capture file is first opened. Packets are processed in the order in which they appear in the packet list. You can enable or disable this feature via the “Analyze TCP sequence numbers” TCP dissector preference.\n\nFor analysis of data or protocols layered on top of TCP (such as HTTP), see Section 7.8.3, “TCP Reassembly”.\n\nFigure 7.7. “TCP Analysis” packet detail items\n\nTCP Analysis flags are added to the TCP protocol tree under “SEQ/ACK analysis”. Each flag is described below. Terms such as “next expected sequence number” and “next expected acknowledgment number” refer to the following”:\n\nNext expected sequence number\n\nThe last-seen sequence number plus segment length. Set when there are no analysis flags and for zero window probes. This is initially zero and calculated based on the previous packet in the same TCP flow. Note that this may not be the same as the tcp.nxtseq protocol field.\n\nNext expected acknowledgment number\n\nThe last-seen sequence number for segments. Set when there are no analysis flags and for zero window probes.\n\nLast-seen acknowledgment number\n\nAlways updated for each packet. Note that this is not the same as the next expected acknowledgment number.\n\nTCP ACKed unseen segment\n\nSet when the expected next acknowledgment number is set for the reverse direction and it’s less than the current acknowledgment number.\n\nTCP Dup ACK <frame>#<acknowledgment number>\n\nSet when all of the following are true:\n\nThe segment size is zero.\n\nThe window size is non-zero and hasn’t changed, or there is valid SACK data.\n\nThe next expected sequence number and last-seen acknowledgment number are non-zero (i.e., the connection has been established).\n\nSYN, FIN, and RST are not set.\n\nTCP Fast Retransmission\n\nSet when all of the following are true:\n\nThis is not a keepalive packet.\n\nIn the forward direction, the segment size is greater than zero or the SYN or FIN is set.\n\nThe next expected sequence number is greater than the current sequence number.\n\nWe have at least two duplicate ACKs in the reverse direction.\n\nThe current sequence number equals the next expected acknowledgment number.\n\nWe saw the last acknowledgment less than 20ms ago.\n\nSupersedes “Out-Of-Order” and “Retransmission”.\n\nTCP Keep-Alive\n\nSet when the segment size is zero or one, the current sequence number is one byte less than the next expected sequence number, and none of SYN, FIN, or RST are set.\n\nSupersedes “Fast Retransmission”, “Out-Of-Order”, “Spurious Retransmission”, and “Retransmission”.\n\nTCP Keep-Alive ACK\n\nSet when all of the following are true:\n\nThe segment size is zero.\n\nThe window size is non-zero and hasn’t changed.\n\nThe current sequence number is the same as the next expected sequence number.\n\nThe current acknowledgment number is the same as the last-seen acknowledgment number.\n\nThe most recently seen packet in the reverse direction was a keepalive.\n\nThe packet is not a SYN, FIN, or RST.\n\nSupersedes “Dup ACK” and “ZeroWindowProbeAck”.\n\nTCP Out-Of-Order\n\nSet when all of the following are true:\n\nThis is not a keepalive packet.\n\nIn the forward direction, the segment length is greater than zero or the SYN or FIN is set.\n\nThe next expected sequence number is greater than the current sequence number.\n\nThe next expected sequence number and the next sequence number differ.\n\nThe last segment arrived within the Out-Of-Order RTT threshold. The threshold is either the value shown in the “iRTT” (tcp.analysis.initial_rtt) field under “SEQ/ACK analysis” if it is present, or the default value of 3ms if it is not.\n\nSupersedes “Retransmission”.\n\nTCP Port numbers reused\n\nSet when the SYN flag is set (not SYN+ACK), we have an existing conversation using the same addresses and ports, and the sequence number is different than the existing conversation’s initial sequence number.\n\nTCP Previous segment not captured\n\nSet when the current sequence number is greater than the next expected sequence number.\n\nTCP Spurious Retransmission\n\nChecks for a retransmission based on analysis data in the reverse direction. Set when all of the following are true:\n\nThe SYN or FIN flag is set.\n\nThis is not a keepalive packet.\n\nThe segment length is greater than zero.\n\nData for this flow has been acknowledged. That is, the last-seen acknowledgment number has been set.\n\nThe next sequence number is less than or equal to the last-seen acknowledgment number.\n\nSupersedes “Fast Retransmission”, “Out-Of-Order”, and “Retransmission”.\n\nTCP Retransmission\n\nSet when all of the following are true:\n\nThis is not a keepalive packet.\n\nIn the forward direction, the segment length is greater than zero or the SYN or FIN flag is set.\n\nThe next expected sequence number is greater than the current sequence number.\n\nTCP Window Full\n\nSet when the segment size is non-zero, we know the window size in the reverse direction, and our segment size exceeds the window size in the reverse direction.\n\nTCP Window Update\n\nSet when the all of the following are true:\n\nThe segment size is zero.\n\nThe window size is non-zero and not equal to the last-seen window size, and there is no valid SACK data.\n\nThe sequence number is equal to the next expected sequence number.\n\nThe acknowledgment number is equal to the last-seen acknowledgment number,\n\nor to the next expected sequence number when answering to a ZeroWindowProbe.\n\nNone of SYN, FIN, or RST are set.\n\nTCP ZeroWindow\n\nSet when the receive window size is zero and none of SYN, FIN, or RST are set.\n\nThe window field in each TCP header advertises the amount of data a receiver can accept. If the receiver can’t accept any more data it will set the window value to zero, which tells the sender to pause its transmission. In some specific cases this is normal — for example, a printer might use a zero window to pause the transmission of a print job while it loads or reverses a sheet of paper. However, in most cases this indicates a performance or capacity problem on the receiving end. It might take a long time (sometimes several minutes) to resume a paused connection, even if the underlying condition that caused the zero window clears up quickly.\n\nTCP ZeroWindowProbe\n\nSet when the sequence number is equal to the next expected sequence number, the segment size is one, and last-seen window size in the reverse direction was zero.\n\nIf the single data byte from a Zero Window Probe is dropped by the receiver (not ACKed), then a subsequent segment should not be flagged as retransmission if all of the following conditions are true for that segment: * The segment size is larger than one. * The next expected sequence number is one less than the current sequence number.\n\nThis affects “Fast Retransmission”, “Out-Of-Order”, or “Retransmission”.\n\nTCP ZeroWindowProbeAck\n\nSet when the all of the following are true:\n\nThe segment size is zero.\n\nThe window size is zero.\n\nThe sequence number is equal to the next expected sequence number.\n\nThe acknowledgment number is equal to the last-seen acknowledgment number.\n\nThe last-seen packet in the reverse direction was a zero window probe.\n\nSupersedes “TCP Dup ACK”.\n\nTCP Ambiguous Interpretations\n\nSome captures are quite difficult to analyze automatically, particularly when the time frame may cover both Fast Retransmission and Out-Of-Order packets. A TCP preference allows to switch the precedence of these two interpretations at the protocol level.\n\nTCP Conversation Completeness\n\nTCP conversations are said to be complete when they have both opening and closing handshakes, independently of any data transfer. However, we might be interested in identifying complete conversations with some data sent, and we are using the following bit values to build a filter value on the tcp.completeness field :\n\n1 : SYN\n\n2 : SYN-ACK\n\n4 : ACK\n\n8 : DATA\n\n16 : FIN\n\n32 : RST\n\nFor example, a conversation containing only a three-way handshake will be found with the filter 'tcp.completeness==7' (1+2+4) while a complete conversation with data transfer will be found with a longer filter as closing a connection can be associated with FIN or RST packets, or even both : 'tcp.completeness==31 or tcp.completeness==47 or tcp.completeness==63'\n\nAnother way to select specific conversation values is to filter on individual flags, the summary field, or a combination of them. Thus, '(tcp.completeness.fin==1 || tcp.completeness.rst==1) && tcp.completeness.str contains \"DASS\"' will find all 'Complete, WITH_DATA' conversations, while the 'Complete, NO_DATA' ones will be found with '(tcp.completeness.fin==1 || tcp.completeness.rst==1) && tcp.completeness.data==0 && tcp.completeness.str contains \"ASS\"'.\n\n7.6. Time Stamps\n\nTime stamps, their precisions and all that can be quite confusing. This section will provide you with information about what’s going on while Wireshark processes time stamps.\n\nWhile packets are captured, each packet is time stamped as it comes in. These time stamps will be saved to the capture file, so they also will be available for (later) analysis.\n\nSo where do these time stamps come from? While capturing, Wireshark gets the time stamps from the libpcap (Npcap) library, which in turn gets them from the operating system kernel. If the capture data is loaded from a capture file, Wireshark obviously gets the data from that file.\n\n7.6.1. Wireshark Internals\n\nThe internal format that Wireshark uses to keep a packet time stamp consists of the date (in days since 1.1.1970) and the time of day (in nanoseconds since midnight). You can adjust the way Wireshark displays the time stamp data in the packet list, see the “Time Display Format” item in the Section 3.7, “The “View” Menu” for details.\n\nWhile reading or writing capture files, Wireshark converts the time stamp data between the capture file format and the internal format as required.\n\nWhile capturing, Wireshark uses the libpcap (Npcap) capture library which supports nanosecond resolution for both pcapng and pcap files, though some devices may only provide microsecond resolution, in which case that will be used. Unless you are working with specialized capturing hardware, this resolution should be adequate.\n\n7.6.2. Capture File Formats\n\nThe vast majority of capture file formats that Wireshark knows support time stamps. The time stamp precision supported by a specific capture file format differs widely and varies from one second “0” to one nanosecond “0.123456789”. Most file formats store the time stamps with a fixed precision (e.g., microseconds, “0.123456”), while some file formats are capable of storing the time stamp precision itself or even having a different precision for different records in the file (whatever the benefit may be).\n\nThe pcapng capture file format supports a wide range of time stamp resolutions, which can be different for each interface in the file, as well as records without time stamps. The common libpcap capture file format, which is widely supported by many other tools, supports two possible fixed resolutions, microsecond or nanosecond, indicated by a magic number at the start of the file. Wireshark and tools like editcap can convert pcap files with nanosecond resolution to microsecond resolution for use with tools that only support the original time stamp precision.\n\nWriting data into a capture file format that doesn’t provide the capability to store the actual precision will lead to loss of information. For example, if you load a capture file with nanosecond resolution and store the capture data in a libpcap file (with microsecond resolution) Wireshark obviously must reduce the precision from nanosecond to microsecond.\n\n7.6.3. Accuracy\n\nPeople often ask “Which time stamp accuracy is provided by Wireshark?”. Well, Wireshark doesn’t create any time stamps itself but simply gets them from “somewhere else” and displays them. So accuracy will depend on the capture system (operating system, performance, etc.) that you use. Because of this, the above question is difficult to answer in a general way.\n\n7.7. Time Zones\n\nIf you travel across the planet, time zones can be confusing. If you get a capture file from somewhere around the world time zones can even be a lot more confusing ;-)\n\nFirst of all, there are two reasons why you may not need to think about time zones at all:\n\nYou are only interested in the time differences between the packet time stamps and don’t need to know the exact date and time of the captured packets (which is often the case).\n\nYou don’t get capture files from different time zones than your own, so there are simply no time zone problems. For example, everyone in your team is working in the same time zone as yourself.\n\nWhat are time zones?\n\nPeople expect that the time reflects the sunset. Dawn should be in the morning maybe around 06:00 and dusk in the evening maybe at 20:00. These times will obviously vary depending on the season. It would be very confusing if everyone on earth would use the same global time as this would correspond to the sunset only at a small part of the world.\n\nFor that reason, the earth is split into several different time zones, each zone with a local time that corresponds to the local sunset.\n\nThe time zone’s base time is UTC (Coordinated Universal Time) or Zulu Time (military and aviation). The older term GMT (Greenwich Mean Time) shouldn’t be used as it is slightly incorrect (up to 0.9 seconds difference to UTC). The UTC base time equals to 0 (based at Greenwich, England) and all time zones have an offset to UTC between -12 to +14 hours!\n\nFor example: If you live in Berlin, you are in a time zone one hour earlier than UTC, so you are in time zone “+1” (time difference in hours compared to UTC). If it’s 3 o’clock in Berlin it’s 2 o’clock in UTC “at the same moment”.\n\nBe aware that at a few places on earth don’t use time zones with even hour offsets (e.g., New Delhi uses UTC+05:30)!\n\nFurther information can be found at: https://en.wikipedia.org/wiki/Time_zone and https://en.wikipedia.org/wiki/Coordinated_Universal_Time.\n\nWhat is daylight saving time (DST)?\n\nDaylight Saving Time (DST), also known as Summer Time is intended to “save” some daylight during the summer months. To do this, a lot of countries (but not all!) add a DST hour to the already existing UTC offset. So you may need to take another hour (or in very rare cases even two hours!) difference into your “time zone calculations”.\n\nUnfortunately, the date at which DST actually takes effect is different throughout the world. You may also note, that the northern and southern hemispheres have opposite DST’s (e.g., while it’s summer in Europe it’s winter in Australia).\n\nKeep in mind: UTC remains the same all year around, regardless of DST!\n\nFurther information can be found at https://en.wikipedia.org/wiki/Daylight_saving.\n\nFurther time zone and DST information can be found at https://wwp.greenwichmeantime.com/ and https://www.timeanddate.com/worldclock/.\n\nSet your computer’s time correctly!\n\nIf you work with people around the world it’s very helpful to set your computer’s time and time zone right.\n\nYou should set your computers time and time zone in the correct sequence:\n\nSet your time zone to your current location\n\nSet your computer’s clock to the local time\n\nThis way you will tell your computer both the local time and also the time offset to UTC. Many organizations simply set the time zone on their servers and networking gear to UTC in order to make coordination and troubleshooting easier.\n\nYou can use the Network Time Protocol (NTP) to automatically adjust your computer to the correct time, by synchronizing it to Internet NTP clock servers. NTP clients are available for all operating systems that Wireshark supports (and for a lot more), for examples see http://www.ntp.org/.\n\n7.7.1. Wireshark and Time Zones\n\nSo what’s the relationship between Wireshark and time zones anyway?\n\nWireshark’s native capture file format (libpcap format), and some other capture file formats, such as the Windows Sniffer, *Peek, Sun snoop formats, and newer versions of the Microsoft Network Monitor and Network Instruments/Viavi Observer formats, save the arrival time of packets as UTC values. UN*X systems, and “Windows NT based” systems represent time internally as UTC. When Wireshark is capturing, no conversion is necessary. However, if the system time zone is not set correctly, the system’s UTC time might not be correctly set even if the system clock appears to display correct local time. When capturing, Npcap has to convert the time to UTC before supplying it to Wireshark. If the system’s time zone is not set correctly, that conversion will not be done correctly.\n\nOther capture file formats, such as the OOS-based Sniffer format and older versions of the Microsoft Network Monitor and Network Instruments/Viavi Observer formats, save the arrival time of packets as local time values.\n\nInternally to Wireshark, time stamps are represented in UTC. This means that when reading capture files that save the arrival time of packets as local time values, Wireshark must convert those local time values to UTC values.\n\nWireshark in turn will display the time stamps always in local time. The displaying computer will convert them from UTC to local time and displays this (local) time. For capture files saving the arrival time of packets as UTC values, this means that the arrival time will be displayed as the local time in your time zone, which might not be the same as the arrival time in the time zone in which the packet was captured. For capture files saving the arrival time of packets as local time values, the conversion to UTC will be done using your time zone’s offset from UTC and DST rules, which means the conversion will not be done correctly; the conversion back to local time for display might undo this correctly, in which case the arrival time will be displayed as the arrival time in which the packet was captured.\n\nTable 7.2. Time zone examples for UTC arrival times (without DST)\n\nLos Angeles New York Madrid London Berlin Tokyo\n\nCapture File (UTC)\n\n10:00\n\n10:00\n\n10:00\n\n10:00\n\n10:00\n\n10:00\n\nLocal Offset to UTC\n\n-8\n\n-5\n\n-1\n\n0\n\n+1\n\n+9\n\nDisplayed Time (Local Time)\n\n02:00\n\n05:00\n\n09:00\n\n10:00\n\n11:00\n\n19:00\n\nFor example, let’s assume that someone in Los Angeles captured a packet with Wireshark at exactly 2 o’clock local time and sends you this capture file. The capture file’s time stamp will be represented in UTC as 10 o’clock. You are located in Berlin and will see 11 o’clock on your Wireshark display.\n\nNow you have a phone call, video conference or Internet meeting with that one to talk about that capture file. As you are both looking at the displayed time on your local computers, the one in Los Angeles still sees 2 o’clock but you in Berlin will see 11 o’clock. The time displays are different as both Wireshark displays will show the (different) local times at the same point in time.\n\nConclusion: You may not bother about the date/time of the time stamp you currently look at unless you must make sure that the date/time is as expected. So, if you get a capture file from a different time zone and/or DST, you’ll have to find out the time zone/DST difference between the two local times and “mentally adjust” the time stamps accordingly. In any case, make sure that every computer in question has the correct time and time zone setting.\n\n7.8. Packet Reassembly\n\n7.8.1. What Is It?\n\nNetwork protocols often need to transport large chunks of data which are complete in themselves, e.g., when transferring a file. The underlying protocol might not be able to handle that chunk size (e.g., limitation of the network packet size), or is stream-based like TCP, which doesn’t know data chunks at all.\n\nIn that case the network protocol has to handle the chunk boundaries itself and (if required) spread the data over multiple packets. It obviously also needs a mechanism to determine the chunk boundaries on the receiving side.\n\nWireshark calls this mechanism reassembly, although a specific protocol specification might use a different term for this (e.g., desegmentation, defragmentation, etc.).\n\n7.8.2. How Wireshark Handles It\n\nFor some of the network protocols Wireshark knows of, a mechanism is implemented to find, decode and display these chunks of data. Wireshark will try to find the corresponding packets of this chunk, and will show the combined data as additional tabs in the “Packet Bytes” pane (for information about this pane. See Section 3.20, “The “Packet Bytes” Pane”).\n\nFigure 7.8. The “Packet Bytes” pane with a reassembled tab\n\nReassembly might take place at several protocol layers, so it’s possible that multiple tabs in the “Packet Bytes” pane appear.\n\nFor example, in a HTTP GET response, the requested data (e.g., an HTML page) is returned. Wireshark will show the hex dump of the data in a new tab “Uncompressed entity body” in the “Packet Bytes” pane.\n\nReassembly is enabled in the preferences by default but can be disabled in the preferences for the protocol in question. Enabling or disabling reassembly settings for a protocol typically requires two things:\n\nThe lower-level protocol (e.g., TCP) must support reassembly. Often this reassembly can be enabled or disabled via the protocol preferences.\n\nThe higher-level protocol (e.g., HTTP) must use the reassembly mechanism to reassemble fragmented protocol data. This too can often be enabled or disabled via the protocol preferences.\n\nThe tooltip of the higher-level protocol setting will notify you if and which lower-level protocol setting also has to be considered.\n\n7.8.3. TCP Reassembly\n\nProtocols such as HTTP or TLS are likely to span multiple TCP segments. The TCP protocol preference “Allow subdissector to reassemble TCP streams” (enabled by default) makes it possible for Wireshark to collect a contiguous sequence of TCP segments and hand them over to the higher-level protocol (for example, to reconstruct a full HTTP message). All but the final segment will be marked with “[TCP segment of a reassembled PDU]” in the packet list.\n\nDisable this preference to reduce memory and processing overhead if you are only interested in TCP sequence number analysis (Section 7.5, “TCP Analysis”). Keep in mind, though, that higher-level protocols might be wrongly dissected. For example, HTTP messages could be shown as “Continuation” and TLS records could be shown as “Ignored Unknown Record”. Such results can also be observed if you start capturing while a TCP connection was already started or when TCP segments are lost or delivered out-of-order.\n\nTo reassemble of out-of-order TCP segments, the TCP protocol preference “Reassemble out-of-order segments” (currently disabled by default) must be enabled in addition to the previous preference. If all packets are received in-order, this preference will not have any effect. Otherwise (if missing segments are encountered while sequentially processing a packet capture), it is assuming that the new and missing segments belong to the same PDU. Caveats:\n\nLost packets are assumed to be received out-of-order or retransmitted later. Applications usually retransmit segments until these are acknowledged, but if the packet capture drops packets, then Wireshark will not be able to reconstruct the TCP stream. In such cases, you can try to disable this preference and hopefully have a partial dissection instead of seeing just “[TCP segment of a reassembled PDU]” for every TCP segment.\n\nWhen doing a capture in monitor mode (IEEE 802.11), packets are more likely to get lost due to signal reception issues. In that case it is recommended to disable the option.\n\nIf the new and missing segments are in fact part of different PDUs, then processing is currently delayed until no more segments are missing, even if the begin of the missing segments completed a PDU. For example, assume six segments forming two PDUs ABC and DEF. When received as ABECDF, an application can start processing the first PDU after receiving ABEC. Wireshark however requires the missing segment D to be received as well. This issue will be addressed in the future.\n\nIn the GUI and during a two-pass dissection (tshark -2), the previous scenario will display both PDUs in the packet with last segment (F) rather than displaying it in the first packet that has the final missing segment of a PDU. This issue will be addressed in the future.\n\nWhen enabled, fields such as the SMB “Time from request” (smb.time) might be smaller if the request follows other out-of-order segments (this reflects application behavior). If the previous scenario however occurs, then the time of the request is based on the frame where all missing segments are received.\n\nRegardless of the setting of these two reassembly-related preferences, you can always use the “Follow TCP Stream” option (Section 7.2, “Following Protocol Streams”) which displays segments in the expected order.\n\n7.9. Name Resolution\n\nName resolution tries to convert some of the numerical address values into a human readable format. There are two possible ways to do these conversions, depending on the resolution to be done: calling system/network services (like the gethostname() function) and/or resolving from Wireshark specific configuration files. For details about the configuration files Wireshark uses for name resolution and alike, see Appendix B, Files and Folders.\n\nThe name resolution feature can be enabled individually for the protocol layers listed in the following sections.\n\n7.9.1. Name Resolution Drawbacks\n\nName resolution can be invaluable while working with Wireshark and may even save you hours of work. Unfortunately, it also has its drawbacks.\n\nName resolution can often fail. The name to be resolved might simply be unknown by the name servers asked, or the servers are just not available and the name is also not found in Wireshark’s configuration files.\n\nResolved names might not be available. Wireshark obtains name resolution information from a variety of sources, including DNS servers, the capture file itself (e.g., for a pcapng file), and the hosts files on your system and in your profile directory. The resolved names might not be available if you open the capture file later or on a different machine. As a result, each time you or someone else opens a particular capture file it may look slightly different due to changing environments.\n\nDNS may add additional packets to your capture file. You might run into the observer effect if the extra traffic from Wireshark’s DNS queries and responses affects the problem you’re trying to troubleshoot or any subsequent analysis.\n\nThe same sort of thing can happen when capturing over a remote connection, e.g., SSH or RDP.\n\nResolved DNS names are cached by Wireshark. This is required for acceptable performance. However, if the name resolution information should change while Wireshark is running, Wireshark won’t notice a change in the name resolution information once it gets cached. If this information changes while Wireshark is running, e.g., a new DHCP lease takes effect, Wireshark won’t notice it.\n\nName resolution in the packet list is done while the list is filled. If a name can be resolved after a packet is added to the list, its former entry won’t be changed. As the name resolution results are cached, you can use View → Reload to rebuild the packet list with the correctly resolved names. However, this isn’t possible while a capture is in progress.\n\n7.9.2. Ethernet Name Resolution (MAC Layer)\n\nTry to resolve an Ethernet MAC address (e.g., 00:09:5b:01:02:03) to a human readable name.\n\nARP name resolution (system service): Wireshark will ask the operating system to convert an Ethernet address to the corresponding IP address (e.g. 00:09:5b:01:02:03 → 192.168.0.1).\n\nEthernet codes (ethers file): If the ARP name resolution failed, Wireshark tries to convert the Ethernet address to a known device name, which has been assigned by the user using an ethers file (e.g., 00:09:5b:01:02:03 → homerouter).\n\nEthernet manufacturer codes (manuf file): If neither ARP or ethers returns a result, Wireshark tries to convert the first 3 bytes of an ethernet address to an abbreviated manufacturer name, which has been assigned by the IEEE (e.g. 00:09:5b:01:02:03 → Netgear_01:02:03).\n\n7.9.3. IP Name Resolution (Network Layer)\n\nTry to resolve an IP address (e.g., 216.239.37.99) to a human readable name.\n\nDNS name resolution (system/library service): Wireshark will use a name resolver to convert an IP address to the hostname associated with it (e.g., 216.239.37.99 → www.1.google.com).\n\nMost applications use synchronously DNS name resolution. For example, your web browser must resolve the host name portion of a URL before it can connect to the server. Capture file analysis is different. A given file might have hundreds, thousands, or millions of IP addresses so for usability and performance reasons Wireshark uses asynchronous resolution. Both mechanisms convert IP addresses to human readable (domain) names and typically use different sources such as the system hosts file (/etc/hosts) and any configured DNS servers.\n\nSince Wireshark doesn’t wait for DNS responses, the host name for a given address might be missing from a given packet when you view it the first time but be present when you view it subsequent times.\n\nYou can adjust name resolution behavior in the Name Resolution section in the Preferences Dialog. You can control resolution itself by adding a hosts file to your personal configuration directory. You can also edit your system hosts file, but that isn’t generally recommended.\n\n7.9.4. TCP/UDP Port Name Resolution (Transport Layer)\n\nTry to resolve a TCP/UDP port (e.g., 80) to a human readable name.\n\nTCP/UDP port conversion (system service): Wireshark will ask the operating system to convert a TCP or UDP port to its well-known name (e.g., 80 → http).\n\n7.9.5. VLAN ID Resolution\n\nTo get a descriptive name for a VLAN tag ID a vlans file can be used.\n\n7.9.6. SS7 Point Code Resolution\n\nTo get a node name for a SS7 point code a ss7pcs file can be used.\n\n7.10. Checksums\n\nSeveral network protocols use checksums to ensure data integrity. Applying checksums as described here is also known as redundancy checking.\n\nWhat are checksums for?\n\nChecksums are used to ensure the integrity of data portions for data transmission or storage. A checksum is basically a calculated summary of such a data portion.\n\nNetwork data transmissions often produce errors, such as toggled, missing or duplicated bits. As a result, the data received might not be identical to the data transmitted, which is obviously a bad thing.\n\nBecause of these transmission errors, network protocols very often use checksums to detect such errors. The transmitter will calculate a checksum of the data and transmits the data together with the checksum. The receiver will calculate the checksum of the received data with the same algorithm as the transmitter. If the received and calculated checksums don’t match a transmission error has occurred.\n\nSome checksum algorithms are able to recover (simple) errors by calculating where the expected error must be and repairing it.\n\nIf there are errors that cannot be recovered, the receiving side throws away the packet. Depending on the network protocol, this data loss is simply ignored or the sending side needs to detect this loss somehow and retransmits the required packet(s).\n\nUsing a checksum drastically reduces the number of undetected transmission errors. However, the usual checksum algorithms cannot guarantee an error detection of 100%, so a very small number of transmission errors may remain undetected.\n\nThere are several different kinds of checksum algorithms; an example of an often used checksum algorithm is CRC32. The checksum algorithm actually chosen for a specific network protocol will depend on the expected error rate of the network medium, the importance of error detection, the processor load to perform the calculation, the performance needed and many other things.\n\nFurther information about checksums can be found at: https://en.wikipedia.org/wiki/Checksum.\n\n7.10.1. Wireshark Checksum Validation\n\nWireshark will validate the checksums of many protocols, e.g., IP, TCP, UDP, etc.\n\nIt will do the same calculation as a “normal receiver” would do, and shows the checksum fields in the packet details with a comment, e.g., [correct] or [invalid, must be 0x12345678].\n\nChecksum validation can be switched off for various protocols in the Wireshark protocol preferences, e.g., to (very slightly) increase performance.\n\nIf the checksum validation is enabled and it detected an invalid checksum, features like packet reassembly won’t be processed. This is avoided as incorrect connection data could “confuse” the internal database.\n\n7.10.2. Checksum Offloading\n\nThe checksum calculation might be done by the network driver, protocol driver or even in hardware.\n\nFor example: The Ethernet transmitting hardware calculates the Ethernet CRC32 checksum and the receiving hardware validates this checksum. If the received checksum is wrong Wireshark won’t even see the packet, as the Ethernet hardware internally throws away the packet.\n\nHigher-level checksums are “traditionally” calculated by the protocol implementation and the completed packet is then handed over to the hardware.\n\nRecent network hardware can perform advanced features such as IP checksum calculation, also known as checksum offloading. The network driver won’t calculate the checksum itself but will simply hand over an empty (zero or garbage filled) checksum field to the hardware.\n\nChecksum offloading can be confusing and having a lot of [invalid] messages on the screen can be quite annoying. As mentioned above, invalid checksums may lead to unreassembled packets, making the analysis of the packet data much harder.\n\nYou can do two things to avoid this checksum offloading problem:\n\nTurn off the checksum offloading in the network driver, if this option is available.\n\nTurn off checksum validation of the specific protocol in the Wireshark preferences. Recent releases of Wireshark disable checksum validation by default due to the prevalence of offloading in modern hardware and operating systems.\n\n7.10.3. Partial Checksums\n\nTCP and UDP checksums are calculated over both the payload and from selected elements from the IPv4 or IPv6 header, known as the pseudo header. Linux and Windows, when offloading checksums, will calculate the contribution from the pseudo header and place it in the checksum field. The driver then directs the hardware to calculate the checksum over the payload area, which will produce the correct result including the pseudo header’s portion of the sum as a matter of mathematics.\n\nThis precomputation speeds up the hardware checksum calculation later, allows the driver to direct the hardware to do checksums over encapsulated payloads (Local Checksum Offload), and allows applications to send the kernel large \"superpacket\" buffers that will be later divided by the hardware into multiple maximum size packets when sent on the network (TCP Segmentation Offload (TSO) and Generic Segmentation Offload (GSO)).\n\nChapter 11. Customizing Wireshark\n\nTable of Contents\n\n11.1. Introduction\n\n11.2. Start Wireshark from the command line\n\n11.3. Packet colorization\n\n11.4. Control Protocol Dissection\n\n11.4.1. The “Enabled Protocols” dialog box\n\n11.4.2. User Specified Decodes\n\n11.5. Preferences\n\n11.5.1. Appearance\n\n11.5.2. Columns\n\n11.5.3. Font and Colors\n\n11.5.4. Layout\n\n11.5.5. Capture\n\n11.5.6. Expert Items\n\n11.5.7. Filter Buttons\n\n11.5.8. Name Resolution\n\n11.5.9. Protocols\n\n11.5.10. RSA Keys\n\n11.5.11. Statistics\n\n11.5.12. Advanced\n\n11.6. Configuration Profiles\n\n11.6.1. Automatic Profile Switching\n\n11.7. User Accessible Tables\n\n11.8. ESS Category Attributes\n\n11.9. MaxMind Database Paths\n\n11.10. IEEE 802.11 WLAN Decryption Keys\n\n11.10.1. Adding Keys\n\n11.10.2. Gotchas\n\n11.11. IKEv2 decryption table\n\n11.12. Object Identifiers\n\n11.13. PRES Users Context List\n\n11.14. SCCP users Table\n\n11.15. SMI (MIB and PIB) Modules\n\n11.16. SMI (MIB and PIB) Paths\n\n11.17. SNMP Enterprise Specific Trap Types\n\n11.18. SNMP users Table\n\n11.19. Tektronix K12xx/15 RF5 protocols Table\n\n11.20. User DLTs dissector table\n\n11.21. Protobuf Search Paths\n\n11.22. Protobuf UDP Message Types\n\n11.1. Introduction\n\nWireshark’s default behavior will usually suit your needs pretty well. However, as you become more familiar with Wireshark, it can be customized in various ways to suit your needs even better. In this chapter we explore:\n\nHow to start Wireshark with command line parameters\n\nHow to colorize the packet list\n\nHow to control protocol dissection\n\nHow to use the various preference settings\n\n11.2. Start Wireshark from the command line\n\nYou can start Wireshark from the command line, but it can also be started from most Window managers as well. In this section we will look at starting it from the command line.\n\nWireshark supports a large number of command line parameters. To see what they are, simply enter the command wireshark -h and the help information shown in Help information available from Wireshark (or something similar) should be printed.\n\nHelp information available from Wireshark.\n\nWireshark 4.5.0 (v4.5.0rc0-48-g7b7ca8210417) Interactively dump and analyze network traffic. See https://www.wireshark.org for more information. Usage: wireshark [options] ... [ <infile> ] Capture interface: -i <interface>, --interface <interface> name or idx of interface (def: first non-loopback) -f <capture filter> packet filter in libpcap filter syntax -s <snaplen>, --snapshot-length <snaplen> packet snapshot length (def: appropriate maximum) -p, --no-promiscuous-mode don't capture in promiscuous mode -I, --monitor-mode capture in monitor mode, if available -B <buffer size>, --buffer-size <buffer size> size of kernel buffer (def: 2MB) -y <link type>, --linktype <link type> link layer type (def: first appropriate) --time-stamp-type <type> timestamp method for interface -D, --list-interfaces print list of interfaces and exit -L, --list-data-link-types print list of link-layer types of iface and exit --list-time-stamp-types print list of timestamp types for iface and exit Capture display: -k start capturing immediately (def: do nothing) -S update packet display when new packets are captured --update-interval interval between updates with new packets (def: 100ms) -l turn on automatic scrolling while -S is in use Capture stop conditions: -c <packet count> stop after n packets (def: infinite) -a <autostop cond.> ..., --autostop <autostop cond.> ... duration:NUM - stop after NUM seconds filesize:NUM - stop this file after NUM KB files:NUM - stop after NUM files packets:NUM - stop after NUM packets Capture output: -b <ringbuffer opt.> ..., --ring-buffer <ringbuffer opt.> duration:NUM - switch to next file after NUM secs filesize:NUM - switch to next file after NUM KB files:NUM - ringbuffer: replace after NUM files packets:NUM - switch to next file after NUM packets interval:NUM - switch to next file when the time is an exact multiple of NUM secs Input file: -r <infile>, --read-file <infile> set the filename to read from (no pipes or stdin!) Processing: -R <read filter>, --read-filter <read filter> packet filter in Wireshark display filter syntax -n disable all name resolutions (def: all enabled) -N <name resolve flags> enable specific name resolution(s): \"mtndsNvg\" -d <layer_type>==<selector>,<decode_as_protocol> ... \"Decode As\", see the man page for details Example: tcp.port==8888,http --enable-protocol <proto_name> enable dissection of proto_name --disable-protocol <proto_name> disable dissection of proto_name --only-protocols <proto_name> Only enable dissection of these protocols, comma separated. Disable everything else --disable-all-protocols Disable dissection of all protocols --enable-heuristic <short_name> enable dissection of heuristic protocol --disable-heuristic <short_name> disable dissection of heuristic protocol User interface: -C <config profile> start with specified configuration profile -H hide the capture info dialog during packet capture -Y <display filter>, --display-filter <display filter> start with the given display filter -g <packet number> go to specified packet number after \"-r\" -J <jump filter> jump to the first packet matching the (display) filter -j search backwards for a matching packet after \"-J\" -t (a|ad|adoy|d|dd|e|r|u|ud|udoy)[.[N]]|.[N] format of time stamps (def: r: rel. to first) -u s|hms output format of seconds (def: s: seconds) -X <key>:<value> eXtension options, see man page for details -z <statistics> show various statistics, see man page for details Output: -w <outfile|-> set the output filename (or '-' for stdout) -F <capture type> set the output file type; default is pcapng. an empty \"-F\" option will list the file types. --capture-comment <comment> add a capture file comment, if supported --temp-dir <directory> write temporary files to this directory (default: /tmp) Diagnostic output: --log-level <level> sets the active log level (\"critical\", \"warning\", etc.) --log-fatal <level> sets level to abort the program (\"critical\" or \"warning\") --log-domains <[!]list> comma-separated list of the active log domains --log-fatal-domains <list> list of domains that cause the program to abort --log-debug <[!]list> list of domains with \"debug\" level --log-noisy <[!]list> list of domains with \"noisy\" level --log-file <path> file to output messages to (in addition to stderr) Miscellaneous: -h, --help display this help and exit -v, --version display version info and exit -P <key>:<path> persconf:path - personal configuration files persdata:path - personal data files -o <name>:<value> ... override preference or recent setting -K <keytab> keytab file to use for kerberos decryption --display <X display> X display to use --fullscreen start Wireshark in full screen\n\nWe will examine each of the command line options in turn.\n\nThe first thing to notice is that issuing the command wireshark by itself will launch Wireshark. However, you can include as many of the command line parameters as you like. Their meanings are as follows ( in alphabetical order ):\n\n-a <capture autostop condition>, --autostop <capture autostop condition>\n\nSpecify a criterion that specifies when Wireshark is to stop writing to a capture file. The criterion is of the form test:value, where test is one of:\n\nduration:value\n\nStop writing to a capture file after value of seconds have elapsed.\n\nfilesize:value\n\nStop writing to a capture file after it reaches a size of value kilobytes (where a kilobyte is 1000 bytes, not 1024 bytes). If this option is used together with the -b option, Wireshark will stop writing to the current capture file and switch to the next one if filesize is reached.\n\nfiles:value\n\nStop writing to capture files after value number of files were written.\n\npackets:value\n\nStop writing to a capture file after value number of packets were written.\n\n-b <capture ring buffer option>\n\nIf a maximum capture file size was specified, this option causes Wireshark to run in “ring buffer” mode, with the specified number of files. In “ring buffer” mode, Wireshark will write to several capture files. Their name is based on the number of the file and on the creation date and time.\n\nWhen the first capture file fills up Wireshark will switch to writing to the next file, and so on. With the files option it’s also possible to form a “ring buffer.” This will fill up new files until the number of files specified, at which point the data in the first file will be discarded so a new file can be written.\n\nIf the optional duration is specified, Wireshark will also switch to the next file when the specified number of seconds has elapsed even if the current file is not completely filled up.\n\nduration:value\n\nSwitch to the next file after value seconds have elapsed, even if the current file is not completely filled up.\n\nfilesize:value\n\nSwitch to the next file after it reaches a size of value kilobytes (where a kilobyte is 1000 bytes, not 1024 bytes).\n\nfiles:value\n\nBegin again with the first file after value number of files were written (form a ring buffer).\n\npackets:value\n\nSwitch to the next file after value number of packets were written, even if the current file is not completely filled up.\n\ninterval:value\n\nSwitch to the next file when the time is an exact multiple of value seconds.\n\n-B <capture buffer size>, --buffer-size <capture buffer size>\n\nSet capture buffer size (in MB, default is 2MB). This is used by the capture driver to buffer packet data until that data can be written to disk. If you encounter packet drops while capturing, try to increase this size. Not supported on some platforms.\n\n-C <config profile>\n\nStart with the specified configuration profile.\n\n-c <capture packet count>\n\nThis option specifies the maximum number of packets to capture when capturing live data. It would be used in conjunction with the -k option.\n\n--capture-comment <comment>\n\nAdd the comment string to the capture file, if supported by the file format.\n\n-d <layer_type>==<selector>,<decode_as_protocol>\n\n\"Decode As\", see Section 11.4.2, “User Specified Decodes” for details. Example: tcp.port==8888,http\n\n-D, --list-interfaces\n\nPrint a list of the interfaces on which Wireshark can capture, then exit. For each network interface, a number and an interface name, possibly followed by a text description of the interface, is printed. The interface name or the number can be supplied to the -i flag to specify an interface on which to capture.\n\nThis can be useful on systems that don’t have a command to list them (e.g., Windows systems, or UNIX systems lacking ifconfig -a). The number can be especially useful on Windows, where the interface name is a GUID.\n\nNote that “can capture” means that Wireshark was able to open that device to do a live capture. If, on your system, a program doing a network capture must be run from an account with special privileges, then, if Wireshark is run with the -D flag and is not run from such an account, it will not list any interfaces.\n\n--display <DISPLAY>\n\nSet the X display to use, instead of the one defined in the environment, or the default display.\n\n--enable-protocol <proto_name>, --disable-protocol <proto_name>\n\nEnable and disable the dissection of the protocol.\n\n--enable-heuristic <short_name>, --disable-heuristic <short_name>\n\nEnable and disable the dissection of the heuristic protocol.\n\n-f <capture filter>\n\nThis option sets the initial capture filter expression to be used when capturing packets.\n\n--fullscreen\n\nStart Wireshark in full screen.\n\n-g <packet number>\n\nAfter reading in a capture file using the -r flag, go to the given packet number.\n\n-h, --help\n\nThis option requests Wireshark to print its version and usage instructions (as shown here) and exit.\n\n-H\n\nHide the capture info dialog during live packet capture.\n\n-i <capture interface>, --interface <capture interface>\n\nSet the name of the network interface or pipe to use for live packet capture.\n\nNetwork interface names should match one of the names listed in wireshark -D (described above). A number, as reported by wireshark -D, can also be used. If you’re using UNIX, netstat -i, ifconfig -a or ip link might also work to list interface names, although not all versions of UNIX support the -a flag to ifconfig.\n\nIf no interface is specified, Wireshark searches the list of interfaces, choosing the first non-loopback interface if there are any non-loopback interfaces, and choosing the first loopback interface if there are no non-loopback interfaces; if there are no interfaces, Wireshark reports an error and doesn’t start the capture.\n\nPipe names should be either the name of a FIFO (named pipe) or “-” to read data from the standard input. Data read from pipes must be in standard libpcap format.\n\n-J <jump filter>\n\nAfter reading in a capture file using the -r flag, jump to the first packet which matches the filter expression. The filter expression is in display filter format. If an exact match cannot be found the first packet afterwards is selected.\n\n-I, --monitor-mode\n\nCapture wireless packets in monitor mode if available.\n\n-j\n\nUse this option after the -J option to search backwards for a first packet to go to.\n\n-k\n\nThe -k option specifies that Wireshark should start capturing packets immediately. This option requires the use of the -i parameter to specify the interface that packet capture will occur from.\n\n-K <keytab file>\n\nUse the specified file for Kerberos decryption.\n\n-l\n\nThis option turns on automatic scrolling if the packet list pane is being updated automatically as packets arrive during a capture (as specified by the -S flag).\n\n-L, --list-data-link-types\n\nList the data link types supported by the interface and exit.\n\n--list-time-stamp-types\n\nList timestamp types configurable for the interface and exit.\n\n-m <font>\n\nThis option sets the name of the font used for most text displayed by Wireshark.\n\n-n\n\nDisable network object name resolution (such as hostname, TCP and UDP port names).\n\n-N <name resolving flags>\n\nTurns on name resolving for particular types of addresses and port numbers. The argument is a string that may contain the following letters:\n\nN\n\nUse external name resolver.\n\nd\n\nEnable name resolution from captured DNS packets.\n\nm\n\nEnable MAC address resolution.\n\nn\n\nEnable network address resolution.\n\nt\n\nEnable transport layer port number resolution.\n\nv\n\nEnable VLAN ID resolution.\n\n-o <preference or recent settings>\n\nSets a preference or recent value, overriding the default value and any value read from a preference or recent file. The argument to the flag is a string of the form prefname:value, where prefname is the name of the preference (which is the same name that would appear in the preferences or recent file), and value is the value to which it should be set. Multiple instances of `-o <preference settings> ` can be given on a single command line.\n\nAn example of setting a single preference would be:\n\nwireshark -o mgcp.display_dissect_tree:TRUE\n\nAn example of setting multiple preferences would be:\n\nwireshark -o mgcp.display_dissect_tree:TRUE -o mgcp.udp.callagent_port:2627\n\nYou can get a list of all available preference strings from the preferences file. See Appendix B, Files and Folders for details.\n\nUser Accessible Tables can be overridden using “uat,” followed by the UAT file name and a valid record for the file:\n\nwireshark -o \"uat:user_dlts:\\\"User 0 (DLT=147)\\\",\\\"http\\\",\\\"0\\\",\\\"\\\",\\\"0\\\",\\\"\\\"\"\n\nThe example above would dissect packets with a libpcap data link type 147 as HTTP, just as if you had configured it in the DLT_USER protocol preferences.\n\n-p, --no-promiscuous-mode\n\nDon’t put the interface into promiscuous mode. Note that the interface might be in promiscuous mode for some other reason. Hence, -p cannot be used to ensure that the only traffic that is captured is traffic sent to or from the machine on which Wireshark is running, broadcast traffic, and multicast traffic to addresses received by that machine.\n\n-P <path setting>\n\nSpecial path settings usually detected automatically. This is used for special cases, e.g., starting Wireshark from a known location on an USB stick.\n\nThe criterion is of the form key:path, where key is one of:\n\npersconf:path\n\nPath of personal configuration files, like the preferences files.\n\npersdata:path\n\nPath of personal data files, it’s the folder initially opened. After the initialization, the recent file will keep the folder last used.\n\n-r <infile>, --read-file <infile>\n\nThis option provides the name of a capture file for Wireshark to read and display. This capture file can be in one of the formats Wireshark understands.\n\n-R <read (display) filter>, --read-filter <read (display) filter>\n\nThis option specifies a display filter to be applied when reading packets from a capture file. The syntax of this filter is that of the display filters discussed in Section 6.3, “Filtering Packets While Viewing”. Packets not matching the filter are discarded.\n\n-s <capture snapshot length>, --snapshot-length <capture snapshot length>\n\nThis option specifies the snapshot length to use when capturing packets. Wireshark will only capture snaplen bytes of data for each packet.\n\n-S\n\nThis option specifies that Wireshark will display packets as it captures them. This is done by capturing in one process and displaying them in a separate process. This is the same as “Update list of packets in real time” in the “Capture Options” dialog box.\n\n-t <time stamp format>\n\nThis option sets the format of packet timestamps that are displayed in the packet list window. The format can be one of:\n\nr\n\nRelative, which specifies timestamps are displayed relative to the first packet captured.\n\na\n\nAbsolute, which specifies that actual times be displayed for all packets.\n\nad\n\nAbsolute with date, which specifies that actual dates and times be displayed for all packets.\n\nadoy\n\nAbsolute with YYYY/DOY date, which specifies that actual dates and times be displayed for all packets.\n\nd\n\nDelta, which specifies that timestamps are relative to the previous packet.\n\ndd: Delta, which specifies that timestamps are relative to the previous displayed packet.\n\ne\n\nEpoch, which specifies that timestamps are seconds since epoch (Jan 1, 1970 00:00:00)\n\nu\n\nAbsolute, which specifies that actual times be displayed for all packets in UTC.\n\nud\n\nAbsolute with date, which specifies that actual dates and times be displayed for all packets in UTC.\n\nudoy\n\nAbsolute with YYYY/DOY date, which specifies that actual dates and times be displayed for all packets in UTC.\n\n-u <s | hms>\n\nShow timesamps as seconds (“s”, the default) or hours, minutes, and seconds (“hms”)\n\n-v, --version\n\nThis option requests Wireshark to print out its version information and exit.\n\n-w <savefile>\n\nThis option sets the name of the file to be used to save captured packets. This can be '-' for stdout.\n\n-y <capture link type>, --link-type <capture like types>\n\nIf a capture is started from the command line with -k, set the data link type to use while capturing packets. The values reported by -L are the values that can be used.\n\n--time-stamp-type <type>\n\nIf a capture is started from the command line with -k, set the time stamp type to use while capturing packets. The values reported by --list-time-stamp-types are the values that can be used.\n\n-X <eXtension option>\n\nSpecify an option to be passed to a Wireshark/TShark module. The eXtension option is in the form extension_key:value, where extension_key can be:\n\nlua_script:<lua_script_filename>\n\nTells Wireshark to load the given script in addition to the default Lua scripts.\n\nlua_script[num]:argument\n\nTells Wireshark to pass the given argument to the lua script identified by num, which is the number indexed order of the lua_script command. For example, if only one script was loaded with -X lua_script:my.lua, then -X lua_script1:foo will pass the string foo to the my.lua script. If two scripts were loaded, such as -X lua_script:my.lua -X lua_script:other.lua in that order, then a -X lua_script2:bar would pass the string bar to the second lua script, ie., other.lua.\n\nread_format:<file_type>\n\nTells Wireshark to use a specific input file type, instead of determining it automatically.\n\nstdin_descr:<description>\n\nDefine a description for the standard input interface, instead of the default: \"Standard input\".\n\n-Y <display filter>, --display-filter <display filter>\n\nStart with the given display filter.\n\n-z <statistics-string>\n\nGet Wireshark to collect various types of statistics and display the result in a window that updates in semi-real time. For the currently implemented statistics consult the Wireshark manual page.\n\n11.3. Packet colorization\n\nA very useful mechanism available in Wireshark is packet colorization. You can set up Wireshark so that it will colorize packets according to a display filter. This allows you to emphasize the packets you might be interested in.\n\nYou can find a lot of coloring rule examples at the Wireshark Wiki Coloring Rules page at https://wiki.wireshark.org/ColoringRules.\n\nThere are two types of coloring rules in Wireshark: temporary rules that are only in effect until you quit the program, and permanent rules that are saved in a preference file so that they are available the next time you run Wireshark.\n\nTemporary rules can be added by selecting a packet and pressing the Ctrl key together with one of the number keys. This will create a coloring rule based on the currently selected conversation. It will try to create a conversation filter based on TCP first, then UDP, then IP and at last Ethernet. Temporary filters can also be created by selecting the Colorize with Filter → Color X menu items when right-clicking in the packet detail pane.\n\nTo permanently colorize packets, select View → Coloring Rules…​. Wireshark will display the “Coloring Rules” dialog box as shown in Figure 11.1, “The “Coloring Rules” dialog box”.\n\nFigure 11.1. The “Coloring Rules” dialog box\n\nIf this is the first time using the Coloring Rules dialog and you’re using the default configuration profile you should see the default rules, shown above.\n\nYou can create a new rule by clicking on the + button. You can delete one or more rules by clicking the - button. The “copy” button will duplicate a rule.\n\nYou can edit a rule by double-clicking on its name or filter. In Figure 11.1, “The “Coloring Rules” dialog box” the name of the rule “Checksum Errors” is being edited. Clicking on the Foreground and Background buttons will open a color chooser (Figure 11.2, “A color chooser”) for the foreground (text) and background colors respectively.\n\nFigure 11.2. A color chooser\n\nThe color chooser appearance depends on your operating system. The macOS color picker is shown. Select the color you desire for the selected packets and click OK.\n\nFigure 11.3, “Using color filters with Wireshark” shows an example of several color filters being used in Wireshark. Note that the frame detail shows that the “Bad TCP” rule was applied, along with the matching filter.\n\nFigure 11.3. Using color filters with Wireshark\n\n11.4. Control Protocol Dissection\n\nThe user can control how protocols are dissected.\n\nEach protocol has its own dissector, so dissecting a complete packet will typically involve several dissectors. As Wireshark tries to find the right dissector for each packet (using static “routes” and heuristics “guessing”), it might choose the wrong dissector in your specific case. For example, Wireshark won’t know if you use a common protocol on an uncommon TCP port, e.g., using HTTP on TCP port 800 instead of the standard port 80.\n\nThere are two ways to control the relations between protocol dissectors: disable a protocol dissector completely or temporarily divert the way Wireshark calls the dissectors.\n\n11.4.1. The “Enabled Protocols” dialog box\n\nThe Enabled Protocols dialog box lets you enable or disable specific protocols. Most protocols are enabled by default. When a protocol is disabled, Wireshark stops processing a packet whenever that protocol is encountered.\n\nTo enable or disable protocols select Analyze → Enabled Protocols…​. Wireshark will pop up the “Enabled Protocols” dialog box as shown in Figure 11.4, “The “Enabled Protocols” dialog box”.\n\nFigure 11.4. The “Enabled Protocols” dialog box\n\nTo disable or enable a protocol, simply click the checkbox using the mouse. Note that typing a few letters of the protocol name in the search box will limit the list to those protocols that contain these letters.\n\nYou can choose from the following actions:\n\nEnable All\n\nEnable all protocols in the list.\n\nDisable All\n\nDisable all protocols in the list.\n\nInvert\n\nToggle the state of all protocols in the list.\n\nOK\n\nSave and apply the changes and close the dialog box, see Appendix B, Files and Folders for details.\n\nCancel\n\nCancel the changes and close the dialog box.\n\n11.4.2. User Specified Decodes\n\nThe “Decode As” functionality lets you temporarily divert specific protocol dissections. This might be useful for example, if you do some uncommon experiments on your network.\n\nDecode As is accessed by selecting the Analyze → Decode As…​. Wireshark will pop up the “Decode As” dialog box as shown in Figure 11.5, “The “Decode As” dialog box”.\n\nFigure 11.5. The “Decode As” dialog box\n\nIn this dialog you are able to edit entries by means of the edit buttons on the left.\n\nYou can also pop up this dialog box from the context menu in the packet list or packet details. It will then contain a new line based on the currently selected packet.\n\nThese settings will be lost if you quit Wireshark or change profile unless you save the entries.\n\n+\n\nAdd new entry for selected packet\n\n-\n\nRemove the selected entry.\n\nCopy\n\nCopy the selected entry.\n\nClear\n\nClear the list of user specified decodes.\n\nOK\n\nApply the user specified decodes and close the dialog box.\n\nSave\n\nSave and apply the user specified decodes and close the dialog box.\n\nCancel\n\nCancel the changes and close the dialog box.\n\n11.5. Preferences\n\nThere are a large number of preferences you can set. Simply select the Edit → Preferences…​ (Wireshark → Preferences…​ on macOS) and Wireshark will pop up the Preferences dialog box as shown in Figure 11.6, “The preferences dialog box”, with the “Appearance” page as default. On the left side is a tree where you can select the page to be shown.\n\nThe OK button will apply the preferences settings and close the dialog.\n\nThe Cancel button will restore all preferences settings to the last saved state.\n\n11.5.1. Appearance\n\nThese preferences give you the option to control the makeup of the GUI.\n\nFigure 11.6. The preferences dialog box\n\nSelecting Remember main window size and placement allow for a repeatable experience when restarting Wireshark.\n\nSelecting Open files in allows you to determine where to start the file selection dialog when opening capture files.\n\nThe preference Show up to allows you to determine how much history is tracked for display filter entries and recent files shown in the main application window.\n\nSelecting Confirm unsaved capture files causes a dialog to appear when closing a capture file when it was not yet saved. This may help preventing inadvertent loss of data, eg., when Wireshark is closed.\n\nSelecting Display autocompletion for filter text causes a drop down list to appear when you enter a display filter. This drop down list contains known display filters for easy selection.\n\nThe preference Main toolbar style allows you to tailor the toolbar style in one of three ways.\n\nThe Wireshark main window title is replaced by the name of the opened capture file. The preferences Window title and Prepend window title allow you to add bracketed strings after and before the window title. These window title strings can contain variables which will be replaced by their respective values.\n\nThe following variables are available.\n\n%C = Capture comment from command line\n\n%F = File path of the capture file\n\n%P = Currently selected profile name\n\n%S = Conditional separator (dash) that only shows when surrounded by variables with values or static text\n\n%V = Wireshark version info\n\nThe Language preference allows you to select the language used in the GUI. Note that the protocol information and details are kept in the language commonly used in this field, that being English.\n\n11.5.2. Columns\n\nThese preferences give you the option to control the definition of the columns shown in the packet list, once a capture file is loaded.\n\nFigure 11.7. Column preferences\n\n+\n\nAdd new entry to the list.\n\n-\n\nRemove the selected entry.\n\nSelecting Show displayed columns only hides all non-displayed columns from the list, possibly making navigating the list easier.\n\nThe rows can be dragged and dropped to arrange them in the desired order.\n\nThe columns in the entries are as follows.\n\nSelecting Displayed causes the column to be shown in the packet list.\n\nThe Title is the text shown in the header of the column in the packet list.\n\nThe Type is the type of value to be shown. This can be a predefined type, ie. a value in a defined format, or custom.\n\nThe following settings are applicable when the Type is set to \"custom\"\n\nThe Fields setting is the display filter name of the field to be shown in the column in the packet list.\n\nThe Field Occurrence setting is count of the given field in the frame, for fields that appear more than once in a frame.\n\nSelecting Resolved causes name resolution to be applied to the field value, when available.\n\n11.5.3. Font and Colors\n\nThese preferences give you the option to select the font and colors used in the various packet panes. Most usable is to select a mono spaced font, which allows for a cleaner presentation, but using a proportional font is possible too.\n\nFigure 11.8. Font and colors preferences\n\n11.5.4. Layout\n\nThese preferences allow you to define the layout of the GUI once a capture file is loaded.\n\nFigure 11.9. Layout preferences\n\nMake sure that you have at least one pane configured to contain the Packet list. Three panes can be active at the same time and they can be laid out as shown in the top layer. The exact sizes of these panes can be changed as needed once a capture file is opened.\n\nSelecting Show packet list separator causes the packet list entries to be slightly set apart, which may improve readability at the cost of the amount of packets shown in the packet list.\n\nSelecting Show column definition in column context menu make the column context menu wider to show the currently configured field type for the column. This may help identify the column to select or modify.\n\nSelecting Allow the list to be sorted enables the sort operator on all the columns. This may prevent inadvertently triggering a sort, which may take considerable time for larger capture files.\n\nThe Maximum number of cached rows setting determines how much packet list information is cached to speed up sort operations, where a larger number causes more memory to be consumed by the cache. Be aware that changing other dissection settings may invalidate the cache content.\n\nSelecting Enable mouse-over colorization enables the highlighting of the currently pointed to packet in the packet list. The currently selected packet is always highlighted.\n\nSelecting Show selected packet number adds the selected packet number to the capture file details in the status bar, taking up some space in the status bar.\n\nSelecting Show file load time adds the time it took to load the capture file to the status bar, taking up some space in the status bar.\n\n11.5.5. Capture\n\nThese preferences allow you to set the default conditions for packet capture.\n\nFigure 11.10. Capture preferences\n\nThe default interface is the interface used for packet capture in case no other is selected on the opening page of GUI. Note that this can be multiple interfaces separated by a comma.\n\nSelecting Capture packets in promiscuous mode causes the network interface(s) to capture on to be configured in promiscuous mode. This allows all (Ethernet) frames to be received by the network interface to be capture, not only those that are addressed to the capture interface.\n\nSelecting Capture packets in pcapng format causes the Next-Generation packet capture file format to be used when capturing. This much more capable packet capture file format has many advantages over the original format, although not every external tool may be capable of handling packet captures in this format.\n\nSelecting Update list of packets in real time causes the packet list to fill up and possibly scroll up during the packet capture process. This does give an insight in the packets captured, although it takes processing power to dissect the capture packets.\n\nThe preference Interval between updates (ms) allows you to configure how often the packet list is updated during the packet capture process. A higher interval reduces processing, but causes more delay between capture and display in the packet list.\n\nSelecting Don’t load interfaces on startup prevents Wireshark from spawning dumpcap to populate the list of capture interfaces on the local system. This might be a time consuming operation delaying the start of the program, however on most systems this is not an issue. The interface list can always be populated after Wireshark is started via Capture → Refresh Interfaces.\n\nSelecting Disable external capture interfaces prevents Wireshark from spawning extcap programs to list off their capture interfaces. This might be a time consuming operation delaying the start of the program, however on most systems this is not an issue.\n\n11.5.6. Expert Items\n\nThese preferences allow you to modify the severity set for expert items.\n\nFigure 11.11. Expert item preferences\n\nIf, for whatever reason, you find that the severity for certain expert items does not match your needs you can change them here and have them used as such, showing up in the appropriate lists and overviews. Get the Field name from selecting the field in the packet details pane, then observe the name shown in the status bar. This is the name you enter on a new line in the list, while setting the desired Severity in the next column.\n\n+\n\nAdd new entry to the list.\n\n-\n\nRemove the selected entry.\n\nCopy\n\nCopy the selected entry.\n\n⌃\n\nMove the selected entry up in the list.\n\n⌄\n\nMove the selected entry down in the list.\n\nClear\n\nClear the list of user specified expert item severities.\n\nCopy from\n\nCopy the list of user specified expert item severities from another profile.\n\n11.5.7. Filter Buttons\n\nHaving quick access to regularly used display filter expressions can be a real productivity boost. Here you can define your own display filter buttons.\n\nFigure 11.12. Filter buttons\n\n+\n\nAdd new entry to the list.\n\n-\n\nRemove the selected entry.\n\nCopy\n\nCopy the selected entry.\n\n⌃\n\nMove the selected entry up in the list.\n\n⌄\n\nMove the selected entry down in the list.\n\nClear\n\nClear the list of user specified display filter buttons.\n\nCopy from\n\nCopy the list of user specified display filter buttons from another profile.\n\nThe columns in the entries are as follows.\n\nSelecting Show in toolbar causes the button to be shown in the toolbar besides the display filter text entry.\n\nThe Button Label is the text shown on the button in the toolbar. The use of a double slash causes the button to create a dropdown list to allow grouping of multiple buttons, e.g. TCP//Syn and TCP//Res.\n\nThe Filter Expression is the display filter expression entered into the display filter text entry when the button is clicked.\n\nThe Comment is the comment text which appears in a bubble when the mouse hovers over the button.\n\n11.5.8. Name Resolution\n\nThese preferences allow you to configure which numeric identifiers in protocols are translated into human readable text. For some of these identifiers the readable texts are read from configurable external sources.\n\nFigure 11.13. Name resolution preferences\n\nSelecting Resolve MAC addresses causes the OUI (Organizationally Unique Identifier) at the start of an Ethernet address to be translated into the name registered with the IEEE for that OUI.\n\nSelecting Resolve transport names causes the UDP and TCP port numbers to be translated into the service registered to these ports by IANA.\n\nSelecting Resolve network (IP) addresses causes IPv4, IPv6 and IPX addresses to be translated into their corresponding host name. To do this Wireshark reaches out to DNS servers to request names for addresses it finds in packets. There are several way to do this, which can be controlled through the following preferences.\n\nSelecting Use captured DNS packet data for name resolution causes DNS response packets in the capture file to fill the network address resolution table. These can then be used to resolve addresses found in the packets.\n\nSelecting Use your system’s DNS settings for name resolution causes DNS requests to be made as would be for other network applications.\n\nSelecting Use a custom list of DNS servers for name resolution causes DNS requests to be made to manually configured DNS servers.\n\nThe DNS Servers Edit…​ button provides access to the dialog to manage these manually configured DNS servers.\n\nThe Maximum concurrent requests input field allows you to limit the amount of DNS queries made at the same time.\n\nSelecting Resolve VLAN IDs causes the file \"vlans\" to be read and used to name VLANs. This file has the simple format of one line per VLAN, starting wit VLAN ID, a tab character, followed by the name of the VLAN.\n\nSelecting Resolve SS7 PCs causes the file \"ss7pcs\" to be read and used to name SS7 Point Codes. This file has the simple format of one line per Point Code, starting with Network Indicator, a dash, the Point Code in decimal, a tab character, followed by the name of the Point Code.\n\nSelecting Enable OID resolution causes the SMI library to be initialized. This library is capable of loading MIB/PIB files to provide name resolution for SMI objects, as present in SNMP packets.\n\nSelecting Suppress SMI errors prevents the SMI library from emitting error messages while loading MIB/PIB files. The SMI library is very sensitive to irregularities in these files often resulting in harmless error being emitted.\n\nThe SMI (MIB and PIB) paths Edit…​ button provides access to the dialog to manage the directories where the MIB/PIB files to be loaded can be found.\n\nThe SMI (MIB and PIB) modules Edit…​ button provides access to the dialog to manage the MIB/PIB modules to be loaded.\n\nSelecting Enable IP geolocation causes the background MaxMind database IP geolocation resolver to be used to attempt to geolocate IP addresses in the packets.\n\nThe MaxMind database directories Edit…​ button provides access to the dialog to manage the directories where the MaxMind database files can be found. See Section 11.9, “MaxMind Database Paths”.\n\n11.5.9. Protocols\n\nWireshark supports quite a few protocols, which is reflected in the long list of child entries of the “Protocols” pane. You can jump to the preferences for a specific protocol by expanding “Protocols” and typing the first few letters of the protocol name.\n\nFigure 11.14. Protocol preferences\n\nThere are a few general protocol related preferences, listed below.\n\nSelecting Display hidden protocol items influences what is shown in the packet details pane of the packet selected from the packet list. Some protocol dissectors add hidden protocol items that provide additional interpretations of the packet data, or with different display filter strings. These may or may not provide valuable information to the user and may clutter the output, therefor these items can be hidden.\n\nSelecting Display byte fields with a space character between bytes influences the way a byte field in shown in the packet details pane of the packet selected in the packet list, if the dissector creates a byte field that is. The bytes in the byte field are normally shown as a concatenated sequence of hexadecimals. This preference allows you to get the representation of each byte separated by a space. This may improve readability of the individual bytes in the byte field.\n\nSelecting Look for incomplete dissectors causes expert items to be added to the dissection of packet data for which the dissector does not create an interpretation. Dissectors should strive to not skip packet bytes and this preference allows you to be made aware of this.\n\nSelecting Enable stricter conversation tracking heuristics allows dissectors to take more identifiers into consideration when creating \"conversations\". These are used to track related packets. The heuristics for these conversations are sensitive to mis-identification of packets, possibly corrupting conversation analysis. Adding more identifiers can reduce the change of this happening. Currently only the IPv4, ICMP and ICMPv6 dissector use this preference.\n\nSelecting Ignore duplicate frames causes a duplicate frame to appear in the packet list, but flagged as ignored, hence not dissected. The determination of a duplicate frame is made based on the SHA256 hash of the bytes in the frame.\n\nThe preference Deinterlacing conversations key gives you options for deinterlacing the conversations. While NONE keeps the historical behaviour, the other options are built on three keys with the following meanings: V (VLAN), M (Mac Address), I (Interface). Packets which seem identical because they have the same payload but have a different value for their VLAN Tag, a MAC Address, or were captured on different interfaces, will then be part of different conversations if the respective deinterlacing key is activated.\n\nThe preference The max number of hashes to keep in memory for determining duplicate frames allows you to set how large the set of frames to consider for duplication is.\n\n11.5.10. RSA Keys\n\nFor more information see https://wiki.wireshark.org/TLS.\n\nFigure 11.15. RSA keys\n\n11.5.11. Statistics\n\nThese preference have influence on the Statistics Tree (stats_tree) based dialogs accessible via the Statistics menu.\n\nFigure 11.16. Statistics preferences\n\nThe preference Tap update interval in ms allows you to set how quickly protocol taps are being updated, partially determining the update speed of various dialogs and graphs.\n\nSelecting Enable the calculation of burst information allows the Statistics Tree system to calculate burst information.\n\nSelecting Show burst count for item rather than rate allows the statistics nodes to show the count of events within the burst window instead of a burst rate. Burst rate is calculated as number of events within burst window divided by the burst window length.\n\nThe preference Burst rate resolution (ms) sets the duration of the time interval into which events are grouped when calculating the burst rate. Setting a higher resolution (ie., a smaller number) increases processing overhead.\n\nThe preference Burst rate window size (ms) sets the duration of the sliding window during which the burst rate is measured. Longer window relative to burst rate resolution increases processing overhead. This value will be truncated to a multiple of the Burst rate resolution preference setting.\n\nThe preference Default sort column for stats_tree stats gives you to option to select one of the columns to sort on.\n\nSelecting Default stats_tree sort order is descending causes a descending sort order based on the previously selected column.\n\nSelecting Case sensitive sort of stats_tree item names causes a case sensitive sort based on the previous selected order and column.\n\nSelecting Always sort 'range' nodes by name causes the sort to take place by name rather than values.\n\nSelecting Always sort 'range' nodes in ascending order makes an exception for range nodes to the previously selected sort order.\n\nSelecting Display the full stats_tree plug-in name causes the full menu path of the Statistics Tree plugin to be shown in the title.\n\n11.5.12. Advanced\n\nThe “Advanced” pane will let you view and edit all of Wireshark’s preferences, similar to about:config and chrome:flags in the Firefox and Chrome web browsers.\n\nFigure 11.17. Advanced preferences\n\nYou can search for a preference by typing text into the “Search” entry. You can also pass preference names to Wireshark and TShark on the command line. For example, the gui.prepend_window_title can be used to differentiate between different instances of Wireshark on your screen:\n\n$ wireshark -o \"gui.prepend_window_title:LAN\" & $ wireshark -o \"gui.prepend_window_title:External Network\" &\n\n11.6. Configuration Profiles\n\nConfiguration Profiles can be used to configure and use more than one set of preferences and configurations. Select the Edit → Configuration Profiles…​ menu item or press Shift+Ctrl+A or Shift+Cmd+A (macOS) and Wireshark will pop up the Configuration Profiles dialog box as shown in Figure 11.18, “The configuration profiles dialog box”. It is also possible to click in the “Profile” part of the statusbar to popup a menu with available Configuration Profiles (Figure 3.23, “The Statusbar with a configuration profile menu”).\n\nConfiguration files stored in each profile include:\n\nPreferences (preferences) (Section 11.5, “Preferences”)\n\nCapture Filters (cfilters) (Section 6.6, “Defining And Saving Filters”)\n\nDisplay Filters (dfilters) (Section 6.6, “Defining And Saving Filters”)\n\nDisplay Filter Macros (dmacros) (Section 6.7, “Defining And Saving Filter Macros”)\n\nColoring Rules (colorfilters) (Section 11.3, “Packet colorization”)\n\nDisabled Protocols (disabled_protos) (Section 11.4.1, “The “Enabled Protocols” dialog box”)\n\nMost User Accessible Tables (Section 11.7, “User Accessible Tables”)\n\nChanged dissector assignments (decode_as_entries), which can be set in the “Decode As…​” dialog box (Section 11.4.2, “User Specified Decodes”).\n\nSome recent settings (recent), such as pane sizes in the Main window (Section 3.3, “The Main window”), column widths in the packet list (Section 3.18, “The “Packet List” Pane”), all selections in the View menu (Section 3.7, “The “View” Menu”) and the last directory navigated to in the “File Open” dialog.\n\nAll other configurations are stored in the personal configuration folder and are common to all profiles.\n\nFigure 11.18. The configuration profiles dialog box\n\nSearch for profile …​\n\nThe list of profiles can be filtered by entering part of the profile’s name into the search box.\n\nType selection\n\nProfiles can be filtered between displaying \"All profiles\", \"Personal profiles\" and \"Global profiles\"\n\nPersonal profiles - these are profiles stored in the user’s configuration directory\n\nGlobal profiles - these are profiles provided with Wireshark\n\nNew (+)\n\nCreate a new profile. The name of the created profile is “New profile” and is highlighted so that you can more easily change it.\n\nDelete (-)\n\nDeletes the selected profile. This includes all configuration files used in this profile. Multiple profiles can be selected and deleted at the same time. It is not possible to delete the “Default” profile or global profiles. Deletion of the \"Default\" profile will reset this profile.\n\nCopy\n\nCopies the selected profile. This copies the configuration of the profile currently selected in the list. The name of the created profile is the same as the copied profile, with the text “(copy)” and is highlighted so that you can more easily change it.\n\nAuto switch packet limit\n\nThe number of packets to check for automatic profile switching, described below. Setting this to zero disables automatic profile switching.\n\nImport\n\nProfiles can be imported from zip-archives as well as directly from directory structures. Profiles, which already exist by name will be skipped, as well as profiles named \"Default\".\n\nExport\n\nProfiles can be exported to a zip-archive. Global profiles, as well as the default profile will be skipped during export. Profiles can be selected in the list individually and only the selected profiles will be exported\n\nOK\n\nThis button saves all changes, applies the selected profile and closes the dialog.\n\nCancel\n\nClose this dialog. This will discard unsaved settings, new profiles will not be added and deleted profiles will not be deleted.\n\nHelp\n\nShow this help page.\n\n11.6.1. Automatic Profile Switching\n\nYou can configure Wireshark to automatically change configuration profiles by adding a display filter to the \"Auto Switch Filter\" setting for a profile. When you open a capture file, Wireshark will check each filter against a limited number of packets and will switch to the first profile with a matching filter. The number of packets is determined by the \"Auto switch packet limit\" setting, and a limit of 0 will disable this feature. Manually changing your profile will disable this behavior until you open a different capture file.\n\n11.7. User Accessible Tables\n\nUser Accessible Tables are a type of preference table which may be associated with particular protocols or with the application as a whole.\n\nUser Accessible Tables have a common editor dialog which works as described in Section 11.5.6, “Expert Items” and Section 11.5.7, “Filter Buttons”. Note that the name of the file appears in the lower right corner of the dialog.\n\nThe files are saved in a CSV format, where values are either double quoted ASCII strings (using C-style backslash escapes for non-printable characters) or unquoted hexstrings, depending on the field type. They can be edited directly when Wireshark is not running, though this is discouraged. Entries can also be appended to the table by passing an appropriate CSV formatted record string on the command line.\n\nMost UATs are stored in the configuration profile:\n\nCustom HTTP headers (custom_http_header_fields)\n\nCustom IMF headers (imf_header_fields)\n\nCustom LDAP AttributeValue types (custom_ldap_attribute_types)\n\nDisplay Filter Buttons (dfilter_buttons)\n\nDisplay Filter Macros (dfilter_macros), prior to Wireshark 4.4\n\nDNS Servers (addr_resolve_dns_servers)\n\nESS Category Attributes (ess_category_attributes)\n\nExpert Item Severity (expert_severity)\n\nIEEE 802.11 WLAN Decryption Keys (80211_keys)\n\nIKEv2 decryption table (ikev2_decryption_table)\n\nI/O Graphs (io_graphs)\n\nK12 Protocols (k12_protos)\n\nObject Identifier Names and Associated Syntaxes ()\n\nPacket Lengths (packet_lengths)\n\nPRES Users Context List (pres_context_list)\n\nSCCP Users Table (sccp_users)\n\nSNMP Enterprise Specific Trap Types (snmp_specific_traps)\n\nSNMP Users (snmp_users)\n\nUser DLTs Table (user_dlts)\n\nProtobuf Search Paths (protobuf_search_paths)\n\nProtobuf UDP Message Types (protobuf_udp_message_types)\n\nOther UATs are stored in the personal configuration directory and are common to all profiles:\n\n11.8. ESS Category Attributes\n\nWireshark uses this table to map ESS Security Category attributes to textual representations. The values to put in this table are usually found in an XML SPIF, which is used for defining security labels.\n\nThis table is a user table, as described in Section 11.7, “User Accessible Tables”, with the following fields:\n\nTag Set\n\nAn Object Identifier representing the Category Tag Set.\n\nValue\n\nThe value (Label And Cert Value) representing the Category.\n\nName\n\nThe textual representation for the value.\n\n11.9. MaxMind Database Paths\n\nIf your copy of Wireshark supports MaxMind’s MaxMindDB library, you can use their d"
    }
}