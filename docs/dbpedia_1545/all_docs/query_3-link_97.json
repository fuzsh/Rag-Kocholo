{
    "id": "dbpedia_1545_3",
    "rank": 97,
    "data": {
        "url": "https://www.semarchy.com/doc/semarchy-mdm/semdg.html",
        "read_more_link": "",
        "language": "en",
        "title": "Semarchy Convergence for MDM Developer’s Guide",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/semarchy_workbench.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/semql_editor.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/refreshvar.gif",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/application_table_view_example.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/application_form_view_flow_example.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/application_form_view_grid_example.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/application_bo_view_example.png",
            "https://www.semarchy.com/doc/semarchy-mdm/images/semdg/edit_expression_button.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Semarchy",
            "Semarchy Convergence for MDM",
            "development",
            "guide",
            "design"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This guide contains information about using the product to design and develop an MDM project.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "This document uses the following formatting conventions:\n\nIn addition to the product manuals, Semarchy provides other resources available on its web site: http://www.semarchy.com.\n\nThere are many ways to access the Semarchy Technical Support. You can call or email our global Technical Support Center (support@semarchy.com). For more information, see http://www.semarchy.com.\n\nWe welcome your comments and suggestions on the quality and usefulness of this documentation.\n\nIf you find any error or have any suggestion for improvement, please mail support@semarchy.com and indicate the title of the documentation along with the chapter, section, and page number, if available. Please let us know if you want a reply.\n\nThis guide contains information about using the product to design and develop an MDM project.\n\nUsing this guide, you will learn how to:\n\nData architects, business analysts, data stewards and business users all share the same point of entry in Semarchy Convergence for MDM through the single Convergence Workbench user interface accessible through any type of browser. This interface uses rich perspectives to suit every user role and allows team collaboration. The advanced meta-data management capabilities enhance the usability of this intuitive interface.\n\nSemarchy Convergence for MDM includes a unique modeling framework that combines both ER and OO modeling with concepts such as inheritance or complex types. Data architects and business analysts use this environment to define semantically complete models that will serve as references for the enterprise. These models include the description of the business entities as well as the rules associated with them.\n\nThe innovative Convergence for MDM technology supports an infinite number of versions and branches of data and metadata. The collaborative process between the different governance teams set the rules to close the editions of metadata and data to keep full traceability or to run multiple projects in parallel.\n\nDuring the modeling phase, the data architect and business analysts create their metadata definition until the first semantically data model is finished. This model is then frozen in an edition and eventually delivered to production. Subsequent iterations of the data model are automatically opened. This allows Semarchy Convergence for MDM users to replay the entire cycle of metadata definition. At any time, project managers may choose to branch the developments in order to develop two versions of the model in parallel.\n\nMaster Data in a Semarchy Convergence for MDM hub can also be managed with versions. Business processes specific to the enterprise set the rate at which data must be frozen in these versions. A consumer can access data in particular edition of the data and can see the data as it was at a particular moment in time. As a consequence, the company can develop a strategy for managing versions of data, for example during the introduction of new major versions of a model, for simulation projects and what-if analysis, or when launching new catalogs.\n\nSemarchy Convergence for MDM supports the integration of data from any source in batch mode, asynchronous or synchronous mode. The platform manages the lifecycle of data published in the hub. This data is pushed by publishers through existing middleware (ETL, SOA, EAI, Data Integration, etc.). The platform provides standards APIs such as SQL for ETLS, Java and Web Services integration for real-time publishing. The certification process follows a sequence of steps to produce and make available certified reference data (Golden Records). These steps apply all the logical integration rules defined in the modeling phase to certify at all times the integrity, quality and uniqueness of the reference data.\n\nWith its Open Plug-in Architecture Semarchy Convergence for MDM can delegate stages of the certification process to any component present in the information system infrastructure.\n\nSemarchy Convergence for MDM support Master Data Applications generation. These applications provide secured and filtered access to the golden and master data of the hub in business-friendly views in a Web 2.0 interface. Applications also support customized Human Workflows for duplicate management and data entry.\n\nThe certified data is stored in a relational database, which allows Semarchy Convergence for MDM to benefit from higher performance and scalability. The data is made available to consumers across multiple channels to allow a non-intrusive integration with the information system:\n\nThe Convergence Pulse component enables business users to collect metrics and measure - with dashboards and KPIs - the health of their Convergence for MDM Hub.\n\nTo access Convergence Workbench, you need a URL, a user name and password that have been provided by your Semarchy Convergence for MDM administrator.\n\nTo log in to the Convergence Workbench:\n\nTo log out of the Convergence Workbench:\n\nA model edition is a version of a model. This edition can be in a closed or open status. Only open editions can be edited.\n\nOpening a model edition connects the workbench to this edition.\n\nThe Convergence Workbench is the graphical interface used by all Semarchy Convergence for MDM users. This user interface exposes information in panels called Views and Editors .\n\nA given layout of views and editors is called a Perspective .\n\nWorking with Editors\n\nAn object currently being viewed or edited appears in an editor in the central part of the screen.\n\nYou can have multiple editors opened at the same time, each editor appearing with a different tab.\n\nEditor Organization\n\nEditors are organized as follows:\n\nThe editor has a local toolbar which is used for editor specific operations. For example, refreshing or saving the content of an editor is performed from the toolbar.\n\nThe editor has a breadcrumb that allows navigating up in the hierarchy of objects.\n\nThe editor has a sidebar which shows the various sections and child objects attached to an editor. You can click in this sidebar to jump to one of these sections.\n\nProperties in the editors are organized into groups, which can be expanded or collapsed.\n\nSaving an Editor\n\nWhen the object in an editor is modified, the editor tab is displayed with a star in the tab name. For example, Contact* indicates that the content of the Contact editor has been modified and need to be saved.\n\nTo save an editor, either:\n\nClick the Save button in the Workbench toolbar.\n\nUse the CTRL+S key combination.\n\nUse the File > Save option in the Workbench menu.\n\nYou can also use the File > Save All menu option or Save All toolbar button to save all modified editors.\n\nClosing an Editor\n\nTo close an editor, either:\n\nClick the Close (Cross) icon on the editor’s tab.\n\nUse the File > Close option in the Workbench menu.\n\nUse the Close option the editor’s context menu (right-click on the editor’s tab).\n\nYou can also use the File > Close All menu option or the Close All option the editor’s context menu (right-click on the editor’s tab) to close all the editors .\n\nAccelerating Edition with CamelCase\n\nIn the editors and dialogs in Convergence Workbench, the Auto Fill checkbox accelerates object creation and edition.\n\nWhen this option is checked and the object name is entered using the CamelCase, the object Label as well as the Physical Name is automatically generated.\n\nFor example, when creating an entity, if you type ProductPart in the name, the label is automatically filled in with Product Part and the physical name is set to PRODUCT_PART.\n\nDuplicating Objects\n\nThe workbench support object duplication for Form Views, Tables Views, Search Forms, Business Objects, Business Object Views and Workflows.\n\nTo duplication an object:\n\nSelect the object to duplicate in the Model Edition tree view.\n\nRight-click and then select Duplicate.\n\nA copy of the object is created.\n\nIt is also possible to duplicate a group of objects. When duplicating a group of objects that reference one another, the references in the copied objects are moved to the copies of the original objects.\n\nFor example:\n\nWhen copying a single business object view BOV1 that references a table view TV1, the copy of the business object View (BOV2) still references the table view TV1.\n\nWhen copying a business object view BOV1 with a table view TV1 that it references (the group includes BOV1 and TV1), the copy of the business object view BOV2 references the copy of the table view BOV2.\n\nTo duplicate a group of objects:\n\nSelect the multiple objects to duplicate in in the Model Edition tree view. Press the CTRL key to enable multiple selection.\n\nRight-click and then select Duplicate.\n\nA copy of the group of object is created. The links are made if possible to the copied objects.\n\nWorkbench Preferences\n\nUser preferences are available to configure the workbench behavior. These preferences are stored in the repository and are specific to each user connecting to the workbench. The preferences are applied regardless of the client computer or browser used by the user to access the workbench.\n\nSetting Preferences\n\nUse the Window > Preferences dialog pages to set how you want the workbench to operate.\n\nYou can browse the Preferences dialog pages by looking through all the titles in the left pane or search a smaller set of titles by using the filter field at the top of the left pane. The results returned by the filter will match both Preference page titles and keywords such as general and stewardship.\n\nThe arrow controls in the upper-right of the right pane enable you to navigate through previously viewed pages. To return to a page after viewing several pages, click the drop-down arrow to display a list of your recently viewed preference pages.\n\nThe following preferences are available in the Preferences dialog:\n\nData Stewardship Preferences apply to the data stewardship applications:\n\nData Page Size: Size of a page displaying a list of records.\n\nShow Hierarchy Navigation: Select this option to display the Hierarchical view of the records in the outline.\n\nShow Lineage Navigation: Select this option to display the Lineage view of the records in the outline.\n\nPredictable Navigation: Select to option to enable automated record sorting when opening a list of records. This option provides a predictable list of records for each access. This option is not recommended when accessing large data sets as sorting may be a time consuming operation.\n\nList of Values Export Format: Format used when exporting attribute values with a list of values type.\n\nList of Values Display Format: Format used when displaying attributes with a list of values type.\n\nGeneral Preferences:\n\nDate Format: Format used to display the date values in the workbench. This format uses Java’s SimpleDataFormat patterns.\n\nDateTime Format: Format used to display the date and time values in the workbench. This format uses Java’s SimpleDataFormat patterns.\n\nLink Perspective to Active Editor: Select this option to automatically switch to the perspective related to an editor when selecting this editor.\n\nUnder the Data Stewardship preferences node, preference pages are listed for the data locations accessed by the user and for the entities under these data locations. These preference pages display no preferences and are used to reset the Filters, Sort and Columns selected by the user for the given entities, as well as the layout of the editors for these entities (the collapsed sections, for example). To reset the preferences on a preferences page, click the Restore Defaults button in this page.\n\nExporting and Importing User Preferences\n\nSharing preferences between users is performed using preferences import/export.\n\nTo export user preferences:\n\nSelect File > Export. The Export wizard opens.\n\nSelect Export Preferences in the Export Destination and then click Next.\n\nClick the Download Preferences File link to download the preferences to your file system.\n\nClick Finish to close the wizard.\n\nTo import user preferences:\n\nSelect File > Import. The Import wizard opens.\n\nSelect Import Preferences in the Import Source and then click Next.\n\nClick the Open button to select an export file.\n\nClick OK in the Import Preferences Dialog.\n\nClick Finish to close the wizard.\n\nImporting preferences replaces all the current user’s preferences by those stored in the preferences file.\n\nSemQL is a language to express declarative rules in Convergence Workbench. It is used in Enrichers, Matchers, Validations, Filters and Consolidators.\n\nSemQL Examples\n\nEnricher Expressions\n\nFirstName: InitCap(FirstName)\n\nName: InitCap(FirstName) || Upper(FirstName)\n\nCity: Replace(Upper(InputAddress.City),'CEDEX','')\n\nIn these examples, InitCap, Upper and Replace are SemQL functions. The concatenate operator || is also a SemQL operator.\n\nValidation Conditions\n\nChecking the Customer’s InputAddress complex attribute validity:\n\nInputAddress.Address is not null and ( InputAddress.PostalCode is not null or InputAddress.City is not null)\n\nIn this example, the IS NOT NULL, AND and OR SemQL operators are used to build the condition.\n\nMatcher\n\nBinning Expression to grouping customers by their Country/PostalCode:\n\nInputAddress.Country || InputAddress.PostalCode\n\nMatching Condition: Matching two customer records by name, address and city name similarity:\n\nSEM_EDIT_DISTANCE_SIMILARITY( Record1.CustomerName, Record2.CustomerName ) > 65 and SEM_EDIT_DISTANCE_SIMILARITY( Record1.InputAddress.Address, Record2.InputAddress.Address ) > 65 and SEM_EDIT_DISTANCE_SIMILARITY( Record1.InputAddress.City, Record2.InputAddress.City ) > 65\n\nIn this last example, SEM_EDIT_DISTANCE_SIMILARITY is a SemQL function. Record1 and Record2 are predefined names for qualifying the two record to match.\n\nPlug-ins allow extending the capabilities of the Semarchy Convergence for MDM using Java code and external APIs.\n\nPlug-ins are used to implement enrichers or validations not feasible in SemQL.\n\nThe plug-ins have the following characteristics:\n\nIn Semarchy Convergence for MDM, modeling is performed at the logical level. You do not design physical objects such as tables in a model, but logical business entities independently from their implementation.\n\nObjects Naming Convention\n\nWhen designing a logical model, it is necessary to enforce a naming convention to guarantee a good readability of the model and a clean implementation.\n\nThere are several names and labels used in the objects in Semarchy Convergence for MDM:\n\nInternal Names (Also called Names) are used mainly by the Model designers and are unique in the model. They can only contain alphanumeric characters, underscores and must start with a letter.\n\nPhysical Names and Prefixes are used to create the objects in the database corresponding to the logical object. These can only contain uppercase characters and underscores.\n\nLabels and Descriptions are visible to the users (end-users and data stewards) consuming data through the UI. These user-friendly labels and descriptions can be fixed at later stages in the design. They are externalized and can be localized (translated) in the platform.\n\nThe following tips should be used for naming objects:\n\nUse meaningful Internal Names. For example, reference relationships should all be named after the pattern <entity name><relation verb><entity name> , like CustomerHasAccountManager .\n\nDo not try to shorten internal names excessively. They may become meaningless. For example, using CustAccMgr instead of CustomerHasAccountManager is not advised .\n\nUse the CamelCase for internal names as it enables the use of the Auto fill feature. For example, ContactBelongsToCustomer, GeocodedAddressType.\n\nDefine team naming conventions that accelerate object type identification. For example, types and list of values can be post-fixed with their type such as GeocodedAddressType, GenderLOV.\n\nDefine user-friendly Labels and Descriptions. Internal Names are for the model designers, but labels and descriptions are for end users.\n\nThe following table lists a typical naming convention that you can adapt to your project.\n\nObject Name Pattern Examples\n\nModel\n\n[ModelName]\n\nStoresAndSuppliersMDM, MyCompanyMDM\n\nEntity\n\n[EntityName]\n\nProductLine, ProductItem\n\nAttribute\n\n[AttributeName]\n\nIsProductAvailable\n\nReference\n\n[FromEntity]Has[ToEntity][Role]\n\nEmployeeHasEmployeeManager\n\nReference Role To\n\n[RoleNameInSingular]\n\nManager\n\nReference Role From\n\n[RoleNameInPlural]\n\nManagedEmployees\n\nComplex Type\n\n[ComplexTypeName]Type\n\nAddressType\n\nUser Defined Type\n\n[TypeName]Type\n\nSimpleStringType\n\nPublisher (Code)\n\n[CODE]\n\nDE\n\nPublisher (Name)\n\n[PublisherName]\n\nDataEntry\n\nJob\n\n[JOB_NAME][JOB_TYPE]\n\nINITIAL_LOAD_FULL, CERTIFY_PRODUCT_SIMPLE\n\nForm View\n\n[FormViewKind]FormView\n\nDefaultFormView, DataEntryFormView, FancyFormView, MainAttributesFormView\n\nTable View\n\n[TableViewKind]TableView\n\nDefaultTableView, AllAttributesTableView\n\nList Of Values\n\n[LOVName]LOV\n\nCurrencyLOV, ProductTypesLOV\n\nBusiness Object\n\n[BoName](By[Name])BO\n\nProductSimpleBO, ProductsByCategoryBO, EmployeeHierarchyBO, PartyAllInformationBO\n\nBO Transition Name\n\n[ReferenceRoleFrom]\n\nManagedEmployees\n\nApplication\n\n[ApplicationName]Application\n\nProductSearchApplication, ProductDesignApplication, ReferenceDataManagementApplication\n\nFolder\n\n[FolderName]\n\nProductsManagement\n\nBusiness Object View\n\n[ViewNameBasedOnBOName]\n\nAllProducts, ProductByCategory, CustomersByRegion\n\nHumanWorkflow\n\n[WorkflowName]\n\nCreateOrModifyCustomers, ManageCustomersDuplicates, InitiateFullProductCreation, RequestProductLabelChange\n\nWorkflow Task\n\n[TaskPurpose]\n\nCreateProductBasicInformation, AddTechnicalDetailsForProduct, VerifyProductCreationGuidelines\n\nWorkflow Transition\n\n[TransitionStatusName]\n\nSendDataForApproval, RejectRequestAndAskForMoreInformation, AcceptAndSendToMarketing\n\nGenerating the Model Documentation\n\nWhen a model is complete or under development, it is possible to generate a documentation set for this model.\n\nThis documentation set may contain the following documents:\n\nThe Logical Model Documentation, which includes a description of the logical model and the rules involved in the integration processes.\n\nThe Applications Documentation, which includes a description of the applications of the model, their related components (views, business objects, etc.) as well as their workflows.\n\nThe Physical Model Documentation, which includes a description of the physical tables generated in the data location when the model is deployed. This document is a physical model reference document for the integration developers.\n\nThe documentation is generated in HTML format and supports hyperlink navigation within and between documents.\n\nTo generate the model documentation:\n\nIn the Model Edition view of the Model Design Perspective, select the model node at the root of the tree.\n\nRight-click and select Export Model Documentation.\n\nIn the Model Documentation Export dialog, select the documents to generate.\n\nSelect the appropriate Encoding and Locale for the exported documentation. The local defines the language of the generated documentation.\n\nClick OK to download the documentation.\n\nThe documentation is exported in a zip file containing the selected documents.\n\nIt is possible to export the model documentation only for a valid model.\n\nSeveral types can be used in the Semarchy Convergence for MDM models:\n\nAll these type as the user-defined are reused across the entire model.\n\nList of Values\n\nList of Values (LOVs) are a user-defined list of code and label pairs.\n\nThey are limited to 1,000 entries and can be imported from a Microsoft Excel Spreadsheet.\n\nExamples:\n\nGender (M:Male, F:Female)\n\nVendorStatus (OK:Active, KO:Inactive, HO:Hold)\n\nLists of values are limited to 1,000 entries. If a list of value needs to contain more than 1,000 entries, you should consider implementing in the form of an entity instead.\n\nTo create a list of values:\n\nRight-click the List of Values node and select Add List of Valuesâ¦. The Create New List of Values wizard opens.\n\nIn the Create New List of Values wizard, check the Auto Fill option and then enter the following values:\n\nName: Internal name of the list of values.\n\nLabel: User-friendly label in this field. Note that as the Auto Fill box is checked, the Label is automatically filled in. Modifying this label is optional.\n\nLength: Length of the code for the LOV.\n\nClick Finish to close the wizard. The List of Values editor opens.\n\nIn the Description field, optionally enter a description for the user-defined type.\n\nAdd values to the list using the following process:\n\nIn the Values section, click the Add Value button. The Create New LOV Value dialog appears.\n\nIn this dialog, enter the following values:\n\nCode: Code of the LOV value. This code is the value stored in an entity attribute.\n\nLabel: User-friendly label displayed for a field having this value.\n\nDescription: Long description of this value.\n\nClick Finish to close the dialog.\n\nRepeat the previous operations to add the values. You can select a line in the list of value and click the Delete button to delete this line. Multiple line selection is also possible.\n\nPress CTRL+S to save the editor.\n\nClose the editor.\n\nList of values can be entered manually as described above and can be translated.\n\nIn addition, you can also import values or translated values from a Microsoft Excel Spreadsheet.\n\nThis spreadsheet must contain only one sheet with three columns containing the Code, Label and Description values. Note that the first line of the spreadsheet will be ignored in the import process.\n\nTo import a list of values from an excel spreadsheet:\n\nOpen the editor for the list of value.\n\nExpand the Values section.\n\nIn the Values section, click the Import Values button. The Import LOV Values wizard appears.\n\nUse the Open button to select a Microsoft Excel spreadsheet.\n\nChoose the type of import:\n\nSelect Import codes, default labels and descriptions to simply import a list of codes, default labels and descriptions.\n\nSelect Import translated labels and description for the following locale then select a locale from the list to import translated labels and descriptions in a given language. Click the Merge option to only update existing and insert new translations. If you uncheck this box, the entire translation is replaced with the content of the Excel file. Entries not existing in the spreadsheet are removed.\n\nClick Next . The changes to perform are computed and a report of object changes is displayed.\n\nClick Finish to perform the import. The Import LOV wizard closes.\n\nPress CTRL+S to save the editor.\n\nClose the editor.\n\nComplex Types\n\nComplex Types are a customized composite type made of several Definition Attributes using Built-in Type, User-Defined Type or a List of Values.\n\nFor example, an Address complex type has the following definition attributes: Street Number, Street Name, Zip Code, City Name and Country.\n\nTo create a complex type:\n\nRight-click the Complex Types node and select Add Complex Typeâ¦. The Create New Complex Type wizard opens.\n\nIn the Create New Complex Type wizard, check the Auto Fill option and then enter the following values:\n\nName: Internal name of the object.\n\nLabel: User-friendly label for this object. Note that as the Auto Fill box is checked, the Label is automatically filled in. Modifying this label is optional.\n\nClick Finish to close the wizard. The Complex Type editor opens.\n\nIn the Description field, optionally enter a description for the complex type.\n\nSelect the Definition Attributes item in the editor sidebar.\n\nRepeat the following steps to add definition attributes to this complex type:\n\nSelect the Add Definition Attributeâ¦ button. The Create New Definition Attribute wizard opens.\n\nIn the Create New Definition Attribute wizard, check the Auto Fill option and then enter the following values:\n\nName: Internal name of the object.\n\nLabel: User-friendly label for this object. Note that as the Auto Fill box is checked, the Label is automatically filled in. Modifying this label is optional.\n\nPhysical Column Name: Name of the physical column containing the values for this attribute. This column name is prefixed with the value of the Physical Prefix specified on the entity complex attribute of this complex type.\n\nType: List of values, built-in or user-defined type of this complex attribute.\n\nLength, Precision, Scale. Size for this definition attribute. The fields available depend on the built-in type selected. For example a String built-in type will only allow entering a Length. If a list of values or a user-defined type was selected, these values cannot be changed.\n\nMandatory: Check this box to make this definition attribute mandatory when the complex type is checked for mandatory values.\n\nClick Finish to close the wizard. The new definition attribute appears in the list. You can double-click the attribute in the list to edit it further and edit its advanced properties (see below).\n\nPress CTRL+S to save the Complex Type editor.\n\nClose the editor.\n\nA complex type has the following advanced properties that impact its behavior:\n\nMandatory: When an entity attribute is checked for mandatory values, and this attribute uses a complex type, each of the definition attributes of this complex type with the mandatory option selected are checked.\n\nSearchable: This option defines whether this attribute is used for searching.\n\nTranslated: Options reserved for a future use.\n\nMulti-Valued: This option applies to definition attributes having the type list of values. Checking this box allows the definition attribute to receive several codes in the list of values, separated by the Value Separator provided. For example, a multi-valued Diplomas field can receive the DM, DP, DPM codes meaning that that contact is Doctor of Medicine, Pharmacy and Preventive Medicine.\n\nEntities are the key components of the logical modeling. They are not database tables, but they represent Business Entities of the domain being implemented in the MDM Project. Example of entities: Customers, Contacts, Parties, etc.\n\nEntity Characteristics\n\nEntities have several key characteristics. They are made of Attributes, have a Matching Behavior and References. They also support Inheritance.\n\nAttributes\n\nEntities have a set of properties, called Attributes. These attributes can be either:\n\nSimple Attributes using a built-in types, user-defined types or a list of values created in the model.\n\nComplex Attributes using complex types created in the model.\n\nFor example, the Contact entity may have the following attributes:\n\nFirstName and LastName: Simple attributes using the user-defined type called GenericNameType\n\nComments: Simple attribute using the built-in type LongText.\n\nGender: Simple attributes based on the GenderLov list of values.\n\nAddress: Complex Attribute using the GeocodedAddress complex type.\n\nMatching Behavior\n\nEach entity has a given a matching behavior. This matching behavior expresses how similar instances (duplicates) of this entity are detected:\n\nID Matching (formerly known as UDPK): Records in entities using ID Matching are matched if they have the same ID. This matching behavior is well suited when there is a true unique identifier for all the applications communicating with the MDM hub and for simple Data Entry use cases.\n\nFuzzy Matching (formerly known as SDPK): Records in entities using Fuzzy Matching are matched using a set of match rules defined in a Matcher.\n\nThe choice of a Matching Behavior is important. Please take into account the following differentiators when creating an entity.\n\nID Matching\n\nID Matching means that all applications in the enterprise share a common ID. It may be a Customer ID, an SSID, etc.. This ID can be used as the unique identifier for the golden records.\n\nThis ID is stored into a single attribute which will be the golden data Primary Key. If the ID in the information system is composed of several columns, you must concatenate these values into the PK column.\n\nAs this ID is common to all systems, matching is always be made using this ID.\n\nA Matcher can be defined for the entity, for detecting potential duplicates when manually creating records in the hub via a data entry workflow.\n\nUse ID Matching only when there is a true unique identifier for all the applications communicating with the MDM Hub, or for simple data entry use cases.\n\nFuzzy Matchings\n\nFuzzy Matching means that applications in the enterprise have different IDs, and Semarchy Convergence for MDM needs to generate a unique identifier (Primary Key - PK) for the golden records. This PK can be either a sequence or a Unique ID (UUID).\n\nSimilar records may exist in the various systems, representing the same master data. These similar records must be matched using fuzzy matching methods that compare their content.\n\nA Matcher must be defined in such entity to describe how source records are matched as similar records to be consolidated into golden records.\n\nUse Fuzzy Matching only when you do not have a shared identifier for all systems, or when you want to perform fuzzy matching and consolidation on the source data.\n\nID Generation\n\nThe matching behavior impacts the method used for generating the values for the Golden Record Primary Key:\n\nID Matching Entities: The Golden Record Primary Key is also the ID that exists in the source systems. When users create new records using data entry workflows, the ID may either be entered manually by the users, or be automatically generated using a Sequence, a Universally Unique Identifier generator (UUID) or a SemQL expression.\n\nFuzzy Matching Entities: The Golden Record Primary Key is managed and always generated by the system, using a Sequence or a Universally Unique Identifier generator (UUID). When users create new records using data entry workflows, the Source ID may either be entered manually by the users, or be automatically generated using a Sequence, a Universally Unique Identifier generator (UUID) or a SemQL expression.\n\nWhen generating IDs automatically using a Sequence in data entry forms for an ID Matching entity, you must take into account records pushed by other publishers (using for example a data integration tool). These publishers may use the same IDs for the same entity, and in this case the records will match by ID. If you want to separate records entered manually from other publishers' records and avoid unexpected matching, configure your sequence using the Start With option to start beyond the range of IDs used by the other publishers.\n\nAn ID generated with a SemQL expression is immutable. This ID will not change after the initial record creation even if the value of the attributes used in the expression change. Such an ID is created when a record form is saved for the first time in a data entry workflow, when a record is imported from a file containing no IDs, or when a record is persisted via a web services operation using a payload that contains no ID.\n\nReferences\n\nEntities are related using Reference Relationships. A reference relationship defines a relation between two entities. For example, an Employee is related to a CostCenter by a EmployeeHasCostCenter relation.\n\nConstraints\n\nData quality rules are created in the design of an entity. These constraints include:\n\nMandatory columns\n\nList of Values range check\n\nUnique Key\n\nRecord level Validations.\n\nReference Relationships\n\nThese constraints are checked on the source records and the consolidated records as part of the integration process. They can also be checked to enforce data quality in data entry workflows .\n\nInheritance\n\nEntities can extend other entities (Inheritance). An entity (child) can be based on another entity (parent).\n\nFor example, the PersonParty and OrganizationParty entities inherit from the Party entity.\n\nThey share all the attributes of their parent but have specificities.\n\nWhen inheritance is used:\n\nThe child entity inherits the following elements: Attributes, Unique Keys, Validations, Enrichers, References and Display Name.\n\nMatchers and Consolidators are not inherited\n\nIt is not possible to modify the matching behavior. The child inherits from the parent’s behavior.\n\nIt is possible to add elements to the child entity: Attributes, Unique Keys, Validations, Enrichers and References.\n\nThe display name defined for the parent entity can be amended in a child entity by appending additional attributes from the child. The separator can be changed.\n\nWhen using inheritance, the underlying physical tables generated for the child entities and parent entity are the same. They contain a superset of all the attributes in the cluster of entities.\n\nDisplay Options\n\nEntities also have display options, including:\n\nA Display Name defining how the entity is display in compact format.\n\nTranslations to display the entities information in a client’s locale.\n\nIntegration Rules\n\nIn addition to the display characteristics, an entity is designed with integration rules describing how master data is created and certified from the source data published by the source applications.\n\nThese characteristics are detailed in the Integration Process Design chapter.\n\nReference Relationships functionally relate two existing entities. One of them is the referenced, and one is referencing.\n\nFor example:\n\nThey are used for:\n\nA reference is expressed in the model in the form of a foreign attribute that is added to the referencing attribute.\n\nData Quality Constraints include all the rules in the model that enforce a certain level of quality on the entities. These rules include:\n\nThe Mandatory Attributes and LOV Validations are designed when creating the Entities. The references are defined when creating Reference Relationships.\n\nIn this section, the Unique Keys and Validations are described. Refer to the previous sections of the chapter for the other constraints.\n\nA Diagram is a graphical representation of a portion of the model or the entire model.\n\nUsing the Diagram, not only you can make a model more readable, but you can also create entities and references in a graphical manner, and organize them as graphical shapes.\n\nIt is important to understand that a diagram only displays shapes which are graphical representations of the entities and references. These shapes are not the real entities and reference, but graphical artifacts in the diagram:\n\nWorking with Entities and References\n\nIn this section, the creation/deletion of entities and references from the diagram is explained.\n\nTo create an entity using the diagram:\n\nIn the Palette, select Add Entity.\n\nClick the diagram. The Create New Entity wizard opens.\n\nFollow the entity creation process described in the Creating an Entity section.\n\nThe entity is created and a shape corresponding to this entity is added to the diagram.\n\nNote that you can also create, edit and delete attributes from the diagram. Select an attribute or entity and use the context menu options.\n\nTo create a reference using the diagram:\n\nIn the Palette, select Add Reference.\n\nSelect the referencing entity in the diagram. Keep the mouse button pressed, and move the cursor to the referenced entity.\n\nRelease the mouse button. The Create New Reference wizard opens. It is pre-filled based on the two entities.\n\nFollow the reference relationship process described in the Reference Relationships section.\n\nThe reference is created and a shape corresponding to this reference is added to the diagram.\n\nTo delete a reference or an entity from the diagram:\n\nIn the diagram, select the entity of reference that you want to delete.\n\nRight-click and select Delete.\n\nClick OK in the Confirm Delete dialog.\n\nThe reference or entity, as well as the shape in the diagram disappear.\n\nDeleting an entity or reference cannot be undone.\n\nWorking with Shapes\n\nIn this section, the creation/deletion of shapes in the diagram without changing the real entity or reference is explained.\n\nTo add existing entities to the diagram:\n\nIn the Palette, select Add Existing Entity.\n\nClick the diagram. The Selection Needed dialog opens showing the list of entities in the diagram.\n\nSelect the entities to add to the diagram.\n\nClick OK. The shapes for the selected entities are added to the diagram.\n\nYou can repeat this operation if you want to add multiple shapes for an entity in the diagram.\n\nTo add existing references to the diagram:\n\nIt is not possible to manually create a shape for reference in a diagram.\n\nWhen an entity is added to the diagram, shapes for the references relating this entity to entities already in the diagram are automatically added.\n\nTo remove a shape from the diagram:\n\nIn the diagram, select the shape representing the entity of reference that you want to delete.\n\nRight-click and select Remove Shape.\n\nThe shape disappears from the diagram. The entity or reference is not deleted.\n\nReverse-engineering can be used to quickly populate a model from table structures stored in a schema.\n\nDuring this process, entities are created with attributes named after the column names.\n\nModel Variables contain values that are used to customize the user experience or parameterize a certification job. Variable values are local to the user session or executed job. They are set either via a job parameter (for jobs), or retrieved from remote servers (declared as Variable Value Providers) when the user opens his session. Variables can be used in SemQL filters and expressions created at design and run-time.\n\nFor more information about Variable Value Providers, see the Configuring Variable Value Providers section in the Semarchy Convergence for MDM Administration Guide.\n\nUsing Model Variables\n\nModel Variables can be used:\n\nIn user sessions: They are set when the user accesses an application, using a variable value provider. In this context, variables are used to parameterize the user experience (for example, in filters restricting the user privileges).\n\nIn certification jobs: In a certification job, a variable value is usually set using a job parameter. If no job parameter is set, the value is set using the variable value provider. In this context, variables are used to parameterize the job execution (for example, in an enricher’s filter expression to prevent the enricher from processing any record depending on the value).\n\nModel Variable can be used, for example, in the following SemQL expressions:\n\nUser’s search filters defined when accessing the data,\n\nRoot and transition filters for Business Objects,\n\nAttributes expressions for Form and Table Views,\n\nRow-level security filters defined in the Model Privileges,\n\nEnricher filters or expressions,\n\nEtc.\n\nIn these SemQL expressions, you can bind the model variable using the :<variable name> syntax. You can also use in these expressions the built-in :V_USERNAME bind variable.\n\nVariable values are not persisted. They are retrieved when the user connects, and disposed at the end of the user session. If the content of the Variable Value Provider (Remote LDAP Directory or Database) is modified, the changes are taken into account only when the user re-connects to Semarchy Convergence for MDM.\n\nWhen a model variable is used in a job, but no corresponding job parameter is set for the job, then the variable takes its value from the variable value provider, using as the connected user the one that has started the job.\n\nCertain display properties are defined as part of the logical modeling effort.\n\nThe Labels and Descriptions provided when creating and editing the entities, attributes, types and references are are used when displaying the entities of the model in the context of applications, and as default labels and descriptions when using attributes from these entities. Other artifacts specific to displaying a model can be defined in the model. They include the Entity Display Names and Complex Types Display Names, described in the following sections.\n\nEntity Display Names\n\nAn entity is a structure containing several attributes (simple and complex). When an entity value needs to be displayed in a compact form (for example, in a table, or in a single field), the Display Name is used.\n\nThe display name defines how an entity is displayed in compact form. It is a concatenation of several attributes, separated by a Separator.\n\nFor example, a Contact entity is shown as <first name>Ë½<last name>..\n\nTo create or modify an entity display name:\n\nRight-click the entity node and select Define Display Nameâ¦. The Modify Display Name wizard opens.\n\nIn the Modify Display Name wizard, enter the following values:\n\nSeparator: String that will separate the selected attributes in the display name.\n\nClick Next.\n\nIn the Display Name Attributes page, select the Available Attributes that you want to add and click the Add >> button to add them to the Selected Attributes.\n\nUse the Move Up and Move Down buttons to order the selected attributes.\n\nClick Finish to close the wizard.\n\nPress CTRL+S to save the Display Name editor.\n\nClose the editor.\n\nOnly one display name can be created for a given entity.\n\nThe Integration Process transforms Source Records pushed in the hub by several Publishers into consolidated and certified Golden Records. This process is automated and involves several phases, generated from the rules and constraints defined in the model. The rules and constraints are defined in the model based on the functional knowledge of the entities and the publishers involved.\n\nIntegration Jobs\n\nWhen all the rules are defined, one of more Integration Jobs can be defined for the model.\n\nThe integration job will run to perform the integration process, using the hub’s database engine for most of the processing (including SemQL processing) and Semarchy Convergence for MDM for running the plug-ins code.\n\nIntegration jobs are triggered to integrate data published in batch by data integration/ETL tools, or to process data handled by users in human workflows.\n\nWhen pushing data in the hub, a data integration or ETL product performs the following:\n\nIt requests a Load ID to identify the data load and initiate a transaction with Semarchy Convergence for MDM.\n\nIt loads data in the landing tables of Semarchy Convergence for MDM, possibly from several sources identified as Publishers.\n\nIt submits the load identified by the Load ID, and when submitting the load, it provides the name of the Integration Job that must be executed to process the incoming data.\n\nSimilarly, when a user starts a human workflow for data entry and duplicate management:\n\nA transaction is created and attached to the workflow instance and is identified by a Load ID.\n\nThe user performs the data entry and duplicate management operations in the graphical user interface. All the data manipulations are performed within the transaction.\n\nWhen the activity is finished, the transaction is submitted. This triggers the Integration Job specified in the workflow definition.\n\nPublishers are application and users that provide source data to the MDM Hub. They identify themselves using a code when pushing batches of data.\n\nThe publisher does not represent the technical provider of the data (the ETL or Data Integration product), but the source of the data (The CRM Application, the Sales Management system, etc.). Examples of publishers: CRM, Sales, Marketing, Finance, etc.\n\nConsolidation performs certain choices depending on the publishers, and the publishers are tracked to identify the origin of the golden data certified by Semarchy Convergence for MDM.\n\nEnrichers normalize, standardize and enrich Source Data pushed by the Publishers in the hub or Consolidated Data resulting from the match and merge process.\n\nThere are two types of enrichers:\n\nCreating Plug-in Enrichers\n\nA Plug-in Enricher enriches several attributes of an entity using attributes from this entity, transformed using a plug-in developed in Java.\n\nA plug-in enricher takes:\n\na list of Plug-in Inputs: These are attributes possibly transformed using SemQL.\n\na list of Plug-in Parameters values.\n\nIt returns a list of Plug-in Outputs which must be mapped on the entity attributes.\n\nAttributes are mapped on the input to feed the plug-in and on the output to enrich the entity with the resulting data transformed by the plug-in.\n\nBefore using a plug-in enricher, make sure the plug-in was added to the platform by the administrator. For more information, refer to the Semarchy Convergence for MDM Administration Guide.\n\nTo create a plug-in enricher:\n\nExpand the entity node, right-click the Enrichers node and select Add Plug-in Enricherâ¦. The Create New Plug-in Enricher wizard opens.\n\nIn the Create New Plug-in Enricher wizard, check the Auto Fill option and then enter the following values:\n\nName: Internal name of the object.\n\nLabel: User-friendly label for this object. Note that as the Auto Fill box is checked, the Label is automatically filled in. Modifying this label is optional.\n\nPlug-in ID: Select the plug-in from the list of plug-ins installed in the platform.\n\nClick Next.\n\nOptionally click the Edit Expression button to open the expression editor to define a filter. The enricher will only enrich those of the records respecting this filter. Skip this task if you want to enrich all the records.\n\nClick Finish to close the wizard. The Plug-in Enricher editor opens. The Plug-in Params, Plug-in Inputs and Plug-in Outputs tables show the parameters and inputs/outputs for this plug-in.\n\nSelect the Enrichment Scope for this enricher. The scope may be Pre-Consolidation Only, Post-Consolidation Only, Pre and Post Consolidation or None (not executed in the jobs).\n\nOnly the parameters that are mandatory for the plug-in to work are listed in the Plug-in Params. You can add the parameters that you need to set to the list:\n\nIn the Plug-in Params table, click the Define Plug-in Parameters button.\n\nIn the Parameters dialog, select the Available Parameters that you want to add and click the Add >> button to add them to the Used Parameters.\n\nClick Finish to close the dialog.\n\nSet the values for the parameters:\n\nClick the Value column in the Plug-in Params table in front a parameter. The cell becomes editable.\n\nEnter the value of the parameter in the cell, and then press Enter.\n\nRepeat the previous steps to set the value for the parameters.\n\nOnly the inputs that are mandatory for the plug-in to work are listed in the Plug-in Inputs. You can add the inputs that you need to set to the list:\n\nIn the Plug-in Inputs table, click the Define Plug-in Inputs button.\n\nIn the Input Bindings dialog, select the Available Inputs that you want to add and click the Add >> button to add them to the Used Inputs.\n\nClick Finish to close the dialog.\n\nSet the values for the inputs:\n\nClick the Expression column in the Plug-in Inputs table in front an input and then click the Edit Expression button. The SemQL editor opens.\n\nEdit the SemQL expression using the attributes to feed the plug-in input and then click OK to close the SemQL Editor.\n\nRepeat the previous steps to set an expression for the inputs.\n\nSelect the attributes to bind no the Plug-in Outputs:\n\nIn the Plug-in Outputs table, click the Define Plug-in Outputs button.\n\nIn the Output Bindings dialog, select the Available Attributes that you want to enrich and click the Add >> button to add them to the Attributes Used.\n\nClick Finish to close the dialog.\n\nFor each attribute in the Plug-in Outputs table, select in the Output Name column the plug-in output that you want to use to enrich the attribute shown in the Attribute Name column.\n\nOptionally, you can use Advanced Plug-in Configuration properties to optimize and configure the plug-in execution.\n\nPress CTRL+S to save the editor.\n\nClose the editor.\n\nAdvanced Plug-in Configuration\n\nThe enrichers and validations plug-ins provide options for optimizing and configuring their execution.\n\nThe following properties appear in the Advanced Configuration section of the editor:\n\nMax Retries: If the execution of the plug-in fails, it is repeated for this number of times.\n\nBehavior on Error: If the execution still fails after the Max Retries have been attempted, the plug-in either Skip the current record, skips the entire enrichment task, or stops the whole job, depending on this property.\n\nThread Pool Size: This property defines the number of parallel threads used by this plug-in. This option is taken into account if the plug-in used is thread safe and declared as such.\n\nSeveral validations can be defined per Entity. Validations check attribute values and reject invalid records. All validations are executed on each record.\n\nValidations can take place (and/or):\n\nPre vs. Post Validation\n\nPre-Consolidation Validation is done on the data from all publishers to this entity, after enrichment.\n\nPost-Consolidation Validation is done on data de-duplicated and consolidated.\n\nChoosing a validation to be done pre and/or post validation has an impact on the behavior of the integration hub.\n\nThe following examples will illustrate the impact of the choice of the pre or post consolidation validation.\n\nExample #1:\n\nThe CheckNullRevenue validation checks that Customer.revenue is not null.\n\nCustomer data is published from the CRM and Sales applications.\n\nOnly the Sales publisher loads revenue data. CRM leaves it null.\n\nThe consolidation needs critical information from the CRM application (email, name, address, etcâ¦)\n\nIf CheckNullRevenue is executed pre-consolidation, all data from the CRM will be rejected, as revenue is null.\n\nAt consolidation, no data will be consolidated from the CRM.\n\nIn this example, CheckNullRevenue should be done Post-Consolidation to avoid rejecting information required later in the integration process.\n\nExample #2:\n\nThe matching process for Customer uses the GeocodedAddress to match customers from all the sources.\n\nAn IsValidGeocodedAddress validation checks that GeocodedAddress is not empty and GeocodedAddress.Quality is high enough.\n\nEnrichers will create a GeocodedAddress, if possible.\n\nIf the resulting GeocodedAddress is empty or not good enough, then these customers should not be processed further.\n\nIn this example, IsValidGeocodedAddress should be done Pre-consolidation to avoid the performance cost of matching records with addresses not meeting the entity requirements.\n\nThe matching phase detects the duplicates in order to consolidate them into a single golden record.\n\nUnderstanding Match and Merge\n\nWhen using ID Matching, the outcome of the matching process is extremely predictable. Indeed, two records with the same ID will match and will be merged according to the Consolidator.\n\nWhen using Fuzzy Matching, the outcome of the matching process is less predictable, as it is based on fuzzy match rules and algorithms that depend on the data in the record. This section explains how match and merge work in this context.\n\nMatch Rules and Scoring\n\nFirst, the matching must detect the duplicates, that is pairs of records that match because they are somehow similar.\n\nMultiple Match Rules in a matcher allow you to define several conditions for considering two records a match. Each condition has a different Matching Score. This score represents the percentage of confidence you put in a match that occurs thanks to a rule.\n\nWhen two records match, they receive a match score equal to the highest score of all the rules that matched them (highest confidence).\n\nMatching Groups & Group Confidence Score\n\nMatching Groups re-group duplicate records that have matched. These groups are created using matching transitivity.\n\nThe matching mechanism is transitive, which means that:\n\nIf A matches B and B matches C, then A, B and C are in the same matching group.\n\nEach matching group has a Confidence Score that expresses how confident you can be with that group of matching records.\n\nThis score is the average of the match scores in the group. Pairs in the group that have not matched by any rule are considered as having a score of zero.\n\nMerging Groups into Golden Records\n\nDepending of the confidence score, you may let the matcher automatically merge the match group. This operation creates a Golden Record from the group, then applies the Consolidator rule to the group of records to define the values that are consolidated in the golden record.\n\nIf a match group is not merged automatically, because its confidence score is not high enough, it is flagged as a Merge Suggestion. In that case:\n\nIncoming records are kept as singleton golden records.\n\nExisting group of records and golden records remain untouched.\n\nMerge Suggestions can be reviewed by data stewards in duplicate management workflows, to decide whether or not to merge groups and create golden records.\n\nThe Merge Policy set when Creating a Matcher defines the confidence scores required to automatically merge groups in a variety of situations. See Automating Merge and Confirmation for more information about the merge policy.\n\nConfirming Golden Record\n\nAs the values change in the source records, the match groups and golden records may change.\n\nConfirming a Golden Record consists in \"freezing\" the match group to avoid having it reconsidered every time data changes. This is typically done by a data steward in the context of a duplicates management workflow. The steward manually confirms the correct match groups and fixes the incorrect match groups.\n\nDepending of the confidence score computed for a match group, you may also want to automatically confirm the golden record to avoid having the steward reviewing all the data.\n\nThe Auto-Confirm Policy set when Creating a Matcher defines the confidence score required to automatically confirm golden records. It also allows you to set whether singletons (golden records composed of a single master record) should be automatically confirmed.\n\nOver time, records may have the following Confirmation Status:\n\nNot Confirmed: The golden record was never confirmed by the matcher or a user.\n\nConfirmed: The golden record was entirely confirmed by the matcher or a user.\n\nPartially Confirmed: Part of the match group that composes the golden record was confirmed by a user, but some masters in this match group are still not marked as confirmed.\n\nPreviously Confirmed: A record that was confirmed but which group has been modified by a user.\n\nRegardless of the Confirmation status of a record, a data stewards is always able in a duplicate management workflow to manually split and merge duplicates.\n\nConsolidation merges fields from all the duplicates detected into a single golden record. It is defined in the Consolidator defined in the entity.\n\nAn Integration Job is a job executed by Semarchy Convergence for MDM to integrate and certify source data into golden records. This job uses the rules defined as part of the integration process, and contains a sequence of Tasks running these rules. Each task addresses one entity, and performs several processes (Enrichment, Validation, etc.) for this entity.\n\nJobs Sequencing and Parallelism\n\nJobs are a sequence of task. These tasks must be ordered to handle referential integrity. For example, if you process the Contact entity and then the Customer entity, you may start processing new contacts attached to customers that do not exist yet. You should preferably process the customers then the contacts.\n\nJobs are themselves executed sequentially in a defined Queues in a FIFO (First-In First-Out) mode.\n\nIf two jobs can run simultaneously, they should be in different queues. For example, if two jobs address two different areas in the same model, then these jobs can run simultaneously in different queues.\n\nIt is not recommended to configure jobs processing the same entity to run in different queues. Instances of these jobs running simultaneously in two different queues may write conflicting changes to this entity, causing major data inconsistencies.\n\nThe model contains entities describing all the master of the enterprise. Business users and data stewards require specific access to the master data the hub, depending on their roles and privileges.\n\nFor example, a deployed model contains customer, contact, employee and cost center entities:\n\nSuch an access to specific access to the master data is defined in Semarchy Convergence for MDM using Applications.\n\nAn application provides the following features:\n\nObjects and Views\n\nIn an application, business users can browse and edit the content of the MDM Hub using user-friendly views called Business Object Views.\n\nA business object view joins several elements:\n\nA Business Object, which is composite object made up from a set of related entities. It is described as a Root Entity and a set of navigable Transitions to Entity Objects. For example, the Company Hierarchy business object includes information from the Cost Center and the Employee entities, and uses the relations that link employee to managers, cost centers to parent cost centers, and employees to cost centers for the transitions.\n\nForm Views and Table Views that describe the layout used to display the entities involved in business object and workflows as forms (e.g.: one Employee record) or tables (e.g.: a list of Employee records reporting to a cost center).\n\nSearch Forms that describe customized screens for searching and filtering each node of the business object.\n\nYou can accelerate the design of applications by Duplicating Objects such as the business object, business object, form/table views and search forms.\n\nDesign Process\n\nWhen creating an application, the designer creates:\n\nVarious Forms Views and Table Views to define the layout of the entities used in the application.\n\nVarious Search Forms to define how to search the entities used in the application.\n\nVarious Business Objects by assembling Entities Objects (from the entities) and organizing them through Transitions (based on the relations).\n\nVarious Business Object Views that will state how these business objects must be displayed using the configured form and table views.\n\nBusiness Objects, Form/Table views and Search Forms can be reused in several Business Object Views across the applications attached to the model. The business object defines a functional group of related entities. The business object view defines how a business object is displayed in a specific application.\n\nTable Views\n\nTable views are views used to display a list of records for a given entity in the context of a business object view or in a duplicate management workflow.\n\nSuch a table has is an ordered list of Table Attributes (columns in the table), and each attribute displays a SemQL expression built from the attributes of the entity. It is possible for all attributes to provide a Custom Label for the table attribute as well as a Display Types.\n\nFor example, to display a list of Employee records, we define two table views:\n\nThe SimpleEmployeeList table view that displays the following attributes:\n\nThe Employee Name, that is the First Name concatenated with Last Name using the following SemQL expression: FirstName || ' ' || LastName\n\nThe employee’s Cost Center.\n\nThe FullEmployeeList table view that displays the same attributes plus confidential information such as Salary, Hire Date, etc.\n\nThe first view will be used in most cases, and the second view will be relevant for applications dedicated to HR users.\n\nThe example below shows a table view in action for an Employee entity.\n\nForm Views\n\nForm views are views used to display the details for one record for a given entity.\n\nA form view is organized in ordered Form Sections that contains an ordered list ordered list of Form Section Attributes.\n\nSimilarly to the attributes of the Table Views, the form section attributes:\n\nDisplay a SemQL expression built from the attributes of the entity.\n\nSupport Custom Labels.\n\nSupport Display Types.\n\nForm views support two types of layout:\n\nThe Flow Layout shows the sections and the attributes within the sections ordered in a vertical flow. This simple layout can be designed very fast.\n\nThe Grid Layout shows sections and attributes at a fixed positions in the form. They are positioned and sized on a grid at design-time. This layout required more work at design-time but gives better results for complex forms.\n\nBoth a grid and a flow layout can be defined for a form view. Switching from grid to flow is performed by user actions or automatically depending on the size of the browser window.\n\nThe figures below show a form view for an employee entity in action with a flow layout, then with a grid layout.\n\nDisplay Types\n\nEach form or table attribute can be associated with a Display Type. The display type defines the graphical component used to show the attribute’s value in the table or form view. The graphical component can be configured using its display properties.\n\nThe available display types are listed in the following table:\n\nDisplay Component Description Available Properties\n\nEach display type is appropriate for displaying certain data. Only the display types relevant for given attribute are available when editing this attribute in the workbench.\n\nThe display properties available for the display types are described in the table below.\n\nDisplay Property Description\n\nNumber Formatting\n\nThe Number Format display property defines the pattern used for rendering numeric values.\n\nIn this pattern:\n\n# corresponds to a digit.\n\n0 corresponds to a digit that is replaced by a zero if not present.\n\n, corresponds to a grouping separator, (typically, a separator for the thousands). This separator is automatically localized.\n\n. corresponds to the decimal separator. This separator is automatically localized.\n\nÂ¤ (Unicode character 00A4) corresponds to the localized currency symbol. It can be used as a prefix or postfix.\n\n%: When used as a prefix or suffix, the value is multiplied by 100 and rendered as a percentage.\n\nYou can define two different patterns for positive and negative values, separated by a semi-colon. For example “###.00;(###.##)” renders negative values between parenthesis.\n\nThe complete pattern reference (including exponential and scientific notations) is available in the Java Decimal Format Pattern reference.\n\nPattern examples (in a US-English Locale):\n\nPattern Value Result\n\n###,###.##\n\n15000000.2\n\n15,000,000.2\n\n####,####.##\n\n15000000.2\n\n1500,0000.2\n\n####.00\n\n15.2\n\n15.20\n\n####\n\n15.2\n\n15\n\n0000\n\n15.2\n\n0015\n\n###.00;(###.##)\n\n15.2\n\n15.20\n\n###.00;(###.##)\n\n-15.2\n\n(15.2)\n\n###Â¤\n\n152\n\n152$\n\nBuilt-in Search Types and Search Forms\n\nConvergence for MDM provides the following built-in search types to look for data in entities:\n\nText: The text search looks up all attributes marked as Searchable in the model that match your search pattern. You can use the % wildcard to match a number of characters or _ to match a single character.\n\nBy Form: This method shows a default form with all the attributes available, and pickers to select values to filter these attributes.\n\nAdvanced Search: Advanced search allows you to specify which attributes to search on and the operators you want to use for comparison.\n\nSemQL: SemQL search allows you use SemQL queries to search. With SemQL, you can use attributes in parent entities or child entities, as well as the SemQL library of functions.\n\nIn addition to these search types, you can design your own Search Forms.\n\nA Search Form exposes several Search Parameters. When the user submits a search form, a search query is issued, using these parameters are bind values.\n\nBusiness Objects\n\nA Business Object is a composite object made up from a set of related entities. It is a functional subset of the model.\n\nFor example, the Company Hierarchy business object includes information from the Cost Center and the Employee entities, and uses the relations that link employees to managers, cost centers to parent cost centers, and employees to cost centers.\n\nEntities used in the business object are defined as Entity Objects. A given entity may appear several times in the same business object. For example, the Customer entity may be used in a business object twice, once to describe the Domestic Customers and once for the International Customers. An entity object is a direct link to an entity, associated with a Filter.\n\nTransitions enable the navigation between entity objects within a given business object. The transitions are created based on the relationship references defined between the entities. For example, if the Cost Center entity is related to the Employee entity through the Employee has Cost Center reference relationship, it is possible in a business object to create a transition to navigate from the cost center to the reporting employees.\n\nA business object is always defined with a Root Entity Object. This root entity object is the entry point of the business object.\n\nFor example, in the Company Hierarchy business object, the root entity object is created from the Cost Center entity, filtered to only return the root cost centers in the hierarchy of cost centers (that is those with no parent cost center).\n\nBusiness Object Views\n\nA Business Object View defines how the business object appears and is used in the application:\n\nFor each entity object, you select a form view to define how one record is displayed. For example, the details of one cost center.\n\nFor each transition, you select a table view to define how the list of child elements of a transition is displayed. For example, the list of employees reporting to a cost center, or the list of child cost centers attached to a given cost center.\n\nFor each entity object, you create a Search Configuration to defined the available built-in search methods and configurable search forms.\n\nBusiness object views are defined within an application, and serve two purposes:\n\nThey are used to browse and search data in a user friendly way from the Application Structure.\n\nThey are used to edit data in the hub as part of a Data Entry Activity.\n\nThe following example shows one instance of the CostCenter business object, displayed through a business object view. The CostCenter business object uses CostCenter as its root object (filtered to show only the root cost centers), and has transitions to the Child Cost Centers (this transition recurses to show an infinite depth of cost centers) and to the cost center’s Reporting Employees. The form and tables used to display each node of the hierarchy are defined in the business object view.\n\nHuman Workflows\n\nHuman Workflows enable business users to manage the data in the MDM hub via an application.\n\nWhen users want to manage the master data, they initiate an Activity based on a predefined human workflow. This activity follows the workflow through Transitions and Tasks which are assigned to roles, claimed, processed and then completed by users. The last task of a workflow can submit (or cancel) the data changes done in the activity, and start a data certification process with these changes.\n\nThere are two types of human workflows in Convergence for MDM:\n\nDuplicate Management Workflows: These workflows allow data stewards to override the decisions taken by the matchers running in the hub. Through these workflows, stewards can either manually match unmatched records, or split duplicate groups that were incorrectly matched (false matches).\n\nData Entry Workflows: These workflows allow data stewards or business users to contribute to the hub as manual publishers. The data entered via these workflows goes through the data certification process to create golden data. Contribution via data entry workflows includes authoring new data, modifying existing data or fixing rejects.\n\nYou can accelerate the design of applications by duplicating workflows.\n\nWorkflow Lifecycle\n\nA workflow is a set of tasks, linked by transitions. A running or completed workflow instance is called an Activity.\n\nAn activity is initiated from an Application. When an activity runs, it executes a single task at a time. A task is assigned to a role declared in Convergence for MDM. Such a task can be claimed by a user having this role. This user then can perform data entry or duplicate management operations. When the task is completed, the user completes the task and moves it through a transition to another task.\n\nThe task may finish the activity either via a submit or a cancel operation. The cancel operation cancels any duplicate management or data entry action, and the submit operation submits into the hub the data entry or duplicate management transaction. After a submit operation, an integration job is started to certify the changes performed in the activity.\n\nTransaction\n\nAn activity carries along a Load Transaction (equivalent to an external load) which contains the duplicates modified or the records manually entered by the users. This transaction attached to the activity, and is transferred with the activity when a task is assigned to a role. This enables multiple entry/edition points and validations steps as part of the workflow.\n\nAn application provides a customized access to the MDM Hub.\n\nViews and object define how business users and data stewards see the MDM hub content in an application.\n\nCreating Table Views\n\nA Table View provides a layout for displaying a list of records for a given entity.\n\nTo create a table view:\n\nRight-click the Table Views node under an entity and select Add Table Viewâ¦. The Create New Table View wizard opens.\n\nIn the Create New Table View wizard, enter the following values:\n\nName: Internal name of the object.\n\nDefault: Select this option if the table view should be used as the default table view for this entity.\n\nClick Finish to close the wizard. The Table View editor opens.\n\nThe table view editor display a list of available attributes and a table showing all the attributes from the table view, with their label and SemQL expression.\n\nTo add attributes to a table view:\n\nIn the Table View editor’s Table tab, drag an attribute from the available Attributes list to the list of table attributes. The new attribute is added to the table attributes table:\n\nIn the table attributes table, you can modify the Name, Label, or Height or this table attribute.\n\nClick the (â¦) Edit Expression button to create a complex expression for the table attribute.\n\nYou can also reorder attributes in this table using drag and drop.\n\nTo edit an attribute, select the Properties view, and then select the attribute in the attributes table. The Properties view shows all its properties, including:\n\nName, Label and Description. Note that if the Use Custom Label option is unchecked, then a default label is used: if the SemQL expression is a simple entity attribute, the default label is the label of this attribute, otherwise, the text of the SemQL expressions is used.\n\nDisplay Types used for the table attribute.\n\nHelp Content: content displayed as the help text for the attribute. This either the attribute metadata or its description.\n\nRead-Only: Select this option to make this field read-only. If this form is used for data entry, read-only fields cannot be edited in the form regardless of the user privileges. Use this option for example to make part of the form or the entire form un-editable, or to include form attributes that are loaded only via enrichers.\n\nYou can add not only attributes from the entity, but also attributes of entities related to the current entity (For example, an employee’s parent Cost Center name), or any complex SemQL expression.\n\nYou can alternately select (by pressing the CTRL key) and drag and drop multiple attributes from the attribute list.\n\nTo remove an attribute from a table view:\n\nSelect the attribute in the attributes table.\n\nClick the Delete Selection button in the editor toolbar and confirm the deletion. The attribute is removed from the table.\n\nCreating Form Views\n\nA Form View provides an organized layout for displaying a given entity record in a form. It is composed of several Form Sections, each section containing Form Attributes.\n\nForm view are arranged either using a vertical Flow Layout, where section and attributes are simply ordered, or a Grid Layout, where each section and attribute is positioned on a grid. You may design a form with one or both layouts. When both layouts are available, the form view switches from grid to flow layout either by user action, or automatically when the display falls below a certain width.\n\nTo create a form view:\n\nRight-click the Form Views node under an entity and select Add Form Viewâ¦. The Create New Form View wizard opens.\n\nIn the Create New Form View wizard, enter the following values:\n\nName: Internal name of the object.\n\nDefault Form View: Select this option if the form view should be used as the default form view for this entity.\n\nDefault Layout: Select the layout used when opening the form view.\n\nUser Layout Switch: Select this option to enable the layout switch by the user.\n\nAuto Layout Switch: Select this option to enable the automated switch based on the Auto Layout Width.\n\nClick Finish to close the wizard. The Form View editor opens.\n\nTo design both the flow and grid layouts for the form view, you must have either User Layout Switch or Auto Layout Switch activated. Otherwise, you can only design the layout selected in the Default Layout.\n\nWhen working with the Form View editor:\n\nThe Overview tab shows the global options for the form view.\n\nThe Outline view shows the sections and attributes available for this form. Those visible in the currently selected (Flow or Grid) view appear in bold font in the Outline.\n\nThe Properties view shows the properties of the selected section or attribute.\n\nThe Grid tab shows a grid corresponding to the grid layout for the form, and the Flow tab shows a table with the ordered list of sections and attributes for the flow layout.\n\nConfiguring the Form\n\nIn the Overview tab, you can configure the following parameters:\n\nThe Default Layout for the form view (Grid or Flow). If you enable either User Layout Switch or Auto Layout Switch, both layouts will be available to the user. Auto Layout Switch switches the layout to Flow when the display is below the Auto Layout Width in pixels.\n\nThe Section Navigator for the flow layout appears as a table of content, tabs or a list of links to switch from section to section. Its position and appearance are configured using the Section Navigator Look and Section Nav. Position options. You can also define whether sections should be managed as expandable/collapsible components.\n\nThe Label alignment defines the position of all the labels in the form view.\n\nAttribute Minimum Width and Attribute Maximum Width are values in pixel that limit the resizing of the attributes on large or small displays.\n\nFlow Layout Design\n\nIn the flow layout, you define and order form sections containing form attributes.\n\nTo add a form section:\n\nIn the Flow tab of the Form View editor, click the Add Form Section button in the toolbar. A new form section is added to the list.\n\nEdit the Name and Label for this section directly in the table or in the Properties view.\n\nOptionally, you can:\n\nMake the section visible or invisible using the Toggle Selection Visibility button in the toolbar.\n\nReorganize the sections order using drag and drop in the table.\n\nA section or attribute can be visible in the flow and/or grid layout. Changing an attribute or section visibility with the Toggle Selection Visibility button does not remove it from the form, and can be reverted. Using the Remove Selection button deletes the attribute or section from the form entirely, which cannot be undone.\n\nTo delete a form section:\n\nIn the Flow tab of the Form View editor, select the form section and then click the Delete Selection button.\n\nConfirm your choice. The section and all its form attributes are deleted.\n\nTo add a form attribute:\n\nIn the Flow tab of the Form View editor, drag an attribute from the available Attributes list to an existing form section. The new attribute is added under the form section. You can now:\n\nModify the Name, Label and Flow Height (size of the attribute in number of lines) for this attribute.\n\nClick the (â¦) Edit Expression button to create a complex expression for the table attribute.\n\nRe-position the attribute using drag and drop.\n\nSelect the Properties view and then select the attribute in the attributes table. The Properties view shows all the attribute properties, including:\n\nName, Label and Description. Note that if the Use Custom Label option is unchecked, then a default label is used: if the SemQL expression is a simple entity attribute, the default label is the label of this attribute, otherwise, the text of the SemQL expressions is used\n\nDisplay Type used for the table attribute.\n\nHelp Content: Content displayed as the help text for the attribute. This either the attribute metadata or its description.\n\nCertain properties available for form attributes are used specifically in the flow layout:\n\nFlow Height defines the height of the displayed component in number of lines.\n\nExpandable defines whether a complex attribute appears as an expandable attribute by default. Such expandable component is optionally Expanded by Default.\n\nCustomized Display Name for reference attributes. If it is checked, you can specify a SemQL Display Name Expression that defines the label shown for the reference. Otherwise, the entity display name is used instead.\n\nYou can alternately select (by pressing the CTRL key) and drag and drop multiple attributes from the attribute list. If you drag them into a section, they are added to this section. If you drag them outside of the sections, a new section is automatically created.\n\nTo remove an attribute from a form section:\n\nSelect the attribute in the attributes table.\n\nClick the Delete Selection button and confirm the deletion. The attribute is removed from the form section.\n\nGrid Layout Design\n\nIn the grid layout, each section and each attribute is positioned at an absolute position on a grid, and has a defined height and width.\n\nTo add a new form section:\n\nIn the Grid tab of the Form View editor, click the Form Section button or drag the button to a position in the grid. A new form section is added to the grid.\n\nIn the Properties view set the following properties for the new section:\n\nName, Label and Description.\n\nX-Coordinate, Y-Coordinate, Width and Height to position and size the section.\n\nDisplay Label: Un-select this option to hide the label of this section in the grid layout.\n\nUse the toolbar to move and re-size faster the selected form section or attribute. Multiple selection is supported.\n\nTo add an existing form section:\n\nDrag an existing form section from the Outline view to the grid. The section is added to the grid and you can edit it from the Properties view.\n\nTo delete a form section:\n\nSelect the form section from the grid and then click the Delete Selection button.\n\nConfirm your choice. The section and all its form attributes are deleted.\n\nTo add a new form attribute:\n\nIn the Grid tab of the Form View editor, drag an attribute from the available Attributes list to an existing section in the grid. The new attribute is added to the grid.\n\nSelect the Properties view and then select the attribute in the grid. The Properties view shows all the attribute properties, including:\n\nName, Label and Description. Note that if the Use Custom Label option is unchecked, then a default label is used: if the SemQL expression is a simple entity attribute, the default label is the label of this attribute, otherwise, the text of the SemQL expressions is used.\n\nDisplay Type used for the form attribute.\n\nHelp Content: Content displayed as the help text for the attribute. This either the attribute metadata or its description.\n\nCustomized Display Name for reference attributes. If it is checked, you can specify a SemQL Display Name Expression that defines the label shown for the reference. Otherwise, the entity display name is used instead.\n\nX-Coordinate, Y-Coordinate, Width and Height to position and size the attribute. You can also drag the attribute directly in the grid to position within its section.\n\nLabel Position to define the position of the label for the attributes (top, left or hidden) and Label Wrap to indicate whether the label text should wrap when overflowing. Label Width defines the size of the label.\n\nYou can drag and drop multiple attributes from the attribute list to the grid. If they are dropped on an existing section, they are added to the section. If they are dropped on the grid, a section is automatically created around these attributes.\n\nTo add an existing form attribute:\n\nDrag an existing form attribute from the Outline view to the grid. The section is added to the grid and you can edit it from the Properties view.\n\nTo remove an attribute from a form section:\n\nSelect the attribute in the grid.\n\nClick the Delete Selection button and confirm the deletion. The attribute is removed from the form section.\n\nCreating Search Forms\n\nA Search Form exposes several Search Parameters to look for records in an entity. When the user submits a search form, a search query is issued, using these parameters are bind values.\n\nNew search forms are immediately available for the entity in the application, but not in the business object views using that entity. You must define a Search Configuration in the business object views to enable or disable both the built-in search types and your own search forms.\n\nTo create a search form:\n\nRight-click the Search Forms node under an entity and select Add Search Formâ¦. The Create New Search Form wizard opens.\n\nIn the Create New Search Form wizard, enter the following values:\n\nName: Internal name of the object.\n\nLabel: User-friendly label in this search form.\n\nDescription: Description of this search form.\n\nClick Finish to close the wizard. The Search Form editor opens.\n\nDefine a Search Tip text that will be displayed in the search form.\n\nAdd a search parameter:\n\nIn the Search Parameters table, click the Add Search Parameter button. The Create New Search Parameter wizard opens.\n\nIn the Create New Search Parameter wizard, enter the following values:\n\nName: Internal name of the object.\n\nBinding: You use this binding string in the search form SemQL query condition to refer to this parameter. Note that as the Auto Fill box is checked, the Binding is automatically filled in. Modifying the binding is optional.\n\nLabel: User-friendly label for this search parameter. Note that as the Auto Fill box is checked, the Label is automatically filled in. Modifying this label is optional.\n\nMandatory: Check this box if this parameter must be set to run the search.\n\nUse Type, Length, Scale and Precision to define logical data type of this parameter.\n\nClick Finish to close the wizard. The parameter appears in the Search Parameters table.\n\nTo edit a search parameter: Select the Properties view and then select the search parameter in the table. The Properties view shows all its properties, including the Name and Definition as well as the Search Parameters Display Properties.\n\nTo remove a search parameter, select the search parameter in the search parameters table, click the Delete button and then confirm the deletion.\n\nUse the Properties view to configure the search parameter.\n\nRepeat the previous step to create all your search parameters.\n\nReorder search parameters in the table using the Move Up and Move Down buttons.\n\nCreate a SemQL Condition for the search query by clicking the Edit Expression button to open the SemQL Editor. Note that the SemQL editor displays the search form parameters bindings in the Variables section.\n\nSearch Parameters Display Properties\n\nThe Display Type of a search parameter define the component used to display this parameter in the search form. A Display Type is optionally configured through display properties.\n\nThe display type available for a search parameter depends on its logical data Type. For example, the Date Picker display type is available only for a DateTime search parameter.\n\nThe display types are listed below with their properties:\n\nText Field: Simple text field. This type is available for all logical data types.\n\nCheckbox: Simple checkbox. This type is available for the Boolean logical data type.\n\nDate Picker: Date selector. This display type is available for the DateTime logical type.\n\nDrop Down List: Selectable list of elements. This display type is typically used to select a search parameter value from a list of values. It is configured using the following options:\n\nDisplay Format: Defines whether the label and/or code of the list of values should be displayed.\n\nSort Order: Defines if the list of values should be sorted by the code or label.\n\nValue Picker: Component opening a popup dialog to select filtered values from a given entity of the model. It is configured using the following options:\n\nLookup Entity: Entity from which the values are selected.\n\nTable View: Table view used in the value picker component.\n\nFilter Expression: SemQL expression used to filter the entity data. This expression can use other search parameters' values.\n\nBound Select Expression: SemQL expression defining the value returned by a value picker selection.\n\nUse Distinct: Check this option to only display distinct values in the value picker.\n\nDisplay Count: Check this option to display the count of records for each distinct value in the picker. This option is available if Use Distinct is selected\n\nSort By Count: If Display Count is selected, this option allows sorting by ascending or descending record count.\n\nDefault Sort Expression: If Use Distinct is not selected, this SemQL expression defines the sort order of the records in the value picker.\n\nSemQL Condition for Search\n\nThe SemQL Condition defined for the search form can use attributes from the search entity as well as attributes from related (parent or child) entities. Refer to a search parameter with its Binding prefixed by a colon :.\n\nFor example, if a search form on the Customers entity has one parameter labeled Searched Name (binding: SEARCHED_NAME), the following SemQL condition filters customers by their name.\n\nCustomerName like '%' || :SEARCHED_NAME || '%'\n\nIf we add to this form a second parameter labeled Has Influencer Contact (Binding: HAS_INFLUENCER_CONTACT), the following SemQL condition filters customers by their name and possibly depending on the fact that they have one or more contacts with IsInfluencer = 1\n\nCustomerName like '%' || :SEARCHED_NAME || '%' and ( :HAS_INFLUENCER_CONTACT = 0 or any Contacts have (IsInfluencer = 1) )\n\nFor a detailed description of the SemQL language with examples, refer to the Semarchy Convergence for MDM SemQL Reference Guide.\n\nCreating Business Objects\n\nA Business Object is a composite object made up from a set of related entities. It is a functional subset of the model.\n\nTo create a new business object:\n\nRight-click the Business Objects node and select Add Business Objectâ¦. The Create New Business Object wizard opens.\n\nIn the Create New Business Object wizard, enter the following values:\n\nEntity: Select the root Entity Object for this business object. The root entity is the main entity of this business object, or the highest entity in the business object’s hierarchy.\n\nName: Internal name for this root Entity Object. The name default to the name of the entity suffixed with EO.\n\nClick Next.\n\nIn the second page of the Create New Business Object wizard, check the Auto Fill option and then enter the following values:\n\nName: Internal name of the business object. It is named by default after the root entity.\n\nLabel: User-friendly label for this object. Note that as the Auto Fill box is checked, the Label is automatically filled in. Modifying this label is optional.\n\nPlural Label: User-friendly label when referring to several instances of this business object. The value for the plural label is automatically generated from the Label value and can be optionally modified.\n\nIn the Description field, optionally enter a description for the Business Object.\n\nClick Next.\n\nEnter a Root Filter expression for the Business Object. This filter selects only the records of the root entity that should appear when opening the business object. For example, in a business object representing the hierarchy of Cost Centers, we should filter only the cost centers with no parent cost center. The navigation to child cost centers will be defined later in the business object.\n\nClick Finish to close the wizard. The Business Object editor opens.\n\nPress CTRL+S to save the new business object.\n\nAfter creating a business object, only the records of the root entity filtered by the root filter are displayed (for example, the root Cost Centers of the hierarchy). To include more entities in the business object (for example, child Cost Centers or Employees reporting to the cost centers), it is necessary to create Transitions to other Entity Objects.\n\nYou can create transitions from the root entity object or from any entity object in the business object.\n\nTo create transitions:\n\nCreate a transition from the root entity object or from another entity object:\n\nTo create a transition from the root entity object: In the Business Object editor, click the Add Transition button in the Transitions table. The Create New Business Object Transition wizard opens.\n\nTo create a transition from another entity object: In the Business Object editor, select the entity in the Transitions table and then click the Add Child Transition button. The Create New Business Object Transition wizard opens.\n\nIn the Create New Business Object Transition wizard, enter the following values:\n\nReference: Select a one of the references from the parent entity object. This reference points to one of the entities related to the parent entity object. For example, the reference that links a Cost Center to its child cost center or to its reporting employees.\n\nName: Internal Name of this transition. The default name is the Referencing Role Name for the selected relation.\n\nLabel: Label for this transition. The default name is the Referencing Role Label for the selected relation. Note that you can set a customized label, plural label and description specific to this transition later. Double-clicking a transition in the editor for a business object opens the transition for edition.\n\nClick Next.\n\nThe target of the transition may be either a New Entity Object or an Existing Entity Object:\n\nTo use an Existing Entity Object:\n\nSelect Use Existing Entity Object and then click Next.\n\nSelect an existing entity object as the Target Entity Object of the transition.\n\nClick Next.\n\nEnter a Filter expression for this transition. This filter select only the records of the target entity object that should appear when navigating through this transition.\n\nTo use a New Entity Object:\n\nSelect New Entity Object and then click Next.\n\nSelect in the Entity field an existing entity that will be target of this transition.\n\nIn Name, enter an internal name for this new entity object. The name default to the name of the entity suffixed with EO.\n\nClick Next.\n\nEnter a Filter expression for this transition. This filter select only the records of the target entity object that should appear when navigating through this transition.\n\nIt is possible to create hierarchies with infinite depth by creating a transition from an entity object to itself. For example, to create a hierarchy of cost centers, create a business object with a Cost center as the root entity object (call it CostCenterEO) and a root filter selecting only the cost centers with no parents (e.g.: ParentCostCenter is null). Then add a transition using the self-relation linking parent and child cost centers, and transition to the existing CostCenterEO.\n\nYou can use folders to organize the business object views in the application.\n\nHuman Workflows enable business users to manage the data in the MDM hub via an application.\n\nConfiguring the Workflow\n\nThe workflow can be configured from the Properties view. Click the background of the workflow diagram to open the workflow properties.\n\nAll workflow have the following properties sections:\n\nName and Definition: The Name, Label, Description, Initiator Role, Admin Role and On Submit Job options in this section are configured when creating the workflow and can be changed here. For Data Entry workflows, the Data Entry Publisher appears here. The additional Start from Homepage (to define whether the workflow can be started on the homepage) and Editable Properties (to define whether certain properties can be modified after startup) also appear in this section.\n\nTasks: The list of tasks of the workflow.\n\nTransitions: The list of transitions of the workflow.\n\nData Entry workflows have specific properties sections:\n\nActions: The Checkout Golden Records, Checkout Master Records, Checkout Rejects and Create New Records options are configured when creating a data entry workflow.\n\nBusiness Object Views: The list of default business objects managed by this data entry workflow. It is possible to override this list on each task of the workflow.\n\nDuplicate Management workflows have the Managed Entity section with the following properties:\n\nManaged Entity: This option lets you choose the entity whose duplicates are handled by this workflow.\n\nTable View: The table view used to display the entity records. This table view should include attributes relevant for duplicates management.\n\nConfiguring a Task\n\nA task selected in the workflow is configured from the Properties view.\n\nThe Name and Definition properties section contains the following properties: Name, Label, Description and Assigned to Role.\n\nFor data entry workflows' tasks, it is in addition possible to:\n\nOverride the list of Business Object Views defined at workflow level with other Business Object views specific to the given task.\n\nConfigure enrichers and validations triggered when data entry is performed in a task.\n\nTask-specific Business Object Views help deliver an optimal experience for the data entry process. Enrichers triggered in tasks add interactivity in the data entry. Validations on tasks enforce data quality as part of the data entry process by pro-actively detecting errors.\n\nOverriding Business Object Views in Tasks\n\nA task of a data entry workflow can override the default business object views from the workflow and use a different set of business object views.\n\nSetting Business Object Views on tasks allows workflow designers to specialize the data entry experience for each task of the workflow. For example, a first task uses a Business Object View to edit simple attributes, and a second (optional) task uses a different one to edit advanced attributes.\n\nTo override business object views in tasks:\n\nSelect the task in the workflow diagram. The Properties view displays this task’s properties.\n\nSelect the Business Object Views section in the Properties view.\n\nClick the Define Managed Business Object Views button in the Properties view toolbar. The Manage Tasks dialog opens.\n\nSelect the appropriate Available Business Object Views and click the Add >> button to add them to the Selected Business Object Views\n\nOrder the Business Object Views using the Move Up and Move Down buttons. The Business Object Views are displayed in this order at run-time.\n\nClick Finish to close the dialog.\n\nSelect the Name and Definition section in the Properties view.\n\nSelect the Override BO Views option. This option must be selected in order to take into account the BO Views of the task instead of those from the workflow.\n\nConfiguring Enrichers and Validations in Tasks\n\nA task of a data entry workflow can provide interactive feedback to the user. This feedback includes:\n\nTriggering enrichers to populate or augment attributes automatically.\n\nTrigger validations to raise issues to the user as he enters data.\n\nThe following sections are available in the Properties view for configuring the interactive feedback for data entry tasks:\n\nThe Enrichers section contains the list of enrichers applicable to the business objects managed by the workflow. These enrichers may be triggered during the workflow execution.\n\nThe Validations section contains the list of validations applicable to the business objects managed by the workflow. These validations may be triggered during the workflow execution.\n\nEnrichers triggered in a task modify the data entered in the transaction. The modified data is persisted in the transaction.\n\nThe triggers for validations and enrichers in a given task are:\n\nKeystrokes: Execute the validation or enricher when keystrokes are done in the data edition window.\n\nField Exit: Execute the validation or enricher when the focus goes out of a field.\n\nManual: Execute the validation or enricher when the user clicks the Validate button.\n\nSave: Execute the validation or enricher when the user saves data in the transaction or clicks the Validate button.\n\nNone: The validation or enricher is not executed during this task.\n\nWhen they have the same execution trigger, enrichers are always executed before validations.\n\nThe validations at a task level have an informational purpose, and do not prevent a user from entering incorrect data. You may prevent the user from proceeding with the workflow using transition validations. See Configuring Enrichers and Validations in Transitions for more information.\n\nAdding a Transition\n\nA transition links to tasks in the diagram.\n\nTo add a transition from the diagram:\n\nIn the Workflow diagram, select the Add Transition tool in the Palette.\n\nSelect a task the diagram or the Start event. Keep the mouse button pressed, and move the cursor to the next task in the workflow, or the built-in Submit or Cancel tasks.\n\nRelease the mouse button.\n\nThe transition is created and a link appears between the two elements in the diagram.\n\nTransitions have a direction. If a transition goes from Task_A to Task_B, it only means that you can move in the activity from Task_A to Task_B. If you want to move from Task_B to Task_A, then you must create another transition in the other direction.\n\nIt is possible to create multiple transitions between two tasks, even in the same direction. For example, you can have two transition path from Task_A to Task_B, each transition having a different configuration.\n\nConfiguring a Transition\n\nA transition selected in the workflow is configured from the Properties view.\n\nThe Name and Definition properties section contains the following task properties: Name, Label and Description. Label and description are customized only if the Use Custom Label option is selected. By default, a transition is named after the target task of this transition.\n\nThe Show Task Completion Dialog option allows you to skip the dialog that prompts a user who completes the task using that transition.\n\nConfiguring Enrichers and Validations in Transitions\n\nA transition of a data entry workflow can enforce data quality checks. These checks warn the user of possible data issues and can optionally block the transition.\n\nThe following sections are available in the Properties view for configuring the checks for data entry transitions:\n\nThe Validations section contains the list of validations applicable to the business objects managed by the workflow. Each validation is configured to Warn the user, Block the transition, or you can simply Skip it.\n\nThe Enrichers section contains the list of enrichers applicable to the business objects managed by the workflow. Select the enrichers to execute before the validations.\n\nSelected enrichers are always executed before validations.\n\nValidations marked as Block prevent the workflow from proceeding through the transition. Validation marked as Warn may be ignored by the user.\n\nAn application or a component of the application (business objects, workflow) must be validated to ensure its correct behavior after deployment and raise possible issues. For example, in a workflow, a task that cannot be reached or a task that cannot lead to the end of the workflow.\n\nTo validate the application or one component from the diagram:\n\nThe workflow is also validated as part of the overall model validation.\n\nYou can conne"
    }
}