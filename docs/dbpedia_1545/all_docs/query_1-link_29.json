{
    "id": "dbpedia_1545_1",
    "rank": 29,
    "data": {
        "url": "https://www.redhat.com/sysadmin/linux-golden-homelab-rhel",
        "read_more_link": "",
        "language": "en",
        "title": "Build a golden image for your RHEL homelab with Image Builder",
        "top_image": "https://www.redhat.com/sysadmin/sites/default/files/styles/google_discover/public/2021-11/home-lab-linux-skills.jpg?itok=bPFZidCB",
        "meta_img": "https://www.redhat.com/sysadmin/sites/default/files/styles/google_discover/public/2021-11/home-lab-linux-skills.jpg?itok=bPFZidCB",
        "images": [
            "https://www.redhat.com/sysadmin/themes/custom/sysadmin/logo.svg",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/full/public/2021-11/home-lab-linux-skills.jpg?itok=YuefqAyV",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/imagebuilder-webconsole1.png?itok=hX_Mr0MS",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/create-blueprint2.png?itok=dqFmYb38",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/create-image3.png?itok=68pI-A6t",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/create-image-hostname4.png?itok=12BWUIjW",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/create-image-user5.png?itok=xxGdpPy9",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/create-image-packages6.png?itok=Ddx831nm",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/create-image-review7.png?itok=hsJFMzic",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/admin-access8.png?itok=MpxK4iJF",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/rhel-base9.png?itok=sqlyo9Tl",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/image-complete10.png?itok=mWZYcmRP",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/embed_large/public/2023-03/build-complete11.png?itok=lb2C4hFr",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/card/public/2020-05/home-office-569153_1920%20Cropped.jpg?itok=CmW7_ge3",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/card/public/2019-10/building_blocks.jpg?itok=ljGlfobH",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/card/public/2021-12/open-office-work.jpg?itok=2vFtAj4q",
            "https://www.redhat.com/sysadmin/sites/default/files/styles/user_picture_square/public/pictures/2023-01/eric-hendricks.png?itok=2ELViZqX",
            "https://www.redhat.com/sysadmin/sites/default/files/2020-12/ace-magic-trick-formatting-date.jpg",
            "https://www.redhat.com/sysadmin/sites/default/files/2023-04/automation-gears-person.jpg",
            "https://www.redhat.com/sysadmin/sites/default/files/2023-04/easter-egg-linux.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "itguyeric",
            "Eric \"IT Guy\" Hendricks",
            "www.redhat.com"
        ],
        "publish_date": "2023-03-20T09:01:33+00:00",
        "summary": "",
        "meta_description": "Create customized templates for your Red Hat Enterprise Linux (RHEL)-based homelab that you can deploy repeatedly with automated upkeep.",
        "meta_lang": "en",
        "meta_favicon": "/sysadmin/themes/custom/sysadmin/favicon.ico",
        "meta_site_name": "Enable Sysadmin",
        "canonical_link": "https://www.redhat.com/sysadmin/linux-golden-homelab-rhel",
        "text": "In How I built a homelab with Red Hat Enterprise Linux (RHEL), I laid out my plans for revamping my home lab using as many Red Hat Enterprise Linux (RHEL) and Red Hat-adjacent tools as I could get my hands on.\n\nMy goals are:\n\nLearn the processes.\n\nTeach others some systems administration good practices.\n\nAutomate my homelab as much as possible.\n\n[ Try this no-cost online course: Red Hat Enterprise Linux technical overview. ]\n\nThe first article covered my goals and the process for building a new \"non-production\" RHEL 9 virtual machine to act as a jump server and collection point for different configuration files, scripts, and the like.\n\nI built a basic server and added only a few tools, such as the web console and Image Builder. In this article, I will focus on building a customized template that:\n\nI can deploy repeatedly.\n\nI can automate its upkeep.\n\nWhat is Image Builder?\n\nThe short version is that Image Builder is the intended future installation experience for RHEL. Image Builder is not a product but a feature within the distribution.\n\nWith Image Builder, administrators can deploy different RHEL versions on different platforms (hardware, virtual, cloud) with different configurations. There are three ways to interact with Image Builder:\n\nA web service through the Red Hat Console\n\nA web-UI-based tool\n\nA command line-based tool\n\n[ Get hands on: Build a RHEL image using the Red Hat Image Builder, then upload it to your chosen cloud service. ]\n\nBuild the first image\n\nA vanilla image should be enough to get started. This image undoubtedly will be one of many I create throughout this project. I'm starting with the web console (Cockpit) Image Builder application to get the ball rolling. The URL to connect to it is: https://{hostname}:9090/composer.\n\nIf you don't have Image Builder installed yet, you can install it with DNF:\n\n# dnf install -y cockpit-composer.noarch\n\nThen enable the socket to start automatically:\n\n# systemctl enable --now osbuild-composer.socket\n\nNow you can access Image Builder using the web console:\n\nUse the Create blueprint wizard to define what the initial image should look like. Start by giving the image a helpful name and description:\n\nThe next step is to decide what output format the image should be. Since my bare-metal server will be a hypervisor for my rebuilt lab, a QEMU-based qcow2 image makes the most sense; your environment may dictate differently.\n\nThe first step in the wizard also asks what the Image Size should be. The default and minimum are 2GB. For now, this should be fine.\n\nI'll move on to customizations. The next screen shows the option to pick a hostname. I will leave this blank and assign a hostname later when I deploy these images.\n\nNext, define a user. I will create a service account named ansible so that I can easily deploy system roles across a small test environment (as I'll do in the next article in this series).\n\nDon't forget to assign a password and create an SSH key. Adding a key here provides everything needed to use the ansible account across the fleet. Also, check the Server administrator box to add the ansible account to the wheel group.\n\nNext, I'll add a few packages I want across my fleet. Again, your choices here may vary. I've only added a couple for now, such as tmux and vim-enhanced.\n\nFinally, review the configuration and save the blueprint.\n\n[ Learn how to manage your Linux environment for success. ]\n\nCreate an image\n\nYou just created a blueprint for a RHEL 9 virtual machine (VM). Think of this as a recipe for a meal you will prepare. It's time to try it.\n\nEither from the wizard you just walked through or from the main page of the Image Builder app, select Create image to begin the build process.\n\nIn the background, Image Builder pulls all the relevant packages from the Red Hat Content Delivery Network (CDN), defines the filesystem layout, and builds the boot image.\n\nDepending on your hardware and internet connection, this process takes a few minutes. But when the image is complete, you won't immediately have to go in and update all your packages.\n\nOnce the image finishes, you can use the qcow2 artifact to build the first test client machine. The easiest way is to use your browser's Download functionality to grab the qcow2 file and upload it to your test environment.\n\nHowever, I want to make additional changes to my image before deploying it.\n\nAdd features to the vanilla image\n\nI want to ensure I have a well-defined image before deploying it repeatedly. To do this, I will switch tools.\n\nThe local, web-based Image Builder tends to be the slowest to get new features due to its ties to the RHEL release development process. It currently lacks a built-in mechanism for updating templates regularly. Remember, the goal for this lab is to operate as hands-off as possible.\n\nI'll use SSH to connect to the jump server for this step. I don't plan on this jump server living a long life, so I don't have to worry about creating a user account or importing any of the preferences. This approach is not advisable for production or long-lived servers, but I'll fix this later with the golden image.\n\nI pulled some knowledge from a couple of different tools for this next part:\n\nA self-paced lab\n\nThe Composer documentation\n\n(In this industry, it is often not what you know, but whether you know how and where to find the knowledge you need.)\n\n[ Keep your most commonly used commands handy with the Linux commands cheat sheet. ]\n\nNext, install the tools:\n\n# dnf install -y composer-cli osbuild-composer # systemctl enable --now osbuild-composer.socket\n\nOpen up the blueprint file you created in the web console:\n\n# composer-cli blueprints list rhel-base # composer-cli blueprints save rhel-base # vim rhel-base.toml name = \"rhel-base\" description = \"Vanilla RHEL 9.x\" version = \"0.0.2\" modules = [] groups = [] distro = \"\" [[packages]] name = \"tmux\" version = \"*\" [[packages]] name = \"vim-enhanced\" version = \"*\" [customizations] [[customizations.user]] name = \"ansible\" description = \"Ansible Service Account\" password = \" <redacted> \" key = \" <redacted> \" groups = [\"wheel\"]\n\nMake a few additions:\n\nname = \"rhel-base\" description = \"Vanilla RHEL 9.x\" version = \"0.0.2\" modules = [] groups = [] distro = \"\" [[packages]] name = \"tmux\" version = \"*\" [[packages]] name = \"vim-enhanced\" version = \"*\" [[packages]] name = \"cockpit\" version = \"*\" [customizations] [[customizations.filesystem]] mountpoint = \"/var/log\" size = \"4 GiB\" [customizations.services] enabled = [\"cockpit\"] [[customizations.user]] name = \"ansible\" description = \"Ansible Service Account\" password = <redacted> \" key = \" <redacted> \" groups = [\"wheel\"]\n\nI added stanzas for Cockpit (the web console) and an enabled services section to ensure the web console starts on boot.\n\nYou can add a 4GB filesystem for /var/log. (You can always add more later.)\n\nFinally, add a user description for the Ansible service account. You can also check the documentation for additional customization ideas.\n\nFor now, though, import the modified blueprint and execute a build:\n\n# composer-cli blueprints push rhel-base.toml # composer-cli compose start rhel-base qcow2 Compose bb259a2e-cbd6-4fe9-99bf-3a9b28e2cbcf added to the queue\n\nYou can keep an eye on the build by running the status command:\n\n# composer-cli compose status bb259a2e-cbd6-4fe9-99bf-3a9b28e2cbcf RUNNING Mon Feb 20 15:50:14 2023 rhel-base 0.0.3 qcow2 209cfd00-a57b-4458-8de0-df0942e2cc65 FINISHED Mon Feb 20 15:05:26 2023 rhel-base 0.0.1 qcow2 2147483648\n\nOnce done, the build will show a FINISHED status like when the job kicked off from the web console earlier. I'll hold onto the finished qcow2 image for the next article.\n\nAutomate future builds\n\nNow I have a good image I can duplicate to build and test what will eventually become my golden image. This planned image will have as many of the latest updates as possible, the preferred packages, user data, and filesystems.\n\nFrom there, I'll be able to add more layers of packages and configurations to the base image to build out the different services I'll be hosting in the lab.\n\nHowever, I don't want to worry about creating a new image manually. As the tool evolves, there will be better options for this, but for today, I plan on using systemd timer to build an updated image on a scheduled basis.\n\nI'm adding a systemd timer to trigger a rebuild every Sunday night. (Did you know about creating your own systemd timers? I didn't! I found the article Use systemd timers instead of cronjobs during my research!)\n\n[ Get the systemd cheat sheet. ]\n\nFirst, you need to create a systemd service to call the composer command:\n\n# vim /etc/systemd/system/composerBuild.service [Unit] Description=Rebuilds a vanilla RHEL template through image builder Wants=composerBuild.timer [Service] Type=oneshot ExecStart=/bin/composer-cli compose start rhel-base qcow2 [Install] WantedBy=multi-user.target\n\nSecond, create a systemd timer to call the service:\n\n# vim /etc/systemd/system/composerBuild.timer [Unit] Description=Timer to rebuild vanilla RHEL template using image builder Requires=composerBuild.service [Timer] Unit=composerBuild.service OnCalendar=Sun [Install] WantedBy=timers.target # systemctl enable composerBuild.timer\n\nAs a paranoid sysadmin, I want to verify that the timer is working:\n\n# systemctl status *timer … output truncated … ● composerBuild.timer - Timer to rebuild vanilla RHEL template using image builder Loaded: loaded (/etc/systemd/system/composerBuild.timer; enabled; vendor preset: disabled) Active: active (waiting) since Thu 2023-02-23 12:04:13 CST; 2min 14s ago Until: Thu 2023-02-23 12:04:13 CST; 2min 14s ago Trigger: Sun 2023-02-26 00:00:00 CST; 2 days left Triggers: ● composerBuild.service\n\nKeep in mind this is a \"quick-and-dirty\" approach. As I add tools like Ansible Automation Platform and Red Hat Satellite, I'll have better options for automating the process of providing up-to-date templates to deploy.\n\n[ Want to test your sysadmin skills? Take a skills assessment today. ]\n\nWrap up\n\nI covered a lot of ground in this article. I am enjoying the process and looking forward to seeing what the lab looks like on the other side of this series!\n\nHere, I talked about the ideas of a golden image and took steps toward building the first couple of client systems that I'll use in the next article.\n\nNext time, I will take the test systems and add RHEL system roles to the golden image. System roles are a codified method of configuring Linux subsystems such as firewalls and SSH using ansible-core and deploying these configurations at scale."
    }
}