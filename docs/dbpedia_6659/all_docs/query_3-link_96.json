{
    "id": "dbpedia_6659_3",
    "rank": 96,
    "data": {
        "url": "https://fury.apache.org/docs/guide/java_object_graph_guide/",
        "read_more_link": "",
        "language": "en",
        "title": "Java Serialization Guide",
        "top_image": "https://fury.apache.org/img/favicon.ico",
        "meta_img": "https://fury.apache.org/img/favicon.ico",
        "images": [
            "https://fury.apache.org/img/navbar-logo.svg",
            "https://fury.apache.org/img/navbar-logo.svg",
            "https://fury.apache.org/img/apache-incubator.svg",
            "https://fury.apache.org/img/apache-incubator.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "When only java object serialization needed, this mode will have better performance compared to cross-language object",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://fury.apache.org/docs/guide/java_object_graph_guide",
        "text": "When only java object serialization needed, this mode will have better performance compared to cross-language object graph serialization.\n\nNote that fury creation is not cheap, the fury instances should be reused between serializations instead of creating it everytime. You should keep fury to a static global variable, or instance variable of some singleton object or limited objects.\n\nFury for single-thread usage:\n\nFury for multiple-thread usage:\n\nFury instances reuse example:\n\nOption NameDescriptionDefault ValuetimeRefIgnoredWhether to ignore reference tracking of all time types registered in TimeSerializers and subclasses of those types when ref tracking is enabled. If ignored, ref tracking of every time type can be enabled by invoking Fury#registerSerializer(Class, Serializer). For example, fury.registerSerializer(Date.class, new DateSerializer(fury, true)). Note that enabling ref tracking should happen before serializer codegen of any types which contain time fields. Otherwise, those fields will still skip ref tracking.truecompressIntEnables or disables int compression for smaller size.truecompressLongEnables or disables long compression for smaller size.truecompressStringEnables or disables string compression for smaller size.trueclassLoaderThe classloader should not be updated; Fury caches class metadata. Use LoaderBinding or ThreadSafeFury for classloader updates.Thread.currentThread().getContextClassLoader()compatibleModeType forward/backward compatibility config. Also Related to checkClassVersion config. SCHEMA_CONSISTENT: Class schema must be consistent between serialization peer and deserialization peer. COMPATIBLE: Class schema can be different between serialization peer and deserialization peer. They can add/delete fields independently.CompatibleMode.SCHEMA_CONSISTENTcheckClassVersionDetermines whether to check the consistency of the class schema. If enabled, Fury checks, writes, and checks consistency using the classVersionHash. It will be automatically disabled when CompatibleMode#COMPATIBLE is enabled. Disabling is not recommended unless you can ensure the class won't evolve.falsecheckJdkClassSerializableEnables or disables checking of Serializable interface for classes under java.*. If a class under java.* is not Serializable, Fury will throw an UnsupportedOperationException.trueregisterGuavaTypesWhether to pre-register Guava types such as RegularImmutableMap/RegularImmutableList. These types are not public API, but seem pretty stable.truerequireClassRegistrationDisabling may allow unknown classes to be deserialized, potentially causing security risks.truesuppressClassRegistrationWarningsWhether to suppress class registration warnings. The warnings can be used for security audit, but may be annoying, this suppression will be enabled by default.truemetaShareEnabledEnables or disables meta share mode.falsescopedMetaShareEnabledScoped meta share focuses on a single serialization process. Metadata created or identified during this process is exclusive to it and is not shared with by other serializations.falsemetaCompressorSet a compressor for meta compression. Note that the passed MetaCompressor should be thread-safe. By default, a Deflater based compressor DeflaterMetaCompressor will be used. Users can pass other compressor such as zstd for better compression rate.DeflaterMetaCompressordeserializeNonexistentClassEnables or disables deserialization/skipping of data for non-existent classes.true if CompatibleMode.Compatible is set, otherwise false.codeGenEnabledDisabling may result in faster initial serialization but slower subsequent serializations.trueasyncCompilationEnabledIf enabled, serialization uses interpreter mode first and switches to JIT serialization after async serializer JIT for a class is finished.falsescalaOptimizationEnabledEnables or disables Scala-specific serialization optimization.falsecopyRefWhen disabled, the copy performance will be better. But fury deep copy will ignore circular and shared reference. Same reference of an object graph will be copied into different objects in one Fury#copy.true\n\nSingle thread fury:\n\nThread-safe fury:\n\nFuryBuilder#withIntCompressed/FuryBuilder#withLongCompressed can be used to compress int/long for smaller size. Normally compress int is enough.\n\nBoth compression are enabled by default, if the serialized is not important, for example, you use flatbuffers for serialization before, which doesn't compress anything, then you should disable compression. If your data are all numbers, the compression may bring 80% performance regression.\n\nFor int compression, fury use 1~5 bytes for encoding. First bit in every byte indicate whether has next byte. if first bit is set, then next byte will be read util first bit of next byte is unset.\n\nFor long compression, fury support two encoding:\n\nFury SLI(Small long as int) Encoding (used by default):\n\nIf long is in [-1073741824, 1073741823], encode as 4 bytes int: | little-endian: ((int) value) << 1 |\n\nOtherwise write as 9 bytes: | 0b1 | little-endian 8bytes long |\n\nFury PVL(Progressive Variable-length Long) Encoding:\n\nFirst bit in every byte indicate whether has next byte. if first bit is set, then next byte will be read util first bit of next byte is unset.\n\nNegative number will be converted to positive number by (v << 1) ^ (v >> 63) to reduce cost of small negative numbers.\n\nIf a number are long type, it can't be represented by smaller bytes mostly, the compression won't get good enough result, not worthy compared to performance cost. Maybe you should try to disable long compression if you find it didn't bring much space savings.\n\nDeep copy example:\n\nMake fury deep copy ignore circular and shared reference, this deep copy mode will ignore circular and shared reference. Same reference of an object graph will be copied into different objects in one Fury#copy.\n\nIn some cases, you may want to implement a serializer for your type, especially some class customize serialization by JDK writeObject/writeReplace/readObject/readResolve, which is very inefficient. For example, you don't want following Foo#writeObject got invoked, you can take following FooSerializer as an example:\n\nRegister serializer:\n\nFuryBuilder#requireClassRegistration can be used to disable class registration, this will allow to deserialize objects unknown types, more flexible but may be insecure if the classes contains malicious code.\n\nDo not disable class registration unless you can ensure your environment is secure. Malicious code in init/equals/hashCode can be executed when deserializing unknown/untrusted types when this option disabled.\n\nClass registration can not only reduce security risks, but also avoid classname serialization cost.\n\nYou can register class with API Fury#register.\n\nNote that class registration order is important, serialization and deserialization peer should have same registration order.\n\nIf you invoke FuryBuilder#requireClassRegistration(false) to disable class registration check, you can set org.apache.fury.resolver.ClassChecker by ClassResolver#setClassChecker to control which classes are allowed for serialization. For example, you can allow classes started with org.example.* by:\n\nFury also provided a org.apache.fury.resolver.AllowListChecker which is allowed/disallowed list based checker to simplify the customization of class check mechanism. You can use this checker or implement more sophisticated checker by yourself.\n\nYou can also register a custom serializer for a class by Fury#registerSerializer API.\n\nOr implement java.io.Externalizable for a class.\n\nFury supports share type metadata (class name, field name, final field type information, etc.) between multiple serializations in a context (ex. TCP connection), and this information will be sent to the peer during the first serialization in the context. Based on this metadata, the peer can rebuild the same deserializer, which avoids transmitting metadata for subsequent serializations and reduces network traffic pressure and supports type forward/backward compatibility automatically.\n\nFury support deserializing non-existent classes, this feature can be enabled by FuryBuilder#deserializeNonexistentClass(true). When enabled, and metadata sharing enabled, Fury will store the deserialized data of this type in a lazy subclass of Map. By using the lazy map implemented by Fury, the rebalance cost of filling map during deserialization can be avoided, which further improves performance. If this data is sent to another process and the class exists in this process, the data will be deserialized into the object of this type without losing any information.\n\nIf metadata sharing is not enabled, the new class data will be skipped and an NonexistentSkipClass stub object will be returned.\n\nIf you use jdk serialization before, and you can't upgrade your client and server at the same time, which is common for online application. Fury provided an util method org.apache.fury.serializer.JavaSerializer.serializedByJDK to check whether the binary are generated by jdk serialization, you use following pattern to make exiting serialization protocol-aware, then upgrade serialization to fury in an async rolling-up way:\n\nCurrently binary compatibility is ensured for minor versions only. For example, if you are using furyv0.2.0, binary compatibility will be provided if you upgrade to fury v0.2.1. But if upgrade to fury v0.4.1, no binary compatibility are ensured. Most of the time there is no need to upgrade fury to newer major version, the current version is fast and compact enough, and we provide some minor fix for recent older versions.\n\nBut if you do want to upgrade fury for better performance and smaller size, you need to write fury version as header to serialized data using code like following to keep binary compatibility:\n\nThen for deserialization, you need:\n\ngetFury is a method to load corresponding fury, you can shade and relocate different version of fury to different package, and load fury by version.\n\nIf you upgrade fury by minor version, or you won't have data serialized by older fury, you can upgrade fury directly, no need to versioning the data.\n\nIf you create fury without setting CompatibleMode to org.apache.fury.config.CompatibleMode.COMPATIBLE, and you got a strange serialization error, it may be caused by class inconsistency between serialization peer and deserialization peer.\n\nIn such cases, you can invoke FuryBuilder#withClassVersionCheck to create fury to validate it, if deserialization throws org.apache.fury.exception.ClassNotCompatibleException, it shows class are inconsistent, and you should create fury with FuryBuilder#withCompaibleMode(CompatibleMode.COMPATIBLE).\n\nCompatibleMode.COMPATIBLE has more performance and space cost, do not set it by default if your classes are always consistent between serialization and deserialization.\n\nIf you serialize an object by invoking Fury#serialize, you should invoke Fury#deserialize for deserialization instead of Fury#deserializeJavaObject.\n\nIf you serialize an object by invoking Fury#serializeJavaObject, you should invoke Fury#deserializeJavaObject for deserialization instead of Fury#deserializeJavaObjectAndClass/Fury#deserialize."
    }
}