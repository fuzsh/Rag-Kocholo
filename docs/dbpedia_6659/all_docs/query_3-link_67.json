{
    "id": "dbpedia_6659_3",
    "rank": 67,
    "data": {
        "url": "https://medium.com/%40shawn.ck.yang/fury-a-blazing-fast-multi-language-serialization-framework-powered-by-jit-and-zero-copy-fdd16f3215cb",
        "read_more_link": "",
        "language": "en",
        "title": "Fury: 170x faster, a new multi-language serialization framework powered by jit and zero-copy",
        "top_image": "https://miro.medium.com/v2/resize:fit:1200/1*1v8gZnGQ-wI53oSyYc2J0Q.png",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1200/1*1v8gZnGQ-wI53oSyYc2J0Q.png",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/da:true/resize:fill:88:88/0*N2JAQiOWW779MMIB",
            "https://miro.medium.com/v2/da:true/resize:fill:144:144/0*N2JAQiOWW779MMIB"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Shawn.Yang",
            "medium.com",
            "@shawn.ck.yang"
        ],
        "publish_date": "2023-07-26T10:48:26.519000+00:00",
        "summary": "",
        "meta_description": "Serialization is a basic component of system communication, and widely used in big data, AI framework, cloud native and other distributed systems. Data transfer between processes/languages/nodes, or…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@shawn.ck.yang/fury-a-blazing-fast-multi-language-serialization-framework-powered-by-jit-and-zero-copy-fdd16f3215cb",
        "text": "Author: chaokunyang\n\nFury is a blazing fast multi-language serialization framework powered by jit(just-in-time compilation) and zero-copy, providing up to 170x performance and ultimate ease of use.\n\nThe GitHub address of fury repository is: https://github.com/apache/incubator-fury\n\nBackground\n\nSerialization is a basic component of system communication, and widely used in big data, AI framework, cloud native and other distributed systems. Data transfer between processes/languages/nodes, or object persistence, state read/write and copy all need serialization. The performance and ease-of-use of serialization affects runtime and development efficiency of the system.\n\nStatic serialization frameworks like protobuf/flatbuffers can’t be used for cross-language application development directly, because they don’t support shared reference and polymorphism, and also need to generate code ahead. Dynamic serialization frameworks such as JDK serialization, Kryo, Fst, Hessian, Pickle provide ease-of-use and dynamics, but don’t support cross-language and suffer significant performance issues, which is unsuitable for high throughput, low latency, and large-scale data transfer scenarios.\n\nTherefore, we developed a new multi-language serialization framework Fury, which is now open-sourced on https://github.com/alipay/fury. Through highly optimized serialization primitives, JIT dynamic compilation and Zero-Copy technologies, Fury is both fast and easy to use. It can cross-language serialize any object automatically and provides ultimate performance at the same time.\n\nWhat is Fury\n\nFury is a multi-language serialization framework powered by JIT dynamic compilation and zero copy, providing blazing fast speed and ease of use:\n\nMultiple languages: Java/Python/C++/Golang/JavaScript/Rust, other languages can be added easily.\n\nHighly optimized serialization primitives.\n\nZero-Copy: support out-of-band serialization and off-heap read/write.\n\nHigh performance: Use JIT(just-in-time) to generate serialization code at runtime in an async multithreaded way, which can optimize methods inlining, code cache, dead code elimination, hash lookup, meta writing and memory read/writing.\n\nMulti protocols: support Java native serialization, cross-language object graph serialization, binary row format; provide flexibility of dynamic serialization, as well as the cross-language of static serialization.\n\nCore Serialization Capabilities\n\nAlthough different scenarios require different serialization protocols, the underlying operations of serialization are similar. Therefore, Fury defines and implements a set of basic serialization capabilities, which can be used for quickly building new multi-language serialization protocols and get speedup by jit acceleration and other optimizations. At the same time, performance optimization for a protocol on the primitives can also benefit all other protocols.\n\nSerialization Primitives\n\nCommon serialization operations contains:\n\nbitmap operations\n\nnumber encoding/decoding\n\nint/long compression\n\nString creation/copy\n\nString encoding: ASCII/UTF8/UTF16\n\nmemory copy\n\narray copy&compression\n\nmeta encoding&compression&cache\n\nFury use SIMD and other advanced language features to make basic operations extremely fast in every languages.\n\nZero-Copy Serialization\n\nLarge-scale data transfer often has multiple binary buffers in an object graph. Some serialization frameworks will write the binaries into an intermediate buffer and introduce multiple time-consuming memory copies. Fury implemented an out-of-band serialization protocol inspired by pickle5, ray and arrow, which can capture all binary buffers in an object graph to avoid intermediate copies of these buffers. The following figure shows the serialization process of zero-copy:\n\nCurrently, Fury supports the following types of zero-copy:\n\njava: all basic types of arrays, ByteBuffer, ArrowRecordBatch, and VectorSchemaRoot\n\npython: all arrays of the array module, numpy arrays, pyarrow.Table, and pyarrow.RecordBatch\n\ngolang:byte slice\n\nYou can also add the new zero copy type based on the Fury interface.\n\nJIT dynamic compilation acceleration\n\nCustom type objects usually contain lots of type information, Fury used this information to generate efficient serialization code at runtime, which can push lots of runtime operations into the dynamic compilation stage. By inlining more methods, better code cache, reducing virtual method calls, conditional branches, hash lookup, metadata writes, and memory reads/writes, the serialization performance is greatly accelerated.\n\nFor Java, Fury implements a runtime codegen framework and defines an operator expression IR. Then fury can perform type inference based on the generic type information of the object at runtime to build an expression tree that describes the logic of serialized code. The codegen framework will generate efficient Java code from the expression tree, then pass to Janino to compile it into bytecode, and load it into the user’s ClassLoader or the ClassLoader created by Fury, and finally compile it into efficient assembly code through Java JIT.\n\nSince JVM JIT skips Big method compilation and inlining, Fury also implements an optimizer to split big methods into small methods recursively, thus ensuring that all code can be compiled and inlined.\n\nFury also supports asynchronous multithreaded compilation by running the codegen tasks in a thread pool, and using interpretation mode until JIT finishes to ensure no serialization burrs. Users can skip warm up serialization of objects.\n\nPython and JavaScript codegen are similar. Generating source code is easier for development and troubleshooting problems.\n\nSince serialization will manipulate objects extensively in each programming language, and the language does not expose the low-level API of the memory model, native methods call has a large cost too, so we cannot use LLVM to build a unified serializer JIT framework. Instead, we implemented a codegen framework for every language separately.\n\nStatic code generation\n\nAlthough JIT compilation can greatly improve serialization efficiency and generate better serialization code based on the statistical distribution of data at runtime, languages like C++ do not support reflection, have no virtual machines, and no low-level API for memory models. We cannot generate serialization code dynamically for such languages through JIT.\n\nIn such scenarios, Fury is implementing an AOT codegen framework, which generates the serialized code statically according to the object schema, and objects can be serialized automatically using the generated serializer. For Rust, Rust macro is used to generate code statically.\n\nCache optimization\n\nWhen serializing a custom type, fury will reorder fields to ensure that fields of the same type are serialized in order. This can hit more data cache and CPU instruction cache.\n\nThe basic type fields are written in descending order by byte size. In this way, if the initial addresses are aligned, subsequent read and write operations will occur at the position where the memory addresses are aligned, making CPU execution more efficient.\n\nMulti-protocol Design and Implementation\n\nBased on the multi-language serialization features provided by Fury core, we have built three serialization protocols for different scenarios:\n\nJava serialization: suitable for pure Java serialization scenarios and provides up to170x speed up;\n\nCross-language object graph serialization: suitable for application-oriented multi-language programming and high-performance cross-language serialization;\n\nRow-format serialization: suitable for distributed computing engines such as Spark/Flink/Dories/Velox/Features frameworks;\n\nIn the future, we will add new protocols for other core scenarios. Users can also build their own protocols based on Fury’s serialization framework.\n\nJava serialization\n\nJava is widely used in big data, cloud native, microservices, and enterprise applications. Therefore, Fury made lots of optimizations for Java serialization, which reduces system latency and server costs a lot, and improves throughput significantly. Our implementation has the following highlights:\n\nBlazing fast performance: Based on Java types, JIT compilation and Unsafe low-level operations, Fury is 170x faster than JDK, and 50~110x faster than Kryo/Hessian at most.\n\n100% JDK serialization API compatibility : supports all JDK custom serialization methods writeObject/readObject/writeReplace/readResolve/readObjectNoData natively to ensure the serialization correctness in any scenario. Kryo/Hessian have some correctness issues in these scenarios.\n\nDrop-in replaces JDK/Kryo/Hessian/Fst, no need to modify user code.\n\nType forward/backward compatibility: When the deserialization and serialization class schema are inconsistent, it can still deserialize correctly. It supports application upgrade and deployment, add/delete fields independently. Fury type-compatible mode is implemented with no performance loss compared to type-consistent mode.\n\nMetadata sharing : share metadata(class name, field name&type, etc.) across multiple serializations under a context (TCP connection), meta will be sent to the peer only for the first serialization, the peer can reconstruct the same deserializer based on this information. Subsequent serialization will skip transferring metadata, which can reduce network traffic, and support type compatibility automatically.\n\nZero copy support: supports out-of-band zero copy and off-heap memory read/write.\n\nCross-language object graph serialization\n\nFury cross-language object graph serialization is primarily used for scenarios that require higher dynamics and ease-of-use. Although frameworks like Protobuf/Flatbuffers support cross-language serialization, they still have limitations:\n\nThey require pre-defined IDLs and generate code statically ahead, lacking sufficient dynamics and flexibility;\n\nThe generated classes don’t conform to object-oriented design and it’s impossible to add behavior to classes, which make them unsuitable for use as domain objects in cross-language application development.\n\nThey don’t support polymorphism. Object-oriented programming uses interfaces to invoke subclass methods, but this pattern isn’t supported well in those frameworks. Although Flatbuffers offers Union, and Protobuf provides OneOf/Any, those API require check object type during serialization and deserialization, which isn't polymorphic.\n\nThey don’t support circular references and shared references. Users need to define a set of IDLs for domain objects and implement reference resolution by themselves, as well as writing code to convert between domain objects and protocol objects in each language. If the object graph depth is deep, more code needs to be written.\n\nDue to the above limitations, Fury implemented a cross-language object graph serialization protocol that:\n\nAutomatically serializes any object across multiple languages: By defining classes in the serialization and deserialization peer, objects in one language can be automatically serialized into objects in another language without creating IDL files, compiling schema to generate code, or writing conversion code.\n\nAutomatically serializes shared and circular references across multiple languages.\n\nSupports object type polymorphism, consistent with the object-oriented programming paradigm, and multiple subtypes can be automatically deserialized without manual intervention.\n\nOut-of-band zero-copy is also supported in this protocol.\n\nExample of Automatic Cross-Language Serialization:\n\nRow-format\n\nFor high-performance computing and large-scale data transfer scenarios, data serialization and transfer are often the performance bottlenecks of the system. If users only need to read part of the data or filter data based on some field of an object, deserializing the entire data will result in unnecessary overhead. Therefore, Fury provides a binary data structure for direct reading and writing on binary data to avoid serialization.\n\nApache Arrow is a standardized columnar storage format that supports binary read and write. However, columnar format is not suitable for all scenarios. Data in online and streaming computing are naturally stored row by row, and row is also used in columnar computing engines when involving data updates, Hash/Join/Aggregation operations.\n\nHowever, there is no standardized implementation for row format. Computing engines such as Spark/Flink/Doris/Velox all defined their row format, which doesn’t support cross-language and can only be used internally by themselves. Flatbuffers does support lazy deserialization, but it requires static compilation of schema IDL and management of offset, which is impossible for complex scenarios.\n\nTherefore, Fury implemented a binary row format inspired by Spark Tungsten and Apache Arrow format, which allows random access and partial deserialization. Currently, Java/Python/C++ versions have been implemented, allowing direct reading and writing on binary data to avoid all serialization overhead, and can convert to arrow format automatically.\n\nThis format is densely stored, byte aligned and cache-friendly, which enables faster read and write operations. By avoiding deserialization, it reduces Java GC pressure and Python overhead. Based on Python’s dynamics, Fury’s data structure implements special methods such as `getattr_/getitem/slice/etc.`, ensuring behavior consistency with Python dataclass/list/object, and users have no perception of this.\n\nPerformance Comparison\n\nHere are some Java serialization performance data, where charts with “compatible” in the title are performance data under type compatible mode: support type forward/backward compatibility. and charts without “compatible” in the title are performance data without type compatibility: class schema must be same between serialization and deserialization. For fairness, Fury disabled the zero-copy feature for all tests.\n\nFuture plan(RoadMap)\n\nMeta compression, auto meta sharing and cross-language schema compatibility.\n\nAOT Framework for c++/golang to generate code statically.\n\nC++/Rust object graph serialization support\n\nGolang/Rust/NodeJS row format support\n\nProtoBuf compatibility support\n\nProtocols for features and knowledge graph serialization\n\nContinuously improve our serialization infrastructure for any new protocols\n\nJoin US\n\nWe are committed to building Fury into an open and neutral community project that pursues passion and innovation. The development and discussion are open-sourced and transparent in the community. Any form of participation is welcome, including but not limited to questions, code contributions, technical discussions, etc. We are looking forward to receiving your ideas and feedback, participating in the project together, pushing the project forward and creating a better serialization framework.\n\nThe GitHub address of the fury is: https://github.com/apache/incubator-fury\n\nOfficial website: https://fury.apache.org\n\nAny issues, PR, and Discussion are welcome.\n\nYou are also welcome to join the following groups to communicate with us."
    }
}