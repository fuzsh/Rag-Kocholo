{
    "id": "dbpedia_4765_0",
    "rank": 88,
    "data": {
        "url": "https://www.w3.org/TR/xmldsig-core1/",
        "read_more_link": "",
        "language": "en",
        "title": "XML Signature Syntax and Processing Version 1.1",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.w3.org/Icons/w3c_home"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "2.1 Simple Example (Signature, SignedInfo, Methods, and References)\n\nThe following example is a detached signature of the content of the HTML4 in XML specification.\n\nExample 2\n\n[s01]<SignatureId=\"MyFirstSignature\" xmlns=\"http://www.w3.org/2000/09/xmldsig#\">[s02]<SignedInfo>[s03]<CanonicalizationMethodAlgorithm=\"http://www.w3.org/2006/12/xml-c14n11\"/>[s04]<SignatureMethodAlgorithm=\"http://www.w3.org/2001/04/xmldsig-more#rsa-sha256\"/>[s05]<Reference URI=\"http://www.w3.org/TR/2000/REC-xhtml1-20000126/\">[s06]<Transforms>[s07]<TransformAlgorithm=\"http://www.w3.org/2006/12/xml-c14n11\"/>[s08]</Transforms> [s09] <DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/> [s10]<DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...</DigestValue>[s11]</Reference> [s12] </SignedInfo>[s13]<SignatureValue>...</SignatureValue>[s14]<KeyInfo>[s15a]<KeyValue>[s15b]<DSAKeyValue>[s15c]<P>...</P><Q>...</Q><G>...</G><Y>...</Y>[s15d]</DSAKeyValue> [s15e] </KeyValue>[s16]</KeyInfo> [s17] </Signature>\n\n[s02-12] The required SignedInfo element is the information that is actually signed. Core validation of SignedInfo consists of two mandatory processes: validation of the signature over SignedInfo and validation of each Reference digest within SignedInfo. Note that the algorithms used in calculating the SignatureValue are also included in the signed information while the SignatureValue element is outside SignedInfo.\n\n[s03] The CanonicalizationMethod is the algorithm that is used to canonicalize the SignedInfo element before it is digested as part of the signature operation. Note that this example is not in canonical form. (None of the examples in this specification are in canonical form.)\n\n[s04] The SignatureMethod is the algorithm that is used to convert the canonicalized SignedInfo into the SignatureValue. It is a combination of a digest algorithm and a key dependent algorithm and possibly other algorithms such as padding, for example RSA-SHA1. The algorithm names are signed to resist attacks based on substituting a weaker algorithm. To promote application interoperability we specify a set of signature algorithms that MUST be implemented, though their use is at the discretion of the signature creator. We specify additional algorithms as RECOMMENDED or OPTIONAL for implementation; the design also permits arbitrary user specified algorithms.\n\n[s05-11] Each Reference element includes the digest method and resulting digest value calculated over the identified data object. It also may include transformations that produced the input to the digest operation. A data object is signed by computing its digest value and a signature over that value. The signature is later checked via reference and signature validation.\n\n[s14-16] KeyInfo indicates the key to be used to validate the signature. Possible forms for identification include certificates, key names, and key agreement algorithms and information -- we define only a few. KeyInfo is optional for two reasons. First, the signer may not wish to reveal key information to all document processing parties. Second, the information may be known within the application's context and need not be represented explicitly. Since KeyInfo is outside of SignedInfo, if the signer wishes to bind the keying information to the signature, a Reference can easily identify and include the KeyInfo as part of the signature. Use of KeyInfo is optional, however note that senders and receivers must agree on how it will be used through a mechanism out of scope for this specification.\n\n2.1.1 More on Reference\n\nExample 3\n\n[s05]<Reference URI=\"http://www.w3.org/TR/2000/REC-xhtml1-20000126/\">[s06]<Transforms>[s07]<TransformAlgorithm=\"http://www.w3.org/2006/12/xml-c14n11\"/>[s08]</Transforms> [s09] <DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/> [s10]<DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...</DigestValue>[s11]</Reference>\n\n[s05] The optional URI attribute of Reference identifies the data object to be signed. This attribute may be omitted on at most one Reference in a Signature. (This limitation is imposed in order to ensure that references and objects may be matched unambiguously.)\n\n[s05-08] This identification, along with the transforms, is a description provided by the signer on how they obtained the signed data object in the form it was digested (i.e. the digested content). The verifier may obtain the digested content in another method so long as the digest verifies. In particular, the verifier may obtain the content from a different location such as a local store than that specified in the URI.\n\n[s06-08] Transforms is an optional ordered list of processing steps that were applied to the resource's content before it was digested. Transforms can include operations such as canonicalization, encoding/decoding (including compression/inflation), XSLT, XPath, XML schema validation, or XInclude. XPath transforms permit the signer to derive an XML document that omits portions of the source document. Consequently those excluded portions can change without affecting signature validity. For example, if the resource being signed encloses the signature itself, such a transform must be used to exclude the signature value from its own computation. If no Transforms element is present, the resource's content is digested directly. While the Working Group has specified mandatory (and optional) canonicalization and decoding algorithms, user specified transforms are permitted.\n\n[s09-10] DigestMethod is the algorithm applied to the data after Transforms is applied (if specified) to yield the DigestValue. The signing of the DigestValue is what binds the content of a resource to the signer's key.\n\n2.2 Extended Example (Object and SignatureProperty)\n\nThis specification does not address mechanisms for making statements or assertions. Instead, this document defines what it means for something to be signed by an XML Signature (integrity, message authentication, and/or signer authentication). Applications that wish to represent other semantics must rely upon other technologies, such as [XML10], [RDF-PRIMER]. For instance, an application might use a foo:assuredby attribute within its own markup to reference a Signature element. Consequently, it's the application that must understand and know how to make trust decisions given the validity of the signature and the meaning of assuredby syntax. We also define a SignatureProperties element type for the inclusion of assertions about the signature itself (e.g., signature semantics, the time of signing or the serial number of hardware used in cryptographic processes). Such assertions may be signed by including a Reference for the SignatureProperties in SignedInfo. While the signing application should be very careful about what it signs (it should understand what is in the SignatureProperty) a receiving application has no obligation to understand that semantic (though its parent trust engine may wish to). Any content about the signature generation may be located within the SignatureProperty element. The mandatory Target attribute references the Signature element to which the property applies.\n\nConsider the preceding example with an additional reference to a local Object that includes a SignatureProperty element. (Such a signature would not only be detached [p02] but enveloping [p03].)\n\nExample 4\n\n[]<SignatureId=\"MySecondSignature\"...>[p01]<SignedInfo>[]...[p02]<Reference URI=\"http://www.w3.org/TR/xml-stylesheet/\">[]...[p03]<Reference URI=\"#AMadeUpTimeStamp\"[p04]Type=\"http://www.w3.org/2000/09/xmldsig#SignatureProperties\">[p05]<Transforms>[p06]<TransformAlgorithm=\"http://www.w3.org/2006/12/xml-c14n11\"/>[p07]</Transforms> [p08] <DigestMethod Algorithm=\"http://www.w3.org/2001/04/xmlenc#sha256\"/> [p09]<DigestValue>dGhpcyBpcyBub3QgYSBzaWduYXR1cmUK...</DigestValue>[p10]</Reference> [p11] </SignedInfo>[p12]...[p13]<Object>[p14]<SignatureProperties>[p15]<SignaturePropertyId=\"AMadeUpTimeStamp\"Target=\"#MySecondSignature\">[p16]<timestamp xmlns=\"http://www.ietf.org/rfcXXXX.txt\">[p17]<date>19990914</date> [p18] <time>14:34:34:34</time>[p19]</timestamp> [p20] </SignatureProperty>[p21]</SignatureProperties> [p22] </Object>[p23]</Signature>\n\n[p04] The optional Type attribute of Reference provides information about the resource identified by the URI. In particular, it can indicate that it is an Object, SignatureProperty, or Manifest element. This can be used by applications to initiate special processing of some Reference elements. References to an XML data element within an Object element SHOULD identify the actual element pointed to. Where the element content is not XML (perhaps it is binary or encoded data) the reference should identify the Object and the Reference Type, if given, SHOULD indicate Object. Note that Type is advisory and no action based on it or checking of its correctness is required by core behavior.\n\n[p13] Object is an optional element for including data objects within the signature element or elsewhere. The Object can be optionally typed and/or encoded.\n\n[p14-21] Signature properties, such as time of signing, can be optionally signed by identifying them from within a Reference. (These properties are traditionally called signature \"attributes\" although that term has no relationship to the XML term \"attribute\".)\n\n4.5 The KeyInfo Element\n\nKeyInfo is an optional element that enables the recipient(s) to obtain the key needed to validate the signature. KeyInfo may contain keys, names, certificates and other public key management information, such as in-band key distribution or key agreement data. This specification defines a few simple types but applications may extend those types or all together replace them with their own key identification and exchange semantics using the XML namespace facility [XML-NAMES]. However, questions of trust of such key information (e.g., its authenticity or strength) are out of scope of this specification and left to the application. Details of the structure and usage of element children of KeyInfo other than simple types described in this specification are out of scope. For example, the definition of PKI certificate contents, certificate ordering, certificate revocation and CRL management are out of scope.\n\nIf KeyInfo is omitted, the recipient is expected to be able to identify the key based on application context. Multiple declarations within KeyInfo refer to the same key. While applications may define and use any mechanism they choose through inclusion of elements from a different namespace, compliant versions MUST implement KeyValue (section 4.5.2 The KeyValue Element) and SHOULD implement KeyInfoReference (section 4.5.10 The KeyInfoReference Element). KeyInfoReference is preferred over use of RetrievalMethod as it avoids use of Transform child elements that introduce security risk and implementation challenges. Support for other children of KeyInfo is OPTIONAL.\n\nThe schema specification of many of KeyInfo's children (e.g., PGPData, SPKIData, X509Data) permit their content to be extended/complemented with elements from another namespace. This may be done only if it is safe to ignore these extension elements while claiming support for the types defined in this specification. Otherwise, external elements, including alternative structures to those defined by this specification, MUST be a child of KeyInfo. For example, should a complete XML-PGP standard be defined, its root element MUST be a child of KeyInfo. (Of course, new structures from external namespaces can incorporate elements from the dsig: namespace via features of the type definition language. For instance, they can create a schema that permits, includes, imports, or derives new types based on dsig: elements.)\n\nThe following list summarizes the KeyInfo types that are allocated an identifier in the dsig: namespace; these can be used within the RetrievalMethod Type attribute to describe a remote KeyInfo structure.\n\nhttp://www.w3.org/2000/09/xmldsig#DSAKeyValue\n\nhttp://www.w3.org/2000/09/xmldsig#RSAKeyValue\n\nhttp://www.w3.org/2000/09/xmldsig#X509Data\n\nhttp://www.w3.org/2000/09/xmldsig#PGPData\n\nhttp://www.w3.org/2000/09/xmldsig#SPKIData\n\nhttp://www.w3.org/2000/09/xmldsig#MgmtData\n\nThe following list summarizes the additional KeyInfo types that are allocated an identifier in the dsig11: namespace.\n\nhttp://www.w3.org/2009/xmldsig11#ECKeyValue\n\nhttp://www.w3.org/2009/xmldsig11#DEREncodedKeyValue\n\nIn addition to the types above for which we define an XML structure, we specify one additional type to indicate a binary (ASN.1 DER) X.509 Certificate.\n\nhttp://www.w3.org/2000/09/xmldsig#rawX509Certificate\n\nSchemaDefinition:\n\n<elementname=\"KeyInfo\"type=\"ds:KeyInfoType\"/><complexTypename=\"KeyInfoType\"mixed=\"true\"><choicemaxOccurs=\"unbounded\"><elementref=\"ds:KeyName\"/><elementref=\"ds:KeyValue\"/><elementref=\"ds:RetrievalMethod\"/><elementref=\"ds:X509Data\"/><elementref=\"ds:PGPData\"/><elementref=\"ds:SPKIData\"/><elementref=\"ds:MgmtData\"/><!-- <element ref=\"dsig11:DEREncodedKeyValue\"/> --><!-- DEREncodedKeyValue (XMLDsig 1.1) will use the any element --><!-- <element ref=\"dsig11:KeyInfoReference\"/> --><!-- KeyInfoReference (XMLDsig 1.1) will use the any element --><!-- <element ref=\"xenc:EncryptedKey\"/> --><!-- EncryptedKey (XMLEnc) will use the any element --><!-- <element ref=\"xenc:Agreement\"/> --><!-- Agreement (XMLEnc) will use the any element --><anyprocessContents=\"lax\"namespace=\"##other\"/><!-- (1,1) elements from (0,unbounded) namespaces --></choice><attributename=\"Id\"type=\"ID\"use=\"optional\"/></complexType>\n\n4.5.1 The KeyName Element\n\nThe KeyName element contains a string value (in which white space is significant) which may be used by the signer to communicate a key identifier to the recipient. Typically, KeyName contains an identifier related to the key pair used to sign the message, but it may contain other protocol-related information that indirectly identifies a key pair. (Common uses of KeyName include simple string names for keys, a key index, a distinguished name (DN), an email address, etc.)\n\nSchemaDefinition:\n\n<elementname=\"KeyName\"type=\"string\"/>\n\n4.5.2 The KeyValue Element\n\nThe KeyValue element contains a single public key that may be useful in validating the signature. Structured formats for defining DSA (REQUIRED), RSA (REQUIRED) and ECDSA (REQUIRED) public keys are defined in section 6.4 Signature Algorithms. The KeyValue element may include externally defined public keys values represented as PCDATA or element types from an external namespace.\n\nSchemaDefinition:\n\n<elementname=\"KeyValue\"type=\"ds:KeyValueType\"/><complexTypename=\"KeyValueType\"mixed=\"true\"><choice><elementref=\"ds:DSAKeyValue\"/><elementref=\"ds:RSAKeyValue\"/><!-- <element ref=\"dsig11:ECKeyValue\"/> --><!-- ECC keys (XMLDsig 1.1) will use the any element --><anynamespace=\"##other\"processContents=\"lax\"/></choice></complexType>\n\n4.5.2.1 The DSAKeyValue Element\n\nIdentifier\n\nType=\"http://www.w3.org/2000/09/xmldsig#DSAKeyValue\"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nDSA keys and the DSA signature algorithm are specified in [FIPS-186-3]. DSA public key values can have the following fields:\n\nP\n\na prime modulus meeting the [FIPS-186-3] requirements\n\nQ\n\nan integer in the range 2**159 < Q < 2**160 which is a prime divisor of P-1\n\nG\n\nan integer with certain properties with respect to P and Q\n\nY\n\nG**X mod P (where X is part of the private key and not made public)\n\nJ\n\n(P - 1) / Q\n\nseed\n\na DSA prime generation seed\n\npgenCounter\n\na DSA prime generation counter\n\nParameter J is available for inclusion solely for efficiency as it is calculatable from P and Q. Parameters seed and pgenCounter are used in the DSA prime number generation algorithm specified in [FIPS-186-3]. As such, they are optional but must either both be present or both be absent. This prime generation algorithm is designed to provide assurance that a weak prime is not being used and it yields a P and Q value. Parameters P, Q, and G can be public and common to a group of users. They might be known from application context. As such, they are optional but P and Q must either both appear or both be absent. If all of P, Q, seed, and pgenCounter are present, implementations are not required to check if they are consistent and are free to use either P and Q or seed and pgenCounter. All parameters are encoded as base64 [RFC2045] values.\n\nArbitrary-length integers (e.g. \"bignums\" such as RSA moduli) are represented in XML as octet strings as defined by the ds:CryptoBinary type.\n\nSchemaDefinition:\n\n<elementname=\"DSAKeyValue\"type=\"ds:DSAKeyValueType\"/><complexTypename=\"DSAKeyValueType\"><sequence><sequenceminOccurs=\"0\"><elementname=\"P\"type=\"ds:CryptoBinary\"/><elementname=\"Q\"type=\"ds:CryptoBinary\"/></sequence><elementname=\"G\"type=\"ds:CryptoBinary\"minOccurs=\"0\"/><elementname=\"Y\"type=\"ds:CryptoBinary\"/><elementname=\"J\"type=\"ds:CryptoBinary\"minOccurs=\"0\"/><sequenceminOccurs=\"0\"><elementname=\"Seed\"type=\"ds:CryptoBinary\"/><elementname=\"PgenCounter\"type=\"ds:CryptoBinary\"/></sequence></sequence></complexType>\n\n4.5.2.2 The RSAKeyValue Element\n\nIdentifier\n\nType=\"http://www.w3.org/2000/09/xmldsig#RSAKeyValue\"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nRSA key values have two fields: Modulus and Exponent.\n\nExample 6\n\n<RSAKeyValue><Modulus>xA7SEU+e0yQH5rm9kbCDN9o3aPIo7HbP7tX6WOocLZAtNfyxSZDU16ksL6W jubafOqNEpcwR3RdFsT7bCqnXPBe5ELh5u4VEy19MzxkXRgrMvavzyBpVRgBUwUlV 5foK5hhmbktQhyNdy/6LpQRhDUDsTvK+g9Ucj47es9AQJ3U= </Modulus><Exponent>AQAB</Exponent></RSAKeyValue>\n\nArbitrary-length integers (e.g. \"bignums\" such as RSA moduli) are represented in XML as octet strings as defined by the ds:CryptoBinary type.\n\nSchemaDefinition:\n\n<elementname=\"RSAKeyValue\"type=\"ds:RSAKeyValueType\"/><complexTypename=\"RSAKeyValueType\"><sequence><elementname=\"Modulus\"type=\"ds:CryptoBinary\"/><elementname=\"Exponent\"type=\"ds:CryptoBinary\"/></sequence></complexType>\n\n4.5.2.3 The ECKeyValue Element\n\nIdentifier\n\nType=\"http://www.w3.org/2009/xmldsig11#ECKeyValue\"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nThe ECKeyValue element is defined in the http://www.w3.org/2009/xmldsig11# namespace.\n\nEC public key values consists of two sub components: Domain parameters and PublicKey.\n\nExample 7\n\n<ECKeyValuexmlns=\"http://www.w3.org/2009/xmldsig11#\"><NamedCurveURI=\"urn:oid:1.2.840.10045.3.1.7\"/><PublicKey> vWccUP6Jp3pcaMCGIcAh3YOev4gaa2ukOANC7Ufg Cf8KDO7AtTOsGJK7/TA8IC3vZoCy9I5oPjRhyTBulBnj7Y </PublicKey></ECKeyValue>\n\nNote - A line break has been added to the PublicKey content to preserve printed page width.\n\nDomain parameters can be encoded explicitly using the dsig11:ECParameters element or by reference using the dsig11:NamedCurve element. A named curve is specified through the URI attribute. For named curves that are identified by OIDs, such as those defined in [RFC3279] and [RFC4055], the OID SHOULD be encoded according to [URN-OID]. Conformant applications MUST support the dsig11:NamedCurve element and the 256-bit prime field curve as identified by the OID 1.2.840.10045.3.1.7.\n\nThe PublicKey element contains a Base64 encoding of a binary representation of the x and y coordinates of the point. Its value is computed as follows:\n\nConvert the elliptic curve point (x,y) to an octet string by first converting the field elements x and y to octet strings as specified in Section 6.2 of [ECC-ALGS] (note), and then prepend the concatenated result of the conversion with 0x04. Support for Elliptic-Curve-Point-to-Octet-String conversion without point compression is REQUIRED.\n\nBase64 encode the octet string resulting from the conversion in Step 1.\n\nSchemaDefinition:\n\n<!-- targetNamespace=\"http://www.w3.org/2009/xmldsig11#\" --><elementname=\"ECKeyValue\"type=\"dsig11:ECKeyValueType\"/><complexTypename=\"ECKeyValueType\"><sequence><choice><elementname=\"ECParameters\"type=\"dsig11:ECParametersType\"/><elementname=\"NamedCurve\"type=\"dsig11:NamedCurveType\"/></choice><elementname=\"PublicKey\"type=\"dsig11:ECPointType\"/></sequence><attributename=\"Id\"type=\"ID\"use=\"optional\"/></complexType><complexTypename=\"NamedCurveType\"><attributename=\"URI\"type=\"anyURI\"use=\"required\"/></complexType><simpleTypename=\"ECPointType\"><restrictionbase=\"ds:CryptoBinary\"/></simpleType>\n\n4.5.2.3.1 Explicit Curve Parameters\n\nThe ECParameters element consists of the following subelements. Note these definitions are based on the those described in [RFC3279].\n\nThe FieldID element identifies the finite field over which the elliptic curve is defined. Additional details on the structures for defining prime and characteristic two fields is provided below.\n\nThe dsig11:Curve element specifies the coefficients a and b of the elliptic curve E. Each coefficient is first converted from a field element to an octet string as specified in section 6.2 of [ECC-ALGS], then the resultant octet string is encoded in base64.\n\nThe Base element specifies the base point P on the elliptic curve. The base point is represented as a value of type ECPointType.\n\nThe Order element specifies the order n of the base point and is encoded as a positiveInteger.\n\nThe Cofactor element is an optional element that specifies the integer h = #E(Fq)/n. The cofactor is not required to support ECDSA, except in parameter validation. The cofactor MAY be included to support parameter validation for ECDSA keys. Parameter validation is not required by this specification. The cofactor is required in ECDH public key parameters.\n\nThe dsig11:ValidationData element is an optional element that specifies the hash algorithm used to generate the elliptic curve E and the base point G verifiably at random. It also specifies the seed that was used to generate the curve and the base point.\n\nSchemaDefinition:\n\n<!-- targetNamespace=\"http://www.w3.org/2009/xmldsig11#\" --><complexTypename=\"ECParametersType\"><sequence><elementname=\"FieldID\"type=\"dsig11:FieldIDType\"/><elementname=\"Curve\"type=\"dsig11:CurveType\"/><elementname=\"Base\"type=\"dsig11:ECPointType\"/><elementname=\"Order\"type=\"ds:CryptoBinary\"/><elementname=\"CoFactor\"type=\"integer\"minOccurs=\"0\"/><elementname=\"ValidationData\"type=\"dsig11:ECValidationDataType\"minOccurs=\"0\"/></sequence></complexType><complexTypename=\"FieldIDType\"><choice><elementref=\"dsig11:Prime\"/><elementref=\"dsig11:TnB\"/><elementref=\"dsig11:PnB\"/><elementref=\"dsig11:GnB\"/><anynamespace=\"##other\"processContents=\"lax\"/></choice></complexType><complexTypename=\"CurveType\"><sequence><elementname=\"A\"type=\"ds:CryptoBinary\"/><elementname=\"B\"type=\"ds:CryptoBinary\"/></sequence></complexType><complexTypename=\"ECValidationDataType\"><sequence><elementname=\"seed\"type=\"ds:CryptoBinary\"/></sequence><attributename=\"hashAlgorithm\"type=\"anyURI\"use=\"required\"/></complexType>\n\nPrime fields are described by a single subelement P, which represents the field size in bits. It is encoded as a positiveInteger.\n\nSchemaDefinition:\n\n<!-- targetNamespace=\"http://www.w3.org/2009/xmldsig11#\" --><elementname=\"Prime\"type=\"dsig11:PrimeFieldParamsType\"/><complexTypename=\"PrimeFieldParamsType\"><sequence><elementname=\"P\"type=\"ds:CryptoBinary\"/></sequence></complexType>\n\nStructures are defined for three types of characteristic two fields: gaussian normal basis, pentanomial basis and trinomial basis.\n\nSchemaDefinition:\n\n<!-- targetNamespace=\"http://www.w3.org/2009/xmldsig11#\" --><elementname=\"GnB\"type=\"dsig11:CharTwoFieldParamsType\"/><complexTypename=\"CharTwoFieldParamsType\"><sequence><elementname=\"M\"type=\"positiveInteger\"/></sequence></complexType><elementname=\"TnB\"type=\"dsig11:TnBFieldParamsType\"/><complexTypename=\"TnBFieldParamsType\"><complexContent><extensionbase=\"dsig11:CharTwoFieldParamsType\"><sequence><elementname=\"K\"type=\"positiveInteger\"/></sequence></extension></complexContent></complexType><elementname=\"PnB\"type=\"dsig11:PnBFieldParamsType\"/><complexTypename=\"PnBFieldParamsType\"><complexContent><extensionbase=\"dsig11:CharTwoFieldParamsType\"><sequence><elementname=\"K1\"type=\"positiveInteger\"/><elementname=\"K2\"type=\"positiveInteger\"/><elementname=\"K3\"type=\"positiveInteger\"/></sequence></extension></complexContent></complexType>\n\n4.5.2.3.2 Compatibility with RFC 4050\n\nImplementations that need to support the [RFC4050] format for ECDSA keys can avoid known interoperability problems with that specification by adhering to the following profile:\n\nAvoid validating the ECDSAKeyValue element against the [RFC4050] schema. XML schema validators may not support integer types with decimal data exceeding 18 decimal digits. [XMLSCHEMA-1][XMLSCHEMA-2].\n\nSupport only the NamedCurve element.\n\nSupport the 256-bit prime field curve, as identified by the URN urn:oid:1.2.840.10045.3.1.7.\n\nThe following is an example of a ECDSAKeyValue element that meets the profile described in this section.\n\nExample 8\n\n<ECDSAKeyValuexmlns=\"http://www.w3.org/2001/04/xmldsig-more#\"><DomainParameters><NamedCurveURN=\"urn:oid:1.2.840.10045.3.1.7\"/></DomainParameters><PublicKey><XValue=\"5851106065380174439324917904648283332 0204931884267326155134056258624064349885\"/><YValue=\"1024033521368277752409102672177795083 59028642524881540878079119895764161434936\"/></PublicKey></ECDSAKeyValue>\n\nNote - A line break has been added to the X and Y Value attribute values to preserve printed page width.\n\n4.5.3 The RetrievalMethod Element\n\nA RetrievalMethod element within KeyInfo is used to convey a reference to KeyInfo information that is stored at another location. For example, several signatures in a document might use a key verified by an X.509v3 certificate chain appearing once in the document or remotely outside the document; each signature's KeyInfo can reference this chain using a single RetrievalMethod element instead of including the entire chain with a sequence of X509Certificate elements.\n\nRetrievalMethod uses the same syntax and dereferencing behavior as the Reference URI attribute (section 4.4.3.1 The URI Attribute) and the Reference Processing Model except that there are no DigestMethod or DigestValue child elements and presence of the URI attribute is mandatory.\n\nType is an optional identifier for the type of data retrieved after all transforms have been applied. The result of dereferencing a RetrievalMethod Reference for all KeyInfo types defined by this specification ( section 4.5 The KeyInfo Element) with a corresponding XML structure is an XML element or document with that element as the root. The rawX509Certificate KeyInfo (for which there is no XML structure) returns a binary X509 certificate.\n\nNote that when referencing one of the defined KeyInfo types within the same document, or some remote documents, at least one Transform is required to turn an ID-based reference to a KeyInfo element into a child element located inside it. This is due to the lack of an XML ID attribute on the defined KeyInfo types. In such cases, use of KeyInfoReference is encouraged instead, see section 4.5.10 The KeyInfoReference Element.\n\nNote: The KeyInfoReference element is preferred over use of RetrievalMethod as it avoids use of Transform child elements that introduce security risk and implementation challenges.\n\nSchemaDefinition:\n\n<elementname=\"RetrievalMethod\"type=\"ds:RetrievalMethodType\"/><complexTypename=\"RetrievalMethodType\"><sequence><elementref=\"ds:Transforms\"minOccurs=\"0\"/></sequence><attributename=\"URI\"type=\"anyURI\"/><attributename=\"Type\"type=\"anyURI\"use=\"optional\"/></complexType>\n\nNote: The schema for the URI attribute of RetrievalMethod erroneously omitted the attribute: use=\"required\". However, this error only results in a more lax schema which permits all valid RetrievalMethod elements. Because the existing schema is embedded in many applications, which may include the schema in their signatures, the schema has not been corrected to be more restrictive.\n\n4.5.4 The X509Data Element\n\nIdentifier\n\nType=\"http://www.w3.org/2000/09/xmldsig#X509Data \"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nAn X509Data element within KeyInfo contains one or more identifiers of keys or X509 certificates (or certificates' identifiers or a revocation list). The content of X509Data is at least one element, from the following set of element types; any of these may appear together or more than once iff (if and only if) each instance describes or is related to the same certificate:\n\nThe deprecated X509IssuerSerial element, which contains an X.509 issuer distinguished name/serial number pair. The distinguished name SHOULD be represented as a string that complies with section 3 of RFC4514 [LDAP-DN], to be generated according to the Distinguished Name Encoding Rules section below,\n\nThe X509SubjectName element, which contains an X.509 subject distinguished name that SHOULD be represented as a string that complies with section 3 of RFC4514 [LDAP-DN], to be generated according to the Distinguished Name Encoding Rules section below,\n\nThe X509SKI element, which contains the base64 encoded plain (i.e. non-DER-encoded) value of a X509 V.3 SubjectKeyIdentifier extension,\n\nThe X509Certificate element, which contains a base64-encoded [X509V3] certificate, and\n\nThe X509CRL element, which contains a base64-encoded certificate revocation list (CRL) [X509V3].\n\nThe dsig11:X509Digest element contains a base64-encoded digest of a certificate. The digest algorithm URI is identified with a required Algorithm attribute. The input to the digest MUST be the raw octets that would be base64-encoded were the same certificate to appear in the X509Certificate element.\n\nElements from an external namespace which accompanies/complements any of the elements above.\n\nAny X509IssuerSerial, X509SKI, X509SubjectName, and dsig11:X509Digest elements that appear MUST refer to the certificate or certificates containing the validation key. All such elements that refer to a particular individual certificate MUST be grouped inside a single X509Data element and if the certificate to which they refer appears, it MUST also be in that X509Data element.\n\nAny X509IssuerSerial, X509SKI, X509SubjectName, and dsig11:X509Digest elements that relate to the same key but different certificates MUST be grouped within a single KeyInfo but MAY occur in multiple X509Data elements.\n\nNote that if X509Data child elements are used to identify a trusted certificate (rather than solely as an untrusted hint supplemented by validation by policy), the complete set of such elements that are intended to identify a certificate SHOULD be integrity protected, typically by signing an entire X509Data or KeyInfo element.\n\nAll certificates appearing in an X509Data element MUST relate to the validation key by either containing it or being part of a certification chain that terminates in a certificate containing the validation key.\n\nNo ordering is implied by the above constraints. The comments in the following instance demonstrate these constraints:\n\nExample 9\n\n<KeyInfo><X509Data><!-- two pointers to certificate-A --><X509IssuerSerial><X509IssuerName> CN=TAMURA Kent, OU=TRL, O=IBM, L=Yamato-shi, ST=Kanagawa, C=JP </X509IssuerName><X509SerialNumber>12345678</X509SerialNumber></X509IssuerSerial><X509SKI>31d97bd7</X509SKI></X509Data><X509Data><!-- single pointer to certificate-B --><X509SubjectName>Subject of Certificate B</X509SubjectName></X509Data><X509Data><!-- certificate chain --><!--Signer cert, issuer CN=arbolCA,OU=FVT,O=IBM,C=US, serial 4--><X509Certificate>MIICXTCCA..</X509Certificate><!-- Intermediate cert subject CN=arbolCA,OU=FVT,O=IBM,C=US issuer CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US --><X509Certificate>MIICPzCCA...</X509Certificate><!-- Root cert subject CN=tootiseCA,OU=FVT,O=Bridgepoint,C=US --><X509Certificate>MIICSTCCA...</X509Certificate></X509Data></KeyInfo>\n\nNote, there is no direct provision for a PKCS#7 encoded \"bag\" of certificates or CRLs. However, a set of certificates and CRLs can occur within an X509Data element and multiple X509Data elements can occur in a KeyInfo. Whenever multiple certificates occur in an X509Data element, at least one such certificate must contain the public key which verifies the signature.\n\nWhile in principle many certificate encodings are possible, it is RECOMMENDED that certificates appearing in an X509Certificate element be limited to an encoding of BER or its DER subset, allowing that within the certificate other content may be present. The use of other encodings may lead to interoperability issues. In any case, XML Signature implementations SHOULD NOT alter or re-encode certificates, as doing so could invalidate their signatures.\n\nThe X509IssuerSerial element has been deprecated in favor of the newly-introduced dsig11:X509Digest element. The XML Schema type of the serial number was defined to be an integer, and XML Schema validators may not support integer types with decimal data exceeding 18 decimal digits [XMLSCHEMA-2]. This has proven insufficient, because many Certificate Authorities issue certificates with large, random serial numbers that exceed this limit. As a result, deployments that do make use of this element should take care if schema validation is involved. New deployments SHOULD avoid use of the element.\n\n4.5.4.1 Distinguished Name Encoding Rules\n\nTo encode a distinguished name (X509IssuerSerial,X509SubjectName, and KeyName if appropriate), the encoding rules in section 2 of RFC 4514 [LDAP-DN] SHOULD be applied, except that the character escaping rules in section 2.4 of RFC 4514 [LDAP-DN] MAY be augmented as follows:\n\nEscape all occurrences of ASCII control characters (Unicode range \\x00 - \\x1f) by replacing them with \"\\\" followed by a two digit hex number showing its Unicode number.\n\nEscape any trailing space characters (Unicode \\x20) by replacing them with \"\\20\", instead of using the escape sequence \"\\ \".\n\nSince an XML document logically consists of characters, not octets, the resulting Unicode string is finally encoded according to the character encoding used for producing the physical representation of the XML document.\n\nSchemaDefinition:\n\n<elementname=\"X509Data\"type=\"ds:X509DataType\"/><complexTypename=\"X509DataType\"><sequencemaxOccurs=\"unbounded\"><choice><elementname=\"X509IssuerSerial\"type=\"ds:X509IssuerSerialType\"/><elementname=\"X509SKI\"type=\"base64Binary\"/><elementname=\"X509SubjectName\"type=\"string\"/><elementname=\"X509Certificate\"type=\"base64Binary\"/><elementname=\"X509CRL\"type=\"base64Binary\"/><!-- <element ref=\"dsig11:X509Digest\"/> --><!-- The X509Digest element (XMLDSig 1.1) will use the any element --><anynamespace=\"##other\"processContents=\"lax\"/></choice></sequence></complexType><complexTypename=\"X509IssuerSerialType\"><sequence><elementname=\"X509IssuerName\"type=\"string\"/><elementname=\"X509SerialNumber\"type=\"integer\"/></sequence></complexType><!-- Note, this schema permits X509Data to be empty; this is precluded by the text in <a href=\"#sec-KeyInfo\" class=\"sectionRef\"></a> which states that at least one element from the dsig namespace should be present in the PGP, SPKI, and X509 structures. This is easily expressed for the other key types, but not for X509Data because of its rich structure. --><!-- targetNameSpace=\"http://www.w3.org/2009/xmldsig11#\" --><elementname=\"X509Digest\"type=\"dsig11:X509DigestType\"/><complexTypename=\"X509DigestType\"><simpleContent><extensionbase=\"base64Binary\"><attributename=\"Algorithm\"type=\"anyURI\"use=\"required\"/></extension></simpleContent></complexType>\n\n4.5.5 The PGPData Element\n\nIdentifier\n\nType=\"http://www.w3.org/2000/09/xmldsig#PGPData \"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nThe PGPData element within KeyInfo is used to convey information related to PGP public key pairs and signatures on such keys. The PGPKeyID's value is a base64Binary sequence containing a standard PGP public key identifier as defined in [PGP] section 11.2]. The PGPKeyPacket contains a base64-encoded Key Material Packet as defined in [PGP] section 5.5]. These children element types can be complemented/extended by siblings from an external namespace within PGPData, or PGPData can be replaced all together with an alternative PGP XML structure as a child of KeyInfo. PGPData must contain one PGPKeyID and/or one PGPKeyPacket and 0 or more elements from an external namespace.\n\nSchemaDefinition:\n\n<elementname=\"PGPData\"type=\"ds:PGPDataType\"/><complexTypename=\"PGPDataType\"><choice><sequence><elementname=\"PGPKeyID\"type=\"base64Binary\"/><elementname=\"PGPKeyPacket\"type=\"base64Binary\"minOccurs=\"0\"/><anynamespace=\"##other\"processContents=\"lax\"minOccurs=\"0\"maxOccurs=\"unbounded\"/></sequence><sequence><elementname=\"PGPKeyPacket\"type=\"base64Binary\"/><anynamespace=\"##other\"processContents=\"lax\"minOccurs=\"0\"maxOccurs=\"unbounded\"/></sequence></choice></complexType>\n\n4.5.6 The SPKIData Element\n\nIdentifier\n\nType=\"http://www.w3.org/2000/09/xmldsig#SPKIData \"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nThe SPKIData element within KeyInfo is used to convey information related to SPKI public key pairs, certificates and other SPKI data. SPKISexp is the base64 encoding of a SPKI canonical S-expression. SPKIData must have at least one SPKISexp; SPKISexp can be complemented/extended by siblings from an external namespace within SPKIData, or SPKIData can be entirely replaced with an alternative SPKI XML structure as a child of KeyInfo.\n\nSchemaDefinition:\n\n<elementname=\"SPKIData\"type=\"ds:SPKIDataType\"/><complexTypename=\"SPKIDataType\"><sequencemaxOccurs=\"unbounded\"><elementname=\"SPKISexp\"type=\"base64Binary\"/><anynamespace=\"##other\"processContents=\"lax\"minOccurs=\"0\"/></sequence></complexType>\n\n4.5.7 The MgmtData Element\n\nIdentifier\n\nType=\"http://www.w3.org/2000/09/xmldsig#MgmtData \"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nThe MgmtData element within KeyInfo is a string value used to convey in-band key distribution or agreement data. However, use of this element is NOT RECOMMENDED and SHOULD NOT be used. The section 4.5.8 XML Encryption EncryptedKey and DerivedKey Elements describes new KeyInfo types for conveying key information.\n\nSchemaDefinition:\n\n<elementname=\"MgmtData\"type=\"string\"/>\n\n4.5.8 XML Encryption EncryptedKey and DerivedKey Elements\n\nThe <xenc:EncryptedKey> and <xenc:DerivedKey> elements defined in [XMLENC-CORE1] as children of ds:KeyInfo can be used to convey in-band encrypted or derived key material. In particular, the xenc:DerivedKey> element may be present when the key used in calculating a Message Authentication Code is derived from a shared secret.\n\n4.5.9 The DEREncodedKeyValue Element\n\nIdentifier\n\nType=\"http://www.w3.org/2009/xmldsig11#DEREncodedKeyValue\"\n\n(this can be used within a RetrievalMethod or Reference element to identify the referent's type)\n\nThe public key algorithm and value are DER-encoded in accordance with the value that would be used in the Subject Public Key Info field of an X.509 certificate, per section 4.1.2.7 of [RFC5280]. The DER-encoded value is then base64-encoded.\n\nFor the key value types supported in this specification, refer to the following for normative references on the format of Subject Public Key Info and the relevant OID values that identify the key/algorithm type:\n\nRSA\n\nSee section 2.3.1 of [RFC3279]\n\nDSA\n\nSee section 2.3.2 of [RFC3279]\n\nEC\n\nSee section 2 of [RFC5480]\n\nSpecifications that define additional key types should provide such a normative reference for their own key types where possible.\n\nSchemaDefinition:\n\n<!-- targetNamespace=\"http://www.w3.org/2009/xmldsig11#\" --><elementname=\"DEREncodedKeyValue\"type=\"dsig11:DEREncodedKeyValueType\"/><complexTypename=\"DEREncodedKeyValueType\"><simpleContent><extensionbase=\"base64Binary\"><attributename=\"Id\"type=\"ID\"use=\"optional\"/></extension></simpleContent></complexType>\n\nHistorical note: The DEREncodedKeyValue element was added to XML Signature 1.1 in order to support certain interoperability scenarios where at least one of signer and/or verifier are not able to serialize keys in the XML formats described in section 4.5.2 The KeyValue Element above. The KeyValue element is to be used for \"bare\" XML key representations (not XML wrappings around other binary encodings like ASN.1 DER); for this reason the DEREncodedKeyValue element is not a child of KeyValue. The DEREncodedKeyValue element is also not a child of the X509Data element, as the keys represented by DEREncodedKeyValue may not have X.509 certificates associated with them (a requirement for X509Data).\n\n4.5.10 The KeyInfoReference Element\n\nA KeyInfoReference element within KeyInfo is used to convey a reference to a KeyInfo element at another location in the same or different document. For example, several signatures in a document might use a key verified by an X.509v3 certificate chain appearing once in the document or remotely outside the document; each signature's KeyInfo can reference this chain using a single KeyInfoReference element instead of including the entire chain with a sequence of X509Certificate elements repeated in multiple places.\n\nKeyInfoReference uses the same syntax and dereferencing behavior as Reference's URI ( section 4.4.3.1 The URI Attribute) and the Reference Processing Model (section 4.4.3.2 The Reference Processing Model) except that there are no child elements and the presence of the URI attribute is mandatory.\n\nThe result of dereferencing a KeyInfoReference MUST be a KeyInfo element, or an XML document with a KeyInfo element as the root.\n\nNote: The KeyInfoReference element is a desirable alternative to the use of RetrievalMethod when the data being referred to is a KeyInfo element and the use of RetrievalMethod would require one or more Transform child elements, which introduce security risk and implementation challenges.\n\nSchemaDefinition:\n\n<!-- targetNamespace=\"http://www.w3.org/2009/xmldsig11#\" --><elementname=\"KeyInfoReference\"type=\"dsig11:KeyInfoReferenceType\"/><complexTypename=\"KeyInfoReferenceType\"><attributename=\"URI\"type=\"anyURI\"use=\"required\"/><attributename=\"Id\"type=\"ID\"use=\"optional\"/></complexType>\n\n6.4 Signature Algorithms\n\nSignature algorithms take two implicit parameters, their keying material determined from KeyInfo and the octet stream output by CanonicalizationMethod. Signature and MAC algorithms are syntactically identical but a signature implies public key cryptography.\n\n6.4.1 DSA\n\nIdentifier:\n\nhttp://www.w3.org/2000/09/xmldsig#dsa-sha1\n\nhttp://www.w3.org/2009/xmldsig11#dsa-sha256\n\nThe DSA family of algorithms is defined in FIPS 186-3 [FIPS-186-3]. FIPS 186-3 defines DSA in terms of two security parameters L and N where L = |p|, N = |q|, p is the prime modulus, q is a prime divisor of (p-1). FIPS 186-3 defines four valid pairs of (L, N); they are: (1024, 160), (2048, 224), (2048, 256) and (3072, 256). The pair (1024, 160) corresponds to the algorithm DSAwithSHA1, which is identified in this specification by the URI http://www.w3.org/2000/09/xmldsig#dsa-sha1. The pairs (2048, 256) and (3072, 256) correspond to the algorithm DSAwithSHA256, which is identified in this specification by the URI http://www.w3.org/2009/xmldsig11#dsa-sha256. This specification does not use the (2048, 224) instance of DSA (which corresponds to DSAwithSHA224).\n\nDSA takes no explicit parameters; an example of a DSA SignatureMethod element is:\n\nExample 16\n\n<SignatureMethodAlgorithm=\"http://www.w3.org/2009/xmldsig11#dsa-sha256\"/>\n\nThe output of the DSA algorithm consists of a pair of integers usually referred by the pair (r, s). The signature value consists of the base64 encoding of the concatenation of two octet-streams that respectively result from the octet-encoding of the values r and s in that order. Integer to octet-stream conversion must be done according to the I2OSP operation defined in the RFC 3447 [PKCS1] specification with a l parameter equal to 20. For example, the SignatureValue element for a DSA signature (r, s) with values specified in hexadecimal:\n\nExample 17\n\nr =8BAC1AB66410435C B7181F95 B16AB97C 92B341C0s =41E2345F1F56DF2458F426D155B4BA2D B6DCD8C8\n\nfrom the example in Appendix 5 of the DSS standard would be\n\nExample 18\n\n<SignatureValue>i6watmQQQ1y3GB+VsWq5fJKzQcBB4jRfH1bfJFj0JtFVtLotttzYyA==</SignatureValue>\n\nSecurity considerations regarding DSA key sizes\n\nPer FIPS 186-3 [FIPS-186-3], the DSA security parameter L is defined to be 1024, 2048 or 3072 bits and the corresponding DSA q value is defined to be 160, 224/256 and 256 bits respectively.\n\nNIST provides guidance on the use of keys of various strength for various time frames in special Publication SP 800-57 Part 1 [SP800-57]. Implementers should consult this publication for guidance on acceptable key lengths for applications, however 2048-bit public keys are the minimum recommended key length and 3072-bit keys are recommended for securing information beyond 2030. SP800-57 Part 1 states that DSA 1024-bit key sizes should not be used except to verify and honor signatures created using older legacy systems.\n\nSince XML Signature 1.0 requires implementations to support DSA-based digital signatures, this XML Signature 1.1 revision allows verifiers to verify DSA signatures for DSA keys of 1024 bits in order to validate existing signatures. XML Signature 1.1 implementations MAY but are NOT REQUIRED to support DSA-based signature generation. Given the short key size and SP800-57 guidelines, DSA with 1024-bit prime moduli SHOULD NOT be used to create signatures. DSA with 1024-bit prime moduli MAY be used to verify older legacy signatures, with an understanding of the associated risks. Important older signatures SHOULD be re-signed with stronger signatures.\n\n6.4.2 RSA (PKCS#1 v1.5)\n\nIdentifier:\n\nhttp://www.w3.org/2000/09/xmldsig#rsa-sha1\n\nhttp://www.w3.org/2001/04/xmldsig-more#rsa-sha224\n\nhttp://www.w3.org/2001/04/xmldsig-more#rsa-sha256\n\nhttp://www.w3.org/2001/04/xmldsig-more#rsa-sha384\n\nhttp://www.w3.org/2001/04/xmldsig-more#rsa-sha512\n\nThe expression \"RSA algorithm\" as used in this specification refers to the RSASSA-PKCS1-v1_5 algorithm described in RFC 3447 [PKCS1]. The RSA algorithm takes no explicit parameters. An example of an RSA SignatureMethod element is:\n\nExample 19\n\n<SignatureMethodAlgorithm=\"http://www.w3.org/2000/09/xmldsig#rsa-sha1\"/>\n\nThe SignatureValue content for an RSA signature is the base64 [RFC2045] encoding of the octet string computed as per RFC 3447 [PKCS1], section 8.2.1: Signature generation for the RSASSA-PKCS1-v1_5 signature scheme]. Computation of the signature will require concatenation of the hash value and a constant string determined by RFC 3447. Signature computation and verification does not require implementation of an ASN.1 parser.\n\nThe resulting base64 [RFC2045] string is the value of the child text node of the SignatureValue element, e.g.\n\nExample 20\n\n<SignatureValue> IWijxQjUrcXBYoCei4QxjWo9Kg8D3p9tlWoT4t0/gyTE96639In0FZFY2/rvP+/bMJ01EArmKZs R5VW3rwoPxw= </SignatureValue>\n\nNote - A line break has been added to preserve printed page width.\n\nSecurity considerations regarding RSA key sizes\n\nNIST provides guidance on the use of keys of various strength for various time frames in special Publication SP 800-57 Part 1 [SP800-57]. Implementers should consult this publication for guidance on acceptable key lengths for applications, however 2048-bit public keys are the minimum recommended key length and 3072-bit keys are recommended for securing information beyond 2030.\n\nAll conforming implementations of XML Signature 1.1 MUST support RSA signature generation and verification with public keys at least 2048 bits in length. RSA public keys of 1024 bits or less SHOULD NOT be used to create new signatures but MAY be used to verify signatures created by older legacy systems. XML Signature 1.1 implementations MUST use at least 2048-bit keys for creating signatures, and SHOULD use at least 3072-bit keys for signatures that will be verified beyond 2030.\n\n6.4.3 ECDSA\n\nIdentifiers:\n\nhttp://www.w3.org/2001/04/xmldsig-more#ecdsa-sha1\n\nhttp://www.w3.org/2001/04/xmldsig-more#ecdsa-sha224\n\nhttp://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\n\nhttp://www.w3.org/2001/04/xmldsig-more#ecdsa-sha384\n\nhttp://www.w3.org/2001/04/xmldsig-more#ecdsa-sha512\n\nThe ECDSA algorithm [FIPS-186-3] takes no explicit parameters. An example of a ECDSA SignatureMethod element is:\n\nExample 21\n\n<SignatureMethodAlgorithm=\"http://www.w3.org/2001/04/xmldsig-more#ecdsa-sha256\"/>\n\nThe output of the ECDSA algorithm consists of a pair of integers usually referred by the pair (r, s). The signature value consists of the base64 encoding of the concatenation of two octet-streams that respectively result from the octet-encoding of the values r and s in that order. Integer to octet-stream conversion must be done according to the I2OSP operation defined in the RFC 3447 [PKCS1] specification with the l parameter equal to the size of the base point order of the curve in bytes (e.g. 32 for the P-256 curve and 66 for the P-521 curve).\n\nThis specification REQUIRES implementations to implement an algorithm that leads to the same results as ECDSA over the P-256 prime curve specified in Section D.2.3 of FIPS 186-3 [FIPS-186-3] (and using the SHA-256 hash algorithm), referred to as the ECDSAwithSHA256 signature algorithm [ECC-ALGS]. It is further RECOMMENDED that implementations also implement algorithms that lead to the same results as ECDSA over the P-384 and P-521 prime curves; these curves are defined in Sections D.2.4 and D.2.5 of FIPS 186-3, respectively [ECC-ALGS].\n\nNote: As described in IETF RFC 6090, the Elliptic Curve DSA (ECDSA) and KT-I signature methods are mathematically and functionally equivalent for fields of characteristic greater than three. See IETF RFC 6090 Section 7.2 [ECC-ALGS].\n\n6.5 Canonicalization Algorithms\n\nIf canonicalization is performed over octets, the canonicalization algorithms take two implicit parameters: the content and its charset. The charset is derived according to the rules of the transport protocols and media types (e.g, [XML-MEDIA-TYPES] defines the media types for XML). This information is necessary to correctly sign and verify documents and often requires careful server side configuration.\n\nVarious canonicalization algorithms require conversion to [UTF-8]. The algorithms below understand at least [UTF-8] and [UTF-16] as input encodings. We RECOMMEND that externally specified algorithms do the same. Knowledge of other encodings is OPTIONAL.\n\nVarious canonicalization algorithms transcode from a non-Unicode encoding to Unicode. The output of these algorithms will be in NFC [NFC]. This is because the XML processor used to prepare the XPath data model input is required (by the Data Model) to use Normalization Form C when converting an XML document to the UCS character domain from any encoding that is not UCS-based.\n\nWe RECOMMEND that externally specified canonicalization algorithms do the same. (Note, there can be ambiguities in converting existing charsets to Unicode, for an example see the XML Japanese Profile Note [XML-Japanese].)\n\nThis specification REQUIRES implementation of Canonical XML 1.0 [XML-C14N], Canonical XML 1.1 [XML-C14N11]] and Exclusive XML Canonicalization [XML-EXC-C14N]. We RECOMMEND that applications that generate signatures choose Canonical XML 1.1 [XML-C14N11] when inclusive canonicalization is desired.\n\nNote: Canonical XML 1.0 [XML-C14N] and Canonical XML 1.1 [XML-C14N11] specify a standard serialization of XML that, when applied to a subdocument, includes the subdocument's ancestor context including all of the namespace declarations and some attributes in the 'xml:' namespace. However, some applications require a method which, to the extent practical, excludes unused ancestor context from a canonicalized subdocument. The Exclusive XML Canonicalization Recommendation [XML-EXC-C14N] may be used to address requirements resulting from scenarios where a subdocument is moved between contexts.\n\n6.5.1 Canonical XML 1.0\n\nIdentifier for REQUIRED Canonical XML 1.0 (omits comments):\n\nhttp://www.w3.org/TR/2001/REC-xml-c14n-20010315\n\nIdentifier for Canonical XML 1.0 with Comments:\n\nhttp://www.w3.org/TR/2001/REC-xml-c14n-20010315#WithComments\n\nInput:\n\noctet-stream, node-set\n\nOutput:\n\noctet-stream\n\nAn example of an XML canonicalization element is:\n\nExample 22\n\n<CanonicalizationMethodAlgorithm=\"http://www.w3.org/TR/2001/REC-xml-c14n-20010315\"/>\n\nThe normative specification of Canonical XML1.0 is [XML-C14N]. The algorithm is capable of taking as input either an octet stream or an XPath node-set (or sufficiently functional alternative). The algorithm produces an octet stream as output. Canonical XML is easily parameterized (via an additional URI) to omit or retain comments.\n\n6.5.2 Canonical XML 1.1\n\nIdentifier for REQUIRED Canonical XML 1.1 (omits comments):\n\nhttp://www.w3.org/2006/12/xml-c14n11\n\nIdentifier for Canonical XML 1.1 with Comments:\n\nhttp://www.w3.org/2006/12/xml-c14n11#WithComments\n\nInput:\n\noctet-stream, node-set\n\nOutput:\n\noctet-stream\n\nThe normative specification of Canonical XML 1.1 is [XML-C14N11]. The algorithm is capable of taking as input either an octet stream or an XPath node-set (or sufficiently functional alternative). The algorithm produces an octet stream as output. Canonical XML 1.1 is easily parameterized (via an additional URI) to omit or retain comments.\n\n6.5.3 Exclusive XML Canonicalization 1.0\n\nIdentifier for REQUIRED Exclusive XML Canonicalization 1.0 (omits comments):\n\nhttp://www.w3.org/2001/10/xml-exc-c14n#\n\nIdentifier for Exclusive XML Canonicalization 1.0 with Comments:\n\nhttp://www.w3.org/2001/10/xml-exc-c14n#WithComments\n\nInput:\n\noctet-stream, node-set\n\nOutput:\n\noctet-stream\n\nThe normative specification of Exclusive XML Canonicalization 1.0 is [XML-EXC-C14N]].\n\n6.6 Transform Algorithms\n\nA Transform algorithm has a single implicit parameter: an octet stream from the Reference or the output of an earlier Transform.\n\nFor implementation requirements, please see Algorithm Identifiers and Implementation Requirements. Application developers are strongly encouraged to support all transforms that are listed as RECOMMENDED unless the application environment has resource constraints that would make such support impractical. Compliance with this recommendation will maximize application interoperability and libraries should be available to enable support of these transforms in applications without extensive development.\n\n6.6.1 Canonicalization\n\nAny canonicalization algorithm that can be used for CanonicalizationMethod (such as those in Canonicalization Algorithms (section 6.5)) can be used as a Transform.\n\n6.6.2 Base64\n\nIdentifiers:\n\nhttp://www.w3.org/2000/09/xmldsig#base64\n\nInput:\n\noctet-stream, node-set\n\nOutput:\n\noctet-stream\n\nThe normative specification for base64 decoding transforms is [RFC2045]. The base64 Transform element has no content. The input is decoded by the algorithms. This transform is useful if an application needs to sign the raw data associated with the encoded content of an element.\n\nThis transform accepts either an octet-stream or a node-set as input. If an octet-string is given as input, then this octet-stream is processed directly. If an XPath node-set (or sufficiently functional alternative) is given as input, then it is converted to an octet stream by performing operations logically equivalent to 1) applying an XPath transform with expression self::text(), then 2) sorting the nodeset by document order, then concatenating the string-value of each of the nodes into one long string. Thus, if an XML element is identified by a shortname XPointer in the Reference URI, and its content consists solely of base64 encoded character data, then this transform automatically strips away the start and end tags of the identified element and any of its descendant elements as well as any descendant comments and processing instructions. The output of this transform is an octet stream.\n\n6.6.3 XPath Filtering\n\nIdentifier:\n\nhttp://www.w3.org/TR/1999/REC-xpath-19991116\n\nInput:\n\noctet-stream, node-set\n\nOutput:\n\nnode-set\n\nThe normative specification for XPath expression evaluation is [XPATH]. The XPath expression to be evaluated appears as the character content of a transform parameter child element named XPath.\n\nThe input required by this transform is an XPath node-set or an octet-stream. Note that if the actual input is an XPath node-set resulting from a null URI or shortname XPointer dereference, then comment nodes will have been omitted. If the actual input is an octet stream, then the application MUST convert the octet stream to an XPath node-set suitable for use by Canonical XML with Comments. (A subsequent application of the REQUIRED Canonical XML algorithm would strip away these comments.) In other words, the input node-set should be equivalent to the one that would be created by the following process:\n\nInitialize an XPath evaluation context by setting the initial node equal to the input XML document's root node, and set the context position and size to 1.\n\nEvaluate the XPath expression (//. | //@* | //namespace::*)\n\nThe evaluation of this expression includes all of the document's nodes (including comments) in the node-set representing the octet stream.\n\nThe transform output is always an XPath node-set. The XPath expression appearing in the XPath parameter is evaluated once for each node in the input node-set. The result is converted to a boolean. If the boolean is true, then the node is included in the output node-set. If the boolean is false, then the node is omitted from the output node-set.\n\nNote: Even if the input node-set has had comments removed, the comment nodes still exist in the underlying parse tree and can separate text nodes. For example, the markup <e>Hello, <!-- comment -->world!</e> contains two text nodes. Therefore, the expression self::text()[string()=\"Hello, world!\"] would fail. Should this problem arise in the application, it can be solved by either canonicalizing the document before the XPath transform to physically remove the comments or by matching the node based on the parent element's string value (e.g. by using the expression self::text()[string(parent::e)=\"Hello, world!\"]).\n\nThe primary purpose of this transform is to ensure that only specifically defined changes to the input XML document are permitted after the signature is affixed. This is done by omitting precisely those nodes that are allowed to change once the signature is affixed, and including all other input nodes in the output. It is the responsibility of the XPath expression author to include all nodes whose change could affect the interpretation of the transform output in the application context.\n\nNote that the XML-Signature XPath Filter 2.0 Recommendation [XMLDSIG-XPATH-FILTER2] may be used for this purpose. That recommendation defines an XPath transform that permits the easy specification of subtree selection and omission that can be efficiently implemented.\n\nAn important scenario would be a document requiring two enveloped signatures. Each signature must omit itself from its own digest calculations, but it is also necessary to exclude the second signature element from the digest calculations of the first signature so that adding the second signature does not break the first signature.\n\nThe XPath transform establishes the following evaluation context for each node of the input node-set:\n\nA context node equal to a node of the input node-set.\n\nA context position, initialized to 1.\n\nA context size, initialized to 1.\n\nA library of functions equal to the function set defined in [XPATH] augmented with a function named here to be treated as if part of the library (and not namespace prefixed).\n\nA set of variable bindings. No means for initializing these is defined. Thus, the set of variable bindings used when evaluating the XPath expression is empty, and use of a variable reference in the XPath expression results in an error.\n\nThe set of namespace declarations in scope for the XPath expression.\n\nAs a result of the context node setting, the XPath expressions appearing in this transform will be quite similar to those used in used in [XSLT], except that the size and position are always 1 to reflect the fact that the transform is automatically visiting every node (in XSLT, one recursively calls the command apply-templates to visit the nodes of the input tree).\n\nThe function here() is defined as follows:\n\nFunction: node-set here()\n\nThe here function returns a node-set containing the attribute or processing instruction node or the parent element of the text node that directly bears the XPath expression. This expression results in an error if the containing XPath expression does not appear in the same XML document against which the XPath expression is being evaluated.\n\nAs an example, consider creating an enveloped signature (a Signature element that is a descendant of an element being signed). Although the signed content should not be changed after signing, the elements within the Signature element are changing (e.g. the digest value must be put inside the DigestValue and the SignatureValue must be subsequently calculated). One way to prevent these changes from invalidating the digest value in DigestValue is to add an XPath Transform that omits all Signature elements and their descendants. For example,\n\nExample 23\n\n<Document> ... <Signaturexmlns=\"http://www.w3.org/2000/09/xmldsig#\"><SignedInfo> ... <ReferenceURI=\"\"><Transforms><TransformAlgorithm=\"http://www.w3.org/TR/1999/REC-xpath-19991116\"><XPathxmlns:dsig=\"&dsig;\"> not(ancestor-or-self::dsig:Signature) </XPath></Transform></Transforms><DigestMethodAlgorithm=\"http://www.w3.org/2000/09/xmldsig#sha1\"/><DigestValue></DigestValue></Reference></SignedInfo><SignatureValue></SignatureValue></Signature> ... </Document>\n\nDue to the null Reference URI in this example, the XPath transform input node-set contains all nodes in the entire parse tree starting at the root node (except the comment nodes). For each node in this node-set, the node is included in the output node-set except if the node or one of its ancestors has a tag of Signature that is in the namespace given by the replacement text for the entity &dsig;.\n\nA more elegant solution uses the here function to omit only the Signature containing the XPath Transform, thus allowing enveloped signatures to sign other signatures. In the example above, use the XPath element:\n\nExample 24\n\n<XPathxmlns:dsig=\"&dsig;\"> count(ancestor-or-self::dsig:Signature | here()/ancestor::dsig:Signature[1]) > count(ancestor-or-self::dsig:Signature)</XPath>\n\nSince the XPath equality operator converts node sets to string values before comparison, we must instead use the XPath union operator (|). For each node of the document, the predicate expression is true if and only if the node-set containing the node and its Signature element ancestors does not include the enveloped Signature element containing the XPath expression (the union does not produce a larger set if the enveloped Signature element is in the node-set given by ancestor-or-self::Signature).\n\n6.6.4 Enveloped Signature Transform\n\nIdentifier:\n\nhttp://www.w3.org/2000/09/xmldsig#enveloped-signature\n\nInput:\n\nnode-set\n\nOutput:\n\nnode-set\n\nAn enveloped signature transform T removes the whole Signature element containing T from the digest calculation of the Reference element containing T. The entire string of characters used by an XML processor to match the Signature with the XML production element is removed. The output of the transform is equivalent to the output that would result from replacing T with an XPath transform containing the following XPath parameter element:\n\nExample 25\n\n<XPathxmlns:dsig=\"&dsig;\"> count(ancestor-or-self::dsig:Signature | here()/ancestor::dsig:Signature[1]) > count(ancestor-or-self::dsig:Signature)</XPath>\n\nThe input and output requirements of this transform are identical to those of the XPath transform, but may only be applied to a node-set from its parent XML document. Note that it is not necessary to use an XPath expression evaluator to create this transform. However, this transform MUST produce output in exactly the same manner as the XPath transform parameterized by the XPath expression above.\n\n6.6.5 XSLT Transform\n\nIdentifier:\n\nhttp://www.w3.org/TR/1999/REC-xslt-19991116\n\nInput:\n\noctet-stream\n\nOutput:\n\noctet-stream\n\nThe normative specification for XSL Transformations is [XSLT]. Specification of a namespace-qualified stylesheet element, which MUST be the sole child of the Transform element, indicates that the specified style sheet should be used. Whether this instantiates in-line processing of local XSLT declarations within the resource is determined by the XSLT processing model; the ordered application of multiple stylesheet may require multiple Transforms. No special provision is made for the identification of a remote stylesheet at a given URI because it can be communicated via an xsl:include or xsl:import within the stylesheet child of the Transform.\n\nThis transform requires an octet stream as input.\n\nThe output of this transform is an octet stream. The processing rules for the XSL style sheet [XSL10] or transform element are stated in the XSLT specification [XSLT].\n\nWe RECOMMEND that XSLT transform authors use an output method of xml for XML and HTML. As XSLT implementations do not produce consistent serializations of their output, we further RECOMMEND inserting a transform after the XSLT transform to canonicalize the output. These steps will help to ensure interoperability of the resulting signatures among applications that support the XSLT transform. Note that if the output is actually HTML, then the result of these steps is logically equivalent [XHTML10].\n\n7.3 Namespace Context and Portable Signatures\n\nIn [XPATH] and consequently the Canonical XML data model an element has namespace nodes that correspond to those declarations within the element and its ancestors:\n\n\"Note: An element E has namespace nodes that represent its namespace declarations as well as any namespace declarations made by its ancestors that have not been overridden in E's declarations, the default namespace if it is non-empty, and the declaration of the prefix xml.\" [XML-C14N]\n\nWhen serializing a Signature element or signed XML data that's the child of other elements using these data models, that Signature element and its children may have in-scope namespaces inherited from its ancestral context. In addition, the Canonical XML and Canonical XML with Comments algorithms define special treatment for attributes in the XML namespace, which can cause them to be part of the canonicalized XML even if they were outside of the document subset. Simple inheritable attributes (i.e. attributes that have a value that requires at most a simple redeclaration such as xml:lang and xml:space) are inherited from nearest ancestor in which they are declared to the apex node of canonicalized XML unless they are already declared at that node. This may frustrate the intent of the signer to create a signature in one context which remains valid in another. For example, given a signature which is a child of B and a grandchild of A:\n\nExample 26\n\n<Axmlns:n1=\"http://foo.example\"><Bxmlns:n2=\"http://bar.example\"><Signaturexmlns=\"http://www.w3.org/2000/09/xmldsig#\"> ... <ReferenceURI=\"#signme\"/> ... </Signature><CID=\"signme\"xmlns=\"http://baz.example\"/></B></A>\n\nwhen either the element B or the signed element C is moved into a [SOAP12-PART1] envelope for transport:\n\nExample 27\n\n<SOAP:Envelopexmlns:SOAP=\"http://schemas.xmlsoap.org/soap/envelope/\"> ... <SOAP:Body><Bxmlns:n2=\"http://bar.example\"><Signaturexmlns=\"http://www.w3.org/2000/09/xmldsig#\"> ... </Signature><CID=\"signme\"xmlns=\"http://baz.example\"/></B></SOAP:Body></SOAP:Envelope>\n\nThe canonical form of the signature in this context will contain new namespace declarations from the SOAP:Envelope context, invalidating the signature. Also, the canonical form will lack namespace declarations it may have originally had from element A's context, also invalidating the signature. To avoid these problems, the application may:\n\nRely upon the enveloping application to properly divorce its body (the signature payload) from the context (the envelope) before the signature is validated. Or,\n\nUse a canonicalization method that \"repels/excludes\" instead of \"attracts\" ancestor context. [XML-C14N] purposefully attracts such context.\n\n8.1 Transforms\n\nA requirement of this specification is to permit signatures to \"apply to a part or totality of a XML document.\" (See [XMLDSIG-REQUIREMENTS], section 3.1.3].) The Transforms mechanism meets this requirement by permitting one to sign data derived from processing the content of the identified resource. For instance, applications that wish to sign a form, but permit users to enter limited field data without invalidating a previous signature on the form might use [XPATH] to exclude those portions the user needs to change. Transforms may be arbitrarily specified and may include encoding transforms, canonicalization instructions or even XSLT transformations. Three cautions are raised with respect to this feature in the following sections.\n\nNote, core validation behavior does not confirm that the signed data was obtained by applying each step of the indicated transforms. (Though it does check that the digest of the resulting content matches that specified in the signature.) For example, some applications may be satisfied with verifying an XML signature over a cached copy of already transformed data. Other applications might require that content be freshly dereferenced and transformed.\n\n8.1.1 Only What is Signed is Secure\n\nFirst, obviously, signatures over a transformed document do not secure any information discarded by transforms: only what is signed is secure.\n\nNote that the use of Canonical XML [XML-C14N] ensures that all internal entities and XML namespaces are expanded within the content being signed. All entities are replaced with their definitions and the canonical form explicitly represents the namespace that an element would otherwise inherit. Applications that do not canonicalize XML content (especially the SignedInfo element) SHOULD NOT use internal entities and SHOULD represent the namespace explicitly within the content being signed since they can not rely upon canonicalization to do this for them. Also, users concerned with the integrity of the element type definitions associated with the XML instance being signed may wish to sign those definitions as well (i.e., the schema, DTD, or natural language description associated with the namespace/identifier).\n\nSecond, an envelope containing signed information is not secured by the signature. For instance, when an encrypted envelope contains a signature, the signature does not protect the authenticity or integrity of unsigned envelope headers nor its ciphertext form, it only secures the plaintext actually signed.\n\n8.1.2 Only What is \"Seen\" Should be Signed\n\nAdditionally, the signature secures any information introduced by the transform: only what is \"seen\" (that which is represented to the user via visual, auditory or other media) should be signed. If signing is intended to convey the judgment or consent of a user (an automated mechanism or person), then it is normally necessary to secure as exactly as practical the information that was presented to that user. Note that this can be accomplished by literally signing what was presented, such as the screen images shown a user. However, this may result in data which is difficult for subsequent software to manipulate. Instead, one can sign the data along with whatever filters, style sheets, client profile or other information that affects its presentation.\n\n8.1.3 \"See\" What is Signed\n\nJust as a user should only sign what he or she \"sees,\" persons and automated mechanism that trust the validity of a transformed document on the basis of a valid signature should operate over the data that was transformed (including canonicalization) and signed, not the original pre-transformed data. This recommendation applies to transforms specified within the signature as well as those included as part of the document itself. For instance, if an XML document includes an embedded style sheet [XSLT] it is the transformed document that should be represented to the user and signed. To meet this recommendation where a document references an external style sheet, the content of that external resource should also be signed as via a signature Reference otherwise the content of that external content might change which alters the resulting document without invalidating the signature.\n\nSome applications might operate over the original or intermediary data but should be extremely careful about potential weaknesses introduced between the original and transformed data. This is a trust decision about the character and meaning of the transforms that an application needs to make with caution. Consider a canonicalization algorithm that normalizes character case (lower to upper) or character composition ('e and accent' to 'accented-e'). An adversary could introduce changes that are normalized and consequently inconsequential to signature validity but material to a DOM processor. For instance, by changing the case of a character one might influence the result of an XPath selection. A serious risk is introduced if that change is normalized for signature validation but the processor operates over the original data and returns a different result than intended.\n\nAs a result:\n\nAll documents operated upon and generated by signature applications MUST be in [NFC] (otherwise intermediate processors might unintentionally break the signature)\n\nEncoding normalizations SHOULD NOT be done as part of a signature transform, or (to state it another way) if normalization does occur, the application SHOULD always \"see\" (operate over) the normalized form."
    }
}