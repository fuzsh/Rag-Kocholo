{
    "id": "dbpedia_4765_2",
    "rank": 9,
    "data": {
        "url": "https://www.computerscience.gcse.guru/theory/error-detection",
        "read_more_link": "",
        "language": "en",
        "title": "Computer Science GCSE GURU",
        "top_image": "https://www.computerscience.gcse.guru/wp-content/uploads/2017/02/Automatic-Repeat-Request-ARQ.png",
        "meta_img": "https://www.computerscience.gcse.guru/wp-content/uploads/2017/02/Automatic-Repeat-Request-ARQ.png",
        "images": [
            "https://www.computerscience.gcse.guru/wp-content/themes/computerscience/images/computer-science-gcse-guru.png",
            "https://www.computerscience.gcse.guru/wp-content/uploads/2017/02/Automatic-Repeat-Request-ARQ.png",
            "https://www.computerscience.gcse.guru/wp-content/uploads/2017/02/Automatic-Repeat-Request-ARQ.png",
            "https://www.computerscience.gcse.guru/wp-content/uploads/2019/04/programming-cheat-sheet-300x300.png",
            "https://www.computerscience.gcse.guru/wp-content/uploads/2019/04/programming-cheat-sheet-300x300.png",
            "https://www.computerscience.gcse.guru/wp-content/uploads/2019/04/GCSE_GURU_LOGO.png"
        ],
        "movies": [
            "https://www.youtube.com/embed/jLuj62Gq-1I?rel=0&showinfo=0"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2017-02-24T10:44:58+00:00",
        "summary": "",
        "meta_description": "There is always the chance that data has been corrupted (changed in some way) during transmission. This is true regardless of the distance of transmission. To avoid having corrupted data it is really important that computers check...",
        "meta_lang": "",
        "meta_favicon": "https://www.computerscience.gcse.guru/wp-content/themes/computerscience/images/apple-touch-icon.png",
        "meta_site_name": "Computer Science GCSE GURU",
        "canonical_link": "https://www.computerscience.gcse.guru/theory/error-detection",
        "text": "Error Detection\n\nThere is always the chance that data has been corrupted (changed in some way) during transmission.\n\nThis is true regardless of the distance of transmission.\n\nTo avoid having corrupted data it is really important that computers check for errors and correct them wherever possible.\n\nThere are several methods of error checking, with some being more effective than others.\n\nParity Check\n\nAn extra bit (parity bit) added to a string of binary code to ensure the number of 1-bits are either even or odd, depending upon the parity check system used.\n\nMethod\n\nThe sending and receiving computers agree the protocol to be used (even or odd)\n\nThe sending computer adds the correct parity bit to the binary data (either an extra 1 or 0)\n\nThe sending computer sends the binary data, including the parity bit\n\nThe receiving computer checks to make sure the overall parity of the data received is as agreed (an even or odd number of 1 bits)\n\nIf the parity of the data is incorrect, the receiving computer will request that the data is transmitted again\n\nDrawbacks of parity checks\n\nIf two bits are transposed (change places) then the computer could be fooled into thinking the data is correct and not corrupted\n\nIf two random bits change state then the system could also be fooled\n\nParity Block\n\nThis method of error checking is similar to a traditional parity check except the data is arranged in a virtual table with parity bits added to each row and column.\n\nA single corrupted bit can be spotted at the intersection of a corrupted row and column.\n\nMultiple corrupted bits would also flaw this system.\n\nChecksum\n\nA block of data is sent alongside a calculated checksum value.\n\nThe receiving computer also calculates what it believes should be the checksum.\n\nThe checksum values are then compared to see if an error has occurred during transmission.\n\nMethod\n\nThe sending computer uses the block of data to be sent, and a predefined mathematical algorithm, to calculate a checksum value\n\nThe sending computer sends the data, plus the checksum value\n\nThe receiving computer uses the data it receives to also calculate what it believes should be the checksum, using the same mathematical algorithm\n\nThe two checksum values are compared by the receiving computer\n\nDue to the nature of the algorithm, it is highly unlikely that corruption has occurred if the checksum values match\n\nIf the checksum values don’t match, the receiving computer requests that the data is transmitted again\n\nCheck Digit\n\nA check digit is the final digit in a code of numbers. It is calculated from all the other digits in the code. It’s purpose is to spot human errors on data entry.\n\nCheck digits are often found in barcodes, product codes or ISBN book numbers.\n\nThere are many different mathematical algorithms that can be used to calculate a check digit. Different industries will have their own preferred method.\n\nMethod\n\nThe check digit is calculated and added to the barcode, packaging, product code etc at the point of manufacture\n\nA human types the long numerical code into a computer, e.g. the cashier will type the barcode number when a scanner fails or packaging is damaged\n\nThe computer calculates what it believes should be the check digit, based on the numbers entered by the human\n\nThe computer then compares it’s calculated check digit with the check digit typed in by the human (the last digit in the long code)\n\nIf the two don’t match, then the human has made an error when typing in the numerical code, e.g. barcode number\n\nThe human will be asked by the computer to re-enter the numerical code\n\nBenefits\n\nGood for spotting human errors such as:\n\nIncorrect digit entered\n\nTransposition error (two numbers change order)\n\nOmitted digit or extra digit\n\nAutomatic Repeat ReQuests (ARQ)\n\nThis form of error detection uses a system of acknowledgements and timeouts. Automatic Repeat ReQuests are often used to ensure reliable transmissions over an unreliable service.\n\nAcknowledgements are messages sent from a receiving device back to the original sending device.\n\nThe acknowledgement can be negative or positive.\n\nA positive acknowledgement means that the data was received and it passed an error check.\n\nA negative acknowledgement means that the data was received but it cannot be used as it failed an error check. It needs to be sent again.\n\nThe timeout is a predetermined period of time that the sending device will wait to get some form of acknowledgement for the data it sent.\n\nIf no acknowledgement is received after the timeout, the device will sent the data again. This continues automatically until an acknowledgement is received, or the maximum number of re-sends occur.\n\nMethod\n\nThe sending computer transmits a block of data\n\nThe sending computer waits a period of time to see if the receiving computer acknowledges receipt of the data\n\nAfter no acknowledgement for a set period of time, a timeout occurs which triggers the data to be automatically resent by the sending computer\n\nThis will continue until the receiving computer acknowledges the data has been received, or a max number of re-sends occurs\n\nEcho Check\n\nWith an echo check, the receiving computer sends a copy of the data immediately back to the sending computer for comparison.\n\nThe sending computer compares the two sets of data to check if any errors occurred during the transmission process.\n\nIf an error has occurred, the data will be transmitted again.\n\nDrawback of echo checks\n\nIf the two sets of data are different you will have no way of knowing whether the error occurred when originally sent, or when it was sent back\n\nEcho checks require a lot of extra data to be transmitted"
    }
}