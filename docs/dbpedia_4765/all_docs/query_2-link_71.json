{
    "id": "dbpedia_4765_2",
    "rank": 71,
    "data": {
        "url": "https://www.asam.net/standards/detail/mcd-1-xcp/wiki/",
        "read_more_link": "",
        "language": "en",
        "title": "ASAM MCD",
        "top_image": "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Icons/android-icon-192x192.png",
        "meta_img": "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Icons/android-icon-192x192.png",
        "images": [
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/asam-logo.svg",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/asam-logo-no-claim.svg",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/login.svg",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/search-grey.svg",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/burger-menu.svg",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/share.svg",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/Public/Images/printer.svg",
            "https://www.asam.net/index.php?eID=dumpFile&t=f&f=13&token=5638dc3e0cdbd3285e51aba5d132977f39fae9aa",
            "https://www.asam.net/index.php?eID=dumpFile&t=f&f=12&token=f5f8c98389c8c3e8024f935c7178a20e9e5dcf1c",
            "https://www.asam.net/index.php?eID=dumpFile&t=f&f=14&token=794b940f1cb9b7355e89b3fcf21438647a08de0f",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=43959&token=2d1482fa5077de5e7c97c6e8e250e26c316966e0",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=43961&token=173bb3a1779cff6d872959e4576c21c5b4dda0a3",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=43963&token=85927e5cfee23cafaa2c31e536ebfa00a3b77951",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=43965&token=be75334406e9aeb9bdb45ec5f97196b5a4d14c53",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=43967&token=97322c9624ddc2d135fc343f90b49b3a4e987e92",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=43969&token=3d44d70b81e8de9dc9bf6b67b71a5def0162ce42",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/images/top.svg",
            "https://www.asam.net/index.php?eID=dumpFile&t=f&f=69&token=1e1fe91473f99c0d004313487e3f8ccd77baca3a",
            "https://www.asam.net/index.php?eID=dumpFile&t=f&f=2168&token=67aa795a96bf71128abbb5326710901498d0c138",
            "https://www.asam.net/index.php?eID=dumpFile&t=p&p=57308&token=2283c799cf08408bae4b2b005df9a39bc5c22611",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/images/rolling.gif",
            "https://www.asam.net/typo3conf/ext/asam_cms/Resources/images/rolling.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/typo3conf/ext/asam_cms/Resources/Public/Icons/apple-icon-57x57.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "History\n\nOrigin\n\nXCP is based on the ASAM Standard CAN Calibration Protocol ( CCP). The first version 1.01 of CCP was standardized in 1995. The latest and current version 2.01 of CCP was finished in 1999. Though still used in many existing ECU implementations, CCP has some disadvantages. One disadvantage is that timestamping for Measurement data is not available. Furthermore, some features were not specified very concisely, for example flash reprogramming.\n\nIn the early 2000s, Calibration interfaces were developed using microcontroller specific debug adapters ( JTAG) or SPI, which were commonly available for microcontrollers. These interfaces provided much higher data transmission rates than the highest CAN baud rate of 1 MBaud and were attached to a Calibration system (typically a PC) via Ethernet. Therefore, the need for an abstraction of CCP was recognized.\n\nASAM Standard\n\nThe initial version of XCP has been developed in 2003.It was designed for use in the automotive industry, primarily for the areas of ECU development, Calibration and testing. Since then, the protocol has widely spread and is supported by many tools on the market. Basically all leading tools in the Measurement & Calibration area support XCP.\n\nTwo reasons for the protocol’s success have been stability and backward-compatibility. Over the years, only extensions were added, which do not break the compatibility to earlier versions.\n\nThe version history of XCP currently consists of 4 releases:\n\nXCP 1.0 (2003):\n\nSpecification of the base standard features measurement & calibration, synchronous stimulation, page switching, reprogramming.\n\nSpecification of the transport layers for CAN, Ethernet (UDP and TCP/IP), SPI and USB.\n\nXCP 1.1 (2008):\n\nAddition of the transport layer for FlexRay.\n\nXCP 1.2 (2013):\n\nAdition of the A2L-IF_DATA description for calculation of the estimated ECU resource consumptions.\n\nXCP 1.3 (2015):\n\nAddition of the base standard features ECU States, Bypassing Error Handling and Time Correlation.\n\nXCP 1.4 (2017):\n\nNew DAQ mode: packed DAQ with reduced transmission of timestamp data, improvement of DAQ data consistency e.g. for multicore processors, slave enforced calibration page switching and resource state changes, additions due to ASAM MCD-1 POD.\n\nXCP 1.5 (2017):\n\nNew associated standard \"Software Debugging over XCP\" has been added to XCP, which allows to carry out typical debugging use cases without the need to connect a debug adapter to the ECU.\n\nMotivation\n\nECU Calibration is a mission critical task for the development of automotive ECUs. XCP avoids the need to create specific ECU implementations for specific Calibration tasks. Essentially, the protocol supports all typical Calibration tasks without the need to recompile to ECU application.\n\nXCP ensures interoperability between Calibration systems and ECUs. Two typical customer-supplier collaboration scenarios are supported:\n\nan OEM calibrates a vehicle consisting of multiple ECUs from different suppliers\n\na supplier provides its ECU to OEMs, and the OEMs use different calibration systems\n\nApplication Areas\n\nXCP can be used in all stages of ECU development, such as function development, ECU Calibration and testing of ECUs. As XCP is able to realize high data rates and short Measurement cycle times in the microsecond range, XCP is very helpful when analyzing the dynamic behavior of electromechanical systems relevant for automotive use cases such as engine or transmission systems or electric drives.\n\nBesides Measurement data acquisition and Calibration use cases, XCP is also used for reprogramming in early stages of ECU development where the required diagnostic services have not been implemented yet.\n\nTechnical Content\n\nIntroduction\n\nA key functionality of ASAM MCD-1 XCP is to enable read and write access to the memory of the ECU. Read access, commonly called \" Measurement\" in the Standard, lets users measure the time response of an internal ECU variable. ECUs are systems with discrete time behavior, whose variables only change at specific time intervals. One of the great strengths of XCP lies in acquiring measured values from RAM only at specific periodic points of time or at specific events. This time or event driven access, commonly called \"event-synchronous Measurement\", allows users to directly evaluate the ECU's behavior over time with recorded values from internal variables and external sensors.\n\nThe access is address-oriented meaning the communication between master (i.e. the Measurement & Calibration tool) and slave (i.e. the ECU) references addresses in memory. So, the Measurement of a variable is essentially implemented as a request of the master to the slave (i.e. “Give me the value of memory location 0x1234\").\n\nWrite access, commonly called \" Calibration\" in the Standard, lets the user optimize parameters of the ECU's algorithms. The Calibration of a parameter is essentially implemented as a request of the master to the slave (i.e. “Set the value at address 0x9876 to 5”).\n\nAn XCP slave does not necessarily need to be an ECU. The XCP protocol may be implemented in different environments. Two examples are either from a model-based development environment to hardware-in-the-loop or software-in-the-loop environments to hardware interfaces that are used to access ECU memory via debug interfaces, such as JTAG, NEXUS and DAP.\n\nThe properties and memory addresses of parameters are described in the A2L- File Format, which is standardized with ASAM MCD-2 MC. This means that access to a specific parameter does not need to be hardcoded into the ECU application. In other words, the ECU contains only a generic XCP slave protocol stack, which responds to memory access service requests from the Calibration system. Different Calibration and Measurement tasks can be performed by different configurations of the Calibration system without recompiling and reprogramming the ECU software.\n\nXCP was designed with these main objectives:\n\nMinimal resource usage in the ECU\n\nEfficient communication\n\nSimple Slave implementation\n\nPlug-and-play configuration with just a small number of parameters\n\nScalability: XCP is also very scalable in its implementation, it is not necessary to implement every command described by the standard\n\nTransferability: XCP can be implemented on major bus systems and is open for future bus systems\n\nCommunication Model\n\nXCP is based on the Master-Slave principle. The ECU is the slave and the Measurement & Calibration tool is the master. A slave may only communicate with one master at any given time. On the other hand, the master can simultaneously communicate with many slaves.\n\nXCP data is exchanged between the master and slave in a message-based way. The XCP packet is embedded in a frame of the transport layer (in the case of XCP on Ethernet with UDP in a UDP packet). The frame consists of three parts: the XCP header, the XCP packet and the XCP tail.\n\nIn the following figure, the XCP packet section inside the XCP message is shown in red. The XCP header and XCP tail depend on the transport protocol.\n\nThe XCP packet is independent of the used transport protocol. It always contains three components: “Identification Field”, “Timestamp Field” and the payload in the “Data Field”. Each Identification Field begins with the Packet Identifier (PID).\n\nThe type of communication via XCP packets is subdivided into one range for commands ( CTO) and one range for sending synchronous data ( DTO).\n\nThe acronyms used here are short for:\n\nCommand Command Packet Description RES Command Response Packet positive response ERR Error negative response EV Event Packet asynchronous event SERV Service Request Packet service request DAQ Data Acquisition send periodic measured values STIM Stimulation periodic stimulation of the slave\n\nCommands are exchanged via CTOs (Command Transfer Objects). For example, the master initiates contact in this direction. The slave must respond to a CMD with RES or ERR. The other CTO messages are sent asynchronously. The Data Transfer Objects ( DTO) are used to transfer synchronous Measurement and Stimulation data.\n\nStandard Commands\n\nThe XCP Standard commands establish and terminate communication, identify the ECU implementation (version check), unlock protected resources, obtain the current session state, and provide read access to the ECU memory. In order to speed up memory downloads, the Calibration system can cache the Calibration memory and optimize the memory downloads by sending only the differing memory parts of a parameter set. This requires that the cache and the ECU memory must be identical. To ensure this, XCP specifies commands for calculation of memory checksums.\n\nSome of the Standard commands are:\n\nSet up Connection With Slave\n\nDisconnect From Slave\n\nGet Current Session Status From Slave\n\nGet Communication Mode Info\n\nGet Identification From Slave\n\nRequest to Save to Non-volatile Memory\n\nGet Seed for Unlocking a Protected Resource\n\nSend Key for Unlocking a Protected Resource\n\nSet Memory Transfer Address in Slave\n\nUpload From Slave to Master\n\nBuild Checksum Over Memory Range\n\nData Acquisition (Measurement)\n\nRead-Service Based Data Acquisition (Polling)\n\nTo read the memory locations of interest, the simplest way to acquire Measurement data from the ECU is to send (typically) periodic requests from the XCP master to the slave. The drawback to these periodic requests is that at least two messages are generated for each signal (command and response), and the acquisition time is not synchronized with the cycle time of the ECU tasks that execute the control algorithms.\n\nSynchronous Data Acquisition (DAQ)\n\nTo overcome these disadvantages of the polling mode, XCP offers the synchronous data acquisition mode. In the control flow of an ECU algorithm, XCP DAQ events can be defined by inserting a function call to the XCP slave protocol stack, which triggers the sampling of Measurement data. In other words, to use this DAQ mode requires the ECU code to be instrumented.\n\nNote: The AUTOSAR Specification defines the XCP BSW module which implements the XCP protocol stack and the internal routines to trigger the sampling of Measurement data.\n\nWhen the algorithm in the slave reaches the location of such a sampling event, the XCP Slave collects the values of the Measurement parameters, saves these values in a buffer and sends them to the master. This setup requires that the slave knows which variables should be measured for which event. The slave obtains this information during the DAQ configuration phase, where the master sends specific commands which define the requested Measurement variables and their associated XCP events. After the completion of the configuration phase, the XCP master starts the Measurement data acquisition, and the XCP slave sends the Measurement data without further explicit read requests to the master.\n\nAn event does not have to be cyclic and time-equidistant. In the case of an engine controller, for example, the event might be angle-synchronous. This makes the time interval between two events dependent on the engine angular velocity. Singular events, such as arbitrary activations of a switch by the driver, are by no means equidistant in time.\n\nXCP provides the feature to “timestamp” the acquired Measurement data sample. It is assumed that an ECU has an internal clock which can be used to timestamp the Measurement data at the moment when it is transferred from the ECU memory to a transmission send buffer.\n\nThe commands used for DAQ configuration are:\n\nSet Pointer to ODT Entry\n\nWrite Element in ODT Entry\n\nSet Mode for DAQ List\n\nStart/Stop/Select DAQ List\n\nStart/Stop DAQ Lists (Synchronously)\n\nWrite Multiple Elements in ODT\n\nRead Element From ODT Entry\n\nGet General Information on DAQ Processor\n\nGet General Information on DAQ Processing Resolution\n\nGet Mode From DAQ List\n\nGet Specific Information for an Event Channel\n\nDTO CTR Properties\n\nClear DAQ List Configuration\n\nGet Specific Information for a DAQ List\n\nClear Dynamic DAQ Configuration\n\nAllocate DAQ Lists\n\nAllocate ODTs to a DAQ List\n\nAllocate ODT Entries to an ODT\n\nSTIM Data Transmission\n\nThe STIM feature is very similar to DAQ, but works in the opposite direction. Using STIM, the Calibration tool is able to overwrite values of variables of the control algorithm in a task synchronous way. This feature can be used to implement a bypass, where parts of the ECU's control algorithms are calculated outside the ECU by an external bypassing system, see the chapter about \"Bypassing\" below for further information.\n\nA STIM configuration is set up using exactly the same commands as a DAQ Measurement configuration.\n\nTime Correlation\n\nXCP offers services to read the current value of the XCP slave clock of the ECU. This enables the Calibration tool to correlate Measurement data from different ECUs when displaying them together in one graphical chart. The command to get the XCP slave clock is GET_DAQ_CLOCK_FROM_SLAVE.\n\nDue to limitations in the implementation of the XCP master and XCP slaves as well as limitations of the communication infrastructure, the achievable accuracy using the above mentioned legacy time correlation technique is limited. Today, there is a strong need for reliable synchronization accuracy in the single-digit microsecond range or even below that.\n\nAs a consequence, the protocol and transport layer specifications have been extended thoroughly with the advanced time correlation technique. As a central improvement, an XCP master is now able to obtain a detailed view of the clock system related to an XCP slave, i.e. the number of different clocks and their characteristics. Along with three basic techniques, advanced time correlation offers all the features needed to improve time synchronization significantly.\n\nThe first technique uses XCP native methods to improve time synchronization. The basic idea of this technique is to generate an XCP master initiated event (GET_DAQ_CLOCK_MULTICASTcommand) that simultaneously occurs at the XCP slaves connected to one transport layer. Each XCP slave has to sample its timestamps at the moment when this event occurs. The initiation of the event is thereby carried out periodically by an XCP master. This approach allows correlating the XCP slave’s timestamps among each other, eliminating the need of knowing the XCP master time as the global reference time. To obtain best accuracy, two requirements have to be satisfied:\n\nParticipating slaves have to sample their timestamps instantaneously with the occurrence of the event.\n\nThe latency between the XCP master and the participating XCP slaves should be the same to ensure a simultaneous occurrence of the XCP master initiated event at each XCP slave.\n\nThe generation of the XCP master initiated event that has to occur simultaneously at the XCP slaves requires broadcast-like mechanism. The method of generating such a broadcast message might be specific for each transport layer and is consequently part of a transport layer Specification.\n\nDue to the broadcast characteristic of the GET_DAQ_CLOCK_MULTICAST command and the fact that the command has to be understood as an XCP master initiated event, the processing of this command differs to classical commands. Instead of sending a positive response as the counterpart to the XCP master initiated command, an XCP slave supporting this feature reacts on aGET_DAQ_CLOCK_MULTICAST command by sending information relevant for time correlation as part of an EV_TIME_SYNC event packet to its XCP master. Therefore, the EV_TIME_SYNCevent packet has been significantly extended.\n\nTo ensure backward compatibility, the legacy formats for EV_TIME_SYNC events as well as the response to GET_DAQ_CLOCK command have to be used after connect. An XCP master supporting the advanced time correlation technique may enable the needed features in an XCP slave using the response format (RESPONSE_FMT) flag in SET_PROPERTIES of the TIME_CORRELATION_PROPERTIES command. Once the advanced time correlation features have been enabled, the XCP slave shall use the extended response formats for these messages.\n\nThe use of the second technique presumes the availability of an XCP unrelated time synchronization technique, e.g. the Precision Time Protocol (PTP) as defined in the IEEE 1588 Standard ( IEEE Standard for a precision clock synchronization protocol for networked Measurement and control systems, Feb. 2009). In this use case it is assumed that the XCP slave’s clock is either synchronized[1] or syntonized[2] to a grandmaster clock. In such a use case, the XCP master first needs to know that the timestamps sent by an XCP slave are synchronized to a grandmaster clock at all. Second, it is necessary to also obtain the information, to which grandmaster clock the XCP slave is synchronized/syntonized to. This information is required to handle systems with more than one grandmaster clock. With introduction of the advanced time correlation technique, XCP nodes are aware of time synchronization carried out through well-established, XCP unrelated standards.\n\nTherefore, each clock known to the XCP slave features a unique identifier. When a clock is synchronized/syntonized to a grandmaster clock, the slave’s clocks’ attributes have to be updated to reflect this state change. Based on the information of the XCP slave’s synchronization state and the information to which grandmaster clock the clock is synchronized to – by evaluating the unique clock identifiers – the XCP master is able to determine hierarchies of synchronized clocks.\n\nThe third technique addresses the requirements of resource limited XCP slaves that do not offer the possibility to synchronize clocks. In such a use case, the XCP slave can offer timestamp tuples to the XCP master, i.e. its local timestamp and the timestamp of the globally synchronized clock that was valid when the local timestamp was read. Based on this technique, the XCP master is aware of the relation between clocks of the XCP slave, and finally is able to perform precise clock correlation within the XCP master.\n\n[1] Two clocks are synchronized to a specified uncertainty if they have the same epoch and their measurements of the time of a single event at an arbitrary time differ by no more than that uncertainty.\n\n[2] Two clocks are syntonized if the duration of the second is the same on both. They may or may not share the same timestamp unit/timestamp size Tuple. They may or may not share the same epoch.\n\nCalibration (CAL)\n\nECU parameters are constant parameters that are adjusted and optimized during the development of the ECU or an ECU Variant. This is an iterative process, in which the optimal value of a parameter is found by repeated measurements and changes. To make parameters modifiable at runtime during ECU’s development, additional RAM memory is needed.\n\nThe most frequently used approach to modifying parameters at runtime (“online calibration”) is to create the parameters in the available RAM memory.\n\nC code example:\n\n#pragma section “RAM_Parameter” const volatile float factor = 0.5;\n\nThis code defines the parameter “factor” as a RAM variable with the initial value 0.5. During compiling and linking of the code, memory space is reserved for the object “factor” in RAM and the associated RAM address appears in the linker- Map file. The initial value 0.5 is stored in flash memory and at the relevant location in the hex file. The addresses of the initial values in flash memory are defined by parameterization of the linker, but they do not appear in the linker- Map file.\n\nDuring booting of the ECU, all RAM variables are initialized once with their initial values from flash memory. The initialization is usually executed in the start-up code of the compiler manufacturer and the application programmer does not need to be concerned with it. The application uses the values of parameters located in RAM and they can be modified via normal XCP memory accesses.\n\nFrom the perspective of the ECU software, Calibration parameters in RAM are unchangeable, i.e. the application itself does not change them. Many compilers discover this fact by code analysis and simply optimize the necessary RAM memory space away. Normally, it is therefore also necessary to prevent the compiler from optimizing by using the “volatile” attribute.\n\nFrom the perspective of the Calibration tool, the RAM area in which the parameters are located is referred to as Calibration RAM (memory that can be calibrated).\n\nThe basic commands to access ECU memory are:\n\nDownload From Master to Slave\n\nDownload From Master to Slave (Block Mode)\n\nDownload From Master to Slave (Fixed Size)\n\nDownload From Master to Slave (Short Version)\n\nModify Bits\n\nECU Memory Layout\n\nThe logical memory layout of the ECU ( XCP slave) is described by objects called memory segments. Memory segments have attributes which describe the content and access type to the parameters, for example DATA+ RAM or CODE+FLASH. A segment is described using the ASAM MCD-2 MC keyword MEMORY_SEGMENT, which contains information like name, address, size and offsets for mirrored segments. The XCP specific information is inside an IF_DATA section, such as page definitions.\n\nParameters which are adjustable by the Calibration system have to be located in data memory segments that are physically located in RAM. Addresses of parameters and memory segments are logical addresses which may be mapped to physical memory addresses by means of memory management units ( MMU). These MMUs offer the possibility to adjust parameters located in a flash memory segment by remapping (using an address translation) to a physical RAM area. It is not necessary to change the ECU control algorithm implementation because it uses logical addresses to access parameters.\n\nPage Switching (PAG)\n\nXCP introduces the concept of pages which make the implemented address translations accessible for the XCP Page Switching service commands. If these services are implemented, the Calibration tool is able to control the active page. If it switches a memory segment from a Flash page to a RAM page, a parameter located in this memory segment can be adjusted during the execution of the control algorithm, also known as online Calibration.\n\nThe access for the Calibration tool and the ECU algorithm can be changed independently.\n\nThis access enables modifications of large parameters (e.g. maps) without jeopardizing the data consistency during write operations to the ECU memory. This consistency is realized by first switching the Calibration tool access to the RAM page, then writing the data to the ECU and after that switching the ECU access to the RAM page. This solution requires of course, that the switching action is implemented as an atomic operation.\n\nNote: This concept depends on the ECU controller features and the XCP slave implementation and may not be supported by all ECUs.\n\nThe page switching commands are:\n\nSet Calibration Page\n\nGet Calibration Page\n\nGet General Information on PAG Processor\n\nGet Specific Information for a SEGMENT\n\nGet Specific Information for a PAGE\n\nSet Mode for a SEGMENT\n\nGet Mode for a SEGMENT\n\nCopy Page\n\nBypassing\n\nBypassing can be implemented by simultaneously making use of Synchronous Data Acquisition and Synchronous Data Stimulation (STIM). For Bypassing, at least two DAQ lists are required for transferring data between the ECU and the bypassing tool, i.e. one DAQ list for reading variables (Data Acquisition) and one DAQ list for writing variables (STIM). Furthermore, specific event channels are required, which control the bypassing process.\n\nThe figure shows an example of a simple bypass that uses a DAQ event channel and a STIM event channel. In the ECU, the inputs of the bypass function are sampled and sent to the bypassing tool as DAQ data before the original function is executed. Typically, the inputs of the bypass function are identical to the inputs of the original function. Once the bypassing tool receives the DAQ data triggers, it starts the execution of the bypass function. The output of the bypassing function is then sent back to the ECU as STIM data. Meanwhile, the ECU finished the execution of the original function. The STIM data is fed back to the ECU, typically by overwriting the outputs of the original function. This bypassing process runs in Real-Time. Consequently, the bypassing tool including the DAQ and STIM communication must execute in at least the same time than the ECU executes the original function.\n\nThe adaption of the ECU code to support a bypass is called a bypass hook. For safety reasons, a bypass hook may need to be activated before it is functional. The mechanism to enable a bypass hook is implementation-specific and not part of the XCP Standard. If required, bypass hooks can be activated using means of XCP, e.g. by writing to a specific Calibration parameter.\n\nFlash Programming (PGM)\n\nFlashing means writing data into an area of flash memory. Writing data into Flash requires precise knowledge of the ECU memory layout. Flash memory is subdivided into multiple sectors (physical sections) which are described by a start address and length. To distinguish them from one another, each of the sectors get a consecutive identification number. The information about the flash sectors is also part of the A2L file.\n\nFlashing can be implemented by a method that is called “flash kernels”. A flash kernel is executable code that is sent to the Slave’s RAM area and is then executed to carry out the actual flash process. The kernel handles the communication with the XCP Master and access to the Flash memory. It might contain the algorithm that is responsible for erasing the flash memory. For security and space reasons, this code is typically not stored permanently in the ECU’s flash memory.\n\nThe flash process with XCP is roughly subdivided into three areas:\n\nPreparation (e.g. for checking versions to avoid that unsuitable content is written to memory)\n\nExecution (the new content is sent to the ECU and written to memory)\n\nPost-processing (e.g. checksum checking, etc.)\n\nAnyone who compares the flashing operation of XCP with flashing over diagnostic protocols will realize that the process-specific elements, such as serial number handling with Metadata, have rather limited functionality. The Standard is mainly used during development and does not cover the more complex process steps that are necessary in End-of-Line flashing. Therefore, when using XCP for flashing the memory of an ECU, it is important to determine whether the content that is to be written to memory is relevant to the ECU. There are no special commands for version checking or other safety features in XCP that would avoid writing invalid content to the ECU.\n\nThe programming commands are:\n\nIndicate the Beginning of a Programming Sequence\n\nClear a Part of Non-volatile Memory\n\nProgram a Non-volatile Memory Segment\n\nIndicate the End of a Programming Sequence\n\nGet General Information on PGM Processor\n\nGet Specific Information for a SECTOR\n\nPrepare Non-volatile Memory Programming\n\nSet Data Format Before Programming\n\nProgram a Non-volatile Memory Segment (Block Mode)\n\nProgram a Non-volatile Memory Segment (fixed size)\n\nProgram Verify\n\nECU States\n\nThe idea of the ECU States concept in XCP is to make the XCP slave status more visible for the XCP master during the XCP session. Using this concept the slave is able to inform the XCP master about changes of the ECU state in the XCP slave. It is possible that certain resources can have an active or inactive state. An ECU state describes the status of all resources. In consequence the status of the slave can change more dynamically and would be still visible for the XCP master.\n\nThis concept is very important for the use case that the ECU and XCP slave are different instances and the XCP slave can run without an active ECU. In this use case a specific connection between protocol handler and ECU exists.\n\nThis concept is based on the already existing resource definition of the XCP Specification with four different resource categories CAL/PAG, DAQ, STIM and PGM which are represented in the resource information and is available via the CONNECT response. The RESOURCE parameter bit field defines which resources are available in general, and the ECU state defines which resources are currently active.\n\nXCP offers two mechanisms to provide the current ECU state to the XCP master:\n\nMandatory: The XCP slave reports the current state to the XCP master in the response to the GET_STATUS command.\n\nOptional: If the XCP slave supports asynchronous event messages, it can use the event EV_ECU_STATE_CHANGE to inform the XCP master about a state change and the new STATE_NUMBER. The XCP slave sends the event message to the XCP master once. With the next GET_STATUS request the XCP master receives the STATE_NUMBER again.\n\nWith both mechanisms the XCP master receives the current STATE_NUMBER. The meaning of the specific state is defined in XCP IF_DATA section of the A2L file.\n\nFor the resource DAQ, STIM and PGM it is possible to define that these resources are active or not active. The CAL/PAG resource can be described with a higher granularity within MEMORY_ACCESS sections. The reason for this is that it could happen that the memory, which is the base for the Calibration, is not completely located in the ECU or in the XCP slave. It could happen that only some parts of the memory are accessible for certain states. Therefore it is possible to define which segment / page of the memory is read- and/or writeable in a specific state.\n\nThe MEMORY_ACCESS definition is not needed if the resource CAL/PAG is not available for a specific state. The page access definition of a memory segment is the base for this concept. AnECU_STATE keeps or restricts this access for the given page. The restrictions concerning switching XCP and/or ECU pages are defined by the MEMORY_SEGMENT section of the A2L file.\n\nECU Description\n\nUsing the ASAM Standard MCD2- MC (also known as ASAP2), the XCP slave interface of an ECU can be modeled by the IF_DATA sections. XCP specifies the XCP IF_DATA section using the ASAP2 Meta Language ( AML). The XCP IF_DATA contains sections which describe:\n\nCommunication parameters (for example communication timeouts, CAN-IDs for communications, etc.)\n\nImplemented service commands\n\nXCP slave resources for the features DAQ, STIM, CAL, PAG and PGM\n\nThe XCP IF_DATA is structured into:\n\nCommon parameters, describing the protocol layer and the available features\n\nThe transport layers.\n\nThe Calibration tool uses this information to establish communication, visualize the implemented XCP features and informs the Calibration engineer about ECU resource limitations.\n\nA typical task is the configuration of data acquisition. Using the IF_DATA information, the Calibration tool shows the available XCP Measurement events. The user configures the sampling rate for a signal by assigning an XCP Measurement event. Furthermore the Calibration tool is able to display the DAQ resource consumption, i.e. how many DAQ space is currently used, and how many signals may be additionally configured.\n\nRelation to Other Standards\n\nASAM XCP is closely related to ASAM MCD-2- MC (also known as ASAP2), which is a description format for internal ECU variables. The ECU specific protocol parameters are described by the ASAP2 Meta Language within so called interface descriptions.\n\nXCP on FlexRay requires the information of the FlexRay network cluster the ECU is part of. The “XCP on FlexRay” IF_DATA section references the FIBEX file (ASAM MCD-2 NET) and the network cluster to get knowledge of the FlexRay communication parameters.\n\nXCP is closely related to the XCP BSW module Specification of AUTOSAR 4.0, which actually implements the protocol stack and defines an RTE interface for sampling XCP Measurement data.\n\nIndustry Adoption\n\nAll major Calibration tool supplier support XCP, typically for all bus systems supported by the Standard. The tools are used for Measurement, rapid prototyping and Calibration throughout all development phases of an ECU. Another common usage scenario for XCP is data logging for fleet testing or other post-production investigation activities, where data loggers need read-only access to data on ECUs. .\n\nMoreover, some tool vendors use the opportunity of XCP for \"Plug & Play\" of Measurement tools via reading out the XCP configuration (ASAP2) via XCP.\n\nAs mentioned above, XCP is integrated into the AUTOSAR basic software architecture. Basic software module vendors offer AUTOSAR-compliant XCP implementations.\n\nBesides the use in automotive development, XCP is also used in other areas such as development of rail systems, combustion chain saws and other applications that make use of embedded controllers.\n\nList of Deliverables\n\nThe Standard includes the following deliverables:\n\nBase Standard\n\nStandard document for the base standard\n\nStandard documents for the associated standards\n\nXCP on CAN and CAN FD\n\nXCP on FlexRay\n\nXCP on Ethernet (UDP and TCP/IP)\n\nXCP on SxI (serial communication links)\n\nXCP on USB\n\nASAP2 Meta language declarations for the ECU specific protocol parameters\n\nA sample source code package for the implementation of a Seed&Key DLL"
    }
}