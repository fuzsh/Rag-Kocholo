{
    "id": "dbpedia_4765_1",
    "rank": 82,
    "data": {
        "url": "http://www.sunshine2k.de/articles/coding/crc/understanding_crc.html",
        "read_more_link": "",
        "language": "en",
        "title": "Sunshine's Homepage",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Programming",
            "Coding",
            "Algorithms",
            "CRC",
            "Cyclic Redundancy Check",
            "Tutorial",
            "C#",
            "Dotnet",
            "Silverlight",
            "Bastian Molkenthin"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Sunshine2k's private homepage about programming - CRC",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Table of Contents\n\nView Online CRC Silverlight application now!\n\nView Online CRC Javascript application now!\n\nDownload C# source code (37 kb)\n\nArticle updated March 2024 (for details, click here to see the changelog).\n\n[Back to top]\n\n1. Foreword & Outline\n\nThis article is the result of the fact that I found finally time to deal with CRC. After reading Wikipedia and some other articles, I had the feeling to not really understand completely in depth.\n\nTherefore I decided to write this article, trying to cover all topics I had difficulties with. And this in exactly the same order I concerned myself with CRC. Please note that this article is not indented to be a full comprehensive CRC guide explaining all details - it should be used as an additional, practical oriented note to all general explanations on the web.\n\nHere's the outline:\n\nAt first, the general idea and functionality of CRC is discussed.\n\nSubsequently, some examples are calculated by hand to get familiar with the process of CRC calculation.\n\nBased on those observations, implementations of CRC calculation are presented step by step, from naive ones till more efficient algorithms. Here the emphasis lies on the target to really get the point of the code compared to the manual calculation. Here an exemplary CRC-8 polynomial is used.\n\nAfterwards, the achieved knowledge is expanded to CRC-16 and CRC-32 calculation, followed by some CRC theory and maybe a FAQ section.\n\n[Back to top]\n\n2. Introduction\n\nCRC (Cyclic Redundancy Check) is a checksum algorithm to detect inconsistency of data, e.g. bit errors during data transmission. A checksum, calculated by CRC, is attached to the data to help the receiver to detect such errors. Refer also to [1] for a short or to [4] for a very detailed CRC introduction.\n\nCRC is based on division. The actual input data is interpreted as one long binary bit stream (dividend) which is divided by another fixed binary number (divisor). The remainder of this division is the checksum value.\n\nHowever, reality is a bit more complicated. The binary numbers (dividend and divisor) are not treated as normal integer values, but as binary polyonimals where the actual bits are used as coefficients.\n\nDivision of polynomials differs from integer division. Without going into detail, the underlying used aritmetic for CRC calculation is based on the XOR (Exclusive-OR) operation (we'll come to an example soon!).\n\n- The dividend is the complete input data (interpreted as binary stream).\n\n- The divisor, also called generator polynomial, is statically defined by the used CRC algorithm. CRC-n using a fixed defined generator polynom with (n+1) bits.\n\n- The CRC checksum value is defined as dividend % divisor.\n\nFor manual calculation, n zero bits are appended to the input data before actual CRC calculation (polynomial division) is computed. Let's perform an example CRC computation:\n\nUseful observations:\n\nIn each step, the leading '1' of the divisor is always aligned with the first '1' of the dividend. This implies that the divisor does not move only 1 bit right per step, but sometimes also several steps (e.g. like in line (*).\n\nThe algorithms stops if the divisor zeroed out each bit of the actual input data (without padding bytes): The input data ranges from column A to H including. In the last step, column H and all prior columns contain 0, so the algorithm stops.\n\nThe remainder (= CRC) is the value 'below' the padding zero bits (column I to P). Because we added n padding bytes, the actual CRC value has also n bits.\n\nOnly the remainder in each step is of interest, the actual division result (quotient) is therefore not tracked at all.\n\n[Back to top]\n\n2.1 CRC Verification\n\nThe remainder is the CRC value which is transmitted along with the input data to the receiver. The receiver can either verify the received data by computing the CRC and compare the calculated CRC value with the received one. Or, more commonly used, the CRC value is directly appened to the actual data. Then the receiver computes the CRC over the whole data (input with CRC value appended): If the CRC value is 0, then most likely no bit error occured during transmission. Let's do verification according the latter case:\n\nExample verification:\n\nThe actual transmission data (input data + CRC) would be b1100001000001111 Note that we have used an 8bit CRC, so the actual CRC value is also 8bit long. The generator polynomial is statically defined by the used CRC algorithm and so it's known by the receiver.\n\nABCDEFGHIJKLMNOP 1100001000001111 100011101....... ---------....... 010011001....... 100011101..... ---------...... 000101111...... 100011101.. ---------... 001100100... 100011101 ---------. 010001110. 100011101 --------- 000000000 -> Remainder is 0, data ok! ABCDEFGHIJKLMNOP\n\n[Back to top]\n\n3. Concept of the CRC shift register\n\nSo we have seen how to calculate the CRC checksum value manually, but how can it be implemented?\n\nThe input data stream is generally quite long (more than 1 bit) so it's not possible to perform a simple division like \"Input data % generator polynomial\". The computation has to be performed step-by-step and here the concept of a shift register comes into play.\n\nA shift register has a fixed width and can shift it's content by one bit, removing the bit at the right or left border and shift in a new bit at the freed position. CRC uses a left shift register: When shifted, the most significant bit pops out the register, the bit at position MSB-1 moves one position left to postion MSB, the bit at position MSB-2 to MSB-1 and so on. The bit position of the least significant bit is free: here the next bit of the input stream is shifted in.\n\nMSB LSB --- --- --- -- -- --- <-- | | | |.... | | <-- (shift in input message bits) --- --- --- -- -- ---\n\nThe process of CRC calculation using a shift register is as follow:\n\nInitialize the register with 0. (Note that initial values != 0 are handled especially, consider chapter 8.6).\n\nShift in the input stream bit by bit. If the popped out MSB is a '1', XOR the register value with the generator polynomial.\n\nIf all input bits are handled, the CRC shift register contains the CRC value.\n\nLet's visualize the procedure with the example data from above\n\n[Back to top]\n\n4. Implementing CRC-8 algorithms\n\nThis chapter handles different algorithms and their implementations in C# for calculating CRC-8 checksum values. It starts with simple algorithms for limited input data and ends with efficient table-based implementations.\n\n[Back to top]\n\n4.1 Simple CRC-8 shift register implementation for one byte input data\n\nLet's start with an implementation of a CRC-8 algorithm for solely one byte input data. The implementation will stay very closely to the shift register process from the example above.\n\nA CRC-8 algorithm uses actually a 9bit generator polynomial, but it would be cumbersome to track such an unaligned value in an algorithm. Fortunately, as described in the previous chapter, the most significant bit can be discarded. First, it is always 1. Second, because the divisor is always aligned in such a manner that this leading '1' alignes with the next '1' of the dividend, the XOR result for this bit is always 0.\n\nThis means we leave out the MSB '1', so we can use the generator polynomial b100011101 = 0x1D as the example polynomial from now on.\n\nLet's start with an implementation which is as close as possible to the shift register approach:\n\npublic static byte Compute_CRC8_Simple_OneByte_ShiftReg(byte byteVal)\n\n{\n\nconst byte generator = 0x1D;\n\nbyte crc = 0;\n\nbyte[] inputstream = new byte[] { byteVal, 0x00 };\n\nforeach (byte b in inputstream)\n\n{\n\nfor (int i = 7; i >= 0; i--)\n\n{\n\nif ((crc & 0x80) != 0)\n\n{\n\ncrc = (byte)(crc << 1);\n\ncrc = ((byte)(b & (1 << i)) != 0) ? (byte)(crc | 0x01) : (byte)(crc & 0xFE);\n\ncrc = (byte)(crc ^ generator);\n\n}\n\nelse\n\n{\n\ncrc = (byte)(crc << 1);\n\ncrc = ((byte)(b & (1 << i)) != 0) ? (byte)(crc | 0x01) : (byte)(crc & 0xFE);\n\n}\n\n}\n\n}\n\nreturn crc;\n\n}\n\n[Back to top]\n\n4.2 Modified CRC-8 bitwise implementation for one byte input data\n\nWell, above implementation looks complicated! How can it be simplified?\n\nThe first 8 left-shifts are useless because the CRC value is initialized with 0 so no XOR operation is performed. This means we can initialize the CRC value directly with the input byte.\n\nSo only '0' are left in the input stream (the appended zeros). They do not have to be explicitly shifted-in, as the C# leftshift operator << fills in the LSB with '0' by default.\n\nThis implies that the inputstream array is not required anymore.\n\nApplying these simplifications result in following implementation (much better, isn't it?):\n\npublic static byte Compute_CRC8_Simple_OneByte(byte byteVal)\n\n{\n\nconst byte generator = 0x1D;\n\nbyte crc = byteVal;\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & 0x80) != 0)\n\n{\n\ncrc = (byte)((crc << 1) ^ generator);\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\nreturn crc;\n\n}\n\nTo illustrate how the algorithmus is working, the example from above (input byte 0xC2, generator polynomial 0x1D) is repeated - this time showing the intermediate values of each step of implementation Compute_CRC8_Simple_OneByte.\n\nThe fact that the crc value is left-shifted by one _before_ it's 'xored' with the divisor should become clear: it's due to the already discussed reason that the MSB bit of the generator polynomial is not stored / not used by the algorithm as well as it's result.\n\n[Back to top]\n\n4.3 General CRC-8 bitwise implementation\n\nTill now only one byte was used as input data, so let's see what happens if the input data is extended to a byte array.\n\nThe first function Compute_CRC8_Simple_OneByte_ShiftReg() could easily be adapted (only the input parameter would be a byte array at which a 0x00 byte is appended), but what about Compute_CRC8_Simple_OneByte()?\n\nThe interesting point is at the border between two bytes: If one byte is completely processed, how is the subsequent byte incorporated into the calculation process? Again, let's start with a simple example (even more manual CRC-calculation action!):\n\nExample for two byte input data {0x01, 0x02} with polynomial 0x1D\n\n000000010000001000000000 100011101 --------- 0000111110000 100011101 --------- 0111011010 100011101 --------- 0110001110 100011101 --------- 0100100110 100011101 --------- 0001110110 = 0x76\n\nActually the algorithm handles one byte at a time, and does not consider the next byte until the current one is completely processed.\n\nRefering to Compute_CRC8_Simple_OneByte, the value crc is set to 0x01 and the input looks like 0000000100000000... So let's see the state when the first byte is completely processed: 000000010000000000000000 100011101 --------- 000011101 Compare this to our manual approach where we have the second byte 0x02 already 'in range': 000000010000001000000000 100011101 --------- 000011111 So obviously the next byte has to be XORed with the current CRC value: 000011101 ^ 00000010 = 000011111 and the algorithm then continues with the 'new' xored value.\n\nWith this knowledge we can easily extend our algorithm to work with an input byte array of arbitrary length:\n\npublic static byte Compute_CRC8_Simple(byte[] bytes)\n\n{\n\nconst byte generator = 0x1D;\n\nbyte crc = 0;\n\nforeach (byte currByte in bytes)\n\n{\n\ncrc ^= currByte;\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & 0x80) != 0)\n\n{\n\ncrc = (byte)((crc << 1) ^ generator);\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\n}\n\nreturn crc;\n\n}\n\n[Back to top]\n\n4.4 Improved CRC-8 byte-by-byte algorithm (lookup table based)\n\nSo far the algorithm is quite inefficient as it works bit by bit. For larger input data, this could be quite slow. But how can our CRC-8 algorithm be accelerated?\n\nThe dividend is the current crc byte value - and a byte can only take 256 different values. The polynomial (= divisor) is fixed. Why not precompute the division for each possible byte by the fixed polynomial and store these result in a lookup table? This is possible as the remainder is always the same for the same dividend and divisor! Then the input stream can be processed byte by byte instead of bit by bit.\n\nLet's use our common example to demonstrate the process manually:\n\nFor step 3 and 5, the lookup table is used instead of bit by bit processing - that makes the actual speedup.\n\nHere an implementation for calculating the 256-element lookup table:\n\npublic static void CalculateTable_CRC8()\n\n{\n\nconst byte generator = 0x1D;\n\ncrctable = new byte[256];\n\nfor (int dividend = 0; dividend < 256; dividend++)\n\n{\n\nbyte currByte = (byte)dividend;\n\nfor (byte bit = 0; bit < 8; bit++)\n\n{\n\nif ((currByte & 0x80) != 0)\n\n{\n\ncurrByte <<= 1;\n\ncurrByte ^= generator;\n\n}\n\nelse\n\n{\n\ncurrByte <<= 1;\n\n}\n\n}\n\ncrctable[dividend] = currByte;\n\n}\n\n}\n\nThen improved CRC-8 algorithm using the lookup table is as follow:\n\npublic static byte Compute_CRC8(byte[] bytes)\n\n{\n\nbyte crc = 0;\n\nforeach (byte b in bytes)\n\n{\n\nbyte data = (byte)(b ^ crc);\n\ncrc = (byte)(crctable[data]);\n\n}\n\nreturn crc;\n\n}\n\nThe improvement of speed comes at the cost of processing time to precalculate the table and of higher memory consumption of the 256-byte elements, but that's worth it :-)!\n\nPlease note that this is not yet the \"full\" CRC-8 algorithm implementation because it does not consider initial XOR values, final XOR values and reflection. This will be covered in chapter 7.\n\n[Back to top]\n\n5. Extending to CRC-16\n\nThe more bits the CRC value has the less is the probability of a collision: for CRC-8 there are only 256 different CRC values. This means if the data is disturbed or modified between sender and receiver, there is a probability of 1/256 that the modified data stream has the same CRC value as the original data stream, thus the error is not detected. Beside other factors (more on this in the theory part), increasing the CRC width results in better error protection.\n\nThis raises the question: What is the impact on the implementation if we want to extend it from CRC-8 to CRC-16?\n\n1. Obviously a CRC-16 uses a polynomial of degree 16 with 17 terms, but similar to CRC-8 the most significant bit is implicitly 1. Therefore the generator polynomial as well as the CRC value have now a 16bit data type.\n\n2. How to 'Xor-In' the next input byte (8bit) into the CRC value (16bit)? The answer is into the most significant byte of the CRC. Similar to chapter 4.3, let's visualize it with an example:\n\nFirst, let's make another manual calculation, this time for CRC-16 with polynomial 0x1021:\n\nWhat happens if the algorithm has handled the first input byte 0x01: 00000001000000000000000000000000 10001000000100001 ----------------- 00001000000100001 Here we see that the next input byte 0x02 = 00000010 has be xored into the MSB of 00001000000100001 to get 00001001000100001 to proceed.\n\n3. The check if the most significant bit set changes because bit15 instead of bit7 has to be tested: 0x80 -> 0x8000\n\nTherefore the CRC-16 simple implementation looks like:\n\npublic static ushort Compute_CRC16_Simple(byte[] bytes)\n\n{\n\nconst ushort generator = 0x1021;\n\nushort crc = 0;\n\nforeach (byte b in bytes)\n\n{\n\ncrc ^= (ushort(b << 8);\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & 0x8000) != 0)\n\n{\n\ncrc = (ushort((crc << 1) ^ generator);\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\n}\n\nreturn crc;\n\n}\n\nThe modification of the implementations for calculating the CRC-16 lookup table is now quite easy:\n\npublic static void CalculateTable_CRC16()\n\n{\n\nconst ushort generator = 0x1021;\n\ncrctable16 = new ushort[256];\n\nfor (int dividend = 0; dividend < 256; dividend++)\n\n{\n\nushort curByte = (ushort(dividend << 8);\n\nfor (byte bit = 0; bit < 8; bit++)\n\n{\n\nif ((curByte & 0x8000) != 0)\n\n{\n\ncurByte <<= 1;\n\ncurByte ^= generator;\n\n}\n\nelse\n\n{\n\ncurByte <<= 1;\n\n}\n\n}\n\ncrctable16[dividend] = curByte;\n\n}\n\n}\n\nThe actual byte by byte is a bit tricky so let's first check our example again:\n\nThe important point is here that after xoring the current byte into the MSB of the intermediate CRC, the MSB is the index into the lookup table.\n\nHere the corresponding implementation for the table-based CRC-16 algorithm:\n\npublic static ushort Compute_CRC16(byte[] bytes)\n\n{\n\nushort crc = 0;\n\nforeach (byte b in bytes)\n\n{\n\nbyte pos = (byte)( (crc >> 8) ^ b);\n\ncrc = (ushort)((crc << 8) ^ (ushort)(crctable16[pos]));\n\n}\n\nreturn crc;\n\n}\n\n[Back to top]\n\n6. Extending to CRC-32\n\nAfter having understood the extension process from CRC-8 to CRC-16 in the previous chapter, the modifications to CRC-32 is pretty easy. I discard the detailed steps as they are very similar to the CRC-16 case - just a quick overview of the changes:\n\nCRC-32 uses a 33-bit polynom, however again the most signficant bit is always '1' and can be discarded. Therefore, the polynomial and the CRC value are represented by 32 bit variables.\n\nThe bit operations change slightly: Moving the input byte into the MSB of CRC requires now a shift by 24. Also the check for the most significant bit uses a different mask of 0x80000000 instead of 0x8000.\n\nActually that's it, so here is the bitwise CRC-32 algorithm implementation:\n\npublic uint Compute_CRC32_Simple(byte[] bytes)\n\n{\n\nconst uint polynomial = 0x04C11DB7;\n\nuint crc = 0;\n\nforeach (byte b in bytes)\n\n{\n\ncrc ^= (uint)(b << 24);\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & 0x80000000) != 0)\n\n{\n\ncrc = (uint)((crc << 1) ^ polynomial);\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\n}\n\nreturn crc;\n\n}\n\nCalculating the CRC-32 lookup table and using it for the CRC computation is then straight forward:\n\nprivate void CalculateCrcTable_CRC32()\n\n{\n\nconst uint polynomial = 0x04C11DB7;\n\ncrcTable = new uint[256];\n\nfor (int dividend = 0; dividend < 256; dividend++)\n\n{\n\nuint curByte = (uint)(dividend << 24);\n\nfor (byte bit = 0; bit < 8; bit++)\n\n{\n\nif ((curByte & 0x80000000) != 0)\n\n{\n\ncurByte <<= 1;\n\ncurByte ^= polynomial;\n\n}\n\nelse\n\n{\n\ncurByte <<= 1;\n\n}\n\n}\n\ncrcTable[dividend] = curByte;\n\n}\n\n}\n\npublic uint Compute_CRC32(byte[] bytes)\n\n{\n\nuint crc = 0;\n\nforeach (byte b in bytes)\n\n{\n\nbyte pos = (byte)((crc ^ (b << 24)) >> 24);\n\ncrc = (uint)((crc << 8) ^ (uint)(crcTable[pos]));\n\n}\n\nreturn crc;\n\n}\n\n[Back to top]\n\n7. CRC algorithm specification\n\nAt this point, you (and me hopefully... ;-) ) should know how CRC computation works and how to calculate it manually as well as how to implement it in your favorite programming language.\n\nHowever, a CRC instance is defined by specific parameters. We have already seen that e.g. the width of the generator polynomial varies, but there are more definition parameters. In order to be able to implement each CRC instance, let's discuss how an CRC algorithm instance is described.\n\n[Back to top]\n\n7.1 CRC parametrization\n\nFollowing standard parameters are used to define a CRC algorithm instance:\n\nName: Well, a CRC instance has to be identified somehow, so each public defined CRC parameter set has a name like e.g. CRC-16/CCITT.\n\nWidth (in bits): Defines the width of the result CRC value (n bits). Simultaneously, also the width of the generator polynomial is defined (n+1 bits). Most common used widths are 8, 16 and 32 bit. But theoretically all widths beginning from 1 are possible. In practice, even quite big (80 bit) or uneven (5 bit or 31 bit) widths are used.\n\nPolynomial: Used generator polynomial value. Note that different representations exist, see chapter 7.2.\n\nInitial Value: The value used to initialize the CRC value / register. In the examples above, always zero is used, but it could be any value.\n\nCAUTION: See chapter 8.6 for the correct handling of initial values not equal to 0.\n\nInput reflected: If this value is TRUE, each input byte is reflected before being used in the calculation. Reflected means that the bits of the input byte are used in reverse order. So this also means that bit 0 is treated as the most significant bit and bit 7 as least significant.\n\nExample with byte 0x82 = b10000010: Reflected(0x82) = Reflected(b10000010) = b01000001 = 0x41.\n\nResult reflected: If this value is TRUE, the final CRC value is reflected before being returned. The reflection is done over the whole CRC value, so e.g. a CRC-32 value is reflected over all 32 bits.\n\nFinal XOR value: The Final XOR value is xored to the final CRC value before being returned. This is done after the 'Result reflected' step. Obviously a Final XOR value of 0 has no impact.\n\nCheck value [Optional]: This value is not required but often specified to help to validate the implementation. This is the CRC value of input string \"123456789\" or as byte array: [0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39].\n\nFor a great overview over standard CRC algorithms, refer to [5].\n\nHere a pseudo-code CRC-32 table-based implementation taking the definition parameters into account:\n\npublic uint Compute_CRC32(byte[] bytes)\n\n{\n\nuint crc = crcModel.Initial;\n\nforeach (byte b in bytes)\n\n{\n\nbyte curByte = (crcModel.InputReflected ? CrcUtil.Reflect8(b) : b);\n\nbyte pos = (byte)((crc ^ (curByte << 24)) >> 24);\n\ncrc = (uint)((crc << 8) ^ (uint)(crcTable[pos]));\n\n}\n\ncrc = (crcModel.ResultReflected ? CrcUtil.Reflect32(crc) : crc);\n\nreturn (uint)(crc ^ crcModel.FinalXor);\n\n}\n\nAnd finally a possible implementation to reflect a 16bit value:\n\npublic static ushort Reflect16(ushort val)\n\n{\n\nushort resVal = 0;\n\nfor (int i = 0; i < 16; i++)\n\n{\n\nif ((val & (1 << i)) != 0)\n\n{\n\nresVal |= (ushort)(1 << (15 - i));\n\n}\n\n}\n\nreturn resVal;\n\n}\n\n[Back to top]\n\n7.2 Representation of generator polynomials\n\nIt is worth to know that there are different ways to represent a generator polynomial in hexadecimal.\n\nRemember: A CRC-n uses a generator polynomial of degree n of the form xn + xn-1 + ... + x1 + x0. Note that it has n+1 coefficients.\n\nNormal representation: The most significant bit (= xn) of the generator polynomial is left out in the hexadecimal representation (as it's always 1). The hexadecimal polynomial contains only the coefficients xn-1 ... x0. We used normal respresentation in this article.\n\nExample: In the CRC-8 discussion we used polynomial 100011101. Discarding the most significant bit results in 100011101, which is 0x1D.\n\nReversed representation: The most significant bit (= xn) of the generator polynomial is left out in the hexadecimal representation (like in the normal representation), but the tail is then reflected ('LSB first'), i.e. each nibble is reversed. So the most-significant bit does not match xn-1 as in the normal representation, but x0.\n\nExample: Polynomial is 100011101. Discarding the most significant bit results in 10001 1101. Reflection (reverse of each nibble) of 0001 1101 is 1011 1000 = 0xB8.\n\nKoopman representation: The least(!) significant bit (= x0) of the generator polynomial is discarded. The hexadecimal polynomial contains only the coefficients xn ... x1.\n\nExample: Polynomial is 100011101. Discarding the least significant bit results in 100011101 = 0x8E.\n\nNote that there are also so-called reciprocal polynomials which have their own representation, see chapter 7.3.\n\n[Back to top]\n\n7.2.1 Choosing a generator polynomial\n\nThe length on the generator polynomial depends on the maximum length of the input data and the desired error detection properties. The more likely one or more bit errors shall be detected and/or the longer the input data may be, the longer the generator polynomial has to be. This also decreases the probality of collisions (same CRC value for different input data).\n\nNote that the actual value of the generator polynomial has also major impact on its error detection capabilities and its design is non-trivial and requires serious math knowledge (e.g. see [2] for an expert article.)\n\n[Back to top]\n\n7.3 Reciprocal polynomials\n\nReciprocal polynomials are polynomials that are reflected. So the least significant coefficient becomes the most significant and the other way. In other words, a reciprocal polynomial is created from a polynomial by assigning coefficient xn to x0, xn-1 to x1 and so on.\n\nThe representation is based on the Koopman representation, but reflected ('LSB first').\n\nCAUTION: Sometimes reciprocal polynomials are called reversed polynomials. This can easily be mixed up with the reversed representation of polynomial as described in chapter 7.2. However these are two different things.\n\nIt's a fact that reversed polynomials are 'as good as' the polynomials of which they are the reciprocal ones referring to their error detection properties.\n\nUnfortunately such polynomials make it all a bit more complicated: the calculated CRC value of a polynomial is NOT the same as the calculated CRC value of its reciprocal polynomial for the same message data!\n\nBecause the LSB and MSB are exchanged, you can think of the processing of reversed polynomials as they would be shifted from the other side into the CRC shift register: In the example of the CRC shift register in chapter 3 the input data was shifted from the right. If the reversed polynomial is used, you could get the same CRC result when shifting the input data from the left. Actually the whole processing is then just mirrored.\n\nIn the C# download package linked at the top, there is a 'reflected' implementation for each CRC class: Such a reflected CRC algorithm produces the same CRC result when using a reversed polynomial like the standard implementation using the non-reversed polynomial by 'mirroring' the processing.\n\n[Back to top]\n\n7.3.1 Reversed CRC lookup table and calculation of reciprocal CRC\n\nThe fact that there are the two variants MSB-to-LSB and LSB-to-MSB often causes confusion. For example this is the reason why often two different lookup tables are found in the net for the same CRC instance: For the well-known standard CRC-32 instance (e.g. PKZIP) with polynomial 0x04c11db7, you can find a lookup table starting with the values 0x00000000 and 0x04C11DB7, the other one with 0x00000000 and 0x77073096. The first one correspond to the algorithms described in this article, while the second corresponds to the reciprocal variant where the coefficients are reflected.\n\nLet's recall the calculation for the 'normal' CRC-32 lookup table, compared to the 'reciprocal variant' of the CRC-32 lookup table :\n\nprivate void CalculateCrcTable()\n\n{\n\ncrcTable = new uint[256];\n\nfor (int dividend = 0; dividend < 256; dividend++)\n\n{\n\nuint curByte = (uint)(dividend << 24);\n\nfor (byte bit = 0; bit < 8; bit++)\n\n{\n\nif ((curByte & 0x80000000) != 0)\n\n{\n\ncurByte <<= 1;\n\ncurByte ^= polynomial;\n\n}\n\nelse\n\n{\n\ncurByte <<= 1;\n\n}\n\n}\n\ncrcTable[dividend] = curByte;\n\n}\n\n}\n\nprivate void CalculateCrcTableReciprocal()\n\n{\n\ncrcTable = new uint[256];\n\nfor (int dividend = 0; dividend < 256; dividend++)\n\n{\n\nuint curByte = (uint)(dividend);\n\nfor (byte bit = 0; bit < 8; bit++)\n\n{\n\nif ((curByte & 0x00000001) != 0)\n\n{\n\ncurByte >>= 1;\n\ncurByte ^= Reflect32(polynomial);\n\n}\n\nelse\n\n{\n\ncurByte >>= 1;\n\n}\n\n}\n\ncrcTable[dividend] = curByte;\n\n}\n\n}\n\nTo calculate the reciprocal variant lookup-table, two changes are required to handle the reflected bit-order: At first, the CRC parameter Polynomial has to be reflected, and second the order of bit processing in the algorithm itself needs to be changed from MSB-to-LSB to LSB-to-MSB, resulting in right-shifting instead of left-shifting.\n\nSo this results in two different look-up tables. This implies that also the actual CRC calculation needs to adapated for the reciprocal variant in order to retrieve the same CRC result as for the normal variant.\n\nIn general, to use the reciprocal variant of a CRC-model, following changes are required for the CRC model: The CRC parameters Polynomial and Initial Value have to be reflected, the parameters Input reflected and Result reflected have to be negated and the parameter Final XOR value remains unchanged. Here some code to change the CRC model to the reciprocal CRC model:\n\npublic static Crc32Model GetReflectedCrcModel(Crc32Model model)\n\n{\n\nreturn new Crc32Model(\n\nCrcUtil.Reflect32(model.Polynomial),\n\nCrcUtil.Reflect32(model.Initial),\n\nmodel.FinalXor,\n\n!model.InputReflected,\n\n!model.ResultReflected\n\n);\n\n}\n\nWith this information, here the table-based calculation of reciprocal CRC-32 (right) compared to the normal calculation (left):\n\npublic uint Compute(byte[] bytes)\n\n{\n\nuint crc = crcModel.Initial;\n\nforeach (byte b in bytes)\n\n{\n\nbyte curByte = (crcModel.InputReflected ? CrcUtil.Reflect8(b) : b);\n\ncrc = (uint)(crc ^ (curByte << 24));\n\nbyte pos = (byte)(crc >> 24);\n\ncrc = (uint)(crc << 8);\n\ncrc = (uint)(crc ^ (uint)crcTable[pos]);\n\n}\n\ncrc = (crcModel.ResultReflected ? CrcUtil.Reflect32(crc) : crc);\n\nreturn (uint)(crc ^ crcModel.FinalXor);\n\n}\n\npublic uint ComputeReciprocal(byte[] bytes)\n\n{\n\ncrcModel = GetReflectedCrcModel(crcModel);\n\nuint crc = crcModel.Initial;\n\nforeach (byte b in bytes)\n\n{\n\nbyte curByte = (crcModel.InputReflected ? CrcUtil.Reflect8(b) : b);\n\ncrc = (uint)(crc ^ curByte);\n\nbyte pos = (byte)(crc & 0xFF);\n\ncrc = (uint)(crc >> 8);\n\ncrc = (uint)(crc ^ (uint)crcTable[pos]);\n\n}\n\ncrc = (crcModel.ResultReflected ? CrcUtil.Reflect32(crc) : crc);\n\nreturn (uint)(crc ^ crcModel.FinalXor);\n\n}\n\n[Back to top]\n\n7.4 Extending to arbitrary CRC sizes (width of polynomials)\n\nUntil now, only CRC widths of 8, 16 and 32 have been considered, thus integer multiples of byte (8 bit) sizes. Of course, there are also CRC algorithms with other widths. What needs to be considered in the implementation to support those kinds of CRC algorithms? This is discussed in this chapter. Note that in the following, still the input values are assumed to be bytes (8 bit values).\n\nIt is obvious that the underlying data type must be sufficiently large to hold the values (so e.g. use 32 bit values for CRC-28). Considering the simple bitwise implementation, following values depend on the CRC width and needs to be adapted as follows (Note: At first, only CRC with > 8 are considered):\n\nCRC > 8:\n\nThe number of bits to move the next byte into the MSB of the CRC register depends on the CRC width. E.g. for CRC-11, the input byte needs only be shifted by 3.\n\nIn general: Number of bits to left shift = crcsize - 8.\n\nThe most significant bit of the CRC is checked if it is set. Therefore the needed bit mask depends on the CRC width. E.g. a CRC-11 value has 11 binary digits, so the bit mask is in binary b100 0000 0000 = 0x400.\n\nIn general: topbitmask = 1 << (crcsize - 1).\n\nFor a CRC-x, only the lower x bits are significant. If a larger data type is used, then the upper unused bits shall be cleared, otherwise the result is interpreted incorrectly. So a mask should be applied to the CRC value. E.g for CRC-11, only the 11 lower bits are relevant, thus the mask would be b111 1111 1111 = 0x7FF.\n\nIn general: final mask = (1 << crcsize) - 1.\n\nThe reflection of a value must also be considered.\n\nWith this information, a sample CRC implementation for CRC width of 8 or greater might look like the following (Note: due to usage of ushort, actually only up to CRC-16 is supported but this changed by replacing uhsort by a larger data type):\n\npublic static ushort Compute_Simple_Crc_8_16(byte[] bytes)\n\n{\n\nushort poly = 0x307;\n\nushort crcsize = 11;\n\nushort initialValue = 0;\n\nbool inputReflected = false;\n\nbool resultReflected = false;\n\nushort finalXor = 0;\n\nushort bitsToShift = (ushort)(crcsize - 8);\n\nushort bitmask = (ushort)(1 << (crcsize - 1));\n\nushort finalmask = (ushort)((1 << crcsize) - 1);\n\nushort crc = initialValue;\n\nforeach (byte b in bytes)\n\n{\n\nbyte curByte = (inputReflected ? Reflect8(b) : b); ;\n\ncrc ^= (ushort)(curByte << bitsToShift);\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & bitmask) != 0)\n\n{\n\ncrc = (ushort)(((crc << 1) ^ poly));\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\ncrc = (ushort)(crc & finalmask);\n\n}\n\ncrc = (ushort)(resultReflected ? ReflectGeneral(crc, crcsize) : crc);\n\ncrc ^= finalXor;\n\nreturn (ushort)(crc);\n\n}\n\nCRC < 8:\n\nFor a CRC width smaller than 8, additional points must taken into account because byte values are used as input values. This means the CRC register is actually smaller than an input value. This is no issue when using the initial shift register implementation.\n\nHowever, it matters for our simple implementation where whole bytes are \"xored\" into the CRC register. It would be required to only \"xor\" the relevant bits and handle the remaining bits of the input byte in the next loop which complicates the handling of the inputs bytes significantly.\n\nAn alternative approach which results in a simpler implementation is to use always an 8 bit CRC register also for a CRC width smaller than 8. The trick is then to only work the \"x\" most significant bits of the CRC register for a CRC with width \"x\". This means:\n\nThe next byte of the input byte stream is just moved into the CRC register, no need to shift the value inside the CRC register.\n\nThe top bit mask is always 0x80.\n\nThe final mask is always 0xFF.\n\nThe initial and polynomial values are shifted to the left so that both are located in the most signficant bits of the 8-bit CRC value.\n\nAt the end of the calculation, the CRC value is shifted back so that it is located in the least signficant bits of the 8-bit CRC register value, otherwise the result is interpreted incorrectly.\n\nSummarized, a possible implementation for CRC-x (where x < 8) might look like following:\n\npublic static ushort Compute_Simple_Crc_SmallerThanEight(byte[] bytes)\n\n{\n\nbyte poly = 0x09;\n\nbyte crcsize = 7;\n\nbyte initialValue = 0;\n\nbool inputReflected = false;\n\nbool resultReflected = false;\n\nbyte finalXor = 0;\n\nbyte bitmask = 0x80;\n\nbyte finalmask = 0xFF;\n\nbyte bitOffsetTo8 = (byte)(8 - crcsize);\n\npoly <<= bitOffsetTo8;\n\nushort crc = initialValue;\n\ncrc <<= bitOffsetTo8;\n\nforeach (byte b in bytes)\n\n{\n\nbyte curByte = (inputReflected ? Reflect8(b) : b); ;\n\ncrc ^= (ushort)(curByte);\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & bitmask) != 0)\n\n{\n\ncrc = (ushort)(((crc << 1) ^ poly));\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\ncrc = (ushort)(crc & finalmask);\n\n}\n\ncrc >>= bitOffsetTo8;\n\ncrc = (ushort)(resultReflected ? ReflectGeneral(crc, crcsize) : crc);\n\ncrc ^= finalXor;\n\nreturn (ushort)(crc);\n\n}\n\n[Back to top]\n\n8. Additional remarks (points worth to know)\n\nThis last chapter contains interesting (and maybe not completely obvious) topics about CRC calculation. These points are optional and contain just additional information, for those who are interested in same background information.\n\n[Back to top]\n\n8.1 Basic mathematical view of CRC (read it first)\n\nFirst let's recall some mathematical basics for CRC definition for better understanding of the next points. Please note that the sub chapter actually represents the same information as chapter 2 (don't hesitate to have a quick look back at this introduction chapter):\n\nCRC-n uses a generator polynomial G(x) which has degree n and n+1 terms: xn + xn-1 + ... + x1 + x0.\n\nThe n+1 terms means that the polynomial has a length of n + 1 bits (using normal representation the most significant bit is left out).\n\nThe computation of CRC, which we know is based on polynomial division (or more specific on Polynomial arithmetic modulo 2), can be stated as M(x) * xn = G(x) * Q(x) + R(x) where:\n\nM(x) is the input binary string, so M(x)*xn is the input string with n zero bits appended. (Stop! Why is it like that? Answer: We'll come to this later in chapter 8.5 ).\n\nG(x) is the generator polynomial with degree n as already stated.\n\nQ(x) is quotient of the division and not used further.\n\nR(x) is the remainder = the actual CRC value.\n\n[Back to top]\n\n8.2 Background to CRC verification\n\nOr: \"Why is the verification result zero if the CRC is computed over the input data with the actual CRC value appended (in the manual approach)?\"\n\nActually, the XOR arithmetic of CRC division is comparable to school arithmetic in this case, so let's start with an example.\n\nWe know that M(x) * xn is the input data bit string with n zero bits appended. As we see later ( in chapters 8.4 and 8.5) appending the bits of R(x) to this input string can be stated as M(x) * xn - R(x).\n\nRearrange the formula: M(x) * xn = G(x) * Q(x) + R(x) ===> M(x) * xn - R(x) = G(x) * Q(x)\n\nHere we see that M(x) * xn - R(x) (which is the input data with the CRC appended) is an integer multiple of the polynomial G(x). And this means that M(x) * xn - R(x) divided by G(x) results in 0.\n\nSide note 1: M(x) * xn = G(x) * Q(x) + R(x) can also be written using the modulo operator mod as R(x) = (M(x) * xn) mod G(x).\n\n[Back to top]\n\n8.3 CRC-1 is the same as a parity bit\n\nThis is correct. Here some clarifying words: A parity bit indicates if the number of bits with value 1 is even or odd. In the case of even parity, the number of bits whose value is 1 in a given set are counted. If that total is odd, the parity bit value is set to 1, making the total count of 1's in the set an even number.\n\nExample: The value 0x34 = 0011 0100 has three '1' bits. Because three is odd, the parity bit is 1.\n\nCRC-1 has degree 1 and 2 terms: a*x^1 + b*x^0. The most significant bit is always 1. However a polynomial 10 has no sense because the actual CRC value would always be 0. So CRC-1 has polyomial 11 (binary) which is just 0x01 in normal representation. And this is in fact the calculation of an even parity bit. Remember that the actual CRC value has n bits, so for CRC-1 the remainder has 1 bit, either 0 or 1.\n\nHere an example for the value 0x34:\n\n001101000 11 --------- 0001000 11 ------- 0100 11 --- 010 11 -- 01 = CRC = 1\n\n[Back to top]\n\n8.4 Why is addition is the same as subtraction in CRC arithmetic?\n\nCRC computation is performed using so-called polynomial arithmetic. This polynomial arithmetic is based on division over the finite field with two elements: 0 and 1. Also called Galois field over two elements.\n\nTo define the addition operation, there are only four cases to distinct:\n\n0 + 0 = 0\n\n0 + 1 = 1\n\n1 + 0 = 1\n\n1 + 1 = 0 - note that there is no carry!\n\nDue to the fact that we perform the calculation over a finite field (refer to [6] for more info), there is only one way to define subtraction:\n\n0 - 0 = 0\n\n0 - 1 = 1\n\n1 - 0 = 1\n\n1 - 1 = 0\n\nWe see that addition and subtraction are the same: Basically this is the XOR operation we have already used several times above.\n\nThat's the reason why we stated above that M(x) * xn - R(x) and M(x) * xn + R(x) are the same in CRC arithmetic.\n\n[Back to top]\n\n8.5 Why does multiplication with xn append n zeros?\n\nThis is due to the fact that each trailing zero bit of adds a factor of x. Let's say we have the polynomial xn + xn-1 + ... + x1 + x0. Multiply it with x:\n\nx* (xn + xn-1 + ... + x1 + x0) = xn+1 + xn + ... + x1\n\nSo by multiplying with x, we have increased the degree of the polynomial by 1, which equals appending a zero to the right. Maybe this gets clearer with an example:\n\n[Back to top]\n\n8.6 When using an initial value other than zero in the shift register, the result is incorrect.\n\nIn chapter 7 initial values were introduced, with the description that it's the value used to initialize the shift register. Well, you can read this statement also in other CRC articles, however there is a trap that is commonly not well described (if at all).\n\nUnfortunately, not. Above examples give the two different CRC values of 0x2A and 0xE0.\n\nLooking at the simple (non-lookup table, but byte-wise handling) CRC-8 implementation, we see the reason:\n\npublic byte Compute_Simple(byte[] bytes)\n\n{\n\nbyte crc = crcModel.Initial;\n\nforeach (byte b in bytes)\n\n{\n\nbyte curByte = (crcModel.InputReflected ? CrcUtil.Reflect8(b) : b);\n\ncrc ^= curByte;\n\nfor (int i = 0; i < 8; i++)\n\n{\n\nif ((crc & 0x80) != 0)\n\n{\n\ncrc = (byte)((crc << 1) ^ crcModel.Polynomial);\n\n}\n\nelse\n\n{\n\ncrc <<= 1;\n\n}\n\n}\n\n}\n\ncrc = (crcModel.ResultReflected ? CrcUtil.Reflect8(crc) : crc);\n\nreturn (byte)(crc ^ crcModel.FinalXor);\n\n}\n\n> Before the actual first xor operation of the CRC calculation is performed, the initial value is xored with the first input byte!\n\nWhat does that mean for the initial value of the shift register when performing the CRC calculation bit by bit, like the pen and paper approach at the top? Answer: The register must be initialized with the initial value 'xored' with the first input bytes. For CRC-16 the initial value must be xored with the first two input bytes, for CRC-32 with the first four input bytes, and so on.\n\nHere an example implementation how to initialize a CRC-32 shift register and the corresponding shift register algorithm. This is taken from the C# source package linked at the top of the article:\n\nprivate uint GetInitialShiftRegister(byte[] bytes)\n\n{\n\nbyte b1 = 0, b2 = 0, b3 = 0, b4 = 0;\n\nif (bytes.Length >= 1)\n\n{\n\nb1 = crcModel.InputReflected ? CrcUtil.Reflect8(bytes[0]) : bytes[0];\n\n}\n\nif (bytes.Length >= 2)\n\n{\n\nb2 = crcModel.InputReflected ? CrcUtil.Reflect8(bytes[1]) : bytes[1];\n\n}\n\nif (bytes.Length >= 3)\n\n{\n\nb3 = crcModel.InputReflected ? CrcUtil.Reflect8(bytes[2]) : bytes[2];\n\n}\n\nif (bytes.Length >= 4)\n\n{\n\nb4 = crcModel.InputReflected ? CrcUtil.Reflect8(bytes[3]) : bytes[3];\n\n}\n\nreturn (uint)(crcModel.Initial ^ (uint)((uint)b4 << 24 | (uint)b3 << 16 | (uint)b2 << 8 | b1));\n\n}\n\npublic uint Compute_Simple_ShiftReg(byte[] bytes)\n\n{\n\nuint crc = GetInitialShiftRegister(bytes);\n\nfor (int byteIndex = 4; byteIndex < bytes.Length + 4; byteIndex++)\n\n{\n\nbyte curByte = (byteIndex < bytes.Length) ? (crcModel.InputReflected ? CrcUtil.Reflect8(bytes[byteIndex]) : bytes[byteIndex]) : (byte)0;\n\nfor (int i = 0; i <= 7; i++)\n\n{\n\nif ((crc & LOWBIT_MASK) != 0)\n\n{\n\ncrc = (uint)(crc >> 1);\n\ncrc = ((uint)(curByte & (1 << i)) != 0) ? (uint)(crc | 0x80000000) : (uint)(crc & 0x7FFFFFFF);\n\ncrc = (uint)(crc ^ crcModel.Polynomial);\n\n}\n\nelse\n\n{\n\ncrc = (uint)(crc >> 1);\n\ncrc = ((uint)(curByte & (1 << i)) != 0) ? (uint)(crc | 0x80000000) : (uint)(crc & 0x7FFFFFFF);\n\n}\n\n}\n\n}\n\ncrc = (crcModel.ResultReflected ? CrcUtil.Reflect32(crc) : crc);\n\nreturn (uint)(crc ^ crcModel.FinalXor);\n\n}\n\n[Back to top]\n\n9. Conclusion & References\n\nThis article is my own guide to CRC: very practical and based on many examples - quite different to most of the other articles on the web. I hope you found it interesting and that it supported you in understanding and implementing CRC!\n\nDrop me a line for corrections, hints, criticism, praise ;)\n\nSunshine, February 2015 (last update: June 2023)\n\nReferences\n\n[1] Cyclic redundancy check @ Wikipedia\n\n[2] \"Cyclic Redundancy Code (CRC) Polynomial Selection For Embedded Networks\". The International Conference on Dependable Systems and Networks: 145â154. Retrieved 29 December 2014.\n\n[3] Mathematics of cyclic redundancy checks @ Wikipedia\n\n[4] A Painless Guide to CRC Error Detection Algorithms\n\n[5] CRC RevEng - Catalogue of parametrised CRC algorithms\n\n[6] Finite field @ Wikipedia\n\n2024/03/23:\n\nAdded a note to chapter 4.4 that the presented algorithm at this location is only an intermediate version to avoid misunderstandings.\n\n2023/06/19:\n\nFixed grammar: Replaced divident by dividend.\n\nClarified several locations that CRC-n uses a polynomial of degree n which has n+1 terms.\n\n2023/03/11:\n\nAdded chapter 7.4 (Extending to arbitrary CRC sizes (width of polynomials))\n\n2019/03/22:\n\nFixed a bug in chapter 7.3.1 about the final XOR value when using the reciprocal variant: In the reciprocal CRC model, the final XOR value must not be reflected, contrary to my previous statement.\n\nNote that in the source code, this was already correctly implemented.\n\n2018/12/29:\n\nReplaced occurrences of x^n by xn for consistent naming.\n\n2018/09/29:\n\nFixed a glitch in the \"Step-by-step visualization of simple CRC-8 algorithmus\" table. Thanks to the careful reader for pointing me to it.\n\nReworked the chapters of representation of polynomials and reciprocal polynomials - hopefully they are more understandable now (chapter 7.2 and 7.3).\n\nFixed a typo in chapter 8.6 (byte 0x01 instead of 0x11). Thanks to the careful reader for pointing me to it.\n\n2016/11/11:\n\nAdded chapters 7.3 (reversed polynomials) and chapter 8.6 (initial value for shift register)\n\nUpdated C# source package with CRC classes that work in the reversed way.\n\nUpdated Javascript Online calculator to show optionally the CRC lookup table in the reversed way.\n\n2016/08/19: Fixed a typo in chapter 8.4: 1 + 1 = 0 instead of 1 + 1 = 1.\n\n2015/05/30: Added chapter 8."
    }
}