{
    "id": "dbpedia_4765_3",
    "rank": 19,
    "data": {
        "url": "https://picaxeforum.co.uk/threads/exclusive-or-xor-used-as-a-serial-data-checksum.11206/",
        "read_more_link": "",
        "language": "en",
        "title": "Exclusive-or (XOR) ^ used as a Serial data checksum",
        "top_image": "https://picaxeforum.co.uk/favicon.ico",
        "meta_img": "https://picaxeforum.co.uk/favicon.ico",
        "images": [
            "https://picaxeforum.co.uk/logo-red.png",
            "https://picaxeforum.co.uk/logo-red.png",
            "https://picaxeforum.co.uk/data/avatars/m/34/34212.jpg?1537202519",
            "https://picaxeforum.co.uk/data/avatars/m/0/700.jpg?1536579607",
            "https://picaxeforum.co.uk/data/avatars/m/0/700.jpg?1536579607",
            "https://picaxeforum.co.uk/data/avatars/m/0/700.jpg?1536579607",
            "https://picaxeforum.co.uk/data/avatars/m/0/700.jpg?1536579607"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2008-12-24T02:51:01+00:00",
        "summary": "",
        "meta_description": "I've searched the forum on this, plus the net, and not quite finding the answer i want.\n\nA company i deal with is investing in a data acquisition system...",
        "meta_lang": "en",
        "meta_favicon": "https://picaxeforum.co.uk/favicon.ico",
        "meta_site_name": "PICAXE Forum",
        "canonical_link": "https://picaxeforum.co.uk/threads/exclusive-or-xor-used-as-a-serial-data-checksum.11206/",
        "text": "I've searched the forum on this, plus the net, and not quite finding the answer i want.\n\nA company i deal with is investing in a data acquisition system that requires data to be sent with a calculated checksum, or the data is ignored. Sounds like a pretty smart way to maintain data integrity. This would be a valuable tool also for Picaxe to Picaxe data communication, whether it be by wire or by the Radio modules ( eg Hope HM- TR or Xbee) that are becoming more and more accessible.\n\nIn the short term i'd like to send my own data from Picaxe to this data acquisition system.\n\nI have been very sucessfully using the serout command to export data to computers and basic serial logging software (eg Eltima RS232 Data logger) and hyperterminal via RS232.\n\nThis computer company, http://www.trisol.com.au/ are saying that the way to send the data is as follows:\n\n<MID>,<PID>,<Value>,<PID>,<Value>,<PID>,<Value>,<PID>,<Value>,CRC<CR><LF>\n\nWhere MID = Message ID, PID = Parameter ID and Value is value, all in ascii characters.\n\nI can handle the message ID, Parameter Identifier and value OK with plain characters, text in invered commas, BintoAscii and then Serout. But now the Checksum CRC.\n\nCRC = ASCII representation of exclusive-or (XOR) sum of all characters from MID(inclusive) to the last value (excluding CRC, <CR> and <LF>).\n\nThis Checksum system is apparently also used for data which comes from a Garmin GPS antenna..\n\nThe receiving computer also calculates the checksum on the incoming data, and if the checksums match, then it accepts the data. Sounds simple.\n\nPicaxe can do XOR, represented by ^. I understand what it is, but not how the maths works. The only thing i can think of is something like:\n\nb1 = b2^b3^b4^b5^ etc\n\nbintoascii b1,b9,b10,b11\n\nSerout 1, T1200, (b2,b3,b4,b5,......b9,b10,b11,13,10)\n\nThis code runs on the simulator OK.\n\nb1 = b2^b3^b4^b5\n\nbintoascii b1,b9,b10,b11\n\nSerout 1, T1200, (b2,b3,b4,b5,b9,b10,b11,13,10)\n\nBut, i would be using up a lot of variables and i have no way of knowing if i was generating the right number anyway. There must be a better way.\n\nThis idea of generating a checksum and then testing for it seems like such a good idea that you would think that it would have been done in picaxe world before. But I can't find where or how. The guy from Trilogy is off on holidays now, so i can't quiz further, till January, but he can't tell me Picaxe code anyway.\n\nAny ideas on using a XOR sum of all characters as described to generate a checksum?\n\nI've searched the forum on this, plus the net, and not quite finding the answer i want.\n\nA company i deal with is investing in a data acquisition system that requires data to be sent with a calculated checksum, or the data is ignored. Sounds like a pretty smart way to maintain data integrity. This would be a valuable tool also for Picaxe to Picaxe data communication, whether it be by wire or by the Radio modules ( eg Hope HM- TR or Xbee) that are becoming more and more accessible.\n\nIn the short term i'd like to send my own data from Picaxe to this data acquisition system.\n\nI have been very sucessfully using the serout command to export data to computers and basic serial logging software (eg Eltima RS232 Data logger) and hyperterminal via RS232.\n\nThis computer company, http://www.trisol.com.au/ are saying that the way to send the data is as follows:\n\n<MID>,<PID>,<Value>,<PID>,<Value>,<PID>,<Value>,<PID>,<Value>,CRC<CR><LF>\n\nWhere MID = Message ID, PID = Parameter ID and Value is value, all in ascii characters.\n\nI can handle the message ID, Parameter Identifier and value OK with plain characters, text in invered commas, BintoAscii and then Serout. But now the Checksum CRC.\n\nCRC = ASCII representation of exclusive-or (XOR) sum of all characters from MID(inclusive) to the last value (excluding CRC, <CR> and <LF>).\n\nThis Checksum system is apparently also used for data which comes from a Garmin GPS antenna..\n\nThe receiving computer also calculates the checksum on the incoming data, and if the checksums match, then it accepts the data. Sounds simple.\n\nPicaxe can do XOR, represented by ^. I understand what it is, but not how the maths works. The only thing i can think of is something like:\n\nb1 = b2^b3^b4^b5^ etc\n\nbintoascii b1,b9,b10,b11\n\nSerout 1, T1200, (b2,b3,b4,b5,......b9,b10,b11,13,10)\n\nThis code runs on the simulator OK.\n\nb1 = b2^b3^b4^b5\n\nbintoascii b1,b9,b10,b11\n\nSerout 1, T1200, (b2,b3,b4,b5,b9,b10,b11,13,10)\n\nBut, i would be using up a lot of variables and i have no way of knowing if i was generating the right number anyway. There must be a better way.\n\nThis idea of generating a checksum and then testing for it seems like such a good idea that you would think that it would have been done in picaxe world before. But I can't find where or how. The guy from Trilogy is off on holidays now, so i can't quiz further, till January, but he can't tell me Picaxe code anyway.\n\nAny ideas on using a XOR sum of all characters as described to generate a checksum?\n\nIt's been a data integrity method used for a long time. Actually checksum and CRC are two very different methods. CRC does use the exclusive or but uses each data and a polynomial.\n\nHere is a link about CRC generation: http://en.wikipedia.org/wiki/Cyclic_Redundancy_Check\n\nA check-sum is a lot simpler. Here is a link for checksum generation:\n\nhttp://en.wikipedia.org/wiki/Checksum\n\nYou use one byte to hold the intermediate results of each summed byte to be sent in the message. You ignore any overflow and just keep adding the message bytes to the sum like so until all have been sent\n\nB0 = 0\n\nB0 = B0 + B1\n\nB0 = B0 + B2\n\nB0 = B0 + B3\n\netc\n\netc\n\nWhen you have finish sending all the message bytes you send the B0 variable as the last byte transmitted.\n\nIf the the receiving end does the same running summation as each byte comes in then it's intermediate running check sum will to equal when it compares the last received checksum byte with the results it has accumulated. For this method to work the receiver has to know either how many bytes there are in message or use the first message byte to convey how long the message is in bytes. The Intel HEX format uses a check-sum method and the Kermit file transfer protocol uses CRC method.\n\nLefty\n\nCyclic Redundancy Check\n\nThanks guys - Knew i'd come to the right place.\n\nIf i'd known CRC was actually a \"cyclic redundancy check\" i would have had a better start!\n\nHe never actually called it a checksum, that was my mistake.\n\nIn following all those great links i can see there are all sorts of CRCs. Some of the code in those links is scaring the pants off me.\n\nThe CRC they suggest is is just what i'd placed in bold. It is also meant to be simple to implement. PH Anderson's seems to be specific to the Dallas one wire, and the complexity of the code is frightening. I can see the great minds had put some work into this.\n\nTarzan's code looks to be along the lines of what i want, but i've never used scratchpad. Is this the best way to do it? I'd hoped to use this on a 08m if i could, and these don't have scratchpad.\n\nI was thinking along the lines of lefty's basic maths, and would somehow do a b0 = b0^b1, as i went along. The Identifiers would always have the same XOR sum and i guess could be pre added? I use bintoascii to generate individual integers so i can serout them as ascii, and thought to XOR them as i went along. The message length would always be the same.\n\nI'll keep working on it, any suggestions welcome, but i'm already in a better place.\n\nStumbling\n\nThanks for the advice, i've been taking it as best i can, using the peek and poke as suggested.\n\nI don't have any \"incoming data\" as such, as per boriz's suggestion. The required data string that has a lot of data repeated every time, the Message ID, what type of message, paramater IDs and all the delimiting commas. I input each repeated value in the register in sequence, and left space for the measured values. The idea is that when i measure the values i can \"Poke\" them into the right place in the register. Then, there are 35 characters in the register, then i use a loop as suggested by Tarzan to read each one, do the XOR calc and serout ascii characters one at a time.\n\nIt ended up being too big for a Picaxe 08m, and that is without even capturing data from the sensors and processing. The peek & Poke plus loop seems to work on the simulator, BUTwhen i trt to output the # version of CRC it seems to lose it, giving red characters on the serial simulator.\n\nI don't know if it is doing what it is supposed to or not. The \"ASCII representation of exclusive-or (XOR) sum of all characters from MID(inclusive) to the last value (excluding CRC, <CR> and <LF>) does not seem to hard a calculation after all that poking and looping.\n\nI've spent quite some time on this, and i'm not sure if i'm on the right track, whether the preload idea is the right way to do it, (eats memory) and whether the CRC calc is what is required of the database.\n\nAlso, in working through this i'm confused as to when you use Hex (eg $32) or BCD eg 50 to represent \"2\".\n\nHere is the code so far:\n\nCode:\n\n; ******************************* ; ** data to infofleet database with XOR CRC ** ; ** CRC = Cyclic Redundancy check, for accuracy of data transmission ; ******************************* #picaxe28x1 symbol temp_byte1 = b10 symbol temp_byte2 = b11 symbol temp_byte3 = b12 symbol CRC = b13 'Data sent in Ascii to the database is supposed to look like this 'GLS,DATA,S1,165,S2,245,S3,185,ST,0,CRC, 13,10 'Preload repeat data bytes into RAM, decimal values from Decimal to accii tables poke 80,0 'value zero poke 81,71 'G poke 82,76 'L poke 83,83 'S poke 84,44 ', poke 85,68 'D poke 86,65 'A poke 87,84 'T poke 88,65 'A poke 89,44 ', poke 90,83 'S poke 91,49 '1 poke 92,44 ', 'three digits data poke 93,32 '(space) poke 94,32 '(space) poke 95,32 '(space) poke 96,44 ', poke 97,83 'S poke 98,50 '2 poke 99,44 ', 'three digits data poke 100,32 '(space) poke 101,32 '(space) poke 102,32 '(space) poke 103,44 ', poke 104,83 'S poke 105,51 '3 poke 106,44 ', 'three digits data poke 107,32 '(space) poke 108,32 '(space) poke 109,32 '(space) poke 110,44 ', poke 111,83 'S poke 112,84 'T poke 113,44 ', 'one digit data poke 114,32 '(space) poke 115,44 ', main: 'Future Code to count the number of seconds into word variable, zero to 999 but temporarily w1 = 340 w2 = 520 w3 = 180 'Status will be determined by future code, but temporarily, let b8 = 1 +48 'Converts byte 1 to Ascii 1 crc = $00 ' Resets to zero bintoascii w1,temp_byte1,temp_byte2,temp_byte3 ' Converts to ascii, splits into three integers poke 93, temp_byte1 ' puts the converted byte in the right spot in register poke 94, temp_byte2 poke 95, temp_byte3 bintoascii w2,temp_byte1,temp_byte2,temp_byte3 ' Converts to ascii, splits into three integers poke 100, temp_byte1 ' puts the converted byte in the right spot poke 101, temp_byte2 poke 102, temp_byte3 bintoascii w3,temp_byte1,temp_byte2,temp_byte3 ' Converts to ascii, splits into three integers poke 107, temp_byte1 ' puts the converted byte in the right spot poke 108, temp_byte2 poke 109, temp_byte3 poke 114, b8 'the ram is now full of correct data on e byte at a time. 'Now Start a loop to get it all back out in sequence let b9 = 80 ' the first register address (blank) do while b9 < 116 b9 = b9 +1 peek b9,temp_byte1 ' Puts value at register address into the temp byte variable CRC = CRC^temp_byte1 ' Increments the CRC XOR calc one byte at a time serout 0, T1200, (temp_byte1) ' Outputs the data in register one byte at a time. loop serout 0, T1200, (#crc,13,10) '# Outputs Ascii representation of CRC, pause 125 goto main\n\nAny comments or suggestions welcome. Thanks again for your assistance.\n\nAnother go.\n\nOK, more info on this seemingly esoteric topic.\n\nThe guy is back from holidays now. He has given me an example (thanks for the suggestion Jeremy) and some code that i think must be designed for the standard microchip product. I don't know that language. I only know (some) picaxe code, so it doesn't make much sense to me.\n\nHere is what he has given me:\n\nCRC Example:\n\nPASHR,RIO,f1,f2,f3,f4,f5 gives a CRC = cc (hexadecimal but send as the string “cc”)\n\nAnd here is what he is telling me is the subroutine that checks it:\n\nCode:\n\nThe below is a routine that checks if the received checksum is OK. In this example the CRC is marked with a leading * but we will simply look for the two bytes after the last comma. As you can see the actual checksum (2 bytes) is calculated by XOR (exclusive OR function)-ing every byte in the message. This does not including the CRC and CR LF (and for this example * is also disregarded), which in this example has already been stripped in the RX_Data but does include the commas and everything else. private length global SumInt private Result try length = Find(Rx_Data,\"*\",0) //get position of CRC-bytes in the message if (length > 0) SumInt = Asc(Mid(Rx_Data,0,1)) for(private charcount = 1, charcount < length, charcount++) SumInt = (SumInt # Asc(Mid(Rx_Data,charcount,1))) endfor If (SumInt == StrToDouble(\"0x\" + Mid(Rx_Data,(length+1),2))) //String 0x identifies to convert from hexadecimal-string to double Result = 1 else Result = 0 endif else Result = 0 endif\n\nUsing this example i wrote the following based on and what i had done before based on all your suggestions. On the simulator it produces all the characters as it is supposed to, but what is meant to be the hex CRC code comes out as [00]91[0D][0a] .If i uncheck the \"display non-printing characters as hex\" box i get 91. this is nothing like the \"cc\" i am supposed to get.\n\nCode:\n\n; ******************************* ; ** data to infofleet database with XOR CRC ** ; ** CRC = Cyclic Redundancy check, for accuracy of data transmission ; ******************************* ; Filename: ; Date: ; File Version: ; Written by: MV ; Function: ; Last Revision: ; Target PICAXE: ; ******************************* #picaxe28x1 symbol temp_byte1 = b10 symbol temp_byte2 = b11 symbol temp_byte3 = b12 symbol CRC = b13 'Example Data sent in Ascii to the database is supposed to look like this 'PASHR,RIO,f1,f2,f3,f4,f5 gives CRC = cc (hexadecimal but send as the string \"cc\") 'Preload repeat data bytes into RAM, decimal values from Decimal to accii tables poke 80,0 'value zero poke 81,80 'P poke 82,65 'A poke 83,83 'S poke 84,72 'H poke 85,82 'R poke 86,44 ', poke 87,82 'R poke 88,73 'I poke 89,79 'O poke 90,44 ', poke 91,102 'f poke 92,49 '1 poke 93,44 ', poke 94,102 'f poke 95,50 '2 poke 96,44 ', poke 97,102 'f poke 98,51 '3 poke 99,44 ', poke 100,102'f poke 101,52 '4 poke 102,44 ', poke 103,102'f poke 104,53 '5 main: crc = $00 ' Resets to zero 'the ram is now full of correct data on e byte at a time. 'Now Start a loop to get it all back out in sequence let b9 = 80 ' the first register address (blank) do while b9 < 105 b9 = b9 +1 peek b9,temp_byte1 ' Puts value at register address into the temp byte variable CRC = CRC^temp_byte1 ' Increments the CRC XOR calc one byte at a time serout 0, T1200, (temp_byte1) ' Outputs the data in register one byte at a time. loop serout 0, T1200, (#crc,13,10) '# Outputs Ascii representation of CRC, pause 125 goto main\n\nI must be missing something fundamental, it is supposed to be simple to implement. I think i'm lost in understanding how hex works in all this, and the foreign code is not helping me at all.\n\nI'm trying, but out of options.\n\nAny help or suggestions appreciated. Objective - picaxe code to generate correct CRC to add to the sent data.\n\nMichael\n\nAssembler?\n\nA bit more info.\n\nThe database guy is assuming i know \"assembler\" language. All i know about \"assembler\" is from this forum and the manual1 p 90, and that is that picaxe is a lot easier than assembler. He's talking about an accumulator, i thought i was doing that by listing all the bytes in poke registers, taking them out one at a time and and XOR adding the two together. (code in previous post) Then Using # on the final variable should output the proper code, but it gives me 91 and not \"cc|\"\n\n{quote}\n\nWhat language is it? I assume Assembler or similar. You might have to load Byte one into accumulator 1 and Byte 2 into accumulator 2 then XOR them. I assume the result would sit in accumulator 1. So then you load byte 3 into accumulator 2 and XOR; Load Byte 3 into accumulator 2 and XOR; … ; until all bytes are completed. The result would be in accumulator 1 &#61672; this is the CRC. Convert it to ASCII and add it to the message.\n\nIf you struggle to determine when the end of the message is: assume the longest possible message and set all bytes to 0x00 then add the message bytes which will leave the not used bytes as 0x00. Then run the above XOR sequence. The 0x00 will affect no changes to the CRC result.\n\n{quote}\n\nI can't see where to next. Any ideas? Could it be something really simple? What he describes sounds easy, i think i'm doing that but i can't get it to work.\n\nMichael\n\nI haven't had much time to study this, but have tried to work through what his code does (which seems to be in C++ which I'm not familiar with, but got help at http://www.cplusplus.com/) . It seems he is scanning the data, WITHOUT commas. He starts by assigning the variable SumInt to the ASCII value of the first byte. Then the For loop interations get the next byte ASCII value and XOR with SumInt, and does this up to but not including the CRC.\n\nHe says the CRC is two bytes. Why it's two and not one I'm not sure, because if you XOR byte values you get byte values not Word values.\n\nThen it seems he adds \"0X\" and the (non-ASCII?) two byte received CRC value to give a 4 byte string. Then uses a StrToDouble function to convert this string to a double value. Then compares this value to the calculated SumInt. Hmmm, not sure what's going on with this 0x bit !\n\nThe devil's in the detail here I expect !\n\nRefinement of Code\n\nData = Eeprom - how could i have missed that, it was only a few pages on and even says data on the index. What a dork i am. Did i mention i'm a beginner?\n\nHippy, I've spent some time trying to combine characters and variables into the DATA command, and could not get it to go, it did not pass the compiler check.\n\nMy fall back was the earlier suggestion of preloading the RAM (peek and poke). with characters and variables, then using a loop to get them back out, use serout (or sertxd) calculating XOR on each increment as i go. The additional lines from Hippys code ( 3 posts earlier) creates the two discrete Hex characters output as ascii. Very clever guys, i can see you have done this sort of thing before.\n\nThe database guy has mentioned the starting character and prefix to the crc (*) from the GPS, but is not using them in this case. When i meet him i'll discuss this, now i've seen hippy's picaxe code i can see it can be done.\n\nBuoyed with the assertion that I have been on a wild goose chase, I have now made up some new code, which has a good chance of working.\n\nI have a picaxe 08M already connected to a DS18B20 temperature sensor and RS232 chip. I'm going to try this code, which works fine in the simulator. It outputs to Picaxe pin 0, which is connected to the RS232 chip:\n\nCode:\n\n#picaxe08m symbol lsd = b7 symbol msd = b8 symbol temp_byte1 = b10 symbol temp_byte2 = b11 symbol temp_byte3 = b12 symbol CRC = b13 Pause 500 'wait for power up. main: 'Preload repeat data bytes into RAM, decimal values from Decimal to accii tables poke 80,0 'value zero poke 81,84 'T poke 82,50 '2 poke 83,83 'S poke 84,44 ', poke 85,68 'D poke 86,65 'A poke 87,84 'T poke 88,65 'A poke 89,44 ', poke 90,116 't poke 91,49 '1 poke 92,44 ', poke 93,32 '(sp) poke 94,32 '(sp) poke 95,46 '. poke 96,32 '(sp) poke 97,44 ', 'read the temp, convert it to ascii and load into the RAM readtemp12 1,w0 w0 = w0*20/32 'convert to temp x 10 bintoascii w0,temp_byte1,temp_byte2,temp_byte3 poke 93,temp_byte1 poke 94,temp_byte2 poke 96,temp_byte3 crc = $00 ' Resets to zero let b9 = 80 ' the first register address (blank) ' now run a loop to get it all out of the ram. do while b9 < 97 b9 = b9 +1 peek b9,temp_byte1 ' Puts value at register address into the temp byte variable CRC = CRC^temp_byte1 ' Increments the CRC XOR calc one byte at a time serout 0, T1200, (temp_byte1) ' Outputs the data in register one byte at a time. loop msd = crc / 16 + \"0\" : If msd > \"9\" Then : msd = msd+7 : End If lsd = crc & $F + \"0\" : If lsd > \"9\" Then : lsd = lsd+7 : End If serout 0, T1200, (msd,lsd,13,10) '# Outputs Ascii representation of CRC, pause 125 goto main\n\nIt outputs T2S,DATA,t1,0.00,7E about once a second.\n\nwhere 0.00 is the temperature in degrees C and 7E is the CRC shown as Ascii, just as he asked.\n\nWhen the Temp varies so does the CRC.\n\nI can put the $ at the front and the * before the CRC easily enough, but i can fool around with all that later on.\n\nSyntax check says 167 bytes, so still room on the picaxe 08m for some more tricks.\n\nAny additional comments or advice welcome!\n\nNothing will happen till at least next week when i see the guy, thanks once again for your assitance, i'll let you know how i get on in the \"real world\".\n\nMichael\n\nWell Done\n\nWell Hippy, you are the man....\n\n:Quote:\n\nIt comes to show that you cannot even trust printed books.\n\nYour CRC routine is working fine and matches mine. On the example I had send the CRC is indeed 91Dec that should be send as 5B in hexadecimal = 2 byte as text-ASCII.\n\nI am also getting the same result of 7E for your example.\n\n:Unquote:\n\nSo the code in the penultimate post (24) works just fine!\n\nHe has suggested to put in the * prior to the CRC because is easier to decode for strings of unknown length. Easily done of course.\n\nI still can't see the eeprom thing, combining text and variables. Youve thrown another TLA (three letter acronym) in there, SFR. I certainly am interested on saving code space because i can use the super versatile 08m, which also saves physical space and looks innocuous. My coding for a raange of outputs has gone over because of using several blocks of text in serout commands, and i'm working on doing that more efficiently. Never had that problem on the 28x1!\n\nThanks again, I'll let you know how the field testing in the real (computer) world goes.\n\nMichael"
    }
}