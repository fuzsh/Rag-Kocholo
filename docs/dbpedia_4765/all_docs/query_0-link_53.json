{
    "id": "dbpedia_4765_0",
    "rank": 53,
    "data": {
        "url": "http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os.html",
        "read_more_link": "",
        "language": "en",
        "title": "PKCS #11 Cryptographic Token Interface Base Specification Version 2.40",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os_files/image001.jpg",
            "http://docs.oasis-open.org/pkcs11/pkcs11-base/v2.40/os/pkcs11-base-v2.40-os_files/image002.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "This document describes the basic PKCS#11 token interface and token behavior.\n\nThe PKCS#11 standard specifies an application programming interface (API), called Cryptoki, for devices that hold cryptographic information and perform cryptographic functions. Cryptoki follows a simple object based approach, addressing the goals of technology independence (any kind of device) and resource sharing (multiple applications accessing multiple devices), presenting to applications a common, logical view of the device called a cryptographic token.\n\nThis document specifies the data types and functions available to an application requiring cryptographic services using the ANSI C programming language. The supplier of a Cryptoki library implementation typically provides these data types and functions via ANSI C header files. Generic ANSI C header files for Cryptoki are available from the PKCS#11 web page. This document and up-to-date errata for Cryptoki will also be available from the same place.\n\nAdditional documents may provide a generic, language-independent Cryptoki interface and/or bindings between Cryptoki and other programming languages.\n\nCryptoki isolates an application from the details of the cryptographic device. The application does not have to change to interface to a different type of device or to run in a different environment; thus, the application is portable. How Cryptoki provides this isolation is beyond the scope of this document, although some conventions for the support of multiple types of device will be addressed here and possibly in a separate document.\n\nDetails of cryptographic mechanisms (algorithms) may be found in the associated PKCS#11 Mechanisms documents.\n\n1.1 Terminology\n\nThe key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL in this document are to be interpreted as described in [RFC2119].\n\n1.2 Definitions\n\nFor the purposes of this standard, the following definitions apply:\n\nAPI Application programming interface.\n\nApplication Any computer program that calls the Cryptoki interface.\n\nASN.1 Abstract Syntax Notation One, as defined in X.680.\n\nAttribute A characteristic of an object.\n\nBER Basic Encoding Rules, as defined in X.690.\n\nCBC Cipher-Block Chaining mode, as defined in FIPS PUB 81.\n\nCertificate A signed message binding a subject name and a public key, or a subject name and a set of attributes.\n\nCMS Cryptographic Message Syntax (see RFC 5652)\n\nCryptographic Device A device storing cryptographic information and possibly performing cryptographic functions. May be implemented as a smart card, smart disk, PCMCIA card, or with some other technology, including software-only.\n\nCryptoki The Cryptographic Token Interface defined in this standard.\n\nCryptoki library A library that implements the functions specified in this standard.\n\nDER Distinguished Encoding Rules, as defined in X.690.\n\nDES Data Encryption Standard, as defined in FIPS PUB 46-3.\n\nDSA Digital Signature Algorithm, as defined in FIPS PUB 186-4.\n\nEC Elliptic Curve\n\nECB Electronic Codebook mode, as defined in FIPS PUB 81.\n\nIV Initialization Vector.\n\nMAC Message Authentication Code.\n\nMechanism A process for implementing a cryptographic operation.\n\nObject An item that is stored on a token. May be data, a certificate, or a key.\n\nPIN Personal Identification Number.\n\nPKCS Public-Key Cryptography Standards.\n\nPRF Pseudo random function.\n\nPTD Personal Trusted Device, as defined in MeT-PTD\n\nRSA The RSA public-key cryptosystem.\n\nReader The means by which information is exchanged with a device.\n\nSession A logical connection between an application and a token.\n\nSlot A logical reader that potentially contains a token.\n\nSSL The Secure Sockets Layer 3.0 protocol.\n\nSubject Name The X.500 distinguished name of the entity to which a key is assigned.\n\nSO A Security Officer user.\n\nTLS Transport Layer Security.\n\nToken The logical view of a cryptographic device defined by Cryptoki.\n\nUser The person using an application that interfaces to Cryptoki.\n\nUTF-8 Universal Character Set (UCS) transformation format (UTF) that represents ISO 10646 and UNICODE strings with a variable number of octets.\n\nWIM Wireless Identification Module.\n\nWTLS Wireless Transport Layer Security.\n\n1.3 Symbols and abbreviations\n\nThe following symbols are used in this standard:\n\nTable 1, Symbols\n\nSymbol\n\nDefinition\n\nN/A\n\nNot applicable\n\nR/O\n\nRead-only\n\nR/W\n\nRead/write\n\nThe following prefixes are used in this standard:\n\nTable 2, Prefixes\n\nCryptoki is based on ANSI C types, and defines the following data types :\n\n/* an unsigned 8-bit value */\n\ntypedef unsigned char CK_BYTE;\n\n/* an unsigned 8-bit character */\n\ntypedef CK_BYTE CK_CHAR;\n\n/* an 8-bit UTF-8 character */\n\ntypedef CK_BYTE CK_UTF8CHAR;\n\n/* a BYTE-sized Boolean flag */\n\ntypedef CK_BYTE CK_BBOOL;\n\n/* an unsigned value, at least 32 bits long */\n\ntypedef unsigned long int CK_ULONG;\n\n/* a signed value, the same size as a CK_ULONG */\n\ntypedef long int CK_LONG;\n\n/* at least 32 bits; each bit is a Boolean flag */\n\ntypedef CK_ULONG CK_FLAGS;\n\nCryptoki also uses pointers to some of these data types, as well as to the type void, which are implementation-dependent. These pointer types are:\n\nCK_BYTE_PTR /* Pointer to a CK_BYTE */\n\nCK_CHAR_PTR /* Pointer to a CK_CHAR */\n\nCK_UTF8CHAR_PTR /* Pointer to a CK_UTF8CHAR */\n\nCK_ULONG_PTR /* Pointer to a CK_ULONG */\n\nCK_VOID_PTR /* Pointer to a void */\n\nCryptoki also defines a pointer to a CK_VOID_PTR, which is implementation-dependent:\n\nCK_VOID_PTR_PTR /* Pointer to a CK_VOID_PTR */\n\nIn addition, Cryptoki defines a C-style NULL pointer, which is distinct from any valid pointer:\n\nNULL_PTR /* A NULL pointer */\n\nIt follows that many of the data and pointer types will vary somewhat from one environment to another (e.g., a CK_ULONG will sometimes be 32 bits, and sometimes perhaps 64 bits). However, these details should not affect an application, assuming it is compiled with Cryptoki header files consistent with the Cryptoki library to which the application is linked.\n\nAll numbers and values expressed in this document are decimal, unless they are preceded by 0x, in which case they are hexadecimal values.\n\nThe CK_CHAR data type holds characters from the following table, taken from ANSI C:\n\nTable 3, Character Set\n\nThe CK_UTF8CHAR data type holds UTF-8 encoded Unicode characters as specified in RFC2279. UTF-8 allows internationalization while maintaining backward compatibility with the Local String definition of PKCS #11 version 2.01.\n\nIn Cryptoki, the CK_BBOOL data type is a Boolean type that can be true or false. A zero value means false, and a nonzero value means true. Similarly, an individual bit flag, CKF_..., can also be set (true) or unset (false). For convenience, Cryptoki defines the following macros for use with values of type CK_BBOOL:\n\n#define CK_FALSE 0\n\n#define CK_TRUE 1\n\nFor backwards compatibility, header files for this version of Cryptoki also define TRUE and FALSE as (CK_DISABLE_TRUE_FALSE may be set by the application vendor):\n\n#ifndef CK_DISABLE_TRUE_FALSE\n\n#ifndef FALSE\n\n#define FALSE CK_FALSE\n\n#endif\n\n#ifndef TRUE\n\n#define TRUE CK_TRUE\n\n#endif\n\n#endif\n\n1.4 Normative References\n\n[FIPS PUB 46-3] NIST. FIPS 46-3: Data Encryption Standard. October 1999.\n\nURL: http://csrc.nist.gov/publications/fips/fips46-3/fips46-3.pdf\n\n[FIPS PUB 81] NIST. FIPS 81: DES Modes of Operation. December 1980.\n\nURL: http://csrc.nist.gov/publications/fips/fips81/fips81.htm\n\n[FIPS PUB 186-4] NIST. FIPS 186-4: Digital Signature Standard. July, 2013.\n\nURL: http://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.186-4.pdf\n\n[PKCS11-Curr] PKCS #11 Cryptographic Token Interface Current Mechanisms Specification Version 2.40. Edited by Susan Gleeson and Chris Zimman. 14 April 2015. OASIS Standard. http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/os/pkcs11-curr-v2.40-os.html. Latest version: http://docs.oasis-open.org/pkcs11/pkcs11-curr/v2.40/pkcs11-curr-v2.40.html.\n\n[PKCS11-Hist] PKCS #11 Cryptographic Token Interface Historical Mechanisms Specification Version 2.40. Edited by Susan Gleeson and Chris Zimman. 14 April 2015. OASIS Standard. http://docs.oasis-open.org/pkcs11/pkcs11-hist/v2.40/os/pkcs11-hist-v2.40-os.html. Latest version: http://docs.oasis-open.org/pkcs11/pkcs11-hist/v2.40/pkcs11-hist-v2.40.html.\n\n[PKCS11-Prof] PKCS #11 Cryptographic Token Interface Profiles Version 2.40. Edited by Tim Hudson. 14 April 2015. OASIS Standard. http://docs.oasis-open.org/pkcs11/pkcs11-profiles/v2.40/os/pkcs11-profiles-v2.40-os.html. Latest version: http://docs.oasis-open.org/pkcs11/pkcs11-profiles/v2.40/pkcs11-profiles-v2.40.html.\n\n[PKCS #1] RSA Laboratories. RSA Cryptography Standard. v2.1, June 14, 2002.\n\nURL: ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-1/pkcs-1v2-1.pdf\n\n[PKCS #3] RSA Laboratories. Diffie-Hellman Key-Agreement Standard. v1.4, November 1993.\n\nURL: ftp://ftp.rsasecurity.com/pub/pkcs/doc/pkcs-3.doc\n\n[PKCS #5] RSA Laboratories. Password-Based Encryption Standard. v2.0, March 25, 1999\n\nURL: ftp://ftp.rsasecurity.com/pub/pkcs/pkcs-5v2/pkcs5v2-0.pdf\n\n[PKCS #7] RSA Laboratories. Cryptographic Message Syntax Standard. v1.5, November 1993\n\nURL : ftp://ftp.rsasecurity.com/pub/pkcs/doc/pkcs-7.doc\n\n[PKCS #8] RSA Laboratories. Private-Key Information Syntax Standard. v1.2, November 1993.\n\nURL: ftp://ftp.rsasecurity.com/pub/pkcs/doc/pkcs-8.doc\n\n[PKCS11-UG]PKCS #11 Cryptographic Token Interface Usage Guide Version 2.40. Edited by John Leiseboer and Robert Griffin. 16 November 2014. OASIS Committee Note 02. http://docs.oasis-open.org/pkcs11/pkcs11-ug/v2.40/cn02/pkcs11-ug-v2.40-cn02.html. Latest version: http://docs.oasis-open.org/pkcs11/pkcs11-ug/v2.40/pkcs11-ug-v2.40.html.\n\n[PKCS #12] RSA Laboratories. Personal Information Exchange Syntax Standard. v1.0, June 1999.\n\n[RFC2119] Bradner, S., Key words for use in RFCs to Indicate Requirement Levels, BCP 14, RFC 2119, March 1997.\n\nURL: http://www.ietf.org/rfc/rfc2119.txt.\n\n[RFC 2279] F. Yergeau. RFC 2279: UTF-8, a transformation format of ISO 10646 Alis Technologies, January 1998. URL: http://www.ietf.org/rfc/rfc2279.txt\n\n[RFC 2534] Masinter, L., Wing, D., Mutz, A., and K. Holtman. RFC 2534: Media Features for Display, Print, and Fax. March 1999. URL: http://www.ietf.org/rfc/rfc2534.txt\n\n[TLS] IETF. RFC 2246: The TLS Protocol Version 1.0 . January 1999.\n\nURL: http://www.ietf.org/rfc/rfc2246.txt\n\n[RFC 5652] R. Housley. RFC 5652: Cryptographic Message Syntax. Septmber 2009. URL: http://www.ietf.org/rfc/rfc5652.txt\n\n[X.500] ITU-T. Information Technology  Open Systems Interconnection  The Directory: Overview of Concepts, Models and Services. February 2001. Identical to ISO/IEC 9594-1\n\n[X.509] ITU-T. Information Technology  Open Systems Interconnection  The Directory: Public-key and Attribute Certificate Frameworks. March 2000.\n\nIdentical to ISO/IEC 9594-8\n\n[X.680] ITU-T. Information Technology  Abstract Syntax Notation One (ASN.1): Specification of Basic Notation. July 2002.\n\nIdentical to ISO/IEC 8824-1\n\n[X.690] ITU-T. Information Technology  ASN.1 Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and Distinguished Encoding Rules (DER). July 2002.\n\nIdentical to ISO/IEC 8825-1\n\n1.5 Non-Normative References\n\n[ANSI C] ANSI/ISO. American National Standard for Programming Languages  C. 1990.\n\n[CC/PP] W3C. Composite Capability/Preference Profiles (CC/PP): Structure and Vocabularies. World Wide Web Consortium, January 2004.\n\nURL: http://www.w3.org/TR/CCPP-struct-vocab/\n\n[CDPD] Ameritech Mobile Communications et al. Cellular Digital Packet Data System Specifications: Part 406: Airlink Security. 1993.\n\n[GCS-API] X/Open Company Ltd. Generic Cryptographic Service API (GCS-API), Base - Draft 2. February 14, 1995.\n\n[ISO/IEC 7816-1] ISO. Information Technology  Identification Cards  Integrated Circuit(s) with Contacts  Part 1: Physical Characteristics. 1998.\n\n[ISO/IEC 7816-4] ISO. Information Technology  Identification Cards  Integrated Circuit(s) with Contacts  Part 4: Interindustry Commands for Interchange. 1995.\n\n[ISO/IEC 8824-1] ISO. Information Technology-- Abstract Syntax Notation One (ASN.1): Specification of Basic Notation. 2002.\n\n[ISO/IEC 8825-1] ISO. Information TechnologyASN.1 Encoding Rules: Specification of Basic Encoding Rules (BER), Canonical Encoding Rules (CER), and Distinguished Encoding Rules (DER). 2002.\n\n[ISO/IEC 9594-1] ISO. Information Technology  Open Systems Interconnection  The Directory: Overview of Concepts, Models and Services. 2001.\n\n[ISO/IEC 9594-8] ISO. Information Technology  Open Systems Interconnection  The Directory: Public-key and Attribute Certificate Frameworks. 2001\n\n[ISO/IEC 9796-2] ISO. Information Technology  Security Techniques  Digital Signature Scheme Giving Message Recovery  Part 2: Integer factorization based mechanisms. 2002.\n\n[Java MIDP] Java Community Process. Mobile Information Device Profile for Java 2 Micro Edition. November 2002.\n\nURL: http://jcp.org/jsr/detail/118.jsp\n\n[MeT-PTD] MeT. MeT PTD Definition  Personal Trusted Device Definition, Version 1.0, February 2003.\n\nURL: http://www.mobiletransaction.org\n\n[PCMCIA] Personal Computer Memory Card International Association. PC Card Standard, Release 2.1,. July 1993.\n\n[SEC 1] Standards for Efficient Cryptography Group (SECG). Standards for Efficient Cryptography (SEC) 1: Elliptic Curve Cryptography. Version 1.0, September 20, 2000.\n\n[SEC 2] Standards for Efficient Cryptography Group (SECG). Standards for Efficient Cryptography (SEC) 2: Recommended Elliptic Curve Domain Parameters. Version 1.0, September 20, 2000.\n\n[WIM] WAP. Wireless Identity Module.  WAP-260-WIM-20010712-a. July 2001.\n\nURL: http://technical.openmobilealliance.org/tech/affiliates/LicenseAgreement.asp?DocName=/wap/wap-260-wim-20010712-a.pdf\n\n[WPKI] Wireless Application Protocol: Public Key Infrastructure Definition.  WAP-217-WPKI-20010424-a. April 2001.\n\nURL: http://technical.openmobilealliance.org/tech/affiliates/LicenseAgreement.asp?DocName=/wap/wap-217-wpki-20010424-a.pdf\n\n[WTLS] WAP. Wireless Transport Layer Security Version  WAP-261-WTLS-20010406-a. April 2001.\n\nURL: http://technical.openmobilealliance.org/tech/affiliates/LicenseAgreement.asp?DocName=/wap/wap-261-wtls-20010406-a.pdf\n\nThere is a large array of Cryptoki-related data types that are defined in the Cryptoki header files. Certain packing and pointer-related aspects of these types are platform and compiler-dependent; these aspects are therefore resolved on a platform-by-platform (or compiler-by-compiler) basis outside of the Cryptoki header files by means of preprocessor directives.\n\nThis means that when writing C or C++ code, certain preprocessor directives MUST be issued before including a Cryptoki header file. These directives are described in the remainder of Section 6.\n\n2.1 Structure packing\n\nCryptoki structures are packed to occupy as little space as is possible. Cryptoki structures SHALL be packed with 1-byte alignment.\n\n2.2 Pointer-related macros\n\nBecause different platforms and compilers have different ways of dealing with different types of pointers, the following 6 macros SHALL be set outside the scope of Cryptoki:\n\n¨CK_PTR\n\nCK_PTR is the indirection string a given platform and compiler uses to make a pointer to an object. It is used in the following fashion:\n\ntypedef CK_BYTE CK_PTR CK_BYTE_PTR;\n\n¨CK_DEFINE_FUNCTION\n\nCK_DEFINE_FUNCTION(returnType, name), when followed by a parentheses-enclosed list of arguments and a function definition, defines a Cryptoki API function in a Cryptoki library. returnType is the return type of the function, and name is its name. It SHALL be used in the following fashion:\n\nCK_DEFINE_FUNCTION(CK_RV, C_Initialize)(\n\nCK_VOID_PTR pReserved\n\n)\n\n{\n\n...\n\n}\n\n¨CK_DECLARE_FUNCTION\n\nCK_DECLARE_FUNCTION(returnType, name), when followed by a parentheses-enclosed list of arguments and a semicolon, declares a Cryptoki API function in a Cryptoki library. returnType is the return type of the function, and name is its name. It SHALL be used in the following fashion:\n\nCK_DECLARE_FUNCTION(CK_RV, C_Initialize)(\n\nCK_VOID_PTR pReserved\n\n);\n\n¨CK_DECLARE_FUNCTION_POINTER\n\nCK_DECLARE_FUNCTION_POINTER(returnType, name), when followed by a parentheses-enclosed list of arguments and a semicolon, declares a variable or type which is a pointer to a Cryptoki API function in a Cryptoki library. returnType is the return type of the function, and name is its name. It SHALL be used in either of the following fashions to define a function pointer variable, myC_Initialize, which can point to a C_Initialize function in a Cryptoki library (note that neither of the following code snippets actually assigns a value to myC_Initialize):\n\nCK_DECLARE_FUNCTION_POINTER(CK_RV, myC_Initialize)(\n\nCK_VOID_PTR pReserved\n\n);\n\nor:\n\ntypedef CK_DECLARE_FUNCTION_POINTER(CK_RV, myC_InitializeType)(\n\nCK_VOID_PTR pReserved\n\n);\n\nmyC_InitializeType myC_Initialize;\n\n¨CK_CALLBACK_FUNCTION\n\nCK_CALLBACK_FUNCTION(returnType, name), when followed by a parentheses-enclosed list of arguments and a semicolon, declares a variable or type which is a pointer to an application callback function that can be used by a Cryptoki API function in a Cryptoki library. returnType is the return type of the function, and name is its name. It SHALL be used in either of the following fashions to define a function pointer variable, myCallback, which can point to an application callback which takes arguments args and returns a CK_RV (note that neither of the following code snippets actually assigns a value to myCallback):\n\nCK_CALLBACK_FUNCTION(CK_RV, myCallback)(args);\n\nor:\n\ntypedef CK_CALLBACK_FUNCTION(CK_RV, myCallbackType)(args);\n\nmyCallbackType myCallback;\n\n¨NULL_PTR\n\nNULL_PTR is the value of a NULL pointer. In any ANSI C environmentand in many others as wellNULL_PTR SHALL be defined simply as 0.\n\nThe general Cryptoki data types are described in the following subsections. The data types for holding parameters for various mechanisms, and the pointers to those parameters, are not described here; these types are described with the information on the mechanisms themselves, in Section 12.\n\nA C or C++ source file in a Cryptoki application or library can define all these types (the types described here and the types that are specifically used for particular mechanism parameters) by including the top-level Cryptoki include file, pkcs11.h. pkcs11.h, in turn, includes the other Cryptoki include files, pkcs11t.h and pkcs11f.h. A source file can also include just pkcs11t.h (instead of pkcs11.h); this defines most (but not all) of the types specified here.\n\nWhen including either of these header files, a source file MUST specify the preprocessor directives indicated in Section 2.\n\n3.1 General information\n\nCryptoki represents general information with the following types:\n\n¨CK_VERSION; CK_VERSION_PTR\n\nCK_VERSION is a structure that describes the version of a Cryptoki interface, a Cryptoki library, or an SSL implementation, or the hardware or firmware version of a slot or token. It is defined as follows:\n\ntypedef struct CK_VERSION {\n\nCK_BYTE major;\n\nCK_BYTE minor;\n\n} CK_VERSION;\n\nThe fields of the structure have the following meanings:\n\nmajor major version number (the integer portion of the version)\n\nminor minor version number (the hundredths portion of the version)\n\nExample: For version 1.0, major = 1 and minor = 0. For version 2.10, major = 2 and minor = 10. Table 4 below lists the major and minor version values for the officially published Cryptoki specifications.\n\nTable 4, Major and minor version values for published Cryptoki specifications\n\nVersion\n\nmajor\n\nminor\n\n1.0\n\n0x01\n\n0x00\n\n2.01\n\n0x02\n\n0x01\n\n2.10\n\n0x02\n\n0x0a\n\n2.11\n\n0x02\n\n0x0b\n\n2.20\n\n0x02\n\n0x14\n\n2.30\n\n0x02\n\n0x1e\n\n2.40\n\n0x02\n\n0x28\n\nMinor revisions of the Cryptoki standard are always upwardly compatible within the same major version number.\n\nCK_VERSION_PTR is a pointer to a CK_VERSION.\n\n¨CK_INFO; CK_INFO_PTR\n\nCK_INFO provides general information about Cryptoki. It is defined as follows:\n\ntypedef struct CK_INFO {\n\nCK_VERSION cryptokiVersion;\n\nCK_UTF8CHAR manufacturerID[32];\n\nCK_FLAGS flags;\n\nCK_UTF8CHAR libraryDescription[32];\n\nCK_VERSION libraryVersion;\n\n} CK_INFO;\n\nThe fields of the structure have the following meanings:\n\ncryptokiVersion Cryptoki interface version number, for compatibility with future revisions of this interface\n\nmanufacturerID ID of the Cryptoki library manufacturer. MUST be padded with the blank character ( ). Should not be null-terminated.\n\nflags bit flags reserved for future versions. MUST be zero for this version\n\nlibraryDescription character-string description of the library. MUST be padded with the blank character ( ). Should not be null-terminated.\n\nlibraryVersion Cryptoki library version number\n\nFor libraries written to this document, the value of cryptokiVersion should match the version of this specification; the value of libraryVersion is the version number of the library software itself.\n\nCK_INFO_PTR is a pointer to a CK_INFO.\n\n¨CK_NOTIFICATION\n\nCK_NOTIFICATION holds the types of notifications that Cryptoki provides to an application. It is defined as follows:\n\ntypedef CK_ULONG CK_NOTIFICATION;\n\nFor this version of Cryptoki, the following types of notifications are defined:\n\nCKN_SURRENDER\n\nThe notifications have the following meanings:\n\nCKN_SURRENDER Cryptoki is surrendering the execution of a function executing in a session so that the application may perform other operations. After performing any desired operations, the application should indicate to Cryptoki whether to continue or cancel the function (see Section 5.16.1).\n\n3.2 Slot and token types\n\nCryptoki represents slot and token information with the following types:\n\n¨CK_SLOT_ID; CK_SLOT_ID_PTR\n\nCK_SLOT_ID is a Cryptoki-assigned value that identifies a slot. It is defined as follows:\n\ntypedef CK_ULONG CK_SLOT_ID;\n\nA list of CK_SLOT_IDs is returned by C_GetSlotList. A priori, any value of CK_SLOT_ID can be a valid slot identifierin particular, a system may have a slot identified by the value 0. It need not have such a slot, however.\n\nCK_SLOT_ID_PTR is a pointer to a CK_SLOT_ID.\n\n¨CK_SLOT_INFO; CK_SLOT_INFO_PTR\n\nCK_SLOT_INFO provides information about a slot. It is defined as follows:\n\ntypedef struct CK_SLOT_INFO {\n\nCK_UTF8CHAR slotDescription[64];\n\nCK_UTF8CHAR manufacturerID[32];\n\nCK_FLAGS flags;\n\nCK_VERSION hardwareVersion;\n\nCK_VERSION firmwareVersion;\n\n} CK_SLOT_INFO;\n\nThe fields of the structure have the following meanings:\n\nslotDescription character-string description of the slot. MUST be padded with the blank character ( ). MUST NOT be null-terminated.\n\nmanufacturerID ID of the slot manufacturer. MUST be padded with the blank character ( ). MUST NOT be null-terminated.\n\nflags bits flags that provide capabilities of the slot. The flags are defined below\n\nhardwareVersion version number of the slots hardware\n\nfirmwareVersion version number of the slots firmware\n\nThe following table defines the flags field:\n\nTable 5, Slot Information Flags\n\nFor a given slot, the value of the CKF_REMOVABLE_DEVICE flag never changes. In addition, if this flag is not set for a given slot, then the CKF_TOKEN_PRESENT flag for that slot is always set. That is, if a slot does not support a removable device, then that slot always has a token in it.\n\nCK_SLOT_INFO_PTR is a pointer to a CK_SLOT_INFO.\n\n¨CK_TOKEN_INFO; CK_TOKEN_INFO_PTR\n\nCK_TOKEN_INFO provides information about a token. It is defined as follows:\n\ntypedef struct CK_TOKEN_INFO {\n\nCK_UTF8CHAR label[32];\n\nCK_UTF8CHAR manufacturerID[32];\n\nCK_UTF8CHAR model[16];\n\nCK_CHAR serialNumber[16];\n\nCK_FLAGS flags;\n\nCK_ULONG ulMaxSessionCount;\n\nCK_ULONG ulSessionCount;\n\nCK_ULONG ulMaxRwSessionCount;\n\nCK_ULONG ulRwSessionCount;\n\nCK_ULONG ulMaxPinLen;\n\nCK_ULONG ulMinPinLen;\n\nCK_ULONG ulTotalPublicMemory;\n\nCK_ULONG ulFreePublicMemory;\n\nCK_ULONG ulTotalPrivateMemory;\n\nCK_ULONG ulFreePrivateMemory;\n\nCK_VERSION hardwareVersion;\n\nCK_VERSION firmwareVersion;\n\nCK_CHAR utcTime[16];\n\n} CK_TOKEN_INFO;\n\nThe fields of the structure have the following meanings:\n\nlabel application-defined label, assigned during token initialization. MUST be padded with the blank character ( ). MUST NOT be null-terminated.\n\nmanufacturerID ID of the device manufacturer. MUST be padded with the blank character ( ). MUST NOT be null-terminated.\n\nmodel model of the device. MUST be padded with the blank character ( ). MUST NOT be null-terminated.\n\nserialNumber character-string serial number of the device. MUST be padded with the blank character ( ). MUST NOT be null-terminated.\n\nflags bit flags indicating capabilities and status of the device as defined below\n\nulMaxSessionCount maximum number of sessions that can be opened with the token at one time by a single application (see CK_TOKEN_INFO Note below)\n\nulSessionCount number of sessions that this application currently has open with the token (see CK_TOKEN_INFO Note below)\n\nulMaxRwSessionCount maximum number of read/write sessions that can be opened with the token at one time by a single application (see CK_TOKEN_INFO Note below)\n\nulRwSessionCount number of read/write sessions that this application currently has open with the token (see CK_TOKEN_INFO Note below)\n\nulMaxPinLen maximum length in bytes of the PIN\n\nulMinPinLen minimum length in bytes of the PIN\n\nulTotalPublicMemory the total amount of memory on the token in bytes in which public objects may be stored (see CK_TOKEN_INFO Note below)\n\nulFreePublicMemory the amount of free (unused) memory on the token in bytes for public objects (see CK_TOKEN_INFO Note below)\n\nulTotalPrivateMemory the total amount of memory on the token in bytes in which private objects may be stored (see CK_TOKEN_INFO Note below)\n\nulFreePrivateMemory the amount of free (unused) memory on the token in bytes for private objects (see CK_TOKEN_INFO Note below)\n\nhardwareVersion version number of hardware\n\nfirmwareVersion version number of firmware\n\nutcTime current time as a character-string of length 16, represented in the format YYYYMMDDhhmmssxx (4 characters for the year; 2 characters each for the month, the day, the hour, the minute, and the second; and 2 additional reserved 0 characters). The value of this field only makes sense for tokens equipped with a clock, as indicated in the token information flags (see below)\n\nThe following table defines the flags field:\n\nTable 6, Token Information Flags\n\nExactly what the CKF_WRITE_PROTECTED flag means is not specified in Cryptoki. An application may be unable to perform certain actions on a write-protected token; these actions can include any of the following, among others:\n\n· Creating/modifying/deleting any object on the token.\n\n· Creating/modifying/deleting a token object on the token.\n\n· Changing the SOs PIN.\n\n· Changing the normal users PIN.\n\nThe token may change the value of the CKF_WRITE_PROTECTED flag depending on the session state to implement its object management policy. For instance, the token may set the CKF_WRITE_PROTECTED flag unless the session state is R/W SO or R/W User to implement a policy that does not allow any objects, public or private, to be created, modified, or deleted unless the user has successfully called C_Login.\n\nThe CKF_USER_PIN_COUNT_LOW, CKF_USER_PIN_COUNT_LOW, CKF_USER_PIN_FINAL_TRY, and CKF_SO_PIN_FINAL_TRY flags may always be set to false if the token does not support the functionality or will not reveal the information because of its security policy.\n\nThe CKF_USER_PIN_TO_BE_CHANGED and CKF_SO_PIN_TO_BE_CHANGED flags may always be set to false if the token does not support the functionality. If a PIN is set to the default value, or has expired, the appropriate CKF_USER_PIN_TO_BE_CHANGED or CKF_SO_PIN_TO_BE_CHANGED flag is set to true. When either of these flags are true, logging in with the corresponding PIN will succeed, but only the C_SetPIN function can be called. Calling any other function that required the user to be logged in will cause CKR_PIN_EXPIRED to be returned until C_SetPIN is called successfully.\n\nCK_TOKEN_INFO Note: The fields ulMaxSessionCount, ulSessionCount, ulMaxRwSessionCount, ulRwSessionCount, ulTotalPublicMemory, ulFreePublicMemory, ulTotalPrivateMemory, and ulFreePrivateMemory can have the special value CK_UNAVAILABLE_INFORMATION, which means that the token and/or library is unable or unwilling to provide that information. In addition, the fields ulMaxSessionCount and ulMaxRwSessionCount can have the special value CK_EFFECTIVELY_INFINITE, which means that there is no practical limit on the number of sessions (resp. R/W sessions) an application can have open with the token.\n\nIt is important to check these fields for these special values. This is particularly true for CK_EFFECTIVELY_INFINITE, since an application seeing this value in the ulMaxSessionCount or ulMaxRwSessionCount field would otherwise conclude that it cant open any sessions with the token, which is far from being the case.\n\nThe upshot of all this is that the correct way to interpret (for example) the ulMaxSessionCount field is something along the lines of the following:\n\nCK_TOKEN_INFO info;\n\n.\n\n.\n\nif ((CK_LONG) info.ulMaxSessionCount\n\n== CK_UNAVAILABLE_INFORMATION) {\n\n/* Token refuses to give value of ulMaxSessionCount */\n\n.\n\n.\n\n} else if (info.ulMaxSessionCount == CK_EFFECTIVELY_INFINITE) {\n\n/* Application can open as many sessions as it wants */\n\n.\n\n.\n\n} else {\n\n/* ulMaxSessionCount really does contain what it should */\n\n.\n\n.\n\n}\n\nCK_TOKEN_INFO_PTR is a pointer to a CK_TOKEN_INFO.\n\n3.3 Session types\n\nCryptoki represents session information with the following types:\n\n¨CK_SESSION_HANDLE; CK_SESSION_HANDLE_PTR\n\nCK_SESSION_HANDLE is a Cryptoki-assigned value that identifies a session. It is defined as follows:\n\ntypedef CK_ULONG CK_SESSION_HANDLE;\n\nValid session handles in Cryptoki always have nonzero values. For developers convenience, Cryptoki defines the following symbolic value:\n\nCK_INVALID_HANDLE\n\nCK_SESSION_HANDLE_PTR is a pointer to a CK_SESSION_HANDLE.\n\n¨CK_USER_TYPE\n\nCK_USER_TYPE holds the types of Cryptoki users described in [PKCS11-UG] and, in addition, a context-specific type described in Section 4.9. It is defined as follows:\n\ntypedef CK_ULONG CK_USER_TYPE;\n\nFor this version of Cryptoki, the following types of users are defined:\n\nCKU_SO\n\nCKU_USER\n\nCKU_CONTEXT_SPECIFIC\n\n¨CK_STATE\n\nCK_STATE holds the session state, as described in [PKCS11-UG]. It is defined as follows:\n\ntypedef CK_ULONG CK_STATE;\n\nFor this version of Cryptoki, the following session states are defined:\n\nCKS_RO_PUBLIC_SESSION\n\nCKS_RO_USER_FUNCTIONS\n\nCKS_RW_PUBLIC_SESSION\n\nCKS_RW_USER_FUNCTIONS\n\nCKS_RW_SO_FUNCTIONS\n\n¨CK_SESSION_INFO; CK_SESSION_INFO_PTR\n\nCK_SESSION_INFO provides information about a session. It is defined as follows:\n\ntypedef struct CK_SESSION_INFO {\n\nCK_SLOT_ID slotID;\n\nCK_STATE state;\n\nCK_FLAGS flags;\n\nCK_ULONG ulDeviceError;\n\n} CK_SESSION_INFO;\n\nThe fields of the structure have the following meanings:\n\nslotID ID of the slot that interfaces with the token\n\nstate the state of the session\n\nflags bit flags that define the type of session; the flags are defined below\n\nulDeviceError an error code defined by the cryptographic device. Used for errors not covered by Cryptoki.\n\nThe following table defines the flags field:\n\nTable 7, Session Information Flags\n\nCK_SESSION_INFO_PTR is a pointer to a CK_SESSION_INFO.\n\n3.4 Object types\n\nCryptoki represents object information with the following types:\n\n¨CK_OBJECT_HANDLE; CK_OBJECT_HANDLE_PTR\n\nCK_OBJECT_HANDLE is a token-specific identifier for an object. It is defined as follows:\n\ntypedef CK_ULONG CK_OBJECT_HANDLE;\n\nWhen an object is created or found on a token by an application, Cryptoki assigns it an object handle for that applications sessions to use to access it. A particular object on a token does not necessarily have a handle which is fixed for the lifetime of the object; however, if a particular session can use a particular handle to access a particular object, then that session will continue to be able to use that handle to access that object as long as the session continues to exist, the object continues to exist, and the object continues to be accessible to the session.\n\nValid object handles in Cryptoki always have nonzero values. For developers convenience, Cryptoki defines the following symbolic value:\n\nCK_INVALID_HANDLE\n\nCK_OBJECT_HANDLE_PTR is a pointer to a CK_OBJECT_HANDLE.\n\n¨CK_OBJECT_CLASS; CK_OBJECT_CLASS_PTR\n\nCK_OBJECT_CLASS is a value that identifies the classes (or types) of objects that Cryptoki recognizes. It is defined as follows:\n\ntypedef CK_ULONG CK_OBJECT_CLASS;\n\nObject classes are defined with the objects that use them. The type is specified on an object through the CKA_CLASS attribute of the object.\n\nVendor defined values for this type may also be specified.\n\nCKO_VENDOR_ DEFINED\n\nObject classes CKO_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their object classes through the PKCS process.\n\nCK_OBJECT_CLASS_PTR is a pointer to a CK_OBJECT_CLASS.\n\n¨CK_HW_FEATURE_TYPE\n\nCK_HW_FEATURE_TYPE is a value that identifies a hardware feature type of a device. It is defined as follows:\n\ntypedef CK_ULONG CK_HW_FEATURE_TYPE;\n\nHardware feature types are defined with the objects that use them. The type is specified on an object through the CKA_HW_FEATURE_TYPE attribute of the object.\n\nVendor defined values for this type may also be specified.\n\nCKH_VENDOR_DEFINED\n\nFeature types CKH_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their feature types through the PKCS process.\n\n¨CK_KEY_TYPE\n\nCK_KEY_TYPE is a value that identifies a key type. It is defined as follows:\n\ntypedef CK_ULONG CK_KEY_TYPE;\n\nKey types are defined with the objects and mechanisms that use them. The key type is specified on an object through the CKA_KEY_TYPE attribute of the object.\n\nVendor defined values for this type may also be specified.\n\nCKK_VENDOR_DEFINED\n\nKey types CKK_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their key types through the PKCS process.\n\n¨CK_CERTIFICATE_TYPE\n\nCK_CERTIFICATE_TYPE is a value that identifies a certificate type. It is defined as follows:\n\ntypedef CK_ULONG CK_CERTIFICATE_TYPE;\n\nCertificate types are defined with the objects and mechanisms that use them. The certificate type is specified on an object through the CKA_CERTIFICATE_TYPE attribute of the object.\n\nVendor defined values for this type may also be specified.\n\nCKC_VENDOR_DEFINED\n\nCertificate types CKC_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their certificate types through the PKCS process.\n\n¨ CK_CERTIFICATE_CATEGORY\n\nCK_CERTIFICATE_CATEGORY is a value that identifies a certificate category. It is defined as follows:\n\ntypedef CK_ULONG CK_CERTIFICATE_CATEGORY;\n\nFor this version of Cryptoki, the following certificate categories are defined:\n\n¨CK_ATTRIBUTE_TYPE\n\nCK_ATTRIBUTE_TYPE is a value that identifies an attribute type. It is defined as follows:\n\ntypedef CK_ULONG CK_ATTRIBUTE_TYPE;\n\nAttributes are defined with the objects and mechanisms that use them. Attributes are specified on an object as a list of type, length value items. These are often specified as an attribute template.\n\nVendor defined values for this type may also be specified.\n\nCKA_VENDOR_DEFINED\n\nAttribute types CKA_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their attribute types through the PKCS process.\n\n¨CK_ATTRIBUTE; CK_ATTRIBUTE_PTR\n\nCK_ATTRIBUTE is a structure that includes the type, value, and length of an attribute. It is defined as follows:\n\ntypedef struct CK_ATTRIBUTE {\n\nCK_ATTRIBUTE_TYPE type;\n\nCK_VOID_PTR pValue;\n\nCK_ULONG ulValueLen;\n\n} CK_ATTRIBUTE;\n\nThe fields of the structure have the following meanings:\n\ntype the attribute type\n\npValue pointer to the value of the attribute\n\nulValueLen length in bytes of the value\n\nIf an attribute has no value, then ulValueLen = 0, and the value of pValue is irrelevant. An array of CK_ATTRIBUTEs is called a template and is used for creating, manipulating and searching for objects. The order of the attributes in a template never matters, even if the template contains vendor-specific attributes. Note that pValue is a void pointer, facilitating the passing of arbitrary values. Both the application and Cryptoki library MUST ensure that the pointer can be safely cast to the expected type (i.e., without word-alignment errors).\n\nThe constant CK_UNAVAILABLE_INFORMATION is used in the ulValueLen field to denote an invalid or unavailable value. See C_GetAttributeValue for further details.\n\nCK_ATTRIBUTE_PTR is a pointer to a CK_ATTRIBUTE.\n\n¨CK_DATE\n\nCK_DATE is a structure that defines a date. It is defined as follows:\n\ntypedef struct CK_DATE {\n\nCK_CHAR year[4];\n\nCK_CHAR month[2];\n\nCK_CHAR day[2];\n\n} CK_DATE;\n\nThe fields of the structure have the following meanings:\n\nyear the year (1900 - 9999)\n\nmonth the month (01 - 12)\n\nday the day (01 - 31)\n\nThe fields hold numeric characters from the character set in Table 3, not the literal byte values.\n\nWhen a Cryptoki object carries an attribute of this type, and the default value of the attribute is specified to be \"empty,\" then Cryptoki libraries SHALL set the attribute's ulValueLen to 0.\n\nNote that implementations of previous versions of Cryptoki may have used other methods to identify an \"empty\" attribute of type CK_DATE, and applications that needs to interoperate with these libraries therefore have to be flexible in what they accept as an empty value.\n\n¨ CK_JAVA_MIDP_SECURITY_DOMAIN\n\nCK_JAVA_MIDP_SECURITY_DOMAIN is a value that identifies the Java MIDP security domain of a certificate. It is defined as follows:\n\ntypedef CK_ULONG CK_JAVA_MIDP_SECURITY_DOMAIN;\n\nFor this version of Cryptoki, the following security domains are defined. See the Java MIDP specification for further information:\n\nConstant\n\nValue\n\nMeaning\n\nCK_SECURITY_DOMAIN_UNSPECIFIED\n\n0x00000000UL\n\nNo domain specified\n\nCK_SECURITY_DOMAIN_MANUFACTURER\n\n0x00000001UL\n\nManufacturer protection domain\n\nCK_SECURITY_DOMAIN_OPERATOR\n\n0x00000002UL\n\nOperator protection domain\n\nCK_SECURITY_DOMAIN_THIRD_PARTY\n\n0x00000003UL\n\nThird party protection domain\n\n3.5 Data types for mechanisms\n\nCryptoki supports the following types for describing mechanisms and parameters to them:\n\n¨CK_MECHANISM_TYPE; CK_MECHANISM_TYPE_PTR\n\nCK_MECHANISM_TYPE is a value that identifies a mechanism type. It is defined as follows:\n\ntypedef CK_ULONG CK_MECHANISM_TYPE;\n\nMechanism types are defined with the objects and mechanism descriptions that use them.\n\nVendor defined values for this type may also be specified.\n\nCKM_VENDOR_DEFINED\n\nMechanism types CKM_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their mechanism types through the PKCS process.\n\nCK_MECHANISM_TYPE_PTR is a pointer to a CK_MECHANISM_TYPE.\n\n¨CK_MECHANISM; CK_MECHANISM_PTR\n\nCK_MECHANISM is a structure that specifies a particular mechanism and any parameters it requires. It is defined as follows:\n\ntypedef struct CK_MECHANISM {\n\nCK_MECHANISM_TYPE mechanism;\n\nCK_VOID_PTR pParameter;\n\nCK_ULONG ulParameterLen;\n\n} CK_MECHANISM;\n\nThe fields of the structure have the following meanings:\n\nmechanism the type of mechanism\n\npParameter pointer to the parameter if required by the mechanism\n\nulParameterLen length in bytes of the parameter\n\nNote that pParameter is a void pointer, facilitating the passing of arbitrary values. Both the application and the Cryptoki library MUST ensure that the pointer can be safely cast to the expected type (i.e., without word-alignment errors).\n\nCK_MECHANISM_PTR is a pointer to a CK_MECHANISM.\n\n¨CK_MECHANISM_INFO; CK_MECHANISM_INFO_PTR\n\nCK_MECHANISM_INFO is a structure that provides information about a particular mechanism. It is defined as follows:\n\ntypedef struct CK_MECHANISM_INFO {\n\nCK_ULONG ulMinKeySize;\n\nCK_ULONG ulMaxKeySize;\n\nCK_FLAGS flags;\n\n} CK_MECHANISM_INFO;\n\nThe fields of the structure have the following meanings:\n\nulMinKeySize the minimum size of the key for the mechanism (whether this is measured in bits or in bytes is mechanism-dependent)\n\nulMaxKeySize the maximum size of the key for the mechanism (whether this is measured in bits or in bytes is mechanism-dependent)\n\nflags bit flags specifying mechanism capabilities\n\nFor some mechanisms, the ulMinKeySize and ulMaxKeySize fields have meaningless values.\n\nThe following table defines the flags field:\n\nTable 8, Mechanism Information Flags\n\nCK_MECHANISM_INFO_PTR is a pointer to a CK_MECHANISM_INFO.\n\n3.6 Function types\n\nCryptoki represents information about functions with the following data types:\n\n¨CK_RV\n\nCK_RV is a value that identifies the return value of a Cryptoki function. It is defined as follows:\n\ntypedef CK_ULONG CK_RV;\n\nVendor defined values for this type may also be specified.\n\nCKR_VENDOR_DEFINED\n\nSection 5.1 defines the meaning of each CK_RV value. Return values CKR_VENDOR_DEFINED and above are permanently reserved for token vendors. For interoperability, vendors should register their return values through the PKCS process.\n\n¨CK_NOTIFY\n\nCK_NOTIFY is the type of a pointer to a function used by Cryptoki to perform notification callbacks. It is defined as follows:\n\ntypedef CK_CALLBACK_FUNCTION(CK_RV, CK_NOTIFY)(\n\nCK_SESSION_HANDLE hSession,\n\nCK_NOTIFICATION event,\n\nCK_VOID_PTR pApplication\n\n);\n\nThe arguments to a notification callback function have the following meanings:\n\nhSession The handle of the session performing the callback\n\nevent The type of notification callback\n\npApplication An application-defined value. This is the same value as was passed to C_OpenSession to open the session performing the callback\n\n¨CK_C_XXX\n\nCryptoki also defines an entire family of other function pointer types. For each function C_XXX in the Cryptoki API (see Section 4.12 for detailed information about each of them), Cryptoki defines a type CK_C_XXX, which is a pointer to a function with the same arguments and return value as C_XXX has. An appropriately-set variable of type CK_C_XXX may be used by an application to call the Cryptoki function C_XXX.\n\n¨CK_FUNCTION_LIST; CK_FUNCTION_LIST_PTR; CK_FUNCTION_LIST_PTR_PTR\n\nCK_FUNCTION_LIST is a structure which contains a Cryptoki version and a function pointer to each function in the Cryptoki API. It is defined as follows:\n\ntypedef struct CK_FUNCTION_LIST {\n\nCK_VERSION version;\n\nCK_C_Initialize C_Initialize;\n\nCK_C_Finalize C_Finalize;\n\nCK_C_GetInfo C_GetInfo;\n\nCK_C_GetFunctionList C_GetFunctionList;\n\nCK_C_GetSlotList C_GetSlotList;\n\nCK_C_GetSlotInfo C_GetSlotInfo;\n\nCK_C_GetTokenInfo C_GetTokenInfo;\n\nCK_C_GetMechanismList C_GetMechanismList;\n\nCK_C_GetMechanismInfo C_GetMechanismInfo;\n\nCK_C_InitToken C_InitToken;\n\nCK_C_InitPIN C_InitPIN;\n\nCK_C_SetPIN C_SetPIN;\n\nCK_C_OpenSession C_OpenSession;\n\nCK_C_CloseSession C_CloseSession;\n\nCK_C_CloseAllSessions C_CloseAllSessions;\n\nCK_C_GetSessionInfo C_GetSessionInfo;\n\nCK_C_GetOperationState C_GetOperationState;\n\nCK_C_SetOperationState C_SetOperationState;\n\nCK_C_Login C_Login;\n\nCK_C_Logout C_Logout;\n\nCK_C_CreateObject C_CreateObject;\n\nCK_C_CopyObject C_CopyObject;\n\nCK_C_DestroyObject C_DestroyObject;\n\nCK_C_GetObjectSize C_GetObjectSize;\n\nCK_C_GetAttributeValue C_GetAttributeValue;\n\nCK_C_SetAttributeValue C_SetAttributeValue;\n\nCK_C_FindObjectsInit C_FindObjectsInit;\n\nCK_C_FindObjects C_FindObjects;\n\nCK_C_FindObjectsFinal C_FindObjectsFinal;\n\nCK_C_EncryptInit C_EncryptInit;\n\nCK_C_Encrypt C_Encrypt;\n\nCK_C_EncryptUpdate C_EncryptUpdate;\n\nCK_C_EncryptFinal C_EncryptFinal;\n\nCK_C_DecryptInit C_DecryptInit;\n\nCK_C_Decrypt C_Decrypt;\n\nCK_C_DecryptUpdate C_DecryptUpdate;\n\nCK_C_DecryptFinal C_DecryptFinal;\n\nCK_C_DigestInit C_DigestInit;\n\nCK_C_Digest C_Digest;\n\nCK_C_DigestUpdate C_DigestUpdate;\n\nCK_C_DigestKey C_DigestKey;\n\nCK_C_DigestFinal C_DigestFinal;\n\nCK_C_SignInit C_SignInit;\n\nCK_C_Sign C_Sign;\n\nCK_C_SignUpdate C_SignUpdate;\n\nCK_C_SignFinal C_SignFinal;\n\nCK_C_SignRecoverInit C_SignRecoverInit;\n\nCK_C_SignRecover C_SignRecover;\n\nCK_C_VerifyInit C_VerifyInit;\n\nCK_C_Verify C_Verify;\n\nCK_C_VerifyUpdate C_VerifyUpdate;\n\nCK_C_VerifyFinal C_VerifyFinal;\n\nCK_C_VerifyRecoverInit C_VerifyRecoverInit;\n\nCK_C_VerifyRecover C_VerifyRecover;\n\nCK_C_DigestEncryptUpdate C_DigestEncryptUpdate;\n\nCK_C_DecryptDigestUpdate C_DecryptDigestUpdate;\n\nCK_C_SignEncryptUpdate C_SignEncryptUpdate;\n\nCK_C_DecryptVerifyUpdate C_DecryptVerifyUpdate;\n\nCK_C_GenerateKey C_GenerateKey;\n\nCK_C_GenerateKeyPair C_GenerateKeyPair;\n\nCK_C_WrapKey C_WrapKey;\n\nCK_C_UnwrapKey C_UnwrapKey;\n\nCK_C_DeriveKey C_DeriveKey;\n\nCK_C_SeedRandom C_SeedRandom;\n\nCK_C_GenerateRandom C_GenerateRandom;\n\nCK_C_GetFunctionStatus C_GetFunctionStatus;\n\nCK_C_CancelFunction C_CancelFunction;\n\nCK_C_WaitForSlotEvent C_WaitForSlotEvent;\n\n} CK_FUNCTION_LIST;\n\nEach Cryptoki library has a static CK_FUNCTION_LIST structure, and a pointer to it (or to a copy of it which is also owned by the library) may be obtained by the C_GetFunctionList function (see Section 5.2). The value that this pointer points to can be used by an application to quickly find out where the executable code for each function in the Cryptoki API is located. Every function in the Cryptoki API MUST have an entry point defined in the Cryptoki librarys CK_FUNCTION_LIST structure. If a particular function in the Cryptoki API is not supported by a library, then the function pointer for that function in the librarys CK_FUNCTION_LIST structure should point to a function stub which simply returns CKR_FUNCTION_NOT_SUPPORTED.\n\nIn this structure version is the cryptoki specification version number. It should match the value of cryptokiVersion returned in the CK_INFO structure.\n\nAn application may or may not be able to modify a Cryptoki librarys static CK_FUNCTION_LIST structure. Whether or not it can, it should never attempt to do so.\n\nCK_FUNCTION_LIST_PTR is a pointer to a CK_FUNCTION_LIST.\n\nCK_FUNCTION_LIST_PTR_PTR is a pointer to a CK_FUNCTION_LIST_PTR.\n\n3.7 Locking-related types\n\nThe types in this section are provided solely for applications which need to access Cryptoki from multiple threads simultaneously. Applications which will not do this need not use any of these types.\n\n¨CK_CREATEMUTEX\n\nCK_CREATEMUTEX is the type of a pointer to an application-supplied function which creates a new mutex object and returns a pointer to it. It is defined as follows:\n\ntypedef CK_CALLBACK_FUNCTION(CK_RV, CK_CREATEMUTEX)(\n\nCK_VOID_PTR_PTR ppMutex\n\n);\n\nCalling a CK_CREATEMUTEX function returns the pointer to the new mutex object in the location pointed to by ppMutex. Such a function should return one of the following values:\n\nCKR_OK, CKR_GENERAL_ERROR\n\nCKR_HOST_MEMORY\n\n¨CK_DESTROYMUTEX\n\nCK_DESTROYMUTEX is the type of a pointer to an application-supplied function which destroys an existing mutex object. It is defined as follows:\n\ntypedef CK_CALLBACK_FUNCTION(CK_RV, CK_DESTROYMUTEX)(\n\nCK_VOID_PTR pMutex\n\n);\n\nThe argument to a CK_DESTROYMUTEX function is a pointer to the mutex object to be destroyed. Such a function should return one of the following values:\n\nCKR_OK, CKR_GENERAL_ERROR\n\nCKR_HOST_MEMORY\n\nCKR_MUTEX_BAD\n\n¨CK_LOCKMUTEX and CK_UNLOCKMUTEX\n\nCK_LOCKMUTEX is the type of a pointer to an application-supplied function which locks an existing mutex object. CK_UNLOCKMUTEX is the type of a pointer to an application-supplied function which unlocks an existing mutex object. The proper behavior for these types of functions is as follows:\n\n· If a CK_LOCKMUTEX function is called on a mutex which is not locked, the calling thread obtains a lock on that mutex and returns.\n\n· If a CK_LOCKMUTEX function is called on a mutex which is locked by some thread other than the calling thread, the calling thread blocks and waits for that mutex to be unlocked.\n\n· If a CK_LOCKMUTEX function is called on a mutex which is locked by the calling thread, the behavior of the function call is undefined.\n\n· If a CK_UNLOCKMUTEX function is called on a mutex which is locked by the calling thread, that mutex is unlocked and the function call returns. Furthermore:\n\no If exactly one thread was blocking on that particular mutex, then that thread stops blocking, obtains a lock on that mutex, and its CK_LOCKMUTEX call returns.\n\no If more than one thread was blocking on that particular mutex, then exactly one of the blocking threads is selected somehow. That lucky thread stops blocking, obtains a lock on the mutex, and its CK_LOCKMUTEX call returns. All other threads blocking on that particular mutex continue to block.\n\n· If a CK_UNLOCKMUTEX function is called on a mutex which is not locked, then the function call returns the error code CKR_MUTEX_NOT_LOCKED.\n\n· If a CK_UNLOCKMUTEX function is called on a mutex which is locked by some thread other than the calling thread, the behavior of the function call is undefined.\n\nCK_LOCKMUTEX is defined as follows:\n\ntypedef CK_CALLBACK_FUNCTION(CK_RV, CK_LOCKMUTEX)(\n\nCK_VOID_PTR pMutex\n\n);\n\nThe argument to a CK_LOCKMUTEX function is a pointer to the mutex object to be locked. Such a function should return one of the following values:\n\nCKR_OK, CKR_GENERAL_ERROR\n\nCKR_HOST_MEMORY,\n\nCKR_MUTEX_BAD\n\nCK_UNLOCKMUTEX is defined as follows:\n\ntypedef CK_CALLBACK_FUNCTION(CK_RV, CK_UNLOCKMUTEX)(\n\nCK_VOID_PTR pMutex\n\n);\n\nThe argument to a CK_UNLOCKMUTEX function is a pointer to the mutex object to be unlocked. Such a function should return one of the following values:\n\nCKR_OK, CKR_GENERAL_ERROR\n\nCKR_HOST_MEMORY\n\nCKR_MUTEX_BAD\n\nCKR_MUTEX_NOT_LOCKED\n\n¨CK_C_INITIALIZE_ARGS; CK_C_INITIALIZE_ARGS_PTR\n\nCK_C_INITIALIZE_ARGS is a structure containing the optional arguments for the C_Initialize function. For this version of Cryptoki, these optional arguments are all concerned with the way the library deals with threads. CK_C_INITIALIZE_ARGS is defined as follows:\n\ntypedef struct CK_C_INITIALIZE_ARGS {\n\nCK_CREATEMUTEX CreateMutex;\n\nCK_DESTROYMUTEX DestroyMutex;\n\nCK_LOCKMUTEX LockMutex;\n\nCK_UNLOCKMUTEX UnlockMutex;\n\nCK_FLAGS flags;\n\nCK_VOID_PTR pReserved;\n\n} CK_C_INITIALIZE_ARGS;\n\nThe fields of the structure have the following meanings:\n\nCreateMutex pointer to a function to use for creating mutex objects\n\nDestroyMutex pointer to a function to use for destroying mutex objects\n\nLockMutex pointer to a function to use for locking mutex objects\n\nUnlockMutex pointer to a function to use for unlocking mutex objects\n\nflags bit flags specifying options for C_Initialize; the flags are defined below\n\npReserved reserved for future use. Should be NULL_PTR for this version of Cryptoki\n\nThe following table defines the flags field:\n\nTable 9, C_Initialize Parameter Flags\n\nCK_C_INITIALIZE_ARGS_PTR is a pointer to a CK_C_INITIALIZE_ARGS.\n\nCryptoki recognizes a number of classes of objects, as defined in the CK_OBJECT_CLASS data type. An object consists of a set of attributes, each of which has a given value. Each attribute that an object possesses has precisely one value. The following figure illustrates the high-level hierarchy of the Cryptoki objects and some of the attributes they support:\n\nFigure 1, Object Attribute Hierarchy\n\nCryptoki provides functions for creating, destroying, and copying objects in general, and for obtaining and modifying the values of their attributes. Some of the cryptographic functions (e.g., C_GenerateKey) also create key objects to hold their results.\n\nObjects are always well-formed in Cryptokithat is, an object always contains all required attributes, and the attributes are always consistent with one another from the time the object is created. This contrasts with some object-based paradigms where an object has no attributes other than perhaps a class when it is created, and is uninitialized for some time. In Cryptoki, objects are always initialized.\n\nTables throughout most of Section 4 define each Cryptoki attribute in terms of the data type of the attribute value and the meaning of the attribute, which may include a default initial value. Some of the data types are defined explicitly by Cryptoki (e.g., CK_OBJECT_CLASS). Attribute values may also take the following types:\n\nByte array an arbitrary string (array) of CK_BYTEs\n\nBig integer a string of CK_BYTEs representing an unsigned integer of arbitrary size, most-significant byte first (e.g., the integer 32768 is represented as the 2-byte string 0x80 0x00)\n\nLocal string an unpadded string of CK_CHARs (see Table 3) with no null-termination\n\nRFC2279 string an unpadded string of CK_UTF8CHARs with no null-termination\n\nA token can hold several identical objects, i.e., it is permissible for two or more objects to have exactly the same values for all their attributes.\n\nIn most cases each type of object in the Cryptoki specification possesses a completely well-defined set of Cryptoki attributes. Some of these attributes possess default values, and need not be specified when creating an object; some of these default values may even be the empty string (). Nonetheless, the object possesses these attributes. A given object has a single value for each attribute it possesses, even if the attribute is a vendor-specific attribute whose meaning is outside the scope of Cryptoki.\n\nIn addition to possessing Cryptoki attributes, objects may possess additional vendor-specific attributes whose meanings and values are not specified by Cryptoki.\n\n4.1 Creating, modifying, and copying objects\n\nAll Cryptoki functions that create, modify, or copy objects take a template as one of their arguments, where the template specifies attribute values. Cryptographic functions that create objects (see Section 5.13) may also contribute some additional attribute values themselves; which attributes have values contributed by a cryptographic function call depends on which cryptographic mechanism is being performed (see [PKCS11-Curr] and [PKCS11-Hist] for specification of mechanisms for PKCS #11). In any case, all the required attributes supported by an object class that do not have default values MUST be specified when an object is created, either in the template or by the function itself.\n\n4.1.1 Creating objects\n\nObjects may be created with the Cryptoki functions C_CreateObject (see Section 5.7), C_GenerateKey, C_GenerateKeyPair, C_UnwrapKey, and C_DeriveKey (see Section 5.13). In addition, copying an existing object (with the function C_CopyObject) also creates a new object, but we consider this type of object creation separately in Section 4.1.3.\n\nAttempting to create an object with any of these functions requires an appropriate template to be supplied.\n\n1. If the supplied template specifies a value for an invalid attribute, then the attempt should fail with the error code CKR_ATTRIBUTE_TYPE_INVALID. An attribute is valid if it is either one of the attributes described in the Cryptoki specification or an additional vendor-specific attribute supported by the library and token.\n\n2. If the supplied template specifies an invalid value for a valid attribute, then the attempt should fail with the error code CKR_ATTRIBUTE_VALUE_INVALID. The valid values for Cryptoki attributes are described in the Cryptoki specification.\n\n3. If the supplied template specifies a value for a read-only attribute, then the attempt should fail with the error code CKR_ATTRIBUTE_READ_ONLY. Whether or not a given Cryptoki attribute is read-only is explicitly stated in the Cryptoki specification; however, a particular library and token may be even more restrictive than Cryptoki specifies. In other words, an attribute which Cryptoki says is not read-only may nonetheless be read-only under certain circumstances (i.e., in conjunction with some combinations of other attributes) for a particular library and token. Whether or not a given non-Cryptoki attribute is read-only is obviously outside the scope of Cryptoki.\n\n4. If the attribute values in the supplied template, together with any default attribute values and any attribute values contributed to the object by the object-creation function itself, are insufficient to fully specify the object to create, then the attempt should fail with the error code CKR_TEMPLATE_INCOMPLETE.\n\n5. If the attribute values in the supplied template, together with any default attribute values and any attribute values contributed to the object by the object-creation function itself, are inconsistent, then the attempt should fail with the error code CKR_TEMPLATE_INCONSISTENT. A set of attribute values is inconsistent if not all of its members can be satisfied simultaneously by the token, although each value individually is valid in Cryptoki. One example of an inconsistent template would be using a template which specifies two different values for the same attribute. Another example would be trying to create a secret key object with an attribute which is appropriate for various types of public keys or private keys, but not for secret keys. A final example would be a template with an attribute that violates some token specific requirement. Note that this final example of an inconsistent template is token-dependenton a different token, such a template might not be inconsistent.\n\n6. If the supplied template specifies the same value for a particular attribute more than once (or the template specifies the same value for a particular attribute that the object-creation function itself contributes to the object), then the behavior of Cryptoki is not completely specified. The attempt to create an object can either succeedthereby creating the same object that would have been created if the multiply-specified attribute had only appeared onceor it can fail with error code CKR_TEMPLATE_INCONSISTENT. Library developers are encouraged to make their libraries behave as though the attribute had only appeared once in the template; application developers are strongly encouraged never to put a particular attribute into a particular template more than once.\n\nIf more than one of the situations listed above applies to an attempt to create an object, then the error code returned from the attempt can be any of the error codes from above that applies.\n\n4.1.2 Modifying objects\n\nObjects may be modified with the Cryptoki function C_SetAttributeValue (see Section 5.7). The template supplied to C_SetAttributeValue can contain new values for attributes which the object already possesses; values for attributes which the object does not yet possess; or both.\n\nSome attributes of an object may be modified after the object has been created, and some may not. In addition, attributes which Cryptoki specifies are modifiable may actually not be modifiable on some tokens. That is, if a Cryptoki attribute is described as being modifiable, that really means only that it is modifiable insofar as the Cryptoki specification is concerned. A particular token might not actually support modification of some such attributes. Furthermore, whether or not a particular attribute of an object on a particular token is modifiable might depend on the values of certain attributes of the object. For example, a secret key objects CKA_SENSITIVE attribute can be changed from CK_FALSE to CK_TRUE, but not the other way around.\n\nAll the scenarios in Section 4.1.1and the error codes they returnapply to modifying objects with C_SetAttributeValue, except for the possibility of a template being incomplete.\n\n4.1.3 Copying objects\n\nUnless an object's CKA_COPYABLE (see table 21) attribute is set to CK_FALSE, it may be copied with the Cryptoki function C_CopyObject (see Section 5.7). In the process of copying an object, C_CopyObject also modifies the attributes of the newly-created copy according to an application-supplied template.\n\nThe Cryptoki attributes which can be modified during the course of a C_CopyObject operation are the same as the Cryptoki attributes which are described as being modifiable, plus the three special attributes CKA_TOKEN, CKA_PRIVATE, CKA_MODIFIABLE and CKA_DESTROYABLE. To be more precise, these attributes are modifiable during the course of a C_CopyObject operation insofar as the Cryptoki specification is concerned. A particular token might not actually support modification of some such attributes during the course of a C_CopyObject operation. Furthermore, whether or not a particular attribute of an object on a particular token is modifiable during the course of a C_CopyObject operation might depend on the values of certain attributes of the object. For example, a secret key objects CKA_SENSITIVE attribute can be changed from CK_FALSE to CK_TRUE during the course of a C_CopyObject operation, but not the other way around.\n\nIf the CKA_COPYABLE attribute of the object to be copied is set to CK_FALSE, C_CopyObject returns CKR_ACTION_PROHIBITED. Otherwise, the scenarios described in 10.1.1 - and the error codes they return - apply to copying objects with C_CopyObject, except for the possibility of a template being incomplete.\n\n4.2 Common attributes\n\nTable 10, Common footnotes for object attribute tables\n\nTable 11, Common Object Attributes\n\nAttribute\n\nData Type\n\nMeaning\n\nCKA_CLASS1\n\nCK_OBJECT_CLASS\n\nObject class (type)\n\nRefer to Table 10 for footnotes\n\nThe above table defines the attributes common to all objects.\n\n4.3 Hardware Feature Objects\n\n4.3.1 Definitions\n\nThis section defines the object class CKO_HW_FEATURE for type CK_OBJECT_CLASS as used in the CKA_CLASS attribute of objects.\n\n4.3.2 Overview\n\nHardware feature objects (CKO_HW_FEATURE) represent features of the device. They provide an easily expandable method for introducing new value-based features to the Cryptoki interface.\n\nWhen searching for objects using C_FindObjectsInit and C_FindObjects, hardware feature objects are not returned unless the CKA_CLASS attribute in the template has the value CKO_HW_FEATURE. This protects applications written to previous versions of Cryptoki from finding objects that they do not understand.\n\nTable 12, Hardware Feature Common Attributes\n\nAttribute\n\nData Type\n\nMeaning\n\nCKA_HW_FEATURE_TYPE1\n\nCK_HW_FEATURE_TYPE\n\nHardware feature (type)\n\n- Refer to Table 10 for footnotes\n\n4.3.3 Clock\n\n4.3.3.1 Definition\n\nThe CKA_HW_FEATURE_TYPE attribute takes the value CKH_CLOCK of type CK_HW_FEATURE.\n\n4.3.3.2 Description\n\nClock objects represent real-time clocks that exist on the device. This represents the same clock source as the utcTime field in the CK_TOKEN_INFO structure.\n\nTable 13, Clock Object Attributes\n\nThe CKA_VALUE attribute may be set using the C_SetAttributeValue function if permitted by the device. The session used to set the time MUST be logged in. The device may require the SO to be the user logged in to modify the time value. C_SetAttributeValue will return the error CKR_USER_NOT_LOGGED_IN to indicate that a different user type is required to set the value.\n\n4.3.4 Monotonic Counter Objects\n\n4.3.4.1 Definition\n\nThe CKA_HW_FEATURE_TYPE attribute takes the value CKH_MONOTONIC_COUNTER of type CK_HW_FEATURE.\n\n4.3.4.2 Description\n\nMonotonic counter objects represent hardware counters that exist on the device. The counter is guaranteed to increase each time its value is read, but not necessarily by one. This might be used by an application for generating serial numbers to get some assurance of uniqueness per token.\n\nTable 14, Monotonic Counter Attributes\n\n1Read Only\n\nThe CKA_VALUE attribute may not be set by the client.\n\n4.3.5 User Interface Objects\n\n4.3.5.1 Definition\n\nThe CKA_HW_FEATURE_TYPE attribute takes the value CKH_USER_INTERFACE of type CK_HW_FEATURE.\n\n4.3.5.2 Description\n\nUser interface objects represent the presentation capabilities of the device.\n\nTable 15, User Interface Object Attributes\n\nThe selection of attributes, and associated data types, has been done in an attempt to stay as aligned with RFC 2534 and CC/PP Struct as possible. The special value CK_UNAVAILABLE_INFORMATION may be used for CK_ULONG-based attributes when information is not available or applicable.\n\nNone of the attribute values may be set by an application.\n\nThe value of the CKA_ENCODING_METHODS attribute may be used when the application needs to send MIME objects with encoded content to the token.\n\n4.4 Storage Objects\n\nThis is not an object class; hence no CKO_ definition is required. It is a category of object classes with common attributes for the object classes that follow.\n\nTable 16, Common Storage Object Attributes\n\nOnly the CKA_LABEL attribute can be modified after the object is created. (The CKA_TOKEN, CKA_PRIVATE, and CKA_MODIFIABLE attributes can be changed in the process of copying an object, however.)\n\nThe CKA_TOKEN attribute identifies whether the object is a token object or a session object.\n\nWhen the CKA_PRIVATE attribute is CK_TRUE, a user may not access the object until the user has been authenticated to the token.\n\nThe value of the CKA_MODIFIABLE attribute determines whether or not an object is read-only.\n\nThe CKA_LABEL attribute is intended to assist users in browsing.\n\nThe value of the CKA_COPYABLE attribute determines whether or not an object can be copied. This attribute can be used in conjunction with CKA_MODIFIABLE to prevent changes to the permitted usages of keys and other objects.\n\nThe value of the CKA_DESTROYABLE attribute determines whether the object can be destroyed using C_DestroyObject.\n\n4.5 Data objects\n\n4.5.1 Definitions\n\nThis section defines the object class CKO_DATA for type CK_OBJECT_CLASS as used in the CKA_CLASS attribute of objects.\n\n4.5.2 Overview\n\nData objects (object class CKO_DATA) hold information defined by an application. Other than providing access to it, Cryptoki does not attach any special meaning to a data object. The following table lists the attributes supported by data objects, in addition to the common attributes defined for this object class:\n\nTable 17, Data Object Attributes\n\nThe CKA_APPLICATION attribute provides a means for applications to indicate ownership of the data objects they manage. Cryptoki does not provide a means of ensuring that only a particular application has access to a data object, however.\n\nThe CKA_OBJECT_ID attribute provides an application independent and expandable way to indicate the type of the data object value. Cryptoki does not provide a means of insuring that the data object identifier matches the data value.\n\nThe following is a sample template containing attributes for creating a data object:\n\nCK_OBJECT_CLASS class = CKO_DATA;\n\nCK_UTF8CHAR label[] = A data object;\n\nCK_UTF8CHAR application[] = An application;\n\nCK_BYTE data[] = Sample data;\n\nCK_BBOOL true = CK_TRUE;\n\nCK_ATTRIBUTE template[] = {\n\n{CKA_CLASS, &class, sizeof(class)},\n\n{CKA_TOKEN, &true, sizeof(true)},\n\n{CKA_LABEL, label, sizeof(label)-1},\n\n{CKA_APPLICATION, application, sizeof(application)-1},\n\n{CKA_VALUE, data, sizeof(data)}\n\n};\n\n4.6 Certificate objects\n\n4.6.1 Definitions\n\nThis section defines the object class CKO_CERTIFICATE for type CK_OBJECT_CLASS as used in the CKA_CLASS attribute of objects.\n\n4.6.2 Overview\n\nCertificate objects (object class CKO_CERTIFICATE) hold public-key or attribute certificates. Other than providing access to certificate objects, Cryptoki does not attach any special meaning to certificates. The following table defines the common certificate object attributes, in addition to the common attributes defined for this object class:\n\nTable 18, Common Certificate Object Attributes\n\n- Refer to Table 10 for footnotes\n\nCryptoki does not enforce the relationship of the CKA_PUBLIC_KEY_INFO to the public key in the certificate, but does recommend that the key be extracted from the certificate to create this value.\n\nThe CKA_CERTIFICATE_TYPE attribute may not be modified after an object is created. This version of Cryptoki supports the following certificate types:\n\n· X.509 public key certificate\n\nWTLS public key certificate\n\n· X.509 attribute certificate\n\nThe CKA_TRUSTED attribute cannot be set to CK_TRUE by an application. It MUST be set by a token initialization application or by the tokens SO. Trusted certificates cannot be modified.\n\nThe CKA_CERTIFICATE_CATEGORY attribute is used to indicate if a stored certificate is a user certificate for which the corresponding private key is available on the token (token user), a CA certificate (authority), or another end-entity certificate (other entity). This attribute may not be modified after an object is created.\n\nThe CKA_CERTIFICATE_CATEGORY and CKA_TRUSTED attributes will together be used to map to the categorization of the certificates.\n\nCKA_CHECK_VALUE: The value of this attribute is derived from the certificate by taking the first three bytes of the SHA-1 hash of the certificate objects CKA_VALUE attribute.\n\nThe CKA_START_DATE and CKA_END_DATE attributes are for reference only; Cryptoki does not attach any special meaning to them. When present, the application is responsible to set them to values that match the certificates encoded not before and not after fields (if any).\n\n4.6.3 X.509 public key certificate objects\n\nX.509 certificate objects (certificate type CKC_X_509) hold X.509 public key certificates. The following table defines the X.509 certificate object attributes, in addition to the common attributes defined for this object class:\n\nTable 19, X.509 Certificate Object Attributes\n\n1MUST be specified when the object is created.\n\n2MUST be specified when the object is created. MUST be non-empty if CKA_URL is empty.\n\n3MUST be non-empty if CKA_VALUE is empty.\n\n4Can only be empty if CKA_URL is empty.\n\nOnly the CKA_ID, CKA_ISSUER, and CKA_SERIAL_NUMBER attributes may be modified after the object is created.\n\nThe CKA_ID attribute is intended as a means of distinguishing multiple public-key/private-key pairs held by the same subject (whether stored in the same token or not). (Since the keys are distinguished by subject name as well as identifier, it is possible that keys for different subjects may have the same CKA_ID value without introducing any ambiguity.)\n\nIt is intended in the interests of interoperability that the subject name and key identifier for a certificate will be the same as those for the corresponding public and private keys (though it is not required that all be stored in the same token). However, Cryptoki does not enforce this association, or even the uniqueness of the key identifier for a given subject; in particular, an application may leave the key identifier empty.\n\nThe CKA_ISSUER and CKA_SERIAL_NUMBER attributes are for compatibility with PKCS #7 and Privacy Enhanced Mail (RFC1421). Note that with the version 3 extensions to X.509 certificates, the key identifier may be carried in the certificate. It is intended that the CKA_ID value be identical to the key identifier in such a certificate extension, although this will not be enforced by Cryptoki.\n\nThe CKA_URL attribute enables the support for storage of the URL where the certificate can be found instead of the certificate itself. Storage of a URL instead of the complete certificate is often used in mobile environments.\n\nThe CKA_HASH_OF_SUBJECT_PUBLIC_KEY and CKA_HASH_OF_ISSUER_PUBLIC_KEY attributes are used to store the hashes of the public keys of the subject and the issuer. They are particularly important when only the URL is available to be able to correlate a certificate with a private key and when searching for the certificate of the issuer. The hash algorithm is defined by CKA_NAME_HASH_ALGORITHM.\n\nThe CKA_JAVA_MIDP_SECURITY_DOMAIN attribute associates a certificate with a Java MIDP security domain.\n\nThe following is a sample template for creating an X.509 certificate object:\n\nCK_OBJECT_CLASS class = CKO_CERTIFICATE;\n\nCK_CERTIFICATE_TYPE certType = CKC_X_509;\n\nCK_UTF8CHAR label[] = A certificate object;\n\nCK_BYTE subject[] = {...};\n\nCK_BYTE id[] = {123};\n\nCK_BYTE certificate[] = {...};\n\nCK_BBOOL true = CK_TRUE;\n\nCK_ATTRIBUTE template[] = {\n\n{CKA_CLASS, &class, sizeof(class)},\n\n{CKA_CERTIFICATE_TYPE, &certType, sizeof(certType)};\n\n{CKA_TOKEN, &true, sizeof(true)},\n\n{CKA_LABEL, label, sizeof(label)-1},\n\n{CKA_SUBJECT, subject, sizeof(subject)},\n\n{CKA_ID, id, sizeof(id)},\n\n{CKA_VALUE, certificate, sizeof(certificate)}\n\n};\n\n4.6.4 WTLS public key certificate objects\n\nWTLS certificate objects (certificate type CKC_WTLS) hold WTLS public key certificates. The following table defines the WTLS certificate object attributes, in addition to the common attributes defined for this object class.\n\nTable 20: WTLS Certificate Object Attributes\n\n1MUST be specified when the object is created. Can only be empty if CKA_VALUE is empty.\n\n2MUST be specified when the object is created. MUST be non-empty if CKA_URL is empty.\n\n3MUST be non-empty if CKA_VALUE is empty.\n\n4Can only be empty if CKA_URL is empty.\n\nOnly the CKA_ISSUER attribute may be modified after the object has been created.\n\nThe encoding for the CKA_SUBJECT, CKA_ISSUER, and CKA_VALUE attributes can be found in [WTLS] (see References).\n\nThe CKA_URL attribute enables the support for storage of the URL where the certificate can be found instead of the certificate itself. Storage of a URL instead of the complete certificate is often used in mobile environments.\n\nThe CKA_HASH_OF_SUBJECT_PUBLIC_KEY and CKA_HASH_OF_ISSUER_PUBLIC_KEY attributes are used to store the hashes of the public keys of the subject and the issuer. They are particularly important when only the URL is available to be able to correlate a certificate with a private key and when searching for the certificate of the issuer. The hash algorithm is defined by CKA_NAME_HASH_ALGORITHM.\n\nThe following is a sample template for creating a WTLS certificate object:\n\nCK_OBJECT_CLASS class = CKO_CERTIFICATE;\n\nCK_CERTIFICATE_TYPE certType = CKC_WTLS;\n\nCK_UTF8CHAR label[] = A certificate object;\n\nCK_BYTE subject[] = {...};\n\nCK_BYTE certificate[] = {...};\n\nCK_BBOOL true = CK_TRUE;\n\nCK_ATTRIBUTE template[] =\n\n{\n\n{CKA_CLASS, &class, sizeof(class)},\n\n{CKA_CERTIFICATE_TYPE, &certType, sizeof(certType)};\n\n{CKA_TOKEN, &true, sizeof(true)},\n\n{CKA_LABEL, label, sizeof(label)-1},\n\n{CKA_SUBJECT, subject, sizeof(subject)},\n\n{CKA_VALUE, certificate, sizeof(certificate)}\n\n};\n\n4.6.5 X.509 attribute certificate objects\n\nX.509 attribute certificate objects (certificate type CKC_X_509_ATTR_CERT) hold X.509 attribute certificates. The following table defines the X.509 attribute certificate object attributes, in addition to the common attributes defined for this object class:\n\nTable 21, X.509 Attribute Certificate Object Attributes\n\n1MUST be specified when the object is created\n\nOnly the CKA_AC_ISSUER, CKA_SERIAL_NUMBER and CKA_ATTR_TYPES attributes may be modified after the object is created.\n\nThe following is a sample template for creating an X.509 attribute certificate object:\n\nCK_OBJECT_CLASS class = CKO_CERTIFICATE;\n\nCK_CERTIFICATE_TYPE certType = CKC_X_509_ATTR_CERT;\n\nCK_UTF8CHAR label[] = \"An attribute certificate object\";\n\nCK_BYTE owner[] = {...};\n\nCK_BYTE certificate[] = {...};\n\nCK_BBOOL true = CK_TRUE;\n\nCK_ATTRIBUTE template[] = {\n\n{CKA_CLASS, &class, sizeof(class)},\n\n{CKA_CERTIFICATE_TYPE, &certType, sizeof(certType)};\n\n{CKA_TOKEN, &true, sizeof(true)},\n\n{CKA_LABEL, label, sizeof(label)-1},\n\n{CKA_OWNER, owner, sizeof(owner)},\n\n{CKA_VALUE, certificate, sizeof(certificate)}\n\n};\n\n4.7 Key objects\n\n4.7.1 Definitions\n\nThere is no CKO_ definition for the base key object class, only for the key types derived from it.\n\nThis section defines the object class CKO_PUBLIC_KEY, CKO_PRIVATE_KEY and CKO_SECRET_KEY for type CK_OBJECT_CLASS as used in the CKA_CLASS attribute of objects.\n\n4.7.2 Overview\n\nKey objects hold encryption or authentication keys, which can be public keys, private keys, or secret keys. The following common footnotes apply to all the tables describing attributes of keys:\n\nThe following table defines the attributes common to public key, private key and secret key classes, in addition to the common attributes defined for this object class:\n\nTable 22, Common Key Attributes\n\n- Refer to Table 10 for footnotes\n\nThe CKA_ID field is intended to distinguish among multiple keys. In the case of public and private keys, this field assists in handling multiple keys held by the same subject; the key identifier for a public key and its corresponding private key should be the same. The key identifier should also be the same as for the corresponding certificate, if one exists. Cryptoki does not enforce these associations, however. (See Section 4.6 for further commentary.)\n\nIn the case of secret keys, the meaning of the CKA_ID attribute is up to the application.\n\nNote that the CKA_START_DATE and CKA_END_DATE attributes are for reference only; Cryptoki does not attach any special meaning to them. In particular, it does not restrict usage of a key according to the dates; doing this is up to the application.\n\nThe CKA_DERIVE attribute has the value CK_TRUE if and only if it is possible to derive other keys from the key.\n\nThe CKA_LOCAL attribute has the value CK_TRUE if and only if the value of the key was originally generated on the token by a C_GenerateKey or C_GenerateKeyPair call.\n\nThe CKA_KEY_GEN_MECHANISM attribute identifies the key generation mechanism used to generate the key material. It contains a valid value only if the CKA_LOCAL attribute has the value CK_TRUE. If CKA_LOCAL has the value CK_FALSE, the value of the attribute is CK_UNAVAILABLE_INFORMATION.\n\n4.8 Public key objects\n\nPublic key objects (object class CKO_PUBLIC_KEY) hold public keys. The following table defines the attributes common to all public keys, in addition to the common attributes defined for this object class:\n\nTable 23, Common Public Key Attributes\n\n- Refer to Table 10 for footnotes\n\nIt is intended in the interests of interoperability that the subject name and key identifier for a public key will be the same as those for the corresponding certificate and private key. However, Cryptoki does not enforce this, and it is not required that the certificate and private key also be stored on the token.\n\nTo map between ISO/IEC 9594-8 (X.509) keyUsage flags for public keys and the PKCS #11 attributes for public keys, use the following table.\n\nTable 24, Mapping of X.509 key usage flags to Cryptoki attributes for public keys\n\nKey usage flags for public keys in X.509 public key certificates\n\nCorresponding cryptoki attributes for public keys.\n\ndataEncipherment\n\nCKA_ENCRYPT\n\ndigitalSignature, keyCertSign, cRLSign\n\nCKA_VERIFY\n\ndigitalSignature, keyCertSign, cRLSign\n\nCKA_VERIFY_RECOVER\n\nkeyAgreement\n\nCKA_DERIVE\n\nkeyEncipherment\n\nCKA_WRAP\n\nnonRepudiation\n\nCKA_VERIFY\n\nnonRepudiation\n\nCKA_VERIFY_RECOVER\n\nThe value of the CKA_PUBLIC_KEY_INFO attribute is the DER encoded value of SubjectPublicKeyInfo:\n\nSubjectPublicKeyInfo ::= SEQUENCE {\n\nalgorithm AlgorithmIdentifier,\n\nsubjectPublicKey BIT_STRING }\n\nThe encodings for the subjectPublicKey field are specified in the description of the public key types in the appropriate [PKCS11-Curr] document for the key types defined within this specification.\n\n4.9 Private key objects\n\nPrivate key objects (object class CKO_PRIVATE_KEY) hold private keys. The following table defines the attributes common to all private keys, in addition to the common attributes defined for this object class:\n\nTable 25, Common Private Key Attributes\n\n- Refer to Table 10 for footnotes\n\nIt is intended in the interests of interoperability that the subject name and key identifier for a private key will be the same as those for the corresponding certificate and public key. However, this is not enforced by Cryptoki, and it is not required that the certificate and public key also be stored on the token.\n\nIf the CKA_SENSITIVE attribute is CK_TRUE, or if the CKA_EXTRACTABLE attribute is CK_FALSE, then certain attributes of the private key cannot be revealed in plaintext outside the token. Which attributes these are is specified for each type of private key in the attribute table in the section describing that type of key.\n\nThe CKA_ALWAYS_AUTHENTICATE attribute can be used to force re-authentication (i.e. force the user to provide a PIN) for each use of a private key. Use in this case means a cryptographic operation such as sign or decrypt. This attribute may only be set to CK_TRUE when CKA_PRIVATE is also CK_TRUE.\n\nRe-authentication occurs by calling C_Login with userType set to CKU_CONTEXT_SPECIFIC immediately after a cryptographic operation using the key has been initiated (e.g. after C_SignInit). In this call, the actual user type is implicitly given by the usage requirements of the active key. If C_Login returns CKR_OK the user was successfully authenticated and this sets the active key in an authenticated state that lasts until the cryptographic operation has successfully or unsuccessfully been completed (e.g. by C_Sign, C_SignFinal,..). A return value CKR_PIN_INCORRECT from C_Login means that the user was denied permission to use the key and continuing the cryptographic operation will result in a behavior as if C_Login had not been called. In both of these cases the session state will remain the same, however repeated failed re-authentication attempts may cause the PIN to be locked. C_Login returns in this case CKR_PIN_LOCKED and this also logs the user out from the token. Failing or omitting to re-authenticate when CKA_ALWAYS_AUTHENTICATE is set to CK_TRUE will result in CKR_USER_NOT_LOGGED_IN to be returned from calls using the key. C_Login will return CKR_OPERATION_NOT_INITIALIZED, but the active cryptographic operation will not be affected, if an attempt is made to re-authenticate when CKA_ALWAYS_AUTHENTICATE is set to CK_FALSE.\n\nThe CKA_PUBLIC_KEY_INFO attribute represents the public key associated with this private key. The data it represents may either be stored as part of the private key data, or regenerated as needed from the private key.\n\nIf this attribute is supplied as part of a template for C_CreateObject, C_CopyObject or C_SetAttributeValue for a private key, the token MUST verify correspondence between the private key data and the public key data as supplied in CKA_PUBLIC_KEY_INFO. This can be done either by deriving a public key from the private key and comparing the values, or by doing a sign and verify operation. If there is a mismatch, the command SHALL return CKR_ATTRIBUTE_VALUE_INVALID. A token MAY choose not to support the CKA_PUBLIC_KEY_INFO attribute for commands which create new private keys. If it does not support the attribute, the command SHALL return CKR_ATTRIBUTE_TYPE_INVALID.\n\nAs a general guideline, private keys of any type SHOULD store sufficient information to retrieve the public key information. In particular, the RSA private key description has been modified in <this version> to add the CKA_PUBLIC_EXPONENT to the list of attributes required for an RSA private key. All other private key types described in this specification contain sufficient information to recover the associated public key.\n\n4.9.1 RSA private key objects\n\nRSA private key objects (object class CKO_PRIVATE_KEY, key type CKK_RSA) hold RSA private keys. The following table defines the RSA private key object attributes, in addition to the common attributes defined for this object class:\n\nTable 26, RSA Private Key Object Attributes\n\nRefer to Table 10 for footnotes\n\nDepending on the token, there may be limits on the length of the key components. See PKCS #1 for more information on RSA keys.\n\nTokens vary in what they actually store for RSA private keys. Some tokens store all of the above attributes, which can assist in performing rapid RSA computations. Other tokens might store only the CKA_MODULUS and CKA_PRIVATE_EXPONENT values. Effective with version 2.40, tokens MUST also store CKA_PUBLIC_EXPONENT. This permits the retrieval of sufficient data to reconstitute the associated public key.\n\nBecause of this, Cryptoki is flexible in dealing with RSA private key objects. When a token generates an RSA private key, it stores whichever of the fields in Table 26 it keeps track of. Later, if an application asks for the values of the keys various attributes, Cryptoki supplies values only for attributes whose values it can obtain (i.e., if Cryptoki is asked for the value of an attribute it cannot obtain, the request fails). Note that a Cryptoki implementation may or may not be able and/or willing to supply various attributes of RSA private keys which are not actually stored on the token. E.g., if a particular token stores values only for the CKA_PRIVATE_EXPONENT, CKA_PUBLIC_EXPONENT, CKA_PRIME_1, and CKA_PRIME_2 attributes, then Cryptoki is certainly able to report values for all the attributes above (since they can all be computed efficiently from these four values). However, a Cryptoki implementation may or may not actually do this extra computation. The only attributes from Table 26 for which a Cryptoki implementation is required to be able to return values are CKA_MODULUS, CKA_PRIVATE_EXPONENT, and CKA_PUBLIC_EXPONENT. A token SHOULD also be able to return CKA_PUBLIC_KEY_INFO for an RSA private key. See the general guidance for Private Keys above.\n\n4.10 Secret key objects\n\nSecret key objects (object class CKO_SECRET_KEY) hold secret keys. The following table defines the attributes common to all secret keys, in addition to the common attributes defined for this object class:\n\nTable 27, Common Secret Key Attributes\n\n- Refer to Table 10 for footnotes\n\nIf the CKA_SENSITIVE attribute is CK_TRUE, or if the CKA_EXTRACTABLE attribute is CK_FALSE, then certain attributes of the secret key cannot be revealed in plaintext outside the token. Which attributes these are is specified for each type of secret key in the attribute table in the section describing that type of key.\n\nThe key check value (KCV) attribute for symmetric key objects to be called CKA_CHECK_VALUE, of type byte array, length 3 bytes, operates like a fingerprint, or checksum of the key. They are intended to be used to cross-check symmetric keys against other systems where the same key is shared, and as a validity check after manual key entry or restore from backup. Refer to object definitions of specific key types for KCV algorithms.\n\nProperties:\n\nFor two keys that are cryptographically identical the value of this attribute should be identical.\n\nCKA_CHECK_VALUE should not be usable to obtain any part of the key value.\n\nNon-uniqueness. Two different keys can have the same CKA_CHECK_VALUE. This is unlikely (the probability can easily be calculated) but possible.\n\nThe attribute is optional, but if supported, regardless of how the key object is created or derived, the value of the attribute is always supplied. It SHALL be supplied even if the encryption operation for the key is forbidden (i.e. when CKA_ENCRYPT is set to CK_FALSE).\n\nIf a value is supplied in the application template (allowed but never necessary) then, if supported, it MUST match what the library calculates it to be or the library returns a CKR_ATTRIBUTE_VALUE_INVALID. If the library does not support the attribute then it should ignore it. Allowing the attribute in the template this way does no harm and allows the attribute to be treated like any other attribute for the purposes of key wrap and unwrap where the attributes are preserved also.\n\nThe generation of the KCV may be prevented by the application supplying the attribute in the template as a no-value (0 length) entry. The application can query the value at any time like any other attribute using C_GetAttributeValue. C_SetAttributeValue may be used to destroy the attribute, by supplying no-value.\n\nUnless otherwise specified for the object definition, the value of this attribute is derived from the key object by taking the first three bytes of an encryption of a single block of null (0x00) bytes, using the default cipher and mode (e.g. ECB) associated with the key type of the secret key object.\n\n4.11 Domain parameter objects\n\n4.11.1 Definitions\n\nThis section defines the object class CKO_DOMAIN_PARAMETERS for type CK_OBJECT_CLASS as used in the CKA_CLASS attribute of objects.\n\n4.11.2 Overview\n\nThis object class was created to support the storage of certain algorithm's extended parameters. DSA and DH both use domain parameters in the key-pair generation step. In particular, some libraries support the generation of domain parameters (originally out of scope for PKCS11) so the object class was added.\n\nTo use a domain parameter object you MUST extract the attributes into a template and supply them (still in the template) to the corresponding key-pair generation function.\n\nDomain parameter objects (object class CKO_DOMAIN_PARAMETERS) hold public domain parameters.\n\nThe following table defines the attributes common to domain parameter objects in addition to the common attributes defined for this object class:\n\nTable 28, Common Domain Parameter Attributes\n\n- Refer to Table 10 for footnotes\n\nThe CKA_LOCAL attribute has the value CK_TRUE if and only if the values of the domain parameters were originally generated on the token by a C_GenerateKey call.\n\n4.12 Mechanism objects\n\n4.12.1 Definitions\n\nThis section defines the object class CKO_MECHANISM for type CK_OBJECT_CLASS as used in the CKA_CLASS attribute of objects.\n\n4.12.2 Overview\n\nMechanism objects provide information about mechanisms supported by a device beyond that given by the CK_MECHANISM_INFO structure.\n\nWhen searching for objects using C_FindObjectsInit and C_FindObjects, mechanism objects are not returned unless the CKA_CLASS attribute in the template has the value CKO_MECHANISM. This protects applications written to previous versions of Cryptoki from finding objects that they do not understand.\n\nTable 29, Common Mechanism Attributes\n\nAttribute\n\nData Type\n\nMeaning\n\nCKA_MECHANISM_TYPE\n\nCK_MECHANISM_TYPE\n\nThe type of mechanism object\n\nThe CKA_MECHANISM_TYPE attribute may not be set.\n\nCryptoki's functions are organized into the following categories:\n\n· general-purpose functions (4 functions)\n\n· slot and token management functions (9 functions)\n\n· session management functions (8 functions)\n\n· object management functions (9 functions)\n\n· encryption functions (4 functions)\n\n· decryption functions (4 functions)\n\n· message digesting functions (5 functions)\n\n· signing and MACing functions (6 functions)\n\n· functions for verifying signatures and MACs (6 functions)\n\n· dual-purpose cryptographic functions (4 functions)\n\n· key management functions (5 functions)\n\n· random number generation functions (2 functions)\n\n· parallel function management functions (2 functions)\n\nIn addition to these functions, Cryptoki can use application-supplied callback functions to notify an application of certain events, and can also use application-supplied functions to handle mutex objects for safe multi-threaded library access.\n\nThe Cryptoki API functions are presented in the following table:\n\nTable 30, Summary of Cryptoki Functions\n\nExecution of a Cryptoki function call is in general an all-or-nothing affair, i.e., a function call accomplishes either its entire goal, or nothing at all.\n\n· If a Cryptoki function executes successfully, it returns the value CKR_OK.\n\n· If a Cryptoki function does not execute successfully, it returns some value other than CKR_OK, and the token is in the same state as it was in prior to the function call. If the function call was supposed to modify the contents of certain memory addresses on the host computer, these memory addresses may have been modified, despite the failure of the function.\n\n· In unusual (and extremely unpleasant!) circumstances, a function can fail with the return value CKR_GENERAL_ERROR. When this happens, the token and/or host computer may be in an inconsistent state, and the goals of the function may have been partially achieved.\n\nThere are a small number of Cryptoki functions whose return values do not behave precisely as described above; these exceptions are documented individually with the description of the functions themselves.\n\nA Cryptoki library need not support every function in the Cryptoki API. However, even an unsupported function MUST have a stub in the library which simply returns the value CKR_FUNCTION_NOT_SUPPORTED. The functions entry in the librarys CK_FUNCTION_LIST structure (as obtained by C_GetFunctionList) should point to this stub function (see Section 3.6).\n\n5.1 Function return values\n\nThe Cryptoki interface possesses a large number of functions and return values. In Section 5.1, we enumerate the various possible return values for Cryptoki functions; most of the remainder of Section 5.1 details the behavior of Cryptoki functions, including what values each of them may return.\n\nBecause of the complexity of the Cryptoki specification, it is recommended that Cryptoki applications attempt to give some leeway when interpreting Cryptoki functions return values. We have attempted to specify the behavior of Cryptoki functions as completely as was feasible; nevertheless, there are presumably some gaps. For example, it is possible that a particular error code which might apply to a particular Cryptoki function is unfortunately not actually listed in the description of that function as a possible error code. It is conceivable that the developer of a Cryptoki library might nevertheless permit his/her implementation of that function to return that error code. It would clearly be somewhat ungraceful if a Cryptoki application using that library were to terminate by abruptly dumping core upon receiving that error code for that function. It would be far preferable for the application to examine the functions return value, see that it indicates some sort of error (even if the application doesnt know precisely what kind of error), and behave accordingly.\n\nSee Section 5.1.8 for some specific details on how a developer might attempt to make an application that accommodates a range of behaviors from Cryptoki libraries.\n\n5.1.1 Universal Cryptoki function return values\n\nAny Cryptoki function can return any of the following values:\n\n· CKR_GENERAL_ERROR: Some horrible, unrecoverable error has occurred. In the worst case, it is possible that the function only partially succeeded, and that the computer and/or token is in an inconsistent state.\n\n· CKR_HOST_MEMORY: The computer that the Cryptoki library is running on has insufficient memory to perform the requested function.\n\n· CKR_FUNCTION_FAILED: The requested function could not be performed, but detailed information about why not is not available in this error return. If the failed function uses a session, it is possible that the CK_SESSION_INFO structure that can be obtained by calling C_GetSessionInfo will hold useful information about what happened in its ulDeviceError field. In any event, although the function call failed, the situation is not necessarily totally hopeless, as it is likely to be when CKR_GENERAL_ERROR is returned. Depending on what the root cause of the error actually was, it is possible that an attempt to make the exact same function call again would succeed.\n\n· CKR_OK: The function executed successfully. Technically, CKR_OK is not quite a universal return value; in particular, the legacy functions C_GetFunctionStatus and C_CancelFunction (see Section 5.15) cannot return CKR_OK.\n\nThe relative priorities of these errors are in the order listed above, e.g., if either of CKR_GENERAL_ERROR or CKR_HOST_MEMORY would be an appropriate error return, then CKR_GENERAL_ERROR should be returned.\n\n5.1.2 Cryptoki function return values for functions that use a session handle\n\nAny Cryptoki function that takes a session handle as one of its arguments (i.e., any Cryptoki function except for C_Initialize, C_Finalize, C_GetInfo, C_GetFunctionList, C_GetSlotList, C_GetSlotInfo, C_GetTokenInfo, C_WaitForSlotEvent, C_GetMechanismList, C_GetMechanismInfo, C_InitToken, C_OpenSession, and C_CloseAllSessions) can return the following values:\n\n· CKR_SESSION_HANDLE_INVALID: The specified session handle was invalid at the time that the function was invoked. Note that this can happen if the sessions token is removed before the function invocation, since removing a token closes all sessions with it.\n\n· CKR_DEVICE_REMOVED: The token was removed from its slot during the execution of the function.\n\n· CKR_SESSION_CLOSED: The session was closed during the execution of the function. Note that, as stated in [PKCS11-UG], the behavior of Cryptoki is undefined if multiple threads of an application attempt to access a common Cryptoki session simultaneously. Therefore, there is actually no guarantee that a function invocation could ever return the value CKR_SESSION_CLOSED. An example of multiple threads accessing a common session simultaneously is where one thread is using a session when another thread closes that same session.\n\nThe relative priorities of these errors are in the order listed above, e.g., if either of CKR_SESSION_HANDLE_INVALID or CKR_DEVICE_REMOVED would be an appropriate error return, then CKR_SESSION_HANDLE_INVALID should be returned.\n\nIn practice, it is often not crucial (or possible) for a Cryptoki library to be able to make a distinction between a token being removed before a function invocation and a token being removed during a function execution.\n\n5.1.3 Cryptoki function return values for functions that use a token\n\nAny Cryptoki function that uses a particular token (i.e., any Cryptoki function except for C_Initialize, C_Finalize, C_GetInfo, C_GetFunctionList, C_GetSlotList, C_GetSlotInfo, or C_WaitForSlotEvent) can return any of the following values:\n\n· CKR_DEVICE_MEMORY: The token does not have sufficient memory to perform the requested function.\n\n· CKR_DEVICE_ERROR: Some problem has occurred with the token and/or slot. This error code can be returned by more than just the functions mentioned above; in particular, it is possible for C_GetSlotInfo to return CKR_DEVICE_ERROR.\n\n· CKR_TOKEN_NOT_PRESENT: The token was not present in its slot at the time that the function was invoked.\n\n· CKR_DEVICE_REMOVED: The token was removed from its slot during the execution of the function.\n\nThe relative priorities of these errors are in the order listed above, e.g., if either of CKR_DEVICE_MEMORY or CKR_DEVICE_ERROR would be an appropriate error return, then CKR_DEVICE_MEMORY should be returned.\n\nIn practice, it is often not critical (or possible) for a Cryptoki library to be able to make a distinction between a token being removed before a function invocation and a token being removed during a function execution.\n\n5.1.4 Special return value for application-supplied callbacks\n\nThere is a special-purpose return value which is not returned by any function in the actual Cryptoki API, but which may be returned by an application-supplied callback function. It is:\n\n· CKR_CANCEL: When a function executing in serial with an application decides to give the application a chance to do some work, it calls an application-supplied function with a CKN_SURRENDER callback (see Section 5.16). If the callback returns the value CKR_CANCEL, then the function aborts and returns CKR_FUNCTION_CANCELED.\n\n5.1.5 Special return values for mutex-handling functions\n\nThere are two other special-purpose return values which are not returned by any actual Cryptoki functions. These values may be returned by application-supplied mutex-handling functions, and they may safely be ignored by application developers who are not using their own threading model. They are:\n\n· CKR_MUTEX_BAD: This error code can be returned by mutex-handling functions that are passed a bad mutex object as an argument. Unfortunately, it is possible for such a function not to recognize a bad mutex object. There is therefore no guarantee that such a function will successfully detect bad mutex objects and return this value.\n\n· CKR_MUTEX_NOT_LOCKED: This error code can be returned by mutex-unlocking functions. It indic"
    }
}