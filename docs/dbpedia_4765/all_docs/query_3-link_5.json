{
    "id": "dbpedia_4765_3",
    "rank": 5,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Check_digit",
        "read_more_link": "",
        "language": "en",
        "title": "Check digit",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2004-02-24T20:26:09+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Check_digit",
        "text": "Error detection for identification numbers\n\nA check digit is a form of redundancy check used for error detection on identification numbers, such as bank account numbers, which are used in an application where they will at least sometimes be input manually. It is analogous to a binary parity bit used to check for errors in computer-generated data. It consists of one or more digits (or letters) computed by an algorithm from the other digits (or letters) in the sequence input.[1]\n\nWith a check digit, one can detect simple errors in the input of a series of characters (usually digits) such as a single mistyped digit or some permutations of two successive digits.\n\nDesign\n\n[edit]\n\nCheck digit algorithms are generally designed to capture human transcription errors. In order of complexity, these include the following: [2]\n\nletter/digit errors, such as l → 1 or O → 0\n\nsingle-digit errors, such as 1 → 2\n\ntransposition errors, such as 12 → 21\n\ntwin errors, such as 11 → 22\n\njump transpositions errors, such as 132 → 231\n\njump twin errors, such as 131 → 232\n\nphonetic errors, such as 60 → 16 (\"sixty\" to \"sixteen\")\n\nIn choosing a system, a high probability of catching errors is traded off against implementation difficulty; simple check digit systems are easily understood and implemented by humans but do not catch as many errors as complex ones, which require sophisticated programs to implement.\n\nA desirable feature is that left-padding with zeros should not change the check digit. This allows variable length numbers to be used and the length to be changed. If there is a single check digit added to the original number, the system will not always capture multiple errors, such as two replacement errors (12 → 34) though, typically, double errors will be caught 90% of the time (both changes would need to change the output by offsetting amounts).\n\nA very simple check digit method would be to take the sum of all digits (digital sum) modulo 10. This would catch any single-digit error, as such an error would always change the sum, but does not catch any transposition errors (switching two digits) as re-ordering does not change the sum.\n\nA slightly more complex method is to take the weighted sum of the digits, modulo 10, with different weights for each number position.\n\nTo illustrate this, for example if the weights for a four digit number were 5, 3, 2, 7 and the number to be coded was 4871, then one would take 5×4 + 3×8 + 2×7 + 7×1 = 65, i.e. 65 modulo 10, and the check digit would be 5, giving 48715.\n\nSystems with weights of 1, 3, 7, or 9, with the weights on neighboring numbers being different, are widely used: for example, 31 31 weights in UPC codes, 13 13 weights in EAN numbers (GS1 algorithm), and the 371 371 371 weights used in United States bank routing transit numbers. This system detects all single-digit errors and around 90% [citation needed]of transposition errors. 1, 3, 7, and 9 are used because they are coprime with 10, so changing any digit changes the check digit; using a coefficient that is divisible by 2 or 5 would lose information (because 5×0 = 5×2 = 5×4 = 5×6 = 5×8 = 0 modulo 10) and thus not catch some single-digit errors. Using different weights on neighboring numbers means that most transpositions change the check digit; however, because all weights differ by an even number, this does not catch transpositions of two digits that differ by 5 (0 and 5, 1 and 6, 2 and 7, 3 and 8, 4 and 9), since the 2 and 5 multiply to yield 10.\n\nThe ISBN-10 code instead uses modulo 11, which is prime, and all the number positions have different weights 1, 2, ... 10. This system thus detects all single-digit substitution and transposition errors (including jump transpositions), but at the cost of the check digit possibly being 10, represented by \"X\". (An alternative is simply to avoid using the serial numbers which result in an \"X\" check digit.) ISBN-13 instead uses the GS1 algorithm used in EAN numbers.\n\nMore complicated algorithms include the Luhn algorithm (1954), which captures 98% of single-digit transposition errors (it does not detect 90 ↔ 09) and the still more sophisticated Verhoeff algorithm (1969), which catches all single-digit substitution and transposition errors, and many (but not all) more complex errors. Similar is another abstract algebra-based method, the Damm algorithm (2004), that too detects all single-digit errors and all adjacent transposition errors. These three methods use a single check digit and will therefore fail to capture around 10%[citation needed] of more complex errors. To reduce this failure rate, it is necessary to use more than one check digit (for example, the modulo 97 check referred to below, which uses two check digits—for the algorithm, see International Bank Account Number) and/or to use a wider range of characters in the check digit, for example letters plus numbers.\n\nExamples\n\n[edit]\n\nUPC, EAN, GLN, GTIN, numbers administered by GS1\n\n[edit]\n\nThe final digit of a Universal Product Code, International Article Number, Global Location Number or Global Trade Item Number is a check digit computed as follows:[3][4]\n\nAdd the digits in the odd-numbered positions from the left (first, third, fifth, etc.—not including the check digit) together and multiply by three.\n\nAdd the digits (up to but not including the check digit) in the even-numbered positions (second, fourth, sixth, etc.) to the result.\n\nTake the remainder of the result divided by 10 (i.e. the modulo 10 operation). If the remainder is equal to 0 then use 0 as the check digit, and if not 0 subtract the remainder from 10 to derive the check digit.\n\nA GS1 check digit calculator and detailed documentation is online at GS1's website.[5] Another official calculator page shows that the mechanism for GTIN-13 is the same for Global Location Number/GLN.[6]\n\nFor instance, the UPC-A barcode for a box of tissues is \"036000241457\". The last digit is the check digit \"7\", and if the other numbers are correct then the check digit calculation must produce 7.\n\nAdd the odd number digits: 0+6+0+2+1+5 = 14.\n\nMultiply the result by 3: 14 × 3 = 42.\n\nAdd the even number digits: 3+0+0+4+4 = 11.\n\nAdd the two results together: 42 + 11 = 53.\n\nTo calculate the check digit, take the remainder of (53 / 10), which is also known as (53 modulo 10), and if not 0, subtract from 10. Therefore, the check digit value is 7. i.e. (53 / 10) = 5 remainder 3; 10 - 3 = 7.\n\nAnother example: to calculate the check digit for the following food item \"01010101010x\".\n\nAdd the odd number digits: 0+0+0+0+0+0 = 0.\n\nMultiply the result by 3: 0 x 3 = 0.\n\nAdd the even number digits: 1+1+1+1+1=5.\n\nAdd the two results together: 0 + 5 = 5.\n\nTo calculate the check digit, take the remainder of (5 / 10), which is also known as (5 modulo 10), and if not 0, subtract from 10: i.e. (5 / 10) = 0 remainder 5; (10 - 5) = 5. Therefore, the check digit x value is 5.\n\nISBN 10\n\n[edit]\n\nThe final character of a ten-digit International Standard Book Number is a check digit computed so that multiplying each digit by its position in the number (counting from the right) and taking the sum of these products modulo 11 is 0. The digit the farthest to the right (which is multiplied by 1) is the check digit, chosen to make the sum correct. It may need to have the value 10, which is represented as the letter X. For example, take the ISBN 0-201-53082-1: The sum of products is 0×10 + 2×9 + 0×8 + 1×7 + 5×6 + 3×5 + 0×4 + 8×3 + 2×2 + 1×1 = 99 ≡ 0 (mod 11). So the ISBN is valid. Positions can also be counted from left, in which case the check digit is multiplied by 10, to check validity: 0×1 + 2×2 + 0×3 + 1×4 + 5×5 + 3×6 + 0×7 + 8×8 + 2×9 + 1×10 = 143 ≡ 0 (mod 11).\n\nISBN 13\n\n[edit]\n\nISBN 13 (in use January 2007) is equal to the EAN-13 code found underneath a book's barcode. Its check digit is generated the same way as the UPC.[7]\n\nNCDA\n\n[edit]\n\nThe NOID Check Digit Algorithm (NCDA),[8] in use since 2004, is designed for application in persistent identifiers and works with variable length strings of letters and digits, called extended digits. It is widely used with the ARK identifier scheme and somewhat used with schemes, such as the Handle System and DOI. An extended digit is constrained to betanumeric characters, which are alphanumerics minus vowels and the letter 'l' (ell). This restriction helps when generating opaque strings that are unlikely to form words by accident and will not contain both O and 0, or l and 1. Having a prime radix of R=29, the betanumeric repertoire permits the algorithm to guarantee detection of single-character and transposition errors[9] for strings less than R=29 characters in length (beyond which it provides a slightly weaker check). The algorithm generalizes to any character repertoire with a prime radix R and strings less than R characters in length.\n\nOther examples of check digits\n\n[edit]\n\nInternational\n\n[edit]\n\nThe International SEDOL number.\n\nThe final digit of an ISSN code or IMO Number.\n\nThe International Securities Identifying Number (ISIN).\n\nObject Management Group FIGI standard final digit.[10]\n\nThe International CAS registry number's final digit.\n\nModulo 10 check digits in credit card account numbers, calculated by the Luhn algorithm.\n\nAlso used in the Norwegian KID (customer identification number) numbers used in bank giros (credit transfer),\n\nUsed in IMEI of mobile phones.\n\nLast check digit in EAN/UPC serialisation of Global Trade Identification Number (GTIN). It applies to GTIN-8, GTIN-12, GTIN-13 and GTIN-14.\n\nThe final digit of a DUNS number (though this is scheduled to change, such as that the final digit will be chosen freely in new allocations, rather than being a check digit).\n\nThe third and fourth digits in an International Bank Account Number (Modulo 97 check).\n\nThe final digit in an International Standard Text Code.\n\nThe final character encoded in a magnetic stripe card is a computed Longitudinal redundancy check.\n\nIn the US\n\n[edit]\n\nThe tenth digit of the National Provider Identifier for the US healthcare industry.\n\nThe final digit of a POSTNET code.\n\nThe North American CUSIP number.\n\nThe final (ninth) digit of the ABA routing transit number, a bank code used in the United States.\n\nThe ninth digit of a Vehicle Identification Number (VIN).\n\nMayo Clinic patient identification numbers used in Arizona and Florida include a trailing check digit[citation needed].\n\nThe eleventh digit of a Customs & Border Protection entry number.\n\nIn Central America\n\n[edit]\n\nThe Guatemalan Tax Number (NIT – Número de Identificación Tributaria) based on modulo 11.\n\nIn Eurasia\n\n[edit]\n\nThe UK NHS Number uses the modulo 11 algorithm.\n\nThe Spanish fiscal identification number (número de identificación fiscal, NIF) (based on modulo 23).\n\nThe Dutch Burgerservicenummer (BSN) (national identifier) uses the modulo 11 algorithm.\n\nThe ninth digit of an Israeli Teudat Zehut (Identity Card) number.\n\nThe 13th digit of the Serbian and Former Yugoslav Unique Master Citizen Number (JMBG). (but not all of them, due to errors or non-residency)\n\nThe last two digits of the 11-digit Turkish Identification Number (Turkish: TC Kimlik Numarası).\n\nThe ninth character in the 14-character EU cattle passport number (cycles from 1 to 7: see British Cattle Movement Service).\n\nThe ninth digit in an Icelandic Kennitala (national ID number).\n\nModulo 97 check digits in a Belgian and Serbian bank account numbers. Serbia sometimes also uses modulo 11, for reference number.\n\nThe ninth digit in a Hungarian TAJ number (social insurance number).\n\nFor the residents of India, the unique identity number named Aadhaar has a trailing 12th digit that is calculated with the Verhoeff algorithm.[11]\n\nThe Intellectual Property Office of Singapore (IPOS) has confirmed a new format for application numbers of registrable intellectual property (IP, e.g., trademarks, patents, registered designs). It will include a check character calculated with the Damm algorithm.[12]\n\nThe last digit of Chinese citizen ID number (second generation) is calculated by modulo 11-2 as specified in Chinese GuoBiao (aka national standard) GB11643-1999 which adopts ISO 7064:1983. 'X' is used if the calculated checking digit is 10.\n\nThe 11th digit of Estonian Isikukood (Personal Identification Code).\n\nThe last letter on vehicle registration plates of Singapore.\n\nIn Oceania\n\n[edit]\n\nThe Australian tax file number (based on modulo 11).\n\nThe seventh character of a New Zealand NHI Number.\n\nThe last digit in a New Zealand locomotive's Traffic Monitoring System (TMS) number.\n\nAlgorithms\n\n[edit]\n\nNotable algorithms include:\n\nLuhn algorithm (1954)\n\nVerhoeff algorithm (1969)\n\nDamm algorithm (2004)\n\nSee also\n\n[edit]\n\nChecksum\n\nCasting out nines – similar modular sum check\n\nCheck bit – binary equivalent\n\nReferences\n\n[edit]"
    }
}