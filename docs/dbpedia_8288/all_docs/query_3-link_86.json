{
    "id": "dbpedia_8288_3",
    "rank": 86,
    "data": {
        "url": "https://ziglang.org/documentation/master/",
        "read_more_link": "",
        "language": "en",
        "title": "The Zig Programming Language",
        "top_image": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==",
        "meta_img": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQCAYAAAAf8/9hAAAAgklEQVR4AWMYWuD7EllJIM4G4g4g5oIJ/odhOJ8wToOxSTXgNxDHoeiBMfA4+wGShjyYOCkG/IGqWQziEzYAoUAeiF9D5U+DxEg14DRU7jWIT5IBIOdCxf+A+CQZAAoopEB7QJwBCBwHiip8UYmRdrAlDpIMgApwQZNnNii5Dq0MBgCxxycBnwEd+wAAAABJRU5ErkJggg==",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Introduction Â§\n\nZig is a general-purpose programming language and toolchain for maintaining robust, optimal, and reusable software.\n\nRobust\n\nBehavior is correct even for edge cases such as out of memory.\n\nOptimal\n\nWrite programs the best way they can behave and perform.\n\nReusable\n\nThe same code works in many environments which have different constraints.\n\nMaintainable\n\nPrecisely communicate intent to the compiler and other programmers. The language imposes a low overhead to reading code and is resilient to changing requirements and environments.\n\nOften the most efficient way to learn something new is to see examples, so this documentation shows how to use each of Zig's features. It is all on one page so you can search with your browser's search tool.\n\nThe code samples in this document are compiled and tested as part of the main test suite of Zig.\n\nThis HTML document depends on no external files, so you can use it offline.\n\nZig Standard Library Â§\n\nThe Zig Standard Library has its own documentation.\n\nZig's Standard Library contains commonly used algorithms, data structures, and definitions to help you build programs or libraries. You will see many examples of Zig's Standard Library used in this documentation. To learn more about the Zig Standard Library, visit the link above.\n\nHello World Â§\n\nMost of the time, it is more appropriate to write to stderr rather than stdout, and whether or not the message is successfully written to the stream is irrelevant. For this common case, there is a simpler API:\n\nIn this case, the ! may be omitted from the return type because no errors are returned from the function.\n\nSee also:\n\nValues\n\n@import\n\nErrors\n\nRoot Source File\n\nSource Encoding\n\nZig supports 3 types of comments. Normal comments are ignored, but doc comments and top-level doc comments are used by the compiler to generate the package documentation.\n\nThe generated documentation is still experimental, and can be produced with:\n\nThere are no multiline comments in Zig (e.g. like /* */ comments in C). This allows Zig to have the property that each line of code can be tokenized out of context.\n\nA doc comment is one that begins with exactly three slashes (i.e. but not ); multiple doc comments in a row are merged together to form a multiline doc comment. The doc comment documents whatever immediately follows it.\n\nDoc comments are only allowed in certain places; it is a compile error to have a doc comment in an unexpected place, such as in the middle of an expression, or just before a non-doc comment.\n\nDoc comments can be interleaved with normal comments. Currently, when producing the package documentation, normal comments are merged with doc comments.\n\nA top-level doc comment is one that begins with two slashes and an exclamation point: ; it documents the current module.\n\nIt is a compile error if a top-level doc comment is not placed at the start of a container, before any expressions.\n\nValues Â§\n\nPrimitive Types Â§\n\nIn addition to the integer types above, arbitrary bit-width integers can be referenced by using an identifier of i or u followed by digits. For example, the identifier i7 refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is 65535.\n\nSee also:\n\nIntegers\n\nFloats\n\nvoid\n\nErrors\n\n@Type\n\nPrimitive Values Â§\n\nSee also:\n\nOptionals\n\nundefined\n\nString Literals and Unicode Code Point Literals Â§\n\nString literals are constant single-item Pointers to null-terminated byte arrays. The type of string literals encodes both the length, and the fact that they are null-terminated, and thus they can be coerced to both Slices and Null-Terminated Pointers. Dereferencing string literals converts them to Arrays.\n\nBecause Zig source code is UTF-8 encoded, any non-ASCII bytes appearing within a string literal in source code carry their UTF-8 meaning into the content of the string in the Zig program; the bytes are not modified by the compiler. It is possible to embed non-UTF-8 bytes into a string literal using \\xNN notation.\n\nIndexing into a string containing non-ASCII bytes returns individual bytes, whether valid UTF-8 or not.\n\nUnicode code point literals have type comptime_int, the same as Integer Literals. All Escape Sequences are valid in both string literals and Unicode code point literals.\n\nSee also:\n\nArrays\n\nSource Encoding\n\nEscape Sequences Â§\n\nNote that the maximum valid Unicode scalar value is 0x10ffff.\n\nMultiline String Literals Â§\n\nMultiline string literals have no escapes and can span across multiple lines. To start a multiline string literal, use the \\\\ token. Just like a comment, the string literal goes until the end of the line. The end of the line is not included in the string literal. However, if the next line begins with \\\\ then a newline is appended and the string literal continues.\n\nSee also:\n\n@embedFile\n\nAssignment Â§\n\nUse the const keyword to assign a value to an identifier:\n\nconst applies to all of the bytes that the identifier immediately addresses. Pointers have their own const-ness.\n\nIf you need a variable that you can modify, use the var keyword:\n\nVariables must be initialized:\n\nundefined Â§\n\nUse undefined to leave variables uninitialized:\n\nundefined can be coerced to any type. Once this happens, it is no longer possible to detect that the value is undefined. undefined means the value could be anything, even something that is nonsense according to the type. Translated into English, undefined means \"Not a meaningful value. Using this value would be a bug. The value will be unused, or overwritten before being used.\"\n\nIn Debug mode, Zig writes 0xaa bytes to undefined memory. This is to catch bugs early, and to help detect use of undefined memory in a debugger. However, this behavior is only an implementation feature, not a language semantic, so it is not guaranteed to be observable to code.\n\nZig Test Â§\n\nCode written within one or more test declarations can be used to ensure behavior meets expectations:\n\nThe testing_introduction.zig code sample tests the function addOne to ensure that it returns 42 given the input 41. From this test's perspective, the addOne function is said to be code under test.\n\nzig test is a tool that creates and runs a test build. By default, it builds and runs an executable program using the default test runner provided by the Zig Standard Library as its main entry point. During the build, test declarations found while resolving the given Zig source file are included for the default test runner to run and report on.\n\nThe shell output shown above displays two lines after the zig test command. These lines are printed to standard error by the default test runner:\n\n1/2 testing_introduction.test.expect addOne adds one to 41...\n\nLines like this indicate which test, out of the total number of tests, is being run. In this case, 1/2 indicates that the first test, out of a total of two tests, is being run. Note that, when the test runner program's standard error is output to the terminal, these lines are cleared when a test succeeds.\n\n2/2 testing_introduction.decltest.addOne...\n\nWhen the test name is an identifier, the default test runner uses the text decltest instead of test.\n\nAll 2 tests passed.\n\nThis line indicates the total number of tests that have passed.\n\nTest Declarations Â§\n\nTest declarations contain the keyword test, followed by an optional name written as a string literal or an identifier, followed by a block containing any valid Zig code that is allowed in a function.\n\nNon-named test blocks always run during test builds and are exempt from Skip Tests.\n\nTest declarations are similar to Functions: they have a return type and a block of code. The implicit return type of test is the Error Union Type anyerror!void, and it cannot be changed. When a Zig source file is not built using the zig test tool, the test declarations are omitted from the build.\n\nTest declarations can be written in the same file, where code under test is written, or in a separate Zig source file. Since test declarations are top-level declarations, they are order-independent and can be written before or after the code under test.\n\nSee also:\n\nThe Global Error Set\n\nGrammar\n\nDoctests Â§\n\nTest declarations named using an identifier are doctests. The identifier must refer to another declaration in scope. A doctest, like a doc comment, serves as documentation for the associated declaration, and will appear in the generated documentation for the declaration.\n\nAn effective doctest should be self-contained and focused on the declaration being tested, answering questions a new user might have about its interface or intended usage, while avoiding unnecessary or confusing details. A doctest is not a substitute for a doc comment, but rather a supplement and companion providing a testable, code-driven example, verified by zig test.\n\nTest Failure Â§\n\nThe default test runner checks for an error returned from a test. When a test returns an error, the test is considered a failure and its error return trace is output to standard error. The total number of failures will be reported after all tests have run.\n\nSkip Tests Â§\n\nOne way to skip tests is to filter them out by using the zig test command line parameter --test-filter [text]. This makes the test build only include tests whose name contains the supplied filter text. Note that non-named tests are run even when using the --test-filter [text] command line parameter.\n\nTo programmatically skip a test, make a test return the error error.SkipZigTest and the default test runner will consider the test as being skipped. The total number of skipped tests will be reported after all tests have run.\n\nReport Memory Leaks Â§\n\nWhen code allocates Memory using the Zig Standard Library's testing allocator, std.testing.allocator, the default test runner will report any leaks that are found from using the testing allocator:\n\nSee also:\n\ndefer\n\nMemory\n\nDetecting Test Build Â§\n\nUse the compile variable @import(\"builtin\").is_test to detect a test build:\n\nTest Output and Logging Â§\n\nThe default test runner and the Zig Standard Library's testing namespace output messages to standard error.\n\nThe Testing Namespace Â§\n\nThe Zig Standard Library's testing namespace contains useful functions to help you create tests. In addition to the expect function, this document uses a couple of more functions as exemplified here:\n\nThe Zig Standard Library also contains functions to compare Slices, strings, and more. See the rest of the std.testing namespace in the Zig Standard Library for more available functions.\n\nTest Tool Documentation Â§\n\nzig test has a few command line parameters which affect the compilation. See zig test --help for a full list.\n\nVariables Â§\n\nA variable is a unit of Memory storage.\n\nIt is generally preferable to use const rather than var when declaring a variable. This causes less work for both humans and computers to do when reading code, and creates more optimization opportunities.\n\nThe extern keyword or @extern builtin function can be used to link against a variable that is exported from another object. The export keyword or @export builtin function can be used to make a variable available to other objects at link time. In both cases, the type of the variable must be C ABI compatible.\n\nSee also:\n\nExporting a C Library\n\nIdentifiers Â§\n\nVariable identifiers are never allowed to shadow identifiers from an outer scope.\n\nIdentifiers must start with an alphabetic character or underscore and may be followed by any number of alphanumeric characters or underscores. They must not overlap with any keywords. See Keyword Reference.\n\nIf a name that does not fit these requirements is needed, such as for linking with external libraries, the @\"\" syntax may be used.\n\nContainer Level Variables Â§\n\nContainer level variables have static lifetime and are order-independent and lazily analyzed. The initialization value of container level variables is implicitly comptime. If a container level variable is const then its value is comptime-known, otherwise it is runtime-known.\n\nContainer level variables may be declared inside a struct, union, enum, or opaque:\n\nStatic Local Variables Â§\n\nIt is also possible to have local variables with static lifetime by using containers inside functions.\n\nThread Local Variables Â§\n\nA variable may be specified to be a thread-local variable using the threadlocal keyword, which makes each thread work with a separate instance of the variable:\n\nFor Single Threaded Builds, all thread local variables are treated as regular Container Level Variables.\n\nThread local variables may not be const.\n\nLocal Variables Â§\n\nLocal variables occur inside Functions, comptime blocks, and @cImport blocks.\n\nWhen a local variable is const, it means that after initialization, the variable's value will not change. If the initialization value of a const variable is comptime-known, then the variable is also comptime-known.\n\nA local variable may be qualified with the comptime keyword. This causes the variable's value to be comptime-known, and all loads and stores of the variable to happen during semantic analysis of the program, rather than at runtime. All variables declared in a comptime expression are implicitly comptime variables.\n\nIntegers Â§\n\nInteger Literals Â§\n\nRuntime Integer Values Â§\n\nInteger literals have no size limitation, and if any undefined behavior occurs, the compiler catches it.\n\nHowever, once an integer value is no longer known at compile-time, it must have a known size, and is vulnerable to undefined behavior.\n\nIn this function, values a and b are known only at runtime, and thus this division operation is vulnerable to both Integer Overflow and Division by Zero.\n\nOperators such as + and - cause undefined behavior on integer overflow. Alternative operators are provided for wrapping and saturating arithmetic on all targets. +% and -% perform wrapping arithmetic while +| and -| perform saturating arithmetic.\n\nZig supports arbitrary bit-width integers, referenced by using an identifier of i or u followed by digits. For example, the identifier i7 refers to a signed 7-bit integer. The maximum allowed bit-width of an integer type is 65535. For signed integer types, Zig uses a two's complement representation.\n\nSee also:\n\nWrapping Operations\n\nFloats Â§\n\nZig has the following floating point types:\n\nf16 - IEEE-754-2008 binary16\n\nf32 - IEEE-754-2008 binary32\n\nf64 - IEEE-754-2008 binary64\n\nf80 - IEEE-754-2008 80-bit extended precision\n\nf128 - IEEE-754-2008 binary128\n\nc_longdouble - matches long double for the target C ABI\n\nFloat Literals Â§\n\nFloat literals have type comptime_float which is guaranteed to have the same precision and operations of the largest other floating point type, which is f128.\n\nFloat literals coerce to any floating point type, and to any integer type when there is no fractional component.\n\nThere is no syntax for NaN, infinity, or negative infinity. For these special values, one must use the standard library:\n\nFloating Point Operations Â§\n\nBy default floating point operations use Strict mode, but you can switch to Optimized mode on a per-block basis:\n\nFor this test we have to separate code into two object files - otherwise the optimizer figures out all the values at compile-time, which operates in strict mode.\n\nSee also:\n\n@setFloatMode\n\nDivision by Zero\n\nOperators Â§\n\nThere is no operator overloading. When you see an operator in Zig, you know that it is doing something from this table, and nothing else.\n\nTable of Operators Â§\n\nPrecedence Â§\n\nx() x[] x.y x.* x.? a!b x{} !x -x -%x ~x &x ?x * / % ** *% *| || + - ++ +% -% +| -| << >> <<| & ^ | orelse catch == != < > <= >= and or = *= *%= *|= /= %= += +%= +|= -= -%= -|= <<= <<|= >>= &= ^= |=\n\nArrays Â§\n\nSee also:\n\nfor\n\nSlices\n\nMultidimensional Arrays Â§\n\nMultidimensional arrays can be created by nesting arrays:\n\nSentinel-Terminated Arrays Â§\n\nThe syntax [N:x]T describes an array which has a sentinel element of value x at the index corresponding to the length N.\n\nSee also:\n\nSentinel-Terminated Pointers\n\nSentinel-Terminated Slices\n\nVectors Â§\n\nA vector is a group of booleans, Integers, Floats, or Pointers which are operated on in parallel, using SIMD instructions if possible. Vector types are created with the builtin function @Vector.\n\nVectors support the same builtin operators as their underlying base types. These operations are performed element-wise, and return a vector of the same length as the input vectors. This includes:\n\nArithmetic (+, -, /, *, @divFloor, @sqrt, @ceil, @log, etc.)\n\nBitwise operators (>>, <<, &, |, ~, etc.)\n\nComparison operators (<, >, ==, etc.)\n\nIt is prohibited to use a math operator on a mixture of scalars (individual numbers) and vectors. Zig provides the @splat builtin to easily convert from scalars to vectors, and it supports @reduce and array indexing syntax to convert from vectors to scalars. Vectors also support assignment to and from fixed-length arrays with comptime-known length.\n\nFor rearranging elements within and between vectors, Zig provides the @shuffle and @select functions.\n\nOperations on vectors shorter than the target machine's native SIMD size will typically compile to single SIMD instructions, while vectors longer than the target machine's native SIMD size will compile to multiple SIMD instructions. If a given operation doesn't have SIMD support on the target architecture, the compiler will default to operating on each vector element one at a time. Zig supports any comptime-known vector length up to 2^32-1, although small powers of two (2-64) are most typical. Note that excessively long vector lengths (e.g. 2^20) may result in compiler crashes on current versions of Zig.\n\nTODO talk about C ABI interop\n\nTODO consider suggesting std.MultiArrayList\n\nSee also:\n\n@splat\n\n@shuffle\n\n@select\n\n@reduce\n\nPointers Â§\n\nZig has two kinds of pointers: single-item and many-item.\n\n*T - single-item pointer to exactly one item.\n\nSupports deref syntax: ptr.*\n\nSupports slice syntax: ptr[0..1]\n\nSupports pointer subtraction: ptr - ptr\n\n[*]T - many-item pointer to unknown number of items.\n\nSupports index syntax: ptr[i]\n\nSupports slice syntax: ptr[start..end] and ptr[start..]\n\nSupports pointer-integer arithmetic: ptr + int, ptr - int\n\nSupports pointer subtraction: ptr - ptr\n\nT must have a known size, which means that it cannot be anyopaque or any other opaque type.\n\nThese types are closely related to Arrays and Slices:\n\n*[N]T - pointer to N items, same as single-item pointer to an array.\n\nSupports index syntax: array_ptr[i]\n\nSupports slice syntax: array_ptr[start..end]\n\nSupports len property: array_ptr.len\n\nSupports pointer subtraction: array_ptr - array_ptr\n\n[]T - is a slice (a fat pointer, which contains a pointer of type [*]T and a length).\n\nSupports index syntax: slice[i]\n\nSupports slice syntax: slice[start..end]\n\nSupports len property: slice.len\n\nUse &x to obtain a single-item pointer:\n\nZig supports pointer arithmetic. It's better to assign the pointer to [*]T and increment that variable. For example, directly incrementing the pointer from a slice will corrupt it.\n\nIn Zig, we generally prefer Slices rather than Sentinel-Terminated Pointers. You can turn an array or pointer into a slice using slice syntax.\n\nSlices have bounds checking and are therefore protected against this kind of undefined behavior. This is one reason we prefer slices to pointers.\n\nPointers work at compile-time too, as long as the code does not depend on an undefined memory layout:\n\nTo convert an integer address into a pointer, use @ptrFromInt. To convert a pointer to an integer, use @intFromPtr:\n\nZig is able to preserve memory addresses in comptime code, as long as the pointer is never dereferenced:\n\nSee also:\n\nOptional Pointers\n\n@ptrFromInt\n\n@intFromPtr\n\nC Pointers\n\nvolatile Â§\n\nLoads and stores are assumed to not have side effects. If a given load or store should have side effects, such as Memory Mapped Input/Output (MMIO), use volatile. In the following code, loads and stores with mmio_ptr are guaranteed to all happen and in the same order as in source code:\n\nNote that volatile is unrelated to concurrency and Atomics. If you see code that is using volatile for something other than Memory Mapped Input/Output, it is probably a bug.\n\n@ptrCast converts a pointer's element type to another. This creates a new pointer that can cause undetectable illegal behavior depending on the loads and stores that pass through it. Generally, other kinds of type conversions are preferable to @ptrCast if possible.\n\nAlignment Â§\n\nEach type has an alignment - a number of bytes such that, when a value of the type is loaded from or stored to memory, the memory address must be evenly divisible by this number. You can use @alignOf to find out this value for any type.\n\nAlignment depends on the CPU architecture, but is always a power of two, and less than 1 << 29.\n\nIn Zig, a pointer type has an alignment value. If the value is equal to the alignment of the underlying type, it can be omitted from the type:\n\nIn the same way that a *i32 can be coerced to a *const i32, a pointer with a larger alignment can be implicitly cast to a pointer with a smaller alignment, but not vice versa.\n\nYou can specify alignment on variables and functions. If you do this, then pointers to them get the specified alignment:\n\nIf you have a pointer or a slice that has a small alignment, but you know that it actually has a bigger alignment, use @alignCast to change the pointer into a more aligned pointer. This is a no-op at runtime, but inserts a safety check:\n\nallowzero Â§\n\nThis pointer attribute allows a pointer to have address zero. This is only ever needed on the freestanding OS target, where the address zero is mappable. If you want to represent null pointers, use Optional Pointers instead. Optional Pointers with allowzero are not the same size as pointers. In this code example, if the pointer did not have the allowzero attribute, this would be a Pointer Cast Invalid Null panic:\n\nSentinel-Terminated Pointers Â§\n\nThe syntax [*:x]T describes a pointer that has a length determined by a sentinel value. This provides protection against buffer overflow and overreads.\n\nSee also:\n\nSentinel-Terminated Slices\n\nSentinel-Terminated Arrays\n\nSlices Â§\n\nA slice is a pointer and a length. The difference between an array and a slice is that the array's length is part of the type and known at compile-time, whereas the slice's length is known at runtime. Both can be accessed with the len field.\n\nThis is one reason we prefer slices to pointers.\n\nSee also:\n\nPointers\n\nfor\n\nArrays\n\nSentinel-Terminated Slices Â§\n\nThe syntax [:x]T is a slice which has a runtime-known length and also guarantees a sentinel value at the element indexed by the length. The type does not guarantee that there are no sentinel elements before that. Sentinel-terminated slices allow element access to the len index.\n\nSentinel-terminated slices can also be created using a variation of the slice syntax data[start..end :x], where data is a many-item pointer, array or slice and x is the sentinel value.\n\nSentinel-terminated slicing asserts that the element in the sentinel position of the backing data is actually the sentinel value. If this is not the case, safety-protected Undefined Behavior results.\n\nSee also:\n\nSentinel-Terminated Pointers\n\nSentinel-Terminated Arrays\n\nstruct Â§\n\nDefault Field Values Â§\n\nEach struct field may have an expression indicating the default field value. Such expressions are executed at comptime, and allow the field to be omitted in a struct literal expression:\n\nDefault field values are only appropriate when the data invariants of a struct cannot be violated by omitting that field from an initialization.\n\nFor example, here is an inappropriate use of default struct field initialization:\n\nAbove you can see the danger of ignoring this principle. The default field values caused the data invariant to be violated, causing illegal behavior.\n\nTo fix this, remove the default values from all the struct fields, and provide a named default value:\n\nIf a struct value requires a runtime-known value in order to be initialized without violating data invariants, then use an initialization method that accepts those runtime values, and populates the remaining fields.\n\nextern struct Â§\n\nAn extern struct has in-memory layout matching the C ABI for the target.\n\nIf well-defined in-memory layout is not required, struct is a better choice because it places fewer restrictions on the compiler.\n\nSee packed struct for a struct that has the ABI of its backing integer, which can be useful for modeling flags.\n\nSee also:\n\nextern union\n\nextern enum\n\npacked struct Â§\n\nUnlike normal structs, packed structs have guaranteed in-memory layout:\n\nFields remain in the order declared, least to most significant.\n\nThere is no padding between fields.\n\nZig supports arbitrary width Integers and although normally, integers with fewer than 8 bits will still use 1 byte of memory, in packed structs, they use exactly their bit width.\n\nbool fields use exactly 1 bit.\n\nAn enum field uses exactly the bit width of its integer tag type.\n\nA packed union field uses exactly the bit width of the union field with the largest bit width.\n\nThis means that a packed struct can participate in a @bitCast or a @ptrCast to reinterpret memory. This even works at comptime:\n\nThe backing integer is inferred from the fields' total bit width. Optionally, it can be explicitly provided and enforced at compile time:\n\nZig allows the address to be taken of a non-byte-aligned field:\n\nHowever, the pointer to a non-byte-aligned field has special properties and cannot be passed when a normal pointer is expected:\n\nIn this case, the function bar cannot be called because the pointer to the non-ABI-aligned field mentions the bit offset, but the function expects an ABI-aligned pointer.\n\nPointers to non-ABI-aligned fields share the same address as the other fields within their host integer:\n\nThis can be observed with @bitOffsetOf and offsetOf:\n\nPacked structs have the same alignment as their backing integer, however, overaligned pointers to packed structs can override this:\n\nIt's also possible to set alignment of struct fields:\n\nUsing packed structs with volatile is problematic, and may be a compile error in the future. For details on this subscribe to this issue. TODO update these docs with a recommendation on how to use packed structs with MMIO (the use case for volatile packed structs) once this issue is resolved. Don't worry, there will be a good solution for this use case in zig.\n\nStruct Naming Â§\n\nSince all structs are anonymous, Zig infers the type name based on a few rules.\n\nIf the struct is in the initialization expression of a variable, it gets named after that variable.\n\nIf the struct is in the return expression, it gets named after the function it is returning from, with the parameter values serialized.\n\nOtherwise, the struct gets a name such as (filename.funcname.__struct_ID).\n\nIf the struct is declared inside another struct, it gets named after both the parent struct and the name inferred by the previous rules, separated by a dot.\n\nAnonymous Struct Literals Â§\n\nZig allows omitting the struct type of a literal. When the result is coerced, the struct literal will directly instantiate the result location, with no copy:\n\nThe struct type can be inferred. Here the result location does not include a type, and so Zig infers the type:\n\nTuples Â§\n\nAnonymous structs can be created without specifying field names, and are referred to as \"tuples\".\n\nThe fields are implicitly named using numbers starting from 0. Because their names are integers, they cannot be accessed with . syntax without also wrapping them in @\"\". Names inside @\"\" are always recognised as identifiers.\n\nLike arrays, tuples have a .len field, can be indexed (provided the index is comptime-known) and work with the ++ and ** operators. They can also be iterated over with inline for.\n\nSee also:\n\ncomptime\n\n@fieldParentPtr\n\nenum Â§\n\nSee also:\n\n@typeInfo\n\n@tagName\n\n@sizeOf\n\nextern enum Â§\n\nBy default, enums are not guaranteed to be compatible with the C ABI:\n\nFor a C-ABI-compatible enum, provide an explicit tag type to the enum:\n\nEnum Literals Â§\n\nEnum literals allow specifying the name of an enum field without specifying the enum type:\n\nNon-exhaustive enum Â§\n\nA non-exhaustive enum can be created by adding a trailing _ field. The enum must specify a tag type and cannot consume every enumeration value.\n\n@enumFromInt on a non-exhaustive enum involves the safety semantics of @intCast to the integer tag type, but beyond that always results in a well-defined enum value.\n\nA switch on a non-exhaustive enum can include a _ prong as an alternative to an else prong. With a _ prong the compiler errors if all the known tag names are not handled by the switch.\n\nunion Â§\n\nA bare union defines a set of possible types that a value can be as a list of fields. Only one field can be active at a time. The in-memory representation of bare unions is not guaranteed. Bare unions cannot be used to reinterpret memory. For that, use @ptrCast, or use an extern union or a packed union which have guaranteed in-memory layout. Accessing the non-active field is safety-checked Undefined Behavior:\n\nYou can activate another field by assigning the entire union:\n\nIn order to use switch with a union, it must be a Tagged union.\n\nTo initialize a union when the tag is a comptime-known name, see @unionInit.\n\nTagged union Â§\n\nUnions can be declared with an enum tag type. This turns the union into a tagged union, which makes it eligible to use with switch expressions. Tagged unions coerce to their tag type: Type Coercion: Unions and Enums.\n\nIn order to modify the payload of a tagged union in a switch expression, place a * before the variable name to make it a pointer:\n\nUnions can be made to infer the enum tag type. Further, unions can have methods just like structs and enums.\n\n@tagName can be used to return a comptime [:0]const u8 value representing the field name:\n\nextern union Â§\n\nAn extern union has memory layout guaranteed to be compatible with the target C ABI.\n\nSee also:\n\nextern struct\n\npacked union Â§\n\nA packed union has well-defined in-memory layout and is eligible to be in a packed struct.\n\nAnonymous Union Literals Â§\n\nAnonymous Struct Literals syntax can be used to initialize unions without specifying the type:\n\nopaque Â§\n\nopaque {} declares a new type with an unknown (but non-zero) size and alignment. It can contain declarations the same as structs, unions, and enums.\n\nThis is typically used for type safety when interacting with C code that does not expose struct details. Example:\n\nBlocks Â§\n\nBlocks are used to limit the scope of variable declarations:\n\nBlocks are expressions. When labeled, break can be used to return a value from the block:\n\nHere, blk can be any name.\n\nSee also:\n\nLabeled while\n\nLabeled for\n\nShadowing Â§\n\nIdentifiers are never allowed to \"hide\" other identifiers by using the same name:\n\nBecause of this, when you read Zig code you can always rely on an identifier to consistently mean the same thing within the scope it is defined. Note that you can, however, use the same name if the scopes are separate:\n\nEmpty Blocks Â§\n\nAn empty block is equivalent to void{}:\n\nswitch Â§\n\nswitch can be used to capture the field values of a Tagged union. Modifications to the field values can be done by placing a * before the capture variable name, turning it into a pointer.\n\nSee also:\n\ncomptime\n\nenum\n\n@compileError\n\nCompile Variables\n\nExhaustive Switching Â§\n\nWhen a switch expression does not have an else clause, it must exhaustively list all the possible values. Failure to do so is a compile error:\n\nSwitching with Enum Literals Â§\n\nEnum Literals can be useful to use with switch to avoid repetitively specifying enum or union types:\n\nInline Switch Prongs Â§\n\nSwitch prongs can be marked as inline to generate the prong's body for each possible value it could have, making the captured value comptime.\n\nThe inline keyword may also be combined with ranges:\n\ninline else prongs can be used as a type safe alternative to inline for loops:\n\nWhen using an inline prong switching on an union an additional capture can be used to obtain the union's enum tag value.\n\nSee also:\n\ninline while\n\ninline for\n\nwhile Â§\n\nA while loop is used to repeatedly execute an expression until some condition is no longer true.\n\nUse break to exit a while loop early.\n\nUse continue to jump back to the beginning of the loop.\n\nWhile loops support a continue expression which is executed when the loop is continued. The continue keyword respects this expression.\n\nWhile loops are expressions. The result of the expression is the result of the else clause of a while loop, which is executed when the condition of the while loop is tested as false.\n\nbreak, like return, accepts a value parameter. This is the result of the while expression. When you break from a while loop, the else branch is not evaluated.\n\nLabeled while Â§\n\nWhen a while loop is labeled, it can be referenced from a break or continue from within a nested loop:\n\nwhile with Optionals Â§\n\nJust like if expressions, while loops can take an optional as the condition and capture the payload. When null is encountered the loop exits.\n\nWhen the |x| syntax is present on a while expression, the while condition must have an Optional Type.\n\nThe else branch is allowed on optional iteration. In this case, it will be executed on the first null value encountered.\n\nwhile with Error Unions Â§\n\nJust like if expressions, while loops can take an error union as the condition and capture the payload or the error code. When the condition results in an error code the else branch is evaluated and the loop is finished.\n\nWhen the else |x| syntax is present on a while expression, the while condition must have an Error Union Type.\n\ninline while Â§\n\nWhile loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values.\n\nIt is recommended to use inline loops only for one of these reasons:\n\nYou need the loop to execute at comptime for the semantics to work.\n\nYou have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\nif\n\nOptionals\n\nErrors\n\ncomptime\n\nunreachable\n\nfor Â§\n\nLabeled for Â§\n\nWhen a for loop is labeled, it can be referenced from a break or continue from within a nested loop:\n\ninline for Â§\n\nFor loops can be inlined. This causes the loop to be unrolled, which allows the code to do some things which only work at compile time, such as use types as first class values. The capture value and iterator value of inlined for loops are compile-time known.\n\nIt is recommended to use inline loops only for one of these reasons:\n\nYou need the loop to execute at comptime for the semantics to work.\n\nYou have a benchmark to prove that forcibly unrolling the loop in this way is measurably faster.\n\nSee also:\n\nwhile\n\ncomptime\n\nArrays\n\nSlices\n\nif Â§\n\nif with Optionals Â§\n\nSee also:\n\nOptionals\n\nErrors\n\ndefer Â§\n\nExecutes an expression unconditionally at scope exit.\n\nDefer expressions are evaluated in reverse order.\n\nInside a defer expression the return statement is not allowed.\n\nSee also:\n\nErrors\n\nunreachable Â§\n\nIn Debug and ReleaseSafe mode unreachable emits a call to panic with the message reached unreachable code.\n\nIn ReleaseFast and ReleaseSmall mode, the optimizer uses the assumption that unreachable code will never be hit to perform optimizations.\n\nBasics Â§\n\nIn fact, this is how std.debug.assert is implemented:\n\nAt Compile-Time Â§\n\nSee also:\n\nZig Test\n\nBuild Mode\n\ncomptime\n\nnoreturn Â§\n\nnoreturn is the type of:\n\nbreak\n\ncontinue\n\nreturn\n\nunreachable\n\nwhile (true) {}\n\nWhen resolving types together, such as if clauses or switch prongs, the noreturn type is compatible with every other type. Consider:\n\nAnother use case for noreturn is the exit function:\n\nFunctions Â§\n\nThere is a difference between a function body and a function pointer. Function bodies are comptime-only types while function Pointers may be runtime-known.\n\nPass-by-value Parameters Â§\n\nPrimitive types such as Integers and Floats passed as parameters are copied, and then the copy is available in the function body. This is called \"passing by value\". Copying a primitive type is essentially free and typically involves nothing more than setting a register.\n\nStructs, unions, and arrays can sometimes be more efficiently passed as a reference, since a copy could be arbitrarily expensive depending on the size. When these types are passed as parameters, Zig may choose to copy and pass by value, or pass by reference, whichever way Zig decides will be faster. This is made possible, in part, by the fact that parameters are immutable.\n\nFor extern functions, Zig follows the C ABI for passing structs and unions by value.\n\nFunction Parameter Type Inference Â§\n\nFunction parameters can be declared with anytype in place of the type. In this case the parameter types will be inferred when the function is called. Use @TypeOf and @typeInfo to get information about the inferred type.\n\ninline fn Â§\n\nAdding the inline keyword to a function definition makes that function become semantically inlined at the callsite. This is not a hint to be possibly observed by optimization passes, but has implications on the types and values involved in the function call.\n\nUnlike normal function calls, arguments at an inline function callsite which are compile-time known are treated as Compile Time Parameters. This can potentially propagate all the way to the return value:\n\nIf inline is removed, the test fails with the compile error instead of passing.\n\nIt is generally better to let the compiler decide when to inline a function, except for these scenarios:\n\nTo change how many stack frames are in the call stack, for debugging purposes.\n\nTo force comptime-ness of the arguments to propagate to the return value of the function, as in the above example.\n\nReal world performance measurements demand it.\n\nNote that inline actually restricts what the compiler is allowed to do. This can harm binary size, compilation speed, and even runtime performance.\n\nFunction Reflection Â§\n\nErrors Â§\n\nError Set Type Â§\n\nAn error set is like an enum. However, each error name across the entire compilation gets assigned an unsigned integer greater than 0. You are allowed to declare the same error name more than once, and if you do, it gets assigned the same integer value.\n\nThe error set type defaults to a u16, though if the maximum number of distinct error values is provided via the --error-limit [num] command line parameter an integer type with the minimum number of bits required to represent all of the error values will be used.\n\nYou can coerce an error from a subset to a superset:\n\nBut you cannot coerce an error from a superset to a subset:\n\nThere is a shortcut for declaring an error set with only 1 value, and then getting that value:\n\nThis is equivalent to:\n\nThis becomes useful when using Inferred Error Sets.\n\nThe Global Error Set Â§\n\nanyerror refers to the global error set. This is the error set that contains all errors in the entire compilation unit. It is a superset of all other error sets and a subset of none of them.\n\nYou can coerce any error set to the global one, and you can explicitly cast an error of the global error set to a non-global one. This inserts a language-level assert to make sure the error value is in fact in the destination error set.\n\nThe global error set should generally be avoided because it prevents the compiler from knowing what errors are possible at compile-time. Knowing the error set at compile-time is better for generated documentation and helpful error messages, such as forgetting a possible error value in a switch.\n\nError Union Type Â§\n\nAn error set type and normal type can be combined with the ! binary operator to form an error union type. You are likely to use an error union type more often than an error set type by itself.\n\nHere is a function to parse a string into a 64-bit integer:\n\nNotice the return type is !u64. This means that the function either returns an unsigned 64 bit integer, or an error. We left off the error set to the left of the !, so the error set is inferred.\n\nWithin the function definition, you can see some return statements that return an error, and at the bottom a return statement that returns a u64. Both types coerce to anyerror!u64.\n\nWhat it looks like to use this function varies depending on what you're trying to do. One of the following:\n\nYou want to provide a default value if it returned an error.\n\nIf it returned an error then you want to return the same error.\n\nYou know with complete certainty it will not return an error, so want to unconditionally unwrap it.\n\nYou want to take a different action for each possible error.\n\ncatch Â§\n\nIf you want to provide a default value, you can use the catch binary operator:\n\nIn this code, number will be equal to the successfully parsed string, or a default value of 13. The type of the right hand side of the binary catch operator must match the unwrapped error union type, or be of type noreturn.\n\nIf you want to provide a default value with catch after performing some logic, you can combine catch with named Blocks:\n\ntry Â§\n\nLet's say you wanted to return the error if you got one, otherwise continue with the function logic:\n\nThere is a shortcut for this. The try expression:\n\ntry evaluates an error union expression. If it is an error, it returns from the current function with the same error. Otherwise, the expression results in the unwrapped value.\n\nMaybe you know with complete certainty that an expression will never be an error. In this case you can do this:\n\nconst number = parseU64(\"1234\", 10) catch unreachable;\n\nHere we know for sure that \"1234\" will parse successfully. So we put the unreachable value on the right hand side. unreachable generates a panic in Debug and ReleaseSafe modes and undefined behavior in ReleaseFast and ReleaseSmall modes. So, while we're debugging the application, if there was a surprise error here, the application would crash appropriately.\n\nYou may want to take a different action for every situation. For that, we combine the if and switch expression:\n\nFinally, you may want to handle only some errors. For that, you can capture the unhandled errors in the else case, which now contains a narrower error set:\n\nYou must use the variable capture syntax. If you don't need the variable, you can capture with _ and avoid the switch.\n\nerrdefer Â§\n\nThe other component to error handling is defer statements. In addition to an unconditional defer, Zig has errdefer, which evaluates the deferred expression on block exit path if and only if the function returned with an error from the block.\n\nExample:\n\nThe neat thing about this is that you get robust error handling without the verbosity and cognitive overhead of trying to make sure every exit path is covered. The deallocation code is always directly following the allocation code.\n\nThe errdefer statement can optionally capture the error:\n\nCommon errdefer Slip-Ups Â§\n\nIt should be noted that errdefer statements only last until the end of the block they are written in, and therefore are not run if an error is returned outside of that block:\n\nTo ensure that deallocateFoo is properly called when returning an error, you must add an errdefer outside of the block:\n\nThe fact that errdefers only last for the block they are declared in is especially important when using loops:\n\nSpecial care must be taken with code that allocates in a loop to make sure that no memory is leaked when returning an error:\n\nA couple of other tidbits about error handling:\n\nThese primitives give enough expressiveness that it's completely practical to have failing to check for an error be a compile error. If you really want to ignore the error, you can add catch unreachable and get the added benefit of crashing in Debug and ReleaseSafe modes if your assumption was wrong.\n\nSince Zig understands error types, it can pre-weight branches in favor of errors not occurring. Just a small optimization benefit that is not available in other languages.\n\nSee also:\n\ndefer\n\nif\n\nswitch\n\nAn error union is created with the ! binary operator. You can use compile-time reflection to access the child type of an error union:\n\nMerging Error Sets Â§\n\nUse the || operator to merge two error sets together. The resulting error set contains the errors of both error sets. Doc comments from the left-hand side override doc comments from the right-hand side. In this example, the doc comments for C.PathNotFound is A doc comment.\n\nThis is especially useful for functions which return different error sets depending on comptime branches. For example, the Zig standard library uses LinuxFileOpenError || WindowsFileOpenError for the error set of opening files.\n\nInferred Error Sets Â§\n\nBecause many functions in Zig return a possible error, Zig supports inferring the error set. To infer the error set for a function, prepend the ! operator to the functionâs return type, like !T:\n\nWhen a function has an inferred error set, that function becomes generic and thus it becomes trickier to do certain things with it, such as obtain a function pointer, or have an error set that is consistent across different build targets. Additionally, inferred error sets are incompatible with recursion.\n\nIn these situations, it is recommended to use an explicit error set. You can generally start with an empty error set and let compile errors guide you toward completing the set.\n\nThese limitations may be overcome in a future version of Zig.\n\nError Return Traces Â§\n\nError Return Traces show all the points in the code that an error was returned to the calling function. This makes it practical to use try everywhere and then still be able to know what happened if an error ends up bubbling all the way out of your application.\n\nLook closely at this example. This is no stack trace.\n\nYou can see that the final error bubbled up was PermissionDenied, but the original error that started this whole thing was FileNotFound. In the bar function, the code handles the original error code, and then returns another one, from the switch statement. Error Return Traces make this clear, whereas a stack trace would look like this:\n\nHere, the stack trace does not explain how the control flow in bar got to the hello() call. One would have to open a debugger or further instrument the application in order to find out. The error return trace, on the other hand, shows exactly how the error bubbled up.\n\nThis debugging feature makes it easier to iterate quickly on code that robustly handles all error conditions. This means that Zig developers will naturally find themselves writing correct, robust code in order to increase their development pace.\n\nError Return Traces are enabled by default in Debug and ReleaseSafe builds and disabled by default in ReleaseFast and ReleaseSmall builds.\n\nThere are a few ways to activate this error return tracing feature:\n\nReturn an error from main\n\nAn error makes its way to catch unreachable and you have not overridden the default panic handler\n\nUse errorReturnTrace to access the current return trace. You can use std.debug.dumpStackTrace to print it. This function returns comptime-known null when building without error return tracing support.\n\nImplementation Details Â§\n\nTo analyze performance cost, there are two cases:\n\nwhen no errors are returned\n\nwhen returning errors\n\nFor the case when no errors are returned, the cost is a single memory write operation, only in the first non-failable function in the call graph that calls a failable function, i.e. when a function returning void calls a function returning error. This is to initialize this struct in the stack memory:\n\nHere, N is the maximum function call depth as determined by call graph analysis. Recursion is ignored and counts for 2.\n\nA pointer to StackTrace is passed as a secret parameter to every function that can return an error, but it's always the first parameter, so it can likely sit in a register and stay there.\n\nThat's it for the path when no errors occur. It's practically free in terms of performance.\n\nWhen generating the code for a function that returns an error, just before the return statement (only for the return statements that return errors), Zig generates a call to this function:\n\nThe cost is 2 math operations plus some memory reads and writes. The memory accessed is constrained and should remain cached for the duration of the error return bubbling.\n\nAs for code size cost, 1 function call before a return statement is no big deal. Even so, I have a plan to make the call to __zig_return_error a tail call, which brings the code size cost down to actually zero. What is a return statement in code without error return tracing can become a jump instruction in code with error return tracing.\n\nOptionals Â§\n\nOne area that Zig provides safety without compromising efficiency or readability is with the optional type.\n\nThe question mark symbolizes the optional type. You can convert a type to an optional type by putting a question mark in front of it, like this:\n\nNow the variable optional_int could be an i32, or null.\n\nInstead of integers, let's talk about pointers. Null references are the source of many runtime exceptions, and even stand accused of being the worst mistake of computer science.\n\nZig does not have them.\n\nInstead, you can use an optional pointer. This secretly compiles down to a normal pointer, since we know we can use 0 as the null value for the optional type. But the compiler can check your work and make sure you don't assign null to something that can't be null.\n\nTypically the downside of not having null is that it makes the code more verbose to write. But, let's compare some equivalent C code and Zig code.\n\nTask: call malloc, if the result is null, return null.\n\nC code\n\nZig code\n\nHere, Zig is at least as convenient, if not more, than C. And, the type of \"ptr\" is [*]u8 not ?[*]u8. The orelse keyword unwrapped the optional type and therefore ptr is guaranteed to be non-null everywhere it is used in the function.\n\nThe other form of checking against NULL you might see looks like this:\n\nIn Zig you can accomplish the same thing:\n\nOnce again, the notable thing here is that inside the if block, foo is no longer an optional pointer, it is a pointer, which cannot be null.\n\nOne benefit to this is that functions which take pointers as arguments can be annotated with the \"nonnull\" attribute - __attribute__((nonnull)) in GCC. The optimizer can sometimes make better decisions knowing that pointer arguments cannot be null.\n\nOptional Type Â§\n\nAn optional is created by putting ? in front of a type. You can use compile-time reflection to access the child type of an optional:\n\nnull Â§\n\nJust like undefined, null has its own type, and the only way to use it is to cast it to a different type:\n\nOptional Pointers Â§\n\nAn optional pointer is guaranteed to be the same size as a pointer. The null of the optional is guaranteed to be address 0.\n\nSee also:\n\nwhile with Optionals\n\nif with Optionals\n\nCasting Â§\n\nA type cast converts a value of one type to another. Zig has Type Coercion for conversions that are known to be completely safe and unambiguous, and Explicit Casts for conversions that one would not want to happen on accident. There is also a third kind of type conversion called Peer Type Resolution for the case when a result type must be decided given multiple operand types.\n\nType Coercion Â§\n\nType coercion occurs when one type is expected, but different type is provided:\n\nType coercions are only allowed when it is completely unambiguous how to get from one type to another, and the transformation is guaranteed to be safe. There is one exception, which is C Pointers.\n\nType Coercion: Stricter Qualification Â§\n\nValues which have the same representation at runtime can be cast to increase the strictness of the qualifiers, no matter how nested the qualifiers are:\n\nconst - non-const to const is allowed\n\nvolatile - non-volatile to volatile is allowed\n\nalign - bigger to smaller alignment is allowed\n\nerror sets to supersets is allowed\n\nThese casts are no-ops at runtime since the value representation does not change.\n\nIn addition, pointers coerce to const optional pointers:\n\nType Coercion: Integer and Float Widening Â§\n\nIntegers coerce to integer types which can represent every value of the old type, and likewise Floats coerce to float types which can represent every value of the old type.\n\nType Coercion: Float to Int Â§\n\nA compiler error is appropriate because this ambiguous expression leaves the compiler two choices about the coercion.\n\nCast 54.0 to comptime_int resulting in @as(comptime_int, 10), which is casted to @as(f32, 10)\n\nCast 5 to comptime_float resulting in @as(comptime_float, 10.8), which is casted to @as(f32, 10.8)\n\nType Coercion: Slices, Arrays and Pointers Â§\n\nSee also:\n\nC Pointers\n\nType Coercion: Optionals Â§\n\nThe payload type of Optionals, as well as null, coerce to the optional type.\n\nOptionals work nested inside the Error Union Type, too:\n\nType Coercion: Error Unions Â§\n\nThe payload type of an Error Union Type as well as the Error Set Type coerce to the error union type:\n\nType Coercion: Compile-Time Known Numbers Â§\n\nWhen a number is comptime-known to be representable in the destination type, it may be coerced:\n\nType Coercion: Unions and Enums Â§\n\nTagged unions can be coerced to enums, and enums can be coerced to tagged unions when they are comptime-known to be a field of the union that has only one possible value, such as void:\n\nSee also:\n\nunion\n\nenum\n\nType Coercion: undefined Â§\n\nundefined can be coerced to any type.\n\nType Coercion: Tuples to Arrays Â§\n\nTuples can be coerced to arrays, if all of the fields have the same type.\n\nExplicit Casts Â§\n\nExplicit casts are performed via Builtin Functions. Some explicit casts are safe; some are not. Some explicit casts perform language-level assertions; some do not. Some explicit casts are no-ops at runtime; some are not.\n\n@bitCast - change type but maintain bit representation\n\n@alignCast - make a pointer have more alignment\n\n@enumFromInt - obtain an enum value based on its integer tag value\n\n@errorFromInt - obtain an error code based on its integer value\n\n@errorCast - convert to a smaller error set\n\n@floatCast - convert a larger float to a smaller float\n\n@floatFromInt - convert an integer to a float value\n\n@intCast - convert between integer types\n\n@intFromBool - convert true to 1 and false to 0\n\n@intFromEnum - obtain the integer tag value of an enum or tagged union\n\n@intFromError - obtain the integer value of an error code\n\n@intFromFloat - obtain the integer part of a float value\n\n@intFromPtr - obtain the address of a pointer\n\n@ptrFromInt - convert an address to a pointer\n\n@ptrCast - convert between pointer types\n\n@truncate - convert between integer types, chopping off bits\n\nPeer Type Resolution Â§\n\nPeer Type Resolution occurs in these places:\n\nswitch expressions\n\nif expressions\n\nwhile expressions\n\nfor expressions\n\nMultiple break statements in a block\n\nSome binary operations\n\nThis kind of type resolution chooses a type that all peer types can coerce into. Here are some examples:\n\nZero Bit Types Â§\n\nFor some types, @sizeOf is 0:\n\nvoid\n\nThe Integers u0 and i0.\n\nArrays and Vectors with len 0, or with an element type that is a zero bit type.\n\nAn enum with only 1 tag.\n\nA struct with all fields being zero bit types.\n\nA union with only 1 field which is a zero bit type.\n\nThese types can only ever have one possible value, and thus require 0 bits to represent. Code that makes use of these types is not included in the final generated code:\n\nWhen this turns into machine code, there is no code generated in the body of entry, even in Debug mode. For example, on x86_64:\n\n0000000000000010 <entry>: 10: 55 push %rbp 11: 48 89 e5 mov %rsp,%rbp 14: 5d pop %rbp 15: c3 retq\n\nThese assembly instructions do not have any code associated with the void values - they only perform the function call prologue and epilogue.\n\nvoid Â§\n\nvoid can be useful for instantiating generic types. For example, given a Map(Key, Value), one can pass void for the Value type to make it into a Set:\n\nNote that this is different from using a dummy value for the hash map value. By using void as the type of the value, the hash map entry type has no value field, and thus the hash map takes up less space. Further, all the code that deals with storing and loading the value is deleted, as seen above.\n\nvoid is distinct from anyopaque. void has a known size of 0 bytes, and anyopaque has an unknown, but non-zero, size.\n\nExpressions of type void are the only ones whose value can be ignored. For example, ignoring a non-void expression is a compile error:\n\nHowever, if the expression has type void, there will be no error. Expression results can be explicitly ignored by assigning them to _.\n\nResult Location Semantics Â§\n\nDuring compilation, every Zig expression and sub-expression is assigned optional result location information. This information dictates what type the expression should have (its result type), and where the resulting value should be placed in memory (its result location). The information is optional in the sense that not every expression has this information: assignment to _, for instance, does not provide any information about the type of an expression, nor does it provide a concrete memory location to place it in.\n\nAs a motivating example, consider the statement const x: u32 = 42;. The type annotation here provides a result type of u32 to the initialization expression 42, instructing the compiler to coerce this integer (initially of type comptime_int) to this type. We will see more examples shortly.\n\nThis is not an implementation detail: the logic outlined above is codified into the Zig language specification, and is the primary mechanism of type inference in the language. This system is collectively referred to as \"Result Location Semantics\".\n\nResult Types Â§\n\nResult types are propagated recursively through expressions where possible. For instance, if the expression &e has result type *u32, then e is given a result type of u32, allowing the language to perform this coercion before taking a reference.\n\nThe result type mechanism is utilized by casting builtins such as @intCast. Rather than taking as an argument the type to cast to, these builtins use their result type to determine this information. The result type is often known from context; where it is not, the @as builtin can be used to explicitly provide a result type.\n\nWe can break down the result types for each component of a simple expression as follows:\n\nThis result type information is useful for the aforementioned cast builtins, as well as to avoid the construction of pre-coercion values, and to avoid the need for explicit type coercions in some cases. The following table details how some common expressions propagate result types, where x and y are arbitrary sub-expressions.\n\nResult Locations Â§\n\nIn addition to result type information, every expression may be optionally assigned a result location: a pointer to which the value must be directly written. This system can be used to prevent intermediate copies when initializing data structures, which can be important for types which must have a fixed memory address (\"pinned\" types).\n\nWhen compiling the simple assignment expression x = e, many languages would create the temporary value e on the stack, and then assign it to x, potentially performing a type coercion in the process. Zig approaches this differently. The expression e is given a result type matching the type of x, and a result location of &x. For many syntactic forms of e, this has no practical impact. However, it can have important semantic effects when working with more complex syntax forms.\n\nFor instance, if the expression .{ .a = x, .b = y } has a result location of ptr, then x is given a result location of &ptr.a, and y a result location of &ptr.b. Without this system, this expression would construct a temporary struct value entirely on the stack, and only then copy it to the destination address. In essence, Zig desugars the assignment foo = .{ .a = x, .b = y } to the two statements foo.a = x; foo.b = y;.\n\nThis can sometimes be important when assigning an aggregate value where the initialization expression depends on the previous value of the aggregate. The easiest way to demonstrate this is by attempting to swap fields of a struct or array - the following logic looks sound, but in fact is not:\n\nThe following table details how some common expressions propagate result locations, where x and y are arbitrary sub-expressions. Note that some expressions cannot provide meaningful result locations to sub-expressions, even if they themselves have a result location.\n\nusingnamespace Â§\n\nusingnamespace is a declaration that mixes all the public declarations of the operand, which must be a struct, union, enum, or opaque, into the namespace:\n\nusingnamespace has an important use case when organizing the public API of a file or package. For example, one might have c.zig with all of the C imports:\n\nThe above example demonstrates using pub to qualify the usingnamespace additionally makes the imported declarations pub. This can be used to forward declarations, giving precise control over what declarations a given file exposes.\n\ncomptime Â§\n\nZig places importance on the concept of whether an expression is known at compile-time. There are a few different places this concept is used, and these building blocks are used to keep the language small, readable, and powerful.\n\nIntroducing the Compile-Time Concept Â§\n\nCompile-Time Parameters Â§\n\nCompile-time parameters is how Zig implements generics. It is compile-time duck typing.\n\nIn Zig, types are first-class citizens. They can be assigned to variables, passed as parameters to functions, and returned from functions. However, they can only be used in expressions which are known at compile-time, which is why the parameter T in the above snippet must be marked with comptime.\n\nA comptime parameter means that:\n\nAt the callsite, the value must be known at compile-time, or it is a compile error.\n\nIn the function definition, the value is known at compile-time.\n\nFor example, if we were to introduce another function to the above snippet:\n\nThis is an error because the programmer attempted to pass a value only known at run-time to a function which expects a value known at compile-time.\n\nAnother way to get an error is if we pass a type that violates the type checker when the function is analyzed. This is what it means to have compile-time duck typing.\n\nFor example:\n\nOn the flip side, inside the function definition with the comptime parameter, the value is known at compile-time. This means that we actually could make this work for the bool type if we wanted to:\n\nThis works because Zig implicitly inlines if expressions when the condition is known at compile-time, and the compiler guarantees that it will skip analysis of the branch not taken.\n\nThis means that the actual function generated for max in this situation looks like this:\n\nAll the code that dealt with compile-time known values is eliminated and we are left with only the necessary run-time code to accomplish the task.\n\nThis works the same way for switch expressions - they are implicitly inlined when the target expression is compile-time known.\n\nCompile-Time Variables Â§\n\nIn Zig, the programmer can label variables as comptime. This guarantees to the compiler that every load and store of the variable is performed at compile-time. Any violation of this results in a compile error.\n\nThis combined with the fact that we can inline loops allows us to write a function which is partially evaluated at compile-time and partially at run-time.\n\nFor example:\n\nThis example is a bit contrived, because the compile-time evaluation component is unnecessary; this code would work fine if it was all done at run-time. But it does end up generating different code. In this example, the function performFn is generated three different times, for the different values of prefix_char provided:\n\nNote that this happens even in a debug build. This is not a way to write more optimized code, but it is a way to make sure that what should happen at compile-time, does happen at compile-time. This catches more errors and allows expressiveness that in other languages requires using macros, generated code, or a preprocessor to accomplish.\n\nCompile-Time Expressions Â§\n\nIn Zig, it matters whether a given expression is known at compile-time or run-time. A programmer can use a comptime expression to guarantee that the expression will be evaluated at compile-time. If this cannot be accomplished, the compiler will emit an error. For example:\n\nIt doesn't make sense that a program could call exit() (or any other external function) at compile-time, so this is a compile error. However, a comptime expression does much more than sometimes cause a compile error.\n\nWithin a comptime expression:\n\nAll variables are comptime variables.\n\nAll if, while, for, and switch expressions are evaluated at compile-time, or emit a compile error if this is not possible.\n\nAll return and try expressions are invalid (unless the function itself is called at compile-time).\n\nAll code with runtime side effects or depending on runtime values emits a compile error.\n\nAll function calls cause the compiler to interpret the function at compile-time, emitting a compile error if the function tries to do something that has global runtime side effects.\n\nThis means that a programmer can create a function which is called both at compile-time and run-time, with no modification to the function required.\n\nLet's look at an example:\n\nImagine if we had forgotten the base case of the recursive function and tried to run the tests:\n\nThe compiler produces an error which is a stack trace from trying to evaluate the function at compile-time.\n\nLuckily, we used an unsigned integer, and so when we tried to subtract 1 from 0, it triggered undefined behavior, which is always a compile error if the compiler knows it happened. But what would have happened if we used a signed integer?\n\nThe compiler is supposed to notice that evaluating this function at compile-time took more than 1000 branches, and thus emits an error and gives up. If the programmer wants to increase the budget for compile-time computation, they can use a built-in function called @setEvalBranchQuota to change the default number 1000 to something else.\n\nHowever, there is a design flaw in the compiler causing it to stack overflow instead of having the proper behavior here. I'm terribly sorry about that. I hope to get this resolved before the next release.\n\nWhat if we fix the base case, but put the wrong value in the expect line?\n\nAt container level (outside of any function), all expressions are implicitly comptime expressions. This means that we can use functions to initialize complex static data. For example:\n\nWhen we compile this program, Zig generates the constants with the answer pre-computed. Here are the lines from the generated LLVM IR:\n\n@0 = internal unnamed_addr constant [25 x i32] [i32 2, i32 3, i32 5, i32 7, i32 11, i32 13, i32 17, i32 19, i32 23, i32 29, i32 31, i32 37, i32 41, i32 43, i32 47, i32 53, i32 59, i32 61, i32 67, i32 71, i32 73, i32 79, i32 83, i32 89, i32 97] @1 = internal unnamed_addr constant i32 1060\n\nNote that we did not have to do anything special with the syntax of these functions. For example, we could call the sum function as is with a slice of numbers whose length and values were only known at run-time.\n\nGeneric Data Structures Â§\n\nZig uses comptime capabilities to implement generic data structures without introducing any special-case syntax.\n\nHere is an example of a generic List data structure.\n\nThat's it. It's a function that returns an anonymous struct. For the purposes of error messages and debugging, Zig infers the name \"List(i32)\" from the function name and parameters invoked when creating the anonymous struct.\n\nTo explicitly give a type a name, we assign it to a constant.\n\nIn this example, the Node struct refers to itself. This works because all top level declarations are order-independent. As long as the compiler can determine the size of the struct, it is free to refer to itself. In this case, Node refers to itself as a pointer, which has a well-defined size at compile time, so it works fine.\n\nCase Study: print in Zig Â§\n\nPutting all of this together, let's see how print works in Zig.\n\nLet's crack open the implementation of this and see how it works:\n\nThis is a proof of concept implementation; the actual function in the standard library has more formatting capabilities.\n\nNote that this is not hard-coded into the Zig compiler; this is userland code in the standard library.\n\nWhen this function is analyzed from our example code above, Zig partially evaluates the function and emits a function that actually looks like this:\n\nprintValue is a function that takes a parameter of any type, and does different things depending on the type:\n\nAnd now, what happens if we give too many arguments to print?\n\nZig gives programmers the tools needed to protect themselves against their own mistakes.\n\nZig doesn't care whether the format argument is a string literal, only that it is a compile-time known value that can be coerced to a []const u8:\n\nThis works fine.\n\nZig does not special case string formatting in the compiler and instead exposes enough power to accomplish this task in userland. It does so without introducing another language on top of Zig, such as a macro language or a preprocessor language. It's Zig all the way down.\n\nSee also:\n\ninline while\n\ninline for\n\nAssembly Â§\n\nFor some use cases, it may be necessary to directly control the machine code generated by Zig programs, rather than relying on Zig's code generation. For these cases, one can use inline assembly. Here is an example of implementing Hello, World on x86_64 Linux using inline assembly:\n\nDissecting the syntax:\n\nFor x86 and x86_64 targets, the syntax is AT&T syntax, rather than the more popular Intel syntax. This is due to technical constraints; assembly parsing is provided by LLVM and its support for Intel syntax is buggy and not well tested.\n\nSome day Zig may have its own assembler. This would allow it to integrate more seamlessly into the language, as well as be compatible with the popular NASM syntax. This documentation section will be updated before 1.0.0 is released, with a conclusive statement about the status of AT&T vs Intel/NASM syntax.\n\nOutput Constraints Â§\n\nOutput constraints are still considered to be unstable in Zig, and so LLVM documentation and GCC documentation must be used to understand the semantics.\n\nNote that some breaking changes to output constraints are planned with issue #215.\n\nInput Constraints Â§\n\nInput constraints are still considered to be unstable in Zig, and so LLVM documentation and GCC documentation must be used to understand the semantics.\n\nNote that some breaking changes to input constraints are planned with issue #215.\n\nClobbers Â§\n\nClobbers are the set of registers whose values will not be preserved by the execution of the assembly code. These do not include output or input registers. The special clobber value of \"memory\" means that the assembly causes writes to arbitrary undeclared memory locations - not only the memory pointed to by a declared indirect output.\n\nFailure to declare the full set of clobbers for a given inline assembly expression is unchecked Undefined Behavior.\n\nGlobal Assembly Â§\n\nWhen an assembly expression occurs in a container level comptime block, this is global assembly.\n\nThis kind of assembly has different rules than inline assembly. First, volatile is not valid because all global assembly is unconditionally included. Second, there are no inputs, outputs, or clobbers. All global assembly is concatenated verbatim into one long string and assembled together. There are no template substitution rules regarding % as there are in inline assembly expressions.\n\nAtomics Â§\n\nTODO: @fence()\n\nTODO: @atomic rmw\n\nTODO: builtin atomic memory ordering enum\n\nSee also:\n\n@atomicLoad\n\n@atomicStore\n\n@atomicRmw\n\n@fence\n\n@cmpxchgWeak\n\n@cmpxchgStrong\n\nAsync Functions Â§\n\nAsync functions regressed with the release of 0.11.0. Their future in the Zig language is unclear due to multiple unsolved problems:\n\nLLVM's lack of ability to optimize them.\n\nThird-party debuggers' lack of ability to debug them.\n\nThe cancellation problem.\n\nAsync function pointers preventing the stack size from being known.\n\nThese problems are surmountable, but it will take time. The Zig team is currently focused on other priorities.\n\nBuiltin Functions Â§\n\nBuiltin functions are provided by the compiler and are prefixed with @. The comptime keyword on a parameter means that the parameter must be known at compile time.\n\n@addrSpaceCast Â§\n\n@addrSpaceCast(ptr: anytype) anytype\n\nConverts a pointer from one address space to another. The new address space is inferred based on the result type. Depending on the current target and address spaces, this cast may be a no-op, a complex operation, or illegal. If the cast is legal, then the resulting pointer points to the same memory location as the pointer operand. It is always valid to cast a pointer between the same address spaces.\n\n@addWithOverflow Â§\n\n@addWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n\nPerforms a + b and returns a tuple with the result and a possible overflow bit.\n\n@alignCast Â§\n\n@alignCast(ptr: anytype) anytype\n\nptr can be *T, ?*T, or []T. Changes the alignment of a pointer. The alignment to use is inferred based on the result type.\n\nA pointer alignment safety check is added to the generated code to make sure the pointer is aligned as promised.\n\n@alignOf Â§\n\n@alignOf(comptime T: type) comptime_int\n\nThis function returns the number of bytes that this type should be aligned to for the current target to match the C ABI. When the child type of a pointer has this alignment, the alignment can be omitted from the type.\n\nconst assert = @import(\"std\").debug.assert; comptime { assert(*u32 == *align(@alignOf(u32)) u32); }\n\nThe result is a target-specific compile time constant. It is guaranteed to be less than or equal to @sizeOf(T).\n\nSee also:\n\nAlignment\n\n@as Â§\n\n@as(comptime T: type, expression) T\n\nPerforms Type Coercion. This cast is allowed when the conversion is unambiguous and safe, and is the preferred way to convert between types, whenever possible.\n\n@atomicLoad Â§\n\n@atomicLoad(comptime T: type, ptr: *const T, comptime ordering: AtomicOrder) T\n\nThis builtin function atomically dereferences a pointer to a T and returns the value.\n\nT must be a pointer, a bool, a float, an integer or an enum.\n\nAtomicOrder can be found with @import(\"std\").builtin.AtomicOrder.\n\nSee also:\n\n@atomicStore\n\n@atomicRmw\n\n@fence\n\n@cmpxchgWeak\n\n@cmpxchgStrong\n\n@atomicRmw Â§\n\n@atomicRmw(comptime T: type, ptr: *T, comptime op: AtomicRmwOp, operand: T, comptime ordering: AtomicOrder) T\n\nThis builtin function dereferences a pointer to a T and atomically modifies the value and returns the previous value.\n\nT must be a pointer, a bool, a float, an integer or an enum.\n\nAtomicOrder can be found with @import(\"std\").builtin.AtomicOrder.\n\nAtomicRmwOp can be found with @import(\"std\").builtin.AtomicRmwOp.\n\nSee also:\n\n@atomicStore\n\n@atomicLoad\n\n@fence\n\n@cmpxchgWeak\n\n@cmpxchgStrong\n\n@atomicStore Â§\n\n@atomicStore(comptime T: type, ptr: *T, value: T, comptime ordering: AtomicOrder) void\n\nThis builtin function dereferences a pointer to a T and atomically stores the given value.\n\nT must be a pointer, a bool, a float, an integer or an enum.\n\nAtomicOrder can be found with @import(\"std\").builtin.AtomicOrder.\n\nSee also:\n\n@atomicLoad\n\n@atomicRmw\n\n@fence\n\n@cmpxchgWeak\n\n@cmpxchgStrong\n\n@bitCast Â§\n\n@bitCast(value: anytype) anytype\n\nConverts a value of one type to another type. The return type is the inferred result type.\n\nAsserts that @sizeOf(@TypeOf(value)) == @sizeOf(DestType).\n\nAsserts that @typeInfo(DestType) != .Pointer. Use @ptrCast or @ptrFromInt if you need this.\n\nCan be used for these things for example:\n\nConvert f32 to u32 bits\n\nConvert i32 to u32 preserving twos complement\n\nWorks at compile-time if value is known at compile time. It's a compile error to bitcast a value of undefined layout; this means that, besides the restriction from types which possess dedicated casting builtins (enums, pointers, error sets), bare structs, error unions, slices, optionals, and any other type without a well-defined memory layout, also cannot be used in this operation.\n\n@bitOffsetOf Â§\n\n@bitOffsetOf(comptime T: type, comptime field_name: []const u8) comptime_int\n\nReturns the bit offset of a field relative to its containing struct.\n\nFor non packed structs, this will always be divisible by 8. For packed structs, non-byte-aligned fields will share a byte offset, but they will have different bit offsets.\n\nSee also:\n\n@offsetOf\n\n@bitSizeOf Â§\n\n@bitSizeOf(comptime T: type) comptime_int\n\nThis function returns the number of bits it takes to store T in memory if the type were a field in a packed struct/union. The result is a target-specific compile time constant.\n\nThis function measures the size at runtime. For types that are disallowed at runtime, such as comptime_int and type, the result is 0.\n\nSee also:\n\n@sizeOf\n\n@typeInfo\n\n@breakpoint Â§\n\n@breakpoint() void\n\nThis function inserts a platform-specific debug trap instruction which causes debuggers to break there. Unlike for @trap(), execution may continue after this point if the program is resumed.\n\nThis function is only valid within function scope.\n\nSee also:\n\n@trap\n\n@mulAdd Â§\n\n@mulAdd(comptime T: type, a: T, b: T, c: T) T\n\nFused multiply-add, similar to (a * b) + c, except only rounds once, and is thus more accurate.\n\nSupports Floats and Vectors of floats.\n\n@byteSwap Â§\n\n@byteSwap(operand: anytype) T\n\n@TypeOf(operand) must be an integer type or an integer vector type with bit count evenly divisible by 8.\n\noperand may be an integer or vector.\n\nSwaps the byte order of the integer. This converts a big endian integer to a little endian integer, and converts a little endian integer to a big endian integer.\n\nNote that for the purposes of memory layout with respect to endianness, the integer type should be related to the number of bytes reported by @sizeOf bytes. This is demonstrated with u24. @sizeOf(u24) == 4, which means that a u24 stored in memory takes 4 bytes, and those 4 bytes are what are swapped on a little vs big endian system. On the other hand, if T is specified to be u24, then only 3 bytes are reversed.\n\n@bitReverse Â§\n\n@bitReverse(integer: anytype) T\n\n@TypeOf(anytype) accepts any integer type or integer vector type.\n\nReverses the bitpattern of an integer value, including the sign bit if applicable.\n\nFor example 0b10110110 (u8 = 182, i8 = -74) becomes 0b01101101 (u8 = 109, i8 = 109).\n\n@offsetOf Â§\n\n@offsetOf(comptime T: type, comptime field_name: []const u8) comptime_int\n\nReturns the byte offset of a field relative to its containing struct.\n\nSee also:\n\n@bitOffsetOf\n\n@call Â§\n\n@call(modifier: std.builtin.CallModifier, function: anytype, args: anytype) anytype\n\nCalls a function, in the same way that invoking an expression with parentheses does:\n\n@call allows more flexibility than normal function call syntax does. The CallModifier enum is reproduced here:\n\n@cDefine Â§\n\n@cDefine(comptime name: []const u8, value) void\n\nThis function can only occur inside @cImport.\n\nThis appends #define $name $value to the @cImport temporary buffer.\n\nTo define without a value, like this:\n\n#define _GNU_SOURCE\n\nUse the void value, like this:\n\n@cDefine(\"_GNU_SOURCE\", {})\n\nSee also:\n\nImport from C Header File\n\n@cInclude\n\n@cImport\n\n@cUndef\n\nvoid\n\n@cImport Â§\n\n@cImport(expression) type\n\nThis function parses C code and imports the functions, types, variables, and compatible macro definitions into a new empty struct type, and then returns that type.\n\nexpression is interpreted at compile time. The builtin functions @cInclude, @cDefine, and @cUndef work within this expression, appending to a temporary buffer which is then parsed as C code.\n\nUsually you should only have one @cImport in your entire application, because it saves the compiler from invoking clang multiple times, and prevents inline functions from being duplicated.\n\nReasons for having multiple @cImport expressions would be:\n\nTo avoid a symbol collision, for example if foo.h and bar.h both #define CONNECTION_COUNT\n\nTo analyze the C code with different preprocessor defines\n\nSee also:\n\nImport from C Header File\n\n@cInclude\n\n@cDefine\n\n@cUndef\n\n@cInclude Â§\n\n@cInclude(comptime path: []const u8) void\n\nThis function can only occur inside @cImport.\n\nThis appends #include <$path>\\n to the c_import temporary buffer.\n\nSee also:\n\nImport from C Header File\n\n@cImport\n\n@cDefine\n\n@cUndef\n\n@clz Â§\n\n@clz(operand: anytype) anytype\n\n@TypeOf(operand) must be an integer type or an integer vector type.\n\noperand may be an integer or vector.\n\nCounts the number of most-significant (leading in a big-endian sense) zeroes in an integer - \"count leading zeroes\".\n\nIf operand is a comptime-known integer, the return type is comptime_int. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nIf operand is zero, @clz returns the bit width of integer type T.\n\nSee also:\n\n@ctz\n\n@popCount\n\n@cmpxchgStrong Â§\n\n@cmpxchgStrong(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T\n\nThis function performs a strong atomic compare-and-exchange operation, returning null if the current value is not the given expected value. It's the equivalent of this code, except atomic:\n\nIf you are using cmpxchg in a retry loop, @cmpxchgWeak is the better choice, because it can be implemented more efficiently in machine instructions.\n\nT must be a pointer, a bool, a float, an integer or an enum.\n\n@typeInfo(@TypeOf(ptr)).Pointer.alignment must be >= @sizeOf(T).\n\nAtomicOrder can be found with @import(\"std\").builtin.AtomicOrder.\n\nSee also:\n\n@atomicStore\n\n@atomicLoad\n\n@atomicRmw\n\n@fence\n\n@cmpxchgWeak\n\n@cmpxchgWeak Â§\n\n@cmpxchgWeak(comptime T: type, ptr: *T, expected_value: T, new_value: T, success_order: AtomicOrder, fail_order: AtomicOrder) ?T\n\nThis function performs a weak atomic compare-and-exchange operation, returning null if the current value is not the given expected value. It's the equivalent of this code, except atomic:\n\nIf you are using cmpxchg in a retry loop, the sporadic failure will be no problem, and cmpxchgWeak is the better choice, because it can be implemented more efficiently in machine instructions. However if you need a stronger guarantee, use @cmpxchgStrong.\n\nT must be a pointer, a bool, a float, an integer or an enum.\n\n@typeInfo(@TypeOf(ptr)).Pointer.alignment must be >= @sizeOf(T).\n\nAtomicOrder can be found with @import(\"std\").builtin.AtomicOrder.\n\nSee also:\n\n@atomicStore\n\n@atomicLoad\n\n@atomicRmw\n\n@fence\n\n@cmpxchgStrong\n\n@compileError Â§\n\n@compileError(comptime msg: []const u8) noreturn\n\nThis function, when semantically analyzed, causes a compile error with the message msg.\n\nThere are several ways that code avoids being semantically checked, such as using if or switch with compile time constants, and comptime functions.\n\n@compileLog Â§\n\n@compileLog(args: ...) void\n\nThis function prints the arguments passed to it at compile-time.\n\nTo prevent accidentally leaving compile log statements in a codebase, a compilation error is added to the build, pointing to the compile log statement. This error prevents code from being generated, but does not otherwise interfere with analysis.\n\nThis function can be used to do \"printf debugging\" on compile-time executing code.\n\n@constCast Â§\n\n@constCast(value: anytype) DestType\n\nRemove const qualifier from a pointer.\n\n@ctz Â§\n\n@ctz(operand: anytype) anytype\n\n@TypeOf(operand) must be an integer type or an integer vector type.\n\noperand may be an integer or vector.\n\nCounts the number of least-significant (trailing in a big-endian sense) zeroes in an integer - \"count trailing zeroes\".\n\nIf operand is a comptime-known integer, the return type is comptime_int. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nIf operand is zero, @ctz returns the bit width of integer type T.\n\nSee also:\n\n@clz\n\n@popCount\n\n@cUndef Â§\n\n@cUndef(comptime name: []const u8) void\n\nThis function can only occur inside @cImport.\n\nThis appends #undef $name to the @cImport temporary buffer.\n\nSee also:\n\nImport from C Header File\n\n@cImport\n\n@cDefine\n\n@cInclude\n\n@cVaArg Â§\n\n@cVaArg(operand: *std.builtin.VaList, comptime T: type) T\n\nImplements the C macro va_arg.\n\nSee also:\n\n@cVaCopy\n\n@cVaEnd\n\n@cVaStart\n\n@cVaCopy Â§\n\n@cVaCopy(src: *std.builtin.VaList) std.builtin.VaList\n\nImplements the C macro va_copy.\n\nSee also:\n\n@cVaArg\n\n@cVaEnd\n\n@cVaStart\n\n@cVaEnd Â§\n\n@cVaEnd(src: *std.builtin.VaList) void\n\nImplements the C macro va_end.\n\nSee also:\n\n@cVaArg\n\n@cVaCopy\n\n@cVaStart\n\n@cVaStart Â§\n\n@cVaStart() std.builtin.VaList\n\nImplements the C macro va_start. Only valid inside a variadic function.\n\nSee also:\n\n@cVaArg\n\n@cVaCopy\n\n@cVaEnd\n\n@divExact Â§\n\n@divExact(numerator: T, denominator: T) T\n\nExact division. Caller guarantees denominator != 0 and @divTrunc(numerator, denominator) * denominator == numerator.\n\n@divExact(6, 3) == 2\n\n@divExact(a, b) * b == a\n\nFor a function that returns a possible error code, use @import(\"std\").math.divExact.\n\nSee also:\n\n@divTrunc\n\n@divFloor\n\n@divFloor Â§\n\n@divFloor(numerator: T, denominator: T) T\n\nFloored division. Rounds toward negative infinity. For unsigned integers it is the same as numerator / denominator. Caller guarantees denominator != 0 and !(@typeInfo(T) == .Int and T.is_signed and numerator == std.math.minInt(T) and denominator == -1).\n\n@divFloor(-5, 3) == -2\n\n(@divFloor(a, b) * b) + @mod(a, b) == a\n\nFor a function that returns a possible error code, use @import(\"std\").math.divFloor.\n\nSee also:\n\n@divTrunc\n\n@divExact\n\n@divTrunc Â§\n\n@divTrunc(numerator: T, denominator: T) T\n\nTruncated division. Rounds toward zero. For unsigned integers it is the same as numerator / denominator. Caller guarantees denominator != 0 and !(@typeInfo(T) == .Int and T.is_signed and numerator == std.math.minInt(T) and denominator == -1).\n\n@divTrunc(-5, 3) == -1\n\n(@divTrunc(a, b) * b) + @rem(a, b) == a\n\nFor a function that returns a possible error code, use @import(\"std\").math.divTrunc.\n\nSee also:\n\n@divFloor\n\n@divExact\n\n@embedFile Â§\n\n@embedFile(comptime path: []const u8) *const [N:0]u8\n\nThis function returns a compile time constant pointer to null-terminated, fixed-size array with length equal to the byte count of the file given by path. The contents of the array are the contents of the file. This is equivalent to a string literal with the file contents.\n\npath is absolute or relative to the current file, just like @import.\n\nSee also:\n\n@import\n\n@enumFromInt Â§\n\n@enumFromInt(integer: anytype) anytype\n\nConverts an integer into an enum value. The return type is the inferred result type.\n\nAttempting to convert an integer with no corresponding value in the enum invokes safety-checked Undefined Behavior. Note that a non-exhaustive enum has corresponding values for all integers in the enum's integer tag type: the _ value represents all the remaining unnamed integers in the enum's tag type.\n\nSee also:\n\n@intFromEnum\n\n@errorFromInt Â§\n\n@errorFromInt(value: std.meta.Int(.unsigned, @bitSizeOf(anyerror))) anyerror\n\nConverts from the integer representation of an error into The Global Error Set type.\n\nIt is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.\n\nAttempting to convert an integer that does not correspond to any error results in safety-protected Undefined Behavior.\n\nSee also:\n\n@intFromError\n\n@errorName Â§\n\n@errorName(err: anyerror) [:0]const u8\n\nThis function returns the string representation of an error. The string representation of error.OutOfMem is \"OutOfMem\".\n\nIf there are no calls to @errorName in an entire application, or all calls have a compile-time known value for err, then no error name table will be generated.\n\n@errorReturnTrace Â§\n\n@errorReturnTrace() ?*builtin.StackTrace\n\nIf the binary is built with error return tracing, and this function is invoked in a function that calls a function with an error or error union return type, returns a stack trace object. Otherwise returns null.\n\n@errorCast Â§\n\n@errorCast(value: anytype) anytype\n\nConverts an error set or error union value from one error set to another error set. The return type is the inferred result type. Attempting to convert an error which is not in the destination error set results in safety-protected Undefined Behavior.\n\n@export Â§\n\n@export(declaration, comptime options: std.builtin.ExportOptions) void\n\nCreates a symbol in the output object file.\n\ndeclaration must be one of two things:\n\nAn identifier (x) identifying a function or a variable.\n\nField access (x.y) looking up a function or a variable.\n\nThis builtin can be called from a comptime block to conditionally export symbols. When declaration is a function with the C calling convention and options.linkage is Strong, this is equivalent to the export keyword used on a function:\n\nThis is equivalent to:\n\nNote that even when using export, the @\"foo\" syntax for identifiers can be used to choose any string for the symbol name:\n\nWhen looking at the resulting object, you can see the symbol is used verbatim:\n\n00000000000001f0 T A function name that is a complete sentence.\n\nSee also:\n\nExporting a C Library\n\n@extern Â§\n\n@extern(T: type, comptime options: std.builtin.ExternOptions) T\n\nCreates a reference to an external symbol in the output object file. T must be a pointer type.\n\nSee also:\n\n@export\n\n@fence Â§\n\n@fence(order: AtomicOrder) void\n\nThe fence function is used to introduce happens-before edges between operations.\n\nAtomicOrder can be found with @import(\"std\").builtin.AtomicOrder.\n\nSee also:\n\n@atomicStore\n\n@atomicLoad\n\n@atomicRmw\n\n@cmpxchgWeak\n\n@cmpxchgStrong\n\n@field Â§\n\n@field(lhs: anytype, comptime field_name: []const u8) (field)\n\nPerforms field access by a compile-time string. Works on both fields and declarations.\n\n@fieldParentPtr Â§\n\n@fieldParentPtr(comptime field_name: []const u8, field_ptr: *T) anytype\n\nGiven a pointer to a field, returns the base pointer of a struct.\n\n@floatCast Â§\n\n@floatCast(value: anytype) anytype\n\nConvert from one float type to another. This cast is safe, but may cause the numeric value to lose precision. The return type is the inferred result type.\n\n@floatFromInt Â§\n\n@floatFromInt(int: anytype) anytype\n\nConverts an integer to the closest floating point representation. The return type is the inferred result type. To convert the other way, use @intFromFloat. This operation is legal for all values of all integer types.\n\n@frameAddress Â§\n\n@frameAddress() usize\n\nThis function returns the base pointer of the current stack frame.\n\nThe implications of this are target-specific and not consistent across all platforms. The frame address may not be available in release mode due to aggressive optimizations.\n\nThis function is only valid within function scope.\n\n@hasDecl Â§\n\n@hasDecl(comptime Container: type, comptime name: []const u8) bool\n\nReturns whether or not a container has a declaration matching name.\n\nSee also:\n\n@hasField\n\n@hasField Â§\n\n@hasField(comptime Container: type, comptime name: []const u8) bool\n\nReturns whether the field name of a struct, union, or enum exists.\n\nThe result is a compile time constant.\n\nIt does not include functions, variables, or constants.\n\nSee also:\n\n@hasDecl\n\n@import Â§\n\n@import(comptime path: []const u8) type\n\nThis function finds a zig file corresponding to path and adds it to the build, if it is not already added.\n\nZig source files are implicitly structs, with a name equal to the file's basename with the extension truncated. @import returns the struct type corresponding to the file.\n\nDeclarations which have the pub keyword may be referenced from a different source file than the one they are declared in.\n\npath can be a relative path or it can be the name of a package. If it is a relative path, it is relative to the file that contains the @import function call.\n\nThe following packages are always available:\n\n@import(\"std\") - Zig Standard Library\n\n@import(\"builtin\") - Target-specific information The command zig build-exe --show-builtin outputs the source to stdout for reference.\n\n@import(\"root\") - Root source file This is usually src/main.zig but depends on what file is built.\n\nSee also:\n\nCompile Variables\n\n@embedFile\n\n@inComptime Â§\n\n@inComptime() bool\n\nReturns whether the builtin was run in a comptime context. The result is a compile-time constant.\n\nThis can be used to provide alternative, comptime-friendly implementations of functions. It should not be used, for instance, to exclude certain functions from being evaluated at comptime.\n\nSee also:\n\ncomptime\n\n@intCast Â§\n\n@intCast(int: anytype) anytype\n\nConverts an integer to another integer while keeping the same numerical value. The return type is the inferred result type. Attempting to convert a number which is out of range of the destination type results in safety-protected Undefined Behavior.\n\nTo truncate the significant bits of a number out of range of the destination type, use @truncate.\n\nIf T is comptime_int, then this is semantically equivalent to Type Coercion.\n\n@intFromBool Â§\n\n@intFromBool(value: bool) u1\n\nConverts true to @as(u1, 1) and false to @as(u1, 0).\n\n@intFromEnum Â§\n\n@intFromEnum(enum_or_tagged_union: anytype) anytype\n\nConverts an enumeration value into its integer tag type. When a tagged union is passed, the tag value is used as the enumeration value.\n\nIf there is only one possible enum value, the result is a comptime_int known at comptime.\n\nSee also:\n\n@enumFromInt\n\n@intFromError Â§\n\n@intFromError(err: anytype) std.meta.Int(.unsigned, @bitSizeOf(anyerror))\n\nSupports the following types:\n\nThe Global Error Set\n\nError Set Type\n\nError Union Type\n\nConverts an error to the integer representation of an error.\n\nIt is generally recommended to avoid this cast, as the integer representation of an error is not stable across source code changes.\n\nSee also:\n\n@errorFromInt\n\n@intFromFloat Â§\n\n@intFromFloat(float: anytype) anytype\n\nConverts the integer part of a floating point number to the inferred result type.\n\nIf the integer part of the floating point number cannot fit in the destination type, it invokes safety-checked Undefined Behavior.\n\nSee also:\n\n@floatFromInt\n\n@intFromPtr Â§\n\n@intFromPtr(value: anytype) usize\n\nConverts value to a usize which is the address of the pointer. value can be *T or ?*T.\n\nTo convert the other way, use @ptrFromInt\n\n@max Â§\n\n@max(a: T, b: T) T\n\nReturns the maximum value of a and b. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.\n\nNaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.\n\nSee also:\n\n@min\n\nVectors\n\n@memcpy Â§\n\n@memcpy(noalias dest, noalias source) void\n\nThis function copies bytes from one region of memory to another.\n\ndest must be a mutable slice, a mutable pointer to an array, or a mutable many-item pointer. It may have any alignment, and it may have any element type.\n\nsource must be a slice, a pointer to an array, or a many-item pointer. It may have any alignment, and it may have any element type.\n\nThe source element type must support Type Coercion into the dest element type. The element types may have different ABI size, however, that may incur a performance penalty.\n\nSimilar to for loops, at least one of source and dest must provide a length, and if two lengths are provided, they must be equal.\n\nFinally, the two memory regions must not overlap.\n\n@memset Â§\n\n@memset(dest, elem) void\n\nThis function sets all the elements of a memory region to elem.\n\ndest must be a mutable slice or a mutable pointer to an array. It may have any alignment, and it may have any element type.\n\nelem is coerced to the element type of dest.\n\nFor securely zeroing out sensitive contents from memory, you should use std.crypto.secureZero\n\n@min Â§\n\n@min(a: T, b: T) T\n\nReturns the minimum value of a and b. This builtin accepts integers, floats, and vectors of either. In the latter case, the operation is performed element wise.\n\nNaNs are handled as follows: if one of the operands of a (pairwise) operation is NaN, the other operand is returned. If both operands are NaN, NaN is returned.\n\nSee also:\n\n@max\n\nVectors\n\n@wasmMemorySize Â§\n\n@wasmMemorySize(index: u32) usize\n\nThis function returns the size of the Wasm memory identified by index as an unsigned value in units of Wasm pages. Note that each Wasm page is 64KB in size.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like @import(\"std\").heap.WasmPageAllocator.\n\nSee also:\n\n@wasmMemoryGrow\n\n@wasmMemoryGrow Â§\n\n@wasmMemoryGrow(index: u32, delta: usize) isize\n\nThis function increases the size of the Wasm memory identified by index by delta in units of unsigned number of Wasm pages. Note that each Wasm page is 64KB in size. On success, returns previous memory size; on failure, if the allocation fails, returns -1.\n\nThis function is a low level intrinsic with no safety mechanisms usually useful for allocator designers targeting Wasm. So unless you are writing a new allocator from scratch, you should use something like @import(\"std\").heap.WasmPageAllocator.\n\nSee also:\n\n@wasmMemorySize\n\n@mod Â§\n\n@mod(numerator: T, denominator: T) T\n\nModulus division. For unsigned integers this is the same as numerator % denominator. Caller guarantees denominator > 0, otherwise the operation will result in a Remainder Division by Zero when runtime safety checks are enabled.\n\n@mod(-5, 3) == 1\n\n(@divFloor(a, b) * b) + @mod(a, b) == a\n\nFor a function that returns an error code, see @import(\"std\").math.mod.\n\nSee also:\n\n@rem\n\n@mulWithOverflow Â§\n\n@mulWithOverflow(a: anytype, b: anytype) struct { @TypeOf(a, b), u1 }\n\nPerforms a * b and returns a tuple with the result and a possible overflow bit.\n\n@panic Â§\n\n@panic(message: []const u8) noreturn\n\nInvokes the panic handler function. By default the panic handler function calls the public panic function exposed in the root source file, or if there is not one specified, the std.builtin.default_panic function from std/builtin.zig.\n\nGenerally it is better to use @import(\"std\").debug.panic. However, @panic can be useful for 2 scenarios:\n\nFrom library code, calling the programmer's panic function if they exposed one in the root source file.\n\nWhen mixing C and Zig code, calling the canonical panic implementation across multiple .o files.\n\nSee also:\n\nRoot Source File\n\n@popCount Â§\n\n@popCount(operand: anytype) anytype\n\n@TypeOf(operand) must be an integer type.\n\noperand may be an integer or vector.\n\nCounts the number of bits set in an integer - \"population count\".\n\nIf operand is a comptime-known integer, the return type is comptime_int. Otherwise, the return type is an unsigned integer or vector of unsigned integers with the minimum number of bits that can represent the bit count of the integer type.\n\nSee also:\n\n@ctz\n\n@clz\n\n@prefetch Â§\n\n@prefetch(ptr: anytype, comptime options: PrefetchOptions) void\n\nThis builtin tells the compiler to emit a prefetch instruction if supported by the target CPU. If the target CPU does not support the requested prefetch instruction, this builtin is a no-op. This function has no effect on the behavior of the p"
    }
}