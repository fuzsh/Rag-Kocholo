{
    "id": "dbpedia_8288_2",
    "rank": 93,
    "data": {
        "url": "https://www.cs.bsu.edu/homepages/dmz/cs697/langtbl.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Programming Languages Table",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.cs.bsu.edu/homepages/dmz/0but1off.gif",
            "https://www.cs.bsu.edu/homepages/dmz/0but2off.gif",
            "https://www.cs.bsu.edu/homepages/dmz/0but3off.gif",
            "https://www.cs.bsu.edu/homepages/dmz/0but4off.gif",
            "https://www.cs.bsu.edu/homepages/dmz/0but5off.gif",
            "https://www.cs.bsu.edu/homepages/dmz/0but6on.gif",
            "https://www.cs.bsu.edu/homepages/dmz/cs697/0reshed1.gif",
            "https://www.cs.bsu.edu/homepages/dmz/cs697/0reshed2.gif",
            "https://www.cs.bsu.edu/homepages/dmz/cs697/0reshed3.gif",
            "https://www.cs.bsu.edu/homepages/dmz/cs697/0reshed4.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Mark Pinis"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Release 8.2, March 1996\n\nBy Capers Jones, Chairman, Software Productivity Research, Inc.\n\nÂ© Copyright 1997 by Software Productivity Research, Inc. All Rights Reserved.\n\nWhat Is A Language Level?\n\nAs language levels go up, fewer statements to code one Function Point are required. For example, COBOL is a level 3 and requires about 105 statements per Function Point.\n\nThe numeric levels of various languages provide a convenient shortcut for converting size from one language to another. For example, if an application requires 1000 non-commentary COBOL statements (level 3), then it would take only 500 statements in a level 6 language (such as NATURAL) and only 250 statements in a level 12 language (such as OBJECTIVE C). As you can see, the average number of statements required is proportional to the levels of the various languages.\n\nDo Language Levels Affect Productivity?\n\nThe correlation between the level of a language and development productivity is not linear. For most large software projects, coding amounts to only about 30 percent of the effort.\n\nAssume a program is written in a language that is twice the level of a similar program, for instance level 6 versus level 3. In this example, the coding effort might be reduced by 50 percent. But the total project might be improved by only 15 percent, since coding only comprised 30 percent of the original effort. Double the level of the language again to a level 12. That will only give an additional 7.5 percent net savings. Once again, coding is halved. But coding is not a major factor for very high level languages.\n\nMore accurate economic productivity rates can be gained by examining the average monthly Function Point production rates associated with various language levels. Table 1 looks at how language levels affect productivity.\n\nTable 1. Language Level Relationship to Productivity\n\nLANGUAGE LEVEL PRODUCTIVITY AVERAGE PER STAFF MONTH -------------- ------------------------- 1 - 3 5 to 10 Function Points 4 - 8 10 to 20 Function Points 9 - 15 16 to 23 Function Points 16 - 23 15 to 30 Function Points 24 - 55 30 to 50 Function Points Above 55 40 to 100 Function Points\n\nWhat Is The Basis For Language Levels?\n\nThe languages and levels in Table 2 were gathered in four ways.\n\nCounting Function Points and Source Code\n\nCounting Source Code\n\nInspecting Source Code\n\nResearching Languages\n\nCounting Function Points And Source Code\n\nActual counts of Function Points and source code statements were performed. Samples of counting Function Points and source code statements were done on Ada, several BASIC dialects, COBOL, PASCAL, and PL/I.\n\nCounting Source Code\n\nSource code statements were counted, then compared to the size of the same program in languages of known levels. Assembly, APL, C, OBJECTIVE C, FORTH, FORTRAN, LISP, PILOT, and PROLOG are languages that produce the same source code count as COBOL. So code sizes were compared to the known quantity of COBOL source code.\n\nInspecting Source Code\n\nSource code inspection for common applications was done. Then the volume of code for the application in a measured language was hypothesized. ACTOR, CLARION, and TRUE BASIC are examples of languages that were inspected and their levels hypothesized by subjective means.\n\nResearching Languages\n\nResearch was done by reading descriptions and genealogies of languages and making an educated guess as to their levels. KL, CLOS, TWAICE, and FASBOL are examples of languages that were assigned tentative levels merely from descriptions of the language, rather than from actual counts.\n\nFor spreadsheets the ordinary concepts of a language do not apply. In this case, formulas, labels, and constants were considered to be statements.\n\nList Of Programming Languages\n\nAs of 1996, there were more than 500 languages and major dialects of languages available to software practitioners. Table 2 lists the most common of them in what is considered version 7 of the SPR Programming Languages Table."
    }
}