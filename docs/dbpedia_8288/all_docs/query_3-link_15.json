{
    "id": "dbpedia_8288_3",
    "rank": 15,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/314490/business-logic-database-vs-code",
        "read_more_link": "",
        "language": "en",
        "title": "Software Engineering Stack Exchange",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://www.gravatar.com/avatar/ca37491e1e3bd92ec508784b010fc088?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://lh4.googleusercontent.com/-ByvKg-Bqv2Q/AAAAAAAAAAI/AAAAAAAAAB8/A0dP5XEIAUg/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/xvEpe.jpg?s=64",
            "https://www.gravatar.com/avatar/0113491d8885646b7ed6f6c949f381ba?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ca37491e1e3bd92ec508784b010fc088?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/78a0a4bb106d07b6c6f33a51988155e3?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/q2bl9.png?s=64",
            "https://www.gravatar.com/avatar/85a0d5887acd8563bb712a3786f2f043?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/aa718bdc1d4d14a5fd36ef850b2f5af9?s=64&d=identicon&r=PG",
            "https://softwareengineering.stackexchange.com/posts/314490/ivc/0d79?prg=f3e6a1e1-4ba7-4e48-98ad-5debd47ea37c"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2016-04-01T17:07:07",
        "summary": "",
        "meta_description": "I'm a student of systems engineering, and all my teachers and friends (that actually work in the area) say that it is better to have as much logic as possible implemented in the database (queries, ...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/314490/business-logic-database-vs-code",
        "text": "See How much business logic should the database implement? for previous discussion.\n\nIn general, everyone wants things done in the layer they control. Because then they control it.\n\nEvery database vendor wants people to put as much logic into the database as possible. Because that locks you into the database. The reasoning is that if multiple applications use the same database, they will reuse code.\n\nHowever programmers emphatically disagree. Databases offer poor programming options. Deploying code to databases is hard. Databases lack basic tools for revision control, interactive editing, deployment and unit testing. Stored procedures tend to involve horrible to debug action at a distance. It has become less common to have multiple applications hit the same database. And if you ever have to make something scale, the one bottleneck that is hardest to fix is your database.\n\nMy bias is clear. I'm a programmer.\n\nBut I've been programming for close to 20 years, mostly as a back end programmer who is responsible for data. I've seen the argument many times for moving logic into the database. I've seen systems that did it, and systems which avoided it. I've had to migrate databases, migrate code bases, etc, etc, etc.\n\nThe worst messes have always been when business logic was in the database. They were always the hardest ones to fix. And I can say that while I've many times encountered the claim that \"we moved logic into the database for performance\", performance is almost always better with a clean normalized data model, good indexes, a caching layer in front of the database, and sane algorithms implemented in a modern programming language.\n\nI am very firmly of the view that when ever possible, business logic should be kept in the software layer and not the database layer. Note, that when ever possible falls far short of always.\n\nThere are strong arguments for both ways, and as always use engineering good judgement to decide for each project how much weight should be applied to each point before deciding which is the more appropriate choice.\n\n(as other people make sugestions in the comments, they can be added to the list)\n\nArguments for the database handling business logic:\n\nBusiness logic needs data to operate on. Getting the logic processing as close to the data gives better performance\n\nOne place to apply updates\n\nArguments for the software layers handling business logic:\n\nWell written software is typically much easier to understand, debug and maintain than SQL stored procedures.\n\nApplication Servers can scale out as well as scale up if the internet application becomes popular.\n\nAs a seasoned professional developer, needing a quick fix to improve application latency, the choice can be between moving some slow running business logic into a stored procedure on the database and/or to implement caching of slow processes.\n\nThere is however a serious gotcha with database based business logic. If your application needs to scale massively, always prefer systems / processes that can scale out (by this I mean, you can add more servers into the processing pool). SQL Databases can only scale up (you need to find a more powerful server to replace your existing one.) If your application has lots of database business logic, you will reach this problem earlier.\n\nBesides all the facts that have been already pointed out, also remember that having business logic in your code rather that the database eventually turns out to be cheaper.\n\nWhen looking for a developer for an application written in PHP and using MySQL as a database, should your business logic be stored in the database, a simple PHP programmer is not enough, and you will have to find someone who also knows how to write, debug and optimize stored procedures. Suddenly you need a guy who knows not only one thing, PHP, but two, PHP and MySQL programming.\n\nAnd do not even think about moving to a higher-performance engine like PostgreSQL, then you also need to hire a guy to transform all stored procedures to PL/SQL.\n\nWhen having business logic in the code, this is only a matter of writing a new abstraction layer for PostgreSQL and swapping out the dependencies in your application, boom, your application suddenly knows PostgreSQL.\n\nGreat question - this is something I advocate at the office very regularly.\n\nMy view is that most of the logic should be in code. It's always very tempting to use a variety of languages because they each have their strengths, but unless you have a perfect development setup (which is very rare), it's preferable to stick to one language.\n\nPeople have mentionned unit testing / revision control versionning, but a very important thing is deployment. Having to synchronize database code changes with code changes can be hazardous.\n\nIf you're in a large-scale software development company, you may have enough specialized people who know either side (database programming vs coding), but otherwise it's tricky to find people who can juggle between the 2 worlds (and most importantly, who make the right trade offs when it comes to deciding what part of the logic needs to be in what language).\n\nPersonally, I find SQL programming languages very primitive, and development tools for them even worse. So I would favor modern programming languages. A good ORM can save most developers from knowing anything about the database, and is worth investing into. People mentionned the efficiency of doing things server side, and this should not be abandoned. There are some very nice programming patterns that allow to express server-side operations using what appears to be a client-side API (e.g. IQueryable in C#).\n\nIn practice, I am still using the odd views or stored procedures, but they are usually mostly purely for aggregation, and have no 'business' logic in them. This is quite useful as they can be used as sources for excel pivottables for instance."
    }
}