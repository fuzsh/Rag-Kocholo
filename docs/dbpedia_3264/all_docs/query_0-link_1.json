{
    "id": "dbpedia_3264_0",
    "rank": 1,
    "data": {
        "url": "https://github.com/imbue-ai/jupyter_ascending",
        "read_more_link": "",
        "language": "en",
        "title": "ai/jupyter_ascending: Ascend your Jupyter Notebook usage",
        "top_image": "https://opengraph.githubassets.com/4b5b8d3f7d65d14e48d9e8cd12a2b8a1559ab1a692f4a48aefc571b02e7e329b/imbue-ai/jupyter_ascending",
        "meta_img": "https://opengraph.githubassets.com/4b5b8d3f7d65d14e48d9e8cd12a2b8a1559ab1a692f4a48aefc571b02e7e329b/imbue-ai/jupyter_ascending",
        "images": [
            "https://github.com/imbue-ai/jupyter_ascending/raw/main/media/demo.gif",
            "https://avatars.githubusercontent.com/u/5598968?s=64&v=4",
            "https://avatars.githubusercontent.com/u/4466899?s=64&v=4",
            "https://avatars.githubusercontent.com/u/753892?s=64&v=4",
            "https://avatars.githubusercontent.com/u/864088?s=64&v=4",
            "https://avatars.githubusercontent.com/u/265859?s=64&v=4",
            "https://avatars.githubusercontent.com/u/386877?s=64&v=4",
            "https://avatars.githubusercontent.com/u/1719584?s=64&v=4"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "imbue-ai"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Ascend your Jupyter Notebook usage. Contribute to imbue-ai/jupyter_ascending development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/imbue-ai/jupyter_ascending",
        "text": "Sync Jupyter Notebooks from any editor\n\nJupyter Ascending lets you edit Jupyter notebooks from your favorite editor, then instantly sync and execute that code in the Jupyter notebook running in your browser.\n\nIt's the best of both worlds--the autocomplete, keybindings, and refactoring tools you love in your favorite editor, plus the great visualization abilities of a Jupyter notebook.\n\nCombined with basic syncing of your code to a remote server, you can have all the power of a beefy dev-server with all the convenience of editing code locally.\n\nYou can confirm it's installed by checking for jupyter_ascending in:\n\nIf your jupyter setup includes multiple python kernels that you'd like to use with jupyter ascending, you'll need to complete this setup in each of those python environments separately.\n\npython -m jupyter_ascending.scripts.make_pair --base example\n\nThis makes a pair of synced py and ipynb files, example.sync.py and example.sync.ipynb.\n\nStart jupyter and open the notebook:\n\npython -m jupyter notebook example.sync.ipynb\n\nAdd some code to the .sync.py file, e.g.\n\necho 'print(\"Hello World!\")' >> example.sync.py\n\nSync the code into the jupyter notebook:\n\npython -m jupyter_ascending.requests.sync --filename example.sync.py\n\nRun that cell of code\n\npython -m jupyter_ascending.requests.execute --filename example.sync.py --line 16\n\nSet up one of the editor integrations to do all of this from within your favorite editor!\n\nVim\n\nVisual Studio Code\n\nPyCharm\n\nOther editors\n\nCurrently Jupyter Ascending expects the jupyter server to be running at localhost:8888. If it's running elsewhere (eg due to having multiple jupyter notebooks open), you'll need to set the env variables JUPYTER_ASCENDING_EXECUTE_HOST and JUPYTER_ASCENDING_EXECUTE_PORT appropriately both where you use the client (ie in your editor) and where you start the server.\n\nBy default the Jupyter server will search for a free port starting at 8888. If 8888 is unavailable and it selects eg 8889, Jupyter Ascending won't work - as it's expecting to connect to 8888. To force Jupyter to use a specific port, start your jupyter notebook with JUPYTER_PORT=8888 JUPYTER_PORT_RETRIES=0 jupyter notebook (or whatever port you want, setting also JUPYTER_ASCENDING_EXECUTE_PORT appropriately).\n\nJupyter Ascending doesn't know or care if the editor and the jupyter server are on the same machine. The client is just sending requests to http://[jupyter_server_url]:[jupyter_server_port]/jupyter_ascending, with the default set to http://localhost:8888/jupyter_ascending. We typically use SSH to forward the local jupyter port into the remote server, but you can set up the networking however you like, and use the environment variables to tell the client where to look for the Jupyter server.\n\nThere's fuzzy-matching logic to match the locally edited file path with the remote notebook file path (eg if the two machines have the code in a different directory), so everything should just work!\n\nHere's an example of how you could set this up:\n\ninstall jupyter-ascending on both the client and the server\n\nput a copy of your project code on both the client and the server\n\nstart a jupyter notebook on the server, and open a .sync.ipynb notebook\n\nset up port forwarding, e.g. with something like this (forwards local port 8888 to the remote port 8888)\n\nssh -L 8888:127.0.0.1:8888 user@remote_hostname\n\nuse Jupyter Ascending clients as normal on the corresponding .sync.py file\n\nThe jupyter-ascending client-server connection is currently completely unauthenticated, even if you have auth enabled on the Jupyter server. This means that, if your jupyter server port is open to the internet, someone could detect that you have jupyter-ascending running, then sync and run arbitrary code on your machine. That's bad!\n\nFor the moment, we recommend only running jupyter-ascending when you're using jupyter locally, or when your jupyter server isn't open to the public internet. For example, we run Jupyter on remote servers, but keep Jupyter accessible only to localhost. Then we use a secure SSH tunnel to do port-forwarding.\n\nHopefully we can add proper authentication in the future. Contributions are welcome here!\n\nyour editor calls the jupyter ascending client library with one of a few commands:\n\nsync the code to the notebook (typically on save)\n\nrun a cell / run all cells / other commands that should be mapped to a keyboard shortcut\n\nthe client library assembles a HTTP POST request and sends it to the jupyter server\n\nthere is a jupyter server extension which accepts HTTP POST requests at http://[jupyter_server_url]:[jupyter_server_port]/jupyter_ascending.\n\nthe server extension matches the request filename to the proper running notebooks and forwards the command along to the notebook plugin\n\na notebook plugin receives the command, and updates the contents of the notebook or executes the requested command.\n\nthe notebook plugin consists of two parts - one part executes within the python process of the notebook kernel, and the other executes in javascript in the notebook's browser window. the part in python launches a little webserver in a thread, which is how it receives messages the server extension. when the webserver thread starts up, it sends a message to the server extension to \"register\" itself so the server extension knows where to send commands for that notebook.\n\nTo do local development (only needed if you're modifying the jupyter-ascending code):\n\nTo check that they are enabled, do something like this:\n\nRun tests from the root directory of this repository using python -m pytest ..\n\nFormat files with pyfixfmt. In a PyCharm file watcher, something like\n\npython -m pyfixfmt --file-glob $FilePathRelativeToProjectRoot$ --verbose\n\nPushing a new version to PyPI:\n\nBump the version number in pyproject.toml and _version.py.\n\npoetry build\n\npoetry publish\n\ngit tag VERSION and git push origin VERSION\n\nUpdating dependencies:"
    }
}