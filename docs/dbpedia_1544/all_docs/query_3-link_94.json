{
    "id": "dbpedia_1544_3",
    "rank": 94,
    "data": {
        "url": "https://dev.to/koenighotze/dealing-with-data-in-microservice-architectures-part-3-replication-4h7b",
        "read_more_link": "",
        "language": "en",
        "title": "Dealing with data in microservice architectures - part 3 - replication",
        "top_image": "https://media.dev.to/cdn-cgi/image/width=1000,height=500,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fa27im3yl747d1s9ajd2w.jpg",
        "meta_img": "https://media.dev.to/cdn-cgi/image/width=1000,height=500,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fa27im3yl747d1s9ajd2w.jpg",
        "images": [
            "https://media.dev.to/cdn-cgi/image/quality=100/https://dev-to-uploads.s3.amazonaws.com/uploads/logos/resized_logo_UQww2soKuUsjaOGNB38o.png",
            "https://dev.to/assets/heart-plus-active-9ea3b22f2bc311281db911d416166c5f430636e76b15cd5df6b3b841d830eefa.svg",
            "https://dev.to/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://dev.to/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://dev.to/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://dev.to/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://dev.to/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg",
            "https://media.dev.to/cdn-cgi/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fa27im3yl747d1s9ajd2w.jpg",
            "https://media.dev.to/cdn-cgi/image/width=50,height=50,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F3776%2F72db2906-3e2c-4b0d-9aac-ba0705023e3d.png",
            "https://dev.to/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://dev.to/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://dev.to/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://dev.to/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://dev.to/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--U4mQLEv_--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/4exsn2v0v90p5imo066f.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--kvq4y6e9--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/15z9puz122akk3zhtmo8.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--OPWlDbQI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/wgjxgo0i7e3bjquj2gye.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--A72K2D4A--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/83mpuor3vm5g6oe45etz.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--rBbtuoZ2--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/nm6vm1t6agi4qs82u9o0.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--7rzH6A4J--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/ienat0afja92swjvy7ni.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--tPGIsZaI--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/gqooirma6aqiv7k1c8lf.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--FQHJw3Le--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/xp9fmvjk6uqvg2afs2t6.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--t6vuiiL7--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/vd09e485754jysyhiono.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--nfwjqjfp--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/91r5ov4859gi81gikui2.png",
            "https://res.cloudinary.com/practicaldev/image/fetch/s--R0JlWJgY--/c_limit%2Cf_auto%2Cfl_progressive%2Cq_auto%2Cw_800/https://dev-to-uploads.s3.amazonaws.com/uploads/articles/3g433nth3a1schlyl3h3.png",
            "https://media.dev.to/cdn-cgi/image/width=256,height=,fit=scale-down,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F8j7kvp660rqzt99zui8e.png",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F1314803%2F2c74d221-c187-421c-8bfb-ca54e05f9100.jpeg",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F1911752%2F1aec00be-2690-4d3f-b2fc-c397d543119f.jpg",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F200748%2Ff5689d79-a0bc-4166-beb5-20958f52d7dc.jpeg",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F307373%2Fe3ac7039-26d6-49a6-a05f-5044b65147df.jpg",
            "https://media.dev.to/cdn-cgi/image/width=90,height=90,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F3776%2F72db2906-3e2c-4b0d-9aac-ba0705023e3d.png",
            "https://media.dev.to/cdn-cgi/image/width=190,height=,fit=scale-down,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F8j7kvp660rqzt99zui8e.png",
            "https://dev.to/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://dev.to/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://dev.to/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://dev.to/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://dev.to/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "microservices",
            "changedatacapture",
            "kafka",
            "software",
            "coding",
            "development",
            "engineering",
            "inclusive",
            "community"
        ],
        "tags": null,
        "authors": [
            "David Schmitz"
        ],
        "publish_date": "2021-05-01T13:15:56+00:00",
        "summary": "",
        "meta_description": "The third part of a series dealing with the problem of data and data ownership in microservice architectures. Tagged with microservices, changedatacapture, kafka.",
        "meta_lang": "en",
        "meta_favicon": "https://res.cloudinary.com/practicaldev/image/fetch/s--E8ak4Hr1--/c_limit,f_auto,fl_progressive,q_auto,w_32/https://dev-to.s3.us-east-2.amazonaws.com/favicon.ico",
        "meta_site_name": "DEV Community",
        "canonical_link": "https://dev.to/koenighotze/dealing-with-data-in-microservice-architectures-part-3-replication-4h7b",
        "text": "Microservices is a popular and widespread architectural style for building non-trivial applications. They offer immense advantages but also some challenges and traps. Some obvious, some of a more insidious nature. In this brief article, I want to focus on how to integrate microservices.\n\nThis overview explains and compares common patterns for dealing with data in microservice architectures. I neither assume to be complete regarding approaches nor do I cover every pro and con of each pattern. As always, experience and context matter.\n\nFour different parts focus on different patterns.\n\nSharing a database\n\nSynchronous calls\n\nReplication\n\nEvent-driven architectures\n\nIn the last article we discussed synchronous calls. The resulting challenges on a technological and organisational level led to surprising insights.\n\nThis article introduces replication as a pattern for data-integration in microservice landscapes. We will look at the basic concepts and especially at their use in hybrid landscapes. Landscapes, where we want to integrate pre-existing datastores with microservices.\n\nClassical replication at 10 km\n\nFirst of all, let’s discuss replication itself. We use replication to increase reliability, allow for fail-over and improve performance. The following sketch illustrates a very simplified view of replicating data.\n\nOne primary and two secondary instances of a database are set up for replication. Each change to the primary instance is also sent to the secondary instances. If the primary instance fails, an actor could switch to one of the secondary instances.\n\nThe primary instance is the only one capable of processing any modifications. The primary instance handles all creation, deletion, or modification requests. The primary instance processes these requests. Then it forwards the changes to the secondary instances. This setup works best for read-mostly use cases, as data can be read from any instance.\n\nThis design looks trivial at first sight. But the implications warrant some discussion.\n\nHow is consistency ensured?\n\nWhat happens if actors read from the secondary instances and the instance is not up to date?\n\nWhat happens if the network breaks between the instances?\n\nand and and.\n\nWe discuss these issues in detail in the following sections.\n\nReplication in microservice landscapes\n\nLet’s take a concrete example to drive the discussion. Suppose a bank wants to modernize its IT and move towards a microservice landscape. One large SQL database stores the financial transactions of customers. This database is of high value to the enterprise and is considered to be the Golden Source. This means that this database contains the \"truth\" about all data stored within. If the database says you transferred some money from A to B, then this is a fact.\n\nThe microservice could access the database directly, see the following illustration.\n\nAs we saw in part one, sharing a database in this way has its own downsides, such as:\n\nClassical databases often only scale vertically. There is an upper limit to the number of clients such a database can serve at the same time.\n\nThe classical database may not be available 24/7. It might have some scheduled, regular downtime.\n\nMore often than not, the data-model of the database does not fit the use-cases of the microservices.\n\nThe ownership of the data may be unclear.\n\nSo, how does one get from the architecture above to something like the following?\n\nThis is where advanced replication tactics enter the scene. There are many ways to tackle this problem. We focus on Change-Data-Capture and complex transformation pipelines.\n\nChange-Data-Capture\n\nThe Change-Data-Capture (CDC) framework hooks into a source database. The framework captures all changes to the data - hence the name. Afterwards, the CDC framework transforms and writes the data to a target database. One example technology for this use case is Kafka. The following illustration visualizes this approach.\n\nWe hook into our source database for example with Kafka Connect and Debezium. Debezium reads the database’s transaction log (TX Log). Debezium forwards changes to the transaction log to Kafka topics. The microservices (MS) consume the data from the topics and fill their databases (DB) as needed. We can optimize the microservice-databases for the respective use case. For example, one microservice might need a PostgreSQL whereas another needs a Redis.\n\nThe initial load can take some time. The framework exports the complete source database. The consumer must manifest or reconstruct the destination databases. But once finished, later changes are fast and small. The next diagrams illustrate this.\n\nThe CDC pipeline (again, Kafka) processes all entries of the transaction log (TX Log). It stores each entry in Kafka-topics and forwards it to the receiving services. These services in turn manifest their local view of those entries.\n\nThe services are operational after the initial run. The CDC pipeline processes only new entries to the transaction log. The next illustration shows this step.\n\nThe transaction log contains new entries. These new entries result in new Kafka events. Note that the top-most topic does not contain new events. Kafka forwards the new events of the bottom two topics to the services.\n\nCreating such a streaming platform extends the scope of this article. We only scratched the surface and omitted many relevant details. This article describes the approach using Kafka tooling.\n\nComplex transformation pipelines\n\nWe can also transform and enrich the data as part of the data replication process. Let’s use financial transactions as a trivial example again. The next illustration depicts such a pipeline.\n\nThe source database stores financial transactions. We use CDC to extract data from the source database and to push the data into raw databases (TX-DB). The raw databases contain copies of the original data.\n\nIn our example, some machine learning tool-set (ML-Magic) analyses the raw data. The result of the analysis is a categorization of the financial transaction. The ML-Magic combines the analysis and the financial transaction data. Finally, the ML-Magic stores this result in a separate enhanced business database. In the example, this is a MongoDB database.\n\nMicroservices use only the business databases. These are derived from the raw data and are optimized for specific use cases. The business database could for example be optimized and contain a denormalized view of the data. New business databases can be added as new use cases arise.\n\nImplications\n\nChange-data-capture and transformation pipelines are both valid approaches. Both help to move from existing system landscapes towards a more flexible architecture. We can adopt a microservice landscape without any modification to the existing assets. The microservices each end up with their optimized data-store. This decouples the development teams and increases agility.\n\nHowever, introducing Kafka and similar frameworks increases the development complexity. Even so,\n\nthis may be a valid investment. The resulting architecture may enable the business side to move and grow faster.\n\nBut nothing is a silver bullet. We identify at least the following questions that are worth further investigation:\n\nThe Golden Source remains. What should happen if microservices create new data or change existing data?\n\nCDC and transformation pipelines take time. How should we deal with data in different states in different parts of our system?\n\nHow can we ensure that data is only used by systems allowed to use said data?\n\nAgain, let’s discuss a concrete example. We have talked about financial transactions. Our current system looks like illustrated by the following diagram.\n\nWe hook into the source database (Golden Source) again with Kafka Connect and Debezium (I). Kafka topics store transaction log entries as events. The microservice consumes the topics it needs (II). Afterwards, it manifests a local view in its local business database (III).\n\nIf we want to read financial transactions, we need to query the local business database. The microservice owns the business database. In the following illustration, a caller sends a GET request to the microservice (I). The microservice queries the optimized local database (II) and answers the GET request.\n\nBut what happens if a client asks the microservice to make a new transfer? A caller sends a POST request to the microservice. The microservice adds the new transaction to its local database. Remember that the Golden Source is the pre-existing source database. It contains the truth. Especially the truth about any financial transactions. So we need to send the information about the new transaction also to this database.\n\nHow do we approach this?\n\nWe could update the local database and then call the API to update the Golden Source. But what happens if the API call fails? Then we need to clean-up the local database and send the error also to the caller.\n\nWe could call the API first and only update the local database if the call was successful. Again, this is not as simple as it seems. The problem is the remote call to the API. There are error cases like e.g. timeouts, that leave us clueless. We do not know if the API call booked the transfer at all.\n\nIn the end, it doesn't matter. We cannot span a transactional context across a HTTP API call and a local database in a meaningful way. Consider the documentation of the good-old HeuristicCommitException.\n\nIn a distributed environment communications failures can happen. If communication between the transaction manager and a recoverable resource is not possible for an extended period of time, the recoverable resource may decide to unilaterally commit or rollback changes done in the context of a transaction. Such a decision is called a heuristic decision. It is one of the worst errors that may happen in a transaction system, as it can lead to parts of the transaction being committed while other parts are rolled back, thus violating the atomicity property of transaction and possibly leading to data integrity corruption.\n\nThere is a pattern that can help us with this scenario: the outbox. We introduce a message log table (ML). A so-called outbox handler forwards all data of the message log to the Golden Source. See the following illustration.\n\nUpdating the message log and the transaction table (TX) happens as one transaction (II and III). Both tables are part of the same database, so a single local transaction is enough.\n\nThe microservice can return the result to the caller and finish the request.\n\nNow we get to the tricky part. Handling the message log. Often the API triggers some process side-effects besides updating the Golden Source. For example, calling out to other APIs or sending messages downstream.\n\nThe following diagram explores the communication flow.\n\nThe Outbox Handler polls the message log table or subscribes to changes to it (I). It reads the data and calls the API (II). If calling the API was successful, then the handler marks the message log entry as done. Otherwise, the Outbox Handler retries the operation. If all fails, the handler marks the entry as not processable.\n\nIn such cases, other mitigation strategies come into place. But this is outside of our discussion.\n\nSuppose the API call was successful. Next, among other things, the API call updates the Golden Source (III). This triggers the CDC pipeline. The CDC component captures the new data added to the Golden Source’s transaction log. Afterwards this data ends up in the Kafka topics (IV). The consuming microservice receives that data (V). Finally, the microservice updates the business database. The database now reflects the state of the Golden Source, too (VI).\n\nWe have omitted many technical details. Still, the complexity of this pattern should stand out. Many things could go wrong at any point. A solid solution must find mitigation strategies for each error case.\n\nEven so, the eventual consistent character of this architecture does not go away. The new data stored in the business database does not reflect the Golden Source data right away. The time delay may or may not be an issue for the concrete use case. But we need to be aware of it and should analyse the impact of it.\n\nThe same holds for the topic of data governance. The patterns of this article lead to data replication, i.e. to storing the same data in many places. Depending on the regulatory requirements, we need to control which parts of the system landscape can use which data. This has to be set in place right from the beginning. Refactoring data governance controls into an existing landscape can be very challenging.\n\nLast but not least, let’s not forget that CDC leads to technical events. Real domain events representing business-level processes are not captured.\n\nSummary\n\nAll things considered, this can be a good option to grow from a static large datastore to a reactive and distributed multi-datastore landscape.\n\nMoving towards modern architectures without any major refactoring of existing systems is possible. We can leverage and use so-called legacy systems without any direct extra cost of doing so.\n\nWe do not change existing systems. So we end up with the \"old\", \"legacy\" system landscape, and the new microservice landscape. Complexity and cost increase. We need more engineers. We need more infrastructure. And so on.\n\nBut, we must not confuse this with event-sourcing or an event driven architecture. It can be the first step into those areas, but only the first. We are considering technical events a la \"Row x in Table y has changed in values A, D, F\". This is different from saying \"SEPA Transaction executed\". And we have to deal with eventual consistency. There is no way of avoiding this.\n\nIn conclusion, we need to check the advantages and implications of the approaches. There cannot be the best answer. We need to consider the concrete requirements and use cases. These determine if this approach is a good fit for our challenge and strategy.\n\nHere are some references for more in-depth information on related topics:\n\nChange Data Capture Pipelines with Debezium and Kafka Streams\n\nNo More Silos: How to Integrate Your Databases with Apache Kafka and CDC\n\nReactive design patterns, Roland Kuhn et. al.\n\nReliable Microservices Data Exchange With the Outbox Pattern\n\nOutlook\n\nThe next and final installment of this series tackles event-sourcing and event-driven-architectures. Both powerful and related concepts. We will look at their implementation and advantages. But as always also at their implications on design and architecture."
    }
}