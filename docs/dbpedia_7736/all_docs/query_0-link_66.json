{
    "id": "dbpedia_7736_0",
    "rank": 66,
    "data": {
        "url": "https://blog.isquaredsoftware.com/2020/09/coding-career-advice-evaluating-libraries-tools/",
        "read_more_link": "",
        "language": "en",
        "title": "Coding Career Advice: Evaluating Software Libraries and Tools",
        "top_image": "https://blog.isquaredsoftware.com/images/logo.png",
        "meta_img": "https://blog.isquaredsoftware.com/images/logo.png",
        "images": [
            "https://blog.isquaredsoftware.com/images/avatar.jpg",
            "https://blog.isquaredsoftware.com/images/PaypalTipJar.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2020-09-21T23:30:00-05:00",
        "summary": "",
        "meta_description": "How to evaluate third-party libraries and tools for potential usage",
        "meta_lang": "",
        "meta_favicon": "https://blog.isquaredsoftware.com/images/favicon.ico?2016-09-13",
        "meta_site_name": "Mark's Dev Blog",
        "canonical_link": "https://blog.isquaredsoftware.com/2020/09/coding-career-advice-evaluating-libraries-tools/",
        "text": "How to evaluate third-party libraries and tools for potential usage\n\nAs a senior developer, I spend a lot of my time looking at tools and libraries to decide if they're something we can or should use as part of our projects. I've developed a strong ability to quickly filter through lists of possible tools to narrow them down, and then do further research on the remaining candidates.\n\nThis is definitely not the kind of skill that they teach you in school, which is sad given the way modern software development is strongly dependent on reusing libraries.\n\nTo help with that, here's some of the things I take into consideration when evaluating tools.\n\nStarting Point: Search Locations ð︎\n\nFor software libraries, you should typically start with the appropriate package manager site for the language you're using, such as NPM for JavaScript, PyPi for Python, or Maven Central for Java). If you're looking for non-library tools such as IDEs, Google is your best bet.\n\nSearching for keywords on those sites should turn up a list of things that are potentially relevant.\n\nPotential Evaluation Criteria ð︎\n\nWhen choosing any tool, you have to evaluate it on multiple criteria. Here's an (incomplete) list of things you may want to consider when looking at any software library or tool that you're considering using:\n\nZeroth Pass: Relevance ð︎\n\nThe first step is to select a list of tools that actually look relevant to your topic. For example, searching NPM for react number input right now turns up 219 hits. There's probably only a much smaller number that actually match what you're looking for. Skim through the hits and pop open the most likely looking options based on the initial descriptions.\n\nFirst Pass: Basic Suitability ð︎\n\nNow that you've got the initial candidate list, it's time to determine which of these may be a good possibility:\n\nDoes this even solve the problems I have right now?\n\nDoes it solve those problems well?\n\nWhat's the license of this tool? Is it compatible with my company's policies?\n\nThe goal of using any tool is to solve a problem you have. If a tool doesn't solve your problem, you shouldn't even consider using it in the first place. (Note that this implies that you should understand what problems you're trying to solve before you start investigating tools to help with them :) )\n\nAlong with that, there's the question of whether a tool is something you can use based on legal or policy concerns. For example, many companies disallow use of GPL-licensed software libraries to avoid any possible issues mixing their proprietary code with GPL-licensed code and being forced to distribute their own code publicly. Other companies might restrict libraries and applications based on the nationality of the authors, purchased licensing terms, or license costs.\n\nOne-line summary of the most common open-source (OSS) licenses:\n\nMIT, BSD: use the code for whatever you want, just credit the original author\n\nLGPL: Use it as long as you don't modify the original library\n\nGPL: If you use it, your own software must be licensed under the GPL as well, and your source must be made available on request\n\nIf you know ahead of time that you can't use a particular tool, there's no point in digging into it further.\n\nSecond Pass: Detailed Evaluations ð︎\n\nOnce you've narrowed down the list down to the top 3-4 choices, you can do a more detailed evaluation of each of them.\n\nHere's some of the criteria that I take into consideration. I don't necessarily have these in a formal checklist, but they're usually in the back of my head in some form. (This list is biased towards OSS software libraries, particularly for JavaScript, but most apply more broadly as well).\n\nHow easy is it to use?\n\nWhat's the size of the community?\n\nHow many projects appear to use this tool?\n\nHow many downloads does this have weekly/monthly?\n\nHow much info is there on using it outside the core docs?\n\nWhat's the size of the ecosystem?\n\nHow many related packages exist?\n\nIf we have an additional use case not solved by the core tool, do addons exist that handle that use case?\n\nHow easy is it to extend or modify this tool?\n\nHow easy is it to understand what the tool does internally and conceptually?\n\nHow much documentation does this have? Is there an actual meaningful docs site, or is it just a Github readme?\n\nHow well tested is this tool?\n\nHow much prior experience does my team have with this tool or something similar?\n\nIs it well maintained?\n\nHow many bugs does it have?\n\nHas this ever had any critical vulnerabilities / CVEs? If so, how many, how often, and how long did they take to get fixed?\n\nHow often do new releases occur? When was the last release?\n\nHow many open issues / PRs are there?\n\nHow fast will things get fixed if there's a bug?\n\nHow many maintainers are there? Are they active?\n\nWhat's the long-term roadmap for this project?\n\nHow many other dependencies does this tool have?\n\nHow many of them are runtime dependencies vs development-only dependencies?\n\nDo we need to be concerned about any of them?\n\nHow much does this affect the architecture of our app?\n\nCan we rip it out if we choose to switch to something else?\n\nHow hard is it to upgrade this tool when a new version comes out?\n\nWhere does this fall in the \"hype cycle\"?\n\nBrand new tool that is experimental? It works, but still only used by early adopters? Mainstream? Dying?\n\nAre people actively starting new projects with this tool, or are they moving away?\n\nWhat technical requirements and system constraints does this have?\n\nWhat's the minimum runtime version?\n\nAre there size concerns, such as min+gzip size for a JS library used in the browser?\n\nThis isn't an all-inclusive list - there's likely other factors you might want to consider as well.\n\nThese all affect a decision on whether using a given tool is a good idea or not for your team. It's also likely that some of these may be more relevant than others depending on your situation.\n\nNote that you could easily spend an infinite amount of time recursing through the transitive dependencies of a given tool, especially if this is a JavaScript package of some kind. For example, a brand new Create-React-App project only has a handful of dependencies: react, react-dom, @testing-library/react, and react-scripts. However, react-scripts itself depends on Jest, ESLint, Webpack, Babel, PostCSS, and a couple dozen other packages, and Webpack in turn ends up pulling in around 700 packages, for a final total of just over 1500 individual packages installed into your node_modules folder. Clearly, inspecting every one of those manually is not feasible, so you have to draw a line somewhere. Given the rise of \"supply chain\" attacks, where malicious packages are deliberately created to steal information or cause harm, it's critical to make these decisions wisely.\n\nIt can sometimes be worth doing a \"trade study\" to evaluate alternatives, especially if multiple people are involved in this decision. Define several categories, decide on the possible range of numeric scores for each category, and rate each tooling option in each category. You may want to add together the scores for each tool, or average them out. Also, you might want to weight some categories as being more important than others. I suggest defining the weights and scoring approach ahead of time, so that the final decision is more fair.\n\nWhen searching for critical security vulnerabilities like CVEs, you can use sites like https://cve.mitre.org/cve/search_cve_list.html and https://nvd.nist.gov/vuln/search as references.\n\nFor open-source projects on Github, it's worth looking at the number of stars, open issues, and PRs. Those aren't final decision criteria, but they can give you a sense of the popularity and health of a project. Also keep an eye on the recent commits to get an idea how active it is.\n\nNPM shows a weekly download stats graph on the package description page, but I prefer using npm-stat.com, which lets you compare the download stats for multiple packages over a specific period of time, with values shown for daily/weekly/monthly/yearly downloads totals.\n\nFor JS client bundle size questions specifically, I strongly recommend using Bundlephobia to determine the true cost of adding a given package to your app. Michel Weststrate's import-size util can also be helpful here.\n\nFurther Information ð︎"
    }
}