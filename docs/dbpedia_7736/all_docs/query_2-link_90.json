{
    "id": "dbpedia_7736_2",
    "rank": 90,
    "data": {
        "url": "https://forums.inedo.com/topic/3664/package-license-definition",
        "read_more_link": "",
        "language": "en",
        "title": "Package license definition",
        "top_image": "https://forums.inedo.com/assets/uploads/system/site-logo.svg",
        "meta_img": "https://forums.inedo.com/assets/uploads/system/site-logo.svg",
        "images": [
            "https://forums.inedo.com/assets/uploads/system/site-logo.svg?v=nobkt0ec794",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/files/1672184170215-79f25c48-e2c4-4d72-babb-eeb503cee88e-image.png",
            "https://forums.inedo.com/assets/uploads/files/1672184261087-53a8a451-3e6b-4b57-85bf-a4f14482f8bc-image.png",
            "https://forums.inedo.com/assets/uploads/files/1672220127374-5866ef36-2eac-4cb3-867d-b378e37c1ca4-image.png",
            "https://forums.inedo.com/assets/uploads/files/1672220219933-cda6e72b-2637-4157-8e49-6dd1c7b6c756-image.png",
            "https://forums.inedo.com/assets/uploads/files/1672220568522-56980e94-ef98-4bab-af10-6ac09a5b8980-image.png",
            "https://forums.inedo.com/assets/uploads/files/1672220535435-e89dbb7a-ecd5-49c8-b136-2c2eb75df26e-image.png",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/profile/4-profileavatar.png",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/plugins/nodebb-plugin-emoji/emoji/android/1f926.png?v=nobkt0ec794",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/assets/uploads/profile/2-profileavatar.jpeg",
            "https://forums.inedo.com/plugins/nodebb-plugin-emoji/emoji/android/1f609.png?v=nobkt0ec794",
            "https://forums.inedo.com/plugins/nodebb-plugin-emoji/emoji/android/1f605.png?v=nobkt0ec794"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "inedo",
            "proget",
            "buildmaster",
            "otter"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-12-27T22:11:58.166000+00:00",
        "summary": "",
        "meta_description": "ProGet Version 2022.16 (Build 7) (Inedo Hub) - Trial version Hello, we are evaluating ProGet as our package manager, and license control is one of the critical features that ProGet gives us. In the first installation, I remember seeing the possibility to ...",
        "meta_lang": "en",
        "meta_favicon": "/assets/uploads/system/favicon.ico?v=nobkt0ec794",
        "meta_site_name": "Forums",
        "canonical_link": "https://forums.inedo.com/topic/3664/package-license-definition",
        "text": "Hello Alana,\n\nThank you for the clarification.\n\nThe problem is, I don't see the option to assign the license type to Package as you can see in the two examples below.\n\nFirst Example\n\nAccord Package\n\nThis package has a file license as you can see here in the picture below\n\nBecause the ProGet is not able to read the file to identify the license (LGPL), the license doesn't appear in the main feed and cannot be allowed/restricted by our rules:\n\nThe same is true for some other packages, for example, Newtonsoft.Json.Schema.\n\nSo, I would like to be able to specify manually the licenses for these type os packages.\n\nSecond Example\n\nFor a package without any license information, the option to assign the license type to Package is not appearing at all\n\nBest Regards,\n\nPedro\n\nHi @pmsensi,\n\nwe are facing a similar challenge. Basically, what I am interested in is a list of packages that we are currently using in our products that don't have a known license assigned to them (or: Proget was unable to identify the license, e.g. because the license info just states \"see licenense.txt\" or something like that). I think that you are looking for something similar and are not asking to analyze all packages that exist on Nuget or npm, because that would probably would not be feasible (as @atripp already mentioned in her reply).\n\nWe are using the new Reporting & SCA feature extensively, and we are getting some very nice license statistics out of it. However, the one thing that is currently missing is the number or list of packages with an unknown license. I hope that this will be added in a future release. In the mean time, looking at the database can be a workaround to at least get a list of the package name.\n\nI think starting with 2022, ProGet started storing license infos of known packages in the database. I am assuming that that info is stored for packages that have been downloaded via ProGet (i.e. \"cached\") or maybe also for packages that have been reported to ProGet via pgscan (@atripp please feel free to add some info to this).\n\nOne simple approach to get the license info of all \"known\" packages, would be this:\n\nselect pi.Package_Name, l.External_Id, l.Title_Text from PackageIds pi left join PackageLicenses pl on pl.Package_Id = pi.Package_Id left join Licenses l on pl.License_Id = l.License_Id group by pi.Package_Name, l.External_Id, l.Title_Text order by 1;\n\nNote that this select groups by package names and ignores versions. You could now simply look for packages without a known license like this:\n\nselect pi.Package_Name, l.External_Id, l.Title_Text from PackageIds pi left join PackageLicenses pl on pl.Package_Id = pi.Package_Id left join Licenses l on pl.License_Id = l.License_Id where l.External_Id is null group by pi.Package_Name, l.External_Id, l.Title_Text order by 1;\n\nHowever, if you look at the result of first query, you might notice that there might be multiple entries for some packages. That might be because a package has changed its license or just its license info (maybe switching from a \"see license.txt\" to an actual SPDX tag), or maybe because there was a bug in previous versions of ProGet that has been fixed in 2202.18 (https://inedo.myjetbrains.com/youtrack/issue/PG-2263). So you might get some false positives with this approach.\n\nTo get a list of packages without any entry of a known license, we have to eliminate the ones with multiple entries. There might be a better and more readable way to get this done, but the query that worked for us is this one:\n\nselect distinct pi.Package_Name from PackageIds pi left join PackageLicenses pl on pl.Package_Id = pi.Package_Id left join Licenses l on pl.License_Id = l.License_Id where l.External_Id is null and pi.Package_Name in (select Package_Name from ( select a.Package_Name from ( select pi.Package_Name, l.External_Id, l.Title_Text from PackageIds pi left join PackageLicenses pl on pl.Package_Id = pi.Package_Id left join Licenses l on pl.License_Id = l.License_Id group by pi.Package_Name, l.External_Id, l.Title_Text ) a group by a.Package_Name having count(*) = 1 ) b);\n\nBTW: in case you are curious: that select gives us a list of 1222 packages.\n\n@apxltd Using URLs for packages would be a nice feature, especially as package URLs contain version numbers. Getting rid of those might already be helpful, because some package come in a rather large number of versions. Of course, even applying a wildcard to just the version of a package might lead to wrong results, because in theory a package could change it's licese from one version to the next, but that is probably not a very realistic scenario.\n\nHowever, things can become messy when different wildcard URLs could be applied to the same package. Unfortunately, not all Microsoft packages use MSPL. Some use MIT, some use the proprietary licenses... It's a real mess. So it probably wouldn't be as easy as making just one rule for microsoft.*. But still, using wildcards could make things a bit easier.\n\n@pmsensi We haven't used TrustedInstaller yet. The approach is interesting, and yes: it would probably make sense to have a central service like a ProGet server check package owners, but it would be a completely different approach to a very different problem. I don't think applying licenses to package owners makes a lot of sense, because - as written above - package owners like Microsoft can apply different licenses to different packages.\n\nThat being said, having a new entity \"package owner\" or \"publisher\" or something like that and being able to filter for that entity could be a cool new feature. This could also be used in the SBOM reporting feature (like: 40 packages come from Microsoft, 20 from vendor A, 7 from vendor B).\n\n@apxltd said in Package license definition:\n\nIn the past, we thought of adding a kind of wildcard URL for licenses, like a \"package://Microsoft.*\" => \"MSPL\" would basically associate all packages with that prefix that don't otherwise have a SPDX code, or an explicit license.\n\nWonder if that would help here?\n\nA colleague of mine actually had an interesting idea today: How about calculating hash values (like SHA-1) for embedded license files and assigning licenses to those hash values? That way one would only have to assign licenses to each license text once (if the license text is identical across different packages or package versions).\n\nThe workflow would be similar to assigning licenses to actual packages / versions, but instead of adding an pseudo URL like \"packages://SomeVendor.SomePackage/1.2.0\" we could do something like \"hash://0xA1B2C3\", where 0xA1B2C3 would be the hash value of the content of the license file. All other packages / versions with the exact same license text would automatically be mapped to the same license.\n\nOf course, some license texts include the name of the product or a copyright note, so we would still get multiple entries for the same license. But it should be significantly less than adding one entry for every package / version.\n\nWhat do you guys think about this idea?\n\nHI @apxltd,\n\nIt's even more confusing to use than packageid://, so we'd need to find a better UI solution\n\nWould it be more confusing to have two or three hash values instead of dozens, maybe hundreds of packageid:// entries for a given license? People are getting used to using hash values (e.g. with GIT commits). One would have to be able to view the original license text, of course (see next point)...\n\nWe'd want to store the full license text as well, so it'd be easy to confirm the contents\n\nAgreed. Otherwise, there is no way of confirming that the hash value was assigned to the correct license. But I don't think that would be infeasible. One could either store the content of the license file in a dedicated table in the database, or in file. And we only have to store it once per hash value. A single license file takes what, 1 maybe 2 KB? Let's say we will have a dozen, maybe a hundred different license files at the end (unlikely, probably more in the lower double digits area). That would take less than 1 MB in total.\n\nThis is all a nontrivial engineering effort\n\nAgreed, but it's not too complex either. There is obviously already code in Proget which detects that there is an embedded license file and that can display the content of that file. I'd say you are probably almost halfway there :-)\n\nWe're not sure how many packages this would impact and how much value / time savings it would represent\n\nHere is an example: Consider the Google.Apis.* packages (https://www.nuget.org/packages?q=google.apis). They all have the exact same Apache 2.0 license file embedded, so we would have to assign just a single hash value instead of dozens / hundreds of individual packages.\n\nAnother point is updates of packages. At the moment we would have to assign a license to every new version of a package. I think this feature could be a huge time saver.\n\nNone of this would even work for remote packages, which is by far what most users find confusing and have issues with\n\nYes, for this to work, Proget would have to download the given package and read to content of its license file. However, there are two major parts of Proget where license become relevant, and I believe the it's not an unrealistic scenario that Proget has downloaded the package in question in both scenarios:\n\nBlocking packages. We want to prevent users from downloading packages with specific licenses. Let's assume a user wants to download X with version 1.2.3, and that package has an embedded license file. Now, to be able to serve the package to the user, Proget has to download it first, right? Either it has done so already and the package is cached, or Proget has to download it on demand. In both cases Proget has a chance to read the license file and compute a has value for its content, if it hasn't already done that before.\n\nReporting. Most packages that are analyzed by the SCA feature should have been downloaded in the past via Proget.\n\nIt would probably require less engineering effort to scan/query all packages on NuGet and make a \"database\" of package licenses using a little human intelligence\n\nI think downloading all packages (including all versions of each package) and analyzing them would take a lot of effort and resources.\n\nIt would require even less effort to just ask package authors to specify license codes, and then eventually the problem will go away on its own probably\n\nWill try this, starting with the Google folks...\n\nThanks for the additional thoughts @sebastian!\n\nI agree... it's not totally infeasible from a technical standpoint, but it's still pretty tricky. Just to comment on a technical thing, FYI...\n\nNow, to be able to serve the package to the user, Proget has to download it first, right?\n\nActually, ProGet \"streams\" content from connectors. This means that, when a user requests a package from ProGet (and that package is on a remote connector), ProGet will then request a package from the connector. As the file is being downloaded, ProGet will send the same data back to the user and optionally write that data to disk. If we didn't do this, ProGet would be basically unusually slow.\n\nA ZIP archive (what package files use) use a tail index, which means you have to read it backwards from End of File. So it's not possible to read an embedded file unless we've downloaded the entire package.\n\nThere are a few other \"gotchas\" we'd need to consider, even for cached/local packages. For example, we can't open/seek the package file just to know the license and if the package should be blocked - especially when it comes to cloud storage (for the same reason - tail indexing). So, we would obviously need to store package license file info in the database too... but then we'd need a way to deal with existing packages on disk that don't yet have that info.\n\nWe may also want to add some sort of heuristic analysis of license text, even if it's simple as a basic distance check. Personally I think that's a bad idea to rely on... but other products do, and the reality is most users would just skim a license anyway.\n\nThis all becomes a lot easier after v2023 with centralized data and a package analyzer that can background scan all these, but still not trivial. And then there's the real hard part... the UI and documentation\n\nWe definitely don't want to hack something in like packageid:// and package::// -- those have been a total pain and plus, I hate the design\n\nAnyway -- just wanted to give more technical insight into why ProGet behaves like this, and why I'm hesitant to jump on the \"reading license file\" approach without adding somethign that's a lot more valuable than what we have now."
    }
}