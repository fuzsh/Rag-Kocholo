{
    "id": "dbpedia_8830_0",
    "rank": 57,
    "data": {
        "url": "https://discussions.unity.com/t/uniinject-dependency-injection-for-unity/901198",
        "read_more_link": "",
        "language": "en",
        "title": "UniInject - Dependency Injection for Unity",
        "top_image": "https://europe1.discourse-cdn.com/unity/original/3X/a/a/aaeab82727497b6f37f4312dcd57be21e6cd25e8.png",
        "meta_img": "https://europe1.discourse-cdn.com/unity/original/3X/a/a/aaeab82727497b6f37f4312dcd57be21e6cd25e8.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Scripting"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-11-25T10:34:28+00:00",
        "summary": "",
        "meta_description": "I created a small Dependency Injection library for Unity call UniInject. \nFind it on GitHub (MIT license): GitHub - achimmihca/UniInject: Dependency Injection for Unity3D \nWhy Dependency Injection? \n\nBetter separation of&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://europe1.discourse-cdn.com/unity/optimized/3X/5/d/5d3b1bfc21f0dea8ce3730e22d85cbf4072b7c02_2_32x32.png",
        "meta_site_name": "Unity Discussions",
        "canonical_link": "https://discussions.unity.com/t/uniinject-dependency-injection-for-unity/901198",
        "text": "I created a small Dependency Injection library for Unity call UniInject.\n\nFind it on GitHub (MIT license): GitHub - achimmihca/UniInject: Dependency Injection for Unity3D\n\nWhy Dependency Injection?\n\nBetter separation of concerns and loose coupling, which leads to composable software and code reuse\n\nBetter testability\n\nLess boilerplate code to get instances\n\nDependency injection (DI) is a general concept in object oriented programming.\n\nIf you are new to the topic, then I recommend you this introduction.\n\nYou might also be interested in the introduction from the Zenject library, which is another DI library for Unity.\n\nWhy UniInject?\n\nThe goal of UniInject is to unify the handling of getting an instance.\n\nIn Unity you can wire up your object’s dependencies in the Editor’s inspector window.\n\nFurthermore, there are GetComponent or GetComponentInChildren.\n\nUsing UIToolkit, you also have visualElement.Query to get instances.\n\nIn UniInject, the same Inject-annotation can be used to get an instance\n\nfrom custom bindings\n\nfrom components (e.g. GetComponent, GetComponentInChildren)\n\nfrom VisualElements (when using Unity’s new UIToolkit / UXML / UIDocument)\n\nFeatures\n\nField, property, method and constructor injection\n\nCyclic dependencies are handled (except for constructor injection)\n\nOptional injection\n\nMarking something as optional will not throw an Exception when no value is present\n\nCustom key for injection\n\nThe default is the type of the field that should be injected\n\nHierarchy of different injection contexts (e.g. for Player1 and Player2)\n\nScene injection is finished after the Awake() method, such that the injected values can be used in the Start() and OnEnable() methods for further setup logic\n\nThe values of GetComponent, GetComponentInChildren, etc. are mockable.\n\nThus, for tests the scene hierarchy can be simulated.\n\nCustom bindings can be created using normal MonoBehaviours that implement the IBinder interface\n\nStatic validation in Edit Mode that there is a value for every symbol, which should be injected\n\nMark fields that are set in the inspector via the InjectedInInspector-annotation.\n\nIt makes the origin of values easier to grasp.\n\nThe static validation can check that a non-null value has been set in such an annotated field.\n\nCalling injection methods is also possible in edit-mode (e.g. calling SceneInjectionManager.DoInjection())\n\nUniInject provides you with tools for DI that you can adapt for your own needs.\n\nBuild upon the given logic to change when, how, and what is injected.\n\nThe included SceneInjectionManager is a good starting point for inspiration."
    }
}