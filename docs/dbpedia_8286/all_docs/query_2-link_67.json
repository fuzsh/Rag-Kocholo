{
    "id": "dbpedia_8286_2",
    "rank": 67,
    "data": {
        "url": "https://budibase.com/blog/tutorials/mysql-gui/",
        "read_more_link": "",
        "language": "en",
        "title": "Create a Free MySQL GUI in 5 Steps",
        "top_image": "https://res.cloudinary.com/daog6scxm/image/upload/v1664899852/cms/How_to_Build_a_MySQL_GUI_zefmyr.png",
        "meta_img": "https://res.cloudinary.com/daog6scxm/image/upload/v1664899852/cms/How_to_Build_a_MySQL_GUI_zefmyr.png",
        "images": [
            "https://res.cloudinary.com/daog6scxm/image/upload/v1696515187/Branding/Assets/Logo/RGB/Full%20Colour/bb_logo_fullcolor_uejofd.svg",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1639756662/cms/IMG_3081_ubvpag.jpg",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664899937/cms/01_g2wkjm.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664899959/cms/02_sewsdx.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664899984/cms/03_xmn84w.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900004/cms/04_m3nhai.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900046/cms/05_c0susq.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900074/cms/06_kstacw.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900099/cms/07_hkrt2p.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900118/cms/08_ympwv3.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900137/cms/09_gl1ll4.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900154/cms/10_ezccjx.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900172/cms/11_womzwo.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900201/cms/12_jhyr2n.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900255/cms/13_qpcljq.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900293/cms/14_n70bjy.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900499/cms/15_brryta.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900618/cms/16_bcz9ba.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1664900636/cms/17_c5n9zh.webp",
            "https://res.cloudinary.com/daog6scxm/image/upload/v1696515187/Branding/Assets/Logo/RGB/Full%20Colour/bb_logo_fullcolor_uejofd.svg",
            "https://px.ads.linkedin.com/collect/?pid=5352410&fmt=gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Ronan McQuillan"
        ],
        "publish_date": "2024-03-20T23:00:00+00:00",
        "summary": "",
        "meta_description": "Read our step-by-step guide to learn how to build a MySQL GUI, in minutes.",
        "meta_lang": "en",
        "meta_favicon": "https://res.cloudinary.com/daog6scxm/image/upload/v1698314967/Branding/Assets/Symbol/RGB/Full%20Colour/trans_ag0ndy.svg",
        "meta_site_name": "",
        "canonical_link": "https://budibase.com/blog/tutorials/mysql-gui/",
        "text": "MySQL is one of the most popular database systems out there. And that’s for a good reason. It is lightweight, fast, easy to learn, and widely available. Using a MySQL GUI to manage your databases will help you make the most out of this tool.\n\nA GUI (Graphical User Interface) allows you to interact with your database with a visual interface. This allows you to see your data and use visual elements as opposed to text-based terminals and command lines.\n\nNaturally, this is crucial if you want your non-technical team to manage data.\n\nIt can be hard to pick the right MySQL GUI tool though.\n\nThere are many options to choose from - many price ranges, features, and operating systems. However, it’s not hard to build a free tool that can do anything you want, and work on any devices you want to, including mobiles.\n\nYou can build your own MySQL GUI in just 5 steps.\n\nThe craziest part is that if you just need a simple CRUD tool, you can do it in just 2 steps, as we’ll see in a few minutes.\n\nTherefore, today we are going to explore how you can build a free MySQL web interface using Budibase. You are going to learn how to:\n\nCreate an app and connect to a database server.\n\nAuto-generate CRUD screens.\n\nDynamically load all tables in your database to import and export data.\n\nDynamically load all columns from a database table.\n\nCreate flexible forms that can edit and insert data into any table or database schema.\n\nCreate flexible tables to display data from any query.\n\nCreate multi-step forms for a query builder, to generate custom queries based on user inputs.\n\nDeploy a fully working management tool with custom database connections.\n\nLet’s get started!\n\nDoes MySQL have a GUI?\n\nMySQL is a database system. It doesn’t have an official GUI, but there are many app options to connect to it. There are free and open source apps, as well as paid options.\n\nIn addition, you can build your own MySQL GUI using the tips from this 5-step guide, leveraging Budibase as a MySQL frontend builder.\n\nWhat is the best GUI for MySQL?\n\nThe right MySQL GUI depends on your use case and requirements. You can build your own MySQL GUI following this guide or you can use one of these great tools listed here:\n\nAdminer\n\nBeeKeeper Studio\n\nDatabase Workbench\n\nDataGrip\n\nDBeaver\n\nDBEdit\n\ndbForge Studio for MySQL\n\nDronaHQ\n\nHeidiSQL\n\nLibreOffice Base\n\nmySQL Workbench\n\nNavicat for MySQL\n\nOpenOffice.org Base\n\nphpMyAdmin\n\nSQLBuddy\n\nSQLyog\n\nToad Edge for MySQL\n\nWebmin\n\nIt’s important to research which features you need from specific tools - for instance, cross-platform integrations or auto completion. Often, custom builds are the most cost-effective option to meet bespoke requirements.\n\nYou might also like our guide to building a Postgres GUI .\n\nWhat is GUI in MySQL?\n\nA MySQL GUI allows you to interact with your data visually. Thus, you can filter, add, update, and delete data without using SQL commands.\n\nBut a lot of these tools allow you to add your own commands as well since you’ll often need to perform custom queries.\n\nThis allows you to get the better of the two worlds. You can quickly perform actions using premade functions if you want. But you can run your own commands if you need to run a specific query as well.\n\nIn this tutorial, you are going to create a MySQL UI that looks like this:\n\nThe first screen allows you to pick one of the tables from your database, select the columns you want to show, and display the table data. If you click on the edit or add new button, you are going to see a form like this one:\n\nThis form is the same for the add new or update actions. There are some differences internally and the delete button is removed if you are adding new items.\n\nIn addition to the home screen, you can see your data with a custom query, like this:\n\nThis screen allows three methods to interact with your MySQL database. You can manually type your desired query, save and retrieve queries, or use the query builder, which is a three-step form to build custom queries based on your form selection.\n\nOnce you run your query, you’ll see your data in a table.\n\nNext, there’s the auto-generated CRUD interface for saved queries:\n\nOn this screen you can see, edit, insert and delete saved queries - for on-the-fly data modeling. These are the queries available in the custom query builder.\n\nLet’s see how you can create this app.\n\nStep 1 - Create an app and connect to a MySQL database\n\nIf you haven’t already, sign up for Budibase. You can create free apps right away.\n\nAfter you’ve created your app, connect to your MySQL database as a data source . Don’t forget to whitelist the Budibase servers in your MySQL server - or ask your database administrator to do so.\n\nOur demo data has three tables:\n\nSaved queries - A table using the Budibase DB to store the saved queries in the custom query screen\n\nPosts - A demo table with posts for a blog, with id, title, content, date\n\nSettings - A demo table with settings for a blog, with id, settings_key, and value\n\nTo make our life easier, we are going to use MySQL procedures. They allow us to execute custom functions in a regular query.\n\nFor example, if you have a store, you can create a custom function that automatically propagates data to the sales, customers, and inventory tables.\n\nIn our example, we are going to implement a procedure to run SQL commands programmatically. With it, we can pass table names as variables and we can run flexible queries for the custom queries page.\n\nYou can use SQL statements to create a procedure for that in your MySQL using this code:\n\nWe create this procedure with the name execute_immediate. Budibase offers a dedicated SQL editor with syntax highlighting as a key feature of our query builder.\n\nThen in the data tab for Budibase, you can create these queries:\n\nExecute\n\nPublic\n\nBindings:\n\nCommand - Default: SELECT * from posts\n\nFields:\n\nCALL execute_immediate( {{command}} )\n\nData:\n\nreturn data[0]\n\nShow_tables\n\nPublic\n\nFields:\n\nSHOW TABLES\n\nTable_columns\n\nPublic\n\nBindings:\n\nTablename - Default: posts\n\nFields:\n\nSELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = {{ tablename }}\n\nThat’s it!\n\nNow let’s create your first screen.\n\nStep 2 - CRUD interface for a quick MySQL GUI\n\nHead over to the design tab. Then, you can stop by the “theme” section and pick a different theme, such as the dark one. In addition, you can pick some other design options for your app such as the accent color and hover color.\n\nThen, click on the Screens option, and add a new screen. Select autogenerated screens and pick the Saved_queries table.\n\nThis should generate new screens that you can use to perform CRUD actions to your Saved_queries table. If you just want a simple MySQL GUI you could just use this method to auto-generate screens for each of your tables.\n\nBut if you have a lot of tables, you can generate flexible interfaces. This allows you to automatically have new tables available to edit without editing your app.\n\nLet’s see how you can implement this.\n\nStep 3 - Custom MySQL GUI to view data\n\nCreate a new screen to be your home screen. You can check the “set as home screen” box in the builder:\n\nThere are quite a few things going on to make this screen work.\n\nFirst, there’s the table selector. This is a data provider that loads the show_tables query. Thus, when you add new tables to your MySQL database, they are listed there automatically.\n\nThen there’s the table columns picker. It’s populated by a data provider that gets the table columns from the currently selected table. It runs the table_columns query with a binding for the table.\n\nFinally, there’s a data provider that executes a query based on the table selected and columns. This data provider populates a repeater that displays your table data.\n\nThis is the elements tree to implement that page in your MySQL GUI:\n\nNow you just need to replicate that logic. The list DB tables is a data provider for the show_tables query.\n\nThen you need a form to hold the options picker for the table you want to load.\n\nThe tables picker is an options picker. You can display the tables as options by using the list DB tables provider as an options source:\n\nThen the table columns data provider has these binding options:\n\nThis means that whenever you select a table, a new value is sent to the table columns query.\n\nInside of it, the columns picker is an options picker component, just like the tables selector. But with a checkbox mode:\n\nThe paragraph to preview the current query has the following JS code to output its text:\n\nThe add new button and the edit buttons are quite similar.\n\nThey are going to redirect your users to the /{{ tablename }}/{{ id }} page. So if you click to edit an item from the posts table with id as 3, you are redirected to the /posts/3 page. And to create new items you are redirected to /posts/0, for example.\n\nYou can implement this with this onclick action on your button:\n\nThe table data provider runs the execute query. You are going to use this binding (as JS code) in it:\n\nYou could use a table to output your query results, and that’s a great way to do with when you have a fixed schema. Since our goal here is to build flexible queries, we need to create our own display for it.\n\nIn this case, you can do it with a repeater, then output whatever data you have in it using cards.\n\nA repeater component outputs any of its child elements once per row of the data provider. Thus, if you have 10 posts, the repeater is going to run 10 times.\n\nIn the demo screen, the repeater contains a paragraph and a button. The paragraph has some JS code to display all the row contents, like this:\n\nAnd the edit button follows the same logic as the add new button. This time you can use this path though:\n\n/edit/{{ Select Table.Value.tablename }}/{{ Repeater.execute.id }}\n\nNow, what happens when you click the add new or edit buttons? Let’s see the logic behind them in the next step.\n\nStep 4 - Edit MySQL data with flexible forms\n\nCreate a new screen, and in its route use /edit/:table/:id. This is how you tell Budibase to create app variables based on the current URL.\n\nThus, when a user visits /edit/posts/3, your app has 2 variables at your disposal:\n\n{{ URL.table }} = posts\n\n{{ URL.id }} = 3\n\nWith this data, you can create flexible edit forms in your MySQL GUI.\n\nThe entire form relies on the fact that new items have ID = 0, and updates have a valid number. With this information, the form understands if you are adding new items or editing them.\n\nThis is the elements tree for that page:\n\nThe first data provider is the Get Item. In it, you run the execute query with this JS binding:\n\nHere you are basically either loading a valid item (if ID > 0) or loading a dummy item (Select 0 as ‘id’). This dummy item is very important. If you don’t add it like this, you will need 2 forms, since this entire component is hidden - given that the main query has no results.\n\nThen you can add a repeater, as usual.\n\nInside it, there’s the delete button, a headline, and the update form.\n\nThe delete button is quite simple. It’s a button with these display conditions:\n\nSo it only shows when you are editing an item. In addition, this button executes three actions when you click on it:\n\nExecute a query:\n\nQuery name: Execute\n\nRequire confirmation: yes\n\nBindings: DELETE FROM {{ URL.table }} WHERE id={{ URL.id }}\n\nUpdate state:\n\nUpdated_rows = 0\n\nNavigate to:\n\n/home\n\nIn other words, it deletes the current item, deletes the udpated_rows state, and goes to the homepage.\n\nThe headline relies on the URL.id to define what text to show. You can use this JS code in it:\n\nThen, the update form has a data provider in it. This data provider loads the table_columns query, using the {{ URL.table }} binding.\n\nNext, you are creating a field for each of these columns. As you saw before, you can create this kind of loop using a repeater.\n\nYou can create a text field, and use these options:\n\nField: {{ Column.table_columns.COLUMN_NAME }}\n\nLabel: {{ Column.table_columns.COLUMN_NAME }}\n\nPlaceholder (JS code):\n\nreturn JSON.stringify($(“Get item.Rows”)[$(“Repeater.Row Index”)][$(“Column.table_columns.COLUMN_NAME”)])\n\nDefault value (JS code):\n\nreturn $(“Get item.Rows”)[$(“Repeater.Row Index”)][$(“Column.table_columns.COLUMN_NAME”)]\n\nThese values create a unique field for each column, and load default data when it exists.\n\nIf you want you can hide the ID column by using configuring conditions of the text field as hide component if {{ Column.Row Index }} equals to 0.\n\nThe entire action of this form is stored on the update button. You can begin by using this JS code in the text field for it:\n\nWith this code your button is going to switch between “add new” and “update”, depending on the item ID.\n\nNext, you can use 3 actions for this button:\n\nUpdate state:\n\nUpdated_rows = 0\n\nExecute query:\n\nQuery name: execute\n\nBinding (JS):\n\nUpdate State:\n\nUpdated_rows = 1\n\nThis JS code checks if it’s an update or insert action and generates the current SQL command for it.\n\nFinally, you can use the updated_rows app state to display a message in case the data-saving actions work. You can do it by creating a container and then using the display condition as show if {{ State.updated_rows }} equals to 1.\n\nStep 5 - Use custom queries in your MySQL GUI\n\nLet’s create a screen to run your own queries, whenever you want to.\n\nHow it works\n\nYou can use three methods to get data into the tables for the custom queries page:\n\nUse the text box.\n\nUse the query builder to generate a SQL command (that is put in the text box).\n\nUse the dropdown to select one of the saved queries.\n\nSo, this is really a two-part logic. First, you need to find a way to execute the commands and display them in a table. And next, you need to find a way to create the query builder to generate some SQL code.\n\nLet’s dive into it.\n\nImplement the custom query page\n\nThe custom query page has this tree structure:\n\nThis is very similar to the home page in the sense that there’s a flexible query, and then you need to output your data somehow. On the homepage, you are using a cards-style layout. On this page it’s a bit different though.\n\nNotice the markdown viewer. That’s where the magic happens.\n\nWith it you can create tables, even if you don’t really know the data structure beforehand.\n\nThat’s because in markup code if you type something like this:\n\nIt turns into a table with a heading (first column, second column), 2 rows with 2 cells in each.\n\nIn addition, you can use more markup code for advanced styling or even links.\n\nBut before we get into that, let’s see how your query is generated.\n\nThere’s a form with a data provider in it. This data provider uses the execute query with a binding for {{ State.query }}.\n\nThis means that whenever you want to run a new query, you just need to edit the app state “query”.\n\nAnd that’s what both of the “run query” buttons do, each saving their own fields (text field or select) into the query app state.\n\nThe query builder button just navigates to /query-builder.\n\nThe save query button has an action to save a row to the saved_queries table, using the {{ Select Table.Fields._sql }} as the query command to be saved.\n\nThe markdown viewer runs this JS code in its text:\n\nIn short, this is what this code does:\n\nGets the table data rows.\n\nInitializes variables to save the table body, header and divisor.\n\nLoops through each row.\n\nAdds a row start character.\n\nLoops through each cell, adding the contents to the table body, and if it’s the first row, adds the header, and divisor to their variables.\n\nMerge headers, divisor, and table body into a single variable.\n\nReturn this variable.\n\nIf you wanted to add an “edit” column, for example, you would just need to add the markup code for it above.\n\nThe only downside of this approach is that the markup table is not full width out of the box. You can fix this by adding an embed element, then use this code in it:\n\nCreate the query builder screen\n\nThe query builder screen is actually a three-step form.\n\nMany of the components of this screen are present on the other screens, but it’s nice to see them in action with a different purpose.\n\nThis is the element tree for that screen:\n\nAnd also:\n\nWhen you add form steps to a form, you can use buttons to navigate between them. That’s what we do here, with the previous and next buttons.\n\nIn the first step, things are quite simple. You just need to add an options picker with custom options for either _selec_t or insert.\n\nYou can add more options later if you want (such as update, delete, joins), but let’s do it this way for this example.\n\nUse a button with the action “Change form step” set to next step.\n\nThen, on step 2, you can use the same table picker that you created on the homepage.\n\nAdd the previous and next buttons, again using “the change form step” actions.\n\nThe third and final step is a bit more complex. In it, there are two different cases.\n\nIf you are using a “select” action, then you use the columns picker, the same way you did on the homepage.\n\nThere’s a paragraph on that page as well to preview the SQL query. For the select action this is the JS code for it:\n\nThen, you can use something very similar on the “save” button. In it, you can use 2 actions:\n\nSave app state: Query_builder\n\nJS code:\n\nNavigate to:\n\n/custom-query\n\nThe select options container has a display condition to be visible if {{ Build Query.Fields.query_type }} is select.\n\nLikewise, the Insert container is set to be visible if {{ Build Query.Fields.query_type }} is insert.\n\nAbout the insert form, it allows you to add the form field values. It works just like the edit form. In it, you get the table columns and use a repeater to generate your form fields.\n\nThe save button for the insert action has the same two actions as the button for the select action. The main difference is that the insert button has this JS code:\n\nThat’s all you need for the query builder. Once it’s saved it generates a query and saves it. Just make sure to use the {{ State.query_builder }} as the default state for the main text field in the custom query page. Thus, where there is a custom query, the text field is pre-populated.\n\nBuild a MySQL GUI with Budibase\n\nToday you learned how you can build a MySQL GUI in just 5 steps. In addition, you saw how you can build apps to interact with databases in many different ways. From a simple autogenerated CRUD interface to complex forms and lists to insert and read data coming from multiple tables.\n\nYou might also like to check out our ultimate guide to building database GUIs .\n\nWe hope you’ve enjoyed it, and see you again next time!"
    }
}