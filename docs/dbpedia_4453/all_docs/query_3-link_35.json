{
    "id": "dbpedia_4453_3",
    "rank": 35,
    "data": {
        "url": "https://www.wahoo.com/rat/docs/rat.js.html",
        "read_more_link": "",
        "language": "en",
        "title": "JSDoc: Source: rat.js",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "ï»¿/** * @license * * Rat Game Engine * * Copyright 2013-2017 Wahoo Studios, Inc. and Steven H. Taylor. * * See the Rat home page for release versions and license information: * http://www.wahoo.com/rat/ * */ //----------------------------------------------------------------------------------------------------------- // r_base // // The base module has the bare minimum to start loading rat. // Most of the rest of rat is in other modules. // // Unfortunately, this r_base module is a lot of stuff shoved together. // We wanted to reference just one boot rat module in an html file and have all the other modules load as needed, // but we ended up needing a lot of base functionality to load and debug correctly, so this got complicated. // We could switch to a code-building system (like typescript?), but so far we've avoided that. // /** Set up a bunch of core rat elements that we need to start everything else up */ // WinJS support if (typeof (WinJS) !== \"undefined\") window.WinJS.Binding.optimizeBindingReferences = true; /** Define the core RAT engine object @export @namespace */ var rat = rat || {}; rat.loaded = false; // Is rat loaded yet? /** Get the global app Rat uses this method to get the global app objects (if it exists) in some rare cases. Internally, rat uses this to pass the app object to code module load functions, in case it's needed, but I suspect nobody uses this. */ rat.getGlobalApp = function () { if (typeof (app) !== \"undefined\") return app; return void 0; }; /** rat.console (debugging, logging, etc.) this is the bare minimum rat.console support in r_base. The rest is defined in r_console @namespace */ rat.console = { output: [], saveOutputToLocalStorage: false, // Save all log entries to local storage copyToSystem: true, logRemotely: false, remoteURL: false, maxLogLines: 150, onceRecord: {}, lastText: \"\", repeat: 0, logNewlines: function(text) { if( !text ) return; text = text.toString(); var strings = text.split( \"\\n\" ); var count = strings.length; // suppress trailing blank lines, e.g. if the string ended in a \\n and we just got a trailing \"\" while (strings[count-1] === \"\") count--; for( var index = 0; index < count; ++index ) { rat.console.log( strings[index] ); } }, // log text log: function (text) { var rconsole = rat.console; var out = rconsole.output; if (text === rconsole.lastText) { rconsole.repeat = rconsole.repeat + 1; out[out.length - 1] = \"|(X\" + rconsole.repeat + \") \" + rconsole.lastText; } else { rconsole.lastText = text; rconsole.repeat = 1; out.push('| ' + text); if (out.length > rconsole.maxLogLines) out.splice(0, 1); // kill oldest } if( rat.console.saveOutputToLocalStorage && rat.system.has.localStorage ) rat.system.getLocalStorage().setItem(\"RAT_LOG\", JSON.stringify(out)); // copy to standard output? if (rconsole.copyToSystem) { var data = '|' + text; console.log('|' + text); if( rat.system.has.xboxLE || rat.system.has.xbox ) Debug.writeln(data); } // send to a remote server? if (rconsole.logRemotely && rconsole.remoteURL) { var xmlhttp = new XMLHttpRequest(); //xmlhttp.onreadystatechange=function(){}; xmlhttp.open(\"GET\", rconsole.remoteURL + text, true); xmlhttp.send(); } } }; /** initial rat.system object, e.g. platform capabilities @namespace */ rat.system = { has: {}, // system supported feature list onPlatform: \"\", // What platform are we on. applyCacheBuster: false // When loading, include a cache buster. }; rat.events = { queued: {} }; /** detect platform and capabilities this accesses variables to determine if they exist, but this throws warnings in JSLint. @suppress {undefinedVars | missingProperties} - Don't warn about the Windows variable or the XboxJS variable */ rat.detectPlatform = function () { if (rat.detectPlatform.detected) return; rat.detectPlatform.detected = true; rat.console.log(\"rat detecting platform...\"); rat.system.has.pointer = true; // assume this for starters. This means mouse or finger. if (typeof Windows !== 'undefined' && typeof winJS !== 'undefined') { rat.system.has.windows8 = true; rat.system.has.winJS = true; //var isWinJS = !!window.Windows && /^ms-appx:/.test(location.href); if (window.Windows.Xbox !== void 0) { rat.system.has.xbox = true; rat.system.has.pointer = false; // sure, it could be Kinect, but we don't support that at all right now. } else { rat.system.has.realWindows8 = true; } // Note: Detecting Windows 8.1 (vs. windows 8.0) at runtime is evidently nontrivial. // If you build a win8.0 app, everybody reports everything the same as 8.0 even if you're actually hosted in 8.1. } else if (typeof XboxJS !== 'undefined') { rat.system.has.xboxLE = true; rat.system.has.pointer = false; // should be true when we support Kinect } // Are we running in wraith? if (typeof Wraith !== 'undefined' && Wraith && Wraith.w_isNative) { rat.system.has.Wraith = true; rat.system.onPlatform = Wraith.w_onPlatform; } // browser/navigator/host stuff var nav = navigator; // Detect support for the gamepad API // Reference: http://www.html5rocks.com/en/tutorials/doodles/gamepad/ rat.system.has.gamepadAPI = !!nav.getGamepads || !!nav.gamepads || !!nav.mozGetGamepads || !!nav.mozGamepads || !!nav.webkitGetGamepads || !!nav.webkitGamepads; if (rat.system.has.gamepadAPI && rat.system.has.xboxLE) rat.system.has.gamepadAPI = false; // Does our host support the event driven gamepad API? Note that Wraith does not. rat.system.has.gamepadAPIEvent = rat.system.has.gamepadAPI && (navigator.userAgent.indexOf('Firefox/') !== -1) && !rat.system.has.Wraith; //rat.console.log(\"Gamepad API Support: \" + rat.system.has.gamepadAPI + \" gamepadAPIEvents:\" + rat.system.has.gamepadAPIEvent); // iOS Browser if (nav && (nav.userAgent.search(\"iPad\") >= 0 || nav.userAgent.search(\"iPod\") >= 0 || nav.userAgent.search(\"iPhone\") >= 0)) rat.system.has.iOSBrowser = true; else rat.system.has.iOSBrowser = false; // PS4 Browser if (nav && (nav.userAgent.search(\"PlayStation 4\") >= 0)) rat.system.has.PS4Browser = true; else rat.system.has.PS4Browser = false; // Chrome browser if (nav && (nav.userAgent.search(\"Chrome\") >= 0)) { rat.system.has.chromeBrowser = true; var raw = navigator.userAgent.match(/Chrom(e|ium)\\/([0-9]+)\\./); rat.system.has.chromeVersion = raw ? parseInt(raw[2], 10) : 0; } else rat.system.has.chromeBrowser = false; // IE browser // see http://www.useragentstring.com/pages/Internet%20Explorer/ if (nav && ((nav.userAgent.search(\"MSIE\") >= 0) || (nav.userAgent.search(\"Edge\") >= 0)) ) { rat.system.has.IEBrowser = true; // todo: convert edge/* to version // (see chrome version check above) if (nav && (nav.userAgent.search(\"Edge/12\")) >= 0) rat.system.has.IEVersion = 12; else if (nav && (nav.userAgent.search(\"like Gecko\") >= 0)) rat.system.has.IEVersion = 11; else if (nav && (nav.userAgent.search(\"MSIE 10\") >= 0)) rat.system.has.IEVersion = 10; else if (nav && (nav.userAgent.search(\"MSIE 9\") >= 0)) rat.system.has.IEVersion = 9; else rat.system.has.IEVersion = 0; // unknown } else rat.system.has.IEBrowser = false; if (nav && nav.userAgent.indexOf('Firefox/') !== -1) rat.system.has.firefoxBrowser = true; else rat.system.has.firefoxBrowser = false; if (nav && nav.userAgent.indexOf('Gecko/') !== -1) // a more generic form of firefox rat.system.has.geckoBrowser = true; else rat.system.has.geckoBrowser = false; if (typeof(chrome) !== \"undefined\" && chrome.app && chrome.app.runtime) { // note: there's some interesting stuff in chrome.runtime, like chrome.runtime.PlatformOs rat.system.has.chromeApp = true; } // CPU class stuff if (nav && nav.cpuClass) // ARM, x64, others.. rat.system.has.cpuClass = nav.cpuClass; else rat.system.has.cpuClass = 'unknown'; // Library detection if (typeof(QUnit) !== \"undefined\" ) { rat.system.has.QUnit = true; rat.system.has.unitTest = true; } // hosting environment - electron (which will also report chrome stuff above) rat.system.has.electron = !!(window.process && window.process.versions && window.process.versions['electron']); rat.system.has.electronVersion = rat.system.has.electron ? (window.process.versions['electron']) : 0; // local storage detection. // Attempting to access the global variable window.localStorage in the Edge Browser, // at least in file:// mode, will throw an exception. So, let's deal with that once, here. // In general, everyone should be using rat.storage objects, // but that system itself and a few other systems (like the rat console) want to access localStorage directly, // so let's set up this check now. // This should be the only place we ever try to access window.localStorage (or localStorage as a global) var storage; try { storage = window.localStorage; } catch (exception) { storage = null; } if (storage) { rat.system.has.localStorage = true; rat.system.localStorageObject = storage; } else { rat.system.has.localStorage = false; rat.system.localStorageObject = null; } }; rat.system.getLocalStorage = function () {return rat.system.localStorageObject;}; /** Parse the URL to get standard argument vars out */ (function(rat) { //only if we actually have window.location. This is to avoid errors in Wraith where window.location is undefined if (window.location){ var loc = window.location.href; // don't include extra stuff in base URL var extraIndex = loc.indexOf(\"?\"); if (extraIndex > 0) rat.system.baseURL = loc.slice(0, extraIndex); else rat.system.baseURL = loc; // Pull values out of the URL rat.system.URLVars = {}; loc.replace(/[?&]+([^=&]+)=([^&]*)/gi, function(m,key,value) { rat.system.URLVars[key] = value; //returns parts }); } })(rat); /** For assets (e.g. images) that are pulled from an external server we may need to fully qualify our path before sending out the request. This is also a very useful bottleneck function for cachebusting, fixing xbox LE paths, and applying other global asset path overrides for our own convenience. @suppress {missingProperties} */ rat.system.fixPath = function (urlPath) { // don't do anything if the path was already empty to begin with if (urlPath.length === 0) return urlPath; var isProperAddress = urlPath.search(/^http/) > -1; // we want to exclude any requests that are already properly formed // project is running a landing experience, prepend with the base URL and randomness to break up caching var newPath = urlPath; if( !isProperAddress ) { // Here are a bunch of path modifications that rat supports: // project is running from a subfolder, e.g. for the intelXDK to keep crap out of top level. if (rat.system.rootFolder) { newPath = rat.system.rootFolder + newPath; if (rat.utils.cleanPath) newPath = rat.utils.cleanPath(newPath); } // check for rat itself being in an alternate path (separate from everything else) if (rat.system.ratAltFolder && newPath.substring(0,4) === \"rat/\") newPath = rat.system.ratAltFolder + newPath.substring(4); // rootSubFolder is just a boolean flag that says go up one directory if (rat.system.rootSubFolder) newPath = \"../\" + newPath; // cache buster support (append random number so host caching is avoided, and newest version of file is always loaded) if (rat.system.has.xboxLE || rat.system.applyCacheBuster) newPath = newPath + \"?_=\" + Math.random(); // in real LE environment, load from correct hosted path if (rat.system.has.xboxLE) newPath = window.adParams._projectBase + newPath; } return newPath; }; /** We need to add this event right now so we can detect when the app is activated */ if (window.WinJS !== void 0) { var activation; if (window.Windows && window.Windows.ApplicationModel) var activation = window.Windows.ApplicationModel.Activation; if (!activation) activation = {}; if (!activation.ActivationKind) activation.ActivationKind = {}; if (!activation.ApplicationExecutionState) activation.ApplicationExecutionState = {}; window.WinJS.Application.onactivated = function (event) { var eventArgs = {}; // see https://msdn.microsoft.com/en-us/library/ie/windows.applicationmodel.activation.activationkind switch (event.detail.kind) { case activation.ActivationKind.launch: eventArgs.kind = \"launched\"; break; case activation.ActivationKind.search: eventArgs.kind = \"searchWith\"; break; case activation.ActivationKind.shareTarget: eventArgs.kind = \"shareTarget\"; break; // Launched via file association case activation.ActivationKind.file: eventArgs.kind = \"file\"; break; case activation.ActivationKind.protocol: eventArgs.kind = \"protocol\"; break; case activation.ActivationKind.fileOpenPicker: eventArgs.kind = \"fileOpenPicker\"; break; case activation.ActivationKind.fileSavePicker: eventArgs.kind = \"fileSavePicker\"; break; case activation.ActivationKind.cachedFileUpdater: eventArgs.kind = \"cachedFileUpdater\"; break; case activation.ActivationKind.ContactPicker: eventArgs.kind = \"contactPicker\"; break; case activation.ActivationKind.device: eventArgs.kind = \"autoplay\"; break; case activation.ActivationKind.printTaskSettings: eventArgs.kind = \"print\"; break; case activation.ActivationKind.cameraSettings: eventArgs.kind = \"camera\"; break; case activation.ActivationKind.restrictedLaunch: eventArgs.kind = \"launched-restricted\"; break; case activation.ActivationKind.appointmentsProvider: eventArgs.kind = \"appointmentsProvider\"; break; case activation.ActivationKind.Contact: eventArgs.kind = \"contact\"; break; case activation.ActivationKind.lockScreenCall: eventArgs.kind = \"launch-locked\"; break; default: eventArgs.kind = \"unknown\"; break; } // The previous app state // https://msdn.microsoft.com/en-us/library/ie/windows.applicationmodel.activation.applicationexecutionstate switch (event.detail.previousExecutionState) { case activation.ApplicationExecutionState.notRunning: eventArgs.prevState = \"notRunning\"; break; case activation.ApplicationExecutionState.running: eventArgs.prevState = \"running\"; break; case activation.ApplicationExecutionState.suspended: eventArgs.prevState = \"suspended\"; break; // Terminated after a suspend. case activation.ApplicationExecutionState.terminated: eventArgs.prevState = \"terminated\"; break; // Closed by the user case activation.ApplicationExecutionState.closedByUser: eventArgs.prevState = \"closed\"; break; default: eventArgs.prevState = \"unknown\"; break; } // Get the session data if there is any eventArgs.sessionState = (window.WinJS.Application.sessionState || {})[\"savedState\"]; // win8 version of starting up - do this after WinJS.UI.processAll has been called // for one thing, this lets us access any weird win8 specific UI // for another it means the above code has been run, which lets us access session data. event.setPromise(window.WinJS.UI.processAll().then(function () { // Queue up the activate event to be fired to the first listener // Also queue a resume from terminate event if we were terminated // Have we loaded the events module rat.events.queued[\"activated\"] = [\"activated\", eventArgs]; if (eventArgs.prevState === \"terminated\") rat.events.queued[\"resumeFromTerminated\"] = [\"resumeFromTerminated\", eventArgs]; })); }; window.WinJS.Application.start(); } // If we don't have WinJS, always queue the activated event else { rat.events.queued[\"activated\"] = [\"activated\", { kind: \"launched\", prevState: \"notRunning\", sessionState: void 0 }]; } /** Provides requestAnimationFrame/cancelAnimationFrame in a cross-browser way. */ window.requestAnimationFrame = window.requestAnimationFrame || window.webkitRequestAnimationFrame || window.mozRequestAnimationFrame || window.oRequestAnimationFrame || window.msRequestAnimationFrame || function ( /* function FrameRequestCallback */ callback, /* DOMElement Element */ element) { return window.setTimeout(callback, 1000 / 60); }; window.cancelAnimationFrame = window.cancelAnimationFrame || window.webkitCancelAnimationFrame || window.mozCancelAnimationFrame || window.oCancelAnimationFrame || window.msCancelAnimationFrame || clearTimeout; // The params of cancelAnimationFrame and clearTimeout match, so I don't need a wrapper around this function /** Util functions necessary for loading rat @namespace */ rat.utils = { // List of all JS files that are either queued to load, loading, or loaded // Key is full file path // value is either \"pending\", \"downloading\", \"loaded\" or \"error\" // Pending is we are going to call loadScriptWithCallback // Downloading is loadScriptWithCallback has been called.. File is downloading. // Loaded is file is downloaded // Error is a failure loadedScripts: { length: 0 }, }; (function (rat) { /** Format an exception for output to the log */ rat.utils.dumpException = function (msg, e) { if (!e) rat.console.log(\"Unable to dump undefined exception\"); else { rat.console.log(\"=======================================================\"); rat.console.log(\"ERROR! \" + msg ); rat.console.log(\"-> Got Exception \" + e.name + \"(\" + (e.number || \"???\") + \")\"); rat.console.log(\"-> \" + e.description || e.message); if (e.stack && typeof(e.stack) === \"string\") rat.console.log(\"-> \" + e.stack); delete e.message; delete e.description; delete e.name; delete e.number; var fullText = JSON.stringify(e); var lines = fullText.split(\"\\\\n\"); for (var index = 0; index < lines.length; ++index) { rat.console.log(\"->\" + lines[index]); } } }; /** Load in a list of resources (JS, JSON, XML(Not yet supported)), with a callback when they are all completed @param {?} options */ rat.utils.loadResources = function (list, callback, options) { var resourceList = list; if (!Array.isArray(resourceList)) resourceList = [resourceList]; options = options || {}; if (options.async === void 0) options.async = true; var updateCB = options.update; var totalLoads = resourceList.length; var loadsLeft = resourceList.length; // Fix the types in the list var index; var len; for (index = 0, len = resourceList.length; index !== len; ++index) { // Entries in the resourceList may be raw strings.. change them to objects if (typeof (resourceList[index]) === 'string') resourceList[index] = { source: resourceList[index] }; resourceList[index].loaded = false; } if (updateCB) updateCB({ left: totalLoads, loaded: 0, of: totalLoads }); if (loadsLeft <= 0) { if (callback) callback(); return; } /** Callback used by loadResource defined in this function so it can access the variables like loadsLeft */ function resourceLoadDone(obj, data) { if (obj) { if (obj.loaded) return; obj.loaded = true; if (obj.callback) obj.callback(data); } --loadsLeft; //rat.console.log(\"...loaded \" + obj.source + \". Loads left:\" + loadsLeft); if (updateCB) updateCB({ left: loadsLeft, loaded: (totalLoads - loadsLeft), of: totalLoads }); if (loadsLeft <= 0 && callback) callback(); } var entry; for (index = 0, len = resourceList.length; index !== len; ++index) { // Entries in the resourceList may be raw strings.. change them to objects entry = resourceList[index]; // If the objects type is not set, get it from the resource ext. if (entry.type === void 0) { var dotAt = entry.source.lastIndexOf(\".\"); if (dotAt === -1) entry.type = \"UNKNOWN\"; else entry.type = entry.source.substr(dotAt + 1).toUpperCase(); } if (entry.type === \"JS\" && !rat.utils.loadedScripts[entry.source]) { rat.utils.loadedScripts[entry.source] = \"pending\"; ++rat.utils.loadedScripts.length; } } for (index = 0, len = resourceList.length; index !== len; ++index) { entry = resourceList[index]; // Process based on type // rat.console.log( \"...loading \" + entry.source + \"...\" ); switch (entry.type) { // Load Javascript case 'JS': // All JS loads need to go through loadScriptWithCallback rat.utils.loadScriptWithCallback(entry.source, !!options.async, resourceLoadDone.bind(void 0, entry)); break; // Load JSON case 'JSON': if (!options.async) rat.console.log(\"ERROR! Unable to load JSON files synchronously\"); else rat.utils.loadJSON(entry.source, resourceLoadDone.bind(void 0, entry)); break; default: rat.console.log(\"WARNING! Attempting to load unrecognized resource \" + entry.source); resourceLoadDone(entry, void 0); break; } } }; /** Load in a series of files (or file sets) in a synchronous manner. This will load one set and then the next. This differs from rat.utils.loadResources in that each file (or file set) is downloaded and processed one at a time @param {Object=} options */ rat.utils.loadResourcesSync = function (list, callback, options) { if (typeof (list) === \"string\") list = [list]; list = list || []; var onIndex = -1; // What index of item are we on. options = options || {}; function loadNextList() { ++onIndex; if (options.update) { // How to stop this load process var abort = options.update({ index: onIndex, list: list, startAgain: loadNextList }); if (abort) return; } // When to stop. if (onIndex >= list.length) { if (callback) callback(); return; } var entry = list[onIndex]; if (options.verbose) rat.console.log(\"Sync load of list item \" + onIndex + \":\" + JSON.stringify(entry)); rat.utils.loadResources(entry, loadNextList, { async: false }); } loadNextList(); }; /** load one script with this callback (generally, you want to use loadResources() above) @param {?} errorCallback */ rat.utils.loadScriptWithCallback = function (filename, async, completeCallback, errorCallback) { // Report of we ever try to re-load a scripts if (rat.utils.loadedScripts[filename] !== void 0 && rat.utils.loadedScripts[filename] !== \"pending\") { rat.console.log(\"WARNING: File \" + filename + \" is getting loaded twice!\"); filename += Math.random(); } if (!rat.utils.loadedScripts[filename]) ++rat.utils.loadedScripts.length; rat.utils.loadedScripts[filename] = \"downloading\"; //rat.console.log(\"load script with callback \" + filename + \", \" + async); // Fix the path var src = rat.system.fixPath(filename); // When we are done, call this function loadDone(obj) { //rat.console.log( \"Script file \" + filename + \" loaded.\" ); // Is this is load event or did we get a ready-state change to complete. if (obj && (obj.type === \"load\" || obj.readyState === \"complete\")) { //rat.console.log( \"Script file \" + filename + \" state \" + obj.type + \" has cb \" + (!!completeCallback)); rat.utils.loadedScripts[filename] = \"loaded\"; if (completeCallback) completeCallback(filename); } } // console.log(\"starting wraith load for \" + filename); // Load in the script (Using wraith if we can) if (rat.system.has.Wraith) { //rat.console.log( \"Loading script \" + src + \" with wraith:\" + (async ? \"Async\" : \"Sync\") ); Wraith.LoadScript({ src: src, async: async, complete: loadDone, }); } else { //rat.console.log( \"Loading script \" + src + \" with DOM:\" + (async ? \"Async\" : \"Sync\") ); // Create a new script tag var script = document.createElement('script'); // Set it up script.async = async || false; script.type = \"text/javascript\"; script.onreadystateChange = loadDone; script.onload = loadDone; script.onerror = function () { rat.utils.loadedScripts[filename] = \"error\"; rat.console.log(\"Failed to load file \" + src); if (errorCallback) errorCallback(filename); }; script.src = src; // Add it to the document var docHead = document.getElementsByTagName('head')[0]; docHead.appendChild(script); //rat.console.log( \"Added script tag for \" + src ); } }; // Load in the QUnit testing framework. rat.utils.loadQUnit = function(onDone) { function continueIfDone() { if( !haveCSS || !haveJS ) return; var canvas = document.getElementsByTagName(\"canvas\")[0]; //canvas.style.postion = \"absolute\"; var body = document.getElementsByTagName(\"body\")[0]; body.style.overflow = \"visible\"; function createDiv(id){ var div = document.createElement(\"div\"); div.id = id; //div.style.position = \"absolute\"; body.insertBefore( div, canvas ); } createDiv( \"qunit\" ); createDiv( \"qunit-fixture\" ); onDone(); } var haveCSS = false, haveJS = false; // Load the QUnit JS file rat.utils.loadScriptWithCallback( \"http://code.jquery.com/qunit/qunit-1.20.0.js\", true, function(){ haveJS = true; continueIfDone(); }); // Load the QUnit CSS file var fileref=document.createElement(\"link\"); fileref.setAttribute(\"rel\", \"stylesheet\"); fileref.setAttribute(\"type\", \"text/css\"); fileref.onload = function() { haveCSS = true; continueIfDone(); }; fileref.setAttribute(\"href\", \"http://code.jquery.com/qunit/qunit-1.20.0.css\"); document.getElementsByTagName(\"head\")[0].appendChild(fileref); }; })(rat); /** rat.load (module management) */ (function (rat) { /** @namespace */ rat.modules = {}; // Rats full modules list rat.modules.byName = {}; // Key is module name rat.modules.length = 0; rat.modules.pending = []; // Array version of any of the above that we have not yet processed /** */ rat.modules.moduleFileLookup = {}; rat.modules.moduleRequiresList = {}; rat.modules.addModulesToFileLookup = function (obj) { for (var name in obj) { if (obj.hasOwnProperty(name)) { if (rat.modules.moduleFileLookup[name] && rat.modules.moduleFileLookup[name] !== obj[name]) rat.console.log(\"Module name \" + name + \" duplicated. in file lookup for \" + rat.modules.moduleFileLookup[name] + \"/\" + obj[name]); else rat.modules.moduleFileLookup[name] = obj[name]; } } }; rat.modules.addModulesToRequiresLookup = function (obj) { for (var name in obj) { if (obj.hasOwnProperty(name)) { if (rat.modules.moduleRequiresList[name]) rat.console.log(\"Module name \" + name + \" duplicated. in requires lookup\"); else rat.modules.moduleRequiresList[name] = obj[name]; } } }; /** This is a list of files that need to be loaded in response to modules that have been added */ rat.modules.missingFiles = { list: [], byPath: {} }; // // Convert a module name to a path function moduleNameToPath(module) { module = module.replace(/\\./g, \"/\"); module = module + \".js\"; //module = module.toLowerCase(); return module; } // // Convert a path to a module name. // Used in limited cases. We generally don't want to assume a file has only one module. function pathToModuleName(path) { var dotPos = path.lastIndexOf('.'); if (dotPos > -1) path = path.substring(0, dotPos); path = path.replace(/\\//g, \".\"); //path = path.toLowerCase(); return path; } // // Check a platform requirement // This is done in a flexible way by looking to see if this platform name is set in rat.system.has // rat.modules.checkPlatformDep = function(platform) { if (!platform || !platform.length) return true; else if (platform[0] == \"!\") return rat.system.has[platform.substring(1)] == void 0; else if (rat.system.has[platform]) return true; return false; } // // Add a file that needs to be loaded before we can continue processing function addModuleMissingFiles(module, ops) { var out_fileList = []; var index; var foundFiles; // If this is an array of modules, if (Array.isArray(module)) { for (index = 0; index !== module.length; ++index) { foundFiles = addModuleMissingFiles(module[index], ops); out_fileList = out_fileList.concat(foundFiles); } return out_fileList; } // We only care about the modules name // This is also where we respect platform restructions if (typeof (module) === \"object\") { if (!rat.modules.checkPlatformDep(module.platform)) return []; module = module.name; } // Is this a file and not a module? var file; var isFile = module.substr(-3).toLowerCase() === \".js\"; if (isFile) { // Before we go queueing up this load, let's see if the module is already in our list. var expectedModule = pathToModuleName(module); if (rat.modules.byName[expectedModule]) return []; // fine - let's load that file. file = module; } else { // Does the module already exist? Don't need to load any file if (rat.modules.byName[module]) return []; // If it isn't a file, try to find the file it is in.. file = rat.modules.moduleFileLookup[module]; // If we don't have a lookup for it, then build the file path from the module name if (!file) file = moduleNameToPath(module); } // Is it already a pending load, or already loaded. // We assume that if this is the case, that we don't need to find their dependencies... var lcFile = file.toLowerCase(); if (!rat.modules.missingFiles.byPath[lcFile] && !rat.utils.loadedScripts[file]) { if (!ops || !ops.justGenFileList) { rat.modules.missingFiles.byPath[lcFile] = true; rat.modules.missingFiles.list[rat.modules.missingFiles.list.length] = lcFile; } out_fileList[out_fileList.length] = file; // Now handle getting other files that we know we will need (see moduleRequiresList) var lookup = rat.modules.moduleRequiresList[module]; if (lookup && lookup.length) { foundFiles = addModuleMissingFiles(lookup, ops); out_fileList = out_fileList.concat(foundFiles); } } return file; } // // Get the list of modules required by another module. // NOTE: This is NOT recursive. We only go one level deep // It also takes into account platform restrictions // This can take either a module name, or a moduleOps object // Returned is a list of module names. function getModuleRequires(moduleName, ops) { if (!moduleName) return []; var list; var module = moduleName; ops = ops || {}; if (typeof (moduleName) === \"string\") module = rat.modules.byName[moduleName]; list = module.requires; var out_list = []; // From the full list, build the applicable list for (var index = 0; index !== list.length; ++index) { var entry = list[index]; // is this a platform that we don't care about if (!rat.modules.checkPlatformDep(entry.platform)) continue; if (ops.forFiles || !entry.fileOnly) out_list[out_list.length] = entry.name; } return out_list; } // Modules that rat will ALWAYS load var requiredModules = [ \"rat.os.r_system\", \"rat.os.r_events\", \"rat.debug.r_console\", \"rat.debug.r_trackvalue\", // really needed? \"rat.debug.r_profiler\", // really needed? \"rat.utils.r_utils\", \"rat.math.r_math\", \"rat.math.r_vector\", \"rat.math.r_matrix\", { name: \"rat.test.r_qunit\", platform: \"QUnit\" } ]; // // Register a new rat modules // rat.modules.add = function (name, requires, code) { // Extract param.. We support two different types of calls // Pure param (name, requires, code) // and Named param ({name:\"\", requires:[], code:function(){}}); // @TODO Add an initFunc phase so different systems can register their own init functions var ops, index; if (typeof (name) !== \"object\") { ops = { name: name, requires: requires, code: code }; } else ops = name; // Validation if (!ops.name) { rat.console.log(\"ERROR: Modules must be given a name\"); ops.name = \"_\" + ((Math.random() * 10000) | 0); } // Flag that we still need to execute any affiliated code // NOTE: Even if no code is provided, this will not get set // Until all required modules have loaded ops.hasBeenProcessed = false; // Cleanup the requires list if (!ops.requires) ops.requires = []; else if (!Array.isArray(ops.requires)) ops.requires = [ops.requires]; for (index = 0; index !== ops.requires.length; ++index) { var entry = ops.requires[index]; if (!entry.name) { // Default behavior is file only dependency entry = { name: entry, platform: void 0, processBefore: false, fileOnly: true }; } // If we have the processBefore flag, set fileOnly to be the reverse of the flag if (entry.processBefore !== void 0) entry.fileOnly = !entry.processBefore; // If we done have the processBefore flag, but do have the fileOnly, processBefore is the reverse of fileOnly else if (entry.fileOnly !== void 0) entry.processBefore = !entry.fileOnly; else { entry.fileOnly = true; entry.processBefore = false; } //entry.name = entry.name.toLowerCase(), ops.requires[index] = entry; } // does this module already exist? if (rat.modules.byName[ops.name]) { rat.console.log(\"ERROR: Attempting to re-define module \" + ops.name); return; } // Add the module to the defined list. rat.modules.byName[ops.name] = ops; rat.modules.pending[rat.modules.pending.length] = ops; ++rat.modules.length; // Inc total number of modules // queue any dependent JS files that are not loaded (or getting loaded) var list = getModuleRequires(ops, { forFiles: true }); addModuleMissingFiles(list); // Remove this modules file from the missing files list // We do this to avoid attempting to re-load files that are part of a concatenated file var myFile = moduleNameToPath(ops.name).toLowerCase(); var missingFileIndex = rat.modules.missingFiles.list.indexOf( myFile ); if( missingFileIndex >= 0 ) { rat.modules.missingFiles.list.splice( missingFileIndex, 1 ); delete rat.modules.missingFiles.byPath[myFile]; } }; // // Return if a given module is ready to be processed rat.modules.isReadyToProcess = function (moduleOps, outList) { if (!moduleOps) return false; outList = outList || []; var modules = rat.modules.byName; var module = moduleOps; if (!module) { rat.console.log(\"Testing if undefined module is ready to process\"); return false; } // If we have already processed this module, then the answer is no. if (module.hasBeenProcessed) return false; // test all required modules var list = getModuleRequires(module); for (var index = 0; index !== list.length; ++index) { var depOn = list[index]; depOn = modules[depOn]; if (depOn && depOn.fileOnly) continue; if (!depOn) outList.push({ name: list[index], hasBeenProcessed: false, isMissing: true }); else if (!depOn.hasBeenProcessed) outList.push(depOn); } // Must be all good return outList.length === 0; }; // // Execute all modules in the order specified by their requirements rat.modules.process = function (ops) { ops = ops || {}; var maxToCall = ops.maxToCall || 0; var noError = !!ops.noError; // Keep looping until we have no more pending modules. // NOTE: By the time we reach this code, all required files should be loaded. var pending = rat.modules.pending; while (pending.length > 0) { // Loop back->front because we will be removing items from the list ++rat.modules.process.passes; var index = pending.length - 1; var oldPending = pending.length; while (index >= 0) { // If this module is ready, process it. var module = pending[index]; if (rat.modules.isReadyToProcess(module)) { if (ops.verbose) rat.console.log(\"rat module processing : \" + module.name); // Execute the code if it exists // Pass rat, and if it exists, the app object. if (module.code) { try { module.code(rat, rat.getGlobalApp()); } catch (e) { // ERROR processing the module. // This often means a syntax error in the module code. // To debug this, look at the value of the \"e\" variable rat.utils.dumpException(\"Failed to process module \" + module.name + \".\", e); throw e; } } if (ops.verbose) rat.console.log(\"done with : \" + module.name); // Flag processed module.hasBeenProcessed = true; // Remove from the pending list. pending.splice(index, 1); // We may only want to call so many items per frame // to avoid a large FPS spike // Currently, only wraith does this. if (maxToCall > 0 && pending.length > 0) { --maxToCall; if (maxToCall <= 0) return \"HIT_LIMIT\"; } } // Loop backwards --index; } // If the number of pending modules did not change, we have a problem if (pending.length === oldPending) { if (!noError) { rat.console.log(\"ERROR! BAD REQUIRES TREE! Unable to process \" + pending.length + \" modules. (circular or missing dependencies?)\"); for (index = 0; index !== pending.length; ++index) { rat.console.log(\">\" + pending[index].name); var list = []; rat.modules.isReadyToProcess(pending[index], list); for (var reqIndex = 0; reqIndex !== list.length; ++reqIndex) rat.console.log(\" >\" + list[reqIndex].name + (list[reqIndex].isMissing ? \" MISSING!\" : \"\")); } return \"ERROR\"; } else return \"PENDING\"; } } }; rat.modules.process.passes = 0; // // Load the rat engine by listing the modules that will be used. // Modules are defined by using rat.modules.add (see above) rat.load = function (loadOptions) { loadOptions = loadOptions || {}; rat.console.log(\"rat.load Verbose=\" + !!loadOptions.verbose); rat.load.numLoadPasses = 0; // How many load passes have we done so far var loadLog = function (text) { if (loadOptions.verbose) rat.console.log(text); }; if (loadOptions.async !== void 0 && !loadOptions.async) loadOptions.async = false; else loadOptions.async = true; // loadOptions.update = function // loadOptions.done = function var addAsync = loadOptions.addAsync || []; var addSync = loadOptions.addSync || []; var fileLists = [addAsync, addSync]; // Start by detecting the platform rat.detectPlatform(); // Adjust all of the module lists to the same format for (var fileListIndex = 0; fileListIndex !== fileLists.length; ++fileListIndex) { var singleList = fileLists[fileListIndex]; for (var fileIndex = singleList.length - 1; fileIndex >= 0; --fileIndex) { if (!singleList[fileIndex]) singleList.splice(fileIndex, 1); else if (!singleList[fileIndex].name) singleList[fileIndex] = { name: singleList[fileIndex] }; } } // Find out if we have already loaded the wraith_core file // Note: wraith_core may be loaded in situations where the Wraith engine is not being used. var loadedWraithCore = typeof (Wraith) === \"object\"; // If we are not in wraith, but we want wraith files loaded, then add the required files if (!rat.system.has.Wraith && rat.load.addWraith) { var wraithPath = \"rat/wraithjs/web/\"; if (!loadOptions.skipLoad) { if (!loadedWraithCore) addModuleMissingFiles(wraithPath + \"wraith_core.js\"); addModuleMissingFiles([wraithPath + \"wraith_dom.js\", wraithPath + \"wraith_canvas.js\"]); } } var loadsLeft, loadsDone; var framesOfSameState = 0; var lastFramesState = void 0; var fileLoadDone = false; var fileProcessDone = false; var requestAnimationFrameID; var syncStarted = false, syncDone = false; if (!loadOptions.skipLoad) { // Add rat's required modules addModuleMissingFiles(requiredModules); // Any modules listed in the addAsync get added now addModuleMissingFiles(addAsync); loadLog(\"Initial file pass selected the following \" + rat.modules.missingFiles.list.length + \" files to load:\"); for (var index = 0; index < rat.modules.missingFiles.list.length; ++index) loadLog(\"-->\" + rat.modules.missingFiles.list[index]); } else { // Avoid all other loads. NOT PROCESS calls loadsLeft = 0; loadsDone = 0; fileLoadDone = true; syncStarted = true; syncDone = true; } // Update while loading/processing files function update() { if (rat.load.failed) return; var percent; ++framesOfSameState; // Still loading files if (!fileLoadDone) percent = (loadsDone / rat.utils.loadedScripts.length) * 100; // @TODO The file load may be done, but we may need to do another loading pass for files that we are missing // Done loading files, but still processing else if (!fileProcessDone) { var maxToCall = (rat.system.has.Wraith && loadOptions.async) ? 1 : 0; var processRes = rat.modules.process({ maxToCall: maxToCall, verbose:loadOptions.verbose }); // Max to process per frame if (processRes === \"ERROR\") { rat.load.failed = true; return; } if (rat.modules.pending.length <= 0) { fileProcessDone = true; lastFramesState = void 0; loadLog(\"rat.modules.process finished. Took \" + rat.modules.process.passes + \" passes.\"); } percent = ((rat.modules.length - rat.modules.pending.length) / rat.modules.length) * 100; } // Keep track of the number of frames nothing has changed. if (percent !== lastFramesState) { lastFramesState = percent; framesOfSameState = 0; } // IF we have too many frames with no change, report what we are waiting on if (framesOfSameState >= 6000) // was 60, was way too spewy... { framesOfSameState = 0; if (fileLoadDone) rat.console.log(\"How did we go \\\"idle\\\" while trying to process files?!? Modules left to proccess: \" + rat.modules.pending.length); else { rat.console.log(\"Went \\\"idle\\\" waiting for \" + loadsLeft + \" of \" + rat.utils.loadedScripts.length + \" file(s) to load.\"); for (var file in rat.utils.loadedScripts) { if (rat.utils.loadedScripts[file] === \"pending\" || rat.utils.loadedScripts[file] === \"downloading\") rat.console.log(\"--->\" + file); } } } // Fire the update callback if one was provided if (loadOptions.update) { loadOptions.update({ load: { done: loadsDone, left: loadsLeft, total: rat.utils.loadedScripts.length, isDone: fileLoadDone }, process: { done: rat.modules.length - rat.modules.pending.length, left: rat.modules.pending.length, total: rat.modules.length, isDone: fileProcessDone }, }); } // Are we ready to move onto the sync phase (if we need to)? if (fileLoadDone && fileProcessDone) { // Are we ready to start the sync load pass? if (!syncStarted) { syncStarted = true; if (!addSync.length) syncDone = true; else { loadLog(\"Starting sync load of \" + addSync.length + \" files.\"); var fileList = addModuleMissingFiles(addSync, { justGenFileList: true }); var singleFileLoaded = function (fields) { if (rat.modules.missingFiles.list.length > 0) { if (!singleFileLoaded.paused) { singleFileLoaded.paused = true; rat.console.log(\"Pause sync loading after \" + (fields.index) + \" of \" + fields.list.length + \" files...\"); } else rat.console.log(\"Keep sync loading paused. More missing files...\"); loadMissingFiles(function () { singleFileLoaded(fields); }, { logTag: \"paused sync\" }); return \"abort\"; } else { rat.modules.process({ noError: true }); if (singleFileLoaded.paused) { rat.console.log(\"Resume sync loading \" + (fields.list.length - (fields.index + 1)) + \" of \" + fields.list.length + \" files...\"); singleFileLoaded.paused = false; fields.startAgain(); } return false; } }; singleFileLoaded.paused = false; rat.utils.loadResourcesSync( fileList, function () { syncDone = true; }, { update: singleFileLoaded, verbose: loadOptions.verbose } ); } } // Is everything loaded and processed if (syncDone) { // Make sure that we have no pending modules from the sync block rat.modules.process(); rat.loaded = true; if (requestAnimationFrameID) { window.cancelAnimationFrame(requestAnimationFrameID); requestAnimationFrameID = 0; } if (loadOptions.done) loadOptions.done(rat, rat.getGlobalApp()); } else { if (!requestAnimationFrameID) requestAnimationFrameID = window.requestAnimationFrame(updateFromAnimationFrame); } } else { if (!requestAnimationFrameID) requestAnimationFrameID = window.requestAnimationFrame(updateFromAnimationFrame); } } // This is how our regular update cycle happens in the module loading system function updateFromAnimationFrame() { requestAnimationFrameID = 0; update(); } function loadMissingFiles(doneCB, ops) { ops = ops || {}; ops.logTag = ops.logTag || \"\"; ++rat.load.numLoadPasses; var list = rat.modules.missingFiles.list; rat.modules.missingFiles.list = []; rat.modules.missingFiles.byPath = {}; loadLog( \"WARNING! Another \" + ops.logTag + \" load phase (\" + rat.load.numLoadPasses + \") is needed to get \" + list.length + \" required file(s).\" ); for (var index = 0; index !== list.length; ++index) loadLog(\"-->\" + list[index]); rat.utils.loadResources(list, doneCB, { update: ops.update }); } // Called when a file loading pass is done function loadFinished() { // Once all files have been loaded, check if there are other files that we need to queue if (rat.modules.missingFiles.list.length > 0) { loadMissingFiles(loadFinished, { update: function (fields) { loadsLeft = fields.left; loadsDone = rat.utils.loadedScripts.length - fields.left; update(); } }); } else { loadLog(\"File load finished. \" + rat.modules.pending.length + \" Modules to process.\"); fileLoadDone = true; // If not async, run now. if (!loadOptions.async) update(); } } var fileList = rat.modules.missingFiles.list; rat.modules.missingFiles.list = []; rat.modules.missingFiles.byPath = {}; // Async load path if (!loadOptions.skipLoad) { if (loadOptions.async) { requestAnimationFrameID = window.requestAnimationFrame(updateFromAnimationFrame); loadLog(\"Starting async file load...\"); ++rat.load.numLoadPasses; rat.utils.loadResources(fileList, loadFinished, { update: function (fields) { loadsLeft = fields.left; loadsDone = rat.utils.loadedScripts.length - fields.left; update(); } }); loadLog(\"... Load Started.\"); } // Sync load path else { loadLog(\"Starting synchronous file load...\"); rat.utils.loadResources(fileList, loadFinished, { async: false }); } } else { if (loadOptions.async) requestAnimationFrameID = window.requestAnimationFrame(updateFromAnimationFrame); loadFinished(); } }; /** Sync loading utility wrapper @param {?} doneFunc */ rat.simpleLoad = function (list, doneFunc) { rat.load({ addSync: list, done: doneFunc }); }; rat.simpleload = rat.simpleLoad; // alt name /** Set the entry point for the application @param {Object=} context */ rat.load.setEntryPoint = function (func, context) { if (typeof (Wraith) === \"object\" && Wraith.SetEntryPoint) Wraith.SetEntryPoint(func, context); else { if (context) func = func.bind(context); window.onload = func; } }; // Allow an external function to call our entry point manually if it is needed rat.ExternalEntryPoint = function () { if (window.onload) window.onload(null); //- This NULL is to fix google closure compiler linting errors. }; })(rat); /** Unit testing API */ (function(rat) { // Empty functions for unit testing rat.unitTest= { // Are unit tests enabled. enabled: true, // Create a test group // platform specific code group: function(name, func) {}, // Define an actual test // Platform genric. Specific version is _test test: function(name, code) { // only conintue if we are enabled and have a _test func if( rat.unitTest.enabled && rat.unitTest._test ) rat.unitTest._test(name, code); }, // Utility to have a single test in a group testGroup: function( grpName, testName, testCode ) { rat.unitTest.group( grpName, function(){ rat.unitTest.test( testName, testCode ); }); } }; })(rat); //----------------------------------------------------------------------------------------------------------- // // r_minified // // Used with rat.js so we know that RAT is minified // Actually, this is a bit of a misnomer. This flag means rat is concatenated and loaded in a // single load. We don't know from this flag whether rat is minified, or how minified. // /** * Define that we are using a minified rat */ rat.system.has.minified = true; //-------------------------------------------------------------------------------------------------- // // rat system-level functionality, // like main loop and update handling, system initialization order, // setting up global update/draw/event functions, etc. // // Note that a lot of system-level stuff is implemented in r_base // // @todo move some debug display functions to debug module // rat.modules.add( \"rat.os.r_system\", [ \"rat.graphics.r_graphics\", \"rat.debug.r_console\", \"rat.debug.r_profiler\", \"rat.debug.r_trackvalue\", // consider not depending on this in final releases somehow \"rat.os.r_events\", \"rat.math.r_math\", { name: \"rat.os.r_le_core\", platform: \"xboxLE\" }, // Platform file { name: \"rat.os.r_electron\", platform: \"electron\" } // electron utils ], function(rat) { rat.paused = false; // For Cheats // todo move to \"debug\" subobject, and move to r_debug module // and rename functions and variables = it's confusing how they conflict/contrast rat.system.debugDrawTiming = false; rat.system.debugDrawStats = false; rat.system.debugDrawFramerateGraph = false; rat.system.debugDrawMemoryGraph = false; rat.system.debugFramerateGraphSettings = { bounds: {} }; rat.system.debugDrawConsole = false; rat.system.load = null; rat.system.commandHandler = null; rat.system.hasFocus = true; if (window.hasFocus) rat.system.hasFocus = window.hasFocus(); else if (document.hasFocus) rat.system.hasFocus = document.hasFocus(); rat.preLoadTimer = null; rat.mousePos = {x:-1, y:-1}; // better way to mark whether we've ever actually gotten the mouse position from a move? /** * @param {string=} canvasID optional * @suppress {uselessCode} - rat.system.load may not exist. */ rat.init = function (canvasID, ops) { ops = ops || {}; // For max flexibility and robustness, support rat.init being called more than once, // in which case just exit. if (rat.initialized) { //rat.console.log(\"rat already initialized.\"); return; } if( ops.useProtectedCycle ) { var origCycle = rat.system.cycle; var hitError = false; rat.system.cycle = function() { try { origCycle(); } catch( e ) { if( !hitError ) { hitError = true; rat.console.saveOutputToLocalStorage = true; var errStr = rat.utils.objectToString(e); rat.console.log( \"!!!ERROR!!!\" ); rat.console.logNewlines( errStr ); } } } } useProtectedCycle = !!ops.useProtectedCycle; rat.console.log(\"Initalizing Rat...\"); //rat.console.log(\"rs: \" +rat.system); if(rat.system.load) rat.system.load(); rat.detectPlatform(); // detect platform and capabilities rat.profiler.init(); rat.graphics.init(canvasID, ops.gfxInit); if( rat.particle ) rat.particle.init(); if( rat.audio ) rat.audio.init(); if (rat.clipboard) rat.clipboard.init(); // eventually, call cycle, which will set itself up repeatedly. //setInterval(rat.system.cycle, 1000 / 60); //setTimeout(rat.system.cycle, 1000 / 60); window.requestAnimationFrame(rat.system.cycle); if( rat.input ) { rat.input.init(); rat.input.autoHandleEvents(); } rat.console.registerCommand(\"showMemory\", function (cmd, args) { var on = rat.system.debugDrawMemoryGraph; rat.system.debugDrawMemoryGraph = !on; }, [\"showMemory\", \"memory\"]); rat.initialized = true; }; rat.preLoadImages = function (imageList, postLoadFunction) { rat.postLoadFunction = postLoadFunction; rat.graphics.preLoadImages(imageList); // start the loading process rat.preLoadTimer = setInterval(rat.processPreLoad, 1000 / 60); // check back from time to time }; rat.processPreLoad = function () { if(rat.graphics.isCacheLoaded()) { rat.console.log(\"rat preload done.\"); clearInterval(rat.preLoadTimer); rat.preLoadTimer = null; if(typeof rat.postLoadFunction !== 'undefined') rat.postLoadFunction(); } }; rat.setDraw = function (f) { rat.draw = f; }; rat.setPostUIDraw = function (f) { rat.postUIDraw = f; }; rat.setUpdate = function (f) { rat.update = f; }; // // main engine loop - do all updates and draw everything // rat.system.lastCycleTime = 0; rat.system.cycle = function () { // John: This makes things harder for me when working in chrome - // I want chrome to give me the exception, not rat. :) // We could move all this code into a subroutine and then maybe optionally support a try/catch around it, // based on platform or config or something? //try //{ // begin new frame rat.graphics.beginFrame(); rat.profiler.pushPerfMark(\"Rat.System.Cycle\"); window.requestAnimationFrame(rat.system.cycle); // request next cycle immediately // This is a system for capping framerate. This avoids those super high spikes we get when the system // suddenly gives us an update again very quickly. Is this desirable? I'm not sure. //if (0) //{ // var now = new Date().getTime();//Date().now(); // var elapsed = now - rat.system.lastCycleTime; // var fpsInterval = rat.math.floor(1000/15); // 1000/60 = 60 fps interval // if (elapsed < fpsInterval) // return; // rat.system.lastCycleTime = now;// - (elapsed % fpsInterval); //} // TODO: move the above, and update deltatime into a new rat module, r_timing // split timing loops into update and rendering? // have updateDeltaTime tell us whether we've hit the minimum threshold for processing (to incorporate the above minimum check) // update rat.profiler.pushPerfMark(\"updateDeltaTime\"); rat.system.updateDeltaTime(); rat.profiler.popPerfMark(\"updateDeltaTime\"); if(rat.update) { rat.profiler.pushPerfMark(\"GameUpdate\"); rat.update(rat.deltaTime); rat.profiler.popPerfMark(\"GameUpdate\"); } if( rat.input ) { rat.profiler.pushPerfMark(\"input.update\"); rat.input.update(rat.deltaTime); rat.profiler.popPerfMark(\"input.update\"); } if( rat.ui ) { rat.profiler.pushPerfMark(\"ui.updateAnimators\"); rat.ui.updateAnimators(rat.deltaTime); rat.profiler.popPerfMark(\"ui.updateAnimators\"); } rat.profiler.pushPerfMark(\"updateScreens\"); rat.screenManager.updateScreens(); rat.profiler.popPerfMark(\"updateScreens\"); if (rat.audio.update) rat.audio.update(rat.deltaTime); if(rat.cycleUpdate) { rat.profiler.pushPerfMark(\"cycleupdate\"); rat.cycleUpdate.updateAll(rat.deltaTime); rat.profiler.popPerfMark(\"cycleupdate\"); } if(rat.timerUpdater) { rat.profiler.pushPerfMark(\"timerUpdate\"); rat.timerUpdater.updateAll(rat.deltaTime); rat.profiler.popPerfMark(\"timerUpdate\"); } if (rat.Rumble && rat.Rumble.supported) rat.Rumble.frameUpdate(rat.deltaTime); // draw, starting with global transform if any, and then installed draw routine var ctx = rat.graphics.getContext(); rat.profiler.pushPerfMark(\"Rendering\"); rat.graphics.save(); rat.graphics.setupMatrixForRendering(); if(rat.graphics.autoClearCanvas) { rat.profiler.pushPerfMark(\"Clearing Canvas\"); rat.graphics.clearCanvas(); rat.profiler.popPerfMark(\"Clearing Canvas\"); } if (rat.graphics.canvas.style && rat.graphics.canvas.style.backgroundImage && rat.system.has.Wraith) { rat.graphics.canvas.style.backgroundImage.drawTiled(rat.graphics.canvas.width, rat.graphics.canvas.height); } if (rat.beforeDraw) { rat.profiler.pushPerfMark(\"BEFORE draw\"); rat.beforeDraw(ctx); rat.profiler.popPerfMark(\"BEFORE draw\"); } if(rat.draw) { rat.profiler.pushPerfMark(\"rat.draw\"); rat.draw(ctx); rat.profiler.popPerfMark(\"rat.draw\"); } if( rat.screenManager ) { rat.profiler.pushPerfMark(\"screen draw\"); rat.screenManager.drawScreens(); rat.profiler.popPerfMark(\"screen draw\"); if (rat.postUIDraw) { rat.profiler.pushPerfMark(\"post UI draw\"); rat.postUIDraw(ctx); rat.profiler.popPerfMark(\"post UI draw\"); } } // draw debug display, if it's turned on // We used to do this after scale/translate, so we can be sure to be in the bottom corner... // but that's lame. For one thing, it makes it hard to see on high-res displays! // Also, these variable names are ridiculous, but they're sort of embedded in many apps at this point. // could at least rename the functions... Or deprecate the old names but keep supporting them...? rat.profiler.pushPerfMark(\"Debug Rendering\"); rat.console.drawConsole(); if (rat.trackValue) rat.trackValue.draw(); if(rat.system.debugDrawTiming) rat.system.drawDebugTiming(); if(rat.system.debugDrawStats) rat.system.drawDebugStats(); if (rat.system.debugDrawFramerateGraph) rat.system.drawDebugFramerateGraph(); if (rat.system.debugDrawMemoryGraph) rat.system.drawDebugMemoryGraph(); if(rat.system.debugDrawConsole) rat.console.drawLog(); if (rat.profiler && rat.profiler.displayStats) { rat.profiler.pushPerfMark(\"Profiler draw\"); rat.profiler.displayStats(); rat.profiler.popPerfMark(\"Profiler draw\"); } rat.profiler.popPerfMark(\"Debug Rendering\"); rat.graphics.restore(); // restore after scaling, translating, etc. rat.profiler.popPerfMark(\"Rendering\"); if (rat.afterDraw) { rat.profiler.pushPerfMark(\"After Draw\"); rat.afterDraw(ctx); rat.profiler.popPerfMark(\"After Draw\"); } rat.profiler.popPerfMark(\"Rat.System.Cycle\"); rat.graphics.endFrame(); //} //catch (err) //{ // rat.console.log( \"EXCEPTION: \" + err.toString() ); //} }; // timing globals - move this stuff to rat namespace rat.deltaTimeRaw = 1 / 60.0; // deltatime. see calculation near framerate update rat.deltaTimeRawSmoothed = rat.deltaTimeRaw; rat.deltaTimeMod = 1; // a way to modify deltatime and speed things up rat.deltaTimeUnsmoothed = rat.deltaTime; rat.deltaTime = rat.deltaTimeRaw; rat.runningFpsUnsmoothed = 1 / rat.deltaTimeUnsmoothed; rat.runningFps = 1 / rat.deltaTime; rat.runningTime = 0; function getDeltaTimeStamp() { if (rat.system.has.Wraith) return 0; else if (window.performance) return window.performance.now()/1000; else return new Date().getTime()/1000; } var lastTimeStamp = getDeltaTimeStamp(); // This array is used to generate the smoothed deltaTimeRaw var gDeltaTimeRawSmoother = []; rat.SMOOTHING_SAMPLE_SIZE = 25; var gSmootherIndex = 0; // These arrays are used by the FPS Debug graph var gDeltaTimeRawRecord = []; var gDeltaTimeRawSmoothedRecord = []; var FPS_RECORD_SIZE = 100; rat.system.FPS_RECORD_SIZE = FPS_RECORD_SIZE; var gFPSRecordIndex = 0; // update deltatime calculation var gHighDeltaTime; // The highest delta time over the last amount of time. This means the slowest FPS var gHighFor = 0;// How long as the high delta time been the hi rat.system.updateDeltaTime = function () { // Things break down with a delta time mode <= 0 if (rat.deltaTimeMod <= 0) rat.deltaTimeMod = 0.0000000001; var now; // Get the rat.deltaTimeRaw // a bunch of timing stuff, both for debug display and for deltatime (DT) calculations // todo: use higher precision timing. if (rat.system.has.Wraith) rat.deltaTimeRaw = Wraith.getDeltaTime(); else { now = getDeltaTimeStamp(); rat.deltaTimeRaw = now - lastTimeStamp; lastTimeStamp = now; } // Force? if (rat.paused) rat.deltaTimeRaw = 0; // artificial limit of dt for systems running so slowly that an accurate dt would be ridiculous. if (rat.deltaTimeRaw > 0.1 && !rat.paused) // 10fps rat.deltaTimeRaw = 0.1; // Include the deltaTimeMod in rat.deltaTime rat.deltaTimeUnsmoothed = rat.deltaTimeRaw * rat.deltaTimeMod; // Get the raw FPS rat.runningFpsUnsmoothed = 1 / rat.deltaTimeUnsmoothed; // Figure out the smoothed deltaTime // this controls how quickly average frame rate matches immediate frame rate. 1 = just use current frame. 5 = average out over 5 frames. // The value was 5 for a long time. I'm just not sure that's right. var totalTimeRaw = 0; gDeltaTimeRawSmoother[gSmootherIndex] = rat.deltaTimeRaw; gSmootherIndex = (gSmootherIndex + 1) % rat.SMOOTHING_SAMPLE_SIZE; var recordSize = gDeltaTimeRawSmoother.length < rat.SMOOTHING_SAMPLE_SIZE ? gDeltaTimeRawSmoother.length : rat.SMOOTHING_SAMPLE_SIZE; for (var index = 0; index !== recordSize; ++index) totalTimeRaw += gDeltaTimeRawSmoother[index]; rat.deltaTimeRawSmoothed = totalTimeRaw / recordSize; rat.deltaTime = rat.deltaTimeRawSmoothed * rat.deltaTimeMod; rat.runningFps = 1 / rat.deltaTime; gDeltaTimeRawRecord[gFPSRecordIndex] = rat.deltaTimeRaw; gDeltaTimeRawSmoothedRecord[gFPSRecordIndex] = rat.deltaTimeRawSmoothed; gFPSRecordIndex = (gFPSRecordIndex + 1) % FPS_RECORD_SIZE; rat.runningTime += rat.deltaTimeRaw; if (gHighDeltaTime === void 0 || (gHighFor += rat.deltaTimeRaw) > 2.0 || gHighDeltaTime < rat.deltaTimeRaw) { gHighDeltaTime = rat.deltaTimeRaw; gHighFor = 0; } }; // draw some debug timing info (framerate info) rat.system.drawDebugTiming = function () { //var dispFps = rat.math.floor(rat.runningFps * 10)/10; var dispFps = rat.math.floor(rat.runningFps); var dispDT = rat.math.floor(rat.deltaTime * 1000) / 1000; var ctx = rat.graphics.getContext(); ctx.fillStyle = \"#F08030\"; var fontSize = rat.math.floor(12 * 1/rat.graphics.globalScale.x); ctx.font = \"bold \" + fontSize + \"px monospace\"; var yPos = rat.graphics.SCREEN_HEIGHT - fontSize; ctx.fillText(\"fps: \" + dispFps + \" DT: \" + dispDT, 30, yPos); }; // draw debug stats - particle counts, for instance // TODO: use offscreen for this and only update when it changes? // fillText is slow and affects the performance we're trying to measure. :( // I'm hesitant to introduce a dependency here from rat.system to rat.ui or rat.offscreen // do we already have a ui dependency? rat.system.drawDebugStats = function () { var atX = 30; var ctx = rat.graphics.getContext(); ctx.fillStyle = \"#F08030\"; var fontSize = rat.math.floor(12 * 1/rat.graphics.globalScale.x); ctx.font = \"bold \" + fontSize + \"px monospace\"; var yShift = fontSize; var yPos = rat.graphics.SCREEN_HEIGHT - 3 * fontSize; // particle stats if( rat.particle ) { var totalSystems = rat.particle.getSystemCount(); var totalEmitters = rat.particle.getAllEmitterCount(); var totalParticles = rat.particle.getAllParticleCount(); var totalCachedStates = rat.particle.State.cacheSize; var totalParticleStateObjects = rat.particle.State.count; // Particle system stats. if(rat.particle.stateCaching.enabled) { ctx.fillText(\" states(cached): \" + totalParticleStateObjects + \"(\" + totalCachedStates + \")\", atX, yPos); yPos -= yShift; } ctx.fillText(\"P: sys: \" + totalSystems + \" em: \" + totalEmitters + \" p: \" + totalParticles, atX, yPos); yPos -= yShift; } // UI stats if (rat.graphics && rat.graphics.frameStats && rat.ui ) { ctx.fillText(\"UI: elem: \" + rat.graphics.frameStats.totalElementsDrawn + \", mcalls \" + rat.ui.mouseMoveCallCount + \", ucalls \" + rat.ui.updateCallCount, atX, yPos); yPos -= yShift; } // image draw calls if (rat.graphics && rat.graphics.Image && rat.graphics.Image.perFrameDrawCount ) { ctx.fillText(\"Images: \" + rat.graphics.Image.perFrameDrawCount, atX, yPos); yPos -= yShift; } // track XUI element render stats, if xui system is even supported if (rat.xuijs) { var total = 0; for( var key in rat.xuijs.XuiElementsDrawnThisFrame) { total += rat.xuijs.XuiElementsDrawnThisFrame[key]; var skippedText = ( (rat.xuijs.XuiElementsSkippedThisFrame[key]) ? \" (/\" + rat.xuijs.XuiElementsSkippedThisFrame[key] + \")\" : \"\"); ctx.fillText( \" \"+ key +\": \" + rat.xuijs.XuiElementsDrawnThisFrame[key] + skippedText , atX, yPos ); yPos -= yShift; } ctx.fillText( \"XUI Elem: \" + total, atX, yPos ); yPos -= yShift; rat.xuijs.XuiElementsDrawnThisFrame = {}; rat.xuijs.XuiElementsSkippedThisFrame = {}; } }; // show debug memory graph (if we can) rat.system.drawDebugMemoryGraph = function () { if( !rat.system.debugMemoryGraphSettings) rat.system.debugMemoryGraphSettings = {bounds:{}, history:[]}; var settings = rat.system.debugMemoryGraphSettings; var ctx = rat.graphics.getContext(); var space = {width : rat.graphics.SCREEN_WIDTH, height : rat.graphics.SCREEN_HEIGHT}; if( !settings.bounds || !settings.bounds.x ) { settings.bounds = {}; settings.bounds.w = space.width/4; settings.bounds.h = space.height/8; settings.bounds.x = space.width * 0.90 - settings.bounds.w; settings.bounds.y = (space.height * 0.95 - (settings.bounds.h * 2))-16; } var bounds = settings.bounds; ctx.save(); ctx.fillStyle = \"white\"; ctx.translate(bounds.x, bounds.y); var fontSize = rat.math.floor(12 * 1/rat.graphics.globalScale.x); ctx.font = \"bold \" + fontSize + \"px monospace\"; // the marks var x, y; for( var markIndex = 0; markIndex < 3; ++markIndex ) { ctx.lineWidth = 1; ctx.strokeStyle = ([\"red\", \"yellow\", \"blue\"])[markIndex]; ctx.beginPath(); y = (markIndex/2) * bounds.h; ctx.moveTo(0, y); ctx.lineTo(bounds.w, y); ctx.stroke(); } // We need two records to draw. if( !window.performance || !window.performance.memory ) { ctx.textAlign = \"start\"; ctx.textBaseline = \"hanging\"; ctx.fillText(\"Memory unavailable.\", 0, bounds.h+1); } else { var ttl = window.performance.memory.totalJSHeapSize || 1; var used= window.performance.memory.usedJSHeapSize || 0; var percent = (used/ttl)*100; settings.history.push( used ); if( settings.history.length > rat.system.FPS_RECORD_SIZE ) settings.history.shift(); ctx.textAlign = \"start\"; ctx.textBaseline = \"hanging\"; ctx.fillText(\"Memory: \" + percent.toFixed(2) + \"% of \" + (ttl / 1024 / 1024).toFixed(2) + \"MB\", 0, bounds.h+1); ctx.strokeStyle = \"green\"; ctx.save(); ctx.beginPath(); for( var index = 0; index < settings.history.length && index < rat.system.FPS_RECORD_SIZE; ++index ) { var visualIndex = index; if( settings.history.length < rat.system.FPS_RECORD_SIZE ) visualIndex += (rat.system.FPS_RECORD_SIZE -settings.history.length); var record = settings.history[index]; var x = bounds.w * (visualIndex/(rat.system.FPS_RECORD_SIZE-1)); var y = bounds.h * (1.0-(record/ttl)); if( index == 0 ) ctx.moveTo( x, y ); else ctx.lineTo( x, y ); } ctx.stroke(); ctx.restore(); } ctx.restore(); }; // show debug frame rate graph rat.system.drawDebugFramerateGraph = function () { // We need two records to draw. var recordCount = gDeltaTimeRawRecord.length; if (recordCount <= 1) return; var ctx = rat.graphics.getContext(); //var canvas = rat.graphics.canvas; var space = {width : rat.graphics.SCREEN_WIDTH, height : rat.graphics.SCREEN_HEIGHT}; var graph = rat.system.debugFramerateGraphSettings; // STT changed this 2015.3.3 // It had the problem that it was only getting set the first time, so if screen resized, it wasn't updating, so it ended up in lame placs. // But I want to respect the idea of having defined settings or not. // So, now we check if there were any settings and recalculate local values ourselves each frame instead of setting the globals. // Another approach would be to copy whatever is set in debugFramerateGraphSettings and just fill in what's missing each frame. // Also note that if some project is actually using debugFramerateGraphSettings, they'd better be adapting to resizes! :) if (!graph || !graph.bounds || !graph.bounds.x) { graph = {bounds:{}}; // make a new local temp settings object graph.bounds.w = space.width/4; graph.bounds.h = space.height/8; graph.bounds.x = space.width * 0.90 - graph.bounds.w; graph.bounds.y = space.height * 0.95 - graph.bounds.h; } ctx.translate(graph.bounds.x, graph.bounds.y); // the marks ctx.lineWidth = 1; ctx.strokeStyle = \"#F02040\"; ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(graph.bounds.w, 0); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, graph.bounds.h / 2); ctx.lineTo(graph.bounds.w, graph.bounds.h / 2); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, graph.bounds.h); ctx.lineTo(graph.bounds.w, graph.bounds.h); ctx.stroke(); // What is the top mark var topMark = 120; // 120 fps function drawChart(vals, startIndex) { ctx.beginPath(); var point = { x: 0, y: 0 }; var len = vals.length; var xShift = graph.bounds.w / (FPS_RECORD_SIZE-1); var p; for (var index = 0; index !== len; ++index) { p = vals[(index + startIndex) % len]; p = (1 / p) / topMark; point.y = graph.bounds.h - (p * graph.bounds.h); if (index === 0) ctx.moveTo(point.x, point.y); else ctx.lineTo(point.x, point.y); point.x += xShift; } ctx.stroke(); } ctx.lineWidth = 2; // Draw profile markers if we are using rat.profiler and have some var p; if (rat.profiler.perfmarkers.length > 0) { ctx.save(); var list = rat.profiler.perfmarkers; // What is the current frame var curFrame = rat.graphics.frameIndex; var marker; var tx; for (var index = 0; index !== list.length; ++index) { marker = list[index]; p = 1-((curFrame - marker.frame) / FPS_RECORD_SIZE); ctx.strokeStyle = marker.color; ctx.beginPath(); tx = graph.bounds.w * p; ctx.moveTo(tx, 0); ctx.lineTo(tx, graph.bounds.h); ctx.stroke(); } ctx.restore(); } // Draw the FPS records // Second - raw ctx.strokeStyle = \"#808000\"; drawChart(gDeltaTimeRawRecord, gFPSRecordIndex); // Draw the FPS records // First - smoothed ctx.strokeStyle = \"#8080FF\"; drawChart(gDeltaTimeRawSmoothedRecord, gFPSRecordIndex); // FPS text // Scale this up to be legible by default in high res. var fontSize = rat.math.floor(12 * 1/rat.graphics.globalScale.x); var dispFps = ((rat.runningFps*100)|0)/100; var dispDT = ((rat.deltaTime * 1000) | 0) / 1000; var lowFPS = 1/gHighDeltaTime; ctx.fillStyle = \"#F0F0F0\"; ctx.font = \"bold \" + fontSize + \"px monospace\"; ctx.textBaseline = \"hanging\"; ctx.TextAlign = \"left\"; dispFps = \"\" + dispFps.toFixed(2); dispDT = \"\" + dispDT.toFixed(3); lowFPS = \"\" + lowFPS.toFixed(2); var padder = \" \"; dispFps = padder.substr(0, padder.length - dispFps.length) + dispFps; dispDT = padder.substr(0, padder.length - dispDT.length) + dispDT; ctx.fillText(\"fps: \" + dispFps + \" (low \"+ lowFPS+\") DT: \" + dispDT, 0, graph.bounds.h); ctx.translate(-graph.bounds.x, -graph.bounds.y); }; // // send a rat/game command down the screen stack. // This lets any screen step in and handle the command. // todo: merge with the above functions // rat.dispatchCommand = function (command, info) { // first see if any screen in the stack is going to handle this. // this is for popups, for example. if( rat.screenManager ) { for(var i = rat.screenManager.screenStack.length - 1; i >= 0; i--) { var screen = rat.screenManager.screenStack[i]; if(typeof screen.handleCommand !== 'undefined') { var handled = screen.handleCommand(command, info); // note that the screen might have popped itself, but the way we're handling this in reverse order is OK. if(handled) return; } } } // then hand to whatever registered command handler there is. if(rat.system.commandHandler) rat.system.commandHandler(command, info); }; rat.system.exit = function() { // note: LE case overridden in LE module if (rat.system.has.Wraith) { if (window.close) window.close(); } else { // can't close in a browser. rat.console.log( \">>>>APP REQUESTED CLOSE, but we are just a poor browser and don't know how.<<<<\" ); } // all other systems do nothing for now }; rat.system.reloadLocation = function(forceGet) { // note: LE case overridden in LE module if (forceGet === void 0) forceGet = true; if (rat.system.has.windows8 || rat.system.has.xbox) { // todo: some specific implementation here? } else { document.location.reload(forceGet); } }; rat.system.assignLocation = function(newURL) { // note: LE case overridden in LE module // todo: different target system compatibility // todo: what is \"url\" here? a relative path from where we started? A fully qualified path including protocol? // consider these variables for usefulness: // var url = location.protocol + '//' + location.host + location.pathname; { document.location.assign(newURL); } }; /** * util to use the proper event handling for IE and other browsers * @param {boolean=} capture optional */ rat.addOSEventListener = function (element, event, func, capture) { if (element && element.addEventListener) return element.addEventListener(event, func, !!capture); else if (element && element.attachEvent) return element.attachEvent(event, func); else if (typeof (window) !== 'undefined' && window.addEventListener) return window.addEventListener(event, func, !!capture); }; /** * util to remove the proper event handling for IE and other browsers * @param {boolean=} capture optional * * If an event listener retains any data (such as inside a closure), use this * function to remove that data reference. Called with the same parameters as * rat.addOSEventListener that added it. */ rat.removeOSEventListener = function (element, event, func, capture) { if (element.removeEventListener) element.removeEventListener(event, func, !!capture); else if (element.detachEvent) element.detachEvent(event, func); else if (typeof window !== 'undefined' && window.removeEventListener) window.removeEventListener(event, func, !!capture); }; /** * add key event listener, and standardize some values in event * @param {boolean=} capture optional */ rat.addOSKeyEventListener = function (element, event, func, capture) { rat.addOSEventListener(element, event, function (e) { if( rat.input ) rat.input.standardizeKeyEvent(e); func(e); }, capture); }; /** Handle event dispatches for error, suspend and resume as fired by WinJS apps */ // Fire on any error // A global error handler that will catch any errors that are not caught and handled by your application's code. // Ideally the user should never hit this function because you have gracefully handled the error before it has // had a chance to bubble up to this point. In case the error gets this far, the function below will display an // error dialog informing the user that an error has occurred. function onError(event) { rat.console.log(\"JS ERROR! \" + JSON.stringify(event)); if (rat.events && rat.events.fire) rat.events.fire(\"error\", { sysEvent: event }); var errorDialog = new window.Windows.UI.Popups.MessageDialog( event.detail.errorUrl + \"\\n\\tLine:\\t\" + event.detail.errorLine + \"\\tCharacter:\\t\" + event.detail.errorCharacter + \"\\nMessage: \" + (event.detail.message || event.detail.errorMessage), (event.type === \"error\") ? \"Unhanded Error!\" : event.type); errorDialog.cancelCommandIndex = 0; errorDialog.defaultCommandIndex = 0; errorDialog.showAsync(); return true; } // Fired when we are resumed from a suspend. function onResume(event) { var args = { sysEvent: event }; if (rat.events && rat.events.fire) rat.events.fire(\"resume\", args); // How did we get a resume before we finished loading in rat... } // Fired when the app is going to be suspended function onSuspend(event) { var sysEvent = event; // Cannot leave this as a param or it isn't available to our sub-functions // If we have async stuff to do... var busyCount = 0; var promise; function setBusy() { ++busyCount; if (busyCount === 1 && rat.system.has.winJS) { sysEvent.setPromise( new window.WinJS.Promise(function (completeDispatch, errorDispatch, progressDispatch) { promise = completeDispatch; }) ); } } // Set that we are done with our work. function setDone() { if (busyCount <= 0) return; --busyCount; if (busyCount === 0 && promise) promise(\"Done\"); } // Set what to save with the suspend. var sessionData = {}; function storeData(data) { sessionData = data; } // Start busy. setBusy(); // Firing the event out into the world. var args = { store: storeData, setBusy: setBusy, setDone: setDone, sysEvent: sysEvent }; if (rat.events && rat.events.fire) rat.events.fire(\"suspend\", args); // Save any data set if (rat.system.has.winJS) window.WinJS.Application.sessionState[\"savedState\"] = sessionData; // And we are done working in this file... Note that we may still be pending elsewhere. setDone(); } var hasSuspendResume = false; if (rat.detectPlatform.detected) hasSuspendResume = rat.system.has.winJS; else hasSuspendResume = !!window.Windows; /** TODO Wraith will need to fire similar (or the same) events if we event ship a JS app running in wraith under Windows 8 or as an XboxOne app */ if (hasSuspendResume && window.WinJS) { /** [JSH 1/20/2015] most of this is copied and modified from what was found in agent. */ window.WinJS.Application.onerror = onError; window.WinJS.Application.oncheckpoint = onSuspend; window.Windows.UI.WebUI.WebUIApplication.addEventListener(\"resuming\", onResume, false); } // Support visibility detection. // See http://stackoverflow.com/questions/1060008/is-there-a-way-to-detect-if-a-browser-window-is-not-currently-active (function() { var hidden = \"hidden\"; function onchange (evt) { var v = \"visible\", h = \"hidden\", evtMap = { focus:v, focusin:v, pageshow:v, blur:h, focusout:h, pagehide:h }; evt = evt || window.event; var result; if (evt.type in evtMap) result = evtMap[evt.type]; else result = this[hidden] ? \"hidden\" : \"visible\"; if (result && rat.events && rat.events.fire) rat.events.fire(\"visibility\", result); } // Standards: if (hidden in document) document.addEventListener(\"visibilitychange\", onchange); else if ((hidden = \"mozHidden\") in document) document.addEventListener(\"mozvisibilitychange\", onchange); else if ((hidden = \"webkitHidden\") in document) document.addEventListener(\"webkitvisibilitychange\", onchange); else if ((hidden = \"msHidden\") in document) document.addEventListener(\"msvisibilitychange\", onchange); // IE 9 and lower: else if (\"onfocusin\" in document) document.onfocusin = document.onfocusout = onchange; // All others: else window.onpageshow = window.onpagehide = window.onfocus = window.onblur = onchange; // set the initial state (but only if browser supports the Page Visibility API) // this doesn't currently work because rat.events doesn't exist yet. // I'm not anxious to make this module dependent on that one. //if( document[hidden] !== undefined ) // onchange({type: document[hidden] ? \"blur\" : \"focus\"}); })(); /** Handle focus/blur events so we can now if the app is in focus */ rat.addOSEventListener( window, \"focus\", function () { if (!rat.system.hasFocus) { //rat.console.log(\"App has focus\"); rat.system.hasFocus = true; if (rat.events && rat.events.fire) rat.events.fire(\"focus\"); } }); rat.addOSEventListener(window, \"blur\", function () { if (rat.system.hasFocus) { //rat.console.log(\"App does NOT have focus\"); rat.system.hasFocus = false; if (rat.events && rat.events.fire) rat.events.fire(\"blur\"); } }); }); //-------------------------------------------------------------------------------------------------- // // A general os event registration and dispatch system // This lets us register and remove registration for events without worrying about // what callbacks were already registered. // We also do some queueing of some events and report them as soon as a listener is registered. // // rat.modules.add( \"rat.os.r_events\", [ ], function(rat) { rat.events = rat.events || {}; rat.events.registered = {}; // key is event name. value is an array rat.events.firing = {}; // if we are firing an event, hold the data that will allow safe removal of events. rat.events.queued = rat.events.queued || {}; /** Register a new event listener */ rat.addEventListener = function( event, func, ctx ) { if( !func ) return; rat.events.registered[event] = rat.events.registered[event] || []; var listeners = rat.events.registered[event]; listeners.push({ func: func, ctx: ctx }); // Some special handling for events that where queued until we got a listener if( rat.events.queued[event] ) { rat.events.fire.apply( rat.events, rat.events.queued[event] ); // queued is an array. Inlcudes the name of the event. rat.events.queued[event] = void 0; } }; /** UnRegister an event listener */ rat.removeEventListener = function( event, func, ctx ) { if( !func ) return false; var listeners = rat.events.registered[event]; if( !listeners ) return false; // Search var firing = rat.events.firing[event]; var listener; for( var index = 0; index !== listeners.length; ++index ) { listener = listeners[index]; if( listener.func === func && listener.ctx === ctx ) { // Make sure that any events that we are already firing are ok if( firing ) { if( firing.index <= index ) --firing.index; --firing.stopAt; } // Remove the event. listeners.splice( index, 1 ); return true; } } // Not found return false; }; // Queue an event until we have added a listener rat.events.queueEvent = function (event /*,[arg, arg, ...]*/) { var fireArgs = Array.prototype.slice.call(arguments); var listeners = rat.events.registered[event]; if (listeners && listeners.length) rat.events.fire.apply(rat.events, fireArgs); else rat.events.queued[event] = fireArgs; }; // Fire an event rat.events.fire = function (event /*,[arg, arg, ...]*/) { //rat.console.log(\"rat firing event \" + event); var listeners = rat.events.registered[event]; if( !listeners || listeners.length === 0 ) return false; var args = Array.prototype.slice.call(arguments, 1); var savedFiring = rat.events.firing[event]; // We use this object so we can safely remove objects while iterating over an array rat.events.firing[event] = { index: 0, stopAt: listeners.length }; var firing = rat.events.firing[event]; var listener, func, ctx; for( ; firing.index !== firing.stopAt; ++firing.index ) { listener = listeners[firing.index]; func = listener.func; ctx = listener.ctx; func.apply( ctx, args ); /** TODO Add some system where we can stop any more events from firing.. */ } rat.events.firing[event] = savedFiring; }; }); //-------------------------------------------------------------------------------------------------- // // rat console // // This is a custom interactive console system, independent of any host console system. // This is really nice for a few reasons... // * we can customize it like crazy and add simple custom commands // (including game-specific commands) that do whatever we want. // * it works at runtime in-game on systems without console debugging or even debug output // (like game-console browsers, among others). // * it's pretty easy to use // * it has nice features like remembering history across sessions // * it has extra functionality for filtering and processing debug output // * more... // // This console tries hard not to depend on other parts of rat, // because it needs to function even if rat hasn't been entirely set up, // e.g. in order to help debug rat setup issues... // // todo: move some of these debug utils to r_debug module maybe? // console namespace rat.modules.add( \"rat.debug.r_console\", [ \"rat.os.r_system\", \"rat.math.r_math\", \"rat.graphics.r_graphics\", \"rat.utils.r_utils\", \"rat.input.r_input\", ], function(rat) { rat.console.config = { bounds : {x:48, y:0, w:{fromParent:true, val:-(48*2)}, h:{percent:true, val:0.5}}, textColor : \"#90B090\", textSize : 12, logLineHeight : 14, // should be similar to text size bgColor : \"rgba(0,0,0,0.5)\", }; rat.console.configChanged = {}; // see writeConfig below - a hash of explicitly changed properties for saving/loading rat.console.state = { consoleAllowed: false, consoleActive: false, cursorPos: 0, pulseTimer: 0, currentCommand: \"\", // Registered commands nextCommandID: 0, // The next ID to provide to a registered command commandList: [], // The list of available commands commandHistory: [], // History of entered commands commandHistoryIndex: -1, // What history item am i accessing (up/down) -1 is im not commandHistoryMax: 100, // Remember up to 100 commands // For auto-complete autoComplete: [], // List of currently built auto-completion options accessingAutoComplete: -1, // where are we in the auto-completion list logOffset: 0, // How to shift the log display consoleKey: '/', // What key to use to open the console // what modifiers to hold for consoleKey above to kick in. // this helps in environments where / is being used by something else! // by default, no modifiers! consoleAltKey : false, consoleCtrlKey : false, consoleShiftKey : false, }; var state = rat.console.state; var storageCmdHistoryKey = \"rat_commandHistory\"; var storageConsoleConfigKey = \"rat_consoleConfig\"; // Load the command history from local storage if it is there // As with other console features, this is fairly low-level code, directly accessing localStorage // instead of using the rat storage object, since we need the console to be up and running before other modules. var storage = rat.system.getLocalStorage(); if (storage) { var hist = storage.getItem(storageCmdHistoryKey); if (hist) rat.console.state.commandHistory = JSON.parse(hist); // Load config from local storage if there var scon = storage.getItem(storageConsoleConfigKey); if (scon) { var scon = JSON.parse(scon); // explicitly check for some settings that need to be constructed manually? // assume everything else can be assigned directly, // but do it one element at a time, keeping any defaults not explicitly found in the saved config. for (var key in scon) { if (rat.console.config[key]) { rat.console.config[key] = scon[key]; rat.console.configChanged[key] = true; // remember the user wanted this changed } } } } // // Write out (changed) config properties // // Write only what has changed! We track property names at the top level, whenever the user actively changes something from the console. // Why? Because we don't want to write out permanent user settings for something the game might later decide has a better *default*, // and if the user didn't explicitly change it, let's leave it. // And what I mean by the user changing it is: They actively used the console UI to change something like font size. // You'll notice in the various \"set\" functions here like setBounds and setTextSize, we don't flag changes, // because we know those might be calls from game code setting up defaults. // It's only explicit changes here in the console that we want to save and use to override defaults. // As of 2016.9.20, that means only textSize and logLineHeight get changed 'cause that's all we have controls for. // though it's possible in the console to manually set values and call rat.console.writeConfig by hand from the console. rat.console.writeConfig = function(propNames) { // mark desired properties as changed (support individual prop or list of props) if (!Array.isArray(propNames)) propNames = [propNames]; for (var i = 0; i < propNames.length; i++) rat.console.configChanged[propNames[i]] = true; // now try to save out if (rat.system.localStorageObject) { var config = {}; for (var key in rat.console.configChanged) { config[key] = rat.console.config[key]; // OK to be a reference - we'll throw away our local config object below } rat.system.localStorageObject.setItem(storageConsoleConfigKey, JSON.stringify(config)); } }; // clear out config entirely rat.console.clearConfig = function() { if (rat.system.localStorageObject) rat.system.localStorageObject.removeItem(storageConsoleConfigKey); rat.console.configChanged = {}; // expect user to refresh or something at this point to reload defaults }; rat.console.setBounds = function(x, y, w, h) { rat.console.config.bounds.x = x; rat.console.config.bounds.y = y; // ignored, currently rat.console.config.bounds.w = w; // ignored, currently rat.console.config.bounds.h = h; // ignored, currently }; rat.console.setTextSize = function(size, lineHeight) { rat.console.config.textSize = size; if (!lineHeight) lineHeight = Math.floor(size * 1.1); // autocalculate to be 20% bigger than text height rat.console.config.logLineHeight = lineHeight; }; // Utility for resetting auto-complete function resetAutoComplete() { state.autoComplete = []; state.accessingAutoComplete = -1; } // Utility function to handle setting the current command function setCurCommand(cmd, resetHistory, resetAutocomplete) { state.currentCommand = cmd; state.cursorPos = rat.math.min( rat.math.max(0, state.cursorPos), state.currentCommand.length); if (resetHistory) state.commandHistoryIndex = -1; if (resetAutocomplete) resetAutoComplete(); } function getGlobalVar(name) { // for now, use rat.utils.get. // This has some weaknesses. Maybe change this one day? // I'm a little concerned about security if we start using eval(). return rat.utils.get(this, name); } // Build the auto-complete list function buildAutocomplete(cmd) { // Start with an empty list. state.autoComplete = []; // The commands must START with cmd to fit. var upperCmd = cmd.toUpperCase(); var commandCount = state.commandList.length; for (var commandIndex = 0; commandIndex !== commandCount; ++commandIndex) { // Is this the matching command // If the command matches, do NOT put its aliases in the list var curCmd = state.commandList[commandIndex]; if (curCmd.name.slice(0, upperCmd.length) === upperCmd ) { state.autoComplete.push(curCmd.name); continue; } // Check its aliases var aliasCount = curCmd.alias.length; for (var aliasIndex = 0; aliasIndex !== aliasCount; ++aliasIndex) { if (curCmd.alias[aliasIndex].slice(0, upperCmd.length) === upperCmd ) state.autoComplete.push(curCmd.alias[aliasIndex]); } } // IF we found nothing, maybe we are entering javascript.. Variable name completion if (state.autoComplete.length <= 0) { // Find the leading variable name... // Do this by finding the last '.' var fullVarNameEndsAt = cmd.lastIndexOf('.'); if (fullVarNameEndsAt > 1)// We MUST find something (app or rat or some other global) { var fullVarName = cmd.substring(0, fullVarNameEndsAt); var mustStartWith = cmd.substring(fullVarNameEndsAt + 1); //if( mustStartWith ) // rat.console.log(\"Auto complete for variables in '\" + fullVarName + \"' starting with '\" + mustStartWith + \"'\"); //else // rat.console.log(\"Auto complete for variables in '\" + fullVarName + \"'\"); // get the variable var variable = getGlobalVar(fullVarName); if (variable !== void 0) { for (var key in variable) { if( key ) { if( mustStartWith ) { var startsWith = key.substring(0, mustStartWith.length); if (startsWith !== mustStartWith) continue; } state.autoComplete.push(fullVarName + \".\" + key); } } } } } // Alphabetical order state.autoComplete.sort(); state.accessingAutoComplete = 0; } // Allow the console rat.console.allow = function (allow) { if (allow === void 0) allow = true; rat.console.state.consoleAllowed = !!allow; }; // Activate the console (make it visible!) // Normally this is not needed, because the console is activated with user input. // But on some systems, e.g. phone or console, we sometimes want the console to be showing // right away. So, this function will activate directly. rat.console.activate = function (doActivate) { if (doActivate === void 0) doActivate = true; rat.console.state.consoleActive = !!doActivate; }; // Log this (type of) output once, recording that we've logged it, // so we can suppress future messages of that type. rat.console.logOnce = function (text, name, count) { if (!name) // if name not specified, use full text message to identify it name = text; if (!count) // optional count (to allow this message more than once, but still limited) count = 1; if (!rat.console.onceRecord[name]) rat.console.onceRecord[name] = 0; rat.console.onceRecord[name]++; if (rat.console.onceRecord[name] <= count) { rat.console.log(text); } }; // Draw the console rat.console.drawConsole = function () { // Bail if we are either not allowed or not active. if (!rat.console.state.consoleAllowed || !rat.console.state.consoleActive) return; // Draw at the bounds set. // This includes drawing the log and any input that we have // Find out what the bounds mean var bounds = rat.console.config.bounds; if (rat.ui && rat.ui.data && rat.ui.data.calcBounds) { var ratBounds = { x: 0, y: 0, w: rat.graphics.SCREEN_WIDTH, h: rat.graphics.SCREEN_HEIGHT }; bounds = rat.ui.data.calcBounds({ bounds: bounds }, ratBounds); } // Draw the BG rat.graphics.drawRect( bounds, { fill: true, color: rat.console.config.bgColor }); rat.graphics.drawRect( bounds, { color: rat.console.config.bgColor, lineWidth:2 }); // Draw the log var logBounds = rat.utils.copyObject( bounds ); logBounds.h -= (rat.console.config.logLineHeight + 10); rat.console.drawLog(logBounds); // Draw the line between the log and the input logBounds.y = logBounds.h; logBounds.h = bounds.h - logBounds.h; rat.graphics.drawRect(logBounds, { color: rat.console.config.bgColor, lineWidth: 2 }); // Draw the running time logBounds.x += 4; logBounds.y += 4; var time = rat.runningTime || 0; var hours = (time/60/60)|0; time -= hours * 60 * 60; var minutes = (time/60)|0; time -= minutes * 60; var seconds = time|0; var timeText = \"\" + hours + \":\" + minutes + \":\" + seconds; var width = rat.graphics.ctx.measureText(timeText); if (width.width !== void 0) width = width.width; rat.graphics.drawText(timeText, logBounds.x + logBounds.w - width - 8, logBounds.y); // Draw the current console text rat.graphics.drawText(\"> \" + state.currentCommand, logBounds.x, logBounds.y); // Draw the cursor state.pulseTimer += rat.deltaTime; if (state.pulseTimer > 0.6) state.pulseTimer = 0; if (state.pulseTimer < 0.3) { var subCmd = state.currentCommand.slice(0, state.cursorPos); width = rat.graphics.ctx.measureText(\"> \" + subCmd); width = width.width || width; logBounds.x += width; rat.graphics.ctx.fillStyle = \"white\"; rat.graphics.ctx.font = \" bold\" + rat.graphics.ctx.font; rat.graphics.drawText(\"|\", logBounds.x, logBounds.y ); } }; // display log lines of text /** @param {Object=} bounds */ rat.console.drawLog = function (bounds) { bounds = bounds || rat.console.config.bounds; var out = rat.console.output; var ctx = rat.graphics.ctx; var logLineHeight = rat.console.config.logLineHeight; // make a copy of my bounds so I can mess with it, if it's not set up. var myBounds = {x:bounds.x, y:bounds.y, w:bounds.w, h:bounds.h}; if (myBounds.w < 0) myBounds.w = rat.graphics.SCREEN_WIDTH - myBounds.x - 10; if (myBounds.h < 0) myBounds.h = rat.graphics.SCREEN_HEIGHT - myBounds.y - 10; ctx.font = '' + rat.console.config.textSize + 'px Arial'; ctx.textAlign = 'left'; ctx.fillStyle = rat.console.config.textColor;//\"#B0FFA0\"; // start high enough so that our last line is at the bottom. var yPos = myBounds.h - 0 - logLineHeight * out.length; var bottom = myBounds.h + myBounds.y; yPos += (rat.console.state.logOffset-1) * logLineHeight; ctx.textBaseline = \"top\";//\"bottom\"; for (var i = 0; i < out.length; i++) { if( (yPos + logLineHeight) > myBounds.y ) ctx.fillText(out[i], myBounds.x, yPos, myBounds.w); yPos += logLineHeight; if( (yPos + logLineHeight) >= bottom && rat.console.state.logOffset > 0 ) { ctx.fillText(\"...\", myBounds.x, yPos, myBounds.w); yPos += logLineHeight; } if( yPos >= bottom ) break; } //ctx.strokeStyle = \"#FFFFFF\"; //ctx.strokeRect(myBounds.x, myBounds.y, myBounds.w, myBounds.h); }; // Get events rat.console.handleEvent = function (ratEvent) { if (ratEvent.eventType !== \"keydown\" && ratEvent.eventType !== \"keypress\") return false; if (ratEvent.eventType === \"keydown\") { // Don't eat F12 - we want to be able to toggle browser debug window, still. // (but what about other events like F5 and F8 - are those already getting allowed somehow?) if (ratEvent.which === rat.keys.f12) return false; // console key (if it's unmodified!) will toggle console activity. // Escape key will only make console inactive. if (( ratEvent.which === rat.keys[state.consoleKey] && (ratEvent.sysEvent.altKey === state.consoleAltKey && ratEvent.sysEvent.ctrlKey === state.consoleCtrlKey && ratEvent.sysEvent.shiftKey === state.consoleShiftKey)) || (ratEvent.which === rat.keys.esc && rat.console.state.consoleActive) ) { rat.console.state.consoleActive = !rat.console.state.consoleActive; return true; } // Not active means not handled. if (!rat.console.state.consoleActive) return false; else ratEvent.allowBrowserDefault = true; // Run the cmd. if (ratEvent.which === rat.keys.enter) { ratEvent.sysEvent.preventDefault(); state.currentCommand = state.currentCommand.trim(); if (state.currentCommand && state.commandHistory[state.commandHistory.length] !== state.currentCommand) { state.commandHistory.unshift(state.currentCommand); if (state.commandHistory.length > state.commandHistoryMax) state.commandHistory.pop(); if (rat.system.localStorageObject) rat.system.localStorageObject.setItem(storageCmdHistoryKey, JSON.stringify(state.commandHistory)); } if( state.currentCommand ) rat.console.parseCommand(state.currentCommand.trim()); setCurCommand(\"\", true, true); } // Erase else if (ratEvent.which === rat.keys.backspace) { ratEvent.sysEvent.preventDefault(); if (state.cursorPos > 0) { --state.cursorPos; setCurCommand(state.currentCommand.slice(0, state.cursorPos) + state.currentCommand.slice(state.cursorPos + 1), false, true); } } else if (ratEvent.which === rat.keys.del) { ratEvent.sysEvent.preventDefault(); if (state.cursorPos < state.currentCommand.length) { setCurCommand(state.currentCommand.slice(0, state.cursorPos) + state.currentCommand.slice(state.cursorPos + 1), false, true); } } // font size change (shift + arrow keys) else if (ratEvent.sysEvent.shiftKey && (ratEvent.which === rat.keys.upArrow || ratEvent.which === rat.keys.downArrow)) { var size = rat.console.config.textSize; if (ratEvent.which === rat.keys.upArrow) size += 2; else if (ratEvent.which === rat.keys.downArrow) { size -= 2; if (size < 4) // let's be reasonable size = 4; } rat.console.setTextSize(size); rat.console.writeConfig(['textSize', 'logLineHeight']); // remember what we just changed } // History access else if (ratEvent.which === rat.keys.upArrow || ratEvent.which === rat.keys.downArrow) { ratEvent.sysEvent.preventDefault(); setCurCommand(state.currentCommand.trim(), false, false); if (ratEvent.which === rat.keys.upArrow) ++state.commandHistoryIndex; else --state.commandHistoryIndex; // If we are less then our current, stay at our current if (state.commandHistoryIndex < -1) state.commandHistoryIndex = -1; // Did we try to go up with no history else if (state.commandHistoryIndex === 0 && state.commandHistory.length === 0) setCurCommand(\"\", true, true); // Did we go off the top. else if (state.commandHistoryIndex >= state.commandHistory.length) { state.commandHistoryIndex = state.commandHistory.length - 1; setCurCommand(state.commandHistory[state.commandHistoryIndex], false, false); } // leaving the history else if (state.commandHistoryIndex === -1) { setCurCommand(\"\", false, false); } // We are accessing the history else { setCurCommand(state.commandHistory[state.commandHistoryIndex], false, true); state.cursorPos = state.currentCommand.length; } } // Cursor position change else if (ratEvent.which === rat.keys.leftArrow || ratEvent.which === rat.keys.rightArrow) { ratEvent.sysEvent.preventDefault(); if (ratEvent.which === rat.keys.leftArrow) --state.cursorPos; else ++state.cursorPos; state.cursorPos = rat.math.max(0, state.cursorPos); state.cursorPos = rat.math.min(state.cursorPos, state.currentCommand.length); } else if (ratEvent.which === rat.keys.home) { ratEvent.sysEvent.preventDefault(); state.cursorPos = 0; } else if (ratEvent.which === rat.keys.end) { ratEvent.sysEvent.preventDefault(); state.cursorPos = state.currentCommand.length; } // TAB for auto-completion else if (ratEvent.which === rat.keys.tab) { ratEvent.sysEvent.preventDefault(); // Find the commands that will complete the current. if (state.accessingAutoComplete === -1) { setCurCommand(state.currentCommand.trim(), false, false); buildAutocomplete(state.currentCommand); } // Auto-complete only does something if there is something to change to. if (state.autoComplete.length > 0) { setCurCommand(state.autoComplete[state.accessingAutoComplete], true, false); state.cursorPos = state.currentCommand.length; if (rat.input.keyboard.isKeyDown(rat.keys.shift)) { state.accessingAutoComplete--; if (state.accessingAutoComplete < 0) state.accessingAutoComplete = state.autoComplete.length - 1; } else { state.accessingAutoComplete++; if (state.accessingAutoComplete >= state.autoComplete.length) state.accessingAutoComplete = 0; } } } // PageUp/PageDown to change log offset else if (ratEvent.which === rat.keys.pageUp || ratEvent.which === rat.keys.pageDown ) { ratEvent.sysEvent.preventDefault(); if( ratEvent.which === rat.keys.pageUp ) ++rat.console.state.logOffset; else --rat.console.state.logOffset; if( rat.console.state.logOffset >= rat.console.output.length ) rat.console.state.logOffset = rat.console.output.length-1; if( rat.console.state.logOffset < 0 ) rat.console.state.logOffset = 0; } } else if (ratEvent.eventType === \"keypress\" ) { // Not active means not handled. if (!rat.console.state.consoleActive) return false; var char = ratEvent.sysEvent.char; if (char.charCodeAt(0) < ' '.charCodeAt(0)) return false; if (state.consoleActive && char !== \"\\n\" && char !== \"\\t\" && char !== state.consoleKey) { if (state.cursorPos === state.currentCommand.length) state.currentCommand += char; else if (state.cursorPos === 0) state.currentCommand = char + state.currentCommand; else state.currentCommand = state.currentCommand.slice(0, state.cursorPos) + char + state.currentCommand.slice(state.cursorPos); state.cursorPos++; resetAutoComplete(); } } // otherwise, claim we handled ANY keyboard event, so key events don't go through console and activate game stuff... return true; // Handled }; // Register new commands into the console rat.console.registerCommand = function (name, func, aliasList) { // Init the new cmd var newCmd = {}; newCmd.name = name.toUpperCase(); newCmd.func = func; newCmd.id = state.nextCommandID++; newCmd.alias = aliasList || []; // All commands and alias are uppercase var aliasCount = newCmd.alias.length; for (var aliasIndex = 0; aliasIndex < aliasCount; aliasIndex++) newCmd.alias[aliasIndex] = newCmd.alias[aliasIndex].toUpperCase(); // Add it to the cmd list state.commandList.push(newCmd); return newCmd.id; }; // Unregister a commands from the console rat.console.unregisterCommand = function (id) { // Find the command that goes with this var commandCount = state.commandList.length; for (var commandIndex = 0; commandIndex < commandCount; commandIndex++) { if (state.commandList[commandIndex].id === id) { state.commandList.splice(commandIndex, 1); return true; } } return false; }; // Get a command by its name rat.console.getCommand = function (cmd) { var upperCmd = cmd.toUpperCase(); var count = state.commandList.length; for (var index = 0; index !== count; ++index) { var curCmd = state.commandList[index]; if (curCmd.name === upperCmd) return curCmd; for (var aliasIndex = 0; aliasIndex !== curCmd.alias.length; ++aliasIndex) { if (curCmd.alias[aliasIndex] === upperCmd) return curCmd; } } // Not found return void 0; }; /** * Run the provided command * @returns true if the command successfully parsed */ rat.console.parseCommand = function (cmd) { // Get the command from the args var fullCmd = cmd; var cmdArgs = cmd.split(/\\s/); cmd = cmdArgs[0]; cmdArgs.splice(0, 1); var foundCmd = rat.console.getCommand(cmd); if (foundCmd) { // Call the command foundCmd.func(cmd, cmdArgs); return true; } else { // Is the string a full variable? If so, dump its members or value to the log var gblVar = getGlobalVar(fullCmd); var dumpVar = fullCmd + \" = \"; if (gblVar !== void 0) { switch( typeof(gblVar) ) { case \"object\": { if (gblVar === null) dumpVar += \"NULL\"; else { rat.console.log(\"--------\"); dumpVar += \"OBJECT:\"; rat.console.log(dumpVar); dumpVar = void 0; // Why are we not using something like JSON.stringify here, // or rat.utils.objectToString. Let's do. // by specifying a \"name\" value here (even though it's just \" \") // we get objectToString to bracket it all with {}, which is nice visually. var output = rat.utils.objectToString(gblVar, \" \"); rat.console.logNewlines(output); /* var longestName = 0; var vals = []; var key; for (key in gblVar) { // We skip some things if (key !== \"parentClass\" && key !== \"parentConstructor\" && key !== \"parent"
    }
}