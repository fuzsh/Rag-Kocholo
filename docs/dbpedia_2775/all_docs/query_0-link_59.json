{
    "id": "dbpedia_2775_0",
    "rank": 59,
    "data": {
        "url": "https://valis.readthedocs.io/en/latest/registration.html",
        "read_more_link": "",
        "language": "en",
        "title": "Registration — valis \"1.1.0\" documentation",
        "top_image": "https://github.com/MathOnco/valis/raw/main/docs/_images/valis_logo_black_no_bg.png",
        "meta_img": "",
        "images": [
            "https://github.com/MathOnco/valis/raw/main/docs/_images/valis_logo_black_no_bg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "src_dir: str\n\nPath to directory containing the slides that will be registered.\n\ndst_dirstr\n\nPath to where the results should be saved.\n\nnamestr, optional\n\nDescriptive name of registrar, such as the sample’s name\n\nseriesint, optional\n\nSlide series to that was read. If None, series will be set to 0.\n\nimage_typestr, optional\n\nThe type of image, either “brightfield”, “fluorescence”, or “multi”. If None, VALIS will guess image_type of each image, based on the number of channels and datatype. Will assume that RGB = “brightfield”, otherwise image_type will be set to “fluorescence”.\n\nfeature_detector_clsFeatureDD, optional\n\nUninstantiated FeatureDD object that detects and computes image features. Default is VggFD. The available feature_detectors are found in the feature_detectors module. If a desired feature detector is not available, one can be created by subclassing feature_detectors.FeatureDD.\n\ntransformer_clsscikit-image Transform class, optional\n\nUninstantiated scikit-image transformer used to find transformation matrix that will warp each image to the target image. Default is SimilarityTransform\n\naffine_optimizer_clsAffineOptimzer class, optional\n\nUninstantiated AffineOptimzer that will minimize a cost function to find the optimal affine transformations. If a desired affine optimization is not available, one can be created by subclassing affine_optimizer.AffineOptimizer.\n\nsimilarity_metricstr, optional\n\nMetric used to calculate similarity between images, which is in turn used to build the distance matrix used to sort the images. Can be “n_matches”, or a string to used as distance in spatial.distance.cdist. “n_matches” is the number of matching features between image pairs.\n\nmatch_filter_method: str, optional\n\n“GMS” will use filter_matches_gms() to remove poor matches. This uses the Grid-based Motion Statistics (GMS) or RANSAC.\n\nimgs_orderedbool, optional\n\nBoolean defining whether or not the order of images in img_dir are already in the correct order. If True, then each filename should begin with the number that indicates its position in the z-stack. If False, then the images will be sorted by ordering a feature distance matix. Default is False.\n\nreference_img_fstr, optional\n\nFilename of image that will be treated as the center of the stack. If None, the index of the middle image will be the reference.\n\nalign_to_referencebool, optional\n\nIf False, images will be non-rigidly aligned serially towards the reference image. If True, images will be non-rigidly aligned directly to the reference image. If reference_img_f is None, then the reference image will be the one in the middle of the stack.\n\nnon_rigid_registrar_clsNonRigidRegistrar, optional\n\nUninstantiated NonRigidRegistrar class that will be used to calculate the deformation fields between images. See the non_rigid_registrars module for a desciption of available methods. If a desired non-rigid registration method is not available, one can be implemented by subclassing.NonRigidRegistrar. If None, then only rigid registration will be performed\n\nnon_rigid_reg_params: dictionary, optional\n\nDictionary containing key, value pairs to be used to initialize non_rigid_registrar_cls. In the case where simple ITK is used by the, params should be a SimpleITK.ParameterMap. Note that numeric values nedd to be converted to strings. See the NonRigidRegistrar classes in non_rigid_registrars for the available non-rigid registration methods and arguments.\n\ncompose_non_rigidbool, optional\n\nWhether or not to compose non-rigid transformations. If True, then an image is non-rigidly warped before aligning to the adjacent non-rigidly aligned image. This allows the transformations to accumulate, which may bring distant features together but could also result in un-wanted deformations, particularly around the edges. If False, the image not warped before being aaligned to the adjacent non-rigidly aligned image. This can reduce unwanted deformations, but may not bring distant features together.\n\nimg_listlist, dictionary, optional\n\nList of images to be registered. However, it can also be a dictionary, in which case the key: value pairs are full_path_to_image: name_of_image, where name_of_image is the key that can be used to access the image from Valis.slide_dict.\n\ndo_rigid: bool, dictionary, optional\n\nWhether or not to perform rigid registration. If False, rigid registration will be skipped.\n\nIf do_rigid is a dictionary, it should contain inverse transformation matrices to rigidly align images to the specificed by reference_img_f. M will be estimated for images that are not in the dictionary. Each key is the filename of the image associated with the transformation matrix, and value is a dictionary containing the following values:\n\nM(required) a 3x3 inverse transformation matrix as a numpy array.\n\nFound by determining how to align fixed to moving. If M was found by determining how to align moving to fixed, then M will need to be inverted first.\n\ntransformation_src_shape_rc(optional) shape (row, col) of image used to find the rigid transformation.\n\nIf not provided, then it is assumed to be the shape of the level 0 slide\n\ntransformation_dst_shape_rc(optional) shape of registered image.\n\nIf not provided, this is assumed to be the shape of the level 0 reference slide.\n\ncrop: str, optional\n\nHow to crop the registered images. “overlap” will crop to include only areas where all images overlapped. “reference” crops to the area that overlaps with a reference image, defined by reference_img_f. This option can be used even if reference_img_f is None because the reference image will be set as the one at the center of the stack.\n\nIf both crop and reference_img_f are None, crop will be set to “overlap”. If crop is None, but reference_img_f is defined, then crop will be set to “reference”.\n\ncreate_masksbool, optional\n\nWhether or not to create and apply masks for registration. Can help focus alignment on the tissue, but can sometimes mask too much if there is a lot of variation in the image.\n\ndenoise_rigidbool, optional\n\nWhether or not to denoise processed images before rigid registion. Note that un-denoised images are used in the non-rigid registration\n\ncrop_for_rigid_regbool, optional\n\nWhether or not to crop the images used for rigid registration. If True, then higher resolution images may be used for rigid registeration, as valis will “zoom” in to the area around the mask created by ImageProcesser.create_mask(), and slice out that region and resize it to have a maximum dimension the same as max_processed_image_dim_px. If False, the full image will be used, although the tissue may be at a lower resolution.\n\ncheck_for_reflectionsbool, optional\n\nDetermine if alignments are improved by relfecting/mirroring/flipping images. Optional because it requires re-detecting features in each version of the images and then re-matching features, and so can be time consuming and not always necessary.\n\nresolution_xyu: tuple, optional\n\nPhysical size per pixel and the unit. If None (the default), these values will be determined for each slide using the slides’ metadata. If provided, this physical pixel sizes will be used for all of the slides. This option is available in case one cannot easily access to the original slides, but does have the information on pixel’s physical units.\n\nslide_dims_dict_whdict, optional\n\nKey= slide/image file name, value= dimensions = [(width, height), (width, height), …] for each level. If None (the default), the slide dimensions will be pulled from the slides’ metadata. If provided, those values will be overwritten. This option is available in case one cannot easily access to the original slides, but does have the information on the slide dimensions.\n\nmax_image_dim_pxint, optional\n\nMaximum width or height of images that will be saved. This limit is mostly to keep memory in check.\n\nmax_processed_image_dim_pxint, optional\n\nMaximum width or height of processed images. An important parameter, as it determines the size of of the image in which features will be detected and displacement fields computed.\n\nmax_non_rigid_registration_dim_pxint, optional\n\nMaximum width or height of images used for non-rigid registration. Larger values may yeild more accurate results, at the expense of speed and memory. There is also a practical limit, as the specified size may be too large to fit in memory.\n\nmask_dictdictionary\n\nDictionary where key = overlap type (all, overlap, or reference), and value = (mask, mask_bbox_xywh)\n\nthumbnail_sizeint, optional\n\nMaximum width or height of thumbnails that show results\n\nnorm_methodstr\n\nName of method used to normalize the processed images. Options are None when normalization is not desired, “histo_match” for histogram matching and “img_stats” for normalizing by image statistics. See preprocessing.match_histograms and preprocessing.norm_khan for details.\n\niter_orderlist of tuples\n\nEach element of iter_order contains a tuple of stack indices. The first value is the index of the moving/current/from image, while the second value is the index of the moving/next/to image.\n\nmicro_rigid_registrar_clsMicroRigidRegistrar, optional\n\nClass used to perform higher resolution rigid registration. If None, this step is skipped.\n\nmicro_rigid_registrar_paramsdictionary\n\nDictionary of keyword arguments used intialize the MicroRigidRegistrar\n\nqt_emitterPySide2.QtCore.Signal, optional"
    }
}