{
    "id": "dbpedia_7423_2",
    "rank": 64,
    "data": {
        "url": "https://github.com/X16Community/x16-emulator/blob/master/README.md",
        "read_more_link": "",
        "language": "en",
        "title": "x16-emulator/README.md at master · X16Community/x16-emulator",
        "top_image": "https://opengraph.githubassets.com/c561de0b69bb9869fab1e6ad12e463378ae5c8b82924e1e734869addabf269b8/X16Community/x16-emulator",
        "meta_img": "https://opengraph.githubassets.com/c561de0b69bb9869fab1e6ad12e463378ae5c8b82924e1e734869addabf269b8/X16Community/x16-emulator",
        "images": [
            "https://github.com/X16Community/x16-emulator/raw/master/.gh/logo.png",
            "https://github.com/x16community/x16-emulator/actions/workflows/build.yml/badge.svg",
            "https://camo.githubusercontent.com/26105f25e671b3fa8143942f1d8fda06ace31f11c77f2c8c929a2cf0c2a4c8af/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f762f72656c656173652f783136636f6d6d756e6974792f7831362d656d756c61746f72",
            "https://camo.githubusercontent.com/ebaedd2f7fcbc670277a07553e946854a45a596a652cbc87caa85e14efc27be7/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f6c6963656e73652f783136636f6d6d756e6974792f7831362d656d756c61746f72",
            "https://camo.githubusercontent.com/0362468b792ce8d83fb05ccff8e41c6eaae3adec9262a0b952ac3a53e6b3395a/68747470733a2f2f696d672e736869656c64732e696f2f6769746875622f636f6e7472696275746f72732f783136636f6d6d756e6974792f7831362d656d756c61746f722e737667"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Emulator for the Commander X16 8-bit computer. Contribute to X16Community/x16-emulator development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/X16Community/x16-emulator/blob/master/README.md",
        "text": "This is an emulator for the Commander X16 computer system. It only depends on SDL2 and should compile on all modern operating systems.\n\nCPU: 65C02 and 65C816 instruction sets, selected by command line switch\n\nVERA\n\nMostly cycle exact emulation\n\nSupports almost all features:\n\ncomposer\n\ntwo layers\n\nsprites\n\nVSYNC, raster, sprite IRQ\n\nSound\n\nPCM\n\nPSG\n\nYM2151\n\nReal-Time-Clock\n\nNVRAM\n\nSystem Management Controller\n\nSD card: reading and writing (image file)\n\nVIA\n\nROM/RAM banking\n\nkeyboard\n\nmouse\n\ngamepads\n\nBinary releases for macOS, Windows and Linux are available on the releases page.\n\nThe emulator itself is dependent only on SDL2. However, to run the emulated system you will also need a compatible rom.bin ROM image. This will be loaded from the directory containing the emulator binary, or you can use the -rom .../path/to/rom.bin option.\n\nWARNING: Older versions of the ROM might not work in newer versions of the emulator, and vice versa.\n\nYou can build a ROM image yourself using the build instructions in the [x16-rom] repo. The rom.bin included in the latest release of the emulator may also work with the HEAD of this repo, but this is not guaranteed.\n\nInstall SDL2 using brew install sdl2.\n\nThe SDL2 development package is available as a distribution package with most major versions of Linux:\n\nRed Hat: yum install SDL2-devel\n\nDebian: apt-get install libsdl2-dev\n\nType make to build the source. The output will be x16emu in the current directory. Remember you will also need a rom.bin as described above.\n\nSteps for compiling WebAssembly/HTML5 can be found here.\n\nCurrently macOS/Linux/MSYS2 is needed to build for Windows. Install mingw-w64 toolchain and mingw32 version of SDL. Type the following command to build the source:\n\nPaths to those libraries can be changed to your installation directory if they aren't located there.\n\nThe output will be x16emu.exe in the current directory. Remember you will also need a rom.bin as described above and SDL2.dll in SDL2's binary folder.\n\nYou can start x16emu/x16emu.exe either by double-clicking it, or from the command line. The latter allows you to specify additional arguments. When starting x16emu without arguments, it will pick up the system ROM (rom.bin) from the executable's directory.\n\n-prg <app.prg>[,<load_addr>] lets you specify a .prg file that gets loaded after start. It is fetched from the host filesystem, even if an SD card is attached. The override load address is hex without a prefix.\n\n-bas <app.txt> lets you specify a BASIC program in ASCII format that automatically typed in (and tokenized).\n\n-run executes the application specified through -prg or -bas using RUN.\n\n-scale {1|2|3|4} scales video output to an integer multiple of 640x480\n\n-quality {nearest|linear|best} change image scaling algorithm quality\n\nnearest: nearest pixel sampling\n\nlinear: linear filtering\n\nbest: (default) anisotropic filtering\n\n-widescreen Stretch output to 16:9 resolution to mimic display of a widescreen monitor.\n\n-fullscreen Start up in fullscreen mode instead of in a window.\n\n-opacity (0.0,...,1.0) Set the opacity value (0.0 for transparent, 1.0 for opaque) of the window. (default: 1.0)\n\n-rtc causes the real-time-clock set to the system's time and date.\n\n-echo [{iso|raw}] causes all KERNAL/BASIC output to be printed to the host's terminal. Enable this and use the BASIC command \"LIST\" to convert a BASIC program to ASCII (detokenize).\n\n-rom <rom.bin> Override KERNAL/BASIC/* ROM file.\n\n-ram <ramsize> specifies banked RAM size in KB (8, 16, 32, ..., 2048). The default is 512.\n\n-cart <crtfile.crt> loads a cartridge file. This requires a specially formatted cartridge file, as specified in the documentation.\n\n-cartbin <romfile.bin> loads a raw cartridge file. This will be loaded starting at ROM bank 32. All cart banks will be flagged as RAM.\n\n-joy1, -joy2, -joy3, -joy4 enables binding a gamepad to that SNES controller port\n\n-nvram lets you specify a 64 byte file for the system's non-volatile RAM. If it does not exist, it will be created once the NVRAM is modified.\n\n-keymap tells the KERNAL to switch to a specific keyboard layout. Use it without an argument to view the supported layouts.\n\n-noemucmdkeys Disable emulator command keys. Ctrl+M/⇧⌘M will always be intercepted by the emulator.\n\n-capture starts the emulator with the mouse/keyboard captured\n\n-nokeyboardcapture prevents the emulator from fully capturing the keyboard in capture mode, which allows OS-level keystrokes like Alt+Tab to work while in capture mode.\n\n-sdcard lets you specify an SD card image (partition table + FAT32) which will be presented as device 8 at boot.\n\n-hostfsdev <unit> specifies the device number to use for the HostFS device. If this argument is not used, and -sdcard is specified, HostFS is disabled. If -sdcard is not specified, the default is 8. If both -sdcard and -hostfsdev 8 are specified, HostFS will take precedence, but both will be active. In this circumstance, if the HostFS device is changed away from unit 8 via a channel 15 command (e.g. \"S-9\"), the SD card device will then become visible on unit 8.\n\n-fsroot <dir> specifies a file system root for the HostFS interface. This lets you save and load files without an SD card image. (As of R42, this is the preferred method.) Default is the current working directory.\n\n-startin <dir> specify the host filesystem directory path that the emulated filesystem starts in. Default is the current working directory if it lies within the hierarchy of fsroot, otherwise it defaults to fsroot itself.\n\n-serial makes accesses to the host filesystem go through the Serial Bus [experimental].\n\n-nohostieee or -nohostfs disables IEEE API interception to access the host fs. IEEE API HostFS is normally enabled unless -sdcard or -serial is specified.\n\n-warp causes the emulator to run as fast as possible, possibly faster than a real X16.\n\n-pastewarp causes the emulator to enter warp mode during pasting (Ctrl+V or ⌘V) and during loading via -bas.\n\n-gif <filename>[,wait] to record the screen into a GIF. See below for more info.\n\n-wav <filename>[{,wait|,auto}] to record audio into a WAV. See below for more info.\n\n-log enables one or more types of logging (e.g. -log KS):\n\nK: keyboard (key-up and key-down events)\n\nS: speed (CPU load, frame misses)\n\nV: video I/O reads and writes\n\n-debug [<address>] enables the debugger. Optionally, set a breakpoint\n\n-dump configure system dump (e.g. -dump CB):\n\nC: CPU registers (7 B: A,X,Y,SP,STATUS,PC)\n\nR: RAM (40 KiB)\n\nB: Banked RAM (2 MiB)\n\nV: Video RAM and registers (128 KiB VRAM, 32 B composer registers, 512 B palette, 16 B layer0 registers, 16 B layer1 registers, 16 B sprite registers, 2 KiB sprite attributes)\n\n-memorystats <filename.txt> Saves memory read and write access statistics to the given file when emulator exits.\n\n-testbench Headless mode for unit testing with an external test runner\n\n-sound <device> can be used to specify the output sound device. If 'none', no audio is generated.\n\n-abufs can be used to specify the number of audio buffers (defaults to 8 when using the SD card, 32 when using HostFS). If you're experiencing stuttering in the audio, try increasing this number. This will result in additional audio latency though.\n\n-via2 installs the second VIA chip expansion at $9F10.\n\n-midline-effects enables mid-scanline raster effects at the cost of vastly increased host CPU usage.\n\n-mhz <integer> sets the emulated CPU's speed. Range is from 1-40. This option is mainly for testing and benchmarking.\n\n-enable-ym2151-irq connects the YM2151's IRQ pin to the system's IRQ line with a modest increase in host CPU usage.\n\n-wuninit enables warnings on the console for reads of uninitialized memory.\n\n-zeroram fills RAM at startup with zeroes instead of the default of random data.\n\n-version prints additional version information of the emulator and ROM.\n\n-c02 selects the 65C02 CPU (default).\n\n-c816 selects the 65C816 CPU (experimental).\n\n-rockwell when used while running with the 65C02 CPU, suppresses the console warning emitted on the first occurence when executing a Rockwell instruction. These are the SMBx, RMBx, BBRx, and BBSx instructions. Since these instructions are not supported on the 65C816 processor, such a program using them would not run properly on the 65C816.\n\n-longpwron Simulate a long press of the power button at system power-on.\n\nWhen compiled with #define TRACE, -trace will enable an instruction trace on stdout.\n\nRun x16emu -h to see all command line options.\n\nThe X16 uses a PS/2 keyboard, and the ROM currently supports several different layouts. The following table shows their names, and what keys produce different characters than expected:\n\nName Description Differences en-us US [`] ⇒ [←], [~] ⇒ [π], [\\] ⇒ [£] en-gb United Kingdom [`] ⇒ [←], [~] ⇒ [π] de German [§] ⇒ [£], [´] ⇒ [^], [^] ⇒ [←], [°] ⇒ [π] nordic Nordic key left of [1] ⇒ [←],[π] it Italian [\\] ⇒ [←], [|] ⇒ [π] pl Polish (Programmers) [`] ⇒ [←], [~] ⇒ [π], [\\] ⇒ [£] hu Hungarian [\\] ⇒ [←], [|] ⇒ [π], [§] ⇒ [£] es Spanish [|] ⇒ π, \\ ⇒ [←], Alt + [<] ⇒ [£] fr French [²] ⇒ [←], [§] ⇒ [£] de-ch Swiss German [^] ⇒ [←], [°] ⇒ [π] fr-be Belgian French [²] ⇒ [←], [³] ⇒ [π] fi Finnish [§] ⇒ [←], [½] ⇒ [π] pt-br Portuguese (Brazil ABNT) [\\] ⇒ [←], [|] ⇒ [π]\n\nKeys that produce international characters (like [ä] or [ç]) will not produce any character.\n\nSince the host computer tells the Commander X16 via the emulator the position of keys that are pressed, you need to configure the layout for the X16 independently of the keyboard layout you have configured on the host.\n\nUse the MENU command to select a layout, or set the keyboard layout at startup using the -keymap command line argument.\n\nThe following keys can be used for controlling games:\n\nKeyboard Key SNES Equivalent X or Ctrl A Z or Alt B S X A Y D L C R Shift SELECT Enter START Cursor Up UP Cursor Down DOWN Cursor Left LEFT Cursor Right RIGHT\n\nCtrl + F and Ctrl + Return will toggle full screen mode.\n\nCtrl + M will toggle mouse capture mode.\n\nCtrl + P will write a screenshot in PNG format to disk.\n\nCtrl + R will reset the computer.\n\nCtrl + Backspace will send an NMI to the computer (like RESTORE key).\n\nCtrl + S will save a system dump (configurable with -dump) to disk.\n\nCtrl + V will paste the clipboard by injecting key presses.\n\nCtrl + = and Ctrl + + will toggle warp mode.\n\n⌘F and ⌘Return will toggle full screen mode.\n\n⇧⌘M will toggle mouse capture mode.\n\n⌘P will write a screenshot in PNG format to disk.\n\n⌘R will reset the computer.\n\n⌘Delete aka ⌘Backspace will send an NMI to the computer (like RESTORE key).\n\n⌘S will save a system dump (configurable with -dump) to disk.\n\n⌘V will paste the clipboard by injecting key presses.\n\n⌘= and ⇧⌘+ will toggle warp mode.\n\nWith the argument -gif, followed by a filename, a screen recording will be saved into the given GIF file. Please exit the emulator before reading the GIF file.\n\nIf the option ,wait is specified after the filename, it will start recording on POKE $9FB5,2. It will capture a single frame on POKE $9FB5,1 and pause recording on POKE $9FB5,0. PEEK($9FB5) returns a 128 if recording is enabled but not active.\n\nWith the argument -wav, followed by a filename, an audio recording will be saved into the given WAV file. Please exit the emulator before reading the WAV file.\n\nIf the option ,wait is specified after the filename, it will start recording on POKE $9FB6,1. If the option ,auto is specified after the filename, it will start recording on the first non-zero audio signal. It will pause recording on POKE $9FB6,0. PEEK($9FB6) returns a 1 if recording is enabled but not active.\n\nx16-emulator exposes registers in the range of, from $9FB0-$9FBF, which allows one to control or toggle various emulator features from within emulated code.\n\nWhen writing machine code that uses these registers, good practice is to read $9FBE and $9FBF and check for their return values. If the emulator is present, those memory locations will return the ASCII/PETSCII characters \"1\" and \"6\" respectively ($31 and $36 hex). After verifying that the code is running under the emulator, you can confidently use the features provided by these registers.\n\nSeveral of the following registers are particularly useful for debugging. In particular, writing data to $9FB9, $9FBA, or $9FBB will output debug information to the console, terminal, or command prompt window from which you ran x16emu.\n\nRegister Read Behavior Write Behavior $9FB0 Returns debugger enabled flag 0 disables, 1 enables the debugger, overriding the absence or presence of the -debug command line argument. $9FB1 Returns video logging flag 0 disables, 1 enables logging of VRAM accesses to the console $9FB2 Returns keyboard logging flag 0 disables, 1 enables logging of keyboard events to the console $9FB3 Returns echo mode 0 disables, 1 enables raw echo, 2 enables cooked (\\Xnn for non-ASCII), and 3 enables ISO (w/ conversion to UTF-8). When on, characters sent via the BSOUT KERNAL call will also appear on the console. $9FB4 Returns save-on-exit flag 0 disables, 1 enables save-on-exit. When this option is set and the program counter reaches $FFFF, the emulator outputs a dump of emulator state to dump.bin before exiting. $9FB5 Returns GIF recorder state 0 pauses, 1 captures a single frame, and 2 activates/resumes GIF recording. The path to the GIF file must have been passed to the -gif command line option in advance. $9FB6 Returns WAV recorder state 0 pauses, 1 enables WAV recording, and 2 sets up autostart. The path to the WAV file must have been passed to the -wav command line option in advance. $9FB7 Returns emu command key flag 0 allows, and 1 inhibits most emulator command keys. Setting this flag prevents the emulator from intercepting keystrokes such as Ctrl+V/⌘V or Ctrl+R/⌘R, allowing the Commander X16 application running inside to make use of them. $9FB8 Latches the cpu clock counter and returns bits 0-7 Resets the cpu clock counter to 0 $9FB9 Returns bits 8-15 from the latched cpu clock counter value Outputs \"User debug 1: $xx\" to the console with xx replaced by the value written. $9FBA Returns bits 16-23 from the latched cpu clock counter value Outputs \"User debug 2: $xx\" to the console with xx replaced by the value written. $9FBB Returns bits 24-31 from the latched cpu clock counter value Outputs the given character to the console. This is basically a STDOUT port for programs running in the emulator. Only printable characters are allowed. Non-printables are replaced with �. $9FBC - - $9FBD Returns the keymap index, based on the argument to the -keymap command line option - $9FBE Returns the value $31/ASCII \"1\", useful for emulator presence detection - $9FBF Returns the value $36/ASCII \"6\", useful for emulator presence detection -\n\nOn startup, the X16 presents direct mode of BASIC V2. You can enter BASIC statements, or line numbers with BASIC statements and RUN the program, just like on Commodore computers.\n\nTo stop execution of a BASIC program, hit the RUN/STOP key (Pause), or Ctrl+C.\n\nTo insert characters, first insert spaces by pressing Shift+Backspace or Insert, then type over those spaces.\n\nTo clear the screen, press Shift+Home.\n\nTo send NMI, similar to STOP+RESTORE on the C64, use Ctrl+Backspace/⌘Delete. On real hardware this is done with Ctrl+Alt+RESTORE (Ctrl+Alt+PrtScr) or by pressing the NMI button.\n\nThe command line argument -sdcard lets you attach an image file for the emulated SD card. Using an emulated SD card makes filesystem operations go through the X16's DOS implementation, so it supports all filesystem operations (including directory listing though DOS\"$ command channel commands using the DOS statement) and guarantees full compatibility with the real device.\n\nImages must be greater than 32 MB in size and contain an MBR partition table and a FAT32 filesystem. The file sdcard.img.zip in this repository is an empty 100 MB image in this format.\n\nOn macOS, you can just double-click an image to mount it, or use the command line:\n\nOn Linux, you can use the command line:\n\nOn Windows, you can use the OSFMount tool. Windows VHD files can also be created using the built-in Disk Manager. Careful attention should be paid to the settings when creating and formatting the VHD:\n\nThe file must be at least 32MB and must be fixed size. Expanding VHDs are not supported.\n\nUse an MBR partition tables. The Commander X16 does not recognize GPT partition tables.\n\nYou must format the VHD with FAT32. Other file formats are not supported.\n\nThis is a trick, since Fixed-size VHD files contain the data first, with the metadata in a footer at the end. Since the emulator does not read or edit that medatada, it will only work with fixed-size files that are fully populated.\n\nIf the system ROM contains any version of the KERNAL, and there is no SD card image attached, all accesses to the (\"IEEE\") Commodore Bus are intercepted by the emulator for device 8 (the default). So the BASIC statements will target the host computer's local filesystem:\n\nThe emulator will interpret filenames relative to the directory it was started in. On macOS, when double-clicking the executable, this is the home directory. To specify a different path as the emulated root, you can use the -fsroot command line option.\n\nTo avoid compatibility problems between the PETSCII and ASCII encodings, you can\n\nuse uppercase filenames on the host side, and unshifted filenames on the X16 side.\n\nuse Ctrl+O to switch to the X16 to ISO mode for ASCII compatibility.\n\nuse Ctrl+N to switch to the upper/lower character set for a workaround.\n\nAs of R42, the Host Filesystem interface (or HostFS) is the preferred method of accessing files. It does not require creating or managing an SDcard image, and it supports all of the CMDR-DOS commands. However, it is not cycle-accurate, since the emulator traps calls to DOS and performs the same actions in the host environment. If performance and hardware accuracy is required, you will want to perform final testing using an SD card image.\n\nBASIC programs are encoded in a tokenized form when saved. They are not simply ASCII files. If you want to edit BASIC programs on the host's text editor, you need to convert it to tokenized BASIC encoding from ASCII encoding before calling LOAD in the emulator.\n\nTo convert the basic file from ASCII to tokenized BASIC encoding, reboot the machine and paste the ASCII text using Ctrl + V (Mac: Cmd + V) into the terminal. You can now run the program with RUN, or use the SAVE BASIC command to write the tokenized version to the host disk. Below is an example.\n\nCopy ASCII text from host basic file \"PRG.BAS\"\n\nPaste into new terminal session\n\nSAVE\"ENCODED.BAS\n\nNow you can restart the emulator and load the encoded basic file with LOAD\"ENCODED.BAS\"\n\nRun with RUN\"ENCODED.BAS\"\n\nTo convert BASIC to ASCII, start x16emu with the -echo argument, LOAD the BASIC file, and type LIST. Now copy the ASCII version from the terminal.\n\nPlease see the KERNAL/BASIC documentation.\n\nThe debugger requires -debug. To start the debugger, press the F12 key. Without -debug, the debugger is disabled and won't start. If you wish to set an initial breakpoint you can also include the memory address, in hexadecimal, of the breakpoint after the -debug switch. For example -debug 080d.\n\nThere are 2 panels you can control. The code panel, the top left half, and the data panel, the bottom half of the screen. You can also edit the contents of the registers PC, A, B, C, D, K, DB, X, Y, and SP.\n\nGreyed out numbers in the register display indicate values that are fixed at their given value due to the current processor state. This applies to\n\nthe high bytes of X and Y if the index flags is set\n\nthe flags M (memory) and I (index) if emulation mode is active\n\nthe high byte of SP if emulation mode is active.\n\nThe debugger uses its own command line with the following syntax:\n\nStatement Description d %x Change the code panel to view disassembly starting from the address %x. m %x Change the data panel to view memory starting from the address %x. v %x Display VERA RAM (VRAM) starting from address %x. b %s %d Changes the current memory bank for disassembly and data. The %s param can be either 'ram' or 'rom', the %d is the memory bank to display (but see NOTE below!). r %s %x Changes the value in the specified register. Valid registers in the %s param are 'pc', 'a', 'b', 'c', 'd', 'k', 'dbr', 'x', 'y', and 'sp'. %x is the value to store in that register.\n\nNOTE. To disassemble or dump memory locations in banked RAM or ROM, prepend the bank number to the address; for example, \"m 4a300\" displays memory contents of BANK 4, starting at address $a300. This also works for the 'd' command.\n\nThe debugger keys are similar to the Microsoft Debugger shortcut keys, and work as follows\n\nKey Description F1 resets the disassembly position to the current PC F2 resets the emulated CPU but not any of the hardware. F5 close debugger window and return to Run mode, the emulator should run as normal. F9 sets the breakpoint to the currently code position. F10 steps 'over' routines - if the next instruction is JSR it will break on return. F11 steps 'into' routines. F12 is used to break back into the debugger. This does not happen if you do not have -debug PAGE UP scrolls memory up by page. PAGE DOWN scrolls memory down by page. Shift + PAGE UP scrolls disassembly up by 16 bytes. Shift + PAGE DOWN scrolls disassembly down by 16 bytes. UP scrolls memory up by row. DOWN scrolls memory down by row. Shift + UP scrolls disassembly up by one byte. Shift + DOWN scrolls disassembly down by one byte. TAB when stopped, or single stepping, hides the debug panel while pressed.\n\nWhen -debug is selected the STP instruction (opcode $DB) will break into the debugger automatically.\n\nKeyboard routines only work when the emulator is running normally. Single stepping through keyboard code will not work at present.\n\nThe Commander X16 will support cartridge ROMs, including auto-booting game cartridges. On the Gen-1 Developer board, the first slot will be used for cartridges. On the Gen-2 console machine, there is only one slot. ROM carts should work on both systems.\n\nThis CRT format is intended for the emulator, and it is not required or used by the hardware. You can, however, use the MakeCart tool to convert between a single CRT file and BIN files that can be used to program a ROM burner. Also, note that this is different from the CRT format used the VICE emualtor, so files are not interchangable.\n\nCommander X16 cartridges will occupy the same address space as the Commander's KERNAL and BASIC ROMs. You can control the active bank by writing to address $0001 on the computer. Banks 0-31 are the built-in ROM banks, and banks 32-255 will select the cartridge ROMs.\n\nThis is the cartridge header. The first 256 bytes are ASCII data and Human readable. The second 256 bytes are bank data; these are byte integers. Text fields are set to 16 or 32-byte boundaries for ease of formatting.\n\nLocation Length Description 00-15 16 ASCII text: CX16 CARTRIDGE\\r\\n 16-31 16 CRT format version. ASCII digits in format 01.02, space padded. 32-63 32 Name. ASCII text. 64-95 32 Programmer/Developer. ASCII text. 96-127 32 Copyright information. ASCII text. 128-191 32 Program version. ASCII text. 192-255 64 Empty. 256-287 32 Fill with zeros. 288-511 224 Bank Flags. 00: Not Present. No data is present in the emulator or in the file. 01: ROM: 16KB of ROM data. Data is write protected in emulator. 02: RAM: No data in file. Bank is read/write in emulator. 03: RAM: Data present: data is loaded from the file and discarded on shutdown. Useful for testing. 04: NVRAM: No Data in file. Memory is writeable. Emulator saves data to NVRAM file. 05: NVRAM: Data present. Memory is writeable. Emulator saves data to NVRAM file. 512-end Payload data. 16384 bytes per bank for types 1, 3, and 5. 0 bytes for types 0,2, and 4.\n\nFor NVRAM banks: on shutdown, the emulator will write out an NVRAM file that contains the data of all of the NVRAM banks. The next time this cartridge is started, the NVRAM file will be loaded into any NVRAM bank. This overwrites any data present in NVRAM banks in the CRT file.\n\nFor types 00, 02, and 04: The file does not contain data for these bank types. Instead, the file skips straight to the next bank with initialized data (01, 03, or 05).\n\nFor all \"No Data\" banks, the data in RAM is undefined. While the emulator currently initializes RAM to 0 bytes, the hardware will have random values. In addition, unpopulated addresses will be \"open collector\" and will have unpredicatable results.\n\nX16 hardware, and thus the emulator, will only read 6502 vectors out of bank 0. This is done via the CPU's VPB pin being connected to the ROM bank latch reset pin. In the past specific vectors were recommended in cartridge ROMs, but this is no longer true. In cartridges, the addresses $FFFA-$FFFF are free to use for data.\n\nA conversion tool to pack cartridge data into a CRT file, makecart, is included in this release.\n\n-cfg <filename.cfg> Use this file to pack the cartridge data. Config file is simply the command line switches, one per line.\n\n-desc \"Name/Description\" Set the description field of the cartridge file. Up to 32 bytes of ASCII text.\n\n-author \"Author Information\" Set the author information field of the cartridge file. Up to 32 bytes of ASCII text.\n\n-copyright \"Copyright Information\" Set the copyright information field of the cartridge file. Up to 32 bytes of ASCII text.\n\n-version \"version\" Set the version information field of the cartridge file. Up to 32 bytes of ASCII text.\n\n-fill <value> Set the fill value to use with any partially-filled banks of cartridge memory. Value can be defined in decimal, or in hexadecimal with a '$' or '0x' prefix. 8-bit values will be repeated every byte, 16-bit values every two bytes, and 32-bit values every 4 bytes.\n\n-rom_file <start_bank> [<filename.bin> [<filename.bin>] ... ]\n\nDefine rom banks from the specified list of files. File data is tightly packed -- if a file does not end on a 16KB interval, the next file will be inserted immediately after it within the same bank. If the last file does not end on a 16KB interval, the remainder of the rom will be filled with the value set by '-fill'.\n\nValid bank numbers are 32 - 255.\n\n-ram <start_bank> [<end bank>] Define one or more banks of RAM. RAM banks are not included in the payload.\n\n-ram_file <start_bank> [<filename.bin> [<filename.bin>] ... ] Define one or more banks of initialized RAM. Note that Initialized RAM banks are not saved to the NVRAM file at shutdown.\n\n-nvram <start_bank> [<end_bank>] Define one or more uninitalized nvram banks.\n\n-nvram_value <start_bank> <end_bank> Define pre-initialized nvram banks with the value set by '-fill'. Repeated payload bytes will be written to the file.\n\n-nvram_file <start_bank> [<filename.bin> [<filename.bin>] ... ]\n\nDefine pre-initialized nvram banks from the specified list of files. File data is tightly packed like with -rom. If the last file does not end on a 16KB interval, the remainder of the rom will be filled with the value set by '-fill'.\n\n-none <start_bank> [<end_bank>] Define one or more unpopulated banks of the cartridge. By default, all banks are unpopulated unless specified by a previous command-line option. These banks are not present in the payload and only popualte the bank header in the CRT file.\n\n-o <output.crt> Set the filename of the output cartridge file.\n\nAll options can be specified multiple times, and are applied in-order from left to right. For -desc and -o, it is legal to specify them multiple times but only the right-most instances of each will have effect.\n\n-unpack <input.crt> [<rom_size>] Unpacks the binary data from the cartridge file into <rom_size> slices. (for use with an EPROM programmer.) The ouptut files will be the same filename as the input file, with _### appended. This will also create a .cfg file that can be used to re-pack the files into a new CRT if needed.\n\nThe config file is just a series of command-line switches, with one item per line. This example assumes ladder.bin uses 3 banks, for a total of 48K, and that each level map is 4KB in size.\n\nThis would create file with\n\n512 byte header\n\n5 ROM banks\n\n3 for the 48K ladder.bin\n\n1 for the four 4KB level files.\n\n1 empty NVRAM bank\n\nSince the NVRAM bank is not initialized, it is not included in the file. This makes the file a total of 66,048 bytes long. (512 bytes, plus four 16KB banks.)\n\nhttps://commanderx16.com\n\nhttps://cx16forum.com/forum\n\nCopyright (c) 2019-2023 Michael Steil <mist64@mac.com>, www.pagetable.com, et al. All rights reserved. License: 2-clause BSD"
    }
}