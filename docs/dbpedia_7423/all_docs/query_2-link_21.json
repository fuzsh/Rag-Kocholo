{
    "id": "dbpedia_7423_2",
    "rank": 21,
    "data": {
        "url": "https://developers.redhat.com/articles/2023/05/08/how-create-execution-environments-using-ansible-builder",
        "read_more_link": "",
        "language": "en",
        "title": "How to create execution environments using ansible-builder",
        "top_image": "https://developers.redhat.com/sites/default/files/styles/share/public/SP-ansible1_2x.png?itok=StIQEumS",
        "meta_img": "https://developers.redhat.com/sites/default/files/styles/share/public/SP-ansible1_2x.png?itok=StIQEumS",
        "images": [
            "https://developers.redhat.com/themes/custom/rhdp_fe/images/branding/2023_RHDLogo_reverse.svg",
            "https://developers.redhat.com/sites/default/files/2023-10/RHEL-2.png",
            "https://developers.redhat.com/sites/default/files/2024-05/RHEL-AI-mini.png",
            "https://developers.redhat.com/sites/default/files/2024-04/rhel-image-mode.png",
            "https://developers.redhat.com/sites/default/files/Red%20Hat%20OS%402x.png",
            "https://developers.redhat.com/sites/default/files/ICO%20-%20Ansible%20Platform%20Learning%20Resources.png",
            "https://developers.redhat.com/sites/default/files/2024-03/Podman%20Desktop_NavigationIcon.png",
            "https://developers.redhat.com/sites/default/files/2024-04/Podman%20Desktop_NavigationIcon%20%281%29.png",
            "https://developers.redhat.com/sites/default/files/homepage-sandbox.jpg",
            "https://developers.redhat.com/sites/default/files/2024-05/ai-ml_featured.png",
            "https://developers.redhat.com/sites/default/files/Red%20Hat%20OS%20Platform%402x.png",
            "https://developers.redhat.com/sites/default/files/Cloud-native%20app%20server%20on%20OpenShift.png",
            "https://developers.redhat.com/sites/default/files/2023-10/Automation-2.png",
            "https://developers.redhat.com/sites/default/files/2023-10/App-Dev-Platform-2.png",
            "https://developers.redhat.com/sites/default/files/2023-10/2023_RHD_SandBox_Graphic_final.png",
            "https://developers.redhat.com/sites/default/files/Red%20Hat%20OS%402x.png",
            "https://developers.redhat.com/sites/default/files/Red%20Hat%20OS%20Platform%402x.png",
            "https://developers.redhat.com/sites/default/files/ICO%20-%20Download%20Ansible%20Automation%20Platform.png",
            "https://developers.redhat.com/sites/default/files/2023-10/java.png",
            "https://developers.redhat.com/sites/default/files/2023-10/ai-ml.png",
            "https://developers.redhat.com/sites/default/files/2023-10/learning.png",
            "https://developers.redhat.com/sites/default/files/2023-10/summit-logo-red%20%281%29.png",
            "https://developers.redhat.com/sites/default/files/styles/article_full_width_1440px_w/public/image_1.png?itok=AxLHdHot",
            "https://developers.redhat.com/sites/default/files/styles/article_floated/public/2024_Ebook_Podman_tilecardv2.png?itok=pqDNZP_Q",
            "https://developers.redhat.com/themes/custom/rhdp_fe/images/branding/2023_RHDLogo_reverse.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Tathagata Paul"
        ],
        "publish_date": "2023-05-08T00:00:00",
        "summary": "",
        "meta_description": "Learn how to use execution environment builder, a CLI tool for Ansible Automation Platform, to create custom images and push them to a private automation hub.",
        "meta_lang": "en",
        "meta_favicon": "/themes/custom/rhdp_fe/favicons/favicon.ico",
        "meta_site_name": "Red Hat Developer",
        "canonical_link": "https://developers.redhat.com/articles/2023/05/08/how-create-execution-environments-using-ansible-builder",
        "text": "The execution environment builder (aka Ansible Builder) is a part of Red Hat Ansible Automation Platform. It is a command-line interface (CLI) tool for building and creating custom execution environments. The Ansible Builder project enables users to automate and accelerate the process of creating execution environments. This article will show you how to install and use the execution environment builder CLI tool.\n\nInstalling the execution environment builder\n\nThe execution environment builder makes it easier for Ansible Automation Platform content creators and administrators to build custom execution environments. They can use dependency information from various Ansible Content Collections and directly from the user.\n\nStep 1: Install the execution environment builder tool\n\nInstall the execution environment builder tool from the Python Package Index (PyPI) by using the following command:\n\npip install ansible-builder\n\nStep 2: Access the ansible-builder subcommands\n\nTo access the subcommands of ansible-builder, run build and create commands to get help output.\n\nThe build subcommand will build the execution environment using the definition file.\n\nansible-builder build –help\n\nIt populates the build context and then uses Podman or Docker to create the execution environment image. The help output appears as follows:\n\nusage: ansible-builder build [-h] [-t TAG] [--container-runtime {podman,docker}] [--build-arg BUILD_ARGS] [-f FILENAME] [-c BUILD_CONTEXT] [--output-filename {Containerfile,Dockerfile}] [-v {0,1,2,3}] Creates a build context (including a Containerfile) from an execution environment spec. The build context will be populated from the execution environment spec. After that, the specified container runtime podman/docker will be invoked to build an image from that definition. After building the image, it can be used locally or published using the supplied tag. optional arguments: -h, --help show this help message and exit -t TAG, --tag TAG The name for the container image being built (default: ansible-execution-env:latest) --container-runtime {podman,docker} Specifies which container runtime to use (default: podman) --build-arg BUILD_ARGS Build-time variables to pass to any podman or docker calls. Internally ansible-builder makes use of ANSIBLE_GALAXY_CLI_COLLECTION_OPTS, EE_BASE_IMAGE, EE_BUILDER_IMAGE. -f FILENAME, --file FILENAME The definition of the execution environment (default: execution-environment.yml) -c BUILD_CONTEXT, --context BUILD_CONTEXT The directory to use for the build context (default: context) --output-filename {Containerfile,Dockerfile} Name of file to write image definition to (default depends on --container-runtime, Containerfile for podman and Dockerfile for docker) -v {0,1,2,3}, --verbosity {0,1,2,3} Increase the output verbosity, for up to three levels of verbosity (invoked via \"--verbosity\" or \"-v\" followed by an integer ranging in value from 0 to 3) (default: 2)\n\nThe create subcommand works similar to the build command.\n\nansible-builder create –help\n\nHowever, it will not build the execution environment image as you will see in the following output:\n\nusage: ansible-builder build [-h] [-t TAG] [--container-runtime {podman,docker}] [--build-arg BUILD_ARGS] [-f FILENAME] [-c BUILD_CONTEXT] [--output-filename {Containerfile,Dockerfile}] [-v {0,1,2,3}] Creates a build context (including a Containerfile) from an execution environment spec. The build context will be populated from the execution environment spec. After that, the specified container runtime podman/docker will be invoked to build an image from that definition. After building the image, it can be used locally or published using the supplied tag. optional arguments: -h, --help show this help message and exit -t TAG, --tag TAG The name for the container image being built (default: ansible-execution-env:latest) --container-runtime {podman,docker} Specifies which container runtime to use (default: podman) --build-arg BUILD_ARGS Build-time variables to pass to any podman or docker calls. Internally ansible-builder makes use of ANSIBLE_GALAXY_CLI_COLLECTION_OPTS, EE_BASE_IMAGE, EE_BUILDER_IMAGE. -f FILENAME, --file FILENAME The definition of the execution environment (default: execution-environment.yml) -c BUILD_CONTEXT, --context BUILD_CONTEXT The directory to use for the build context (default: context) --output-filename {Containerfile,Dockerfile} Name of file to write image definition to (default depends on --container-runtime, Containerfile for podman and Dockerfile for docker) -v {0,1,2,3}, --verbosity {0,1,2,3} Increase the output verbosity, for up to three levels of verbosity (invoked via \"--verbosity\" or \"-v\" followed by an integer ranging in value from 0 to 3) (default: 2)\n\nStep 3: Populate the ansible-builder spec\n\nPopulate the ansible-builder spec to build the custom execution environment by running the following command:\n\nmkdir project_directory && cd project_directory\n\nPopulate the execution-environment.yml file:\n\ncat <<EOT >> execution-environment.yml --- version: 1 dependencies: galaxy: requirements.yml EOT\n\nCreate a requirements.yml file and populate the contents with the following:\n\ncat <<EOT >> requirements.yml --- collections: - name: servicenow.itsm EOT\n\nThrough the spec and requirements file, we ensure that execution environment builder will download the servicenow.itsm collection while building the execution environment. The default download location is galaxy.ansible.com. You can also point to an automation hub or your own hub instance in the spec file.\n\nStep 4: Build the execution environment\n\nBuild the execution environment using the previously created files. Run the following command to create a new custom execution environment called custom-ee:\n\nansible-builder build -v3 -t custom-ee\n\nThe -v3 flag adds verbosity to the CLI run, and -t custom-ee will tag your image with the name you provided.\n\nThe output appears as follows:\n\nAnsible Builder is building your execution environment image, \"custom-ee\". File context/_build/requirements.yml will be created. Rewriting Containerfile to capture collection requirements Running command: podman build -f context/Containerfile -t custom-ee context [1/3] STEP 1/7: FROM registry.redhat.io/ansible-automation-platform-21/ee-minimal-rhel8:latest AS galaxy [1/3] STEP 2/7: ARG ANSIBLE_GALAXY_CLI_COLLECTION_OPTS= --> 88d9ea223d0 [1/3] STEP 3/7: USER root --> 549f29055c2 [1/3] STEP 4/7: ADD _build /build --> 0d3e9515b12 [1/3] STEP 5/7: WORKDIR /build --> 3b290acf78c [1/3] STEP 6/7: RUN ansible-galaxy role install -r requirements.yml --roles-path /usr/share/ansible/roles Skipping install, no requirements found --> 8af36370e78 [1/3] STEP 7/7: RUN ansible-galaxy collection install $ANSIBLE_GALAXY_CLI_COLLECTION_OPTS -r requirements.yml --collections-path /usr/share/ansible/collections Starting galaxy collection install process Process install dependency map …\n\nRun the following commands to check the image list:\n\npodman images\n\nThe output appears as follows:\n\nREPOSITORY TAG IMAGE ID CREATED SIZE localhost/custom-ee latest bfe6c40bad52 21 seconds ago 626 MB\n\nStep 5: Build a complex execution environment\n\nTo build a complex execution environment, go back into the project directory with the following command:\n\ncd project_directory\n\nEdit the execution-environment.yml file and add the following content:\n\ncat <<EOT >> execution-environment.yml --- version: 1 dependencies: galaxy: requirements.yml python: requirements.txt system: bindep.txt additional_build_steps: prepend: | RUN whoami RUN cat /etc/os-release append: - RUN echo This is a post-install command! - RUN ls -la /etc EOT\n\nWe can see the following:\n\nPython requirements were added through the requirements.txt file, which will hold the pip dependencies.\n\nWe added a bindep.txt, which will hold the rpm installs.\n\nAdditional build steps that will run before (prepend) and after (append) the build steps.\n\nNow create a new file called requirements.yml and append the following content:\n\ncat <<EOT >> requirements.yml --- collections: - name: servicenow.itsm - name: ansible.utils EOT\n\nWe added a new collection called ansible.utils alongside the servicenow.itsm file.\n\nCreate a new file called requirements.txt and then append the following:\n\ncat <<EOT >> requirements.txt gcp-cli ncclient netaddr paramiko EOT\n\nThis contains the Python requirements that need to be installed via pip.\n\nCreate a new file called bindep.txt and then append the following:\n\ncat <<EOT >> bindep.txt findutils [compile platform:centos-8 platform:rhel-8] gcc [compile platform:centos-8 platform:rhel-8] make [compile platform:centos-8 platform:rhel-8] python38-devel [compile platform:centos-8 platform:rhel-8] python38-cffi [platform:centos-8 platform:rhel-8] python38-cryptography [platform:centos-8 platform:rhel-8] python38-pycparser [platform:centos-8 platform:rhel-8] EOT\n\nThis file contains the rpm requirements needed to be installed using dnf.\n\nRun the following build:\n\nansible-builder build -v3 -t custom-ee\n\nThe output is as follows:\n\nAnsible Builder is building your execution environment image, \"custom-ee\". File context/_build/requirements.yml will be created. File context/_build/requirements.txt will be created. File context/_build/bindep.txt will be created. Rewriting Containerfile to capture collection requirements Running command: podman build -f context/Containerfile -t custom-ee context [1/3] STEP 1/7: FROM registry.redhat.io/ansible-automation-platform-21/ee-minimal-rhel8:latest AS galaxy [1/3] STEP 2/7: ARG ANSIBLE_GALAXY_CLI_COLLECTION_OPTS= --> Using cache 88d9ea223d01bec0d53eb7efcf0e76b5f7da0285a411f2ce0116fe9641cbc3a0 --> 88d9ea223d0 [1/3] STEP 3/7: USER root --> Using cache 549f29055c2f1ba0ef3f7c5dfdc67a40302ff0330af927adb94fbcd7b0b1e7b4 --> 549f29055c2 [1/3] STEP 4/7: ADD _build /build --> 6b9ee91e773 [1/3] STEP 5/7: WORKDIR /build --> 5518e019f2d [1/3] STEP 6/7: RUN ansible-galaxy role install -r requirements.yml --roles-path /usr/share/ansible/roles Skipping install, no requirements found --> 60c1605d66c [1/3] STEP 7/7: RUN ansible-galaxy collection install $ANSIBLE_GALAXY_CLI_COLLECTION_OPTS -r requirements.yml --collections-path /usr/share/ansible/collections Starting galaxy collection install process Process install dependency map\n\nYou can check the context or Containerfile to see all the steps you took to build the execution environment. You can transfer the context directory to a different server and replicate the image creation via docker or podman commands.\n\nPushing the execution environment to a private automation hub\n\nLog in to the private automation hub by using the podman command:\n\npodman login <automation hub url>\n\nThen tag the image before pushing it to the hub as follows:\n\npodman tag localhost/custom-ee <automation hub url>/developers-bu-aap-builder\n\nFinally, push it to the private automation hub as follows:\n\npodman push <automation hub url>/developers-bu-aap-builder\n\nWe can see the image pushed to the private automation hub in Figure 1:\n\nContinue your automation journey with Ansible Automation Platform"
    }
}