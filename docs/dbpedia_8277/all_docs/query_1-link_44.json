{
    "id": "dbpedia_8277_1",
    "rank": 44,
    "data": {
        "url": "https://tsh.io/blog/taskfile-or-gnu-make-for-automation/",
        "read_more_link": "",
        "language": "en",
        "title": "Taskfile or GNU make – which one to use for automation?",
        "top_image": "https://tsh.io/wp-content/uploads/2021/04/taskfile-and-gnu-make-article.png",
        "meta_img": "https://tsh.io/wp-content/uploads/2021/04/taskfile-and-gnu-make-article.png",
        "images": [
            "https://tsh.io/wp-content/uploads/2024/07/programming-team-chat.svg",
            "https://tsh.io/wp-content/uploads/2024/07/target-center.svg",
            "https://tsh.io/wp-content/uploads/2024/07/car-dashboard-speed.svg",
            "https://tsh.io/wp-content/uploads/2024/07/programming-team-chat.svg",
            "https://tsh.io/wp-content/uploads/2024/07/target-center.svg",
            "https://tsh.io/wp-content/uploads/2024/07/car-dashboard-speed.svg",
            "https://tsh.io/wp-content/uploads/2020/01/grzegorz-blog_-150x150.jpeg",
            "https://tsh.io/wp-content/uploads/fly-images/18133/taskfile-and-gnu-make-article-810x531.png, https://tsh.io/wp-content/uploads/2021/04/taskfile-and-gnu-make-article.png 2x",
            "https://tsh.io/wp-content/uploads/2021/04/taskfile-preference-meme.png",
            "https://tsh.io/wp-content/uploads/2021/04/yaml-file-engineer.jpg",
            "https://tsh.io/wp-content/uploads/2021/04/gnu-make-meme.jpg",
            "https://tsh.io/wp-content/uploads/2021/04/make-syntax.png",
            "https://tsh.io/wp-content/uploads/2021/04/taskfile-syntax.png",
            "https://tsh.io/wp-content/uploads/2021/04/taskfile-commands.png",
            "https://tsh.io/wp-content/uploads/2021/04/taskfile-commands-from-main-directory.png",
            "https://tsh.io/wp-content/uploads/2020/01/grzegorz-blog_-150x150.jpeg",
            "https://tsh.io/wp-content/uploads/2023/08/2023_Poland_ENG.png",
            "https://tsh.io/wp-content/uploads/2023/02/AWS-Advanced-Partner-120px.svg",
            "https://tsh.io/wp-content/uploads/fly-images/21642/computer-world-95x40.png, https://tsh.io/wp-content/uploads/2021/09/computer-world.png 2x",
            "https://tsh.io/wp-content/uploads/fly-images/21641/technology-fast-50-181x40.png, https://tsh.io/wp-content/uploads/2021/09/technology-fast-50.png 2x",
            "https://tsh.io/wp-content/uploads/fly-images/21643/office-superstar-91x40.png, https://tsh.io/wp-content/uploads/2021/09/office-superstar.png 2x",
            "https://tsh.io/wp-content/themes/tsh-theme-2024-08-06-15-53-01/dist/images/fe-poir1x.png?id=6cd7564db74f8c4f3efc44d8985dc071, https://tsh.io/wp-content/themes/tsh-theme-2024-08-06-15-53-01/dist/images/fe-poir.png?id=0c8a17559849d6b0a8b403a3b0be6fcd 2x",
            "https://tsh.io/wp-content/themes/tsh-theme-2024-08-06-15-53-01/dist/images/deprecated/infobar/icon-close.svg",
            "https://tsh.io/wp-content/uploads/2023/09/eu-flag.svg",
            "https://tsh.io/wp-content/uploads/fly-images/26468/Eyass-Shakrah-male-zdjęcie-120x120.png, https://tsh.io/wp-content/uploads/2022/06/Eyass-Shakrah-male-zdjęcie.png 2x"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "https://tsh.io/blog/author/grzegorz-matuszak/#author",
            "Grzegorz Matuszak"
        ],
        "publish_date": "2021-04-20T13:52:49+02:00",
        "summary": "",
        "meta_description": "Taskfile or GNU make – which one of these popular build tools is a better choice for automating common project setup tasks in 2021?",
        "meta_lang": "en",
        "meta_favicon": "https://tsh.io/wp-content/themes/tsh-theme-2024-08-06-15-53-01/dist/images/deprecated/favicons/apple-touch-icon.png",
        "meta_site_name": "The Software House",
        "canonical_link": "https://tsh.io/blog/taskfile-or-gnu-make-for-automation/",
        "text": "Makefile vs Taskfile – comparison\n\nAs I mentioned before, this article is more about why I (and my team members) prefer to use Taskfile rather than Makefile. I did my best to find counterparts in both technologies.\n\nUnfortunately, the main reason we use Taskfile is because… it always works and is easier to use compared to GNU make.\n\nSyntax\n\nLet’s start with syntax. Both solutions are unique. Here is an example from Visual Studio Code.\n\nMakefile\n\nTaskfile\n\nAmount of code\n\nThe “full usage” of Taskfile requires much more stuff to declare. Thankfully, version 3 reduced this amount. The interesting thing is that Taskfile provides the possibility of setting a description. Thanks to this feature, it’s easy to search for specific commands or try to understand implemented functions. Since the description is written in a human-friendly language, there is no need to read the code line by line.\n\nIndention\n\nBoth Taskfile and Makefile implement an “off-side rule”. This means that the developer has to worry about indention.\n\nMakefile forces to use <tab> to create the indention. If you want to use Makefile, then make sure to supply this information to your IDE! Many developers spend hours debugging Makefile scripts, because they used spaces instead of tabs. Taskfile doesn’t have this problem. It follows the YAML convention, which is much more flexible.\n\nHabits\n\nIt’s more like a side note, but our minds do love habits. Many developers use the YAML format in their daily work. It’s much easier for them to read YAML than GNU Make. When you want to choose technology, please consider what is easier to read and if it’s worth dealing with the new Makefile format.\n\nOSes\n\nMakefile was created for Unix-based systems. It works great for them. As always, Windows users have to think about workarounds (not everyone uses WSL).\n\nTaskfile was created to run cross-platform. Everybody can use the same commands. The only thing which is worth remembering is to set variables to identify OS instead of hardcoding values.\n\nAn example of a command to download Kubernetes binary that works for all OSes:\n\nList of all commands\n\nWhen developers have to deal with many projects (have to be onboarded somewhere), it’s important to get the knowledge of what is available without reinventing the wheel. In this case, it’s good to have the chance to see a list of available commands to run.\n\nTaskfile has a built-in flag -l that delivers the list. It’s worth setting it as a “default” action. Remember – Taskfile only lists commands which have a description.\n\nThe same feature is also possible to implement using GNU Make, but it requires additional effort and code lines to achieve this goal.\n\nMakefile vs Taskfile – functions\n\nName conflicts\n\nBy default, Makefile reads files, not commands. If there is a command called “test” and a directory with the same name, Makefile will try to “read” the directory, not the command! This behavior might confuse and take time to fix, especially when a new user doesn’t have knowledge of how Makefile works. The solution is to use PHONY, which requires additional effort (remember to use it + write additional code). Taskfile doesn’t have this problem.\n\nConditions\n\nA major difference between Makefile and Taskfile is how conditions work. Makefile behaves like other popular languages. Nothing special (expect syntax) here.\n\nTaskfile has three features related to conditions. The first is related to preconditions. The task command will not be executed when the result of preconditions is false. It helps to reduce the complexity of the code.\n\nThe second possibility is to use the status function. When all conditions are met, the task will be skipped.\n\nThe third possibility is to use the “normal” if command:\n\nVariables\n\nThere are two types of variables: normal and environment. These types work with both Taskfile and Makefile, but the difference is in implementation.\n\nEnvironment variables\n\nTaskfile has the possibility to take environment variables from the .env file, declare them in the global file scope, and use them to forward for CLI scripts.\n\nThese functionalities are important during migrations from Makefile to Taskfile.\n\nBelow, you’ll find the same commands in Makefile.\n\nConclusions\n\nMakefile doesn’t provide the possibility of setting environment variables inside Makefile. The only way (except dirty hacks) is to put everything into the environment file.\n\nBy default, it’s not possible to forward dynamic CLI arguments. To make it work, Makefile requires writing hacks (check ifeq part for an example).\n\nBoth Makefile and Taskfile can read environment variables from .env by default. For custom filename, Makefile requires running the includeand exportcommands. The problem is that the official documentation does not explain that solution. There’s a thread on StackExchange, however.\n\n“Normal” variables\n\nTaskfile has four different scopes/places to declare a variable. It’s useful during script preparation. The basic format uses brackets “{{ }}” to define them. Variables without dot “.” are built-in. To use self-declared variables, it’s required to add a dot at the beginning.\n\nIt looks similar in Makefile.\n\nConcluding conclusions\n\nFor the Makefile environment, variables and “normal” variables stored in files are the same.\n\nMakefile doesn’t have the local scope. Everything has to be global.\n\nMakefile doesn’t have the option of getting information about OS, architecture, etc. Taskfile has built-in variables to get this information. There are workarounds, but they all take too much space to copy-paste them to example scripts.\n\nParser\n\nTaskfile uses a shell parser for Golang, which doesn’t work if it’s not in the library. I struggled with it once in the last 2 years of using Taskfile.\n\nDocumentation\n\nOne of the most important things is being able to find information. Here, Makefile has much more information since it has much more features. Personally, I prefer the Task documentation, because of the modern look and easy-to-read format of commands.\n\nSplit files\n\nTo set up a project for different environments, it’s required to run many commands. Sometimes, it’s good to split these commands into many directories. Local environment setup commands should go into the main directory, the ones for deployment into the DevOps directory, etc.\n\nWhat’s frustrating is that developers have to find these files, go to the directory, and then they should be able to run commands. Quite annoying? A much better solution is to run all commands from the main directory.\n\nFor Makefile, there is no simple way. It’s required to have to cd do the directory to then execute a command. What about Taskfile? There is a built-in function called include, which helps not only to execute commands from the main directory context, but also to execute them from destination directories. Quite confusing?\n\nMain directory\n\nNote that the second file has a path: devops/deployment/Taskfile.yml.\n\nThe result\n\nOne place to run the same commands from different directories\n\nSometimes, it’s required to run more fancy scripts. Imagine that a project has one repository for many Terraform modules. Most developers don’t want to have Terraform installed locally, as they want to use one terraform version without downloading terraform binary for each directory separately. With Taskfile, that is quite easy.\n\nThe usage here is task terraform:init PROJECT_NAME=<directory_name>\n\nFor Make, I wasn’t able to find a quick and easy solution to implement that."
    }
}