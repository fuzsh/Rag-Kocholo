{
    "id": "dbpedia_8277_2",
    "rank": 75,
    "data": {
        "url": "https://www.cppstories.com/2017/02/how-to-stay-sane-with-modern-c/",
        "read_more_link": "",
        "language": "en",
        "title": "How To Stay Sane with Modern C++",
        "top_image": "https://www.cppstories.com/2017/images/2017-02-06-how-to-stay-sane-with-modern-c-cppcomplex2.png",
        "meta_img": "https://www.cppstories.com/2017/images/2017-02-06-how-to-stay-sane-with-modern-c-cppcomplex2.png",
        "images": [
            "https://www.cppstories.com/images/cpp17indetailtop2.png",
            "https://www.cppstories.com/2017/images/2017-02-06-how-to-stay-sane-with-modern-c-cppcomplex2.png",
            "https://1.bp.blogspot.com/-NlWWmBI1jU4/X3q-pFyEtNI/AAAAAAAAExo/JYKpY-hn6Mk4x8x8RYf_amP-Px_N46vaQCLcBGAsYHQ/s0/cpp_spec_pages_count.png",
            "https://www.cppstories.com/2017/images/sanecpp.png",
            "https://www.cppstories.com/images/joinpatreon_160.png",
            "https://www.cppstories.com/images/cpp17_160_side.png",
            "https://www.cppstories.com/images/lambda_160_side.png",
            "https://www.cppstories.com/images/cppinit_160_side.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2017-02-06T08:15:00+01:00",
        "summary": "",
        "meta_description": "C++ grows very fast! For example, the number of pages of the C++ standard went from 879 pages for C++98/03 to 1834 for C++20! Nearly 1000 pages! What’s more, with each revision of C++, we get several dozens of new features. Have a look at my blog post with all C++17 features, it shows 48 items, and my C++20 reference card lists 47 elements!",
        "meta_lang": "en",
        "meta_favicon": "https://www.cppstories.com/image/theme/favicon.ico",
        "meta_site_name": "C++ Stories",
        "canonical_link": "https://www.cppstories.com/2017/02/how-to-stay-sane-with-modern-c/",
        "text": "Table of Contents\n\nC++ grows very fast! For example, the number of pages of the C++ standard went from 879 pages for C++98/03 to 1834 for C++20! Nearly 1000 pages! What’s more, with each revision of C++, we get several dozens of new features. Have a look at my blog post with all C++17 features, it shows 48 items, and my C++20 reference card lists 47 elements!\n\nDo you need to learn all of that stuff to write good code?\n\nHow to stay sane in the C++ world today?\n\nIntro\n\nYou probably know that C++ is a complex language. As I’ve found, there’s even a whole Wiki page about the criticism of Cpp. Modern C++ adds even more stuff to the package!\n\nHere’s the full data about the page count in the specs that I’ve mentioned before:\n\nC++98/03 - 879, N1905, Oct 2005\n\nC++11 - 1324, last draft, N3337, Jan 2012\n\nC++14 - 1368, last draft, Nov 2014\n\nC++17 - 1586, draft, N4606\n\nC++20 - 1834, draft, N4861\n\nIt looks like C++17 is almost ~80% ‘larger’ than C++98/03, and the latest draft of C++ has nearly 1000 pages more than C++03. You can complain about added complexity and that it’s hard to learn all of those things. But is this so terrible? What can you do about the whole situation?\n\nThis post was motivated by some stories recently found::\n\nHN: C++11 FAQ\n\nr/programming, lvalues and rvalues used to be simple things. Now, only a handful of people truly understand all facets of C++ value categories.\n\nWhy I don’t spend time with Modern C++ anymore | Hacker News\n\nr/programming, Modern C++ Features – decltype and std::declval\n\nReading this sub for an hour has made me crazy. : cpp\n\nABI: Now or Never : cpp\n\nBut to have a balance and something positive, there’s also a discussion like this one:\n\nI am a developer and just started learning C++, and I’m LOVING it! Programs feel real for the first time! : cpp\n\nMaybe it’s not that bad after all? :)\n\nFirst, let’s see some problems that you might bump into in C++.\n\nSome Problems\n\nTo name a few:\n\nToo slow pace\n\nToo fast pace\n\nConfusion/complexity of features\n\nSlow compilation Times\n\nLack of dependency management\n\nLet’s look at those in more detail.\n\nToo slow pace\n\nIn 2017 we got C++17. While it’s great, that we get a new standard every three years, a lot of developers complained that the new version is not what everyone waited for.\n\nA lot of features: like concepts, modules, ranges, co-routines, … were not accepted and we need to wait at least three more years to get them in the spec.\n\nNow, in 2020, we have C++20 ready, and those significant features are shipping with compilers! Yet, we can complain that contracts are not present, reflection, executors or networking is still being discussed. They might appear in C++23 or even later.\n\nIt looks like some features are slower to accept… .and there will always be something to complain.\n\nToo fast pace\n\nAs usual, we might have two contradicting opinions here. Although for some people the pace is slow, for others it’s hard to keep up with the changes.\n\nYou’ve just learned C++11/14… and now you need to update the knowledge with C++17, and then C++20 is along the way. Three years is not that short time, but bear in mind the compiler conformance, company policies, team guidelines might walk at a different pace.\n\nDo your companies update to the most modern C++ version immediately or wait a couple of years?\n\nConfusion / complexity of features\n\nJust read that comment:\n\nCallMeDonk\n\nI love c++. It’s my go to language, but you have to admit its ‘hodge podge’ implementation of value types is bizarre at best. Most programmers including me prefer simple well-defined language constructs over bizarre and over complicated grammar. I’m not a computer language lawyer. I’m a programmer.\n\nIs C++ clear in every aspect? Probably not…\n\nHere are some topics that might be hard to understand and might cause confusion among programmers:\n\nMove semantics\n\nThe principle of move semantics are quite clear: instead of copying try to “steal” the guts of the managed resources, and you should get a nice performance boost. But the devil is in the detail.\n\nI don’t write a lot of generic code, so, fortunately, I don’t have to think about move semantics all the time. But I was quite confused when I bumped into move and const - see my last article on that. I don’t believe every C++ will understand the rules here. Especially that you now need to remember about six default operations generated by the compiler: default constructor, destructor, copy constructor, move constructor, assign operator and move assignment operator.\n\nRvalues/xvalues/prvalues… myValues, fooValues\n\nThe last ones are made up… but still having all of the value categories is overwhelming!\n\nIn C (or C++98/03) you just had to know lvalue vs rvalue, now it’s a bit more subtle.\n\nStill, the question is if you need to know it by heart?\n\nSome good comments:\n\nc0r3ntin\n\nIt is complicated, but not on a daily basis. Can this value be addressed ? can it be copied ? can it be moved ? Should it be moved ? There is very few situation where you want to actively to be very specific and need a full understanding. ( templated library writing, hot paths, etc).\n\nMost of the time C++ is not more complicated than java or something. Sadly this is lost on most people. C++ may be the most complex language out there but you can write very good code without caring about the specific.\n\nBigObject o = getBigObject();\n\nInitialization\n\n18 ways now (as of C++17)! - Initialization in C++ is bonkers and the r/cpp thread\n\nTemplates (and Template deduction)\n\nI was quite lost when I saw all the changes for C++17; there are so many details about templates!\n\nThe same situation happens in C++20, where we have a significant and long-awaited improvement: concepts - which revolutionise C++!\n\nYet, if you want to learn templates, it might be overwhelming at first.\n\nABI\n\nWith the growing list of new features, it might be tempting to “start from scratch” and fix old issues in the design of C++. But the principle of the language is that it cannot break old code, so that why the Committee is so restrictive and don’t like to change the way how features are introduced.\n\nThere’s no right answer to this issue, but in any way, it’s good to have a well-discussed topic rather than a rushed move.\n\nWe can complain that C++ is not “shipping” with a cool dependency management system. But the reality is that it might not happen in the foreseeable future. Having a “standard” package manager is a tough choice, especially that it would have to handle so many different platforms and systems where C++ is available.\n\nNot Safe Enough\n\nSome time ago, you could read some of the articles (this and that)where they mentioned:\n\nRoughly 70% of all serious security bugs in the Chrome codebase are memory management and safety bugs, Google engineers said this week.\n\nAnd similarly for Microsoft. Since most of the code is C or C++, then everyone blames C++ for not being safe enough.\n\nOthers areas?\n\nWhat are your main problems with the language?\n\nSo far, we’ve discussed some problems… so how to live with them? Is there a chance to solve those issues?\n\nHow to Stay Sane\n\nThere’s no perfect programming language; every one of them has some issues. Here are my suggestions on how to cope with the problems of Modern C++:\n\nStay positive\n\nUse best guidelines\n\nUse best tools\n\nStay up to date\n\nDon’t open the hood\n\nUse what you need\n\nIncremental change\n\nLast resort: your old code is still safe and compiles\n\nStay positive, the language is evolving\n\nNo one wants to write code using old syntax and constructs. We’ve already seen a lot of complaints about old C++ before C++11. It took almost 13 years (counting from major C++98, not including minor C++03) to came up with the major version: C++11. Now we can be happy that we get back on track, and every three years there will be some changes. At the end of the day, you cannot say that your language is dead and old.\n\nWhile some of the features are huge and can bring confusion or more things to learn, things are more straightforward than harder:\n\nMost of those 1000 new pages that were added after C++03 are for the Standard Library. This means that you have more helpers and sub-systems you can use, without the need to find third-party libraries. That definitely makes your life easier.\n\nFor move semantics, you can rely on library types as they will do the right job for you. For example, you can now safely return std::vector and be sure that it might be moved or even elided and no extra copy will be needed.\n\nFor templates, it’s getting easier and easier. Concepts make code safes, without tricks like SFINAE. What’s more, we have constexpr and auto which makes generic code even simpler (almost like a regular code).\n\nAs for the safety: Hava look here at automatic tools for the safety profile for C++ Guidelines. New safety rules in C++ Core Check | C++ Team Blog. We can expect new and better tools that perform code analysis or even instrumentation to find potential safety issues as fast as possible. Or here Closing the Gap between Rust and C++ Using Principles of Static Analysis - Sunny Chatterjee - CppCon\n\nUse Guidelines\n\nIf you’re lost with many different aspects of C++ code, then you should reach for C++ Core Guidelines. It’s created by the community of dedicated and passionated C++ developers, and the main editors are Herb Sutter and Bjarne Stroustrup.\n\nSee here:\n\nC++ Core Guidelines @Github\n\nAnd here’s a nice looking web site:\n\nC++ Core Guidelines - Website\n\nJust type the issue you are facing (for example return value), and you can easily find the advice - for example: Guideline: Return values\n\nUsing those guidelines will save you a lot of time, and you can learn some good patterns very quickly.\n\nThanks to Clang and also improved development speed in other platforms, we get tools like:\n\nClang Tidy (previously clang- modernise)\n\nClang Format\n\nClang Static Analyzer\n\nVisualAssist\n\nClion/Resharper C++\n\nVisualStudio - tools like C++ Core Checker\n\nPVS Studio\n\nClang Power Tools for Visual Studio\n\nNew C++ Core Check Rules | C++ Team Blog\n\nC++ Core Guidelines checker reference | Microsoft Docs\n\nIntroducing vcperf /timetrace for C++ build time analysis | C++ Team Blog\n\nNew safety rules in C++ Core Check | C++ Team Blog - C++ as safe as Rust?\n\nOr see my article about the other tools: C++ Ecosystem: Compilers, IDEs, Tools, Testing and More\n\nWhile it’s not super great as for other languages (mostly Java-based or .NET based), it’s getting better and better. Bear in mind that because of the complex C++ grammar, it’s tough to implement tools that analyse the code on the fly.\n\nC++ community is very much alive. There are many blogs, books, conferences… and there’s even a chance a local community is in your city!\n\nFor a start, I suggest going to isocpp.org the central place for all of the events/news/articles. Then you might check Meeting C++ and info about local C++ groups. There’s also reddit/cpp where you can read some of the best C++ stories.\n\nAnd there’s also a CppCast - a weekly podcast for C++ developers.\n\nAnd remember about books like:\n\nThe C++ Programming Language, 4th Edition 4th Edition\n\nEffective Modern C++\n\nProgramming: Principles and Practice Using C++\n\nDiscovering Modern C++: An Intensive Course for Scientists, Engineers, and Programmers\n\nA Tour of C++ (C++ In-Depth Series) 2nd Edition\n\nYou can also take a look at the list of suggested C++ Resources:\n\nBartek’s coding blog: Resources\n\nToo many details? Just don’t open the hood.\n\nOne of the reasons C++ has so much power is that it allows you to implement code very close to the metal. You have control over all of the details, memory layout, performance optimisations, etc, etc… At the same time, such abilities increase the complexity of the language.\n\nStill, if you don’t need to go that far, you can stay at a relatively higher level of abstraction.\n\nFor example, there’s no need to write an optional type because you can use std::optional from the Standard Library. If you don’t want to bother with lowe level and error-prone unions you should see std::variant which is a safe alternative.\n\nUse what you need\n\nC++ is a multi-paradigm language; you can use it in many different ways. Recently, I’ve read an interesting comment that said that a Cpp programmer might for years do very well without touching advanced stuff like template metaprogramming or even exceptions. This heavily depends on the code style of the project.\n\nEven such companies like Google limit features of C++, for example, they don’t use exceptions.\n\nThis is a bit of repetition, but if you’re not a library developer, you might not get into troubles with custom move operators or move constructors. Similarly, advances metaprogramming stuff might also not be a crucial part of your code.\n\nIncremental Change\n\nIf you start from scratch or have a small code base then going to C++11/14 should be relatively easy. What about million-line of code, code that was created 20 years (or more!) ago?\n\nJust do it step by step.\n\nAt least for the new code, you should start using Modern C++. Moreover, by applying “The Boy Scout Rule”, you can improve the surrounding code that you touch.\n\nThis will probably result in some mixed code, but still, it’s better than staying with the legacy style only.\n\nLast resort: your old code will still compile!\n\nOne of the reasons why C++ specs are getting larger and larger is that the language is backward compatible. So the committee usually introduces new features, but rarely remove the old stuff. So… your code can still compile. If you don’t want to move and use newer things, then you can stay with your current style.\n\nFrom time to time you’ll get some warnings about deprecated stuff or removed features (like auto_ptr in C++17), but even in that case, you can switch the compiler to target some older C++ standard.\n\nSummary\n\nThis article is partially a rant, partially a ‘glorification.’ I try to see the problematic sides of the language and its evolution process and some positive signs as well.\n\nWhile we can complain about the complexity, pace of changes, etc, I think we cannot say that the language is dead. That’s a good thing! :)\n\nI don’t think you have to rapidly chase the new features and immediately rewrite your existing code. Just try to stay up to date with news, use the features that really improve your work and gradually your code should improve and be more ‘modern’ (however, can that be defined - see meetingcpp article on that)."
    }
}