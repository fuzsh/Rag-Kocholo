{
    "id": "dbpedia_8277_0",
    "rank": 43,
    "data": {
        "url": "https://www.bernardosulzbach.com/page/2/",
        "read_more_link": "",
        "language": "en",
        "title": "",
        "top_image": "https://www.bernardosulzbach.com/favicon-32x32.png",
        "meta_img": "https://www.bernardosulzbach.com/favicon-32x32.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Discourses on computers, software, and mathematics.",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Finding the Maximum of Four Integers\n\nInspired by an analysis of the source code of Rogue, I decided to find out how modern compilers encode selecting the maximum of four integers.\n\nint max(int a, int b, int c, int d) { return a > b ? (a > c ? (a > d ? a : d) : (c > d ? c : d)) : (b > c ? (b > d ? b : d) : (c > d ? c : d)); }\n\nIt is important to note that this is isolated code generation and a modern compiler could probably do better if more context was available.\n\nUsing Clang 5.0, I get the following (with optimizations enabled, of course).\n\n0: 39 f7 cmp edi, esi 2: 0f 4d f7 cmovge esi, edi 5: 39 d6 cmp esi, edx 7: 0f 4c f2 cmovl esi, edx a: 39 ce cmp esi, ecx c: 0f 4c f1 cmovl esi, ecx f: 89 f0 mov eax, esi 11: c3 ret\n\nI will rename the code according to the calling convention used here.\n\na -> edi b -> esi c -> edx d -> ecx\n\nThe result follows with some comments on what the code is doing.\n\ncmp a, b cmovge b, a # If a >= b, assign a to b. # Now b has max(a, b). cmp b, c cmovl b, c # If max(a, b) < c, assign c to b. # Now b has max(max(a, b), c). cmp b, d cmovl b, d # If max(max(a, b), c) < d, assign d to b. # Now b has max(max(max(a, b), c), d). mov eax, b # Return b through eax. ret\n\nI don’t think it can be done in less code than this.\n\nAs one might expect, using C++ and std::max, we get almost identical x86.\n\nExamining Compiler Output 2\n\nIn this post I present a short comparison between the machine code generated by GCC 7.2 and Clang 5.0.0 for the evaluation of a floating point polynomial.\n\nFor both compilers, only -O2 was used, but -O3 produced the same code.\n\nfloat evaluate(float a, float b) { return (a - b + 1.0f) * (a - b) * (a - b - 1.0f); }\n\nGCC\n\nevaluate(float, float): subss xmm0, xmm1 movss xmm2, DWORD PTR .LC0[rip] movaps xmm1, xmm0 addss xmm1, xmm2 mulss xmm1, xmm0 subss xmm0, xmm2 mulss xmm0, xmm1 ret .LC0: .long 1065353216\n\nClang\n\n.LCPI0_0: .long 1065353216 # float 1 .LCPI0_1: .long 3212836864 # float -1 evaluate(float, float): # @evaluate(float, float) subss xmm0, xmm1 movss xmm1, dword ptr [rip + .LCPI0_0] addss xmm1, xmm0 mulss xmm1, xmm0 addss xmm0, dword ptr [rip + .LCPI0_1] mulss xmm0, xmm1 ret\n\nExplanation (for the Clang output)\n\nxmm0 = a xmm1 = b xmm0 = a - b xmm1 = 1.0f xmm1 = a - b + 1.0f xmm1 = (a - b + 1.0f) * (a - b) xmm0 = a - b - 1.0f xmm0 = (a - b - 1.0f) * (a - b + 1.0f) * (a - b)\n\nGCC seems to prefer movaps over movss, even though movss is sufficient in this case. A reason for doing so is that using movaps avoid stalls from partial updates to XMM registers. Clang doesn’t generate movaps, but uses two constants and only addss for them rather than only having one and using subss to subtract one from a register.\n\nAfter benchmarking these alternatives, they had roughly the same throughput.\n\nExamining Compiler Output 1\n\nIn this post I present a short comparison between the machine code generated by Clang 5.0.0 for two different for loops.\n\nSum up to N\n\nThe first function sums from 1 to N and returns the result.\n\nC++\n\nint sumUpTo(int n) { int x = 0; for (int i = 1; i <= n; i++) { x += i; } return x; }\n\nOutput\n\nsumUpTo(int): test edi, edi jle .LBB0_1 lea eax, [rdi - 1] lea ecx, [rdi - 2] imul rcx, rax shr rcx lea eax, [rcx + 2*rdi - 1] ret .LBB0_1: xor eax, eax ret\n\nAs you can see, Clang used a closed formula to evaluate the expression!\n\nWhat should it be\n\n(1 + n)(n) / 2 = (n^2 + n) / 2\n\nWhat Clang does\n\n(n - 1)(n - 2) / 2 + (2n - 1) = (n^2 - 3n + 2) / 2 + (4n - 2) / 2 = (n^2 + n) / 2\n\nIt is important to note that the reason why a compiler would rather evaluate this convoluted expression is that it will not overflow like the first expression would.\n\nSum up to N multiplying by 2\n\nC++\n\nint sumTwiceUpTo(int n) { int x = 0; for (int i = 1; i <= n; i++) { x += 2 * i; } return x; }\n\nOutput\n\nsumTwiceUpTo(int): test edi, edi jle .LBB1_1 lea eax, [rdi - 1] lea ecx, [rdi - 2] imul ecx, eax and ecx, -2 lea eax, [rcx + 4*rdi - 2] ret .LBB1_1: xor eax, eax ret\n\nWhat is is\n\n(1 + n)(n) = (n^2 + n)\n\nWhat Clang does\n\n((n - 1)(n - 2) & 111...0) + 4n - 2 = (n - 1)(n - 2) + 4n - 2 = n^2 + n\n\nAgain, a closed formula!\n\nIt is interesting to note that the and is completely useless here: it is forcing the product (which is always even) into a even number. Also, it requires the multiplication result to be evaluated, so it could add measurable delay.\n\nWunderlist to Taskwarrior\n\nDescription\n\nWunderlist to Taskwarrior is an application that fetches your tasks from Wunderlist and inserts them into Taskwarrior. It can be regularly ran by the operating system to keep Taskwarrior up-to-date.\n\nWhy I Made This\n\nAs I cannot update Taskwarrior when I am not near one of my computers I needed a way to update Taskwarrior while on the road. The solution I found uses Wunderlist as an intermediate. I already used Wunderlist for simple lists such as the weekly groceries but I greatly prefer Taskwarrior over it, so I still use Taskwarrior when I am at my computer.\n\nRelevant Features\n\nSelective Synchronization. Lists starting with “!” are never synchronized.\n\nData Safety. All communication is done via HTTPS.\n\nPersistence. SQLite is used to keep track of what has been synchronized.\n\nI had to decide between a continuous process which would update Taskwarrior or a utility application that would be scheduled to run regularly. I opted for the latter as the application initialization and termination are not so expensive. Currently, I’ve been running it every minute on one of my computers.\n\nThe Code\n\nWunderlist to Taskwarrior was written in Haskell using Stack so it should be easy enough to get a build for your own computer.\n\nThis is the GitHub repository.\n\nMinimum Window Substring\n\nDescription\n\nThis is a post regarding the solution to a substring problem which follows a pattern that is quite common among substring problems: it is solvable with a pair of fast and slow iterators.\n\nThis problem can often appear as an interview question or as part of a competitive programming problem in sites such as LeetCode and Codeforces.\n\nIf this is not possible, we will return the empty string.\n\nProblem Statement\n\nGiven two strings, S and T, find the minimum window in S which will contain all the characters in T (with their frequencies) in linear time.\n\nS T Answer \"\" \"\" \"\" \"\" \"A\" \"\" \"A\" \"\" \"\" \"A\" \"A\" \"A\" \"A\" \"AB\" \"A\" \"ADOBECODEBANC\" \"ABC\" \"BANC\" \"ADOBECODECABANC\" \"ABC\" \"CAB\"\n\nC++ Solution\n\nstring minimum_window_substring(string s, string t) { if (t.empty()) { return \"\"; } // Frequency in the token. unordered_map<char, size_t> tf; for (char c : t) { tf[c]++; } // Frequency in the string. unordered_map<char, size_t> sf; // How many characters we have to match. const auto target = t.size(); const auto n = s.size(); size_t best_i = 0; const auto no_size = numeric_limits<size_t>::max(); size_t best_size = no_size; size_t slow = 0; size_t fast = 0; size_t matched = 0; // Advance fast until we met the target. // Then shrink with slow until we no longer meet the conditions. // As this advances each pointer at most N times, this is O(n). while (slow < n && fast < n) { sf[s[fast]]++; if (sf[s[fast]] <= tf[s[fast]]) { matched++; } fast++; // Here, the range is [slow, fast). while (matched == target && slow < fast) { const size_t match_size = fast - slow; if (match_size < best_size) { best_i = slow; best_size = match_size; } sf[s[slow]]--; if (sf[s[slow]] < tf[s[slow]]) { matched--; } slow++; } } if (best_size == no_size) { return \"\"; } return s.substr(best_i, best_size); }"
    }
}