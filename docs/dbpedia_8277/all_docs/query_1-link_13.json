{
    "id": "dbpedia_8277_1",
    "rank": 13,
    "data": {
        "url": "https://taskwarrior.org/docs/hooks/",
        "read_more_link": "",
        "language": "en",
        "title": "Taskwarrior",
        "top_image": "https://taskwarrior.org/images/favicon.ico",
        "meta_img": "https://taskwarrior.org/images/favicon.ico",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/images/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Hooks v1\n\nThe API defined here is the [Hooks v1] API. Later versions will allow a script to determine which version of the Hooks API is being used.\n\nHooks\n\nA hook system is a way to run other programs/scripts at certain points in Taskwarrior’s execution, so that processing can be influenced. These callout points correspond to locations in the code where some critical processing is occurring. These are called events.\n\nHook scripts are associated with events. When that event occurs, all associated hooks scripts are run. Data is exchanged between Taskwarrior and the hook scripts.\n\nThe hook scripts may be written in any suitable programming language. A typical hook script will read data, perform some function, then write data and diagnostics and exit with a status code.\n\nThere is no configuration required for the hook scripts - their presence, accessibility and execute permission is all that is required.\n\nEvents\n\nHooks are triggered by events, and the list of supported events is kept short.\n\nEventon-launchThis event is triggered at launch, after the initialization of all data structures, but before any processing. This event provides an opportunity to prevent launch.on-exitThis event is triggered after all processing, but immediately before output is displayed, which is the last opportunity to contribute footnotes/errors. This event has no opportunity to modify tasks.on-addThis event is triggered when a new task is created, after the data has been processed, but before the task is saved. This event provides an opportunity to approve, deny, or modify the task being created.on-modifyThis event is triggered when an existing task is modified, after the data has been read and processed, but before the task is saved. This event provides an opportunity to approve, deny, or further change the modification of the task.\n\nTask completion and deletion are considered modifications, indicated by the change to the ‘status’ attribute.\n\nThe Git Model\n\nFollowing the Git model, a hook script need only exist in a specific location, possess a recognizable name, and have execute permission, in order for it to be run.\n\nThe location for hooks scripts is by default ~/.task/hooks, which is itself defined by the rc.data.location setting, and a hooks subdirectory. A hook script must either reside in this location, or be symbolically linked into this location. The location itself may be a symbolic link. The name of the hook script should be of the form:\n\n<event>[<identifier>]\n\nSome examples being:\n\non-add on-add.01 on-add-require-project\n\nThe event at the start of the script name associates the script with that event. The optional identifier allows for multiple scripts associated with the same event.\n\nWhen there are multiple scripts associated with the same event, the order of execution is the collating sequence of the script name. A hook script can be disabled by either removing execute permission, renaming it, or moving it to another location.\n\nInput\n\nInput to hook scripts consists of JSON-formatted objects, one per line, in the Taskwarrior JSON Format which is also used by the export command.\n\n$ task 1 export {\"description\":\"Buy some milk\",\"entry\":\"20141118T050231Z\",\"status\":\"pending\",\"uuid\":\"a360fc44-315c-4366-b70c-ea7e7520b749\"}\n\nThe above example may wrap over several lines, but exported JSON always contains 1 object per line. Whitespace within the line is permitted, per the JSON standard, but the task must occupy only one line of output.\n\nOutput\n\nOutput from a hook script is a combination of a JSON-formatted task and text. Just as the JSON for a task must occupy a single line, so must a single feedback message. Feedback text is optional for a successful hook script, but required for a failing script. If provided it will be displayed by Taskwarrior according to the verbosity setting.\n\nHere is sample output from a hypothetical spell-checking hook script:\n\n{\"description\":\"Buy some milk\",\"entry\":\"20141118T050231Z\",\"status\":\"pending\",\"uuid\":\"a360fc44-315c-4366-b70c-ea7e7520b749\"} Spell checking found no errors.\n\nThe output is a single line JSON object which represents an optionally modified task, and a single line of feedback text to be displayed.\n\nThere may only be one line of JSON, and it must be for the same task that was provided as input.\n\nExit Status\n\nA hook script may exit with a zero status which signals that all is well. A tasks emitted will be added/modified, and any feedback will be shown as a footnote.\n\nA hook script may exit with a non-zero status which signals a problem. This terminates processing. All tasks emitted will be ignored. Feedback is required in this case, and will be shown as an error.\n\nInterfaces\n\nThe hook scripts have different responsibilities, depending on the type of hook. Some are provided with JSON input, some are expected to indicate that processing should continue or stop. All may provide error messages.\n\nEventInputOutputStatus Zero 0Status Non-Zeroon-launchNoneNo JSONOptional feedback becomes footnotesRequired feedback becomes errorsFeedbackProcessing continuesProcessing terminateson-exitJSON for added/modified tasksNo JSONOptional feedback becomes footnotesRequired feedback becomes errorsFeedbackon-addJSON for added taskJSON for added taskJSON for added taskJSON ignoredFeedbackOptional feedback becomes footnotesRequired feedback becomes errorsProcessing continuesProcessing terminateson-modifyJSON for original taskJSON for modified tasksJSON for modified taskJSON ignoredJSON for modified taskFeedbackOptional feedback becomes footnotesRequired feedback becomes errorsProcessing continuesProcessing terminates\n\nThis means that on-launch hooks should expect 0 lines of input, on-exit 0 to many, on-add 1, and on-modify 2.\n\nImpact\n\nThe hook system is visible in several places:\n\nThe diagnostics command will enumerate hook scripts, indicating whether the script is executable. This helps to diagnose hook problems.\n\nIn debug mode (rc.debug=1) the hook debug mode (rc.debug.hooks=1) is automatically set.\n\nHooks have their own debug mode. Setting rc.debug.hooks=1 will show which hook scripts are called, and run time. This will help hook script authors to minimize their runtime.\n\nSetting rc.debug.hooks=2 will also show the input, output and exit status of the hook scripts.\n\nSafety\n\nWith any hook system there are potential problems which involve race conditions, infinite loops and runaway cascading effects. Various measures are taken to mitigate these problems:\n\nMalformed JSON is rejected\n\nCorrect JSON that is not a task is simply ignored by Taskwarrior\n\nPlease note: installing hook scripts can be as dangerous as installing any software, and if you are unsure of what the script does, don’t install it.\n\nExamples\n\nHere are some example uses for hooks. This list is intended as inspiration, and may not represent actual scripts that exist.\n\nPolicy enforcement: referencing issues, description length, project values\n\nShadow files\n\nUser defined special tags\n\nAutomatic priority escalation\n\nAutomated data backup\n\nMaking certain tasks read-only\n\nDisabling features like recurrence or priorities\n\nSpell-checking\n\nPreventing use of profanity\n\nPerforming a sync on launch\n\nThere are example hook scripts installed with Taskwarrior."
    }
}