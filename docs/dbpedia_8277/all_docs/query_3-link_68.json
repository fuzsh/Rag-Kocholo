{
    "id": "dbpedia_8277_3",
    "rank": 68,
    "data": {
        "url": "https://nixos.org/manual/nixos/stable/",
        "read_more_link": "",
        "language": "en",
        "title": "NixOS Manual",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Configuration\n\nThis chapter describes how to configure various aspects of a NixOS machine through the configuration file /etc/nixos/configuration.nix. As described in Changing the Configuration, changes to this file only take effect after you run nixos-rebuild.\n\nTable of Contents\n\nConfiguration Syntax\n\nPackage Management\n\nUser Management\n\nFile Systems\n\nX Window System\n\nWayland\n\nGPU acceleration\n\nXfce Desktop Environment\n\nNetworking\n\nLinux Kernel\n\nSubversion\n\nPantheon Desktop\n\nGNOME Desktop\n\nExternal Bootloader Backends\n\nClevis\n\nGarage\n\nYouTrack\n\nSuwayomi-Server\n\nPlausible\n\nPict-rs\n\nNextcloud\n\nMatomo\n\nLemmy\n\nKeycloak\n\nJitsi Meet\n\nHonk\n\nGrocy\n\nGoToSocial\n\nFileSender\n\nDiscourse\n\nDavis\n\nCastopod\n\nc2FmZQ\n\nAkkoma\n\nsystemd-lock-handler\n\nMeilisearch\n\nYggdrasil\n\nProsody\n\nPleroma\n\nNetbird server\n\nNetbird\n\nMosquitto\n\nJottacloud Command-line Tool\n\nGNS3 Server\n\nFirefox Sync server\n\nDnsmasq\n\nLitestream\n\nPrometheus exporters\n\nparsedmarc\n\nOCS Inventory Agent\n\nGoss\n\nCert Spotter\n\nWeeChat\n\nTaskserver\n\nSourcehut\n\nGitLab\n\nForgejo\n\nApache Kafka\n\nAnki Sync Server\n\nMatrix\n\nMjolnir (Matrix Moderation Tool)\n\nMaubot\n\nMailman\n\nTrezor\n\nEmacs\n\nLivebook\n\nBlackfire profiler\n\nAthens\n\nFlatpak\n\nTigerBeetle\n\nPostgreSQL\n\nFoundationDB\n\nBorgBackup\n\nSSL/TLS Certificates with ACME\n\nOh my ZSH\n\nPlotinus\n\nDigital Bitbox\n\nInput Methods\n\nProfiles\n\nKubernetes\n\nConfiguration Syntax\n\nTable of Contents\n\nNixOS Configuration File\n\nAbstractions\n\nModularity\n\nThe NixOS configuration file /etc/nixos/configuration.nix is actually a Nix expression, which is the Nix package manager’s purely functional language for describing how to build packages and configurations. This means you have all the expressive power of that language at your disposal, including the ability to abstract over common patterns, which is very useful when managing complex systems. The syntax and semantics of the Nix language are fully described in the Nix manual, but here we give a short overview of the most important constructs useful in NixOS configuration files.\n\nNixOS Configuration File\n\nThe NixOS configuration file generally looks like this:\n\n{ config, pkgs, ... }: { /* option definitions */ }\n\nThe first line ({ config, pkgs, ... }:) denotes that this is actually a function that takes at least the two arguments config and pkgs. (These are explained later, in chapter Writing NixOS Modules) The function returns a set of option definitions ({ ... }). These definitions have the form name = value, where name is the name of an option and value is its value. For example,\n\n{ config, pkgs, ... }: { services.httpd.enable = true; services.httpd.adminAddr = \"alice@example.org\"; services.httpd.virtualHosts.localhost.documentRoot = \"/webroot\"; }\n\ndefines a configuration with three option definitions that together enable the Apache HTTP Server with /webroot as the document root.\n\nSets can be nested, and in fact dots in option names are shorthand for defining a set containing another set. For instance, services.httpd.enable defines a set named services that contains a set named httpd, which in turn contains an option definition named enable with value true. This means that the example above can also be written as:\n\n{ config, pkgs, ... }: { services = { httpd = { enable = true; adminAddr = \"alice@example.org\"; virtualHosts = { localhost = { documentRoot = \"/webroot\"; }; }; }; }; }\n\nwhich may be more convenient if you have lots of option definitions that share the same prefix (such as services.httpd).\n\nNixOS checks your option definitions for correctness. For instance, if you try to define an option that doesn’t exist (that is, doesn’t have a corresponding option declaration), nixos-rebuild will give an error like:\n\nThe option `services.httpd.enable' defined in `/etc/nixos/configuration.nix' does not exist.\n\nLikewise, values in option definitions must have a correct type. For instance, services.httpd.enable must be a Boolean (true or false). Trying to give it a value of another type, such as a string, will cause an error:\n\nThe option value `services.httpd.enable' in `/etc/nixos/configuration.nix' is not a boolean.\n\nOptions have various types of values. The most important are:\n\nStrings\n\nStrings are enclosed in double quotes, e.g.\n\n{ networking.hostName = \"dexter\"; }\n\nSpecial characters can be escaped by prefixing them with a backslash (e.g. \\\").\n\nMulti-line strings can be enclosed in double single quotes, e.g.\n\n{ networking.extraHosts = '' 127.0.0.2 other-localhost 10.0.0.1 server ''; }\n\nThe main difference is that it strips from each line a number of spaces equal to the minimal indentation of the string as a whole (disregarding the indentation of empty lines), and that characters like \" and \\ are not special (making it more convenient for including things like shell code). See more info about this in the Nix manual here.\n\nBooleans\n\nThese can be true or false, e.g.\n\n{ networking.firewall.enable = true; networking.firewall.allowPing = false; }\n\nIntegers\n\nFor example,\n\n{ boot.kernel.sysctl.\"net.ipv4.tcp_keepalive_time\" = 60; }\n\n(Note that here the attribute name net.ipv4.tcp_keepalive_time is enclosed in quotes to prevent it from being interpreted as a set named net containing a set named ipv4, and so on. This is because it’s not a NixOS option but the literal name of a Linux kernel setting.)\n\nSets\n\nSets were introduced above. They are name/value pairs enclosed in braces, as in the option definition\n\n{ fileSystems.\"/boot\" = { device = \"/dev/sda1\"; fsType = \"ext4\"; options = [ \"rw\" \"data=ordered\" \"relatime\" ]; }; }\n\nLists\n\nThe important thing to note about lists is that list elements are separated by whitespace, like this:\n\n{ boot.kernelModules = [ \"fuse\" \"kvm-intel\" \"coretemp\" ]; }\n\nList elements can be any other type, e.g. sets:\n\n{ swapDevices = [ { device = \"/dev/disk/by-label/swap\"; } ]; }\n\nPackages\n\nUsually, the packages you need are already part of the Nix Packages collection, which is a set that can be accessed through the function argument pkgs. Typical uses:\n\n{ environment.systemPackages = [ pkgs.thunderbird pkgs.emacs ]; services.postgresql.package = pkgs.postgresql_14; }\n\nThe latter option definition changes the default PostgreSQL package used by NixOS’s PostgreSQL service to 14.x. For more information on packages, including how to add new ones, see the section called “Adding Custom Packages”.\n\nAbstractions\n\nIf you find yourself repeating yourself over and over, it’s time to abstract. Take, for instance, this Apache HTTP Server configuration:\n\n{ services.httpd.virtualHosts = { \"blog.example.org\" = { documentRoot = \"/webroot/blog.example.org\"; adminAddr = \"alice@example.org\"; forceSSL = true; enableACME = true; }; \"wiki.example.org\" = { documentRoot = \"/webroot/wiki.example.org\"; adminAddr = \"alice@example.org\"; forceSSL = true; enableACME = true; }; }; }\n\nIt defines two virtual hosts with nearly identical configuration; the only difference is the document root directories. To prevent this duplication, we can use a let:\n\nlet commonConfig = { adminAddr = \"alice@example.org\"; forceSSL = true; enableACME = true; }; in { services.httpd.virtualHosts = { \"blog.example.org\" = (commonConfig // { documentRoot = \"/webroot/blog.example.org\"; }); \"wiki.example.org\" = (commonConfig // { documentRoot = \"/webroot/wiki.example.org\"; }); }; }\n\nThe let commonConfig = ... defines a variable named commonConfig. The // operator merges two attribute sets, so the configuration of the second virtual host is the set commonConfig extended with the document root option.\n\nYou can write a let wherever an expression is allowed. Thus, you also could have written:\n\n{ services.httpd.virtualHosts = let commonConfig = { /* ... */ }; in { \"blog.example.org\" = (commonConfig // { /* ... */ }); \"wiki.example.org\" = (commonConfig // { /* ... */ }); }; }\n\nbut not { let commonConfig = ...; in ...; } since attributes (as opposed to attribute values) are not expressions.\n\nFunctions provide another method of abstraction. For instance, suppose that we want to generate lots of different virtual hosts, all with identical configuration except for the document root. This can be done as follows:\n\n{ services.httpd.virtualHosts = let makeVirtualHost = webroot: { documentRoot = webroot; adminAddr = \"alice@example.org\"; forceSSL = true; enableACME = true; }; in { \"example.org\" = (makeVirtualHost \"/webroot/example.org\"); \"example.com\" = (makeVirtualHost \"/webroot/example.com\"); \"example.gov\" = (makeVirtualHost \"/webroot/example.gov\"); \"example.nl\" = (makeVirtualHost \"/webroot/example.nl\"); }; }\n\nHere, makeVirtualHost is a function that takes a single argument webroot and returns the configuration for a virtual host. That function is then called for several names to produce the list of virtual host configurations.\n\nModularity\n\nThe NixOS configuration mechanism is modular. If your configuration.nix becomes too big, you can split it into multiple files. Likewise, if you have multiple NixOS configurations (e.g. for different computers) with some commonality, you can move the common configuration into a shared file.\n\nModules have exactly the same syntax as configuration.nix. In fact, configuration.nix is itself a module. You can use other modules by including them from configuration.nix, e.g.:\n\n{ config, pkgs, ... }: { imports = [ ./vpn.nix ./kde.nix ]; services.httpd.enable = true; environment.systemPackages = [ pkgs.emacs ]; # ... }\n\nHere, we include two modules from the same directory, vpn.nix and kde.nix. The latter might look like this:\n\n{ config, pkgs, ... }: { services.xserver.enable = true; services.displayManager.sddm.enable = true; services.xserver.desktopManager.plasma5.enable = true; environment.systemPackages = [ pkgs.vim ]; }\n\nNote that both configuration.nix and kde.nix define the option environment.systemPackages. When multiple modules define an option, NixOS will try to merge the definitions. In the case of environment.systemPackages the lists of packages will be concatenated. The value in configuration.nix is merged last, so for list-type options, it will appear at the end of the merged list. If you want it to appear first, you can use mkBefore:\n\n{ boot.kernelModules = mkBefore [ \"kvm-intel\" ]; }\n\nThis causes the kvm-intel kernel module to be loaded before any other kernel modules.\n\nFor other types of options, a merge may not be possible. For instance, if two modules define services.httpd.adminAddr, nixos-rebuild will give an error:\n\nThe unique option `services.httpd.adminAddr' is defined multiple times, in `/etc/nixos/httpd.nix' and `/etc/nixos/configuration.nix'.\n\nWhen that happens, it’s possible to force one definition take precedence over the others:\n\n{ services.httpd.adminAddr = pkgs.lib.mkForce \"bob@example.org\"; }\n\nWhen using multiple modules, you may need to access configuration values defined in other modules. This is what the config function argument is for: it contains the complete, merged system configuration. That is, config is the result of combining the configurations returned by every module. (If you’re wondering how it’s possible that the (indirect) result of a function is passed as an input to that same function: that’s because Nix is a “lazy” language — it only computes values when they are needed. This works as long as no individual configuration value depends on itself.)\n\nFor example, here is a module that adds some packages to environment.systemPackages only if services.xserver.enable is set to true somewhere else:\n\n{ config, pkgs, ... }: { environment.systemPackages = if config.services.xserver.enable then [ pkgs.firefox pkgs.thunderbird ] else [ ]; }\n\nWith multiple modules, it may not be obvious what the final value of a configuration option is. The command nixos-option allows you to find out:\n\n$ nixos-option services.xserver.enable true $ nixos-option boot.kernelModules [ \"tun\" \"ipv6\" \"loop\" ... ]\n\nInteractive exploration of the configuration is possible using nix repl, a read-eval-print loop for Nix expressions. A typical use:\n\n$ nix repl '<nixpkgs/nixos>' nix-repl> config.networking.hostName \"mandark\" nix-repl> map (x: x.hostName) config.services.httpd.virtualHosts [ \"example.org\" \"example.gov\" ]\n\nWhile abstracting your configuration, you may find it useful to generate modules using code, instead of writing files. The example below would have the same effect as importing a file which sets those options.\n\n{ config, pkgs, ... }: let netConfig = hostName: { networking.hostName = hostName; networking.useDHCP = false; }; in { imports = [ (netConfig \"nixos.localdomain\") ]; }\n\nPackage Management\n\nTable of Contents\n\nDeclarative Package Management\n\nAd-Hoc Package Management\n\nThis section describes how to add additional packages to your system. NixOS has two distinct styles of package management:\n\nDeclarative, where you declare what packages you want in your configuration.nix. Every time you run nixos-rebuild, NixOS will ensure that you get a consistent set of binaries corresponding to your specification.\n\nAd hoc, where you install, upgrade and uninstall packages via the nix-env command. This style allows mixing packages from different Nixpkgs versions. It’s the only choice for non-root users.\n\nDeclarative Package Management\n\nWith declarative package management, you specify which packages you want on your system by setting the option environment.systemPackages. For instance, adding the following line to configuration.nix enables the Mozilla Thunderbird email application:\n\n{ environment.systemPackages = [ pkgs.thunderbird ]; }\n\nThe effect of this specification is that the Thunderbird package from Nixpkgs will be built or downloaded as part of the system when you run nixos-rebuild switch.\n\nNote\n\nSome packages require additional global configuration such as D-Bus or systemd service registration so adding them to environment.systemPackages might not be sufficient. You are advised to check the list of options whether a NixOS module for the package does not exist.\n\nYou can get a list of the available packages as follows:\n\n$ nix-env -qaP '*' --description nixos.firefox firefox-23.0 Mozilla Firefox - the browser, reloaded ...\n\nThe first column in the output is the attribute name, such as nixos.thunderbird.\n\nNote: the nixos prefix tells us that we want to get the package from the nixos channel and works only in CLI tools. In declarative configuration use pkgs prefix (variable).\n\nTo “uninstall” a package, remove it from environment.systemPackages and run nixos-rebuild switch.\n\nCustomising Packages\n\nThe Nixpkgs configuration for a NixOS system is set by the nixpkgs.config option.\n\nExample 5. Globally allow unfree packages\n\n{ nixpkgs.config = { allowUnfree = true; }; }\n\nNote\n\nThis only allows unfree software in the given NixOS configuration. For users invoking Nix commands such as nix-build, Nixpkgs is configured independently. See the Nixpkgs manual section on global configuration for details.\n\nSome packages in Nixpkgs have options to enable or disable optional functionality, or change other aspects of the package.\n\nWarning\n\nUnfortunately, Nixpkgs currently lacks a way to query available package configuration options.\n\nNote\n\nFor example, many packages come with extensions one might add. Examples include:\n\npassExtensions.pass-otp\n\npython310Packages.requests\n\nYou can use them like this:\n\n{ environment.systemPackages = with pkgs; [ sl (pass.withExtensions (subpkgs: with subpkgs; [ pass-audit pass-otp pass-genphrase ])) (python3.withPackages (subpkgs: with subpkgs; [ requests ])) cowsay ]; }\n\nApart from high-level options, it’s possible to tweak a package in almost arbitrary ways, such as changing or disabling dependencies of a package. For instance, the Emacs package in Nixpkgs by default has a dependency on GTK 2. If you want to build it against GTK 3, you can specify that as follows:\n\n{ environment.systemPackages = [ (pkgs.emacs.override { gtk = pkgs.gtk3; }) ]; }\n\nThe function override performs the call to the Nix function that produces Emacs, with the original arguments amended by the set of arguments specified by you. So here the function argument gtk gets the value pkgs.gtk3, causing Emacs to depend on GTK 3. (The parentheses are necessary because in Nix, function application binds more weakly than list construction, so without them, environment.systemPackages would be a list with two elements.)\n\nEven greater customisation is possible using the function overrideAttrs. While the override mechanism above overrides the arguments of a package function, overrideAttrs allows changing the attributes passed to mkDerivation. This permits changing any aspect of the package, such as the source code. For instance, if you want to override the source code of Emacs, you can say:\n\n{ environment.systemPackages = [ (pkgs.emacs.overrideAttrs (oldAttrs: { name = \"emacs-25.0-pre\"; src = /path/to/my/emacs/tree; })) ]; }\n\nHere, overrideAttrs takes the Nix derivation specified by pkgs.emacs and produces a new derivation in which the original’s name and src attribute have been replaced by the given values by re-calling stdenv.mkDerivation. The original attributes are accessible via the function argument, which is conventionally named oldAttrs.\n\nThe overrides shown above are not global. They do not affect the original package; other packages in Nixpkgs continue to depend on the original rather than the customised package. This means that if another package in your system depends on the original package, you end up with two instances of the package. If you want to have everything depend on your customised instance, you can apply a global override as follows:\n\n{ nixpkgs.config.packageOverrides = pkgs: { emacs = pkgs.emacs.override { gtk = pkgs.gtk3; }; }; }\n\nThe effect of this definition is essentially equivalent to modifying the emacs attribute in the Nixpkgs source tree. Any package in Nixpkgs that depends on emacs will be passed your customised instance. (However, the value pkgs.emacs in nixpkgs.config.packageOverrides refers to the original rather than overridden instance, to prevent an infinite recursion.)\n\nAdding Custom Packages\n\nIt’s possible that a package you need is not available in NixOS. In that case, you can do two things. Either you can package it with Nix, or you can try to use prebuilt packages from upstream. Due to the peculiarities of NixOS, it is important to note that building software from source is often easier than using pre-built executables.\n\nBuilding with Nix\n\nThis can be done either in-tree or out-of-tree. For an in-tree build, you can clone the Nixpkgs repository, add the package to your clone, and (optionally) submit a patch or pull request to have it accepted into the main Nixpkgs repository. This is described in detail in the Nixpkgs manual. In short, you clone Nixpkgs:\n\n$ git clone https://github.com/NixOS/nixpkgs $ cd nixpkgs\n\nThen you write and test the package as described in the Nixpkgs manual. Finally, you add it to environment.systemPackages, e.g.\n\n{ environment.systemPackages = [ pkgs.my-package ]; }\n\nand you run nixos-rebuild, specifying your own Nixpkgs tree:\n\n# nixos-rebuild switch -I nixpkgs=/path/to/my/nixpkgs\n\nThe second possibility is to add the package outside of the Nixpkgs tree. For instance, here is how you specify a build of the GNU Hello package directly in configuration.nix:\n\n{ environment.systemPackages = let my-hello = with pkgs; stdenv.mkDerivation rec { name = \"hello-2.8\"; src = fetchurl { url = \"mirror://gnu/hello/${name}.tar.gz\"; hash = \"sha256-5rd/gffPfa761Kn1tl3myunD8TuM+66oy1O7XqVGDXM=\"; }; }; in [ my-hello ]; }\n\nOf course, you can also move the definition of my-hello into a separate Nix expression, e.g.\n\n{ environment.systemPackages = [ (import ./my-hello.nix) ]; }\n\nwhere my-hello.nix contains:\n\nwith import <nixpkgs> {}; # bring all of Nixpkgs into scope stdenv.mkDerivation rec { name = \"hello-2.8\"; src = fetchurl { url = \"mirror://gnu/hello/${name}.tar.gz\"; hash = \"sha256-5rd/gffPfa761Kn1tl3myunD8TuM+66oy1O7XqVGDXM=\"; }; }\n\nThis allows testing the package easily:\n\n$ nix-build my-hello.nix $ ./result/bin/hello Hello, world!\n\nUsing pre-built executables\n\nMost pre-built executables will not work on NixOS. There are two notable exceptions: flatpaks and AppImages. For flatpaks see the dedicated section. AppImages will not run “as-is” on NixOS. First you need to install appimage-run: add to /etc/nixos/configuration.nix\n\n{ environment.systemPackages = [ pkgs.appimage-run ]; }\n\nThen instead of running the AppImage “as-is”, run appimage-run foo.appimage.\n\nTo make other pre-built executables work on NixOS, you need to package them with Nix and special helpers like autoPatchelfHook or buildFHSEnv. See the Nixpkgs manual for details. This is complex and often doing a source build is easier.\n\nAd-Hoc Package Management\n\nWith the command nix-env, you can install and uninstall packages from the command line. For instance, to install Mozilla Thunderbird:\n\n$ nix-env -iA nixos.thunderbird\n\nIf you invoke this as root, the package is installed in the Nix profile /nix/var/nix/profiles/default and visible to all users of the system; otherwise, the package ends up in /nix/var/nix/profiles/per-user/username/profile and is not visible to other users. The -A flag specifies the package by its attribute name; without it, the package is installed by matching against its package name (e.g. thunderbird). The latter is slower because it requires matching against all available Nix packages, and is ambiguous if there are multiple matching packages.\n\nPackages come from the NixOS channel. You typically upgrade a package by updating to the latest version of the NixOS channel:\n\n$ nix-channel --update nixos\n\nand then running nix-env -i again. Other packages in the profile are not affected; this is the crucial difference with the declarative style of package management, where running nixos-rebuild switch causes all packages to be updated to their current versions in the NixOS channel. You can however upgrade all packages for which there is a newer version by doing:\n\n$ nix-env -u '*'\n\nA package can be uninstalled using the -e flag:\n\n$ nix-env -e thunderbird\n\nFinally, you can roll back an undesirable nix-env action:\n\n$ nix-env --rollback\n\nnix-env has many more flags. For details, see the nix-env(1) manpage or the Nix manual.\n\nUser Management\n\nTable of Contents\n\nCreate users and groups with systemd-sysusers\n\nNixOS supports both declarative and imperative styles of user management. In the declarative style, users are specified in configuration.nix. For instance, the following states that a user account named alice shall exist:\n\n{ users.users.alice = { isNormalUser = true; home = \"/home/alice\"; description = \"Alice Foobar\"; extraGroups = [ \"wheel\" \"networkmanager\" ]; openssh.authorizedKeys.keys = [ \"ssh-dss AAAAB3Nza... alice@foobar\" ]; }; }\n\nNote that alice is a member of the wheel and networkmanager groups, which allows her to use sudo to execute commands as root and to configure the network, respectively. Also note the SSH public key that allows remote logins with the corresponding private key. Users created in this way do not have a password by default, so they cannot log in via mechanisms that require a password. However, you can use the passwd program to set a password, which is retained across invocations of nixos-rebuild.\n\nIf you set users.mutableUsers to false, then the contents of /etc/passwd and /etc/group will be congruent to your NixOS configuration. For instance, if you remove a user from users.users and run nixos-rebuild, the user account will cease to exist. Also, imperative commands for managing users and groups, such as useradd, are no longer available. Passwords may still be assigned by setting the user’s hashedPassword option. A hashed password can be generated using mkpasswd.\n\nA user ID (uid) is assigned automatically. You can also specify a uid manually by adding\n\n{ uid = 1000; }\n\nto the user specification.\n\nGroups can be specified similarly. The following states that a group named students shall exist:\n\n{ users.groups.students.gid = 1000; }\n\nAs with users, the group ID (gid) is optional and will be assigned automatically if it’s missing.\n\nIn the imperative style, users and groups are managed by commands such as useradd, groupmod and so on. For instance, to create a user account named alice:\n\n# useradd -m alice\n\nTo make all nix tools available to this new user use `su - USER` which opens a login shell (==shell that loads the profile) for given user. This will create the ~/.nix-defexpr symlink. So run:\n\n# su - alice -c \"true\"\n\nThe flag -m causes the creation of a home directory for the new user, which is generally what you want. The user does not have an initial password and therefore cannot log in. A password can be set using the passwd utility:\n\n# passwd alice Enter new UNIX password: *** Retype new UNIX password: ***\n\nA user can be deleted using userdel:\n\n# userdel -r alice\n\nThe flag -r deletes the user’s home directory. Accounts can be modified using usermod. Unix groups can be managed using groupadd, groupmod and groupdel.\n\nCreate users and groups with systemd-sysusers\n\nNote\n\nThis is experimental.\n\nInstead of using a custom perl script to create users and groups, you can use systemd-sysusers:\n\n{ systemd.sysusers.enable = true; }\n\nThe primary benefit of this is to remove a dependency on perl.\n\nFile Systems\n\nTable of Contents\n\nLUKS-Encrypted File Systems\n\nSSHFS File Systems\n\nOverlayfs\n\nYou can define file systems using the fileSystems configuration option. For instance, the following definition causes NixOS to mount the Ext4 file system on device /dev/disk/by-label/data onto the mount point /data:\n\n{ fileSystems.\"/data\" = { device = \"/dev/disk/by-label/data\"; fsType = \"ext4\"; }; }\n\nThis will create an entry in /etc/fstab, which will generate a corresponding systemd.mount unit via systemd-fstab-generator. The filesystem will be mounted automatically unless \"noauto\" is present in options. \"noauto\" filesystems can be mounted explicitly using systemctl e.g. systemctl start data.mount. Mount points are created automatically if they don’t already exist. For device, it’s best to use the topology-independent device aliases in /dev/disk/by-label and /dev/disk/by-uuid, as these don’t change if the topology changes (e.g. if a disk is moved to another IDE controller).\n\nYou can usually omit the file system type (fsType), since mount can usually detect the type and load the necessary kernel module automatically. However, if the file system is needed at early boot (in the initial ramdisk) and is not ext2, ext3 or ext4, then it’s best to specify fsType to ensure that the kernel module is available.\n\nNote\n\nSystem startup will fail if any of the filesystems fails to mount, dropping you to the emergency shell. You can make a mount asynchronous and non-critical by adding options = [ \"nofail\" ];.\n\nLUKS-Encrypted File Systems\n\nNixOS supports file systems that are encrypted using LUKS (Linux Unified Key Setup). For example, here is how you create an encrypted Ext4 file system on the device /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d:\n\n# cryptsetup luksFormat /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d WARNING! ======== This will overwrite data on /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d irrevocably. Are you sure? (Type uppercase yes): YES Enter LUKS passphrase: *** Verify passphrase: *** # cryptsetup luksOpen /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d crypted Enter passphrase for /dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d: *** # mkfs.ext4 /dev/mapper/crypted\n\nThe LUKS volume should be automatically picked up by nixos-generate-config, but you might want to verify that your hardware-configuration.nix looks correct. To manually ensure that the system is automatically mounted at boot time as /, add the following to configuration.nix:\n\n{ boot.initrd.luks.devices.crypted.device = \"/dev/disk/by-uuid/3f6b0024-3a44-4fde-a43a-767b872abe5d\"; fileSystems.\"/\".device = \"/dev/mapper/crypted\"; }\n\nShould grub be used as bootloader, and /boot is located on an encrypted partition, it is necessary to add the following grub option:\n\n{ boot.loader.grub.enableCryptodisk = true; }\n\nFIDO2\n\nNixOS also supports unlocking your LUKS-Encrypted file system using a FIDO2 compatible token.\n\nWithout systemd in initrd\n\nIn the following example, we will create a new FIDO2 credential and add it as a new key to our existing device /dev/sda2:\n\n# export FIDO2_LABEL=\"/dev/sda2 @ $HOSTNAME\" # fido2luks credential \"$FIDO2_LABEL\" f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7 # fido2luks -i add-key /dev/sda2 f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7 Password: Password (again): Old password: Old password (again): Added to key to device /dev/sda2, slot: 2\n\nTo ensure that this file system is decrypted using the FIDO2 compatible key, add the following to configuration.nix:\n\n{ boot.initrd.luks.fido2Support = true; boot.initrd.luks.devices.\"/dev/sda2\".fido2.credential = \"f1d00200108b9d6e849a8b388da457688e3dd653b4e53770012d8f28e5d3b269865038c346802f36f3da7278b13ad6a3bb6a1452e24ebeeaa24ba40eef559b1b287d2a2f80b7\"; }\n\nYou can also use the FIDO2 passwordless setup, but for security reasons, you might want to enable it only when your device is PIN protected, such as Trezor.\n\n{ boot.initrd.luks.devices.\"/dev/sda2\".fido2.passwordLess = true; }\n\nsystemd Stage 1\n\nIf systemd stage 1 is enabled, it handles unlocking of LUKS-enrypted volumes during boot. The following example enables systemd stage1 and adds support for unlocking the existing LUKS2 volume root using any enrolled FIDO2 compatible tokens.\n\n{ boot.initrd = { luks.devices.root = { crypttabExtraOpts = [ \"fido2-device=auto\" ]; device = \"/dev/sda2\"; }; systemd.enable = true; }; }\n\nAll tokens that should be used for unlocking the LUKS2-encrypted volume must first be enrolled using systemd-cryptenroll. In the following example, a new key slot for the first discovered token is added to the LUKS volume.\n\n# systemd-cryptenroll --fido2-device=auto /dev/sda2\n\nExisting key slots are left intact, unless --wipe-slot= is specified. It is recommened to add a recovery key that should be stored in a secure physical location and can be entered wherever a password would be entered.\n\n# systemd-cryptenroll --recovery-key /dev/sda2\n\nSSHFS File Systems\n\nSSHFS is a FUSE filesystem that allows easy access to directories on a remote machine using the SSH File Transfer Protocol (SFTP). It means that if you have SSH access to a machine, no additional setup is needed to mount a directory.\n\nInteractive mounting\n\nIn NixOS, SSHFS is packaged as sshfs. Once installed, mounting a directory interactively is simple as running:\n\n$ sshfs my-user@example.com:/my-dir /mnt/my-dir\n\nLike any other FUSE file system, the directory is unmounted using:\n\n$ fusermount -u /mnt/my-dir\n\nNon-interactive mounting\n\nMounting non-interactively requires some precautions because sshfs will run at boot and under a different user (root). For obvious reason, you can’t input a password, so public key authentication using an unencrypted key is needed. To create a new key without a passphrase you can do:\n\n$ ssh-keygen -t ed25519 -P '' -f example-key Generating public/private ed25519 key pair. Your identification has been saved in example-key Your public key has been saved in example-key.pub The key fingerprint is: SHA256:yjxl3UbTn31fLWeyLYTAKYJPRmzknjQZoyG8gSNEoIE my-user@workstation\n\nTo keep the key safe, change the ownership to root:root and make sure the permissions are 600: OpenSSH normally refuses to use the key if it’s not well-protected.\n\nThe file system can be configured in NixOS via the usual fileSystems option. Here’s a typical setup:\n\n{ fileSystems.\"/mnt/my-dir\" = { device = \"my-user@example.com:/my-dir/\"; fsType = \"sshfs\"; options = [ # Filesystem options \"allow_other\" # for non-root access \"_netdev\" # this is a network fs \"x-systemd.automount\" # mount on demand # SSH options \"reconnect\" # handle connection drops \"ServerAliveInterval=15\" # keep connections alive \"IdentityFile=/var/secrets/example-key\" ]; }; }\n\nMore options from ssh_config(5) can be given as well, for example you can change the default SSH port or specify a jump proxy:\n\n{ options = [ \"ProxyJump=bastion@example.com\" \"Port=22\" ]; }\n\nIt’s also possible to change the ssh command used by SSHFS to connect to the server. For example:\n\n{ options = [ (builtins.replaceStrings [\" \"] [\"\\\\040\"] \"ssh_command=${pkgs.openssh}/bin/ssh -v -L 8080:localhost:80\") ]; }\n\nNote\n\nThe escaping of spaces is needed because every option is written to the /etc/fstab file, which is a space-separated table.\n\nTroubleshooting\n\nIf you’re having a hard time figuring out why mounting is failing, you can add the option \"debug\". This enables a verbose log in SSHFS that you can access via:\n\n$ journalctl -u $(systemd-escape -p /mnt/my-dir/).mount Jun 22 11:41:18 workstation mount[87790]: SSHFS version 3.7.1 Jun 22 11:41:18 workstation mount[87793]: executing <ssh> <-x> <-a> <-oClearAllForwardings=yes> <-oServerAliveInterval=15> <-oIdentityFile=/var/secrets/wrong-key> <-2> <my-user@example.com> <-s> <sftp> Jun 22 11:41:19 workstation mount[87793]: my-user@example.com: Permission denied (publickey). Jun 22 11:41:19 workstation mount[87790]: read: Connection reset by peer Jun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Mount process exited, code=exited, status=1/FAILURE Jun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Failed with result 'exit-code'. Jun 22 11:41:19 workstation systemd[1]: Failed to mount /mnt/my-dir. Jun 22 11:41:19 workstation systemd[1]: mnt-my\\x2ddir.mount: Consumed 54ms CPU time, received 2.3K IP traffic, sent 2.7K IP traffic.\n\nNote\n\nIf the mount point contains special characters it needs to be escaped using systemd-escape. This is due to the way systemd converts paths into unit names.\n\nOverlayfs\n\nNixOS offers a convenient abstraction to create both read-only as well writable overlays.\n\n{ fileSystems = { \"/writable-overlay\" = { overlay = { lowerdir = [ writableOverlayLowerdir ]; upperdir = \"/.rw-writable-overlay/upper\"; workdir = \"/.rw-writable-overlay/work\"; }; # Mount the writable overlay in the initrd. neededForBoot = true; }; \"/readonly-overlay\".overlay.lowerdir = [ writableOverlayLowerdir writableOverlayLowerdir2 ]; }; }\n\nIf upperdir and workdir are not null, they will be created before the overlay is mounted.\n\nTo mount an overlay as read-only, you need to provide at least two lowerdirs.\n\nX Window System\n\nTable of Contents\n\nAuto-login\n\nIntel Graphics drivers\n\nProprietary NVIDIA drivers\n\nProprietary AMD drivers\n\nTouchpads\n\nGTK/Qt themes\n\nCustom XKB layouts\n\nThe X Window System (X11) provides the basis of NixOS’ graphical user interface. It can be enabled as follows:\n\n{ services.xserver.enable = true; }\n\nThe X server will automatically detect and use the appropriate video driver from a set of X.org drivers (such as vesa and intel). You can also specify a driver manually, e.g.\n\n{ services.xserver.videoDrivers = [ \"r128\" ]; }\n\nto enable X.org’s xf86-video-r128 driver.\n\nYou also need to enable at least one desktop or window manager. Otherwise, you can only log into a plain undecorated xterm window. Thus you should pick one or more of the following lines:\n\n{ services.xserver.desktopManager.plasma5.enable = true; services.xserver.desktopManager.xfce.enable = true; services.xserver.desktopManager.gnome.enable = true; services.xserver.desktopManager.mate.enable = true; services.xserver.windowManager.xmonad.enable = true; services.xserver.windowManager.twm.enable = true; services.xserver.windowManager.icewm.enable = true; services.xserver.windowManager.i3.enable = true; services.xserver.windowManager.herbstluftwm.enable = true; }\n\nNixOS’s default display manager (the program that provides a graphical login prompt and manages the X server) is LightDM. You can select an alternative one by picking one of the following lines:\n\n{ services.displayManager.sddm.enable = true; services.xserver.displayManager.gdm.enable = true; }\n\nYou can set the keyboard layout (and optionally the layout variant):\n\n{ services.xserver.xkb.layout = \"de\"; services.xserver.xkb.variant = \"neo\"; }\n\nThe X server is started automatically at boot time. If you don’t want this to happen, you can set:\n\n{ services.xserver.autorun = false; }\n\nThe X server can then be started manually:\n\n# systemctl start display-manager.service\n\nOn 64-bit systems, if you want OpenGL for 32-bit programs such as in Wine, you should also set the following:\n\n{ hardware.opengl.driSupport32Bit = true; }\n\nAuto-login\n\nThe x11 login screen can be skipped entirely, automatically logging you into your window manager and desktop environment when you boot your computer.\n\nThis is especially helpful if you have disk encryption enabled. Since you already have to provide a password to decrypt your disk, entering a second password to login can be redundant.\n\nTo enable auto-login, you need to define your default window manager and desktop environment. If you wanted no desktop environment and i3 as your your window manager, you’d define:\n\n{ services.displayManager.defaultSession = \"none+i3\"; }\n\nEvery display manager in NixOS supports auto-login, here is an example using lightdm for a user alice:\n\n{ services.xserver.displayManager.lightdm.enable = true; services.displayManager.autoLogin.enable = true; services.displayManager.autoLogin.user = \"alice\"; }\n\nIntel Graphics drivers\n\nThere are two choices for Intel Graphics drivers in X.org: modesetting (included in the xorg-server itself) and intel (provided by the package xf86-video-intel).\n\nThe default and recommended is modesetting. It is a generic driver which uses the kernel mode setting (KMS) mechanism. It supports Glamor (2D graphics acceleration via OpenGL) and is actively maintained but may perform worse in some cases (like in old chipsets).\n\nThe second driver, intel, is specific to Intel GPUs, but not recommended by most distributions: it lacks several modern features (for example, it doesn’t support Glamor) and the package hasn’t been officially updated since 2015.\n\nThe results vary depending on the hardware, so you may have to try both drivers. Use the option services.xserver.videoDrivers to set one. The recommended configuration for modern systems is:\n\n{ services.xserver.videoDrivers = [ \"modesetting\" ]; }\n\nIf you experience screen tearing no matter what, this configuration was reported to resolve the issue:\n\n{ services.xserver.videoDrivers = [ \"intel\" ]; services.xserver.deviceSection = '' Option \"DRI\" \"2\" Option \"TearFree\" \"true\" ''; }\n\nNote that this will likely downgrade the performance compared to modesetting or intel with DRI 3 (default).\n\nProprietary NVIDIA drivers\n\nNVIDIA provides a proprietary driver for its graphics cards that has better 3D performance than the X.org drivers. It is not enabled by default because it’s not free software. You can enable it as follows:\n\n{ services.xserver.videoDrivers = [ \"nvidia\" ]; }\n\nIf you have an older card, you may have to use one of the legacy drivers:\n\n{ hardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.legacy_470; hardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.legacy_390; hardware.nvidia.package = config.boot.kernelPackages.nvidiaPackages.legacy_340; }\n\nYou may need to reboot after enabling this driver to prevent a clash with other kernel modules.\n\nProprietary AMD drivers\n\nAMD provides a proprietary driver for its graphics cards that is not enabled by default because it’s not Free Software, is often broken in nixpkgs and as of this writing doesn’t offer more features or performance. If you still want to use it anyway, you need to explicitly set:\n\n{ services.xserver.videoDrivers = [ \"amdgpu-pro\" ]; }\n\nYou will need to reboot after enabling this driver to prevent a clash with other kernel modules.\n\nTouchpads\n\nSupport for Synaptics touchpads (found in many laptops such as the Dell Latitude series) can be enabled as follows:\n\n{ services.libinput.enable = true; }\n\nThe driver has many options (see Appendix A). For instance, the following disables tap-to-click behavior:\n\n{ services.libinput.touchpad.tapping = false; }\n\nNote: the use of services.xserver.synaptics is deprecated since NixOS 17.09.\n\nGTK/Qt themes\n\nGTK themes can be installed either to user profile or system-wide (via environment.systemPackages). To make Qt 5 applications look similar to GTK ones, you can use the following configuration:\n\n{ qt.enable = true; qt.platformTheme = \"gtk2\"; qt.style = \"gtk2\"; }\n\nCustom XKB layouts\n\nIt is possible to install custom XKB keyboard layouts using the option services.xserver.xkb.extraLayouts.\n\nAs a first example, we are going to create a layout based on the basic US layout, with an additional layer to type some greek symbols by pressing the right-alt key.\n\nCreate a file called us-greek with the following content (under a directory called symbols; it’s an XKB peculiarity that will help with testing):\n\nxkb_symbols \"us-greek\" { include \"us(basic)\" // includes the base US keys include \"level3(ralt_switch)\" // configures right alt as a third level switch key <LatA> { [ a, A, Greek_alpha ] }; key <LatB> { [ b, B, Greek_beta ] }; key <LatG> { [ g, G, Greek_gamma ] }; key <LatD> { [ d, D, Greek_delta ] }; key <LatZ> { [ z, Z, Greek_zeta ] }; };\n\nA minimal layout specification must include the following:\n\n{ services.xserver.xkb.extraLayouts.us-greek = { description = \"US layout with alt-gr greek\"; languages = [ \"eng\" ]; symbolsFile = /yourpath/symbols/us-greek; }; }\n\nNote\n\nThe name (after extraLayouts.) should match the one given to the xkb_symbols block.\n\nApplying this customization requires rebuilding several packages, and a broken XKB file can lead to the X session crashing at login. Therefore, you’re strongly advised to test your layout before applying it:\n\n$ nix-shell -p xorg.xkbcomp $ setxkbmap -I/yourpath us-greek -print | xkbcomp -I/yourpath - $DISPLAY\n\nYou can inspect the predefined XKB files for examples:\n\n$ echo \"$(nix-build --no-out-link '<nixpkgs>' -A xorg.xkeyboardconfig)/etc/X11/xkb/\"\n\nOnce the configuration is applied, and you did a logout/login cycle, the layout should be ready to use. You can try it by e.g. running setxkbmap us-greek and then type <alt>+a (it may not get applied in your terminal straight away). To change the default, the usual services.xserver.xkb.layout option can still be used.\n\nA layout can have several other components besides xkb_symbols, for example we will define new keycodes for some multimedia key and bind these to some symbol.\n\nUse the xev utility from pkgs.xorg.xev to find the codes of the keys of interest, then create a media-key file to hold the keycodes definitions\n\nxkb_keycodes \"media\" { <volUp> = 123; <volDown> = 456; }\n\nNow use the newly define keycodes in media-sym:\n\nxkb_symbols \"media\" { key.type = \"ONE_LEVEL\"; key <volUp> { [ XF86AudioLowerVolume ] }; key <volDown> { [ XF86AudioRaiseVolume ] }; }\n\nAs before, to install the layout do\n\n{ services.xserver.xkb.extraLayouts.media = { description = \"Multimedia keys remapping\"; languages = [ \"eng\" ]; symbolsFile = /path/to/media-key; keycodesFile = /path/to/media-sym; }; }\n\nNote\n\nThe function pkgs.writeText <filename> <content> can be useful if you prefer to keep the layout definitions inside the NixOS configuration.\n\nUnfortunately, the Xorg server does not (currently) support setting a keymap directly but relies instead on XKB rules to select the matching components (keycodes, types, …) of a layout. This means that components other than symbols won’t be loaded by default. As a workaround, you can set the keymap using setxkbmap at the start of the session with:\n\n{ services.xserver.displayManager.sessionCommands = \"setxkbmap -keycodes media\"; }\n\nIf you are manually starting the X server, you should set the argument -xkbdir /etc/X11/xkb, otherwise X won’t find your layout files. For example with xinit run\n\n$ xinit -- -xkbdir /etc/X11/xkb\n\nTo learn how to write layouts take a look at the XKB documentation . More example layouts can also be found here .\n\nWayland\n\nWhile X11 (see X Window System) is still the primary display technology on NixOS, Wayland support is steadily improving. Where X11 separates the X Server and the window manager, on Wayland those are combined: a Wayland Compositor is like an X11 window manager, but also embeds the Wayland ‘Server’ functionality. This means it is sufficient to install a Wayland Compositor such as sway without separately enabling a Wayland server:\n\n{ programs.sway.enable = true; }\n\nThis installs the sway compositor along with some essential utilities. Now you can start sway from the TTY console.\n\nIf you are using a wlroots-based compositor, like sway, and want to be able to share your screen, you might want to activate this option:\n\n{ xdg.portal.wlr.enable = true; }\n\nand configure Pipewire using services.pipewire.enable and related options.\n\nGPU acceleration\n\nTable of Contents\n\nOpenCL\n\nVulkan\n\nVA-API\n\nCommon issues\n\nNixOS provides various APIs that benefit from GPU hardware acceleration, such as VA-API and VDPAU for video playback; OpenGL and Vulkan for 3D graphics; and OpenCL for general-purpose computing. This chapter describes how to set up GPU hardware acceleration (as far as this is not done automatically) and how to verify that hardware acceleration is indeed used.\n\nMost of the aforementioned APIs are agnostic with regards to which display server is used. Consequently, these instructions should apply both to the X Window System and Wayland compositors.\n\nOpenCL\n\nOpenCL is a general compute API. It is used by various applications such as Blender and Darktable to accelerate certain operations.\n\nOpenCL applications load drivers through the Installable Client Driver (ICD) mechanism. In this mechanism, an ICD file specifies the path to the OpenCL driver for a particular GPU family. In NixOS, there are two ways to make ICD files visible to the ICD loader. The first is through the OCL_ICD_VENDORS environment variable. This variable can contain a directory which is scanned by the ICL loader for ICD files. For example:\n\n$ export \\ OCL_ICD_VENDORS=`nix-build '<nixpkgs>' --no-out-link -A rocmPackages.clr.icd`/etc/OpenCL/vendors/\n\nThe second mechanism is to add the OpenCL driver package to hardware.opengl.extraPackages. This links the ICD file under /run/opengl-driver, where it will be visible to the ICD loader.\n\nThe proper installation of OpenCL drivers can be verified through the clinfo command of the clinfo package. This command will report the number of hardware devices that is found and give detailed information for each device:\n\n$ clinfo | head -n3 Number of platforms 1 Platform Name AMD Accelerated Parallel Processing Platform Vendor Advanced Micro Devices, Inc.\n\nAMD\n\nModern AMD Graphics Core Next (GCN) GPUs are supported through the rocmPackages.clr.icd package. Adding this package to hardware.opengl.extraPackages enables OpenCL support:\n\n{ hardware.opengl.extraPackages = [ rocmPackages.clr.icd ]; }\n\nIntel\n\nIntel Gen8 and later GPUs are supported by the Intel NEO OpenCL runtime that is provided by the intel-compute-runtime package. The proprietary Intel OpenCL runtime, in the intel-ocl package, is an alternative for Gen7 GPUs.\n\nThe intel-compute-runtime or intel-ocl package can be added to hardware.opengl.extraPackages to enable OpenCL support. For example, for Gen8 and later GPUs, the following configuration can be used:\n\n{ hardware.opengl.extraPackages = [ intel-compute-runtime ]; }\n\nVulkan\n\nVulkan is a graphics and compute API for GPUs. It is used directly by games or indirectly though compatibility layers like DXVK.\n\nBy default, if hardware.opengl.driSupport is enabled, mesa is installed and provides Vulkan for supported hardware.\n\nSimilar to OpenCL, Vulkan drivers are loaded through the Installable Client Driver (ICD) mechanism. ICD files for Vulkan are JSON files that specify the path to the driver library and the supported Vulkan version. All successfully loaded drivers are exposed to the application as different GPUs. In NixOS, there are two ways to make ICD files visible to Vulkan applications: an environment variable and a module option.\n\nThe first option is through the VK_ICD_FILENAMES environment variable. This variable can contain multiple JSON files, separated by :. For example:\n\n$ export \\ VK_ICD_FILENAMES=`nix-build '<nixpkgs>' --no-out-link -A amdvlk`/share/vulkan/icd.d/amd_icd64.json\n\nThe second mechanism is to add the Vulkan driver package to hardware.opengl.extraPackages. This links the ICD file under /run/opengl-driver, where it will be visible to the ICD loader.\n\nThe proper installation of Vulkan drivers can be verified through the vulkaninfo command of the vulkan-tools package. This command will report the hardware devices and drivers found, in this example output amdvlk and radv:\n\n$ vulkaninfo | grep GPU GPU id : 0 (Unknown AMD GPU) GPU id : 1 (AMD RADV NAVI10 (LLVM 9.0.1)) ... GPU0: deviceType = PHYSICAL_DEVICE_TYPE_DISCRETE_GPU deviceName = Unknown AMD GPU GPU1: deviceType = PHYSICAL_DEVICE_TYPE_DISCRETE_GPU\n\nA simple graphical application that uses Vulkan is vkcube from the vulkan-tools package.\n\nAMD\n\nModern AMD Graphics Core Next (GCN) GPUs are supported through either radv, which is part of mesa, or the amdvlk package. Adding the amdvlk package to hardware.opengl.extraPackages makes amdvlk the default driver and hides radv and lavapipe from the device list. A specific driver can be forced as follows:\n\n{ hardware.opengl.extraPackages = [ pkgs.amdvlk ]; # To enable Vulkan support for 32-bit applications, also add: hardware.opengl.extraPackages32 = [ pkgs.driversi686Linux.amdvlk ]; # Force radv environment.variables.AMD_VULKAN_ICD = \"RADV\"; # Or environment.variables.VK_ICD_FILENAMES = \"/run/opengl-driver/share/vulkan/icd.d/radeon_icd.x86_64.json\"; }\n\nVA-API\n\nVA-API (Video Acceleration API) is an open-source library and API specification, which provides access to graphics hardware acceleration capabilities for video processing.\n\nVA-API drivers are loaded by libva. The version in nixpkgs is built to search the opengl driver path, so drivers can be installed in hardware.opengl.extraPackages.\n\nVA-API can be tested using:\n\n$ nix-shell -p libva-utils --run vainfo\n\nIntel\n\nModern Intel GPUs use the iHD driver, which can be installed with:\n\n{ hardware.opengl.extraPackages = [ intel-media-driver ]; }\n\nOlder Intel GPUs use the i965 driver, which can be installed with:\n\n{ hardware.opengl.extraPackages = [ intel-vaapi-driver ]; }\n\nCommon issues\n\nUser permissions\n\nExcept where noted explicitly, it should not be necessary to adjust user permissions to use these acceleration APIs. In the default configuration, GPU devices have world-read/write permissions (/dev/dri/renderD*) or are tagged as uaccess (/dev/dri/card*). The access control lists of devices with the uaccess tag will be updated automatically when a user logs in through systemd-logind. For example, if the user alice is logged in, the access control list should look as follows:\n\n$ getfacl /dev/dri/card0 # file: dev/dri/card0 # owner: root # group: video user::rw- user:alice:rw- group::rw- mask::rw- other::---\n\nIf you disabled (this functionality of) systemd-logind, you may need to add the user to the video group and log in again.\n\nMixing different versions of nixpkgs\n\nThe Installable Client Driver (ICD) mechanism used by OpenCL and Vulkan loads runtimes into its address space using dlopen. Mixing an ICD loader mechanism and runtimes from different version of nixpkgs may not work. For example, if the ICD loader uses an older version of glibc than the runtime, the runtime may not be loadable due to missing symbols. Unfortunately, the loader will generally be quiet about such issues.\n\nIf you suspect that you are running into library version mismatches between an ICL loader and a runtime, you could run an application with the LD_DEBUG variable set to get more diagnostic information. For example, OpenCL can be tested with LD_DEBUG=files clinfo, which should report missing symbols.\n\nXfce Desktop Environment\n\nTable of Contents\n\nThunar\n\nTroubleshooting\n\nTo enable the Xfce Desktop Environment, set\n\n{ services.xserver.desktopManager.xfce.enable = true; services.displayManager.defaultSession = \"xfce\"; }\n\nOptionally, picom can be enabled for nice graphical effects, some example settings:\n\n{ services.picom = { enable = true; fade = true; inactiveOpacity = 0.9; shadow = true; fadeDelta = 4; }; }\n\nSome Xfce programs are not installed automatically. To install them manually (system wide), put them into your environment.systemPackages from pkgs.xfce.\n\nThunar\n\nThunar (the Xfce file manager) is automatically enabled when Xfce is enabled. To enable Thunar without enabling Xfce, use the configuration option programs.thunar.enable instead of adding pkgs.xfce.thunar to environment.systemPackages.\n\nIf you’d like to add extra plugins to Thunar, add them to programs.thunar.plugins. You shouldn’t just add them to environment.systemPackages.\n\nTroubleshooting\n\nEven after enabling udisks2, volume management might not work. Thunar and/or the desktop takes time to show up. Thunar will spit out this kind of message on start (look at journalctl --user -b).\n\nThunar:2410): GVFS-RemoteVolumeMonitor-WARNING **: remote volume monitor with dbus name org.gtk.Private.UDisks2VolumeMonitor is not supported\n\nThis is caused by some needed GNOME services not running. This is all fixed by enabling “Launch GNOME services on startup” in the Advanced tab of the Session and Startup settings panel. Alternatively, you can run this command to do the same thing.\n\n$ xfconf-query -c xfce4-session -p /compat/LaunchGNOME -s true\n\nIt is necessary to log out and log in again for this to take effect.\n\nNetworking\n\nTable of Contents\n\nNetworkManager\n\nSecure Shell Access\n\nIPv4 Configuration\n\nIPv6 Configuration\n\nFirewall\n\nWireless Networks\n\nAd-Hoc Configuration\n\nRenaming network interfaces\n\nThis section describes how to configure networking components on your NixOS machine.\n\nNetworkManager\n\nTo facilitate network configuration, some desktop environments use NetworkManager. You can enable NetworkManager by setting:\n\n{ networking.networkmanager.enable = true; }\n\nsome desktop managers (e.g., GNOME) enable NetworkManager automatically for you.\n\nAll users that should have permission to change network settings must belong to the networkmanager group:\n\n{ users.users.alice.extraGroups = [ \"networkmanager\" ]; }\n\nNetworkManager is controlled using either nmcli or nmtui (curses-based terminal user interface). See their manual pages for details on their usage. Some desktop environments (GNOME, KDE) have their own configuration tools for NetworkManager. On XFCE, there is no configuration tool for NetworkManager by default: by enabling programs.nm-applet.enable, the graphical applet will be installed and will launch automatically when the graphical session is started.\n\nNote\n\nnetworking.networkmanager and networking.wireless (WPA Supplicant) can be used together if desired. To do this you need to instruct NetworkManager to ignore those interfaces like:\n\n{ networking.networkmanager.unmanaged = [ \"*\" \"except:type:wwan\" \"except:type:gsm\" ]; }\n\nRefer to the option description for the exact syntax and references to external documentation.\n\nSecure Shell Access\n\nSecure shell (SSH) access to your machine can be enabled by setting:\n\n{ services.openssh.enable = true; }\n\nBy default, root logins using a password are disallowed. They can be disabled entirely by setting services.openssh.settings.PermitRootLogin to \"no\".\n\nYou can declaratively specify authorised RSA/DSA public keys for a user as follows:\n\n{ users.users.alice.openssh.authorizedKeys.keys = [ \"ssh-dss AAAAB3NzaC1kc3MAAACBAPIkGWVEt4...\" ]; }\n\nIPv4 Configuration\n\nBy default, NixOS uses DHCP (specifically, dhcpcd) to automatically configure network interfaces. However, you can configure an interface manually as follows:\n\n{ networking.interfaces.eth0.ipv4.addresses = [ { address = \"192.168.1.2\"; prefixLength = 24; } ]; }\n\nTypically you’ll also want to set a default gateway and set of name servers:\n\n{ networking.defaultGateway = \"192.168.1.1\"; networking.nameservers = [ \"8.8.8.8\" ]; }\n\nNote\n\nStatically configured interfaces are set up by the systemd service interface-name-cfg.service. The default gateway and name server configuration is performed by network-setup.service.\n\nThe host name is set using networking.hostName:\n\n{ networking.hostName = \"cartman\"; }\n\nThe default host name is nixos. Set it to the empty string (\"\") to allow the DHCP server to provide the host name.\n\nIPv6 Configuration\n\nIPv6 is enabled by default. Stateless address autoconfiguration is used to automatically assign IPv6 addresses to all interfaces, and Privacy Extensions (RFC 4946) are enabled by default. You can adjust the default for this by setting networking.tempAddresses. This option may be overridden on a per-interface basis by networking.interfaces.<name>.tempAddress. You can disable IPv6 support globally by setting:\n\n{ networking.enableIPv6 = false; }\n\nYou can disable IPv6 on a single interface using a normal sysctl (in this example, we use interface eth0):\n\n{ boot.kernel.sysctl.\"net.ipv6.conf.eth0.disable_ipv6\" = true; }\n\nAs with IPv4 networking interfaces are automatically configured via DHCPv6. You can configure an interface manually:\n\n{ networking.interfaces.eth0.ipv6.addresses = [ { address = \"fe00:aa:bb:cc::2\"; prefixLength = 64; } ]; }\n\nFor configuring a gateway, optionally with explicitly specified interface:\n\n{ networking.defaultGateway6 = { address = \"fe00::1\"; interface = \"enp0s3\"; }; }\n\nSee the section called “IPv4 Configuration” for similar examples and additional information.\n\nFirewall\n\nNixOS has a simple stateful firewall that blocks incoming connections and other unexpected packets. The firewall applies to both IPv4 and IPv6 traffic. It is enabled by default. It can be disabled as follows:\n\n{ networking.firewall.enable = false; }\n\nIf the firewall is enabled, you can open specific TCP ports to the outside world:\n\n{ networking.firewall.allowedTCPPorts = [ 80 443 ]; }\n\nNote that TCP port 22 (ssh) is opened automatically if the SSH daemon is enabled (services.openssh.enable = true). UDP ports can be opened through networking.firewall.allowedUDPPorts.\n\nTo open ranges of TCP ports:\n\n{ networking.firewall.allowedTCPPortRanges = [ { from = 4000; to = 4007; } { from = 8000; to = 8010; } ]; }\n\nSimilarly, UDP port ranges can be opened through networking.firewall.allowedUDPPortRanges.\n\nWireless Networks\n\nFor a desktop installation using NetworkManager (e.g., GNOME), you just have to make sure the user is in the networkmanager group and you can skip the rest of this section on wireless networks.\n\nNixOS will start wpa_supplicant for you if you enable this setting:\n\n{ networking.wireless.enable = true; }\n\nNixOS lets you specify networks for wpa_supplicant declaratively:\n\n{ networking.wireless.networks = { echelon = { # SSID with no spaces or special characters psk = \"abcdefgh\"; }; \"echelon's AP\" = { # SSID with spaces and/or special characters psk = \"ijklmnop\"; }; echelon = { # Hidden SSID hidden = true; psk = \"qrstuvwx\"; }; free.wifi = {}; # Public wireless network }; }\n\nBe aware that keys will be written to the nix store in plaintext! When no networks are set, it will default to using a configuration file at /etc/wpa_supplicant.conf. You should edit this file yourself to define wireless networks, WPA keys and so on (see wpa_supplicant.conf(5)).\n\nIf you are using WPA2 you can generate pskRaw key using wpa_passphrase:\n\n$ wpa_passphrase ESSID PSK network={ ssid=\"echelon\" #psk=\"abcdefgh\" psk=dca6d6ed41f4ab5a984c9f55f6f66d4efdc720ebf66959810f4329bb391c5435 }\n\n{ networking.wireless.networks = { echelon = { pskRaw = \"dca6d6ed41f4ab5a984c9f55f6f66d4efdc720ebf66959810f4329bb391c5435\"; }; }; }\n\nor you can use it to directly generate the wpa_supplicant.conf:\n\n# wpa_passphrase ESSID PSK > /etc/wpa_supplicant.conf\n\nAfter you have edited the wpa_supplicant.conf, you need to restart the wpa_supplicant service.\n\n# systemctl restart wpa_supplicant.service\n\nAd-Hoc Configuration\n\nYou can use networking.localCommands to specify shell commands to be run at the end of network-setup.service. This is useful for doing network configuration not covered by the existing NixOS modules. For instance, to statically configure an IPv6 address:\n\n{ networking.localCommands = '' ip -6 addr add 2001:610:685:1::1/64 dev eth0 ''; }\n\nRenaming network interfaces\n\nNixOS uses the udev predictable naming scheme to assign names to network interfaces. This means that by default cards are not given the traditional names like eth0 or eth1, whose order can change unpredictably across reboots. Instead, relying on physical locations and firmware information, the scheme produces names like ens1, enp2s0, etc.\n\nThese names are predictable but less memorable and not necessarily stable: for example installing new hardware or changing firmware settings can result in a name change. If this is undesirable, for example if you have a single ethernet card, you can revert to the traditional scheme by setting networking.usePredictableInterfaceNames to false.\n\nAssigning custom names\n\nIn case there are multiple interfaces of the same type, it’s better to assign custom names based on the device hardware address. For example, we assign the name wan to the interface with MAC address 52:54:00:12:01:01 using a netword link unit:\n\n{ systemd.network.links.\"10-wan\" = { matchConfig.PermanentMACAddress = \"52:54:00:12:01:01\"; linkConfig.Name = \"wan\"; }; }\n\nNote that links are directly read by udev, not networkd, and will work even if networkd is disabled.\n\nAlternatively, we can use a plain old udev rule:\n\n{ boot.initrd.services.udev.rules = '' SUBSYSTEM==\"net\", ACTION==\"add\", DRIVERS==\"?*\", \\ ATTR{address}==\"52:54:00:12:01:01\", KERNEL==\"eth*\", NAME=\"wan\" ''; }\n\nWarning\n\nThe rule must be installed in the initrd using boot.initrd.services.udev.rules, not the usual services.udev.extraRules option. This is to avoid race conditions with other programs controlling the interface.\n\nLinux Kernel\n\nTable of Contents\n\nBuilding a custom kernel\n\nRust\n\nDeveloping kernel modules\n\nZFS\n\nYou can override the Linux kernel and associated packages using the option boot.kernelPackages. For instance, this selects the Linux 3.10 kernel:\n\n{ boot.kernelPackages = pkgs.linuxKernel.packages.linux_3_10; }\n\nNote that this not only replaces the kernel, but also packages that are specific to the kernel version, such as the NVIDIA video drivers. This ensures that driver packages are consistent with the kernel.\n\nWhile pkgs.linuxKernel.packages contains all available kernel packages, you may want to use one of the unversioned pkgs.linuxPackages_* aliases such as pkgs.linuxPackages_latest, that are kept up to date with new versions.\n\nPlease note that the current convention in NixOS is to only keep actively maintained kernel versions on both unstable and the currently supported stable release(s) of NixOS. This means that a non-longterm kernel will be removed after it’s abandoned by the kernel developers, even on stable NixOS versions. If you pin your kernel onto a non-longterm version, expect your evaluation to fail as soon as the version is out of maintenance.\n\nLongterm versions of kernels will be removed before the next stable NixOS that will exceed the maintenance period of the kernel version.\n\nThe default Linux kernel configuration should be fine for most users. You can see the configuration of your current kernel with the following command:\n\nzcat /proc/config.gz\n\nIf you want to change the kernel configuration, you can use the packageOverrides feature (see the section called “Customising Packages”). For instance, to enable support for the kernel debugger KGDB:\n\n{ nixpkgs.config.packageOverrides = pkgs: pkgs.lib.recursiveUpdate pkgs { linuxKernel.kernels.linux_5_10 = pkgs.linuxKernel.kernels.linux_5_10.override { extraConfig = '' KGDB y ''; }; }; }\n\nextraConfig takes a list of Linux kernel configuration options, one per line. The name of the option should not include the prefix CONFIG_. The option value is typically y, n or m (to build something as a kernel module).\n\nKernel modules for hardware devices are generally loaded automatically by udev. You can force a module to be loaded via boot.kernelModules, e.g.\n\n{ boot.kernelModules = [ \"fuse\" \"kvm-intel\" \"coretemp\" ]; }\n\nIf the module is required early during the boot (e.g. to mount the root file system), you can use boot.initrd.kernelModules:\n\n{ boot.initrd.kernelModules = [ \"cifs\" ]; }\n\nThis causes the specified modules and their dependencies to be added to the initial ramdisk.\n\nKernel runtime parameters can be set through boot.kernel.sysctl, e.g.\n\n{ boot.kernel.sysctl.\"net.ipv4.tcp_keepalive_time\" = 120; }\n\nsets the kernel’s TCP keepalive time to 120 seconds. To see the available parameters, run sysctl -a.\n\nBuilding a custom kernel\n\nPlease refer to the Nixpkgs manual for the various ways of building a custom kernel.\n\nTo use your custom kernel package in your NixOS configuration, set\n\n{ boot.kernelPackages = pkgs.linuxPackagesFor yourCustomKernel; }\n\nRust\n\nThe Linux kernel does not have Rust language support enabled by default. For kernel versions 6.7 or newer, experimental Rust support can be enabled. In a NixOS configuration, set:\n\n{ boot.kernelPatches = [ { name = \"Rust Support\"; patch = null; features = { rust = true; }; } ]; }\n\nDeveloping kernel modules\n\nThis section was moved to the Nixpkgs manual.\n\nZFS\n\nIt’s a common issue that the latest stable version of ZFS doesn’t support the latest available Linux kernel. It is recommended to use the latest available LTS that’s compatible with ZFS. Usually this is the default kernel provided by nixpkgs (i.e. pkgs.linuxPackages).\n\nAlternatively, it’s possible to pin the system to the latest available kernel version that is supported by ZFS like this:\n\n{ boot.kernelPackages = pkgs.zfs.latestCompatibleLinuxPackages; }\n\nPlease note that the version this attribute points to isn’t monotonic because the latest kernel version only refers to kernel versions supported by the Linux developers. In other words, the latest kernel version that ZFS is compatible with may decrease over time.\n\nAn example: the latest version ZFS is compatible with is 5.19 which is a non-longterm version. When 5.19 is out of maintenance, the latest supported kernel version is 5.15 because it’s longterm and the versions 5.16, 5.17 and 5.18 are already out of maintenance because they’re non-longterm.\n\nSubversion\n\nTable of Contents\n\nSubversion inside Apache HTTP\n\nSubversion is a centralized version-control system. It can use a variety of protocols for communication between client and server.\n\nSubversion inside Apache HTTP\n\nThis section focuses on configuring a web-based server on top of the Apache HTTP server, which uses WebDAV/DeltaV for communication.\n\nFor more information on the general setup, please refer to the the appropriate section of the Subversion book.\n\nTo configure, include in /etc/nixos/configuration.nix code to activate Apache HTTP, setting services.httpd.adminAddr appropriately:\n\n{ services.httpd.enable = true; services.httpd.adminAddr = \"...\"; networking.firewall.allowedTCPPorts = [ 80 443 ]; }\n\nFor a simple Subversion server with basic authentication, configure the Subversion module for Apache as follows, setting hostName and documentRoot appropriately, and SVNParentPath to the parent directory of the repositories, AuthzSVNAccessFile to the location of the .authz file describing access permission, and AuthUserFile to the password file.\n\n{ services.httpd.extraModules = [ # note that order is *super* important here { name = \"dav_svn\"; path = \"${pkgs.apacheHttpdPackages.subversion}/modules/mod_dav_svn.so\"; } { name = \"authz_svn\"; path = \"${pkgs.apacheHttpdPackages.subversion}/modules/mod_authz_svn.so\"; } ]; services.httpd.virtualHosts = { \"svn\" = { hostName = HOSTNAME; documentRoot = DOCUMENTROOT; locations.\"/svn\".extraConfig = '' DAV svn SVNParentPath REPO_PARENT AuthzSVNAccessFile ACCESS_FILE AuthName \"SVN Repositories\" AuthType Basic AuthUserFile PASSWORD_FILE Require valid-user ''; }; }; }\n\nThe key \"svn\" is just a symbolic name identifying the virtual host. The \"/svn\" in locations.\"/svn\".extraConfig is the path underneath which the repositories will be served.\n\nThis page explains how to set up the Subversion configuration itself. This boils down to the following:\n\nUnderneath REPO_PARENT repositories can be set up as follows:\n\n$ svn create REPO_NAME\n\nRepository files need to be accessible by wwwrun:\n\n$ chown -R wwwrun:wwwrun REPO_PARENT\n\nThe password file PASSWORD_FILE can be created as follows:\n\n$ htpasswd -cs PASSWORD_FILE USER_NAME\n\nAdditional users can be set up similarly, omitting the c flag:\n\n$ htpasswd -s PASSWORD_FILE USER_NAME\n\nThe file describing access permissions ACCESS_FILE will look something like the following:\n\n[/] * = r [REPO_NAME:/] USER_NAME = rw\n\nThe Subversion repositories will be accessible as http://HOSTNAME/svn/REPO_NAME.\n\nPantheon Desktop\n\nTable of Contents\n\nEnabling Pantheon\n\nWingpanel and Switchboard plugins\n\nFAQ\n\nPantheon is the desktop environment created for the elementary OS distribution. It is written from scratch in Vala, utilizing GNOME technologies with GTK and Granite.\n\nEnabling Pantheon\n\nAll of Pantheon is working in NixOS and the applications should be available, aside from a few exceptions. To enable Pantheon, set\n\n{ services.xserver.desktopManager.pantheon.enable = true; }\n\nThis automatically enables LightDM and Pantheon’s LightDM greeter. If you’d like to disable this, set\n\n{ services.xserver.displayManager.lightdm.greeters.pantheon.enable = false; services.xserver.displayManager.lightdm.enable = false; }\n\nbut please be aware using Pantheon without LightDM as a display manager will break screenlocking from the UI. The NixOS module for Pantheon installs all of Pantheon’s default applications. If you’d like to not install Pantheon’s apps, set\n\n{ services.pantheon.apps.enable = false; }\n\nYou can also use environment.pantheon.excludePackages to remove any other app (like elementary-mail).\n\nWingpanel and Switchboard plugins\n\nWingpanel and Switchboard work differently than they do in other distributions, as far as using plugins. You cannot install a plugin globally (like with environment.systemPackages) to start using it. You should instead be using the following options:\n\nservices.xserver.desktopManager.pantheon.extraWingpanelIndicators\n\nservices.xserver.desktopManager.pantheon.extraSwitchboardPlugs\n\nto configure the programs with plugs or indicators.\n\nThe difference in NixOS is both these programs are patched to load plugins from a directory that is the value of an environment variable. All of which is controlled in Nix. If you need to configure the particular packages manually you can override the packages like:\n\nwingpanel-with-indicators.override { indicators = [ pkgs.some-special-indicator ]; }\n\nswitchboard-with-plugs.override { plugs = [ pkgs.some-special-plug ]; }\n\nplease note that, like how the NixOS options describe these as extra plugins, this would only add to the default plugins included with the programs. If for some reason you’d like to configure which plugins to use exactly, both packages have an argument for this:\n\nwingpanel-with-indicators.override { useDefaultIndicators = false; indicators = specialListOfIndicators; }\n\nswitchboard-with-plugs.override { useDefaultPlugs = false; plugs = specialListOfPlugs; }\n\nthis could be most useful for testing a particular plug-in in isolation.\n\nFAQ\n\nI have switched from a different desktop and Pantheon’s theming looks messed up.\n\nOpen Switchboard and go to: Administration → About → Restore Default Settings → Restore Settings. This will reset any dconf settings to their Pantheon defaults. Note this could reset certain GNOME specific preferences if that desktop was used prior.\n\nI cannot enable both GNOME and Pantheon.\n\nThis is a known issue and there is no known workaround.\n\nDoes AppCenter work, or is it available?\n\nAppCenter has been available since 20.03. Starting from 21.11, the Flatpak backend should work so you can install some Flatpak applications using it. However, due to missing appstream metadata, the Packagekit backend does not function currently. See this issue.\n\nIf you are using Pantheon, AppCenter should be installed by default if you have Flatpak support enabled. If you also wish to add the appcenter Flatpak remote:\n\n$ flatpak remote-add --if-not-exists appcenter https://flatpak.elementary.io/repo.flatpakrepo\n\nGNOME Desktop\n\nTable of Contents\n\nEnabling GNOME\n\nEnabling GNOME Flashback\n\nIcons and GTK Themes\n\nShell Extensions\n\nGSettings Overrides\n\nFrequently Asked Questions\n\nGNOME provides a simple, yet full-featured desktop environment with a focus on productivity. Its Mutter compositor supports both Wayland and X server, and the GNOME Shell user interface is fully customizable by extensions.\n\nEnabling GNOME\n\nAll of the core apps, optional apps, games, and core developer tools from GNOME are available.\n\nTo enable the GNOME desktop use:\n\n{ services.xserver.desktopManager.gnome.enable = true; services.xserver.displayManager.gdm.enable = true; }\n\nNote\n\nWhile it is not strictly necessary to use GDM as the display manager with GNOME, it is recommended, as some features such as screen lock might not work without it.\n\nThe default applications used in NixOS are very minimal, inspired by the defaults used in gnome-build-meta.\n\nGNOME without the apps\n\nIf you’d like to only use the GNOME desktop and not the apps, you can disable them with:\n\n{ services.gnome.core-utilities.enable = false; }\n\nand none of them will be installed.\n\nIf you’d only like to omit a subset of the core utilities, you can use environment.gnome.excludePackages. Note that this mechanism can only exclude core utilities, games and core developer tools.\n\nDisabling GNOME services\n\nIt is also possible to disable many of the core services. For example, if you do not need indexing files, you can disable Tracker with:\n\n{ services.gnome.tracker-miners.enable = false; services.gnome.tracker.enable = false; }\n\nNote, however, that doing so is not supported and might break some applications. Notably, GNOME Music cannot work without Tracker.\n\nGNOME games\n\nYou can install all of the GNOME games with:\n\n{ services.gnome.games.enable = true; }\n\nYou can install GNOME core developer tools with:\n\n{ services.gnome.core-developer-tools.enable = true; }\n\nEnabling GNOME Flashback\n\nGNOME Flashback provides a desktop environment based on the classic GNOME 2 architecture. You can enable the default GNOME Flashback session, which uses the Metacity window manager, with:\n\n{ services.xserver.desktopManager.gnome.flashback.enableMetacity = true; }\n\nIt is also possible to create custom sessions that replace Metacity with a different window manager using services.xserver.desktopManager.gnome.flashback.customSessions.\n\nThe following example uses xmonad window manager:\n\n{ services.xserver.desktopManager.gnome.flashback.customSessions = [ { wmName = \"xmonad\"; wmLabel = \"XMonad\"; wmCommand = \"${pkgs.haskellPackages.xmonad}/bin/xmonad\"; enableGnomePanel = false; } ]; }\n\nIcons and GTK Themes\n\nIcon themes and GTK themes don’t require any special option to install in NixOS.\n\nYou can add them to environment.systemPackages and switch to them with GNOME Tweaks. If you’d like to do this manually in dconf, change the values of the following keys:\n\n/org/gnome/desktop/interface/gtk-theme /org/gnome/desktop/interface/icon-theme\n\nin dconf-editor\n\nShell Extensions\n\nMost Shell extensions are packaged under the gnomeExtensions attribute. Some packages that include Shell extensions, like gnome.gpaste, don’t have their extension decoupled under this attribute.\n\nYou can install them like any other package:\n\n{ environment.systemPackages = [ gnomeExtensions.dash-to-dock gnomeExtensions.gsconnect gnomeExtensions.mpris-indicator-button ]; }\n\nUnfortunately, we lack a way for these to be managed in a completely declarative way. So you have to enable them manually with an Extensions application. It is possible to use a GSettings override for this on org.gnome.shell.enabled-extensions, but that will only influence the default value.\n\nGSettings Overrides\n\nMajority of software building on the GNOME platform use GLib’s GSettings system to manage runtime configuration. For our purposes, the system consists of XML schemas describing the individual configuration options, stored in the package, and a settings backend, where the values of the settings are stored. On NixOS, like on most Linux distributions, dconf database is used as the backend.\n\nGSettings vendor overrides can be used to adjust the default values for settings of the GNOME desktop and apps by replacing the default values specified in the XML schemas. Using overrides will allow you to pre-seed user settings before you even start the session.\n\nWarning\n\nOverrides really only change the default values for GSettings keys so if you or an application changes the setting value, the value set by the override will be ignored. Until NixOS’s dconf module implements changing values, you will either need to keep that in mind and clear the setting from the backend using dconf reset command when that happens, or use the module from home-manager.\n\nYou can override the default GSettings values using the services.xserver.desktopManager.gnome.extraGSettingsOverrides option.\n\nTake note that whatever packages you want to override GSettings for, you need to add them to services.xserver.desktopManager.gnome.extraGSettingsOverridePackages.\n\nYou can use dconf-editor tool to explore which GSettings you can set.\n\nExample\n\n{ services.xserver.desktopManager.gnome = { extraGSettingsOverrides = '' # Change default background [org.gnome.desktop.background] picture-uri='file://${pkgs.nixos-artwork.wallpapers.mosaic-blue.gnomeFilePath}' # Favorite apps in gnome-shell [org.gnome.shell] favorite-apps=['org.gnome.Console.desktop', 'org.gnome.Nautilus.desktop'] ''; extraGSettingsOverridePackages = [ pkgs.gsettings-desktop-schemas # for org.gnome.desktop pkgs.gnome.gnome-shell # for org.gnome.shell ]; }; }\n\nFrequently Asked Questions\n\nCan I use LightDM with GNOME?\n\nYes you can, and any other display-manager in NixOS.\n\nHowever, it doesn’t work correctly for the Wayland session of GNOME Shell yet, and won’t be able to lock your screen.\n\nSee this issue.\n\nExternal Bootloader Backends\n\nTable of Contents\n\nDeveloping Custom Bootloader Backends\n\nNixOS has support for several bootloader backends by default: systemd-boot, grub, uboot, etc. The built-in bootloader backend support is generic and supports most use cases. Some users may prefer to create advanced workflows around managing the bootloader and bootable entries.\n\nYou can replace the built-in bootloader support with your own tooling using the “external” bootloader option.\n\nImagine you have created a new package called FooBoot. FooBoot provides a program at ${pkgs.fooboot}/bin/fooboot-install which takes the system closure’s path as its only argument and configures the system’s bootloader.\n\nYou can enable FooBoot like this:\n\n{ pkgs, ... }: { boot.loader.external = { enable = true; installHook = \"${pkgs.fooboot}/bin/fooboot-install\"; }; }\n\nDeveloping Custom Bootloader Backends\n\nBootloaders should use RFC-0125’s Bootspec format and synthesis tools to identify the key properties for bootable system generations.\n\nClevis\n\nTable of Contents\n\nCreate a JWE file containing your secret\n\nActivate unattended decryption of a resource at boot\n\nClevis is a framework for automated decryption of resources. Clevis allows for secure unattended disk decryption during boot, using decryption policies that must be satisfied for the data to decrypt.\n\nCreate a JWE file containing your secret\n\nThe first step is to embed your secret in a JWE file. JWE files have to be created through the clevis command line. 3 types of policies are supported:\n\nTPM policies\n\nSecrets are pinned against the presence of a TPM2 device, for example:\n\necho -n hi | clevis encrypt tpm2 '{}' > hi.jwe\n\nTang policies\n\nSecrets are pinned against the presence of a Tang server, for example:\n\necho -n hi | clevis encrypt tang '{\"url\": \"http://tang.local\"}' > hi.jwe\n\nShamir Secret Sharing\n\nUsing Shamir’s Secret Sharing (sss), secrets are pinned using a combination of the two preceding policies. For example:\n\necho -n hi | clevis encrypt sss \\ '{\"t\": 2, \"pins\": {\"tpm2\": {\"pcr_ids\": \"0\"}, \"tang\": {\"url\": \"http://tang.local\"}}}' \\ > hi.jwe\n\nFor more complete documentation on how to generate a secret with clevis, see the clevis documentation.\n\nActivate unattended decryption of a resource at boot\n\nIn order to activate unattended decryption of a resource at boot, enable the clevis module:\n\n{ boot.initrd.clevis.enable = true; }\n\nThen, specify the device you want to decrypt using a given clevis secret. Clevis will automatically try to decrypt the device at boot and will fallback to interactive unlocking if the decryption policy is not fulfilled.\n\n{ boot.initrd.clevis.devices.\"/dev/nvme0n1p1\".secretFile = ./nvme0n1p1.jwe; }\n\nOnly bcachefs, zfs and luks encrypted devices are supported at this time.\n\nGarage\n\nTable of Contents\n\nGeneral considerations on upgrades\n\nAdvanced upgrades (minor/major version upgrades)\n\nMaintainer information\n\nGarage is an open-source, self-hostable S3 store, simpler than MinIO, for geodistributed stores. The server setup can be automated using services.garage. A client configured to your local Garage instance is available in the global environment as garage-manage.\n\nThe current default by NixOS is garage_0_8 which is also the latest major version available.\n\nGeneral considerations on upgrades\n\nGarage provides a cookbook documentation on how to upgrade: https://garagehq.deuxfleurs.fr/documentation/cookbook/upgrading/\n\nWarning\n\nGarage has two types of upgrades: patch-level upgrades and minor/major version upgrades.\n\nIn all cases, you should read the changelog and ideally test the upgrade on a staging cluster.\n\nChecking the health of your cluster can be achieved using garage-manage repair.\n\nWarning\n\nUntil 1.0 is released, patch-level upgrades are considered as minor version upgrades. Minor version upgrades are considered as major version upgrades. i.e. 0.6 to 0.7 is a major version upgrade.\n\nStraightforward upgrades (patch-level upgrades). Upgrades must be performed one by one, i.e. for each node, stop it, upgrade it : change stateVersion or services.garage.package, restart it if it was not already by switching.\n\nMultiple version upgrades. Garage do not provide any guarantee on moving more than one major-version forward. E.g., if you’re on 0.7, you cannot upgrade to 0.9. You need to upgrade to 0.8 first. As long as stateVersion is declared properly, this is enforced automatically. The module will issue a warning to remind the user to upgrade to latest Garage after that deploy.\n\nAdvanced upgrades (minor/major version upgrades)\n\nHere are some baseline instructions to handle advanced upgrades in Garage, when in doubt, please refer to upstream instructions.\n\nDisable API and web access to Garage.\n\nPerform garage-manage repair --all-nodes --yes tables and garage-manage repair --all-nodes --yes blocks.\n\nVerify the resulting logs and check that data is synced properly between all nodes. If you have time, do additional checks (scrub, block_refs, etc.).\n\nCheck if queues are empty by garage-manage stats or through monitoring tools.\n\nRun systemctl stop garage to stop the actual Garage version.\n\nBackup the metadata folder of ALL your nodes, e.g. for a metadata directory (the default one) in /var/lib/garage/meta, you can run pushd /var/lib/garage; tar -acf meta-v0.7.tar.zst meta/; popd.\n\nRun the offline migration: nix-shell -p garage_0_8 --run \"garage offline-repair --yes\", this can take some time depending on how many objects are stored in your cluster.\n\nBump Garage version in your NixOS configuration, either by changing stateVersion or bumping services.garage.package, this should restart Garage automatically.\n\nPerform garage-manage repair --all-nodes --yes tables and garage-manage repair --all-nodes --yes blocks.\n\nWait for a full table sync to run.\n\nYour upgraded cluster should be in a working state, re-enable API and web access.\n\nMaintainer information\n\nAs stated in the previous paragraph, we must provide a clean upgrade-path for Garage since it cannot move more than one major version forward on a single upgrade. This chapter adds some notes how Garage updates should be rolled out in the future. This is inspired from how Nextcloud does it.\n\nWhile patch-level updates are no problem and can be done directly in the package-expression (and should be backported to supported stable branches after that), major-releases should be added in a new attribute (e.g. Garage v0.8.0 should be available in nixpkgs as pkgs.garage_0_8_0). To provide simple upgrade paths it’s generally useful to backport those as well to stable branches. As long as the package-default isn’t altered, this won’t break existing setups. After that, the versioning-warning in the garage-module should be updated to make sure that the package-option selects the latest version on fresh setups.\n\nIf major-releases will be abandoned by upstream, we should check first if those are needed in NixOS for a safe upgrade-path before removing those. In that case we should keep those packages, but mark them as insecure in an expression like this (in <nixpkgs/pkgs/tools/filesystem/garage/default.nix>):\n\n/* ... */ { garage_0_7_3 = generic { version = \"0.7.3\"; sha256 = \"0000000000000000000000000000000000000000000000000000\"; eol = true; }; }\n\nIdeally we should make sure that it’s possible to jump two NixOS versions forward: i.e. the warnings and the logic in the module should guard a user to upgrade from a Garage on e.g. 22.11 to a Garage on 23.11.\n\nYouTrack\n\nTable of Contents\n\nInstallation\n\nUpgrade from 2022.3 to 2023.x\n\nYouTrack is a browser-based bug tracker, issue tracking system and project management software.\n\nInstallation\n\nYouTrack exposes a web GUI installer on first login. You need a token to access it. You can find this token in the log of the youtrack service. The log line looks like\n\n* JetBrains YouTrack 2023.3 Configuration Wizard will be available on [http://127.0.0.1:8090/?wizard_token=somelongtoken] after start\n\nUpgrade from 2022.3 to 2023.x\n\nStarting with YouTrack 2023.1, JetBrains no longer distributes it as as JAR. The new distribution with the JetBrains Launcher as a ZIP changed the basic data structure and also some configuration parameters. Check out https://www.jetbrains.com/help/youtrack/server/YouTrack-Java-Start-Parameters.html for more information on the new configuration options. When upgrading to YouTrack 2023.1 or higher, a migration script will move the old state directory to /var/lib/youtrack/2022_3 as a backup. A one-time manual update is required:\n\nBefore you update take a backup of your YouTrack instance!\n\nMigrate the options you set in services.youtrack.extraParams and services.youtrack.jvmOpts to services.youtrack.generalParameters and services.youtrack.environmentalParameters (see the examples and the YouTrack docs)\n\nTo start the upgrade set services.youtrack.package = pkgs.youtrack\n\nYouTrack then starts in upgrade mode, meaning you need to obtain the wizard token as above\n\nSelect you want to Upgrade YouTrack\n\nAs source you select /var/lib/youtrack/2022_3/teamsysdata/ (adopt if you have a different state path)\n\nChange the data directory location to /var/lib/youtrack/data/. The other paths should already be right.\n\nIf you migrate a larger YouTrack instance, it might be useful to set -Dexodus.entityStore.refactoring.forceAll=true in services.youtrack.generalParameters for the first startup of YouTrack 2023.x.\n\nSuwayomi-Server\n\nTable of Contents\n\nBasic usage\n\nBasic authentication\n\nExtra configuration\n\nA free and open source manga reader server that runs extensions built for Tachiyomi.\n\nBasic usage\n\nBy default, the module will execute Suwayomi-Server backend and web UI:\n\n{ ... }: { services.suwayomi-server = { enable = true; }; }\n\nIt runs in the systemd service named suwayomi-server in the data directory /var/lib/suwayomi-server.\n\nYou can change the default parameters with some other parameters:\n\n{ ... }: { services.suwayomi-server = { enable = true; dataDir = \"/var/lib/suwayomi\"; # Default is \"/var/lib/suwayomi-server\" openFirewall = true; settings = { server.port = 4567; }; }; }\n\nIf you want to create a desktop icon, you can activate the system tray option:\n\n{ ... }: { services.suwayomi-server = { enable = true; dataDir = \"/var/lib/suwayomi\"; # Default is \"/var/lib/suwayomi-server\" openFirewall = true; settings = { server.port = 4567; server.enableSystemTray = true; }; }; }\n\nBasic authentication\n\nYou can configure a basic authentication to the web interface with:\n\n{ ... }: { services.suwayomi-server = { enable = true; openFirewall = true; settings = { server.port = 4567; server = { basicAuthEnabled = true; basicAuthUsername = \"username\"; # NOTE: this is not a real upstream option basicAuthPasswordFile = ./path/to/the/password/file; }; }; }; }\n\nExtra configuration\n\nNot all the configuration options are available directly in this module, but you can add the other options of suwayomi-server with:\n\n{ ... }: { services.suwayomi-server = { enable = true; openFirewall = true; settings = { server = { port = 4567; autoDownloadNewChapters = false; maxSourcesInParallel = 6; extensionRepos = [ \"https://raw.githubusercontent.com/MY_ACCOUNT/MY_REPO/repo/index.min.json\" ]; }; }; }; }\n\nPlausible\n\nTable of Contents\n\nBasic Usage\n\nPlausible is a privacy-friendly alternative to Google analytics.\n\nBasic Usage\n\nAt first, a secret key is needed to be generated. This can be done with e.g.\n\n$ openssl rand -base64 64\n\nAfter that, plausible can be deployed like this:\n\n{ services.plausible = { enable = true; adminUser = { # activate is used to skip the email verification of the admin-user that's # automatically created by plausible. This is only supported if # postgresql is configured by the module. This is done by default, but # can be turned off with services.plausible.database.postgres.setup. activate = true; email = \"admin@localhost\"; passwordFile = \"/run/secrets/plausible-admin-pwd\"; }; server = { baseUrl = \"http://analytics.example.org\"; # secretKeybaseFile is a path to the file which contains the secret generated # with openssl as described above. secretKeybaseFile = \"/run/secrets/plausible-secret-key-base\"; }; }; }\n\nPict-rs\n\nTable of Contents\n\nQuickstart\n\nUsage\n\nMissing\n\npict-rs is a a simple image hosting service.\n\nQuickstart\n\nthe minimum to start pict-rs is\n\n{ services.pict-rs.enable = true; }\n\nthis will start the http server on port 8080 by default.\n\nUsage\n\npict-rs offers the following endpoints:\n\nPOST /image for uploading an image. Uploaded content must be valid multipart/form-data with an image array located within the images[] key\n\nThis endpoint returns the following JSON structure on success with a 201 Created status\n\n{ \"files\": [ { \"delete_token\": \"JFvFhqJA98\", \"file\": \"lkWZDRvugm.jpg\" }, { \"delete_token\": \"kAYy9nk2WK\", \"file\": \"8qFS0QooAn.jpg\" }, { \"delete_token\": \"OxRpM3sf0Y\", \"file\": \"1hJaYfGE01.jpg\" } ], \"msg\": \"ok\" }\n\nGET /image/download?url=... Download an image from a remote server, returning the same JSON payload as the POST endpoint\n\nGET /image/original/{file} for getting a full-resolution image. file here is the file key from the /image endpoint’s JSON\n\nGET /image/details/original/{file} for getting the details of a full-resolution image. The returned JSON is structured like so:\n\n{ \"width\": 800, \"height\": 537, \"content_type\": \"image/webp\", \"created_at\": [ 2020, 345, 67376, 394363487 ] }\n\nGET /image/process.{ext}?src={file}&... get a file with transformations applied. existing transformations include\n\nidentity=true: apply no changes\n\nblur={float}: apply a gaussian blur to the file\n\nthumbnail={int}: produce a thumbnail of the image fitting inside an {int} by {int} square using raw pixel sampling\n\nresize={int}: produce a thumbnail of the image fitting inside an {int} by {int} square using a Lanczos2 filter. This is slower than sampling but looks a bit better in some cases\n\ncrop={int-w}x{int-h}: produce a cropped version of the image with an {int-w} by {int-h} aspect ratio. The resulting crop will be centered on the image. Either the width or height of the image will remain full-size, depending on the image’s aspect ratio and the requested aspect ratio. For example, a 1600x900 image cropped with a 1x1 aspect ratio will become 900x900. A 1600x1100 image cropped with a 16x9 aspect ratio will become 1600x900.\n\nSupported ext file extensions include png, jpg, and webp\n\nAn example of usage could be\n\nGET /image/process.jpg?src=asdf.png&thumbnail=256&blur=3.0\n\nwhich would create a 256x256px JPEG thumbnail and blur it\n\nGET /image/details/process.{ext}?src={file}&... for getting the details of a processed image. The returned JSON is the same format as listed for the full-resolution details endpoint.\n\nDELETE /image/delete/{delete_token}/{file} or GET /image/delete/{delete_token}/{file} to delete a file, where delete_token and file are from the /image endpoint’s JSON\n\nMissing\n\nConfiguring the secure-api-key is not included yet. The envisioned basic use case is consumption on localhost by other services without exposing the service to the internet.\n\nNextcloud\n\nTable of Contents\n\nBasic usage\n\nCommon problems\n\nUsing an alternative webserver as reverse-proxy (e.g. httpd)\n\nInstalling Apps and PHP extensions\n\nKnown warnings\n\nMaintainer information\n\nNextcloud is an open-source, self-hostable cloud platform. The server setup can be automated using services.nextcloud. A desktop client is packaged at pkgs.nextcloud-client.\n\nThe current default by NixOS is nextcloud29 which is also the latest major version available.\n\nBasic usage\n\nNextcloud is a PHP-based application which requires an HTTP server (services.nextcloud and optionally supports services.nginx).\n\nFor the database, you can set services.nextcloud.config.dbtype to either sqlite (the default), mysql, or pgsql. The simplest is sqlite, which will be automatically created and managed by the application. For the last two, you can easily create a local database by setting services.nextcloud.database.createLocally to true, Nextcloud will automatically be configured to connect to it through socket.\n\nA very basic configuration may look like this:\n\n{ pkgs, ... }: { services.nextcloud = { enable = true; hostName = \"nextcloud.tld\"; database.createLocally = true; config = { dbtype = \"pgsql\"; adminpassFile = \"/path/to/admin-pass-file\"; }; }; networking.firewall.allowedTCPPorts = [ 80 443 ]; }\n\nThe hostName option is used internally to configure an HTTP server using PHP-FPM and nginx. The config attribute set is used by the imperative installer and all values are written to an additional file to ensure that changes can be applied by changing the module’s options.\n\nIn case the application serves multiple domains (those are checked with $_SERVER['HTTP_HOST']) it’s needed to add them to services.nextcloud.settings.trusted_domains.\n\nAuto updates for Nextcloud apps can be enabled using services.nextcloud.autoUpdateApps.\n\nCommon problems\n\nGeneral notes. Unfortunately Nextcloud appears to be very stateful when it comes to managing its own configuration. The config file lives in the home directory of the nextcloud user (by default /var/lib/nextcloud/config/config.php) and is also used to track several states of the application (e.g., whether installed or not).\n\nAll configuration parameters are also stored in /var/lib/nextcloud/config/override.config.php which is generated by the module and linked from the store to ensure that all values from config.php can be modified by the module. However config.php manages the application’s state and shouldn’t be touched manually because of that.\n\nWarning\n\nDon’t delete config.php! This file tracks the application’s state and a deletion can cause unwanted side-effects!\n\nWarning\n\nDon’t rerun nextcloud-occ maintenance:install! This command tries to install the application and can cause unwanted side-effects!\n\nMultiple version upgrades. Nextcloud doesn’t allow to move more than one major-version forward. E.g., if you’re on v16, you cannot upgrade to v18, you need to upgrade to v17 first. This is ensured automatically as long as the stateVersion is declared properly. In that case the oldest version available (one major behind the one from the previous NixOS release) will be selected by default and the module will generate a warning that reminds the user to upgrade to latest Nextcloud after that deploy.\n\nError: Command \"upgrade\" is not defined. This error usually occurs if the initial installation (nextcloud-occ maintenance:install) has failed. After that, the application is not installed, but the upgrade is attempted to be executed. Further context can be found in NixOS/nixpkgs#111175.\n\nFirst of all, it makes sense to find out what went wrong by looking at the logs of the installation via journalctl -u nextcloud-setup and try to fix the underlying issue.\n\nIf this occurs on an existing setup, this is most likely because the maintenance mode is active. It can be deactivated by running nextcloud-occ maintenance:mode --off. It’s advisable though to check the logs first on why the maintenance mode was activated.\n\nWarning\n\nOnly perform the following measures on freshly installed instances!\n\nA re-run of the installer can be forced by deleting /var/lib/nextcloud/config/config.php. This is the only time advisable because the fresh install doesn’t have any state that can be lost. In case that doesn’t help, an entire re-creation can be forced via rm -rf ~nextcloud/.\n\nServer-side encryption. Nextcloud supports server-side encryption (SSE). This is not an end-to-end encryption, but can be used to encrypt files that will be persisted to external storage such as S3.\n\nUsing an alternative webserver as reverse-proxy (e.g. httpd)\n\nBy default, nginx is used as reverse-proxy for nextcloud. However, it’s possible to use e.g. httpd by explicitly disabling nginx using services.nginx.enable and fixing the settings listen.owner & listen.group in the corresponding phpfpm pool.\n\nAn exemplary configuration may look like this:\n\n{ config, lib, pkgs, ... }: { services.nginx.enable = false; services.nextcloud = { enable = true; hostName = \"localhost\"; /* further, required options */ }; services.phpfpm.pools.nextcloud.settings = { \"listen.owner\" = config.services.httpd.user; \"listen.group\" = config.services.httpd.group; }; services.httpd = { enable = true; adminAddr = \"webmaster@localhost\"; extraModules = [ \"proxy_fcgi\" ]; virtualHosts.\"localhost\" = { documentRoot = config.services.nextcloud.package; extraConfig = '' <Directory \"${config.services.nextcloud.package}\"> <FilesMatch \"\\.php$\"> <If \"-f %{REQUEST_FILENAME}\"> SetHandler \"proxy:unix:${config.services.phpfpm.pools.nextcloud.socket}|fcgi://localhost/\" </If> </FilesMatch> <IfModule mod_rewrite.c> RewriteEngine On RewriteBase / RewriteRule ^index\\.php$ - [L] RewriteCond %{REQUEST_FILENAME} !-f RewriteCond %{REQUEST_FILENAME} !-d RewriteRule . /index.php [L] </IfModule> DirectoryIndex index.php Require all granted Options +FollowSymLinks </Directory> ''; }; }; }\n\nInstalling Apps and PHP extensions\n\nNextcloud apps are installed statefully through the web interface. Some apps may require extra PHP extensions to be installed. This can be configured with the services.nextcloud.phpExtraExtensions setting.\n\nAlternatively, extra apps can also be declared with the services.nextcloud.extraApps setting. When using this setting, apps can no longer be managed statefully because this can lead to Nextcloud updating apps that are managed by Nix. If yo"
    }
}