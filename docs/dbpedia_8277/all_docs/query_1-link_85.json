{
    "id": "dbpedia_8277_1",
    "rank": 85,
    "data": {
        "url": "https://taskwarrior.wordpress.com/",
        "read_more_link": "",
        "language": "en",
        "title": "Taskwarrior Team",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://2.gravatar.com/avatar/2ed49816ecb435de082ef979fdd55b9b5ddf71d3e96d3401ce718b454e47f13f?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/494b66896c398a00b16f5a2a288f0f8b083a4b2df4da6e9fa88aa1c90f1f70ce?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/e89c760bb216675425472a7193dd920a4276785def219c7035441b6ff4657e3c?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/e89c760bb216675425472a7193dd920a4276785def219c7035441b6ff4657e3c?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/aa25e89d9f3098b55f6eec82a5daa6329169da3e56ca8d6d223b9eaf0840c39b?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/2ed49816ecb435de082ef979fdd55b9b5ddf71d3e96d3401ce718b454e47f13f?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/2ed49816ecb435de082ef979fdd55b9b5ddf71d3e96d3401ce718b454e47f13f?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color1.png?w=632&h=137",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color1a.png?w=632&h=81",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color2.png?w=632&h=84",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color3.png?w=632&h=68",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color4.png?w=632&h=167",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color5.png?w=632&h=438",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color8.png?w=632",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/12/color6.png?w=632&h=423",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/11/view1.png?w=632&h=72",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/11/view2.png?w=632&h=119",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/11/view5.png?w=632&h=121",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/11/view3.png?w=632&h=72",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/11/view4.png?w=632&h=73",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/494b66896c398a00b16f5a2a288f0f8b083a4b2df4da6e9fa88aa1c90f1f70ce?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/e89c760bb216675425472a7193dd920a4276785def219c7035441b6ff4657e3c?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/aa25e89d9f3098b55f6eec82a5daa6329169da3e56ca8d6d223b9eaf0840c39b?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/dfa233817640627693d349c39b01288e1560cd70b89a0674bff845ccd3df107d?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/a61ad68d4014bc3650b399631ce357b46f85229749a16ea223ec31ad62319e71?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/a61ad68d4014bc3650b399631ce357b46f85229749a16ea223ec31ad62319e71?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/aa25e89d9f3098b55f6eec82a5daa6329169da3e56ca8d6d223b9eaf0840c39b?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/a61ad68d4014bc3650b399631ce357b46f85229749a16ea223ec31ad62319e71?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/e89c760bb216675425472a7193dd920a4276785def219c7035441b6ff4657e3c?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://2.gravatar.com/avatar/e89c760bb216675425472a7193dd920a4276785def219c7035441b6ff4657e3c?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/494b66896c398a00b16f5a2a288f0f8b083a4b2df4da6e9fa88aa1c90f1f70ce?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt1.png?w=632&h=55",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt2.png?w=632&h=33",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt3.png?w=632&h=35",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt4.png?w=632&h=36",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt3.png?w=632&h=35",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt5.png?w=632&h=38",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/09/vt6.png?w=632&h=41",
            "https://1.gravatar.com/avatar/48d085762984cc631ec2df5ddf7a506b7abe2767242ddaf36de6725e02132169?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/48d085762984cc631ec2df5ddf7a506b7abe2767242ddaf36de6725e02132169?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/48d085762984cc631ec2df5ddf7a506b7abe2767242ddaf36de6725e02132169?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/alias-13.png?w=632&h=115",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/alias-23.png?w=632&h=147",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/alias-33.png?w=632&h=33",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/alias-43.png?w=632&h=32",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/alias-53.png?w=632&h=17",
            "https://1.gravatar.com/avatar/df898b211118e8daa0411f0a112fa0b9bf542406f9cad3ab8991f3faab835eb5?s=16&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://1.gravatar.com/avatar/df898b211118e8daa0411f0a112fa0b9bf542406f9cad3ab8991f3faab835eb5?s=32&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://0.gravatar.com/avatar/ca99e62121b5d54342a16d234ad0e0512c38e38c7ec1e451b9832068ce587ab2?s=48&d=https%3A%2F%2Fs0.wp.com%2Fi%2Fmu.gif&r=G",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/flod-s.png?w=632",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/flod-overview.png?w=632",
            "https://taskwarrior.wordpress.com/wp-content/uploads/2013/08/flod-arch.png?w=632",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "http://taskwarrior.org",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "Taskwarrior Team",
        "canonical_link": "https://taskwarrior.wordpress.com/",
        "text": "Improving Filters\n\nFilters support the idea of restricting a set of tasks according to the attributes of that task. The simplest filter is an empty one, which performs no restriction, resulting in a list of all tasks:\n\ntask all\n\nThe ‘all’ report is used here because it has no intrinsic filter. Other reports have filters that obstruct the illustration. A simple filter is to restrict to only ‘pending’ tasks, like this:\n\ntask status:pending all\n\nThis match can be inverted by inserting an attribute modifier:\n\ntask status.not:pending all\n\nMultiple matches can be combined, and the result is a conjunction, further restricting the results:\n\ntask status:pending project:Home all\n\nThese attribute modifiers have been used for a long time, but they are limited. Recent changes have added support for better filtering, and opening the syntax up for more interesting capabilities. For example, the ‘:’ can be replaced by an ‘=’ character, allowing this:\n\ntask status=pending all\n\nWhile this appears to be a simple substitution, it is actually something more. The ‘name:value’ syntax is recognized by the command line parser, then converted to ‘name=value’ internally and then the evaluator *only* supports ‘=’ as an exact match operator. This is true of almost all the syntax for filters; the command is parsed, converted, and the internal format is evaluated. The above command is equivalent to:\n\ntask status = pending all\n\nSuppose you wanted to filter on tasks containing ‘the’. There are several ways to do this, the simplest is:\n\ntask the all\n\nThis is just a shorthand way of specifying:\n\ntask description.contains:the\n\nBut you can use regular expressions too:\n\ntask /the/ all\n\nHere the // characters delimit the regular expression. Internally, all of the above are treated the same:\n\ntask description \\~ the all task 'description ~ the' all\n\nYou can see here that either the backslash \\ or the quotes ” are needed to hide the ~ character from the shell, which will it expand to your home directory. There are many special characters that the shell will act upon. The above can be inverted (and abbreviated) with this:\n\ntask 'desc !~ the' all\n\nSimilarly, filters containing multiple restrictions, such as this:\n\ntask status:pending description.contains:the all\n\nAre using conjunctions, which means the above is equivalent to inserting an implicit ‘and’ operator between the terms like this:\n\ntask status:pending and description.contains:the all\n\nRewriting this using operators instead of attribute modifiers, we get:\n\ntask 'status = pending and description ~ the' all\n\nIn addition to ‘and’, you can use ‘or’:\n\ntask 'status = pending or description ~ the' all\n\nYou can use parentheses to control precedence:\n\ntask '( status = pending or status = completed ) and desc ~ the' all\n\nFor a description of current filter support see Filters.\n\nWhere Are Filters Heading?\n\nFilters are being simplified. That means less of the syntactic sugar (/the/), with more operators (~, !~ …) and standardization. The attribute modifiers are too limited and will not be further enhanced. Soon they will be deprecated,\n\nultimately removed.\n\nFilters are simply algebraic expressions, evaluated in the context of a single task. Taskwarrior is getting a new command line parser and expression evaluator for 2.4.0, and this means new operators and greater use of expressions.\n\nNext…\n\nThe next article will cover the new functionality coming in 2.4.0 that takes the new filter syntax much further.\n\nCodebase 101 – Color\n\nTaskwarrior supports color in the terminal, and does this by implementing a color model, which is a nice abstraction for handling colorized text. The model allows us to specify color such as “red”, instead of using…\n\nTerminal Escape Sequences\n\nTerminal programs such as XTerm display the data received from an application in the window or on the screen. But not all of it. If the data contains an escape sequence, which is a known sequence of data, usually indicated by some leading unprintable character, then XTerm does not display it. Not directly at least, because it must first decode what is being sent, and act accordingly. There are hundreds of different XTerm escape sequences, but just a few of them handle color.\n\nIt can help to think of HTML as an analogy. To display a word in boldface, you might use this HTML:\n\nregular <b>bold</b> regular\n\nHere the word ‘bold’ is surrounded by a Bold tag. XTerm color works in a similar fashion, but is a lot less readable.\n\nTypically a program such as Taskwarrior will look at the $TERM environment variable, use that value to look up the supported escape sequences in termcap for the given terminal, and use only the supported subset.\n\nSupport For Different Terminals\n\nDoes Taskwarrior look at $TERM? No. Does Taskwarrior use termcap at all? No. Does it use NCurses to manage all this? No. It simply uses Xterm escape sequences, ignores other terminal types, and so far (going on seven years now) no one has asked for any other terminal support. There just doesn’t appear to be a need.\n\nHow Are Escape Sequences Used?\n\nHere is an example of the escape sequence for the foreground color red, used directly in the terminal:\n\nThe echo command simply sends the data to the terminal, and the first example contains only the word ‘Hello’. The second example inserts the escape sequence ^[[31m to turn on the red foreground, and ^[[0m to turn off all color. In order to enter the second example “red” sequence in the terminal, using Bash, type the following keys in sequence:\n\nCtrl-V <Escape> [ 3 1 m\n\nTo be specific, type Ctrl-V (both ‘Control’ and ‘V’ at the same time), then hit the ‘Escape’ key, then ‘[‘, then ‘3’, then ‘1’ then ‘m’. Note that when you enter a literal escape character (with Ctrl-V, Escape) it shows up as ^[. This is expected, as escape sequences do strange things to your terminal. Also note that if you do this, and mess up the terminal (it’s possible), all you need to do is close and reopen the terminal window.\n\nIt should be noted that the second example echoes 14 characters, but only 5 are displayed. The others are interpreted as color codes and consumed by the terminal. The important aspect of this is the ’31’, which is the code for foreground color red.\n\nThere are also escape sequences for bold, underline, inverse. The special escape sequence ^[[0m resets all the color, so that makes it possible to combined colored and non-colored text, like this:\n\nHere the ‘4’ means underline. In addition to foreground color, there is a background color, and these may be combined like this:\n\nSee how the ’31’ (foreground red) is combined (using ‘;’) with ’44’ (background blue) to specify both foreground and background color. Using what we have seen so far, colorful “graphics” (they are not really graphics, just colored text cells), can be produced, for example this text:\n\nDoes not display any text, just spaces on colored backgrounds ’44’ (blue) and ’47’ (white), and it looks like this:\n\nTaking this further, it becomes possible to construct complex sequences of color codes to produce, for example, a monthly burndown chart for the Taskwarrior 2.3.0 project:\n\nAll this is simply text, spaces and escape sequences. Here is another example of the Taskwarrior calendar, using a purple theme, combining text and escape sequences:\n\nThe Taskwarrior color model has three responsibilities, which are:\n\n[1] Naming Convention\n\nThis is simply a way to map the XTerm escape sequences into some more readable and usable set of names for colors. There are four ways to specify colors, the first is by simple name:\n\nred, blue, black, green, cyan, magenta, yellow, white\n\nThese are the simple 8-color names. Then there is an RGB model:\n\nrgb000 – rgb555\n\nThis ranges from black (rgb000) to white (rgb555) through a color cube, where the red, green and blue components each have six possible values (0, 1, 2, 3, 4, 5). The model maps these coordinates to the right escape sequence, which, as one would hope, follows an orderly convention.\n\nThere there are the 24 grey colors:\n\ngray0 – gray23\n\nThese follow a monochrome scale, and are used in the demo “task logo” command (go ahead, try it).\n\nFinally there is a direct specification of all 256 colors using:\n\ncolor0 – color255\n\nThis sequences ranges from the 8 standard colors, the brighter equivalents, through the color cube, to the gray-scale.\n\n[2] Composition\n\nThe color model provides a small language to allow composition. For example, there is the trivial case of just specifying a foreground color:\n\nred\n\nBut to distinguish foreground from background, the syntax used the word “on”:\n\nred on blue\n\nThis can include other attributes, such as:\n\nbold red underline on bright blue\n\nAny of the naming conventions can be used here.\n\n[3] Blending\n\nThis is really a stretch, given the simplistic nature of the terminal color, but there is support for combined two colors into one. It is rudimentary and can only blend easily combined attributes, such as foreground with background, color with underline. Future improvements will allow combinations like red + blue –> magenta.\n\nHere are all the color combinations supported by Taskwarrior, as seen in the command “task color”:\n\nYou might ask “Why does ‘on bright green’ look like two kinds of grey?”. This is because the terminal used to generate these screenshots is using a modified Solarized theme, which remapped color8 – color14.\n\nAdvanced Topics\n\nThe standard 8 colors cannot be combined with the 256-color equivalents. When this is attempted (red on gray15), the red is upgraded to color1. Similarly, ‘bold red’ is upgraded to color9. Similarly, ‘on bright red’ is upgraded into the 256-color system. This is handled automatically.\n\nThere is a missing advanced feature – optimization. Sometimes it is possible to examine colorized text and remove some redundant color codes. Consider this pseudo-HTML:\n\n<red>one</red><bold-red>two</bold-red><red>three</red>\n\nThis could be reduced to:\n\n<red>one<bold>two</bold>three</red>\n\nAlthough this optimization is not implemented, the redundancy does exist, and should be addressed, because it can greatly reduce the I/O of Taskwarrior.\n\nCodebase 101 – Grid View\n\nMost Taskwarrior data is displayed in a rectangular grid, with rows and columns, header, footer and messages. Displaying data in that grid is the result of some complex text formatting. This formatting will be described in detail, but first a simple example to illustrate the issues at hand:\n\nShown are two columns of data, the first is a single word, the second shows multiple words. This is a typical layout problem, although a simple one.\n\nTaskwarrior implements two similar view objects, ‘ViewTask’ which displays task data, and ‘ViewText’ which is a more general grid of strings. The ‘ViewTask’ object will be described here, but the ideas apply to both.\n\nIt should be pointed out that only ViewText stores a copy of the data. ViewTask does not need a data copy, as the task database is readily available, and there is a large performance cost to copying that data, which is best avoided.\n\nWhat is a row?\n\nA row in a report corresponds directly to a single task, which is itself a set of attributes (description, project, priority …), arranged horizontally in the output. A row may occupy one or more lines of text, depending on how the data is formatted.\n\nWhat is a column?\n\nA column is a task attribute, formatted in a specific way. There are many different column formats supported, as an example, the ‘priority’ attribute may be shown in ‘long’ or ‘short’ form:\n\npriority.long Pending priority.short P\n\n(See ‘task columns’ for a full list, with examples).\n\nCustom Reports\n\nA custom report contains two major elements: the column list and the filter. The column list determines the quantity, type, formatting and ordering of the columns, and this indirectly determines the width of the report.\n\nThe filter is an algebraic expression that is applied to the set of all tasks, which reduces the set to only those matching the specified criteria, and determines the length, or rows of the report.\n\nBut Does It Fit?\n\nBefore formatting output, Taskwarrior determines the dimensions of the terminal window, in characters. All output must fit within the width of the terminal. The height is a different matter, because of vertical scrolling. Note that it is possible to control the height of a report using something like ‘limit:page’ or ‘limit:5’ to restrict the number of rows of data shown.\n\nOnce the terminal width is known, it must be determined how the columns will be formatted. Each task attribute is represented by a code object, for example the description attribute is represented by ColDescription. This object, which inherits from the base Columns object, has the ability to measure the data, and render the data.\n\nMeasuring Data\n\nIn most cases this is straightforward. Using the ‘priority’ column as an example, we know that if a report uses this, then the corresponding column has two formats to support:\n\npriority.short (default) priority.long\n\nThe short format use a single-character representation (‘H’, ‘M’ or ‘L’). The long format uses words (‘High’, ‘Medium’, ‘Low’), with the longest word (‘Medium’) needing 6 characters.\n\nThus the ColPriority object, when asked to measure itself, will yield either a width of 1 or 6 characters, according to the format.\n\nBut there is also the column label to consider. In this case, the label is ‘Pri’, and needs 3 characters. Therefore, the final result is that the priority columns needs 3 or 6 characters. Priority is a fixed-width column.\n\nThis measurement is performed for all tasks that will be shown in the report. This means the ViewTask will know how much space each column needs, for the set of tasks it will display.\n\nVariable Width Columns\n\nThe description column requires more complex formatting. When asked to measure itself, it determines two measurements – the ideal width and the minimum width. The ideal width is the length of the description field. This assumes infinite terminal width, with no word wrapping. Here is an example:\n\n|Words of varying length used.| 1 29\n\nThe ideal width is 29 characters. The minimum width is calculated to be the length of the longest word in the description. This corresponds to the ideal width, if only one word were displayed per line:\n\n|Words | |of | |varying| |length | |used. | 1 7\n\nThe minimum width is 7 characters. This means that the description shown can be comfortably rendered using a width of 7 characters or more, up to a maximum width of 29 characters. Not discussed here is hyphenation, which is a way to reduce the minimum width down to an arbitrary size, if hyphenation is used. Taskwarrior supports hyphenation.\n\nUsing Terminal Width Wisely\n\nFixed width columns have specific width requirements, and variable width columns are flexible. Provided the terminal width is large enough to contain the sum of the column widths, then the report can be shown.\n\nIf the terminal is wider than the minimum needed, the variable-width columns in the report can all benefit from the extra space. The excess width is then distributed among the variable-width columns, until they reach their ideal width, or there is no more space.\n\nIf the terminal width exceeds the sum of all the ideal widths, then the whole terminal width is not even used, because it would have no effect.\n\nThen It Gets Complicated\n\nTaskwarrior uses UTF8 only. This has an impact on ViewTask, because some Unicode characters occupy two character cells.\n\nThe width usage of a character is determined by using Markus Kuhn’s free implementation of IEEE Std 1002.1-2001:\n\nhttp://www.cl.cam.ac.uk/~mgk25/ucs/wcwidth.c\n\nFurther complications arise when color is considered. The color escape sequences have zero display width, but occupy space in the text. Great care must be taken when determining the length of text; there are important differences between character count, display character count, and string length.\n\nOther ViewTask features complicate matters further. There is the notion of a blank character in between each displayed column (rc.column.padding=3):\n\nFinally there is report indentation (rc.indent.report=8):\n\nWhile there are always improvements that can be made, the ViewTask grid meets all the immediate needs for formatting.\n\nA Personal Task Server\n\nThis article will explain how to set up and sync with your own task server.\n\nWhy Do I Need A Task Server?\n\nYou may want to sync tasks between several machines, or you might anticipate doing that. You may also want to have a backup copy of your tasks.\n\nWhy Do I Need A Personal Task Server?\n\nSetting up your own Task Server means having complete control and privacy. There will be secure hosted server accounts soon, but for now you will need to set up your own server.\n\nFirst Things First\n\nThis is new territory for Taskwarrior, which means using beta software, and that means we’re going to make a backup as step 1. Here is a very easy way to backup your data:\n\n$ cd ~/.task $ tar czf task-backup-$(date +'%Y%m%d').tar.gz *\n\nNow put that file somewhere for safe keeping, because beta software contains bugs. The truth is that all software contains bugs, so if you aren’t making a backup of all your data, then, well, why not?\n\nSatisfy the Dependencies\n\nBefore building the software, you will need to satisfy the dependencies by installing the following:\n\nGnuTLS\n\nlibuuid\n\nlibreadline\n\ncmake\n\nmake\n\nA C++ Compiler\n\nNote that some OSes (Darwin, FreeBSD …) include libuuid functionality in libc.\n\nBuild the Code\n\nThe next step is to obtain the code and build it. This means getting the Taskwarrior 2.3.0 and Task Server 1.0.0 beta2 tarballs. Here are the steps, and notice that the code is built in the home directory. Naturally you can build the code anywhere you wish, but the later in this article we will be referring to this location. Adjust accordingly.\n\n$ cd $ curl -O http://taskwarrior.org/download/taskd-1.0.0.beta2.tar.gz $ tar xzf taskd-1.0.0.beta2.tar.gz $ cd taskd-1.0.0.beta2 $ cmake . $ make $ sudo make install $ cd $ curl -O http://taskwarrior.org/download/task-2.3.0.beta2.tar.gz $ tar xzf task-2.3.0.beta2.tar.gz $ cd task-2.3.0.beta2 $ cmake . $ make $ sudo make install\n\nNote that you may choose to run the server on one machine, and the client on another. Bear this in mind as you obtain and build the code.\n\nServer Setup\n\nOn the server machine, a location for the data must be chosen and created. The TASKDDATA environment variable will be used to indicate that location, and is also used by the server itself. In fact, most server commands require either that the TASKDDATA variable is set, or the “–data …” option is fully specified. In this example, we are using ~/server_data.\n\n$ export TASKDDATA=~/server_data $ mkdir -p $TASKDDATA\n\nEverything the server does will be confined to that directory. Now we let the server initialize that directory:\n\n$ taskd init You must specify the 'server' variable, for example: taskd config server localhost:53589 Created ~/server_data/config\n\nNext we create an organization (‘Public’) and a user (‘Your Name’ is used here). Substitute your name in the following commands:\n\n$ taskd add org Public Created organization 'Public' $ taskd add user 'Public' 'Your Name' New user key: cf31f287-ee9e-43a8-843e-e8bbd5de4294 Created user 'Your Name' for organization 'Public'\n\nThe organization is a grouping of users, and will become essential in later server releases.\n\nNote that you will get a different ‘New user key’, than shown here, and you will need to retain that, to be used later. Note that the key is just a unique id, because your name alone is not necessarily unique.\n\nNow we create certificates and keys. The command below will generate all the certs and keys for the server, but this includes self-signed certificates, and this is not recommended for production use. This is for personal use, and this may be acceptable for you, but if not, you will need to purchase a proper certificate and key, backed by a proper certificate authority.\n\n$ cd ~/taskd-1.0.0.beta2/pki $ ./generate ... $ cp client.cert.pem $TASKDDATA $ cp client.key.pem $TASKDDATA $ cp server.cert.pem $TASKDDATA $ cp server.key.pem $TASKDDATA $ cp server.crl.pem $TASKDDATA $ cp ca.cert.pem $TASKDDATA $ taskd config --force client.cert $ROOT/client.cert.pem $ taskd config --force client.key $ROOT/client.key.pem $ taskd config --force server.cert $ROOT/server.cert.pem $ taskd config --force server.key $ROOT/server.key.pem $ taskd config --force server.crl $ROOT/server.crl.pem $ taskd config --force ca.cert $ROOT/ca.cert.pem\n\nNow we configure some basic details for the server. The chosen port is 53589. Note that we allow Taskwarrior clients specifically.\n\n$ cd $TASKDDATA/.. $ taskd config --force log $PWD/taskd.log $ taskd config --force pid.file $PWD/taskd.pid $ taskd config --force server localhost:53589 $ taskd config --force client.allow '^task [2-9]'\n\nYou can look at all the configuration settings:\n\n$ taskd config\n\nIt is time now to launch the server:\n\n$ taskdctl start\n\nThis command launched the server as a daemon process. Note that you use ‘taskdctl stop’ to terminate the server. This command requires the TASKDDATA variable. Your server is now running, and ready for syncing.\n\nClient Setup\n\nOn your client machine it is assumed that you are already using Taskwarrior, and already have local tasks to sync. If this is not the case, setup and add one. We need to create a cert and key for you, based on the server cert:\n\n$ cd ~/taskd-1.0.0.beta2/pki $ ./generate.client your_name ...\n\nCopy the cert, key and ca to your ~/.task directory. The reason we are copying the CA cert is because this is a self-signed cert, and we need the CA to validate against. Alternately we could force Taskwarrior to trust all certs, but that is not recommended.\n\n$ cp your_name.cert.pem ~/.task $ cp your_name.key.pem ~/.task $ cp ca.cert.pem ~/.task\n\nNow we need to configure Taskwarrior to be aware of these certs:\n\n$ task config taskd.certificate ~/.task/your_name.cert.pem $ task config taskd.key ~/.task/your_name.key.pem $ task config taskd.ca ~/.task/ca.cert.pem\n\nNow set the server info and provide the credentials, which include the ID key generated when the user was added to the server:\n\n$ task config taskd.server localhost:53589 $ task config taskd.credentials 'Public/Your Name/cf31f287-ee9e-43a8-843e-e8bbd5de4294'\n\nNow your client is ready to sync.\n\nFirst Time Sync\n\nThe first time you sync is special – the client sends all your pending tasks to the server. This is something you should only do once. Run this:\n\n$ task sync init Please confirm that you wish to upload all your pending tasks to the Task Server (yes/no) yes Syncing with localhost:53589 Sync successful. 2 changes uploaded.\n\nYou should get an indication that tasks were uploaded, in this case 2 of them.\n\nGeneral Sync\n\nAfter the first time sync, you switch and just use this command:\n\n$ task sync Syncing with localhost:53589 Sync successful. No changes.\n\nThis will give you feedback about what happened. Please note that it is perfectly safe to run this command as often as you wish. Syncing is safe and does not consume great system resources.\n\nBut it does require network connectivity, and if there is no connectivity you will be notified. It is not a problem if a sync fails because of this, because the next sync that works will catch up with all the changes, and do the right merging.\n\nThe general usage pattern is that after you modify data locally, Taskwarrior will start notifying you that you need to sync, after commands, like this:\n\n$ task project:foo list No matches. There are local changes. Sync required.\n\nThis is just a reminder to sync. Respond with a sync, and the reminder goes away:\n\n$ task sync Syncing with <server>:<port> Sync successful. 1 changes uploaded.\n\nPlease remember this is beta software, and if you find bugs or have unanswered questions, please contact us at support@taskwarrior.org.\n\nFor the latest version of this document, with corrections and added info see: http://taskwarrior.org/projects/taskwarrior/wiki/Server_setup\n\nDocument Object Model – DOM\n\nAny program that manages data has a responsibility to make that data accessible. Furthermore, any open, extensible system needs to make that data readily accessible to third party scripts and programs in different ways.\n\nThere is a entire zoo of different species of scripts out there that need to be supported, and the future form of these animals is unknown:\n\nhttp://taskwarrior.org/projects/taskwarrior/wiki/ExternalScripts\n\nWill the next script be in Bash or Python? Will it consume data? Will it produce data? Does it need access to an individual datum? Will it maintain an open connection to the data or simply make one change?\n\nFor most purposes, the ability to import and export tasks in JSON format is the most complete method. All data can be accessed, but this requires parsing JSON for the whole task, and it is possible that a script needs only to access, for example, the task description.\n\nDocument Object Model\n\nThis is where a Document Object Model (DOM) can help. A DOM provides an addressing mechanism to reference individual data items. While Taskwarrior has supported DOM addressing for a while now, it is only with the upcoming 2.3.0 release that is has become more complete and useful for extensions.\n\nIn its simplest form, the DOM provides references to attributes in a task. For example, suppose you were adding a new task:\n\n$ task add Take out the trash due:friday wait:friday\n\nThis is a task that has a due date, but remains hidden until that due date. See how ‘friday’ is duplicated in that command? The DOM can be used to just reference that due date instead:\n\n$ task add Take out the trash due:friday wait:due\n\nThat ‘due’ is a DOM reference, and it means ‘the due date of the task in hand’. This is not much help now, but one arbitrary date math is supported (perhaps in 2.4.0), it will make the following possible:\n\n$ task add Mothers Day due:2014-05-11 wait:due-1wk\n\nFurthermore, this combination of DOM reference and date math will allow default wait rules to be implemented. A more complex DOM example is when data from a specific task is referenced:\n\n$ task add Buy the ingredients due:21st Task 123 added $ task add Bake the cake due:123.due\n\nThis example shows a reference ‘123.due’ being used when creating task 124. DOM references can also refer to completed and deleted tasks, using the UUID, which means DOM addresses may be one of the following forms:\n\n<attribute> <id>.<attribute> <uuid>.<attribute>\n\nAdditionally, configuration settings can be accessed:\n\nrc.<name>\n\nAnd finally a few program values:\n\nsystem.os system.version context.width context.height context.program context.args\n\nDOM addresses can be accessed using a helper command, new in 2.3.0, named ‘_get’\n\nwhich can be used to evaluate DOM addresses:\n\n$ task _get system.version 2.3.0.beta1 $ task _get 213.project tw.230 $ task _get 208.tags 208.urgency bug 4.838356 $ task _get 1.uuid 8ad2e3db-914d-4832-b0e6-72fa04f6e331 $ task _get 8ad2e3db-914d-4832-b0e6-72fa04f6e331.description Support listing breaks due, hour, day, week, month $ task _get $(task _get 1.uuid).description Support listing breaks due, hour, day, week, month\n\nNote that when querying configuration values, you need to distinguish between the DOM address and a runtime override, by shutting off parsing like this:\n\n$ task _get -- rc.dateformat YYYY-MM-DD\n\nThe DOM is useful for both third-party scripts and user command-line use. New features will make more use of DOM references, and you’ll start to see them being used in example documentation.\n\nVirtual Tags\n\nVirtual Tags\n\nThe tag syntax is very powerful and simple to use. There are two ways to use this, shown here:\n\nThese two commands illustrate the complete tag interface. The first command is a filter that lists only tasks that have the HOME tag. The second command is a filter that lists only tasks that _do not_ have the WORK tag. The + and – syntax means presence and absence of a tag. This is simple to use, and can be combined like this:\n\nThis shows tasks that have the HOME tag, but do not have the WORK tag. This is a very simple and easy to use mechanism, but it does require that your tasks are properly tagged. In other words, it is based directly on task metadata.\n\nComplex Filters\n\nSome Taskwarrior filters are simple in concept, but the syntax is not that straightforward. For example, to determine whether a task has a due date that falls on the current day, you need to use this filter:\n\nThis filters tasks with a due date during the narrow time window of ‘today’. Note that is is not sufficient to just specify the date, because due dates all have associated times (defaulting to 0:00), and if you want to match the date, you need to consider the time. So for example, this command _does not_ list tasks due today:\n\nInstead, this filter matches tasks with a due date of today, and a time of 0:00. In order to see all tasks due today, you need to provide proper range bracketing.\n\nSimplification\n\nHere is where virtual tags can help, by providing a simple tag interface to more complex state conditions of the task. There is a virtual tag, named TODAY that can be used in filters, and it means that instead of this filter:\n\nWe can now use this:\n\nWhich is a much simpler way of filtering tasks due today. Because this is a tag interface, we can also invert it:\n\nThis shows only tasks that are not due today.\n\nVirtual tags are built in to Taskwarrior. They are evaluated at run time, which means they do not require direct metadata, and therefore do not occupy space in the data files, but are determined according to the state of the task in the same way that the complex filter example above is determined.\n\nThus virtual tags combine the ease of use of the tag interface with more complex defined conditions, for convenience.\n\nSupported Virtual Tags\n\nSince version 2.2.0, Taskwarrior has supported virtual tags, and the list will continue to grow. Here are the supported virtual tags as of version 2.3.0:\n\nBLOCKED – Is the task dependent on another incomplete task?\n\nUNBLOCKED – The opposite of BLOCKED, for convenience. Note +BLOCKED == -UNBLOCKED and vice versa.\n\nBLOCKING – Does another task depend on this incomplete task?\n\nDUE – Is this task due within 7 days? Determined by rc.due\n\nDUETODAY – Is this task due sometime today?\n\nTODAY – Is this task due sometime today?\n\nOVERDUE – Is this task past it’s due date?\n\nWEEK – Is this task due this week?\n\nMONTH – Is this task due this month?\n\nYEAR – Is this task due this year?\n\nACTIVE – Is the task active, ie does it have a start date?\n\nSCHEDULED – Is the task scheduled, ie does it have a scheduled date?\n\nPARENT – Is the task a hidden parent recurring task?\n\nCHILD – Is the task a recurring child task?\n\nUNTIL – Does the task expire, ie does it have an until date?\n\nWAITING – Is the task hidden, ie does it have a wait date?\n\nANNOTATED – Does the task have any annotations?\n\nPerhaps you have a suggestion for more virtual tags? Please let us know!\n\nSee http://taskwarrior.org/projects/taskwarrior/wiki/Feature_virtual_tags for the full list that will be updated over time.\n\nThe Multiple Client Challenge\n\nThere is an issue that we need to very careful about. We need to make sure different task server clients don’t corrupt data through the selective implementation of features.\n\nEach client of the task server will implement different functionality. Even if feature parity is attempted, one will likely be released ahead of the other, so essentially there will always be the possibility of different functionality between clients.\n\nBut the data is shared. That’s the tricky part. Fortunately this can be solved with a rule. The rule is this:\n\nA client MUST preserve intact all unrecognized task attributes, for all I/O operations.\n\nThat’s a fairly simple rule, but one that is essential to make different clients work together. Let’s look at an example.\n\nSuppose there is a client that doesn’t support tags. By not supporting tags, it would not show tags, or allow them to be added, removed, or modified. But as a client to the task server, tags are sure to be found in the data. By obeying the rule, any task that does have tags will not lose those tags when handled by the client.\n\nTo look at this at a lower level, the format of the tasks to/from the server is JSON, and the rule says that the JSON structure and contents must be preserved, and only recognized constructs may be manipulated.\n\nThis may sound restrictive, but is in fact very permissive. It allows for clients that are incredibly simple. An example of this might be a Top Ten task app that only supports a completion action on the ten most urgent tasks, and furthermore only displays the descriptions. Such a simple app, by obeying the rule, and implementing only one feature, remains compliant, and does not harm user data, even though it doesn’t understand all the data.\n\nThis opens the door for lightweight clients. Small apps that might simply capture new tasks, or an app that just spell-checks task descriptions. Not every client of the task server needs a UI…\n\nFlod Testing\n\nWhat is Flod?\n\nContinuous Integration is a best practice, and Flod is a tool that manages that for us. While there are many such tools available (and they are very good), this one is incredibly simple. We like simple products.\n\nThere is a development repository, and commits there trigger the need for test builds, recorded by a central server, and serviced by a satellite node. As a developer, you don’t notice this happening, because the software runs (locally or remotely) as a daemon, so it’s all very much behind the scenes.\n\nWhy do we need Flod?\n\nThere were 27 or so releases of Taskwarrior before we started using Flod, so this is not a small data sample. Of those, more than half were bug fix releases. That is to say releases we were obligated to make, to improve stability and quality, rather than releases that were a balance of minor bug fixes and new features. Compounding that, Taskwarrior runs on multiple platforms, and in the past that meant there was a lot of last-minute “does it work on this platform?” experimentation.\n\nSince using Flod for the last year, we have not needed to make any emergency releases. It’s still a little early to tell, but it appears to be working well for us.\n\nWhat are the benefits?\n\nThe main benefit is instant feedback about test failures across multiple platforms, allowing us to respond quickly. This means that the quality of the product is higher during early stage development, and the testing is a good indicator towards the end of the cycle of whether the release is ready. We have higher confidence of the code quality on platforms that we do not use day to day.\n\nNaturally, this depends on other factors, such as having good test coverage, but that’s another discussion.\n\nThe setup we are using looks like this:\n\nWhile that diagram shows three satellites (and therefore three platforms tested), we have about 10 such platforms that run tests as soon as they are able. These satellites are running on a variety of machines and VMs. For example Amazon AWS, Rackspace, Linode, personal machines, VirtualBox and VMWare instances are all running satellites.\n\nNot all of the above are available all the time. The VMs in particular, can spend weeks in an “off” or hibernated state, and when awoken, they process the backlog and go back to sleep. This is common with distributed systems where connectivity is not only not guaranteed, but can be very sporadic.\n\nHere is an example of a live test report, covering several platforms, for the development branch of Taskwarrior.\n\nHow is the community participating?\n\nWe have been very lucky, with several contributors running Flod satellites. Bryan is one example (see taskwarrior-2.3.0) providing an Arch 64-bit platform for testing. This satellite connects daily and runs a limited number of tests to minimize impact, and the result is invaluable – we know that Taskwarrior 2.3.0 runs properly on Arch.\n\nWhere is it going?\n\nFlod will be generalized to be able to handle more revision control systems. The current Git support will be extended to include at least Mercurial. In addition to CMake, we would like to support Autoconf.\n\nIt might also be wise to include other testing setups. Currently TAP is the only supported model, but TAP13 specifically is on the list, which would make for richer reports.\n\nIs it available?\n\nYes and no. While the code is open source, and freely available (Flod), it is not generalized yet, so will only work on the kind of projects we operate (git, cmake, make, TAP). So while Flod is great for us, it needs to mature before it is useful to others. But we still wanted to tell you about it, because it is doing a good job of making Taskwarrior more reliable."
    }
}