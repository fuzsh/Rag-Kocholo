{
    "id": "dbpedia_6853_3",
    "rank": 84,
    "data": {
        "url": "https://www.w3.org/TR/uievents/",
        "read_more_link": "",
        "language": "en",
        "title": "UI Events",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.w3.org/StyleSheets/TR/2021/logos/W3C",
            "https://www.w3.org/TR/uievents/images/event-inheritance.svg",
            "https://www.w3.org/TR/uievents/images/stacked-event-mouse-dispatch.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-06-22T00:00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.w3.org/TR/uievents/",
        "text": "1. Introduction\n\n1.1. Overview\n\nUI Events is designed with two main goals. The first goal is the design of an event system which allows registration of event listeners and describes event flow through a tree structure. Additionally, the specification will provide standard modules of events for user interface control and document mutation notifications, including defined contextual information for each of these event modules.\n\nThe second goal of UI Events is to provide a common subset of the current event systems used in existing browsers. This is intended to foster interoperability of existing scripts and content. It is not expected that this goal will be met with full backwards compatibility. However, the specification attempts to achieve this when possible.\n\n1.2. Conformance\n\nThis section is normative.\n\nWithin this specification, the key words MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD, SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL are to be interpreted as described in [RFC2119].\n\nThis specification is to be understood in the context of the DOM Level 3 Core specification [DOM-Level-3-Core] and the general considerations for DOM implementations apply. For example, handling of namespace URIs is discussed in XML Namespaces. For additional information about conformance, please see the DOM Level 3 Core specification [DOM-Level-3-Core]. A user agent is not required to conform to the entirety of another specification in order to conform to this specification, but it MUST conform to the specific parts of any other specification which are called out in this specification (e.g., a conforming UI Events user agent MUST support the DOMString data type as defined in [WebIDL], but need not support every method or data type defined in [WebIDL] in order to conform to UI Events).\n\nThis specification defines several classes of conformance for different user agents, specifications, and content authors:\n\n1.2.1. Web browsers and other dynamic or interactive user agents\n\nA dynamic or interactive user agent, referred to here as a browser (be it a Web browser, AT (Accessibility Technology) application, or other similar program), conforms to UI Events if it supports:\n\nthe Core module defined in [DOM-Level-3-Core]\n\nall the interfaces and events with their associated methods, attributes, and semantics defined in this specification with the exception of those marked as deprecated (a conforming user agent MAY implement the deprecated interfaces, events, or APIs for backwards compatibility, but is not required to do so in order to be conforming)\n\nthe complete set of key and code values defined in [UIEvents-Key] and [UIEvents-Code] (subject to platform availability), and\n\nall other normative requirements defined in this specification.\n\nA conforming browser MUST dispatch events appropriate to the given EventTarget when the conditions defined for that event type have been met.\n\nA browser conforms specifically to UI Events if it implements the interfaces and related event types specified in this document.\n\nA conforming browser MUST support scripting, declarative interactivity, or some other means of detecting and dispatching events in the manner described by this specification, and MUST support the APIs specified for that event type.\n\nIn addition to meeting all other conformance criteria, a conforming browser MAY implement features of this specification marked as deprecated, for backwards compatibility with existing content, but such implementation is discouraged.\n\nA conforming browser MAY also support features not found in this specification, but which use the interfaces, events, or other features defined in this specification, and MAY implement additional interfaces and event types appropriate to that implementation. Such features can be later standardized in future specifications.\n\nA browser which does not conform to all required portions of this specification MUST NOT claim conformance to UI Events. Such an implementation which does conform to portions of this specification MAY claim conformance to those specific portions.\n\nA conforming browser MUST also be a conforming implementation of the IDL fragments in this specification, as described in the Web IDL specification [WebIDL].\n\nA content authoring tool conforms to UI Events if it produces content which uses the event types, consistent in a manner as defined in this specification.\n\nA content authoring tool MUST NOT claim conformance to UI Events for content it produces which uses features of this specification marked as deprecated in this specification.\n\nA conforming content authoring tool SHOULD provide to the content author a means to use all event types and interfaces appropriate to all host languages in the content document being produced.\n\n1.2.3. Content authors and content\n\nA content author creates conforming UI Events content if that content uses the event types consistent in a manner as defined in this specification.\n\nA content author SHOULD NOT use features of this specification marked as deprecated, but SHOULD rely instead upon replacement mechanisms defined in this specification and elsewhere.\n\nConforming content MUST use the semantics of the interfaces and event types as described in this specification.\n\nContent authors are advised to follow best practices as described in accessibility and internationalization guideline specifications.\n\n1.2.4. Specifications and host languages\n\nA specification or host language conforms to UI Events if it references and uses the event flow mechanism, interfaces, events, or other features defined in [DOM], and does not extend these features in incompatible ways.\n\nA specification or host language conforms specifically to UI Events if it references and uses the interfaces and related event types specified in this document. A conforming specification MAY define additional interfaces and event types appropriate to that specification, or MAY extend the UI Events interfaces and event types in a manner that does not contradict or conflict with the definitions of those interfaces and event types in this specification.\n\nSpecifications or host languages which reference UI Events SHOULD NOT use or recommend features of this specification marked as deprecated, but SHOULD use or recommend the indicated replacement for that the feature (if available).\n\n2. Stylistic Conventions\n\nThis specification follows the Proposed W3C Specification Conventions, with the following supplemental additions:\n\nThe key cap printed on a key is shown as ↓, = or Q. This is used to refer to a key from the user’s perspective without regard for the key and code values in the generated KeyboardEvent.\n\nGlyphs representing character are shown as: \"𣧂\".\n\nUnicode character encodings are shown as: U+003d.\n\nNames of key values generated by a key press (i.e., the value of KeyboardEvent.key) are shown as: \"ArrowDown\", \"=\", \"q\" or \"Q\".\n\nNames of key codes associated with the physical keys (i.e., the value of KeyboardEvent.code) are shown as: \"ArrowDown\", \"Equal\" or \"KeyQ\".\n\nIn addition, certain terms are used in this specification with particular meanings. The term implementation applies to a browser, content authoring tool, or other user agent that implements this specification, while a content author is a person who writes script or code that takes advantage of the interfaces, methods, attributes, events, and other features described in this specification in order to make Web applications, and a user is the person who uses those Web applications in an implementation.\n\nAnd finally:\n\nThis is a note.\n\nThis is an open issue.\n\nThis is a warning.\n\ninterface Example { // This is an IDL definition. };\n\n3. Basic Event Interfaces\n\nThe basic event interfaces defined in [DOM] are fundamental to UI Events. These basic event interfaces MUST always be supported by the implementation:\n\nThe Event interface and its following constants, methods and attributes:\n\nNONE constant\n\nCAPTURING_PHASE constant\n\nAT_TARGET constant\n\nBUBBLING_PHASE constant\n\ntype attribute\n\ntarget attribute\n\ncurrentTarget attribute\n\neventPhase attribute\n\nbubbles attribute\n\ncancelable attribute\n\ncomposed attribute\n\nattribute\n\ndefaultPrevented attribute\n\nisTrusted attribute\n\nstopPropagation() method\n\nstopImmediatePropagation() method\n\npreventDefault() method\n\ninitEvent() method\n\nThe CustomEvent interface and its following method and attribute:\n\ninitCustomEvent() method\n\ndetail attribute\n\nThe EventTarget interface and its following methods:\n\naddEventListener() method\n\nremoveEventListener() method\n\ndispatchEvent() method\n\nThe EventListener interface and its handleEvent() method\n\nThe Document interface’s createEvent() method\n\nThe event types defined in this specification derive from these basic interfaces, and MUST inherit all of the attributes, methods, and constants of the interfaces they derive from.\n\nThe following chart describes the inheritance structure of the interfaces described in this specification.\n\n3.1. List of Event Types\n\nEach event MUST be associated with a type, called event type and available as the type attribute on the event object. The event type MUST be of type DOMString.\n\nDepending on the level of DOM support, or the devices used for display (e.g., screen) or interaction (e.g., mouse, keyboard, touch screen, or voice), these event types can be generated by the implementation. When used with an [XML] or [HTML5] application, the specifications of those languages MAY restrict the semantics and scope (in particular the possible event targets) associated with an event type. Refer to the specification defining the language used in order to find those restrictions or to find event types that are not defined in this document.\n\nThe following table provides an informative summary of the event types described in this specification.\n\nEvent Type Sync / Async Bubbling Phase Trusted event target types DOM Interface Cancelable Default Action abort Sync No Window, Element Event No None auxclick Sync Yes Element PointerEvent Yes Varies beforeinput Sync Yes Element InputEvent Yes Update the DOM element blur Sync No Window, Element FocusEvent No None click Sync Yes Element PointerEvent Yes Varies: for targets with an associated activation behavior, executes the activation behavior; for focusable targets, gives the element focus. compositionstart Sync Yes Element CompositionEvent Yes Show a text composition system candidate window Sync Yes Element CompositionEvent No None compositionend Sync Yes Element CompositionEvent No None contextmenu Sync Yes Element PointerEvent Yes Invoke a context menu if supported dblclick Sync Yes Element MouseEvent No Varies: for targets with an associated activation behavior, executes the activation behavior; for focusable targets, gives the element focus. error Async No Window, Element Event No None focus Sync No Window, Element FocusEvent No None focusin Sync Yes Window, Element FocusEvent No None focusout Sync Yes Window, Element FocusEvent No None input Sync Yes Element InputEvent No None keydown Sync Yes Element KeyboardEvent Yes Varies: trigger beforeinput and input events; launch text composition system; blur and focus events; keypress event (if supported); activation behavior; other events keyup Sync Yes Element KeyboardEvent Yes None load Async No Window, Document, Element Event No None mousedown Sync Yes Element MouseEvent Yes Varies: start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported) mouseenter Sync No Element MouseEvent No None mouseleave Sync No Element MouseEvent No None mousemove Sync Yes Element MouseEvent Yes None mouseout Sync Yes Element MouseEvent Yes None mouseover Sync Yes Element MouseEvent Yes None mouseup Sync Yes Element MouseEvent Yes None select Sync Yes Element Event No None unload Sync No Window, Document, Element Event No None wheel Async Yes Element WheelEvent Yes Scroll (or zoom) the document\n\nFor a list of events which are deprecated in this specification, see the Legacy Event Types appendix at the end of this document.\n\nThe following is one way to interpret the above tables: the load event will trigger event listeners attached on Element nodes for that event and on the capture and target phases. This event is not cancelable. If an event listener for the load event is attached to a node other than Window, Document, or Element nodes, or if it is attached to the bubbling phase only, this event listener would not be triggered.\n\nDon’t interpret the above tables as definitive for the listed event types. For example, the load event is used in other specifications, for example, in XMLHttpRequest. Similarly, dispatchEvent() can be used to dispatch untrusted events to listeners on any object that also implements EventTarget.\n\nThe event objects associated with the event types described above contain additional context information--refer to the description of the DOM interfaces for further information.\n\n3.2. User Interface Events\n\nThe User Interface event module contains basic event types associated with user interfaces and document manipulation.\n\n3.2.1. Interface UIEvent\n\nIntroduced in DOM Level 2\n\nThe UIEvent interface provides specific contextual information associated with User Interface events.\n\nTo create an instance of the UIEvent interface, use the UIEvent constructor, passing an optional UIEventInit dictionary.\n\nFor newly defined events, you don’t have to inherit UIEvent interface just because they are related to user interface. Inherit only when members of UIEventInit make sense to those events.\n\n3.2.1.1. UIEvent\n\n[Exposed=Window] interface UIEvent : Event { constructor(DOMString type, optional UIEventInit eventInitDict = {}); readonly attribute Window? view; readonly attribute long detail; };\n\nUIEvent . view\n\nThe view attribute identifies the Window from which the event was generated.\n\nThe un-initialized value of this attribute MUST be null.\n\nUIEvent . detail\n\nSpecifies some detail information about the Event, depending on the type of event.\n\nThe un-initialized value of this attribute MUST be 0.\n\n3.2.1.2. UIEventInit\n\ndictionary UIEventInit : EventInit { Window? view = null; long detail = 0; };\n\nUIEventInit . view\n\nShould be initialized to the Window object of the global environment in which this event will be dispatched. If this event will be dispatched to an element, the view property should be set to the Window object containing the element’s ownerDocument.\n\nUIEventInit . detail\n\nThis value is initialized to a number that is application-specific.\n\n3.2.2. UIEvent Algorithms\n\n3.2.2.1. initialize a UIEvent\n\nInput\n\nevent, the UIEvent to initialize\n\neventType, a DOMString containing the event type\n\neventTarget, the EventTarget of the event\n\nbubbles, true if this event bubbles\n\ncancelable, true if this event is cancelable\n\nOutput\n\nNone\n\nInitialize the base Event attributes:\n\nInitialize an Event with event, eventType, bubbles and cancelable\n\nSet event.target = eventTarget\n\nInitialize the following public attributes:\n\nSet event.view = the eventTarget’s node document’s Window object\n\nSet event.detail = 0\n\nInitialize the following historical attributes:\n\nSet event.which = 0 (used by both MouseEvent and KeyboardEvent)\n\n3.2.3. UIEvent Types\n\nThe User Interface event types are listed below. Some of these events use the UIEvent interface if generated from a user interface, but the Event interface otherwise, as detailed in each event.\n\n3.2.3.1. load\n\nType load Interface UIEvent if generated from a user interface, Event otherwise. Sync / Async Async Bubbles No Trusted Targets Window, Document, Element Cancelable No Default action None Context\n\n(trusted events)\n\nEvent.target : common object whose contained resources have loaded\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nA user agent MUST dispatch this event when the DOM implementation finishes loading the resource (such as the document) and any dependent resources (such as images, style sheets, or scripts). Dependent resources that fail to load MUST NOT prevent this event from firing if the resource that loaded them is still accessible via the DOM. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.\n\nFor legacy reasons, load events for resources inside the document (e.g., images) do not include the Window in the propagation path in HTML implementations. See [HTML5] for more information.\n\n3.2.3.2. unload\n\nType unload Interface UIEvent if generated from a user interface, Event otherwise. Sync / Async Sync Bubbles No Trusted Targets Window, Document, Element Cancelable No Default action None Context\n\n(trusted events)\n\nEvent.target : common object whose contained resources have been removed\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nA user agent MUST dispatch this event when the DOM Implementation removes from the environment the resource (such as the document) or any dependent resources (such as images, style sheets, scripts). The document MUST be unloaded after the dispatch of this event type. If this event type is dispatched, implementations are REQUIRED to dispatch this event at least on the Document node.\n\n3.2.3.3. abort\n\nType abort Interface UIEvent if generated from a user interface, Event otherwise. Sync / Async Sync Bubbles No Trusted Targets Window, Element Cancelable No Default action None Context\n\n(trusted events)\n\nEvent.target : element whose resources have been stopped from loading without error\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nA user agent MUST dispatch this event when the loading of a resource has been aborted, such as by a user canceling the load while it is still in progress.\n\n3.2.3.4. error\n\nType error Interface UIEvent if generated from a user interface, Event otherwise. Sync / Async Async Bubbles No Trusted Targets Window, Element Cancelable No Default action None Context\n\n(trusted events)\n\nEvent.target : element whose resources have been stopped from loading due to error\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nA user agent MUST dispatch this event when a resource failed to load, or has been loaded but cannot be interpreted according to its semantics, such as an invalid image, a script execution error, or non-well-formed XML.\n\n3.2.3.5. select\n\nType select Interface UIEvent if generated from a user interface, Event otherwise. Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable No Default action None Context\n\n(trusted events)\n\nEvent.target : element whose text content has been selected\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nA user agent MUST dispatch this event when a user selects some text. This event is dispatched after the selection has occurred.\n\nThis specification does not provide contextual information to access the selected text. Where applicable, a host language SHOULD define rules for how a user MAY select content (with consideration for international language conventions), at what point the select event is dispatched, and how a content author MAY access the user-selected content.\n\nIn order to access to user-selected content, content authors will use native capabilities of the host languages, such as the Document.getSelection() method of the HTML Editing APIs [Editing].\n\nThe select event might not be available for all elements in all languages. For example, in [HTML5], select events can be dispatched only on form input and textarea elements. Implementations can dispatch select events in any context deemed appropriate, including text selections outside of form controls, or image or markup selections such as in SVG.\n\n3.3. Focus Events\n\nThis interface and its associated event types and § 3.3.2 Focus Event Order were designed in accordance to the concepts and guidelines defined in User Agent Accessibility Guidelines 2.0 [UAAG20], with particular attention on the focus mechanism and the terms defined in the glossary entry for focus.\n\n3.3.1. Interface FocusEvent\n\nIntroduced in this specification\n\nThe FocusEvent interface provides specific contextual information associated with Focus events.\n\nTo create an instance of the FocusEvent interface, use the FocusEvent constructor, passing an optional FocusEventInit dictionary.\n\n3.3.1.1. FocusEvent\n\n[Exposed=Window] interface FocusEvent : UIEvent { constructor(DOMString type, optional FocusEventInit eventInitDict = {}); readonly attribute EventTarget? relatedTarget; };\n\nFocusEvent . relatedTarget\n\nUsed to identify a secondary EventTarget related to a Focus event, depending on the type of event.\n\nFor security reasons with nested browsing contexts, when tabbing into or out of a nested context, the relevant EventTarget SHOULD be null.\n\nThe un-initialized value of this attribute MUST be null.\n\n3.3.1.2. FocusEventInit\n\ndictionary FocusEventInit : UIEventInit { EventTarget? relatedTarget = null; };\n\nFocusEventInit . relatedTarget\n\nThe relatedTarget should be initialized to the element losing focus (in the case of a focus or focusin event) or the element gaining focus (in the case of a blur or focusout event).\n\n3.3.2. Focus Event Order\n\nThe focus events defined in this specification occur in a set order relative to one another. The following is the typical sequence of events when a focus is shifted between elements (this order assumes that no element is initially focused):\n\nEvent Type Notes User shifts focus 1 focus Sent after first target element receives focus 2 focusin Follows the focus event User shifts focus 3 blur Sent after first target element loses focus 4 focusout Follows the blur event 5 focus Sent after second target element receives focus 6 focusin Follows the focus event\n\nThis specification does not define the behavior of focus events when interacting with methods such as focus() or blur(). See the relevant specifications where those methods are defined for such behavior.\n\n3.3.3. Document Focus and Focus Context\n\nThis event module includes event types for notification of changes in document focus. There are three distinct focus contexts that are relevant to this discussion:\n\nThe operating system focus context which MAY be on one of many different applications currently running on the computer. One of these applications with focus can be a browser.\n\nWhen the browser has focus, the user can switch (such as with the tab key) the application focus context among the different browser user interface fields (e.g., the Web site location bar, a search field, etc.). One of these user interface fields can be the document being shown in a tab.\n\nWhen the document itself has focus, the document focus context can be set to any of the focusable elements in the document.\n\nThe event types defined in this specification deal exclusively with document focus, and the event target identified in the event details MUST only be part of the document or documents in the window, never a part of the browser or operating system, even when switching from one focus context to another.\n\nNormally, a document always has a focused element (even if it is the document element itself) and a persistent focus ring. When switching between focus contexts, the document’s currently focused element and focus ring normally remain in their current state. For example, if a document has three focusable elements, with the second element focused, when a user changes operating system focus to another application and then back to the browser, the second element will still be focused within the document, and tabbing will change the focus to the third element. A host language MAY define specific elements which might receive focus, the conditions under which an element MAY receive focus, the means by which focus MAY be changed, and the order in which the focus changes. For example, in some cases an element might be given focus by moving a pointer over it, while other circumstances might require a mouse click. Some elements might not be focusable at all, and some might be focusable only by special means (clicking on the element), but not by tabbing to it. Documents MAY contain multiple focus rings. Other specifications MAY define a more complex focus model than is described in this specification, including allowing multiple elements to have the current focus.\n\n3.3.4. Focus Event Types\n\nThe Focus event types are listed below.\n\n3.3.4.1. blur\n\nType blur Interface FocusEvent Sync / Async Sync Bubbles No Trusted Targets Window, Element Cancelable No Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : event target losing focus\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nFocusEvent.relatedTarget : event target receiving focus.\n\nA user agent MUST dispatch this event when an event target loses focus. The focus MUST be taken from the element before the dispatch of this event type. This event type is similar to focusout, but does not bubble.\n\n3.3.4.2. focus\n\nType focus Interface FocusEvent Sync / Async Sync Bubbles No Trusted Targets Window, Element Cancelable No Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : event target receiving focus\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nFocusEvent.relatedTarget : event target losing focus (if any).\n\nA user agent MUST dispatch this event when an event target receives focus. The focus MUST be given to the element before the dispatch of this event type. This event type is similar to focusin, but does not bubble.\n\n3.3.4.3. focusin\n\nType focusin Interface FocusEvent Sync / Async Sync Bubbles Yes Trusted Targets Window, Element Cancelable No Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : event target receiving focus\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nFocusEvent.relatedTarget : event target losing focus (if any).\n\nA user agent MUST dispatch this event when an event target receives focus. The event target MUST be the element which received focus. The focus event MUST fire before the dispatch of this event type. This event type is similar to focus, but does bubble.\n\n3.3.4.4. focusout\n\nType focusout Interface FocusEvent Sync / Async Sync Bubbles Yes Trusted Targets Window, Element Cancelable No Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : event target losing focus\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nFocusEvent.relatedTarget : event target receiving focus.\n\nA user agent MUST dispatch this event when an event target loses focus. The event target MUST be the element which lost focus. The blur event MUST fire before the dispatch of this event type. This event type is similar to blur, but does bubble.\n\n3.4. Mouse Events\n\nThe mouse event module originates from the [HTML401] onclick, ondblclick, onmousedown, onmouseup, onmouseover, onmousemove, and onmouseout attributes. This event module is specifically designed for use with pointing input devices, such as a mouse or a trackball.\n\n3.4.1. Interface MouseEvent\n\nIntroduced in DOM Level 2, modified in this specification\n\nThe MouseEvent interface provides specific contextual information associated with Mouse events.\n\nIn the case of nested elements, mouse events are always targeted at the most deeply nested element.\n\nAncestors of the targeted element can use event bubbling to obtain notifications of mouse events which occur within their descendent elements.\n\nTo create an instance of the MouseEvent interface, use the MouseEvent constructor, passing an optional MouseEventInit dictionary.\n\nWhen initializing MouseEvent objects using initMouseEvent, implementations can use the client coordinates clientX and clientY for calculation of other coordinates (such as target coordinates exposed by DOM Level 0 implementations or other proprietary attributes, e.g., pageX).\n\n3.4.1.1. MouseEvent\n\n[Exposed=Window] interface MouseEvent : UIEvent { constructor(DOMString type, optional MouseEventInit eventInitDict = {}); readonly attribute long screenX; readonly attribute long screenY; readonly attribute long clientX; readonly attribute long clientY; readonly attribute long layerX; readonly attribute long layerY; readonly attribute boolean ctrlKey; readonly attribute boolean shiftKey; readonly attribute boolean altKey; readonly attribute boolean metaKey; readonly attribute short button; readonly attribute unsigned short buttons; readonly attribute EventTarget? relatedTarget; boolean getModifierState(DOMString keyArg); };\n\nscreenX, of type long, readonly\n\nThe horizontal coordinate at which the event occurred relative to the origin of the screen coordinate system.\n\nThe un-initialized value of this attribute MUST be 0.\n\nscreenY, of type long, readonly\n\nThe vertical coordinate at which the event occurred relative to the origin of the screen coordinate system.\n\nThe un-initialized value of this attribute MUST be 0.\n\nclientX, of type long, readonly\n\nThe horizontal coordinate at which the event occurred relative to the viewport associated with the event.\n\nThe un-initialized value of this attribute MUST be 0.\n\nclientY, of type long, readonly\n\nThe vertical coordinate at which the event occurred relative to the viewport associated with the event.\n\nThe un-initialized value of this attribute MUST be 0.\n\nlayerX, of type long, readonly\n\nThe horizontal offset from the nearest ancestor element which is a stacking context, is positioned, or paints in the positioned phase when painting a stacking context.\n\nThe un-initialized value of this attribute MUST be 0.\n\nlayerY, of type long, readonly\n\nThe vertical offset from the nearest ancestor element which is a stacking context, is positioned, or paints in the positioned phase when painting a stacking context.\n\nThe un-initialized value of this attribute MUST be 0.\n\nctrlKey, of type boolean, readonly\n\nRefer to the KeyboardEvent's ctrlKey attribute.\n\nThe un-initialized value of this attribute MUST be false.\n\nshiftKey, of type boolean, readonly\n\nRefer to the KeyboardEvent's shiftKey attribute.\n\nThe un-initialized value of this attribute MUST be false.\n\naltKey, of type boolean, readonly\n\nRefer to the KeyboardEvent's altKey attribute.\n\nThe un-initialized value of this attribute MUST be false.\n\nmetaKey, of type boolean, readonly\n\nRefer to the KeyboardEvent's metaKey attribute.\n\nThe un-initialized value of this attribute MUST be false.\n\nbutton, of type short, readonly\n\nDuring mouse events caused by the depression or release of a mouse button, button MUST be used to indicate which pointer device button changed state.\n\nThe value of the button attribute MUST be as follows:\n\n0 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text) or the un-initialized value.\n\n1 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).\n\n2 MUST indicate the secondary button (in general, the right button, often used to display a context menu).\n\n3 MUST indicate the X1 (back) button.\n\n4 MUST indicate the X2 (forward) button.\n\nSome pointing devices provide or simulate more button states, and values higher than 2 or lower than 0 MAY be used to represent such buttons.\n\nThe value of button is not updated for events not caused by the depression/release of a mouse button. In these scenarios, take care not to interpret the value 0 as the left button, but rather as the un-initialized value.\n\nSome default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.\n\nThe un-initialized value of this attribute MUST be 0.\n\nbuttons, of type unsigned short, readonly\n\nDuring any mouse events, buttons MUST be used to indicate which combination of mouse buttons are currently being pressed, expressed as a bitmask.\n\nThough similarly named, the values for the buttons attribute and the button attribute are very different. The value of button is assumed to be valid during mousedown / mouseup event handlers, whereas the buttons attribute reflects the state of the mouse’s buttons for any trusted MouseEvent object (while it is being dispatched), because it can represent the \"no button currently active\" state (0).\n\nThe value of the buttons attribute MUST be as follows:\n\n0 MUST indicate no button is currently active.\n\n1 MUST indicate the primary button of the device (in general, the left button or the only button on single-button devices, used to activate a user interface control or select text).\n\n2 MUST indicate the secondary button (in general, the right button, often used to display a context menu), if present.\n\n4 MUST indicate the auxiliary button (in general, the middle button, often combined with a mouse wheel).\n\nSome pointing devices provide or simulate more buttons. To represent such buttons, the value MUST be doubled for each successive button (in the binary series 8, 16, 32, ... ).\n\nBecause the sum of any set of button values is a unique number, a content author can use a bitwise operation to determine how many buttons are currently being pressed and which buttons they are, for an arbitrary number of mouse buttons on a device. For example, the value 3 indicates that the left and right button are currently both pressed, while the value 5 indicates that the left and middle button are currently both pressed.\n\nSome default actions related to events such as mousedown and mouseup depend on the specific mouse button in use.\n\nThe un-initialized value of this attribute MUST be 0.\n\nrelatedTarget, of type EventTarget, readonly, nullable\n\nUsed to identify a secondary EventTarget related to a UI event, depending on the type of event.\n\nThe un-initialized value of this attribute MUST be null.\n\ngetModifierState(keyArg)\n\nIntroduced in this specification\n\nQueries the state of a modifier using a key value.\n\nReturns true if it is a modifier key and the modifier is activated, false otherwise.\n\nDOMString keyArg\n\nRefer to the KeyboardEvent's getModifierState() method for a description of this parameter.\n\n3.4.1.2. MouseEventInit\n\ndictionary MouseEventInit : EventModifierInit { long screenX = 0; long screenY = 0; long clientX = 0; long clientY = 0; short button = 0; unsigned short buttons = 0; EventTarget? relatedTarget = null; };\n\nscreenX, of type long, defaulting to 0\n\nInitializes the screenX attribute of the MouseEvent object to the desired horizontal relative position of the mouse pointer on the user’s screen.\n\nInitializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.\n\nscreenY, of type long, defaulting to 0\n\nInitializes the screenY attribute of the MouseEvent object to the desired vertical relative position of the mouse pointer on the user’s screen.\n\nInitializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.\n\nclientX, of type long, defaulting to 0\n\nInitializes the clientX attribute of the MouseEvent object to the desired horizontal position of the mouse pointer relative to the client window of the user’s browser.\n\nInitializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.\n\nclientY, of type long, defaulting to 0\n\nInitializes the clientY attribute of the MouseEvent object to the desired vertical position of the mouse pointer relative to the client window of the user’s browser.\n\nInitializing the event object to the given mouse position must not move the user’s mouse pointer to the initialized position.\n\nbutton, of type short, defaulting to 0\n\nInitializes the button attribute of the MouseEvent object to a number representing the desired state of the button(s) of the mouse.\n\nThe value 0 is used to represent the primary mouse button, 1 is used to represent the auxiliary/middle mouse button, and 2 to represent the right mouse button. Numbers greater than 2 are also possible, but are not specified in this document.\n\nbuttons, of type unsigned short, defaulting to 0\n\nInitializes the buttons attribute of the MouseEvent object to a number representing one or more of the button(s) of the mouse that are to be considered active.\n\nThe buttons attribute is a bit-field. If a mask value of 1 is true when applied to the value of the bit field, then the primary mouse button is down. If a mask value of 2 is true when applied to the value of the bit field, then the right mouse button is down. If a mask value of 4 is true when applied to the value of the bit field, then the auxiliary/middle button is down.\n\nIn JavaScript, to initialize the buttons attribute as if the right (2) and middle button (4) were being pressed simultaneously, the buttons value can be assigned as either:\n\n{ buttons: 2 | 4 }\n\nor:\n\n{ buttons: 6 }\n\nrelatedTarget, of type EventTarget, nullable, defaulting to null\n\nThe relatedTarget should be initialized to the element whose bounds the mouse pointer just left (in the case of a mouseover or mouseenter event) or the element whose bounds the mouse pointer is entering (in the case of a mouseout or mouseleave or focusout event). For other events, this value need not be assigned (and will default to null).\n\nImplementations MUST maintain the current click count when generating mouse events. This MUST be a non-negative integer indicating the number of consecutive clicks of a pointing device button within a specific time. The delay after which the count resets is specific to the environment configuration.\n\n3.4.2. Event Modifier Initializers\n\nThe MouseEvent and KeyboardEvent interfaces share a set of keyboard modifier attributes and support a mechanism for retrieving additional modifier states. The following dictionary enables authors to initialize keyboard modifier attributes of the MouseEvent and KeyboardEvent interfaces, as well as the additional modifier states queried via getModifierState(). The steps for constructing events using this dictionary are defined in the MouseEvent constructors section.\n\ndictionary EventModifierInit : UIEventInit { boolean ctrlKey = false; boolean shiftKey = false; boolean altKey = false; boolean metaKey = false; boolean modifierAltGraph = false; boolean modifierCapsLock = false; boolean modifierFn = false; boolean modifierFnLock = false; boolean modifierHyper = false; boolean modifierNumLock = false; boolean modifierScrollLock = false; boolean modifierSuper = false; boolean modifierSymbol = false; boolean modifierSymbolLock = false; };\n\nctrlKey, of type boolean, defaulting to false\n\nInitializes the ctrlKey attribute of the MouseEvent or KeyboardEvent objects to true if the Control key modifier is to be considered active, false otherwise.\n\nWhen true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Control must return true.\n\nshiftKey, of type boolean, defaulting to false\n\nInitializes the shiftKey attribute of the MouseEvent or KeyboardEvent objects to true if the Shift key modifier is to be considered active, false otherwise.\n\nWhen true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Shift must return true.\n\naltKey, of type boolean, defaulting to false\n\nInitializes the altKey attribute of the MouseEvent or KeyboardEvent objects to true if the Alt (alternative) (or Option) key modifier is to be considered active, false otherwise.\n\nWhen true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Alt must return true.\n\nmetaKey, of type boolean, defaulting to false\n\nInitializes the metaKey attribute of the MouseEvent or KeyboardEvent objects to true if the Meta key modifier is to be considered active, false otherwise.\n\nWhen true, implementations must also initialize the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with either the parameter Meta must return true.\n\nmodifierAltGraph, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter AltGraph must return true.\n\nmodifierCapsLock, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter CapsLock must return true.\n\nmodifierFn, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Fn must return true.\n\nmodifierFnLock, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter FnLock must return true.\n\nmodifierHyper, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Hyper must return true.\n\nmodifierNumLock, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter NumLock must return true.\n\nmodifierScrollLock, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter ScrollLock must return true.\n\nmodifierSuper, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Super must return true.\n\nmodifierSymbol, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter Symbol must return true.\n\nmodifierSymbolLock, of type boolean, defaulting to false\n\nInitializes the event object’s key modifier state such that calls to the getModifierState() or getModifierState() when provided with the parameter SymbolLock must return true.\n\n3.4.2.1. Constructing Mouse Events\n\nGenerally, when a constructor of an Event interface, or of an interface inherited from the Event interface, is invoked, the steps described in [DOM] should be followed. However the MouseEvent interfaces provide additional dictionary members for initializing the internal state of the Event object’s key modifiers: specifically, the internal state queried for using the getModifierState() methods. This section supplements the DOM4 steps for intializing a new MouseEvent object with these optional modifier states.\n\nFor the purposes of constructing a MouseEvent, or object derived from these objects using the algorithm below, all MouseEvent, and derived objects have internal key modifier state which can be set and retrieved using the key modifier names described in the Modifier Keys table in [UIEvents-Key].\n\nThe following steps supplement the algorithm defined for constructing events in DOM4:\n\nIf the Event being constructed is a MouseEvent object or an object that derives from it, and a EventModifierInit argument was provided to the constructor, then run the following sub-steps:\n\nFor each EventModifierInit argument, if the dictionary member begins with the string \"modifier\", then let the key modifier name be the dictionary member’s name excluding the prefix \"modifier\", and set the Event object’s internal key modifier state that matches the key modifier name to the corresponding value.\n\n3.4.3. MouseEvent Algorithms\n\n3.4.3.1. Native OS Requirements\n\nThe algorithms in this section assume that the native platform OS will provide the following:\n\nAn event when the mouse is moved (handled by handle native mouse move)\n\nAn event when a mouse button is pressed (handled by handle native mouse down)\n\nAn event when a mouse button is released (handled by handle native mouse up)\n\nA way to identify when a mouse button press should be interpreted as a \"click\" (handled by handle native mouse click)\n\nFor example, as a flag or as a separate event\n\nIf a separate \"click\" event is fired, then the native OS will fire it immediately after the corresponding \"mouse up\" event, with no intervening mouse-related events\n\nA way to identify when a mouse click is a \"double click\" (handled by handle native mouse double click)\n\nFor these events, the OS will be able to provide the following info:\n\nThe x,y mouse coordinates relative to the native OS desktop\n\nThe x,y mouse coordinates relative to the UA’s window viewport\n\nWhich keyboard modifiers are currently being held\n\n3.4.3.2. Global State for MouseEvent\n\n3.4.3.2.1. User Agent-Level State\n\nThe UA must maintain the following values that are shared for the entire User Agent.\n\nA mouse button bitmask that tracks the current state of the mouse buttons.\n\n3.4.3.2.2. Window-Level State\n\nThe UA must maintain the following values that are shared for the Window.\n\nA last mouse element value (initially undefined) that keeps track of the last Element that we sent a MouseEvent to.\n\nA last mouse DOM path value (initially empty) that contains a snapshot of the ancestors Elements of the last mouse element when the most recent mouse event was sent.\n\n3.4.3.3. Internal State for MouseEvent\n\nA MouseEvent has the following internal flags that are used to track the state of various modifier keys: shift flag, control flag, alt flag, altgraph flag, and meta flag. These flags are set if the corresponding modifier key was pressed at the time of the mouse event.\n\n3.4.3.4. initialize a MouseEvent\n\nInput\n\nevent, the MouseEvent to initialize\n\neventType, a DOMString containing the event type\n\neventTarget, the EventTarget of the event\n\nbubbles, true if this event bubbles\n\ncancelable, true if this event is cancelable\n\nOutput\n\nNone\n\nInitialize a UIEvent with event, eventType, eventTarget, bubbles and cancelable.\n\nInitialize the following public attributes:\n\nSet event.screenX = the x-coordinate of the position where the event occurred relative to the origin of the desktop\n\nSet event.screenY = the y-coordinate of the position where the event occurred relative to the origin of the desktop\n\nSet event.clientX = the x-coordinate of the position where the event occurred relative to the origin of the viewport\n\nSet event.clientY = the y-coordinate of the position where the event occurred relative to the origin of the viewport\n\nSet mouse event modifiers with event\n\nSet event.button = 0\n\nSet event.buttons = mouse button bitmask\n\nInitialize PointerLock attributes for MouseEvent with event\n\n3.4.3.5. set mouse event modifiers\n\nInput\n\nevent, the MouseEvent to update\n\nOutput\n\nNone\n\nSet event’s shift flag if key modifier state includes \"Shift\", unset it otherwise\n\nSet event’s control flag if key modifier state includes \"Control\", unset it otherwise\n\nSet event’s alt flag if key modifier state includes \"Alt\", unset it otherwise\n\nSet event’s altgraph flag if key modifier state includes \"AltGraph\", unset it otherwise\n\nSet event’s meta flag if key modifier state includes \"Meta\", unset it otherwise\n\nSet event.shiftKey = true if the event’s shift flag is set, false otherwise\n\nSet event.ctrlKey = true if the event’s control flag is set, false otherwise\n\nSet event.altKey = true if the event’s alt flag or altgraph flag is set, false otherwise\n\nSet event.metaKey = true if the event’s meta flag is set, false otherwise\n\n3.4.3.6. create a cancelable MouseEvent\n\nInput\n\neventType, a DOMString containing a valid MouseEvent type\n\neventTarget, the EventTarget of the event\n\nOutput\n\nNone\n\nLet bubbles be \"true\"\n\nLet cancelable be \"true\"\n\nLet event = the result of creating a new event using MouseEvent\n\nInitialize a MouseEvent with event, eventType, eventTarget, bubbles and cancelable.\n\nReturn event\n\n3.4.3.7. create a non-cancelable MouseEvent\n\nInput\n\neventType, a DOMString containing a valid MouseEvent type\n\neventTarget, the EventTarget of the event\n\nOutput\n\nNone\n\nLet bubbles be \"false\"\n\nLet cancelable be \"false\"\n\nLet event = the result of creating a new event using MouseEvent\n\nInitialize a MouseEvent with event, eventType, eventTarget, bubbles and cancelable.\n\nReturn event\n\n3.4.3.8. calculate MouseEvent button attribute\n\nInput\n\nmbutton, an ID that identifies a mouse button\n\nOutput\n\nA button ID suitable for storing in the MouseEvent's button attribute\n\nIf mbutton is the primary mouse button, then return 0\n\nIf mbutton is the auxiliary (middle) mouse button, then return 1\n\nIf mbutton is the secondary mouse button, then return 2\n\nIf mbutton is the X1 (back) button, then return 3\n\nIf mbutton is the X2 (forward) button, then return 4\n\n3.4.3.9. set MouseEvent attributes from native\n\nInput\n\nevent, the MouseEvent to initialize\n\nnative, the native mouse event\n\nOutput\n\nNone\n\nTODO\n\nIf event.type is one of [ mousedown, mouseup ], then\n\nLet mbutton be an ID from native that identifies which mouse button was pressed\n\nSet event.button = calculate MouseEvent button attribute with mbutton\n\n3.4.3.10. handle native mouse down\n\nInput\n\nnative, the native mousedown\n\nOutput\n\nNone\n\nLet mbutton be an ID from native that identifies which mouse button was pressed\n\nUpdate the mouse button bitmask as follows:\n\nIf mbutton is the primary mouse button, then set the 0x01 bit\n\nIf mbutton is the secondary mouse button, then set the 0x02 bit\n\nIf mbutton is the auxiliary (middle) mouse button, then set the 0x04 bit\n\nOther buttons can be added starting with 0x08\n\nLet target = hit test with viewport-relative coordinates from native\n\nLet event = create a cancelable MouseEvent with \"mousedown\", target\n\nSet MouseEvent attributes from native with native\n\nMaybe send pointerdown event with event\n\nLet result = dispatch event at target\n\nIf result is true and target is a focusable area that is click focusable, then\n\nRun the focusing steps at target\n\nif mbutton is the secondary mouse button, then\n\nMaybe show context menu with native, target\n\n3.4.3.11. handle native mouse up\n\nInput\n\nnative, the native mouseup\n\nOutput\n\nNone\n\nOther mouse events can occur between the mousedown and mouseup.\n\nLet mbutton be an ID from native that identifies which mouse button was pressed\n\nUpdate the mouse button bitmask as follows:\n\nIf mbutton is the primary mouse button, then clear the 0x01 bit\n\nIf mbutton is the secondary mouse button, then clear the 0x02 bit\n\nIf mbutton is the auxiliary (middle) mouse button, then clear the 0x04 bit\n\nLet target = hit test with viewport-relative coordinates from native\n\nLet event = create a cancelable MouseEvent with \"mouseup\", target\n\nSet MouseEvent attributes from native with native\n\nMaybe send pointerup event with event\n\ndispatch event at target\n\n3.4.3.12. handle native mouse click\n\nInput\n\nnative, the native mouse click\n\nOutput\n\nNone\n\nThe platform should call this immediately after handle native mouse up for mouseups that generate clicks.\n\nLet target = hit test with viewport-relative coordinates from native\n\nSend click event with native and target.\n\n3.4.3.13. send click event\n\nInput\n\nnative, the native mousedown\n\ntarget, the EventTarget of the event\n\nOutput\n\nNone\n\nLet mbutton = 1 (primary mouse button by default)\n\nIf native is valid, then\n\nLet mbutton be an ID from native that identifies which mouse button was pressed\n\nSet eventType = \"click\" if mbutton is the primary mouse button, otherwise \"auxclick\"\n\nLet event = create a PointerEvent with eventType and target\n\nIf native is valid, then\n\nSet MouseEvent attributes from native with event, native\n\nIf event.screenX is not an integer value, then round it.\n\nIf event.screenY is not an integer value, then round it.\n\ndispatch event at target\n\nSee pointerevents/100 for info about browsers using PointerEvents and rounded coordinates.\n\nAny \"default action\" is handled during dispatch by triggering the activation behavior algorithm for the target. So there is no need for handle that here. However, need to verify that the existing spec handles disabled/css-pointer-events/inert/...\n\nTo handle `HTMLelement.click()`, call this algorithm with native = null and target = `HTMLelement`.\n\nTo handle keyboard-initiated clicks, call this algorithm with native = null and target = currently focused element.\n\n3.4.3.14. handle native mouse double click\n\nInput\n\nnative, the native mouse double click\n\nOutput\n\nNone\n\nThis should be called immediately after handle native mouse click for mouse clicks that generate double clicks.\n\nLet mbutton be an ID from native that identifies which mouse button was pressed\n\nIf mbutton is not the primary mouse button, then return\n\nLet target = hit test with viewport-relative coordinates from native\n\nLet event = create a PointerEvent with \"dblclick\" and target\n\nSet MouseEvent attributes from native with event, native\n\nIf event.screenX is not an integer value, then round it.\n\nIf event.screenY is not an integer value, then round it.\n\ndispatch event at target\n\n3.4.3.15. handle native mouse move\n\nInput\n\nnative, the native mouse move\n\nOutput\n\nNone\n\nThis algorithm makes assumptions about the dispatch of PointerEvents because they are not currently specified explicitly. Once pointerevents/285 is resolved this may need to be updated.\n\nLet target = hit test with viewport-relative coordinates from native\n\nLet targetDomPath = calculate DOM path\n\nGenerate events for leaving the current element:\n\nIf last mouse element is defined and not equal to target, then\n\nLet mouseout = create a cancelable MouseEvent with \"mouseout\" and last mouse element\n\nTODO: Set mouseout attributes from native. +CSSOM attributes\n\nMaybe send pointerout event with mouseout\n\nDispatch mouseout at target\n\nVerify behavior when canceled (appears to have no effect).\n\nLet leaveElements be a copy of last mouse DOM path with all elements common to targetDomPath removed.\n\nFor each element in leaveElements, do\n\nHandle case where element has been deleted. Also case where it has been moved: Should the DOM mutation have triggered a mouseleave event? Should we sent it now? Should it be dropped? Need to verify what current browsers do.\n\nLet mouseleave = create a non-cancelable MouseEvent with \"mouseleave\" and element\n\nSet mouseleave.composed = false\n\nCheck compat: Value of event.composed. Spec says false. Chrome/Linux = true. Firefox/Linux = false.\n\nMaybe send pointerleave event with mouseleave\n\nLet result = dispatch mouseleave at element\n\nGenerate events for entering the new element:\n\nIf target is not last mouse element, then\n\nLet mouseover = create a cancelable MouseEvent with \"mouseover\" and target\n\nTODO: Set mouseout attributes from native. +CSSOM attributes\n\nMaybe send pointerover event with mouseover\n\nDispatch mouseout at target\n\nNeed to verify behavior when canceled (appears to have no effect).\n\nLet enterElements be a copy of targetDomPath with all elements common to last mouse DOM path removed.\n\nFor each element in enterElements, do\n\nHandle case where element has been deleted or moved.\n\nLet mouseenter = create a non-cancelable MouseEvent with \"mouseenter\" and element\n\nSet mouseenter.composed = false\n\nCheck compat: Value of event.composed. Spec says false. Chrome/Linux = true. Firefox/Linux = false.\n\nMaybe send pointerenter event with mouseenter\n\nCheck compat for shadow DOM elements. Chrome/Linux fires this event at the element and the shadow root.\n\nLet result = dispatch mouseenter at element\n\nSet last mouse element to target\n\nSet last mouse DOM path to targetDomPath\n\nLet mousemove = create a cancelable MouseEvent with \"mousemove\" and element\n\nSet PointerLock attributes for mousemove\n\nMaybe send pointermove event with mousemove\n\nDispatch mousemove at element\n\n3.4.3.16. maybe show context menu\n\nInput\n\nnative, the native mousedown or pointer event\n\ntarget, the EventTarget of the event\n\nOutput\n\nNone\n\nLet menuevent = create a PointerEvent with \"contextmenu\", target\n\nIf native is valid, then\n\nSet MouseEvent attributes from native with native\n\nLet result = dispatch menuevent at target\n\nIf result is true, then show the UA context menu\n\nTo handle a context menu triggered by the keyboard, call this algorithm with native = null and target = currently focused element.\n\n3.4.4. Mouse Event Order\n\nCertain mouse events defined in this specification MUST occur in a set order relative to one another. The following shows the event sequence that MUST occur when a pointing device’s cursor is moved over an element:\n\nEvent Type Element Notes 1 mousemove Pointing device is moved into element A... 2 mouseover A 3 mouseenter A 4 mousemove A Multiple mousemove events Pointing device is moved out of element A... 5 mouseout A 6 mouseleave A\n\nWhen a pointing device is moved into an element A, and then into a nested element B and then back out again, the following sequence of events MUST occur:\n\nEvent Type Element Notes 1 mousemove Pointing device is moved into element A... 2 mouseover A 3 mouseenter A 4 mousemove A Multiple mousemove events Pointing device is moved into nested element B... 5 mouseout A 6 mouseover B 7 mouseenter B 8 mousemove B Multiple mousemove events Pointing device is moved from element B into A... 9 mouseout B 10 mouseleave B 11 mouseover A 12 mousemove A Multiple mousemove events Pointing device is moved out of element A... 13 mouseout A 14 mouseleave A\n\nSometimes elements can be visually overlapped using CSS. In the following example, three elements labeled A, B, and C all have the same dimensions and absolute position on a web page. Element C is a child of B, and B is a child of A in the DOM:\n\nWhen the pointing device is moved from outside the element stack to the element labeled C and then moved out again, the following series of events MUST occur:\n\nEvent Type Element Notes 1 mousemove Pointing device is moved into element C, the topmost element in the stack 2 mouseover C 3 mouseenter A 4 mouseenter B 5 mouseenter C 6 mousemove C Multiple mousemove events Pointing device is moved out of element C... 7 mouseout C 8 mouseleave C 9 mouseleave B 10 mouseleave A\n\nThe mouseover/mouseout events are only fired once, while mouseenter/mouseleave events are fired three times (once to each element).\n\nThe following is the typical sequence of events when a button associated with a pointing device (e.g., a mouse button or trackpad) is pressed and released over an element:\n\nEvent Type Notes 1 mousedown 2 mousemove OPTIONAL, multiple events, some limits 3 mouseup 4 click 5 mousemove OPTIONAL, multiple events, some limits 6 mousedown 7 mousemove OPTIONAL, multiple events, some limits 8 mouseup 9 click 10 dblclick\n\nThe lag time, degree, distance, and number of mousemove events allowed between the mousedown and mouseup events while still firing a click or dblclick event will be implementation-, device-, and platform-specific. This tolerance can aid users that have physical disabilities like unsteady hands when these users interact with a pointing device.\n\nEach implementation will determine the appropriate hysteresis tolerance, but in general SHOULD fire click and dblclick events when the event target of the associated mousedown and mouseup events is the same element with no mouseout or mouseleave events intervening, and SHOULD fire click and dblclick events on the nearest common inclusive ancestor when the associated mousedown and mouseup event targets are different.\n\nIf a mousedown event was targeted at an HTML document’s body element, and the corresponding mouseup event was targeted at the root element, then the click event will be dispatched to the root element, since it is the nearest common inclusive ancestor.\n\nIf the event target (e.g. the target element) is removed from the DOM during the mouse events sequence, the remaining events of the sequence MUST NOT be fired on that element.\n\nIf the target element is removed from the DOM as the result of a mousedown event, no events for that element will be dispatched for mouseup, click, or dblclick, nor any default activation events. However, the mouseup event will still be dispatched on the element that is exposed to the mouse after the removal of the initial target element. Similarly, if the target element is removed from the DOM during the dispatch of a mouseup event, the click and subsequent events will not be dispatched.\n\n3.4.5. Mouse Event Types\n\nThe Mouse event types are listed below. In the case of nested elements, mouse event types are always targeted at the most deeply nested element. Ancestors of the targeted element MAY use bubbling to obtain notification of mouse events which occur within its descendent elements.\n\n3.4.5.1. auxclick\n\nType auxclick Interface PointerEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action Varies Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : value based on current button pressed\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nFor PointerEvent specific attributes, see the [PointerEvents3] spec.\n\nThe auxclick event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the non-primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.\n\nThe auxclick event should only be fired for the non-primary pointer buttons (i.e., when button value is not 0, buttons value is greater than 1). The primary button (like the left button on a standard mouse) MUST NOT fire auxclick events. See click for a corresponding event that is associated with the primary button.\n\nThe auxclick event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the auxclick event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button.\n\nThe default action of the auxclick event type varies based on the event target of the event and the value of the button or buttons attributes. Typical default actions of the auxclick event type are as follows:\n\nIf the event target has associated activation behavior, the default action MUST be to execute that activation behavior.\n\nReceiving and handling auxclick for the middle button.\n\nmyLink.addEventListener(\"auxclick\", function(e) { if (e.button === 1) { // This would prevent the default behavior which is for example // opening a new tab when middle clicking on a link. e.preventDefault(); // Do something else to handle middle button click like taking // care of opening link or non-link buttons in new tabs in a way // that fits the app. Other actions like closing a tab in a tab-strip // which should be done on the click action can be done here too. } });\n\nIn the case of right button, the auxclick event is dispatched after any contextmenu event. Note that some user agents swallow all input events while a context menu is being displayed, so auxclick may not be available to applications in such scenarios. See this example for more clarification.\n\nReceiving and handling auxclick for the right button\n\nmyDiv.addEventListener(\"contextmenu\", function(e) { // This call makes sure no context menu is shown // to interfere with page receiving the events. e.preventDefault(); }); myDiv.addEventListener(\"auxclick\", function(e) { if (e.button === 2) { // Do something else to handle right button click like opening a // customized context menu inside the app. } });\n\n3.4.5.2. click\n\nType click Interface PointerEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action Varies Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : indicates the current click count; the attribute value MUST be 1 when the user begins this action and increments by 1 for each click.\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : value based on current button pressed\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nFor PointerEvent specific attributes, see the [PointerEvents3] spec.\n\nThe click event type MUST be dispatched on the topmost event target indicated by the pointer, when the user presses down and releases the primary pointer button, or otherwise activates the pointer in a manner that simulates such an action. The actuation method of the mouse button depends upon the pointer device and the environment configuration, e.g., it MAY depend on the screen location or the delay between the press and release of the pointing device button.\n\nThe click event should only be fired for the primary pointer button (i.e., when button value is 0, buttons value is 1). Secondary buttons (like the middle or right button on a standard mouse) MUST NOT fire click events. See auxclick for a corresponding event that is associated with the non-primary buttons.\n\nThe click event MAY be preceded by the mousedown and mouseup events on the same element, disregarding changes between other node types (e.g., text nodes). Depending upon the environment configuration, the click event MAY be dispatched if one or more of the event types mouseover, mousemove, and mouseout occur between the press and release of the pointing device button. The click event MAY also be followed by the dblclick event.\n\nIf a user mouses down on a text node child of a <p> element which has been styled with a large line-height, shifts the mouse slightly such that it is no longer over an area containing text but is still within the containing block of that <p> element (i.e., the pointer is between lines of the same text block, but not over the text node per se), then subsequently mouses up, this will likely still trigger a click event (if it falls within the normal temporal hysteresis for a click), since the user has stayed within the scope of the same element. Note that user-agent-generated mouse events are not dispatched on text nodes.\n\nIn addition to being associated with pointer devices, the click event type MUST be dispatched as part of an element activation.\n\nFor maximum accessibility, content authors are encouraged to use the click event type when defining activation behavior for custom controls, rather than other pointing-device event types such as mousedown or mouseup, which are more device-specific. Though the click event type has its origins in pointer devices (e.g., a mouse), subsequent implementation enhancements have extended it beyond that association, and it can be considered a device-independent event type for element activation.\n\nThe default action of the click event type varies based on the event target of the event and the value of the button or buttons attributes. Typical default actions of the click event type are as follows:\n\nIf the event target has associated activation behavior, the default action MUST be to execute that activation behavior.\n\nIf the event target is focusable, the default action MUST be to give that element document focus.\n\n3.4.5.3. contextmenu\n\nType contextmenu Interface PointerEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action Invoke a context menu if supported. Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : value based on current button pressed\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nA user agent MUST dispatch this event before invoking a context menu.\n\nWhen the contextmenu event is triggered by right mouse button, the contextmenu event MUST be dispatched after the mousedown event.\n\nDepending on the platform, the contextmenu event may be dispatched before or after the mouseup event.\n\n3.4.5.4. dblclick\n\nType dblclick Interface MouseEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : indicates the current click count\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : value based on current button pressed\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nA user agent MUST dispatch this event when the primary button of a pointing device is clicked twice over an element. The definition of a double click depends on the environment configuration, except that the event target MUST be the same between mousedown, mouseup, and dblclick. This event type MUST be dispatched after the event type click if a click and double click occur simultaneously, and after the event type mouseup otherwise.\n\nAs with the click event, the dblclick event should only be fired for the primary pointer button. Secondary buttons MUST NOT fire dblclick events.\n\nCanceling the click event does not affect the firing of a dblclick event.\n\nAs with the click event type, the default action of the dblclick event type varies based on the event target of the event and the value of the button or buttons attributes. The typical default actions of the dblclick event type match those of the click event type.\n\n3.4.5.5. mousedown\n\nType mousedown Interface MouseEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action Varies: Start a drag/drop operation; start a text selection; start a scroll/pan interaction (in combination with the middle mouse button, if supported) Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : indicates the current click count incremented by one. For example, if no click happened before the mousedown, detail will contain the value 1\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : value based on current button pressed\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nA user agent MUST dispatch this event when a pointing device button is pressed over an element.\n\nMany implementations use the mousedown event to begin a variety of contextually dependent default actions. These default actions can be prevented if this event is canceled. Some of these default actions could include: beginning a drag/drop interaction with an image or link, starting text selection, etc. Additionally, some implementations provide a mouse-driven panning feature that is activated when the middle mouse button is pressed at the time the mousedown event is dispatched.\n\n3.4.5.6. mouseenter\n\nType mouseenter Interface MouseEvent Sync / Async Sync Bubbles No Trusted Targets Element Cancelable No Composed No Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : 0\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : indicates the event target a pointing device is exiting, if any.\n\nA user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or one of its descendent elements. A user agent MUST also dispatch this event when the element or one of its descendants moves to be underneath the primary pointing device. This event type is similar to mouseover, but differs in that it does not bubble, and MUST NOT be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.\n\nThere are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseleave event type.\n\n3.4.5.7. mouseleave\n\nType mouseleave Interface MouseEvent Sync / Async Sync Bubbles No Trusted Targets Element Cancelable No Composed No Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : 0\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : indicates the event target a pointing device is exiting, if any.\n\nA user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element and all of its descendent elements. A user agent MUST also dispatch this event when the element or one of its descendants moves to be no longer underneath the primary pointing device. This event type is similar to mouseout, but differs in that does not bubble, and that it MUST NOT be dispatched until the pointing device has left the boundaries of the element and the boundaries of all of its children.\n\nThere are similarities between this event type and the CSS :hover pseudo-class [CSS2]. See also the mouseenter event type.\n\n3.4.5.8. mousemove\n\nType mousemove Interface MouseEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : 0\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nA user agent MUST dispatch this event when a pointing device is moved while it is over an element. The frequency rate of events while the pointing device is moved is implementation-, device-, and platform-specific, but multiple consecutive mousemove events SHOULD be fired for sustained pointer-device movement, rather than a single event for each instance of mouse movement. Implementations are encouraged to determine the optimal frequency rate to balance responsiveness with performance.\n\nIn some implementation environments, such as a browser, mousemove events can continue to fire if the user began a drag operation (e.g., a mouse button is pressed) and the pointing device has left the boundary of the user agent.\n\nThis event was formerly specified to be non-cancelable in DOM Level 2 Events, but was changed to reflect existing interoperability between user agents.\n\n3.4.5.9. mouseout\n\nType mouseout Interface MouseEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : 0\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : indicates the event target a pointing device is entering, if any.\n\nA user agent MUST dispatch this event when a pointing device is moved off of the boundaries of an element or when the element is moved to be no longer underneath the primary pointing device. This event type is similar to mouseleave, but differs in that does bubble, and that it MUST be dispatched when the pointer device moves from an element onto the boundaries of one of its descendent elements.\n\nSee also the mouseover event type.\n\n3.4.5.10. mouseover\n\nType mouseover Interface MouseEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : 0\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : indicates the event target a pointing device is entering, if any.\n\nA user agent MUST dispatch this event when a pointing device is moved onto the boundaries of an element or when the element is moved to be underneath the primary pointing device. This event type is similar to mouseenter, but differs in that it bubbles, and that it MUST be dispatched when the pointer device moves onto the boundaries of an element whose ancestor element is the event target for the same event listener instance.\n\nSee also the mouseout event type.\n\n3.4.5.11. mouseup\n\nType mouseup Interface MouseEvent Sync / Async Sync Bubbles Yes Trusted Targets Element Cancelable Yes Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : topmost event target\n\nUIEvent.view : Window\n\nUIEvent.detail : indicates the current click count incremented by one.\n\nMouseEvent.screenX : value based on the pointer position on the screen\n\nMouseEvent.screenY : value based on the pointer position on the screen\n\nMouseEvent.clientX : value based on the pointer position within the viewport\n\nMouseEvent.clientY : value based on the pointer position within the viewport\n\nMouseEvent.layerX : value based on the pointer position within the containing element\n\nMouseEvent.layerY : value based on the pointer position within the containing element\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : value based on current button pressed\n\nMouseEvent.buttons : value based on all buttons currently depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : null\n\nA user agent MUST dispatch this event when a pointing device button is released over an element.\n\nIn some implementation environments, such as a browser, a mouseup event can be dispatched even if the pointing device has left the boundary of the user agent, e.g., if the user began a drag operation with a mouse button pressed.\n\n3.5. Wheel Events\n\nWheels are devices that can be rotated in one or more spatial dimensions, and which can be associated with a pointer device. The coordinate system depends on the environment configuration.\n\nThe user’s environment might be configured to associate vertical scrolling with rotation along the y-axis, horizontal scrolling with rotation along the x-axis, and zooming with rotation along the z-axis.\n\nThe deltaX, deltaY, and deltaZ attributes of WheelEvent objects indicate a measurement along their respective axes in units of pixels, lines, or pages. The reported measurements are provided after an environment-specific algorithm translates the actual rotation/movement of the wheel device into the appropriate values and units.\n\nA user’s environment settings can be customized to interpret actual rotation/movement of a wheel device in different ways. One movement of a common dented mouse wheel can produce a measurement of 162 pixels (162 is just an example value, actual values can depend on the current screen dimensions of the user-agent). But a user can change their default environment settings to speed-up their mouse wheel, increasing this number. Furthermore, some mouse wheel software can support acceleration (the faster the wheel is rotated/moved, the greater the delta of each measurement) or even sub-pixel rotation measurements. Because of this, authors can not assume a given rotation amount in one user agent will produce the same delta value in all user agents.\n\nThe sign (positive or negative) of the values of the deltaX, deltaY, and deltaZ attributes MUST be consistent between multiple dispatches of the wheel event while the motion of the actual wheel device is rotating/moving in the same direction. If a user agent scrolls as the default action of the wheel event then the sign of the delta SHOULD be given by a right-hand coordinate system where positive X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively.\n\nIndividual user agents can (depending on their environment and hardware configuration) interpret the same physical user interaction on the wheel differently. For example, a vertical swipe on the edge of a trackpad from top to bottom can be interpreted as a wheel action intended to either scroll the page down or to pan the page up (i.e., resulting in either a positive or negative deltaY value respectively).\n\nA user agent MUST create a wheel event transaction when the first wheel event is fired, so that all subsequent wheel events within a implementation-specific amount of time can be targetted at the same element. A wheel event transaction is series of wheel events that are associated with a single user gesture. The wheel event transaction MUST have an associated event target that is the topmost event target at the time the first wheel event occurs in the group.\n\nIf a series of wheel events targetted in a scrollable element start above a child element, later events for the same user gesture may occur over the child element.\n\n3.5.1. Interface WheelEvent\n\nIntroduced in this specification\n\nThe WheelEvent interface provides specific contextual information associated with wheel events.\n\nTo create an instance of the WheelEvent interface, use the WheelEvent constructor, passing an optional WheelEventInit dictionary.\n\n3.5.1.1. WheelEvent\n\n[Exposed=Window] interface WheelEvent : MouseEvent { constructor(DOMString type, optional WheelEventInit eventInitDict = {}); // DeltaModeCode const unsigned long DOM_DELTA_PIXEL = 0x00; const unsigned long DOM_DELTA_LINE = 0x01; const unsigned long DOM_DELTA_PAGE = 0x02; readonly attribute double deltaX; readonly attribute double deltaY; readonly attribute double deltaZ; readonly attribute unsigned long deltaMode; };\n\nDOM_DELTA_PIXEL\n\nThe units of measurement for the delta MUST be pixels. This is the most typical case in most operating system and implementation configurations.\n\nDOM_DELTA_LINE\n\nThe units of measurement for the delta MUST be individual lines of text. This is the case for many form controls.\n\nDOM_DELTA_PAGE\n\nThe units of measurement for the delta MUST be pages, either defined as a single screen or as a demarcated page.\n\ndeltaX, of type double, readonly\n\nIn user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the x-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the x-axis.\n\nThe un-initialized value of this attribute MUST be 0.0.\n\ndeltaY, of type double, readonly\n\nIn user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the y-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the y-axis.\n\nThe un-initialized value of this attribute MUST be 0.0.\n\ndeltaZ, of type double, readonly\n\nIn user agents where the default action of the wheel event is to scroll, the value MUST be the measurement along the z-axis (in pixels, lines, or pages) to be scrolled in the case where the event is not cancelled. Otherwise, this is an implementation-specific measurement (in pixels, lines, or pages) of the movement of a wheel device around the z-axis.\n\nThe un-initialized value of this attribute MUST be 0.0.\n\ndeltaMode, of type unsigned long, readonly\n\nThe deltaMode attribute contains an indication of the units of measurement for the delta values. The default value is DOM_DELTA_PIXEL (pixels).\n\nThis attribute MUST be set to one of the DOM_DELTA constants to indicate the units of measurement for the delta values. The precise measurement is specific to device, operating system, and application configurations.\n\nThe un-initialized value of this attribute MUST be 0.\n\n3.5.1.2. WheelEventInit\n\ndictionary WheelEventInit : MouseEventInit { double deltaX = 0.0; double deltaY = 0.0; double deltaZ = 0.0; unsigned long deltaMode = 0; };\n\ndeltaX, of type double, defaulting to 0.0\n\nSee deltaZ attribute.\n\ndeltaY, of type double, defaulting to 0.0\n\nSee deltaZ attribute.\n\ndeltaZ, of type double, defaulting to 0.0\n\nInitializes the deltaZ attribute of the WheelEvent object. Relative positive values for this attribute (as well as the deltaX and deltaY attributes) are given by a right-hand coordinate system where the X, Y, and Z axes are directed towards the right-most edge, bottom-most edge, and farthest depth (away from the user) of the document, respectively. Negative relative values are in the respective opposite directions.\n\ndeltaMode, of type unsigned long, defaulting to 0\n\nInitializes the deltaMode attribute on the WheelEvent object to the enumerated values 0, 1, or 2, which represent the amount of pixels scrolled (DOM_DELTA_PIXEL), lines scrolled (DOM_DELTA_LINE), or pages scrolled (DOM_DELTA_PAGE) if the rotation of the wheel would have resulted in scrolling.\n\n3.5.2. Wheel Event Types\n\n3.5.2.1. wheel\n\nType wheel Interface WheelEvent Sync / Async Async Bubbles Yes Trusted Targets Element Cancelable Varies Composed Yes Default action Scroll (or zoom) the document Context\n\n(trusted events)\n\nEvent.target : element target for the current wheel event transaction\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nMouseEvent.screenX : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0\n\nMouseEvent.screenY : if the wheel is associated with a pointing device, the value based on the pointer position on the screen, otherwise 0\n\nMouseEvent.clientX : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0\n\nMouseEvent.clientY : if the wheel is associated with a pointing device, the value based on the pointer position within the viewport, otherwise 0\n\nMouseEvent.altKey : true if Alt modifier was active, otherwise false\n\nMouseEvent.ctrlKey : true if Control modifier was active, otherwise false\n\nMouseEvent.shiftKey : true if Shift modifier was active, otherwise false\n\nMouseEvent.metaKey : true if Meta modifier was active, otherwise false\n\nMouseEvent.button : if wheel is associated with a pointing device, value based on current button pressed, otherwise 0\n\nMouseEvent.buttons : if wheel is associated with a pointing device, value based on all buttons current depressed, 0 if no buttons pressed\n\nMouseEvent.relatedTarget : indicates the event target the pointing device is pointing at, if any\n\nWheelEvent.deltaX : expected amount that the page will scroll along the x-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the x-axis\n\nWheelEvent.deltaY : expected amount that the page will scroll along the y-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the y-axis\n\nWheelEvent.deltaZ : expected amount that the page will scroll along the z-axis according to the deltaMode units; or an implementation-specific value of movement of a wheel around the z-axis\n\nWheelEvent.deltaMode : unit indicator (pixels, lines, or pages) for the deltaX, deltaY, and deltaZ attributes\n\nA user agent MUST dispatch this event when a mouse wheel has been rotated around any axis, or when an equivalent input device (such as a mouse-ball, certain tablets or touchpads, etc.) has emulated such an action. Depending on the platform and input device, diagonal wheel deltas MAY be delivered either as a single wheel event with multiple non-zero axes or as separate wheel events for each non-zero axis.\n\nThe typical default action of the wheel event type is to scroll (or in some cases, zoom) the document by the indicated amount. If this event is canceled, the implementation MUST NOT scroll or zoom the document (or perform whatever other implementation-specific default action is associated with this event type).\n\nIn some user agents, or with some input devices, the speed that the wheel has been turned can affect the delta values, with a faster speed producing a higher delta value.\n\n3.5.2.2. cancelability of wheel events\n\nCalling preventDefault on a wheel event can prevent or otherwise interrupt scrolling. For maximum scroll performance, a user agent may not wait for each wheel event associated with the scroll to be processed to see if it will be canceled. In such cases the user agent should generate wheel events whose cancelable property is false, indicating that preventDefault cannot be used to prevent or interrupt scrolling. Otherwise cancelable will be true.\n\nIn particular, a user agent should generate only uncancelable wheel events when it observes that there are no non-passive listeners for the event.\n\n3.6. Input Events\n\nInput events are sent as notifications whenever the DOM is being updated (or about to be updated) as a direct result of a user action (e.g., keyboard input in an editable region, deleting or formatting text, ...).\n\n3.6.1. Interface InputEvent\n\n3.6.1.1. InputEvent\n\nIntroduced in DOM Level 3\n\n[Exposed=Window] interface InputEvent : UIEvent { constructor(DOMString type, optional InputEventInit eventInitDict = {}); readonly attribute USVString? data; readonly attribute boolean isComposing; readonly attribute DOMString inputType; };\n\ndata, of type USVString, readonly, nullable\n\ndata holds the value of the characters generated by an input method. This MAY be a single Unicode character or a non-empty sequence of Unicode characters [Unicode]. Characters SHOULD be normalized as defined by the Unicode normalization form NFC, defined in [UAX15]. This attribute MAY contain the empty string.\n\nThe un-initialized value of this attribute MUST be null.\n\nisComposing, of type boolean, readonly\n\ntrue if the input event occurs as part of a composition session, i.e., after a compositionstart event and before the corresponding compositionend event.\n\nThe un-initialized value of this attribute MUST be false.\n\ninputType, of type DOMString, readonly\n\ninputType contains a string that identifies the type of input associated with the event.\n\nFor a list of valid values for this attribute, refer to the [Input-Events] specification.\n\nThe un-initialized value of this attribute MUST be the empty string \"\".\n\n3.6.1.2. InputEventInit\n\ndictionary InputEventInit : UIEventInit { DOMString? data = null; boolean isComposing = false; DOMString inputType = \"\"; };\n\ndata, of type DOMString, nullable, defaulting to null\n\nInitializes the data attribute of the InputEvent object.\n\nisComposing, of type boolean, defaulting to false\n\nInitializes the isComposing attribute of the InputEvent object.\n\ninputType, of type DOMString, defaulting to \"\"\n\nInitializes the inputType attribute of the InputEvent object.\n\n3.6.2. Input Event Order\n\nThe input events defined in this specification MUST occur in a set order relative to one another.\n\nEvent Type Notes 1 beforeinput DOM element is updated 2 input\n\n3.6.3. Input Event Types\n\n3.6.3.1. beforeinput\n\nType beforeinput Interface InputEvent Sync / Async Sync Bubbles Yes Trusted Targets Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled Cancelable Yes Composed Yes Default action Update the DOM element Context\n\n(trusted events)\n\nEvent.target : event target that is about to be updated\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nInputEvent.data : the string containing the data that will be added to the element, which MAY be null if the content will be deleted\n\nInputEvent.isComposing : true if this event is dispatched during a dead key sequence or while an input method editor is active (such that composition events are being dispatched); false otherwise.\n\nA user agent MUST dispatch this event when the DOM is about to be updated.\n\n3.6.3.2. input\n\nType input Interface InputEvent Sync / Async Sync Bubbles Yes Trusted Targets Element (specifically: control types such as HTMLInputElement, etc.) or any Element with contenteditable attribute enabled Cancelable No Composed Yes Default action None Context\n\n(trusted events)\n\nEvent.target : event target that was just updated\n\nUIEvent.view : Window\n\nUIEvent.detail : 0\n\nInputEv"
    }
}