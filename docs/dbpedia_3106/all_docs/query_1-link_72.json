{
    "id": "dbpedia_3106_1",
    "rank": 72,
    "data": {
        "url": "https://forum.arduino.cc/t/strain-gauge-hx711-nrf24l01/660723",
        "read_more_link": "",
        "language": "en",
        "title": "strain gauge + hx711 + nrf24l01",
        "top_image": "https://europe1.discourse-cdn.com/arduino/original/4X/e/4/b/e4b49aa2dde688f4864654d04e7e91e17d53c764.png",
        "meta_img": "https://europe1.discourse-cdn.com/arduino/original/4X/e/4/b/e4b49aa2dde688f4864654d04e7e91e17d53c764.png",
        "images": [
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/e/4/b/e4b49aa2dde688f4864654d04e7e91e17d53c764_2_500x500.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/e/4/b/e4b49aa2dde688f4864654d04e7e91e17d53c764_2_500x500.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/3X/c/c/cc4b0921af3d89006e843364a2b18989ad72f83e_2_32x32.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/e/4/b/e4b49aa2dde688f4864654d04e7e91e17d53c764_2_500x500.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2020-06-14T17:14:46+00:00",
        "summary": "",
        "meta_description": "Hello, \nI want to create a Wheatstone bridge half bridge using 2 strain gauges of 120 ohms and receive mV/V value through hx711. \nI want to receive the value through HX711 and receive the wireless communication value usi&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://europe1.discourse-cdn.com/arduino/optimized/3X/c/c/cc4b0921af3d89006e843364a2b18989ad72f83e_2_32x32.png",
        "meta_site_name": "Arduino Forum",
        "canonical_link": "https://forum.arduino.cc/t/strain-gauge-hx711-nrf24l01/660723",
        "text": "Hello,\n\nI want to create a Wheatstone bridge half bridge using 2 strain gauges of 120 ohms and receive mV/V value through hx711.\n\nI want to receive the value through HX711 and receive the wireless communication value using NRF24L01, so the value is not received.\n\nI wanted to get the real value to use the code below, const char text[] = \"Hello World\"; In this part, I don't know what the const char text[] means, and I run it.\n\nGetting a strain gage value with hx711 is also worrying that the values ​​are too sharp, but I would like to ask for advice first.\n\nIs it correct to write hx711 code and nrf24l01 code together in the transmitter? If it is correct, in what order should I receive the value. I\n\ndon't have to try for a few days, so I eagerly post a question like this.. Thank you in advance.\n\nhow to combine nrf24l01 code and hx711 code to receive strain guage value\n\nThe photo below is a code and line connection. Except the variable resistor part there, I connected the HX711 and the half bridge.\n\nhx711 code\n\n#include \"HX711.h\"\n\n// HX711 circuit wiring\n\nconst int LOADCELL_DOUT_PIN = A1;\n\nconst int LOADCELL_SCK_PIN = A0;\n\nHX711 scale;\n\nvoid setup() {\n\nSerial.begin(9600);\n\nscale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);\n\n}\n\nvoid loop() {\n\nif (scale.is_ready()) {\n\nlong reading = scale.read();\n\nSerial.print(\"HX711 reading: \");\n\nSerial.println(reading);\n\n} else {\n\nSerial.println(\"HX711 not found.\");\n\n}\n\ndelay(1000);\n\n}\n\nTransmitter\n\n#include <SPI.h>\n\n#include <nRF24L01.h>\n\n#include <RF24.h>\n\nRF24 radio(7,8);// Declare CE and CSN to configure nRF24L01 radio on SPI bus.\n\nconst byte address[ 6] = \"00001\"; //You can change the address value to 5 strings, and the transmitter and receiver must have the same address\n\nvoid setup() {\n\nradio.begin();\n\nradio.openWritingPipe(address); //Set the address of the destination to send data, which is the previously set 5 character string\n\nradio.setPALevel(RF24_PA_MIN); //Set power level for power supply. If they are close to each other, set them to minimum.\n\n//You can set RF24_PA_MIN / RF24_PA_LOW / RF24_PA_HIGH / RF24_PA_MAX, etc. in the order of close distance.\n\n//It is recommended to use bypass capacitors at GND and 3.3V to ensure a stable voltage during operation at high levels (at long distances).\n\nradio.stopListening(); //Set the module as a transmitter\n\n}\n\nvoid loop() {\n\nconst char text[] = \"Hello World\";\n\nradio.write(&text, sizeof(text)); //Send the message to the receiver\n\ndelay(1000);\n\n}\n\nReceiver\n\n#include <SPI.h>\n\n#include <nRF24L01.h>\n\n#include <RF24.h>\n\nRF24 radio(7,8);// Declare CE and CSN to configure nRF24L01 radio on SPI bus.\n\nconst byte address[6] = \"00001\"; //You can change the address value to 5 strings, and the transmitter and receiver must be the same address.\n\nvoid setup() {\n\nSerial.begin(9600);\n\nradio.begin();\n\nradio.openReadingPipe(0, address);\n\nradio.setPALevel(RF24_PA_MIN); //Set power level for power supply. If they are close to each other, set them to minimum.\n\n//You can set RF24_PA_MIN / RF24_PA_LOW / RF24_PA_HIGH / RF24_PA_MAX, etc. in the order of close distance.\n\n//It is recommended to use bypass capacitors at GND and 3.3V to have a stable voltage during high level (if the distance is high)\n\nradio.startListening(); //Set the module as a receiver\n\n}\n\nvoid loop() {\n\nif (radio.available()) {\n\nchar text[32] = \"\";\n\nradio.read(&text, sizeof(text));\n\nSerial.println(text);\n\n}\n\n}\n\nI don't understand the language this Topic is using. This is the English language section of the Forum.\n\nIn case you can read English have a look at this Simple nRF24L01+ Tutorial.\n\nWireless problems can be very difficult to debug so get the wireless part working on its own before you start adding any other features.\n\nThe examples are as simple as I could make them and they have worked for other Forum members. If you get stuck it will be easier to help with code that I am familiar with. Start by getting the first example to work\n\nThere is also a connection test program to check that the Arduino can talk to the nRF24 it is connected to.\n\nA common problem with nRF24 modules is insufficient 3.3v current from the Arduino 3.3v pin. The high-power nRF24s (with the external antenna) will definitely need an external power supply. At least for testing try powering the nRF24 with a pair of AA alkaline cells (3v) with the battery GND connected to the Arduino GND.\n\nIf you are using the high-power nRF24s (with the external antenna) make sure there is sufficient distance between the two nRF24 so that the signal does not overwhelm the receiver - try 3 metres separation. If you are new to nRF24s it may be better to start with a pair of low power modules with the pcb antenna.\n\n...R\n\nHello,\n\nI want to create a Wheatstone bridge half bridge using 2 strain gauges of 120 ohms and receive mV/V value through hx711.\n\nI want to receive the value through HX711 and receive the wireless communication value using NRF24L01, so the value is not received.\n\nI wanted to get the real value to use the code below, const char text[] = \"Hello World\"; In this part, I don't know what the const char text[] means, and I run it.\n\nGetting a strain gage value with hx711 is also worrying that the values ​​are too sharp, but I would like to ask for advice first.\n\nIs it correct to write hx711 code and nrf24l01 code together in the transmitter? If it is correct, in what order should I receive the value. I\n\ndon't have to try for a few days, so I eagerly post a question like this.. Thank you in advance.\n\nThe photo below is a code and line connection. Except the variable resistor part there, I connected the HX711 and the half bridge.\n\nhx711 code\n\n#include \"HX711.h\"\n\n// HX711 circuit wiring\n\nconst int LOADCELL_DOUT_PIN = A1;\n\nconst int LOADCELL_SCK_PIN = A0;\n\nHX711 scale;\n\nvoid setup() {\n\nSerial.begin(9600);\n\nscale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);\n\n}\n\nvoid loop() {\n\nif (scale.is_ready()) {\n\nlong reading = scale.read();\n\nSerial.print(\"HX711 reading: \");\n\nSerial.println(reading);\n\n} else {\n\nSerial.println(\"HX711 not found.\");\n\n}\n\ndelay(1000);\n\n}\n\nTransmitter\n\n#include <SPI.h>\n\n#include <nRF24L01.h>\n\n#include <RF24.h>\n\nRF24 radio(7,8);// Declare CE and CSN to configure nRF24L01 radio on SPI bus.\n\nconst byte address[ 6] = \"00001\"; //You can change the address value to 5 strings, and the transmitter and receiver must have the same address\n\nvoid setup() {\n\nradio.begin();\n\nradio.openWritingPipe(address); //Set the address of the destination to send data, which is the previously set 5 character string\n\nradio.setPALevel(RF24_PA_MIN); //Set power level for power supply. If they are close to each other, set them to minimum.\n\n//You can set RF24_PA_MIN / RF24_PA_LOW / RF24_PA_HIGH / RF24_PA_MAX, etc. in the order of close distance.\n\n//It is recommended to use bypass capacitors at GND and 3.3V to ensure a stable voltage during operation at high levels (at long distances).\n\nradio.stopListening(); //Set the module as a transmitter\n\n}\n\nvoid loop() {\n\nconst char text[] = \"Hello World\";\n\nradio.write(&text, sizeof(text)); //Send the message to the receiver\n\ndelay(1000);\n\n}\n\nReceiver\n\n#include <SPI.h>\n\n#include <nRF24L01.h>\n\n#include <RF24.h>\n\nRF24 radio(7,8);// Declare CE and CSN to configure nRF24L01 radio on SPI bus.\n\nconst byte address[6] = \"00001\"; //You can change the address value to 5 strings, and the transmitter and receiver must be the same address.\n\nvoid setup() {\n\nSerial.begin(9600);\n\nradio.begin();\n\nradio.openReadingPipe(0, address);\n\nradio.setPALevel(RF24_PA_MIN); //Set power level for power supply. If they are close to each other, set them to minimum.\n\n//You can set RF24_PA_MIN / RF24_PA_LOW / RF24_PA_HIGH / RF24_PA_MAX, etc. in the order of close distance.\n\n//It is recommended to use bypass capacitors at GND and 3.3V to have a stable voltage during high level (if the distance is high)\n\nradio.startListening(); //Set the module as a receiver\n\n}\n\nvoid loop() {\n\nif (radio.available()) {\n\nchar text[32] = \"\";\n\nradio.read(&text, sizeof(text));\n\nSerial.println(text);\n\n}\n\n}\n\nStrange sunglasses come out with the number 8, I don't know why it comes out like this.\n\nHello,\n\nI want to create a Wheatstone bridge half bridge using 2 strain gauges of 120 ohms and receive mV/V value through hx711.\n\nI want to receive the value through HX711 and receive the wireless communication value using NRF24L01, so the value is not received.\n\nI wanted to get the real value to use the code below, const char text[] = \"Hello World\"; In this part, I don't know what the const char text[] means, and I run it.\n\nGetting a strain gage value with hx711 is also worrying that the values ​​are too sharp, but I would like to ask for advice first.\n\nIs it correct to write hx711 code and nrf24l01 code together in the transmitter? If it is correct, in what order should I receive the value. I\n\ndon't have to try for a few days, so I eagerly post a question like this.. Thank you in advance.\n\nhow to combine nrf24l01 code and hx711 code to receive strain guage value\n\nThe photo below is a code and line connection. Except the variable resistor part there, I connected the HX711 and the half bridge.\n\nhx711 code\n\n#include \"HX711.h\"\n\n// HX711 circuit wiring\n\nconst int LOADCELL_DOUT_PIN = A1;\n\nconst int LOADCELL_SCK_PIN = A0;\n\nHX711 scale;\n\nvoid setup() {\n\nSerial.begin(9600);\n\nscale.begin(LOADCELL_DOUT_PIN, LOADCELL_SCK_PIN);\n\n}\n\nvoid loop() {\n\nif (scale.is_ready()) {\n\nlong reading = scale.read();\n\nSerial.print(\"HX711 reading: \");\n\nSerial.println(reading);\n\n} else {\n\nSerial.println(\"HX711 not found.\");\n\n}\n\ndelay(1000);\n\n}\n\nTransmitter\n\n#include <SPI.h>\n\n#include <nRF24L01.h>\n\n#include <RF24.h>\n\nRF24 radio(7,8);// Declare CE and CSN to configure nRF24L01 radio on SPI bus.\n\nconst byte address[ 6] = \"00001\"; //You can change the address value to 5 strings, and the transmitter and receiver must have the same address\n\nvoid setup() {\n\nradio.begin();\n\nradio.openWritingPipe(address); //Set the address of the destination to send data, which is the previously set 5 character string\n\nradio.setPALevel(RF24_PA_MIN); //Set power level for power supply. If they are close to each other, set them to minimum.\n\n//You can set RF24_PA_MIN / RF24_PA_LOW / RF24_PA_HIGH / RF24_PA_MAX, etc. in the order of close distance.\n\n//It is recommended to use bypass capacitors at GND and 3.3V to ensure a stable voltage during operation at high levels (at long distances).\n\nradio.stopListening(); //Set the module as a transmitter\n\n}\n\nvoid loop() {\n\nconst char text[] = \"Hello World\";\n\nradio.write(&text, sizeof(text)); //Send the message to the receiver\n\ndelay(1000);\n\n}\n\nReceiver\n\n#include <SPI.h>\n\n#include <nRF24L01.h>\n\n#include <RF24.h>\n\nRF24 radio(7,8);// Declare CE and CSN to configure nRF24L01 radio on SPI bus.\n\nconst byte address[6] = \"00001\"; //You can change the address value to 5 strings, and the transmitter and receiver must be the same address.\n\nvoid setup() {\n\nSerial.begin(9600);\n\nradio.begin();\n\nradio.openReadingPipe(0, address);\n\nradio.setPALevel(RF24_PA_MIN); //Set power level for power supply. If they are close to each other, set them to minimum.\n\n//You can set RF24_PA_MIN / RF24_PA_LOW / RF24_PA_HIGH / RF24_PA_MAX, etc. in the order of close distance.\n\n//It is recommended to use bypass capacitors at GND and 3.3V to have a stable voltage during high level (if the distance is high)\n\nradio.startListening(); //Set the module as a receiver\n\n}\n\nvoid loop() {\n\nif (radio.available()) {\n\nchar text[32] = \"\";\n\nradio.read(&text, sizeof(text));\n\nSerial.println(text);\n\n}\n\n}"
    }
}