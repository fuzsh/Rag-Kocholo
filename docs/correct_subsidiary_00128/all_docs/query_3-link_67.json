{
    "id": "correct_subsidiary_00128_3",
    "rank": 67,
    "data": {
        "url": "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/uioprxy.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Oracle Adaptive Access Manager Proxy",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/nonprxy.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/prxy.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_008.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_009.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_002.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_007.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_006.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_004.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_009.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_005.gif",
            "https://docs.oracle.com/cd/E28280_01/dev.1111/e15480/img/aadev_jd_001.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2014-08-01T21:34:13+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "6.1.1 Important Terms\n\nFor your reference, important terms are defined in this section.\n\nMicrosoft ISA\n\nFrom the Microsoft Web site: \"the Internet Security and Acceleration (ISA) Server is the integrated edge security gateway that helps protect IT environments from Internet-based threats while providing users with fast and secure remote access to applications and data.\"\n\nUniversal Installation Option\n\nThe Universal Installation Option is the Oracle Adaptive Access Manager integration strategy that does not require any code modification to the protected Web applications. The Universal Installation Option involves placing the UIO Proxy in front of the protected Web applications\n\nProxy\n\nA proxy is a server that services the requests of its clients by forwarding requests to other servers. This chapter is concerned with the Web proxy, where the proxy handles Web Protocols, mainly HTTP.\n\nForward Proxy\n\nA forward proxy is an intermediate server that sits between the client and the origin server. To get content from the origin server, the client sends a request to the proxy naming the origin server as the target, and the proxy then requests the content from the origin server and returns it to the client. The client must be specially configured to use the forward proxy to access other sites.\n\nReverse Proxy\n\nA reverse proxy appears to the client just like an ordinary Web server. No special configuration on the client is necessary. The client makes ordinary requests for content in the name-space of the reverse proxy. The reverse proxy then decides where to send those requests and returns the content as if it were itself the origin. The UIO Proxy running in the Microsoft Internet Security and Acceleration (ISA) Server is an example of a reverse proxy.\n\nOAAM Server\n\nOAAM Server is the Web application component of Oracle Adaptive Access Manager. The UIO Proxy redirects the client browser to OAAM Server for tracking and authentication purposes as defined by the UIO Proxy XML configuration.\n\n6.3.4 Configuring Memcache (for Linux only)\n\nThis is an optional configuration that may be needed for Linux deployment of UIO Apache Proxy. The UIO Apache Proxy maintains a session for the user where it keeps local state such as session level variables for the user. On Windows, there is always a single process for Apache httpd server running and so this session information is local to the process. On Linux, you could have multiple Apache httpd server processes running which means the session information cannot be kept local to the process but needs to be centralized. In this case, memcached is used to hold the session information. The following description is to identify when you must use memcached to hold the UIO Apache Proxy session information.\n\nApache httpd ships with a selection of Multi-Processing Modules (MPMs) which are responsible for binding to network ports on the machine, accepting requests, and dispatching children to handle the requests. On Linux: httpd can run with two different MPMs: httpd with prefork MPM (single-threaded) or with worker MPM (multi-threaded). The MPM is built into the httpd and is not a run-time option.\n\nWith prefork MPM, httpd maintains a pool of single-threaded processes, where each request is handled by a single process. In this case, you must configure UIO Apache Proxy to use memcached.\n\nWith worker MPM, httpd maintains a pool of multithreaded processes, where every process could be handling multiple requests at a time. In this case, you can configure Apache httpd to launch a single process and avoid using memcached. However, the default configuration launches multiple processes and if you want to keep that unchanged, then you must configure UIO Apache Proxy to use memcached. Here is an example of httpd.conf example that can be used to configure a worker MPM to launch a single process.\n\n# Following forces worker MPM to run 1 process (make sure mod_cgid is # not loaded, otherwise it starts one more httpd process). # Basically ThreadLimit=MinSpareThreads=MaxSpareThreads=MaxClients=ThreadsPerChild # and StartServers=1. Setting MaxRequestsPerChild to 0 ensures that the process is not # bounced. <IfModule mpm_worker_module> ThreadLimit 150 StartServers 1 MinSpareThreads 150 MaxSpareThreads 150 MaxClients 150 ThreadsPerChild 150 MaxRequestsPerChild 0 </IfModule>\n\nOn Windows, httpd MPM is always in multi-threading mode with a single process.\n\nOn Linux, in the case where the httpd runs multiple process (irrespective of single or multithreaded), the UIO Apache Proxy session data must be maintained in a common store (database or cache) so that multiple processes can access the session data. The UIO Proxy uses memcache (a memory based very fast cache) to store the session data.\n\nAt startup, the UIO Proxy autodetects whether httpd is running with a single process or multiple processes. If httpd is running with multiple processes (which is the case with prefork or worker mpm on Linux), it tries to connect to the memcache daemon using default connection parameters (that are defined in Section 6.3.6.1, \"UIO_Settings.xml\"). On Windows, by default, the UIO Proxy uses local sessions. It does not connect to the memcache daemon; however it can also be configured to maintain session data in the memcache daemon (explained in Section 6.3.6.1, \"UIO_Settings.xml\").\n\nFor the scenarios where the UIO Apache Proxy is connecting to memcache daemon, you must install memcache on your system using the instructions from the memcache Web site and run the memcache daemon(s) before running the Apache httpd.\n\nInstall memcache using instructions at:\n\nhttp://www.danga.com/memcached\n\nYou may already have a binary installation available from your Linux distribution. The UIO Apache Proxy has been tested with version 1.2.5 of memcache.\n\n6.6.1 Elements of the UIO Proxy Configuration File\n\nThe following sections describe various elements of the proxy configuration file.\n\n6.6.1.1 Components of Interceptors\n\nInterceptors are the most important elements in the proxy configuration. Authoring the proxy configuration file deals mostly with defining interceptors.\n\nThere are two types of interceptors: request interceptors and response interceptors. As the names suggest, request interceptors are used when the proxy receives HTTP requests from the client browser and response interceptors are used when the proxy receives HTTP response from the server, for example, Web application or OAAM Server.\n\nThere are four components to an interceptor and all of them are optional.\n\nList of URLs - the interceptor will be evaluated if the interceptor URL list contains the current request URL or if the URL list is empty. The URLs must be an exact match; there is no support for regular expressions. For a request interceptor, this is the set of URLs for which the request interceptor will be executed in the request portion of the HTTP request, for example, on the way from the client to the server. For a response interceptor, the URL is that of the HTTP request; the response interceptor will be executed in the response portion of the HTTP request, for example, while getting the response from the server to the client. If the URL has query parameters, then they should not be listed. You can use conditions to check for any query parameters.\n\nList of conditions - conditions can inspect the request/response contents, such as checking for the presence of an HTTP header/parameter/cookie, and so on, or testing whether a header/parameter/cookie has a specific value or not. Filters and action defined in the interceptor will be executed only if all the conditions specified are met or if no condition is specified.\n\nList of filters - filters perform an action that might modify the request/response contents or modify some state information in the proxy. For example, a filter can add/remove HTTP headers, save HTTP header/parameter/cookie value in a proxy variable, and so on.\n\nAction - after executing the filters the interceptor will perform the action, if one is specified. Actions can be one of the following:\n\na redirect the client to a different URL\n\nsend a saved response to the client\n\nperform a HTTP get on server\n\nperform a HTTP post on server\n\nsend a saved request to the server\n\nTable 6-13 Components of Interceptors\n\nInterceptor Attributes Description\n\n6.6.1.2 Conditions\n\nConditions are used in the proxy to inspect HTTP request/response or the state information saved in the proxy (variables). Each condition evaluates to either true or false. Conditions are evaluated in the order they are listed in the configuration file until a condition evaluates to false or all conditions are evaluated. Table 6-14 lists conditions that can be defined in an interceptor.\n\nTable 6-14 Conditions Defined in an Interceptor\n\nCondition name Attributes Description\n\nAttribute id is optional and is used only in trace messages. If no value is specified, the condition name (like HeaderPresent) will be used.\n\nAttribute enabled is optional and the default value is true. This attribute can be used to enable/disable a condition. The value of this attribute can be set to the name of a global variable; in such case, the condition will be enabled or disabled according to the value of the global variable.\n\nAttribute value can be set to the name of a proxy variable. In such a case, the proxy will evaluate the variable at checkpoint and use that value in the condition.\n\nAttribute mode can be set to one of the following: begins-with, ends-with, contains.\n\nAttribute ignore-case can be set to one of the following: true, false.\n\n6.6.1.3 Filters\n\nFilters are used in the proxy to modify HTTP request/response contents or modify the state information saved in the proxy (variables). Filters are executed in the order they are listed in the configuration file. Table 6-15 lists filters that can be defined in an interceptor.\n\nTable 6-15 Filters Defined in an Interceptor\n\nFilter name Attributes Description\n\n6.6.1.4 Filter Examples - ProcessString\n\nFind the sub-string between the given start-tag and end-tag in the source string, extract the sub-string found and save extracted sub-string in the given variable. The action of 'extract' will extract the first matching start-tag and end-tag pair.\n\n<ProcessString source=\"%RESPONSE_CONTENT\" find=\"sub-string\" start-tag=\"var traceID = '\" end-tag=\"';\" action=\"extract\" variable=\"$TRACE_ID\"/>\n\nFind the given search-string in the source string, replace it with the replace string and save the updated string in the given variable. You can also use the count attribute to specify behavior in case there are multiple matches. The attribute 'count' can take values all, once or a number.\n\n<ProcessString source=\"/bfb/accounts/accounts.asp?TraceID=$TRACE_ID\" find=\"string\" search-str=\"$TRACE_ID\" action=\"replace\" replace=\"$TRACE_ID\" variable=\"%POST_URL\"/>\n\nFind the sub-string between the given start-tag and end-tag in the source string, replace it (including the start and end tags) with the evaluated value of the sub string found and save the updated string in the given variable. You can use the attribute count to specify the behavior in case of multiple matches. This attribute can take the value of 'all', 'once' or a number.\n\n<ProcessString source=\"/cgi-bin/mcw055.cgi?TRANEXIT[$UrlSuffix]\" find=\"sub-string\" start-tag=\"[\" end-tag=\"]\" action=\"eval\" variable=\"%LogoffUrl\"/>\n\nYou can specify the attribute ignore-case as true or false and it can be applied to any of the above examples and accordingly the search operation will be case sensitive or not. You can specify encoding attribute optionally and it will encode the resulting string before storing in to the variable. This attribute can take only base64 value. If you do not specify this attribute then the resulting string is stored as is.\n\nThe encoding attribute is supported only on UIO Apache Proxy. On UIO ISA Proxy you will have to use FormatString if you want to encode the result in base 64.\n\n6.6.1.5 Filter Examples - FormatString\n\nHere is an example to create a HTTP Basic Authentication response header in variable $AuthHeaderValue, using the user name/password in variables %userid and %password:\n\n<FormatString variable=\"%UsernamePassword\" format-str=\"{0}:{1}\" param-0=\"%userid\" param-1=\"%password\" encoder=\"Base64\"/> <FormatString variable=\"$AuthHeaderValue\" format-str=\"Basic {0}\" param-0=\"%UsernamePassword\"/>\n\n6.6.1.6 Actions\n\nAn interceptor can optionally perform one of the following actions after executing all the filters. No further interceptors will be attempted after executing an action.\n\nredirect-client\n\nOften the proxy would need to redirect the client to load another URL; redirect-client is the action to use in such cases. The proxy will send a 302 HTTP response to request the client to load the specified URL. It takes has 2 attributes: url which contains the URL to which the proxy should re-direct the user and display-url which is optional.\n\nIf the display-url attribute is specified in the interceptor, the proxy will send a HTTP 302 response to the browser to load the URL specified in display-url attribute. When the proxy receives this request, it will perform a HTTP-GET on the server to get the URL specified in the url attribute.\n\nsend-to-client\n\nOften a response from the server would have to be saved in the proxy and sent to the client later after performing a few other HTTP requests; send-to-client is the action to use in such cases. The proxy will send the client the contents of specified variable. It has two attributes: html which contains the variable that has the saved content that you want send back to the user and optional attribute display-url.\n\nIf the display-url attribute is specified in the interceptor, the proxy will send a HTTP 302 response to the browser to load the URL specified in display-url attribute. When the proxy receives this request, it will send the response specified in the interceptor.\n\nget-server\n\nSometimes the proxy would need to get a URL from the server; get-server is the action to use in such cases. The proxy will send a HTTP-GET request for the specified URL to the server. It has two attributes: url which is the URL to perform the get on and the display-url which is optional.\n\nIf the display-url attribute is specified in the interceptor or if this action is specified in a response interceptor, the proxy will send a HTTP 302 response to the browser. When the proxy receives this request it will perform a HTTP-GET on the server to get the URL specified in the url attribute.\n\npost-server\n\nSometimes the proxy would need to post to a URL in the server; post-server is the action to use in such cases. The proxy will send a HTTP-POST request for the specified URL to the server. It has two attributes: url that has the URL to which the post needs to be sent and optional display-url.\n\nIf display-url attribute is specified in the interceptor or if this action is specified in a response interceptor, the proxy will send a HTTP 302 response to the browser. When the proxy receives this request it will perform a HTTP-POST to the server to the URL specified in the url attribute.\n\nsend-to-server\n\nIn certain situations the request from the client needs to be saved in the proxy and sent to the server later after performing a few other HTTP requests; send-to-server is the action to use in such cases. The proxy will send the contents of the specified variable to the server. It has two attributes: html which contains the variable that has the saved content and the optional display-url attribute.\n\nIf the display-url attribute is specified in the interceptor, then the proxy will send out a HTTP 302 redirect response to the browser. This will cause the browser to request for the display-url and then the proxy will send out the saved request to the server. If you use this action in a response interceptor, then display-url is mandatory; without this, the action will fail.\n\n6.6.1.7 Variables\n\nThe proxy variables can store string data in the proxy memory. Variables can be used in conditions, filters and actions. For example, SaveHeader filter can be used to save the value a specific header in the given proxy variable. This variable value could later be used, for example, to add a parameter to the request. Variables can also be used in conditions to determine whether to execute an interceptor or not.\n\nThe proxy variables are of 3 types, depending upon the life span of the variable. The type of variable is determined by the first letter of the variable name, which can be one of: %, $, @.\n\nAll types of variables can be set using filters like SetVariable, SaveHeader, SaveParam, SaveResponse, and other filters.\n\nAll types of variables can be unset/deleted by the UnsetVariable filter. The ClearSession filter can be used to remove all session variables.\n\nRequest variables\n\nRequest variables: these variable names start with %. These variables are associated with the current request and are deleted at the completion of the current request. Request variables are used where the value is not needed across requests.\n\nSession variables\n\nSession variables: these variable names start with $. These variables are associated with the current proxy session and are deleted when the proxy session is cleaned up. Session variables are used where the value should be preserved across requests from a client.\n\nGlobal variables\n\nGlobal variables: these variable names start with @. These variables are associated with the current proxy configuration and are deleted when the proxy configuration is unloaded. Global variables are used where the value needs to be preserved across requests and across clients.\n\nGlobal variables can be set at the proxy configuration load time using SetGlobal in the configuration file. In the UIO ISA Proxy, global variables can also be set by adding registry values under key HKLM\\Software\\Bharosa\\Proxy\\Globals. The name of each entry under this key should be the variable name, starting with @. And the data of the entry should be the value of the variable. The registry-type of the value can be REG_DWORD, REG_SZ or REG_EXPAND_SZ.\n\nPre-defined variables\n\nThe UIO Proxy supports the following pre-defined request variables:\n\nTable 6-16 Pre-defined Variables Supported by the UIO Proxy\n\nVariable name Description\n\n6.6.1.8 Application\n\nA single proxy installation can be used to provide multifactor authentication for multiple Web application that run in one or more Web servers. In the UIO Proxy configuration, an application is a grouping of interceptors defined for a single Web application.\n\nRequest and response interceptors can be defined outside of an application in the proxy configuration file. These interceptors are called \"global\" interceptors and will be evaluated and executed prior to the interceptors defined in the applications.\n\n6.6.2 Interception Process\n\nAn HTTP messages consist of requests from the client to server and responses from the server to client. HTTP is transaction oriented. A request from client to server will have a single response from the server to client. The request has a set of headers followed by, optionally, a request body. Similarly the response has headers and, optionally, a body. Since the proxy is sitting in between the client and the target application, it can modify the request headers, body and response headers and body of any HTTP request, using the configuration XML. Note that a response could be a normal 200 OK response or it could be a redirect response 302 or any other HTTP status response. In all these cases, the response is for that request and will trigger the response interceptors for the same request. An example, if the request is for the URL /doLogin.do, and the response is a redirect (302) with the location of /loginPage.jsp then all the request and response interceptors will be triggered for the URL /doLogin.do. The next HTTP request is a HTTP GET on /loginPage.jsp and this will cause all the request and response interceptors for /loginPage.jsp to be triggered.\n\nWhen a request arrives, the proxy evaluates request interceptors defined for the URL in the order they are defined in the configuration file. Similarly when on receiving response from the Web server, the proxy evaluates response interceptors defined for the URL of the HTTP request in the order defined in the configuration file.\n\nIf the conditions in an interceptor evaluate to true, the proxy will execute that interceptor i.e. execute the filters and action. After executing an interceptor, the proxy will continue with the next interceptor only if the following conditions are met:\n\nno action is specified for the current interceptor\n\npost-exec-action attribute for the current interceptor is continue\n\nIt is highly recommended that the post-exec-action attribute be specified for interceptors that do not define an action. For global interceptors (for example, the interceptors defined outside of any application), the default value of post-exec-action attribute is continue. The stop-phase-intercept value of post-exec-action on a request interceptor stops the request interception but continues with response interception while stop-intercept stops the interception completely for that request. For non-global interceptors, the default value is continue if no action is specified and stop-phase-intercept if an action is specified.\n\nAs mentioned earlier the proxy configuration can contain multiple applications. While finding the list of interceptors to evaluate for a URL, only the following interceptors are considered:\n\nglobal interceptors that are defined outside of any application\n\ninterceptors defined in the application associated with the current session\n\nEach session will be associated with at most one application. If no application is associated with the current session (yet) when the proxy finds an interceptor in an application for the URL, it will associate the application with the current session.\n\nIf the current session already has an application associated, and if no interceptor is found in that application for the URL, the proxy will then look for intercepts in other applications. If an interceptor is found in another application for the URL, a new session will be created and the request will be associated with the new session."
    }
}