{
    "id": "correct_subsidiary_00128_3",
    "rank": 72,
    "data": {
        "url": "https://docs.oracle.com/cd/E52734_01/oaam/AAMAD/performance.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Performance Considerations and Best Practices",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2015-08-19T15:23:40+00:00",
        "summary": "",
        "meta_description": "Checking for performance problems requires observation of the effects that lead to the decision that a performance issue exists and access to configuration and performance information.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "29.3.1 Policies and Rules\n\nIn most cases, creating of rules and policies should not be the focus when dealing with performance. However, as in any technology, there are tips and tricks that you can use to maximize performance when needed. Most of the considerations in this section are focused on the configuration.\n\nOrder Rules with Simple Conditions in the Beginning\n\nReordering rule conditions can improve the performance of rule evaluation in time, memory use, or both. Configure rules that are less complex, such as ones checking for a property or small variables, to run first in the order of evaluation. Configure the rules containing complex conditions like autolearning (a dynamic condition) to run after the simpler rules. The evaluation stops when a rule is evaluated to true. For example, if the first rule returns true, OAAM does not attempt to evaluate the second rule.\n\nConsider Policy Structure and Behavior\n\nIsolate the rules that require a great deal of time to process, then look at the policy to determine where performance issues might exists. For example, if it requires a great deal of time to execute all the rules associated to a policy, too many rules may be associated to a policy or more expensive rules are used. If there are too many rules, consider splitting them into different policies. If there are expensive rules consider optimizing the underlying SQL queries or optimizing/tuning database.\n\nRunning Conditions Multiple Times is Not Efficient/Can We Nest Them?\n\nThere policies where the outcome is to perform an action or give a score for a particular user or for when a feature is enabled. If a number of conditions are repeated that look for the particular user or an enabled feature in many rules, make the condition a decision point in one of your policies instead and continue from this point to a different flow. For example, if the condition is to check for a particular type of user, evaluating the same conditions many times evaluates the same users. If the condition is to check if a user is a mobile phone user and if he is, perform this action and give this score; and check if a user is a mobile phone user and if he is, perform that action and give another score, and so on. Instead of evaluating the condition in such a manner, consider nesting policies. Set up the evaluation to check if users are mobile phone customers and if they are, execute these different policies. In this way, you do not execute the conditions many times.\n\nOrder Rules So Not All Overrides are Evaluated\n\nAre there overrides? Overrides (trigger combinations) are used to override the outcome of rules. In the Trigger Combination tab, each row in any trigger combination represents a rule that is presenting a policy. If there is a set of trigger combinations for a policy, each row corresponds to a rule. Each vertical column represents a combination of rules that are triggering or not. The trigger combinations evaluate sequentially, moving from column 1 to columns 2, 3, 4 and so on, and stop as soon as a rule return combination is matched.\n\nIdentify the rules that are more complex and arrange them so that they are evaluated first. If the first column is true, the second column will not be looked at. Arrange rules so OAAM does not need to evaluate all the overrides.\n\nKeep Only Required Rules, Patterns, and Logs\n\nKeep only required rules. If you are not using a rule, you may want to disable or remove it. A rule adds queries for every session that runs. You do not want additional queries to run on the database if it is not necessary. Standard device rules are shipped with OAAM. If you are not planning to use devices in evaluations, you can disable all the rules for devices.\n\nKeep only required patterns. If you are not using patterns in rules, disable or remove them. Each time you perform an operation and a session runs, autolearning can potentially run five to ten queries. If queries are run on the database, performance is affected.\n\nKeep only required updates (rule logs for example). The OAAM database has rule logs as a feature. Rule logs will update tables in the database. If you do not want every session available for analysis for investigation, you may want to completely turn detailed rule logs off or you can enable them only for the time you need them (for example, for 5 seconds).\n\nDetermine the Resource Bundles Needed for the Deployment\n\nResource bundle are properties files that contains locale-specific data used in internationalizing the application.\n\nConsider if you need all the resource bundles and whether or not you can remove some. If your deployment is not multilingual, or if do not need all the resources and locales, consider not using some of the resource bundles.\n\nUse Lightweight Applications and Policies/Rule Configuration\n\nUse lightweight applications and policies/rules. In custom development, consider the resources required when adding a policy, rule, and action.\n\n29.3.3 Database\n\nAmount of Database Activity\n\nThe amount of database activity depends on several factors:\n\nWhether the user, device, or browser is new or existing\n\nIf autolearning is used then the number of patterns\n\nNumber of policies and rules defined and the number of checkpoints\n\nOAAM prints out every SQL if the property bharosa.db.query.performance.warning.threshold.ms is set to zero.\n\nSet this property and try a typical login and then grep for the log messages with the string \"ms execution for\" or \"SQLCall\".\n\nThat will give you an estimate about the typical database activity of login.\n\nDatabase Queries to Determine the Space Used\n\nUse the following query to determine the average size of row in tables:\n\n. select table_name, avg_row_len from user_tables .\n\nUse the following query to determine the size of indexes of the tables:\n\n. select inds.table_name, inds.index_name, sum( inds.sizes ) as index_bytes_per_row from ( select i.index_name, i.table_name, i.column_name, decode(data_type, 'DATE' , 7, 'CHAR' , data_length, 'VARCHAR2', decode( sign(data_length)-250, -1, .7*data_length+3, .7*data_length+1), 'NUMBER' , floor(nvl(data_precision,38)/2)+2 ) as sizes from user_ind_columns i, user_tab_columns t where t.TABLE_NAME = i.table_name AND t.COLUMN_NAME = i.COLUMN_NAME order by i.table_name, i.column_name ) inds group by inds.table_name, inds.index_name;\n\nDatabase Tuning Practices\n\nOAAM has indexes created as standard based on performance testing.\n\nThe standard indexes should be sufficient for most deployments but database administrators may choose to add additional indexes if they feel they are required after performance testing. This is rare however unless transactional use cases are involved.\n\nThe database administrator may choose to adjust the database server parameters to tune I/O so that insets and updates are efficient\n\nThe database administrator should monitor the production environment until the database server is stable\n\nOracle Partitioning Option\n\nPartitioning is an option that extends Oracle Database 11g Enterprise Edition standard capabilities.\n\nDeployments with more than 100K logins/transactions per day are recommended to use partitioning. When running the Oracle Fusion Middleware Repository Creation Utility (RCU) the partitioned scheme is used.\n\nDatabases 500 GB and over should use partitioning.\n\nOAAM Database Indexes Contention - Oracle Real Application Cluster (Oracle RAC) Specific\n\nIf high index contention occurs, you may want to partition the following indexes:\n\nPK_VT_TRX_LOGS\n\nPK_VT_ENT_TRX_MAP\n\nVT_TRX_LOGS_IDX3\n\nVT_WF_MONTHS_IDX1\n\nPK_VT_TRX_DATA\n\nVT_WF_YEARS_IDX0\n\nVT_WF_MONTHS_IDX0\n\nVT_TRX_LOGS_IDX6\n\nAlso partition the VT_USER_PROFILE table.\n\nDatabase I/O (input/output)\n\nDatabase I/O (input/output) performance problems may result if queries take a long time to run.\n\nAudit and Query\n\nQuery and audit activities may perform many sequential reads and table scans on the production index/tablespaces. To lessen the performance impact, you might consider maintaining a logical standby database using DataGuard where you can have an option to query, audit, and perform reporting using the logical standby database. The logical standby database would have all the data as production, except for the last one hour. The production database instance can just be used to perform its inserts, updates, and so on, and also for active monitoring and alerts."
    }
}