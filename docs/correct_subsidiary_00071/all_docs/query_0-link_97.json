{
    "id": "correct_subsidiary_00071_0",
    "rank": 97,
    "data": {
        "url": "https://patents.google.com/patent/US5657390A/en",
        "read_more_link": "",
        "language": "en",
        "title": "US5657390A - Secure socket layer application program apparatus and method - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/0a/7b/d4/f2e0c7002668c3/US5657390-drawings-page-2.png",
            "https://patentimages.storage.googleapis.com/15/ab/1e/a1d034445ef8bc/US5657390-drawings-page-3.png",
            "https://patentimages.storage.googleapis.com/b4/d8/1a/b529ccd2621507/US5657390-drawings-page-4.png",
            "https://patentimages.storage.googleapis.com/c4/bd/6b/393f9a77fed53a/US5657390-drawings-page-5.png",
            "https://patentimages.storage.googleapis.com/e6/dc/f4/d9b6eb53ac22a4/US5657390-drawings-page-6.png",
            "https://patentimages.storage.googleapis.com/9a/19/af/cd55f43a975ea5/US5657390-drawings-page-7.png",
            "https://patentimages.storage.googleapis.com/3d/c1/ae/1b456e83be9466/US5657390-drawings-page-8.png",
            "https://patentimages.storage.googleapis.com/21/f1/52/fdc3e8abe01b5b/US5657390-drawings-page-9.png",
            "https://patentimages.storage.googleapis.com/e3/07/bb/7b84295331e4b4/US5657390-drawings-page-10.png",
            "https://patentimages.storage.googleapis.com/03/26/80/e4dcc0f67ef065/US5657390-drawings-page-11.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1995-08-25T00:00:00",
        "summary": "",
        "meta_description": "A computer program product comprising: a computer useable medium having computer readable program code means embodied therein for encrypting and decrypting information transferred over a network between a client application program running in a client computer and a server application program running in a server computer, the computer readable program code means in the computer program product comprising: computer readable program code means for providing a socket application program interface to an application layer program; computer readable program code means for providing encrypted information to transport protocol layer services; computer readable program code means for encrypting information received from an application layer program; and computer readable program code means for decrypting information received from transport protocol layer services.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US5657390A/en",
        "text": "BACKGROUND OF THE INVENTION\n\n1. Field of the Invention\n\nThe invention relates generally to computer networks, and more particularly, to securing private communications between networked computers.\n\n2. Description of the Related Art\n\nThere is an increasing need for security in communications over public and private networks. The expanding popularity of the Internet, and especially the World Wide Web, have lured many more people and businesses into the realm of network communications. There has been a concomitant rapid growth in the transmission of confidential information over these networks. As a consequence, there is a critical need for improved approaches to ensuring the confidentiality of private information.\n\nNetwork security is a burgeoning field. There are well known encryption alorithms, authentication techniques and integrity checking mechanisms which serve as the foundation for today's secure communications. For example, public key encryption techniques using RSA and Diffie-Hellman are widely used. Well known public key encryption techniques generally described in the following U.S. Patents: U.S. Pat. No. 4,200,770 entitled, Cryptographic Apparatus and Method, invented by Hellman, Diffie and Merkle; U.S. Pat. No. 4,218,582 entitled, Public Key Cryptographic Apparatus and Method, invented by Hellman and Merkle; U.S. Pat. No. 4,405,829 entitled Cryptographic Communications System and Method, invented by Rivest, Shamir and Adleman; and U.S. Pat. No. 4,424,414 entitled, Exponentiation Cryptographic Apparatus and Method, invented by Hellman and Pohlig. For a general discussion of network security, refer to Network and Internetwork Security, by William Stallings, Prentice Hall, Inc., 1995.\n\nIn spite of the great strides that have been made in network security, there still is a need for further improvement. For example, with the proliferation of heterogeneous network environments in which different host computers use different operating system platforms, there is an increasing need for a security mechanism that is platform independent. Moreover, with the increasing sophistication and variety of application programs that seek access to a wide range of information over networks, there is an increasing need for a security mechanism that can work with many different types of applications that request a wide variety of different types of information from a wide variety of different types of server applications. Furthermore, as security becomes more important and the volume of confidential network transactions expands, it becomes increasingly important to ensure that security can be achieved efficiently, with minimal lime and effort. The present invention meets these needs.\n\nSUMMARY OF THE INVENTION\n\nIn one aspect, the invention provides a sockets application program interface bound to a security protocol which is layered between an application layer and transport layer. The socket interface is widely used in network environments. This facilitates integration of the invention into a wide range of host machines connected to a network. Placing the security protocol between the application layer and the transport layer enables many different types of application programs to employ the new security with only slight modification. Moreover, the security protocol can communicate with many different operating system platforms without requiring operating system changes.\n\nIn another aspect, the invention provides a more efficient handshake protocol and session key generation scheme. When a client and server application first establish a secure sockets connection, in accordance with the invention, they engage in a novel handshake protocol in which they negotiate security procedures, produce a master key and generate session keys to be used to encrypt and decrypt information transferred through the sockets connection. If there are multiple connections between the client and server applications during a prescribed time interval, then the handshake protcol may elect to re-use a previously negotiated master key, thereby obviating the need to generate a new master key, and saving time in establishing a secure connection.\n\nThese and other features and advantages of the invention will become more apparent from the following description of exemplary embodiments thereof, as illustrated in the accompanying drawings.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nFIG. 1 is a pictorial diagram of a computer network;\n\nFIG. 2 is an illustrative drawing of a computer of the network of FIG. 2;\n\nFIG. 3 is an illustrative diagram of an electronic document with hyperlinks;\n\nFIG. 4 illustrates client/server message flow, in accordance with a present embodiment of the invention, using the RSA protocol where no session-identifier is found;\n\nFIG. 5 shows client/server message flow, in accordance with a present embodiment of invention, using the RSA protocol where there is a shared session-identifier;\n\nFIG. 6 shows client/server message flow, in accordance with a present embodiment of the invention, using the RSA protocol and there is a common session-identification and client authentication is requested;\n\nFIG. 7 shows client/server message flow, in accordance with a present embodiment of the invention, using a Diffie-Hellman key exchange where there is shared session-identification;\n\nFIG. 8 shows a generalized representation of a typical Internet protocol stack which resides in each host machine (client and server) and a typical subnet protocol stack;\n\nFIG. 9 is an illustrative view of client side and server side application layer and transport layer programs and protocol structures in accordance with a present embodiment of the invention;\n\nFIG. 10 is an illustrative view of client and server side application layer and transport layer programs and protocol structures which employ the Winsock DLL in conjunction with the SSL library in accordance with an alternative embodiment of the invention;\n\nFIG. 11 is an illustrative view of client and server side application layer and transport layer programs and protocol structures which employ a variation of the Winsock DLL in conjunction with the SSL library in accordance with another alternative embodiment of the invention; and which employ a variation of the Winsock DLL in conjunction with the SSL library in accordance with another alternative embodiment of the present invention; and\n\nFIG. 12a, 12b and 12c are an illustrative flow diagram showing an example of the process involved in secure client-server communication in accordance with a present embodiment of the invention.\n\nDETAILED DESCRIPTION OF THE PREFERRED EMBODIMENT\n\nThe present invention comprises a novel process and related computer program embodied in a computer useable medium for ensuring private communications between application programs running on different computers. The following description is presented to enable any person skilled in the art to make and use the invention. Descriptions of specific applications are provided only as examples. Various modifications to the preferred embodiment will be readily apparent to those skilled in the art, and the general principles defined herein may be applied to other embodiments and applications without departing from the spirit and scope of the invention. Thus, the present invention is not intended to be limited to the embodiment shown, but is to be accorded the widest scope consistent with the principles and features disclosed herein.\n\nA. The Client--Server Model\n\nThis section provides a general description of exemplary host computers (client and server) and the network environment in which they operate.\n\nFIG. 1 is an illustrative pictorial diagram of a typical well known computer network 100 such as the Internet, for example. The computer network 100 includes small computers, such as computers 102, 104, 106, 108, 110 and 112 and large computers, such as computers A and B, commonly used as servers. In general, small computers may be \"personal computers\" or workstations and are sites where a human user operates the computer to make requests for data or services from other computers on the network. Often, the requested data resides in the large computers referred to as servers. In this scenario, the small computers are client systems and the large computers are servers. In this specification, the term \"client\" refers to a computer's general role as a requester of data or services, and the term \"server\" refers to a computer's role as a provider of data or services. In general, the size of a computer, in terms of its storage capacity and processing capability, does not necessarily affect its ability to act as a client or server. Further, it is possible that a computer may request data or services in one transaction and provide data or services in another transaction, thus changing its role from client to server or vice versa.\n\nThe illustrative drawing of FIG. 2 shows an exemplary well known client computer system 140. It includes a display device 142 (such as a monitor), a display screen 144, a cabinet 146 (which encloses typical computer components such as a CPU, RAM, ROM, video card, hard drive, network adapter card, serial ports, etc.), a keyboard 148, a mouse 150, and perhaps a modem 152. The modem, for example, allows the client computer system to be connected to an Interact network via phone lines, for example.\n\nB. HTML Documents and HTTP\n\nThis section describes the use of identification tags to designate hyperlinks using HTML documents and HTTP as an example. As explained in the specification, however, the present invention applies to other types of documents as well, such as Adobe PDF, voice documents and motion picture and still picture documents.\n\nIn order to make the transfer of data from one arbitrary computer to another possible, uniform protocols have been developed. An early attempt at creating a uniform protocol for data transfers over the Internet is File Transfer Protocol (FTP). More recent protocols include Gopher developed at the University of Minnesota and the World Wide Web project which defined the HyperText Transfer Protocol (HTTP). HTTP has been defined by an Internet Draft dated Nov. 5, 1993 and subsequent drains.\n\nBy providing uniform protocols so that clients may request objects and servers may deliver objects to clients, computers on the Internet are able to easily transfer different types of information such as text and images. By using the HyperText concept an efficient user interface is provided to a human user that allows the user to discover what information is available and to request the information.\n\nAn illustration of the HyperText concept is shown in FIG. 3. In FIG. 3, a portion of document 10 is shown. This is symbolic of text which would appear, for example, on a computer display screen as viewed by a user. Text portion 10 includes simple text and HyperText, the latter being text associated with a link. In text portion 10 there are two HyperText phrases associated with links. The first one is \"client-server model\" while the second is \"Internet\". The fact that these text phrases are associated with links is indicated by the underlining of the text phrases.\n\nThe first phrase \"client-server model\" is linked to text document 12 by means of link 16. Text document 12 is a separate document from text document 10. Text document 12 may reside in the same computer system as text document 10 or text document 12 may be in a remote location such as in a storage device connected to a server that is geographically removed from the computer system that a user is operating to view document 10.\n\nIn practice, links such as 16 can be implemented in a document, such as document 10, by using a special text format that allows embedded tags or other symbols within the text to specify a link. These embedded tags are not displayed to a user reading the text. One popular tag syntax is part of the HyperText Markup Language (HTML) and uses a Uniform Resource Locator (URL) form of addressing. The URL is unique for each object on the network. Objects may be text documents, images, sounds, programs or other forms of digital data. In FIG. 3, documents 12 and 14 are text objects pointed to by HyperText links. A HyperText link can be specified in a number of ways with HTML's. The use of URLs is merely a currently popular standard way to specify links.\n\nOnce specified, link 16 allows a user who is viewing document 10 to easily retrieve document 12. The user is provided with a simple and obvious indication that the phrase \"client-server model\" is a HyperText link to another document by the underlining. Since the phrase is one that is being used in context within the document the user is reading, the user may make a timely decision to learn more about the subject of the HyperText phrase. For example, in FIG. 3, the HyperText phrase \"client-server model\" links to document 12 which provides a further description of a client-server model.\n\nA common way for the user to access document 12 while viewing document 10 on a display screen of a computer system is to move a pointer on the display screen by means of an input device, such as a mouse, so that the pointer is over the phrase \"client-server model\". The user then depresses the mouse button to \"click on\" the phrase. This causes the user's computer system to retrieve document 12 either from local storage or from a remote location connected to the user's computer via a network such as the Internet. Once document 12 is retrieved, the user's computer system displays the document, or a portion of the document, on the user's display screen.\n\nSimilarly, the second phrase in document 10, \"Internet . . . allows the user to access document 14 by link 20. In other words, if the user clicks on the HyperText phrase \"Internet\" document 14, or a portion of document 14, is displayed on the user's screen. HyperText documents can have nested linking. Document 12 is the target of a HyperText link and may, itself, have HyperText links within it as shown in FIG. 3 where link 18 is associated with HyperText \"Internet\" in document 12. Note that the same word or phrase may function as a link in different documents and different documents may link to a common document. Many variations on HyperText linking from that shown in FIG. 3 are possible.\n\nC. Overview of Sockets API and Secure Sockets Layer (SSL) Interface\n\nA current embodiment of the invention provides a security protocol layered beneath an application protocol used by an application program to communicate over a network. The security protocol is implemented through a \"Secure Sockets Layer\" library (the SSL library) which is bound to the application program. The SSL library modules emulate the widely known \"sockets\" application program interface (API). The sockets API is supported by most major operating systems including UNIX and Microsoft Windows. For a general discussion of the sockets interface, refer to, Internetworking with TCP/IP, volume 1, by Douglas E. Comer, Prentice-Hall, Inc. 1995, pages 335-364.\n\nThe SSL library establishes a sockets connection with an application running on a remote computer and then performs a security handshake. Once the security handshake is complete, the SSL library then encrypts and decrypts all data sent to and received from a remote host computer through the socket connection. The SSL library is used with a reliable transport protocol. For the UNIX Windows environments, this is commonly provided by TCP/IP. The sockets API also can be used to provide access to Xerox XNS, Novell SPX/IPX and the OSI protocols as well.\n\nThe sockets API typically serves as an interface used by applications to communicate with the TCP/IP protocol stack. Generally, the client and server programs each invoke operating system functions that set up an association between them referred to as a sockets connection. The client and server applications then invoke operating system functions to send and receive information between them over a network, such as the Internet, in a similar manner to calling functions to perform ordinary input/output. The information, for example, may include graphics, data, instructions and even computer programs. The sockets connection between the two programs uses data structures which allow access to TCP/IP services. The sockets API ordinarily provides a series of system calls that application programs can invoke to request sockets connection communication services.\n\nMore specifically, the typical approach to using sockets is that a server application creates an open socket ready to accept connections at a given IP address and (well known) port. Once such a socket has been created, buffer space can be allocated to store incoming connection requests. The server socket ordinarily behaves as a passive endpoint waiting for a connection request to arrive from a client. In order for a client to send a connection request to a passive socket, the socket must have a name. Therefore, names are bound to sockets and are published so that a remote client can address the named socket. To initiate a connection to a remote socket a client application ordinarily requests a connection and specifies a local (client) socket and a remote name as parameters. Multiple clients can use a single server socket. Client requests can be queued in a buffer associated with the server socket. Typically when a request is accepted from the queue, a new socket is created and the new socket is used as the server side connection endpoint with a client. In this manner, a single well known port number can be used to establish many simultaneous socket connections. A shutdown (or dose) request usually is employed to terminate a socket connection.\n\nThus, in a present embodiment of the invention, an application layer program makes sockets calls to its SSL library which sets up a sockets connection and also ensures security during data transmission over the network. There are important advantages in binding a connection interface (sockets API) plus a security protocol (described below) in a layer between an application program layer and a transport layer in accordance with the invention. For example, since the sockets API is so widely used by application programs and operating systems, the SSL's sockets API can be adopted for use in a broad range of network environments. Moreover, since the SSL library of the presently preferred embodiment of the invention, is disposed between the application program layer and the transport layer, security can be provided to multiple different types of applications without significant modification to the applications themselves. Furthermore, changes in security requirements or procedures often can be more readily implemented by changing security protocols disposed above the transport layer, which is typically implemented as part of the operating system, than by changing the operating system itself. As explained above, the SSL library is layered between the application layer programs and the operating system transport control protocol stack. As a result, SSL security can be modified and upgraded without changing the operating system.\n\nD. SSL Library's Security: Key Exchange, Authentication and Integrity Checks\n\nThis section explains the apparatus and methods whereby a client application and a server application ensure adequate security during an information exchange between them. Subsequent sections explain the details of a novel \"Record Protocol Specification\" used during SSL communications between client and server and the details of a novel \"Handshake Protocol\" used to establish a secure \"sockets\" layer (SSL) communication channel between client and server. The disclosure in this section references public key algorithms, bulk ciphers, authentication processes and integrity checks in general. It will be appreciated that the principles discussed in this section can be applied to numerous different specific instances of each of these security and integrity check mechanisms. The section below describing the handshake protocol provides many examples of different combinations of public key algorithms, bulk ciphers, authentication processes and integrity checks that can be employed consistent with the invention.\n\nRSA Key Exchange Assuming No \"Session-Identifier\"\n\nReferring to FIG. 4, there is shown the message flow during handshake protocol negotiation where RSA key exchange is employed and no \"session-identifier\" is stored in server cache. Note that at the stage at which the message exchange in FIG. 4 begins, the client and server already have established a \"sockets\" connection between them, and the server has determined that the connection is to be a secure connection that employs the novel SSL processes and program control mechanisms described herein. As explained above, the sockets API is well known. Moreover, in accordance with the invention, the sockets connection is initiated by a client application SSL-- open call to its SSL library which is bound to the client application. The data transferred between client and server can be encrypted/decrypted as it is channeled through the socket. But first, before any data is transferred, the client and the server must negotiate an encryption technique for the data transfer, authenticate the connected parties (server and possibly client too), and check the integrity of the agreed upon secure connection. This negotiation is carried out in response to the SSL-- open call through message flow of FIG. 4, which takes place using the sockets connection previously set up as part of that same SSL-- open call.\n\nThe client sends to the server, through the sockets connection, a client-hello message which includes the following information: challenge data and cipher-- specs. In the current implementation of the invention, the challenge data is a random number used to ensure channel integrity as explained below. The cipher-specs indicate which bulk ciphers are supported by the client.\n\nThe server responds to the client-hello message with a server-hello message which includes the following information: connection-- identification, server-- certificate and cipher-- specs. The connection-- identification is a randomly generated set of bits. The server-- certificate is issued to the server through well known techniques and is used to certify the authenticity of the server. The cipher-- specs sent by the server to the client indicate the bulk cipher to be used during the data transfer. The bulk cipher is selected by the server from the choices provide by the client in the ciper-- specs portion of the client-hello message. Since it is possible that there may be multiple different ciphers supported by the client and by the server, it is necessary for the client and server to \"negotiate\" which cipher to use based upon the available client and server ciphers. Upon receiving the client-hello message, the server determines which server ciphers match the available client ciphers identified in the client cipher-- specs portion of the client-hello message. The server selects a cipher to be used to encrypt/decrypt the data to be transmitted and indicates its choice in the cipher-- specs portion of the server-hello message.\n\nThe client delivers a master key to the server in a client-master-key message. The master key, for example, can be a randomly generated number. The master key is used by the client and the server to produce session keys which will be employed to actually encrypt/decrypt the data to be transferred through the sockets connection. The master key is a shared secret between the client and the server. The master key is delivered by the client to the server in encrypted form using a key exchange encryption algorithm. In FIG. 4, an RSA public key algorithm is employed for key exchange.\n\nOnce the master key has been delivered to the server, the server and the client both can independently generate the session keys used to actually encrypt/decrypt data transferred following successful completion of the handshake protocol. The session keys are produced using well known techniques such as through hash functions referenced in the sections below or some other function of the master key and another data value. A more detailed explanation of the session key production techniques used in the presently preferred embodiment of the invention is provided below in the handshake protocol section. It should be understood that, while public key encryption techniques are used for master key exchange, the actual encryption/decryption of data transferred between client and server through the socket is achieved using a well known bulk cipher, such as RC2, RC4 or IDEA, negotiated through the respective cipher-- specs components of the information exchanged in the client-hello and server-hello messages. The selected bulk cipher uses the session keys to encipher/decipher data and messages transferred through the socket connection.\n\nThe client sends a client-finished message which indicates that the client is satisfied with the server. In a present embodiment of the invention, the client-finish message includes a hash of all of the handshake protocol messages previously sent by the client. The hash is encrypted using the agreed upon bulk cipher plus a session key generated by the client, referred to in FIG. 4 as the client-write-key. Note that the hash function also is negotiated as part of the cipher-- specs. In addition, the connection-identification previously sent to the client by the server is transmitted to the server with the client-finish message to authenticate the channel. The server uses the client messages handshake hash to verify the integrity of the communication between client and server. This final integrity check will expose third party intervention even if it occurred at the beginning of the handshake protocol.\n\nThe server sends a server-finished message which indicates that the server is satisfied with the client and is ready to begin the actual data transfer through the socket connection. In a present embodiment of the invention, the server-finish message includes a hash of all of the handshake protocol messages previously sent by the server. The hash is encrypted using the agreed upon bulk cipher plus a session key generated by the server, referred to in FIG. 4 as the server-- write-- key. The hash function also is negotiated as part of the cipher-- specs. The server uses the server messages handshake hash to verify the integrity of the communication between client and server as explained above.\n\nIn addition, a new session-- identification is sent together with the hashandshake hash encrypted using the bulk cipher and the server-- write-- key. This new-- session-- identification is stored by both the client application and the server application in their respective cache memories together with the master key and the encryption algorithm selection (cipher plus hash) so that, as explained below, the master key can be used again in a future socket connection between the client and the server. Note that if a client machine, for example, is running multiple instantiations of the application program then each instantiation will have its own session-identification.\n\nIn a present embodiment, the session-- identifications are stored by client application and server application in a table like the following:\n\n______________________________________ session.sub.-- identification table ______________________________________ session.sub.-- ID machine IP address master key encryption timer algorithm ______________________________________\n\nThe server-finish message also includes the challenge data sent by the client to the server in the client-hello message. The challenge data is encrypted by the selected bulk cipher using the server-- write-- key. The client decrypts the challenge data in order to verify that the key exchange has been successful by testing the ability to encrypt and decrypt the mutually known challenge data using the newly generated session keys.\n\nRSA Key Exchange Assuming a Session-Identificr Found By Client and Server\n\nReferring to FIG. 5, there is shown a sequence of messages transferred through the socket connection when the client and server negotiate the handshake protocol at a time when each stores a common session-- identification in its respective cache memory. The session-- identification for a given handshake protocol is stored for a period of time together with the information generated during the handshake. That stored information includes the previously agreed upon block cipher and hash function as well as the earlier master key. A given session-- identification together with its related information is retained in cache memory in the client and in the server for a prescribed period of time, 100 seconds in a current implementation. During that time interval, if the client application again attempts to access the server through a new SSL library connection, then the new connection can use the same block cipher, hash function and master key that were negotiated during the prior handshake protocol.\n\nThe stored session-- identification information advantageously saves time in establishing secure sockets connections without unreasonably compromising security. The generation of session keys is a relatively time consuming task since it involves the exchange of a master key using a relatively slow public key algorithm. By using the previously derived session-- identification information, the master key and encryption algorithm (a block cipher plus a hash function in the preferred embodiment), the most time consuming handshake steps can be avoided. This approach is particularly beneficial, for example, in applications such as client-server data transfers involving a client application establishing a secure sockets connection with a secure server over the Internet. A client application, such as a web browser constructed in accordance with the present invention for example, may set up a connection to a remote server in order to retrieve information requested by a client user.\n\nFor instance, an electronic document containing hyperlinks may be displayed by the client browser application. Whenever a user \"clicks\" on (or selects) portion of the document associated with a hyperlink, another electronic document or file or a graphic or some other remotely stored information that corresponds to the link is retrieved over the Internet from the server. Before the transfer can occur, however, the handshake protocol is negotiated, and encryption/decryption information is developed as described above. That information is stored with the session-- identification for that connection. When that new document (or other information) has been transferred to the client, the SSL library causes the secure sockets connection used to accomplish the transfer of that next document to be closed. The session-- identification information (master key, block cipher, hash function) is stored in cache by the client and server applications for a prescribed time intervals. If within that time a user of that same client browser application \"clicks\" on another hyperlink, then the client browser application will set up another sockets connection with the server to satisfy this latest request. Rather than go through the entire time consuming handshake protocol, however, the client and server will use the previously generated and stored session-- identification information (master key, block cipher, hash function) to secure data transfer through the new socket set up by the SSL library to satisfy this latest request.\n\nIt will be appreciated that as each subsequent client request is made to the secure server, a new session-- identification with a new interval timer is stored in the client cache memory and in the server cache memory. Thus, the same block cipher, master key and hash functions can be used for multiple secure sockets connections, even when the connections occur over a time interval which is extends beyond the prescribed interval of the original connection for which the session-- identification information was negotiated, provided that there is no time gap between any two requests that exceeds the prescribed time interval.\n\nReferring to FIG. 5 in step-- the client-hello message sends a session-- identification which identifies previously stored security information (master key, block cipher, hash function) together with challenge data and cipher-- specs. The server-hello message sends a connection-- identification together with a session-- identification-- hit indication. Since the has been a hit, there is a match between a session-- identification stored in the client cache and a session-- identification stored in the server cache. This means that there was a previous secure sockets connection between the client application and the server application, and that the session-- identification information negotiated and stored in conjunction with that prior connection still is available for use with this later connection. Therefore there is no need to negotiate a cipher-- specs or to generate and a new master key or to generate new session keys. The remaining steps in FIG. 5 are identical to the corresponding steps in FIG. 4. Note that a new session-- identification is delivered in the server-finish message. This new session-- identification supplants the prior session-- identifications which matched.\n\nRSA Key Exchange Assuming Session-Identification Match and Client Authentication\n\nIn FIG. 6 the first four messages, client-hello, server-- hello, client-finish and server-verify are identical to the first four messages in FIG. 5. However, the server sends a request-certificate message which includes authentication-- type and challenge data encrypted with the server-- write key (one of the earlier agreed upon master keys). The authentication-type specifies an encryption technique to be used to authenticate the client; several authentication techniques can be supported by a current embodiment of the invention as explained in a following section. The challenge data is used in the authentication process. A client-certificate message is sent by the client to the server. The client-certificate message includes certificate-- type, client-- certificate and response-- data, all of which are encrypted using the client-- write-- key (one of the earlier agreed upon master key). Several certificate types, described below, are supported by the current embodiment. The certificate-- type indicates which one has been employed. The client-- certificate contains the data defined by the certificate-- type value. The response data contains authentication response data which is a function of the authentication-- type sent by the server in the request-certificate message. The final step is the same as the final steps in FIGS. 4 and 5.\n\nDiffie-Hellman Key Exchange Assuming No Session-Identification\n\nFIG. 7, illustrates a Diffie-Hellman (DH) key exchange in accordance with a current implementation of the present invention. The client-hello and the server-hello messages, are the same as the corresponding messages in FIG. 4. Also, the client-finish message and the server-finish message are the same as corresponding messages in FIG. 4. In a present implementation of a DH key exchange, a \"Y\" value and a random number are delivered by the client to the server in a client-dh-key message. The Y value is a public number which corresponds to a secret number which is the result of an exponentiation process. The Y value and the random number are used by both client and server to generate a new randomized key. In a DH key exchange, both sides in the exchange independently generate the same master key. The client-session-key message delivers the session-- key-- 1 encrypted by a master-- key. The client session-key message -- also delivers the random number encrypted by the session-- key-- 1. This encrypted random number is important in hardware implementations of the DH exchange.\n\nE. SSL Library's Sockets API\n\nOverview of Internet Architecture\n\nReferring to FIG. 8, there is a generalized illustrative representation of a typical protocol stack which resides in each host machine (client and server) connected to the Internet. Also shown is the encapsulation and decapsulation of a typical program data unit (PDU) (or message) as it travels from one host to another through the Internet. The application layer security mechanisms and processes of the present invention ordinarily operate in an Internet environment, although the invention can be practiced in different network environments as well.\n\nThe typical Internet protocol stack includes five network \"layers\". Note that the Internet model lacks the presentation and session layers that are proposed in the International Standards Organization (ISO) Open Systems Interconnection (OSI) Reference Model. During client-server communications, information to be transferred from the server to the client, for example, is first transferred from server application layer computer programs down to the server transport layer. Next, the information is transferred down through network, data link and physical layers that may be associated with the server, and then up through physical, data link and network layers that may be associated with the client. Information transfer down and back up through these lower three layers may involve transfers through a communication subnet which may include routing devices as illustrated. The information then continues its trip up through the client transport layer to the client application layer. The transfer of information in the opposite direction, from client to server, involves a similar layer by layer transfer but in the opposite direction, starting with the client application layer and ending with the server application layer. Those skilled in the art will appreciate that there are various different protocols that can be used to implement the different protocol layers, and that many variations of the basic network model are possible. For a discussion of well known network architectures and the typical functions associated with the various layers within the architecture refer to, Network Management Standards: SNMP, CMIP, TMN, MIBs, and Object Libraries, Second Edition, by Uyless Black, McGraw-Hill, Inc., 1994. Also see, Computer Networks, Second Edition, by Andrew S. Tanenbaum, Prentice-Hall, Inc., 1989.\n\nFocus on Application and Transport Layer Security\n\nIn FIG. 9, there is an illustrative drawing providing a more detailed view of client side and server side application layer and transport layer programs and protocol structures used during client-server network communications in accordance with a current embodiment of the invention. The client and server application layers each include SSL libraries which cooperate to provide an application program interface which encrypts and decrypts information passed between different client and server application programs through a transport layer socket connection. The client application layer, for example, may include any of numerous types of computer programs which rely upon client-server network connections. For example, the client application might be a network browser application used to provide user access to the World Wide Web. Alternatively, for instance, the client application might be employed for financial transactions involving credit card or home banking. It should be appreciated that these are but a few sample types of application programs that require security when involved in information transfer using a client-server network connection. The server application layer, for example, may include an HTTP server which provides information to a client browser application in response to a client request. In a present embodiment, the client application layer may includes multiple application layer protocols used during transfers of information in connection with different categories of applications. For example, in a present embodiment of the invention, a client application may employ HTTP, network news transfer protocol (NNTP), file transfer protocol (FTP), and Telnet. Each different application protocol is used in communications involving different server applications. For example, NNTP is used to access certain news sources over the Internet; FTP can be used for file transfers over the Internet; and a Telnet can be used for remote login over the Internet.\n\nAn SSL library provides a sockets API that other applications can call to encrypt and decrypt information passed through a socket connection. Moreover, in a current embodiment of the invention, both the client and the server include operating system services which implement respective client and server transport layer protocols that use socket type connections. These built in transport layer operating system services may be an integral part of the client and server operating systems. That is generally the case, for example, with the UNIX operating system.\n\nAlternatively, for example, the present invention may be practiced in a host (client or server) environment in which transport layer socket connection services are implemented as part of an application layer dynamic link library (DLL), such as Winsock for instance, which runs on top of a Windows operating system. Winsock is a DLL which provides a socket application program interface, but it does not provide the socket layer security.\n\nThe illustrative drawing of FIG. 10 shows client and server side application layers and transport layers which employ the Winsock DLL in conjunction with the SSL library in accordance with an alternative embodiment of the present invention. In operation, for example, a client application calls Winsock to request a socket connection to a server application. Winsock, in turn, calls the SSL library and requests a connection to the server application. The SSL library then calls the operating system protocol stack and establishes the socket connection with the server side. The client side and server side SSL libraries negotiate security. Once a security scheme has been agreed upon, the client side SSL library returns a message to Winsock indicating that a socket connection is available. Winsock, in turn, returns a message to the calling client application indicating that a socket is ready. The client then can proceed to communicate with the server application through Winsock and the SSL library using the secure socket connection set up by the SSL library.\n\nThe illustrative drawings of FIG. 11 shows client and server side application layers and transport layers which employ a variation of the Winsock DLL in conjunction with the SSL library in accordance with another alternative embodiment of the present invention. Winsock has been modified to incorporate the SSL library functionality into a new DLL referred to herein as the Winsock/SSL-- library. In operation, for example, a client application calls Winsock/SSL-- library to request a socket connection to a server application. The Winsock/SSL-- library, in turn, calls the operating system protocol stack and establishes the socket connection with the server side. The client side and server side Winsock/SSL-- libraries negotiate security. Once a security scheme has been agreed upon, the client side Winsock/SSL-- library returns a message to the calling client application indicating that a socket is ready. The client then can proceed to communicate with the server application through the Winsock/SSL-- library using the secure socket connection.\n\nSSL Library's Sockets API\n\nBriefly summarized, in a present embodiment, the application program interface provided by the SSL library includes the following calls: SSL-- open, SSL-- write, SSL-- read and SSL-- close.\n\nSSL-- open\n\nWhen an application calls SSL-- open, the SSL library to make a request to the operating system transport layer service to open a socket connection. The handshake protocol takes place between the client side and server side SSL libraries. The handshake results in an encryption scheme agreed upon by the client and server side SSL libraries. Once the handshake has been successfully completed, the SSL library returns a message to the calling application indicating that a socket connection has been opened.\n\nSSL-- write\n\nWhen an application calls SSL-- write, the SSL library encrypts the information presented to it by the application using the agreed upon encryption scheme. The SSL library then calls the operating system transport layer service and requests a write of the encrypted message to a server designated by the calling application using the socket connection created during SSL-- open. SSL-- read\n\nWhen a host (client or server) that monitors a port designated for SSL library communications receives a message, the application calls SSL-- read which invokes the SSL library which then decrypts the message, and passes the decrypted message to the application.\n\nSSL-- close\n\nWhen a transfer of information through a socket connection created by an SSL-- open call is finished or an error condition occurs, SSL-- close is called by either the client or the server. The SSL library that receives SSL-- close sends a message instructing the operating system transport layer service to close the socket connection. Note that whenever an error is detected during information transfer, either during handshake protocol or actual data transfer, SSL-- close is called by the host (client or server) that discovers the error. This is a security precaution.\n\nThus, the SSL library decrypts information before sending it to an application program, and encrypts information after receiving it from an application program. Conversely, the SSL library encrypts information before sending it to a transport layer socket connection, and decrypts information after receiving it from a transport layer socket connection. In other words, the SSL library only sends and receives clear (unencrypted) information to and from application programs, and the SSL library only sends and receives encrypted information to and from a socket connection. In essence, the apparatus and method of the present invention redirects client-server information transfers between application layer and transport layer so that the information passes through an encryption/decryption mechanism implemented as client side and server side SSL libraries. The operation of the security mechanisms and processes of the present invention will become more apparent from the following explanation of the flow diagram of FIG. E3.\n\nF. An Example of the SSL Library in Action\n\nFIG. 12A-C illustrates the operation of the application layer and transport layer programs and protocols of FIGS. 9 and 8 during client-server communications in accordance with a present embodiment of the invention. For the purpose of explaining the FIG. 12A-C flow diagram, it is assumed that the client application is a network browser and that the server application is an HTTP server. However, it should be appreciated that the invention can be employed with other types of client and server applications. Furthermore, the invention can be practiced with a host that employs an application layer DLL, such as Winsock, which provides a socket application program interface to host applications.\n\nIn FIG. 12A-C a user of a client browser application program, for example, may wish to access additional information (text, graphics, or sound, etc.) that relates to certain text or an image or an icon displayed on a client computer screen. Referring to FIG. 3, for instance, the client computer screen at first might display the illustrated text describing the World Wide Web. Embedded in the text is the word, \"Internet\", which is highlighted through underlining and bolding. The highlighting indicates to the user that the word, \"Internet\", corresponds to a hyperlink that can be used to access a related electronic document that provides more information about the Internet. When the user \"clicks\" on (or selects) the word \"Internet\", the client application retrieves from the electronic document a URL such as, HTTP:\\\\HOME.NETSCAPE.COM\\FILENAME.HTML, for example, with a header that identifies a server that has the additional information about the \"Internet\" sought by the user. In practice, for example, the electronic document may contain an HTML hyperlink tag that is used to set up a client-server relationship in which the sought after \"Internet\" information stored by a server will be provided to the client application in response to the user's \"clicking\" on the word \"Internet\" in the electronic document.\n\nAlthough this example is cast in terms of a document having an HTML format, the invention may be practiced with documents or ties using different formats. That is, a prefix (like HTTPS), marker or name can be added to the URL, or other network address indicator, of almost any file or document to indicate that it is to be made \"secure\" in accordance with the invention. For example, a JPEG, GIF, MPEG, Postscript or voice files, or almost any hypermedia document can be made secure using the apparatus and methods of the invention.\n\nNote that even the act of opening an electronic document may involve creating multiple socket connections in order to gather information to be displayed as part of the document. For example, document text may be retrieved from one server, and each graphics image in the document may be retrieved from another server. The information in the document may be highly confidential. Hence, each of the connections used to open the document in the first place can be protected through encryption in accordance with the present invention. Moreover, once the document is displayed, it may contain hyperlinks to yet other information (text, graphics, sound, etc.). It is just such a hyperlink that is the subject of the example illustrated in FIG. 12A-C.\n\nReferring again to FIG. 12A-C, the client application calls SSL-- open to request a socket connection with the server identified in the URL associated with the highlighted selected word \"Interact\". In this example, the HTTPS header in the URL indicates that the server is a secure HTTP server. The \"S\" suffix in the header syntax indicates that the connection is to be a secure connection, and that the application should invoke the SSL library. The absence of an \"S\" from the header syntax, that is a normal HTTP header, would indicate that the connection need not be secure, and that the SSL library need not be invoked. Thus, the HTTPS header indicates to the application that the SSL library is to be called to provide a secure HTTP transfer. Note that the protocol known as HTTP itself is not altered or modified. Rather, information transferred between client and server applications is encrypted/decrypted in transit using the client side and server side SSL libraries. In effect, the SSL libraries provide an additional security layer between application and transport layers.\n\nIt will be appreciated that a URL prefix or suffix or similar identifier can be employed to indicate to an application program that the SSL library should be invoked in connection with other types of client-server transfers as well. For example, an FTP transfer can be made secure by inserting a marker such as, \"FTPS\", in a URL to indicate that the application should call the SSL library to accomplish the transfer. The client side and server side SSL libraries handle security while the FTP application remains unchanged. The same can be done with NNTP or Telnet transfers, for example. In each case, the client and server SSL libraries set up a secure socket connection through which all information is passed in encrypted form.\n\nIn response to SSL-- open, the client SSL library calls the appropriate client operating system service requesting a socket connection with the HTTP server identified in the URL. It will be appreciated that different client computers may employ different operating systems, such as UNIX or Windows, for instance.\n\nThe client and the server establish a socket connection between them. At this point in the SSL-- open process, the socket connection is not yet a secure one. Rather, it is a typical connection of the general type that the client operating system would set up in response to an application request to open a socket connection. More specifically, the client operating system transport layer service, over a network architecture of the general type disclosed in FIG. 8, communicates with the corresponding operating system service transport layer service of the designated HTTP server to establish a client endpoint and a server endpoint for a transport layer socket connection. The client endpoints are defined by a combination comprising IP address (or DNS name) and port number. A TCP message header typically contains a port number which indicate the source and destination ports of a message. The lower level protocols carry the IP address. A host (client or server) can determine whether or not a message is encrypted based upon the port numbers in the TCP header.\n\nWhen the client and server operating system services have established the socket connection described above, the client operating system returns a message to the SSL library indicating successful connection. The client side SSL library and the server side SSL library then engage in a handshake protocol in accordance with the invention using the socket connection that has been established by the client and server operating system services. During the handshake procedure, for example, encryption/decryption precautions are negotiated, the server is authenticated and the integrity of the socket security is checked. A detailed explanation of the handshake protocol is provided elsewhere in this specification. Once the handshake procedure has been successfully completed, the client SSL library returns to the client application a message indicating the HTTP server endpoint of the socket connection. Meanwhile, the server side SSL library listens on the endpoint port.\n\nNext, continuing with the above example, the client application sends an SSL-- write to the client side SSL library with a message addressed to the designated server endpoint requesting the information relating to the selected word \"Internet\" that appeared in the electronic document. In response to the SSL-- write, the client side SSL library encrypts the client application message using an encryption/decryption scheme agreed upon for the connection during the handshake negotiation process. The client side SSL then calls the client operating system transport layer service with a request to send the encrypted message addressed to the HTTP server endpoint using the socket connection created during the SSL-- open. The client operating system sends the encrypted client application request over the network to the HTTPS server endpoint. Note that the information transferred through the socket connection is secure since it was encrypted before it entered the socket using the agreed upon SSL library encryption procedures.\n\nUpon receipt of the encrypted client application message addressed to the designated server port number, the server calls SSL-- read invokes the SSL library decryption routines which then decrypt the received message using the agreed upon decryption scheme. Basically, the server knows that any message sent to the designated server port number is a message that requires decryption. Whenever a message arrives on a server port number designated during the SSL-- open process, the server calls SSL-- read to decrypt the received message. Once decrypted, the message is passed over to the server application. The HTTP server retrieves the information requested by the client application message.\n\nAs explained above, there is a session-- identification table stored for each client-server socket connection which indicates the master key, cipher and hash for the session. This session-- identification information is used as context for the present secure socket connection, and as explained above, may be re-used in later connections.\n\nWhen the server has retrieved the requested information, it then calls the server SSL library with an SSL-- write requesting delivery of the requested information to the client side endpoint. The server side SSL library encrypts information, and then calls the server operating system transport layer service and requests a write of the encrypted message to the designated client endpoint. The server side operating system transport layer service handles the request and delivers the message to the client application endpoint.\n\nUpon receipt of the encrypted server message addressed to the designated client port number, the client application calls SSL-- read to invoke the SSL library decryption routines which then decrypt the received message using the agreed upon decryption scheme. The client side SSL library then delivers the decrypted HTTP server message to the client application.\n\nFinally, the client application displays on the client display screen information corresponding to the selected word, \"Internet\", which was retrieved from the HTTPS server. The server calls SSL dose to dose the socket connection when it has finished sending the requested information.\n\nG. Record Protocol Specification\n\nIn this section, additional details are provided concerning SSL record formats, handshake protocols and security techniques employed by a presently preferred embodiment of the invention.\n\nSSL Record Header Format.\n\nIn SSL, all data sent is encapsulated in a record, an object which is composed of a header and some non-zero amount of data. Each record header contains a two or three byte length code. If the most significant bit is set in the first byte of the record length code then the record has no padding and the total header length will be 2 bytes, otherwise the record has padding and the total header length will be 3 bytes. The record header is transmitted before the data portion of the record.\n\nNote that in the long header case (3 bytes total), the second most significant bit in the first byte has special meaning. When zero, the record being sent is a data record. When one, the record being sent is a security escape (there are currently no examples of security escapes; this is reserved for future versions of the protocol). In either case, the length code describes how much data is in the record.\n\nThe record length code does not include the number of bytes consumed by the record header (2 or 3). For the 2 byte header, the record length is computed by (using a \"C\"-like notation):\n\nRECORD-LENGTH=((byte[O]&0x7f)<<8))|byte[l];\n\nWhere byte[O]represents the first byte received and byte[1]the second byte received. When the 3 byte header is used, the record length is computed as follows (using a \"C\"-like notation):\n\nRECORD-LENGTH=((byte[O]&0x3f)<<8))|byte[1];\n\nIS-ESCAPE=(byte[O1 & 0x40)!=0;\n\nPADDING=byte[2];\n\nThe record header defines a value called PADDING. The PADDING value specifies how many bytes of data were appended to the original record by the sender. The padding data is used to make the record length be a multiple of the block ciphers block size when a block cipher is used for encryption. The sender of a \"padded\" record appends the padding data to the end of its normal data and then encrypts the total amount (which is now a multiple of the block cipher's block size). The actual value of the padding data is unimportant, but the encrypted form of it must be transmitted for the receiver to properly decrypt the record. Once the total amount being transmitted is known the header can be properly constructed with the PADDING value set appropriately.\n\nThe receiver of a padded record decrypts the entire record data (sans record length and the optional padding) to get the clear data, then subtracts the PADDING value from the RECORD-LENGTH to determine the final RECORD-LENGTH. The clear form of the padding data must be discarded.\n\nSSL Record Data Format.\n\nThe data portion of an SSL record is composed of three components (transmitted and received in the order shown):\n\nMAC-DATA[MAC-SIZE]\n\nACTUAL-DATA [N]\n\nPADDING-DATA [PADDING]\n\nACTUAL-DATA is the actual data being transmitted (the message payload). PADDING-DATA is the padding data sent when a block cipher is used and padding is needed. Finally, MAC-DATA is the \"message Authentication Code\".\n\nWhen SSL records are sent in the clear, no cipher is used. Consequently the amount of PADDING-DATA will be zero and the amount of MACDATA will be zero. When encryption is in effect, the PADDING-DATA will be a function of the cipher block size. The MAC-DATA is a function of the CIPHER-CHOICE (more about that later).\n\nThe MAC-DATA is computed as follows:\n\nMAC-DATA: =HASH[SECRET, ACTUAL-DATA,\n\nPADDING-DATA, SEQUENCE-NUMBER]\n\nWhere the SECRET data is fed to the hash function first, followed by the ACTUAL-DATA, which is followed by the PADDING-DATA which is finally followed by the SEQUENCE-NUMBER. The SEQUENCE-NUMBER is a 32 bit value which is presented to the hash function as four bytes, with the first byte being the most significant byte of the sequence number, the second byte being the next most significant byte of the sequence number, the third byte being the third most significant byte, and the fourth byte being the least significant byte (that is, in network byte order or \"big ending\" order).\n\nMAC-SIZE is a function of the digest algorithm being used. For MD2 and MD5 the MAC-SIZE will be 16 bytes (128 bits).\n\nThe SECRET value is a function of which party is sending the message and what kind of key exchange algorithm/cipher was chosen.\n\nFor the non-token key exchange algorithms (e.g. RSA, DH):\n\nIf the client is sending the message then the SECRET is the CLIENT-WRITE-KEY (the server will use the SERVER-READ-KEY to verify the MAC). If the client is receiving the message then the SECRET is the CLIENT-READ-KEY (the server will use the SERVER-WRITE-KEY to generate the MAC).\n\nFor the token key exchange algorithms (e.g. RSA-TOKEN, DH-TOKEN, FORTEZZA-TOKEN):\n\nThe SECRET value is the RANDOM-NUMBER from the CLIENT-SESSION-KEY message. The value is used identically by the client and the server for both sending and receiving.\n\nThe SEQUENCE-NUMBER is a counter which is incremented by both the sender and the receiver. For each transmission direction, a pair of counters is kept (one by the sender, one by the receiver). Every time a message is sent by a sender the counter is incremented. Sequence numbers are 32 bit unsigned quantities and must wrap to zero after incrementing past 0xFFFFFFFF.\n\nThe receiver of a message uses the expected value of the sequence number as input into the MAC HASH function (the HASH function is chosen from the CIPHER-CHOICE). The computed MAC-DATA must agree bit for bit with the transmitted MAC-DATA. If the comparison is not identity then the record is considered damaged, and it is to be treated as if an \"1/0 Error\" had occurred (i.e. an unrecoverable error is asserted and the connection is closed).\n\nA final consistency check is done when a block cipher is used and the protocol is using encryption. The mount of data present in a record (RECORD-LENGTH)) must be a multiple of the cipher's block size. If the received record is not a multiple of the cipher's block size then the record is considered damaged, and it is to be treated as if an \"1/0 Error\" had occurred (i.e. an unrecoverable error is asserted and the connection is closed).\n\nThe SSL Record Layer is used for all SSL communications, including handshake messages, security escapes and application data transfers. The SSL Record Layer is used by both the client and the server at all times.\n\nFor a two byte header, the maximum record length is 32767 bytes. For the three byte header the maximum record length is 16383 bytes. The SSL Handshake Protocol messages are constrained to fit in a single SSL Record Protocol record. Application protocol messages are allowed to consume multiple SSL Record Protocol record's.\n\nBefore the first record is sent using SSL all sequence numbers are initialized to zero. The transmit sequence number is incremented after every message sent, starting with the CLIENT-HELLO and SERVER-HELLO messages.\n\nOut of Band Data.\n\nSSL Version 3 supports the transmission and reception of \"out of band data\". Out of band data is normally defined at the TCP/IP protocol level, but because of SSL's privacy enhancements and support for block ciphers, this becomes difficult to support.\n\nTo send out-of-band data, the sender sends an escape record whose body contains a single byte of data indicating the escape type code:\n\nchar escape-tee-code\n\nThe escape-type-code value should be SSL-- ET-- OOB-- DATA. The record following the escape record will be interpreted as \"out-of-band\" data and will only be made available to the receiver through an unspecified mechanism that is different than the receivers normal data reception method. The transmitted data record and the escape record are transmitted normally (i.e. encryption, MAC computations, and block cipher padding remain in effect).\n\nNote that the escape record and the following record are sent using normal TCP sending mechanisms, not using the \"out of band\" mechanisms.\n\nH. Handshake Protocol\n\nIn this section, additional details are provided concerning the SSL handshake protocol and security techniques employed by a presently preferred embodiment of the invention.\n\nProtocol Flow\n\nThe handshake protocol includes several phases. In a present embodiment of the invention, the first phase is the \"hello\" phase which is used to define the capabilities of the client and server and to agree upon a set of algorithms to use for privacy and authentication. The first phase also allows for the discovery of a \"session-identification\", and if present, to skip some of the successive phases. The following messages are exchanged in the hello phase:\n\nCLIENT-HELLO\n\nSERVER-HELLO\n\nThe second phase is the key exchange phase during which key material is exchanged between the client and server. The key exchange results in the client and server sharing a master key. The following are exchanged in the key exchange phase:\n\nCLIENT-MASTER-KEY\n\nCLIENT-DH-KEY\n\nThe third phase is the session key production phase in which the actual session keys that will be used during the current communication session are produced. The following are exchanged in he session key production phase:\n\nCLIENT-SESSION-KEY\n\nThe fourth phase is the server-verify phase which, in the current embodiment, is used only when the RSA key exchange algorithm is used. This phase verifies the server's discovery of the master key and subsequent generation of the session keys. The following messages are exchanged in the server verify phase:\n\nSERVER-VERIFY\n\nThe fifth phase involves client authentication. This phase is used only for key exchange algorithms that do not authenticate the client. Currently, only the RSA key exchange algorithm fails to authenticate the client. The following messages are exchanged in the client authentication phase:\n\nREQUEST-CERTIFICATE\n\nCLIENT-CERTIFICATE\n\nThe sixth phase is the final phase during which both sides of the conversation exchange \"finish\" messages. The following messages are exchanged in the finished phase:\n\nCLIENT-FINISHED\n\nSERVER-FINISHED\n\nErrors\n\nError handling in the SSL Handshake protocol is very simple. When an error is detected, the detecting party sends a message to the other party. Errors that are not recoverable cause the client and server to abort the secure connection. Servers and client are required to \"forget\" any session identifiers associated with a failing connection.\n\nThe SSL Handshake Protocol defines the following errors:\n\nNO-CIPHER-ERROR\n\nThe above error is returned by the client to the server when it cannot find a cipher or key size that it supports that is also supported by the server. This error is not recoverable.\n\nNO-CERTIFICATE-ERROR\n\nWhen a REQUEST-CERTIFICATE message is sent, the above error may be returned if the client has no certificate to reply with. This error is recoverable (for client authentication only).\n\nBAD-CERTIFICATE-ERROR\n\nThe above error is returned when a certificate is deemed bad by the receiving party. Bad means that either the signature of the certificate was bad or that the values in the certificate were inappropriate (e.g. a name in the certificate did not match the expected name). This error is recoverable (for client authentication only).\n\nUNSUPPORTED-CERTIFICATE-TYPE-ERROR\n\nThe above error is returned when a client/server receives a certificate type that it can't support. This error is recoverable (for client authentication only).\n\nHandshake Protocol Messages\n\nHandshake protocol messages are encapsulated using the \"SSL Record Protocol\". The messages are composed of two parts: a single byte message code and some data. The client and server exchange messages until both sides have sent their \"finished\" message, indicating that they are satisfied with the handshake protocol conversation. While one end of the conversation may have finished, the other end may not. Therefore, the finished end must continue to receive protocol handshake messages until it receives a \"finished\" message from its peer.\n\nAfter the pair of session keys has been determined by each party, the message bodies are encrypted. For the client, this happens after it verifies the session-identifier or creates a new master key and has sent it to the server. For the server, this happens after the session-identifier is found to be good, or the server receives the client's master key message.\n\nThe following notation is used in the preferred embodiment for SSLHP messages:\n\nchar MSG-EXAMPLE\n\nchar FIELD1\n\nchar FIELD2\n\nchar THING-MSB\n\nchar THING-LSB\n\nchar THING-DATA[(MSB<<8)|LSB];\n\nThis notation defines the data in the protocol message, including the message type code. The order is presented top to bottom, with the top most element being transmitted first, and the bottom most element transferred last.\n\nFor the \"THING-DATA\" entry, the MSB and LSB values are actually THING-MSB and THING-LSB (respectively) and define the number of bytes of data actually present in the message. For example, if THINGMSB were zero and THING-LSB were 8 then the THING-DATA array would be exactly 8 bytes long. This shorthand is used below.\n\nLength codes are unsigned values, and when the MSB and LSB are combined the result is an unsigned value. Unless otherwise specified lengths values are \"length in bytes\".\n\nERROR Message\n\nThe ERROR message may be sent clear or encrypted. The error message may be sent in a number of the Handshake Protocol phases. Its format is:\n\nchar MSG-ERROR\n\nchar ERROR-CODE-MSB\n\nchar ERROR-CODE-LSB\n\nThis message is sent when an error is detected. If the message is sent after session-key have been negotiated then the message is sent encrypted, otherwise it is sent in the clear. Also, if the error is unrecoverable then the sender shuts down its connection after sending the error. In a similar fashion the receiver will close its connection upon receipt of an unrecoverable error.\n\n\"Hello\" Phase Messages:\n\nThe \"Hello\" phase messages are used by client and server inform of security and encryption capabilities. The security and encryption information is contained the CIPHER-SPECS data passed initially from the client to the server. This data defines the kinds of security and encryption algorithms that the client can support. The data is made available to the server in the CLIENT-HELLO message. The CIPHER SPECS contain the key exchange algorithms supported by the client in server and the certificate types supported by the client. The server is required to examine the CIPHER-SPECS sent by the client and remove any that it does not support and any that it chooses not to support. In addition, for SSL version 3, the server is required to choose a single key exchange algorithm from the choices provided by the client.\n\nThe encryption and security capabilities that are resolved by the \"Hello\" phase messages are:\n\nThe key exchange algorithm and certificates for each endpoint (the client's certificate is optional).\n\nThe symmetric cipher algorithm the session-key(s) for it and any key argument data.\n\nThe hash function used for MAC computations. handshake hash computation and session key production.\n\nClient-Hello\n\nThe client-hello message is sent in the clear. The form of the client-hello message is as follows:\n\nchar MSG-CLIENT-HELLO\n\nchar CLIENT-VERSION-MSB\n\nchar CLIENT-VERSION-LSB\n\nchar CIPHER-SPECS-LENGTH-MSB\n\nchar CIPHER-SPECS-LENGTH-LSB\n\nchar SESSION-ID-LENGTH-MSB\n\nchar SESSION-ID-LENGTH-LSB\n\nchar CHALLENGE-LENGTH-MSB\n\nchar CHALLENGE-LENGTH-LSB\n\nchar CIPHER-SPECS-DATA[(MSB<<8)|LSB]\n\nchar SESSION-ID-DATA[(MSB<<8)|LSB]\n\nchar CHALLENGE-DATA[(MSB<<8)|LSB]\n\nWhen a client first connects to a server it is required to send the CLIENT-HELLO message. The server is expecting this message from the client as its first message. It is an error for a client to send anything else as its first message.\n\nThe client sends to the server its SSL version (currently there are several versions of the novel SSL), its cipher specs (see below), some challenge data, and the session-identifier data. The session-identifier data is only sent if the client found a session-identifier in its cache for the server, and the SESSION-ID-LENGTH will be non-zero. When there is no session-identifier for the server SESSION-ID-LENGTH must be zero. The challenge data is used to authenticate the server. After the client and server agree on a pair of session keys, the server returns a SERVER-VERIFY message with the encrypted form of the CHALLENGE-DATA.\n\nAlso note that the server will not send its SERVER-HELLO message until it has received the CLIENT-HELLO message. This is done so that the server can indicate the status of the client's session-identifier back to the client in the server's first message (i.e. to increase protocol efficiency and reduce the number of round trips required).\n\nThe server examines the CLIENT-HELLO message and will verify that it can support the client version and one of the client cipher specs. The server can optionally edit the cipher specs. removing any entries it doesn't choose to support. The edited version will be returned in the SERVER-HELLO message if the session-identifier is not in the server's cache.\n\nThe CIPHER-SPECS-LENGTH must be greater than zero and a multiple of 3. The SESSION-ID-LENGTH must either be zero or 16. The CHALLENGE-LENGTH must be greater than or equal to 16 and less than or equal to 32.\n\nThis message must be the first message sent by the client to the server. After the message is sent the client waits for a SERVER-HELLO message. Any other message returned by the server (other than ERROR) is disallowed.\n\nServer-Hello\n\nThe SERVER-HELLO message is sent in the clear. The format of the SERVER-HELLO message is as follows:\n\nchar MSG-SERVER-HELLO\n\nchar SESSION-ID-HIT\n\nchar CERTIFICATE-TYPE\n\nchar SERVER-VERSION-MSB\n\nchar SERVER-VERSION-LSB\n\nchar CERTIFICATE-LENGTH-MSB\n\nchar CERTIFICATE-LENGTH-LSB\n\nchar CIPHER-SPECS-LENGTH-MSB\n\nchar CIPHER-SPECS-LENGTH-LSB\n\nchar CONNECTION-ID-LENGTH-MSB\n\nchar CONNECTION-ID-LENGTH-LSB\n\nchar CERTIFICATE-DATA[MSB<<8)|LSB]\n\nchar CIPHER-SPECS-DATA[MSB<<8)|LSB]\n\nchar CONNECTION-ID-DATA[MSB<<8)|LSB]\n\nThe server sends this message after receiving the clients CLIENT-HELLO message. The server returns the SESSION-ID-HIT flag indicating whether or not the received session-identifier is known by the server (i.e. in the server's session-identifier cache). The SESSION-ID-HIT flag will be non-zero if the client sent the server a session-identifier (in the CLIENT-HELLO message with SESSION-ID-LENGTH 0) and the server found the client's session-identifier in its cache. If the SESSION-ID-HIT flag is non-zero then the CERTIFICATE-TYPE, CERTIFICATE-LENGTH and CIPHER-SPECS-LENGTH fields will be zero.\n\nThe CERTIFICATE-TYPE value, when non-zero, has one of the values described above (see the information on the CLIENT-CERTIFICATE message).\n\nWhen the SESSION-D-HIT flag is zero, the server packages up its certificate, its cipher specs and a connection-id to send to the client. Using this information the client can generate a session key and return it to the server with the CLIENT-MASTER-KEY message.\n\nWhen the SESSION-ID-HIT flag is non-zero, both the server and the client compute a new pair of session keys for the current session derived from the MASTER-KEY that was exchanged when the SESSION-ID was created. The SERVER-READ-KEY and SERVER-WRITE-KEY are derived from the original MASTER-KEY keys in the same manner as the CLIENT-READ-KEY and CLIENT-WRITE-KEY:\n\nSERVER-READ-KEY :=CLIENT-WRITE-KEY\n\nSERVER-WRITE-KEY :=CLIENT-READ-KEY\n\nNote that when keys are being derived and the SESSION-ID-HIT flag is set and the server discovers the client's session-identifier in the servers cache, then the KEY-ARG-DATA is used from the time when the SESSION-ID was established. This is because the client does not send new KEY-ARG-DATA (recall that the KEY-ARG-DATA is sent only in the CLIENT-MASTER-KEY message).\n\nThe CONNECTION-ID-DATA is a string of randomly generated bytes used by the server and client at various points in the protocol. The CLIENT-FINISHED message contains an encrypted version of the CONNECTION-ID-DATA. The length of the CONNECTION-ID must be between 16 and than 32 bytes, inclusive.\n\nThe CIPHER-SPECS-DATA define the kind of algorithms supported by the sender. Each SESSION-CIPHER-SPEC is 3 bytes long and looks like this:\n\nchar CIPHER-KIND-0\n\nchar CIPHER-KIND- 1\n\nchar CIPHER-KIND-2\n\nWhere CIPHER-KIND is one of(for SSL version 2 and version 3):\n\nSSL-- CK-- RC4-- 128-- WITH-- MD5\n\nSSL-- CK-- RC4-- 128-- EXPORT40-- WITH-- MD5\n\nSSL-- CK-- RC2-- 128-- CBC-- WITH-- MD5\n\nSSL-- CK-- RC2128-- CBC-- EXPORT40-- WITH-- MD5\n\nSSL-- CK-- IDEA-- 128-- CBC-- WITH-- MD5\n\nSSL-- CK-- DES-- 64-- CBC-- WITH-- MD5\n\nSSL-- CK-- DES-- 192-- EDE3-- CBC-- WITH-- MD5\n\nThe following CIPHER-KIND's are added for SSL version 3:\n\nSSL-- CK-- 'NULL-- WITH-- MD5\n\nSSL-- CK-- DES-- 64-- CBC-- WITH-- SHA\n\nSSL-- CK-- DES-- 192 EDE3-- CBC-- WITH-- SHA\n\nSSL-- KEA-- RSA\n\nSSL-- KEA-- RSA-- TOKEN-- WITH-- DES\n\nSSL-- KEA-- RSA-- TOKEN-- WITH-- DES-- EDE3\n\nSSL-- KEA-- RSA-- TOKEN-- WITH-- RC4\n\nSSL-- KEA-- DH SSL-- KEA-- DH-- TOKEN-- WITH-- DES\n\nSSL-- KEA-- DH-- TOKEN-- WITH-- DES-- EDE3\n\nSSL-- KEA-- DH-- ANONYMOUS\n\nSSL-- KEA-- DH-- TOKEN-- ANONYMOUS-- WITH-- DES\n\nSSL-- KEA-- DH-- TOKEN-- ANONYMOUS-- WITH-- DES-- EDE3\n\nSSL-- KEA-- FORTEZZA-- SSL-- KEA-- FORTEZZA-- ANONYMOUS\n\nSSL-- KEA-- FORTEZZA-- TOKEN\n\nSSL-- KEA-- FORTEZZA-- TOKEN-- ANONYMOUS\n\nNote that additional or different algorithms may be used without departing from the invention.\n\nThe server receives CIPHER-KIND-DATA from the client and culls out the ciphers the server does not want to support. In addition, for SSL version 3 the server must eliminate all but one of the key exchange algorithm's.\n\nThe SSL-- CK-- RC4-- 128-- EXPORT40-- WITH-- MD5 cipher is an RCI cipher where some of the session key is sent in the clear and the rest is sent encrypted (exactly 40 bits of it). MD5 is used as the hash function for production of MAC's and session key's. This cipher type is provided to support \"export\" versions (i.e. versions of the protocol that can be distributed outside of the United States) of the client or server.\n\nAn exportable implementation of the SSL Handshake Protocol will have secret key lengths restricted to 40 bits and only support either RC2, RC4 or both. For non-export implementations key lengths can be more generous (we recommend at least 128 bits). It is permissible for the client and server to have a non-intersecting set of stream ciphers. This, simply put, means they cannot communicate.\n\nThe SSL Handshake Protocol defines the SSL-- CK-- RC4-- 128-- WITH-- MDS to have a key length of 128 bits. The SSL-- CK-- RC4-- I 28-- EXPORT40-- WITH-- MD5 also has a key length of 128 bits. However, only 40 of the bits are secret (the other 88 bits are sent in the clear by the client to the server).\n\nThe SERVER-HELLO message is sent after the server receives the CLIENT-HELLO message, and before the server sends the SERVER-VERIFY message.\n\nKey Exchange Phase Messages\n\nThe \"Key Exchange\" phase is used to establish a MASTER-KEY that is a shared secret between the client and the server. The kind of message sent by the client is dependent on the key exchange algorithm chosen by the server. If an RSA key exchange algorithm is used then the CLIENT-MASTER-KEY message will be sent. The CLIENT-DH-KEY is used for Diffie-Hellman style key exchanges (e.g. DH and FORTEZZA).\n\nIn addition, session key production is a function of the Kind of key exchange algorithm. \"Token\" key exchange algorithms use the CLIENT-SESSION-KEY message to define the session keys. Non-token key exchange algorithm'5 use the key production facilities described in below in the section describing session-key production.\n\nClient-Master-Key\n\nThe client-master-key is sent primarily in the clear. The format of the client-master-key message is as follows:\n\nchar MSG-CLIENT-MASTER-KEY\n\nchar CIPHER-KIND [3]\n\nchar CLEAR-KEY-LENGTH-MSB\n\nchar CLEAR-KEY-LENGTH-LSB\n\nchar ENCRYPTED-KEY-LENGTH-MSB\n\nchar ENCRYPTED-KEY-LENGTH-LSB\n\nchar KEY-ARG-LENGTH-MSB\n\nchar KEY-ARG-LENGTH-LSB\n\nchar CLEAR-KEY-DATA[MSB<<8)|LSB]\n\nchar ENCRYPTED-KEY-DATA[MSB<<8)|LSB]\n\nchar KEY-ARG-DATA[MSB<<8)|LSB]\n\nThe client sends this message when it has determined a master key for the server to use. Note that when a session-identifier has been agreed upon, the client-master-key message is not sent.\n\nThe CIPHER-KIND field indicates which cipher was chosen from the server's CIPHER-SPECS.\n\nThe CLEAR-KEY-DATA contains the clear portion of the MASTER-KEY. The CLEAR-KEY-DATA is combined with the SECRET-KEY-DATA (described shortly) to form the MASTER-KEY, with the SECRET-KEY-DATA being the least significant bytes of the final MASTER-KEY. The ENCRYPTED-KEY-DATA contains the secret portions of the MASTER-KEY, encrypted using the server's public key. The encryption block is formatted using block type 2 from PKCS#1, as specified in RSA Encryption Standard, Version 1.5, Nov. 1993. The data portion of the block is formatted as follows:\n\nchar SECRET-KEY-DATA[SECRET-LENGTH]\n\nSECRET-LENGTH is the number of bytes of each session key that is being transmitted encrypted. The SECRET-LENGTH plus the CLEARKEY-LENGTH equals the number of bytes present in the cipher key (as defined by the CIPHER-KIND). It is an error if the SECRET-LENGTH found after decrypting the PKCS#1 formatted encryption block does not match the expected value. It is also an error if CLEAR-KEY-LENGTH is non-zero and the CIPHER-KIND is not an export cipher.\n\nIf the key algorithm needs an argument (for example, DES-CBC's initialization vector) then the KEY-ARG-LENGTH fields will be non-zero and the KEY-ARG-DATA will contain the-relevant data. For the\n\nSSL-- CK-- RC2-- 128-- CBC-- WITH-- MD5\n\nSSL-- CK-- RC2-- 128-- CBC-- EXPORT40-- WITH-- MD5\n\nSSL-- CK-- IDEA-- 128-- CBC-- WITH-- MD5\n\nSSL-- CK-- DES-- 64-- CBC-- WITH-- MD5\n\nSSL-- CK-- DES-- 192-- EDE3-- CBC-- WITH-- MD5\n\nSSL-- CK-- DES-- 64-- CBC-- WITH-- SHA\n\nSSL-- CK-- DES-- 192-- EDE3-- CBC-- WITH-- SHA\n\nalgorithms the KEY-ARG data must be present and be exactly 8 bytes long.\n\nThe CLIENT-MASTER-KEY message must be sent after the CLIENT-HELLO message and before the CLIENT-FINISHED message. The CLIENT-MASTER-KEY message must be sent if the SERVER-HELLO message contains a SESSION-ID-HIT value of 0.\n\nSession Key Production\n\nClient and server session key production is a function of the CIPHERCHOICE (Note that this step is skipped for \"token\" key exchange algorithm's--the CLIENT-SESSION-KEY message is used instead):\n\nSSL-- CK-- NULL-- WITH-- MD5\n\nSSL-- CK-- RC4-- 128-- WITH-- MD5\n\nSSL-- CK-- RC4-- 128-- EXPORT40-- WITH-- MD5\n\nSSL-- CK-- RC2-- 128-- CBC-- WITH-- MD5\n\nSSL-- CK-- RC2-- 128-- CBC-- EXPORT40-- WITH-- MD5\n\nSSL-- CK-- IDEA-- 128-- CBC-- WITH-- MD5\n\nKEY-MATERIAL-0:=MD5[MASTER-KEY, \"0\", CHALLENGE, CONNECTION-ID\n\nKEY-MATERIAL-I :=MD5[MASTER-KEY, \"1\", CHALLENGE, CONNECTION-ID\n\nCLIENT-READ-KEY :=KEY-MATERIAL-0[0-15]\n\nCLIENT-WRITE-KEY :=KEY-MATERIAL-1 [0-15]\n\nWhere KEY-MATERIAL-0[0-15] means the first 16 bytes of the KEY-MATERIAL-0 data, with KEY-MATERIAL-0[0] becoming the most significant byte of the CLIENT-READ-KEY.\n\nData is fed to the MD5 hash function in the order shown, from left to right: first the MASTER-KEY, then the \"0\" or \"1\", then the CHALLENGE and then finally the CONNECTION-ID.\n\nNote that the \"0\" means the ascii zero character (0x30), not a zero value. \"1\" means the ascii I character (0x31). MD5 produces 128 bits of output data which are used directly as the key to the cipher algorithm (The most significant byte of the MD5 output becomes the most significant byte of the key material).\n\nFinally, note that although the NULL cipher produces session keys in the same was as the other ciphers listed, the session keys are not actually used for encryption. However, they are used for the SECRET value in the MAC computation.\n\n______________________________________ SSL.sub.-- CK.sub.-- DES.sub.-- 64.sub.-- CBC.sub.-- WITH.sub.-- MD5 SSL.sub.-- CK.sub.-- DES.sub.-- 64.sub.-- CBC.sub.-- WITH.sub.-- SHA KEY-MATERIAL -0:= HASH[MASTER-KEY, CHALLENGE, CONNECTION-ID CLIENT-READ-KEY:= KEY-MATERIAL-0[0-7] CLIENT-WRITE-KEY:= KEY-MATERIAL-0[8-15] ______________________________________\n\nFor DES-CBC, a single 16 bytes of key material are produced using HASH. The first 8 bytes of the hash function results are used as the CLIENT-READ-KEY while the next 8 bytes are used as the CLIENT-WRITE-KEY The initialization vector is provided in the KEY-ARG-DATA. Note that the raw key data is not parity adjusted and that this step must be performed before the keys are legitimate DES keys.\n\n__________________________________________________________________________ SSL.sub.-- CK.sub.-- DES.sub.-- 192.sub.-- EDE3.sub.-- CBC.sub.-- WITH.sub.-- MD5 SSL.sub.-- CK.sub.-- DES.sub.-- 192.sub.-- EDE3.sub.-- CBC.sub.-- WITH.sub.-- SHAKEY.sub.-- MATERIAL-0:= HASH[MASTER-KEY, \"0\", CHALLENGE, CONNECTION-ID KEY-MATERIAL-I:= HASH[MASTER-KEY, \"1\" CHALLENGE, CONNECTION-ID KEY-MATERIAL-2:= HASH[MASTER-KEY, \"2\", CHALLENGE, CONNECTION-ID CLIENT-READ-KEY-0:= KEY-MATERLAL-0[0-7] CLIENT-READ-KEY-I:= KEY-MATERLAL-0[8-15] CLIENT-READ-KEY-2:= KEY-MATERIAL-I[0-7] CLIENT-WRITE-KEY-0:= KEY-MATERIAL-I[8-15] CLIENT-WRITE-KEY-I:= KEY-MATERIAL-2[0-7] CLIENT-WRITE-KEY-2:= KEY-MATERIAL-2[8-IS] __________________________________________________________________________\n\nData is fed to the HASH function in the order shown, from left to right: first the MASTER-KEY, then the \"0\", \"1\" or \"2\",then the CHALLENGE and then finally the CONNECTION-ID. Note that the \"0\" means the ascii zero character (0x30), not a zero value. \"1\" means the ascii 1 character (0x31). \"2\"means the ascii 2 character (0x32).\n\nA total of 6 keys are produced, 3 for the read side DES-EDE3 cipher and 3 for the write side DES-EDE3 function. The initialization vector is provided in the KEY-ARG-DATA. The keys that are produced are not parity adjusted. This step must be performed before proper DES keys are usable.\n\nRecall that the MASTER-KEY is given to the server in the CLIENT-MASTER-KEY message. The CHALLENGE is given to the server by the client in the CLIENT-HELLO message. The CONNECTION-ID is given to the client by the server in the SERVER-HELLO message. This makes the resulting cipher keys a function of the original session and the current session. Note that the master key is never directly used to encrypt data, and therefore cannot be easily discovered.\n\nClient-DH-Key\n\nThe client-DH-Key is sent primarily in the clear. The form of the client-DH-Key message is as follows:\n\nchar MSG-CLIENT-DH-KEY\n\nchar Y-LENGTH-MSB\n\nchar Y-LENGTH-LSB\n\nchar CERTIFICATE-TYPE\n\nchar CERTIFICATE-LENGTH-MSB\n\nchar CERTIFICATE-LENGTH-LSB\n\nchar RANDOM-LENGTH-MSB\n\nchar RANDOM-LENGTH-LSB\n\nchar Y-DATA[MSB<<8|LSB]\n\nchar CERTIFICATE-DATA[MSB<<8|LSB]\n\nchar RANDOM-DATA[MSB<<8|LSB]\n\nThe client sends this message to the server to finish a Diffie-Hellman style key exchange. The client provides it's \"Y\" value either directly in the YDATA or indirectly in the CERTIFICATE-DATA. If the key exchange algorithm is not \"anonymous\" then the client must provide the certificate data.\n\nThe RANDOM-DATA is used by the server and client to produce the MASTER-KEY. This is necessary when mutual authentication is used because otherwise the MASTER-KEY would be a constant,\n\nThe CLIENT-SESSION-KEY message must immediately follow this message.\n\nSession Key Production Phase Messages\n\nThis message is used by \"token\" key exchange algorithms. Token's disallow key material to leave the token unencrypted and because of this the client must communicate to the server the encrypted value of the session keys (because the server cannot produce them).\n\nClient-Session-Key\n\nThe client-session-key message format is as follows:\n\nchar MSG-CLIENT-SESSION-KEY\n\nchar CIPER-KIND [3]\n\nchar CLEAR-KEY1-LENGTH-MSB\n\nchar CLEAR-KEY1-LENGTH-LSB\n\nchar ENCRYPTEDI-KEY-LENGTH-MSB\n\nchar ENCRYPTED1-KEY-LENGTH-LSB\n\nchar CLEAR-KEY2-LENGTH-MSB\n\nchar CLEAR-KEY2-LENGTH-LSB\n\nchar ENCRYPTED2-KEY-LENGTH-MSB\n\nchar ENCRYPTED2-KEY-LENGTH-LSB\n\nchar KEY-ARG-LENGTH-MSB\n\nchar KEY-ARG-LENGTH-LSB\n\nchar RANDOM-NUMBER-LENGTH-MSB\n\nchar RANDOM-NUMBER-LENGTH-LSB\n\nchar CLEAR-KEY1-DATA[MSB<<8/LSB]\n\nchar ENCRYPTED-KEY1-DATA[MSB<<8/LSB]\n\nchar CLEAR-KEY2-DATA[MSB<<8/LSB]\n\nchar ENCRYPTED-KEY2-DATA[MSB<<8/LSB]\n\nchar KEY-ARG-DATA[MSB<<8/LSB]\n\nchar RANDOM-NUMBER-DATA[MSB<<8/LSB]\n\nThis message is sent by the client after either the CLIENT-MASTER-KEY message or the CLIENT-DH-KEY message. The message is used to establish one (or two) session keys with the server. Each session key is composed of two pieces: the CLEAR-KEY-DATA and the ENCRYPTED-KEY-DATA. If the CIPHER-KIND indicates an export grade cipher then some of the key data will be sent in the clear (in the CLEAR-KEY-DATA). The CLEAR-KEY-DATA and the ENCRYPTED-KEY-DATA are concatenated to produce a session key. This message allows for two independent session keys to be established. If two keys are used then the first key (KEY1) becomes the CLIENTWRITE-KEY and the SERVER-READ-KEY. The second key (KEY2) becomes the CLIENT-READ-KEY and the SERVER-WRITE-KEY.\n\nThe ENCRYPTED-KEY-DATA's are encrypted using the MASTER-KEY (the MASTER-KEY was established by the CLIENT-DH-KEY message). The RANDOM-NUMBER-DATA is encrypted using KEY1.\n\nThe KEY-ARG-DATA is used by ciphers that require some sort of initialization data (e.g. DES's IV). The RANDOM-NUMBER-DATA is used as the SECRET for MAC computations (recall that for tokens the session key data is not available in the clear)\n\nServer Verify Phase Messages\n\nThe server-verify message is sent encrypted.\n\nServer-Verify\n\nThe client-session-key message has the following format:\n\nchar MSG-SERVER-VERIFY\n\nchar CHALLENGE-DATA[N-1]\n\nThe server sends this message after a pair of session keys (SERVER-READ-KEY and SERVER-WRITE-KEY) have been agreed upon either by a session-identifier or by explicit specification with the CLIENT-MASTER-KEY message. The message contains an encrypted copy of the CHALLENGE-DATA sent by the client in the CLIENT-HELLO message.\n\n\"N\" is the number of bytes in the message that was sent, so \"N-1\" is the number of bytes in the CHALLENGE-DATA without the message header byte.\n\nThis message is used to verify the server as follows. A legitimate server will have the private key that corresponds to the public key contained in the server certificate that was transmitted in the SERVER-HELLO message. Accordingly, the legitimate server will be able to extract and reconstruct the pair of session keys (SERVER-READ-KEY and SERVER-WRITE-KEY). Finally, only a server that has done the extraction and decryption properly can correctly encrypt the CHALLENGE-DATA. This, in essence, \"proves\" that the server has the private key that goes with the public key in the server's certificate.\n\nThe CHALLENGE-DATA must be the exact same length as originally sent by the client in the CLIENT-HELLO message. Its value must match exactly the value sent in the dear by the client in the CLIENT-HELLO message. The client must decrypt this message and compare the value received with the value sent, and only if the values are identical is the server to be \"trusted\". If the lengths do not match or the value doesn't match then the connection is to be closed by the client.\n\nThis message must be sent by the server to the client after either detecting a session-identifier hit (and replying with a SERVER-HELLO message with SESSION-ID-HIT not equal to zero) or when the server receives the CLIENT MASTER-KEY message. This message must be sent before any Phase 2 messages or a SERVER-FINISHED message.\n\nClient Authentication Phase Messages\n\nClient Authentication messages are sent encrypted.\n\nRequest-Certificate\n\nThe request-certificate message has the following format:\n\nchar MSG-REQUEST-CERTIFICATE\n\nchar AUTHENTICATION-TYPE\n\nchar CERTIFICATE-CHALLENGE-DATA[N-2]\n\nA server may issue this request asking for the client's certificate. This message can be used with the RSA key exchange algorithm only. The client responds with a CLIENT-CERTIFICATE message immediately if it has one, or an ERROR message (with error code NO-CERTIFICATE-ERROR) if it doesn't. The CERTIFICATE-CHALLENGE-DATA is a short byte string (whose length is greater than or equal to 16 bytes and less than or equal to 32 bytes) that the client will use to respond to this message.\n\nThe AUTHENTICATION-TYPE value is used to choose a particular means of authenticating the client. The following types are defined:\n\nSSL-- AT-- MD5-- WITH-- RSA-- ENCRYPTION\n\nThe SSL-- AT-- MD5-- WITH-- RSA-- ENCRYPTION type requires that the client construct an MD5 message digest using information as described above in the section on the CLIENT-CERTIFICATE message. Once the digest is created, the client encrypts it using its private key (formatted according to the digital signature standard defined in PKCS#1). The server authenticates the client when it receives the CLIENT-CERTIFICATE message.\n\nThis message may be sent after a SERVER-VERIFY message and before a SERVER-FINISHED message.\n\nClient-Certificate\n\nThe format of the client-certificate message is as follows:\n\nchar MSG-CLIENT-CERTIFICATE\n\nchar CERTIFICATE-TYPE\n\nchar CERTIFICATE-LENGTH-MSB\n\nchar CERTIFICATE-LENGTH-LSB\n\nchar RESPONSE-LENGTH-MSB\n\nchar RESPONSE-LENGTH-LSB\n\nchar CERTIFICATE-DATA[MSB<<8/LSB]\n\nchar RESPONSE-DATA[MSB<<8/LSB]\n\nThis message is sent by one an SSL client in response to a server REQUEST-CERTIFICATE message. The CERTIFICATE-DATA contains data defined by the CERTIFICATE-TYPE value. An ERROR message is sent with error code NO-CERTIFICATE-ERROR when this request cannot be answered properly (e.g. the receiver of the message has no registered certificate).\n\nCERTIFICATE-TYPE is one of:\n\nSSL-- X509-- CERTIFICATE\n\nThe CERTIFICATE-DATA contains an X.509 (1988) signed certificate.\n\nSee CCITT, Recommendation X.509: \"The Directory--Authentication Framework\". 1988.\n\nSSL-- PKCS7-- CERTIFICATE\n\nThe CERTIFICATE-DATA contains a PKCS-7 formatted certificate list.\n\nThe RESPONSE-DATA contains the authentication response data. This data is a function of the AUTHENTICATION-TYPE value sent by the server.\n\nWhen AUTHENTICATION-TYPE is SSL-- AT-- MD5-- WITH-- RSA-- ENCRYPTION then the RESPONSE-DATA contains a digital signature of the following components (in the order shown):\n\n1. the KEY-MATERIAL-0\n\n2. the KEY-MATERIAL-1 (only if defined by the cipher kind)\n\n3. the KEY-MATERIAL-2 (only if defined by the cipher Kind)\n\n4. the CERTIFICATE-CHALLENGE-DATA (from the REQUEST-CERTIFICATE message)\n\n5. the server's signed certificate (from the SERVER-HELLO message)\n\nThe digital signature is constructed using MD5 and then encrypted using the clients private key, formatted according to PKCS#1's digital signature standard. See, RSA Laboratories, PKCS#1: RSA Encryption Standard, Version 1.5, Nov. 1993. The server authenticates the client by verifying the digital signature using standard techniques. Note that other digest functions are supported. Either a new AUTHENTICATION-TYPE can be added, or the algorithm-id in the digital signature can be changed.\n\nThis message must be sent by the client only in response to a REQUEST-CERTIFICATE message.\n\nFinished Phase Messages\n\nFinished phase messages are sent encrypted.\n\nClient-Finished\n\nThe Client-finished message has the following format:\n\nchar MSG-CLIENT-FINISHED\n\nchar CONNECTION-ID-LENGTH-MSB\n\nchar CONNECTION-ID-LENGTH-LSB\n\nchar HANDSHAKE-HASH-LENGTH-MSB\n\nchar HANDSHAKE-HASH-LENGTH-LSB\n\nchar CONNECTION-B-DATA[MSB<<8/LSB]\n\nchar HANDSHAKE-HASH-DATA[MSB<<8/LSB]\n\nThe client sends this message when it is satisfied with the server. Note that the client must continue to listen for server messages until it receives a SERVER-FINISHED message. The CONNECTION-ID data is the original connection-identifier the server sent with its SERVER-HELLO message.\n\nThe HANDSHAKE-HASH data is the hash of the client's handshake messages sent previously to the server. The hash function used is defined by the agreed upon cipher (e.g., MD5). The client initializes the hash function at the beginning of the communications session and feeds into it every SSL record sent to the server. The entire record is sent including the record header, MAC, record data and optional padding. If the record was sent encrypted then the encrypted data is fed to the hash function, otherwise the clear data is used. The data is fed to the hash function in the same order as it is transmitted. When the client is ready to send the CLIENT-FINISHED message, the client \"finalizes\" the hash function retrieving from it the final hash value (in the case of MDS, 128 bits of data).\n\nNote that data sent prior to discovery of the hash function must be saved by the client so that it can be fed to the hash function once the hash function is determined.\n\nAlso note that the client authentication messages will not be protected under the cover of the HANDSHAKE-HASH. This is not a problem, however, because the CLIENT-CERTIFICATE message is sent encrypted and is already protected with by a MAC.\n\nFor version 2 of the protocol, the client must send this message after it has received the SERVER-HELLO message. If the SERVER-HELLO message SESSION-ID-HIT flag is non-zero then the CLIENT-FINISHED message is sent immediately, otherwise the CLIENT-FINISHED message is sent after the CLIENT-MASTER-KEY message.\n\nClient-FinishediV2\n\nchar MSG-CLIENT-FINISHED-V2\n\nchar CONNECTION- ID [N-1]\n\nThe client sends this message when it is satisfied with the server. Note that the client must continue to listen for server messages until it receives a SERVER-FINISHED message. The CONNECTION-ID data is the original connection-identifier the server sent with its SERVER-HELLO message, encrypted using the agreed upon session key.\n\n\"N\" is the number of bytes in the message that was sent, so \"N-1\" is the number of bytes in the message without the message header byte.\n\nFor version 2 of the protocol, the client must send this message after it has received the SERVER-HELLO message. If the SERVER-HELLO message SESSION-ID-HIT flag is non-zero then the CLIENT-FINISHED message is sent immediately, otherwise the CLIENT-FINISHED message is sent after the CLIENT-MASTER-KEY message.\n\nServer-Finished\n\nchar MSG-SERVER-FINISHED\n\nchar SESSION-ID-LENGTH-MSB\n\nchar SESSION-ID-LENGTH-LSB\n\nchar HANDSHAKE-HASH-LENGTH-MSB\n\nchar HANDSHAKE-HASH-LENGTH-LSB\n\nchar SESSION-ID-DATA[MSB<<8/LSB]\n\nchar "
    }
}