{
    "id": "dbpedia_4518_3",
    "rank": 67,
    "data": {
        "url": "https://builtin.com/software-engineering-perspectives/compiler-vs-interpreter",
        "read_more_link": "",
        "language": "en",
        "title": "Compiler vs. Interpreter in Programming",
        "top_image": "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=cover,w=1200,h=635,q=80/https://builtin.com/sites/www.builtin.com/files/2023-04/compiler-vs-interpreter.jpg",
        "meta_img": "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=cover,w=1200,h=635,q=80/https://builtin.com/sites/www.builtin.com/files/2023-04/compiler-vs-interpreter.jpg",
        "images": [
            "https://static.builtin.com/dist/images/bi-header-logo.svg",
            "https://static.builtin.com/dist/images/bi-header-logo.svg",
            "https://builtin.com/software-engineering-perspectives/company.logo",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,w=96,h=96,q=100/https://builtin.com/sites/www.builtin.com/files/2023-04/Rakia%20Ben%20Sassi_0.jpeg",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=cover,w=320,h=200,q=80/https://builtin.com/sites/www.builtin.com/files/2023-04/compiler-vs-interpreter.jpg",
            "https://static.builtin.com/dist/images/expert-badge.svg",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=contain,w=120,h=70,q=80/https://builtin.com/sites/www.builtin.com/files/2024-02/companies-hiring-software-engineers.jpg",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=contain,w=120,h=70,q=80/https://builtin.com/sites/www.builtin.com/files/2024-03/rise-prompt-engineering.jpg",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=contain,w=120,h=70,q=80/https://builtin.com/sites/www.builtin.com/files/2024-08/tmux-config.png",
            "https://static.builtin.com/dist/images/midnight_9.svg",
            "https://static.builtin.com/dist/images/builtin-logo.svg",
            "https://static.builtin.com/dist/images/united-we-tech.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Rakia Ben Sassi"
        ],
        "publish_date": "2023-04-24T19:45:00+00:00",
        "summary": "",
        "meta_description": "Both compilers and interpreters are used to convert a high-level language into machine code. However, there are differences between how and when they work.",
        "meta_lang": "en",
        "meta_favicon": "https://static.builtin.com/dist/images/favicon.png",
        "meta_site_name": "Built In",
        "canonical_link": "https://builtin.com/software-engineering-perspectives/compiler-vs-interpreter",
        "text": "I still remember a discussion with a colleague in which I said, “That’s the transpiler,” and he replied, “The…what?”\n\nIf you’ve never heard that name, you’re not alone. As developers, we all get used to writing code in a high-level language that humans can understand. However, computers can only understand a program written in a binary system known as machine code.\n\nTo speak to a computer in its non-human language, we came up with two solutions: interpreters and compilers. Ironically, most of us know very little about them, although they’re a part of our daily coding life.\n\nIn this post, I’ll dive into the journey of translating a high-level language into a machine code ready for execution. I’ll focus on the inner workings of the two key players in this game, the compiler and the interpreter, and break down the related concepts.\n\nCompilers vs. Interpreters: How Do They Work?\n\nCompilers and interpreters have long been used as computer programs to transform code. But they work in different ways:\n\nA compiler translates code written in a high-level programming language into a lower-level language like assembly language, object code andmachine code (binary 1 and 0 bits). It converts the code ahead of time before the program runs.\n\nAn interpreter translates the code line-by-line when the program is running. You’ve likely used interpreters unknowingly at some point in your work career.\n\nMore on Software DevelopmentBuild a Discord Bot With Python\n\nCompilers vs. Interpreters: Advantages and Disadvantages\n\nBoth compilers and interpreters have pros and cons:\n\nA compiler takes in the entire program and requires a lot of time to analyze the source code. Whereas the interpreter takes a single line of code and very little time to analyze it.\n\nCompiled code runs faster, while interpreted code runs slower.\n\nA compiler displays all errors after compilation. If your code has mistakes, it will not compile. But the interpreter displays errors of each line one by one.\n\nInterpretation does not replace compilation completely.\n\nCompilers can contain interpreters for optimization reasons like faster performance and smaller memory footprint.\n\nA high-level programming language is usually referred to as “compiled language” or “interpreted language.” However, in practice, they can have both compiled and interpreted implementations. C, for example, is called a compiled language, despite the existence of C interpreters. The first JavaScript engines were simple interpreters, but all modern engines use just-in-time (JIT) compilation for performance reasons.\n\n4 Common Types of Interpreters to Know\n\nInterpreters were used as early as 1952 to ease programming and also translate between low-level machine languages. The first interpreted high-level language was Lisp. Python, Ruby, Perl and PHP are other examples of programming languages that use interpreters.\n\nBelow is a list of interpreter’s types:\n\n4 Types of Interpreters\n\nBytecode interpreter\n\nThreaded code interpreter\n\nAbstract syntax tree interpreter\n\nJustin-in-time compilation\n\n1. Bytecode Interpreter\n\nThe trend toward bytecode interpretation and just-in-time compilation blurs the distinction between compilers and interpreters. Bytecode interpreters can process up to 256 instructions, with each instruction starting with a byte.\n\n2. Threaded Code Interpreter\n\nUnlike bytecode interpreters, threaded code interpreters use pointers instead of bytes. Each instruction is a word pointing to a function or an instruction sequence, possibly followed by a parameter. The number of different instructions is limited by the available memory and address space.\n\nForth code, which is used in Open Firmware systems, is a classical example of threaded code. The source code is compiled into a bytecode known as “F code,” which a virtual machine then interprets.\n\n3. Abstract Syntax Tree Interpreter\n\nIf you’re a TypeScript developer with some familiarity of the TypeScript architecture, you may have heard about the abstract syntax tree (AST).\n\nAST is an approach to transform the source code into an optimized abstract syntax tree, then execute the program following this tree structure, or use it to generate native code just-in-time.\n\nAST keeps the global program structure and relations between statements. This allows the system to perform better analysis during runtime and makes AST a better intermediate format for just-in-time compilers than bytecode representation.\n\nHowever, for interpreters, AST causes more overhead. Interpreters walking the abstract syntax tree are slower than those generating bytecode.\n\n4. Just-in-Time Compilation\n\nJust-in-time compilation (JIT) is a technique in which the intermediate representation is compiled to native machine code at runtime.\n\n10 Common Types of Compilers to Know\n\nBelow are the common types of compilers you should know.\n\n10 Types of Compilers\n\nCross-compiler\n\nNative compiler\n\nBootstrap compiler\n\nDecompiler\n\nSource-to-source compiler\n\nLanguage rewriter\n\nBytecode compiler\n\nJust-in-time compiler\n\nAOT compilation\n\nAssembler\n\n1. Cross-compiler\n\nA cross-compiler is one that runs on a computer whose CPU or operating system differs from the one on which the code it produces will run.\n\n2. Native Compiler\n\nA native compiler produces an output that would run on the same type of computer and operating system as the compiler itself.\n\n3. Bootstrap Compiler\n\nBootstrap compiler is a compiler written in the language that it intends to compile.\n\n4. Decompiler\n\nA decompiler translates code from a low-level language to a higher level one.\n\n5. Source-to-Source Compiler (Transpiler)\n\nA source-to-source compiler is a program that translates between high-level languages. This type of compiler is also known as a transcompiler or transpiler.\n\nSome examples of a transpiler include:\n\nEmscripten: This transpiles C/C++ to JavaScript.\n\nBabel: This transpiles JavaScript code from ES6+ to ES5.\n\nCfront: The original compiler for C++ (from around 1983). It used C as its target language and created C code with no indent style and no pretty C intermediate code, since the generated code was not usually intended to be readable by humans.\n\n6. A Language Rewriter\n\nThis is usually a program translating form of expressions without a change of language.\n\n7. Bytecode Compiler\n\nA compiler that translates a high-level language into an intermediate simple language that a bytecode interpreter or virtual machine can interpret. Examples include: Bytecode compilers for Java and Python.\n\n8. Just-in-Time Compiler (JIT Compiler)\n\nA JIT compiler defers compilation until runtime. It generally runs inside an interpreter.\n\nExamples of a JIT compiler include:\n\nThe earliest published JIT compiler is attributed to LISP in 1960.\n\nThe latter technique appeared in languages such as Smalltalk in the 1980s.\n\nSince then, JIT compilation has gained mainstream attention amongst modern languages like Java, .NET Framework, Python and most modern JavaScript implementations.\n\nIn Java, source files are first compiled and converted into .class files that contain Java bytecode, a highly optimized set of instructions, then a bytecode interpreter executes the bytecode, and later the JIT compiler translates the bytecode to machine code.\n\nJava bytecode can either be interpreted at runtime by a virtual machine, or compiled at load time or runtime into native code. Modern JVM implementations use the compilation approach, so after the initial startup time the performance is equivalent to native code.\n\n9. AOT Compilation\n\nAhead-of-time (AOT) compilation is the approach of compiling a higher-level programming language, or an intermediate representation such as Java bytecode, before the runtime.\n\nAn example of this is the Angular framework. This uses an ahead-of-time (AOT) compiler to transform HTML and TypeScript code into JavaScript code during the build time to provide a faster rendering later on the browser when the code is running.\n\n10. Assembler\n\nAn assembler translates human-readable assembly language into machine code. This compilation process is called assembly. The inverse program that converts machine code to assembly language is called a disassembler.\n\nAn assembly language (ASM) is a low-level programming language in which there is a dependence on the machine code instructions. That’s why every assembly language is designed for exactly one specific computer architecture.\n\nMore on Software DevelopmentWhat Is the Java Runtime Environment?\n\nWhy Compilers and Interpreters Are Important\n\nBoth compilers and interpreters are computer programs that convert a code written in a high-level language into a lower-level or machine code understood by computers. However, there are differences in how they work and when to use them."
    }
}