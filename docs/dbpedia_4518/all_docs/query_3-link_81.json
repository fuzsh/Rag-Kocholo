{
    "id": "dbpedia_4518_3",
    "rank": 81,
    "data": {
        "url": "https://www.techtarget.com/whatis/definition/Hamming-code",
        "read_more_link": "",
        "language": "en",
        "title": "What is Hamming code and how does it work?",
        "top_image": "https://cdn.ttgtmedia.com/ITKE/images/logos/TTlogo-379x201.png",
        "meta_img": "https://cdn.ttgtmedia.com/ITKE/images/logos/TTlogo-379x201.png",
        "images": [
            "https://cdn.ttgtmedia.com/rms/onlineimages/wright_gavin.jpg",
            "https://cdn.ttgtmedia.com/rms/onlineImages/GC5A444272_ram_mobile.jpg"
        ],
        "movies": [
            "https://www.youtube.com/embed/H_M--weEzpA?autoplay=0&modestbranding=1&rel=0&widget_referrer=https://www.techtarget.com/whatis/definition/Hamming-code&enablejsapi=1&origin=https://www.techtarget.com",
            "https://www.youtube.com/embed/fUGPQgO5pFM?autoplay=0&modestbranding=1&rel=0&widget_referrer=https://www.techtarget.com/whatis/definition/Hamming-code&enablejsapi=1&origin=https://www.techtarget.com"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Gavin Wright"
        ],
        "publish_date": "2022-07-11T09:00:00+00:00",
        "summary": "",
        "meta_description": "Learn about Hamming code, an error correction method to detect/correct errors to data when it's stored or transmitted. See how it works and when it works best.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "WhatIs",
        "canonical_link": "https://www.techtarget.com/whatis/definition/Hamming-code",
        "text": "What is Hamming code?\n\nHamming code is an error correction system that can detect and correct errors when data is stored or transmitted. It requires adding additional parity bits with the data. It is commonly used in error correction code (ECC) RAM. It's named after its inventor, Richard W. Hamming.\n\nWhenever data is transmitted or stored, it's possible that the data may become corrupted. This can take the form of bit flips, where a binary 1 becomes a 0 or vice versa. Error correcting codes seek to find when an error is introduced into some data. This is done by adding parity bits, or redundant information, to the data.\n\nIf enough parity data is added, it enables forward error correction (FEC), where errors can be automatically fixed when read back. FEC can increase the data transmission rate for noisy channels by reducing the amount of necessary retransmits.\n\nHamming code uses a block parity mechanism. The data is divided into blocks, and parity is added to the block. Hamming code can correct single-bit errors and detect the presence of two-bit errors in a data block.\n\nThe amount of parity data added to Hamming code is given by the formula 2p ≥ d + p + 1, where p is the number of parity bits and d is the number of data bits. For example, if you wanted to transmit 7 data bits, the formula would be 24 ≥ 7 + 4 + 1, so 4 parity bits are required.\n\nThe type of error correcting is given as the name of the algorithm, the total number of bits in the block and then the number of effective data bits. Therefore, Hamming encoding with 4 data bits and 3 parity bits for a total of 7 total bits is given as Hamming(7,4).\n\nStandard Hamming code can only detect and correct a single-bit error. If two bits are in error, it is possible that the two errors will look like a single-bit error. To account for that, an additional overall parity bit can be added to reliably detect errors in two bits. This is known as single error correction/double error detection (SECDED).\n\nHamming code history\n\nBefore Hamming code, there were several error correction methods in use that were not as efficient or effective. The simplest method involves adding a single parity bit. This can detect a single error but not detect two-bit errors nor correct the error. Another method was repeating each bit three times. This could detect and correct a single bit error but not errors in two bits. Repeating the bits was also very inefficient.\n\nRichard Hamming worked for Bell Labs in the 1940s and 1950s. During that time, computers used relays and read information from punched paper tape. These systems were often prone to errors relating to the paper tape being misread or relays getting stuck. If an operator was on hand when the error occurred, the program could be restarted; if the error occurred outside of working hours, the computer would skip the entire program, losing time and work.\n\nHamming reasoned that, if a computer can detect an error, it could also correct the error. So, he began working on an error correcting algorithm, and in 1950, he published the Hamming code.\n\nHamming code uses\n\nHamming code is used in situations where consistency is more important than efficiency of transmission. Its transmission efficiency goes up as the block size increases. In Hamming(7, 4), the effective data rate is only 0.571, while Hamming(255, 247) is 0.969.\n\nHamming code is relatively simple to use and can be implemented in hardware. This also means that it is fast to compute. These properties make it perfect for use in error correcting computer memory since it is possible for computer RAM to have an error or bit flip from radiation or cosmic rays striking the memory cell. ECC RAM uses Hamming code with SECDED to automatically correct single errors and raise an alarm on two errors.\n\nTo illustrate the value of ECC RAM, imagine a bank database server was recording a deposit of $100. As an 8-bit integer, that amount would be stored as the binary number 01100100. If a cosmic ray changed the first bit, it would change the deposit amount to $228, or 11100100. ECC memory would catch and correct this error automatically. In the rare case two bits became corrupted, the computer would assume that something was wrong with its hardware and cause a kernel panic or blue screen to protect the data integrity.\n\nHamming code is not used in modern data transmission. Wired data connections are generally not noisy enough to warrant the overhead of added parity data, and if an error is encountered, it may be faster to ask the sender to retransmit the faulty packet. Also, low-density parity-check (LDPC) codes are more efficient to transmit but require more computation than Hamming code. Since modern computers have more processing power available, LDPC is used for Wi-Fi 6 and 10GBASE-T Ethernet.\n\nOne area where Hamming code is used for data transmission is in satellite and space communication. Because of the great distances involved, long transmit times and the requirements for accurate data, it is preferred to use the slower but more precise Hamming code and sacrifice overall transmission rate.\n\nHamming code example and technical details\n\nGenerating and reading a Hamming code is simple and can be done on paper.\n\nThe general process to make a Hamming code is as follows. Note that all the following binary is given as big-endian numbers, where the most significant bit is on the left and least significant on the right:\n\nFind the total block length with both data bits and parity bits.\n\nNumber each bit with its binary value.\n\nEach value with only a single binary 1 and the remaining digits 0s (powers of 2) become parity bits. All other bits are data bits.\n\nEach parity bit covers all data bits that have the parity bit's value set to 1. Put another way, where the data bit value is AND checked to the parity bit value it is greater than one:\n\nFor example, parity bit 1 (001) covers data bit 3 (011), bit 5 (101) and bit 7 (111).\n\nParity bit 2 (010) covers data bit 3 (011), bit 6 (110) and bit 7 (111).\n\nParity bit 4 (100) covers data bit 5 (101), bit 6 (110) and bit 7 (111).\n\nSet the parity bit equal to 1 if all the values of its data bits are odd; set it to 0 if the total number is even.\n\nThis can be expressed as a chart. Note that each data bit is covered by more than one parity bit.\n\nPosition DEC\n\n7\n\n6\n\n5\n\n4\n\n3\n\n2\n\n1\n\nPosition BIN\n\n111\n\n110\n\n101\n\n100\n\n011\n\n010\n\n001\n\nData/Parity\n\nData 7\n\nData 6\n\nData 5\n\nParity 4\n\nData 3\n\nParity 2\n\nParity 1\n\nParity Bit Coverage\n\nP1\n\nx\n\nx\n\nx\n\nx\n\nP2\n\nx\n\nx\n\nx\n\nx\n\nP3\n\nx\n\nx\n\nx\n\nx\n\nAs an example, let's encode the decimal value 12 (binary 1100) in Hamming code.\n\nFirst, enter the binary values in the data positions.\n\nData/Parity\n\nData 7\n\nData 6\n\nData 5\n\nParity 4\n\nData 3\n\nParity 2\n\nParity 1\n\n1\n\n1\n\n0\n\nx\n\n0\n\nx\n\nx\n\nNext, compute the parity values by checking if the sum of the protected bits is even or odd:\n\nData 7, 5 and 3 added equals 01, an odd number. So, set parity 1 to 1.\n\nData 7, 6 and 3 added equals 10, an even number. So, set parity 2 to 0.\n\nData 7, 6 and 5 added equals 10, an even number. So, set parity 4 to 0.\n\nThe results are the following:\n\nData/Parity\n\nData 7\n\nData 6\n\nData 5\n\nParity 4\n\nData 3\n\nParity 2\n\nParity 1\n\n1\n\n1\n\n0\n\n0\n\n0\n\n0\n\n1\n\nThe parity bits are checked against the data bits on the receive side to validate that none of them have been changed.\n\nSuppose that data bit 6 was flipped. In that case, parity 2 and 4 would not be correct. The decoder would see that means that data 6 was in error and correct it.\n\nSuppose parity bit 2 was in error. Since none of the other parity bits would be wrong, it would know that only the parity was wrong and ignore it.\n\nHamming code can thereby detect and correct any single-bit error. If two data bits were flipped, it could detect it but not correct the error. Because the parity bits themselves do not have any parity data stored, if a data bit and a parity bit were flipped, it would be indistinguishable from a single-bit flip. Therefore, an additional overall parity bit is often added to reliably detect errors with 2 bits.\n\nSee also: forward error correction, modem error-correcting protocols, SPI NAND host-side error correction, encoding and decoding, most significant bit or byte, classical computing and Extended Binary Coded Decimal Interchange Code."
    }
}