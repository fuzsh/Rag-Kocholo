{
    "id": "dbpedia_4518_1",
    "rank": 90,
    "data": {
        "url": "https://www.cs.cornell.edu/~tomf/notes/cps104/twoscomp.html",
        "read_more_link": "",
        "language": "en",
        "title": "Two's Complement",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Thomas Finley, April 2000\n\nContents and Introduction\n\nContents and Introduction Conversion from Two's Complement Conversion to Two's Complement Arithmetic with Two's Complement Why Inversion and Adding One Works\n\nTwo's complement is not a complicated scheme and is not well served by anything lengthly. Therefore, after this introduction, which explains what two's complement is and how to use it, there are mostly examples.\n\nTwo's complement is the way every computer I know of chooses to represent integers. To get the two's complement negative notation of an integer, you write out the number in binary. You then invert the digits, and add one to the result.\n\nSuppose we're working with 8 bit quantities (for simplicity's sake) and suppose we want to find how -28 would be expressed in two's complement notation. First we write out 28 in binary form.\n\n00011100\n\nThen we invert the digits. 0 becomes 1, 1 becomes 0.\n\n11100011\n\nThen we add 1.\n\n11100100\n\nThat is how one would write -28 in 8 bit binary.\n\nConversion from Two's Complement\n\nUse the number 0xFFFFFFFF as an example. In binary, that is:\n\n1111 1111 1111 1111 1111 1111 1111 1111\n\nWhat can we say about this number? It's first (leftmost) bit is 1, which means that this represents a number that is negative. That's just the way that things are in two's complement: a leading 1 means the number is negative, a leading 0 means the number is 0 or positive.\n\nTo see what this number is a negative of, we reverse the sign of this number. But how to do that? The class notes say (on 3.17) that to reverse the sign you simply invert the bits (0 goes to 1, and 1 to 0) and add one to the resulting number.\n\nThe inversion of that binary number is, obviously:\n\n0000 0000 0000 0000 0000 0000 0000 0000\n\nThen we add one.\n\n0000 0000 0000 0000 0000 0000 0000 0001\n\nSo the negative of 0xFFFFFFFF is 0x00000001, more commonly known as 1. So 0xFFFFFFFF is -1.\n\nConversion to Two's Complement\n\nNote that this works both ways. If you have -30, and want to represent it in 2's complement, you take the binary representation of 30:\n\n0000 0000 0000 0000 0000 0000 0001 1110\n\nInvert the digits.\n\n1111 1111 1111 1111 1111 1111 1110 0001\n\nAnd add one.\n\n1111 1111 1111 1111 1111 1111 1110 0010\n\nConverted back into hex, this is 0xFFFFFFE2. And indeed, suppose you have this code:\n\n#include <stdio.h> int main() { int myInt; myInt = 0xFFFFFFE2; printf(\"%d\\n\",myInt); return 0; }\n\nThat should yield an output of -30. Try it out if you like.\n\nArithmetic with Two's Complement\n\nOne of the nice properties of two's complement is that addition and subtraction is made very simple. With a system like two's complement, the circuitry for addition and subtraction can be unified, whereas otherwise they would have to be treated as separate operations.\n\nIn the examples in this section, I do addition and subtraction in two's complement, but you'll notice that every time I do actual operations with binary numbers I am always adding.\n\nExample 1\n\nSuppose we want to add two numbers 69 and 12 together. If we're to use decimal, we see the sum is 81. But let's use binary instead, since that's what the computer uses.\n\n1 1\n\nCarry Row\n\n0000 0000 0000 0000 0000 0000 0100 0101\n\n(69)\n\n+ 0000 0000 0000 0000 0000 0000 0000 1100\n\n(12)\n\n0000 0000 0000 0000 0000 0000 0101 0001\n\n(81)\n\nExample 2\n\nNow suppose we want to subtract 12 from 69. Now, 69 - 12 = 69 + (-12). To get the negative of 12 we take its binary representation, invert, and add one.\n\n0000 0000 0000 0000 0000 0000 0000 1100\n\nInvert the digits.\n\n1111 1111 1111 1111 1111 1111 1111 0011\n\nAnd add one.\n\n1111 1111 1111 1111 1111 1111 1111 0100\n\nThe last is the binary representation for -12. As before, we'll add the two numbers together.\n\n1111 1111 1111 1111 1111 1111 1 1\n\nCarry Row\n\n0000 0000 0000 0000 0000 0000 0100 0101\n\n(69)\n\n+ 1111 1111 1111 1111 1111 1111 1111 0100\n\n(-12)\n\n0000 0000 0000 0000 0000 0000 0011 1001\n\n(57)\n\nWe result in 57, which is 69-12.\n\nExample 3\n\nLastly, we'll subtract 69 from 12. Similar to our operation in example 2, 12 - 69 = 12 + (-&nbsp69). The two's complement representation of 69 is the following. I assume you've had enough illustrations of inverting and adding one.\n\n1111 1111 1111 1111 1111 1111 1011 1011\n\nSo we add this number to 12.\n\n111\n\nCarry Row\n\n0000 0000 0000 0000 0000 0000 0000 1100\n\n(12)\n\n+ 1111 1111 1111 1111 1111 1111 1011 1011\n\n(-69)\n\n1111 1111 1111 1111 1111 1111 1100 0111\n\n(-57)\n\nThis results in 12 - 69 = -57, which is correct.\n\nWhy Inversion and Adding One Works\n\nInvert and add one. Invert and add one. It works, and you may want to know why. If you don't care, skip this, as it is hardly essential. This is only intended for those curious as to why that rather strange technique actually makes mathematical sense.\n\nInverting and adding one might sound like a stupid thing to do, but it's actually just a mathematical shortcut of a rather straightforward computation.\n\nBorrowing and Subtraction\n\nRemember the old trick we learned in first grade of \"borrowing one's\" from future ten's places to perform a subtraction? You may not, so I'll go over it. As an example, I'll do 93702 minus 58358.\n\n93702 - 58358 -------\n\nNow, then, what's the answer to this computation? We'll start at the least significant digit, and subtract term by term. We can't subtract 8 from 2, so we'll borrow a digit from the next most significant place (the tens place) to make it 12 minus 8. 12 minus 8 is 4, and we note a 1 digit above the ten's column to signify that we must remember to subtract by one on the next iteration.\n\n1 93702 - 58358 ------- 4\n\nThis next iteration is 0 minus 5, and minus 1, or 0 minus 6. Again, we can't do 0 minus 6, so we borrow from the next most significant figure once more to make that 10 minus 6, which is 4.\n\n11 93702 - 58358 ------- 44\n\nThis next iteration is 7 minus 3, and minus 1, or 7 minus 4. This is 3. We don't have to borrow this time.\n\n11 93702 - 58358 ------- 344\n\nThis next iteration is 3 minus 8. Again, we must borrow to make thi 13 minus 8, or 5.\n\n1 11 93702 - 58358 ------- 5344\n\nThis next iteration is 9 minus 5, and minus 1, or 9 minus 6. This is 3. We don't have to borrow this time.\n\n1 11 93702 - 58358 ------- 35344\n\nSo 93702 minus 58358 is 35344.\n\nBorrowing and it's Relevance to the Negative of a Number\n\nWhen you want to find the negative of a number, you take the number, and subtract it from zero. Now, suppose we're really stupid, like a computer, and instead of simply writing a negative sign in front of a number A when we subtract A from 0, we actually go through the steps of subtracting A from 0.\n\nTake the following idiotic computation of 0 minus 3:\n\nEt cetera, et cetera. We'd wind up with a number composed of a 7 in the one's digit, a 9 in every digit more significant than the 100's place.\n\nThe Same in Binary\n\nWe can do more or less the same thing with binary. In this example I use 8 bit binary numbers, but the principle is the same for both 8 bit binary numbers (chars) and 32 bit binary numbers (ints). I take the number 75 (in 8 bit binary that is 010010112) and subtract that from zero.\n\nSometimes I am in the position where I am subtracting 1 from zero, and also subtracting another borrowed 1 against it.\n\n00000000 - 01001011 ----------\n\n1 00000000 - 01001011 ---------- 1\n\n11 00000000 - 01001011 ---------- 01\n\n111 00000000 - 01001011 ---------- 101\n\n1111 00000000 - 01001011 ---------- 0101\n\n11111 00000000 - 01001011 ---------- 10101\n\n111111 00000000 - 01001011 ---------- 110101\n\n1111111 00000000 - 01001011 ---------- 0110101\n\n11111111 00000000 - 01001011 ---------- 10110101\n\nIf we wanted we could go further, but there would be no point. Inside of a computer the result of this computation would be assigned to an eight bit variable, so any bits beyond the eighth would be discarded.\n\nWith the fact that we'll simply disregard any extra digits in mind, what difference would it make to the end result to have subtracted 01001011 from 100000000 (a one bit followed by 8 zero bits) rather than 0? There is none. If we do that, we wind up with the same result:\n\n11111111 100000000 - 01001011 ---------- 010110101\n\nSo to find the negative of an n-bit number in a computer, subtract the number from 0 or subtract it from 2n. In binary, this power of two will be a one bit followed by n zero bits.\n\nIn the case of 8-bit numbers, it will answer just as well if we subtract our number from (1 + 11111111) rather than 100000000.\n\n1 + 11111111 - 01001011 ----------\n\nIn binary, when we subtract a number A from a number of all 1 bits, what we're doing is inverting the bits of A. So the subtract operation is the equivalent of inverting the bits of the number. Then, we add one.\n\nSo, to the computer, taking the negative of a number, that is, subtracting a number from 0, is the same as inverting the bits and adding one, which is where the trick comes from.\n\nThomas Finley 2000"
    }
}