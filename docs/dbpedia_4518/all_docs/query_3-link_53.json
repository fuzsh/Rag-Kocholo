{
    "id": "dbpedia_4518_3",
    "rank": 53,
    "data": {
        "url": "https://go.dev/ref/spec",
        "read_more_link": "",
        "language": "en",
        "title": "The Go Programming Language Specification",
        "top_image": "https://go.dev/doc/gopher/gopher5logo.jpg",
        "meta_img": "https://go.dev/doc/gopher/gopher5logo.jpg",
        "images": [
            "https://go.dev/images/go-logo-white.svg",
            "https://go.dev/images/logos/social/google-groups.svg",
            "https://go.dev/images/logos/social/github.svg",
            "https://go.dev/images/logos/social/twitter.svg",
            "https://go.dev/images/logos/social/reddit.svg",
            "https://go.dev/images/logos/social/slack.svg",
            "https://go.dev/images/logos/social/stack-overflow.svg",
            "https://go.dev/images/go-logo-blue.svg",
            "https://go.dev/images/logos/social/google-groups.svg",
            "https://go.dev/images/logos/social/github.svg",
            "https://go.dev/images/logos/social/twitter.svg",
            "https://go.dev/images/logos/social/reddit.svg",
            "https://go.dev/images/logos/social/slack.svg",
            "https://go.dev/images/logos/social/stack-overflow.svg",
            "https://go.dev/images/gophers/pilot-bust.svg",
            "https://go.dev/images/icons/brightness_6_gm_grey_24dp.svg",
            "https://go.dev/images/icons/brightness_2_gm_grey_24dp.svg",
            "https://go.dev/images/icons/light_mode_gm_grey_24dp.svg",
            "https://go.dev/images/google-white.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/images/favicon-gopher.png",
        "meta_site_name": "",
        "canonical_link": "https://go.dev/ref/spec",
        "text": "Language version go1.23 (June 13, 2024)\n\nIntroduction\n\nThis is the reference manual for the Go programming language. The pre-Go1.18 version, without generics, can be found here. For more information and other documents, see go.dev.\n\nGo is a general-purpose language designed with systems programming in mind. It is strongly typed and garbage-collected and has explicit support for concurrent programming. Programs are constructed from packages, whose properties allow efficient management of dependencies.\n\nThe syntax is compact and simple to parse, allowing for easy analysis by automatic tools such as integrated development environments.\n\nNotation\n\nThe syntax is specified using a variant of Extended Backus-Naur Form (EBNF):\n\nSyntax = { Production } . Production = production_name \"=\" [ Expression ] \".\" . Expression = Term { \"|\" Term } . Term = Factor { Factor } . Factor = production_name | token [ \"…\" token ] | Group | Option | Repetition . Group = \"(\" Expression \")\" . Option = \"[\" Expression \"]\" . Repetition = \"{\" Expression \"}\" .\n\nProductions are expressions constructed from terms and the following operators, in increasing precedence:\n\n| alternation () grouping [] option (0 or 1 times) {} repetition (0 to n times)\n\nLowercase production names are used to identify lexical (terminal) tokens. Non-terminals are in CamelCase. Lexical tokens are enclosed in double quotes \"\" or back quotes ``.\n\nThe form a … b represents the set of characters from a through b as alternatives. The horizontal ellipsis … is also used elsewhere in the spec to informally denote various enumerations or code snippets that are not further specified. The character … (as opposed to the three characters ...) is not a token of the Go language.\n\nA link of the form [Go 1.xx] indicates that a described language feature (or some aspect of it) was changed or added with language version 1.xx and thus requires at minimum that language version to build. For details, see the linked section in the appendix.\n\nSource code representation\n\nSource code is Unicode text encoded in UTF-8. The text is not canonicalized, so a single accented code point is distinct from the same character constructed from combining an accent and a letter; those are treated as two code points. For simplicity, this document will use the unqualified term character to refer to a Unicode code point in the source text.\n\nEach code point is distinct; for instance, uppercase and lowercase letters are different characters.\n\nImplementation restriction: For compatibility with other tools, a compiler may disallow the NUL character (U+0000) in the source text.\n\nImplementation restriction: For compatibility with other tools, a compiler may ignore a UTF-8-encoded byte order mark (U+FEFF) if it is the first Unicode code point in the source text. A byte order mark may be disallowed anywhere else in the source.\n\nCharacters\n\nThe following terms are used to denote specific Unicode character categories:\n\nnewline = /* the Unicode code point U+000A */ . unicode_char = /* an arbitrary Unicode code point except newline */ . unicode_letter = /* a Unicode code point categorized as \"Letter\" */ . unicode_digit = /* a Unicode code point categorized as \"Number, decimal digit\" */ .\n\nIn The Unicode Standard 8.0, Section 4.5 \"General Category\" defines a set of character categories. Go treats all characters in any of the Letter categories Lu, Ll, Lt, Lm, or Lo as Unicode letters, and those in the Number category Nd as Unicode digits.\n\nLetters and digits\n\nThe underscore character _ (U+005F) is considered a lowercase letter.\n\nletter = unicode_letter | \"_\" . decimal_digit = \"0\" … \"9\" . binary_digit = \"0\" | \"1\" . octal_digit = \"0\" … \"7\" . hex_digit = \"0\" … \"9\" | \"A\" … \"F\" | \"a\" … \"f\" .\n\nLexical elements\n\nComments serve as program documentation. There are two forms:\n\nLine comments start with the character sequence // and stop at the end of the line.\n\nGeneral comments start with the character sequence /* and stop with the first subsequent character sequence */.\n\nA comment cannot start inside a rune or string literal, or inside a comment. A general comment containing no newlines acts like a space. Any other comment acts like a newline.\n\nTokens\n\nTokens form the vocabulary of the Go language. There are four classes: identifiers, keywords, operators and punctuation, and literals. White space, formed from spaces (U+0020), horizontal tabs (U+0009), carriage returns (U+000D), and newlines (U+000A), is ignored except as it separates tokens that would otherwise combine into a single token. Also, a newline or end of file may trigger the insertion of a semicolon. While breaking the input into tokens, the next token is the longest sequence of characters that form a valid token.\n\nSemicolons\n\nThe formal syntax uses semicolons \";\" as terminators in a number of productions. Go programs may omit most of these semicolons using the following two rules:\n\nWhen the input is broken into tokens, a semicolon is automatically inserted into the token stream immediately after a line's final token if that token is\n\nan identifier\n\nan integer, floating-point, imaginary, rune, or string literal\n\none of the keywords break, continue, fallthrough, or return\n\none of the operators and punctuation ++, --, ), ], or }\n\nTo allow complex statements to occupy a single line, a semicolon may be omitted before a closing \")\" or \"}\".\n\nTo reflect idiomatic use, code examples in this document elide semicolons using these rules.\n\nIdentifiers\n\nIdentifiers name program entities such as variables and types. An identifier is a sequence of one or more letters and digits. The first character in an identifier must be a letter.\n\nidentifier = letter { letter | unicode_digit } .\n\na _x9 ThisVariableIsExported αβ\n\nSome identifiers are predeclared.\n\nKeywords\n\nThe following keywords are reserved and may not be used as identifiers.\n\nbreak default func interface select case defer go map struct chan else goto package switch const fallthrough if range type continue for import return var\n\nOperators and punctuation\n\nThe following character sequences represent operators (including assignment operators) and punctuation [Go 1.18]:\n\n+ & += &= && == != ( ) - | -= |= || < <= [ ] * ^ *= ^= <- > >= { } / << /= <<= ++ = := , ; % >> %= >>= -- ! ... . : &^ &^= ~\n\nInteger literals\n\nAn integer literal is a sequence of digits representing an integer constant. An optional prefix sets a non-decimal base: 0b or 0B for binary, 0, 0o, or 0O for octal, and 0x or 0X for hexadecimal [Go 1.13]. A single 0 is considered a decimal zero. In hexadecimal literals, letters a through f and A through F represent values 10 through 15.\n\nFor readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal's value.\n\nint_lit = decimal_lit | binary_lit | octal_lit | hex_lit . decimal_lit = \"0\" | ( \"1\" … \"9\" ) [ [ \"_\" ] decimal_digits ] . binary_lit = \"0\" ( \"b\" | \"B\" ) [ \"_\" ] binary_digits . octal_lit = \"0\" [ \"o\" | \"O\" ] [ \"_\" ] octal_digits . hex_lit = \"0\" ( \"x\" | \"X\" ) [ \"_\" ] hex_digits . decimal_digits = decimal_digit { [ \"_\" ] decimal_digit } . binary_digits = binary_digit { [ \"_\" ] binary_digit } . octal_digits = octal_digit { [ \"_\" ] octal_digit } . hex_digits = hex_digit { [ \"_\" ] hex_digit } .\n\n42 4_2 0600 0_600 0o600 0O600 // second character is capital letter 'O' 0xBadFace 0xBad_Face 0x_67_7a_2f_cc_40_c6 170141183460469231731687303715884105727 170_141183_460469_231731_687303_715884_105727 _42 // an identifier, not an integer literal 42_ // invalid: _ must separate successive digits 4__2 // invalid: only one _ at a time 0_xBadFace // invalid: _ must separate successive digits\n\nFloating-point literals\n\nA floating-point literal is a decimal or hexadecimal representation of a floating-point constant.\n\nA decimal floating-point literal consists of an integer part (decimal digits), a decimal point, a fractional part (decimal digits), and an exponent part (e or E followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; one of the decimal point or the exponent part may be elided. An exponent value exp scales the mantissa (integer and fractional part) by 10exp.\n\nA hexadecimal floating-point literal consists of a 0x or 0X prefix, an integer part (hexadecimal digits), a radix point, a fractional part (hexadecimal digits), and an exponent part (p or P followed by an optional sign and decimal digits). One of the integer part or the fractional part may be elided; the radix point may be elided as well, but the exponent part is required. (This syntax matches the one given in IEEE 754-2008 §5.12.3.) An exponent value exp scales the mantissa (integer and fractional part) by 2exp [Go 1.13].\n\nFor readability, an underscore character _ may appear after a base prefix or between successive digits; such underscores do not change the literal value.\n\nfloat_lit = decimal_float_lit | hex_float_lit . decimal_float_lit = decimal_digits \".\" [ decimal_digits ] [ decimal_exponent ] | decimal_digits decimal_exponent | \".\" decimal_digits [ decimal_exponent ] . decimal_exponent = ( \"e\" | \"E\" ) [ \"+\" | \"-\" ] decimal_digits . hex_float_lit = \"0\" ( \"x\" | \"X\" ) hex_mantissa hex_exponent . hex_mantissa = [ \"_\" ] hex_digits \".\" [ hex_digits ] | [ \"_\" ] hex_digits | \".\" hex_digits . hex_exponent = ( \"p\" | \"P\" ) [ \"+\" | \"-\" ] decimal_digits .\n\n0. 72.40 072.40 // == 72.40 2.71828 1.e+0 6.67428e-11 1E6 .25 .12345E+5 1_5. // == 15.0 0.15e+0_2 // == 15.0 0x1p-2 // == 0.25 0x2.p10 // == 2048.0 0x1.Fp+0 // == 1.9375 0X.8p-0 // == 0.5 0X_1FFFP-16 // == 0.1249847412109375 0x15e-2 // == 0x15e - 2 (integer subtraction) 0x.p1 // invalid: mantissa has no digits 1p-2 // invalid: p exponent requires hexadecimal mantissa 0x1.5e-2 // invalid: hexadecimal mantissa requires p exponent 1_.5 // invalid: _ must separate successive digits 1._5 // invalid: _ must separate successive digits 1.5_e1 // invalid: _ must separate successive digits 1.5e_1 // invalid: _ must separate successive digits 1.5e1_ // invalid: _ must separate successive digits\n\nImaginary literals\n\nAn imaginary literal represents the imaginary part of a complex constant. It consists of an integer or floating-point literal followed by the lowercase letter i. The value of an imaginary literal is the value of the respective integer or floating-point literal multiplied by the imaginary unit i [Go 1.13]\n\nimaginary_lit = (decimal_digits | int_lit | float_lit) \"i\" .\n\nFor backward compatibility, an imaginary literal's integer part consisting entirely of decimal digits (and possibly underscores) is considered a decimal integer, even if it starts with a leading 0.\n\n0i 0123i // == 123i for backward-compatibility 0o123i // == 0o123 * 1i == 83i 0xabci // == 0xabc * 1i == 2748i 0.i 2.71828i 1.e+0i 6.67428e-11i 1E6i .25i .12345E+5i 0x1p-2i // == 0x1p-2 * 1i == 0.25i\n\nRune literals\n\nA rune literal represents a rune constant, an integer value identifying a Unicode code point. A rune literal is expressed as one or more characters enclosed in single quotes, as in 'x' or '\\n'. Within the quotes, any character may appear except newline and unescaped single quote. A single quoted character represents the Unicode value of the character itself, while multi-character sequences beginning with a backslash encode values in various formats.\n\nThe simplest form represents the single character within the quotes; since Go source text is Unicode characters encoded in UTF-8, multiple UTF-8-encoded bytes may represent a single integer value. For instance, the literal 'a' holds a single byte representing a literal a, Unicode U+0061, value 0x61, while 'ä' holds two bytes (0xc3 0xa4) representing a literal a-dieresis, U+00E4, value 0xe4.\n\nSeveral backslash escapes allow arbitrary values to be encoded as ASCII text. There are four ways to represent the integer value as a numeric constant: \\x followed by exactly two hexadecimal digits; \\u followed by exactly four hexadecimal digits; \\U followed by exactly eight hexadecimal digits, and a plain backslash \\ followed by exactly three octal digits. In each case the value of the literal is the value represented by the digits in the corresponding base.\n\nAlthough these representations all result in an integer, they have different valid ranges. Octal escapes must represent a value between 0 and 255 inclusive. Hexadecimal escapes satisfy this condition by construction. The escapes \\u and \\U represent Unicode code points so within them some values are illegal, in particular those above 0x10FFFF and surrogate halves.\n\nAfter a backslash, certain single-character escapes represent special values:\n\n\\a U+0007 alert or bell \\b U+0008 backspace \\f U+000C form feed \\n U+000A line feed or newline \\r U+000D carriage return \\t U+0009 horizontal tab \\v U+000B vertical tab \\\\ U+005C backslash \\' U+0027 single quote (valid escape only within rune literals) \\\" U+0022 double quote (valid escape only within string literals)\n\nAn unrecognized character following a backslash in a rune literal is illegal.\n\nrune_lit = \"'\" ( unicode_value | byte_value ) \"'\" . unicode_value = unicode_char | little_u_value | big_u_value | escaped_char . byte_value = octal_byte_value | hex_byte_value . octal_byte_value = `\\` octal_digit octal_digit octal_digit . hex_byte_value = `\\` \"x\" hex_digit hex_digit . little_u_value = `\\` \"u\" hex_digit hex_digit hex_digit hex_digit . big_u_value = `\\` \"U\" hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit hex_digit . escaped_char = `\\` ( \"a\" | \"b\" | \"f\" | \"n\" | \"r\" | \"t\" | \"v\" | `\\` | \"'\" | `\"` ) .\n\n'a' 'ä' '本' '\\t' '\\000' '\\007' '\\377' '\\x07' '\\xff' '\\u12e4' '\\U00101234' '\\'' // rune literal containing single quote character 'aa' // illegal: too many characters '\\k' // illegal: k is not recognized after a backslash '\\xa' // illegal: too few hexadecimal digits '\\0' // illegal: too few octal digits '\\400' // illegal: octal value over 255 '\\uDFFF' // illegal: surrogate half '\\U00110000' // illegal: invalid Unicode code point\n\nString literals\n\nA string literal represents a string constant obtained from concatenating a sequence of characters. There are two forms: raw string literals and interpreted string literals.\n\nRaw string literals are character sequences between back quotes, as in `foo`. Within the quotes, any character may appear except back quote. The value of a raw string literal is the string composed of the uninterpreted (implicitly UTF-8-encoded) characters between the quotes; in particular, backslashes have no special meaning and the string may contain newlines. Carriage return characters ('\\r') inside raw string literals are discarded from the raw string value.\n\nInterpreted string literals are character sequences between double quotes, as in \"bar\". Within the quotes, any character may appear except newline and unescaped double quote. The text between the quotes forms the value of the literal, with backslash escapes interpreted as they are in rune literals (except that \\' is illegal and \\\" is legal), with the same restrictions. The three-digit octal (\\nnn) and two-digit hexadecimal (\\xnn) escapes represent individual bytes of the resulting string; all other escapes represent the (possibly multi-byte) UTF-8 encoding of individual characters. Thus inside a string literal \\377 and \\xFF represent a single byte of value 0xFF=255, while ÿ, \\u00FF, \\U000000FF and \\xc3\\xbf represent the two bytes 0xc3 0xbf of the UTF-8 encoding of character U+00FF.\n\nstring_lit = raw_string_lit | interpreted_string_lit . raw_string_lit = \"`\" { unicode_char | newline } \"`\" . interpreted_string_lit = `\"` { unicode_value | byte_value } `\"` .\n\n`abc` // same as \"abc\" `\\n \\n` // same as \"\\\\n\\n\\\\n\" \"\\n\" \"\\\"\" // same as `\"` \"Hello, world!\\n\" \"日本語\" \"\\u65e5本\\U00008a9e\" \"\\xff\\u00FF\" \"\\uD800\" // illegal: surrogate half \"\\U00110000\" // illegal: invalid Unicode code point\n\nThese examples all represent the same string:\n\n\"日本語\" // UTF-8 input text `日本語` // UTF-8 input text as a raw literal \"\\u65e5\\u672c\\u8a9e\" // the explicit Unicode code points \"\\U000065e5\\U0000672c\\U00008a9e\" // the explicit Unicode code points \"\\xe6\\x97\\xa5\\xe6\\x9c\\xac\\xe8\\xaa\\x9e\" // the explicit UTF-8 bytes\n\nIf the source code represents a character as two code points, such as a combining form involving an accent and a letter, the result will be an error if placed in a rune literal (it is not a single code point), and will appear as two code points if placed in a string literal.\n\nConstants\n\nThere are boolean constants, rune constants, integer constants, floating-point constants, complex constants, and string constants. Rune, integer, floating-point, and complex constants are collectively called numeric constants.\n\nA constant value is represented by a rune, integer, floating-point, imaginary, or string literal, an identifier denoting a constant, a constant expression, a conversion with a result that is a constant, or the result value of some built-in functions such as min or max applied to constant arguments, unsafe.Sizeof applied to certain values, cap or len applied to some expressions, real and imag applied to a complex constant and complex applied to numeric constants. The boolean truth values are represented by the predeclared constants true and false. The predeclared identifier iota denotes an integer constant.\n\nIn general, complex constants are a form of constant expression and are discussed in that section.\n\nNumeric constants represent exact values of arbitrary precision and do not overflow. Consequently, there are no constants denoting the IEEE 754 negative zero, infinity, and not-a-number values.\n\nConstants may be typed or untyped. Literal constants, true, false, iota, and certain constant expressions containing only untyped constant operands are untyped.\n\nA constant may be given a type explicitly by a constant declaration or conversion, or implicitly when used in a variable declaration or an assignment statement or as an operand in an expression. It is an error if the constant value cannot be represented as a value of the respective type. If the type is a type parameter, the constant is converted into a non-constant value of the type parameter.\n\nAn untyped constant has a default type which is the type to which the constant is implicitly converted in contexts where a typed value is required, for instance, in a short variable declaration such as i := 0 where there is no explicit type. The default type of an untyped constant is bool, rune, int, float64, complex128, or string respectively, depending on whether it is a boolean, rune, integer, floating-point, complex, or string constant.\n\nImplementation restriction: Although numeric constants have arbitrary precision in the language, a compiler may implement them using an internal representation with limited precision. That said, every implementation must:\n\nRepresent integer constants with at least 256 bits.\n\nRepresent floating-point constants, including the parts of a complex constant, with a mantissa of at least 256 bits and a signed binary exponent of at least 16 bits.\n\nGive an error if unable to represent an integer constant precisely.\n\nGive an error if unable to represent a floating-point or complex constant due to overflow.\n\nRound to the nearest representable constant if unable to represent a floating-point or complex constant due to limits on precision.\n\nThese requirements apply both to literal constants and to the result of evaluating constant expressions.\n\nVariables\n\nA variable is a storage location for holding a value. The set of permissible values is determined by the variable's type.\n\nA variable declaration or, for function parameters and results, the signature of a function declaration or function literal reserves storage for a named variable. Calling the built-in function new or taking the address of a composite literal allocates storage for a variable at run time. Such an anonymous variable is referred to via a (possibly implicit) pointer indirection.\n\nStructured variables of array, slice, and struct types have elements and fields that may be addressed individually. Each such element acts like a variable.\n\nThe static type (or just type) of a variable is the type given in its declaration, the type provided in the new call or composite literal, or the type of an element of a structured variable. Variables of interface type also have a distinct dynamic type, which is the (non-interface) type of the value assigned to the variable at run time (unless the value is the predeclared identifier nil, which has no type). The dynamic type may vary during execution but values stored in interface variables are always assignable to the static type of the variable.\n\nvar x interface{} // x is nil and has static type interface{} var v *T // v has value nil, static type *T x = 42 // x has value 42 and dynamic type int x = v // x has value (*T)(nil) and dynamic type *T\n\nA variable's value is retrieved by referring to the variable in an expression; it is the most recent value assigned to the variable. If a variable has not yet been assigned a value, its value is the zero value for its type.\n\nTypes\n\nA type determines a set of values together with operations and methods specific to those values. A type may be denoted by a type name, if it has one, which must be followed by type arguments if the type is generic. A type may also be specified using a type literal, which composes a type from existing types.\n\nType = TypeName [ TypeArgs ] | TypeLit | \"(\" Type \")\" . TypeName = identifier | QualifiedIdent . TypeArgs = \"[\" TypeList [ \",\" ] \"]\" . TypeList = Type { \",\" Type } . TypeLit = ArrayType | StructType | PointerType | FunctionType | InterfaceType | SliceType | MapType | ChannelType .\n\nThe language predeclares certain type names. Others are introduced with type declarations or type parameter lists. Composite types—array, struct, pointer, function, interface, slice, map, and channel types—may be constructed using type literals.\n\nPredeclared types, defined types, and type parameters are called named types. An alias denotes a named type if the type given in the alias declaration is a named type.\n\nBoolean types\n\nA boolean type represents the set of Boolean truth values denoted by the predeclared constants true and false. The predeclared boolean type is bool; it is a defined type.\n\nNumeric types\n\nAn integer, floating-point, or complex type represents the set of integer, floating-point, or complex values, respectively. They are collectively called numeric types. The predeclared architecture-independent numeric types are:\n\nuint8 the set of all unsigned 8-bit integers (0 to 255) uint16 the set of all unsigned 16-bit integers (0 to 65535) uint32 the set of all unsigned 32-bit integers (0 to 4294967295) uint64 the set of all unsigned 64-bit integers (0 to 18446744073709551615) int8 the set of all signed 8-bit integers (-128 to 127) int16 the set of all signed 16-bit integers (-32768 to 32767) int32 the set of all signed 32-bit integers (-2147483648 to 2147483647) int64 the set of all signed 64-bit integers (-9223372036854775808 to 9223372036854775807) float32 the set of all IEEE 754 32-bit floating-point numbers float64 the set of all IEEE 754 64-bit floating-point numbers complex64 the set of all complex numbers with float32 real and imaginary parts complex128 the set of all complex numbers with float64 real and imaginary parts byte alias for uint8 rune alias for int32\n\nThe value of an n-bit integer is n bits wide and represented using two's complement arithmetic.\n\nThere is also a set of predeclared integer types with implementation-specific sizes:\n\nuint either 32 or 64 bits int same size as uint uintptr an unsigned integer large enough to store the uninterpreted bits of a pointer value\n\nTo avoid portability issues all numeric types are defined types and thus distinct except byte, which is an alias for uint8, and rune, which is an alias for int32. Explicit conversions are required when different numeric types are mixed in an expression or assignment. For instance, int32 and int are not the same type even though they may have the same size on a particular architecture.\n\nString types\n\nA string type represents the set of string values. A string value is a (possibly empty) sequence of bytes. The number of bytes is called the length of the string and is never negative. Strings are immutable: once created, it is impossible to change the contents of a string. The predeclared string type is string; it is a defined type.\n\nThe length of a string s can be discovered using the built-in function len. The length is a compile-time constant if the string is a constant. A string's bytes can be accessed by integer indices 0 through len(s)-1. It is illegal to take the address of such an element; if s[i] is the i'th byte of a string, &s[i] is invalid.\n\nArray types\n\nAn array is a numbered sequence of elements of a single type, called the element type. The number of elements is called the length of the array and is never negative.\n\nArrayType = \"[\" ArrayLength \"]\" ElementType . ArrayLength = Expression . ElementType = Type .\n\nThe length is part of the array's type; it must evaluate to a non-negative constant representable by a value of type int. The length of array a can be discovered using the built-in function len. The elements can be addressed by integer indices 0 through len(a)-1. Array types are always one-dimensional but may be composed to form multi-dimensional types.\n\n[32]byte [2*N] struct { x, y int32 } [1000]*float64 [3][5]int [2][2][2]float64 // same as [2]([2]([2]float64))\n\nAn array type T may not have an element of type T, or of a type containing T as a component, directly or indirectly, if those containing types are only array or struct types.\n\n// invalid array types type ( T1 [10]T1 // element type of T1 is T1 T2 [10]struct{ f T2 } // T2 contains T2 as component of a struct T3 [10]T4 // T3 contains T3 as component of a struct in T4 T4 struct{ f T3 } // T4 contains T4 as component of array T3 in a struct ) // valid array types type ( T5 [10]*T5 // T5 contains T5 as component of a pointer T6 [10]func() T6 // T6 contains T6 as component of a function type T7 [10]struct{ f []T7 } // T7 contains T7 as component of a slice in a struct )\n\nSlice types\n\nA slice is a descriptor for a contiguous segment of an underlying array and provides access to a numbered sequence of elements from that array. A slice type denotes the set of all slices of arrays of its element type. The number of elements is called the length of the slice and is never negative. The value of an uninitialized slice is nil.\n\nSliceType = \"[\" \"]\" ElementType .\n\nThe length of a slice s can be discovered by the built-in function len; unlike with arrays it may change during execution. The elements can be addressed by integer indices 0 through len(s)-1. The slice index of a given element may be less than the index of the same element in the underlying array.\n\nA slice, once initialized, is always associated with an underlying array that holds its elements. A slice therefore shares storage with its array and with other slices of the same array; by contrast, distinct arrays always represent distinct storage.\n\nThe array underlying a slice may extend past the end of the slice. The capacity is a measure of that extent: it is the sum of the length of the slice and the length of the array beyond the slice; a slice of length up to that capacity can be created by slicing a new one from the original slice. The capacity of a slice a can be discovered using the built-in function cap(a).\n\nA new, initialized slice value for a given element type T may be made using the built-in function make, which takes a slice type and parameters specifying the length and optionally the capacity. A slice created with make always allocates a new, hidden array to which the returned slice value refers. That is, executing\n\nmake([]T, length, capacity)\n\nproduces the same slice as allocating an array and slicing it, so these two expressions are equivalent:\n\nmake([]int, 50, 100) new([100]int)[0:50]\n\nLike arrays, slices are always one-dimensional but may be composed to construct higher-dimensional objects. With arrays of arrays, the inner arrays are, by construction, always the same length; however with slices of slices (or arrays of slices), the inner lengths may vary dynamically. Moreover, the inner slices must be initialized individually.\n\nStruct types\n\nA struct is a sequence of named elements, called fields, each of which has a name and a type. Field names may be specified explicitly (IdentifierList) or implicitly (EmbeddedField). Within a struct, non-blank field names must be unique.\n\nStructType = \"struct\" \"{\" { FieldDecl \";\" } \"}\" . FieldDecl = (IdentifierList Type | EmbeddedField) [ Tag ] . EmbeddedField = [ \"*\" ] TypeName [ TypeArgs ] . Tag = string_lit .\n\n// An empty struct. struct {} // A struct with 6 fields. struct { x, y int u float32 _ float32 // padding A *[]int F func() }\n\nA field declared with a type but no explicit field name is called an embedded field. An embedded field must be specified as a type name T or as a pointer to a non-interface type name *T, and T itself may not be a pointer type. The unqualified type name acts as the field name.\n\n// A struct with four embedded fields of types T1, *T2, P.T3 and *P.T4 struct { T1 // field name is T1 *T2 // field name is T2 P.T3 // field name is T3 *P.T4 // field name is T4 x, y int // field names are x and y }\n\nThe following declaration is illegal because field names must be unique in a struct type:\n\nstruct { T // conflicts with embedded field *T and *P.T *T // conflicts with embedded field T and *P.T *P.T // conflicts with embedded field T and *T }\n\nA field or method f of an embedded field in a struct x is called promoted if x.f is a legal selector that denotes that field or method f.\n\nPromoted fields act like ordinary fields of a struct except that they cannot be used as field names in composite literals of the struct.\n\nGiven a struct type S and a named type T, promoted methods are included in the method set of the struct as follows:\n\nIf S contains an embedded field T, the method sets of S and *S both include promoted methods with receiver T. The method set of *S also includes promoted methods with receiver *T.\n\nIf S contains an embedded field *T, the method sets of S and *S both include promoted methods with receiver T or *T.\n\nA field declaration may be followed by an optional string literal tag, which becomes an attribute for all the fields in the corresponding field declaration. An empty tag string is equivalent to an absent tag. The tags are made visible through a reflection interface and take part in type identity for structs but are otherwise ignored.\n\nstruct { x, y float64 \"\" // an empty tag string is like an absent tag name string \"any string is permitted as a tag\" _ [4]byte \"ceci n'est pas un champ de structure\" } // A struct corresponding to a TimeStamp protocol buffer. // The tag strings define the protocol buffer field numbers; // they follow the convention outlined by the reflect package. struct { microsec uint64 `protobuf:\"1\"` serverIP6 uint64 `protobuf:\"2\"` }\n\nA struct type T may not contain a field of type T, or of a type containing T as a component, directly or indirectly, if those containing types are only array or struct types.\n\n// invalid struct types type ( T1 struct{ T1 } // T1 contains a field of T1 T2 struct{ f [10]T2 } // T2 contains T2 as component of an array T3 struct{ T4 } // T3 contains T3 as component of an array in struct T4 T4 struct{ f [10]T3 } // T4 contains T4 as component of struct T3 in an array ) // valid struct types type ( T5 struct{ f *T5 } // T5 contains T5 as component of a pointer T6 struct{ f func() T6 } // T6 contains T6 as component of a function type T7 struct{ f [10][]T7 } // T7 contains T7 as component of a slice in an array )\n\nPointer types\n\nA pointer type denotes the set of all pointers to variables of a given type, called the base type of the pointer. The value of an uninitialized pointer is nil.\n\nPointerType = \"*\" BaseType . BaseType = Type .\n\n*Point *[4]int\n\nFunction types\n\nA function type denotes the set of all functions with the same parameter and result types. The value of an uninitialized variable of function type is nil.\n\nFunctionType = \"func\" Signature . Signature = Parameters [ Result ] . Result = Parameters | Type . Parameters = \"(\" [ ParameterList [ \",\" ] ] \")\" . ParameterList = ParameterDecl { \",\" ParameterDecl } . ParameterDecl = [ IdentifierList ] [ \"...\" ] Type .\n\nWithin a list of parameters or results, the names (IdentifierList) must either all be present or all be absent. If present, each name stands for one item (parameter or result) of the specified type and all non-blank names in the signature must be unique. If absent, each type stands for one item of that type. Parameter and result lists are always parenthesized except that if there is exactly one unnamed result it may be written as an unparenthesized type.\n\nThe final incoming parameter in a function signature may have a type prefixed with .... A function with such a parameter is called variadic and may be invoked with zero or more arguments for that parameter.\n\nfunc() func(x int) int func(a, _ int, z float32) bool func(a, b int, z float32) (bool) func(prefix string, values ...int) func(a, b int, z float64, opt ...interface{}) (success bool) func(int, int, float64) (float64, *[]int) func(n int) func(p *T)\n\nInterface types\n\nAn interface type defines a type set. A variable of interface type can store a value of any type that is in the type set of the interface. Such a type is said to implement the interface. The value of an uninitialized variable of interface type is nil.\n\nInterfaceType = \"interface\" \"{\" { InterfaceElem \";\" } \"}\" . InterfaceElem = MethodElem | TypeElem . MethodElem = MethodName Signature . MethodName = identifier . TypeElem = TypeTerm { \"|\" TypeTerm } . TypeTerm = Type | UnderlyingType . UnderlyingType = \"~\" Type .\n\nAn interface type is specified by a list of interface elements. An interface element is either a method or a type element, where a type element is a union of one or more type terms. A type term is either a single type or a single underlying type.\n\nBasic interfaces\n\nIn its most basic form an interface specifies a (possibly empty) list of methods. The type set defined by such an interface is the set of types which implement all of those methods, and the corresponding method set consists exactly of the methods specified by the interface. Interfaces whose type sets can be defined entirely by a list of methods are called basic interfaces.\n\n// A simple File interface. interface { Read([]byte) (int, error) Write([]byte) (int, error) Close() error }\n\nThe name of each explicitly specified method must be unique and not blank.\n\ninterface { String() string String() string // illegal: String not unique _(x int) // illegal: method must have non-blank name }\n\nMore than one type may implement an interface. For instance, if two types S1 and S2 have the method set\n\nfunc (p T) Read(p []byte) (n int, err error) func (p T) Write(p []byte) (n int, err error) func (p T) Close() error\n\n(where T stands for either S1 or S2) then the File interface is implemented by both S1 and S2, regardless of what other methods S1 and S2 may have or share.\n\nEvery type that is a member of the type set of an interface implements that interface. Any given type may implement several distinct interfaces. For instance, all types implement the empty interface which stands for the set of all (non-interface) types:\n\ninterface{}\n\nFor convenience, the predeclared type any is an alias for the empty interface. [Go 1.18]\n\nSimilarly, consider this interface specification, which appears within a type declaration to define an interface called Locker:\n\ntype Locker interface { Lock() Unlock() }\n\nIf S1 and S2 also implement\n\nfunc (p T) Lock() { … } func (p T) Unlock() { … }\n\nthey implement the Locker interface as well as the File interface.\n\nEmbedded interfaces\n\nIn a slightly more general form an interface T may use a (possibly qualified) interface type name E as an interface element. This is called embedding interface E in T [Go 1.14]. The type set of T is the intersection of the type sets defined by T's explicitly declared methods and the type sets of T’s embedded interfaces. In other words, the type set of T is the set of all types that implement all the explicitly declared methods of T and also all the methods of E [Go 1.18].\n\ntype Reader interface { Read(p []byte) (n int, err error) Close() error } type Writer interface { Write(p []byte) (n int, err error) Close() error } // ReadWriter's methods are Read, Write, and Close. type ReadWriter interface { Reader // includes methods of Reader in ReadWriter's method set Writer // includes methods of Writer in ReadWriter's method set }\n\nWhen embedding interfaces, methods with the same names must have identical signatures.\n\ntype ReadCloser interface { Reader // includes methods of Reader in ReadCloser's method set Close() // illegal: signatures of Reader.Close and Close are different }\n\nGeneral interfaces\n\nIn their most general form, an interface element may also be an arbitrary type term T, or a term of the form ~T specifying the underlying type T, or a union of terms t1|t2|…|tn [Go 1.18]. Together with method specifications, these elements enable the precise definition of an interface's type set as follows:\n\nThe type set of the empty interface is the set of all non-interface types.\n\nThe type set of a non-empty interface is the intersection of the type sets of its interface elements.\n\nThe type set of a method specification is the set of all non-interface types whose method sets include that method.\n\nThe type set of a non-interface type term is the set consisting of just that type.\n\nThe type set of a term of the form ~T is the set of all types whose underlying type is T.\n\nThe type set of a union of terms t1|t2|…|tn is the union of the type sets of the terms.\n\nThe quantification \"the set of all non-interface types\" refers not just to all (non-interface) types declared in the program at hand, but all possible types in all possible programs, and hence is infinite. Similarly, given the set of all non-interface types that implement a particular method, the intersection of the method sets of those types will contain exactly that method, even if all types in the program at hand always pair that method with another method.\n\nBy construction, an interface's type set never contains an interface type.\n\n// An interface representing only the type int. interface { int } // An interface representing all types with underlying type int. interface { ~int } // An interface representing all types with underlying type int that implement the String method. interface { ~int String() string } // An interface representing an empty type set: there is no type that is both an int and a string. interface { int string }\n\nIn a term of the form ~T, the underlying type of T must be itself, and T cannot be an interface.\n\ntype MyInt int interface { ~[]byte // the underlying type of []byte is itself ~MyInt // illegal: the underlying type of MyInt is not MyInt ~error // illegal: error is an interface }\n\nUnion elements denote unions of type sets:\n\n// The Float interface represents all floating-point types // (including any named types whose underlying types are // either float32 or float64). type Float interface { ~float32 | ~float64 }\n\nThe type T in a term of the form T or ~T cannot be a type parameter, and the type sets of all non-interface terms must be pairwise disjoint (the pairwise intersection of the type sets must be empty). Given a type parameter P:\n\ninterface { P // illegal: P is a type parameter int | ~P // illegal: P is a type parameter ~int | MyInt // illegal: the type sets for ~int and MyInt are not disjoint (~int includes MyInt) float32 | Float // overlapping type sets but Float is an interface }\n\nImplementation restriction: A union (with more than one term) cannot contain the predeclared identifier comparable or interfaces that specify methods, or embed comparable or interfaces that specify methods.\n\nInterfaces that are not basic may only be used as type constraints, or as elements of other interfaces used as constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nvar x Float // illegal: Float is not a basic interface var x interface{} = Float(nil) // illegal type Floatish struct { f Float // illegal }\n\nAn interface type T may not embed a type element that is, contains, or embeds T, directly or indirectly.\n\n// illegal: Bad may not embed itself type Bad interface { Bad } // illegal: Bad1 may not embed itself using Bad2 type Bad1 interface { Bad2 } type Bad2 interface { Bad1 } // illegal: Bad3 may not embed a union containing Bad3 type Bad3 interface { ~int | ~string | Bad3 } // illegal: Bad4 may not embed an array containing Bad4 as element type type Bad4 interface { [10]Bad4 }\n\nImplementing an interface\n\nA type T implements an interface I if\n\nT is not an interface and is an element of the type set of I; or\n\nT is an interface and the type set of T is a subset of the type set of I.\n\nA value of type T implements an interface if T implements the interface.\n\nMap types\n\nA map is an unordered group of elements of one type, called the element type, indexed by a set of unique keys of another type, called the key type. The value of an uninitialized map is nil.\n\nMapType = \"map\" \"[\" KeyType \"]\" ElementType . KeyType = Type .\n\nThe comparison operators == and != must be fully defined for operands of the key type; thus the key type must not be a function, map, or slice. If the key type is an interface type, these comparison operators must be defined for the dynamic key values; failure will cause a run-time panic.\n\nmap[string]int map[*T]struct{ x, y float64 } map[string]interface{}\n\nThe number of map elements is called its length. For a map m, it can be discovered using the built-in function len and may change during execution. Elements may be added during execution using assignments and retrieved with index expressions; they may be removed with the delete and clear built-in function.\n\nA new, empty map value is made using the built-in function make, which takes the map type and an optional capacity hint as arguments:\n\nmake(map[string]int) make(map[string]int, 100)\n\nThe initial capacity does not bound its size: maps grow to accommodate the number of items stored in them, with the exception of nil maps. A nil map is equivalent to an empty map except that no elements may be added.\n\nChannel types\n\nA channel provides a mechanism for concurrently executing functions to communicate by sending and receiving values of a specified element type. The value of an uninitialized channel is nil.\n\nChannelType = ( \"chan\" | \"chan\" \"<-\" | \"<-\" \"chan\" ) ElementType .\n\nThe optional <- operator specifies the channel direction, send or receive. If a direction is given, the channel is directional, otherwise it is bidirectional. A channel may be constrained only to send or only to receive by assignment or explicit conversion.\n\nchan T // can be used to send and receive values of type T chan<- float64 // can only be used to send float64s <-chan int // can only be used to receive ints\n\nThe <- operator associates with the leftmost chan possible:\n\nchan<- chan int // same as chan<- (chan int) chan<- <-chan int // same as chan<- (<-chan int) <-chan <-chan int // same as <-chan (<-chan int) chan (<-chan int)\n\nA new, initialized channel value can be made using the built-in function make, which takes the channel type and an optional capacity as arguments:\n\nmake(chan int, 100)\n\nThe capacity, in number of elements, sets the size of the buffer in the channel. If the capacity is zero or absent, the channel is unbuffered and communication succeeds only when both a sender and receiver are ready. Otherwise, the channel is buffered and communication succeeds without blocking if the buffer is not full (sends) or not empty (receives). A nil channel is never ready for communication.\n\nA channel may be closed with the built-in function close. The multi-valued assignment form of the receive operator reports whether a received value was sent before the channel was closed.\n\nA single channel may be used in send statements, receive operations, and calls to the built-in functions cap and len by any number of goroutines without further synchronization. Channels act as first-in-first-out queues. For example, if one goroutine sends values on a channel and a second goroutine receives them, the values are received in the order sent.\n\nProperties of types and values\n\nUnderlying types\n\nEach type T has an underlying type: If T is one of the predeclared boolean, numeric, or string types, or a type literal, the corresponding underlying type is T itself. Otherwise, T's underlying type is the underlying type of the type to which T refers in its declaration. For a type parameter that is the underlying type of its type constraint, which is always an interface.\n\ntype ( A1 = string A2 = A1 ) type ( B1 string B2 B1 B3 []B1 B4 B3 ) func f[P any](x P) { … }\n\nThe underlying type of string, A1, A2, B1, and B2 is string. The underlying type of []B1, B3, and B4 is []B1. The underlying type of P is interface{}.\n\nCore types\n\nEach non-interface type T has a core type, which is the same as the underlying type of T.\n\nAn interface T has a core type if one of the following conditions is satisfied:\n\nThere is a single type U which is the underlying type of all types in the type set of T; or\n\nthe type set of T contains only channel types with identical element type E, and all directional channels have the same direction.\n\nNo other interfaces have a core type.\n\nThe core type of an interface is, depending on the condition that is satisfied, either:\n\nthe type U; or\n\nthe type chan E if T contains only bidirectional channels, or the type chan<- E or <-chan E depending on the direction of the directional channels present.\n\nBy definition, a core type is never a defined type, type parameter, or interface type.\n\nExamples of interfaces with core types:\n\ntype Celsius float32 type Kelvin float32 interface{ int } // int interface{ Celsius|Kelvin } // float32 interface{ ~chan int } // chan int interface{ ~chan int|~chan<- int } // chan<- int interface{ ~[]*data; String() string } // []*data\n\nExamples of interfaces without core types:\n\ninterface{} // no single underlying type interface{ Celsius|float64 } // no single underlying type interface{ chan int | chan<- string } // channels have different element types interface{ <-chan int | chan<- int } // directional channels have different directions\n\nSome operations (slice expressions, append and copy) rely on a slightly more loose form of core types which accept byte slices and strings. Specifically, if there are exactly two types, []byte and string, which are the underlying types of all types in the type set of interface T, the core type of T is called bytestring.\n\nExamples of interfaces with bytestring core types:\n\ninterface{ int } // int (same as ordinary core type) interface{ []byte | string } // bytestring interface{ ~[]byte | myString } // bytestring\n\nNote that bytestring is not a real type; it cannot be used to declare variables or compose other types. It exists solely to describe the behavior of some operations that read from a sequence of bytes, which may be a byte slice or a string.\n\nType identity\n\nTwo types are either identical or different.\n\nA named type is always different from any other type. Otherwise, two types are identical if their underlying type literals are structurally equivalent; that is, they have the same literal structure and corresponding components have identical types. In detail:\n\nTwo array types are identical if they have identical element types and the same array length.\n\nTwo slice types are identical if they have identical element types.\n\nTwo struct types are identical if they have the same sequence of fields, and if corresponding fields have the same names, and identical types, and identical tags. Non-exported field names from different packages are always different.\n\nTwo pointer types are identical if they have identical base types.\n\nTwo function types are identical if they have the same number of parameters and result values, corresponding parameter and result types are identical, and either both functions are variadic or neither is. Parameter and result names are not required to match.\n\nTwo interface types are identical if they define the same type set.\n\nTwo map types are identical if they have identical key and element types.\n\nTwo channel types are identical if they have identical element types and the same direction.\n\nTwo instantiated types are identical if their defined types and all type arguments are identical.\n\nGiven the declarations\n\ntype ( A0 = []string A1 = A0 A2 = struct{ a, b int } A3 = int A4 = func(A3, float64) *A0 A5 = func(x int, _ float64) *[]string B0 A0 B1 []string B2 struct{ a, b int } B3 struct{ a, c int } B4 func(int, float64) *B0 B5 func(x int, y float64) *A1 C0 = B0 D0[P1, P2 any] struct{ x P1; y P2 } E0 = D0[int, string] )\n\nthese types are identical:\n\nA0, A1, and []string A2 and struct{ a, b int } A3 and int A4, func(int, float64) *[]string, and A5 B0 and C0 D0[int, string] and E0 []int and []int struct{ a, b *B5 } and struct{ a, b *B5 } func(x int, y float64) *[]string, func(int, float64) (result *[]string), and A5\n\nB0 and B1 are different because they are new types created by distinct type definitions; func(int, float64) *B0 and func(x int, y float64) *[]string are different because B0 is different from []string; and P1 and P2 are different because they are different type parameters. D0[int, string] and struct{ x int; y string } are different because the former is an instantiated defined type while the latter is a type literal (but they are still assignable).\n\nAssignability\n\nA value x of type V is assignable to a variable of type T (\"x is assignable to T\") if one of the following conditions applies:\n\nV and T are identical.\n\nV and T have identical underlying types but are not type parameters and at least one of V or T is not a named type.\n\nV and T are channel types with identical element types, V is a bidirectional channel, and at least one of V or T is not a named type.\n\nT is an interface type, but not a type parameter, and x implements T.\n\nx is the predeclared identifier nil and T is a pointer, function, slice, map, channel, or interface type, but not a type parameter.\n\nx is an untyped constant representable by a value of type T.\n\nAdditionally, if x's type V or T are type parameters, x is assignable to a variable of type T if one of the following conditions applies:\n\nx is the predeclared identifier nil, T is a type parameter, and x is assignable to each type in T's type set.\n\nV is not a named type, T is a type parameter, and x is assignable to each type in T's type set.\n\nV is a type parameter and T is not a named type, and values of each type in V's type set are assignable to T.\n\nRepresentability\n\nA constant x is representable by a value of type T, where T is not a type parameter, if one of the following conditions applies:\n\nx is in the set of values determined by T.\n\nT is a floating-point type and x can be rounded to T's precision without overflow. Rounding uses IEEE 754 round-to-even rules but with an IEEE negative zero further simplified to an unsigned zero. Note that constant values never result in an IEEE negative zero, NaN, or infinity.\n\nT is a complex type, and x's components real(x) and imag(x) are representable by values of T's component type (float32 or float64).\n\nIf T is a type parameter, x is representable by a value of type T if x is representable by a value of each type in T's type set.\n\nx T x is representable by a value of T because 'a' byte 97 is in the set of byte values 97 rune rune is an alias for int32, and 97 is in the set of 32-bit integers \"foo\" string \"foo\" is in the set of string values 1024 int16 1024 is in the set of 16-bit integers 42.0 byte 42 is in the set of unsigned 8-bit integers 1e10 uint64 10000000000 is in the set of unsigned 64-bit integers 2.718281828459045 float32 2.718281828459045 rounds to 2.7182817 which is in the set of float32 values -1e-1000 float64 -1e-1000 rounds to IEEE -0.0 which is further simplified to 0.0 0i int 0 is an integer value (42 + 0i) float32 42.0 (with zero imaginary part) is in the set of float32 values\n\nx T x is not representable by a value of T because 0 bool 0 is not in the set of boolean values 'a' string 'a' is a rune, it is not in the set of string values 1024 byte 1024 is not in the set of unsigned 8-bit integers -1 uint16 -1 is not in the set of unsigned 16-bit integers 1.1 int 1.1 is not an integer value 42i float32 (0 + 42i) is not in the set of float32 values 1e1000 float64 1e1000 overflows to IEEE +Inf after rounding\n\nMethod sets\n\nThe method set of a type determines the methods that can be called on an operand of that type. Every type has a (possibly empty) method set associated with it:\n\nThe method set of a defined type T consists of all methods declared with receiver type T.\n\nThe method set of a pointer to a defined type T (where T is neither a pointer nor an interface) is the set of all methods declared with receiver *T or T.\n\nThe method set of an interface type is the intersection of the method sets of each type in the interface's type set (the resulting method set is usually just the set of declared methods in the interface).\n\nFurther rules apply to structs (and pointer to structs) containing embedded fields, as described in the section on struct types. Any other type has an empty method set.\n\nIn a method set, each method must have a unique non-blank method name.\n\nBlocks\n\nA block is a possibly empty sequence of declarations and statements within matching brace brackets.\n\nBlock = \"{\" StatementList \"}\" . StatementList = { Statement \";\" } .\n\nIn addition to explicit blocks in the source code, there are implicit blocks:\n\nThe universe block encompasses all Go source text.\n\nEach package has a package block containing all Go source text for that package.\n\nEach file has a file block containing all Go source text in that file.\n\nEach \"if\", \"for\", and \"switch\" statement is considered to be in its own implicit block.\n\nEach clause in a \"switch\" or \"select\" statement acts as an implicit block.\n\nBlocks nest and influence scoping.\n\nDeclarations and scope\n\nA declaration binds a non-blank identifier to a constant, type, type parameter, variable, function, label, or package. Every identifier in a program must be declared. No identifier may be declared twice in the same block, and no identifier may be declared in both the file and package block.\n\nThe blank identifier may be used like any other identifier in a declaration, but it does not introduce a binding and thus is not declared. In the package block, the identifier init may only be used for init function declarations, and like the blank identifier it does not introduce a new binding.\n\nDeclaration = ConstDecl | TypeDecl | VarDecl . TopLevelDecl = Declaration | FunctionDecl | MethodDecl .\n\nThe scope of a declared identifier is the extent of source text in which the identifier denotes the specified constant, type, variable, function, label, or package.\n\nGo is lexically scoped using blocks:\n\nThe scope of a predeclared identifier is the universe block.\n\nThe scope of an identifier denoting a constant, type, variable, or function (but not method) declared at top level (outside any function) is the package block.\n\nThe scope of the package name of an imported package is the file block of the file containing the import declaration.\n\nThe scope of an identifier denoting a method receiver, function parameter, or result variable is the function body.\n\nThe scope of an identifier denoting a type parameter of a function or declared by a method receiver begins after the name of the function and ends at the end of the function body.\n\nThe scope of an identifier denoting a type parameter of a type begins after the name of the type and ends at the end of the TypeSpec.\n\nThe scope of a constant or variable identifier declared inside a function begins at the end of the ConstSpec or VarSpec (ShortVarDecl for short variable declarations) and ends at the end of the innermost containing block.\n\nThe scope of a type identifier declared inside a function begins at the identifier in the TypeSpec and ends at the end of the innermost containing block.\n\nAn identifier declared in a block may be redeclared in an inner block. While the identifier of the inner declaration is in scope, it denotes the entity declared by the inner declaration.\n\nThe package clause is not a declaration; the package name does not appear in any scope. Its purpose is to identify the files belonging to the same package and to specify the default package name for import declarations.\n\nLabel scopes\n\nLabels are declared by labeled statements and are used in the \"break\", \"continue\", and \"goto\" statements. It is illegal to define a label that is never used. In contrast to other identifiers, labels are not block scoped and do not conflict with identifiers that are not labels. The scope of a label is the body of the function in which it is declared and excludes the body of any nested function.\n\nBlank identifier\n\nThe blank identifier is represented by the underscore character _. It serves as an anonymous placeholder instead of a regular (non-blank) identifier and has special meaning in declarations, as an operand, and in assignment statements.\n\nPredeclared identifiers\n\nThe following identifiers are implicitly declared in the universe block [Go 1.18] [Go 1.21]:\n\nTypes: any bool byte comparable complex64 complex128 error float32 float64 int int8 int16 int32 int64 rune string uint uint8 uint16 uint32 uint64 uintptr Constants: true false iota Zero value: nil Functions: append cap clear close complex copy delete imag len make max min new panic print println real recover\n\nExported identifiers\n\nAn identifier may be exported to permit access to it from another package. An identifier is exported if both:\n\nthe first character of the identifier's name is a Unicode uppercase letter (Unicode character category Lu); and\n\nthe identifier is declared in the package block or it is a field name or method name.\n\nAll other identifiers are not exported.\n\nUniqueness of identifiers\n\nGiven a set of identifiers, an identifier is called unique if it is different from every other in the set. Two identifiers are different if they are spelled differently, or if they appear in different packages and are not exported. Otherwise, they are the same.\n\nConstant declarations\n\nA constant declaration binds a list of identifiers (the names of the constants) to the values of a list of constant expressions. The number of identifiers must be equal to the number of expressions, and the nth identifier on the left is bound to the value of the nth expression on the right.\n\nConstDecl = \"const\" ( ConstSpec | \"(\" { ConstSpec \";\" } \")\" ) . ConstSpec = IdentifierList [ [ Type ] \"=\" ExpressionList ] . IdentifierList = identifier { \",\" identifier } . ExpressionList = Expression { \",\" Expression } .\n\nIf the type is present, all constants take the type specified, and the expressions must be assignable to that type, which must not be a type parameter. If the type is omitted, the constants take the individual types of the corresponding expressions. If the expression values are untyped constants, the declared constants remain untyped and the constant identifiers denote the constant values. For instance, if the expression is a floating-point literal, the constant identifier denotes a floating-point constant, even if the literal's fractional part is zero.\n\nconst Pi float64 = 3.14159265358979323846 const zero = 0.0 // untyped floating-point constant const ( size int64 = 1024 eof = -1 // untyped integer constant ) const a, b, c = 3, 4, \"foo\" // a = 3, b = 4, c = \"foo\", untyped integer and string constants const u, v float32 = 0, 3 // u = 0.0, v = 3.0\n\nWithin a parenthesized const declaration list the expression list may be omitted from any but the first ConstSpec. Such an empty list is equivalent to the textual substitution of the first preceding non-empty expression list and its type if any. Omitting the list of expressions is therefore equivalent to repeating the previous list. The number of identifiers must be equal to the number of expressions in the previous list. Together with the iota constant generator this mechanism permits light-weight declaration of sequential values:\n\nconst ( Sunday = iota Monday Tuesday Wednesday Thursday Friday Partyday numberOfDays // this constant is not exported )\n\nIota\n\nWithin a constant declaration, the predeclared identifier iota represents successive untyped integer constants. Its value is the index of the respective ConstSpec in that constant declaration, starting at zero. It can be used to construct a set of related constants:\n\nconst ( c0 = iota // c0 == 0 c1 = iota // c1 == 1 c2 = iota // c2 == 2 ) const ( a = 1 << iota // a == 1 (iota == 0) b = 1 << iota // b == 2 (iota == 1) c = 3 // c == 3 (iota == 2, unused) d = 1 << iota // d == 8 (iota == 3) ) const ( u = iota * 42 // u == 0 (untyped integer constant) v float64 = iota * 42 // v == 42.0 (float64 constant) w = iota * 42 // w == 84 (untyped integer constant) ) const x = iota // x == 0 const y = iota // y == 0\n\nBy definition, multiple uses of iota in the same ConstSpec all have the same value:\n\nconst ( bit0, mask0 = 1 << iota, 1<<iota - 1 // bit0 == 1, mask0 == 0 (iota == 0) bit1, mask1 // bit1 == 2, mask1 == 1 (iota == 1) _, _ // (iota == 2, unused) bit3, mask3 // bit3 == 8, mask3 == 7 (iota == 3) )\n\nThis last example exploits the implicit repetition of the last non-empty expression list.\n\nType declarations\n\nA type declaration binds an identifier, the type name, to a type. Type declarations come in two forms: alias declarations and type definitions.\n\nTypeDecl = \"type\" ( TypeSpec | \"(\" { TypeSpec \";\" } \")\" ) . TypeSpec = AliasDecl | TypeDef .\n\nAlias declarations\n\nAn alias declaration binds an identifier to the given type [Go 1.9].\n\nAliasDecl = identifier \"=\" Type .\n\nWithin the scope of the identifier, it serves as an alias for the type.\n\ntype ( nodeList = []*Node // nodeList and []*Node are identical types Polar = polar // Polar and polar denote identical types )\n\nType definitions\n\nA type definition creates a new, distinct type with the same underlying type and operations as the given type and binds an identifier, the type name, to it.\n\nTypeDef = identifier [ TypeParameters ] Type .\n\nThe new type is called a defined type. It is different from any other type, including the type it is created from.\n\ntype ( Point struct{ x, y float64 } // Point and struct{ x, y float64 } are different types polar Point // polar and Point denote different types ) type TreeNode struct { left, right *TreeNode value any } type Block interface { BlockSize() int Encrypt(src, dst []byte) Decrypt(src, dst []byte) }\n\nA defined type may have methods associated with it. It does not inherit any methods bound to the given type, but the method set of an interface type or of elements of a composite type remains unchanged:\n\n// A Mutex is a data type with two methods, Lock and Unlock. type Mutex struct { /* Mutex fields */ } func (m *Mutex) Lock() { /* Lock implementation */ } func (m *Mutex) Unlock() { /* Unlock implementation */ } // NewMutex has the same composition as Mutex but its method set is empty. type NewMutex Mutex // The method set of PtrMutex's underlying type *Mutex remains unchanged, // but the method set of PtrMutex is empty. type PtrMutex *Mutex // The method set of *PrintableMutex contains the methods // Lock and Unlock bound to its embedded field Mutex. type PrintableMutex struct { Mutex } // MyBlock is an interface type that has the same method set as Block. type MyBlock Block\n\nType definitions may be used to define different boolean, numeric, or string types and associate methods with them:\n\ntype TimeZone int const ( EST TimeZone = -(5 + iota) CST MST PST ) func (tz TimeZone) String() string { return fmt.Sprintf(\"GMT%+dh\", tz) }\n\nIf the type definition specifies type parameters, the type name denotes a generic type. Generic types must be instantiated when they are used.\n\ntype List[T any] struct { next *List[T] value T }\n\nIn a type definition the given type cannot be a type parameter.\n\ntype T[P any] P // illegal: P is a type parameter func f[T any]() { type L T // illegal: T is a type parameter declared by the enclosing function }\n\nA generic type may also have methods associated with it. In this case, the method receivers must declare the same number of type parameters as present in the generic type definition.\n\n// The method Len returns the number of elements in the linked list l. func (l *List[T]) Len() int { … }\n\nType parameter declarations\n\nA type parameter list declares the type parameters of a generic function or type declaration. The type parameter list looks like an ordinary function parameter list except that the type parameter names must all be present and the list is enclosed in square brackets rather than parentheses [Go 1.18].\n\nTypeParameters = \"[\" TypeParamList [ \",\" ] \"]\" . TypeParamList = TypeParamDecl { \",\" TypeParamDecl } . TypeParamDecl = IdentifierList TypeConstraint .\n\nAll non-blank names in the list must be unique. Each name declares a type parameter, which is a new and different named type that acts as a placeholder for an (as of yet) unknown type in the declaration. The type parameter is replaced with a type argument upon instantiation of the generic function or type.\n\n[P any] [S interface{ ~[]byte|string }] [S ~[]E, E any] [P Constraint[int]] [_ any]\n\nJust as each ordinary function parameter has a parameter type, each type parameter has a corresponding (meta-)type which is called its type constraint.\n\nA parsing ambiguity arises when the type parameter list for a generic type declares a single type parameter P with a constraint C such that the text P C forms a valid expression:\n\ntype T[P *C] … type T[P (C)] … type T[P *C|Q] … …\n\nIn these rare cases, the type parameter list is indistinguishable from an expression and the type declaration is parsed as an array type declaration. To resolve the ambiguity, embed the constraint in an interface or use a trailing comma:\n\ntype T[P interface{*C}] … type T[P *C,] …\n\nType parameters may also be declared by the receiver specification of a method declaration associated with a generic type.\n\nWithin a type parameter list of a generic type T, a type constraint may not (directly, or indirectly through the type parameter list of another generic type) refer to T.\n\ntype T1[P T1[P]] … // illegal: T1 refers to itself type T2[P interface{ T2[int] }] … // illegal: T2 refers to itself type T3[P interface{ m(T3[int])}] … // illegal: T3 refers to itself type T4[P T5[P]] … // illegal: T4 refers to T5 and type T5[P T4[P]] … // T5 refers to T4 type T6[P int] struct{ f *T6[P] } // ok: reference to T6 is not in type parameter list\n\nType constraints\n\nA type constraint is an interface that defines the set of permissible type arguments for the respective type parameter and controls the operations supported by values of that type parameter [Go 1.18].\n\nTypeConstraint = TypeElem .\n\nIf the constraint is an interface literal of the form interface{E} where E is an embedded type element (not a method), in a type parameter list the enclosing interface{ … } may be omitted for convenience:\n\n[T []P] // = [T interface{[]P}] [T ~int] // = [T interface{~int}] [T int|string] // = [T interface{int|string}] type Constraint ~int // illegal: ~int is not in a type parameter list\n\nThe predeclared interface type comparable denotes the set of all non-interface types that are strictly comparable [Go 1.18].\n\nEven though interfaces that are not type parameters are comparable, they are not strictly comparable and therefore they do not implement comparable. However, they satisfy comparable.\n\nint // implements comparable (int is strictly comparable) []byte // does not implement comparable (slices cannot be compared) interface{} // does not implement comparable (see above) interface{ ~int | ~string } // type parameter only: implements comparable (int, string types are strictly comparable) interface{ comparable } // type parameter only: implements comparable (comparable implements itself) interface{ ~int | ~[]byte } // type parameter only: does not implement comparable (slices are not comparable) interface{ ~struct{ any } } // type parameter only: does not implement comparable (field any is not strictly comparable)\n\nThe comparable interface and interfaces that (directly or indirectly) embed comparable may only be used as type constraints. They cannot be the types of values or variables, or components of other, non-interface types.\n\nSatisfying a type constraint\n\nA type argument T satisfies a type constraint C if T is an element of the type set defined by C; i.e., if T implements C. As an exception, a strictly comparable type constraint may also be satisfied by a comparable (not necessarily strictly comparable) type argument [Go 1.20]. More precisely:\n\nA type T satisfies a constraint C if\n\nT implements C; or\n\nC can be written in the form interface{ comparable; E }, where E is a basic interface and T is comparable and implements E.\n\ntype argument type constraint // constraint satisfaction int interface{ ~int } // satisfied: int implements interface{ ~int } string comparable // satisfied: string implements comparable (string is strictly comparable) []byte comparable // not satisfied: slices are not comparable any interface{ comparable; int } // not satisfied: any does not implement interface{ int } any comparable // satisfied: any is comparable and implements the basic interface any struct{f any} comparable // satisfied: struct{f any} is comparable and implements the basic interface any any interface{ comparable; m() } // not satisfied: any does not implement the basic interface interface{ m() } interface{ m() } interface{ comparable; m() } // satisfied: interface{ m() } is comparable and implements the basic interface interface{ m() }\n\nBecause of the exception in the constraint satisfaction rule, comparing operands of type parameter type may panic at run-time (even though comparable type parameters are always strictly comparable).\n\nVariable declarations\n\nA variable declaration creates one or more variables, binds corresponding identifiers to them, and gives each a type and an initial value.\n\nVarDecl = \"var\" ( VarSpec | \"(\" { VarSpec \";\" } \")\" ) . VarSpec = IdentifierList ( Type [ \"=\" ExpressionList ] | \"=\" ExpressionList ) .\n\nvar i int var U, V, W float64 var k = 0 var x, y float32 = -1, -2 var ( i int u, v, s = 2.0, 3.0, \"bar\" ) var re, im = complexSqrt(-1) var _, found = entries[name] // map lookup; only interested in \"found\"\n\nIf a list of expressions is given, the variables are initialized with the expressions following the rules for assignment statements. Otherwise, each variable is initialized to its zero value.\n\nIf a type is present, each variable is given that type. Otherwise, each variable is given the type of the corresponding initialization value in the assignment. If that value is an untyped constant, it is first implicitly converted to its default type; if it is an untyped boolean value, it is first implicitly converted to type bool. The predeclared value nil cannot be used to initialize a variable with no explicit type.\n\nvar d = math.Sin(0.5) // d is float64 var i = 42 // i is int var t, ok = x.(T) // t is T, ok is bool var n = nil // illegal\n\nImplementation restriction: A compiler may make it illegal to declare a variable inside a function body if the variable is never used.\n\nShort variable declarations\n\nA short variable declaration uses the syntax:\n\nShortVarDecl = IdentifierList \":=\" ExpressionList .\n\nIt is shorthand for a regular variable declaration with initializer expressions but no types:\n\n\"var\" IdentifierList \"=\" ExpressionList .\n\ni, j := 0, 10 f := func() int { return 7 } ch := make(chan int) r, w, _ := os.Pipe() // os.Pipe() returns a connected pair of Files and an error, if any _, y, _ := coord(p) // coord() returns three values; only interested in y coordinate\n\nUnlike regular variable declarations, a short variable declaration may redeclare variables provided they were originally declared earlier in the same block (or the parameter lists if the block is the function body) with the same type, and at least one of the non-blank variables is new. As a consequence, redeclaration can only appear in a multi-variable short declaration. Redeclaration does not introduce a new variable; it just assigns a new value to the original. The non-blank variable names on the left side of := must be unique.\n\nfield1, offset := nextField(str, 0) field2, offset := nextField(str, offset) // redeclares offset x, y, x := 1, 2, 3 // illegal: x repeated on left side of :=\n\nShort variable declarations may appear only inside functions. In some contexts such as the initializers for \"if\", \"for\", or \"switch\" statements, they can be used to declare local temporary variables.\n\nFunction declarations\n\nA function declaration binds an identifier, the function name, to a function.\n\nFunctionDecl = \"func\" FunctionName [ TypeParameters ] Signature [ FunctionBody ] . FunctionName = identifier . FunctionBody = Block .\n\nIf the function's signature declares result parameters, the function body's statement list must end in a terminating statement.\n\nfunc IndexRune(s string, r rune) int { for i, c := range s { if c == r { return i } } // invalid: missing return statement }\n\nIf the function declaration specifies type parameters, the function name denotes a generic function. A generic function must be instantiated before it can be called or used as a value.\n\nfunc min[T ~int|~float64](x, y T) T { if x < y { return x } return y }\n\nA function declaration without type parameters may omit the body. Such a declaration provides the signature for a function implemented outside Go, such as an assembly routine.\n\nfunc flushICache(begin, end uintptr) // implemented externally\n\nMethod declarations\n\nA method is a function with a receiver. A method declaration binds an identifier, the method name, to a method, and associates the method with the receiver's base type.\n\nMethodDecl = \"func\" Receiver MethodName Signature [ FunctionBody ] . Receiver = Parameters .\n\nThe receiver is specified via an extra parameter section preceding the method name. That parameter section must declare a single non-variadic parameter, the receiver. Its type must be a defined type T or a pointer to a defined type T, possibly followed by a list of type parameter names [P1, P2, …] enclosed in square brackets. T is called the receiver base type. A receiver base type cannot be a pointer or interface type and it must be defined in the same package as the method. The method is said to be bound to its receiver base type and the method name is visible only within selectors for type T or *T.\n\nA non-blank receiver identifier must be unique in the method signature. If the receiver's value is not referenced inside the body of the method, its identifier may be omitted in the declaration. The same applies in general to parameters of functions and methods.\n\nFor a base type, the non-blank names of methods bound to it must be unique. If the base type is a struct type, the non-blank method and field names must be distinct.\n\nGiven defined type Point the declarations\n\nfunc (p *Point) Length() float64 { return math.Sqrt(p.x * p.x + p.y * p.y) } func (p *Point) Scale(factor float64) { p.x *= factor p.y *= factor }\n\nbind the methods Length and Scale, with receiver type *Point, to the base type Point.\n\nIf the receiver base type is a generic type, the receiver specification must declare corresponding type parameters for the method to use. This makes the receiver type parameters available to the method. Syntactically, this type parameter declaration looks like an instantiation of the receiver base type: the type arguments must be identifiers denoting the type parameters being declared, one for each type parameter of the receiver base type. The type parameter names do not need to match their corresponding parameter names in the receiver base type definition, and all non-blank parameter names must be unique in the receiver parameter section and the method signature. The receiver type parameter constraints are implied by the receiver base type definition: corresponding type parameters have corresponding constraints.\n\ntype Pair[A, B any] struct { a A b B } func (p Pair[A, B]) Swap() Pair[B, A] { … } // receiver declares A, B func (p Pair[First, _]) First() First { … } // receiver declares First, corresponds to A in Pair\n\nExpressions\n\nAn expression specifies the computation of a value by applying operators and functions to operands.\n\nOperands\n\nOperands denote the elementary values in an expression. An operand may be a literal, a (possibly qualified) non-blank identifier denoting a constant, variable, or function, or a parenthesized expression.\n\nOperand = Literal | OperandName [ TypeArgs ] | \"(\" Expression \")\" . Literal = BasicLit | CompositeLit | FunctionLit . BasicLit = int_lit | float_lit | imaginary_lit | rune_lit | string_lit . OperandName = identifier | QualifiedIdent .\n\nAn operand name denoting a generic function may be followed by a list of type arguments; the resulting operand is an instantiated function.\n\nThe blank identifier may appear as an operand only on the left-hand side of an assignment statement.\n\nImplementation restriction: A compiler need not report an error if an operand's type is a type parameter with an empty type set. Functions with such type parameters cannot be instantiated; any attempt will lead to an error at the instantiation site.\n\nQualified identifiers\n\nA qualified identifier is an identifier qualified with a package name prefix. Both the package name and the identifier must not be blank.\n\nQualifiedIdent = PackageName \".\" identifier .\n\nA qualified identifier accesses an identifier in a different package, which must be imported. The identifier must be exported and declared in the package block of that package.\n\nmath.Sin // denotes the Sin function in package math\n\nComposite literals\n\nComposite literals construct new composite values each time they are evaluated. They consist of the type of the literal followed by a brace-bound list of elements. Each element may optionally be preceded by a corresponding key.\n\nCompositeLit = LiteralType LiteralValue . LiteralType = StructType | ArrayType | \"[\" \"...\" \"]\" ElementType | SliceType | MapType | TypeName [ TypeArgs ] . LiteralValue = \"{\" [ ElementList [ \",\" ] ] \"}\" . ElementList = KeyedElement { \",\" KeyedElement } . KeyedElement = [ Key \":\" ] Element . Key = FieldName | Expression | LiteralValue . FieldName = identifier . Element = Expression | LiteralValue .\n\nThe LiteralType's core type T must be a struct, array, slice, or map type (the syntax enforces this constraint except when the type is given as a TypeName). The types of the elements and keys must be assignable to the respective field, element, and key types of type T; there is no additional conversion. The key is interpreted as a field name for struct literals, an index for array and slice literals, and a key for map literals. For map literals, all elements must have a key. It is an error to specify multiple elements with the same field name or constant key value. For non-constant map keys, see the section on evaluation order.\n\nFor struct literals the following rules apply:\n\nA key must be a field name declared in the struct type.\n\nAn element list that does not contain any keys must list an element for each struct field in the order in which the fields are declared.\n\nIf any element has a key, every element must have a key.\n\nAn element list that contains keys does not need to have an element for each struct field. Omitted fields get the zero value for that field.\n\nA literal may omit the element list; such a literal evaluates to the zero value for its type.\n\nIt is an error to specify an element for a non-exported field of a struct belonging to a different package.\n\nGiven the declarations\n\ntype Point3D struct { x, y, z float64 } type Line struct { p, q Point3D }\n\none may write\n\norigin := Point3D{} // zero value for Point3D line := Line{origin, Point3D{y: -4, z: 12.3}} // zero value for line.q.x\n\nFor array and slice literals the following rules apply:\n\nEach element has an associated integer index marking its position in the array.\n\nAn element with a key uses the key as its index. The key must be a non-negative constant representable by a value of type int; and if it is typed it must be of integer type.\n\nAn element without a key uses the previous element's index plus one. If the first element has no key, its index is zero.\n\nTaking the address of a composite literal generates a pointer to a unique variable initialized with the literal's value.\n\nvar pointer *Point3D = &Point3D{y: 1000}\n\nNote that the zero value for a slice or map type is not the same as an initialized but empty value of the same type. Consequently, taking the address of an empty slice or map composite literal does not have the same effect as allocating a new slice or map value with new.\n\np1 := &[]int{} // p1 points to an initialized, empty slice with value []int{} and length 0 p2 := new([]int) // p2 points to an uninitialized slice with value nil and length 0\n\nThe length of an array literal is the length specified in the literal type. If fewer elements than the length are provided in the literal, the missing elements are set to the zero value for the array element type. It is an error to provide elements with index values outside the index range of the array. The notation ... specifies an array length equal to the maximum element index plus one.\n\nbuffer := [10]string{} // len(buffer) == 10 intSet := [6]int{1, 2, 3, 5} // len(intSet) == 6 days := [...]string{\"Sat\", \"Sun\"} // len(days) == 2\n\nA slice literal describes the entire underlying array literal. Thus the length and capacity of a slice literal are the maximum element index plus one. A slice literal has the form\n\n[]T{x1, x2, … xn}\n\nand is shorthand for a slice operation applied to an array:\n\ntmp := [n]T{x1, x2, … xn} tmp[0 : n]\n\nWithin a composite literal of array, slice, or map type T, elements or map keys that are themselves composite literals may elide the respective literal type if it is identical to the element or key type of T. Similarly, elements or keys that are addresses of composite literals may elide the &T when the element or key type is *T.\n\n[...]Point{{1.5, -3.5}, {0, 0}} // same as [...]Point{Point{1.5, -3.5}, Point{0, 0}} [][]int{{1, 2, 3}, {4, 5}} // same as [][]int{[]int{1, 2, 3}, []int{4, 5}} [][]Point{{{0, 1}, {1, 2}}} // same as [][]Point{[]Point{Point{0, 1}, Point{1, 2}}} map[string]Point{\"orig\": {0, 0}} // same as map[string]Point{\"orig\": Point{0, 0}} map[Point]string{{0, 0}: \"orig\"} // same as map[Point]string{Point{0, 0}: \"orig\"} type PPoint *Point [2]*Point{{1.5, -3.5}, {}} // same as [2]*Point{&Point{1.5, -3.5}, &Point{}} [2]PPoint{{1.5, -3.5}, {}} // same as [2]PPoint{PPoint(&Point{1.5, -3.5}), PPoint(&Point{})}\n\nA parsing ambiguity arises when a composite literal using the TypeName form of the LiteralType appears as an operand between the keyword and the opening brace of the block of an \"if\", \"for\", or \"switch\" statement, and the composite literal is not enclosed in parentheses, square brackets, or curly braces. In this rare case, the opening brace of the literal is erroneously parsed as the one introducing the block of statements. To resolve the ambiguity, the composite literal must appear within parentheses.\n\nif x == (T{a,b,c}[i]) { … } if (x == T{a,b,c}[i]) { … }\n\nExamples of valid array, slice, and map literals:\n\n// list of prime numbers primes := []int{2, 3, 5, 7, 9, 2147483647} // vowels[ch] is true if ch is a vowel vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true} // the array [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1} filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1} // frequencies in Hz for equal-tempered scale (A4 = 440Hz) noteFrequency := map[string]float32{ \"C0\": 16.35, \"D0\": 18.35, \"E0\": 20.60, \"F0\": 21.83, \"G0\": 24.50, \"A0\": 27.50, \"B0\": 30.87, }\n\nFunction literals\n\nA function literal represents an anonymous function. Function literals cannot declare type parameters.\n\nFunctionLit = \"func\" Signature FunctionBody .\n\nfunc(a, b int, z float64) bool { return a*b < int(z) }\n\nA function literal can be assigned to a variable or invoked directly.\n\nf := func(x, y int) int { return x + y } func(ch chan int) { ch <- ACK }(replyChan)\n\nFunction literals are closures: they may refer to variables defined in a surrounding function. Those variables are then shared between the surrounding function and the function literal, and they survive as long as they are accessible.\n\nPrimary expressions\n\nPrimary expressions are the operands for unary and binary expressions.\n\nPrimaryExpr = Operand | Conversion | MethodExpr | PrimaryExpr Selector | PrimaryExpr Index | PrimaryExpr Slice | PrimaryExpr TypeAssertion | PrimaryExpr Arguments . Selector = \".\" identifier . Index = \"[\" Expression [ \",\" ] \"]\" . Slice = \"[\" [ Expression ] \":\" [ Expression ] \"]\" | \"[\" [ Expression ] \":\" Expression \":\" Expression \"]\" . TypeAssertion = \".\" \"(\" Type \")\" . Arguments = \"(\" [ ( ExpressionList | Type [ \",\" ExpressionList ] ) [ \"...\" ] [ \",\" ] ] \")\" .\n\nx 2 (s + \".txt\") f(3.1415, true) Point{1, 2} m[\"foo\"] s[i : j + 1] obj.color f.p[i].x()\n\nSelectors\n\nFor a primary expression x that is not a package name, the selector expression\n\nx.f\n\ndenotes the field or method f of the value x (or sometimes *x; see below). The identifier f is called the (field or method) selector; it must not be the blank identifier. The type of the selector expression is the type of f. If x is a package name, see the section on qualified identifiers.\n\nA selector f may denote a field or method f of a type T, or it may refer to a field or method f of a nested embedded field of T. The number of embedded fields traversed to reach f is called its depth in T. The depth of a field or method f declared in T is zero. The depth of a field or method f declared in an embedded field A in T is the depth of f in A plus one.\n\nThe following rules apply to selectors:\n\nFor a value x of type T or *T where T is not a pointer or interface type, x.f denotes the field or method at the shallowest depth in T where there is such an f. If there is not exactly one f with shallowest depth, the selector expression is illegal.\n\nFor a value x of type I where I is an interface type, x.f denotes the actual method with name f of the dynamic value of x. If there is no method with name f in the method set of I, the selector expression is illegal.\n\nAs an exception, if the type of x is a defined pointer type and (*x).f is a valid selector expression denoting a field (but not a method), x.f is shorthand for (*x).f.\n\nIn all other cases, x.f is illegal.\n\nIf x is of pointer type and has the value nil and x.f denotes a struct field, assigning to or evaluating x.f causes a run-time panic.\n\nIf x is of interface type and has the value nil, calling or evaluating the method x.f causes a run-time panic.\n\nFor example, given the declarations:\n\ntype T0 struct { x int } func (*T0) M0() type T1 struct { y int } func (T1) M1() type T2 struct { z int T1 *T0 } func (*T2) M2() type Q *T2 var t T2 // with t.T0 != nil var p *T2 // with p != nil and (*p).T0 != nil var q Q = p\n\none may write:\n\nt.z // t.z t.y // t.T1.y t.x // (*t.T0).x p.z // (*p).z p.y // (*p).T1.y p.x // (*(*p).T0).x q.x // (*(*q).T0).x (*q).x is a valid field selector p.M0() // ((*p).T0).M0() M0 expects *T0 receiver p.M1() // ((*p).T1).M1() M1 expects T1 receiver p.M2() // p.M2() M2 expects *T2 receiver t.M2() // (&t).M2() M2 expects *T2 receiver, see section on Calls\n\nbut the following is invalid:\n\nq.M0() // (*q).M0 is valid but not a field selector\n\nMethod expressions\n\nIf M is in the method set of type T, T.M is a function that is callable as a regular function with the same arguments as M prefixed by an additional argument that is the receiver of the method.\n\nMethodExpr = ReceiverType \".\" MethodName . ReceiverType = Type .\n\nConsider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type *T.\n\ntype T struct { a int } func (tv T) Mv(a int) int { return 0 } // value receiver func (tp *T) Mp(f float32) float32 { return 1 } // pointer receiver var t T\n\nThe expression\n\nT.Mv\n\nyields a function equivalent to Mv but with an explicit receiver as its first argument; it has signature\n\nfunc(tv T, a int) int\n\nThat function may be called normally with an explicit receiver, so these five invocations are equivalent:\n\nt.Mv(7) T.Mv(t, 7) (T).Mv(t, 7) f1 := T.Mv; f1(t, 7) f2 := (T).Mv; f2(t, 7)\n\nSimilarly, the expression\n\n(*T).Mp\n\nyields a function value representing Mp with signature\n\nfunc(tp *T, f float32) float32\n\nFor a method with a value receiver, one can derive a function with an explicit pointer receiver, so\n\n(*T).Mv\n\nyields a function value representing Mv with signature\n\nfunc(tv *T, a int) int\n\nSuch a function indirects through the receiver to create a value to pass as the receiver to the underlying method; the method does not overwrite the value whose address is passed in the function call.\n\nThe final case, a value-receiver function for a pointer-receiver method, is illegal because pointer-receiver methods are not in the method set of the value type.\n\nFunction values derived from methods are called with function call syntax; the receiver is provided as the first argument to the call. That is, given f := T.Mv, f is invoked as f(t, 7) not t.f(7). To construct a function that binds the receiver, use a function literal or method value.\n\nIt is legal to derive a function value from a method of an interface type. The resulting function takes an explicit receiver of that interface type.\n\nMethod values\n\nIf the expression x has static type T and M is in the method set of type T, x.M is called a method value. The method value x.M is a function value that is callable with the same arguments as a method call of x.M. The expression x is evaluated and saved during the evaluation of the method value; the saved copy is then used as the receiver in any calls, which may be executed later.\n\ntype S struct { *T } type T int func (t T) M() { print(t) } t := new(T) s := S{T: t} f := t.M // receiver *t is evaluated and stored in f g := s.M // receiver *(s.T) is evaluated and stored in g *t = 42 // does not affect stored receivers in f and g\n\nThe type T may be an interface or non-interface type.\n\nAs in the discussion of method expressions above, consider a struct type T with two methods, Mv, whose receiver is of type T, and Mp, whose receiver is of type *T.\n\ntype T struct { a int } func (tv T) Mv(a int) int { return 0 } // value receiver func (tp *T) Mp(f float32) float32 { return 1 } // pointer receiver var t T var pt *T func makeT() T\n\nThe expression\n\nt.Mv\n\nyields a function value of type\n\nfunc(int) int\n\nThese two invocations are equivalent:\n\nt.Mv(7) f := t.Mv; f(7)\n\nSimilarly, the expression\n\npt.Mp\n\nyields a function value of type\n\nfunc(float32) float32\n\nAs with selectors, a reference to a non-interface method with a value receiver using a pointer will automatically dereference that pointer: pt.Mv is equivalent to (*pt).Mv.\n\nAs with method calls, a reference to a non-interface method with a pointer receiver using an addressable value will automatically take the address of that value: t.Mp is equivalent to (&t).Mp.\n\nf := t.Mv; f(7) // like t.Mv(7) f := pt.Mp; f(7) // like pt.Mp(7) f := pt.Mv; f(7) // like (*pt).Mv(7) f := t.Mp; f(7) // like (&t).Mp(7) f := makeT().Mp // invalid: result of makeT() is not addressable\n\nAlthough the examples above use non-interface types, it is also legal to create a method value from a value of interface type.\n\nvar i interface { M(int) } = myVal f := i.M; f(7) // like i.M(7)\n\nIndex expressions\n\nA primary expression of the form\n\na[x]\n\ndenotes the element of the array, pointer to array, slice, string or map a indexed by x. The value x is called the index or map key, respectively. The following rules apply:\n\nIf a is neither a map nor a type parameter:\n\nthe index x must be an untyped constant or its core type must be an integer\n\na constant index must be non-negative and representable by a value of type int\n\na constant index that is untyped is given type int\n\nthe index x is in range if 0 <= x < len(a), otherwise it is out of range\n\nFor a of array type A:\n\na constant index must be in range\n\nif x is out of range at run time, a run-time panic occurs\n\na[x] is the array element at index x and the type of a[x] is the element type of A\n\nFor a of pointer to array type:\n\na[x] is shorthand for (*a)[x]\n\nFor a of slice type S:\n\nif x is out of range at run time, a run-time panic occurs\n\na[x] is the slice element at index x and the type of a[x] is the element type of S\n\nFor a of string type:\n\na constant index must be in range if the string a is also constant\n\nif x is out of range at run time, a run-time panic occurs\n\na[x] is the non-constant byte value at index x and the type of a[x] is byte\n\na[x] may not be assigned to\n\nFor a of map type M:\n\nx's type must be assignable to the key type of M\n\nif the map contains an entry with key x, a[x] is the map element with key x and the type of a[x] is the element type of M\n\nif the map is nil or does not contain such an entry, a[x] is the zero value for the element type of M\n\nFor a of type parameter type P:\n\nThe index expression a[x] must be valid for values of all types in P's type set.\n\nThe element types of all types in P's type set must be identical. In this context, the element type of a string type is byte.\n\nIf there is a map type in the type set of P, all types in that type set must be map types, and the respective key types must be all identical.\n\na[x] is the array, slice, or string element at index x, or the map element with key x of the type argument that P is instantiated with, and the type of a[x] is the type of the (identical) element types.\n\na[x] may not be assigned to if P's type set includes string types.\n\nOtherwise a[x] is illegal.\n\nAn index expression on a map a of type map[K]V used in an assignment statement or initialization of the special form\n\nv, ok = a[x] v, ok := a[x] var v, ok = a[x]\n\nyields an additional untyped boolean value. The value of ok is true if the key x is present in the map, and false otherwise.\n\nAssigning to an element of a nil map causes a run-time panic.\n\nSlice expressions\n\nSlice expressions construct a substring or slice from a string, array, pointer to array, or slice. There are two variants: a simple form that specifies a low and high bound, and a full form that also specifies a bound on the capacity.\n\nSimple slice expressions\n\nThe primary expression\n\na[low : high]\n\nconstructs a substring or slice. The core type of a must be a string, array, pointer to array, slice, or a bytestring. The indices low and high select which elements of operand a appear in the result. The result has indices starting at 0 and length equal to high - low. After slicing the array a\n\na := [5]int{1, 2, 3, 4, 5} s := a[1:4]\n\nthe slice s has type []int, length 3, capacity 4, and elements\n\ns[0] == 2 s[1] == 3 s[2] == 4\n\nFor convenience, any of the indices may be omitted. A missing low index defaults to zero; a missing high index defaults to the length of the sliced operand:\n\na[2:] // same as a[2 : len(a)] a[:3] // same as a[0 : 3] a[:] // same as a[0 : len(a)]\n\nIf a is a pointer to an array, a[low : high] is shorthand for (*a)[low : high].\n\nFor arrays or strings, the indices are in range if 0 <= low <= high <= len(a), otherwise they are out of range. For slices, the upper index bound is the slice capacity cap(a) rather than the length. A constant index must be non-negative and representable by a value of type int; for arrays or constant strings, constant indices must also be in range. If both indices are constant, they must satisfy low <= high. If the indices are out of range at run time, a run-time panic occurs.\n\nExcept for untyped strings, if the sliced operand is a string or slice, the result of the slice operation is a non-constant value of the same type as the operand. For untyped string operands the result is a non-constant value of type string. If the sliced operand is an array, it must be addressable and the result of the slice operation is a slice with the same element type as the array.\n\nIf the sliced operand of a valid slice expression is a nil slice, the result is a nil slice. Otherwise, if the result is a slice, it shares its underlying array with the operand.\n\nvar a [10]int s1 := a[3:7] // underlying array of s1 is array a; &s1[2] == &a[5] s2 := s1[1:4] // underlying array of s2 is underlying array of s1 which is array a; &s2[1] == &a[5] s2[1] = 42 // s2[1] == s1[2] == a[5] == 42; they all refer to the same underlying array element var s []int s3 := s[:0] // s3 == nil\n\nFull slice expressions\n\nThe primary expression\n\na[low : high : max]\n\nconstructs a slice of the same type, and with the same length and elements as the simple slice expression a[low : high]. Additionally, it controls the resulting slice's capacity by setting it to max - low. Only the first index may be omitted; it defaults to 0. The core type of a must be an array, pointer to array, or slice (but not a string). After slicing the array a\n\na := [5]int{1, 2, 3, 4, 5} t := a[1:3:5]\n\nthe slice t has type []int, length 2, capacity 4, and elements\n\nt[0] == 2 t[1] == 3\n\nAs for simple slice expressions, if a is a pointer to an array, a[low : high : max] is shorthand for (*a)[low : high : max]. If the sliced operand is an array, it must be addressable.\n\nThe indices are in range if 0 <= low <= high <= max <= cap(a), otherwise they are out of range. A constant index must be non-negative and representable by a value of type int; for arrays, constant indices must also be in range. If multiple indices are constant, the constants that are present must be in range relative to each other. If the indices are out of range at run time, a run-time panic occurs.\n\nType assertions\n\nFor an expression x of interface type, but not a type parameter, and a type T, the primary expression\n\nx.(T)\n\nasserts that x is not nil and that the value stored in x is of type T. The notation x.(T) is called a type assertion.\n\nMore precisely, if T is not an interface type, x.(T) asserts that the dynamic type of x is identical to the type T. In this case, T must implement the (interface) type of x; otherwise the type assertion is invalid since it is not possible for x to store a value of type T. If T is an interface type, x.(T) asserts that the dynamic type of x implements the interface T.\n\nIf the type assertion holds, the value of the expression is the value stored in x and its type is T. If the type assertion is false, a run-time panic occurs. In other words, even though the dynamic type of x is known only at run time, the type of x.(T) is known to be T in a correct program.\n\nvar x interface{} = 7 // x has dynamic type int and value 7 i := x.(int) // i has type int and value 7 type I interface { m() } func f(y I) { s := y.(string) // illegal: string does not implement I (missing method m) r := y.(io.Reader) // r has type io.Reader and the dynamic type of y must implement both I and io.Reader … }\n\nA type assertion used in an assignment statement or initialization of the special form\n\nv, ok = x.(T) v, ok := x.(T) var v, ok = x.(T) var v, ok interface{} = x.(T) // dynamic types of v and ok are T and bool\n\nyields an additional untyped boolean value. The value of ok is true if the assertion holds. Otherwise it i"
    }
}