{
    "id": "dbpedia_1004_0",
    "rank": 38,
    "data": {
        "url": "https://github.com/b-rodrigues/modern_R/blob/master/04-descriptives.Rmd",
        "read_more_link": "",
        "language": "en",
        "title": "modern_R/04-descriptives.Rmd at master · b-rodrigues/modern_R",
        "top_image": "https://opengraph.githubassets.com/40f936fa24405cdd03c21a10468ec67c2c4ef922207a55c6e6bb295dc550ef07/b-rodrigues/modern_R",
        "meta_img": "https://opengraph.githubassets.com/40f936fa24405cdd03c21a10468ec67c2c4ef922207a55c6e6bb295dc550ef07/b-rodrigues/modern_R",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "b-rodrigues"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Contribute to b-rodrigues/modern_R development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/b-rodrigues/modern_R/blob/master/04-descriptives.Rmd",
        "text": "# Descriptive statistics and data manipulation\n\nNow that we are familiar with some R objects and know how to import data, it is time to write some\n\ncode. In this chapter, we are going to compute descriptive statistics for a single dataset, but\n\nalso for a list of datasets later in the chapter. However, I will not give a list of functions to\n\ncompute descriptive statistics; if you need a specific function you can find easily in the *Help*\n\npane in Rstudio or using any modern internet search engine. What I will do is show you a workflow\n\nthat allows you to compute the descripitive statisics you need fast. R has a lot of built-in\n\nfunctions for descriptive statistics; however, if you want to compute statistics for different\n\nsub-groups, some more complex manipulations are needed. At least this was true in the past.\n\nNowadays, thanks to the packages from the `{tidyverse}`, it is very easy and fast to compute\n\ndescriptive statistics by any stratifying variable(s). The package we are going to use for this is\n\ncalled `{dplyr}`. `{dplyr}` contains a lot of functions that make manipulating data and computing\n\ndescriptive statistics very easy. To make things easier for now, we are going to use example data\n\nincluded with `{dplyr}`. So no need to import an external dataset; this does not change anything to\n\nthe example that we are going to study here; the source of the data does not matter for this. Using\n\n`{dplyr}` is possible only if the data you are working with is already in a useful shape. When data\n\nis more messy, you will need to first manipulate it to bring it a *tidy* format. For this, we will\n\nuse `{tidyr}`, which is very useful package to reshape data and to do advanced cleaning of your\n\ndata. All these tidyverse functions are also called *verbs*. However, before getting to know these\n\nverbs, let's do an analysis using standard, or *base* R functions. This will be the benchmark\n\nagainst which we are going to measure a `{tidyverse}` workflow.\n\n## A data exploration exercice using *base* R\n\nLet's first load the `starwars` data set, included in the `{dplyr}` package:\n\n```{r}\n\nlibrary(dplyr)\n\ndata(starwars)\n\n```\n\nLet's first take a look at the data:\n\n```{r}\n\nhead(starwars)\n\n```\n\nThis data contains information on Star Wars characters. The first question you have to answer is\n\nto find the average height of the characters:\n\n```{r}\n\nmean(starwars$height)\n\n```\n\nAs discussed in Chapter 2, `$` allows you to access columns of a `data.frame` objects.\n\nBecause there are `NA` values in the data, the result is also `NA`. To get the result, you need to\n\nadd an option to `mean()`:\n\n```{r}\n\nmean(starwars$height, na.rm = TRUE)\n\n```\n\nLet's also take a look at the standard deviation:\n\n```{r}\n\nsd(starwars$height, na.rm = TRUE)\n\n```\n\nIt might be more informative to compute these two statistics by sex, so for this, we are going\n\nto use `aggregate()`:\n\n```{r}\n\naggregate(starwars$height,\n\nby = list(sex = starwars$sex),\n\nmean)\n\n```\n\nOh, shoot! Most groups have missing values in them, so we get `NA` back. We need to use `na.rm = TRUE`\n\njust like before. Thankfully, it is possible to pass this option to `mean()` inside `aggregate()` as well:\n\n```{r}\n\naggregate(starwars$height,\n\nby = list(sex = starwars$sex),\n\nmean, na.rm = TRUE)\n\n```\n\nLater in the book, we are also going to see how to define our own functions (with the default options that\n\nare useful to us), and this will also help in this sort of situation.\n\nEven though we can use `na.rm = TRUE`, let's also use `subset()` to filter out the `NA` values beforehand:\n\n```{r}\n\nstarwars_no_nas <- subset(starwars,\n\n!is.na(height))\n\naggregate(starwars_no_nas$height,\n\nby = list(sex = starwars_no_nas$sex),\n\nmean)\n\n```\n\n(`aggregate()` also has a `subset = ` option, but I prefer to explicitely subset the data set with `subset()`).\n\nEven if you are not familiar with `aggregate()`, I believe the above lines are quite\n\nself-explanatory. You need to provide `aggregate()` with 3 things; the variable you want to\n\nsummarize (or only the data frame, if you want to summarize all variables), a list of grouping\n\nvariables and then the function that will be applied to each subgroup. And by the way, to test for\n\n`NA`, one uses the function `is.na()` not something like `species == \"NA\"` or anything like that.\n\n`!is.na()` does the opposite (`!` reverses booleans, so `!TRUE` becomes `FALSE` and vice-versa).\n\nYou can easily add another grouping variable:\n\n```{r}\n\naggregate(starwars_no_nas$height,\n\nby = list(Sex = starwars_no_nas$sex,\n\n`Hair color` = starwars_no_nas$hair_color),\n\nmean)\n\n```\n\nor use another function:\n\n```{r}\n\naggregate(starwars_no_nas$height,\n\nby = list(Sex = starwars_no_nas$sex),\n\nsd)\n\n```\n\n(let's ignore the `NA`s). It is important to note that `aggregate()` returns a `data.frame` object.\n\nYou can only give one function to `aggregate()`, so if you need the mean and the standard deviation of `height`,\n\nyou must do it in two steps.\n\nSince R 4.1, a new infix operator `|>` has been introduced, which is really handy for writing the kind of\n\ncode we've been looking at in this chapter. `|>` is also called a pipe, or the *base* pipe to distinguish\n\nit from *another* pipe that we'll discuss in the next section. For now, let's learn about `|>`.\n\nConsider the following:\n\n```{r}\n\n10 |> sqrt()\n\n```\n\nThis computes `sqrt(10)`; so what `|>` does, is pass the left hand side (`10`, in the example above) to the\n\nright hand side (`sqrt()`). Using `|>` might seem more complicated and verbose than not using it, but you\n\nwill see in a bit why it can be useful. The next function I would like to introduce at this point is `with()`.\n\n`with()` makes it possible to apply functions on `data.frame` columns without having to write `$` all the time.\n\nFor example, consider this:\n\n```{r}\n\nmean(starwars$height, na.rm = TRUE)\n\nwith(starwars,\n\nmean(height, na.rm = TRUE))\n\n```\n\nThe advantage of using `with()` is that we can directly reference `height` without using `$`. Here again, this\n\nis more verbose than simply using `$`... so why bother with it? It turns out that by combining `|>` and `with()`,\n\nwe can write very clean and concise code. Let's go back to a previous example to illustrate this idea:\n\n```{r}\n\nstarwars_no_nas <- subset(starwars,\n\n!is.na(height))\n\naggregate(starwars_no_nas$height,\n\nby = list(sex = starwars_no_nas$sex),\n\nmean)\n\n```\n\nFirst, we created a new dataset where we filtered out rows where `height` is `NA`. This dataset is useless otherwise,\n\nbut we need it for the next part, where we actually do what we want (computing the average `height` by `sex`).\n\nUsing `|>` and `with()`, we can write this in one go:\n\n```{r}\n\nstarwars |>\n\nsubset(!is.na(sex)) |>\n\nwith(aggregate(height,\n\nby = list(Species = species,\n\nSex = sex),\n\nmean))\n\n```\n\nSo let's unpack this. In the first two rows, using `|>`, we pass the `starwars` `data.frame` to `subset()`:\n\n```{r}\n\nstarwars |>\n\nsubset(!is.na(sex))\n\n```\n\nas I explained before, this is exactly the same as `subset(starwars, !is.na(sex))`. Then, we pass the result of\n\n`subset()` to the next function, `with()`. The first argument of `with()` must be a `data.frame`, and this is exactly\n\nwhat `subset()` returns! So now the output of `subset()` is passed down to `with()`, which makes it now possible\n\nto reference the columns of the `data.frame` in `aggregate()` directly. If you have a hard time understanding what\n\nis going on, you can use `quote()` to see what's going on. `quote()` returns an expression with evaluating it:\n\n```{r}\n\nquote(log(10))\n\n```\n\nWhy am I bring this up? Well, since `a |> f()` is exactly equal to `f(a)`, quoting the code above will return\n\nan expression with `|>`. For instance:\n\n```{r}\n\nquote(10 |> log())\n\n```\n\nSo let's quote the big block of code from above:\n\n```{r}\n\nquote(\n\nstarwars |>\n\nsubset(!is.na(sex)) |>\n\nwith(aggregate(height,\n\nby = list(Species = species,\n\nSex = sex),\n\nmean))\n\n)\n\n```\n\nI think now you see why using `|>` makes code much clearer; the nested expression you would need to write otherwise\n\nis much less readable, unless you define intermediate objects. And without `with()`, this is what you\n\nwould need to write:\n\n```{r, eval = F}\n\nb <- subset(starwars, !is.na(height))\n\naggregate(b$height, by = list(Species = b$species, Sex = b$sex), mean)\n\n```\n\nTo finish this section, let's say that you wanted to have the average `height` and `mass` by sex. In this case\n\nyou need to specify the columns in `aggregate()` with `cbind()` (let's use `na.rm = TRUE` again instead of\n\n`subset()`ing the data beforehand):\n\n```{r}\n\nstarwars |>\n\nwith(aggregate(cbind(height, mass),\n\nby = list(Sex = sex),\n\nFUN = mean, na.rm = TRUE))\n\n```\n\nLet's now continue with some more advanced operations using this fake dataset:\n\n```{r}\n\nsurvey_data_base <- as.data.frame(\n\ntibble::tribble(\n\n~id, ~var1, ~var2, ~var3,\n\n1, 1, 0.2, 0.3,\n\n2, 1.4, 1.9, 4.1,\n\n3, 0.1, 2.8, 8.9,\n\n4, 1.7, 1.9, 7.6\n\n)\n\n)\n\n```\n\n```{r}\n\nsurvey_data_base\n\n```\n\nDepending on what you want to do with this data, it is not in the right shape. For example, it\n\nwould not be possible to simply compute the average of `var1`, `var2` and `var3` for each `id`.\n\nThis is because this would require running `mean()` by row, but this is not very easy. This is\n\nbecause R is not suited to row-based workflows. Well I'm lying a little bit here, it turns here\n\nthat R comes with a `rowMeans()` function. So this would work:\n\n```{r}\n\nsurvey_data_base |>\n\ntransform(mean_id = rowMeans(cbind(var1, var2, var3))) #transform adds a column to a data.frame\n\n```\n\nBut there is no `rowSD()` or `rowMax()`, etc... so it is much better to reshape the data and put it in a\n\nformat that gives us maximum flexibility. To reshape the data, we'll be using the aptly-called `reshape()` command:\n\n```{r}\n\nsurvey_data_long <- reshape(survey_data_base,\n\nvarying = list(2:4), v.names = \"variable\", direction = \"long\")\n\n```\n\nWe can now easily compute the average of `variable` for each `id`:\n\n```{r}\n\naggregate(survey_data_long$variable,\n\nby = list(Id = survey_data_long$id),\n\nmean)\n\n```\n\nor any other variable:\n\n```{r}\n\naggregate(survey_data_long$variable,\n\nby = list(Id = survey_data_long$id),\n\nmax)\n\n```\n\nAs you can see, R comes with very powerful functions right out of the box, ready to use. When I was\n\nstudying, unfortunately, my professors had been brought up on FORTRAN loops, so we had to do to all\n\nthis using loops (not reshaping, thankfully), which was not so easy.\n\nNow that we have seen how *base* R works, let's redo the analysis using `{tidyverse}` verbs.\n\nThe `{tidyverse}` provides many more functions, each of them doing only one single thing. You will\n\nshortly see why this is quite important; by focusing on just one task, and by focusing on the data frame\n\nas the central object, it becomes possible to build really complex workflows, piece by piece,\n\nvery easily.\n\nBut before deep diving into the `{tidyverse}`, let's take a moment to discuss about another infix\n\noperator, `%>%`.\n\n## Smoking is bad for you, but pipes are your friend\n\nThe title of this section might sound weird at first, but by the end of it, you'll get this\n\n(terrible) pun.\n\nYou probably know the following painting by René Magritte, *La trahison des images*:\n\n```{r, echo=FALSE}\n\nknitr::include_graphics(\"assets/pas_une_pipe.png\")\n\n```\n\nIt turns out there's an R package from the `tidyverse` that is called `magrittr`. What does this\n\npackage do? This package introduced *pipes* to R, way before `|>` in R 4.1. Pipes are a concept\n\nfrom the Unix operating system; if you're using a GNU+Linux distribution or macOS, you're basically\n\nusing a *modern* unix (that's an oversimplification, but I'm an economist by training, and\n\noutrageously oversimplifying things is what we do, deal with it). The *magrittr* pipe is written as\n\n`%>%`. Just like `|>`, `%>%` takes the left hand side to feed it as the first argument of the\n\nfunction in the right hand side. Try the following:\n\n```{r, include = FALSE}\n\nlibrary(magrittr)\n\n```\n\n```{r, eval = FALSE}\n\nlibrary(magrittr)\n\n```\n\n```{r}\n\n16 %>% sqrt\n\n```\n\nYou can chain multiple functions, as you can with `|>`:\n\n```{r}\n\n16 %>%\n\nsqrt %>%\n\nlog\n\n```\n\nBut unlike with `|>`, you can omit `()`. `%>%` also has other features. For example, you can\n\npipe things to other infix operators. For example, `+`. You can use `+` as usual:\n\n```{r}\n\n2 + 12\n\n```\n\nOr as a prefix operator:\n\n```{r}\n\n`+`(2, 12)\n\n```\n\nYou can use this notation with `%>%`:\n\n```{r}\n\n16 %>% sqrt %>% `+`(18)\n\n```\n\nThis also works using `|>` since R version 4.2, but only if you use the `_` pipe placeholder:\n\n```{r}\n\n16 |> sqrt() |> `+`(x = _, 18)\n\n```\n\nThe output of `16` (`16`) got fed to `sqrt()`, and the output of `sqrt(16)` (4) got fed to `+(18)`\n\n(so we got `+(4, 18)` = 22). Without `%>%` you'd write the line just above like this:\n\n```{r}\n\nsqrt(16) + 18\n\n```\n\nJust like before, with `|>`, this might seem overly complicated, but using these pipes will\n\nmake our code much more readable. I'm sure you'll be convinced by the end of this chapter.\n\n`%>%` is not the only pipe operator in `magrittr`. There's `%T%`, `%<>%` and `%$%`. All have their\n\nuses, but are basically shortcuts to some common tasks with `%>%` plus another function. Which\n\nmeans that you can live without them, and because of this, I will not discuss them.\n\n## The `{tidyverse}`'s *enfant prodige*: `{dplyr}`\n\nThe best way to get started with the tidyverse packages is to get to know `{dplyr}`. `{dplyr}`\n\nprovides a lot of very useful functions that makes it very easy to get discriptive statistics or\n\nadd new columns to your data.\n\n### A first taste of data manipulation with `{dplyr}`\n\nThis section will walk you through a typical analysis using `{dplyr}` funcitons. Just go with it; I\n\nwill give more details in the next sections.\n\nFirst, let's load `{dplyr}` and the included `starwars` dataset. Let's also take a look at the\n\nfirst 5 lines of the dataset:\n\n```{r}\n\nlibrary(dplyr)\n\ndata(starwars)\n\nhead(starwars)\n\n```\n\n`data(starwars)` loads the example dataset called `starwars` that is included in the package\n\n`{dplyr}`. As I said earlier, this is just an example; you could have loaded an external dataset,\n\nfrom a `.csv` file for instance. This does not matter for what comes next.\n\nLike we saw earlier, R includes a lot of functions for descriptive statistics, such as `mean()`,\n\n`sd()`, `cov()`, and many more. What `{dplyr}` brings to the table is a grammar of data\n\nmanipulation that makes it very easy to apply descriptive statistics functions, or any other,\n\nvery easily.\n\nJust like before, we are going to compute the average height by `sex`:\n\n```{r}\n\nstarwars %>%\n\ngroup_by(sex) %>%\n\nsummarise(mean_height = mean(height, na.rm = TRUE))\n\n```\n\nThe very nice thing about using `%>%` and `{dplyr}` verbs/functions, is that this is really\n\nreadable. The above three lines can be translated like so in English:\n\n*Take the starwars dataset, then group by sex, then compute the mean height (for each subgroup) by\n\nomitting missing values.*\n\n`%>%` can be translated by \"then\". Without `%>%` you would need to change the code to:\n\n```{r}\n\nsummarise(group_by(starwars, sex), mean(height, na.rm = TRUE))\n\n```\n\nUnlike with the *base* approach, each function does only one thing. With the base function\n\n`aggregate()` was used to also define the subgroups. This is not the case with `{dplyr}`; one\n\nfunction to create the groups (`group_by()`) and then one function to compute the summaries\n\n(`summarise()`). Also, `group_by()` creates a specific subgroup for individuals where `sex` is\n\nmissing. This is the last line in the data frame, where `sex` is `NA`. Another nice thing is that\n\nyou can specify the column containing the average height. I chose to name it `mean_height`.\n\nNow, let's suppose that we want to filter some data first:\n\n```{r}\n\nstarwars %>%\n\nfilter(gender == \"masculine\") %>%\n\ngroup_by(sex) %>%\n\nsummarise(mean_height = mean(height, na.rm = TRUE))\n\n```\n\nAgain, the `%>%` makes the above lines of code very easy to read. Without it, one would need to\n\nwrite:\n\n```{r}\n\nsummarise(group_by(filter(starwars, gender == \"masculine\"), sex), mean(height, na.rm = TRUE))\n\n```\n\nI think you agree with me that this is not very readable. One way to make it more readable would\n\nbe to save intermediary variables:\n\n```{r}\n\nfiltered_data <- filter(starwars, gender == \"masculine\")\n\ngrouped_data <- group_by(filter(starwars, gender == \"masculine\"), sex)\n\nsummarise(grouped_data, mean(height))\n\n```\n\nBut this can get very tedious. Once you're used to `%>%`, you won't go back to not use it.\n\nBefore continuing and to make things clearer; `filter()`, `group_by()` and `summarise()` are\n\nfunctions that are included in `{dplyr}`. `%>%` is actually a function from `{magrittr}`, but this\n\npackage gets loaded on the fly when you load `{dplyr}`, so you do not need to worry about it.\n\nThe result of all these operations that use `{dplyr}` functions are actually other datasets, or\n\n`tibbles`. This means that you can save them in variable, or write them to disk, and then work with\n\nthese as any other datasets.\n\n```{r}\n\nmean_height <- starwars %>%\n\ngroup_by(sex) %>%\n\nsummarise(mean(height))\n\nclass(mean_height)\n\nhead(mean_height)\n\n```\n\nYou could then write this data to disk using `rio::export()` for instance. If you need more than\n\nthe mean of the height, you can keep adding as many functions as needed (another advantage over\n\n`aggregate()`:\n\n```{r}\n\nsummary_table <- starwars %>%\n\ngroup_by(sex) %>%\n\nsummarise(mean_height = mean(height, na.rm = TRUE),\n\nvar_height = var(height, na.rm = TRUE),\n\nn_obs = n())\n\nsummary_table\n\n```\n\nI've added more functions, namely `var()`, to get the variance of height, and `n()`, which\n\nis a function from `{dplyr}`, not base R, to get the number of observations. This is quite useful,\n\nbecause we see that there is a group with only one individual. Let's focus on the\n\nsexes for which we have more than 1 individual. Since we save all the previous operations (which\n\nproduce a `tibble`) in a variable, we can keep going from there:\n\n```{r}\n\nsummary_table2 <- summary_table %>%\n\nfilter(n_obs > 1)\n\nsummary_table2\n\n```\n\nAs mentioned before, there's a lot of `NA`s; this is because by default, `mean()` and `var()`\n\nreturn `NA` if even one single observation is `NA`. This is good, because it forces you to look at\n\nthe data to see what is going on. If you would get a number, even if there were `NA`s you could\n\nvery easily miss these missing values. It is better for functions to fail early and often than the\n\nopposite. This is way we keep using `na.rm = TRUE` for `mean()` and `var()`.\n\nNow let's actually take a look at the rows where `sex` is `NA`:\n\n```{r}\n\nstarwars %>%\n\nfilter(is.na(sex))\n\n```\n\nThere's only 4 rows where `sex` is `NA`. Let's ignore them:\n\n```{r}\n\nstarwars %>%\n\nfilter(!is.na(sex)) %>%\n\ngroup_by(sex) %>%\n\nsummarise(ave_height = mean(height, na.rm = TRUE),\n\nvar_height = var(height, na.rm = TRUE),\n\nn_obs = n()) %>%\n\nfilter(n_obs > 1)\n\n```\n\nAnd why not compute the same table, but first add another stratifying variable?\n\n```{r}\n\nstarwars %>%\n\nfilter(!is.na(sex)) %>%\n\ngroup_by(sex, eye_color) %>%\n\nsummarise(ave_height = mean(height, na.rm = TRUE),\n\nvar_height = var(height, na.rm = TRUE),\n\nn_obs = n()) %>%\n\nfilter(n_obs > 1)\n\n```\n\nOk, that's it for a first taste. We have already discovered some very useful `{dplyr}` functions,\n\n`filter()`, `group_by()` and summarise `summarise()`.\n\nNow, we are going to learn more about these functions in more detail.\n\n### Filter the rows of a dataset with `filter()`\n\nWe're going to use the `Gasoline` dataset from the `plm` package, so install that first:\n\n```{r, eval = FALSE}\n\ninstall.packages(\"plm\")\n\n```\n\nThen load the required data:\n\n```{r}\n\ndata(Gasoline, package = \"plm\")\n\n```\n\nand load dplyr:\n\n```{r}\n\nlibrary(dplyr)\n\n```\n\nThis dataset gives the consumption of gasoline for 18 countries from 1960 to 1978. When you load\n\nthe data like this, it is a standard `data.frame`. `{dplyr}` functions can be used on standard\n\n`data.frame` objects, but also on `tibble`s. `tibble`s are just like data frame, but with a better\n\nprint method (and other niceties). I'll discuss the `{tibble}` package later, but for now, let's\n\nconvert the data to a `tibble` and change its name, and also transform the `country` column to\n\nlower case:\n\n```{r}\n\ngasoline <- as_tibble(Gasoline)\n\ngasoline <- gasoline %>%\n\nmutate(country = tolower(country))\n\n```\n\n`filter()` is pretty straightforward. What if you would like to subset the data to focus on the\n\nyear 1969? Simple:\n\n```{r}\n\nfilter(gasoline, year == 1969)\n\n```\n\nLet's use `%>%`, since we're familiar with it now:\n\n```{r}\n\ngasoline %>%\n\nfilter(year == 1969)\n\n```\n\nYou can also filter more than just one year, by using the `%in%` operator:\n\n```{r}\n\ngasoline %>%\n\nfilter(year %in% seq(1969, 1973))\n\n```\n\nIt is also possible use `between()`, a helper function:\n\n```{r}\n\ngasoline %>%\n\nfilter(between(year, 1969, 1973))\n\n```\n\nTo select non-consecutive years:\n\n```{r}\n\ngasoline %>%\n\nfilter(year %in% c(1969, 1973, 1977))\n\n```\n\n`%in%` tests if an object is part of a set.\n\n### Select columns with `select()`\n\nWhile `filter()` allows you to keep or discard rows of data, `select()` allows you to keep or\n\ndiscard entire columns. To keep columns:\n\n```{r}\n\ngasoline %>%\n\nselect(country, year, lrpmg)\n\n```\n\nTo discard them:\n\n```{r}\n\ngasoline %>%\n\nselect(-country, -year, -lrpmg)\n\n```\n\nTo rename them:\n\n```{r}\n\ngasoline %>%\n\nselect(country, date = year, lrpmg)\n\n```\n\nThere's also `rename()`:\n\n```{r}\n\ngasoline %>%\n\nrename(date = year)\n\n```\n\n`rename()` does not do any kind of selection, but just renames.\n\nYou can also use `select()` to re-order columns:\n\n```{r}\n\ngasoline %>%\n\nselect(year, country, lrpmg, everything())\n\n```\n\n`everything()` is a helper function, and there's also `starts_with()`, and `ends_with()`. For\n\nexample, what if we are only interested in columns whose name start with \"l\"?\n\n```{r}\n\ngasoline %>%\n\nselect(starts_with(\"l\"))\n\n```\n\n`ends_with()` works in a similar fashion. There is also `contains()`:\n\n```{r}\n\ngasoline %>%\n\nselect(country, year, contains(\"car\"))\n\n```\n\nYou can read more about these helper functions [here](https://tidyselect.r-lib.org/reference/language.html), but we're going to look more into\n\nthem in a coming section.\n\nAnother verb, similar to `select()`, is `pull()`. Let's compare the two:\n\n```{r}\n\ngasoline %>%\n\nselect(lrpmg)\n\n```\n\n```{r}\n\ngasoline %>%\n\npull(lrpmg) %>%\n\nhead() # using head() because there's 337 elements in total\n\n```\n\n`pull()`, unlike `select()`, does not return a `tibble`, but only the column you want, as a\n\nvector.\n\n### Group the observations of your dataset with `group_by()`\n\n`group_by()` is a very useful verb; as the name implies, it allows you to create groups and then,\n\nfor example, compute descriptive statistics by groups. For example, let's group our data by\n\ncountry:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country)\n\n```\n\nIt looks like nothing much happened, but if you look at the second line of the output you can read\n\nthe following:\n\n```{r}\n\n## # Groups: country [18]\n\n```\n\nthis means that the data is grouped, and every computation you will do now will take these groups\n\ninto account. It is also possible to group by more than one variable:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country, year)\n\n```\n\nand so on. You can then also ungroup:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country, year) %>%\n\nungroup()\n\n```\n\nOnce your data is grouped, the operations that will follow will be executed inside each group.\n\n### Get summary statistics with `summarise()`\n\nOk, now that we have learned the basic verbs, we can start to do more interesting stuff. For\n\nexample, one might want to compute the average gasoline consumption in each country, for\n\nthe whole period:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nsummarise(mean(lgaspcar))\n\n```\n\n`mean()` was given as an argument to `summarise()`, which is a `{dplyr}` verb. What we get is\n\nanother `tibble`, that contains the variable we used to group, as well as the average per country.\n\nWe can also rename this column:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nsummarise(mean_gaspcar = mean(lgaspcar))\n\n```\n\nand because the output is a `tibble`, we can continue to use `{dplyr}` verbs on it:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nsummarise(mean_gaspcar = mean(lgaspcar)) %>%\n\nfilter(country == \"france\")\n\n```\n\n`summarise()` is a very useful verb. For example, we can compute several descriptive statistics at once:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nsummarise(mean_gaspcar = mean(lgaspcar),\n\nsd_gaspcar = sd(lgaspcar),\n\nmax_gaspcar = max(lgaspcar),\n\nmin_gaspcar = min(lgaspcar))\n\n```\n\nBecause the output is a `tibble`, you can save it in a variable of course:\n\n```{r}\n\ndesc_gasoline <- gasoline %>%\n\ngroup_by(country) %>%\n\nsummarise(mean_gaspcar = mean(lgaspcar),\n\nsd_gaspcar = sd(lgaspcar),\n\nmax_gaspcar = max(lgaspcar),\n\nmin_gaspcar = min(lgaspcar))\n\n```\n\nAnd then you can answer questions such as, *which country has the maximum average gasoline\n\nconsumption?*:\n\n```{r}\n\ndesc_gasoline %>%\n\nfilter(max(mean_gaspcar) == mean_gaspcar)\n\n```\n\nTurns out it's Turkey. What about the minimum consumption?\n\n```{r}\n\ndesc_gasoline %>%\n\nfilter(min(mean_gaspcar) == mean_gaspcar)\n\n```\n\nBecause the output of `{dplyr}` verbs is a tibble, it is possible to continue working with it. This\n\nis one shortcoming of using the base `summary()` function. The object returned by that function is\n\nnot very easy to manipulate.\n\n### Adding columns with `mutate()` and `transmute()`\n\n`mutate()` adds a column to the `tibble`, which can contain any transformation of any other\n\nvariable:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nmutate(n())\n\n```\n\nUsing `mutate()` I've added a column that counts how many times the country appears in the `tibble`,\n\nusing `n()`, another `{dplyr}` function. There's also `count()` and `tally()`, which we are going to\n\nsee further down. It is also possible to rename the column on the fly:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nmutate(count = n())\n\n```\n\nIt is possible to do any arbitrary operation:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\nmutate(spam = exp(lgaspcar + lincomep))\n\n```\n\n`transmute()` is the same as `mutate()`, but only returns the created variable:\n\n```{r}\n\ngasoline %>%\n\ngroup_by(country) %>%\n\ntransmute(spam = exp(lgaspcar + lincomep))\n\n```\n\n### Joining `tibble`s with `full_join()`, `left_join()`, `right_join()` and all the others\n\nI will end this section on `{dplyr}` with the very useful verbs: the `*_join()` verbs. Let's first\n\nstart by loading another dataset from the `plm` package. `SumHes` and let's convert it to `tibble`\n\nand rename it:\n\n```{r, include = FALSE}\n\ngasoline <- as_tibble(Gasoline) %>%\n\nmutate(country = tolower(country))\n\n```\n\n```{r}\n\ndata(SumHes, package = \"plm\")\n\npwt <- SumHes %>%\n\nas_tibble() %>%\n\nmutate(country = tolower(country))\n\n```\n\nLet's take a quick look at the data:\n\n```{r}\n\nglimpse(pwt)\n\n```\n\nWe can merge both `gasoline` and `pwt` by country and year, as these two variables are common to\n\nboth datasets. There are more countries and years in the `pwt` dataset, so when merging both, and\n\ndepending on which function you use, you will either have `NA`'s for the variables where there is\n\nno match, or rows that will be dropped. Let's start with `full_join`:\n\n```{r}\n\ngas_pwt_full <- gasoline %>%\n\nfull_join(pwt, by = c(\"country\", \"year\"))\n\n```\n\nLet's see which countries and years are included:\n\n```{r}\n\ngas_pwt_full %>%\n\ncount(country, year)\n\n```\n\nAs you see, every country and year was included, but what happened for, say, the U.S.S.R? This country\n\nis in `pwt` but not in `gasoline` at all:\n\n```{r}\n\ngas_pwt_full %>%\n\nfilter(country == \"u.s.s.r.\")\n\n```\n\nAs you probably guessed, the variables from `gasoline` that are not included in `pwt` are filled with\n\n`NA`s. One could remove all these lines and only keep countries for which these variables are not\n\n`NA` everywhere with `filter()`, but there is a simpler solution:\n\n```{r}\n\ngas_pwt_inner <- gasoline %>%\n\ninner_join(pwt, by = c(\"country\", \"year\"))\n\n```\n\nLet's use the `tabyl()` from the `janitor` packages which is a very nice alternative to the `table()`\n\nfunction from base R:\n\n```{r}\n\nlibrary(janitor)\n\ngas_pwt_inner %>%\n\ntabyl(country)\n\n```\n\nOnly countries with values in both datasets were returned. It's almost every country from `gasoline`,\n\napart from Germany (called \"germany west\" in `pwt` and \"germany\" in `gasoline`. I left it as is to\n\nprovide an example of a country not in `pwt`). Let's also look at the variables:\n\n```{r}\n\nglimpse(gas_pwt_inner)\n\n```\n\nThe variables from both datasets are in the joined data.\n\nContrast this to `semi_join()`:\n\n```{r}\n\ngas_pwt_semi <- gasoline %>%\n\nsemi_join(pwt, by = c(\"country\", \"year\"))\n\nglimpse(gas_pwt_semi)\n\ngas_pwt_semi %>%\n\ntabyl(country)\n\n```\n\nOnly columns of `gasoline` are returned, and only rows of `gasoline` that were matched with rows\n\nfrom `pwt`. `semi_join()` is not a commutative operation:\n\n```{r}\n\npwt_gas_semi <- pwt %>%\n\nsemi_join(gasoline, by = c(\"country\", \"year\"))\n\nglimpse(pwt_gas_semi)\n\ngas_pwt_semi %>%\n\ntabyl(country)\n\n```\n\nThe rows are the same, but not the columns.\n\n`left_join()` and `right_join()` return all the rows from either the dataset that is on the\n\n\"left\" (the first argument of the fonction) or on the \"right\" (the second argument of the\n\nfunction) but all columns from both datasets. So depending on which countries you're interested in,\n\nyou're going to use either one of these functions:\n\n```{r}\n\ngas_pwt_left <- gasoline %>%\n\nleft_join(pwt, by = c(\"country\", \"year\"))\n\ngas_pwt_left %>%\n\ntabyl(country)\n\n```\n\n```{r}\n\ngas_pwt_right <- gasoline %>%\n\nright_join(pwt, by = c(\"country\", \"year\"))\n\ngas_pwt_right %>%\n\ntabyl(country) %>%\n\nhead()\n\n```\n\nThe last merge function is `anti_join()`:\n\n```{r}\n\ngas_pwt_anti <- gasoline %>%\n\nanti_join(pwt, by = c(\"country\", \"year\"))\n\nglimpse(gas_pwt_anti)\n\ngas_pwt_anti %>%\n\ntabyl(country)\n\n```\n\n`gas_pwt_anti` has the columns the `gasoline` dataset as well as the only country from `gasoline`\n\nthat is not in `pwt`: \"germany\".\n\nThat was it for the basic `{dplyr}` verbs. Next, we're going to learn about `{tidyr}`.\n\n## Reshaping and sprucing up data with `{tidyr}`\n\nNote: this section is going to be a lot harder than anything you've seen until now. Reshaping\n\ndata is tricky, and to really grok it, you need time, and you need to run each line, and see what\n\nhappens. Take your time, and don't be discouraged.\n\nAnother important package from the `{tidyverse}` that goes hand in hand with `{dplyr}` is `{tidyr}`.\n\n`{tidyr}` is the package you need when it's time to reshape data.\n\nI will start by presenting `pivot_wider()` and `pivot_longer()`."
    }
}