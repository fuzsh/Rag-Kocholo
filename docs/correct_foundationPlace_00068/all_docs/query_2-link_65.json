{
    "id": "correct_foundationPlace_00068_2",
    "rank": 65,
    "data": {
        "url": "https://aws.amazon.com/what-is/cloud-native/",
        "read_more_link": "",
        "language": "en",
        "title": "What is Cloud Native?",
        "top_image": "https://a0.awsstatic.com/libra-css/images/logos/aws_logo_smile_1200x630.png",
        "meta_img": "https://a0.awsstatic.com/libra-css/images/logos/aws_logo_smile_1200x630.png",
        "images": [
            "https://d1.awsstatic.com/Free-Tier_64.f14d1a130811a363bbea22de4bb589f9ab801dfb.png",
            "https://d1.awsstatic.com/Compute_64.72db591feb90f4ca9d441ea54260e9937c83ac0e.png",
            "https://d1.awsstatic.com/Learn-More_64.dc6d454a262eb880a9dd0d8cb283dca5bc00cb18.png",
            "https://d1.awsstatic.com/All-Products_64.78a4c2cdfdd82b7abc3fda6b44371491bdf5963e.png",
            "https://d1.awsstatic.com/webteam/product-pages/Product-Page_Standard-Icons_01_Product-Features_SqInk.a8d5666758afc5121b4eb818ae18126031c4b61e.png",
            "https://d1.awsstatic.com/webteam/product-pages/Product-Page_Standard-Icons_02_Sign-Up_SqInk.f43d5ddc9c43883eec6187f34c68155402b13312.png",
            "https://d1.awsstatic.com/webteam/product-pages/Product-Page_Standard-Icons_03_Start-Building_SqInk.6a1ef4429a6604cda9b0857084aa13e2ee4eebca.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "What is Cloud Native, how and why businesses use Cloud Native Applications, and how to use Cloud Native Applications with AWS.",
        "meta_lang": "en",
        "meta_favicon": "https://a0.awsstatic.com/libra-css/images/site/fav/favicon.ico",
        "meta_site_name": "Amazon Web Services, Inc.",
        "canonical_link": "https://aws.amazon.com/what-is/cloud-native/",
        "text": "Organizations gain competitive advantages in various ways when they build cloud-native software applications.\n\nIncrease efficiency\n\nCloud-native development brings along agile practices like DevOps and continuous delivery (CD). Developers use automated tools, cloud services, and modern design culture to build scalable applications rapidly.\n\nReduce cost\n\nBy adopting the cloud-native approach, companies don't have to invest in the procurement and maintenance of costly physical infrastructure. This results in long-term savings in operational expenditure. The cost savings of building cloud-native solutions might also benefit your clients.\n\nEnsure availability\n\nCloud-native technology allows companies to build resilient and highly available applications. Feature updates do not cause downtime and companies can scale up app resources during peak seasons to provide a positive customer experience.\n\nCloud-native applications are software programs that consist of multiple small, interdependent services called microservices. Traditionally, developers built monolithic applications with a single block structure containing all the required functionalities. By using the cloud-native approach, software developers break the functionalities into smaller microservices. This makes cloud-native applications more agile as these microservices work independently and take minimal computing resources to run.\n\nCloud-native applications compared to traditional enterprise applications\n\nTraditional enterprise applications were built using less flexible software development methods. Developers typically worked on a large batch of software functionalities before releasing them for testing. As such, traditional enterprise applications took longer to deploy and were not scalable.\n\nOn the other hand, cloud-native applications use a collaborative approach and are highly scalable on different platforms. Developers use software tools to heavily automate building, testing, and deploying procedures in cloud-native applications. You can set up, deploy, or duplicate microservices in an instant, an action that's not possible with traditional applications.\n\nThe cloud-native architecture combines software components that development teams use to build and run scalable cloud-native applications. The CNCF lists immutable infrastructure, microservices, declarative APIs, containers, and service meshes as the technological blocks of cloud-native architecture.\n\nImmutable infrastructure\n\nImmutable infrastructure means that the servers for hosting cloud-native applications remain unchanged after deployment. If the application requires more computing resources, the old server is discarded, and the app is moved to a new high-performance server. By avoiding manual upgrades, immutable infrastructure makes cloud-native deployment a predictable process.\n\nMicroservices\n\nMicroservices are small, independent software components that collectively perform as complete cloud-native software. Each microservice focuses on a small, specific problem. Microservices are loosely coupled, which means that they are independent software components that communicate with each other. Developers make changes to the application by working on individual microservices. That way, the application continues to function even if one microservice fails.\n\nAPI\n\nApplication Programming Interface (API) is a method that two or more software programs use to exchange information. Cloud-native systems use APIs to bring the loosely coupled microservices together. API tells you what data the microservice wants and what results it can give you, instead of specifying the steps to achieve the outcome.\n\nService mesh\n\nService mesh is a software layer in the cloud infrastructure that manages the communication between multiple microservices. Developers use the service mesh to introduce additional functions without writing new code in the application.\n\nContainers\n\nContainers are the smallest compute unit in a cloud-native application. They are software components that pack the microservice code and other required files in cloud-native systems. By containerizing the microservices, cloud-native applications run independently of the underlying operating system and hardware. This means that software developers can deploy cloud-native applications on premises, on cloud infrastructure, or on hybrid clouds. Developers use containers for packaging the microservices with their respective dependencies, such as the resource files, libraries, and scripts that the main application requires to run.\n\nBenefits of containers\n\nSome benefits of containers include:\n\nYou use fewer computing resources than conventional application deployment\n\nYou can deploy them almost instantly\n\nYou can scale the cloud computing resources your application requires more efficiently\n\nCloud-native application development describes how and where developers build and deploy cloud-native applications. A cultural shift is important for cloud-native development. Developers adopt specific software practices to decrease the software delivery timeline and deliver accurate features that meet changing user expectations. We give some common cloud-native development practices below.\n\nContinuous integration\n\nContinuous integration (CI) is a software practice in which developers integrate changes into a shared code base frequently and without errors. Small, frequent changes make development more efficient because you can identify and troubleshoot issues faster. CI tools automatically assess the code quality for every change so that development teams can add new features with greater confidence.\n\nContinuous delivery\n\nContinuous delivery (CD) is a software practice that supports cloud-native development. With CD, development teams ensure that the microservices are always ready to be deployed to the cloud. They use software automation tools to reduce risk when making changes, such as introducing new features and fixing bugs on applications. CI and CD work together for efficient software delivery.\n\nDevOps\n\nDevOps is a software culture that improves the collaboration of development and operations teams. It is a design philosophy that aligns with the cloud-native model. DevOps practices allow organizations to speed up the software development lifecycle. Developers and operation engineers use DevOps tools to automate cloud-native development.\n\nServerless\n\nServerless computing is a cloud-native model where the cloud provider fully manages the underlying server infrastructure. Developers use serverless computing because the cloud infrastructure automatically scales and configures to meet application requirements. Developers only pay for the resources the application uses. The serverless architecture automatically removes compute resources when the app stops running.\n\nFaster development\n\nDevelopers use the cloud-native approach to reduce development time and achieve better quality applications. Instead of relying on specific hardware infrastructure, developers build ready-to-deploy containerized applications with DevOps practices. This allows developers to respond to changes quickly. For example, they can make several daily updates without shutting down the app.\n\nPlatform independence\n\nBy building and deploying applications in the cloud, developers are assured of the consistency and reliability of the operating environment. They don't have to worry about hardware incompatibility because the cloud provider takes care of it. Therefore, developers can focus on delivering values in the app instead of setting up the underlying infrastructure.\n\nCost-effective operations\n\nYou only pay for the resources your application actually uses. For example, if your user traffic spikes only during certain times of the year, you pay additional charges only for that time period. You do not have to provision extra resources that sit idle for most of the year.\n\nCloud-native stack describes the layers of cloud-native technologies that developers use to build, manage, and run cloud-native applications. They are categorized as follows.\n\nInfrastructure layer\n\nThe infrastructure layer is the foundation of the cloud-native stack. It consists of operating systems, storage, network, and other computing resources managed by third-party cloud providers.\n\nProvisioning layer\n\nThe provisioning layer consists of cloud services that allocate and configure the cloud environment.\n\nRuntime layer\n\nThe runtime layer provides cloud-native technologies for containers to function. This comprises cloud data storage, networking capability, and a container runtime such as containerd.\n\nOrchestration and management layer\n\nOrchestration and management are responsible for integrating the various cloud components so that they function as a single unit. It is similar to how an operating system works in traditional computing. Developers use orchestration tools like Kubernetes to deploy, manage, and scale cloud applications on different machines.\n\nApplication definition and development layer\n\nThis cloud-native stack layer consists of software technologies for building cloud-native applications. For example, developers use cloud technologies like database, messaging, container images, and continuous integration (CI) and continuous delivery (CD) tools to build cloud applications.\n\nObservability and analysis tools\n\nObservability and analysis tools monitor, evaluate, and improve the system health of cloud applications. Developers use tools to monitor metrics like CPU usage, memory, and latency to ensure there is no disruption to the app's service quality."
    }
}