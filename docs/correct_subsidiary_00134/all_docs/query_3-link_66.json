{
    "id": "correct_subsidiary_00134_3",
    "rank": 66,
    "data": {
        "url": "https://www.everand.com/book/253047129/Oracle-Coherence-3-5",
        "read_more_link": "",
        "language": "en",
        "title": "Oracle Coherence 3.5 by Aleksandar Seovic, Mark Falco, Patrick Peralta (Ebook)",
        "top_image": "https://imgv2-2-f.scribdassets.com/img/word_document/253047129/original/2e40593a6f/1721910411?v=1",
        "meta_img": "https://imgv2-2-f.scribdassets.com/img/word_document/253047129/original/2e40593a6f/1721910411?v=1",
        "images": [
            "https://s-f.scribdassets.com/webpack/assets/images/content_preview/everand_subscription_banner/evarand_eng_desktop_1x.f0d8b73f.png",
            "https://imgv2-2-f.scribdassets.com/img/audiobook_square/418587313/76x76/a8e1925a29/1721837863?v=1",
            "https://imgv2-2-f.scribdassets.com/img/audiobook_square/378766866/76x76/37b7f7ac2e/1721837736?v=1",
            "https://imgv2-2-f.scribdassets.com/img/audiobook_square/459116359/76x76/03996619e3/1721687928?v=1",
            "https://imgv2-1-f.scribdassets.com/img/audiobook_square/402593935/76x76/075dbb7706/1721688081?v=1",
            "https://imgv2-2-f.scribdassets.com/img/word_document/282487335/76x76/28f80f1a99/1721836974?v=1",
            "https://imgv2-1-f.scribdassets.com/img/audiobook_square/413916178/76x76/ff6d1bde57/1721837683?v=1"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Aleksandar Seovic"
        ],
        "publish_date": "2010-03-30T00:00:00",
        "summary": "",
        "meta_description": "Read Oracle Coherence 3.5 by Aleksandar Seovic,Mark Falco,Patrick Peralta with a free trial. Read millions of eBooks and audiobooks on the web, iPad, iPhone and Android.",
        "meta_lang": "en",
        "meta_favicon": "https://s-f.scribdassets.com/everand.ico?a248c1029?v=5",
        "meta_site_name": "Everand",
        "canonical_link": "https://www.everand.com/book/253047129/Oracle-Coherence-3-5",
        "text": "Table of Contents\n\nOracle Coherence 3.5\n\nCredits\n\nForeword\n\nA word about the author\n\nAbout the author\n\nAcknowledgements\n\nAbout the co-authors\n\nAbout the reviewers\n\nPreface\n\nIntroducing Oracle Coherence\n\nDistributed caching\n\nDistributed queries\n\nIn-place and parallel processing\n\nCache events\n\nCoherence within the Oracle ecosystem\n\nCoherence usage scenarios\n\nOracle Coherence editions\n\nWhat this book covers\n\nWhat you need for this book\n\nWho this book is for\n\nWho this book is not for\n\nConventions\n\nReader feedback\n\nCustomer support\n\nErrata\n\nPiracy\n\nQuestions\n\n1. Achieving Performance, Scalability, and Availability Objectives\n\nAchieving performance objectives\n\nDealing with latency\n\nMinimizing bandwidth usage\n\nCoherence and performance\n\nAchieving scalability\n\nStateless services do not exist\n\nScaling a database is hard\n\nDatabase scale-out approaches\n\nMaster-slave replication\n\nDatabase clustering\n\nDatabase sharding\n\nReturn of the state\n\nUsing Coherence to reduce database load\n\nCoherence and master-slave databases\n\nCoherence and database clusters\n\nCoherence and database sharding\n\nCoherence and scalability\n\nAchieving high availability\n\nAdding redundancy to the system\n\nRedundancy is not enough\n\nCoherence and availability\n\nPutting it all together\n\nDesign for performance and scalability\n\nSet performance goals at each level\n\nMeasure and monitor\n\nEducate your team\n\nSummary\n\n2. Getting Started\n\nInstalling Coherence\n\nWhat's in the box?\n\nStarting up the Coherence cluster\n\nTroubleshooting cluster start-up\n\nMulticast issues\n\nBinding issues\n\nAccessing the data grid\n\nCoherence console\n\nCreating caches\n\nWorking with the cache\n\nConfiguring the development environment\n\nReferencing necessary JAR files\n\nEnabling IntelliSense for configuration files\n\nStarting Coherence nodes within the IDE\n\nCreating a private cluster\n\nConfiguring Coherence\n\nOperational configuration\n\nConfiguring logging\n\nConfiguring a private cluster\n\nUsing the Coherence API\n\nThe basics: NamedCache and CacheFactory\n\nThe Hello World example\n\nCoherence API in action: Implementing the cache loader\n\nLoader design\n\nImplementing CsvSource\n\nImplementing CoherenceTarget\n\nTesting the Cache loader\n\nTesting and debugging Coherence applications\n\nSummary\n\n3. Planning Your Caches\n\nAnatomy of a clustered cache\n\nClustered cache topologies\n\nReplicated Cache service\n\nRead performance\n\nWrite performance\n\nData set size\n\nCoherence node size on modern JVMs\n\nFault tolerance\n\nWhen to use it?\n\nPartitioned Cache service\n\nRead performance\n\nWrite performance\n\nData set size\n\nFault tolerance\n\nWhen to use it?\n\nNear cache\n\nNear cache invalidation strategies\n\nNone\n\nPresent\n\nAll\n\nAuto\n\nWhen to use it?\n\nContinuous Query Cache\n\nBacking maps\n\nLocal cache\n\nExternal backing map\n\nPaged external backing map\n\nOverflow backing map\n\nRead-write backing map\n\nPartitioned backing map\n\nCache configuration\n\nCaching schemes\n\nDistributed cache scheme\n\nLocal cache scheme\n\nNear cache scheme\n\nRead-write backing map scheme\n\nPartitioned backing map\n\nPartitioned read-write backing map\n\nCache mappings\n\nSample cache configuration\n\nSummary\n\n4. Implementing Domain Objects\n\nIntroducing the Coherent Bank sample application\n\nCoherent Bank requirements\n\nCoherent Bank domain model\n\nDomain model building blocks\n\nEntities and aggregates\n\nImplementing entities\n\nIdentity management\n\nCreating entity instances\n\nManaging entity relationships\n\nDealing with dependencies\n\nSpecifying data affinity\n\nValue objects\n\nImplementing the Money value object\n\nValue objects as identifiers\n\nServices\n\nImplementing the CurrencyConverter service\n\nFactories\n\nRepositories\n\nImplementing object serialization\n\nPOF basics\n\nPOF context\n\nConfigurablePofContext\n\nImplementing serialization code\n\nPortableObject or PofSerializer?\n\nCollection serialization with POF\n\nAdding support for schema evolution\n\nImplementing Evolvable objects\n\nImplementing serialization for Evolvable objects\n\nSummary\n\n5. Querying the Data Grid\n\nBuilt-in filters\n\nValue extractors\n\nReflection extractor\n\nOther built-in value extractors\n\nIdentityExtractor\n\nChainedExtractor and MultiExtractor\n\nPofExtractor\n\nImplementing a custom value extractor\n\nSimplifying Coherence queries\n\nFilter builder\n\nObtaining query results\n\nControlling query scope using data affinity\n\nQuerying near cache\n\nSorting the results\n\nPaging over query results\n\nUsing indexes to improve query performance\n\nAnatomy of an Index\n\nCreating indexes\n\nCoherence query limitations\n\nAggregators\n\nBuilt-in aggregators\n\nUsing aggregators\n\nImplementing LookupValuesAggregator\n\nSummary\n\n6. Parallel and In-Place Processing\n\nEntry processors\n\nIn-place processing\n\nImplementing WithdrawalProcessor\n\nCache service re-entrancy\n\nAccessing the backing map directly\n\nBuilt-in entry processors\n\nVersionedPut and VersionedPutAll\n\nPriorityProcessor\n\nExtractorProcessor\n\nUpdaterProcessor\n\nInvocation service\n\nConfiguring the invocation service\n\nImplementing agents\n\nExecuting agents\n\nCommonJ Work Manager\n\nWork Manager API basics\n\nDefining work\n\nScheduling work\n\nProcessing the results\n\nCoherence Work Manager limitations\n\nCoherence Incubator\n\nSummary\n\n7. Processing Data Grid Events\n\nCache events\n\nRegistering map listeners\n\nProgrammatic listener registration\n\nListening to specific events\n\nListening for specific property changes\n\nTransforming map events\n\nRegistering listeners within the cache configuration file\n\nMaking any map observable\n\nBacking map events\n\nImplementing a low-balance listener\n\nAbstractBackingMapListener\n\nLow-balance listener\n\nRegistering a backing map listener\n\nMap triggers\n\nUsing map triggers for data validation\n\nData validation framework\n\nImplementing validation trigger\n\nRegistering map triggers\n\nContinuous query cache\n\nObserving a continuous query cache\n\nUsing a continuous query cache as a substitute for a replicated cache\n\nSummary\n\n8. Implementing the Persistence Layer\n\nCache aside\n\nRead-through caching\n\nImplementing read through\n\nIntroducing the read-write backing map\n\nUsing Spring Framework with a read-write backing map\n\nRefresh ahead\n\nUsing refresh ahead to pre-fetch exchange rates\n\nAdditional considerations\n\nWrite through\n\nWrite behind\n\nUsing write behind for accounts and transactions\n\nWrite behind and storeAll\n\nHandling write-through/write-behind failures\n\nCluster member failures\n\nStore failures\n\nWrite behind and eviction\n\nWrite behind and deletes\n\nConfiguring backup with a read-write backing map\n\nBackup with read through\n\nBackup with write behind\n\nBuilt-in CacheStore implementations\n\nUsing the Coherence JPA CacheStore\n\nSummary\n\n9. Bridging Platform and Network Boundaries\n\nCoherence networking\n\nCoherence*Extend overview\n\nConfiguring Coherence*Extend\n\nConfiguring proxy servers\n\nConfiguring clients\n\nConfiguring remote cache scheme\n\nMapping cache names to caches\n\nConfiguring a remote invocation service\n\nAddress providers\n\nHandling connection or proxy server failure\n\nCoherence*Extend limitations\n\nExplicit concurrency control\n\nExecuting invocable agents via Coherence*Extend\n\nSecuring proxy servers\n\nUsing network filters\n\nBuilt-in network filters\n\nCompression filter\n\nSymmetric encryption filter\n\nImplementing a custom network filter\n\nSummary\n\n10. Accessing Coherence from .NET\n\n.NET client configuration\n\nCoherence configuration files in .NET\n\nOperational descriptor\n\nCache configuration\n\nPOF configuration\n\nResource loading in Coherence for .NET\n\nResource abstraction\n\nProtocols and resource loader\n\nApproaches to .NET client configuration\n\nConvention-based configuration\n\nExplicit configuration\n\nProgrammatic configuration\n\nImplementing the client application\n\nBasic Cache Operations\n\nImplementing data objects\n\nImplementing the IPortableObject interface\n\nImplementing the external serializer\n\nExecuting queries\n\nImplementing filters and value extractors\n\nImplementing PropertyExtractor in C#\n\nExecuting the aggregators and entry processors\n\nListening for cache events\n\nCache listeners\n\nEvent marshalling in Windows Forms applications\n\nContinuous Query Cache\n\nData binding with Windows Presentation Foundation (WPF)\n\nSummary\n\n11. Accessing Coherence from C++\n\nConfiguring Coherence C++\n\nManaged object model\n\nHandles, Views, and Holders\n\nManaged object creation\n\nCasting and type checking\n\nHandling exceptions\n\nClass hierarchy namespaces\n\nImplementing a Coherence C++ client application\n\nImplementing Cacheable C++ Data Objects\n\nManaged adapter\n\nData object serialization\n\nImplementing managed classes\n\nUnderstanding specifications\n\nFactory methods\n\nMember variables\n\nImplementing constructors\n\nImplementing methods\n\nImplementing the PortableObject interface\n\nImplementing external serializer\n\nExecuting queries\n\nValue extractors\n\nExtracting values from locally cached objects\n\nPofExtractor\n\nImplementing PropertyExtractor in C++\n\nFilters\n\nPerforming a query in C++\n\nExecuting aggregators and entry processors\n\nImplementing DepositProcessor in C++\n\nListening for cache events\n\nCache listeners\n\nStandard type integration\n\nSummary\n\n12. The Right Tool for the Job\n\nA. Coherent Bank Sample Application\n\nPrerequisites\n\nSun Java JDK 1.6\n\nMicrosoft Visual Studio 2008\n\nOracle Coherence 3.5.3\n\nAnt 1.7+\n\nNAnt 0.86\n\nInstallation\n\nDeploying the Java Application\n\nDeploying the C++ Application\n\nDeploying the .NET Application\n\nShutting everything down\n\nReview the code\n\nIndex\n\nOracle Coherence 3.5\n\nAleksandar Seović\n\nMark Falco\n\nPatrick Peralta\n\nOracle Coherence 3.5\n\nCopyright © 2010 Packt Publishing\n\nAll rights reserved. No part of this book may be reproduced, stored in a retrieval system, or transmitted in any form or by any means, without the prior written permission of the publisher, except in the case of brief quotations embedded in critical articles or reviews.\n\nEvery effort has been made in the preparation of this book to ensure the accuracy of the information presented. However, the information contained in this book is sold without warranty, either express or implied. Neither the authors, Packt Publishing, nor its dealers or distributors will be held liable for any damages caused or alleged to be caused directly or indirectly by this book.\n\nPackt Publishing has endeavored to provide trademark information about all the companies and products mentioned in this book by the appropriate use of capitals. However, Packt Publishing cannot guarantee the accuracy of this information.\n\nFirst published: April 2010\n\nProduction Reference: 1240310\n\nPublished by Packt Publishing Ltd.\n\n32 Lincoln Road\n\nOlton\n\nBirmingham, B27 6PA, UK.\n\nISBN 978-1-847196-12-5\n\nwww.packtpub.com\n\nCover Image by Vinayak Chittar (<vinayak.chittar@gmail.com>)\n\nCredits\n\nAuthors\n\nAleksandar Seović\n\nMark Falco\n\nPatrick Peralta\n\nReviewers\n\nRob Harrop\n\nJimmy Nilsson\n\nPatrick Peralta\n\nSteve Samuelson\n\nRobert Varga\n\nAcquisition Editor\n\nJames Lumsden\n\nDevelopment Editor\n\nDilip Venkatesh\n\nTechnical Editor\n\nArani Roy\n\nIndexer\n\nRekha Nair\n\nEditorial Team Leader\n\nMithun Sehgal\n\nProject Team Leader\n\nLata Basantani\n\nProject Coordinator\n\nSrimoyee Ghoshal\n\nProofreader\n\nChris Smith\n\nGraphics\n\nGeetanjali Sawant\n\nProduction Coordinator\n\nShantanu Zagade\n\nCover Work\n\nShantanu Zagade\n\nForeword\n\nThere are a few timeless truths of software development that are near-universally accepted, and have become the basis for many a witty saying over the years. For starters, there's Zymurgy's First Law of Evolving Systems Dynamics, which states:\n\nOnce you open a can of worms, the only way to re-can them is to use a bigger can.\n\nAnd Weinberg's Second Law, which postulates that,\n\nIf builders built buildings the way that programmers wrote programs, the first woodpecker to come along would destroy civilization.\n\nThere is true brilliance in this timeless wit, enjoyed and appreciated by generation after generation of software developers.\n\nThe largest set of challenges that the modern programmer faces, and thus the source of most of the wit that we as programmers revel in, revolves around the seemingly boundless growth of complexity. Hardware becomes more complex. Operating systems become more complex. Programming languages and APIs become more complex. And the applications that we build and evolve, become more and more complex.\n\nThe complexity of a system always seems to hover ever so slightly on the far side of manageable, just slightly over the edge of the cliff. And while our work reality is a world full of complexity—or perhaps because of that complexity—we gravitate toward the pristine and the simple. While our day-to-day lives may be focused on diagnosing failures in production systems, our guiding light is the concept of continuous availability. While we may have to manually correct data when things go wrong, our aspirations remain with data integrity and information reliability. While the complexity of the legacy applications that we manage forces us to adopt the most expensive means of adding capacity, our higher thoughts are focused on commodity scale-out and linear scalability. And while the complex, layered, and often twisted system designs result in hopelessly slow responses to user actions, we fundamentally believe that users should experience near-instant responses for almost any conceivable action they take.\n\nIn a word, we believe in the ilities.\n\nAvailability. Reliability. Scalability. Performance. These are attributes that we wish to endow each and every one of our systems with. If a system lacks continuous availability, its users will be directly impacted by failures within the system. If a system lacks information reliability, then users will never know if the information they are using can be trusted. If a system lacks scalability, its growing popularity will overwhelm and kill it—it will fail just as it begins to succeed! If a system lacks performance, it will inflict a dose of pain upon its users with each and every interaction.\n\nWe wish to achieve these ilities because we wish for our labors to be beneficial to others, and we hope that the value that we provide through these systems endures far longer than the passing whims and fads of technology and industry.\n\nPerhaps no greater revolution has occurred in our industry than the World Wide Web. Suddenly, the systems we provide had a limitless audience, with instant access to the latest and greatest versions of our software. Users are so accustomed to instant responses from one application that failure to achieve the same will cause them to quickly abandon another. Downtime no longer represents an inconvenience—for major websites, their online foibles have become headline news on the printed pages of the Wall Street Journal!\n\nAt the same time, the competitive landscape has forced companies, and thus their IT departments, to act and react far more quickly than before. The instant popularity of a particular good, service, or website can bring mind-boggling hordes of unexpected—though generally not undesired—users. Companies must be able to roll out new features and capabilities quickly, to grow their capacity dynamically in order to match the increase in users, and to provide instantaneous responsiveness with correct and up-to-date information to each and every user.\n\nThese are the systems that Oracle Coherence was designed to enable. These are the systems that this book will help you build.\n\nIf there was only one piece of advice that I could instill into the mind of a software architect or developer responsible for one of these systems, it would be this: architecture matters, and in systems of scale and systems that require availability, architecture matters absolutely! Failure to achieve a solid architecture will doom in advance any hope of significant scalability, and will leave the effects of failure within the system to pure chance.\n\nNo amount of brilliant programming can make up for a lack of architectural foresight. Systems do not remain available by accident, nor do they scale by accident. Achieving information reliability in a system that remains continuously available and provides high performance under varying degrees of load and scale is an outcome that results only when a systematic and well-conceived architecture has been laid down. Availability, reliability, scalability, and performance must be the core tenets of an architecture, and they must be baked into and throughout that architecture.\n\nIf there were a second piece of advice that I could confer, it would be this: as a craftsman or craftswoman, know your tools, and know them well. Using Oracle Coherence as part of a system does not ensure any of the ilities by itself; it is simply a powerful tool for simultaneously achieving those ilities as part of a great architecture. This book is an effort to condense a huge amount of experience and knowledge into a medium of transfer that you can rehydrate into instant knowledge for yourself.\n\nAnd the last piece of advice is this: don't believe it until you see it; make sure that you push it until it fails. While testing, if you don't overload the system until it breaks, then you can't be certain that it will work. If you don't pull the plug while it's running, then you can't be certain that it will handle failure when it truly matters. Don't be satisfied until you understand the limits of your systems, and until you appreciate and understand what lies beyond those boundaries.\n\nA word about the author\n\nI first met Aleks Seović in 2005. I was attending the Javapolis (now Devoxx) conference in Antwerp with the express purpose of persuading Aleks to create the .NET implementation of Coherence. I had known of him through his work in creating the Spring.NET framework, and knew that there was only one person whom I wanted to lead the creation of our own product for .NET. As they say, the rest is history: We hit it off smashingly, and found a great deal of common ground in our experiences with enterprise systems, the challenges of distributed computing, architecting for scalable performance and high availability, and the need for seamless and reliable information exchange between Java and .NET applications.\n\nAleks has such a great ability to understand complex systems, and such a compelling manner of reducing complexity into simple concepts, that I was ecstatic when he told me that he was writing this book. Starting a book is no challenge at all, but finishing a book is a great feat. Many years of work have gone into these pages. May you enjoy and profit from this book as deeply as I have enjoyed and profited from my conversations with Aleks over these past years.\n\nCameron Purdy\n\nLexington, MA\n\nJanuary 2010\n\nAbout the author\n\nAleksandar Seović is the founder of and managing director at S4HC, Inc., where he leads professional services practice. He works with customers throughout the world to help them solve performance and scalability puzzles and implement innovative solutions to complex business and technical problems.\n\nAleksandar lead the implementation of Oracle Coherence for .NET, a client library that allows applications written in any .NET language to access data and services provided by an Oracle Coherence data grid. He was also one of the key people involved in the design and implementation of Portable Object Format (POF), a platform-independent object serialization format that allows seamless interoperability of Coherence-based Java, .NET, and C++ applications.\n\nAleksandar is Oracle ACE Director for Fusion Middleware, and frequently speaks about and evangelizes Coherence at conferences, Java and .NET user group events, and Coherence SIGs. He blogs about Coherence and related topics at http://coherence.seovic.com.\n\nAcknowledgements\n\nFirst and foremost, I'd like to thank Cameron Purdy and Alex Gleyzer for giving me the opportunity to work on Coherence. It has been quite a journey—I still remember the day when we got a .NET application to connect to the cluster for the first time. Guys, it has been a privilege working with you all these years to make a great product even better.\n\nI've heard many times that a book is never a single person's creation. Only now, after I have written one myself, I truly understand what that means.\n\nI cannot thank enough my co-authors, Mark Falco and Patrick Peralta, members of the Coherence engineering team, who contributed two great chapters to the book. Patrick's chapter covers pretty much everything you need to know in order to integrate Coherence with persistent data sources. As for Mark's chapter on using the Coherence C++ client, well, let's just say that I would've had a really hard time writing that one myself.\n\nThe sample application for the book is the result of the hard work of my colleagues from Solutions for Human Capital: Ivan Cikić, Nenad Dobrilović, Marko Dumić, and Aleksandar Jević. They managed to deliver (once again) on a very tight schedule, and I am very proud of the final result. Thank you for all the help and for putting up with my last minute change requests—I know it wasn't easy at times, but you have done a wonderful job.\n\nI can honestly say (and everyone who saw the first draft is my witness) that this book was significantly improved based on the feedback from many reviewers. The official reviewers for the book were Rob Harrop, Jimmy Nilsson, Patrick Peralta, Steve Samuelson, and Robert Varga, but Mark Falco, Cameron Purdy, Cristobal Soto, Phil Wheeler, and Andrew Wilson also provided invaluable feedback. Jimmy, it is mostly your fault that there is a sample application now demonstrating (among other things) how to build a clean, testable domain model that works well with Coherence.\n\nMany members of Coherence engineering and Oracle's Architecture team were only an e-mail or phone call away when I had questions: Noah Arliss, Simon Bisson, Gene Gleyzer, Jason Howes, Rob Misek, Andy Nguyen, Brian Oliver, Jon Purdy, and Randy Stafford all helped at one point or another, whether they know it or not. Thank you for that, and thank you for building such a great product.\n\nJames Lumsden, Dilip Venkatesh, Rajashree Hamine, and Srimoyee Ghoshal from Packt Publishing provided necessary support when I needed it and helped me reach the finish line. James, I know the journey was much longer than either of us expected. Thank you for believing in me even when I didn't.\n\nMy partners at Solutions for Human Capital, Snejana Sevak, Aleksandar Jević, and Nebojša Peruničić, helped more than they realize by shielding me from the daily disturbances of running a business and allowing me to focus my energy on writing, and I thank them for that.\n\nI would also like to thank all the clients and colleagues I worked with over the years. I learned something new from each one of you, and for that I am grateful.\n\nMost importantly, I would like to thank my family. My wife Marija supported me from the moment I decided to work on this book, even though she knew that my already busy schedule would only get busier because of it. People who think astronauts' wives have it rough have never met the wife of a traveling geek who decides to write a book. Хвала, љубави.\n\nTo my children, Ana Maria and Novak, I am sorry I couldn't play with you as much as we all wanted, and promise to make it up to you. You are too young to understand why daddy was sleeping during the day and working at night, but that doesn't matter now. Daddy is back and loves you both very much!\n\nAbout the co-authors\n\nMark Falco is a Consulting Member of Technical Staff at Oracle. He has been part of the Coherence development team since 2005 where he has specialized in the areas of clustered communication protocols as well as the Coherence for C++ object model. Mark holds a B.S. in computer science from Stevens Institute of Technology.\n\nI would like to thank Aleks for the opportunity to contribute to this book and Tangosol for the years of fun and interesting work. Thank you Otti, Erika, and Mia for your encouragement and support.\n\nPatrick Peralta is a Senior Software Engineer for Oracle (formerly Tangosol) specializing in Coherence and middleware Java. He wears many hats in Coherence engineering, including development, training, documentation, and support. He has extensive experience in supporting and consulting customers in fields such as retail, hospitality, and finance.\n\nAs an active member of the Java developer community he has spoken at user groups and conferences across the US including Spring One and Oracle Open World. Prior to joining Oracle, Patrick was a senior developer at Symantec, working on Java/J2EE based services, web applications, system integrations, and Swing desktop clients. Patrick has a B.S. in computer science from Stetson University in Florida.\n\nHe currently maintains a blog on Coherence and other software development topics at http://blackbeanbag.net.\n\nI would like to express my appreciation and gratitude to those that provided valuable feedback, including Aleks Seović, Gene Gleyzer, Andy Nguyen, Pas Apicella, and Shaun Smith. Many thanks as well to my family, including my parents, siblings, and especially my wonderful wife Maria and son Isaac for providing me with joy and perspective on what is truly important in life.\n\nAbout the reviewers\n\nRob Harrop is a respected speaker, author, entrepreneur, and technologist.\n\nAs Lead Engineer of SpringSource dm Server, Rob is driving SpringSource's enterprise middleware product line and ensuring that the company continues to deliver high-performance, highly scalable enterprise solutions.\n\nWith a thorough knowledge of both Java and .NET, Rob has successfully deployed projects across both platforms. He has extensive experience across a variety of sectors, in particular banking, retail, and government. Prior to joining SpringSource, he co-founded the UK-based software company Cake Solutions Limited and worked as a Lead Developer for a successful dotcom start-up.\n\nRob is the author of five books, including Pro Spring, a widely acclaimed, comprehensive resource on the Spring Framework.\n\nJimmy Nilsson has been working as a developer/architect for over 20 years.\n\nHe has authored Applying Domain-Driven Design and Patterns and .NET Enterprise Design.\n\nSteve Samuelson has worked in IT for over 20 years across various industries including home building, finance, and education. Although experienced with Windows deployment and hardware, Steve prefers custom software development. Currently, Steve is the Chief Architect for an international education provider where he works with multiple technologies running under Unix and Windows. Steve's primary interest lies in Microsoft .NET development and tools, but he makes sure to keep up on emerging Java and Oracle technologies among others.\n\nRobert Varga is a Lead Software Engineer at EPAM Systems. He has worked in various roles from Developer to Enterprise Architect on several large projects for various customers, mostly in the areas of insurance, online betting, online auctions, and finance. He is also an Oracle ACE since 2008.\n\nRobert has worked on Java-based enterprise systems since 1998 and on various projects with the Coherence data grid since 2005. He is among the most active contributors to the Oracle Coherence support forums helping developers with questions about Oracle Coherence.\n\nPreface\n\nAs an architect of a large, mission-critical website or enterprise application, you need to address at least three major non-functional requirements: performance, scalability, and availability.\n\nPerformance is defined as the amount of time that an operation takes to complete. In a web application, it is usually measured as time to last byte (TTLB)—the amount of time elapsed from the moment the web server received a request, until the moment the last byte of response has been sent back to the client. Performance is extremely important, because experience has shown us that no matter how great and full-featured an application is, if it is slow and unresponsive, the users will hate it.\n\nScalability is the ability of the system to maintain acceptable performance as the load increases, or to support additional load by adding hardware resources. While it is relatively simple to make an application perform well in a single-user environment, it is significantly more difficult to maintain that level of performance as the number of simultaneous users increases to thousands, or in the case of very large public websites, to tens or even hundreds of thousands. The bottom line is, if your application doesn't scale well, its performance will degrade as the load increases and the users will hate it.\n\nFinally, availability is measured as the percentage of time an application is available to the users. While some applications can crash several times a day without causing major inconvenience to the user, most mission-critical applications simply cannot afford that luxury and need to be available 24 hours a day, every day. If your application is mission critical, you need to ensure that it is highly available or the users will hate it. To make things even worse, if you build an e-commerce website that crashes during the holiday season, your investors will hate you as well.\n\nThe moral of the story is that in order to keep your users happy and avoid all that hatred, you as an architect need to ensure that your application is fast, remains fast even under heavy load, and stays up and running even when the hardware or software components that it depends on fail. Unfortunately, while it is relatively easy to satisfy any one of these three requirements individually and not too difficult to comply with any two of them, it is considerably more difficult to fulfill all three at the same time.\n\nIntroducing Oracle Coherence\n\nOver the last few years, In-Memory Data Grids have become an increasingly popular way to solve many of the problems related to performance and scalability, while improving availability of the system at the same time.\n\nOracle Coherence is an In-Memory Data Grid that allows you to eliminate single points of failure and single points of bottleneck in your application by distributing your application's objects and related processing across multiple physical servers.\n\nThere are several important points in the definition above:\n\nCoherence manages application objects, which are ready for use within the application. This eliminates the need for repeated, and often expensive, loading and transformation of the raw data into objects.\n\nCoherence distributes application objects across many physical servers while ensuring that a coherent, Single System Image (SSI) is presented to the application.\n\nCoherence ensures that no data or in-flight operations are lost by assuming that any node could fail at any time and by ensuring that every piece of information is stored in multiple places.\n\nCoherence stores data in memory in order to achieve very high performance and low latency for data access.\n\nCoherence allows you to distribute not only application objects, but also the processing that should be performed on these objects. This can help you eliminate single points of bottleneck.\n\nThe following sections provide a high-level overview of Coherence features; the remainder of the book will teach you how, and more importantly, when to use them.\n\nDistributed caching\n\nOne of the easiest ways to improve application performance is to bring data closer to the application, and keep it in a format that the application can consume more easily.\n\nMost enterprise applications are written in one of the object-oriented languages, such as Java or C#, while most data is stored in relational databases, such as Oracle, MySql or SQL Server. This means that in order to use the data, the application needs to load it from the database and convert it into objects. Because of the impedance mismatch between tabular data in the database and objects in memory, this conversion process is not always simple and introduces some overhead, even when sophisticated O-R mapping tools, such as Hibernate or EclipseLink are used.\n\nCaching objects in the application tier minimizes this performance overhead by avoiding unnecessary trips to the database and data conversion. This is why all production-quality O-R mapping tools cache objects internally and short-circuit object lookups by returning cached instances instead, whenever possible.\n\nHowever, when you scale out your application across multiple servers, you will start running into cache synchronization issues. Each server will cache its own copy of the data, and will have no way of knowing if that same data has been changed on another server—in this case, the locally cached copy should be invalidated and evicted from the cache.\n\nOracle Coherence solves this problem by allowing you to distribute your cache across a cluster of machines, while providing a unified, fully coherent view of the data. This means that you can configure Coherence as an L2 cache for Hibernate or EclipseLink, and forget about distributed cache synchronization!\n\nIf this was all Coherence did, it would be impressive enough. However, it actually does so much more that I don't recommend using it purely as an L2 cache, unless you have an existing application that you need to scale out. While Coherence works like a charm as an L2 cache behind an O-R mapper, this architecture barely scratches the surface of what Coherence can do. It is like killing an ox for a pound of meat, as the Serbian proverb says.\n\nIt is much more powerful to use Coherence as a logical persistence layer of your application, which sits between the application logic and the physical data store. Whenever the application needs data, it asks Coherence for it. If the data is not already in the cache, Coherence will transparently load it from the data store, cache it, and return it to the application. Similarly, when the application needs to store data, it simply puts objects into the cache, and Coherence updates the underlying data store automatically.\n\nThis architecture is depicted in the following diagram and is the basis for the architecture we will use throughout the book:\n\nAlthough Coherence is not really a persistent store in the preceding scenario, the fact that the application thinks that it is decouples the application from the data store and enables you to achieve very high scalability and availability. You can even configure Coherence so the application will be isolated from a complete data store failure.\n\nDistributed queries\n\nHaving all the data in the world is meaningless unless there is a way to find the information you need, when you need it. One of the many advantages of In-Memory Data Grids over clustered caches, such as Memcached, is the ability to find data not just by the primary key, but also by executing queries and aggregations against the cache.\n\nCoherence is no exception—it allows you to execute queries and aggregations in parallel, across all the nodes in the cluster. This allows for the efficient processing of large data sets within the grid and enables you to improve aggregation and query performance by simply adding more nodes to the cluster.\n\nIn-place and parallel processing\n\nIn many situations, you can improve performance enormously if you perform the processing where the data is stored, instead of retrieving the data that needs to be processed. For example, while working with a relational database, you can use bulk update or a stored procedure to update many records without moving any data across the network.\n\nCoherence allows you to achieve the same thing. Instead of retrieving the whole dataset that needs to be processed and iterating over it on a single machine, you can create an entry processor—a class that encapsulates the logic you want to execute for each object in a target dataset. You can then submit an instance of the processor into the cluster, and it will be executed locally on each node. By doing so, you eliminate the need to move a large amount of data across the network. The entry processor itself is typically very small and allows processing to occur in parallel.\n\nThe performance benefit of this approach is tremendous. Entry processors, just like distributed queries, execute in parallel across grid nodes. This allows you to improve performance by simply spreading your data across more nodes.\n\nCoherence also provides a grid-enabled implementation of CommonJ Work Manager, which is the basis for JSR-237. This allows you to submit a collection of work items that Coherence will execute in parallel across the grid. Again, the more nodes you have in the grid, the more work items can be executed in parallel, thereby improving the overall performance.\n\nCache events\n\nIn many applications, it is useful to know when a particular piece of data changes. For example, you might need to update a stock price on the screen as it changes, or alert the user if a new workflow task is assigned to them.\n\nThe easiest and the most common solution is to periodically poll the server to see if the information on the client needs to be updated. This is essentially what Outlook does when it checks for new e-mail on the POP3 mail server, and you (the user) control how often the polling should happen.\n\nThe problem with polling is that the more frequently it occurs, the more load it puts on the server, decreasing its scalability, even if there is no new information to be retrieved.\n\nOn the other hand, if the server knows which information you are interested in, it can push that information to you. This is how Outlook works with Exchange Server—when the new mail arrives, the Exchange Server notifies Outlook about this event, and Outlook displays the new message in your inbox.\n\nCoherence allows you to register interest in a specific cache, a specific item, or even a specific subset of the data within the cache using a query. You can specify if you are interested in cache insertions, updates or deletions only, as well as whether you would like to receive the old and the new cache value with the event.\n\nAs the events occur in the cluster, your application is notified and can take the appropriate action, without the need to poll the server.\n\nCoherence within the Oracle ecosystem\n\nIf you look at Oracle marketing material, you will find out that Coherence is a member of the Oracle Fusion Middleware product suite. However, if you dig a bit deeper, you will find out that it is not just another product in the suite, but a foundation for some of the high-profile initiatives that have been announced by Oracle, such as Oracle WebLogic Application Grid and Complex Event Processing.\n\nCoherence is also the underpinning of the SOA grid—a next-generation SOA platform that David Chappell, vice president and chief technologist for SOA at Oracle, wrote about for The SOA Magazine [SOAGrid1&2].\n\nI believe that over the next few years, we will see Coherence being used more and more as an enabling technology within various Oracle products, because it provides an excellent foundation for fast, scalable, and highly-available solutions.\n\nCoherence usage scenarios"
    }
}