{
    "id": "correct_subsidiary_00134_3",
    "rank": 79,
    "data": {
        "url": "https://dokumen.pub/implementing-domain-driven-design-4th-printingnbsped-9780321834577-0321834577.html",
        "read_more_link": "",
        "language": "en",
        "title": "driven design [4th printing&nbsp;ed.] 9780321834577, 0321834577",
        "top_image": "https://dokumen.pub/img/implementing-domain-driven-design-4th-printingnbsped-9780321834577-0321834577.jpg",
        "meta_img": "https://dokumen.pub/img/implementing-domain-driven-design-4th-printingnbsped-9780321834577-0321834577.jpg",
        "images": [
            "https://dokumen.pub/dokumenpub/assets/img/dokumenpub_logo.png",
            "https://dokumen.pub/img/200x200/implementing-domain-driven-design-0321834577-9780321834577.jpg",
            "https://dokumen.pub/img/200x200/vaughn-vernon-implementing-domain-driven-design-978-0321834577.jpg",
            "https://dokumen.pub/img/200x200/akka-in-action-second-edition-meap-v13-9780321125217-0321125215-9780321834577-0321834577.jpg",
            "https://dokumen.pub/img/200x200/implementing-cloud-design-patterns-for-aws-9781782177340-2153775104-1782177345.jpg",
            "https://dokumen.pub/img/200x200/implementing-cloud-design-patterns-for-aws-solutions-and-design-ideas-for-solving-system-design-problems-2nd-edition-9781789130911-9781789136203-1789130913.jpg",
            "https://dokumen.pub/img/200x200/android-user-interface-design-implementing-material-design-for-developers-second-edition-9780134191959-0134191951.jpg",
            "https://dokumen.pub/img/200x200/practical-design-patterns-for-java-developers-hone-your-software-design-skills-by-implementing-popular-design-patterns-in-java-9781804614679-180461467x.jpg",
            "https://dokumen.pub/img/200x200/key-performance-indicators-developing-implementing-and-using-winning-kpis-4thnbsped-1119620775-9781119620778.jpg",
            "https://dokumen.pub/img/200x200/design-of-fluid-thermal-systems-solution-manual-4th-edition.jpg",
            "https://dokumen.pub/img/200x200/implementing-quantlib.jpg",
            "https://dokumen.pub/img/200x200/implementing-domain-driven-design-4th-printingnbsped-9780321834577-0321834577.jpg",
            "https://dokumen.pub/dokumenpub/assets/img/dokumenpub_logo.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "...",
        "meta_lang": "en",
        "meta_favicon": "https://dokumen.pub/dokumenpub/assets/img/apple-icon-57x57.png",
        "meta_site_name": "dokumen.pub",
        "canonical_link": "https://dokumen.pub/implementing-domain-driven-design-4th-printingnbsped-9780321834577-0321834577.html",
        "text": "Citation preview\n\nPraise for Implementing Domain-Driven Design “With Implementing Domain-Driven Design, Vaughn has made an important contribution not only to the literature of the Domain-Driven Design community, but also to the literature of the broader enterprise application architecture field. In key chapters on Architecture and Repositories, for example, Vaughn shows how DDD fits with the expanding array of architecture styles and persistence technologies for enterprise applications—including SOA and REST, NoSQL and data grids—that has emerged in the decade since Eric Evans’ seminal book was first published. And, fittingly, Vaughn illuminates the blocking and tackling of DDD—the implementation of entities, value objects, aggregates, services, events, factories, and repositories—with plentiful examples and valuable insights drawn from decades of practical experience. In a word, I would describe this book as thorough. For software developers of all experience levels looking to improve their results, and design and implement domain-driven enterprise applications consistently with the best current state of professional practice, Implementing Domain-Driven Design will impart a treasure trove of knowledge hard won within the DDD and enterprise application architecture communities over the last couple decades.” —Randy Stafford, Architect At-Large, Oracle Coherence Product Development “Domain-Driven Design is a powerful set of thinking tools that can have a profound impact on how effective a team can be at building software-intensive systems. The thing is that many developers got lost at times when applying these thinking tools and really needed more concrete guidance. In this book, Vaughn provides the missing links between theory and practice. In addition to shedding light on many of the misunderstood elements of DDD, Vaughn also connects new concepts like Command/Query Responsibility Segregation and Event Sourcing that many advanced DDD practitioners have used with great success. This book is a must-read for anybody looking to put DDD into practice.” —Udi Dahan, Founder of NServiceBus “For years, developers struggling to practice Domain-Driven Design have been wishing for more practical help in actually implementing DDD. Vaughn did an excellent job in closing the gap between theory and practice with a complete implementation reference. He paints a vivid picture of what it is like to do DDD in a contemporary project, and provides plenty of practical advice on how to approach and solve typical challenges occurring in a project life cycle.” —Alberto Brandolini, DDD Instructor, Certified by Eric Evans and Domain Language, Inc. “Implementing Domain-Driven Design does a remarkable thing: it takes a sophisticated and substantial topic area in DDD and presents it clearly, with nuance, fun and finesse. This book is written in an engaging and friendly style, like a trusted advisor giving you expert counsel on how to accomplish what is most important. By the time you finish the book you will be able to begin applying all the important concepts of\n\nDDD, and then some. As I read, I found myself highlighting many sections . . . I will be referring back to it, and recommending it, often.” —Paul Rayner, Principal Consultant & Owner, Virtual Genius, LLC., DDD Instructor, Certified by Eric Evans and Domain Language, Inc., DDD Denver Founder and Co-leader “One important part of the DDD classes I teach is discussing how to put all the ideas and pieces together into a full blown working implementation. With this book, the DDD community now has a comprehensive reference that addresses this in detail. Implementing Domain-Driven Design deals with all aspects of building a system using DDD, from getting the small details right to keeping track of the big picture. This is a great reference and an excellent companion to Eric Evans seminal DDD book.” —Patrik Fredriksson, DDD Instructor, Certified by Eric Evans and Domain Language, Inc. “If you care about software craftsmanship—and you should—then Domain-Driven Design is a crucial skill set to master and Implementing Domain-Driven Design is the fast path to success. IDDD offers a highly readable yet rigorous discussion of DDD’s strategic and tactical patterns that enables developers to move immediately from understanding to action. Tomorrow’s business software will benefit from the clear guidance provided by this book.” —Dave Muirhead, Principal Consultant, Blue River Systems Group “There’s theory and practice around DDD that every developer needs to know, and this is the missing piece of the puzzle that puts it all together. Highly recommended!” —Rickard Öberg, Java Champion and Developer at Neo Technology “In IDDD, Vaughn takes a top-down approach to DDD, bringing strategic patterns such as bounded context and context maps to the fore, with the building block patterns of entities, values and services tackled later. His book uses a case study throughout, and to get the most out of it you’ll need to spend time grokking that case study. But if you do you’ll be able to see the value of applying DDD to a complex domain; the frequent sidenotes, diagrams, tables, and code all help illustrate the main points. So if you want to build a solid DDD system employing the architectural styles most commonly in use today, Vaughn’s book comes recommended.” —Dan Haywood, author of Domain-Driven Design with Naked Objects “This book employs a top-down approach to understanding DDD in a way that fluently connects strategic patterns to lower level tactical constraints. Theory is coupled with guided approaches to implementation within modern architectural styles. Throughout the book, Vaughn highlights the importance and value of focusing on the business domain all while balancing technical considerations. As a result, the role of DDD, as well as what it does and perhaps more importantly doesn’t imply, become ostensibly clear. Many a time, my team and I would be at odds with the friction encountered in applying DDD. With Implementing Domain-Driven Design as our luminous guide we were able to overcome those challenges and translate our efforts into immediate business value.” —Lev Gorodinski, Principal Architect, DrillSpot.com\n\nImplementing Domain-Driven Design\n\nThis page intentionally left blank\n\nImplementing Domain-Driven Design\n\nVaughn Vernon\n\nUpper Saddle River, NJ • Boston • Indianapolis • San Francisco New York • Toronto • Montreal • London • Munich • Paris • Madrid Capetown • Sydney • Tokyo • Singapore • Mexico City\n\nMany of the designations used by manufacturers and sellers to distinguish their products are claimed as trademarks. Where those designations appear in this book, and the publisher was aware of a trademark claim, the designations have been printed with initial capital letters or in all capitals. The author and publisher have taken care in the preparation of this book, but make no expressed or implied warranty of any kind and assume no responsibility for errors or omissions. No liability is assumed for incidental or consequential damages in connection with or arising out of the use of the information or programs contained herein. The publisher offers excellent discounts on this book when ordered in quantity for bulk purchases or special sales, which may include electronic versions and/or custom covers and content particular to your business, training goals, marketing focus, and branding interests. For more information, please contact: U.S. Corporate and Government Sales (800) 382-3419 [email protected] For sales outside the United States, please contact: International Sales [email protected] Visit us on the Web: informit.com/aw Library of Congress Control Number: 2012954071 Copyright © 2013 Pearson Education, Inc. All rights reserved. Printed in the United States of America. This publication is protected by copyright, and permission must be obtained from the publisher prior to any prohibited reproduction, storage in a retrieval system, or transmission in any form or by any means, electronic, mechanical, photocopying, recording, or likewise. To obtain permission to use material from this work, please submit a written request to Pearson Education, Inc., Permissions Department, One Lake Street, Upper Saddle River, New Jersey 07458, or you may fax your request to (201) 236-3290. ISBN-13: 978-0-321-83457-7 ISBN-10: 0-321-83457-7 Text printed in the United States on recycled paper at Courier in Westford, Massachusetts. Second printing, July 2013\n\nThis book is dedicated to my dearest Nicole and Tristan. Thanks for your love, your support, and your patience.\n\nThis page intentionally left blank\n\nContents Foreword . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . xvii Preface . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n\nxix\n\nAcknowledgments. . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxix About the Author . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxiii Guide to This Book . . . . . . . . . . . . . . . . . . . . . . . . . . . . xxxv Chapter 1 Getting Started with DDD . . . . . . . . . . . . . . . . . . . Can I DDD? . . . . . . . . . . . . . . . . . . . . . . . . . Why You Should Do DDD . . . . . . . . . . . . . . . . . . How to Do DDD . . . . . . . . . . . . . . . . . . . . . . . The Business Value of Using DDD . . . . . . . . . . . . . . 1. The Organization Gains a Useful Model of Its Domain 2. A Refined, Precise Definition and Understanding of the Business Is Developed . . . . . . . . . . . . . . . . . 3. Domain Experts Contribute to Software Design . . . . 4. A Better User Experience Is Gained . . . . . . . . . . 5. Clean Boundaries Are Placed around Pure Models . . . 6. Enterprise Architecture Is Better Organized . . . . . . 7. Agile, Iterative, Continuous Modeling Is Used . . . . . 8. New Tools, Both Strategic and Tactical, Are Employed\n\n. . . . .\n\n. . . . .\n\n1\n\n. 2 . 6 . 20 . 25 . 26\n\n. . . 27 . . . 27 . . . 27 . . . .\n\n. . . .\n\n. . . .\n\n28 28 28 28\n\nThe Challenges of Applying DDD . . . . . . . . . . . . . . . . . 29 Fiction, with Bucketfuls of Reality . . . . . . . . . . . . . . . . . 38 Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 41\n\nix\n\nx\n\nC ON T EN TS\n\nChapter 2 Domains, Subdomains, and Bounded Contexts\n\n. . . . . . . . 43\n\nBig Picture . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 43 Subdomains and Bounded Contexts at Work . . . . . . . . . . 44 Focus on the Core Domain . . . . . . . . . . . . . . . . . . . 50 Why Strategic Design Is So Incredibly Essential . . . . . . . . . . 53 Real-World Domains and Subdomains . . . . . . . . . . . . . . . 56 Making Sense of Bounded Contexts . . . . . . . . . . . . . . . . 62 Room for More than the Model . . . . . . . . . . . . . . . . . 66 Size of Bounded Contexts . . . . . . . . . . . . . . . . . . . . 68 Aligning with Technical Components . . . . . . . . . . . . . 71 Sample Contexts . . . . . . . . . . . . . . . . . . . . . . . . . . 72 Collaboration Context. . . . . . . Identity and Access Context . . . . Agile Project Management Context Wrap-Up . . . . . . . . . . . . . . . Chapter 3 Context Maps\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n. . . .\n\n73 80 82 84\n\n. . . . . . . . . . . . . . . . . . . . . . . . . 87\n\nWhy Context Maps Are So Essential . . . . Drawing Context Maps . . . . . . . . . . Projects and Organizational Relationships Mapping the Three Contexts . . . . . . . Wrap-Up . . . . . . . . . . . . . . . . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . . .\n\n. . . .\n\n87 89 91 95 111\n\nChapter 4 Architecture . . . . . . . . . . . . . . . . . . . . . . . . . . 113 Interviewing the Successful CIO . . . . . . Layers . . . . . . . . . . . . . . . . . . . Dependency Inversion Principle . . . . . Hexagonal or Ports and Adapters . . . . . Service-Oriented . . . . . . . . . . . . . . Representational State Transfer—REST . . REST as an Architectural Style . . . . . Key Aspects of a RESTful HTTP Server Key Aspects of a RESTful HTTP Client\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n114 119 123 125 130 133 133 135 136\n\nREST and DDD . . . . . . . . . . . . . . . . . . . . . . . . 136 Why REST? . . . . . . . . . . . . . . . . . . . . . . . . . . 138\n\nC ON T EN TS\n\nCommand-Query Responsibility Segregation, or CQRS . . . . . 138 Examining Areas of CQRS . . . . . . . . . . . . . . . . . . 140 Dealing with an Eventually Consistent Query Model . . . . . 146 Event-Driven Architecture . . . . . . . . . . . . . . . . . . . . 147 Pipes and Filters . . . . . . . . . . . . . . . . . . . . . . . . 149 Long-Running Processes, aka Sagas . . . . . . . . . . . . . 153 Event Sourcing . . . . . . . . . . . . . . . . . . . . . . . . 160 Data Fabric and Grid-Based Distributed Computing . . . . . . 163 Data Replication . . . . . . . . . . . . . . . . . . . . . . . 164 Event-Driven Fabrics and Domain Events . . . . . . . . . . . 165 Continuous Queries . . . . . . . . . . . . . . . . . . . . . . 166 Distributed Processing . . . . . . . . . . . . . . . . . . . . 167 Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 168 Chapter 5 Entities . . . . . . . . . . . . . . . . . . . . . . . . . . . . 171 Why We Use Entities . . . . . . . . . . . . . . . . . . Unique Identity . . . . . . . . . . . . . . . . . . . . . User Provides Identity . . . . . . . . . . . . . . . . Application Generates Identity . . . . . . . . . . . Persistence Mechanism Generates Identity . . . . . Another Bounded Context Assigns Identity . . . . . When the Timing of Identity Generation Matters . . Surrogate Identity . . . . . . . . . . . . . . . . . . Identity Stability . . . . . . . . . . . . . . . . . . . Discovering Entities and Their Intrinsic Characteristics Uncovering Entities and Properties . . . . . . . . . Digging for Essential Behavior . . . . . . . . . . . Roles and Responsibilities . . . . . . . . . . . . . Construction . . . . . . . . . . . . . . . . . . . . Validation . . . . . . . . . . . . . . . . . . . . . . Change Tracking . . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . .\n\n171 173 174 175 179 182 184 186 188 191 192 196 200 205 208 216\n\nWrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 217 Chapter 6 Value Objects . . . . . . . . . . . . . . . . . . . . . . . . . 219 Value Characteristics . . . . . . . . . . . . . . . . . . . . . . . 221 Measures, Quantifies, or Describes . . . . . . . . . . . . . . 221 Immutable . . . . . . . . . . . . . . . . . . . . . . . . . . . 221\n\nxi\n\nxii\n\nC ON T EN TS\n\nConceptual Whole . . . . . . . . . . . . . . . . . . . . . . 223 Replaceability . . . . . . . . . . . . . . . . . . . . . . . . . 226 Value Equality . . . . . . . . . . . . . . . . . . . . . . . . . 227 Side-Effect-Free Behavior . . . . . . . . . . . . . . . . . . . 228 Integrate with Minimalism . . . . . . . . . . . . . . . . . . . . 232 Standard Types Expressed as Values . . . . . . . . . . . . . . . 234 Testing Value Objects . . . . . . . . . . . . . . . . . . . . . . 239 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . . 243 Persisting Value Objects . . . . . . . . . . . . . . . . . . . . . 248 Reject Undue Influence of Data Model Leakage. . . . . . . . 249 ORM and Single Value Objects . . . . . . . . . . . . . ORM and Many Values Serialized into a Single Column ORM and Many Values Backed by a Database Entity. . ORM and Many Values Backed by a Join Table. . . . . ORM and Enum-as-State Objects . . . . . . . . . . . . Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n251 253 255 260 261 263\n\nChapter 7 Services . . . . . . . . . . . . . . . . . . . . . . . . . . . . 265 What a Domain Service Is (but First, What It Is Not) Make Sure You Need a Service . . . . . . . . . . . . Modeling a Service in the Domain . . . . . . . . . . Is Separated Interface a Necessity? . . . . . . . . A Calculation Process . . . . . . . . . . . . . . . Transformation Services . . . . . . . . . . . . . . Using a Mini-Layer of Domain Services . . . . . Testing Services. . . . . . . . . . . . . . . . . . . . Wrap-Up . . . . . . . . . . . . . . . . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n. . . . . . . . .\n\n267 268 272 275 277 280 281 281 284\n\nChapter 8 Domain Events . . . . . . . . . . . . . . . . . . . . . . . . 285 The When and Why of Domain Events . . . . . . . . . . . . . 285 Modeling Events . . . . . . . . . . . . . . . . . . . . . . . . . 288 With Aggregate Characteristics . . . . . . . . . . . . . . . . 294 Identity . . . . . . . . . . . . . . . . . . . . . . . . . . . . 295 Publishing Events from the Domain Model . . . . . . . . . . . 296 Publisher . . . . . . . . . . . . . . . . . . . . . . . . . . . 297 Subscribers . . . . . . . . . . . . . . . . . . . . . . . . . . 300\n\nC ON T EN TS\n\nSpreading the News to Remote Bounded Contexts . . . . . . . 303 Messaging Infrastructure Consistency . . . . . . . . . . . . 303 Autonomous Services and Systems . . . . . . . . . . . . . . 305 Latency Tolerances . . . . . . . . . . . . . . . . . . . . . . 306 Event Store . . . . . . . . . . . . . . . . . . . . . . . . . . . . 307 Architectural Styles for Forwarding Stored Events . . . . . . . . 312 Publishing Notifications as RESTful Resources . . . . . . . . 312 Publishing Notifications through Messaging Middleware . . 317 Implementation . . . . . . . . . . . . . . . . . . . . . . . . . 318 Publishing the NotificationLog . . . . . . . . . . . . . . 319 Publishing Message-Based Notifications . . . . . . . . . . . 324 Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 331 Chapter 9 Modules\n\n. . . . . . . . . . . . . . . . . . . . . . . . . . . 333\n\nDesigning with Modules . . . . . . . . . . . . . . Basic Module Naming Conventions . . . . . . . . Module Naming Conventions for the Model . . . . Modules of the Agile Project Management Context Modules in Other Layers . . . . . . . . . . . . . Module before Bounded Context . . . . . . . . . Wrap-Up . . . . . . . . . . . . . . . . . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n333 336 337 340 343 344 345\n\nChapter 10 Aggregates . . . . . . . . . . . . . . . . . . . . . . . . . . 347 Using Aggregates in the Scrum Core Domain . . . . . . First Attempt: Large-Cluster Aggregate . . . . . . . . Second Attempt: Multiple Aggregates . . . . . . . . . Rule: Model True Invariants in Consistency Boundaries . Rule: Design Small Aggregates . . . . . . . . . . . . . . Don’t Trust Every Use Case . . . . . . . . . . . . . . Rule: Reference Other Aggregates by Identity . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n. . . . . . .\n\n348 349 351 353 355 358 359\n\nMaking Aggregates Work Together through Identity References . . . . . . . . . . . . . . . . . . . . . . . . . 361 Model Navigation . . . . . . . . . . . . . . . . . . . . . . . 362 Scalability and Distribution . . . . . . . . . . . . . . . . . . 363 Rule: Use Eventual Consistency Outside the Boundary . . . . . 364 Ask Whose Job It Is . . . . . . . . . . . . . . . . . . . . . . 366\n\nxiii\n\nxiv\n\nC ON T EN TS\n\nReasons to Break the Rules . . . . . . . . . . . . . . . . . . . 367 Reason One: User Interface Convenience . . . . . . . . . . . 367 Reason Two: Lack of Technical Mechanisms . . . . . . . . . 368 Reason Three: Global Transactions . . . . . . . . . . . . . . 369 Reason Four: Query Performance . . . . . . . . . . . . . . . 369 Adhering to the Rules . . . . . . . . . . . . . . . . . . . . . 370 Gaining Insight through Discovery . . . . . . . . . . . . . . . . 370 Rethinking the Design, Again . . . . . . . . . . . . . . . . . 370 Estimating Aggregate Cost . . . . . . . . . . . . . . . . . . 372 Common Usage Scenarios\n\n. . . . . . . . . . . . . . . . . . 373\n\nMemory Consumption . . . . . . . . . . Exploring Another Alternative Design . . Implementing Eventual Consistency . . . . Is It the Team Member’s Job? . . . . . . . Time for Decisions . . . . . . . . . . . . Implementation . . . . . . . . . . . . . . . Create a Root Entity with Unique Identity Favor Value Object Parts . . . . . . . . . Using Law of Demeter and Tell, Don’t Ask Optimistic Concurrency . . . . . . . . . . Avoid Dependency Injection . . . . . . . . Wrap-Up . . . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n. . . . . . . . . . . .\n\n374 375 376 378 379 380 380 382 382 385 387 388\n\nChapter 11 Factories . . . . . . . . . . . . . . . . . . . . . . . . . . . 389 Factories in the Domain Model . . . . Factory Method on Aggregate Root . . Creating CalendarEntry Instances Creating Discussion Instances . . Factory on Service . . . . . . . . . . . Wrap-Up . . . . . . . . . . . . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . . .\n\n389 391 392 395 397 400\n\nChapter 12 Repositories . . . . . . . . . . . . . . . . . . . . . . . . . 401 Collection-Oriented Repositories . . . . . . . . . . . . . . . . 402 Hibernate Implementation . . . . . . . . . . . . . . . . . . 407 Considerations for a TopLink Implementation . . . . . . . . 416\n\nC ON T EN TS\n\nPersistence-Oriented Repositories . . . . . . . . . . . . . . . . 418 Coherence Implementation . . . . . . . . . . . . . . . . . . 420 MongoDB Implementation . . . . . . . . . . . . . . . . . . 425 Additional Behavior . . . . . . . . . . . . . . . . . . . . . . . 430 Managing Transactions . . . . . . . . . . . . . . . . . . . . . 432 A Warning . . . . . . . . . . . . . . . . . . . . . . . . . . 437 Type Hierarchies . . . . . . . . . . . . . . . . . . . . . . . . . 437 Repository versus Data Access Object . . . . . . . . . . . . . . 440 Testing Repositories . . . . . . . . . . . . . . . . . . . . . . . 441 Testing with In-Memory Implementations . . . . . . . . . . 445 Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 448 Chapter 13 Integrating Bounded Contexts . . . . . . . . . . . . . . . . 449 Integration Basics . . . . . . . . . . . . . . . . . . . . . Distributed Systems Are Fundamentally Different . . . Exchanging Information across System Boundaries . . . Integration Using RESTful Resources . . . . . . . . . . . Implementing the RESTful Resource . . . . . . . . . . Implementing the REST Client Using an Anticorruption Layer . . . . . . . . . . . . . . . . . . . . . . . . . Integration Using Messaging . . . . . . . . . . . . . . . . Staying Informed about Product Owners and Team Members . . . . . . . . . . . . . . . . . . . . . . .\n\n. . . . .\n\nCan You Handle the Responsibility? . . . . . . . . . Long-Running Processes, and Avoiding Responsibility Process State Machines and Time-out Trackers . . . . Designing a More Sophisticated Process . . . . . . . When Messaging or Your System Is Unavailable . . . Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . .\n\n. . . . . .\n\n. . . . . .\n\n. . . . .\n\n. . . . .\n\n450 451 452 458 459\n\n. . . 463 . . . 469 . . . 469 . . . . . .\n\n. . . . . .\n\n476 481 493 503 507 508\n\nChapter 14 Application. . . . . . . . . . . . . . . . . . . . . . . . . . 509 User Interface . . . . . . . . . . . . . . . . . . . . . . . . . . 512 Rendering Domain Objects . . . . . . . . . . . . . . . . . . 512 Render Data Transfer Object from Aggregate Instances . . . 513 Use a Mediator to Publish Aggregate Internal State . . . . . . 514 Render Aggregate Instances from a Domain Payload Object 515\n\nxv\n\nxvi\n\nC ON T EN TS\n\nState Representations of Aggregate Instances . . . . . . . . . 516 Use Case Optimal Repository Queries. . . . . . . . . . . . . 517 Dealing with Multiple, Disparate Clients . . . . . . . . . . . 517 Rendition Adapters and Handling User Edits . . . . . . . . . 518 Application Services . . . . . . . . . . . . . . . . . . . . . . . 521 Sample Application Service . . . . . . . . . . . . . . . . . . 522 Decoupled Service Output . . . . . . . . . . . . . . . . . . 528 Composing Multiple Bounded Contexts . . . . . . . . . . . . . 531 Infrastructure . . . . . . . . . . . . . . . . . . . . . . . . . . 532 Enterprise Component Containers . . . . . . . . . . . . . . . . 534 Wrap-Up . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 537 Appendix A Aggregates and Event Sourcing: A+ES . . . . . . . . . . . 539 Inside an Application Service . Command Handlers . . . . . . Lambda Syntax . . . . . . . . Concurrency Control . . . . . . Structural Freedom with A+ES . Performance . . . . . . . . . . Implementing an Event Store . . Relational Persistence . . . . . BLOB Persistence . . . . . . . Focused Aggregates . . . . . . Read Model Projections . . . . Use with Aggregate Design . . Events Enrichment . . . . . . . Supporting Tools and Patterns . Event Serializers . . . . . . . Event Immutability . . . . . Value Objects . . . . . . . . Contract Generation . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n. . . . . . . . . . . . . . . . . .\n\n541 549 553 554 558 558 561 565 568 569 570 573 573 576 576 577 577 580\n\nUnit Testing and Specifications . . . . . . . . . . . . . . . . . 582 Event Sourcing in Functional Languages . . . . . . . . . . . . . 583 Bibliography . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 585 Index . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . 589\n\nForeword In this new book, Vaughn Vernon presents the whole of Domain-Driven Design (DDD) in a distinctive way, with new explanations of the concepts, new examples, and an original organization of topics. I believe this fresh, alternative approach will help people grasp the subtleties of DDD, particularly the more abstract ones such as Aggregates and Bounded Contexts. Not only do different people prefer different styles—subtle abstractions are hard to absorb without multiple explanations. Also, the book conveys some of the insights of the past nine years that have been described in papers and presentations but have not appeared in a book before now. It places Domain Events alongside Entities and Value Objects as the building blocks of a model. It discusses the Big Ball of Mud and places it into the Context Map. It explains the hexagonal architecture, which has emerged as a better description of what we do than the layered architecture. My first exposure to the material in this book came almost two years ago (although Vaughn had been working on his book for some time by then). At the first DDD Summit, several of us committed to writing about certain topics about which we felt there were fresh things to say or there was a particular need in the community for more specific advice. Vaughn took up the challenge of writing about Aggregates, and he followed through with a series of excellent articles about Aggregates (which became a chapter in this book). There was also a consensus at the summit that many practitioners would benefit from a more prescriptive treatment of some of the DDD patterns. The honest answer to almost any question in software development is, “It depends.” That is not very useful to people who want to learn to apply a technique, however. A person who is assimilating a new subject needs concrete guidance. Rules of thumb don’t have to be right in all cases. They are what usually works well or the thing to try first. Through their decisiveness, they convey the philosophy of the approach to solving the problem. Vaughn’s book has a good mix of straightforward advice balanced with a discussion of tradeoffs that keep it from being simplistic.\n\nxvii\n\nxviii\n\nF OR EWOR D\n\nNot only have additional patterns, such as Domain Events, become a mainstream part of DDD—people in the field have progressed in learning how to apply those patterns, not to mention adapting them to newer architectures and technologies. Nine years after my book, Domain-Driven Design: Tackling Complexity in the Heart of Software, was published, there’s actually a lot to say about DDD that is new, and there are new ways to talk about the fundamentals. Vaughn’s book is the most complete explanation yet of those new insights into practicing DDD. —Eric Evans Domain Language, Inc.\n\nPreface All the calculations show it can’t work. There’s only one thing to do: make it work. —Pierre-Georges Latécoère, early French aviation entrepreneur And make it work we shall. The Domain-Driven Design approach to software development is far too important to leave any capable developer without clear directions for how to implement it successfully.\n\nGetting Grounded, Getting Airborne When I was a kid, my father learned to pilot small airplanes. Often the whole family would go up flying. Sometimes we flew to another airport for lunch, then returned. When Dad had less time but longed to be in the air, we’d go out, just the two of us, and circle the airport doing “touch-and-goes.” We also took some long trips. For those, we always had a map of the route that Dad had earlier charted. Our job as kids was to help navigate by looking out for landmarks below so we could be certain to stay on course. This was great fun for us because it was a challenge to spot objects so far below that exhibited little in the way of identifying details. Actually, I’m sure that Dad always knew where we were. He had all the instruments on the dashboard, and he was licensed for instrument flight. The view from the air really changed my perspective. Now and then Dad and I would fly over our house in the countryside. At a few hundred feet up, this gave me a context for home that I didn’t have before. As Dad would cruise over our house, Mom and my sisters would run out into the yard to wave at us. I knew it was them, although I couldn’t look into their eyes. We couldn’t\n\nxix\n\nxx\n\nP R EFACE\n\nconverse. If I had shouted out the airplane window, they would never have heard me. I could see the split-rail fence in the front dividing our property from the road. When on the ground I’d walk across it as if on a balance beam. From the air, it looked like carefully woven twigs. And there was the huge yard that I circled row by row on our riding lawn mower every summer. From the air, I saw only a sea of green, not the blades of grass. I loved those moments in the air. They are etched in my memory as if Dad and I were just taxiing in after landing to tie down for the evening. As much as I loved those flights, they sure were no substitute for being on the ground. And as cool as they were, the touch-and-goes were just too brief to make me feel grounded.\n\nLanding with Domain-Driven Design Getting in touch with Domain-Driven Design (DDD) can be like flight to a kid. The view from the air is stunning, but sometimes things look unfamiliar enough to prevent us from knowing exactly where we are. Getting from point A to point B appears far from realistic. The DDD grownups always seem to know where they are. They’ve long ago plotted a course, and they are completely in tune with their navigational instruments. A great number of others don’t feel grounded. What is needed is the ability to “land and tie down.” Next, a map is needed to guide the way from where we are to where we need to be. In the book Domain-Driven Design: Tackling Complexity in the Heart of Software [Evans], Eric Evans brought about what is a timeless work. It is my firm belief that Eric’s work will guide developers in practical ways for decades to come. Like other pattern works, it establishes flight far enough above the surface to give a broad vision. Yet, there may be a bit more of a challenge when we need to understand the groundwork involved in implementing DDD, and we usually desire more detailed examples. If only we could land and stay on the surface a bit longer, and even drive home or to some other familiar place. Part of my goal is to take you in for a soft landing, secure the aircraft, and help you get home by way of a well-known surface route. That will help you make sense of implementing DDD, giving you examples that use familiar tools and technologies. And since none of us can stay home all the time, I will also help you venture out onto other paths to explore new terrain, taking you to places that perhaps you’ve never been before. Sometimes the path will be steep, but given the right tactics, a challenging yet safe ascent is possible. On this trip you’ll learn about alternative architectures and patterns for integrating\n\nM A PPI NG\n\nT HE\n\nTERR A I N\n\nAND\n\nC H ART I NG\n\nFOR\n\nF LIGH T\n\nmultiple domain models. This may expose you to some previously unexplored territory. You will find detailed coverage of strategic modeling with multiple integrations, and you’ll even learn how to develop autonomous services. My goal is to provide a map to help you take both short jaunts and long, complicated treks, enjoying the surrounding detail, without getting lost or injured along the way.\n\nMapping the Terrain and Charting for Flight It seems that in software development we are always mapping from one thing to another. We map our objects to databases. We map our objects to the user interface and then back again. We map our objects to and from various application representations, including those that can be consumed by other systems and applications. With all this mapping, it’s natural to want a map from the higher-level patterns of Evans to implementation. Even if you have already landed a few times with DDD, there is probably more to benefit from. Sometimes DDD is first embraced as a technical tool set. Some refer to this approach to DDD as DDD-Lite. We may have homed in on Entities, Services, possibly made a brave attempt at designing Aggregates, and tried to manage their persistence using Repositories. Those patterns felt a bit like familiar ground, so we put them to use. We may even have found some use for Value Objects along the way. All of these fall within the catalog of tactical design patterns, which are more technical. They help us take on a serious software problem with the skill of a surgeon with a scalpel. Still, there is much to learn about these and other places to go with tactical design as well. I map them to implementation. Have you traveled beyond tactical modeling? Have you visited and even lingered with what some call the “other half” of DDD, the strategic design patterns? If you’ve left out the use of Bounded Context and Context Maps, you have probably also missed out on the use of the Ubiquitous Language. If there is a single “invention” Evans delivers to the software development community, it is the Ubiquitous Language. At a minimum he brought the Ubiquitous Language out of the dusty archives of design wisdom. It is a team pattern used to capture the concepts and terms of a specific core business domain in the software model itself. The software model incorporates the nouns, adjectives, verbs, and richer expressions formally spoken by the development team, a team that includes one or more business domain experts. It would be a mistake, however, to conclude that the Language is limited to mere words. Just as any human language reflects the minds of those who speak it, the Ubiquitous\n\nxxi\n\nxxii\n\nP R EFACE\n\nLanguage reflects the mental model of the experts of the business domain you are working in. Thus, the software and the tests that verify the model’s adherence to the tenets of the domain both capture and adhere to this Language, the same conceived and spoken by the team. The Language is equally as valuable as the various strategic and tactical modeling patterns and in some cases has a more enduring quality. Simply stated, practicing DDD-Lite leads to the construction of inferior domain models. That’s because the Ubiquitous Language, Bounded Context, and Context Mapping have so much to offer. You get more than a team lingo. The Language of a team in an explicit Bounded Context expressed as a domain model adds true business value and gives us certainty that we are implementing the correct software. Even from a technical standpoint, it helps us create better models, ones with more potent behaviors, that are pure and less error prone. Thus, I map the strategic design patterns to understandable example implementations. This book maps the terrain of DDD in a way that allows you to experience the benefits of both strategic and tactical design. It puts you in touch with its business value and technical strengths by peering closely at the details. It would be a disappointment if all we ever did with DDD is stay on the ground. Getting stuck in the details, we’d forget that the view from flight teaches us a lot, too. Don’t limit yourself to rugged ground travel. Brave the challenge of getting in the pilot’s seat and see from a height that is telling. With training flights on strategic design, with its Bounded Contexts and Context Maps, you will be prepared to gain a grander perspective on its full realization. When you reward yourself with DDD flight, I will have reached my goal.\n\nSummary of Chapters The following highlights the chapters of this book and how you can benefit from each one.\n\nChapter 1: Getting Started with DDD This chapter introduces you to the benefits of using DDD and how to achieve the most from it. You will learn what DDD can do for your projects and your teams as you grapple with complexity. You’ll find out how to score your project to see if it deserves the DDD investment. You will consider the common alternatives to DDD and why they often lead to problems. The chapter lays the foundations of DDD as you learn how to take the first steps on your project,\n\nS UM M ARY\n\nOF\n\nC H A P T ERS\n\nand it even gives you some ways to sell DDD to your management, domain experts, and technical team members. That will enable you to face the challenges of using DDD armed with the knowledge of how to succeed. You are introduced to a project case study that involves a fictitious company and team, yet one with real-world DDD challenges. The company, with the charter to create innovative SaaS-based products in a multitenant environment, experiences many of the mistakes common to DDD adoption but makes vital discoveries that help the teams solve their issues and keep the project on track. The project is one that most developers can relate to, as it involves developing a Scrum-based project management application. This case study introduction sets the stage for subsequent chapters. Each strategic and tactical pattern is taught through the eyes of the team, both as they err and as they make strides toward maturity in implementing DDD successfully.\n\nChapter 2: Domains, Subdomains, and Bounded Contexts What is a Domain, a Subdomain, and a Core Domain? What are Bounded Contexts, and why and how should you use them? These questions are answered in the light of mistakes made by the project team in our case study. Early on in their first DDD project they failed to understand the Subdomain they were working within, its Bounded Context, and a concise Ubiquitous Language. In fact, they were completely unfamiliar with strategic design, only leveraging the tactical patterns for their technical benefits. This led to problems in their initial domain model design. Fortunately, they recognized what had happened before it became a hopeless morass. A vital message is conveyed, that of applying Bounded Contexts to distinguish and segregate models properly. Addressed are common misapplications of the pattern along with effective implementation advice. The text then leads you through the corrective steps the team took and how that resulted in the creation of two distinct Bounded Contexts. This led to the proper separation of modeling concepts in their third Bounded Context, the new Core Domain, and the main sample used in the book. This chapter will strongly resonate with readers who have felt the pain of applying DDD only in a technical way. If you are uninitiated in strategic design, you are pointed in the right direction to start out on a successful journey.\n\nChapter 3: Context Maps Context Maps are a powerful tool to help a team understand their business domain, the boundaries between distinct models, and how they are currently, or can be, integrated. This technique is not limited to drawing a diagram of\n\nxxiii\n\nxxiv\n\nP R EFACE\n\nyour system architecture. It’s about understanding the relationships between the various Bounded Contexts in an enterprise and the patterns used to map objects cleanly from one model to another. Use of this tool is important to succeeding with Bounded Contexts in a complex business enterprise. This chapter takes you through the process used by the project team as they applied Context Mapping to understand the problems they created with their first Bounded Context (Chapter 2). It then shows how the two resulting clean Bounded Contexts were leveraged by the team responsible for designing and implementing the new Core Domain.\n\nChapter 4: Architecture Just about everyone knows the Layers Architecture. Are Layers the only way to house a DDD application, or can other diverse architectures be used? Here we consider how to use DDD within such architectures as Hexagonal (Ports and Adapters), Service-Oriented, REST, CQRS, Event-Driven (Pipes and Filters, Long-Running Processes or Sagas, Event Sourcing), and Data Fabric/GridBased. Several of these architectural styles were put to use by the project team.\n\nChapter 5: Entities The first of the DDD tactical patterns treated is Entities. The project team first leaned too heavily on these, overlooking the importance of designing with Value Objects when appropriate. This led to a discussion of how to avoid widespread overuse of Entities because of the undue influence of databases and persistence frameworks. Once you are familiar with ways to distinguish their proper use, you see lots of examples of how to design Entities well. How do we express the Ubiquitous Language with an Entity? How are Entities tested, implemented, and persisted? You are stepped through how-to guidance for each of these.\n\nChapter 6: Value Objects Early on the project team missed out on important modeling opportunities with Value Objects. They focused too intensely on the individual attributes of Entities when they should have been giving careful consideration to how multiple related attributes are properly gathered as an immutable whole. This chapter looks at Value Object design from several angles, discussing how to identify the special characteristics in the model as a means to determine when to use a Value rather than an Entity. Other important topics are covered, such as the role of Values in integration and modeling Standard Types. The chapter then shows how to design domain-centric tests, how to implement Value types,\n\nS UM M ARY\n\nOF\n\nC H A P T ERS\n\nand how to avoid the bad influence persistence mechanisms can have on our need to store them as part of an Aggregate.\n\nChapter 7: Services This chapter shows how to determine when to model a concept as a finegrained, stateless Service that lives in the domain model. You are shown when you should design a Service instead of an Entity or Value Object, and how Domain Services can be implemented to handle business domain logic as well as for technical integration purposes. The decisions of the project team are used to exemplify when to use Services and how they are designed.\n\nChapter 8: Domain Events Domain Events were not formally introduced by Eric Evans as part of DDD until after his book was published. You’ll learn why Domain Events published by the model are so powerful, and the diverse ways that they can be used, even in supporting integration and autonomous business services. Although various kinds of technical events are sent and processed by applications, the distinguishing characteristics of Domain Events are spotlighted. Design and implementation guidance is provided, instructing you on available options and trade-offs. The chapter then teaches how to create a Publish-Subscribe mechanism, how Domain Events are published to integrated subscribers across the enterprise, ways to create and manage an Event Store, and how to properly deal with common messaging challenges faced. Each of these areas is discussed in light of the project team’s efforts to use them correctly and to their best advantage.\n\nChapter 9: Modules How do we organize model objects into right-sized containers with limited coupling to objects that are in different containers? How do we name these containers so they reflect the Ubiquitous Language? Beyond packages and namespaces, how can we use the more modern modularization facilities, such as OSGi and Jigsaw, provided by languages and frameworks? Here you will see how Modules were put to use by the project team across a few of their projects.\n\nChapter 10: Aggregates Aggregates are probably the least well understood among DDD’s tactical tools. Yet, if we apply some rules of thumb, Aggregates can be made simpler and quicker to implement. You will learn how to cut through the complexity\n\nxxv\n\nxxvi\n\nP R EFACE\n\nbarrier to use Aggregates that create consistency boundaries around small object clusters. Because of putting too much emphasis on the less important aspects of Aggregates, the project team in our case study stumbled in a few different ways. We step through the team’s iterations with a few modeling challenges and analyze what went wrong and what they did about it. The result of their efforts led to a deeper understanding of their Core Domain. We look in on how the team corrected their mistakes through the proper application of transactional and eventual consistency, and how that led them to design a more scalable and high-performing model within a distributed processing environment.\n\nChapter 11: Factories [Gamma et al.] has plenty to say about Factories, so why bother with treating them in this book? This is a simple chapter that does not attempt to reinvent the wheel. Rather, its focus is on understanding where Factories should exist. There are, of course, a few good tips to share about designing a worthy Factory in a DDD setting. See how the project team created Factories in their Core Domain as a way to simplify the client interface and protect the model’s consumers from introducing disastrous bugs into their multitenant environment.\n\nChapter 12: Repositories Isn’t a Repository just a simple Data Access Object (DAO)? If not, what’s the difference? Why should we consider designing Repositories to mimic collections rather than databases? Learn how to design a Repository that is used with an ORM, one that supports the Coherence grid-based distributed cache, and one that uses a NoSQL key-value store. Each of these optional persistence mechanisms was at the disposal of the project team because of the power and versatility behind the Repository building block pattern.\n\nChapter 13: Integrating Bounded Contexts Now that you understand the higher-level techniques of Context Mapping and have the tactical patterns on your side, what is involved in actually implementing the integrations between models? What integration options are afforded by DDD? This chapter uncovers a few different ways to implement model integrations using Context Mapping. Instruction is given based on how the project team integrated the Core Domain with other supporting Bounded Contexts introduced in early chapters.\n\nJ AVA\n\nAND\n\nD EV ELOPMEN T TOOLS\n\nChapter 14: Application You have designed a model per your Core Domain’s Ubiquitous Language. You’ve developed ample tests around its usage and correctness, and it works. But how do other members of your team design the areas of the application that surround the model? Should they use DTOs to transfer data between the model and the user interface? Or are there other options for conveying model state up to the presentation components? How do the Application Services and infrastructure work? This chapter addresses those concerns using the now familiar project to convey available options.\n\nAppendix A: Aggregates and Event Sourcing: A+ES Event Sourcing is an important technical approach to persisting Aggregates that also provides the basis for developing an Event-Driven Architecture. Event Sourcing can be used to represent the entire state of an Aggregate as a sequence of Events that have occurred since it was created. The Events are used to rebuild the state of the Aggregate by replaying them in the same order in which they occurred. The premise is that this approach simplifies persistence and allows capturing concepts with complex behavioral properties, besides the far-reaching influence the Events themselves can have on your own and external systems.\n\nJava and Development Tools The majority of the examples in this book use the Java Programming Language. I could have provided the examples in C#, but I made a conscious decision to use Java instead. First of all, and sad to say, I think there has been a general abandonment of good design and development practices in the Java community. These days it may be difficult to find a clean, explicit domain model in most Java-based projects. It seems to me that Scrum and other agile techniques are being used as substitutes for careful modeling, where a product backlog is thrust at developers as if it serves as a set of designs. Most agile practitioners will leave their daily stand-up without giving a second thought to how their backlog tasks will affect the underlying model of the business. Although I assume this is needless to say, I must assert that Scrum, for example, was never meant to stand in place of design. No matter how many project and product managers would like to keep you marching on a relentless path of continuous delivery, Scrum\n\nxxvii\n\nxxviii\n\nP R EFACE\n\nwas not meant only as a means to keep Gantt chart enthusiasts happy. Yet, it has become that in so many cases. I consider this a big problem, and a major theme I have is to inspire the Java community to return to domain modeling by giving a reasonable amount of thought to how sound, yet agile and rapid, design techniques can benefit their work. Further, there are already some good resources for using DDD in a .NET environment, one being Applying Domain-Driven Design and Patterns: With Examples in C# and .NET by Jimmy Nilsson [Nilsson]. Due to Jimmy’s good work and that of others promoting the Alt.NET mindset, there is a high tide of good design and development practices going on in the .NET community. Java developers need to take notice. Second, I am well aware that the C#.NET community will have no problem whatsoever understanding Java code. Due to the fact that much of the DDD community uses C#.NET, most of my early book reviewers are C# developers, and I never once received a complaint about their having to read Java code. So, I have no concern that my use of Java in any way alienates C# developers. I need to add that at the time of this writing there was a significant shift toward interest in using document-based and key-value storage over relational databases. This is for good reason, for even Martin Fowler has aptly nicknamed these “aggregate-oriented storage.” It’s a fitting name and well describes the advantages of using NoSQL storage in a DDD setting. Yet, in my consulting work I find that many are still quite married to relational databases and object-relational mapping. Therefore, I think that in practical terms there has been no disservice to the community of NoSQL enthusiasts by my including guidance on using object-relational mapping techniques for domain models. I do acknowledge, however, that this may earn me some scorn from those who think that the object-relational impedance mismatch makes it unworthy of consideration. That’s fine, and I accept the flames, because there is a vast majority who must still live with the drudgeries of this impedance mismatch on a day-to-day basis, however unenlightened they may seem to the minority. Of course, I also provide guidance in Chapter 12, “Repositories,” on the use of document-based, key-value, and Data Fabric/Grid-Based stores. As well, in several places I discuss where the use of a NoSQL store would tend to influence an alternative design of Aggregates and their contained parts. It’s quite likely that the trend toward NoSQL stores will continue to spur growth in that sector, so in this case object-relational developers need to take notice. As you can see, I understand both sides of the argument, and I agree with both. It’s all part of the ongoing friction created by technology trends, and the friction needs to happen in order for positive change to happen.\n\nAcknowledgments I am grateful to the fine staff at Addison-Wesley for giving me the opportunity to publish under their highly respected label. As I have stated before in my classes and presentations, I see Addison-Wesley as a publisher that understands the value of DDD. Both Christopher Guzikowski and Chris Zahn (Dr. Z) have supported my efforts throughout the editorial process. I will not forget the day that Christopher Guzikowski called to share the news that he wanted to sign me as one of his authors. I will remember how he encouraged me to persevere through the doubts that most authors must experience, until publication was in sight. Of course, it was Dr. Z who made sure the text was put into a publishable state. Thanks to my production editor, Elizabeth Ryan, for coordinating the book’s publication details. And thanks to my intrepid copyeditor, Barbara Wood. Going back a ways, it was Eric Evans who devoted a major portion of five years of his career to write the first definitive work on DDD. Without his efforts, the wisdom that grew out of the Smalltalk and patterns communities, and that Eric himself refined, many more developers would just be hacking their way to delivering bad software. Sadly, this problem is more common than it should be. As Eric says, the poor quality of software development, and the uncreative joylessness of the teams that produce the software, nearly drove him to exit the software industry for good. We owe Eric hearty thanks for concentrating his energy into educating rather than into a career change. At the end of the first DDD Summit in 2011, which Eric invited me to attend, it was determined that the leadership should produce a set of guidelines by which more developers could succeed with DDD. I was already far along with this book and was in a good position to understand what developers were missing. I offered to write an essay to provide the “rules of thumb” for Aggregates. I determined that this three-part series entitled “Effective Aggregate Design” would form the foundation for Chapter 10 of this book. Once released on dddcommunity.org, it became quite clear how such sound guidance was\n\nxxix\n\nxxx\n\nACKNOW LEDGMEN TS\n\ngreatly needed. Thanks to others among the DDD leadership who reviewed that essay and thus provided valuable feedback for this book. Eric Evans and Paul Rayner did several detailed reviews of the essay. I also received feedback from Udi Dahan, Greg Young, Jimmy Nilsson, Niclas Hedhman, and Rickard Öberg. Special thanks go to Randy Stafford, a longtime member of the DDD community. After attending a DDD talk I gave several years ago in Denver, Randy urged me to become more involved in the larger DDD community. Sometime later, Randy introduced me to Eric Evans so I could pitch my ideas about drawing the DDD community together. While my ideas were a bit grander and possibly less achievable, Eric convinced us that forming a smaller contingent composed of clear DDD leadership would have more near-term value. From these discussions the DDD Summit 2011 was formed. Needless to say, without Randy’s coaxing me to push forward with my views of DDD, this book would not exist, and perhaps not even a DDD Summit. Although Randy was too busy with Oracle Coherence work to contribute to this book, perhaps we will get the chance to write something in the future in a combined effort. A huge thank-you goes to Rinat Abdullin, Stefan Tilkov, and Wes Williams for contributing sections about specialized topics to the text. It’s nearly impossible to know everything about everything related to DDD, and absolutely impossible to be an expert in all areas of software development. That’s why I turned to experts in specific areas to write a few sections of Chapter 4 and Appendix A. Thanks go to Stefan Tilkov for his uncommon knowledge of REST, to Wes Williams for his GemFire experience, and to Rinat Abdullin for sharing his continually expanding experience with Event Sourcing for Aggregate implementation. One of my earliest reviewers was Leo Gorodinsk, and he stuck with the project. I first met Leo at our DDD Denver meetup. He provided a lot of great feedback on this book based on his own struggles while implementing DDD with his team in Boulder, Colorado. I hope my book helped Leo as much as his critical reviews helped me. I see Leo as part of DDD’s future. Many others provided feedback on at least one chapter of my book, and some on several chapters. Some of the more critical feedback was provided by Gojko Adzic, Alberto Brandolini, Udi Dahan, Dan Haywood, Dave Muirhead, and Stefan Tilkov. Specifically, Dan Haywood and Gojko Adzic delivered much of the early feedback, which was based on the most-painful-to-read content I produced. I am glad they endured and corrected me. Alberto Brandolini’s insights into strategic design in general, and Context Mapping specifically, helped me focus on the essence of that vital material. Dave Muirhead, with an abundance of experience in object-oriented design, domain modeling, as well as object persistence and in-memory data grids—including GemFire\n\nACKNOW LEDGMEN TS\n\nand Coherence—influenced my text regarding some of the history and finer details of object persistence. Besides his REST contribution, Stefan Tilkov supplied additional insights into architecture in general, and SOA and Pipes and Filters specifically. Finally, Udi Dahan validated and helped me clarify some of the concepts of CQRS, Long-Running Processes (aka Sagas), and messaging with NServiceBus. Other reviewers who provided valuable feedback were Rinat Abdullin, Svein Arne Ackenhausen, Javier Ruiz Aranguren, William Doman, Chuck Durfee, Craig Hoff, Aeden Jameson, Jiwei Wu, Josh Maletz, Tom Marrs, Michael McCarthy, Rob Meidal, Jon Slenk, Aaron Stockton, Tom Stockton, Chris Sutton, and Wes Williams. Scorpio Steele produced the fantastic illustrations for the book. Scorpio made everyone on the IDDD team the superheroes that they truly are. At the other end of the spectrum was the nontechnical editorial review by my good friend Kerry Gilbert. While everyone else made sure I was technically correct, Kerry put me “under the grammar hammer.” My father and mother have provided great inspiration and support throughout my life. My father—AJ in the “Cowboy Logic” humor throughout this book—is not just a cowboy. Don’t get me wrong. Being a great cowboy would be enough. Besides loving flight and piloting airplanes, my father was an accomplished civil engineer and land surveyor, and a talented negotiator. He still loves math and studying the galaxies. Among many other things he taught me, my Dad imparted to me how to solve a right triangle when I was around ten years old. Thanks, Dad, for giving me a technical bent at a young age. Thanks also go to my mom, one of the nicest people you could ever know. She has always encouraged and supported me through my personal challenges. Besides, what stamina I have comes from her. I could go on, but I could never say enough good things about her. Although this book is dedicated to my loving wife, Nicole, and our marvelous son, Tristan, my thanks would not be complete without a special mention here. They are the ones who allowed me to work on and complete the book. Without their support and encouragement my task would not have been possible. Thanks so much, my dearest loved ones.\n\nxxxi\n\nThis page intentionally left blank\n\nAbout the Author Vaughn Vernon is a veteran software craftsman with more than twenty-five years of experience in software design, development, and architecture. He is a thought leader in simplifying software design and implementation using innovative methods. He has been programming with object-oriented languages since the 1980s and applying the tenets of Domain-Driven Design since his Smalltalk domain modeling days in the early 1990s. His experience spans a wide range of business domains, including aerospace, environmental, geospatial, insurance, medical and health care, and telecommunications. He has also succeeded in technical endeavors, creating reusable frameworks, libraries, and implementation acceleration tools. He consults and speaks internationally and has taught his Implementing Domain-Driven Design classes on multiple continents. You can read more about his latest efforts at www.VaughnVernon.co and follow him on Twitter here: @VaughnVernon.\n\nxxxiii\n\nThis page intentionally left blank\n\nGuide to This Book The book Domain-Driven Design by Eric Evans presents what is essentially a large pattern language. A pattern language is a set of software patterns that are intertwined because they are dependent on each other. Any one pattern references one or more other patterns that it depends on, or that depend on it. What does this mean for you? It means that as you read any given chapter of this book, you could run into a DDD pattern that isn’t discussed in that chapter and that you don’t already know. Don’t panic, and please don’t stop reading out of frustration. The referenced pattern is very likely explained in detail in another chapter of the book. In order to help unravel the pattern language, I used the syntax found in Table G.1 in the text.\n\nTable G.1\n\nThe Syntax Used in This Book\n\nWhen You See This . . .\n\nIt Means This . . .\n\nPattern Name (#)\n\n1. It is the first time the pattern is referenced in the chapter that you are reading, or 2. It is an important additional reference to a pattern that was already mentioned in the chapter, but it’s essential to know where to locate more information about it at that point in the text.\n\nBounded Context (2)\n\nThe chapter you are reading is referencing Chapter 2 for you to find out deep details about Bounded Contexts.\n\nBounded Context\n\nIt is the way I reference a pattern already mentioned in the same chapter. I don’t want to irritate you by making every reference to a given pattern bold, with a chapter number.\n\n[REFERENCE]\n\nIt is a bibliographic reference to another work. continues\n\nxxxv\n\nxxxvi\n\nG U IDE\n\nTO\n\nTable G.1\n\nTH IS B OOK\n\nThe Syntax Used in This Book (Continued )\n\nWhen You See This . . .\n\nIt Means This . . .\n\n[Evans] or [Evans, Ref]\n\nI don’t cover the specific referenced DDD pattern extensively, and if you want to know more, you need to read these works by Eric Evans. (They’re always recommended reading!) [Evans] means his classic book, Domain-Driven Design. [Evans, Ref] means a second publication that is a separate, condensed reference to the patterns in [Evans] that have been updated and extended.\n\n[Gamma et al.] and [Fowler, P of EAA]\n\n[Gamma et al.] means the classic book Design Patterns. [Fowler, P of EAA] means Martin Fowler’s Patterns of Enterprise Application Architecture. I reference these works frequently. Although I reference several other works as well, you will tend to see these a bit more than others. Examine the full bibliography for details.\n\nIf you start reading in the middle of a chapter and you see a reference such as Bounded Context, remember that you’ll probably find a chapter in this book that covers the pattern. Just glance at the index for a richer set of references. If you have already read [Evans] and you know its patterns to some degree, you’ll probably tend to use this book as a way to clarify your understanding of DDD and to get ideas for how to improve your existing model designs. In that case you may not need a big-picture view right now. But if you are relatively new to DDD, the following section will help you see how the patterns fit together, and how this book can be used to get you up and running quickly. So, read on.\n\nBig-Picture View of DDD Early on I take you through one of the pillars of DDD, the Ubiquitous Language (1). A Ubiquitous Language is applicable within a single Bounded Context (2). Straightaway, you need to familiarize yourself with that critical domain modeling mindset. Just remember that whichever way your software models are designed tactically, strategically you’ll want them to reflect the following: a clean Ubiquitous Language modeled in an explicitly Bounded Context.\n\nG U IDE\n\nTO\n\nTH IS B OOK\n\nStrategic Modeling A Bounded Context is a conceptual boundary where a domain model is applicable. It provides a context for the Ubiquitous Language that is spoken by the team and expressed in its carefully designed software model, as shown in Figure G.1. Ubiquitous Language (1) modeled inside Equities domain model with a single, clean Ubiquitous Language\n\nEquities Context Bounded Context (2) Explicit boundary around model Figure G.1\n\nA diagram illustrating a Bounded Context and relevant Ubiquitous Language\n\nAs you practice strategic design, you’ll find that the Context Mapping (3) patterns seen in Figure G.2 work in harmony. Your team will use Context Maps to understand their project terrain. We’ve just considered the big picture of DDD’s strategic design. Understanding it is imperative.\n\nAccounts Domain Model\n\nBounded Context (2)\n\nAccounts Context ? Equities Domain Model\n\n?\n\nU D\n\nEquities Context Context Mappings (3) with integration relationships: Open Host Service, Published Language, Anticorruption Layer, Customer-Supplier, Partnership, Conformist, Shared Kernel Figure G.2\n\nContext Maps show the relationships among Bounded Contexts.\n\nxxxvii\n\nxxxviii\n\nG U IDE\n\nTO\n\nTH IS B OOK\n\nArchitecture Sometimes a new Bounded Context or existing ones that interact through Context Mapping will need to take on a new style of Architecture (4). It’s important to keep in mind that your strategically and tactically designed domain models should be architecturally neutral. Still, there will need to be some architecture around and between each model. A powerful architectural style for hosting a Bounded Context is Hexagonal, which can be used to facilitate other styles such as Service-Oriented, REST and Event-Driven, and others. Figure G.3 depicts a Hexagonal Architecture, and while it may look a little busy, it’s a fairly simplistic style to employ. Sometimes we may be tempted to place too much emphasis on architecture rather than focusing on the importance of carefully crafting a DDD-based model. Architecture is important, but architectural influences come and go. Remember to prioritize correctly, placing more emphasis on the domain model, which has greater business value and will be more enduring.\n\nArchitecture (4) such as the Hexagonal style Tactical domain model at the heart of the Bounded Context\n\nAdapter Adapter Adapter\n\nApplication Adapter Adapter Adapter\n\nDomain Model\n\nAdapter\n\nAdapter\n\nFigure G.3\n\nThe Hexagonal Architecture with the domain model at the heart of the software\n\nG U IDE\n\nTO\n\nTH IS B OOK\n\nxxxix\n\nTactical Modeling We model tactically inside a Bounded Context using DDD’s building block patterns. One of the most important patterns of tactical design is Aggregate (10), as illustrated in Figure G.4. An Aggregate is composed of either a single Entity (5) or a cluster of Entities and Value Objects (6) that must remain transactionally consistent throughout the Aggregate’s lifetime. Understanding how to effectively model Aggregates is quite important and one of the least well understood techniques among DDD’s building blocks. If they are so important, you may be wondering why Aggregates are placed later in the book. First of all, the placement of tactical patterns in this book follows the same order as is found in [Evans]. Also, since Aggregates are based on other tactical patterns, we cover the basic building blocks—such as Entities and Value Objects—before the more complex Aggregate pattern. An instance of an Aggregate is persisted using its Repository (12) and later searched for within and retrieved from it. You can see an indication of that in Figure G.4. Use stateless Services (7), such as seen in Figure G.5, inside the domain model to perform business operations that don’t fit naturally as an operation on an Entity or a Value Object.\n\nAggregate (10) with transactional consistency boundary\n\nAggregate Type 1\n\nAggregate Type 2\n\nValue Type 1\n\nRoot Entity 1\n\nRoot Entity 2\n\nValue Type 3\n\n0..*\n\nRepository 1 Figure G.4\n\n0..*\n\nValue Type 2\n\nEntity Type 3\n\nValue Type 4\n\nState inside reflecting true business rules must remain completely consistent\n\nUse a Repository (12) to persist a specific Aggregate type\n\nRepository 2\n\nTwo Aggregate types with their own transactional consistency boundaries\n\nxl\n\nG U IDE\n\nTO\n\nTH IS B OOK\n\nUse a Service (7) to perform an operation that cuts across Aggregates, for example\n\nQuery operation\n\nRoot Entity 1\n\nDomain Service 1 Command operation\n\nFigure G.5\n\nRoot Entity 2\n\nDomain Services carry out domain-specific operations, which may involve multiple domain objects.\n\nUse Domain Events (8) to indicate the occurrence of significant happenings in the domain. Domain Events can be modeled a few different ways. When they capture occurrences that are a result of some Aggregate command operation, the Aggregate itself publishes the Event as depicted in Figure G.6. Although often given little thought, it’s really important to design Modules (9) correctly. In its simplest form, think of a Module as a package in Java or a namespace in C#. Remember that if you design your Modules mechanically rather than according to the Ubiquitous Language, they will probably do more harm than good. Figure G.7 illustrates how Modules should contain a limited set of cohesive domain objects. Of course, there’s much more to implementing DDD, and I won’t try to cover it all here. There’s a whole book ahead of you that does just that. I think this Guide gets you off on the right foot for your journey through implementing DDD. So, enjoy the journey!\n\nEvent create\n\nSubscriber handle\n\nAggregate\n\nSubscriber publish\n\nEvent Publisher\n\nEvent\n\nSubscriber\n\nFigure G.6\n\nDomain Events can be published by Aggregates.\n\nG U IDE\n\nTO\n\nTH IS B OOK\n\ncom.companyname.context.domain.model.concept\n\nFigure G.7\n\nEntity 1\n\nEntity 2\n\nIdentity\n\nValue Type\n\nA Module contains and organizes cohesive domain objects.\n\nOh, and just to get you familiarized with Cowboy Logic, here’s one for the trail: Cowboy Logic AJ: “Don’t worry about bitin’ off more than you can chew. Your mouth is probably a whole lot bigger than you think.” ;-) LB: “You meant to say ‘mind,’ J. Your mind is bigger than you think!”\n\nxli\n\nThis page intentionally left blank\n\nChapter 1\n\nGetting Started with DDD Design is not just what it looks like and feels like. Design is how it works. —Steve Jobs We strive to produce quality in the software we develop. We achieve some quality by using tests to help us avoid delivering software with a fatal number of bugs. Yet, even if we could produce completely bug-free software, that in itself does not necessarily mean that a quality software model is designed. The software model—the way the software expresses the solution to the business goal being sought—could still suffer greatly. Delivering software with few defects is obviously good. Still, we can reach higher for a well-designed software model that explicitly reflects the intended business objective, and our work may even reach the level of great. The software development approach called Domain-Driven Design, or DDD, exists to help us more readily succeed at achieving high-quality software model designs. When implemented correctly, DDD helps us reach the point where our design is exactly how the software works. This book is about helping you correctly implement DDD. You may be completely new to DDD, you may have tried it and struggled, or you may have already succeeded with it before. Regardless, you no doubt are reading this book because you want to improve your ability to implement DDD, and you can. The chapter road map helps you target your specific needs. Road Map to This Chapter • Discover what DDD can do for your projects and your teams as you grapple with complexity. • Find out how to score your project to see if it deserves the DDD investment. • Consider the common alternatives to DDD and why they often lead to problems. • Grasp the foundations of DDD as you learn how to take the first steps on your project. • Learn how to sell DDD to your management, domain experts, and technical team members. continues\n\n1\n\n2\n\nChapter 1\n\nG ET T I NG START ED\n\nWITH\n\nDDD\n\n• Face the challenges of using DDD armed with knowledge of how to succeed. • Look in on a team that is learning how to implement DDD.\n\nWhat should you expect from DDD? Not a heavy, dense, ceremonial process that blocks your way to progress. Rather, expect to use the agile development techniques you probably already have come to trust. Beyond agile, anticipate the acquisition of methods that help you gain deep insight into your business domain, with the prospect of producing testable, malleable, organized, carefully crafted, high-quality software models. DDD gives you both the strategic and tactical modeling tools necessary to design high-quality software that meets core business objectives.\n\nCan I DDD? You can implement DDD if you have • A passion for creating excellent software every day, and the tenacity to achieve that goal • The eagerness to learn and improve, and the fortitude to admit you need to • The aptitude to understand software patterns and how to properly apply them • The skill and patience to explore design alternatives using proven agile methods • The courage to challenge the status quo • The desire and ability to pay attention to details, to experiment and discover • A drive to seek ways to code smarter and better I’m not going to tell you that there isn’t a learning curve. To put it bluntly, the learning curve can be steep. Yet, this book has been put together to help flatten the curve as much as possible. My goal is to help you and your team implement DDD with the greatest potential for success. DDD isn’t first and foremost about technology. In its most central principles, DDD is about discussion, listening, understanding, discovery, and business\n\nC A N I DDD?\n\nvalue, all in an effort to centralize knowledge. If you are capable of understanding the business in which your company works, you can at a minimum participate in the software model discovery process to produce a Ubiquitous Language. Sure, you’re going to have to learn more about the business, lots more. Still, you are on your way to succeeding with DDD already because you can comprehend the concepts of your business, you revel in developing great software, and that gives you the proper footing to take DDD all the way. Won’t having years, even a decade or two, of software development experience help? It might. Nevertheless, software development experience doesn’t give you the ability to listen and learn from domain experts, the people who know the most about some high-priority area of the business. You are at a greater advantage if you can engage with those who seldom, if ever, express themselves using technical lingo. You’re going to have to listen and listen carefully. You’re going to have to respect their viewpoint and trust that they know a lot more than you do. There Are Big Advantages to Engaging with Domain Experts You are at a greater advantage if you can engage with those who seldom, if ever, express themselves using technical lingo. Just as you are going to learn from them, there is a high probability that they are also going to learn from you.\n\nWhat you may like best about DDD is that the domain experts are also going to have to listen to you. You are on the team just as they are. As strange as it may seem, the domain experts don’t know everything about their business, and they are also going to learn more about it. Just as you are going to learn from them, there is a high probability that they are also going to learn from you. Your questions about what they know will most likely also uncover what they don’t know. You’ll be directly involved in helping everyone on the team discover a deeper understanding of the business, even shaping the business. It’s great when a team learns and grows together. If you give it a chance, DDD makes that possible. But We Don’t Have Domain Experts A domain expert is not one by job title. These are the people who know the line of business you are working in really well. They probably have a lot of background in the business domain, and they might be product designers or even your salespeople. Look past the job title. The people you are looking for know more about what you are working on than anyone else, and for sure way more than you know. Find them. Listen. Learn. Design in code.\n\nSo far we’re off to a pretty reassuring start. Still, I am also not going to tell you that technical ability isn’t important, that somehow you can get by without\n\n3\n\n4\n\nChapter 1\n\nG ET T I NG START ED\n\nWITH\n\nDDD\n\nit. You will have to grasp some advanced software domain modeling concepts. Even so, it doesn’t necessarily mean you are going to be in over your head. If you have abilities somewhere between grasping Head First Design Patterns [Freeman et al.] and grokking the original Design Patterns [Gamma et al.] text, or even more advanced patterns, you stand a really good chance of succeeding with DDD. You can bank on this: I’m going to do everything I can to make that happen by lowering the bar, no matter what your level of experience. What’s a Domain Model? It’s a software model of the very specific business domain you are working in. Often it’s implemented as an object model, where those objects have both data and behavior with literal and accurate business meaning. Creating a unique, carefully crafted domain model at the heart of a core, strategic application or subsystem is essential to practicing DDD. With DDD your domain models will tend to be smallish, very focused. Using DDD, you never try to model the whole business enterprise with a single, large domain model. Phew, that’s good!\n\nConsider the following perspectives of the people who can benefit from DDD. I know you fit in here somewhere: • Newbie, junior developer: “I’m young, with fresh ideas, I’ve got pent-up energy to code, and I’m going to have an impact. What’s got me miffed is one of the projects I sprint on. I didn’t expect that my first gig off campus would mean shoveling data back and forth using lots of almost identical yet redundant ‘objects.’ Why is this architecture so complex if that’s all that’s happening? What’s up with that? The code breaks a lot when I try to change it. Does anyone actually understand what it’s supposed to do? Now there are some complex new features I have to add. I regularly slap an adapter around legacy classes to shield me from the goo. No joy. I’m sure there’s something I can do besides code and debug all day and night just to finish iterations. Whatever that is, I’m going to track it down and own it. I heard some of the others talking about DDD. It sounds like Gang of Four, but tuned for the domain model. Nice.” Gotcha covered. • Midlevel developer: “Over the past few months I’ve been included on the new system. It’s my turn to make a difference. I get it, but what I’m missing are profound insights when I’m meeting with the senior developers. Sometimes things seem whacked, but I’m not sure why. I’m going to help change the way things are done around here. I know that throwing technology at a problem only takes you so far, and that’s basically not far enough. What I need is a sound software development technique that’s\n\nC A N I DDD?\n\ngoing to help me become a wise and experienced software practitioner. One of the senior architects, the new guy, made a pitch for something called DDD. I’m listening.” You’re sounding senior already. Read on. Your forward-thinking attitude will be rewarded. • Senior developer, architect: “I’ve used DDD on a few projects, but not since landing this new position. I like the power of the tactical patterns, but there’s a lot more I could apply, with strategic design being one. What I found most insightful when reading [Evans] was the Ubiquitous Language. That’s powerful stuff. I’ve had discussions with a number of my teammates and management, trying to influence DDD’s adoption here. One of the new kids and a few of the midlevel and senior members are jazzed about the prospects. Management isn’t so excited. I recently joined this company, and although I was brought in to lead, it seems that the organization is less interested in disruptive advancements than I thought. Whatever. I’m not giving up. With other developers psyched about it, I know we can make it happen. The payoffs are going to be much greater than anticipated. We’ll draw the pure business people—the domain experts—closer to our technical teams, and we’ll actually invest in our solutions, not just grunt them out iteration after iteration.” Now that’s what a leader does. This book has lots of guidance that shows how to succeed with strategic design. • Domain expert: “I’ve been involved in specifying the IT solutions to our business challenges for a long time now. Maybe it’s too much to expect, but I wish the developers understood better what we do here. They’re always talking down to us like we’re stupid. What they don’t understand is, if it wasn’t for us there wouldn’t be jobs here for them to mess around with computers. The developers always have some strange way of talking about what our software does. If we talk about A, they say it’s really called B. It’s like we have to have some sort of dictionary and road map on hand every time we try to communicate what we need. If we don’t let them have their way by calling B what we know is A, they don’t cooperate. We waste so much time in this mode. Why can’t the software just work the way the real experts think about the business?” You’ve got that right. One of the biggest problems is the false need for translation between business people and techies. This chapter is for you. As you’re going to see, DDD puts you and developers on level ground.\n\n5\n\n6\n\nChapter 1\n\nG ET T I NG START ED\n\nWITH\n\nDDD\n\nAnd, surprise! You’ve got some developers already leaning your way. Help them here. • Manager: “We are shipping software. It’s not always with the greatest result, and changes seem to take longer than they should. The developers keep talking about some domain something-or-another. I’m not sure we need to get high centered on yet another technique or methodology, like it’s some kind of silver bullet. I’ve heard all that a thousand times before. We try, the fad dies, and we are right back to the same-old same-old. I keep saying that we need to stay the course and stop dreaming, but the team keeps hounding me. They’ve worked hard, so I owe them a listen. They are smart people and they all deserve a chance to improve things before they get torqued and move on. I could allow them some time to learn and adjust if I can get backing from upper management. I think I could get that approval if I can convince my boss of the team’s claims of achieving critical software investment and a centralization of business knowledge. Truth is, it will make my job easier if I can do something to inspire trust and cooperation between my teams and business experts. Anyway, that’s what I am hearing I can do.” Good manager! Whoever you are, here’s an important heads-up. To succeed with DDD you are going to have to learn something, and actually a lot of somethings. That shouldn’t be a big deal, though. You are smart and you have to learn all the time. Yet we all face this challenge: Personally I’m always ready to learn, although I do not always like being taught. —Sir Winston Churchill\n\nThat’s where this book comes in. I’ve tried to make the teaching as pleasant as possible while delivering the vital understanding you need to implement DDD with success. Your question, though, is: “Why should I do DDD?” That’s fair.\n\nWhy You Should Do DDD Actually, I’ve already given you some pretty good reasons why DDD makes so much practical sense. At the risk of breaking the DRY principle (“Don’t repeat yourself”), I reiterate them here and also add to the earlier reasons. Does anyone hear an echo?\n\nW H Y YOU S HOU LD D O DDD\n\n• Put domain experts and developers on a level playing field, which produces software that makes perfect sense to the business, not just the coders. This doesn’t mean merely tolerating the opposite group. It means becoming one cohesive, tight-knit team. • That “makes sense to the business” thing means investing in the business by making software that is as close as possible to what the business leaders and experts would create if they were the coders. • You can actually teach the business more about itself. No domain expert, no C-level manager, no one, ever knows every single thing about the business. It’s a constant discovery process that becomes more insightful over time. With DDD, everybody learns because everybody contributes to discovery discussions. • Centralizing knowledge is key, because with that the business is capable of ensuring that understanding the software is not locked in “tribal knowledge,” available only to a select few, who are usually only the developers. • There are zero translations between the domain experts, the software developers, and the software. That doesn’t mean maybe some few translations. It means zero translations because your team develops a common, shared language that everyone on the team speaks. • The design is the code, and the code is the design. The design is how it works. Knowing the best code design comes through quick experimental models using an agile discovery process. • DDD provides sound software development techniques that address both strategic and tactical design. Strategic design helps us understand what are the most important software investments to make, what existing software assets to leverage in order to get there fastest and safest, and who must be involved. Tactical design helps us craft the single elegant model of a solution using time-tested, proven software building blocks. Like any good, high-yielding investment, DDD has some up-front cost of time and effort for the team. Considering the typical challenges encountered by every software development effort will reinforce the need to invest in a sound software development approach.\n\nDelivering Business Value Can Be Elusive Developing software that delivers true business value is not the same thing as developing ordinary business software. Software that delivers true business value aligns with the business strategic initiatives and bears solutions with\n\n7\n\n8\n\nChapter 1\n\nG ET T I NG START ED\n\nWITH\n\nDDD\n\nclearly identifiable competitive advantage—software that is not about technology, but about the business. Business knowledge is never centralized. Development teams have to balance and prioritize among the needs and requests of multiple stakeholders and engage with many people having diverse skill sets, all with the goal of uncovering software functional and nonfunctional requirements. After gathering all that information, how can teams be certain that any given requirement delivers true business value? In fact, what are the business values being sought, and how do you uncover them, prioritize them, and realize them? One of the worst disconnects of a business software development effort is seen in the gap between domain experts and software developers. Generally speaking, true domain experts are focused on delivering business value. On the other hand, software developers are typically drawn to technology and technical solutions to business problems. It’s not that software developers have wrong motivations; it’s just what tends to grab their attention. Even when software developers engage with domain experts, the collaboration is largely at a surface level, and the software that gets developed often results in a translation/mapping between how the business thinks and operates and how the software developer interprets that. The resulting software generally does not reflect a recognizable realization of the mental model of the domain experts, or perhaps it does so only partially. Over time this disconnect becomes costly. The translation of domain knowledge into software is lost as developers transition to other projects or leave the company. A different, yet related problem is when one or more domain experts do not agree with each other. This tends to happen because each expert has more or less experience in the specific domain being modeled, or they are simply experts in related but different areas. It’s also common for multiple “domain experts” to have no expertise in a given domain, where they are more of a business analyst, yet they are expected to bring insightful direction to discussions. When this situation goes unchecked, it results in blurred rather than crisp mental models, which lead to conflicting software models. Worse still is when the technical approach to software development actually wrongly changes the way the business functions. While a different scenario, it is well known that enterprise resource planning (ERP) software will often change the overall business operations of an organization to fit the way the ERP functions. The total cost of owning the ERP cannot be fully calculated in terms of license and maintenance fees. The reorganization and disruption to the business can be far more costly than either of those two tangible factors. A similar dynamic is at play as your software development teams interpret what the business needs into what the newly developed software actually does. This can be both costly and disruptive to the business, its customers, and\n\nW H Y YOU S HOU LD D O DDD\n\nits partners. Furthermore, this technical interpretation is both unnecessary and avoidable with the use of proven software development techniques. The solution is a key investment.\n\nHow DDD Helps DDD is an approach to developing software that focuses on these three primary aspects: 1. DDD brings domain experts and software developers together in order to develop software that reflects the mental model of the business experts. This does not mean that effort is spent on modeling the “real world.” Rather, DDD delivers a model that is the most useful to the business. Sometimes useful and realistic models happen to intersect, but to the degree that they diverge, DDD chooses useful. With this aspect the efforts of domain experts and software developers are devoted to jointly developing a Ubiquitous Language of the areas of the business that they are focused on modeling. The Ubiquitous Language is developed with full team agreement, is spoken, and is directly captured in the model of the software. It is worth reiterating that the team is composed of both domain experts and software developers. It’s never “us and them.” It’s always us. This is a key business value that allows business know-how to outlive the relatively short initial development efforts that deliver the first few versions of the software, and the teams that produce it. It’s the point where the cost of developing software is a justifiable business investment, not just a cost center. This entire effort unifies domain experts who initially disagree with each other, or who simply lack core knowledge of the domain. Further, it strengthens the close-knit team by spreading deep domain insight among all team members, including software developers. Consider this the hands-on training that every company should invest in its knowledge workers. 2. DDD addresses the strategic initiatives of the business. While this strategic design approach naturally includes technical analysis, it is more concerned with the strategic direction of the business. It helps define the best inter-team organizational relationships and provides early-warning systems for recognizing when a given relationship could cause software and even project failure. The technical aspects of strategic design have the goal of cleanly bounding systems and business concerns, which protects each business-level service. This provides meaningful motivations\n\n9\n\n10\n\nChapter 1\n\nG ET T I NG START ED\n\nWITH\n\nDDD\n\nfor how an overall service-oriented architecture or business-driven architecture is achieved. 3. DDD meets the real technical demands of the software by using tactical design modeling tools to analyze and develop the executable software deliverables. These tactical design tools allow developers to produce software that is a correct codification of the domain experts’ mental model, is highly testable, is less error prone (a provable statement), performs to service-level agreements (SLAs), is scalable, and allows for distributed computing. DDD best practices generally address a dozen or more higher-level architectural and lower-level software design concerns, with a focus on recognizing true business rules and data invariants, and protecting the rules from error situations. Using this approach to software development, you and your team can succeed in delivering true business value.\n\nGrappling with the Complexity of Your Domain We primarily want to use DDD in the areas that are most important to the business. You don’t invest in what can be easily replaced. You invest in the nontrivial, the more complex stuff, the most valuable and important stuff that promises to return the greatest dividends. That’s why we call such a model a Core Domain (2). It is these, and in second priority the significant Supporting Subdomains (2), that deserve and get the biggest investment. Rightly, then, we need to grasp what complex means. Use DDD to Simplify, Not to Complicate Use DDD to model a complex domain in the simplest possible way. Never use DDD to make your solution more complex.\n\nWhat qualifies as complex will differ from business to business. Different companies have different challenges, different levels of maturity, and different software development capabilities. So rather than determining what is complex, it may be easier to determine what is nontrivial. Thus, your team and management will have to determine if a system you are planning to work on deserves the cost of making a DDD investment.\n\nDDD Scorecard: Use Table 1.1 to determine whether your project qualifies for an investment in DDD. If a row on the scorecard describes your project, place the corresponding number of points in the right-hand column. Tally all the points for your project. If it’s 7 or higher, seriously consider using DDD.\n\nTable 1.1\n\nThe DDD Scorecard\n\nDoes Your Project Score a Total of 7 Points or Higher? If Your Project . . .\n\nPoints\n\nSupporting Thoughts\n\n11\n\nIf your application is completely data-centric and truly qualifies for a pure CRUD solution, where every operation is basically a simple database query to Create, Read, Update, or Delete, you don’t need DDD. Your team just needs to put a pretty face on a database table editor. In other words, if you can trust your users to insert data directly into a table, update it, and sometimes delete it, you wouldn’t even need a user interface. That’s not realistic, but it’s conceptually relevant. If you could even use a simple database development tool to create a solution, don’t waste your company’s time and money on DDD.\n\n0\n\nThis seems like a no-brainer, but it’s not usually that easy to determine simple versus complex. It’s not as if every application that isn’t pure CRUD deserves the time and effort of using DDD. So maybe we could come up with other metrics to help us draw a line between what is complex and what is not . . .\n\nIf your system requires just 30 or fewer business operations, it’s probably pretty simple. This would mean that your application would have no more than 30 total user stories or use case flows, with each of those flows having only minimal business logic. If you could quickly and easily develop such an application using Ruby on Rails or Groovy and Grails and not feel the pain of lacking power and control over complexity and change, your system probably doesn’t need to use DDD.\n\n1\n\nTo be clear, I am talking about 25 to 30 single business methods, not 25 to 30 whole service interfaces, each with multiple methods. The latter might be complex.\n\nSo let’s say that somewhere in the range of 30 to 40 user stories or use case flows could be creeping toward complexity. Your system might be getting into DDD territory.\n\n2\n\nCaveat emptor: Very often complexity is not recognized soon enough. We software developers are really, really good at underestimating complexity and level of effort. Just because we might want to code up a Rails or Grails application doesn’t mean we should. In the long run those could hurt more than help.\n\nYour Score\n\ncontinues\n\nTable 1.1\n\nThe DDD Scorecard (Continued )\n\nDoes Your Project Score a Total of 7 Points or Higher? If Your Project . . . Even if the application is not going to be complex now, will it grow in complexity? You may not know this for sure until real users start working with it, but there is a step in the “Supporting Thoughts” column that may help uncover the true situation.\n\nPoints 3\n\nSupporting Thoughts Here it pays off to walk through the more complex usage scenarios with domain experts and see where it leads. Are domain experts . . .\n\n12\n\n1. . . . already asking for more complex features? If so, it’s likely an indication that the application is already or will soon become too complex to use a CRUD approach.\n\nBe careful here. If there is any hint at all that the application has even moderate complexity—here’s a good time to be paranoid—that may be sufficient indication that it will actually be more than moderately complex. Lean toward DDD.\n\n2. . . . so bored with the features that they can hardly bear discussing them? It’s probably not complex.\n\nThe application’s features are going to change often over a number of years, and you can’t anticipate that the kinds of changes will be simple.\n\n4\n\nDDD can help you manage the complexity of refactoring your model over time.\n\nYou don’t understand the Domain (2) because it’s new. As far as you and your team know, nobody has done this before. That most likely means it’s complex, or at least deserves due diligence with analytical scrutiny to determine the level of complexity.\n\n5\n\nYou are going to need to work with domain experts and experiment with models to get it right. You certainly also scored on one o"
    }
}