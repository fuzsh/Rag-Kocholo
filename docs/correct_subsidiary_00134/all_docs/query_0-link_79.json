{
    "id": "correct_subsidiary_00134_0",
    "rank": 79,
    "data": {
        "url": "https://patents.google.com/patent/WO2008150675A1/en",
        "read_more_link": "",
        "language": "en",
        "title": "WO2008150675A1 - Event processing language - Google Patents",
        "top_image": "https://patentimages.storage.googleapis.com/10/bd/fd/807665932ee20d/imgf000012_0001.png",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/10/bd/fd/807665932ee20d/imgf000012_0001.png",
            "https://patentimages.storage.googleapis.com/b8/2e/47/9b87f48f036dab/imgf000014_0001.png",
            "https://patentimages.storage.googleapis.com/99/71/55/8aaa293870e14c/imgf000041_0001.png",
            "https://patentimages.storage.googleapis.com/a0/29/60/46ed7e6ba3f685/imgf000045_0001.png",
            "https://patentimages.storage.googleapis.com/c2/26/0b/d2c28ef1ebf1be/imgf000046_0001.png",
            "https://patentimages.storage.googleapis.com/cf/14/69/57764c70d843d5/imgf000058_0001.png",
            "https://patentimages.storage.googleapis.com/25/eb/62/f03a454b8e1169/imgf000059_0001.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2007-05-29T00:00:00",
        "summary": "",
        "meta_description": "An event processor can use event processing queries to operate an event. Event processing queries can include a 'retain' clause that limits the amount of data over which the query is run.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/WO2008150675A1/en",
        "text": "EVENT PROCESSING LANGUAGE\n\nInventors: Alexandra de Castro Alves\n\nJames Taylor\n\nCLAIM OF PRIORITY\n\n[0001] This application claims priority from the following co-pending application, which is hereby incorporated in their entirety: U.S. Provisional Application No. 60/940,655 entitled: \"EVENT PROCESSING LANGUAGE\", by Alexandre Alves, et al., filed May 29, 2007, (Attorney Docket No. BEAS-02189US0); U.S. Provisional Application No. 60/947,011 entitled: \"EVENT PROCESSING QUERY LANGUAGE\", by Alexandre Alves, et al., filed June 29, 2007, (Attorney Docket No. BEAS-02189US4);U.S. Utility Application No. 12/043.480 entitled: \"EVENT PROCESSING QUERY LANGUAGE INCLUDING RETAIN CLAUSE\", by Alexandre Alves, et al., filed March 6, 2008, (Attorney Docket No. BEAS-02189US1); U.S. Utility Application No. 12/043,508 entitled: \"EVENT PROCESSING QUERY LANGUAGE INCLUDING AN OUTPUT CLAUSE\", by Alexandre Alves, et al., filed March 6, 2008, (Attorney Docket No. BEAS-02189US2); and to U.S. UÏlity Application No. 12/043,552 entitled: \"EVENT PROCESSING QUERY LANGUAGE USING PATTERN MATCHING\", by Alexandre Alves, et al., filed March 6, 2008, (Attorney Docket No. BEAS-02189US3).\n\nBACKGROUND\n\n[0002J Event processing is becoming more and more popular. In a complex event processor, streams of data are evaluated in real time. Because of the amount of data and the operation speeds required, the data is not stored into a database before it is processed. This means that a typical database language like SQL is not sufficient for processing the data.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\n|0003| Figure 1 illustrates an event processor of one embodiment of the present invention. [0004] Figure 2 illustrates the use of a \"retain\" clause in an event processing language. [0005] Figure 3 illustrates the use of an \"output\" clause in an event processing language. [0006] Figure 4 illustrates the use of pattern matching in an event processing language. [0007] Figures 5-10 illustrate the operation of event processing queries. [0008] Figure 11 illustrates an XML schema for a rules file of one embodiment. [0009] Figure 12 illustrates a high level view of an event-driven system.\n\n[0010] Figure 13 illustrates an exemplary application model of one embodiment. |00111 Figure 14 illustrates an exemplary UML class diagram for the logical components of a realtime application server.\n\n[0012] Figure 15 illustrates an exemplary event hierarchy for a financial trading system application. [0013] Figure 16 illustrates an exemplary event processing network of a complete business.\n\n[0014] Figure 17 illustrates an exemplary realtime application server product stack.\n\n[0015] Figure 18 illustrates an exemplary Acceptor-Connector design pattern interaction diagram. (0016) Figures 19 and 20 illustrate exemplary join scenarios.\n\n[0017] Figures 21 and 22 illustrate exemplary sequence diagrams.\n\nDETAILED DESCRIPTION [0018] Figure 1 shows an example of a system where event processor 102 operates on one or more event streams. In this example, event streams A and B are sent to the event processor 102. The event processing language queries can be used by the event processor 102 to operate on the event streams.\n\n[0019] In one example, the event processing language queries 104 are interpreted by an event processing query language interpreter 106. Queries 108 can then operate on event streams.\n\n[0020J Figure 2 shows an exemplary computer implemented system 200 comprising an event processor using queries to operate on an event. At least some event processing queries includes a \"retain\" clause that limits the amount of data over which the query is run. [0021] Figure 2 is a functional diagram. In the example of Figure 2, the query 204 includes a retain clause 206 that is used by the event processor 202 to determine how much of the event stream data 208 to retain for processing.\n\n[0022] The retained event data can be processed according to a function clause 210 to produce an output 212. The retain clause can limit the query to a certain time period or to a certain number of events. [0023] In one embodiment, at least one RETAIN clause is used in each FROM clause. The RETAIN clause can apply to all stream sources listed in the FROM clause that precedes it Conceptually it can define a window of event data for each stream source over which the query can be executed. In one embodiment, the RETAIN clause can have the following syntax: RETAIN\n\n( ALL [EVENTS] ) | ( [BATCH OF]\n\n( integer (EVENT| EVENTS) ) | ( timejnterva! (BASED ON prop_name)* ) ( PARTITION BY prop_name )*\n\n( WITH [n] (LARGEST | SMALLEST | UNIQUE) prop_name )* )\n\n[0024] To keep all events for a stream source, in one embodiment, ALL [EVENTS] can be specified in the retain clause. For example:\n\nSELECT AVG(price) FROM StockTick RETAIN ALL EVENTS\n\n[0025] In this case, the average price can be calculated based on all StockTick events that occur. Care should be taken with this option, however, since memory may run out when making calculations that require all or part of each event object to be retained under high volume scenarios. One such example would be in calculating a weighted average. [0026] In one embodiment, the amount of event data to keep when running the query may be determined in two ways. The first option is to specify the maximum number of events kept. For example, the query below would keep a maximum of 100 StockTick events on which the average price would be computed:\n\nSELECT AVG(price) FROM StockTick RETAIN 100 EVENTS\n\n[0027] As each new StockTick event comes in, the average price would be computed, with a maximum of 100 events being used for the calculation. [0028J The second option is to specify the time interval in which to collect event data. For example, the query below would keep 1 minute's worth of StockTick events and compute the average price for this data:\n\nSELECT AVG(price) FROM StockTick RETAIN 1 MINUTE\n\n[0029] In this case, as each new StockTick event comes in, again the average price would be computed. However, events that arrived more than one minute ago would be removed from the window with the average price being recalculated based on the remaining events in the window.\n\n[0030] In one embodiment, by default, the windows holding event data are sliding. With sliding windows, as a new event enters the window, an old events fall off the end of the window once the window is at capacity. Sliding windows can cause the query to be re- executed as each new event enters and/or old event leaves the window. An alternative is to specify that the event data should be batched prior to query execution. Only when the window is full, is the query is executed. After this, new event data can again be collected until the window is once again full at which time the query can be re-executed. [0031] For example, the query below would batch together 100 events prior to executing the query to compute the average price:\n\nSELECT AVG(price) FROM StockTÏck RETAIN BATCH OF 100 EVENTS\n\n[0032] Once executed, it would batch the next 100 events together prior to re-executing the query.\n\n[0033] In one embodiment, the time interval for the RETAIN clause may be specified in days, hours, minutes, seconds, and/or milliseconds: timejnterval: [day-pan]lhourÏarf\\[minute-parf\\[secondsÏarfl[millisecond$-parf]\n\nday-part: number (\"days\" | \"day\") hour-part: number (\"hours\" | \"hour\" | \"hr\") minute-part: number (\"minutes\" | \"minute\" | \"min\") seconds-part: number (\"seconds\" | \"second\" | \"sec\") milliseconds-part: number (\"milliseconds\" | \"millisecond\" | \"msec\" | \"ms\")\n\n[0034] Some examples of time intervals are: 10 seconds; 10 minutes; 30 seconds; 20 sec; 100 msec; 0.5 minutes; and 1 day 2 hours 20 minutes 15 seconds 110 milliseconds\n\n[0035] By default, the elapse of a time interval can be based on an internal system clock. However, in some cases, the time can be based on a timestamp value appearing as an event property. In one embodiment, a BASED ON clause can be used to specify the property name containing a long-typed timestamp value. This can be applicable for time- based windows. In this example, the StockTick events would be expected to have a 'timestamp' property of type long whose value would control inclusion into and removal from the window:\n\nSELECT AVG(Ïrice) FROM StockTick RETAIN 1 MINUTE BASED ON timestamp\n\n[0036] If more than one event source in the FROM clause has the same named property to store the timestamp, it can be listed a single time in the BASED ON clause. If multiple, differently named properties are used for the timestamp value, the BASED ON clause can be repeated. In one embodiment, when using the BASED ON clause, each stream source listed in the FROM clause has an associated timestamp property listed or an exception can be thrown. A property may be referred to by simply using its property name within the RETAIN clause. However, if ambiguities exist because the same property name exists in more than one stream source in the FROM clause, it can be prefixed with its alias name followed by a period (similar to the behavior of properties referenced in the SELECT clause). A PARTITION BY clause can allow a window to be further subdivided into multiple windows based on the unique values contained in the properties listed. For example, the following query can keep 3 events for each unique stock symbol:\n\nSELECT stockSymbol, price\n\nFROM StockTick RETAIN 3 EVENTS PARTITION BY stockSymbol [0037J Conceptually this can be similar to the GROUP BY functionality in SQL or EPL. However, the PARTITION BY clause only controls the size and subdivision of the window and does not cause event data to be aggregated as with the GROUP BY clause. However, in most cases, the PARTITION BY clause can be used in conjunction with the GROUP BY clause with same properties specified in both.\n\n[0038] The following examples illustrate the interaction between PARTITION BY and GROUP BY. In the first example, with the absence of the PARTITION BY clause, a total of 10 events can be kept across all stock symbols. SELECT stockSymbol, AVG(price)\n\nFROM StockTick RETAIN 10 EVENTS GROUP BY stockSymbol\n\n[00391 The average price for each unique set of stock symbol can be computed based on these 10 events. If a stock symbol of 11AAA\" comes into the window, it may cause a different stock symbol such as \"BBB\" to leave the window. This would cause the average price for both the \"AAA\" group as well as the \"BBB\" group to change. The second example includes the PARTITION BY clause and the GROUP BY clause.\n\nSELECT stockSymbol, AVG(price)\n\nFROM StockTick RETAIN 10 EVENTS PARTITION BY stockSymbol GROUP BY stockSymbol\n\n[0040] In this case, 10 events can be kept for each unique stock symbol. If a stock symbol of \"AAA\" comes into the window, it would only affect the sub-window associated with that symbol and not other windows for different stock symbols. Thus, in this case, only the average price of \"AAA\" would be affected. [0041J In one embodiment, the WITH clause can allow the largest, smallest, and unique property values to be kept in the window. For example, to keep the two highest priced stocks, the following statement would be used:\n\nSELECT stockSymbol, price FROM StockTick RETAIN 2 EVENTS WITH LARGEST price |0042] In the case of time-based windows, the [n] qualifier before the LARGEST or SMALLEST keyword can determine how many values are kept. For example, the following statement would keep the two smallest prices seen over one minute:\n\nSELECT stockSymbol, price FROM StockTick RETAIN 1 MINUTE WITH 2 SMALLEST price\n\n[0043] In the absence of this qualifier, the single largest or smallest value can be kept.\n\n[0044] The UNIQUE qualifier can cause the window to include only the most recent among events having the same value for the specified property. For example, the following query would keep only the last stock tick for each unique stock symbol: SELECT * FROM StockTick RETAIN 1 DAY WITH UNIQUE stockSymbol\n\n[0045| Prior events of the same property value can be posted as old events by the engine. The query is done as a sliding window.\n\n[0046] Figure 3 shows a computer-implemented system comprising an event processor 302 using queries to operate on event streams. At least some event queries 304 can include an output clause 306 to restrict the output of the query.\n\n[0047] In the functional diagram example of Figure 3, the query 304 includes an output clause 306 that is used by event processor 302 to determine how to throttle the output [0048] The output clause can hold the output of the query until a certain amount of time has occurred or until a certain number of events have been received. [0049] The output of the query can be another stream. An \"insert into\" clause can be used to create another stream.\n\n[0050J A \"First\" keyword can indicate that the first event or events in an output batch is to be output. A \"Last\" keyword can indicate that the last event or events in an output batch is to be output. [0051] The OUTPUT clause can be optional in the event processing language and can be used to control or stabilize the rate at which events are output. For example, the following statement can batch old and new events and outputs them at the end of every 90 second interval.\n\nSELECT * FROM StockTickEvent RETAIN 5 EVENTS OUTPUT EVERY 90 SECONDS\n\n[0052] Here is the syntax for output rate limiting of one embodiment:\n\nOUTPUT [ALL I ( (FIRST | LAST) [number^ EVERY number [EVENTS | time_unif\\ where timejunit MIN | MINUTE | MINUTES | SEC | SECOND | SECONDS | MILLISECONDS | MS\n\n[0053] The ALL keyword can be the default and specifies that all events in a batch 5 should be output. The batch size can be specified in terms of time or number of events.\n\n[0054J The FIRST keyword can specify that only the first event in an output batch is to be output. The optional number qualifier can allow more than one event to be output. The FIRST keyword can instruct the engine to output the first matching event(s) as soon as they arrive, and then ignore matching events for the time interval or number of events specified.0 After the time interval elapsed, or the number of matching events has been reached, the same cycle can start again.\n\n[0055] The LAST keyword can specify to only output the last event at the end of the given time interval or after the given number of matching events have been accumulated. The optional number qualifier allows more than one event to be output.\n\nS [0056J The time interval can also be specified in terms of minutes or milliseconds; the following statement is identical to the first one.\n\nSELECT * FROM StockTickEvent RETAIN 5 EVENTS OUTPUT EVERY 1.5 MINUTES\n\n[0057] Another way that output can be stabilized is by batching events until a certain0 number of events have been collected. The next statement only outputs when either 5 (or more) new or 5 (or more) old events have been batched.\n\nSELECT * FROM StockTickEvent RETAIN 30 SECONDS OUTPUT EVERY 5 EVENTS\n\n[0058] Additionally, in one embodiment, event output can be further modified by the5 optional LAST keyword, which causes output of only the last event(s) to arrive into an output batch. For the example below, the last five events would be output every three minutes.\n\nSELECT * FROM StockTickEvent RETAIN 30 SECONDS OUTPUT LAST 5 EVERY 3 MINUTES\n\n[0059] Using the FIRST keyword you can be notified at the start of the interval. This allows one to be immediately notified each time a rate falls below a threshold.\n\nSELECT * FROM TickRate RETAIN 30 SECONDS WHERE rate < 100\n\nOUTPUT FIRST EVERY 60 SECONDS [0060] The OUTPUT clause can interact in two ways with the GROUP BY and HAVING clauses. First, in the OUTPUT EVERY n EVENTS case, the number n can refer to the number of events arriving into the GROUP BY clause. That is, if the GROUP BY clause outputs only 1 event per group, or if the arriving events don't satisfy the HAVING clause, then the actual number of events output by the statement could be fewer than n. [0061 J Second, the LAST and ALL keywords can have special meanings when used in a statement with aggregate functions and the GROUP BY clause. The LAST keyword can specify that only groups whose aggregate values have been updated with the most recent batch of events should be output. The ALL keyword (the default) can specify that the most recent data for all groups seen so far should be output, whether or not these groups' aggregate values have just been updated.\n\n[0062| Figure 4 shows a computer-implemented system 400 comprising an event processor 402 using queries to operate on an event stream. At least some event processing queries 404 can include a \"matching\" clause 406 that matches a pattern in the event stream or streams. [0063| A variable can be bound to the event that matches. The variable can be used in a later query expression. The first or second stream can be filtered before the matching by filter clause of the query. A \"followed by\" operator can be used to match event conditions in a particular order. (0064J A query can use Boolean operations for a match. The Boolean operations include an \"AND\" an OR\" and a \"NOT\".\n\n[0065J In one embodiment, the pattern matching can use multiple event streams. [0066] A MATCHING clause can allow for the detection of a series of one or more events occurring that satisfies a specified pattern. Pattern expressions can be references to streams or stream aliases separated by logical operators such as AND, OR, and FOLLOWED BY to define the sequence of events that compose the pattern. The MATCHING clause can execute prior to the WHERE or HAVING clauses. The syntax can be as follows:\n\nMATCHING stÏam_Î¸xprÎ¸ssion ( ( AND | OR | [NOT] FOLLOWED BY ) stream_Î¸xprÎ¸ssion )*\n\n[00671 The stream_expression can be either a stream source name or a stream source alias optionally bound to a variable and filtered by a parenthesized expression. It can be prefixed by a NOT to match the absence of an event occurring: stmam_Î¸xpÏssion: [NOT\\[var_name=]{strÎ¸am_namÎ¸\\stmam_alias)[(filtÎ¸r_Î¸xprBssion)}\n\n[0068] The var_name can be bound to the event object occurring that triggers the match. It may be referenced as any other event property in filter expressions that follow as well as in other clauses such as the SELECT and WHERE clauses. An alias can be used to eliminate ambiguity if the same event type is used multiple times in the FROM clause. In one embodiment, the streamjexpression can optionally be followed by a parenthesized expression to filter the matching events of that type. The expression act as a precondition for events to enter the corresponding window and has the same syntax as a WHERE clause expression.\n\n(0069] In the example below we look for RFIDEvent event with a category of \"Perishable\" followed by an RFIDError whose id matches the id of the matched RFIDEvent object.\n\nSELECT * FROM RFIDEvent.RFIDError RETAIN 1 MINUTE MATCHING a=RFIDEvent(category=\"Perishable\")\n\nFOLLOWED BY RFIDError(id=a.id)\n\n[007Oj The next sections discuss the syntax, semantics, and additional operators available in the MATCHING clause to express temporal constraints for pattern matching of one embodiment.\n\n[00711 A FOLLOWED BY temporal operator can match on the occurrence of several event conditions in a particular order. This need not mean that two events must immediately follow each other.\n\n|0072| The AND logical operator can require both nested pattern expressions to turn true before the whole expression returns true. In the context of the MATCHING clause, the operator can match on the occurrence of several event conditions but not necessarily in a particular order. For example, the following pattern can match when both event A and event B are found:\n\nA AND B\n\n[0073} This pattern can match on any sequence of A followed by B in either order. In addition, it is not required that a B event immediately follow an A event - other events may appear in between the occurrence of an A event and a B event for this expression to return true.\n\n|0074] The OR logical operator can require either one of the expressions to turn true before the whole expression returns true. In the context of the MATCHING clause, the operator can match on the occurrence of either of several event conditions but not necessarily in a particular order.\n\n[0075J For example, the following pattern can match for either event A or event B:\n\nA OR B\n\n[0076J The following would detect all stock ticks that are either above a certain price or above a certain volume.\n\nStockTick(price > 1.0) OR StockTick( volume > 1000)\n\n(0077J The NOT operator can negate the truth value of an expression. In the context of the MATCHING clause, the operator can allow the absence of an event condition to be detected. [0078] In one embodiment, the following pattern matches only when an event A is encountered followed by event B but only if no event C was encountered before event B.\n\n( A FOLLOWED BY B ) AND NOT C\n\n[0079] The FROM clause may list the same event type multiple times, In this case, the event type alias can be used in the MATCHING clause. The statement below is an example in which the pattern matches for one RFIDEvent followed by another RFIDEvent prior to an RFIDErrorEvent occurring:\n\nSELECT * FROM RFIDEvent rfidA, RFIDEvent rfidB, RFIDErrorEvent rfidError RETAIN 1 MINUTE MATCHING ( rfidA FOLLOWED BY rfidB ) AND NOT rfidError\n\n[0080] Using the BATCH OF qualifier in the RETAIN clause can have special meaning when matching sequences of events. Without the BATCH OF qualifier, once the specified sequence of events is detected, continued attempts to match can be made with events following the first event in the matched sequence. However, with the BATCH OF qualifier, attempts to match can continue with events following the last event in the matched sequence. [0081| Consider exemplary operations for an example event sequence, as follows:\n\nA 1 B1 C 1 B2 A2 D 1 A3 B3 E1 A4 F1 B4\n\nEXEMPLARY EMBODIMENT\n\nS [0082] An exemplary embodiment of a system using methods of the present invention is described below. The following exemplary embodiment is not meant to be limiting as to terms, definitions and the like. For example, language in this section is not intended to limit or define the claim terms but only to describe a particular exemplary embodiment. This section merely describes one exemplary way to implement the present invention. Other architectures implementing the methods and systems of the present invention can be done. [0083] The following describes an Event Processing Language (EPL) for an event server, such as WebLogic Event Server 2.0. The language can allow event data from streams and external JDBC sources to be declaratively filtered, correlated, aggregated, and merged, with the ability to insert results to other streams for further downstream processing. The language can have additional functionality over SQL type languages to both a) constraint the amount of data over which the query is run since unlike relatively static relational table data, the stream data is continuously flowing, and b) detect a series of events that match a specified pattern.\n\n(0084] In one embodiment, the Complex Event Processor module can be broken down into the following functional components: event representation, processing model, programmatic interface, and language specification. [0085] Events can be represented as Plain Old JAVA Objects (POJOs) following the JavaBeans conventions. Event properties can be exposed through getter methods on the POJO. When possible, the results from EPL statement execution can also returned as POJOs. However, there are times when un-typed events are returned such as when event streams are joined. In this case, an instance of the Map collection interface can be returned. (0086] The EPL processing model can be continuous: results can be output as soon as incoming events are received that meet the constraints of the statement. In one embodiment, two types of events can be generated during output: insert events for new events entering the output window and remove events for old events exiting the output window. Listeners may be attached and notified when either or both type of events occur. [0087J In one embodiment,. incoming events may be processed through either sliding or batched windows. Sliding windows can process events by gradually moving the window over the data in single increments, while batched windows can process events by moving the window over data in discrete chunks. The window size may be defined by the maximum number of events contained or by the maximum amount of time to keep an event. (0088] The EPL programmatic interfaces can allow statements to be individually compiled or loaded in bulk through a URL Statements may be iterated over, retrieved, started and stopped. Listeners may be attached to statements and notified when either insert and/or remove events occur.\n\n(0089] The Event Processing Language (EPL), can be a SQL-like language with SELECT, FROM, WHERE, GROUP BY, HAVING and ORDER BY clauses. Streams replace tables as the source of data with events replacing rows as the basic unit of data. Since events are composed of data, the SQL concepts of correlation through joins, filtering through sub-queries, and aggregation through grouping may be effectively leveraged. The INSERT INTO clause can be recast as a means of forwarding events to other streams for further downstream processing. External data accessible through JDBC may be queried and joined with the stream data. Additional clauses such as the RETAIN, MATCHING, and OUTPUT clauses can also be available to provide language constructs specific to event processing. [0090] The RETAIN clause can constrain the amount of data over which the query is run, essentially defining a virtual window over the stream data. Unlike relational database systems in which tables bound the extents of the data, event processing systems can use alternative, more dynamic means of limiting the queried data. [00911 The MATCHING clause can detect sequences of events matching a specific pattern. Temporal and logical operators such as AND, OR, and FOLLOWED BY can enable both occurrence of and absence of events to be detected through arbitrarily complex expressions.\n\n[0092] The OUTPUT clause can throttle results of statement execution to prevent overloading downstream processors. Either all or a subset of the first or last resulting events can be passed on in either time or row-based batches.\n\n[0093] An event can be an immutable record of a past occurrence of an action or state change. In this example, event is represented by the com. bean. wlrt.ede.StreamingEvent interface. In this example, an event can have an underlying object that represents the event object which is accessible through the StreamingEvent.getUnderlying{) method. In one embodiment, the underlying object can have a set of event properties that supply information about the event and may be represented as any of the following;\n\n[0094] Plain old Java object (POJO) events can be object instances that expose event properties through JavaBeans-style getter methods. Events classes or interfaces do not have to be fully compliant to the JavaBeans specification; however for the EPL engine to obtain event properties, in one embodiment, the required JavaBeans getter methods must be present.\n\n10095] EPL can support JavaBeans-style event classes that extend a super class or implement one or more interfaces. Also, EPL statements can refer to Java interface classes and abstract classes.\n\n[0096] Classes that represent events can be made immutable. As events are recordings of a state change or action that occurred in the past, the relevant event properties need not be changeable. However this is not a hard requirement and the EPL engine can accept events that are mutable as well.\n\n(0097J Events can also be represented by objects that implement the java.util.Map interface. Event properties of Map events can be the values of each entry accessible through the get method exposed by the java.util.Map interface.\n\n[0098] Entries in the Map can represent event properties. Keys can be of the type java.util.String for the engine to be able to look up event property names specified by EPL statements. Values can be of any type. POJOs may also appear as values in a Map.\n\n[0099] The engine can also query Java objects as values in a Map event via the nested property syntax. Thus Map events can be used to aggregate multiple data structures into a single event and query the composite information in a convenient way. The example below demonstrates a Map event with a transaction and an account object.\n\nMap event = new HashMapQ; event.put(\"txn\", txn); event.put(\"account\", account); events.add(new Streaming EventObject(TxnEventType, 0, 0, event));\n\n[00100] An example statement could look as follows.\n\nSELECT accountid, account.rate * txn.amount FROM TxnEvent RETAIN 60 SECONDS GROUP BY account.id\n\n[00101] EPL expressions can include simple as well as indexed, mapped and nested event properties. The table below outlines the different exemplary types of properties and their syntax in an event expression. This syntax allows statements to query deep JavaBeaÏs objects graphs, XML structures and Map events. The following describes types of one embodiments:\n\nType Description Syntax Example A property that has a single value that name sensorlD\n\nSimple may be retrieved. The property type may be a primitive type\n\n(such as int, or java.lang.String) or another complex type.\n\nA nested property is a property that name.nestedname sensor, value\n\nNested Lives within another property of an event. Note that events represented as a Map may only nest other POJO events and not other Map events.\n\nAn indexed property stores an name[//?dex] sensor[0]\n\nIndexed ordered collection of objects\n\n(all of the same type) that can be individually accessed by an integer valued, non-negative index (or subscript).\n\nNote that events represented as a\n\nMap do not support Indexed properties.\n\nA mapped property stores a keyed name('kÎ¸Î³) sensor('lighf)\n\nMapped collection of objects (all of the same type). As an extension to standard JavaBeans APIs, EPL considers any property that accepts a String-valued key a mapped property. Note that events represented as a Map do not support Indexed properties\n\n[00102| Assume there is an EmployeeEvent event class as shown below. The mapped and indexed properties in this example can return Java objects but could also return Java language primitive types (such as int or String). The Address object and Employee objects can themselves have properties that are nested within them, such as a street-Name in the Address object or a name of the employee in the Employee object.\n\npublic class EmployeeEvent { public String getFirstNameQ; public Address getAddress(String type); public Employee getSubordinate(int index); public EmployeeQ getAIISubordinatesQ; }\n\n[00103] Simple event properties can require a getter-method that returns the property value. In this example, the getFirstName getter method returns the firstName event property of type String.\n\n[00104) Indexed event properties can require either one of the following getter-methods:\n\nâ¢ A method that takes an integer type key value and returns the property value, such as the getSubordinate method.\n\nâ¦ A method that returns an array-type such as the getSubordinates getter method, which returns an array of Employee.\n\n[00105] In an EPL statement, indexed properties can be accessed via the property [index] syntax.\n\n[00106] Mapped event properties can require a getter-method that takes a String type key value and returns a property value, such as the getAddress method. In an EPL or event pattern statement, mapped properties can be accessed via the property ('key') syntax.\n\n[00107] Nested event properties can require a getter-method that returns the nesting object. The getAddress and getSubordinate methods can be mapped and indexed properties that return a nesting object In an EPL statement, nested properties can be accessed via the property.nestedProperty syntax.\n\n[00108) EPL statements can allow the use of indexed, mapped and nested properties (or a combination of these) at any place where one or more event property names are expected.\n\nThe example below shows different combinations of indexed, mapped and nested properties.\n\naddressOhome').streetName subordinate[0].name='anotherName' allSubordinates[1 ]. name subordinate[0].address('home').streetName |00109] Similarly, the syntax can be used in EPL statements in all places where an event property name is expected, such as in select lists, where clauses or join criteria.\n\nSELECT firstName, addressCwork1), subordinate[0].name, subordinate[1].namÎ² FROM EmployeeEvent RETAIN ALL WHERE address('work').streetName = 'Park Ave'\n\n[00110] Event listeners can provide a means of receiving programmatic notifications when events occur that meet the criteria specified in an EPL statement. In one embodiment, listeners may be notified when either:\n\n* New events occur that meet the criteria specified in an EPL statement. These are termed ISTREAM events.\n\n* Old events that previously met the criteria specified in an EPL statement are pushed out of the output window due to their expiration or due to new incoming events occurring that take their place. These are termed RSTREAM events.\n\n[00111] Detailed examples illustrating when each of these notifications occur are provided below.\n\n[00112] In one embodiment, to receive ISTREAM events the com.bea.wlrtede.StreamingEventListener interface is used. Implementations can provide a single onEvent method that the engine invokes when results become available. With this interface, only the new events are sent to the listener. public interface StreamingEventListener extends EventListener {\n\nvoid onEvent(List<StreamingEvent> newEvents) throws RejectStreamingEventException;.\n\nr\n\n* Listeners that do not want to implement the Listener interface\n\n* can annotate an existing method to notify runtime which method\n\n* to call back when events arrive.\n\n* */\n\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME)\n\nÂ©interface Callback {\n\n} }\n\n[00113| To receive both ISTREAM and RSTREAM events the com.bea.wlrt.ede.RStreamingEventListener interface can be used. Since this interface is derived from the StreamingEventÏstener interface, implementations must provide both an onEvent method as well as an onREvent method. The engine can invoke the onEvent as before while the onREvent method is invoked when either ISTREAM or RSTREAM events occur. With the onREvent method, both the new and old events can be sent to the listener. public interface RStreamingEventListener extends StreamingEventListener {\n\nvoid onREvent(List<StreamingEvent> newEvents, List<StreamingEvent> oldEvents) throws RejectStreamingEventException;\n\nr\n\n* Listeners that do not want to implement the Listener interface\n\n* can annotate an existing method to notify runtime which method * to call back when events arrive.\n\n*\n\n*/\n\n@Target(ElementType.METHOD) @Retention(RetentionPolicy.RUNTIME) Â©interface Callback {\n\n} }\n\n[00114| In one embodiment, the engine can provide statement results to listeners by placing results in com.bea.wlrt.ede.StreamingEvent instances. A typical listener implementation can query the StreamingEvent instances via getter methods to obtain the statement-generated results.\n\n[00115] The get method on the StreamingEvent interface can be used to retrieve result columns by name. The property name supplied to the get method can also be used to query nested, indexed or array properties of object graphs. |00116] The getUnderiying method on the StreamingEvent interface can allow update listeners to obtain the underlying event object. For wildcard selects, the underlying event is the original event object that was sent into the engine. For joins and select clauses with expressions, the underlying object implements Java. util. Map. [00117| The top-level extended Backus-Naur form (eBNF) for EPL can be as follows:\n\n[ INSERT INTO insert_into_def] SELECT selectjist FROM stream_source_list\n\n[ MATCHING pattern_expression ] [ WHERE searchjconditions ]\n\n[ GROUP BY gmuping_expression_list ]\n\n[ HAVING grouping_search_conditions ]\n\n[ ORDER BY order_by_expression_list ]\n\n[ OUTPUT outputjspeciftcation ] [00118) In one embodiment, literal keywords are not case sensitive. Each clause is detailed in the following sections. In addition, the built-in operators and functions are listed and described.\n\n[00119) The SELECT clause can be required in all EPL statements. The SELECT clause can be used to select all properties via the wildcard *, or to specify a list of event properties and expressions. The SELECT clause can define the event type (event property names and types) of the resulting events published by the statement, or pulled from the statement.\n\n[00120] The SELECT clause can also offer optional ISTREAM and RSTREAM keywords to control how events are posted to update listeners attached to the statement.\n\nThe syntax for the SELECT clause, of one embodiment, is summarized below.\n\nSELECT [RSTREAM | ISTREAM] ( expmssionjst | * )\n\n[00121| The following examples use the FROM clause which defines the sources of the event data.\n\n[00122] To chose the particular event properties to return:\n\nSELECT event_property [, event_property] [, ...] FROM streamjdbf\n\n[00123| The following statement can select the count and standard deviation of the volume for the last 100 stock tick events. SELECT COUNT, STDDEV(volume) FROM StOCkTick RETAIN 100 EVENTS\n\n[00124] The select dause can contain one or more expressions.\n\nSELECT expression [, expression] [, ...] FROM streamjdef\n\n[00125] The following statement can select the volume multiplied by price for a time batch of the last 30 seconds of stock tick events.\n\nSELECT volume * price FROM StockTick RETAIN BATCH OF 30 SECONDS\n\n[00126] Event properties and expressions can be aliased using below syntax.\n\nSELECT [event_property | expression] AS identifier [,...]\n\n[00127] The following statement can select volume multiplied by price and specifies the name volPrice for the event property.\n\nSELECT volume * price AS volPrice FROM StockTick RETAIN 100 EVENTS\n\n[00128] The syntax for selecting all event properties in a stream can be:\n\nSELECT * FROM stream_def\n\n[00129] The following statement can select all of the StockTick event properties for the last 30 seconds:\n\nSELECT â¢ FROM StockTick RETAIN 30 SECONDS\n\n[00130] In a join statement, using the SELECT * syntax can select event properties that contain the events representing the joined streams themselves.\n\n[00131] The * wildcard and expressions can also be combined in a SELECT clause. The combination selects all event properties and in addition the computed values as specified by any additional expressions that are part of the SELECT clause. Here is an example that selects all properties of stock tick events plus a computed product of price and volume that the statement names 'pricevolume': SELECT *, price * volume AS pricevolume FROM StockTick RETAIN ALL\n\n[00132] The optional ISTREAM and RSTREAM keywords in the SELECT clause can define the event stream posted to update listeners to the statement. If neither keyword is specified, the engine can post both insert and remove stream events to statement listeners. The insert stream can consist of the events entering the respective window(s) or stream(s) or aggregations, while the remove stream consists of the events leaving the respective window(s) or the changed aggregation result.\n\n[00133] By specifying the ISTREAM keyword you can instruct the engine to only post insert stream events to update listeners. In one embodiment, the engine can then not post any remove stream events. By specifying the RSTREAM keyword you can instruct the engine to only post remove stream events to update listeners. In one embodiment, the engine can then not post any insert stream events.\n\n[00134] The following statement can select only the events that are leaving the 30 second time window.\n\nSELECT RSTREAM * FROM StockTick RETAI N 30 SECONDS\n\n[00135] The ISTREAM and RSTREAM keywords in the SELECT clause can be matched by same-name keywords available in the INSERT INTO clause. While the keywords in the SELECT clause control the event stream posted to update listeners to the statement, the same keywords in the insert into clause can specify the event stream that the engine makes available to other statements.\n\n[00136] The FROM clause can be required in all EPL statements. It can specify one or more event streams as the source of the event data.\n\nFROM streamjBxpression [ innerjoin \\ outerjoin ] with innerjoin specified as a comma separated list of stream expressions:\n\n(, stream_expression )*\n\nand outer_join defined as:\n\n((LEFTIRIGHTIFULL) OUTER JOIN stream_expression ON prop_name = prop_name)* |00137] A stream_expression can simply define the name of the event type used as the source of the stream data, or in more complex scenarios define either a subquery expression as a nested EPL statement or a parameterized SQL query to access JDBC data. In all of these cases, the streamjsxpression can optionally include an alias as an identifier to qualify any ambiguous property name references in other expressions and a RETAIN clause to define the window of stream data seen by the rest of the query:\n\n{stream_name | subquery_expr | param_sÏf/_ÏfuÎ¸/y) [[AS] alias]] [RETAIN retainjÎ²xpÎ® subquery_Î¸xpr. ( Î¸pl_statÎ²ment ) param_sql_query: database_name (parametÎ²rizÎ¸d_sql_quÎ¸rÎ³)\n\n100138] The subqueryjexpr can define a sub query or nested EPL statement in parenthesis. A sub query can be used to pre-filter event stream data seen by the outer EPL statement. For example, the following query would restrict the data seen by the outer EPL statement to only StockTick events coming from a Reuters feed.\n\nSELECT stockSymbol , AVG(price)\n\nFROM (SELECT * FROM StockTick WHERE feedName = \"Reuters' ) RETAIN 1 MINUTE PARTITION BY stockSymbol GROUP BY stockSymbol\n\n[00139] Sub queries can be arbitrarily nested. In one embodiment, sub queries may not contain an INSERT INTO or an OUTPUT clause. In one embodiment, unlike with a top level EPL statement, a RETAIN clause is optional within a subquery.\n\n(00140] The param_sql_query can specify a parameterized SQL query in quotes surrounded by parenthesis that enables reference and historical data accessible through JDBC to be retrieved. The database_name can identify the name of the database over which the query can be executed. Configuration information can be associated with this database name to establish a database connection, control connection creation and removal, and to setup caching policies for query results.\n\n[00141] The RETAIN clause can define the quantity of event data read from the streams listed in the FROM clause prior to query processing. Each stream may have its own RETAIN clause if each require different retain policies. Otherwise, the RETAIN clause may appear at the end of the FROM clause for it to apply to all streams. Essentially the RETAIN clause can apply to all streams that appear before it in the FROM clause. |00142] For example, in the following EPL statement, five StockTick events can be retained while three News events can be retained:\n\nSELECT tstockSymbol, t.price, n.summary\n\nFROM StockTick t RETAIN 5 EVENTS, News n RETAIN 3 EVENTS WHERE tstockSymbol = n.stockSymbol\n\n[00143] However, in the following statement, four StockTick and four News events can be retained:\n\nSELECT tstockSymbol, tprice, n.summary FROM StockTick t, News n RETAIN 4 EVENTS WHERE tstockSymbol = n.stockSymbol\n\n[00144| In one embodiment, with the exception of sub query expressions, all stream sources are constrained by a RETAIN clause. Thus, in one embodiment, at a minimum the FROM clause contains at least one RETAIN clause at the end for top level EPL statements. External data from parameterized SQL queries need not affected by the RETAIN clause.\n\n[00145] Two or more event streams can be part of the FROM dause with all of the streams determine the resulting events. The WHERE clause can list the join conditions that EPL uses to relate events in two or more streams. In one embodiment, if the condition is failed to be met, for example if no event data occurs for either of the joined stream source, no output need be produced.\n\n[00146] Each point in time that an event arrives to one of the event streams, the two event streams can be joined and output events can be produced according to the where-clause.\n\n[00147| This example joins two event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes. The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.\n\nSELECT fraud.accountNumber AS accntNum, fraud.warning AS warn, withdraw. amount AS amount,\n\nMAX(fraud.timestamp, withdraw.timestamp) AS timestamp, VithdraWlFraud1 AS desc\n\nFROM FraudWarningEvent AS fraud RETAIN 30 MIN,\n\nWithdrawalEvent AS withdraw RETAIN 30 SEC WHERE fraud.accountNumber = withdraw.accountNÏ mber\n\n[00148] Left outer joins, right outer joins and full outer joins between an unlimited number of event streams can be supported by EPL Depending on the LEFT, RIGHT, or FULL qualifier, in the absence of event data from either stream source, output may still occur.\n\n[00149] If the outer join is a left outer join, there can be an output event for each event of the stream on the left-hand side of the clause. For example, in the left outer join shown below we can get output for each event in the stream Rfid Event, even if the event does not match any event in the event stream OrderList\n\nSELECT *\n\nFROM RfidEvent AS rfid\n\nLEFT OUTER JOIN OrderList AS orderlist\n\nON rfid.itemld = orderListitemld RETAIN 30 SECONDS\n\n[00150] Similarly, if the join is a Right Outer Join, then there can be an output event for each event of the stream on the right-hand side of the clause. For example, in the right outer join shown below we can get output for each event in the stream OrderList, even if the event does not match any event in the event stream RfidEvent\n\nSELECT *\n\nFROM RfidEvent AS rfid\n\nRIGHT OUTER JOIN OrderList AS orderlist\n\nON rfid.itemld = orderList.itemld RETAIN 30 SECONDS\n\n[00151| For all types of outer joins, if the join condition is not met, the select list can be computed with the event properties of the arrived event while all other event properties are considered to be null.\n\nSELECT * FROM RfidEvent AS rfid\n\nFULL OUTER JOIN\n\nOrderList AS orderlist ON rfid.itemld = orderListitemld RETAIN 30 SECONDS\n\n[00152] The last type of outer join is a full outer join. In a full outer join, each point in time that an event arrives to one of the event streams, one or more output events are produced. In the example below, when either an RfidEvent or an OrderList event arrive, one or more output event is produced.\n\n[00153] A sub query expression can be a nested EPL statement that appears in parenthesis in the FROM clause. A sub query need not contain an INSERT INTO clause or an OUTPUT clause, and unlike top level EPL statements, a RETAIN clause is optional. [00154] Sub query expressions can execute prior to their containing EPL statement and thus can be useful to pre-filter event data seen by the outer statement. For example, the following query can calculate the moving average of a particular stock over the last 100 StockTick events:\n\nSELECT AVG(Ïrice) FROM (SELECT * FROM StockTick WHERE stockSymbol = 'ACME' ) RETAIN 100 EVENTS\n\n[00155] In one embodiment, if the WHERE clause had been placed in the outer query, StockTick events for other stock symbols would enter into the window, reducing the number of events used to calculate the average price. [00156] In addition, a subquery may be used to a) transform the structure of the inner event source to the structure required by the outer EPL statement or b) merge multiple event streams to form a single stream of events. This allows a single EPL statement to be used instead of multiple EPL statements with an INSERT INTO clause connecting them. For example, the following query merges transaction data from EventA and EventB and then uses the combined data in the outer query: SELECT custld, SUM(latency)\n\nFROM (SELECT A.customerld AS custld, A.timestamp -B.timestamp AS latency FROM EventA A, EventB B WHERE A.txnld = B.txnld) RETAIN 30 MIN GROUP BY custld\n\n[00l57| Note that a subquery itself may contain subqueries thus allowing arbitrary levels of nesting. [00158] Parameterized SQL queries can enable reference and historical data accessible through JDBC to be queried via SQL within EPL statements. In one embodiment, in order for such data sources to become accessible to EPL, some configuration is required. [00159] In one embodiment, the following restrictions can apply: â¢ Only one event stream and one SQL query may be joined; Joins of two or more event streams with an SQL query are not supported.\n\nâ¢ Constraints specified in the RETAIN clause are ignored for the stream for the SQL query; That is, one cannot create a time-based or event-based window on an SQL query. However one can use the INSERT INTO syntax to make join results available to a further statement.\n\nâ¢ The database software supports JDBC prepared statements that provide statement metadata at compilation time. Most major databases provide this function.\n\n|00160| Other embodiments need have these restrictions.\n\n[00161] The query string can be single or double quoted and surrounded by square brackets. The query may contain one or more substitution parameters. The query string can be passed to the database software unchanged, allowing the use of any SQL query syntax that your database understands, including stored procedure calls.\n\n[00162] Substitution parameters in the SQL query string take the form ${event_property_name}. The engine resolves event_property_name at statement execution time to the actual event property value supplied by the events in the joined event stream.\n\n[00163] The engine can determine the type of the SQL query output columns by means of the result set metadata that your database software returns for the statement. The actual query results can be obtained via the getObject on java.sql.ResultSet.\n\n[00164] The sample EPL statement below joins an event stream consisting of CustomerCallEvent events with the results of an SQL query against the database named MyCustomerDB and table Customer:\n\nSELECT custld, cust_name FROM CustomerCallEvent,\n\nMyCustomerDB (' SELECT cust_name FROM Customer WHERE cust_id = ${custld} ') RETAIN 10 MINUTES\n\n[00165] The example above assumes that CustomerCallEvent supplies an event property named custld. The SQL query can select the customer name from the Customer table. The WHERE clause in the SQL can match the Customer table column cust_id with the value of custld in each CustomerCall Event event. In one embodiment, the engine executes the SQL query for each new CustomerCallEvent encountered. If the SQL query returns no rows for a given customer id, the engine can generate no output event. Else the engine can generate one output event for each row returned by the SQL query. An outer join as described in the next section can be used to control whether the engine should generate output events even when the SQL query returns no rows. The next example adds a time window of 30 seconds to the event stream CustomerCallEvent. It also renames the selected properties to customerName and customerld to demonstrate how the naming of columns in an SQL query can be used in the select clause in the EQL query. The example uses explicit stream names via the AS keyword.\n\nSELECT customerld, customerName FROM CustomerCallEvent AS cce RETAIN 30 SECONDS. MyCustomerDB (\"SELECT cust_id AS customerld, cust_name AS customerName\n\nFROM Customer WHERE custjd = ${cce.custld}\") AS cq\n\n[00166] Any window, such as the time window, generates insert events as events enter the window, and remove events as events leave the window. The engine executes the given SQL query for each CustomerCallEvent in both the insert stream and the remove stream cases. As a performance optimization, the ISTREAM or RSTREAM keywords in the SELECT clause can be used to instruct the engine to only join insert or remove events, reducing the number of SQL query executions. Parameterized SQL queries can be used in outer joins as well. Use a left outer join, such as in the next statement, if you need an output event for each event regardless of whether or not the SQL query returns rows. If the SQL query returns no rows, the join result populates null values into the selected properties.\n\nSELECT custld, custName FROM CustomerCallEvent AS cce LEFT OUTER JOIN MyCustomerDB (\"SELECT custjd, cust_name AS custName\n\nFROM Customer WHERE custjd = ${cce.custld}\") AS cq ON cce.custld = cq.custjd RETAIN 10 MINUTES (00167] The statement above can always generates at least one output event for each CustomerCallEvent, containing all columns selected by the SQL query, even if the SQL query does not return any rows. Note the ON expression that is used for outer joins. The ON can act as an additional filter to rows returned by the SQL query. The WHERE clause can S be an optional clause in EPL statements. Using the WHERE clause event streams can be joined and events can be filtered. In one embodiment, aggregate functions may not appear in a WHERE clause. To filter using aggregate functions, the HAVING clause can be used.\n\nWHERE aggregate_free_expression\n\n[00168] Comparison operators =, <, >, >=, <=, !=, <>, IS NULL, IS NOT NULL and logical0 combinations via ANO and OR can be supported in the where clause. Some examples are listed below.\n\n... WHERE fraud.severity = 5 AND amount > 500 ... WHERE (orderltem.orderld IS NULL) OR (orderltem.class != 10) ... WHERE (orderltem.orderld = NULL) OR (orderltem.class <> 10) 5 ... WHERE itemCount / packageCount > 10\n\n[00169] The GROUP BY clause can be optional in EPL statements. The GROUP BY clause can divide the output of an EPL statement into groups. You can group by one or more event property names, or by the result of computed expressions. When used with aggregate0 functions, GROUP BY can retrieve the calculations in each subgroup. You can use GROUP BY without aggregate functions, but generally that can produce confusing results.\n\n[00170] For example, the below statement can return the total price per symbol for all stock tick events in the last 30 seconds:\n\nSELECT symbol, SUM(price) FROM StockTickEvent RETAIN 30 SEC GROUP BY symbol 5 [00171] The syntax of the group by clause can be:\n\nGROUP BY aimgate_free_expression [, arregate_frBe_expression] [, ...]\n\n[00172] EPL can place the following restrictions on expressions in the GROUP BY clause:\n\n1. Expressions in the GROUP BY clause cannot contain aggregate functions\n\n2. Event properties that are used within aggregate functions in the SELECT clause cannot also be used in a GROUP BY expression\n\n[00173] In one embodiment, you can list more then one expression in the GROUP BY clause to nest groups. Once the sets are established with GROUP BY, the aggregation functions can be applied. This statement can post the median volume for all stock tick events in the last 30 seconds grouped by symbol and tick data feed. EPL can post one event for each group to statement update listeners:\n\nSELECT symbol, tickDataFeed, MEDIAN(volume) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol, tickDataFeed (00174| In the statement above the event properties in the select list (symbol and tickDataFeed) can be listed in the GROUP BY clause. The statement can thus follow the SQL standard which prescribes that non-aggregated event properties in the select list must match the GROUP BY columns. EPL can also support statements in which one or more event properties in the select list are not listed in the GROUP BY clause. The statement below demonstrates this case. It calculates the standard deviation for the last 30 seconds of stock ticks aggregating by symbol and posting for each event the symbol, tickDataFeed and the standard deviation on price.\n\nSELECT symbol, tickDataFeed, STDDEV(Ïrice) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol\n\n[00175J The above example still aggregates the price event property based on the symbol, but produces one event per incoming event, not one event per group. Additionally, EPL can support statements in which one or more event properties in the GROUP BY clause are not listed in the select list. This is an example that calculates the mean deviation per symbol and tickDataFeed and posts one event per group with symbol and mean deviation of price in the generated events. Since tickDataFeed is not in the posted results, this can potentially be confusing.\n\nSELECT symbol, AVEDEV(price) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol, tickDataFeed\n\n[00176] Expressions can also be allowed in the GROUP BY list:\n\nSELECT symbol * price, count(*) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol * price\n\n[00177] If the GROUP BY expression can result in a null value, the null value can become its own group. All null values can be aggregated into the same group. In one embodiment, the COUNT(expression) aggregate function does not count null values and the COUNT returns zero if only null values are encountered.\n\n[00178| In one embodiment, you can use a WHERE clause in a statement with GROUP BY. Events that do not satisfy the conditions in the WHERE clause can be eliminated before any grouping is done. For example, the statement below posts the number of stock ticks in the last 30 seconds with a volume larger then 100, posting one event per group (symbol).\n\nSELECT symbol, countf)\n\nFROM StockTickEvent RETAIN 30 SECONDS\n\nWHERE volume > 100\n\nGROUP BY symbol\n\n(00179) The HAVING clause can be optional in EPL statements. The HAVING clause can be used to pass or reject events defined by the GROUP BY clause. The HAVING clause can set conditions for the GROUP BY clause in the same way WHERE sets conditions for the SELECT clause, except the WHERE clause cannot include aggregate functions, while HAVING often does.\n\nHAVING expression\n\n[00180] This statement is an example of a HAVING clause with an aggregate function. It can post the total price per symbol for the last 30 seconds of stock tick events for only those symbols in which the total price exceeds 1000. The HAVING clause eliminates all symbols where the total price is equal or less then 1000.\n\nSELECT symbol, SUM(Ïrice)\n\nFROM StockTickEvent RETAIN 30 SEC\n\nGROUP BY symbol\n\nHAVING SUM(price) > 1000\n\n[00181] To include more then one condition in the HAVING clause combine the conditions with AND, OR or NOT. This is shown in the statement below which selects only groups with a total price greater then 1000 and an average volume less then 500. SELECT symbol, SUM(price), AVG(volume)\n\nFROM StockTickEvent RETAIN 30 SEC\n\nGROUP BY symbol\n\nHAVING SUM(price) > 1000 AND AVG(volume) < 500\n\n[00182] EPL can place the following restrictions on expressions in the HAVING clause:\n\n3. Any expressions that contain aggregate functions must also occur in the SELECT clause\n\n(001831 A statement with the HAVING clause should also have a GROUP BY clause. If you omit GROUP BY, all the events not excluded by the WHERE clause return as a single group. In that case HAVING can act like a WHERE except that HAVING can have aggregate functions.\n\n[00184) The HAVING clause can also be used without GROUP BY clause as the below example shows. The example below posts events where the price is less then the current running average price of all stock tick events in the last 30 seconds.\n\nSELECT symbol, price, AVG(price)\n\nFROM StockTickEvent RETAIN 30 SEC\n\nHAVING price < AVG(price)\n\n[00185| When an EPL statement includes subqueries, a MATCHING clause, WHERE conditions, a GROUP BY clause, and HAVING conditions, the sequence in which each clause executes can determine the final result:\n\n4. Any subqueries present in the statement run first. The subqueries act as a filter for events to enter the window of the outer query.\n\n5. The event stream's filter conditions in the MATCHING clause, if present, can dictate which events enter a window. The filter discards any events not meeting filter criteria. 6. The WHERE clause excludes events that do not meet its search condition.\n\n7. Aggregate functions in the select list calculate summary values for each group.\n\n8. The HAVING clause can exclude events from the final results that do not meet its search condition.\n\n[00l86| The following query can illustrate the use of filter, WHERE, GROUP BY and HAVING clauses in one statement with a SELECT clause containing an aggregate function.\n\nSELECT tickDataFeed, STDDEV(price)\n\nFROM (SELECT * FROM StockTickEvent WHERE symboN'ACME) RETAIN 10 EVENTS\n\nWHERE volume > 1000 GROUP BY tickDataFeÎ²d HAVING STDDEV(price) > 0.8 [00187J EPL can filter events using the subquery for the event stream StockTickEvent. In the example above, only events with symbol ACME enter the window over the last 10 events, all other events are simply discarded. The WHERE clause can remove any events posted into the window (events entering the window and event leaving the window) that do not match the condition of volume greater then 1000. Remaining events are applied to the STDDEV standard deviation aggregate function for each tick data feed as specified in the GROUP BY clause. Each tickDataFeed value can generate one event. EPL can apply the HAVING clause and only lets events pass for tickDataFeed groups with a standard deviation of pnce greater then 0.8. [00188| The ORDER BY clause can be optional in EPL It can be used for ordering output events by their properties, or by expressions involving those properties. For example, the following statement can batch 1 minute of stock tick events sorting them first by price and then by volume.\n\nSELECT symbol FROM StockTickEvent RETAIN BATCH OF 1 MINUTE ORDER BY price, volume\n\n[00189] Here is an exemplary syntax for an ORDER BY clause:\n\nORDER BY expression [ASC | DESC] [, expression [ASC | DESC] [,...]]\n\n[00190] EPL can place the following restrictions on the expressions in the ORDER BY clause:\n\n9. All aggregate functions that appear in the ORDER BY clause must also appear in the SELECT expression.\n\n[00191] Otherwise, in one embodiment, any kind of expression that can appear in the SELECT clause, as well as any alias defined in the SELECT clause, is also valid in the ORDER BY clause.\n\n[00192] The INSERT INTO clause can be optional in EPL. This clause can be specified to make the results of a statement available as an event stream for use in further statements.\n\nThe clause can also be used to merge multiple event streams to form a single stream of events.\n\nINSERT INTO CombinedEvent\n\nSELECT A.customerld AS custld, A.timestamp -B.timestamp AS latency FROM EventA A, EventB B RETAIN 30 MIN WHERE A.txnld = B.txnld\n\n[00193] The INSERT INTO clause in the above statement, can generate events of type CombinedEvent. Each generated CombinedEvent event can have two event properties named \"custld\" and \"latency\". The events generated by the above statement can be used in further statements. For example, the statement below uses the generated events.\n\nSELECT custld, SUM(latency)\n\nFROM CombinedEvent RETAIN 30 MIN GROUP BY custld\n\n[00194] The INSERT INTO clause can consist of just an event type alias, or of an event type alias and one or more event property names. The syntax for the INSERT INTO clause can be as follows:\n\nINSERT [ISTREAM | RSTREAM] INTO event_type_alias [(prop_name [,prop_name, [....]] ) ]\n\n100195] The ISTREAM (default) and RSTREAM keywords are optional. If neither keyword is specified, the engine can supply the insert stream events generated by the statement to attached update listeners. The insert stream can consist of the events entering the respective window{s) or stream(s). If the RSTREAM keyword is specified, the engine supplies the remove stream events generated by the statement. The remove stream can consist of the events leaving the respective window(s).\n\n[00196] The event_type_alias can be an identifier that names the events generated by the engine. The identifier can be used in statements to filter and process events of the given name.\n\n[00197] The engine can also allow update listeners to be attached to a statement that contain an INSERT INTO clause.\n\n[00198] To merge event streams, the same event_type_alias identifier can be used in any EPL statements that you would like to be merged. Make sure to use the same number and names of event properties and that event property types match up.\n\n[00199| EPL can place the following restrictions on the INSERT INTO clause:\n\n10. The number of elements in the SELECT clause must match the number of elements in the INSERT INTO clause if the clause specifies a list of event property names. S 11. If the event type alias has already been defined by a prior statement and the event property names and types do not match, an exception is thrown at statement creation time.\n\n[00200J The example statement below shows the alternative form of the I NSERT I NTO clause that explicitly defines the property names to use. O INSERT INTO CombinedEvent (custld, latency) SELECT A.customerld, A.timestamp - B.timestamp FROM EventA A, EventB B RETAIN 30 MIN WHERE A.txnld = B.txnld\n\n{00201] The RSTREAM keyword can be used to indicate to the engine to generate only 5 remove stream events. This can be useful if we want to trigger actions when events leave a window rather then when events enter a window. The statement below generates CombinedEvent events when EventA and EventB leave the window after 30 minutes.\n\nINSERT RSTREAM INTO CombinedEvent\n\nSELECT A.customerld AS custld, A.timestamp - B.timestamp AS latency 0 FROM EventA A, EventB B RETAIN 30 MIN WHERE A.txnld = B.txnld\n\n(00202] The precedence of arithmetic and logical operators in EPL can follow Java standard arithmetic and logical operator precedence.\n\n[00203] The table below outlines the arithmetic operators available, in one embodiment.\n\nOperator Description\n\n+, - As unary operators they denote a positive or negative expression. As binary operators they add or subtract. *, / Multiplication and division are binary operators. % Modulo binary operator.\n\n[00204] The table below outlines the logical and comparison operators available, in one embodiment.\n\nOperator Description\n\nNOT Returns true if the following condition is false, returns false if it is true OR Returns true if either component condition is true, returns false if both are false AND Returns true if both component conditions are true, returns false if either is false\n\n=, I=, <, > <=, >=,<> Comparison operators\n\n5\n\n(00205J The table below outlines the concatenation operators available, in one embodiment.\n\nOperator Description\n\nH Concatenates character strings\n\n[00206| The table below outlines the binary operators available, in one embodiment.\n\nOperator Description\n\n& Bitwise AND if both operands are numbers; conditional AND if both operands are\n\nBoolean I Bitwise OR if both operands are numbers; conditional OR if both operands are Boolean\n\nÎ Bitwise exclusive OR (XOR)\n\n10\n\n[00207] The { and } curly braces can be array definition operators following the Java array initialization syntax. Arrays can be useful to pass to user-defined functions or to select array data in a SELECT clause.\n\n[00208] Array definitions can consist of zero or more expressions within curly braces. Any I S type of expression can be allowed within array definitions including constants, arithmetic expressions or event properties. This is the syntax of an array definition:\n\n{ [expression [,expression [,...]]] } [00209J Consider the next statement that returns an event property named actions. The engine populates the actions property as an array of Java. lang. String values with a length of 2 elements. The first element of the array contains the observation property value and the second element the command property value of RFIDEvent events.\n\nSELECT {observation, command} AS actions FROM RFIDEvent RETAIN ALL\n\n[00210] The engine can determine the array type based on the types returned by the expressions in the array definition. For example, if all expressions in the array definition return integer values then the type of the array is java.lang.lntegerQ. If the types returned by all expressions are a compatible number types, such as integer and double values, the engine coerces the array element values and returns a suitable type, Java. lang. DoubleO in this example. The type of the array returned is ObjectJf if the types of expressions cannot be coerced or return object values. Null values can also be used in an array definition.\n\n100211] Arrays can come in handy for use as parameters to user-defined functions:\n\nSELECT * FROM RFIDEvent RETAIN ALL WHERE Fiiter.myFilter(zone, {1,2,3}) [00212] The IN operator can determine if a given value matches any value in a list The syntax of the operator can be:\n\ntest_expnession [NOT] IN (expression [expression [,...]] )\n\n[00213] The tÎ²st_exprÎ²ssion can be any valid expression. The IN keyword can be followed by a list of expressions to test for a match. The optional NOT keyword can specify that the result of the predicate be negated.\n\n[00214] The result of an IN expression can be of type Boolean. In one embodiment, if the value of test_expmssion is equal to any expression from the comma-separated list, the result value is true. Otherwise, the result value is false. In one embodiment, all expressions must be of the same type or a type compatible with test_expression.\n\n[0021S] The next example shows how the IN keyword can be applied to select certain command types of RFID events:\n\nSELECT * FROM RFIDEvent RETAIN ALL WHERE command IN ('OBSERVATION', 'SIGNAL') |00216] The statement is equivalent to:\n\nSELECT * FROM RFIDEvent RETAIN ALL WHERE command = 'OBSERVATION' OR symbol = 'SIGNAL' [00217) The BETWEEN operator can specify a range to test. In one embodiment, the syntax of the operator is:\n\ntÎ¸st_Î²xprÎ¸ssion [NOT] BETWEEN beginjsxpression AND end_expr&$sion\n\n[00218] The tÎ²st_Î¸xprÎ²ssion can be any valid expression and is the expression to test for the range being inclusively within the expressions defined by begm' _expression and Î¸nd_Î²xpression. The NOT keyword can specify that the result of the predicate be negated.\n\n[00219| The result of a BETWEEN expression can be of type Boolean. If the value of test_exprÎ²ssion is greater then or equal to the value of begin_Î²xpression and less than or equal to the value of endjÎ²xpression, the result can be true.\n\n[00220] The next example shows how the BETWEEN keyword can be used to select events with a price between 55 and 60 (inclusive).\n\nSELECT * FROM StockTickEvent RETAIN ALL WHERE price BETWEEN 55 AND 60\n\n[00221] The equivalent expression without using the BETWEEN keyword is:\n\nSELECT * FROM StockTickEvent RETAIN ALL WHERE price >= 55 AND price <= 60\n\n[00222] In one embodiment, the begin_expression and end_expression may occur in either order without affecting the query. For example, the following can be equivalent to the above example:\n\nSELECT â¢ FROM StockTickEvent RETAIN ALL WHERE price BETWEEN 60 AND 55\n\n[00223] The LIKE operator can provide standard SQL pattern matching. SQL pattern matching can allow you to use 'J to match any single character and '%' to match an arbitrary number of characters (including zero characters). In EPL, SQL patterns are case-sensitive by default. The syntax of LIKE is:\n\ntÎ¸st_Î²xprBssion [NOT] LIKE pattern_expression [ESCAPE string_Htenal\\ [00224] The test_expression can be any valid expression yielding a String type or a numeric result. The optional NOT keyword specifies that the result of the predicate be negated. The LIKE keyword is followed by any valid standard SQL pattem_expnession yielding a String-typed result. The optional ESCAPE keyword signals the escape character used to escape 'J and '%' values in the pattern.\n\n[00225J The result of a LIKE expression is of type Boolean. If the value of test_expression matches the pattern_expression, the result value is true. Otherwise, the result value is false. An example for the LIKE keyword is shown below.\n\nSELECT * FROM PersonLocationEvent RETAIN ALL WHERE name LIKE 10ZoJaCk0Zo1\n\n[00226] The escape character can be defined as follows. In this example the where- clause matches events where the suffix property is a single 1J character.\n\nSELECT * FROM PersonLocationEvent RETAIN ALL WHERE suffix LIKE '!_' ESCAPE '!' [00227] The REGEXP operator can be a form of pattern matching based on regular expressions implemented through the Java java.util.regex package. The syntax of REGEXP is:\n\ntest_expression [NOT] REGEXP pattem_expression\n\n[00228| The tÎ²st_Î¸xprÎ²ssion can be any valid expression yielding a String type or a numeric result The optional NOT keyword specifies that the result of the predicate be negated. The REGEXP keyword can be followed by any valid regular expression pattÎ²rnjÎ²xpression yielding a String-typed result.\n\n[00229] The result of a REGEXP expression can be of type Boolean. In one embodiment, if the value of test_expression matches the regular expression pattemjÎ²xpression, the result value is true. Otherwise, the result value is false.\n\n[00230] An example for the REGEXP operator is below.\n\nSELECT * FROM PersonLocationEvent RETAIN ALL WHERE name REGEXP 'Mack*' [00231] The followed by FOLLOWED BY operator can specify that first the left hand expression must turn true and only then is the right hand expression evaluated for matching events.\n\n|00232] Look for event A and if encountered, look for event B. A and B can itself be nested event pattern expressions.\n\nA FOLLOWED BY B\n\n[00233] Note that this does not mean that event A must immediately be followed by event B. Other events may occur between the event A and the event B and this expression would still evaluate to true. If this is not the desired behavior, the NOT operator can be used as described in the next section.\n\n[002341 This is a pattern that fires when two status events indicating an error occur after the other.\n\nstatus='ERROR' FOLLOWED BY status='ERROR* [00235] Single-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.\n\n[00236] EPL can allow static Java library methods as single-row functions, and also features built-in single-row functions.\n\n[00237] EPL can auto-import the following Java library packages:\n\nâ¢ java.lang.*\n\nâ¢ java.math.*\n\nâ¢ java.text.*\n\nâ¢ java.util.*\n\n[00238] The Java static library methods can be used in all expressions as shown in below example:\n\nSELECT symbol, Math.round(volume/1000) FROM StockTickEvent RETAIN 30 SECONDS\n\n[00239] Other arbitrary Java classes may also be used, however their names may need to be fully qualified or configured to be imported.\n\n[00240] The table below outlines the built-in single-row functions available, in one embodiment. Single-row Function Result\n\nMAX(expression, expression [, expression [,...]) Returns the highest numeric value among the two or more comma-separated expressions.\n\nMIN{exprÃ¸ss/o/7, expression [, expression [,...]) Returns the lowest numeric value among the two or more comma-separated expressions.\n\nCOALESCE(express/o/7, expression [, expression Returns the first non-null value in I-}) the list, or null if there are no non-null values.\n\nCASE value Returns result where the first\n\nWHEN compare_value THEN result value equals compare_value.\n\n[WHEN compare_value THEN resuff ...]\n\n[ELSE resulfl END CASE value Returns the result for the first\n\nWHEN condition THEN rest/// condition that is true.\n\n[WHEN condition THEN resoff ...] END PREV(expmss/on, event_property) Returns a property value of a previous event, relative to the event order within a data window\n\nPR\\OR(integer, event_property) Returns a property value of a prior event, relative to the natural order of arrival of events\n\n[00241] The MIN and MAX functions can take two or more expression parameters. The min function can return the lowest numeric value among these comma-separated expressions, while the MAX function can return the highest numeric value. The return type can be the compatible aggregated type of all return values.\n\n[00242) The next example shows the MAX function that has a Double return type and returns the value 1.1.\n\nSELECT MAX(I, 1.1, 2 * 0.5) FROM ... (00243] The MIN function can return the lowest value. The statement below uses the function to determine the smaller of two timestamp values.\n\nSELECT symbol, MIN(ticks.timestamp, news.timestamp) AS minT FROM StockTickEvent AS ticks, NewsEvent AS news RETAIN 30 SECONDS\n\nWHERE ticks.symbol = news.symbol\n\n[00244] Note that the MIN and MAX functions can also available as aggregate functions.\n\n[00245] The result of the COALESCE function can be the first expression in a list of expressions that returns a non-null value. The return type can be the compatible aggregated type of all return values.\n\n[00246] This example returns a String type result with a value of foo1.\n\nSELECT COALESCE(NULL, 'foo1) FROM ...\n\n[00247] The CASE control flow function can have two versions. The first version can take a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version can take a list of conditions and returns the result for the first condition that is true.\n\n[00248] The return type of a CASE expression is the compatible aggregated type of all return values.\n\n[00249] The example below shows the first version of a CASE statement. It has a String return type and returns the value 'one'.\n\nSELECT CASE 1 WHEN 1 THEN 'one' WHEN 2 THEN 'two' ELSE 'more' END FROM ...\n\n[00250] The second version of the CASE function can take a list of conditions. The next example has a Boolean return type and returns the Boolean value true.\n\nSELECT CASE WHEN 1>0 THEN true ELSE false END FROM ...\n\n[00251] The PREV function can return the property value of a previous event The first parameter can denote the ith previous event in the order established by the data window. The second parameter can be a property name for which the function returns the value for the previous event.\n\n[00252] This example selects the value of the price property of the second previous event from the current Trade event.\n\nSELECT PREV(2, price) FROM Trade RETAIN 10 EVENTS\n\n[00253] Since the PREV function takes the order established by the data window into account, the function can work well with sorted windows. In the following example the statement selects the symbol of the three Trade events that had the largest, second-largest and third-largest volume. SELECT PREV(O, symbol), PREV(I1 symbol), PREV(2, symbol) FROM Trade RETAIN 10 EVENTS WITH HIGHEST volume\n\n[00254] The i'h previous event parameter can also be an expression returning an Integer type value. The next statement joins the Trade data window with a RankSelectionEvent event that provides a rank property used to look up a certain position in the sorted Trade data window:\n\nSELECT PREV(rank, symbol) FROM Trade, RankSelectionEvent RETAIN 10 EVENTS WITH HIGHEST volume\n\n[00255] The PREV function can return a NULL value if the data window does not currently hold the ilh previous event. The example below can illustrate this using a time batch window. Here the PREV function can return a null value for any events in which the previous event is not in the same batch of events. The PRIOR function as discussed below can be used if a null value is not the desired result.\n\nSELECT PREV(I1 symbol) FROM Trade RETAIN BATCH OF 1 MINUTE\n\n[00256] The combination of the PREV function and the PARTITION BY clause can return the property value for a previous event in the given group.\n\n[00257] Let's look at an example. Assume we want to obtain the price of the previous event of the same symbol as the current event.\n\n[00258] The statement that follows can solve this problem. It can partition the window on the symbol property over a time window of one minute. As a result, when the engine encounters a new symbol value that it hasn't seen before, it can create a new window specifically to hold events for that symbol. Consequently, the PREV function can return the previous event within the respective time window for that event's symbol value.\n\nSELECT PREV(I, price) AS prevprice FROM Trade RETAIN 1 MIN PARTITION BY symbol\n\n[00259| The following restrictions can apply to the PREV functions and its results, in one embodiment:\n\nâ¢ The function always returns a null value for remove stream (old data) events\n\nâ¢ The function may only be used on streams that are constrained by a RETAIN clause\n\n[00260| The PRIOR function can return the property value of a prior event. The first parameter can be an integer value that denotes the i1*1 prior event in the natural order of arrival. The second parameter can be a property name for which the function returns the value for the prior event. This example selects the value of the price property of the second prior event to the current Trade event. SELECT PRIOR(2, price) FROM Trade RETAIN ALL\n\n[00261] The PRIOR function can be used on any event stream or view and does not require a stream to be constrained by a RETAIN clause as with the PREV function. The function can operate based on the order of arrival of events in the event stream that provides the events. The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause can employ the prior function to select the current average and the average before the current average:\n\nSELECT AVG(volume) AS avgVolume, PRIOR(I, avgVolume) FROM TradeAverages RETAIN BATCH OF 1 MINUTE\n\n[00262] The PRIOR function can be similar to the PREV function. The key differences between the two functions can be as follows:\n\nâ¢ The PREV function can return previous events in the order provided by the window, while the PRIOR function returns prior events in the order of arrival in the stream.\n\nâ¢ The PREV function can require a RETAIN clause while the PRIOR function does not.\n\nâ¢ The PREV function can return the previous event taking into account any grouping. The PRIOR function returns prior events regardless of any grouping.\n\nâ¢ The PREV function can return a null value for remove stream events, i.e. for events leaving a data window. The PRIOR function does not have this restriction. [00263] The aggregate functions can be SUM, AVG1 COUNT, MAX, MIN, MEDIAN, STDDEV, and AVEDEV. You can use aggregate functions to calculate and summarize data from event properties. For example, to find out the total price for all stock tick events in the last 30 seconds, type:\n\nSELECT SUM(price) FROM StockTickEvent RETAIN 30 SECONDS\n\n[00264] Here is the syntax for aggregate functions: aggregate_function( [all | distinct] expression)\n\n[00265] You can apply aggregate functions to all events in an event stream window or other view, or to one or more groups of events. From each set of events to which an aggregate function is applied, EPL generates a single value.\n\n(00266] The expression can be usually an event property name. However it can also be a constant, function, or any combination of event property names, constants, and functions connected by arithmetic operators.\n\n[00267] For example, to find out the average price for all stock tick events in the last 30 seconds if the price was doubled:\n\nSELECT AVG(price * 2) FROM StockTickEvent RETAIN 30 SECONDS\n\n[00268] You can use the optional keyword DISTINCT with all aggregate functions to eliminate duplicate values before the aggregate function is applied. The optional keyword ALL which performs the operation on all events is the default.\n\n[00269] Note that the MIN and MAX aggregate functions are also available as single row functions.\n\n[00270] The syntax of the aggregation functions and the results they produce, for one embodiment, are shown in table below.\n\n[00271) In one embodiment, you can use aggregation functions in a SELECT clause and in a HAVING clause. In one embodiment, you cannot use aggregate functions in a WHERE clause, but you can use the WHERE clause to restrict the events to which the aggregate is applied. The next query computes the average and sum of the price of stock tick events for the symbol AMCE only, for the last 10 stock tick events regardless of their symbol.\n\nSELECT 1BEA stats' AS title, AVG(price) AS avgPrice, SUM(price) AS sumPrice FROM StockTickEvent RETAIN 10 EVENTS WHERE symboM'ACME'\n\n[00272) In the above example, the length window of 10 elements is not affected by the\n\nWHERE clause; all events enter and leave the length window regardless of their symbol. If we only care about the last 10 ACME events, we need to use a subquery expression as shown below.\n\nSELECT 'ACME stats' AS title, AVG(pricÎ²) AS avgPrice, SUM(price) AS sumPrice FROM (SELECT * FROM StockTickEvent WHERE symbol='ACME') RETAIN 10 EVENTS\n\n|00273] In one embodiment, you can use aggregate functions with any type of event property or expression, with the following restrictions:\n\n1. You can use SUM, AVG, MEDIAN, STDDEV, and AVEDEV with numeric event properties only\n\n[00274| EPL can ignore any null values returned by the event property or expression on which the aggregate function is operating, except for the COUNT(*) function, which counts null values as well. All aggregate functions can return null if the data set contains no events, or if all events in the data set contain only null values for the aggregated expression. A user- defined function can be invoked anywhere as an expression itself or within an expression. The function can simply be a public static method that the class loader can resolve at statement creation time. The engine can resolve the function reference at statement creation time and verifies parameter types. The example below assumes a class MyClass that exposes a public static method myFunction accepting two parameters, and returning a numeric type such as double.\n\nSELECT 3 * MyClass. myFunction(price, volume) as myValue FROM StockTick RETAIN 30 SECONDS\n\n[00275| User-defined functions also take array parameters as this example shows.\n\nSELECT * FROM RFIDEvent RETAIN 10 MINUTES\n\nWHERE com.mycompany.rfid.MyChecker.islnZone(zone, {10, 20, 30}) (00276J The EPL processing model can be continuous: Listeners to statements receive updated data as soon as the engine processes events for that statement, according to the statement's choice of event streams, retain clause restrictions, filters and output rates.\n\n[00277] In this section, we look at the output of a very simple EPL statement. The statement selects an event stream without using a data window and without applying any filtering, as follows: SELECT * FROM Withdrawal RETAIN ALL\n\n(002781 Th's statement selects ail Withdrawal events. Every time the engine processes an event of type Withdrawal or any sub-type of Withdrawal, it invokes all update listeners, handing the new event to each of the statement* s listeners.\n\n[00279J The term insert stream can denote the new events arriving, and entering a data window or aggregation. The insert stream in this example is the stream of arriving Withdrawal events, and is posted to update listeners as new events.\n\n[00280J Figure 5 below shows a series of Withdrawal events 1 to 6 arriving over time. For this diagram as well as the others in this section, the number in parenthesis is the value of the amount property in the Withdrawal event.\n\n[00281] The example statement above results in only new events and no old events posted by the engine to the statement's listeners since no RETAIN clause is specified. [002821 In one embodiment, there can be two types of sliding windows: row-based and time-based. Each of these is discussed in the following sections. [00283] A row-based sliding window can instruct the engine to only keep the last N events for a stream. The next statement can apply a length window onto the Withdrawal event stream. The statement serves to illustrate the concept of data window and events entering and leaving a data window:\n\nSELECT * FROM Withdrawal RETAIN 5 EVENTS\n\n[00284] The size of this statement's window is five events. The engine enters all arriving Withdrawal events into the window. When the window is full, the oldest Withdrawal event is pushed out the window. The engine indicates to update listeners all events entering the window as new events, and all events leaving the window as old events.\n\n[00285] While the term insert stream can denote new events arriving, the term remove stream can denote events leaving a data window, or changing aggregation values. In this example, the remove stream is the stream of Withdrawal events that leave the length window, and such events are posted to update listeners as old events.\n\n[00286] Figure 6 illustrates how the length window contents change as events arrive and shows the events posted to an update listener.\n\n[00287] As before, all arriving events are posted as new events to update listeners. In addition, when event W1 leaves the length window on arrival of event W6, it is posted as an old event to update listeners.\n\n(00288] Similar to a length window, a time window also keeps the most recent events up to a given time period. A time window of 5 seconds, for example, keeps the last 5 seconds of events. As seconds pass, the time window actively pushes the oldest events out of the window resulting in one or more old events posted to update listeners.\n\n|00289J Note that EPL can support optional ISTREAM and RSTREAM keywords on SELECT clauses and on INSERT INTO clauses. These can instruct the engine to only forward events that enter or leave data windows, or select only current or prior aggregation values, i.e. the insert stream or the remove stream.\n\n(00290) A time-based sliding window can be a moving window extending to the specified time interval into the past based on the system time. Time-based sliding windows enable us to limit the number of events considered by a query, as do row-based sliding windows. Figure 7 serves to illustrate the functioning of a time window. For the diagram, we assume a query that simply selects the event itself and does not group or filter events.\n\nSELECT * FROM Withdrawal RETAIN 4 SECONDS\n\n(002911 Figure 7 starts at a given time t and displays the contents of the time window at t+4 and t+5 seconds and so on. The activity as illustrated by the Figure 7:\n\n1. At time t + 4 seconds an event Wi arrives and enters the time window. The engine reports the new event to update listeners.\n\n2. At time t + 5 seconds an event W2 arrives and enters the time window. The engine reports the new event to update listeners.\n\n3. At time t + 6.5 seconds an event W3 arrives and enters the time window. The engine reports the new event to update listeners. 4. At time t + 8 seconds event Wi leaves the time window. The engine reports the event as an old event to update listeners.\n\n[00292] As a practical example, consider the need to determine all accounts where the average withdrawal amount per account for the last 4 seconds of withdrawals is greater then 1000. The statement to solve this problem is shown below. SELECT account, AVG(amount) FROM Withdrawal RETAIN 4 SECONDS GROUP BY account HAVING amount > 1000\n\n(00293] Both row-based and time-based windows may be batched. The next sections explain each of these concepts in turn.\n\n[00294) The time-based batch window can buffer events and releases them every specified time interval in one update. Time-based batch windows can control the evaluation of events, as does the length batch window.\n\n[00295] Figure 8 serves to illustrate the functioning of a time batch view. For the diagram, we assume a simple query as below:\n\nSELECT * FROM Withdrawal RETAIN BATCH OF 4 SECONDS\n\n[00296] Figure 8 starts at a given time t and displays the contents of the time window at t + 4 and t + 5 seconds and so on. The activity as illustrated by Figure 8:\n\n1. At time t + 1 seconds an event W1 arrives and enters the batch. No call to inform update listeners occurs.\n\n2. At time t + 3 seconds an event W2 arrives and enters the batch. No call to inform update listeners occurs. 3. At time t + 4 seconds the engine processes the batched events and a starts a new batch. The engine reports events W1 and W2 to update listeners.\n\n4. At time t + 6.5 seconds an event W3 arrives and enters the batch. No call to inform update listeners occurs.\n\n5. At time t + 8 seconds the engine processes the batched events and a starts a new batch. The engine reports the event W3 as new data to update listeners. The engine reports the events W1 and W2 as old data (prior batch) to update listeners.\n\n[00297] A row-based window may be batched as well. For example, the following query would wait to receive five events prior to doing any processing:\n\nSELECT * FROM Withdrawal RETAIN BATCH OF 5 EVENTS [00298] Once five events were received, the query would run and again wait for a new set of five events prior to processing.\n\n[00299J Filters to event streams appear in a subquery expression and allow filtering events out of a given stream before events enter a data window. This filtering can occur prior to the WHERE clause executing. When possible, filtering should be done in a subquery as opposed to the WHERE clause, since this can improve performance by reducing the amount of data seen by the rest of the EPL statement.\n\n[00300] The statement below, illustrated in Figure 9, shows a subquery that selects Withdrawal events with an amount value of 200 or more.\n\nSELECT * FROM (SELECT * FROM Withdrawal WHERE amount >= 200) RETAIN 5 EVENTS\n\n100301] With the subquery, any Withdrawal events that have an amount of less then 200 do not enter the window of the outer query and are therefore not passed to update listeners. [00302] The WHERE clause and HAVING clause in statements eliminate potential result rows at a later stage in processing, after events have been processed into a statement's data window or other views.\n\n[00303] The next statement, illustrated in Figure 10, applies a WHERE clause to Withdrawal events instead of a subquery.\n\nSELECT * FROM Withdrawal RETAIN 5 EVENTS WHERE amount >= 200\n\n[00304] The WHERE clause can apply to both new events and old events. As the diagram below shows, arriving events enter the window regardless of the value of the \"amount\" property. However, only events that pass the WHERE clause are handed to update listeners. Also, as events leave the data window, only those events that pass the conditions in the WHERE clause are posted to update listeners as old events.\n\n[00305] Statements that aggregate events via aggregations functions also post remove stream events as aggregated values change. Consider the following statement that alerts when two Withdrawal events have been received:\n\nSELECT COUNTO AS mycount FROM Withdrawal RETAIN ALL HAVING COUNTO = 2 [00306] When the engine encounters the second withdrawal event, the engine can post a new event to update listeners. The value of the mycount property on that new event is 2. Additionally, when the engine encounters the third Withdrawal event, it can post an old event to update listeners containing the prior value of the count. The value of the mycount property on that old event is also 2.\n\n[00307J The ISTREÎAM or RSTREAM keyword can be used to eliminate either new events or old events posted to update listeners. The next statement uses the ISTREAM keyword causing the engine to call the update listener only once when the second Withdrawal event is received:\n\nSELECT ISTREAM COUNT(*) AS mycount FROM Withdrawal RETAIN ALL HAVING COUNT(') = 2\n\n[00308J The Java programmatic interface for the EPL can be rooted at the com. bea.wlrt.ede. Processor interface. This interface can provide methods to load, compile, start, stop, and retrieve EPL statements.\n\n|00309] EPL statements can be loaded and compiled individually through the following method:\n\nStatement compileQuery(String query); [00310] If the query fails to compile, a StatementException can be thrown. Alternatively, multiple statements may be loaded from a URL using the following method: void loadQueries (URL location);\n\n[003111 If the queries fail to compile, a MultiStatementException can be thrown. Note that individual queries compiled through the compileQuery need not persisted and have no effect on the rule files located at the URL location.\n\n[00312] The com.bea.wlrt.ede.Statement interface can allow update listeners to be attached to an EPL statement using the following method: void addStreamingEventListener (StreamingEventListener listener); [00313] The engine can call the following method on the com.bea.wlrt.ede.StreamingEventÏstener interface when events are added to the output window as a result of executing the statement: void onEvent (List newEvents);\n\n[00314] Alternatively, the occurrence of both added and removed events may be monitored by using the com.bea.wlrt.ede.RStreamingEventÏstener interface. In this case, the engine can invoke the following method when events are added to or removed from the output window as a result of executing the statement: void onREvent (List addedEvents, List removedEvents);\n\n[00315] The rules file containing queries loaded through the Processor.loadQueries(URI) method can have the structure shown in the XML schema of Figure 11. |00316] Below is an example of a rules file with two EPL statements:\n\n<processor xmlns=\"http://www.bea.com/wlrt/ede\" type=\" wlevs:epl\">\n\n<rules>\n\n<rule><![CDATA[ SELECT stockSymbol, price\n\nFROM StockTick RETAIN 2 events\n\nWHERE stockSymbol = 1AAA' AND price > 10.0\n\n]]></rule>\n\n<rule><![CDATA[ SELECT stockSymbol, price\n\nFROM StockTick RETAIN 2 events\n\nWHERE stockSymbol = 1BBB' AND price > 80.0\n\n]]></rule>\n\n</rÏ les> </processor>\n\n[00317] The use cases below illustrate through examples usage of various language features.\n\n[00318] For the throughput statistics and to detect rapid fall-off we calculate a ticks per second rate for each market data feed. [00319] We can use an EPL statement that batches together 1 second of events from the market data event stream source. We specify the feed and a count of events per feed as output values. To make this data available for further processing, we insert output events into the Ticks PerSecond event stream:\n\nINSERT INTO TicksPerSecond SELECT feed, COUNTf) AS cnt\n\nFROM MarketDataEvent RETAIN BATCH OF 1 SECOND GROUP BY feed\n\n[00320] For computing the highest priced stocks, we define a sliding window that retains 100 events for each unique stock symbol where the block size of the trade is greater than 10. For example, if there are 5,000 stock symbols, then 5,000 x 100 or 5,000,000 events would be kept. Only MarketTrade events with a block size of greater than 10 can enter the window and only the 100 highest priced events can be retained.\n\n[00321] The results can be grouped by stock symbol and ordered alphabetically with stock symbols having an average price of less than 100 being filtered from the output SELECT symbol, AVG(Ïrice)\n\nFROM (SELECT * FROM MarketTrade WHERE blockSize > 10) RETAIN 100 EVENTS PARTITION BY symbol WITH LARGEST price GROUP BY symbol HAVING AVG(price) >= 100 ORDER BY symbol\n\n[00322] We detect the route a car is taking based on the car location event data that contains information about the location and direction of a car on a highway. We first segment the data by carld to isolate information about a particular car and subsequently segment by expressway, direction and segment to plot its direction. We are then able to calculate tfte speed of the car based on this information.\n\n[00323) The first PARTITION BY car"
    }
}