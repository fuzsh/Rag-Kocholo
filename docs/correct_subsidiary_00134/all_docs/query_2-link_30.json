{
    "id": "correct_subsidiary_00134_2",
    "rank": 30,
    "data": {
        "url": "https://patents.google.com/patent/US8122006B2/en",
        "read_more_link": "",
        "language": "en",
        "title": "US8122006B2 - Event processing query language including retain clause - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/dc/2a/d7/8246a770c87c00/US08122006-20120221-D00000.png",
            "https://patentimages.storage.googleapis.com/70/96/2e/654757f588e90f/US08122006-20120221-D00001.png",
            "https://patentimages.storage.googleapis.com/25/d3/91/130f30d07151a4/US08122006-20120221-D00002.png",
            "https://patentimages.storage.googleapis.com/c6/c1/59/a48a8097fa5d2e/US08122006-20120221-D00003.png",
            "https://patentimages.storage.googleapis.com/91/2c/1a/0242a5633d038d/US08122006-20120221-D00004.png",
            "https://patentimages.storage.googleapis.com/4d/69/67/1a2f4276bd8022/US08122006-20120221-D00005.png",
            "https://patentimages.storage.googleapis.com/72/09/ea/621e5e99e6594e/US08122006-20120221-D00006.png",
            "https://patentimages.storage.googleapis.com/ba/1b/33/246fd01dc558d9/US08122006-20120221-D00007.png",
            "https://patentimages.storage.googleapis.com/0b/10/92/d8e9171fbc705c/US08122006-20120221-D00008.png",
            "https://patentimages.storage.googleapis.com/09/a5/90/9dcba4c32e52fb/US08122006-20120221-D00009.png",
            "https://patentimages.storage.googleapis.com/43/be/18/70f4fe9c3f88d4/US08122006-20120221-D00010.png",
            "https://patentimages.storage.googleapis.com/d1/37/66/8d0d1642526eb7/US08122006-20120221-D00011.png",
            "https://patentimages.storage.googleapis.com/68/39/dc/32bd2639f96e53/US08122006-20120221-D00012.png",
            "https://patentimages.storage.googleapis.com/5c/e7/33/deceb415b41c35/US08122006-20120221-D00013.png",
            "https://patentimages.storage.googleapis.com/bb/83/76/af948cad95bff0/US08122006-20120221-D00014.png",
            "https://patentimages.storage.googleapis.com/ac/c7/b8/b4c87211829869/US08122006-20120221-D00015.png",
            "https://patentimages.storage.googleapis.com/2d/ce/64/e7d147ceb8f962/US08122006-20120221-D00016.png",
            "https://patentimages.storage.googleapis.com/10/af/1f/c446fe28b77796/US08122006-20120221-D00017.png",
            "https://patentimages.storage.googleapis.com/ca/48/10/1e2686019907a5/US08122006-20120221-D00018.png",
            "https://patentimages.storage.googleapis.com/f8/84/f4/edef269181c320/US08122006-20120221-D00019.png",
            "https://patentimages.storage.googleapis.com/d1/66/45/a873a24d47e777/US08122006-20120221-D00020.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2007-05-29T00:00:00",
        "summary": "",
        "meta_description": "An event processor can use event processing queries to operate an event. Event processing queries can include a âretainâ clause that limits the amount of data over which the query is run.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US8122006B2/en",
        "text": "CLAIM OF PRIORITY\n\nThis application claims priority from the following application, which is hereby incorporated in their entirety: U.S. Provisional Application No. 60/940,655 entitled: âEVENT PROCESSING LANGUAGEâ, by Alexandre Alves, et al., filed May 29, 2007, and to U.S. Provisional Application No. 60/947,011 entitled: âEVENT PROCESSING QUERY LANGUAGEâ, by Alexandre Alves, et al., filed Jun. 29, 2007.\n\nBACKGROUND\n\nEvent processing is becoming more and more popular. In a complex event processor, streams of data are evaluated in real time. Because of the amount of data and the operation speeds required, the data is not stored into a database before it is processed. This means that a typical database language like SQL is not sufficient for processing the data.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nFIG. 1 illustrates an event processor of one embodiment of the present invention.\n\nFIG. 2 illustrates the use of a âretainâ clause in an event processing language.\n\nFIG. 3 illustrates the use of an âoutputâ clause in an event processing language.\n\nFIG. 4 illustrates the use of pattern matching in an event processing language.\n\nFIGS. 5-10 illustrate the operation of event processing queries.\n\nFIG. 11 illustrates an XML schema for a rules file of one embodiment.\n\nFIG. 12 illustrates a high level view of an event-driven system.\n\nFIG. 13 illustrates an exemplary application model of one embodiment.\n\nFIG. 14 illustrates an exemplary UML class diagram for the logical components of a realtime application server.\n\nFIG. 15 illustrates an exemplary event hierarchy for a financial trading system application.\n\nFIG. 16 illustrates an exemplary event processing network of a complete business.\n\nFIG. 17 illustrates an exemplary realtime application server product stack.\n\nFIG. 18 illustrates an exemplary Acceptor-Connector design pattern interaction diagram.\n\nFIGS. 19 and 20 illustrate exemplary join scenarios.\n\nFIGS. 21 and 22 illustrate exemplary sequence diagrams.\n\nDETAILED DESCRIPTION\n\nFIG. 1 shows an example of a system where event processor 102 operates on one or more event streams. In this example, event streams A and B are sent to the event processor 102. The event processing language queries can be used by the event processor 102 to operate on the event streams.\n\nIn one example, the event processing language queries 104 are interpreted by an event processing query language interpreter 106. Queries 108 can then operate on event streams.\n\nFIG. 2 shows an exemplary computer implemented system 200 comprising an event processor using queries to operate on an event. At least some event processing queries includes a âretainâ clause that limits the amount of data over which the query is run.\n\nFIG. 2 is a functional diagram. In the example of FIG. 2, the query 204 includes a retain clause 206 that is used by the event processor 202 to determine how much of the event stream data 208 to retain for processing.\n\nThe retained event data can be processed according to a function clause 210 to produce an output 212. The retain clause can limit the query to a certain time period or to a certain number of events.\n\nIn one embodiment, at least one RETAIN clause is used in each FROM clause. The RETAIN clause can apply to all stream sources listed in the FROM clause that precedes it. Conceptually it can define a window of event data for each stream source over which the query can be executed. In one embodiment, the RETAIN clause can have the following syntax:\n\nRETAIN â( ALL [EVENTS] ) | â( [BATCH OF] âââ( integer (EVENT|EVENTS) ) | ( time_interval (BASED ON prop_name)* ) âââ( PARTITION BY prop_name )* ââ( WITH [n] (LARGEST | SMALLEST | UNIQUE) prop_name )* )\n\nTo keep all events for a stream source, in one embodiment, ALL [EVENTS] can be specified in the retain clause. For example:\n\nSELECT AVG(price) FROM StockTick RETAIN ALL EVENTS\n\nIn this case, the average price can be calculated based on all StockTick events that occur. Care should be taken with this option, however, since memory may run out when making calculations that require all or part of each event object to be retained under high volume scenarios. One such example would be in calculating a weighted average.\n\nIn one embodiment, the amount of event data to keep when running the query may be determined in two ways. The first option is to specify the maximum number of events kept. For example, the query below would keep a maximum of 100 StockTick events on which the average price would be computed:\n\nSELECT AVG(price) FROM StockTick RETAIN 100 EVENTS\n\nAs each new StockTick event comes in, the average price would be computed, with a maximum of 100 events being used for the calculation.\n\nThe second option is to specify the time interval in which to collect event data. For example, the query below would keep 1 minute's worth of StockTick events and compute the average price for this data:\n\nSELECT AVG(price) FROM StockTick RETAIN 1 MINUTE\n\nIn this case, as each new StockTick event comes in, again the average price would be computed. However, events that arrived more than one minute ago would be removed from the window with the average price being recalculated based on the remaining events in the window.\n\nIn one embodiment, by default, the windows holding event data are sliding. With sliding windows, as a new event enters the window, an old events fall off the end of the window once the window is at capacity. Sliding windows can cause the query to be re-executed as each new event enters and/or old event leaves the window. An alternative is to specify that the event data should be batched prior to query execution. Only when the window is full, is the query is executed. After this, new event data can again be collected until the window is once again full at which time the query can be re-executed.\n\nFor example, the query below would batch together 100 events prior to executing the query to compute the average price:\n\nSELECT AVG(price) FROM StockTick RETAIN BATCH OF 100 EVENTS\n\nOnce executed, it would batch the next 100 events together prior to re-executing the query.\n\nIn one embodiment, the time interval for the RETAIN clause may be specified in days, hours, minutes, seconds, and/or milliseconds:\n\nââtime_interval: [day-part][hour-part][minute-part][seconds- part][milliseconds-part] ââday-part: number (âdaysâ | âdayâ) ââhour-part: number (âhoursâ | âhourâ | âhrâ) ââminute-part: number (âminutesâ | âminuteâ | âminâ) ââseconds-part: number (âsecondsâ | âsecondâ | âsecâ) ââmilliseconds-part: number (âmillisecondsâ | âmillisecondâ | âââmsecâ | âmsâ)\n\nSome examples of time intervals are: 10 seconds; 10 minutes; 30 seconds; 20 sec; 100 msec; 0.5 minutes; and 1 day 2 hours 20 minutes 15 seconds 110 milliseconds\n\nBy default, the elapse of a time interval can be based on an internal system clock. However, in some cases, the time can be based on a timestamp value appearing as an event property. In one embodiment, a BASED ON clause can be used to specify the property name containing a long-typed timestamp value. This can be applicable for time-based windows. In this example, the StockTick events would be expected to have a âtimestampâ property of type long whose value would control inclusion into and removal from the window:\n\nSELECT AVG(price) FROM StockTick RETAIN 1 MINUTE BASED ON timestamp\n\nIf more than one event source in the FROM clause has the same named property to store the timestamp, it can be listed a single time in the BASED ON clause. If multiple, differently named properties are used for the timestamp value, the BASED ON clause can be repeated. In one embodiment, when using the BASED ON clause, each stream source listed in the FROM clause has an associated timestamp property listed or an exception can be thrown. A property may be referred to by simply using its property name within the RETAIN clause. However, if ambiguities exist because the same property name exists in more than one stream source in the FROM clause, it can be prefixed with its alias name followed by a period (similar to the behavior of properties referenced in the SELECT clause). A PARTITION BY clause can allow a window to be further subdivided into multiple windows based on the unique values contained in the properties listed. For example, the following query can keep 3 events for each unique stock symbol:\n\nSELECT stockSymbol, price FROM StockTick RETAIN 3 EVENTS PARTITION BY stockSymbol\n\nConceptually this can be similar to the GROUP BY functionality in SQL or EPL. However, the PARTITION BY clause only controls the size and subdivision of the window and does not cause event data to be aggregated as with the GROUP BY clause. However, in most cases, the PARTITION BY clause can be used in conjunction with the GROUP BY clause with same properties specified in both.\n\nThe following examples illustrate the interaction between PARTITION BY and GROUP BY. In the first example, with the absence of the PARTITION BY clause, a total of 10 events can be kept across all stock symbols.\n\nSELECT stockSymbol, AVG(price) FROM StockTick RETAIN 10 EVENTS GROUP BY stockSymbol\n\nThe average price for each unique set of stock symbol can be computed based on these 10 events. If a stock symbol of âAAAâ comes into the window, it may cause a different stock symbol such as âBBBâ to leave the window. This would cause the average price for both the âAAAâ group as well as the âBBBâ group to change. The second example includes the PARTITION BY clause and the GROUP BY clause.\n\nSELECT stockSymbol, AVG(price) FROM StockTick RETAIN 10 EVENTS PARTITION BY stockSymbol GROUP BY stockSymbol\n\nIn this case, 10 events can be kept for each unique stock symbol. If a stock symbol of âAAAâ comes into the window, it would only affect the sub-window associated with that symbol and not other windows for different stock symbols. Thus, in this case, only the average price of âAAAâ would be affected.\n\nIn one embodiment, the WITH clause can allow the largest, smallest, and unique property values to be kept in the window. For example, to keep the two highest priced stocks, the following statement would be used:\n\nââSELECT stockSymbol, price FROM StockTick RETAIN 2 EVENTS WITH LARGEST price\n\nIn the case of time-based windows, the [n] qualifier before the LARGEST or SMALLEST keyword can determine how many values are kept. For example, the following statement would keep the two smallest prices seen over one minute:\n\nââSELECT stockSymbol, price FROM StockTick RETAIN 1 MINUTE WITH 2 SMALLEST price\n\nIn the absence of this qualifier, the single largest or smallest value can be kept. The UNIQUE qualifier can cause the window to include only the most recent among events having the same value for the specified property. For example, the following query would keep only the last stock tick for each unique stock symbol:\n\nSELECT * FROM StockTick RETAIN 1 DAY WITH UNIQUE stockSymbol\n\nPrior events of the same property value can be posted as old events by the engine. The query is done as a sliding window.\n\nFIG. 3 shows a computer-implemented system comprising an event processor 302 using queries to operate on event streams. At least some event queries 304 can include an output clause 306 to restrict the output of the query.\n\nIn the functional diagram example of FIG. 3, the query 304 includes an output clause 306 that is used by event processor 302 to determine how to throttle the output.\n\nThe output clause can hold the output of the query until a certain amount of time has occurred or until a certain number of events have been received.\n\nThe output of the query can be another stream. An âinsert intoâ clause can be used to create another stream.\n\nA âFirstâ keyword can indicate that the first event or events in an output batch is to be output. A âLastâ keyword can indicate that the last event or events in an output batch is to be output.\n\nThe OUTPUT clause can be optional in the event processing language and can be used to control or stabilize the rate at which events are output. For example, the following statement can batch old and new events and outputs them at the end of every 90 second interval.\n\nââSELECT * FROM StockTickEvent RETAIN 5 EVENTS OUTPUT EVERY 90 SECONDS\n\nHere is the syntax for output rate limiting of one embodiment:\n\nââOUTPUT [ALL | ( (FIRST | LAST) [number]] EVERY number [EVENTS | time_unit] ââwhere ââtime_unit: MIN | MINUTE | MINUTES | SEC | SECOND | ââSECONDS | MILLISECONDS | MS\n\nThe ALL keyword can be the default and specifies that all events in a batch should be output. The batch size can be specified in terms of time or number of events.\n\nThe FIRST keyword can specify that only the first event in an output batch is to be output. The optional number qualifier can allow more than one event to be output. The FIRST keyword can instruct the engine to output the first matching event(s) as soon as they arrive, and then ignore matching events for the time interval or number of events specified. After the time interval elapsed, or the number of matching events has been reached, the same cycle can start again.\n\nThe LAST keyword can specify to only output the last event at the end of the given time interval or after the given number of matching events have been accumulated. The optional number qualifier allows more than one event to be output.\n\nThe time interval can also be specified in terms of minutes or milliseconds; the following statement is identical to the first one.\n\nââSELECT * FROM StockTickEvent RETAIN 5 EVENTS OUTPUT EVERY 1.5 MINUTES\n\nAnother way that output can be stabilized is by batching events until a certain number of events have been collected. The next statement only outputs when either 5 (or more) new or 5 (or more) old events have been batched.\n\nââSELECT * FROM StockTickEvent RETAIN 30 SECONDS OUTPUT EVERY 5 EVENTS\n\nAdditionally, in one embodiment, event output can be further modified by the optional LAST keyword, which causes output of only the last event(s) to arrive into an output batch. For the example below, the last five events would be output every three minutes.\n\nââSELECT * FROM StockTickEvent RETAIN 30 SECONDS OUTPUT LAST 5 EVERY 3 MINUTES\n\nUsing the FIRST keyword you can be notified at the start of the interval. This allows one to be immediately notified each time a rate falls below a threshold.\n\nSELECT * FROM TickRate RETAIN 30 SECONDS WHERE rate < 100 OUTPUT FIRST EVERY 60 SECONDS\n\nThe OUTPUT clause can interact in two ways with the GROUP BY and HAVING clauses. First, in the OUTPUT EVERY n EVENTS case, the number n can refer to the number of events arriving into the GROUP BY clause. That is, if the GROUP BY clause outputs only 1 event per group, or if the arriving events don't satisfy the HAVING clause, then the actual number of events output by the statement could be fewer than n.\n\nSecond, the LAST and ALL keywords can have special meanings when used in a statement with aggregate functions and the GROUP BY clause. The LAST keyword can specify that only groups whose aggregate values have been updated with the most recent batch of events should be output. The ALL keyword (the default) can specify that the most recent data for all groups seen so far should be output, whether or not these groups' aggregate values have just been updated.\n\nFIG. 4 shows a computer-implemented system 400 comprising an event processor 402 using queries to operate on an event stream. At least some event processing queries 404 can include a âmatchingâ clause 406 that matches a pattern in the event stream or streams.\n\nA variable can be bound to the event that matches. The variable can be used in a later query expression. The first or second stream can be filtered before the matching by filter clause of the query. A âfollowed byâ operator can be used to match event conditions in a particular order.\n\nA query can use Boolean operations for a match. The Boolean operations include an âANDâ an âORâ and a âNOTâ.\n\nIn one embodiment, the pattern matching can use multiple event streams.\n\nA MATCHING clause can allow for the detection of a series of one or more events occurring that satisfies a specified pattern. Pattern expressions can be references to streams or stream aliases separated by logical operators such as AND, OR, and FOLLOWED BY to define the sequence of events that compose the pattern. The MATCHING clause can execute prior to the WHERE or HAVING clauses. The syntax can be as follows:\n\nââMATCHING stream_expression ( ( AND | OR | [NOT] FOLLOWED BY ) stream_expression )*\n\nThe stream_expression can be either a stream source name or a stream source alias optionally bound to a variable and filtered by a parenthesized expression. It can be prefixed by a NOT to match the absence of an event occurring:\n\nstream_expression: [NOT][var_name=](stream_name|stream_alias)[(filter_expression)]\n\nThe var_name can be bound to the event object occurring that triggers the match. It may be referenced as any other event property in filter expressions that follow as well as in other clauses such as the SELECT and WHERE clauses. An alias can be used to eliminate ambiguity if the same event type is used multiple times in the FROM clause. In one embodiment, the stream_expression can optionally be followed by a parenthesized expression to filter the matching events of that type. The expression act as a precondition for events to enter the corresponding window and has the same syntax as a WHERE clause expression.\n\nIn the example below we look for RFIDEvent event with a category of âPerishableâ followed by an RFIDError whose id matches the id of the matched RFIDEvent object.\n\nSELECT * FROM RFIDEvent,RFIDError RETAIN 1 MINUTE MATCHING a=RFIDEvent(category=âPerishableâ) FOLLOWED BY RFIDError(id=a.id)\n\nThe next sections discuss the syntax, semantics, and additional operators available in the MATCHING clause to express temporal constraints for pattern matching of one embodiment.\n\nA FOLLOWED BY temporal operator can match on the occurrence of several event conditions in a particular order. This need not mean that two events must immediately follow each other.\n\nThe AND logical operator can require both nested pattern expressions to turn true before the whole expression returns true. In the context of the MATCHING clause, the operator can match on the occurrence of several event conditions but not necessarily in a particular order. For example, the following pattern can match when both event A and event B are found:\n\nA and B\n\nThis pattern can match on any sequence of A followed by B in either order. In addition, it is not required that a B event immediately follow an A eventâother events may appear in between the occurrence of an A event and a B event for this expression to return true.\n\nThe OR logical operator can require either one of the expressions to turn true before the whole expression returns true. In the context of the MATCHING clause, the operator can match on the occurrence of either of several event conditions but not necessarily in a particular order.\n\nFor example, the following pattern can match for either event A or event B:\n\nA OR B\n\nThe following would detect all stock ticks that are either above a certain price or above a certain volume.\n\nStockTick(price>1.0) OR StockTick(volume>1000)\n\nThe NOT operator can negate the truth value of an expression. In the context of the MATCHING clause, the operator can allow the absence of an event condition to be detected.\n\nIn one embodiment, the following pattern matches only when an event A is encountered followed by event B but only if no event C was encountered before event B.\n\n(A FOLLOWED BY B) AND NOT C\n\nThe FROM clause may list the same event type multiple times. In this case, the event type alias can be used in the MATCHING clause. The statement below is an example in which the pattern matches for one RFIDEvent followed by another RFIDEvent prior to an RFIDErrorEvent occurring:\n\nSELECT * FROM RFIDEvent rfidA, RFIDEvent rfidB, RFIDErrorEvent rfidError ââRETAIN 1 MINUTE ââMATCHING ( rfidA FOLLOWED BY rfidB ) AND NOT rfidError\n\nUsing the BATCH OF qualifier in the RETAIN clause can have special meaning when matching sequences of events. Without the BATCH OF qualifier, once the specified sequence of events is detected, continued attempts to match can be made with events following the first event in the matched sequence. However, with the BATCH OF qualifier, attempts to match can continue with events following the last event in the matched sequence.\n\nConsider exemplary operations for an example event sequence, as follows:\n\nA1 B1 C1 B2 A2 D1 A3 B3 E1 A4 F1 B4\n\nExample Description SELECT * The pattern fires for every event A followed by an event B FROM EventA with a sliding window. At the time a pattern is detected A, EventB B with the occurrence of event B, matching starts again with RETAIN the event after A. 1 MINUTE 1. Matches on B1 for combination {A1, B1} MATCHING A 2. Matches on B3 for combination {A2, B3} and {A3, FOLLOWED B3}. Note that two matches occur with B3 since after the BY B first match, the matching continue with events following A2 instead of with event following B3. 3. Matches on B4 for combination {A4, B4} SELECT * The pattern fires for every event A followed by an event B FROM EventA with a batched window. At the time a pattern is detected A, EventB B with the occurrence of event B, matching starts again with RETAIN the event after B. BATCH 1. Matches on B1 for combination {A1, B1} OF 1 MINUTE 2. Matches on B3 for combination {A2, B3}. Note MATCHING A that only one match of B3 occurs since after the first FOLLOWED match, matching continues with the events following B3 BY B instead of with the event following A2 as was done above. 3. Matches on B4 for combination {A4, B4}\n\nExemplary Embodiment\n\nAn exemplary embodiment of a system using methods of the present invention is described below. The following exemplary embodiment is not meant to be limiting as to terms, definitions and the like. For example, language in this section is not intended to limit or define the claim terms but only to describe a particular exemplary embodiment. This section merely describes one exemplary way to implement the present invention. Other architectures implementing the methods and systems of the present invention can be done.\n\nThe following describes an Event Processing Language (EPL) for an event server, such as WebLogic Event Server 2.0. The language can allow event data from streams and external JDBC sources to be declaratively filtered, correlated, aggregated, and merged, with the ability to insert results to other streams for further downstream processing. The language can have additional functionality over SQL type languages to both a) constraint the amount of data over which the query is run since unlike relatively static relational table data, the stream data is continuously flowing, and b) detect a series of events that match a specified pattern.\n\nIn one embodiment, the Complex Event Processor module can be broken down into the following functional components: event representation, processing model, programmatic interface, and language specification.\n\nEvents can be represented as Plain Old JAVA Objects (POJOs) following the JavaBeans conventions. Event properties can be exposed through getter methods on the POJO. When possible, the results from EPL statement execution can also returned as POJOs. However, there are times when un-typed events are returned such as when event streams are joined. In this case, an instance of the Map collection interface can be returned.\n\nThe EPL processing model can be continuous: results can be output as soon as incoming events are received that meet the constraints of the statement. In one embodiment, two types of events can be generated during output: insert events for new events entering the output window and remove events for old events exiting the output window. Listeners may be attached and notified when either or both type of events occur.\n\nIn one embodiment, incoming events may be processed through either sliding or batched windows. Sliding windows can process events by gradually moving the window over the data in single increments, while batched windows can process events by moving the window over data in discrete chunks. The window size may be defined by the maximum number of events contained or by the maximum amount of time to keep an event.\n\nThe EPL programmatic interfaces can allow statements to be individually compiled or loaded in bulk through a URL. Statements may be iterated over, retrieved, started and stopped. Listeners may be attached to statements and notified when either insert and/or remove events occur.\n\nThe Event Processing Language (EPL), can be a SQL-like language with SELECT, FROM, WHERE, GROUP BY, HAVING and ORDER BY clauses. Streams replace tables as the source of data with events replacing rows as the basic unit of data. Since events are composed of data, the SQL concepts of correlation through joins, filtering through sub-queries, and aggregation through grouping may be effectively leveraged. The INSERT INTO clause can be recast as a means of forwarding events to other streams for further downstream processing. External data accessible through JDBC may be queried and joined with the stream data. Additional clauses such as the RETAIN, MATCHING, and OUTPUT clauses can also be available to provide language constructs specific to event processing.\n\nThe RETAIN clause can constrain the amount of data over which the query is run, essentially defining a virtual window over the stream data. Unlike relational database systems in which tables bound the extents of the data, event processing systems can use alternative, more dynamic means of limiting the queried data.\n\nThe MATCHING clause can detect sequences of events matching a specific pattern. Temporal and logical operators such as AND, OR, and FOLLOWED BY can enable both occurrence of and absence of events to be detected through arbitrarily complex expressions.\n\nThe OUTPUT clause can throttle results of statement execution to prevent overloading downstream processors. Either all or a subset of the first or last resulting events can be passed on in either time or row-based batches.\n\nAn event can be an immutable record of a past occurrence of an action or state change. In this example, event is represented by the com.bean.wlrt.ede.StreamingEvent interface. In this example, an event can have an underlying object that represents the event object which is accessible through the StreamingEvent.getUnderlying( ) method. In one embodiment, the underlying object can have a set of event properties that supply information about the event and may be represented as any of the following:\n\nJava Class Description java.lang.Object Any Java POJO with getter methods following JavaBeans conventions. java.util.Map Map events are key-values pairs\n\nPlain old Java object (POJO) events can be object instances that expose event properties through JavaBeans-style getter methods. Events classes or interfaces do not have to be fully compliant to the JavaBeans specification; however for the EPL engine to obtain event properties, in one embodiment, the required JavaBeans getter methods must be present.\n\nEPL can support JavaBeans-style event classes that extend a super class or implement one or more interfaces. Also, EPL statements can refer to Java interface classes and abstract classes.\n\nClasses that represent events can be made immutable. As events are recordings of a state change or action that occurred in the past, the relevant event properties need not be changeable. However this is not a hard requirement and the EPL engine can accept events that are mutable as well.\n\nEvents can also be represented by objects that implement the java.util.Map interface. Event properties of Map events can be the values of each entry accessible through the get method exposed by the java.util.Map interface.\n\nEntries in the Map can represent event properties. Keys can be of the type java.util.String for the engine to be able to look up event property names specified by EPL statements. Values can be of any type. POJOs may also appear as values in a Map.\n\nThe engine can also query Java objects as values in a Map event via the nested property syntax. Thus Map events can be used to aggregate multiple data structures into a single event and query the composite information in a convenient way. The example below demonstrates a Map event with a transaction and an account object.\n\nMap event = new HashMap( ); event.put(âtxnâ, txn); event.put(âaccountâ, account); events.add(new StreamingEventObject(TxnEventType, 0, 0, event));\n\nAn example statement could look as follows.\n\nSELECT account.id, account.rate * txn.amount FROM TxnEvent RETAIN 60 SECONDS GROUP BY account.id\n\nEPL expressions can include simple as well as indexed, mapped and nested event properties. The table below outlines the different exemplary types of properties and their syntax in an event expression. This syntax allows statements to query deep JavaBeans objects graphs, XML structures and Map events. The following describes types of one embodiments:\n\nType Description Syntax Example Simple A property that has a single value that name sensorID may be retrieved. The property type may be a primitive type (such as int, or java.lang.String) or another complex type. Nested A nested property is a property that name.nestedname sensor.value Lives within another property of an event. Note that events represented as a Map may only nest other POJO events and not other Map events. Indexed An indexed property stores an name[index] sensor[0] ordered collection of objects (all of the same type) that can be individually accessed by an integer valued, non-negative index (or subscript). Note that events represented as a Map do not support Indexed properties. Mapped A mapped property stores a keyed name(âkeyâ) sensor(âlightâ) collection of objects (all of the same type). As an extension to standard JavaBeans APIs, EPL considers any property that accepts a String-valued key a mapped property. Note that events represented as a Map do not support Indexed properties\n\nAssume there is an EmployeeEvent event class as shown below. The mapped and indexed properties in this example can return Java objects but could also return Java language primitive types (such as int or String). The Address object and Employee objects can themselves have properties that are nested within them, such as a street-Name in the Address object or a name of the employee in the Employee object.\n\npublic class EmployeeEvent { public String getFirstName( ); public Address getAddress(String type); public Employee getSubordinate(int index); public Employee[] getAllSubordinates( ); }\n\nSimple event properties can require a getter-method that returns the property value. In this example, the getFirstName getter method returns the firstName event property of type String.\n\nIndexed event properties can require either one of the following getter-methods:\n\nA method that takes an integer type key value and returns the property value, such as the getSubordinate method.\n\nA method that returns an array-type such as the getSubordinates getter method, which returns an array of Employee.\n\nIn an EPL statement, indexed properties can be accessed via the property [index] syntax.\n\nMapped event properties can require a getter-method that takes a String type key value and returns a property value, such as the getAddress method. In an EPL or event pattern statement, mapped properties can be accessed via the property (âkeyâ) syntax.\n\nNested event properties can require a getter-method that returns the nesting object. The getAddress and getSubordinate methods can be mapped and indexed properties that return a nesting object. In an EPL statement, nested properties can be accessed via the property.nestedProperty syntax.\n\nEPL statements can allow the use of indexed, mapped and nested properties (or a combination of these) at any place where one or more event property names are expected. The example below shows different combinations of indexed, mapped and nested properties.\n\naddress(âhomeâ).streetName\n\nsubordinate[0] name=âanotherNameâ\n\nallSubordinates[1].name\n\nsubordinate[0].address(âhomeâ).streetName\n\nSimilarly, the syntax can be used in EPL statements in all places where an event property name is expected, such as in select lists, where clauses or join criteria.\n\nSELECT firstName, address(âworkâ), subordinate[0].name, subordinate[1].name FROM EmployeeEvent RETAIN ALL WHERE address(âworkâ).streetName = âPark Aveâ\n\nEvent listeners can provide a means of receiving programmatic notifications when events occur that meet the criteria specified in an EPL statement. In one embodiment, listeners may be notified when either:\n\nNew events occur that meet the criteria specified in an EPL statement. These are termed ISTREAM events.\n\nOld events that previously met the criteria specified in an EPL statement are pushed out of the output window due to their expiration or due to new incoming events occurring that take their place. These are termed RSTREAM events.\n\nDetailed examples illustrating when each of these notifications occur are provided below.\n\nIn one embodiment, to receive ISTREAM events the com.bea.wlrt.ede.StreamingEventListener interface is used. Implementations can provide a single onEvent method that the engine invokes when results become available. With this interface, only the new events are sent to the listener.\n\npublic interface StreamingEventListener extends EventListener { âvoid onEvent(List<StreamingEvent> newEvents) throws RejectStreamingEventException;. â/** ââ* Listeners that do not want to implement the Listener interface ââ* can annotate an existing method to notify runtime which method ââ* to call back when events arrive. ââ* ââ*/ â@Target(ElementType.METHOD) â@Retention(RetentionPolicy.RUNTIME) â@interface Callback { â} }\n\nTo receive both ISTREAM and RSTREAM events the com.bea.wlrt.ede.RStreamingEventListener interface can be used. Since this interface is derived from the StreamingEventListener interface, implementations must provide both an onEvent method as well as an on REvent method. The engine can invoke the onEvent as before while the on REvent method is invoked when either ISTREAM or RSTREAM events occur. With the on REvent method, both the new and old events can be sent to the listener.\n\npublic interface RStreamingEventListener extends StreamingEventListener { âvoid onREvent(List<StreamingEvent> newEvents, âList<StreamingEvent> oldEvents) ââthrows RejectStreamingEventException; â/** ââ* Listeners that do not want to implement the Listener interface ââ* can annotate an existing method to notify runtime which method ââ* to call back when events arrive. ââ* ââ*/ â@Target(ElementType.METHOD) â@Retention(RetentionPolicy.RUNTIME) â@interface Callback { â} }\n\nIn one embodiment, the engine can provide statement results to listeners by placing results in com.bea.wlrt.ede.StreamingEvent instances. A typical listener implementation can query the StreamingEvent instances via getter methods to obtain the statement-generated results.\n\nThe get method on the StreamingEvent interface can be used to retrieve result columns by name. The property name supplied to the get method can also be used to query nested, indexed or array properties of object graphs.\n\nThe getUnderlying method on the StreamingEvent interface can allow update listeners to obtain the underlying event object. For wildcard selects, the underlying event is the original event object that was sent into the engine. For joins and select clauses with expressions, the underlying object implements java.util.Map.\n\nThe top-level extended Backus-Naur form (eBNF) for EPL can be as follows:\n\n[ INSERT INTO insert_into_def] âSELECT select_list âFROM stream_source_list [ MATCHING pattern_expression ] [ WHERE search_conditions ] [ GROUP BY grouping_expression_list ] [ HAVING grouping_search_conditions ] [ ORDER BY order_by_expression_list ] [ OUTPUT output_specification ]\n\nIn one embodiment, literal keywords are not case sensitive. Each clause is detailed in the following sections. In addition, the built-in operators and functions are listed and described.\n\nThe SELECT clause can be required in all EPL statements. The SELECT clause can be used to select all properties via the wildcard *, or to specify a list of event properties and expressions. The SELECT clause can define the event type (event property names and types) of the resulting events published by the statement, or pulled from the statement.\n\nThe SELECT clause can also offer optional ISTREAM and RSTREAM keywords to control how events are posted to update listeners attached to the statement. The syntax for the SELECT clause, of one embodiment, is summarized below.\n\nSELECT [RSTREAM|ISTREAM] (expression_list|*)\n\nThe following examples use the FROM clause which defines the sources of the event data.\n\nTo chose the particular event properties to return:\n\nSELECT event_property [, event_property] [, . . . ] FROM stream_def\n\nThe following statement can select the count and standard deviation of the volume for the last 100 stock tick events.\n\nSELECT COUNT, STDDEV(volume) FROM StockTick RETAIN 100 EVENTS\n\nThe select clause can contain one or more expressions.\n\nSELECT expression [, expression] [, . . . ] FROM stream_def\n\nThe following statement can select the volume multiplied by price for a time batch of the last 30 seconds of stock tick events.\n\nSELECT volume * price FROM StockTick RETAIN BATCH OF 30 SECONDS\n\nEvent properties and expressions can be aliased using below syntax.\n\nSELECT [event_property|expression] AS identifier [, . . . ]\n\nThe following statement can select volume multiplied by price and specifies the name volPrice for the event property.\n\nSELECT volume*price AS volPrice FROM StockTick RETAIN 100 EVENTS\n\nThe syntax for selecting all event properties in a stream can be:\n\nSELECT *FROM stream_def\n\nThe following statement can select all of the StockTick event properties for the last 30 seconds:\n\nSELECT * FROM StockTick RETAIN 30 SECONDS\n\nIn a join statement, using the SELECT * syntax can select event properties that contain the events representing the joined streams themselves.\n\nThe * wildcard and expressions can also be combined in a SELECT clause. The combination selects all event properties and in addition the computed values as specified by any additional expressions that are part of the SELECT clause. Here is an example that selects all properties of stock tick events plus a computed product of price and volume that the statement names âpricevolumeâ:\n\nSELECT *, price * volume AS pricevolume FROM StockTick RETAIN ALL\n\nThe optional ISTREAM and RSTREAM keywords in the SELECT clause can define the event stream posted to update listeners to the statement. If neither keyword is specified, the engine can post both insert and remove stream events to statement listeners. The insert stream can consist of the events entering the respective window(s) or stream(s) or aggregations, while the remove stream consists of the events leaving the respective window(s) or the changed aggregation result.\n\nBy specifying the ISTREAM keyword you can instruct the engine to only post insert stream events to update listeners. In one embodiment, the engine can then not post any remove stream events. By specifying the RSTREAM keyword you can instruct the engine to only post remove stream events to update listeners. In one embodiment, the engine can then not post any insert stream events.\n\nThe following statement can select only the events that are leaving the 30 second time window.\n\nSELECT RSTREAM * FROM StockTick RETAIN 30 SECONDS\n\nThe ISTREAM and RSTREAM keywords in the SELECT clause can be matched by same-name keywords available in the INSERT INTO clause. While the keywords in the SELECT clause control the event stream posted to update listeners to the statement, the same keywords in the insert into clause can specify the event stream that the engine makes available to other statements.\n\nThe FROM clause can be required in all EPL statements. It can specify one or more event streams as the source of the event data.\n\nFROM stream_expression [ inner_join | outer_join ] with inner_join specified as a comma separated list of stream expressions: â(, stream_expression )* and outer_join defined as: ((LEFT|RIGHT|FULL) OUTER JOIN stream_expression ON prop_name = prop_name)*\n\nA stream_expression can simply define the name of the event type used as the source of the stream data, or in more complex scenarios define either a subquery expression as a nested EPL statement or a parameterized SQL query to access JDBC data. In all of these cases, the stream_expression can optionally include an alias as an identifier to qualify any ambiguous property name references in other expressions and a RETAIN clause to define the window of stream data seen by the rest of the query:\n\n(stream_name | subquery_expr | param_sql_query) [[AS] alias]] [RETAIN retain_expr] subquery_expr: ( epl_statement ) param_sql_query: database_name (âparameterized_sql_queryâ)\n\nThe subquery_expr can define a sub query or nested EPL statement in parenthesis. A sub query can be used to pre-filter event stream data seen by the outer EPL statement. For example, the following query would restrict the data seen by the outer EPL statement to only StockTick events coming from a Reuters feed.\n\nSELECT stockSymbol, AVG(price) FROM (SELECT * FROM StockTick WHERE feedName = âReutersâ ) RETAIN 1 MINUTE PARTITION BY stockSymbol GROUP BY stockSymbol\n\nSub queries can be arbitrarily nested. In one embodiment, sub queries may not contain an INSERT INTO or an OUTPUT clause. In one embodiment, unlike with a top level EPL statement, a RETAIN clause is optional within a subquery.\n\nThe param_sql_query can specify a parameterized SQL query in quotes surrounded by parenthesis that enables reference and historical data accessible through JDBC to be retrieved. The database_name can identify the name of the database over which the query can be executed. Configuration information can be associated with this database name to establish a database connection, control connection creation and removal, and to setup caching policies for query results.\n\nThe RETAIN clause can define the quantity of event data read from the streams listed in the FROM clause prior to query processing. Each stream may have its own RETAIN clause if each require different retain policies. Otherwise, the RETAIN clause may appear at the end of the FROM clause for it to apply to all streams. Essentially the RETAIN clause can apply to all streams that appear before it in the FROM clause.\n\nFor example, in the following EPL statement, five StockTick events can be retained while three News events can be retained:\n\nSELECT t.stockSymbol, t.price, n.summary FROM StockTick t RETAIN 5 EVENTS, News n RETAIN 3 EVENTS WHERE t.stockSymbol = n.stockSymbol\n\nHowever, in the following statement, four StockTick and four News events can be retained:\n\nSELECT t.stockSymbol, t.price, n.summary FROM StockTick t, News n RETAIN 4 EVENTS WHERE t.stockSymbol = n.stockSymbol\n\nIn one embodiment, with the exception of sub query expressions, all stream sources are constrained by a RETAIN clause. Thus, in one embodiment, at a minimum the FROM clause contains at least one RETAIN clause at the end for top level EPL statements. External data from parameterized SQL queries need not affected by the RETAIN clause.\n\nTwo or more event streams can be part of the FROM clause with all of the streams determine the resulting events. The WHERE clause can list the join conditions that EPL uses to relate events in two or more streams. In one embodiment, if the condition is failed to be met, for example if no event data occurs for either of the joined stream source, no output need be produced.\n\nEach point in time that an event arrives to one of the event streams, the two event streams can be joined and output events can be produced according to the where-clause.\n\nThis example joins two event streams. The first event stream consists of fraud warning events for which we keep the last 30 minutes. The second stream is withdrawal events for which we consider the last 30 seconds. The streams are joined on account number.\n\nSELECT fraud.accountNumber AS accntNum, âfraud.warning AS warn, withdraw.amount AS amount, âMAX(fraud.timestamp, withdraw.timestamp) AS timestamp, ââwithdrawlFraudâ AS desc FROM Fraud WarningEvent AS fraud RETAIN 30 MIN, ââWithdrawalEvent AS withdraw RETAIN 30 SEC WHERE fraud.accountNumber = withdraw.accountNumber\n\nLeft outer joins, right outer joins and full outer joins between an unlimited number of event streams can be supported by EPL. Depending on the LEFT, RIGHT, or FULL qualifier, in the absence of event data from either stream source, output may still occur.\n\nIf the outer join is a left outer join, there can be an output event for each event of the stream on the left-hand side of the clause. For example, in the left outer join shown below we can get output for each event in the stream RfidEvent, even if the event does not match any event in the event stream OrderList.\n\nSELECT * FROM RfidEvent AS rfid âââLEFT OUTER JOIN ââOrderList AS orderlist âââON rfid.itemId = orderList.itemId RETAIN 30 SECONDS\n\nSimilarly, if the join is a Right Outer Join, then there can be an output event for each event of the stream on the right-hand side of the clause. For example, in the right outer join shown below we can get output for each event in the stream OrderList, even if the event does not match any event in the event stream RfidEvent.\n\nSELECT * FROM RfidEvent AS rfid âââRIGHT OUTER JOIN ââOrderList AS orderlist âââON rfid.itemId = orderList.itemId RETAIN 30 SECONDS\n\nFor all types of outer joins, if the join condition is not met, the select list can be computed with the event properties of the arrived event while all other event properties are considered to be null.\n\nSELECT * FROM RfidEvent AS rfid âââFULL OUTER JOIN ââOrderList AS orderlist âââON rfid.itemId = orderList.itemId RETAIN 30 SECONDS\n\nThe last type of outer join is a full outer join. In a full outer join, each point in time that an event arrives to one of the event streams, one or more output events are produced. In the example below, when either an RfidEvent or an OrderList event arrive, one or more output event is produced.\n\nA sub query expression can be a nested EPL statement that appears in parenthesis in the FROM clause. A sub query need not contain an INSERT INTO clause or an OUTPUT clause, and unlike top level EPL statements, a RETAIN clause is optional.\n\nSub query expressions can execute prior to their containing EPL statement and thus can be useful to pre-filter event data seen by the outer statement. For example, the following query can calculate the moving average of a particular stock over the last 100 StockTick events:\n\nSELECT AVG(price) FROM (SELECT * FROM StockTick WHERE stockSymbol = âACMEâ ) RETAIN 100 EVENTS\n\nIn one embodiment, if the WHERE clause had been placed in the outer query, StockTick events for other stock symbols would enter into the window, reducing the number of events used to calculate the average price.\n\nIn addition, a subquery may be used to a) transform the structure of the inner event source to the structure required by the outer EPL statement or b) merge multiple event streams to form a single stream of events. This allows a single EPL statement to be used instead of multiple EPL statements with an INSERT INTO clause connecting them. For example, the following query merges transaction data from EventA and EventB and then uses the combined data in the outer query:\n\nSELECT custId, SUM(latency) FROM (SELECT A.customerId AS custId, A.timestamp -B.timestamp AS latency ââFROM EventA A, EventB B ââWHERE A.txnId = B.txnId) RETAIN 30 MIN GROUP BY custId\n\nNote that a subquery itself may contain subqueries thus allowing arbitrary levels of nesting.\n\nParameterized SQL queries can enable reference and historical data accessible through JDBC to be queried via SQL within EPL statements. In one embodiment, in order for such data sources to become accessible to EPL, some configuration is required.\n\nIn one embodiment, the following restrictions can apply:\n\nOnly one event stream and one SQL query may be joined; Joins of two or more event streams with an SQL query are not supported.\n\nConstraints specified in the RETAIN clause are ignored for the stream for the SQL query; That is, one cannot create a time-based or event-based window on an SQL query. However one can use the INSERT INTO syntax to make join results available to a further statement.\n\nThe database software supports JDBC prepared statements that provide statement metadata at compilation time. Most major databases provide this function.\n\nOther embodiments need have these restrictions.\n\nThe query string can be single or double quoted and surrounded by square brackets. The query may contain one or more substitution parameters. The query string can be passed to the database software unchanged, allowing the use of any SQL query syntax that your database understands, including stored procedure calls.\n\nSubstitution parameters in the SQL query string take the form ${event_property_name}. The engine resolves event_property_name at statement execution time to the actual event property value supplied by the events in the joined event stream.\n\nThe engine can determine the type of the SQL query output columns by means of the result set metadata that your database software returns for the statement. The actual query results can be obtained via the getObject on java.sql.ResultSet.\n\nThe sample EPL statement below joins an event stream consisting of CustomerCallEvent events with the results of an SQL query against the database named MyCustomerDB and table Customer:\n\nSELECT custId, cust_name FROM CustomerCallEvent, MyCustomerDB (â SELECT cust_name FROM Customer WHERE cust_id = ${custId} â) ââRETAIN 10 MINUTES\n\nThe example above assumes that CustomerCallEvent supplies an event property named custId. The SQL query can select the customer name from the Customer table. The WHERE clause in the SQL can match the Customer table column cust_id with the value of custId in each CustomerCallEvent event. In one embodiment, the engine executes the SQL query for each new CustomerCallEvent encountered. If the SQL query returns no rows for a given customer id, the engine can generate no output event. Else the engine can generate one output event for each row returned by the SQL query. An outer join as described in the next section can be used to control whether the engine should generate output events even when the SQL query returns no rows. The next example adds a time window of 30 seconds to the event stream CustomerCallEvent. It also renames the selected properties to customerName and customerId to demonstrate how the naming of columns in an SQL query can be used in the select clause in the EQL query. The example uses explicit stream names via the AS keyword.\n\nSELECT customerId, customerName FROM CustomerCallEvent AS cce RETAIN 30 SECONDS, âMyCustomerDB ââ(âSELECT cust_id AS customerId, cust_name AS customerName âââFROM Customer WHERE cust_id = ${cce.custId}â) AS cq\n\nAny window, such as the time window, generates insert events as events enter the window, and remove events as events leave the window. The engine executes the given SQL query for each CustomerCallEvent in both the insert stream and the remove stream cases. As a performance optimization, the ISTREAM or RSTREAM keywords in the SELECT clause can be used to instruct the engine to only join insert or remove events, reducing the number of SQL query executions. Parameterized SQL queries can be used in outer joins as well. Use a left outer join, such as in the next statement, if you need an output event for each event regardless of whether or not the SQL query returns rows. If the SQL query returns no rows, the join result populates null values into the selected properties.\n\nSELECT custId, custName FROM CustomerCallEvent AS cce âLEFT OUTER JOIN âMyCustomerDB ââ(âSELECT cust_id, cust_name AS custName âââFROM Customer WHERE cust_id = ${cce.custId}â) AS cq âON cce.custId = cq.cust_id RETAIN 10 MINUTES\n\nThe statement above can always generates at least one output event for each CustomerCallEvent, containing all columns selected by the SQL query, even if the SQL query does not return any rows. Note the ON expression that is used for outer joins. The ON can act as an additional filter to rows returned by the SQL query. The WHERE clause can be an optional clause in EPL statements. Using the WHERE clause event streams can be joined and events can be filtered. In one embodiment, aggregate functions may not appear in a WHERE clause. To filter using aggregate functions, the HAVING clause can be used.\n\nWHERE aggregate_free_expression\n\nComparison operators =, <, >, >=, <=, !=, < >, IS NULL, IS NOT NULL and logical combinations via AND and OR can be supported in the where clause. Some examples are listed below.\n\n... WHERE fraud.severity = 5 AND amount > 500 ... WHERE (orderItem.orderId IS NULL) OR (orderItem.class != 10) ... WHERE (orderItem.orderId = NULL) OR (orderItem.class <> 10) ... WHERE itemCount / packageCount > 10\n\nThe GROUP BY clause can be optional in EPL statements. The GROUP BY clause can divide the output of an EPL statement into groups. You can group by one or more event property names, or by the result of computed expressions. When used with aggregate functions, GROUP BY can retrieve the calculations in each subgroup. You can use GROUP BY without aggregate functions, but generally that can produce confusing results.\n\nFor example, the below statement can return the total price per symbol for all stock tick events in the last 30 seconds:\n\nSELECT symbol, SUM(price) FROM StockTickEvent RETAIN 30 SEC GROUP BY symbol\n\nThe syntax of the group by clause can be:\n\nGROUP BY arregate_free_expression [, arregate_free_expression] [, . . . ]\n\nEPL can place the following restrictions on expressions in the GROUP BY clause:\n\n1. Expressions in the GROUP BY clause cannot contain aggregate functions\n\n2. Event properties that are used within aggregate functions in the SELECT clause cannot also be used in a GROUP BY expression\n\nIn one embodiment, you can list more then one expression in the GROUP BY clause to nest groups. Once the sets are established with GROUP BY, the aggregation functions can be applied. This statement can post the median volume for all stock tick events in the last 30 seconds grouped by symbol and tick data feed. EPL can post one event for each group to statement update listeners:\n\nSELECT symbol, tickDataFeed, MEDIAN(volume) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol, tickDataFeed\n\nIn the statement above the event properties in the select list (symbol and tickDataFeed) can be listed in the GROUP BY clause. The statement can thus follow the SQL standard which prescribes that non-aggregated event properties in the select list must match the GROUP BY columns. EPL can also support statements in which one or more event properties in the select list are not listed in the GROUP BY clause. The statement below demonstrates this case. It calculates the standard deviation for the last 30 seconds of stock ticks aggregating by symbol and posting for each event the symbol, tickDataFeed and the standard deviation on price.\n\nSELECT symbol, tickDataFeed, STDDEV(price) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol\n\nThe above example still aggregates the price event property based on the symbol, but produces one event per incoming event, not one event per group. Additionally, EPL can support statements in which one or more event properties in the GROUP BY clause are not listed in the select list. This is an example that calculates the mean deviation per symbol and tickDataFeed and posts one event per group with symbol and mean deviation of price in the generated events. Since tickDataFeed is not in the posted results, this can potentially be confusing.\n\nSELECT symbol, AVEDEV(price) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol, tickDataFeed\n\nExpressions can also be allowed in the GROUP BY list:\n\nSELECT symbol * price, count(*) FROM StockTickEvent RETAIN 30 SECONDS GROUP BY symbol * price\n\nIf the GROUP BY expression can result in a null value, the null value can become its own group. All null values can be aggregated into the same group. In one embodiment, the COUNT(expression) aggregate function does not count null values and the COUNT returns zero if only null values are encountered.\n\nIn one embodiment, you can use a WHERE clause in a statement with GROUP BY. Events that do not satisfy the conditions in the WHERE clause can be eliminated before any grouping is done. For example, the statement below posts the number of stock ticks in the last 30 seconds with a volume larger then 100, posting one event per group (symbol).\n\nSELECT symbol, count(*) FROM StockTickEvent RETAIN 30 SECONDS WHERE volume > 100 GROUP BY symbol\n\nThe HAVING clause can be optional in EPL statements. The HAVING clause can be used to pass or reject events defined by the GROUP BY clause. The HAVING clause can set conditions for the GROUP BY clause in the same way WHERE sets conditions for the SELECT clause, except the WHERE clause cannot include aggregate functions, while HAVING often does.\n\nHAVING expression\n\nThis statement is an example of a HAVING clause with an aggregate function. It can post the total price per symbol for the last 30 seconds of stock tick events for only those symbols in which the total price exceeds 1000. The HAVING clause eliminates all symbols where the total price is equal or less then 1000.\n\nSELECT symbol, SUM(price) FROM StockTickEvent RETAIN 30 SEC GROUP BY symbol HAVING SUM(price) > 1000\n\nTo include more then one condition in the HAVING clause combine the conditions with AND, OR or NOT. This is shown in the statement below which selects only groups with a total price greater then 1000 and an average volume less then 500.\n\nSELECT symbol, SUM(price), AVG(volume) FROM StockTickEvent RETAIN 30 SEC GROUP BY symbol HAVING SUM(price) > 1000 AND AVG(volume) < 500\n\nEPL can place the following restrictions on expressions in the HAVING clause:\n\n3. Any expressions that contain aggregate functions must also occur in the SELECT clause\n\nA statement with the HAVING clause should also have a GROUP BY clause. If you omit GROUP BY, all the events not excluded by the WHERE clause return as a single group. In that case HAVING can act like a WHERE except that HAVING can have aggregate functions.\n\nThe HAVING clause can also be used without GROUP BY clause as the below example shows. The example below posts events where the price is less then the current running average price of all stock tick events in the last 30 seconds.\n\nSELECT symbol, price, AVG(price) FROM StockTickEvent RETAIN 30 SEC HAVING price < AVG(price)\n\nWhen an EPL statement includes subqueries, a MATCHING clause, WHERE conditions, a GROUP BY clause, and HAVING conditions, the sequence in which each clause executes can determine the final result:\n\n4. Any subqueries present in the statement run first. The subqueries act as a filter for events to enter the window of the outer query.\n\n5. The event stream's filter conditions in the MATCHING clause, if present, can dictate which events enter a window. The filter discards any events not meeting filter criteria.\n\n6. The WHERE clause excludes events that do not meet its search condition.\n\n7. Aggregate functions in the select list calculate summary values for each group.\n\n8. The HAVING clause can exclude events from the final results that do not meet its search condition.\n\nThe following query can illustrate the use of filter, WHERE, GROUP BY and HAVING clauses in one statement with a SELECT clause containing an aggregate function.\n\nSELECT tickDataFeed, STDDEV(price) FROM (SELECT * FROM StockTickEvent WHERE symbol=âACMEâ) âRETAIN 10 EVENTS âWHERE volume > 1000 âGROUP BY tickDataFeed âHAVING STDDEV(price) > 0.8\n\nEPL can filter events using the subquery for the event stream StockTickEvent. In the example above, only events with symbol ACME enter the window over the last 10 events, all other events are simply discarded. The WHERE clause can remove any events posted into the window (events entering the window and event leaving the window) that do not match the condition of volume greater then 1000. Remaining events are applied to the STDDEV standard deviation aggregate function for each tick data feed as specified in the GROUP BY clause. Each tickDataFeed value can generate one event. EPL can apply the HAVING clause and only lets events pass for tickDataFeed groups with a standard deviation of price greater then 0.8.\n\nThe ORDER BY clause can be optional in EPL. It can be used for ordering output events by their properties, or by expressions involving those properties. For example, the following statement can batch 1 minute of stock tick events sorting them first by price and then by volume.\n\nSELECT symbol FROM StockTickEvent RETAIN BATCH OF 1 MINUTE ORDER BY price, volume\n\nHere is an exemplary syntax for an ORDER BY clause:\n\nORDER BY expression [ASC|DESC] [, expression [ASC|DESC] [, . . . ]]\n\nEPL can place the following restrictions on the expressions in the ORDER BY clause:\n\n9. All aggregate functions that appear in the ORDER BY clause must also appear in the SELECT expression.\n\nOtherwise, in one embodiment, any kind of expression that can appear in the SELECT clause, as well as any alias defined in the SELECT clause, is also valid in the ORDER BY clause.\n\nThe INSERT INTO clause can be optional in EPL. This clause can be specified to make the results of a statement available as an event stream for use in further statements. The clause can also be used to merge multiple event streams to form a single stream of events.\n\nINSERT INTO CombinedEvent SELECT A.customerId AS custId, A.timestamp -B.timestamp AS latency FROM EventA A, EventB B RETAIN 30 MIN WHERE A.txnId = B.txnId\n\nThe INSERT INTO clause in the above statement, can generate events of type CombinedEvent. Each generated CombinedEvent event can have two event properties named âcustIdâ and âlatencyâ. The events generated by the above statement can be used in further statements. For example, the statement below uses the generated events.\n\nSELECT custId, SUM(latency) FROM CombinedEvent RETAIN 30 MIN GROUP BY custId\n\nThe INSERT INTO clause can consist of just an event type alias, or of an event type alias and one or more event property names. The syntax for the INSERT INTO clause can be as follows:\n\nINSERT [ISTREAM | RSTREAM] INTO event_type_alias [(prop_name [,prop_name, [,...]] ) ]\n\nThe ISTREAM (default) and RSTREAM keywords are optional. If neither keyword is specified, the engine can supply the insert stream events generated by the statement to attached update listeners. The insert stream can consist of the events entering the respective window(s) or stream(s). If the RSTREAM keyword is specified, the engine supplies the remove stream events generated by the statement. The remove stream can consist of the events leaving the respective window(s).\n\nThe event_type_alias can be an identifier that names the events generated by the engine. The identifier can be used in statements to filter and process events of the given name.\n\nThe engine can also allow update listeners to be attached to a statement that contain an INSERT INTO clause.\n\nTo merge event streams, the same event_type_alias identifier can be used in any EPL statements that you would like to be merged. Make sure to use the same number and names of event properties and that event property types match up.\n\nEPL can place the following restrictions on the INSERT INTO clause:\n\n10. The number of elements in the SELECT clause must match the number of elements in the INSERT INTO clause if the clause specifies a list of event property names.\n\n11. If the event type alias has already been defined by a prior statement and the event property names and types do not match, an exception is thrown at statement creation time.\n\nThe example statement below shows the alternative form of the INSERT INTO clause that explicitly defines the property names to use.\n\nINSERT INTO CombinedEvent (custId, latency) SELECT A.customerId, A.timestamp - B.timestamp FROM EventA A, EventB B RETAIN 30 MIN WHERE A.txnId = B.txnId\n\nThe RSTREAM keyword can be used to indicate to the engine to generate only remove stream events. This can be useful if we want to trigger actions when events leave a window rather then when events enter a window. The statement below generates CombinedEvent events when EventA and EventB leave the window after 30 minutes.\n\nINSERT RSTREAM INTO CombinedEvent SELECT A.customerId AS custId, A.timestamp - B.timestamp AS latency FROM EventA A, EventB B RETAIN 30 MIN WHERE A.txnId = B.txnId\n\nThe precedence of arithmetic and logical operators in EPL can follow Java standard arithmetic and logical operator precedence.\n\nThe table below outlines the arithmetic operators available, in one embodiment.\n\nOperator Description +, â As unary operators they denote a positive or negative expression. As binary operators they add or subtract. *, / Multiplication and division are binary operators. % Modulo binary operator.\n\nThe table below outlines the logical and comparison operators available, in one embodiment.\n\nOperator Description NOT Returns true if the following condition is false, returns false if it is true OR Returns true if either component condition is true, returns false if both are false AND Returns true if both component conditions are true, returns false if either is false =, !=, <, > <=, >=, <> Comparison operators\n\nThe table below outlines the concatenation operators available, in one embodiment.\n\nOperator Description || Concatenates character strings\n\nThe table below outlines the binary operators available, in one embodiment.\n\nOperator Description & Bitwise AND if both operands are numbers; conditional AND if both operands are Boolean | Bitwise OR if both operands are numbers; conditional OR if both operands are Boolean {circumflex over (â)} Bitwise exclusive OR (XOR)\n\nThe {and} curly braces can be array definition operators following the Java array initialization syntax. Arrays can be useful to pass to user-defined functions or to select array data in a SELECT clause.\n\nArray definitions can consist of zero or more expressions within curly braces. Any type of expression can be allowed within array definitions including constants, arithmetic expressions or event properties. This is the syntax of an array definition:\n\n{[expression [,expression [, . . . ]]]}\n\nConsider the next statement that returns an event property named actions. The engine populates the actions property as an array of java.lang.String values with a length of 2 elements. The first element of the array contains the observation property value and the second element the command property value of RFIDEvent events.\n\nSELECT {observation, command} AS actions FROM RFIDEvent RETAIN ALL\n\nThe engine can determine the array type based on the types returned by the expressions in the array definition. For example, if all expressions in the array definition return integer values then the type of the array is java.lang.Integer[ ]. If the types returned by all expressions are a compatible number types, such as integer and double values, the engine coerces the array element values and returns a suitable type, java.lang.Double[ ] in this example. The type of the array returned is Object[ ] if the types of expressions cannot be coerced or return object values. Null values can also be used in an array definition.\n\nArrays can come in handy for use as parameters to user-defined functions:\n\nSELECT * FROM RFIDEvent RETAIN ALL WHERE Filter.myFilter(zone, {1,2,3})\n\nThe IN operator can determine if a given value matches any value in a list. The syntax of the operator can be:\n\ntest_expression [NOT] IN (expression [,expression [, . . . ]])\n\nThe test_expression can be any valid expression. The IN keyword can be followed by a list of expressions to test for a match. The optional NOT keyword can specify that the result of the predicate be negated.\n\nThe result of an IN expression can be of type Boolean. In one embodiment, if the value of test_expression is equal to any expression from the comma-separated list, the result value is true. Otherwise, the result value is false. In one embodiment, all expressions must be of the same type or a type compatible with test_expression.\n\nThe next example shows how the IN keyword can be applied to select certain command types of RFID events:\n\nSELECT * FROM RFIDEvent RETAIN ALL WHERE command IN (âOBSERVATIONâ, âSIGNALâ)\n\nThe statement is equivalent to:\n\nSELECT * FROM RFIDEvent RETAIN ALL WHERE command = âOBSERVATIONâ OR symbol = âSIGNALâ\n\nThe BETWEEN operator can specify a range to test. In one embodiment, the syntax of the operator is:\n\ntest_expression [NOT] BETWEEN begin_expression AND end_expression\n\nThe test_expression can be any valid expression and is the expression to test for the range being inclusively within the expressions defined by begin_expression and end_expression. The NOT keyword can specify that the result of the predicate be negated.\n\nThe result of a BETWEEN expression can be of type Boolean. If the value of test_expression is greater then or equal to the value of begin_expression and less than or equal to the value of end_expression, the result can be true.\n\nThe next example shows how the BETWEEN keyword can be used to select events with a price between 55 and 60 (inclusive).\n\nSELECT * FROM StockTickEvent RETAIN ALL WHERE price BETWEEN 55 AND 60\n\nThe equivalent expression without using the BETWEEN keyword is:\n\nSELECT * FROM StockTickEvent RETAIN ALL WHERE price >= 55 AND price <= 60\n\nIn one embodiment, the begin_expression and end_expression may occur in either order without affecting the query. For example, the following can be equivalent to the above example:\n\nSELECT * FROM StockTickEvent RETAIN ALL WHERE price BETWEEN 60 AND 55\n\nThe LIKE operator can provide standard SQL pattern matching. SQL pattern matching can allow you to use â_â to match any single character and â%â to match an arbitrary number of characters (including zero characters). In EPL, SQL patterns are case-sensitive by default. The syntax of LIKE is:\n\ntest_expression [NOT] LIKE pattern_expression [ESCAPE string_literal]\n\nThe test_expression can be any valid expression yielding a String type or a numeric result. The optional NOT keyword specifies that the result of the predicate be negated. The LIKE keyword is followed by any valid standard SQL pattern_expression yielding a String-typed result. The optional ESCAPE keyword signals the escape character used to escape â_â and â%â values in the pattern.\n\nThe result of a LIKE expression is of type Boolean. If the value of test_expression matches the pattern_expression, the result value is true. Otherwise, the result value is false. An example for the LIKE keyword is shown below.\n\nSELECT * FROM PersonLocationEvent RETAIN ALL WHERE name LIKE â%Jack%â\n\nThe escape character can be defined as follows. In this example the where-clause matches events where the suffix property is a single â_â character.\n\nSELECT * FROM PersonLocationEvent RETAIN ALL WHERE suffix LIKE â!_â ESCAPE â!â\n\nThe REGEXP operator can be a form of pattern matching based on regular expressions implemented through the Java java.util.regex package. The syntax of REGEXP is:\n\ntest_expression [NOT] REGEXP pattern_expression\n\nThe test_expression can be any valid expression yielding a String type or a numeric result. The optional NOT keyword specifies that the result of the predicate be negated. The REGEXP keyword can be followed by any valid regular expression pattern_expression yielding a String-typed result.\n\nThe result of a REGEXP expression can be of type Boolean. In one embodiment, if the value of test_expression matches the regular expression pattern_expression, the result value is true. Otherwise, the result value is false.\n\nAn example for the REGEXP operator is below.\n\nSELECT * FROM PersonLocationEvent RETAIN ALL WHERE name REGEXP â*Jack*â\n\nThe followed by FOLLOWED BY operator can specify that first the left hand expression must turn true and only then is the right hand expression evaluated for matching events.\n\nLook for event A and if encountered, look for event B. A and B can itself be nested event pattern expressions.\n\nA FOLLOWED BY B\n\nNote that this does not mean that event A must immediately be followed by event B. Other events may occur between the event A and the event B and this expression would still evaluate to true. If this is not the desired behavior, the NOT operator can be used as described in the next section.\n\nThis is a pattern that fires when two status events indicating an error occur after the other.\n\nstatus=âERRORâ FOLLOWED BY status=âERRORâ\n\nSingle-row functions return a single value for every single result row generated by your statement. These functions can appear anywhere where expressions are allowed.\n\nEPL can allow static Java library methods as single-row functions, and also features built-in single-row functions.\n\nEPL can auto-import the following Java library packages:\n\njava.lang.*\n\njava.math.*\n\njava.text.*\n\njava.util.*\n\nThe Java static library methods can be used in all expressions as shown in below example:\n\nSELECT symbol, Math.round(volume/1000) FROM StockTickEvent RETAIN 30 SECONDS\n\nOther arbitrary Java classes may also be used, however their names may need to be fully qualified or configured to be imported.\n\nThe table below outlines the built-in single-row functions available, in one embodiment.\n\nSingle-row Function Result MAX(expression, expression [, expression Returns the highest numeric [,...]) value among the two or more comma-separated expressions. MIN(expression, expression [, expression Returns the lowest numeric [,...]) value among the two or more comma-separated expressions. COALESCE(expression, expression Returns the first non-null value [, expression ,...]) in the list, or null if there are no non-null values. CASE value Returns result where the first âWHEN compare_value THEN result value equals compare_value. â[WHEN compare_value THEN result ...] â[ELSE result] END CASE value Returns the result for the first âWHEN condition THEN result condition that is true. â[WHEN condition THEN result ...] â[ELSE result] END PREV(expression, event_property) Returns a property value of a previous event, relative to the event order within a data window PRIOR(integer, event_property) Returns a property value of a prior event, relative to the natural order of arrival of events\n\nThe MIN and MAX functions can take two or more expression parameters. The min function can return the lowest numeric value among these comma-separated expressions, while the MAX function can return the highest numeric value. The return type can be the compatible aggregated type of all return values.\n\nThe next example shows the MAX function that has a Double return type and returns the value 1.1.\n\nSELECT MAX(1, 1.1, 2*0.5) FROM . . .\n\nThe MIN function can return the lowest value. The statement below uses the function to determine the smaller of two timestamp values.\n\nSELECT symbol, MIN(ticks.timestamp, news.timestamp) AS minT FROM StockTickEvent AS ticks, NewsEvent AS news RETAIN 30 SECONDS WHERE ticks.symbol = news.symbol\n\nNote that the MIN and MAX functions can also available as aggregate functions.\n\nThe result of the COALESCE function can be the first expression in a list of expressions that returns a non-null value. The return type can be the compatible aggregated type of all return values.\n\nThis example returns a String type result with a value of âfooâ.\n\nSELECT COALESCE(NULL, âfooâ) FROM . . .\n\nThe CASE control flow function can have two versions. The first version can take a value and a list of compare values to compare against, and returns the result where the first value equals the compare value. The second version can take a list of conditions and returns the result for the first condition that is true.\n\nThe return type of a CASE expression is the compatible aggregated type of all return values.\n\nThe example below shows the first version of a CASE statement. It has a String return type and returns the value âoneâ.\n\nSELECT CASE 1 WHEN 1 THEN âoneâ WHEN 2 THEN âtwoâ ELSE âmoreâ END FROM ...\n\nThe second version of the CASE function can take a list of conditions. The next example has a Boolean return type and returns the Boolean value true.\n\nSELECT CASE WHEN 1>0 THEN true ELSE false END FROM . . .\n\nThe PREV function can return the property value of a previous event. The first parameter can denote the ith previous event in the order established by the data window. The second parameter can be a property name for which the function returns the value for the previous event.\n\nThis example selects the value of the price property of the second previous event from the current Trade event.\n\nSELECT PREV(2, price) FROM Trade RETAIN 10 EVENTS\n\nSince the PREV function takes the order established by the data window into account, the function can work well with sorted windows. In the following example the statement selects the symbol of the three Trade events that had the largest, second-largest and third-largest volume.\n\nSELECT PREV(0, symbol), PREV(1, symbol), PREV(2, symbol) FROM Trade RETAIN 10 EVENTS WITH HIGHEST volume\n\nThe ith previous event parameter can also be an expression returning an Integer type value. The next statement joins the Trade data window with a RankSelectionEvent event that provides a rank property used to look up a certain position in the sorted Trade data window:\n\nSELECT PREV(rank, symbol) FROM Trade, RankSelectionEvent RETAIN 10 EVENTS WITH HIGHEST volume\n\nThe PREV function can return a NULL value if the data window does not currently hold the ith previous event. The example below can illustrate this using a time batch window. Here the PREV function can return a null value for any events in which the previous event is not in the same batch of events. The PRIOR function as discussed below can be used if a null value is not the desired result.\n\nSELECT PREV(1, symbol) FROM Trade RETAIN BATCH OF 1 MINUTE\n\nThe combination of the PREV function and the PARTITION BY clause can return the property value for a previous event in the given group.\n\nLet's look at an example. Assume we want to obtain the price of the previous event of the same symbol as the current event.\n\nThe statement that follows can solve this problem. It can partition the window on the symbol property over a time window of one minute. As a result, when the engine encounters a new symbol value that it hasn't seen before, it can create a new window specifically to hold events for that symbol. Consequently, the PREV function can return the previous event within the respective time window for that event's symbol value.\n\nSELECT PREV(1, price) AS prevprice FROM Trade RETAIN 1 MIN PARTITION BY symbol\n\nThe following restrictions can apply to the PREV functions and its results, in one embodiment:\n\nThe function always returns a null value for remove stream (old data) events\n\nThe function may only be used on streams that are constrained by a RETAIN clause\n\nThe PRIOR function can return the property value of a prior event. The first parameter can be an integer value that denotes the ith prior event in the natural order of arrival. The second parameter can be a property name for which the function returns the value for the prior event. This example selects the value of the price property of the second prior event to the current Trade event.\n\nSELECT PRIOR(2, price) FROM Trade RETAIN ALL\n\nThe PRIOR function can be used on any event stream or view and does not require a stream to be constrained by a RETAIN clause as with the PREV function. The function can operate based on the order of arrival of events in the event stream that provides the events. The next statement uses a time batch window to compute an average volume for 1 minute of Trade events, posting results every minute. The select-clause can employ the prior function to select the current average and the average before the current average:\n\nSELECT AVG(volume) AS avgVolume, PRIOR(1, avgVolume) FROM TradeAverages RETAIN BATCH OF 1 MINUTE\n\nThe PRIOR function can be similar to the PREV function. The key differences between the two functions can be as follows:\n\nThe PREV function can return previous events in the order provided by the window, while the PRIOR function returns prior events in the order of arrival in the stream.\n\nThe PREV function can require a RETAIN clause while the PRIOR function does not.\n\nThe PREV function can return the previous event taking into account any grouping. The PRIOR function returns prior events regardless of any grouping.\n\nThe PREV function can return a null value for remove stream events, i.e. for events leaving a data window. The PRIOR function does not have this restriction.\n\nThe aggregate functions can be SUM, AVG, COUNT, MAX, MIN, MEDIAN, STDDEV, and AVEDEV. You can use aggregate functions to calculate and summarize data from event properties. For example, to find out the total price for all stock tick events in the last 30 seconds, type:\n\nSELECT SUM(price) FROM StockTickEvent RETAIN 30 SECONDS\n\nHere is the syntax for aggregate functions:\n\naggregate_function([all|distinct] expression)\n\nYou can apply aggregate functions to all events in an event stream window or other view, or to one or more groups of events. From each set of events to which an aggregate function is applied, EPL generates a single value.\n\nThe expression can be usually an event property name. However it can also be a constant, function, or any combination of event property names, constants, and functions connected by arithmetic operators.\n\nFor example, to find out the average price for all stock tick events in the last 30 seconds if the price was doubled:\n\nSELECT AVG(price*2) FROM StockTickEvent RETAIN 30 SECONDS\n\nYou can use the optional keyword DISTINCT with all aggregate functions to eliminate duplicate values before the aggregate function is applied. The optional keyword ALL which performs the operation on all events is the default.\n\nNote that the MIN and MAX aggregate functions are also available as single row functions.\n\nThe syntax of the aggregation functions and the results they produce, for one embodiment, are shown in table below.\n\nAggregate Function Result SUM([ALL|DISTINCT] Totals the (distinct) values in the expression) expression, returning a value of long, double, float or integer type depending on the expression AVG([ALL|DISTINCT] Average of the (distinct) values in the expression) expression, returning a value of double type COUNT([ALL|DISTINCT] Number of the (distinct) non-null values expression) in the expression, returning a value of long type COUNT(*) Number of events, returning a value of long type MAX([ALL|DISTINCT] Highest (distinct) value in the expression, expression) returning a value of the same type as the expression itself returns MIN([ALL|DISTINCT] Lowest (distinct) value in the expression, expression) returning a value of the same type as the expression itself returns MEDIAN([ALL|DISTINCT] Median (distinct) value in the expression, expression) returning a value of double type STDDEV([ALL|DISTINCT] Standard deviation of the (distinct) values expression) in the expression, returning a value of double type AVEDEV([ALL|DISTINCT] Mean deviation of the (distinct) values in expression) the expression, returning a value of double type TREND(expression) Number of consecutive up ticks (as positive number), down ticks (as negative number), or no change (as zero) for expression.\n\nIn one embodiment, you can use aggregation functions in a SELECT clause and in a HAVING clause. In one embodiment, you cannot use aggregate functions in a WHERE clause, but you can use the WHERE clause to restrict the events to which the aggregate is applied. The next query computes the average and sum of the price of stock tick events for the symbol AMCE only, for the last 10 stock tick events regardless of their symbol.\n\nSELECT âBEA statsâ AS title, AVG(price) AS avgPrice, SUM(price) AS sumPrice FROM StockTickEvent RETAIN 10 EVENTS WHERE symbol=âACMEâ\n\nIn the above example, the length window of 10 elements is not affected by the WHERE clause; all events enter and leave the length window regardless of their symbol. If we only care about the last 10 ACME events, we need to use a subquery expression as shown below.\n\nSELECT âACME statsâ AS title, AVG(price) AS avgPrice, SUM(price) AS sumPrice FROM (SELECT * FROM StockTickEvent WHERE symbol=âACMEâ) RETAIN 10 EVENTS\n\nIn one embodiment, you can use aggregate functions with any type of event property or expression, with the following restrictions:\n\n1. You can use SUM, AVG, MEDIAN, STDDEV, and AVEDEV with numeric event properties only\n\nEPL can ignore any null values returned by the event property or expression on which the aggregate function is operating, except for the COUNT(*) function, which counts null values as well. All aggregate functions can return null if the data set contains no events, or if all events in the data set contain only null values for the aggregated expression. A user-defined function can be invoked anywhere as an expression itself or within an expression. The function can simply be a public static method that the class loader can resolve at statement creation time. The engine can resolve the function reference at statement creation time and verifies parameter types. The example below assumes a class MyClass that exposes a public static method myFunction accepting two parameters, and returning a numeric type such as double.\n\nSELECT 3 * MyClass.myFunction(price, volume) as myValue FROM StockTick RETAIN 30 SECONDS\n\nUser-defined functions also take array parameters as this example shows.\n\nSELECT * FROM RFIDEvent RETAIN 10 MINUTES WHERE com.mycompany.rfid.MyChecker.isInZone(zone, {10, 20, 30})\n\nThe EPL processing model can be continuous: Listeners to statements receive updated data as soon as the engine processes events for that statement, according to the statement's choice of event streams, retain clause restrictions, filters and output rates.\n\nIn this section, we look at the output of a very simple EPL statement. The statement selects an event stream without using a data window and without applying any filtering, as follows:\n\nSELECT * FROM Withdrawal RETAIN ALL\n\nThis statement selects all Withdrawal events. Every time the engine processes an event of type Withdrawal or any sub-type of Withdrawal, it invokes all update listeners, handing the new event to each of the statement's listeners.\n\nThe term insert stream can denote the new events arriving, and entering a data window or aggregation. The insert stream in this example is the stream of arriving Withdrawal events, and is posted to update listeners as new events.\n\nFIG. 5 below shows a series of Withdrawal events 1 to 6 arriving over time. For this diagram as well as the others in this section, the number in parenthesis is the value of the amount property in the Withdrawal event.\n\nThe example statement above results in only new events and no old events posted by the engine to the statement's listeners since no RETAIN clause is specified.\n\nIn one embodiment, there can be two types of sliding windows: row-based and time-based. Each of these is discussed in the following sections.\n\nA row-based sliding window can instruct the engine to only keep the last N events for a stream. The next statement can apply a length window onto the Withdrawal event stream. The statement serves to illustrate the concept of data window and events entering and leaving a data window:\n\nSELECT * FROM Withdrawal RETAIN 5 EVENTS\n\nThe size of this statement's window is five events. The engine enters all arriving Withdrawal events into the window. When the window is full, the oldest Withdrawal event is pushed out the window. The engine indicates to update listeners all events entering the window as new events, and all events leaving the window as old events.\n\nWhile the term insert stream can denote new events arriving, the term remove stream can denote events leaving a data window, or changing aggregation values. In this example, the remove stream is the stream of Withdrawal events that leave the length window, and such events are posted to update listeners as old events.\n\nFIG. 6 illustrates how the length window contents change as events arrive and shows the events posted to an update listener.\n\nAs before, all arriving events are posted as new events to update listeners. In addition, when event W1 leaves the length window on arrival of event W6, it is posted as an old event to update listeners.\n\nSimilar to a length window, a time window also keeps the most recent events up to a given time period. A time window of 5 seconds, for example, keeps the last 5 seconds of events. As seconds pass, the time window actively pushes the oldest events out of the window resulting in one or more old events posted to update listeners.\n\nNote that EPL can support optional ISTREAM and RSTREAM keywords on SELECT clauses and on INSERT INTO clauses. These can instruct the engine to only forward events that enter or leave data windows, or select only current or prior aggregation values, i.e. the insert stream or the remove stream.\n\nA time-based sliding window can be a moving window extending to the specified time interval into the past based on the system time. Time-based sliding windows enable us to limit the number of events considered by a query, as do row-based sliding windows. FIG. 7 serves to illustrate the functioning of a time window. For the diagram, we assume a query that simply selects the event itself and does not group or filter events.\n\nSELECT * FROM Withdrawal RETAIN 4 SECONDS\n\nFIG. 7 starts at a given time t and displays the contents of the time window at t+4 and t+5 seconds and so on. The activity as illustrated by the FIG. 7:\n\n1. At time t+4 seconds an event W1 arrives and enters the time window. The engine reports the new event to update listeners.\n\n2. At time t+5 seconds an event W2 arrives and enters the time window. The engine reports the new event to update listeners.\n\n3. At time t+6.5 seconds an event W3 arrives and enters the time window. The engine reports the new event to update listeners.\n\n4. At time t+8 seconds event W1 leaves the time window. The engine reports the event as an old event to update listeners.\n\nAs a practical example, consider the need to determine all accounts where the average withdrawal amount per account for the last 4 seconds of withdrawals is greater then 1000. The statement to solve this problem is shown below.\n\nSELECT account, AVG(amount) FROM Withdrawal RETAIN 4 SECONDS GROUP BY account HAVING amount > 1000\n\nBoth row-based and time-based windows may be batched. The next sections explain each of these concepts in turn.\n\nThe time-based batch window can buffer events and releases them every specified time interval in one update. Time-based batch windows can control the evaluation of events, as does the length batch window.\n\nFIG. 8 serves to illustrate the functioning of a time batch view. For the diagram, we assume a simple query as below:\n\nSELECT * FROM Withdrawal RETAIN BATCH OF 4 SECONDS\n\nFIG. 8 starts at a given time t and displays the contents of the time window at t+4 and t+5 seconds and so on. The activity as illustrated by FIG. 8:\n\n1. At time t+1 seconds an event WI arrives and enters the batch. No call to inform update listeners occurs.\n\n2. At time t+3 seconds an event W2 arrives and enters the batch. No call to inform update listeners occurs.\n\n3. At time t+4 seconds the engine processes the batched events and a starts a new batch. The engine reports events W1 and W2 to update listeners.\n\n4. At time t+6.5 seconds an event W3 arrives and enters the batch. No call to inform update listeners occurs.\n\n5. At time t+8 seconds the engine processes the batched events and a starts a new batch. The engine reports the event W3 as new data to update listeners. The engine reports the events W1 and W2 as old data (prior batch) to update listeners.\n\nA row-based window may be batched as well. For example, the following query would wait to receive five events prior to doing any processing:\n\nSELECT * FROM Withdrawal RETAIN BATCH OF 5 EVENTS\n\nOnce five events were received, the query would run and again wait for a new set of five events prior to processing.\n\nFilters to event streams appear in a subquery expression and allow filtering events out of a given stream before events enter a data window. This filtering can occur prior to the WHERE clause executing. When possible, filtering should be done in a subquery as opposed to the WHERE clause, since this can improve performance by reducing the amount of data seen by the rest of the EPL statement.\n\nThe statement below, illustrated in FIG. 9, shows a subquery that selects Withdrawal events with an amount value of 200 or more.\n\nSELECT * FROM (SELECT * FROM Withdrawal WHERE amount >= 200) RETAIN 5 EVENTS\n\nWith the subquery, any Withdrawal events that have an amount of less then 200 do not enter the window of the outer query and are therefore not passed to update listeners.\n\nThe WHERE clause and HAVING clause in statements eliminate potential result rows at a later stage in processing, after events have been processed into a statement's data window or other views.\n\nThe next statement, illustrated in FIG. 10, applies a WHERE clause to Withdrawal events instead of a subquery.\n\nSELECT * FROM Withdrawal RETAIN 5 EVENTS WHERE amount>=200\n\nThe WHERE clause can apply to both new events and old events. As the diagram below shows, arriving events enter the window regardless of the value of the âamountâ property. However, only events that pass the WHERE clause are handed to update listeners. Also, as events leave the data window, only those events that pass the conditions in the WHERE clause are posted to update listeners as old events.\n\nStatements that aggregate events via aggregations functions also post remove stream events as aggregated values change. Consider the following statement that alerts when two Withdrawal events have been received:\n\nSELECT COUNT(*) AS mycount FROM Withdrawal RETAIN ALL HAVING COUNT(*) = 2\n\nWhen the engine encounters the second withdrawal event, the engine can post a new event to update listeners. The value of the mycount property on that new event is 2. Additionally, when the engine encounters the third Withdrawal event, it can post an old event to update listeners containing the prior value of the count. The value of the mycount property on that old event is also 2.\n\nThe ISTREAM or RSTREAM keyword can be used to eliminate either new events or old events posted to update listeners. The next statement uses the ISTREAM keyword causing the engine to call the update listener only once when the second Withdrawal event is received:\n\nSELECT ISTREAM COUNT(*) AS mycount FROM Withdrawal RETAIN ALL HAVING COUNT(*) = 2\n\nThe Java programmatic interface for the EPL can be rooted at the com.bea.wlrt.ede.Processor interface. This interface can provide methods to load, compile, start, stop, and retrieve EPL statements.\n\nEPL statements can be loaded and compiled individually through the following method:\n\nStatement compileQuery(String query);\n\nIf the query fails to compile, a StatementException can be thrown. Alternatively, multiple statements may be loaded from a URL using the following method:\n\nvoid loadQueries (URL location);\n\nIf the queries fail to compile, a MultiStatementException can be thrown. Note that individual queries compiled through the compileQuery need not persisted and have no effect on the rule files located at the URL location.\n\nThe com.bea.wlrt.ede.Statement interface can allow update listeners to be attached to an EPL statement using the following method:\n\nvoid addStreamingEventListener (StreamingEventListener listener);\n\nThe engine can call the following method on the com.bea.wlrt.ede.StreamingEventListener interface when events are added to the output window as a result of executing the statement:\n\nvoid onEvent (List newEvents);\n\nAlternatively, the occurrence of both added and removed events may be monitored by using the com.bea.wlrt.ede.RStreamingEventListener interface. In this case, the engine can invoke the following method when events are added to or removed from the output window as a result of executing the statement:\n\nvoid on REvent (List addedEvents, List removedEvents);\n\nThe rules file containing queries loaded through the Processor.loadQueries(URI) method can have the structure shown in the XML schema of FIG. 11.\n\nBelow is an example of a rules file with two EPL statements:\n\n<processor xmlns=âhttp://www.bea.com/wlrt/edeâ type=â wlevs:eplâ> <rules> <rule><![CDATA[ SELECT stockSymbol, price FROM StockTick RETAIN 2 events WHERE stockSymbol = âAAAâ AND price > 10.0 ]]></rule> <rule><![CDATA[ SELECT stockSymbol, price FROM StockTick RETAIN 2 events WHERE stockSymbol = âBBBâ AND price > 80.0 ]]></rule> </rules> </processor>\n\nThe use cases below illustrate through examples usage of various language features.\n\nFor the throughput statistics and to detect rapid fall-off we calculate a ticks per second rate for each market data feed.\n\nWe can use an EPL statement that batches together 1 second of events from the market data event stream source. We specify the feed and a count of events per feed as output values. To make this data available for further processing, we insert output events into the TicksPerSecond event stream:\n\nââINSERT INTO TicksPerSecond ââSELECT feed, COUNT(*) AS cnt FROM MarketDataEvent RETAIN BATCH OF 1 SECOND GROUP BY feed\n\nFor computing the highest priced stocks, we define a sliding window that retains 100 events for each unique stock symbol where the block size of the trade is greater than 10. For example, if there are 5,000 stock symbols, then 5,000Ã100 or 5,000,000 events would be kept. Only MarketTrade events with a block size of greater than 10 can enter the window and only the 100 highest priced events can be retained.\n\nThe results can be grouped by stock symbol and ordered alphabetically with stock symbols having an average price of less than 100 being filtered from the output.\n\nSELECT symbol, AVG(price) FROM (SELECT * FROM MarketTrade WHERE blockSize > 10) RETAIN 100 EVENTS PARTITION BY symbol WITH LARGEST price GROUP BY symbol HAVING AVG(price) >= 100 ORDER BY symbol\n\nWe detect the route a car is taking based on the car location event data that contains information about the location and direction of a car on a highway. We first segment the data by carId to isolate information about a particular car and subsequently segment by expressway, direction and segment to plot its direction. We are then able to calculate the speed of the car based on this information.\n\nThe first PARTITION BY carId groups car lo"
    }
}