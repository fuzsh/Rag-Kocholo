{
    "id": "correct_subsidiary_00134_0",
    "rank": 47,
    "data": {
        "url": "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/manual.html",
        "read_more_link": "",
        "language": "en",
        "title": "OpenJPA User's Guide",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-arch.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-exceptions.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/appid-hierarchy.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-meta-model.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/persistence.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/entitymanagerfactory.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/entitymanager.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-state-transitions.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-transaction.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-query.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/sqlquery-model.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-meta-model.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/mapping-tables.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-mapping-identity.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/inher-superclass-table.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-inher-joined.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/inher-tpc.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-inher-all.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-discrim-all.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-basic-field.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/secondary-table.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-embedded.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-direct-relation.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-assoc-table.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-map.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-meta-model.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/jpa-data-model.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/enhancement.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/joins-constant.png",
            "https://openjpa.apache.org/docs/openjpa-0.9.0-incubating/manual/img/inv-key-coll.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "2. Field and Property Metadata\n\nThe persistence implementation must be able to retrieve and set the persistent state of your entities, mapped superclasses, and embeddable types. JPA offers two modes of persistent state access: field access, and property access. Under field access, the implementation injects state directly into your persistent fields, and retrieves changed state from your fields as well. To declare field access on an entity with XML metadata, set the access attribute of your entity XML element to FIELD. To use field access for an entity using annotation metadata, simply place your metadata and mapping annotations on your field declarations:\n\n@ManyToOne private Company publisher;\n\nProperty access, on the other hand, retrieves and loads state through JavaBean \"getter\" and \"setter\" methods. For a property p of type T, you must define the following getter method:\n\nT getP();\n\nFor boolean properties, this is also acceptable:\n\nboolean isP();\n\nYou must also define the following setter method:\n\nvoid setP(T value);\n\nTo use property access, set your entity element's access attribute to PROPERTY, or place your metadata and mapping annotations on the getter method:\n\n@ManyToOne private Company getPublisher() { ... } private void setPublisher(Company publisher) { ... }\n\nWarning\n\nWhen using property access, only the getter and setter method for a property should ever access the underlying persistent field directly. Other methods, including internal business methods in the persistent class, should go through the getter and setter methods when manipulating persistent state.\n\nAlso, take care when adding business logic to your getter and setter methods. Consider that they are invoked by the persistence implementation to load and retrieve all persistent state; other side effects might not be desirable.\n\nEach class must use either field access or property access for all state; you cannot use both access types within the same class. Additionally, a subclass must use the same access type as its superclass.\n\nThe remainder of this document uses the term \"persistent field\" to refer to either a persistent field or a persistent property.\n\n2.1. Transient\n\nThe Transient annotation specifies that a field is non-persistent. Use it to exclude fields from management that would otherwise be persistent. Transient is a marker annotation only; it has no properties.\n\nThe equivalent XML element is transient. It has a single attribute:\n\nname: The transient field or property name. This attribute is required.\n\n2.2. Id\n\nAnnotate your simple identity fields with Id. This annotation has no properties. We explore entity identity and identity fields in Section 1.3, “ Identity Fields ”.\n\nThe equivalent XML element is id. It has one required attribute:\n\nname: The name of the identity field or property.\n\n2.3. Generated Value\n\nThe previous section showed you how to declare your identity fields with the Id annotation. It is often convenient to allow the persistence implementation to assign a unique value to your identity fields automatically. JPA includes the the GeneratedValue annotation for this purpose. It has the following properties:\n\nGenerationType strategy: Enum value specifying how to auto-generate the field value. The GenerationType enum has the following values:\n\nGeneratorType.AUTO: The default. Assign the field a generated value, leaving the details to the JPA vendor.\n\nGenerationType.IDENTITY: The database will assign an identity value on insert.\n\nGenerationType.SEQUENCE: Use a datastore sequence to generate a field value.\n\nGenerationType.TABLE: Use a sequence table to generate a field value.\n\nString generator: The name of a generator defined in mapping metadata. We show you how to define named generators in Section 5, “ Generators ”. If the GenerationType is set but this property is unset, the JPA implementation uses appropriate defaults for the selected generation type.\n\nThe equivalent XML element is generated-value, which includes the following attributes:\n\nstrategy: One of TABLE, SEQUENCE, IDENTITY, or AUTO, defaulting to AUTO.\n\ngenerator: Equivalent to the generator property listed above.\n\nNote\n\nOpenJPA allows you to use the GeneratedValue annotation on any field, not just identity fields. Before using the IDENTITY generation strategy, however, read Section 3.3, “ Autoassign / Identity Strategy Caveats ” in the Reference Guide.\n\nOpenJPA also offers two additional generator strategies for non-numeric fields, which you can access by setting strategy to AUTO (the default), and setting the generator string to:\n\nuuid-string: OpenJPA will generate a 128-bit UUID unique within the network, represented as a 16-character string. For more information on UUIDs, see the IETF UUID draft specification at: http://www1.ics.uci.edu/~ejw/authoring/uuid-guid/\n\nuuid-hex: Same as uuid-string, but represents the UUID as a 32-character hexadecimal string.\n\nThese string constants are defined in org.apache.openjpa.persistence.Generator.\n\n2.4. Embedded Id\n\nIf your entity has multiple identity values, you may declare multiple @Id fields, or you may declare a single @EmbeddedId field. The type of a field annotated with EmbeddedId must be an embeddable entity class. The fields of this embeddable class are considered the identity values of the owning entity. We explore entity identity and identity fields in Section 1.3, “ Identity Fields ”.\n\nThe EmbeddedId annotation has no properties.\n\nThe equivalent XML element is embedded-id. It has one required attribute:\n\nname: The name of the identity field or property.\n\n2.5. Version\n\nUse the Version annotation to designate a version field. Section 1.4, “ Version Field ” explained the importance of version fields to JPA. This is a marker annotation; it has no properties.\n\nThe equivalent XML element is version, which has a single attribute:\n\nname: The name of the version field or property. This attribute is required.\n\n2.6. Basic\n\nBasic signifies a standard value persisted as-is to the datastore. You can use the Basic annotation on persistent fields of the following types: primitives, primitive wrappers, java.lang.String, byte[], Byte[], char[], Character[], java.math.BigDecimal, java.math.BigInteger, java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Timestamp, Enums, and Serializable types.\n\nBasic declares these properties:\n\nFetchType fetch: Whether to load the field eagerly (FetchType.EAGER) or lazily ( FetchType.LAZY). Defaults to FetchType.EAGER.\n\nboolean optional: Whether the datastore allows null values. Defaults to true.\n\nThe equivalent XML element is basic. It has the following attributes:\n\nname: The name of the field or property. This attribute is required.\n\nfetch: One of EAGER or LAZY .\n\noptional: Boolean indicating whether the field value may be null.\n\n2.6.1. Fetch Type\n\nMany metadata annotations in JPA have a fetch property. This property can take on one of two values: FetchType.EAGER or FetchType.LAZY. FetchType.EAGER means that the field is loaded by the JPA implementation before it returns the persistent object to you. Whenever you retrieve an entity from a query or from the EntityManager, you are guaranteed that all of its eager fields are populated with datastore data.\n\nFetchType.LAZY is a hint to the JPA runtime that you want to defer loading of the field until you access it. This is called lazy loading. Lazy loading is completely transparent; when you attempt to read the field for the first time, the JPA runtime will load the value from the datastore and populate the field automatically. Lazy loading is only a hint and not a directive because some JPA implementations cannot lazy-load certain field types.\n\nWith a mix of eager and lazily-loaded fields, you can ensure that commonly-used fields load efficiently, and that other state loads transparently when accessed. As you will see in Section 3, “ Persistence Context ”, you can also use eager fetching to ensure that entites have all needed data loaded before they become detached at the end of a persistence context.\n\nNote\n\nOpenJPA can lazy-load any field type. OpenJPA also allows you to dynamically change which fields are eagerly or lazily loaded at runtime. See Section 6, “ Fetch Groups ” in the Reference Guide for details.\n\nThe Reference Guide details OpenJPA's eager fetching behavior in Section 7, “ Eager Fetching ”.\n\n2.7. Embedded\n\nUse the Embedded marker annotation on embeddable field types. Embedded fields are mapped as part of the datastore record of the declaring entity. In our sample model, Author and Company each embed their Address, rather than forming a relation to an Address as a separate entity.\n\nThe equivalent XML element is embedded, which expects a single attribute:\n\nname: The name of the field or property. This attribute is required.\n\n2.8. Many To One\n\nWhen an entity A references a single entity B, and other As might also reference the same B, we say there is a many to one relation from A to B. In our sample model, for example, each magazine has a reference to its publisher. Multiple magazines might have the same publisher. We say, then, that the Magazine.publisher field is a many to one relation from magazines to publishers.\n\nJPA indicates many to one relations between entities with the ManyToOne annotation. This annotation has the following properties:\n\nClass targetEntity: The class of the related entity type.\n\nCascadeType[] cascade: Array of enum values defining cascade behavior for this field. We explore cascades below. Defaults to an empty array.\n\nFetchType fetch: Whether to load the field eagerly (FetchType.EAGER) or lazily (FetchType.LAZY). Defaults to FetchType.EAGER. See Section 2.6.1, “ Fetch Type ” above for details on fetch types.\n\nboolean optional: Whether the related object must exist. If false, this field cannot be null. Defaults to true.\n\nThe equivalent XML element is many-to-one. It accepts the following attributes:\n\nname: The name of the field or property. This attribute is required.\n\ntarget-entity: The class of the related type.\n\nfetch: One of EAGER or LAZY.\n\noptional: Boolean indicating whether the field value may be null.\n\n2.8.1. Cascade Type\n\nWe introduce the JPA EntityManager in Chapter 8, EntityManager . The EntityManager has APIs to persist new entities, remove (delete) existing entities, refresh entity state from the datastore, and merge detached entity state back into the persistence context. We explore all of these APIs in detail later in the overview.\n\nWhen the EntityManager is performing the above operations, you can instruct it to automatically cascade the operation to the entities held in a persistent field with the cascade property of your metadata annotation. This process is recursive. The cascade property accepts an array of CascadeType enum values.\n\nCascadeType.PERSIST: When persisting an entity, also persist the entities held in this field. We suggest liberal application of this cascade rule, because if the EntityManager finds a field that references a new entity during flush, and the field does not use CascadeType.PERSIST, it is an error.\n\nCascadeType.REMOVE: When deleting an entity, also delete the entities held in this field.\n\nCascadeType.REFRESH: When refreshing an entity, also refresh the entities held in this field.\n\nCascadeType.MERGE: When merging entity state, also merge the entities held in this field.\n\nCascadeType defines one additional value, CascadeType.ALL, that acts as a shortcut for all of the values above. The following annotations are equivalent:\n\n@ManyToOne(cascade={CascadeType.PERSIST,CascadeType.REMOVE, CascadeType.REFRESH,CascadeType.MERGE}) private Company publisher;\n\n@ManyToOne(cascade=CascadeType.ALL) private Company publisher;\n\nIn XML, these enumeration constants are available as child elements of the cascade element. The cascade element is itself a child of many-to-one. The following examples are equivalent:\n\n<many-to-one name=\"publisher\"> <cascade> <cascade-persist/> <cascade-merge/> <cascade-remove/> <cascade-refresh/> </cascade> </many-to-one>\n\n<many-to-one name=\"publisher\"> <cascade> <cascade-all/> </cascade> </many-to-one>\n\n2.9. One To Many\n\nWhen an entity A references multiple B entities, and no two As reference the same B, we say there is a one to many relation from A to B.\n\nOne to many relations are the exact inverse of the many to one relations we detailed in the preceding section. In that section, we said that the Magazine.publisher field is a many to one relation from magazines to publishers. Now, we see that the Company.mags field is the inverse - a one to many relation from publishers to magazines. Each company may publish multiple magazines, but each magazine can have only one publisher.\n\nJPA indicates one to many relations between entities with the OneToMany annotation. This annotation has the following properties:\n\nClass targetEntity: The class of the related entity type. This information is usually taken from the parameterized collection or map element type. You must supply it explicitly, however, if your field isn't a parameterized type.\n\nString mappedBy: Names the many to one field in the related entity that maps this bidirectional relation. We explain bidirectional relations below. Leaving this property unset signals that this is a standard unidirectional relation.\n\nCascadeType[] cascade: Array of enum values defining cascade behavior for the collection elements. We explore cascades above in Section 2.8.1, “ Cascade Type ”. Defaults to an empty array.\n\nFetchType fetch: Whether to load the field eagerly (FetchType.EAGER) or lazily (FetchType.LAZY). Defaults to FetchType.LAZY. See Section 2.6.1, “ Fetch Type ” above for details on fetch types.\n\nThe equivalent XML element is one-to-many, which includes the following attributes:\n\nname: The name of the field or property. This attribute is required.\n\ntarget-entity: The class of the related type.\n\nfetch: One of EAGER or LAZY.\n\nmapped-by: The name of the field or property that owns the relation. See Section 2, “ Field and Property Metadata ”.\n\nYou may also nest the cascade element within a one-to-many element.\n\n2.9.1. Bidirectional Relations\n\nWhen two fields are logical inverses of each other, they form a bidirectional relation. Our model contains two bidirectional relations: Magazine.publisher and Company.mags form one bidirectional relation, and Article.authors and Author.articles form the other. In both cases, there is a clear link between the two fields that form the relationship. A magazine refers to its publisher while the publisher refers to all its published magazines. An article refers to its authors while each author refers to her written articles.\n\nWhen the two fields of a bidirectional relation share the same datastore mapping, JPA formalizes the connection with the mappedBy property. Marking Company.mags as mappedBy Magazine.publisher means two things:\n\nCompany.mags uses the datastore mapping for Magazine.publisher, but inverses it. In fact, it is illegal to specify any additional mapping information when you use the mappedBy property. All mapping information is read from the referenced field. We explore mapping in depth in Chapter 12, Mapping Metadata .\n\nMagazine.publisher is the \"owner\" of the relation. The field that specifies the mapping data is always the owner. This means that changes to the Magazine.publisher field are reflected in the datastore, while changes to the Company.mags field alone are not. Changes to Company.mags may still affect the JPA implementation's cache, however. Thus, it is very important that you keep your object model consistent by properly maintaining both sides of your bidirectional relations at all times.\n\nYou should always take advantage of the mappedBy property rather than mapping each field of a bidirectional relation independently. Failing to do so may result in the JPA implementation trying to update the database with conflicting data. Be careful to only mark one side of the relation as mappedBy, however. One side has to actually do the mapping!\n\nNote\n\nYou can configure OpenJPA to automatically synchronize both sides of a bidirectional relation, or to perform various actions when it detects inconsistent relations. See Section 4, “ Managed Inverses ” in the Reference Guide for details.\n\n2.10. One To One\n\nWhen an entity A references a single entity B, and no other As can reference the same B, we say there is a one to one relation between A and B. In our sample model, Magazine has a one to one relation to Article through the Magazine.coverArticle field. No two magazines can have the same cover article.\n\nJPA indicates one to one relations between entities with the OneToOne annotation. This annotation has the following properties:\n\nClass targetEntity: The class of the related entity type. This information is usually taken from the field type.\n\nString mappedBy: Names the field in the related entity that maps this bidirectional relation. We explain bidirectional relations in Section 2.9.1, “ Bidirectional Relations ” above. Leaving this property unset signals that this is a standard unidirectional relation.\n\nCascadeType[] cascade: Array of enum values defining cascade behavior for this field. We explore cascades in Section 2.8.1, “ Cascade Type ” above. Defaults to an empty array.\n\nFetchType fetch: Whether to load the field eagerly (FetchType.EAGER) or lazily (FetchType.LAZY). Defaults to FetchType.EAGER. See Section 2.6.1, “ Fetch Type ” above for details on fetch types.\n\nboolean optional: Whether the related object must exist. If false, this field cannot be null. Defaults to true.\n\nThe equivalent XML element is one-to-one which understands the following attributes:\n\nname: The name of the field or property. This attribute is required.\n\ntarget-entity: The class of the related type.\n\nfetch: One of EAGER or LAZY.\n\nmapped-by: The field that owns the relation. See Section 2, “ Field and Property Metadata ”.\n\nYou may also nest the cascade element within a one-to-one element.\n\n2.11. Many To Many\n\nWhen an entity A references multiple B entities, and other As might reference some of the same Bs, we say there is a many to many relation between A and B. In our sample model, for example, each article has a reference to all the authors that contributed to the article. Other articles might have some of the same authors. We say, then, that Article and Author have a many to many relation through the Article.authors field.\n\nJPA indicates many to many relations between entities with the ManyToMany annotation. This annotation has the following properties:\n\nClass targetEntity: The class of the related entity type. This information is usually taken from the parameterized collection or map element type. You must supply it explicitly, however, if your field isn't a parameterized type.\n\nString mappedBy: Names the many to many field in the related entity that maps this bidirectional relation. We explain bidirectional relations in Section 2.9.1, “ Bidirectional Relations ” above. Leaving this property unset signals that this is a standard unidirectional relation.\n\nCascadeType[] cascade: Array of enum values defining cascade behavior for the collection elements. We explore cascades above in Section 2.8.1, “ Cascade Type ”. Defaults to an empty array.\n\nFetchType fetch: Whether to load the field eagerly (FetchType.EAGER) or lazily (FetchType.LAZY). Defaults to FetchType.LAZY. See Section 2.6.1, “ Fetch Type ” above for details on fetch types.\n\nThe equivalent XML element is many-to-many. It accepts the following attributes:\n\nname: The name of the field or property. This attribute is required.\n\ntarget-entity: The class of the related type.\n\nfetch: One of EAGER or LAZY.\n\nmapped-by: The field that owns the relation. See Section 2, “ Field and Property Metadata ”.\n\nYou may also nest the cascade element within a many-to-many element.\n\n2.12. Order By\n\nDatastores such as relational databases do not preserve the order of records. Your persistent List fields might be ordered one way the first time you retrieve an object from the datastore, and a completely different way the next. To ensure consistent ordering of collection fields, you must use the OrderBy annotation. The OrderBy annotation's value is a string defining the order of the collection elements. An empty value means to sort on the identity value(s) of the elements in ascending order. Any other value must be of the form:\n\n<field name>[ ASC|DESC][, ...]\n\nEach <field name> is the name of a persistent field in the collection's element type. You can optionally follow each field by the keyword ASC for ascending order, or DESC for descending order. If the direction is omitted, it defaults to ascending.\n\nThe equivalent XML element is order-by which can be listed as a sub-element of the one-to-many or many-to-many elements. The text within this element is parsed as the order by string.\n\nNote\n\nOpenJPA expands the available ordering syntax. See ??? in the Reference Guide for details.\n\n2.13. Map Key\n\nJPA supports persistent Map fields through either a OneToMany or ManyToMany association. The related entities form the map values. JPA derives the map keys by extracting a field from each entity value. The MapKey annotation designates the field that is used as the key. It has the following properties:\n\nString name: The name of a field in the related entity class to use as the map key. If no name is given, defaults to the identity field of the related entity class.\n\nThe equivalent XML element is map-key which can be listed as a sub-element of the one-to-many or many-to-many elements. The map-key element has the following attributes:\n\nname: The name of the field in the related entity class to use as the map key.\n\n2.14. Persistent Field Defaults\n\nIn the absence of any of the annotations above, JPA defines the following default behavior for declared fields:\n\nFields declared static, transient, or final default to non-persistent.\n\nFields of any primitive type, primitive wrapper type, java.lang.String, byte[], Byte[], char[], Character[], java.math.BigDecimal, java.math.BigInteger, java.util.Date, java.util.Calendar, java.sql.Date, java.sql.Timestamp, or any Serializable type default to persistent, as if annotated with @Basic.\n\nFields of an embeddable type default to persistent, as if annotated with @Embedded.\n\nAll other fields default to non-persistent.\n\nNote that according to these defaults, all relations between entities must be annotated explicitly. Without an annotation, a relation field will default to serialized storage if the related entity type is serializable, or will default to being non-persistent if not.\n\n3. XML Schema\n\nWe present the complete XML schema below. Many of the elements relate to object/relational mapping rather than metadata; these elements are discussed in Chapter 12, Mapping Metadata .\n\n<?xml version=\"1.0\" encoding=\"UTF-8\"?> <xsd:schema targetNamespace=\"http://java.sun.com/xml/ns/persistence/orm\" xmlns:orm=\"http://java.sun.com/xml/ns/persistence/orm\" xmlns:xsd=\"http://www.w3.org/2001/XMLSchema\" elementFormDefault=\"qualified\" attributeFormDefault=\"unqualified\" version=\"1.0\"> <xsd:annotation> <xsd:documentation> @(#)orm_1_0.xsd 1.0 Feb 14 2006 </xsd:documentation> </xsd:annotation> <xsd:annotation> <xsd:documentation> This is the XML Schema for the persistence object-relational mapping file. The file may be named \"META-INF/orm.xml\" in the persistence archive or it may be named some other name which would be used to locate the file as resource on the classpath. </xsd:documentation> </xsd:annotation> <xsd:complexType name=\"emptyType\"/> <xsd:simpleType name=\"versionType\"> <xsd:restriction base=\"xsd:token\"> <xsd:pattern value=\"[0-9]+(\\.[0-9]+)*\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:element name=\"entity-mappings\"> <xsd:complexType> <xsd:annotation> <xsd:documentation> The entity-mappings element is the root element of an mapping file. It contains the following four types of elements: 1. The persistence-unit-metadata element contains metadata for the entire persistence unit. It is undefined if this element occurs in multiple mapping files within the same persistence unit. 2. The package, schema, catalog and access elements apply to all of the entity, mapped-superclass and embeddable elements defined in the same file in which they occur. 3. The sequence-generator, table-generator, named-query, named-native-query and sql-result-set-mapping elements are global to the persistence unit. It is undefined to have more than one sequence-generator or table-generator of the same name in the same or different mapping files in a persistence unit. It is also undefined to have more than one named-query or named-native-query of the same name in the same or different mapping files in a persistence unit. 4. The entity, mapped-superclass and embeddable elements each define the mapping information for a managed persistent class. The mapping information contained in these elements may be complete or it may be partial. </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"persistence-unit-metadata\" type=\"orm:persistence-unit-metadata\" minOccurs=\"0\"/> <xsd:element name=\"package\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"schema\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"catalog\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"access\" type=\"orm:access-type\" minOccurs=\"0\"/> <xsd:element name=\"sequence-generator\" type=\"orm:sequence-generator\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"table-generator\" type=\"orm:table-generator\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"named-query\" type=\"orm:named-query\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"named-native-query\" type=\"orm:named-native-query\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"sql-result-set-mapping\" type=\"orm:sql-result-set-mapping\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"mapped-superclass\" type=\"orm:mapped-superclass\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"entity\" type=\"orm:entity\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"embeddable\" type=\"orm:embeddable\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"version\" type=\"orm:versionType\" fixed=\"1.0\" use=\"required\"/> </xsd:complexType> </xsd:element> <!-- **************************************************** --> <xsd:complexType name=\"persistence-unit-metadata\"> <xsd:annotation> <xsd:documentation> Metadata that applies to the persistence unit and not just to the mapping file in which it is contained. If the xml-mapping-metadata-complete element is specified then the complete set of mapping metadata for the persistence unit is contained in the XML mapping files for the persistence unit. </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"xml-mapping-metadata-complete\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"persistence-unit-defaults\" type=\"orm:persistence-unit-defaults\" minOccurs=\"0\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"persistence-unit-defaults\"> <xsd:annotation> <xsd:documentation> These defaults are applied to the persistence unit as a whole unless they are overridden by local annotation or XML element settings. schema - Used as the schema for all tables or secondary tables that apply to the persistence unit catalog - Used as the catalog for all tables or secondary tables that apply to the persistence unit access - Used as the access type for all managed classes in the persistence unit cascade-persist - Adds cascade-persist to the set of cascade options in entity relationships of the persistence unit entity-listeners - List of default entity listeners to be invoked on each entity in the persistence unit. </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"schema\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"catalog\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"access\" type=\"orm:access-type\" minOccurs=\"0\"/> <xsd:element name=\"cascade-persist\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"entity-listeners\" type=\"orm:entity-listeners\" minOccurs=\"0\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"entity\"> <xsd:annotation> <xsd:documentation> Defines the settings and mappings for an entity. Is allowed to be sparsely populated and used in conjunction with the annotations. Alternatively, the metadata-complete attribute can be used to indicate that no annotations on the entity class (and its fields or properties) are to be processed. If this is the case then the defaulting rules for the entity and its subelements will be recursively applied. @Target(TYPE) @Retention(RUNTIME) public @interface Entity { String name() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"table\" type=\"orm:table\" minOccurs=\"0\"/> <xsd:element name=\"secondary-table\" type=\"orm:secondary-table\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"primary-key-join-column\" type=\"orm:primary-key-join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"id-class\" type=\"orm:id-class\" minOccurs=\"0\"/> <xsd:element name=\"inheritance\" type=\"orm:inheritance\" minOccurs=\"0\"/> <xsd:element name=\"discriminator-value\" type=\"orm:discriminator-value\" minOccurs=\"0\"/> <xsd:element name=\"discriminator-column\" type=\"orm:discriminator-column\" minOccurs=\"0\"/> <xsd:element name=\"sequence-generator\" type=\"orm:sequence-generator\" minOccurs=\"0\"/> <xsd:element name=\"table-generator\" type=\"orm:table-generator\" minOccurs=\"0\"/> <xsd:element name=\"named-query\" type=\"orm:named-query\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"named-native-query\" type=\"orm:named-native-query\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"sql-result-set-mapping\" type=\"orm:sql-result-set-mapping\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"exclude-default-listeners\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"exclude-superclass-listeners\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"entity-listeners\" type=\"orm:entity-listeners\" minOccurs=\"0\"/> <xsd:element name=\"pre-persist\" type=\"orm:pre-persist\" minOccurs=\"0\"/> <xsd:element name=\"post-persist\" type=\"orm:post-persist\" minOccurs=\"0\"/> <xsd:element name=\"pre-remove\" type=\"orm:pre-remove\" minOccurs=\"0\"/> <xsd:element name=\"post-remove\" type=\"orm:post-remove\" minOccurs=\"0\"/> <xsd:element name=\"pre-update\" type=\"orm:pre-update\" minOccurs=\"0\"/> <xsd:element name=\"post-update\" type=\"orm:post-update\" minOccurs=\"0\"/> <xsd:element name=\"post-load\" type=\"orm:post-load\" minOccurs=\"0\"/> <xsd:element name=\"attribute-override\" type=\"orm:attribute-override\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"association-override\" type=\"orm:association-override\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"attributes\" type=\"orm:attributes\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"access\" type=\"orm:access-type\"/> <xsd:attribute name=\"metadata-complete\" type=\"xsd:boolean\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"attributes\"> <xsd:annotation> <xsd:documentation> This element contains the entity field or property mappings. It may be sparsely populated to include only a subset of the fields or properties. If metadata-complete for the entity is true then the remainder of the attributes will be defaulted according to the default rules. </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:choice> <xsd:element name=\"id\" type=\"orm:id\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"embedded-id\" type=\"orm:embedded-id\" minOccurs=\"0\"/> </xsd:choice> <xsd:element name=\"basic\" type=\"orm:basic\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"version\" type=\"orm:version\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"many-to-one\" type=\"orm:many-to-one\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"one-to-many\" type=\"orm:one-to-many\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"one-to-one\" type=\"orm:one-to-one\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"many-to-many\" type=\"orm:many-to-many\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"embedded\" type=\"orm:embedded\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"transient\" type=\"orm:transient\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:simpleType name=\"access-type\"> <xsd:annotation> <xsd:documentation> This element determines how the persistence provider accesses the state of an entity or embedded object. </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"PROPERTY\"/> <xsd:enumeration value=\"FIELD\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:complexType name=\"entity-listeners\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface EntityListeners { Class[] value(); } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"entity-listener\" type=\"orm:entity-listener\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"entity-listener\"> <xsd:annotation> <xsd:documentation> Defines an entity listener to be invoked at lifecycle events for the entities that list this listener. </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"pre-persist\" type=\"orm:pre-persist\" minOccurs=\"0\"/> <xsd:element name=\"post-persist\" type=\"orm:post-persist\" minOccurs=\"0\"/> <xsd:element name=\"pre-remove\" type=\"orm:pre-remove\" minOccurs=\"0\"/> <xsd:element name=\"post-remove\" type=\"orm:post-remove\" minOccurs=\"0\"/> <xsd:element name=\"pre-update\" type=\"orm:pre-update\" minOccurs=\"0\"/> <xsd:element name=\"post-update\" type=\"orm:post-update\" minOccurs=\"0\"/> <xsd:element name=\"post-load\" type=\"orm:post-load\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"pre-persist\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PrePersist {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"post-persist\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PostPersist {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"pre-remove\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PreRemove {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"post-remove\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PostRemove {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"pre-update\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PreUpdate {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"post-update\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PostUpdate {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"post-load\"> <xsd:annotation> <xsd:documentation> @Target({METHOD}) @Retention(RUNTIME) public @interface PostLoad {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"method-name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"query-hint\"> <xsd:annotation> <xsd:documentation> @Target({}) @Retention(RUNTIME) public @interface QueryHint { String name(); String value(); } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"value\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"named-query\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface NamedQuery { String name(); String query(); QueryHint[] hints() default {}; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"query\" type=\"xsd:string\"/> <xsd:element name=\"hint\" type=\"orm:query-hint\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"named-native-query\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface NamedNativeQuery { String name(); String query(); QueryHint[] hints() default {}; Class resultClass() default void.class; String resultSetMapping() default \"\"; //named SqlResultSetMapping } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"query\" type=\"xsd:string\"/> <xsd:element name=\"hint\" type=\"orm:query-hint\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"result-class\" type=\"xsd:string\"/> <xsd:attribute name=\"result-set-mapping\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"sql-result-set-mapping\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface SqlResultSetMapping { String name(); EntityResult[] entities() default {}; ColumnResult[] columns() default {}; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"entity-result\" type=\"orm:entity-result\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"column-result\" type=\"orm:column-result\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"entity-result\"> <xsd:annotation> <xsd:documentation> @Target({}) @Retention(RUNTIME) public @interface EntityResult { Class entityClass(); FieldResult[] fields() default {}; String discriminatorColumn() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"field-result\" type=\"orm:field-result\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"entity-class\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"discriminator-column\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"field-result\"> <xsd:annotation> <xsd:documentation> @Target({}) @Retention(RUNTIME) public @interface FieldResult { String name(); String column(); } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"column\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"column-result\"> <xsd:annotation> <xsd:documentation> @Target({}) @Retention(RUNTIME) public @interface ColumnResult { String name(); } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"table\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface Table { String name() default \"\"; String catalog() default \"\"; String schema() default \"\"; UniqueConstraint[] uniqueConstraints() default {}; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"catalog\" type=\"xsd:string\"/> <xsd:attribute name=\"schema\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"secondary-table\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface SecondaryTable { String name(); String catalog() default \"\"; String schema() default \"\"; PrimaryKeyJoinColumn[] pkJoinColumns() default {}; UniqueConstraint[] uniqueConstraints() default {}; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"primary-key-join-column\" type=\"orm:primary-key-join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"catalog\" type=\"xsd:string\"/> <xsd:attribute name=\"schema\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"unique-constraint\"> <xsd:annotation> <xsd:documentation> @Target({}) @Retention(RUNTIME) public @interface UniqueConstraint { String[] columnNames(); } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"column-name\" type=\"xsd:string\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"column\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Column { String name() default \"\"; boolean unique() default false; boolean nullable() default true; boolean insertable() default true; boolean updatable() default true; String columnDefinition() default \"\"; String table() default \"\"; int length() default 255; int precision() default 0; // decimal precision int scale() default 0; // decimal scale } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"unique\" type=\"xsd:boolean\"/> <xsd:attribute name=\"nullable\" type=\"xsd:boolean\"/> <xsd:attribute name=\"insertable\" type=\"xsd:boolean\"/> <xsd:attribute name=\"updatable\" type=\"xsd:boolean\"/> <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/> <xsd:attribute name=\"table\" type=\"xsd:string\"/> <xsd:attribute name=\"length\" type=\"xsd:int\"/> <xsd:attribute name=\"precision\" type=\"xsd:int\"/> <xsd:attribute name=\"scale\" type=\"xsd:int\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"join-column\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface JoinColumn { String name() default \"\"; String referencedColumnName() default \"\"; boolean unique() default false; boolean nullable() default true; boolean insertable() default true; boolean updatable() default true; String columnDefinition() default \"\"; String table() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"referenced-column-name\" type=\"xsd:string\"/> <xsd:attribute name=\"unique\" type=\"xsd:boolean\"/> <xsd:attribute name=\"nullable\" type=\"xsd:boolean\"/> <xsd:attribute name=\"insertable\" type=\"xsd:boolean\"/> <xsd:attribute name=\"updatable\" type=\"xsd:boolean\"/> <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/> <xsd:attribute name=\"table\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:simpleType name=\"generation-type\"> <xsd:annotation> <xsd:documentation> public enum GenerationType { TABLE, SEQUENCE, IDENTITY, AUTO }; </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"TABLE\"/> <xsd:enumeration value=\"SEQUENCE\"/> <xsd:enumeration value=\"IDENTITY\"/> <xsd:enumeration value=\"AUTO\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:complexType name=\"attribute-override\"> <xsd:annotation> <xsd:documentation> @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface AttributeOverride { String name(); Column column(); } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"column\" type=\"orm:column\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"association-override\"> <xsd:annotation> <xsd:documentation> @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface AssociationOverride { String name(); JoinColumn[] joinColumns(); } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"join-column\" type=\"orm:join-column\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"id-class\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface IdClass { Class value(); } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"id\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Id {} </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"column\" type=\"orm:column\" minOccurs=\"0\"/> <xsd:element name=\"generated-value\" type=\"orm:generated-value\" minOccurs=\"0\"/> <xsd:element name=\"temporal\" type=\"orm:temporal\" minOccurs=\"0\"/> <xsd:element name=\"table-generator\" type=\"orm:table-generator\" minOccurs=\"0\"/> <xsd:element name=\"sequence-generator\" type=\"orm:sequence-generator\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"embedded-id\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface EmbeddedId {} </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"attribute-override\" type=\"orm:attribute-override\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"transient\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Transient {} </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"version\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Version {} </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"column\" type=\"orm:column\" minOccurs=\"0\"/> <xsd:element name=\"temporal\" type=\"orm:temporal\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"basic\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Basic { FetchType fetch() default EAGER; boolean optional() default true; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"column\" type=\"orm:column\" minOccurs=\"0\"/> <xsd:choice> <xsd:element name=\"lob\" type=\"orm:lob\" minOccurs=\"0\"/> <xsd:element name=\"temporal\" type=\"orm:temporal\" minOccurs=\"0\"/> <xsd:element name=\"enumerated\" type=\"orm:enumerated\" minOccurs=\"0\"/> </xsd:choice> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/> <xsd:attribute name=\"optional\" type=\"xsd:boolean\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:simpleType name=\"fetch-type\"> <xsd:annotation> <xsd:documentation> public enum FetchType { LAZY, EAGER }; </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"LAZY\"/> <xsd:enumeration value=\"EAGER\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:complexType name=\"lob\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Lob {} </xsd:documentation> </xsd:annotation> </xsd:complexType> <!-- **************************************************** --> <xsd:simpleType name=\"temporal\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Temporal { TemporalType value(); } </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"orm:temporal-type\"/> </xsd:simpleType> <!-- **************************************************** --> <xsd:simpleType name=\"temporal-type\"> <xsd:annotation> <xsd:documentation> public enum TemporalType { DATE, // java.sql.Date TIME, // java.sql.Time TIMESTAMP // java.sql.Timestamp } </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"DATE\"/> <xsd:enumeration value=\"TIME\"/> <xsd:enumeration value=\"TIMESTAMP\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:simpleType name=\"enumerated\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Enumerated { EnumType value() default ORDINAL; } </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"orm:enum-type\"/> </xsd:simpleType> <!-- **************************************************** --> <xsd:simpleType name=\"enum-type\"> <xsd:annotation> <xsd:documentation> public enum EnumType { ORDINAL, STRING } </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"ORDINAL\"/> <xsd:enumeration value=\"STRING\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:complexType name=\"many-to-one\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface ManyToOne { Class targetEntity() default void.class; CascadeType[] cascade() default {}; FetchType fetch() default EAGER; boolean optional() default true; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:choice> <xsd:element name=\"join-column\" type=\"orm:join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"join-table\" type=\"orm:join-table\" minOccurs=\"0\"/> </xsd:choice> <xsd:element name=\"cascade\" type=\"orm:cascade-type\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/> <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/> <xsd:attribute name=\"optional\" type=\"xsd:boolean\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"cascade-type\"> <xsd:annotation> <xsd:documentation> public enum CascadeType { ALL, PERSIST, MERGE, REMOVE, REFRESH}; </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"cascade-all\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"cascade-persist\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"cascade-merge\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"cascade-remove\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"cascade-refresh\" type=\"orm:emptyType\" minOccurs=\"0\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"one-to-one\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface OneToOne { Class targetEntity() default void.class; CascadeType[] cascade() default {}; FetchType fetch() default EAGER; boolean optional() default true; String mappedBy() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:choice> <xsd:element name=\"primary-key-join-column\" type=\"orm:primary-key-join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"join-column\" type=\"orm:join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"join-table\" type=\"orm:join-table\" minOccurs=\"0\"/> </xsd:choice> <xsd:element name=\"cascade\" type=\"orm:cascade-type\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/> <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/> <xsd:attribute name=\"optional\" type=\"xsd:boolean\"/> <xsd:attribute name=\"mapped-by\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"one-to-many\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface OneToMany { Class targetEntity() default void.class; CascadeType[] cascade() default {}; FetchType fetch() default LAZY; String mappedBy() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"order-by\" type=\"orm:order-by\" minOccurs=\"0\"/> <xsd:element name=\"map-key\" type=\"orm:map-key\" minOccurs=\"0\"/> <xsd:choice> <xsd:element name=\"join-table\" type=\"orm:join-table\" minOccurs=\"0\"/> <xsd:element name=\"join-column\" type=\"orm:join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:choice> <xsd:element name=\"cascade\" type=\"orm:cascade-type\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/> <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/> <xsd:attribute name=\"mapped-by\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"join-table\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface JoinTable { String name() default \"\"; String catalog() default \"\"; String schema() default \"\"; JoinColumn[] joinColumns() default {}; JoinColumn[] inverseJoinColumns() default {}; UniqueConstraint[] uniqueConstraints() default {}; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"join-column\" type=\"orm:join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"inverse-join-column\" type=\"orm:join-column\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"catalog\" type=\"xsd:string\"/> <xsd:attribute name=\"schema\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"many-to-many\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface ManyToMany { Class targetEntity() default void.class; CascadeType[] cascade() default {}; FetchType fetch() default LAZY; String mappedBy() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"order-by\" type=\"orm:order-by\" minOccurs=\"0\"/> <xsd:element name=\"map-key\" type=\"orm:map-key\" minOccurs=\"0\"/> <xsd:element name=\"join-table\" type=\"orm:join-table\" minOccurs=\"0\"/> <xsd:element name=\"cascade\" type=\"orm:cascade-type\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"target-entity\" type=\"xsd:string\"/> <xsd:attribute name=\"fetch\" type=\"orm:fetch-type\"/> <xsd:attribute name=\"mapped-by\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"generated-value\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface GeneratedValue { GenerationType strategy() default AUTO; String generator() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"strategy\" type=\"orm:generation-type\"/> <xsd:attribute name=\"generator\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"map-key\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface MapKey { String name() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:simpleType name=\"order-by\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface OrderBy { String value() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:string\"/> </xsd:simpleType> <!-- **************************************************** --> <xsd:complexType name=\"inheritance\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface Inheritance { InheritanceType strategy() default SINGLE_TABLE; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"strategy\" type=\"orm:inheritance-type\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:simpleType name=\"inheritance-type\"> <xsd:annotation> <xsd:documentation> public enum InheritanceType { SINGLE_TABLE, JOINED, TABLE_PER_CLASS}; </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"SINGLE_TABLE\"/> <xsd:enumeration value=\"JOINED\"/> <xsd:enumeration value=\"TABLE_PER_CLASS\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:simpleType name=\"discriminator-value\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface DiscriminatorValue { String value(); } </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:string\"/> </xsd:simpleType> <!-- **************************************************** --> <xsd:simpleType name=\"discriminator-type\"> <xsd:annotation> <xsd:documentation> public enum DiscriminatorType { STRING, CHAR, INTEGER }; </xsd:documentation> </xsd:annotation> <xsd:restriction base=\"xsd:token\"> <xsd:enumeration value=\"STRING\"/> <xsd:enumeration value=\"CHAR\"/> <xsd:enumeration value=\"INTEGER\"/> </xsd:restriction> </xsd:simpleType> <!-- **************************************************** --> <xsd:complexType name=\"primary-key-join-column\"> <xsd:annotation> <xsd:documentation> @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface PrimaryKeyJoinColumn { String name() default \"\"; String referencedColumnName() default \"\"; String columnDefinition() default \"\"; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"referenced-column-name\" type=\"xsd:string\"/> <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"discriminator-column\"> <xsd:annotation> <xsd:documentation> @Target({TYPE}) @Retention(RUNTIME) public @interface DiscriminatorColumn { String name() default \"DTYPE\"; DiscriminatorType discriminatorType() default STRING; String columnDefinition() default \"\"; int length() default 31; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\"/> <xsd:attribute name=\"discriminator-type\" type=\"orm:discriminator-type\"/> <xsd:attribute name=\"column-definition\" type=\"xsd:string\"/> <xsd:attribute name=\"length\" type=\"xsd:int\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"embeddable\"> <xsd:annotation> <xsd:documentation> Defines the settings and mappings for embeddable objects. Is allowed to be sparsely populated and used in conjunction with the annotations. Alternatively, the metadata-complete attribute can be used to indicate that no annotations are to be processed in the class. If this is the case then the defaulting rules will be recursively applied. @Target({TYPE}) @Retention(RUNTIME) public @interface Embeddable {} </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"attributes\" type=\"orm:embeddable-attributes\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"access\" type=\"orm:access-type\"/> <xsd:attribute name=\"metadata-complete\" type=\"xsd:boolean\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"embeddable-attributes\"> <xsd:sequence> <xsd:element name=\"basic\" type=\"orm:basic\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> <xsd:element name=\"transient\" type=\"orm:transient\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"embedded\"> <xsd:annotation> <xsd:documentation> @Target({METHOD, FIELD}) @Retention(RUNTIME) public @interface Embedded {} </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"attribute-override\" type=\"orm:attribute-override\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"mapped-superclass\"> <xsd:annotation> <xsd:documentation> Defines the settings and mappings for a mapped superclass. Is allowed to be sparsely populated and used in conjunction with the annotations. Alternatively, the metadata-complete attribute can be used to indicate that no annotations are to be processed If this is the case then the defaulting rules will be recursively applied. @Target(TYPE) @Retention(RUNTIME) public @interface MappedSuperclass{} </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"description\" type=\"xsd:string\" minOccurs=\"0\"/> <xsd:element name=\"id-class\" type=\"orm:id-class\" minOccurs=\"0\"/> <xsd:element name=\"exclude-default-listeners\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"exclude-superclass-listeners\" type=\"orm:emptyType\" minOccurs=\"0\"/> <xsd:element name=\"entity-listeners\" type=\"orm:entity-listeners\" minOccurs=\"0\"/> <xsd:element name=\"pre-persist\" type=\"orm:pre-persist\" minOccurs=\"0\"/> <xsd:element name=\"post-persist\" type=\"orm:post-persist\" minOccurs=\"0\"/> <xsd:element name=\"pre-remove\" type=\"orm:pre-remove\" minOccurs=\"0\"/> <xsd:element name=\"post-remove\" type=\"orm:post-remove\" minOccurs=\"0\"/> <xsd:element name=\"pre-update\" type=\"orm:pre-update\" minOccurs=\"0\"/> <xsd:element name=\"post-update\" type=\"orm:post-update\" minOccurs=\"0\"/> <xsd:element name=\"post-load\" type=\"orm:post-load\" minOccurs=\"0\"/> <xsd:element name=\"attributes\" type=\"orm:attributes\" minOccurs=\"0\"/> </xsd:sequence> <xsd:attribute name=\"class\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"access\" type=\"orm:access-type\"/> <xsd:attribute name=\"metadata-complete\" type=\"xsd:boolean\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"sequence-generator\"> <xsd:annotation> <xsd:documentation> @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface SequenceGenerator { String name(); String sequenceName() default \"\"; int initialValue() default 1; int allocationSize() default 50; } </xsd:documentation> </xsd:annotation> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"sequence-name\" type=\"xsd:string\"/> <xsd:attribute name=\"initial-value\" type=\"xsd:int\"/> <xsd:attribute name=\"allocation-size\" type=\"xsd:int\"/> </xsd:complexType> <!-- **************************************************** --> <xsd:complexType name=\"table-generator\"> <xsd:annotation> <xsd:documentation> @Target({TYPE, METHOD, FIELD}) @Retention(RUNTIME) public @interface TableGenerator { String name(); String table() default \"\"; String catalog() default \"\"; String schema() default \"\"; String pkColumnName() default \"\"; String valueColumnName() default \"\"; String pkColumnValue() default \"\"; int initialValue() default 0; int allocationSize() default 50; UniqueConstraint[] uniqueConstraints() default {}; } </xsd:documentation> </xsd:annotation> <xsd:sequence> <xsd:element name=\"unique-constraint\" type=\"orm:unique-constraint\" minOccurs=\"0\" maxOccurs=\"unbounded\"/> </xsd:sequence> <xsd:attribute name=\"name\" type=\"xsd:string\" use=\"required\"/> <xsd:attribute name=\"table\" type=\"xsd:string\"/> <xsd:attribute name=\"catalog\" type=\"xsd:string\"/> <xsd:attribute name=\"schema\" type=\"xsd:string\"/> <xsd:attribute name=\"pk-column-name\" type=\"xsd:string\"/> <xsd:attribute name=\"value-column-name\" type=\"xsd:string\"/> <xsd:attribute name=\"pk-column-value\" type=\"xsd:string\"/> <xsd:attribute name=\"initial-value\" type=\"xsd:int\"/> <xsd:attribute name=\"allocation-size\" type=\"xsd:int\"/> </xsd:complexType> </xsd:schema>\n\n2. Entity Lifecycle Management\n\nEntityManagers perform several actions that affect the lifecycle state of entity instances.\n\npublic void persist(Object entity);\n\nTransitions new instances to managed. On the next flush or commit, the newly persisted instances will be inserted into the datastore.\n\nFor a given entity A, the persist method behaves as follows:\n\nIf A is a new entity, it becomes managed.\n\nIf A is an existing managed entity, it is ignored. However, the persist operation cascades as defined below.\n\nIf A is a removed entity, it becomes managed.\n\nIf A is a detached entity, an IllegalArgumentException is thrown.\n\nThe persist operation recurses on all relation fields of A whose cascades include CascadeType.PERSIST.\n\nThis action can only be used in the context of an active transaction.\n\npublic void remove(Object entity);\n\nTransitions managed instances to removed. The instances will be deleted from the datastore on the next flush or commit. Accessing a removed entity has undefined results.\n\nFor a given entity A, the remove method behaves as follows:\n\nIf A is a new entity, it is ignored. However, the remove operation cascades as defined below.\n\nIf A is an existing managed entity, it becomes removed.\n\nIf A is a removed entity, it is ignored.\n\nIf A is a detached entity, an IllegalArgumentException is thrown.\n\nThe remove operation recurses on all relation fields of A whose cascades include CascadeType.REMOVE.\n\nThis action can only be used in the context of an active transaction.\n\npublic void refresh(Object entity);\n\nUse the refresh action to make sure the persistent state of an instance is synchronized with the values in the datastore. refresh is intended for long-running optimistic transactions in which there is a danger of seeing stale data.\n\nFor a given entity A, the refresh method behaves as follows:\n\nIf A is a new entity, it is ignored. However, the remove operation cascades as defined below.\n\nIf A is an existing managed entity, its state is refreshed from the datastore.\n\nIf A is a removed entity, it is ignored.\n\nIf A is a detached entity, an IllegalArgumentException is thrown.\n\nThe refresh operation recurses on all relation fields of A whose cascades include CascadeType.REFRESH.\n\npublic Object merge(Object entity);\n\nA common use case for an application running in a servlet or application server is to \"detach\" objects from all server resources, modify them, and then \"attach\" them again. For example, a servlet might store persistent data in a user session between a modification based on a series of web forms. Between each form request, the web container might decide to serialize the session, requiring that the stored persistent state be disassociated from any other resources. Similarly, a client/server application might transfer persistent objects to a client via serialization, allow the client to modify their state, and then have the client return the modified data in order to be saved. This is sometimes referred to as the data transfer object or value object pattern, and it allows fine-grained manipulation of data objects without incurring the overhead of multiple remote method invocations.\n\nJPA provides support for this pattern by automatically detaching entities when they are serialized or when a persistence context ends (see Section 3, “ Persistence Context ” for an exploration of persistence contexts). The JPA merge API re-attaches detached entities. This allows you to detach a persistent instance, modify the detached instance offline, and merge the instance back into an EntityManager (either the same one that detached the instance, or a new one). The changes will then be applied to the existing instance from the datastore.\n\nA detached entity maintains its persistent identity, but cannot load additional state from the datastore. Accessing any persistent field or property that was not loaded at the time of detachment has undefined results. Also, be sure not to alter the version or identity fields of detached instances if you plan on merging them later.\n\nThe merge method returns a managed copy of the given detached entity. Changes made to the persistent state of the detached entity are applied to this managed instance. Because merging involves changing persistent state, you can only merge within a transaction.\n\nIf you attempt to merge an instance whose representation has changed in the datastore since detachment, the merge operation will throw an exception, or the transaction in which you perform the merge will fail on commit, just as if a normal optimistic conflict were detected.\n\nNote\n\nOpenJPA offers enhancements to JPA detachment functionality, including additional options to control which fields are detached. See Section 1, “ Detach and Attach ” in the Reference Guide for details.\n\nFor a given entity A, the merge method behaves as follows:\n\nIf A is a detached entity, its state is copied into existing managed instance A' of the same entity identity, or a new managed copy of A is created.\n\nIf A is a new entity, a new managed entity A' is created and the state of A is copied into A'.\n\nIf A is an existing managed entity, it is ignored. However, the merge operation still cascades as defined below.\n\nIf A is a removed entity, an IllegalArgumentException is thrown.\n\nThe merge operation recurses on all relation fields of A whose cascades include CascadeType.MERGE.\n\npublic void lock (Object entity, LockModeType mode);\n\nThis method locks the given entity using the named mode. The javax.persistence.LockModeType enum defines two modes:\n\nREAD: Other transactions may concurrently read the object, but cannot concurrently update it.\n\nWRITE: Other transactions cannot concurrently read or write the object. When a transaction is committed that holds WRITE locks on any entites, those entites will have their version incremented even if the entities themselves did not change in the transaction.\n\nNote\n\nOpenJPA has additional APIs for controlling object locking. See Section 3, “ Object Locking ” in the Reference Guide for details.\n\nThe following diagram illustrates the lifecycle of an entity with respect to the APIs presented in this section.\n\n1. JPQL API\n\n1.1. Query Basics\n\nSELECT x FROM Magazine x\n\nThe preceding is a simple JPQL query for all Magazine entities.\n\npublic Query createQuery(String jpql);\n\nThe EntityManager.createQuery method creates a Query instance from a given JPQL string.\n\npublic List getResultList();\n\nInvoking Query.getResultList executes the query and returns a List containing the matching objects. The following example executes our Magazine query above:\n\nEntityManager em = ... Query q = em.createQuery(\"SELECT x FROM Magazine x\"); List<Magazine> results = (List<Magazine>) q.getResultList();\n\nA JPQL query has an internal namespace declared in the from clause of the query. Arbitrary identifiers are assigned to entities so that they can be referenced elsewhere in the query. In the query example above, the identifier x is assigned to the entity Magazine .\n\nNote\n\nThe as keyword can optionally be used when declaring identifiers in the from clause. SELECT x FROM Magazine x and SELECT x FROM Magazine AS x are synonymous.\n\nFollowing the select clause of the query is the object or objects that the query returns. In the case of the query above, the query's result list will contain instances of the Magazine class.\n\nNote\n\nWhen selecting entities, you can optional use the keyword object . The clauses select x and SELECT OBJECT(x) are synonymous.\n\nThe optional where clause places criteria on matching results. For example:\n\nSELECT x FROM Magazine x WHERE x.title = 'JDJ'\n\nKeywords in JPQL expressions are case-insensitive, but entity, identifier, and member names are not. For example, the expression above could also be expressed as:\n\nSELECT x FROM Magazine x WHERE x.title = 'JDJ'\n\nBut it could not be expressed as:\n\nSELECT x FROM Magazine x WHERE x.TITLE = 'JDJ'\n\nAs with the select clause, alias names in the where clause are resolved to the entity declared in the from clause. The query above could be described in English as \"for all Magazine instances x, return a list of every x such that x's title field is equal to 'JDJ'\".\n\nJPQL uses SQL-like syntax for query criteria. The and and or logical operators chain multiple criteria together:\n\nSELECT x FROM Magazine x WHERE x.title = 'JDJ' OR x.title = 'JavaPro'\n\nThe = operator tests for equality. <> tests for inequality. JPQL also supports the following arithmetic operators for numeric comparisons: >, >=, <, <=. For example:\n\nSELECT x FROM Magazine x WHERE x.price > 3.00 AND x.price <= 5.00\n\nThis query returns all magazines whose price is greater than 3.00 and less than or equal to 5.00.\n\nSELECT x FROM Magazine x WHERE x.price <> 3.00\n\nThis query returns all Magazines whose price is not equals to 3.00.\n\nYou can group expressions together using parentheses in order to specify how they are evaluated. This is similar to how parentheses are used in Java. For example:\n\nSELECT x FROM Magazine x WHERE (x.price > 3.00 AND x.price <= 5.00) OR x.price = 7.00\n\nThis expression would match magazines whose price is 4.00, 5.00, or 7.00, but not 6.00. Alternately:\n\nSELECT x FROM Magazine x WHERE x.price > 3.00 AND (x.price <= 5.00 OR x.price = 7.00)\n\nThis expression will magazines whose price is 5.00 or 7.00, but not 4.00 or 6.00.\n\nJPQL also includes the following conditionals:\n\n[NOT] BETWEEN: Shorthand for expressing that a value falls between two other values. The following two statements are synonymous:\n\nSELECT x FROM Magazine x WHERE x.price >= 3.00 AND x.price <= 5.00\n\nSELECT x FROM Magazine x WHERE x.price BETWEEN 3.00 AND 5.00\n\n[NOT] LIKE: Performs a string comparison with wildcard support. The special character '_' in the parameter means to match any single character, and the special character '%' means to match any sequence of characters. The following statement matches title fields \"JDJ\" and \"JavaPro\", but not \"IT Insider\":\n\nSELECT x FROM Magazine x WHERE x.title LIKE 'J%'\n\nThe following statement matches the title field \"JDJ\" but not \"JavaPro\":\n\nSELECT x FROM Magazine x WHERE x.title LIKE 'J__'\n\n[NOT] IN: Specifies that the member must be equal to one element of the provided list. The following two statements are synonymous:\n\nSELECT x FROM Magazine x WHERE x.title IN ('JDJ', 'JavaPro', 'IT Insider')\n\nSELECT x FROM Magazine x WHERE x.title = 'JDJ' OR x.title = 'JavaPro' OR x.title = 'IT Insider'\n\nIS [NOT] EMPTY: Specifies that the collection field holds no elements. For example:\n\nSELECT x FROM Magazine x WHERE x.articles is empty\n\nThis statement will return all magazines whose articles member contains no elements.\n\nIS [NOT] NULL: Specifies that the field is equal to null. For example:\n\nSELECT x FROM Magazine x WHERE x.publisher is null\n\nThis statement will return all Magazine instances whose \"publisher\" field is set to null.\n\nNOT: Negates the contained expression. For example, the following two statements are synonymous:\n\nSELECT x FROM Magazine x WHERE NOT(x.price = 10.0)\n\nSELECT x FROM Magazine x WHERE x.price <> 10.0\n\n1.2. Relation Traversal\n\nRelations between objects can be traversed using Java-like syntax. For example, if the Magazine class has a field named \"publisher\" or type Company, that relation can be queried as follows:\n\nSELECT x FROM Magazine x WHERE x.publisher.name = 'Random House'\n\nThis query returns all Magazine instances whose publisher field is set to a Company instance whose name is \"Random House\".\n\nSingle-valued relation traversal implies that the relation is not null. In SQL terms, this is known as an inner join. If you want to also include relations that are null, you can specify:\n\nSELECT x FROM Magazine x WHERE x.publisher.name = 'Random House' or x.publisher is null\n\nYou can also traverse collection fields in queries, but you must declare each traversal in the from clause. Consider:\n\nSELECT x FROM Magazine x, IN(x.articles) y WHERE y.authorName = 'John Doe'\n\nThis query says that for each Magazine x , traverse the articles relation and check each Articley, and pass the filter if y's authorName field is equal to \"John Doe\". In short, this query will return all magazines that have any articles written by John Doe.\n\nNote\n\nThe IN() syntax can also be expressed with the keywords inner join. The statements SELECT x FROM Magazine x, IN(x.articles) y WHERE y.authorName = 'John Doe' and SELECT x FROM Magazine x inner join x.articles y WHERE y.authorName = 'John Doe' are synonymous.\n\n1.3. Fetch Joins\n\nJPQL queries may specify one or more join fetch declarations, which allow the query to specify which fields in the returned instances will be pre-fetched.\n\nSELECT x FROM Magazine x join fetch x.articles WHERE x.title = 'JDJ'\n\nThe query above returns Magazine instances and guarantees that the articles field will already be fetched in the returned instances.\n\nMultiple fields may be specified in separate join fetch declarations:\n\nSELECT x FROM Magazine x join fetch x.articles join fetch x.authors WHERE x.title = 'JDJ'\n\nNote\n\nSpecifying the join fetch declaration is functionally equivalent to adding the fields to the Query's FetchConfiguration. See Section 6, “ Fetch Groups ”.\n\n1.4. JPQL Functions\n\nAs well as supporting direct field and relation comparisons, JPQL supports a pre-defined set of functions that you can apply.\n\nCONCAT(string1, string2): Concatenates two string fields or literals. For example:\n\nSELECT x FROM Magazine x WHERE CONCAT(x.title, 's') = 'JDJs'\n\nSUBSTRING(string, startIndex, length): Returns the part of the string argument starting at startIndex (1-based) and ending at length characters past startIndex.\n\nSELECT x FROM Magazine x WHERE SUBSTRING(x.title, 1, 1) = 'J'\n\nTRIM([LEADING | TRAILING | BOTH] [character FROM] string: Trims the specified character from either the beginning ( LEADING ) end ( TRAILING) or both ( BOTH ) of the string argument. If no trim character is specified, the space character will be trimmed.\n\nSELECT x FROM Magazine x WHERE TRIM(BOTH 'J' FROM x.title) = 'D'\n\nLOWER(string): Returns the lower-case of the specified string argument.\n\nSELECT x FROM Magazine x WHERE LOWER(x.title) = 'jdj'\n\nUPPER(string): Returns the upper-case of the specified string argument.\n\nSELECT x FROM Magazine x WHERE UPPER(x.title) = 'JAVAPRO'\n\nLENGTH(string): Returns the number of characters in the specified string argument.\n\nSELECT x FROM Magazine x WHERE LENGTH(x.title) = 3\n\nLOCATE(searchString, candidateString [, startIndex]): Returns the first index of searchString in candidateString. Positions are 1-based. If the string is not found, returns 0.\n\nSELECT x FROM Magazine x WHERE LOCATE('D', x.title) = 2\n\nABS(number): Returns the absolute value of the argument.\n\nSELECT x FROM Magazine x WHERE ABS(x.price) >= 5.00\n\nSQRT(number): Returns the square root of the argument.\n\nSELECT x FROM Magazine x WHERE SQRT(x.price) >= 1.00\n\nMOD(number, divisor): Returns the modulo of number and divisor.\n\nSELECT x FROM Magazine x WHERE MOD(x.price, 10) = 0\n\nCURRENT_DATE: Returns the current date.\n\nCURRENT_TIME: Returns the current time.\n\nCURRENT_TIMESTAMP: Returns the current timestamp.\n\n1.5. Polymorphic Queries\n\nAll JPQL queries are polymorphic, which means the from clause of a query includes not only instances of the specific entity class to which it refers, but all subclasses of that class as well. The instances returned by a query include instances of the subclasses that satisfy the query conditions. For example, the following query may return instances of Magazine , as well as Tabloid and Digest instances, where Tabloid and Digest are Magazine subclasses.\n\nSELECT x FROM Magazine x WHERE x.price < 5\n\n1.6. Query Parameters\n\nJPQL provides support for parameterized queries. Either named parameters or positional parameters may be specified in the query string. Parameters allow you to re-use query templates where only the input parameters vary. A single query can declare either named parameters or positional parameters, but is not allowed to declare both named and positional parameters.\n\npublic Query setParameter (int pos, Object value);\n\nSpecify positional parameters in your JPQL string using an integer prefixed by a question mark. You can then populate the Query object with positional parameter values via calls to the setParameter method above. The method returns the Query instance for optional method chaining.\n\nEntityManager em = ... Query q = em.createQuery(\"SELECT x FROM Magazine x WHERE x.title = ?1 and x.price > ?2\"); q.setParameter(1, \"JDJ\").setParameter(2, 5.0); List<Magazine> results = (List<Magazine>) q.getResultList();\n\nThis code will substitute JDJ for the ?1 parameter and 5.0 for the ?2 parameter, then execute the query with those values.\n\npublic Query setParameter(String name, Object value);\n\nNamed parameter are denoted by prefixing an arbitrary name with a colon in your JPQL string. You can then populate the Query object with parameter values using the method above. Like the positional parameter method, this method returns the Query instance for optional method chaining.\n\nEntityManager em = ... Query q = em.createQuery(\"SELECT x FROM Magazine x WHERE x.title = :titleParam and x.price > :priceParam\"); q.setParameter(\"titleParam\", \"JDJ\").setParameter(\"priceParam\", 5.0); List<Magazine> results = (List<Magazine>) q.getResultList();\n\nThis code substitutes JDJ for the :titleParam parameter and 5.0 for the :priceParam parameter, then executes the query with those values.\n\n1.7. Ordering\n\nJPQL queries may optionally contain an order by clause which specifies one or more fields to order by when returning query results. You may follow the order by field clause with the asc or desc keywords, which indicate that ordering should be ascending or descending, respectively. If the direction is omitted, ordering is ascending by default.\n\nSELECT x FROM Magazine x order by x.title asc, x.price desc\n\nThe query above returns Magazine instances sorted by their title in ascending order. In cases where the titles of two or more magazines are the same, those instances will be sorted by price in descending order.\n\n1.8. Aggregates\n\nJPQL queries can select aggregate data as well as objects. JPQL includes the min, max, avg, and count aggregates. These functions can be used for reporting and summary queries.\n\nThe following query will return the average of all the prices of all the magazines:\n\nEntityManager em = ... Query q = em.createQuery(\"SELECT AVG(x.price) FROM Magazine x\"); Number result = (Number) q.getSingleResult();\n\nThe following query will return the highest price of all the magazines titled \"JDJ\":\n\nEntityManager em = ... Query q = em.createQuery(\"SELECT MAX(x.price) FROM Magazine x WHERE x.title = 'JDJ'\"); Number result = (Number) q.getSingleResult();\n\n1.9. Named Queries\n\nQuery templates can be statically declared using the NamedQuery and NamedQueries annotations. For example:\n\n@Entity @NamedQueries({ @NamedQuery(name=\"magsOverPrice\", query=\"SELECT x FROM Magazine x WHERE x.price > ?1\"), @NamedQuery(name=\"magsByTitle\", query=\"SELECT x FROM Magazine x WHERE x.title = :titleParam\") }) public class Magazine { ... }\n\nThese declarations will define two named queries called magsOverPrice and magsByTitle.\n\npublic Query createNamedQuery(String name);\n\nYou retrieve named queries with the above EntityManager method. For example:\n\nEntityManager em = ... Query q = em.createNamedQuery(\"magsOverPrice\"); q.setParameter(1, 5.0f); List<Magazine> results = (List<Magazine>) q.getResultList();\n\nEntityManager em = ... Query q = em.createNamedQuery(\"magsByTitle\"); q.setParameter(\"titleParam\", \"JDJ\"); List<Magazine> results = (List<Magazine>) q.getResultList();\n\n1.10. Delete By Query\n\nQueries are useful not only for finding objects, but for efficiently deleting them as well. For example, you might delete all records created before a certain date. Rather than bring these objects into memory and delete them individually, JPA allows you to perform a single bulk delete based on JPQL criteria.\n\nDelete by query uses the same JPQL syntax as normal queries, with one exception: begin your query string with the delete keyword instead of the select keyword. To then execute the delete, you call the following Query method:\n\npublic int executeUpdate();\n\nThis method returns the number of objects deleted. The following example deletes all subscriptions whose expiration date has passed.\n\nExample 10.1. Delete by Query\n\nQuery q = em.createQuery(\"DELETE s FROM Subscription s WHERE s.subscriptionDate < :today\"); q.setParameter(\"today\", new Date()); int deleted = q.executeUpdate();\n\n1.11. Update By Query\n\nSimilar to bulk deletes, it is sometimes necessary to perform updates against a large number of queries in a single operation, without having to bring all the instances down to the client. Rather than bring these objects into memory and modifying them individually, JPA allows you to perform a single bulk update based on JPQL criteria.\n\nUpdate by query uses the same JPQL syntax as normal queries, except that the query string begins with the update keyword instead of select. To execute the update, you call the following Query method:\n\npublic int executeUpdate();\n\nThis method returns the number of objects updated. The following example updates all subscriptions whose expiration date has passed to have the \"paid\" field set to true..\n\nExample 10.2. Update by Query\n\nQuery q = em.createQuery(\"UPDATE Subscription s SET s.paid = :paid WHERE s.subscriptionDate < :today\"); q.setParameter(\"today\", new Date()); q.setParameter(\"paid\", true); int updated = q.executeUpdate();\n\n2. JPQL Language Reference\n\nThe Java Persistence Query Language (JPQL) is used to define searches against persistent entities independent of the mechanism used to store those entities. As such, JPQL is \"portable\", and not constrained to any particular data store. The Java Persistence query language is an extension of the Enterprise JavaBeans query language, EJB QL, adding operations such as bulk deletes and updates, join operations, aggregates, projections, and subqueries. Furthermore, JPQL queries can be declared statically in metadata, or can be dynamically built in code. This chapter provides the full definition of the language.\n\nNote\n\nMuch of this section is paraphrased or taken directly from Chapter 4 of the JSR 220 specification.\n\n2.1. JPQL Statement Types\n\nA JPQL statement may be either a SELECT statement, an UPDATE statement, or a DELETE statement. This chapter refers to all such statements as \"queries\". Where it is important to distinguish among statement types, the specific statement type is referenced. In BNF syntax, a query language statement is defined as:\n\nQL_statement ::= select_statement | update_statement | delete_statement\n\nThe complete BNF for JPQL is defined in Section 2.12, “ JPQL BNF ”. Any JPQL statement may be constructed dynamically or may be statically defined in a metadata annotation or XML descriptor element. All statement types may have parameters, as discussed in Section 2.5.4, “ JPQL Input Parameters ”.\n\n2.1.1. JPQL Select Statement\n\nA select statement is a string which consists of the following clauses:\n\na SELECT clause, which determines the type of the objects or values to be selected.\n\na FROM clause, which provides declarations that designate the domain to which the expressions specified in the other clauses of the query apply.\n\nan optional WHERE clause, which may be used to restrict the results that are returned by the query.\n\nan optional GROUP BY clause, which allows query results to be aggregated in terms of groups.\n\nan optional HAVING clause, which allows filtering over aggregated groups.\n\nan optional ORDER BY clause, which may be used to order the results that are returned by the query.\n\nIn BNF syntax, a select statement is defined as:\n\nselect_statement ::= select_clause from_clause [where_clause] [groupby_clause] [having_clause] [orderby_clause]\n\nA select statement must always have a SELECT and a FROM clause. The square brackets [] indicate that the other clauses are optional.\n\n2.1.2. JPQL Update and Delete Statements\n\nUpdate and delete statements provide bulk operations over sets of entities. In BNF syntax, these operations are defined as:\n\nupdate_statement ::= update_clause [where_clause]\n\ndelete_statement ::= delete_clause [where_clause]\n\nThe update and delete clauses determine the type of the entities to be updated or deleted. The WHERE clause may be used to restrict the scope of the update or delete operation. Update and delete statements are described further in Section 2.9, “ JPQL Bulk Update and Delete ”.\n\n2.2. JPQL Abstract Schema Types and Query Domains\n\nThe Java Persistence query language is a typed language, and every expression has a type. The type of an expression is derived from the structure of the expression, the abstract schema types of the identification variable declarations, the types to which the persistent fields and relationships evaluate, and the types of literals. The abstract schema type of an entity is derived from the entity class and the metadata information provided by Java language annotations or in the XML descriptor.\n\nInformally, the abstract schema type of an entity can be characterized as follows:\n\nFor every persistent field or get accessor method (for a persistent property) of the entity class, there is a field (\"state-field\") whose abstract schema type corresponds to that of the field or the result type of the accessor method.\n\nFor every persistent relationship field or get accessor method (for a persistent relationship property) of the entity class, there is a field (\"association-field\") whose type is the abstract schema type of the related entity (or, if the relationship is a one-to-many or many-to-many, a collection of such). Abstract schema types are specific to the query language data model. The persistence provider is not required to implement or otherwise materialize an abstract schema type. The domain of a query consists of the abstract schema types of all entities that are defined in the same persistence unit. The domain of a query may be restricted by the navigability of the relationships of the entity on which it is based. The association-fields of an entity's abstract schema type determine navigability. Using the association-fields and their values, a query can select related entities and use their abstract schema types in the query.\n\n2.2.1. JPQL Entity Naming\n\nEntities are designated in query strings by their entity names. The entity name is defined by the name element of the Entity annotation (or the entity-name XML descriptor element), and defaults to the unqualified name of the entity class. Entity names are scoped within the persistence unit and must be unique within the persistence unit.\n\n2.2.2. JPQL Schema Example\n\nThis example assumes that the application developer provides several entity classes, representing magazines, publishers, authors, and articles. The abstract schema types for these entities are Magazine, Publisher, Author, and Article.\n\nSeveral Entities with Abstract Persistence Schemas Defined in the Same Persistence Unit. The entity Publisher has a one-to-many relationships with Magazine. There is also a one-to-many relationship between Magazine and Article . The entity Article is related to Author in a one-to-one relationship.\n\nQueries to select magazines can be defined by navigating over the association-fields and state-fields defined by Magazine and Author. A query to find all magazines that have unpublished articles is as follows:\n\nSELECT DISTINCT mag FROM Magazine AS mag JOIN mag.articles AS art WHERE art.published = FALSE\n\nThis query navigates over the association-field authors of the abstract schema type Magazine to find articles, and uses the state-field published of Article to select those magazines that have at least one article that is published. Although predefined reserved identifiers, such as DISTINCT, FROM, AS, JOIN, WHERE, and FALSE appear in upper case in this example, predefined reserved identifiers are case insensitive. The SELECT clause of this example designates the return type of this query to be of type Magazine. Because the same persistence unit defines the abstract persistence schemas of the related entities, the developer can also specify a query over articles that utilizes the abstract schema type for products, and hence the state-fields and association-fields of both the abstract schema types Magazine and Author. For example, if the abstract schema type Author has a state-field named firstName, a query over articles can be specified using this state-field. Such a query might be to find all magazines that have articles authored by someone with the first name \"John\".\n\nSELECT DISTINCT mag FROM Magazine mag JOIN mag.articles art JOIN art.author auth WHERE auth.firstName = 'John'\n\nBecause Magazine is related to Author by means of the relationships between Magazine and Article and between Article and Author, navigation using the association-fields authors and product is used to express the query. This query is specified by using the abstract schema name Magazine, which designates the abstract schema type over which the query ranges. The basis for the navigation is provided by the association-fields authors and product of the abstract schema types Magazine and Article respectively.\n\n2.3. JPQL FROM Clause and Navigational Declarations\n\nThe FROM clause of a query defines the domain of the query by declaring identification variables. An identification variable is an identifier declared in the FROM clause of a query. The domain of the query may be constrained by path expressions. Identification variables designate instances of a particular entity abstract schema type. The FROM clause can contain multiple identification variable declarations separated by a comma (,).\n\nfrom_clause ::= FROM identification_variable_declaration {, {identification_variable_declaration | collection_member_declaration}}*\n\nidentification_variable_declaration ::= range_variable_declaration { join | fetch_join }*\n\nrange_variable_declaration ::= abstract_schema_name [AS] identification_variable\n\njoin ::= join_spec join_association_path_expression [AS] identification_variable\n\nfetch_join ::= join_spec FETCH join_association_path_expression\n\njoin_association_path_expression ::= join_collection_valued_path_expression | join_single_valued_association_path_expression\n\njoin_spec ::= [ LEFT [OUTER] | INNER ] JOIN\n\ncollection_member_declaration ::= IN (collection_valued_path_expression) [AS] identification_variable\n\n2.3.1. JPQL FROM Identifiers\n\nAn identifier is a character sequence of unlimited length. The character sequence must begin with a Java identifier start character, and all other characters must be Java identifier part characters. An identifier start character is any character for which the method Character.isJavaIdentifierStart returns true. This includes the underscore (_) character and the dollar sign ($) character. An identifier part character is any character for which the method Character.isJavaIdentifierPart returns true. The question mark (?) character is reserved for use by the Java Persistence query language. The following are reserved identifiers:\n\nSELECT\n\nFROM\n\nWHERE\n\nUPDATE\n\nDELETE\n\nJOIN\n\nOUTER\n\nINNER\n\nLEFT\n\nGROUP\n\nBY\n\nHAVING\n\nFETCH\n\nDISTINCT\n\nOBJECT\n\nNULL\n\nTRUE\n\nFALSE\n\nNOT\n\nAND\n\nOR\n\nBETWEEN\n\nLIKE\n\nIN\n\nAS\n\nUNKNOWN\n\nEMPTY\n\nMEMBER\n\nOF\n\nIS\n\nAVG\n\nMAX\n\nMIN\n\nSUM\n\nCOUNT\n\nORDER\n\nBY\n\nASC\n\nDESC\n\nMOD\n\nUPPER\n\nLOWER\n\nTRIM\n\nPOSITION\n\nCHARACTER_LENGTH\n\nCHAR_LENGTH\n\nBIT_LENGTH\n\nCURRENT_TIME\n\nCURRENT_DATE\n\nCURRENT_TIMESTAMP\n\nNEW\n\nEXISTS\n\nALL\n\nANY\n\nSOME\n\nReserved identifiers are case insensitive. Reserved identifiers must not be used as identification variables. It is recommended that other SQL reserved words also not be as identification variables in queries because they may be used as reserved identifiers in future releases of the specification.\n\n2.3.2. JPQL Identification Variables\n\nAn identification variable is a valid identifier declared in the FROM clause of a query. All identification variables must be declared in the FROM clause. Identification variables cannot be declared in other clauses. An identification variable must not be a reserved identifier or have the same name as any entity in the same persistence unit: Identification variables are case insensitive. An identification variable evaluates to a value of the type of the expression used in declaring the variable. For example, consider the previous query:\n\nSELECT DISTINCT mag FROM Magazine mag JOIN mag.articles art JOIN art.author auth WHERE auth.firstName = 'John'\n\nIn the FROM clause declaration mag.articlesart, the identification variable art evaluates to any Article value directly reachable from Magazine. The association-field articles is a collection of instances of the abstract schema type Article and the identification variable art refers to an element of this collection. The type of auth is the abstract schema type of Author. An identification variable ranges over the abstract schema type of an entity. An identification variable designates an instance of an entity abstract schema type or an element of a collection of entity abstract schema type instances. Identification variables are existentially quantified in a query. An identification variable always designates a reference to a single value. It is declared in one of three ways: in a range variable declaration, in a join clause, or in a collection member declaration. The identification variable declarations are evaluated from left to right in the FROM clause, and an identification variable declaration can use the result of a preceding identification variable declaration of the query string.\n\n2.3.3. JPQL Range Declarations\n\nThe syntax fo"
    }
}