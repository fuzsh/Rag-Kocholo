{
    "id": "correct_subsidiary_00134_3",
    "rank": 62,
    "data": {
        "url": "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/index.html",
        "read_more_link": "",
        "language": "en",
        "title": "Castor 1.3.3 - Reference documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/persistence-layered-architecture.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/3.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/3.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/note.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/admons/tip.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/1.png",
            "https://castor-data-binding.github.io/castor/reference-guides/1.3.3/html-single/images/callouts/2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Werner Guttmann ()",
            "Bruce Snyder ()",
            "Assaf Arkin ()"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "1.1. XML framework\n\n1.1.1. Introduction\n\nCastor XML is an XML data binding framework. Unlike the two main XML APIs, DOM (Document Object Model) and SAX (Simple API for XML) which deal with the structure of an XML document, Castor enables you to deal with the data defined in an XML document through an object model which represents that data.\n\nCastor XML can marshal almost any \"bean-like\" Java Object to and from XML. In most cases the marshalling framework uses a set of ClassDescriptors and FieldDescriptors to describe how an Object should be marshalled and unmarshalled from XML.\n\nFor those not familiar with the terms \"marshal\" and \"unmarshal\", it's simply the act of converting a stream (sequence of bytes) of data to and from an Object. The act of \"marshalling\" consists of converting an Object to a stream, and \"unmarshalling\" from a stream to an Object.\n\n1.1.2. Castor XML - The XML data binding framework\n\nThe XML data binding framework, as it's name implies, is responsible for doing the conversion between Java and XML. The framework consists of two worker classes, org/exolab/castor/xml/Marshaller and org.exolab.castor.xml.Unmarshaller respectively, and a bootstrap class org.exolab.castor.xml.XMLContext used for configuration of the XML data binding framework and instantiation of the two worker objects.\n\nLets walk through a very simple example. Assume we have a simple Person class as follows:\n\nimport java.util.Date; public class Person implements java.io.Serializable { private String name = null; private Date dob = null; public Person() { super(); } public Person(String name) { this.name = name; } public Date getDateOfBirth() { return dob; } public String getName() { return name; } public void setDateOfBirth(Date dob) { this.dob = dob; } public void setName(String name) { this.name = name; } }\n\nTo (un-)marshal data to and from XML, Castor XML can be used in one of three modes:\n\nintrospection mode\n\nmapping mode\n\ndescriptor mode (aka generation mode)\n\nThe following sections discuss each of these modes at a high level.\n\n1.1.2.1. Introspection mode\n\nThe introspection mode is the simplest mode to use from a user perspective, as it does not require any configuration from the user. As such, the user does not have to provide any mapping file(s), nor point Castor to any generated descriptor classes (as discussed in the 'descriptor mode' section).\n\nIn this mode, the user makes use of static methods on the org.exolab.castor.xml.Marshaller and org.exolab.castor.xml.Unmarshaller classes, providing all required data as parameters on these method calls.\n\nTo marshal an instance of the person class you simply call the org.exolab.castor.xml.Marshaller as follows:\n\nPerson person = new Person(\"Ryan 'Mad Dog' Madden\"); person.setDateOfBirth(new Date(1955, 8, 15)); writer = new FileWriter(\"test.xml\"); Marshaller.marshal(person, writer);\n\nThis produces the XML shown in Example 1.1, “XML produced in introspection mode”\n\nExample 1.1. XML produced in introspection mode\n\nXML to written\n\nTo unmarshal an instance of the person class from XML, you simply call the org.exolab.castor.xml.Unmarshaller as follows:\n\nreader = new FileReader(\"test.xml\"); Person person = (Person) Unmarshaller.unmarshal(Person.class, reader);\n\nMarshalling and unmarshalling is basically that simple.\n\nNote Note: The above example uses the static methods of the marshalling framework, and as such no Marshaller and/or Unmarshaller instances need to be created. A common mistake in this context when using a mapping file is to call the org.exolab.castor.xml.Marshaller or org.exolab.castor.xml.Unmarshaller as in the above example. This won't work, as the mapping will be ignored.\n\nIn introspection mode , Castor XML uses Java reflection to establish the binding between the Java classes (and their properties) and the XML, following a set of (default) naming rules. Whilst it is possible to change to a different set of naming rules, there's no way to override this (default) naming for individual artifacts. In such a case, a mapping file should be used.\n\n1.1.2.2. Mapping mode\n\nIn mapping mode , the user provides Castor XML with a user-defined mapping (in form of a mapping file) that allows the (partial) definition of a customized mapping between Java classes (and their properties) and XML.\n\nWhen you are using a mapping file, create an instance of the org.exolab.castor.xml.XMLContext class and use the org.exolab.castor.xml.XMLContext.addMapping(Mapping) method to provide Castor XML with one of more mapping files.\n\nTo start using Castor XML for marshalling and/or unmarshalling based upon your custom mapping, create instances of org.exolab.castor.xml.Marshaller and org.exolab.castor.xml.Unmarshalleras needed using one of the following methods:\n\nTable 1.1. Methods on XMLContext to create Un-/Marshaller objects\n\nMethod nameDescription\n\ncreateMarshaller\n\nCreates a Marshaller instance.\n\ncreateUnmarshaller\n\nCreates a Unmarshaller instance.\n\nand call any of the non-static (un)marshal methods to trigger data binding in either way.\n\nBelow code shows a full example that demonstrates unmarshalling a Person instance from XML using a org.exolab.castor.xml.Unmarshaller instance as obtained from an XMLContext previously configured to your needs.\n\nExample 1.2. Unmarshalling from XML using a mapping\n\nimport org.exolab.castor.xml.XMLContext; import org.exolab.castor.mapping.Mapping; import org.exolab.castor.xml.Unmarshaller; Mapping mapping = new Mapping(); mapping.loadMapping(\"mapping.xml\"); XMLContext context = new XMLContext(); context.addMapping(mapping); reader = new FileReader(\"test.xml\"); Unmarshaller unmarshaller = context.createUnmarshaller(); unmarshaller.setClass(Person.class); Person person = (Person) unmarshaller.unmarshal(reader);\n\nTo marshal the very same Person instance to XML using a org.exolab.castor.xml.Marshaller obtained from the same org.exolab.castor.xml.XMLContext, use code as follows:\n\nExample 1.3. Marshalling to XML using a mapping\n\nimport org.exolab.castor.xml.Marshaller; Writer writer = new FileWriter(\"out.xml\"); Marshaller marshaller = context.createMarshaller(); marshaller.setWriter(writer); marshaller.marshal(person);\n\nPlease have a look at XML Mapping for a detailed discussion of the mapping file and its structure.\n\nFor more information on how to effectively deal with loading mapping file(s) especially in multi-threaded environments, please check the best practice section.\n\n1.1.2.3. Descriptor mode\n\nTBD\n\n1.1.3. Sources and destinations\n\nCastor supports multiple sources and destinations from which objects can be marshalled and unmarshalled.\n\nTable 1.2. Marshalling destinations.\n\nDestinationDescription\n\nTable 1.3. Unmarshalling sources.\n\nSourceDescription\n\nCastor 1.3.2 and 1.3.3 introduced support for the STaX API for both for marshalling and unmarshalling. The framework fully supports the STaX cursor and iterator API.\n\nAn example of marshalling using STaX:\n\nExample 1.4. Marshalling to a StAX java.xml.stream.XMLStreamWriter\n\nStringWriter writer = new StringWriter(); XMLOutputFactory outputFactory = XMLOutputFactory.newInstance(); XMLStreamWriter xmlStreamWriter = outputFactory.createXMLStreamWriter(writer); marshaller.setXmlStreamWriter(xmlStreamWriter); marshaller.marshal(object);\n\nAlso beginning from version 1.3.3, the framework has been modified to support Source and Result interfaces. Now it is possible to use SAXSource, DOMSource and StreamSource for unmarshalling and corresponding classes for marshalling.\n\nBelow an example of marshalling into Result:\n\nExample 1.5. Marshalling to a javax.xml.transform.dom.DOMResult\n\nObject obj = ... XMLContext xmlContext = ... Marshaller marshaller = xmlContext.createMarshaller(); DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = factory.newDocumentBuilder(); Document document = builder.newDocument(); marshaller.setResult(new DOMResult(document)); marshaller.marshall(obj);\n\nAnother example of unmarshalling from Source:\n\nExample 1.6. Unmarshalling from a javax.xml.transform.sax.SAXSource\n\nXMLContext xmlContext = ... Unmarshaller unmarshaller = xmlContext.createUnmarshaller(); InputSource inputSource = new InputSource(new StringReader(xml)); SAXSource saxSource = new SAXSource(inputSource); Object result = unmarshaller.unmarshal(saxSource);\n\n1.1.4. XMLContext - A consolidated way to bootstrap Castor\n\nWith Castor 1.1.2, the org.exolab.castor.xml.XMLContext class has been added to the Castor marshalling framework. This new class provides a bootstrap mechanism for Castor XML, and allows easy (and efficient) instantiation of org.exolab.castor.xml.Marshaller and org.exolab.castor.xml.Unmarshaller instances as needed.\n\nAs shown above, the org.exolab.castor.xml.XMLContext class offers various factory methods to obtain a new org.exolab.castor.xml.Marshaller, org.exolab.castor.xml.Unmarshaller.\n\nWhen you need more than one org.exolab.castor.xml.Unmarshaller instance in your application, please call org.exolab.castor.xml.XMLContext.createUnmarshaller() as required. As all Unmarshaller instances are created from the very same XMLContext instance, overhead will be minimal. Please note, though, that use of one Unmarshaller instance is not thread-safe.\n\n1.1.5. Using existing Classes/Objects\n\nCastor can marshal \"almost\" any arbitrary Object to and from XML. When descriptors are not available for a specfic Class, the marshalling framework uses reflection to gain information about the object.\n\nNote Actually an in memory set of descriptors are created for the object and we will soon have a way for saving these descriptors as Java source, so that they may be modified and compiled with little effort.\n\nIf a set of descriptors exist for the classes, then Castor will use those to gain information about how to handle the marshalling. See Section 1.1.6, “Class Descriptors” for more information.\n\nThere is one main restrictions to marshalling objects. These classes must have have a public default constructor (ie. a constructor with no arguments) and adequete \"getter\" and \"setter\" methods to be properly be marshalled and unmarshalled.\n\nThe example illustrated in the previous section Section 1.1.2, “Castor XML - The XML data binding framework” demonstrates how to use the framework with existing classes.\n\n1.1.6. Class Descriptors\n\nClass descriptors provide the \"Castor Framework\" with necessary information so that the Class can be marshalled properly. The class descriptors can be shared between the JDO and XML frameworks.\n\nClass descriptors contain a set of ???\n\nXML Class descriptors provide the marshalling framework with the information it needs about a class in order to be marshalled to and from XML. The XMLClassDescriptor org.exolab.castor.xml.XMLClassDescriptor.\n\nXML Class Descriptors are created in four main ways. Two of these are basically run-time, and the other two are compile time.\n\n1. Compile-Time Descriptors\n\nTo use \"compile-time\" class descriptors, one can either implement the org.exolab.castor.xml.XMLClassDescriptor interface for each class which needs to be \"described\", or have the Source Code Generator create the proper descriptors.\n\nThe main advantage of compile-time descriptors is that they are faster than the run-time approach.\n\n2. Run-Time Descriptors\n\nTo use \"run-time\" class descriptors, one can either simply let Castor introspect the classes, a mapping file can be provided, or a combination of both \"default introspection\" and a specified mapping file may be used.\n\nFor \"default introspection\" to work the class being introspected must have adequete setter/getter methods for each field of the class that should be marshalled and unmarshalled. If no getter/setter methods exist, Castor can handle direct field access to public fields. It does not do both at the same time. So if the respective class has any getter/setter methods at all, then no direct field access will take place.\n\nThere is nothing to do to enable \"default introspection\". If a descriptor cannot be found for a class, introspection occurs automatically.\n\nSome behavior of the introspector may be controlled by setting the appropriate properties in the castor.properties file. Such behavior consists of changing the naming conventions, and whether primitive types are treated as attributes or elements. See castor.properties file for more information.\n\nA mapping file may also be used to \"describe\" the classes which are to be marshalled. The mapping is loaded before any marshalling/unmarshalling takes place. See org.exolab.castor.mapping.Mapping\n\nThe main advantage of run-time descriptors is that it takes very little effort to get something working.\n\n1.2. XML Mapping\n\n1.2.1. Introduction\n\nCastor XML mapping is a way to simplify the binding of java classes to XML document. It allows to transform the data contained in a java object model into/from an XML document.\n\nAlthough it is possible to rely on Castor's default behavior to marshal and unmarshal Java objects into an XML document, it might be necessary to have more control over this behavior. For example, if a Java object model already exists, Castor XML Mapping can be used as a bridge between the XML document and that Java object model.\n\nCastor allows one to specify some of its marshalling/unmarshalling behavior using a mapping file. This file gives explicit information to Castor on how a given XML document and a given set of Java objects relate to each other.\n\nA Castor mapping file is a good way to dissociate the changes in the structure of a Java object model from the changes in the corresponding XML document format.\n\n1.2.2. Overview\n\nThe mapping information is specified by an XML document. This document is written from the point of view of the Java object and describes how the properties of the object have to be translated into XML. One constraint for the mapping file is that Castor should be able to infer unambiguously from it how a given XML element/attribute has to be translated into the object model during unmarshalling.\n\nThe mapping file describes for each object how each of its fields have to be mapped into XML. A field is an abstraction for a property of an object. It can correspond directly to a public class variable or indirectly to a property via some accessor methods (setters and getters).\n\nIt is possible to use the mapping and Castor default behavior in conjunction: when Castor has to handle an object or an XML data but can't find information about it in the mapping file, it will rely on its default behavior. Castor will use the Java Reflection API to introspect the Java objects to determine what to do.\n\nNote: Castor can't handle all possible mappings. In some complex cases, it may be necessary to rely on an XSL transformation in conjunction with Castor to adapt the XML document to a more friendly format.\n\n1.2.2.1. Marshalling Behavior\n\nFor Castor, a Java class has to map into an XML element. When Castor marshals an object, it will:\n\nuse the mapping information, if any, to find the name of the element to create\n\nor\n\nby default, create a name using the name of the class\n\nIt will then use the fields information from the mapping file to determine how a given property of the object has to be translated into one and only one of the following:\n\nan attribute\n\nan element\n\ntext content\n\nnothing, as we can choose to ignore a particular field\n\nThis process will be recursive: if Castor finds a property that has a class type specified elsewhere in the mapping file, it will use this information to marshal the object.\n\nBy default, if Castor finds no information for a given class in the mapping file, it will introspect the class and apply a set of default rules to guess the fields and marshal them. The default rules are as follows:\n\nAll primitive types, including the primitive type wrappers (Boolean, Short, etc...) are marshalled as attributes.\n\nAll other objects are marshalled as elements with either text content or element content.\n\n1.2.2.2. Unmarshalling Behavior\n\nWhen Castor finds an element while unmarshalling a document, it will try to use the mapping information to determine which object to instantiate. If no mapping information is present, Castor will use the name of the element to try to guess the name of a class to instantiate (for example, for an element named 'test-element', Castor will try to instantiate a class named 'TestElement' if no information is given in the mapping file). Castor will then use the field information of the mapping file to handle the content of the element.\n\nIf the class is not described in the mapping file, Castor will instrospect the class using the Java Reflection API to determine if there is any function of the form getXxxYyy()/setXxxYyy(<type> x). This accessor will be associated with XML element/attribute named 'xxx-yyy'. In the future, we will provide a way to override this default behavior.\n\nCastor will introspect object variables and use direct access _only_ if no get/set methods have been found in the class. In this case, Castor will look for public variables of the form:\n\npublic <type> xxxYYY;\n\nand expect an element/attribute named 'xxx-yyy'. The only handled collections for <type> are java.lang.Vector and array. (up to version 0.8.10)\n\nFor primitive <type>, Castor will look for an attribute first and then an element. If <type> is not a primitive type, Castor will look for an element first and then an attribute.\n\n1.2.3. The Mapping File\n\nThe following sections define the syntax for each of the mapping file artefacts and their semantical meaning.\n\n1.2.3.1. Sample domain objects\n\nThis section defines a small domain model that will be referenced by various mapping file (fragments/samples) in the following sections. The model consists of two two classes Order and OrderItem, where an order holds a list of order items.\n\npublic class Order { private List orderItems; private String orderNumber; public List getOrderItems() { return orderItems; } public void setOrderItems(List orderItems) { this.orderItems = orderItems; } public String getOrderNumber() { return orderNumber; } public void setOrderNumber(String orderNumber) { this.orderNumber = orderNumber; } } public class OrderItem { private String id; private Integer orderQuantity; public String getId() { return id; } public void setId(String id) { this.id = id; } public Integer getOrderQuantity() { return orderQuantity; } public void setOrderQuantity(Integer orderQuantity) { this.orderQuantity = orderQuantity; } }\n\nAs shown above in bold, the Order instance has a (private) field 'orderItems' to hold a collection of OrderItem instances. This field is publically exposed by corresponding getter and setter methods.\n\n1.2.3.2. The <mapping> element\n\n<!ELEMENT mapping ( description?, include*, field-handler*, class*, key-generator* )>\n\nThe <mapping> element is the root element of a mapping file. It contains:\n\nan optional description\n\nzero or more <include> which facilitates reusing mapping files\n\nzero of more <field-handler> defining custom, configurable field handlers\n\nzero or more <class> descriptions: one for each class we intend to give mapping information\n\nzero or more <key-generator>: not used for XML mapping\n\nA mapping file look like this:\n\n<?xml version=\"1.0\"?> <!DOCTYPE mapping PUBLIC \"-//EXOLAB/Castor Mapping DTD Version 1.0//EN\" castor.org \"http://castor.org/mapping.dtd\"> <mapping> <description>Description of the mapping</description> <include href=\"other_mapping_file.xml\"/> <!-- mapping for class 'A' --> <class name=\"A\"> ......... </class> <!-- mapping for class 'B' --> <class name=\"B\"> ......... </class> </mapping>\n\n1.2.3.3. The <class> element\n\n<!ELEMENT class ( description?, cache-type?, map-to?, field+ )> <!ATTLIST class name ID #REQUIRED extends IDREF #IMPLIED depends IDREF #IMPLIED auto-complete ( true |false ) \"false\" identity CDATA #IMPLIED access ( read-only | shared | exclusive | db-locked ) \"shared\" key-generator IDREF #IMPLIED >\n\nThe <class> element contains all the information used to map a Java class into an XML document. The content of <class> is mainly used to describe the fields that will be mapped.\n\nTable 1.4. Description of the attributes\n\nNameDescriptionnameThe fuly-qualified name of the Java class that we want to map to.extendsThe fully qualified name of a parent class. This attribute should be used only if this class extends another class for which a class mapping is provided. It should not be used if there's no class maping for the extended class.dependsUsed with Castor JDO only; for more information on this field, please see the JDO documentation.auto-completeIf true, the class will be introspected to determine its field and the fields specified in the mapping file will be used to overide the fields found during the introspection.identityUsed with Castor JDO only; for more information on this field, please see see the JDO documentation.accessUsed with Castor JDO only; for more information on this field, please see see the JDO documentation.key-generatorUsed with Castor JDO only; for more information on this field, please see see the JDO documentation.\n\nThe auto-complete attributes is interesting as it allow a fine degree of control of the introspector: it is possible to specifiy only the fields whose Castor default behavior does not suite our needs. These feature should simplify the handling of complexe class containing many fields. Please see below for an example usage of this attribute.\n\nTable 1.5. Description of the content\n\nNameDescriptiondescriptionAn optional description.cache-typeUsed with Castor JDO only; for more information on this field, please see see the JDO documentation.map-to Used if the name of the element is not the name of the class. By default, Castor will infer the name of the element to be mapped from the name of the class: a Java class named 'XxxYyy' will be transformed in 'xxx-yyy'. If you don't want Castor to generate the name, you need to use <map-to> to specify the name you want to use. <map-to> is only used for the root element. fieldZero or more <field> elements, which are used to describe the properties of the Java class being mapped.\n\n1.2.3.3.1. Sample <class> mappings\n\nThe following mapping fragment defines a class mapping for the OrderItem class:\n\n<class name=\"mypackage.OrderItem> <map-to xml=\"item\"/> <field name=\"id\" type=\"string\"> <bind-xml name=\"identity\" node=\"attribute\"/> </field> </field name=\"orderQuantity\" type=\"integer\"> <bind-xml name=\"quantity\" node=\"element\"/> </field> </class>\n\nWhen marshalling an OrderItem instance, this yields the following XML:\n\n<?xml version=\"1.0\" ?> <item identity=\"12\"> <quantity>100</quantity> </item>\n\nThe following mapping fragment defines a class mapping for the same class, where for all properties but id introspection should be used; the use of the auto-complete attribute instructs Castor XML to use introspection for all attributes other than 'id', where the given field mapping will be used.\n\n<class name=\"mypackage.OrderItem auto-complete=\"true\"> <map-to xml=\"item\"/> <field name=\"id\" type=\"string\"> <bind-xml name=\"identity\" node=\"attribute\"/> </field> </class>\n\nWhen marshalling the very same OrderItem instance, this yields the following XML:\n\n<?xml version=\"1.0\" ?> <item identity=\"12\"> <order-quantity>100</order-quantity> </item>\n\nBy removing the <map-to> element from above class mapping, ...\n\n<class name=\"mypackage.OrderItem auto-complete=\"true\"> <field name=\"id\" type=\"string\"> <bind-xml name=\"identity\" node=\"attribute\"/> </field> </class>\n\n... Castor will use introspection to infer the element name from the Java class name (OrderItem), applying a default naming convention scheme.\n\nWhen marshalling the very same OrderItem instance, this yields the following XML:\n\n<?xml version=\"1.0\" ?> <order-item identity=\"12\"> <order-quantity>100</order-quantity> </order-item>\n\n1.2.3.4. The <map-to> element\n\n<!ELEMENT map-to EMPTY> <!ATTLIST map-to table NMTOKEN #IMPLIED xml NMTOKEN #IMPLIED ns-uri NMTOKEN #IMPLIED ns-prefix NMTOKEN #IMPLIED ldap-dn NMTOKEN #IMPLIED element-definition (true|false) \"false\" NEW as of 1.0M3 ldap-oc NMTOKEN #IMPLIED>\n\n<map-to> is used to specify the name of the element that should be associated with the given class. <map-to> is only used for the root class. If this information is not present, Castor will:\n\nfor marshalling, infer the name of the element to be mapped from the name of the class: a Java class named 'XxxYyy' will be transformed into 'xxx-yyy'.\n\nfor unmarshalling, infer the name of the class from the name of the element: for an element named 'test-element' Castor will try to use a class named 'TestElement'\n\nPlease note that it is possible to change the naming scheme used by Castor to translate between the XML name and the Java class name in the castor.properties file.\n\nTable 1.6. Description of attributes\n\nxmlName of the element that the class is associated to.ns-uriNamespace URIns-prefixDesired namespaceelement-definitionTrue if the descriptor as created from a schema definition that was of type element (as opposed to a <complexType> definition). This only is useful in the context of source code generation.ldap-dnNot used for Castor XMLldap-ocNot used for Castor XML\n\n1.2.3.4.1. <map-to> samples\n\nThe following mapping fragment defines a <map-to element for the OrderItem class, manually setting the element name to a value of 'item'.\n\n<class name=\"myPackage.OrderItem\"> ... <map-to xml=\"item\" /> ... </class>\n\nThe following mapping fragment instructs Castor to assign a namespace URI of http://castor.org/sample/mapping/ to the <item> element, and use a namespace prefix of 'castor' during un-/marshalling.\n\n<class name=\"myPackage.OrderItem\"> ... <map-to xml=\"item\" ns-uri=\"http://castor.org/sample/mapping/\" ns-prefix=\"castor\"/> ... </class>\n\nWhen marshalling an OrderItem instance, this will yield the following XML:\n\n<?xml version=\"1.0\" ?> <castor:order-item xmlns:castor=\"http://castor.org/sample/mapping/\" identity=\"12\"> <castor:order-quantity>100</castor:order-quantity> </castor:order-item>\n\n1.2.3.5. The <field> element\n\n<!ELEMENT field ( description?, sql?, bind-xml?, ldap? )> <!ATTLIST field name NMTOKEN #REQUIRED type NMTOKEN #IMPLIED handler NMTOKEN #IMPLIED required ( true | false ) \"false\" direct ( true | false ) \"false\" lazy ( true | false ) \"false\" transient ( true | false ) \"false\" nillable ( true | false ) \"false\" container ( true | false ) \"false\" get-method NMTOKEN #IMPLIED set-method NMTOKEN #IMPLIED create-method NMTOKEN #IMPLIED collection ( array | vector | hashtable | collection | set | map ) #IMPLIED>\n\n<field> is used to describe a property of a Java object we want to marshal/unmarshal. It gives:\n\nits identity ('name')\n\nits type (infered from 'type' and 'collection')\n\nits access method (infered from 'direct', 'get-method', 'set-method')\n\nFrom this information, Castor is able to access a given property in the Java class.\n\nIn order to determine the signature that Castor expects, there are two easy rules to apply.\n\n1. Determine <type>.\n\nIf there is no 'collection' attribute, the <type> is just the Java type specified in <type_attribute> (the value of the 'type' attribute in the XML document). The value of <type_attribute> can be a fully qualified Java object like 'java.lang.String' or one of the allowed short name:\n\nTable 1.7. Type shortnames\n\nshort namePrimitive type?Java ClassotherNjava.lang.ObjectstringNjava.lang.StringintegerYjava.lang.Integer.TYPElongYjava.lang.Long.TYPEbooleanYjava.lang.Boolean.TYPEdoubleYjava.lang.Double.TYPEfloatYjava.lang.Float.TYPEbig-decimalNjava.math.BigDecimalbyteYjava.lang.Byte.TYPEdateNjava.util.DateshortYjava.lang.Short.TYPEcharYjava.lang.Character.TYPEbytesNbyte[]charsNchar[]stringsNString[]localeNjava.util.Locale\n\nCastor will try to cast the data in the XML file in the proper Java type.\n\nIf there is a collection attribute , you can use the following table:\n\nTable 1.8. Type implementations\n\nname<type>default implementationarray<type_attribute>[]<type_attribute>[]arraylistjava.util.Listjava.util.Arraylistvectorjava.util.Vectorjava.util.Vectorhashtablejava.util.Hashtablejava.util.Hashtablecollectionjava.util.Collectionjava.util.Arraylistsetjava.util.Setjava.util.Hashsetmapjava.util.Mapjava.util.Hashmapsortedsetjava.util.SortedSetjava.util.TreeSet\n\nThe type of the object inside the collection is <type_attribute>. The 'default implementation' is the type used if the object holding the collection is found to be null and need to be instantiated.\n\nFor hashtable and maps (since 0.9.5.3), Castor will save both key and values. When marshalling output <key> and <value> elements. These names can be controlled by using a top-level or nested class mapping for the org.exolab.castor.mapping.MapItem class.\n\nNote: for backward compatibility with prior versions of Castor, the saveMapKeys property can be set to false in the castor.properties file.\n\nFor versions prior to 0.9.5.3, hashtable and maps, Castor will save only the value during marshalling and during unmarshalling will add a map entry using the object as both the key and value, e.g. map.put(object, object).\n\nIt is necessary to use a collection when the content model of the element expects more than one element of the specified type.\n\nDetermine the signature of the function\n\nIf 'direct' is set to true, Castor expects to find a class variable with the given signature:\n\npublic <type> <name>;\n\nIf 'direct' is set to false or omitted, Castor will access the property though accessor methods. Castor determines the signature of the accessors as follow: If the 'get-method' or 'set-method' attributes are supplied, it will try to find a function with the following signature:\n\npublic <type> <get-method>();\n\nor\n\npublic void <set-method>(<type> value);\n\nIf 'get-method' and 'set-method' attributes are not provided, Castor will try to find the following function:\n\npublic <type> get<capitalized-name>();\n\nor\n\npublic void set<capitalized-name>(<type> value);\n\n<capitalized-name> means that Castor takes the <name> attribute and put its first letter in uppercase without modifying the other letters.\n\nThe content of <field> will contain the information on how to map this given field to SQL, XML, ...\n\nExceptions concerning collection fields:\n\nThe default is to treat the 'get-method' as a simple getter returning the collection field, and the 'set-method' as a simple getter used to set a new instance on the collection field.\n\nTable 1.9. Collection field access\n\nParameterDescription\n\nTable 1.10. Description of the attributes\n\nNameDescriptionnameThe field 'name' is required even if no such field exists in the class. If 'direct' access is used, 'name' should be the name of a public instance member in the object to be mapped (the field must be public, not static and not transient). If no direct access and no 'get-/set-method' is specified, this name will be used to infer the name of the accessors methods.typeThe Java type of the field. It is used to access the field. Castor will use this information to cast the XML information (like string into integer). It is also used to define the signature of the accessor methods. If a collection is specified, this is used to specify the type of the objects held by the collection. See description above for more details.requiredA field can be optional or required.nillableA field can be of content 'nil'.transientIf true, this field will be ignored during the marshalling. This is usefull when used together with the auto-complete=\"true\" option.directIf true, Castor will expect a public variable in the containing class and will access it directly (for both reading and writing).containerIndicates whether the field should be treated as a container, i.e. only it's fields should be persisted, but not the containing class itself. In this case, the container attribute should be set to true (supported in Castor XML only).collectionIf a parent expects more than one occurrence of one of its element, it is necessary to specify which collection Castor will use to handle them. The type specified is used to define the type of the content inside the collection.get-methodOptional name of the 'get method' Castor should use. If this attribute is not set and the set-method attribute is not set, then Castor will try to infer the name of this method with the algorithm described above.set-methodOptional name of the 'set method' Castor should use. If this attribute is not set and the get-method attribute is not set, then Castor will try to infer the name of this method with the algorithm described above.create-methodOptionally defines a factory method for the instantiation of a FieldHandlerhandlerIf present, specifies one of the following:\n\nThe fully-qualified class name of a custom field handler implementation, or\n\nThe (short) name of a configurable field handler definition.\n\n1.2.3.6. Description of the content\n\nIn the case of XML mapping, the content of a field element should be one and only one <bind-xml> element describing how this given field will be mapped into the XML document.\n\n1.2.3.6.1. Mapping constructor arguments (since 0.9.5)\n\nStarting with release 0.9.5, for attribute mapped fields, support has been added to map a constructor field using the set-method attribute.\n\nTo specify that a field (mapped to an attribute) should be used as a constructor argument during object initialization, please specify a set-method attribute on the <field> mapping and use \"%X\" as the value of the set-method attribute, where X is a positive integer number, e.g. %1 or %21.\n\nFor example:\n\n<field name=\"foo\" set-method=\"%1\" get-method=\"getFoo\" type=\"string\"> <bind-xml node=\"attribute\"/> </field>\n\nNote that because the set-method is specified, the get-method also must be specified.\n\nTip: the XML HOW-TO section has a HOW-TO document for mapping constructor arguments, incl. a fully working mapping.\n\n1.2.3.6.2. Sample 1: Defining a custom field handler\n\nThe following mapping fragment defines a <field> element for the member property of the org.some.package.Root class, specifying a custom org.exolab.castor.mapping.FieldHandler implementation.\n\n<class name=\"org.some.package.Root\"> <field name=\"member\" type=\"string\" handler=\"org.some.package.CustomFieldHandlerImpl\"/> </class>\n\n1.2.3.6.3. Sample 2: Defining a custom configurable field handler\n\nThe same custom field handler as in the previous sample can be defined with a separate configurable <field-handler> definition, where additional configuration can be provided.\n\n<field-handler name=\"myHandler\" class=\"org.some.package.CustomFieldHandlerImpl\"> <param name=\"date-format\" value=\"yyyyMMddHHmmss\"/> </field-handler>\n\nand subsequently be referred to by its name as shown in the following field mapping:\n\n<class name=\"org.some.package.Root\"> <field name=\"member\" type=\"string\" handler=\"myHandler\"/> </class>\n\n1.2.3.6.4. Sample 3: Using the container attribute\n\nAssume you have a class mapping for a class Order which defines - amongst others - a field mapping as follows, where the field item refers to an instance of a class Item.\n\n<class name=\"some.example.Order\"> ... <field name=\"item\" type=\"some.example.Item\" > <bind-xml> name=\"item\" node=\"element\" /> </field> ... </class> <class name=\"some.example.Item\"> <field name=\"id\" type=\"long\" /> <field name=\"description\" type=\"string\" /> </class>\n\nMarshalling an instance of Order would produce XML as follows:\n\n<order> ... <item> <id>100</id> <description>...</description> </item> </order>\n\nIf you do not want the Item instance to be marshalled, but only its fields, change the field mapping for the item member to be as follows:\n\n<field name=\"item\" type=\"some.example.Item\" container=\"false\" > <bind-xml> name=\"item\" node=\"element\" /> </field>\n\nThe resulting XML would look as follows:\n\n<order> ... <id>100</id> <description>...</description> </order>\n\n1.2.3.7. The <bind-xml> element\n\n1.2.3.7.1. Grammar\n\n<!ELEMENT bind-xml (class?, property*)> <!ATTLIST bind-xml name NMTOKEN #IMPLIED type NMTOKEN #IMPLIED location CDATA #IMPLIED matches NMTOKENS #IMPLIED QName-prefix NMTOKEN #IMPLIED reference ( true | false ) \"false\" node ( attribute | element | text ) #IMPLIED auto-naming ( deriveByClass | deriveByField ) #IMPLIED transient ( true | false ) \"false\">\n\n1.2.3.7.1.1. Definiton\n\nThe <bind-xml> element is used to describe how a given Java field should appear in an XML document. It is used both for marshalling and unmarshalling.\n\nTable 1.11. Description of the attributes\n\nnameThe name of the element or attribute. auto-namingIf no name is specified, this attribute controls how castor will automatically create a name for the field. Normally, the name is created using the field name, however many times it is necessary to create the name by using the class type instead (such as heterogenenous collections).typeXML Schema type (of the value of this field) that requires specific handling in the Castor Marshalling Framework (such as 'QName' for instance).location (since 0.9.4.4)Allows the user to specify the \"sub-path\" for which the value should be marshalled to and from. This is useful for \"wrapping\" values in elements or for mapping values that appear on sub-elements to the current \"element\" represented by the class mapping. For more information, see the Location attribute below.QName-prefixWhen the field represents a QName value, a prefix can be provided that is used when marshalling value of type QName. More information on the use of 'QName-prefix' can be found in the SourceGenerator DocumentationreferenceIndicates if this field has to be treated as a reference by the unmarshaller. In order to work properly, you must specify the node type to 'attribute' for both the 'id' and the 'reference'. In newer versions of Castor, 'element' node for reference is allowed. Remember to make sure that an identity field is specified on the <class> mapping for the object type being referenced so that Castor knows what the object's identity is.matchesAllows overriding the matches rules for the name of the element. It is a standard regular expression and will be used instead of the 'name' field. A '*' will match any xml name, however it will only be matched if no other field exists that matches the xml name.nodeIndicates if the name corresponds to an attribute, an element, or text content. By default, primitive types are assumed to be an attribute, otherwise the node is assumed to be an elementransientAllows for making this field transient for XML. The default value is inherited from the <field> element.\n\n1.2.3.7.2. Nested class mapping\n\nSince 0.9.5.3, the bind-xml element supports a nested class mapping, which is often useful when needing to specify more than one mapping for a particular class. A good example of this is when mapping Hashtable/HashMap/Map.\n\n<bind-xml ...> <class name=\"org.exolab.castor.mapping.MapItem\"> <field name=\"key\" type=\"java.lang.String\"> <bind-xml name=\"id\"/> </field> <field name=\"value\" type=\"com.acme.Foo\"/> </class> </bind-xml>\n\n1.2.4. Usage Pattern\n\nHere is an example of how Castor Mapping can be used. We want to map an XML document like the following one (called 'order.xml'). model.\n\n<Order reference=\"12343-AHSHE-314159\"> <Client> <Name>Jean Smith</Name> <Address>2000, Alameda de las Pulgas, San Mateo, CA 94403</Address> </Client> <Item reference=\"RF-0001\"> <Description>Stuffed Penguin</Description> <Quantity>10</Quantity> <UnitPrice>8.95</UnitPrice> </Item> <Item reference=\"RF-0034\"> <Description>Chocolate</Description> <Quantity5</Quantity> <UnitPrice>28.50</UnitPrice> </Item> <Item reference=\"RF-3341\"> <Description>Cookie</Description> <Quantity>30</Quantity> <UnitPrice>0.85</UnitPrice> </Item> </Order>\n\nInto the following object model composed of 3 classes:\n\nMyOrder: represent an order\n\nClient: used to store information on the client\n\nItem: used to store item in an order\n\nThe sources of these classes follow.\n\nimport java.util.Vector; import java.util.Enumeration; public class MyOrder { private String _ref; private ClientData _client; private Vector _items; private float _total; public void setReference(String ref) { _ref = ref; } public String getReference() { return _ref; } public void setClientData(ClientData client) { _client = client; } public ClientData getClientData() { return _client; } public void setItemsList(Vector items) { _items = items; } public Vector getItemsList() { return _items; } public void setTotal(float total) { _total = total; } public float getTotal() { return _total; } public float getTotalPrice() { float total = 0.0f; for (Enumeration e = _items.elements() ; e.hasMoreElements() ;) { Item item = (Item) e.nextElement(); total += item._quantity * item._unitPrice; } return total; } }\n\npublic class ClientData { private String _name; private String _address; public void setName(String name) { _name = name; } public String getName() { return _name; } public void setAddress(String address) { _address = address; } public String getAddress() { return _address; } }\n\npublic class Item { public String _reference; public int _quantity; public float _unitPrice; public String _description; }\n\nThe XML document and the java object model can be connected by using the following mapping file:\n\n<?xml version=\"1.0\"?> <!DOCTYPE mapping PUBLIC \"-//EXOLAB/Castor Mapping DTD Version 1.0//EN\" \"http://castor.org/mapping.dtd\"> <mapping> <class name=\"MyOrder\"> <map-to xml=\"Order\"/> <field name=\"Reference\" type=\"java.lang.String\"> <bind-xml name=\"reference\" node=\"attribute\"/> </field> <field name=\"Total\" type=\"float\"> <bind-xml name=\"total-price\" node=\"attribute\"/> </field> <field name=\"ClientData\" type=\"ClientData\"> <bind-xml name=\"Client\"/> </field> <field name=\"ItemsList\" type=\"Item\" collection=\"vector\"> <bind-xml name=\"Item\"/> </field> </class> <class name=\"ClientData\"> <field name=\"Name\" type=\"java.lang.String\"> <bind-xml name=\"Name\" node=\"element\"/> </field> <field name=\"Address\" type=\"java.lang.String\"> <bind-xml name=\"Address\" node=\"element\"/> </field> </class> <class name=\"Item\"> <field name=\"_reference\" type=\"java.lang.String\" direct=\"true\"> <bind-xml name=\"reference\" node=\"attribute\"/> </field> <field name=\"_quantity\" type=\"integer\" direct=\"true\"> <bind-xml name=\"Quantity\" node=\"element\"/> </field> <field name=\"_unitPrice\" type=\"float\" direct=\"true\"> <bind-xml name=\"UnitPrice\" node=\"element\"/> </field> <field name=\"_description\" type=\"string\" direct=\"true\"> <bind-xml name=\"Description\" node=\"element\"/> </field> </class> </mapping>\n\nThe following class is an example of how to use Castor XML Mapping to manipulate the file 'order.xml'. It unmarshals the document 'order.xml', computes the total price, sets the total price in the java object and marshals the object model back into XML with the calculated price.\n\nimport org.exolab.castor.mapping.Mapping; import org.exolab.castor.mapping.MappingException; import org.exolab.castor.xml.Unmarshaller; import org.exolab.castor.xml.Marshaller; import java.io.IOException; import java.io.FileReader; import java.io.OutputStreamWriter; import org.xml.sax.InputSource; public class main { public static void main(String args[]) { Mapping mapping = new Mapping(); try { mapping.loadMapping( \"mapping.xml\" ); Unmarshaller unmar = new Unmarshaller(mapping); MyOrder order = (MyOrder)unmar.unmarshal(new InputSource(new FileReader(\"order.xml\"))); float total = order.getTotalPrice(); System.out.println(\"Order total price = \" + total); order.setTotal(total); Marshaller marshaller = new Marshaller(new OutputStreamWriter(System.out)); marshaller.setMapping(mapping); marshaller.marshal(order); } catch (Exception e) { System.out.println(e); return; } } }\n\n1.2.5. xsi:type\n\nOrdinarily, a mapping will only reference types that are concrete classes (i.e. not interfaces nor abstract classes). The reason is that to unmarshal a type requires instantiating it and one cannot instantiate an interface. However, in many real situations, object models depend on the use of interfaces. Many class properties are defined to have interface types to support the ability to swap implementations. This is often the case in frameworks.\n\nThe problem is that a different mapping must be used each time the same model is to be used to marshal/unmarshal an implementation that uses different concrete types. This is not convenient. The mapping should represent the model and the specific concrete type used to unmarshal a document is a configuration parameter; it should be specified in the instance document to be unmarshalled, not the mapping.\n\nFor example, assume a very simple object model of an engine that has one property that is a processor:\n\npublic interface IProcessor { public void process(); } public class Engine { private IProcessor processor; public IProcessor getProcessor() { return processor; } public void setProcessor(IProcessor processor) { this.processor = processor; } }\n\nA typical mapping file for such a design may be:\n\n<mapping> <class name=\"Engine\"> <map-to xml=\"engine\" /> <field name=\"processor\" type=\"IProcessor\" required=\"true\"> <bind-xml name=\"processor\" node=\"element\" /> </field> </class> </mapping>\n\nIt is possible to use such a mapping and still have the marshal/unmarshal process work by specifying the concrete implementation of IProcessor in the document to be unmarshalled, using the xsi:type attribute, as follows:\n\n<engine> <processor xsi:type=\"java:com.abc.MyProcessor\" /> </engine>\n\nIn this manner, one is still able to maintain only a single mapping, but vary the manner in which the document is unmarshalled from one instance document to the next. This flexibility is powerful because it enables the support of polymorphism within the castor xml marshalling framework.\n\nSuppose we wanted the following XML instead:\n\n<engine> <myProcessor/> </engine>\n\nIn the above output our XML name changed to match the type of the class used instead of relying on the xsi:type attribute. This can be achieved by modifying the mapping file as such:\n\n<mapping> <class name=\"Engine\"> <map-to xml=\"engine\" /> <field name=\"processor\" type=\"IProcessor\" required=\"true\"> <bind-xml auto-naming=\"deriveByClass\" node=\"element\" /> </field> </class> <class name=\"MyProcessor\"> <map-to xml=\"myProcessor\" /> </class> </mapping>\n\n1.2.6. Location attribute\n\nSince 0.9.5\n\nThe location attribute allows the user to map fields from nested elements or specify a wrapper element for a given field. Wrapper elements are simply elements which appear in the XML instance, but do not have a direct mapping to an object or field within the object model.\n\nFor example to map an instance of the following class:\n\npublic class Foo { private Bar bar = null; public Foo(); public getBar() { return bar; } public void setBar(Bar bar) { this.bar = bar; } }\n\ninto the following XML instance:\n\n<?xml version=\"1.0\"?> <foo>; <abc> <bar>...</bar> </abc> </foo>\n\n(notice that an 'abc' field doesn't exist in the Bar class) One would use the following mapping:\n\n<?xml version=\"1.0\"?> ... <class name=\"Foo\"> <field name=\"bar\" type=\"Bar\"> <bind-xml name=\"bar\" location=\"abc\"/> </field> </class> ... </mapping>\n\nNote the \"location\" attribute. The value of this attribute is the name of the wrapper element. To use more than one wrapper element, the name is separated by a forward-slash as such:\n\n<bind-xml name=\"bar\" location=\"abc/xyz\" />\n\nNote that the name of the element is not part of the location itself and that the location is always relative to the class in which the field is being defined. This works for attributes also:\n\n<bind-xml name=\"bar\" location=\"abc\" node=\"attribute\" />\n\nwill produce the following:\n\n<?xml version=\"1.0\"?> <foo> <abc bar=\"...\"/>; </foo>\n\n1.2.7. Tips\n\nSome helpful hints...\n\n1.2.7.1. Automatically create a mapping file\n\nCastor comes with a tool that can automatically create a mapping from class files. Please see the XML FAQ for more information.\n\n1.2.7.2. Create your own FieldHandler\n\nSometimes to handle complex situations you'll need to create your own FieldHandler. Normally a FieldHandler deals with a specific class and field, however generic, reusable FieldHandlers can also be created by extending org.exolab.castor.mapping.GeneralizedFieldHandler or org.exolab.castor.mapping.AbstractFieldHandler. The FieldHandler can be specified on the <field> element.\n\nFor more information on writing a custom FieldHandler please see the following: XML FieldHandlers.\n\n1.2.7.3. Mapping constructor arguments (since 0.9.5)\n\nYou may map any attributes to constructor arguments. For more information on how to map constructor arguments see the information available in the section on set-method above.\n\nPlease note that mapping elements to constructor arguments is not yet supported.\n\nTip: the XML HOW-TO section has a HOW-TO document for mapping constructor arguments.\n\n1.2.7.4. Preventing Castor from checking for a default constructor (since 0.9.5)\n\nSometimes it's useful to prevent Castor from checking for a default constructor, such as when trying to write a mapping for an interface or type-safe enum. You can use the \"undocumented\" verify-constructable=\"false\" attribute on the <class> element to prevent Castor from looking for the default constructor.\n\n1.2.7.5. Type safe enumeration mapping (since 0.9.5)\n\nWhile you can always use your own custom FieldHandler for handling type-safe enumeration classes, Castor does have a built-in approach to dealing with these types of classes. If the type-safe enum class has a public static <type> valueOf(String) method Castor will call that method so that the proper instance of the enumeration is returned. Note: You'll also need to disable the default constructor check in the mapping file (see section 7.4 above to see more on this).\n\n1.7. Castor XML: Writing Custom FieldHandlers\n\n1.7.1. Introduction\n\nSometimes we need to deal with a data format that Castor doesn't support out-of-the-box, such as an unsupported Date/Time representation, or we want to wrap and unwrap fields in Wrapper objects to get the desired XML output without changing our object model. To handle these cases Castor allows specifying a custom org.exolab.castor.mapping.FieldHandler which can do these varying conversions during calls to the fields setter and getter methods.\n\n1.7.2. Writing a simple FieldHandler\n\nWhen a writing a FieldHandler handler we need to provide implementations of the various methods specified in the FieldHandler interface. The main two methods are the getValue and setValue methods which will basically handle all our conversion code. The other methods provide ways to create a new instance of the field's value or reset the field value.\n\nLet's take a look at how to convert a date in the format YYYY-MM-DD using a custom FieldHandler. We want to marshal the following XML input file text.xml:\n\n<?xml version=\"1.0\"?> <root>2004-05-10</root>\n\nThe class we'll be marshalling from and unmarshalling to looks as follows:\n\nimport java.util.Date; public class Root { private Date _date; public Root() { super(); } public Date getDate() { return _date; } public void setDate(final Date date) { _date = date; }\n\nSo we need to write a custom FieldHandler that takes the input String and converts it into the proper java.util.Date instance:\n\nimport org.exolab.castor.mapping.FieldHandler; import org.exolab.castor.mapping.FieldDescriptor; import org.exolab.castor.mapping.ValidityException; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class MyDateHandler implements FieldHandler { private static final String FORMAT = \"yyyy-MM-dd\"; public MyDateHandler() { super(); } public Object getValue(final Object object) throws IllegalStateException { Root root = (Root)object; Date value = root.getDate(); if (value == null) return null; SimpleDateFormat formatter = new SimpleDateFormat(FORMAT); Date date = (Date)value; return formatter.format(date); } public void setValue(Object object, Object value) throws IllegalStateException, IllegalArgumentException { Root root = (Root)object; SimpleDateFormat formatter = new SimpleDateFormat(FORMAT); Date date = null; try { date = formatter.parse((String)value); } catch(ParseException px) { throw new IllegalArgumentException(px.getMessage()); } root.setDate(date); } public Object newInstance(Object parent) throws IllegalStateException { return null; } public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException { ((Root)object).setDate(null); } }\n\nIn order to tell Castor that we want to use our Custom FieldHandler we must specify it in the mapping file mapping.xml:\n\n<?xml version=\"1.0\"?> <mapping> <class name=\"Root\"> <field name=\"date\" type=\"string\" handler=\"MyDateHandler\"> <bind-xml node=\"text\"/> </field> </class> </mapping>\n\nWe can now use a simple Test class to unmarshal our XML document:\n\nimport java.io.*; import org.exolab.castor.xml.*; import org.exolab.castor.mapping.*; public class Test { public static void main(String[] args) { try { Mapping mapping = new Mapping(); mapping.loadMapping(\"mapping.xml\"); System.out.println(\"unmarshalling root instance:\"); System.out.println(); Reader reader = new FileReader(\"test.xml\"); Unmarshaller unmarshaller = new Unmarshaller(Root.class); unmarshaller.setMapping(mapping); Root root = (Root) unmarshaller.unmarshal(reader); reader.close(); System.out.println(\"Root#getDate : \" + root.getDate()); } catch (Exception e) { e.printStackTrace(); } } }\n\nNow simply compile the code and run!\n\n% java Test unmarshalling root instance: Root#getDate : Mon May 10 00:00:00 CDT 2004\n\nAfter running our test program we can see that Castor invoked our custom FieldHandler and we got our properly formatted date in our Root.class.\n\n1.7.3. Writing a GeneralizedFieldHandler\n\nA org.exolab.castor.mapping.GeneralizedFieldHandler is an extension of FieldHandler interface where we simply write the conversion methods and Castor will automatically handle the underlying get/set operations. This allows us to re-use the same FieldHandler for fields from different classes that require the same conversion.\n\nThe same FieldHandler we used above can be written as a GeneralizedFieldHandler as such:\n\nimport org.exolab.castor.mapping.GeneralizedFieldHandler; import org.exolab.castor.mapping.FieldDescriptor; import java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; public class MyDateHandler extends GeneralizedFieldHandler { private static final String FORMAT = \"yyyy-MM-dd\"; public MyDateHandler() { super(); } public Object convertUponGet(Object value) { if (value == null) return null; SimpleDateFormat formatter = new SimpleDateFormat(FORMAT); Date date = (Date)value; return formatter.format(date); } public Object convertUponSet(Object value) { SimpleDateFormat formatter = new SimpleDateFormat(FORMAT); Date date = null; try { date = formatter.parse((String)value); } catch(ParseException px) { throw new IllegalArgumentException(px.getMessage()); } return date; } public Class getFieldType() { return Date.class; } public Object newInstance(Object parent) throws IllegalStateException { return null; } }\n\nEverything else is the same. So we can re-run our test case using this GeneralizedFieldHandler and we'll get the same result. The main difference is that we implement the convertUponGet and convertUponSet methods.\n\nNotice that we never reference the Root class in our GeneralizedFieldHandler. This allows us to use the same exact FieldHandler for any field that requires this type of conversion.\n\n1.7.4. Use ConfigurableFieldHandler for more flexibility\n\nIn some situations, the GeneralizedFieldHandler might not provide sufficient flexibility. Suppose your XML document uses more than one date format. You could solve this by creating a GeneralizedFieldHandler subclass per date format, but that would lead to code duplication, which in itself is not desirable.\n\nA ConfigurableFieldHandler is a FieldHandler that can be configured in the mapping file with any kind and any number of parameters. You can simply configure two (or more) instances of the same ConfigurableFieldHandler class with different date format patterns. Here's a mapping file that uses a ConfigurableFieldHandler to marshal and unmarshal the date field, similar to the preceding examples:\n\n<?xml version=\"1.0\"?> <mapping> <field-handler name=\"myHandler\" class=\"FieldHandlerImpl\"> <param name=\"date-format\" value=\"yyyyMMddHHmmss\"/> </field-handler> <class name=\"Root\"> <field name=\"date\" type=\"string\" handler=\"myHandler\"/> </class> </mapping>\n\nThe field-handler element defines the ConfigurableFieldHandler. The class must be an implementation of the org.exolab.castor.mapping.ConfigurableFieldHandler interface. This instance is configured with a date format. However, each implementation can decide which, and how many parameters to use.\n\nThe field handler instance is referenced by the field element, using the handler attribute.\n\nHere's the ConfigurableFieldHandler implementation:\n\nimport java.text.ParseException; import java.text.SimpleDateFormat; import java.util.Date; import java.text.ParseException; import java.text.SimpleDateFormat; import java.text.DateFormat; import java.util.Date; import java.util.Properties; import org.exolab.castor.mapping.ConfigurableFieldHandler; import org.exolab.castor.mapping.FieldHandler; import org.exolab.castor.mapping.GeneralizedFieldHandler; import org.exolab.castor.mapping.ValidityException; public class FieldHandlerImpl implements FieldHandler, ConfigurableFieldHandler { private DateFormat formatter; public void setConfiguration(final Properties config) throws ValidityException { String pattern = config.getProperty(\"date-format\"); if (pattern == null) { throw new ValidityException(\"Required parameter \\\"date-format\\\" is missing for FieldHandlerImpl.\"); } try { formatter = new SimpleDateFormat(pattern); } catch (IllegalArgumentException e) { throw new ValidityException(\"Pattern \\\"\"+pattern+\"\\\" is not a valid date format.\"); } } public Object getValue(Object object) throws IllegalStateException { Root root = (Root)object; Date value = root.getDate(); if (value == null) return null; return formatter.format(value); } public void setValue(Object object, Object value) throws IllegalStateException, IllegalArgumentException { Root root = (Root)object; Date date = null; try { date = formatter.parse((String)value); } catch(ParseException px) { throw new IllegalArgumentException(px.getMessage()); } root.setDate(date); } public Object newInstance(Object parent) throws IllegalStateException { return null; } public void resetValue(Object object) throws IllegalStateException, IllegalArgumentException { ((Root)object).setDate(null); } }\n\nThis implementation is similar to the first MyDateHandler example on this page, except that is adds a setConfiguration method as specified by the ConfigurableFieldHandler interface. All parameters that are configured in the mapping file will be passed in as a Properties object. The implementing method is responsible for processing the configuration data.\n\nAs a convenience, org.exolab.castor.mapping.AbstractFieldHandler already implements ConfigurableFieldHandler. However, the setConfiguration method is not doing anything. Any subclass of AbstractFieldHandler only has to override this method to leverage the configuration capabilities. Since AbstractFieldHandler and its subclass GeneralizedFieldHandler are useful abstract classes, you'd probably want to use them anyway. It eliminates the need to implement the ConfigurableFieldHandler interface yourself.\n\n1.7.5. Reuse a ConfigurableFieldHandler for more than one field definition\n\nImagine a scenario where you want to use above ConfigurableFieldHandler instance for more than one field - a valid use case as it promotes reuse.\n\n<?xml version=\"1.0\"?> <mapping> <field-handler name=\"myFirstHandler\" class=\"FieldHandlerImpl\"> <param name=\"date-format\" value=\"yyyyMMddHHmmss\"/> </field-handler> <field-handler name=\"mySecondHandler\" class=\"FieldHandlerImpl\"> <param name=\"date-format\" value=\"yyyy-MM-ddHH:mm:ss\"/> </field-handler> <class name=\"Root\"> <field name=\"firstDate\" type=\"string\" handler=\"myFirstHandler\"/> <field name=\"secondDate\" type=\"string\" handler=\"myFirstHandler\"/> <field name=\"thirdDate\" type=\"string\" handler=\"mySecondHandler\"/> </class> </mapping>\n\nFor this to work, there's one more thing you will have to do: your ConfigurableFieldHandler implementation has to implement the ClonableFieldHandlerMarker interface and implement the copyFieldHandler() method. As indicated by the name, please return a clone/copy of your FieldHandler instance ... and you are all set.\n\nA simplified sample implementation could look as follows, extending the FieldHandlerImpl class from the previous section:\n\npublic class FieldHandlerImpl implements FieldHandler, ConfigurableFieldHandler, ClonableFieldHandlerMarker { private DateFormat format; ... public void setFormat(DateFormat format) { this.format = format; } @Override public FieldHandler copyFieldHandler() { FieldHandlerImpl handler = new FieldHandlerImpl(); handler.setFormat(this.getFormat()); return handler; } }\n\n1.7.6. No Constructor, No Problem!\n\nA number of classes such as type-safe enum style classes have no constructor, but instead have some sort of static factory method used for converting a string value into an instance of the class. With a custom FieldHandler we can allow Castor to work nicely with these types of classes.\n\nEven though Castor XML supports the \"valueOf\" method type-safe enum style classes, we'll show you how to write a custom handler for these classes anyway since it's useful for any type of class regardless of the name of the factory method.\n\nLet's look at how to write a handler for the following type-safe enum style class, which was actually generated by Castor XML (javadoc removed for brevity):\n\nimport java.io.Serializable; import java.util.Enumeration; import java.util.Hashtable; public class Color implements java.io.Serializable { public static final int RED_TYPE = 0; public static final Color RED = new Color(RED_TYPE, \"red\"); public static final int GREEN_TYPE = 1; public static final Color GREEN = new Color(GREEN_TYPE, \"green\"); public static final int BLUE_TYPE = 2; public static final Color BLUE = new Color(BLUE_TYPE, \"blue\"); private static java.util.Hashtable _memberTable = init(); private int type = -1; private java.lang.String stringValue = null; private Color(int type, java.lang.String value) { super(); this.type = type; this.stringValue = value; } public static java.util.Enumeration enumerate() { return _memberTable.elements(); } public int getType() { return this.type; } private static java.util.Hashtable init() { Hashtable members = new Hashtable(); members.put(\"red\", RED); members.put(\"green\", GREEN); members.put(\"blue\", BLUE); return members; } public java.lang.String toString() { return this.stringValue; } public static Color valueOf(java.lang.String string) { Object obj = null; if (string != null) obj = _memberTable.get(string); if (obj == null) { String err = \"'\" + string + \"' is not a valid Color\"; throw new IllegalArgumentException(err); } return (Color) obj; } }\n\nThe GeneralizedFieldHandler for the above Color class is as follows (javadoc removed for brevity):\n\nimport org.exolab.castor.mapping.GeneralizedFieldHandler; import org.exolab.castor.mapping.FieldDescriptor; public class ColorHandler extends GeneralizedFieldHandler { public ColorHandler() { super(); } public Object convertUponGet(Object value) { if (value == null) return null; Color color = (Color)value; return color.toString(); } public Object convertUponSet(Object value) { return Color.valueOf((String)value); } public Class getFieldType() { return Color.class; } public Object newInstance( Object parent ) throws IllegalStateException { return null; } }\n\nThat's all there really is to it. Now we just need to hook this up to our mapping file and run a sample test.\n\nIf we have a root class Foo as such:\n\npublic class Foo { private Color _color = null; private int _size = 0; private String _name = null; public Foo() { super(); } public Color getColor() { return _color; } public String getName() { return _name; } public int getSize() { return _size; } public void setColor(Color color) { _color = color; } public void setName(String name) { _name = name; } public void setSize(int size) { _size = size; } }\n\nOur mapping file would be the following:\n\n<?xml version=\"1.0\"?> <mapping> <class name=\"Foo\"> <field name=\"size\" type=\"integer\"> <bind-xml node=\"element\"/> </field> <field name=\"name\" type=\"string\"/> <field name=\"color\" type=\"string\" handler=\"ColorHandler\"/> </class> </mapping>\n\nWe can now use our custom FieldHandler to unmarshal the following xml input:\n\n<?xml version=\"1.0\"?> <foo> <name>MyFoo</name> <size>345</size> <color>blue</color> </foo>\n\nA sample test class is as follows:\n\nimport java.io.*; import org.exolab.castor.xml.*; import org.exolab.castor.mapping.*; public class Test { public static void main(String[] args) { try { Mapping mapping = new Mapping(); mapping.loadMapping(\"mapping.xml\"); System.out.println(\"unmarshalling Foo:\"); System.out.println(); Reader reader = new FileReader(\"test.xml\"); Unmarshaller unmarshaller = new Unmarshaller(Foo.class); unmarshaller.setMapping(mapping); Foo foo = (Foo) unmarshaller.unmarshal(reader); reader.close(); System.out.println(\"Foo#size : \" + foo.getSize()); System.out.print(\"Foo#color: \"); if (foo.getColor() == null) { System.out.println(\"null\"); } else { System.out.println(foo.getColor().toString()); } PrintWriter pw = new PrintWriter(System.out); Marshaller marshaller = new Marshaller(pw); marshaller.setMapping(mapping); marshaller.marshal(foo); pw.flush(); } catch (Exception e) { e.printStackTrace(); } } }\n\n1.7.7. Collections and FieldHandlers\n\nIf you're going to be using custom field handlers for collection fields with a GeneralizedFieldHandler using versions of Castor prior to 0.9.6, then you'll need to handle the collection iteration yourself in the convertUponGet method.\n\nIf you're not using a GeneralizedFieldHandler, then you'll need to handle the collection iteration yourself in the FieldHandler#getValue() method.\n\n2.6. XML schema support\n\nCastor XML supports the W3C XML Schema 1.0 Second Edition Recommendation document (10/28/2004) The Schema Object Model (located in the package org.exolab.castor.xml.schema) provides an in-memory representation of a given XML schema whereas the XML code generator provides a binding between XML schema data types and structures into the corresponding ones in Java.\n\nThe Castor Schema Object Model can read (org.exolab.castor.xml.schema.reader) and write (org.exolab.castor.xml.schema.writer) an XML Schema as defined by the W3C recommandation. It allows you to create and manipulate an in-memory view of an XML Schema.\n\nThe Castor Schema Object Model supports the W3C XML Schema recommendation with no limitation. However the Source Generator does currently not offer a one to one mapping from an XML Schema component to a Java component for every XML Schema components; some limitations exist. The aim of the following sections is to provide a list of supported features in the Source Generator. Please keep in mind that the Castor Schema Object Model again can handle any XML Schema without limitations.\n\nSome Schema types do not have a corresponding type in Java. Thus the Source Generator uses Castor implementation of these specific types (located in the org.exolab.castor.types package). For instance the duration type is implemented directly in Castor. Remember that the representation of XML Schema datatypes does not try to fit the W3C XML Schema specifications exactly. The aim is to map an XML Schema type to the Java type that is the best fit to the XML Schema type.\n\nYou will find next a list of the supported XML Schema data types and structures in the Source Code Generator. For a more detailed support of XML Schema structure and more information on the Schema Object Model, please refer to Source Generator User Document (PDF).\n\n2.6.1. Supported XML Schema Built-in Datatypes\n\nThe following is a list of the supported datatypes with the corresponding facets and the Java mapping type.\n\n2.6.1.1. Primitive Datatypes\n\nTable 2.15. Supported primitive data types\n\nXML Schema TypeSupported FacetsJava mapping typeanyURIenumerationjava.lang.Stringbase64Binarybyte[]booleanpattern boolean or java.lang.Boolean[ ] dateenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[ ]org.exolab.castor.types.DatedateTimeenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b] java.util.Datedecimal totalDigits, fractionDigits, pattern, whiteSpace, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] java.math.BigDecimaldoubleenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b] double or java.lang.Double[c] durationenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.Durationfloatenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b] float or java.lang.Float[c] gDayenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.GDaygMonthenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.GMonthgMonthDayenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.GMonthDaygYearenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.GYeargYearMonthenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.GYearMonthhexBinarybyte[]QNamelength, minLength, maxLength, pattern, enumerationjava.lang.Stringstringlength, minLength, maxLength, pattern, enumeration, whiteSpacejava.lang.Stringtimeenumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, pattern, whitespace[b]org.exolab.castor.types.Time\n\n2.6.1.2. Derived Datatypes\n\nTable 2.16. Supported derived data types\n\nTypeSupported FacetsJava mapping typebytetotalDigits, fractionDigits[ ], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[ ] byte/java.lang.Byte [ ] ENTITYNot implementedENTITIESNot implementedIDenumerationjava.lang.StringIDREFjava.lang.ObjectIDREFSjava.util.Vector of java.lang.ObjectinttotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] int/java.lang.Integer[c] integertotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] long/java.lang.Long[c] languagelength, minLength, maxLength, pattern, enumeration, whiteSpace treated as a xsd:string[ ] longtotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] long/java.lang.Long[c] NameNot implementedNCNameenumerationjava.lang.StringnegativeIntegertotalDigits, fractionDigits[ ], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] long/java.lang.Long[c] NMTOKENenumeration, length, maxlength, minlengthjava.lang.StringNMTOKENSjava.util.Vector of java.lang.StringNOTATIONNot implementednonNegativeIntegertotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] long/java.lang.Long[c] nonPositiveIntegertotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] long/java.lang.Long[c] normalizedStringenumeration, length, minLength, maxLength, patternjava.lang.StringpositiveIntegertotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] long/java.lang.Long[c] shorttotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] short/java.lang.Short[c] tokenlength, minLength, maxLength, pattern, enumeration, whiteSpace treated as a xsd:string[d], unsignedBytetotalDigits, fractionDigits[a], maxExclusive, minExclusive, maxInclusive, minInclusive, pattern, whitespace[b] short/java.lang.Short[c] unsignedInttotalDigits, fractionDigits[a], maxExclusive, minExclusive, maxInclusive, minInclusive, pattern, whitespace[b] long/java.lang.Long[c] unsignedLongtotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] java.math.BigIntegerunsignedShorttotalDigits, fractionDigits[a], pattern, enumeration, maxInclusive, maxExclusive, minInclusive, minExclusive, whitespace[b] int or java.lang.Integer[c]\n\n2.6.2. Supported XML Schema Structures\n\nSupporting XML schema structures is a constant work. The main structures are already supported with some limitations. The following will give you a rough list of the supported structures. For a more detailed support of XML Schema structure in the Source Generator or in the Schema Object Model, please refer to Source Generator User Document (PDF).\n\nSupported schema components:\n\nAttribute declaration (<attribute>)\n\nElement declaration (<element>)\n\nComplex type definition (<complexType>)\n\nAttribute group definition (<attributeGroup>)\n\nModel group definition (<group>)\n\nModel group (<all>, <choice> and <sequence>)\n\nAnnotation (<annotation>)\n\nWildcard (<any>)\n\nSimple type definition (<simpleType>)\n\n2.6.2.1. Groups\n\nGrouping support covers both model group definitions (<group>) and model groups (<all>, <choice> and <sequence>). In this section we will label as a 'nested group' any model group whose first parent is another model group.\n\nFor each top-level model group definition, a class is generated either when using the 'element' mapping property or the 'type' one.\n\nIf a group -- nested or not -- appears to have maxOccurs > 1 , then a class is generated to represent the items contained in the group.\n\nFor each nested group, a class is generated. The name of the generated class will follow this naming convention: Name,Compositor+,Counter? where\n\n'Name' is name of the top-level component (element, complexType or group).\n\n'Compositor' is the compositor of the nested group. For instance, if a 'choice' is nested inside a sequence, the value of Compositor will be SequenceChoice ('Sequence'+'Choice'). Note: if the 'choice' is inside a Model Group and that Model Group parent is a Model Group Definition or a complexType then the value of'Compositor' will be only 'Choice'.\n\n'Counter' is a number that prevents naming collision.\n\n2.6.2.2. Wildcard\n\n<any> is supported and will be mapped to an AnyNode instance. However, full namespace validation is not yet implemented, even though an AnyNode structure is fully namespace aware.\n\n<anyAttribute> is currently not supported. It is a work in progress.\n\n3.4. Castor JDO - Configuration\n\nCastor JDO allows for two simple ways of specifying its required configuration, e.g. by the means of supplying Castor JDO with an XML-based configuration file, and by specifying its configuration programmatically via the org.exoalb.castor.util.jdo.JDOConfFactory class.\n\n3.4.1. The Castor configuration file\n\nThe default way to configure how Castor interacts with a specific database system is by using a configuration file. It specifies the means to obtain a connection to the database server, the mapping between Java classes and tables in that database server, and the service provider to use for talking to that server (For a more flexible, programmatic way without configuration files see section JDOConfFactory).\n\nThe application will access the database(s) by its given name (database/name) and will be able to persist all objects specified in the included mapping file(s).\n\nThe engine attribute specifies the persistence engine for this database server. Different database servers vary in the SQL syntax and capabilites they support, and this attribute names the service provider to use.\n\nThe following names are supported in Castor:\n\nTable 3.1. Supported engine names\n\nengine nameRDBMSdb2DB/2derbyDerbygenericGeneric JDBC supporthsqlHypersonic SQLinformixInformixinstantdbInstantDBinterbaseInterbasemysqlMySQLoracleOracle 7 - Oracle 9ipostgresqlPostgreSQL 7.1sapdbSAP DB / MaxDBsql-serverMicrosoft SQL ServersybaseSybase 11pointbaseBorland PointbaseprogressProgress RDBMS\n\nThe means to acquire a database connection is specified in one of three ways: as a JDBC driver URL, as a JDBC DataSource, or as a DataSource to lookup through JNDI. When Castor is used inside a J2EE application server it is recommended to use JNDI lookup (see the jndi element), allowing the application server to manage connection pooling and distributed transactions.\n\nThe class mapping is included from an external mapping file, allowing multiple mappings to be included in the same database configuration, or two databases to share the same mappings. For concurrency and integrity reasons, two database configurations should never attempt to use overlapping mappings. It is recommended to use one database configuration per database server.\n\nThe mapping file is specified using a URL, typically a file: URL. If the database configuration file and mapping file reside in the same directory, use a relative URL. Relative URLs also work if the database configuration and mapping files are obtained from the application JAR and reside in the same classpath.\n\nThe driver element specifies the JDBC driver for obtaining new connections to the database server. The driver is obtained from the JDBC DriverManager and must be located in the class path. The JDBC URL locates the driver and provides the access properties. Additional properties may be specified using param elements (e.g. buffer size, network protocol, etc).\n\nUse the class-name attribute to specify the driver class for automatic registration with the JDBC DriverManager. If missing, the driver must be registered in any other means, including properties file, Class.forName(), etc.\n\nFor example, to configure an Oracle 8 thin driver, use:\n\n<jdo-conf> <database name=\"ebiz\" engine=\"oracle\"> <driver class-name=\"oracle.jdbc.driver.OracleDriver\" url=\"jdbc:oracle:thin:@host:port:SID\"> <param name=\"user\" value=\"scott\" /> <param name=\"password\" value=\"tiger\" /> </driver> ... </database> ... </jdo-conf>\n\nThe data-source element specifies the JDBC DataSource for obtaining new connections to the database server. DataSources are defined in the JDBC 2.0 standard extension API which is included with Castor, and implement the interface javax.sql.DataSource.\n\nThe DataSource implementation class name is specified by the class-name attribute and configured through Bean-like accessor methods specified for the param element. The DTD for the param element is undefined and depends on the DataSource being used.\n\nFor example, to configure a PostgreSQL 7.1 DataSource, use:\n\n<jdo-conf> <database name=\"ebiz\" engine=\"oracle\"> <data-source class-name=\"org.postgresql.PostgresqlDataSource\"> <param name=\"serverName\" value=\"host\" /> <param name=\"portNumber\" value=\"5432\" /> <param name=\"databaseName\" value=\"db\" /> <param name=\"user\" value=\"user\" /> <param name=\"password=\" value=\"secret\" /> </data-source> ... </database> ... </jdo-conf>\n\nThe jndi element specifies the JDBC DataSource for obtaining new connections to the database server through a JNDI lookup. The JNDI environment naming context (ENC) is used to obtain a suitable DataSource..\n\nWhen running inside a J2EE application server, this is the preferred method for obtaining database connections. It enables the J2EE application server to configure the connection, maintain a connection pool, and manage distributed transactions.\n\nFor example, to specify a J2EE DataSource, use:\n\n<jdo-conf> <database name=\"ebiz\" engine=\"oracle\"> <jndi name=\"java:comp/env/jdbc/mydb\" /> </database> ... </jdo-conf>\n\n3.4.1.1. Transaction demarcation\n\nAs opposed to release pre 0.9.6, transaction demarcation is now configured in the JDO configuration file. As such, the user has to specify which transaction demarcation to use. Transactions when used with Castor JDO can either be local or global, and you instruct Castor to use a specific mode by supplying a <transaction-demarcation> element.\n\n3.4.1.1.1. Local Mode\n\nWhen using Castor JDO stand-alone and you want Castor to control transaction demarcation, please use the <transaction-demarcation> element as follows:\n\n<transaction-demarcation mode=\"local\" />\n\n3.4.1.1.2. Global Mode\n\nWhen running inside a J2EE application server, and you want to use global (XA) transactions, please make use the <transaction-demarcation> element as follows:\n\n<transaction-demarcation mode=\"global\"> <transaction-manager name=\"jndi\" /> </transaction-demarcation>\n\nIn this mode, the <transaction-manager> element specifies the transaction manager that is used by your J2EE container to control these transactions.\n\nThe following transaction managers are supported in Castor:\n\nTable 3.2. Supported transaction managers\n\nNameDescriptionjndiTM looked up in the JNDI ENCwebsphereIBM WebSphere 4 and previous releaseswebsphere5IBM WebSphere 5websphere51IBM WebSphere 5.1jotmJOTMatomikosAtomikos\n\nIn addition to specifying the transaction manager name, it is possible to pass arbitrary name/value pairs to the transaction manager instance.\n\n<transaction-demarcation mode=\"global\"> <transaction-manager name=\"jndi\"> <param name=\"jndiEnc\" value=\"java:comp/env/TransactionManager\"/> </transaction-manager> </transaction-demarcation>\n\n3.4.1.2. Sample Configuration File\n\nThe following configuration file instructs Castor JDO to execute against an Oracle RDBMS using the thin (type 4) JDBC driver, and refers to three mapping files that define mappings for product, order and customer related data.\n\n<?xml version=\"1.0\"?> <jdo-conf name=\"order-system\"> <database name=\"ebiz\" engine=\"oracle\"> <driver class-name=\"oracle.jdbc.driver.OracleDriver\" url=\"jdbc:oracle:thin:@machine:post:SID\"> <param name=\"user\" value=\"scott\"/> <param name=\"password\" value=\"tiger\"/> </driver> <mapping href=\"products.xml\"/> <mapping href=\"orders.xml\"/> <mapping href=\"customers.xml\"/> </database> <transaction-demarcation mode=\"local\"/> </jdo-conf>\n\nThe following configuration file uses a connection obtained from the J2EE application server and a single mapping file:\n\n<?xml version=\"1.0\"?> <jdo-conf> <database name=\"ebiz\" engine=\"oracle\"> <jndi name=\"java:comp/env/jdbc/mydb\"/> <mapping href=\"ebiz.xml\"/> </database> <transaction-demarcation mode=\"global\"> <transaction-manager name=\"jndi\"> <param name=\"jndiEnc\" value=\"java:comp/env/TransactionManager\"/> </transaction-manager> </transaction-demarcation> </jdo-conf>\n\n3.4.1.3. Prepared statement pooling\n\nCastor JDO uses JDBC prepared statements to execute SQL statements against the specified RDBMS of your choice. Per definition, Castor JDO does not provide any prepared statement pooling. As such, Castor relies on prepared statement pooling being provided by different means.\n\nOne such way is to use Jakarta's Commons DBCP as database connection pool, and to turn prepared statement pooling on by configuring DBCP accordingly.\n\nPlease check with Using Pooled Database Connections for general information about hot to use DBCP with Castor.\n\n3.4.1.4. Sample configurations for various databases\n\nBesides the examples listed above, more configuraton examples can be found in the configuration files for the Castor JDO tests, which can be found in src/tests/jdo once you have downloaded and expanded the Castor source package. For each database (vendor) supported, you are going to find a database-specific JDO configuration file in this directory, e.g. src/tests/jdo/mysql.xml for mySQL™ or src/tests/jdo/oracle.xml for Oracle™.\n\n3.4.1.4.1. Sybase JConnect (JDBC data source)\n\n... < > <data-source class-name=\"com.sybase.jdbc2.jdbc.SybDataSource\"> <param name=\"user\" value=\"user\" /> <param name=\"password value=\"secret\" /> <param name=\"portNumber\" value=\"4100\" /> <param name=\"serverName\" value=\"host\" /> </data-source> ...\n\n3.4.1.4.2. PostgreSQL (JDBC data source)\n\n... < > <data-source class-name=\"org.postgresql.PostgresqlDataSource\"> <param name=\"serverName\" value=\"host\" /> <param name=\"portNumber\" value=\"5432\" /> <param name=\"databaseName\" value=\"db\" /> <param name=\"user\" value=\"user\" /> <param name=\"password\" value=\"secret\" /> </data-source> ...\n\n3.4.1.4.3. Oracle (JDBC Driver)\n\n... < > <driver class-name=\"oracle.jdbc.driver.OracleDriver\" url=\"jdbc:oracle:thin:@host:post:SID\"> <param name=\"user\" value=\"scott\" /> <param name=\"password\" value=\"tiger\" /> </driver> ...\n\n3.4.1.4.4. mySQL (JDBC Driver)\n\n... < > <driver class-name=\"com.mysql.jdbc.Driver\" url=\"jdbc:mysql:/localhost:2206/test\"> <param name=\"user\" value=\"scott\" /> <param name=\"password\" value=\"tiger\" /> </driver> ...\n\n3.4.1.4.5. InstantDB\n\n... < > <driver class-name=\"org.enhydra.instantdb.jdbc.idbDriver\" url=\"jdbc:idb:C:\\\\castor-1.0\\\\db\\\\test\\\\test.prp\"> <param name=\"user\" value=\"\" /> <param name=\"password\" value=\"\" /> </driver> ...\n\n3.4.2. JDOConfFactory - A programmatic way of configuring Castor JDO\n\nMany applications need to connect to a database using varying user accounts or database instances. To accomplish this, the utility class org.exolab.castor.jdo.util.JDOConfFactory\">JDOConfFactory and a JDOManager.loadConfiguration(org.exolab.castor.jdo.conf.JdoConf) method has been added to Castor.\n\nThe following code snippet shows an example how to create a JDO configuration without the use of a default XML-based database configuration file:\n\nprivate static final String DRIVER = \"oracle.jdbc.driver.OracleDriver\"; private static final String CONNECT = \"jdbc:oracle:thin:localhost:1521:SID\"; private static final String USERNAME = \"scott\"; private static final String PASSWORD = \"tiger\"; private static final String MAPPING = \"mapping.xml\"; private static final String DATABASE = \"mydb\"; private static final String ENGINE = \"oracle\"; org.castor.jdo.conf.Driver driverConf = JDOConfFactory.createDriver(DRIVER, CONNECT, USERNAME, PASSWORD); org.castor.jdo.conf.Mapping mappingConf = JDOConfFactory.createMapping(getClass().getResource(MAPPING).toString()); org.castor.jdo.conf.Database dbConf = JDOConfFactory.createDatabase(DATABASE, ENGINE, driverConf, mappingConf); JDOManager.loadConfiguration(JDOConfFactory.createJdoConf(dbConf)); jdoManager = JDOManager.createInstance(DATABASE); Database db = jdoManager.getDatabase();\n\nAs an alternative to using a org.exolab.castor.jdo.conf.Driver, you can also configure Castor to use a JDBC 2.0 DataSource:\n\nprivate static final String DS = \"oracle.jdbc.pool.OracleConnectionCacheImpl\"; private static final String CONNECT = \"jdbc:oracle:thin:localhost:1521:SID\"; private static final String USERNAME = \"scott\"; private static final String PASSWORD = \"tiger\"; private static final String MAPPING = \"mapping.xml\"; private static final String DATABASE = \"mydb\"; private static final String ENGINE = \"oracle\"; Properties props = new Properties(); props.put(\"URL\", CONNECT); props.put(\"user\", USERNAME); props.put(\"password\", PASSWORD); org.castor.jdo.conf.DataSource dsConf = JDOConfFactory.createDataSource(DS, props); org.castor.jdo.conf.Mapping mappingConf = JDOConfFactory.createMapping(getClass().getResource(MAPPING).toString()); org.castor.jdo.conf.Database dbConf = JDOConfFactory.createDatabase(DATABASE, ENGINE, dsConf, mappingConf); JDOManager.loadConfiguration(JDOConfFactory.createJdoConf(dbConf)); jdoManager = JDOManager.createInstance(DATABASE); Database db = jdoManager.getDatabase();\n\n3.4.3. References\n\n3.4.3.1. The JDO Configuration DTD\n\nFor validation, the configuration file should include the following document type definition. For DTD validation use:\n\n<!DOCTYPE jdo-conf PUBLIC \"-//EXOLAB/Castor JDO Configuration DTD Version 1.0//EN\" \"http://castor.org/jdo-conf.dtd\">\n\nFor XML Schema validation use:\n\n<!DOCTYPE jdo-conf PUBLIC \"-//EXOLAB/Castor JDO Configuration Schema Version 1.0//EN\" \"http://castor.org/jdo-conf.xsd\">\n\nThe Castor namespace URI is http://castor.org/.\n\nThe Castor JDO database configuration DTD is:\n\n<!ELEMENT jdo-conf ( database+, transaction-demarcation )> <!ATTLIST jdo-conf name CDATA \"jdo-conf\"> <!ELEMENT database ( ( driver | data-source | jndi )?, mapping+ )> <!ATTLIST database name ID #REQUIRED engine CDATA \"generic\"> <!ELEMENT mapping EMPTY> <!ATTLIST mapping href CDATA #REQUIRED> <!ELEMENT driver ( param* )> <!ATTLIST driver url CDATA #REQUIRED class-name CDATA #REQUIRED> <!ELEMENT data-source ( param* )> <!ATTLIST data-source class-name CDATA #REQUIRED> <!ELEMENT jndi ANY> <!ATTLIST jndi name CDATA #REQUIRED> <!ELEMENT transaction-demarcation ( transaction-manager? )> <!ATTLIST transaction-demarcation mode CDATA #REQUIRED> <!ELEMENT transaction-manager ( param* )> <!ATTLIST transaction-manager name CDATA #REQUIRED> <!ELEMENT param EMPTY> <!ATTLIST param name CDATA #REQUIRED value CDATA #REQUIRED>\n\n3.5. Type Support\n\n3.5.1. Types\n\nThe Castor type mechanism assures proper conversion between Java types and external types.\n\n3.5.1.1. Castor XML\n\nCastor XML converts all Java fields into XML element and attribute values.\n\n3.5.1.2. Castor JDO\n\nCastor JDO converts Java fields into SQL columns which are persisted through the JDBC driver. Due to implementation details, the field type expected by the JDBC driver is not always the field type defined for the mapped object.\n\nThe most common occurrences of mistyping is when using fields of type FLOAT, DOUBLE, NUMERIC, and DECIMAL. SQL type FLOAT actually maps to Java type java.lang.Double. SQL types NUMERIC and DECIMAL map to Java type java.math.BigDecimal.\n\nWhen such an inconsistency occurs, Castor JDO will throw an IllegalArgumentException during object persistence with a message indicating the two conflicting types.\n\nIn order to avoid runtime exceptions, we recommend explicitly specifying types in the mapping file using the SQL typing convention. See SQL Type Conversion.\n\n3.5.1.3. Castor DAX\n\nCastor DAX converts all Java fields into LDAP attribute values. LDAP attribute values are always textual and are represented as the string value of the field, e.g. \"5\" or \"true\".\n\nLDAP attributes may also contain binary values. When storing byte arrays or serialized Java objects, DAX will store them as byte arrays.\n\n3.5.2. The Field Mapping\n\nThe field element includes an optional attribute called type which can be used to specify the Java type of the field. This attribute is optional since Castor can always derive the exact Java type from the class definition.\n\nWe highly recommend that developers use the type field in their mapping file as a means to provide static type checking. When loading a mapping file, Castor will compare the actual Java type with the type specified in the mapping and will complain about inconsistencies.\n\nThe field type can be specified either given the full class name (e.g. java.lang.Integer) or using a short name. The following table lists all the acceptable short names and the Java types they represent:\n\nTable 3.3. Acceptable short names\n\nshort namePrimitive type?Java Classbig-decimalNjava.math.BigDecimalbooleanYjava.lang.Boolean.TYPEbyteYjava.lang.Byte.TYPEbytesNbyte[]charYjava.lang.Character.TYPEcharsNchar[]clobNjava.sql.ClobdateNjava.util.DatedoubleYjava.lang.Double.TYPEfloatYjava.lang.Float.TYPEintegerYjava.lang.Integer.TYPElocaleNjava.util.LocalelongYjava.lang.Long.TYPEotherNjava.lang.ObjectshortYjava.lang.Short.TYPEstringNjava.lang.StringstringsNString[]streamNjava.io.InputStream\n\nIn addition, support for the following Castor-internal field types has been added:\n\nTable 3.4. Castor-internal field types\n\nshort namePrimitive type?Java ClassdurationNorg.exolab.castor.types.Duration\n\n3.5.3. SQL Dates and Default Timezones\n\nCastor will use the JDBC ResultSet.getDate(int, Calendar) and related methods which take a Calendar object to specify the timezone of the data retrieved from the database when the timezone information is not already specified in the data; this ensures that the \"current\" timezone is applied.\n\nThe default time zone can be configured in the castor.properties file; see the configuration section for details on how to configure Castor with information about your default time zone.\n\nTo change the timezone to a different timezone than the default, please set a (different) value on the org.exolab.castor.jdo.defaultTimeZone property:\n\n# Default time zone to apply to dates/times fetched from database fields, # if not already part of the data. Specify same format as in # java.util.TimeZone.getTimeZone, or an empty string to use the computer's # local time zone. org.exolab.castor.jdo.defaultTimeZone= #org.exolab.castor.jdo.defaultTimeZone=GMT+8:00\n\n3.5.4. SQL Type Conversion\n\nCastor JDO uses the JDBC getObject/setObject methods in order to retrieve and set fields. These methods do not perform automatic type conversion, often resulting in unexpected behavior. For example, when using a NUMERIC field with direct JDBC access, application developers tend to call getInteger() or getFloat(), but the Java object returned from a call to getObject is often a java.math.BigDecimal.\n\nCastor JDO implements automatic type conversion between Java and SQL. For this mechanism to work, the mapping file must specify the SQL type being used for Castor to employ the proper convertor. If no SQL type is specified, no conversion will occur, possibly resulting in an IllegalArgumentException being thrown.\n\nSQL types are specified with the sql-type attribute using either the default Java type returned by the JDBC driver (e.g. java.lang.Integer or the proper SQL type name (without precision). The following table lists the supported SQL type names and the corresponding Java types:\n\nTable 3.5. Supported SQL type names\n\nSQL TypeJava Typebigintjava.lang.Longbinarybyte[]bitjava.lang.Booleanblobjava.io.InputStreamcharjava.lang.Stringclobjava.sql.Clobdecimaljava.math.BigDecimaldoublejava.lang.Doublefloatjava.lang.Doubleintegerjava.lang.Integerlongvarbinarybyte[]longvarcharjava.lang.Stringnumericjava.math.BigDecimalrealjava.lang.Floatsmallintjava.lang.Shorttimejava.sql.Timetimestampjava.sql.Timestamptinyintjava.lang.Bytevarbinarybyte[]varcharjava.lang.Stringotherjava.lang.Objectjavaobjectjava.lang.Object\n\nThe following example illustrates how to specify SQL type in field mapping:\n\n<field name=\"prodId\" type=\"integer\"> <sql name=\"prod_id\" type=\"numeric\"/> </field>\n\nPlease note that java.util.Date is not automatically converted into a java.sql.Date object; while it is in theory possible to do so, there are three different possible storage formats for date information: as a java.sql.Date, java.sql.Time, and java.sql.Timestamp. Rather than impose a possibly inappropriate data mapping on an entry, no automatic transformation will take place.\n\nJDBC drivers which do not, themselves, perform a mapping between java.util.Date and the sql format specified on the database will throw an error when java.util.Date is passed to them on the prepared statement. Moreover, auto-conversion of java.util.Date is outside of the JDBC specification; it is not a supported auto-convert format.\n\nUsers wishing to store date information into the database should ensure that they set date, time, or timestamp as the sql type on the sql-type attribute.\n\n3.5.5. Parameterized Type Convertors\n\nSome of the type convertors may have a string parameter, which changes the conversion algorithm. The parameter is specified in square brackets after the SQL type, for example:\n\n<field name=\"active\" type=\"boolean\"> <sql name=\"acc_active\" type=\"char[01]\"/> </field>\n\nwhere \"0\" is the character value for false and \"1\" is the character value for true.\n\nIn the above example the first of a bunch of parameterized type convertors is used, \"boolean --> char\" convertor. The parameter must have length 2, the first character is the value for false, the second character is the value for true. The default value is \"FT\". The actual SQL type should be char(1).\n\nThe second and third convertors are \"boolean --> integer\" and \"boolean --> numeric\". Its parameter must be + for +1 or - for -1 representing true. False is always converted to 0. For example:\n\n<field name=\"flagWithMinusOneForTrue\" type=\"boolean\"> <sql name=\"flag\" type=\"integer[-]\"/> </field>\n\nIf the parameter is not specified, true is converted to +1.\n\nThe fourth convertor is \"date --> char\". Its parameter must be a correct pattern for SimpleDateFormat. For example:\n\n<field name=\"dateOfBirth\" type=\"date\"> <sql name=\"pers_dob\" type=\"char[MMM d, yyyy]\"/> </field>\n\nIf the parameter is not specified, the conversion is performed using toString() method of the Date class.\n\nThe fifth and the sixth convertors are \"date --> integer\" and \"date --> numeric\". Their parameters are also patterns having syntax based on the SimpleDateFormat syntax, but repeated characters are eliminated. The following table shows the substitution rules that are used to obtain the SimpleDateFormat pattern from the parameter.\n\nTable 3.6. Substitution rules\n\nY,yyyyyyearMMMmonth in yearD,dddday in monthh,HHHhour in day (0~23)mmmminute in hourssssecond in minuteSSSSmillisecond\n\nFor example, \"YMD\" parameter is expanded to \"yyyyMMdd\" SimpleDateFormat pattern, \"YMDhmsS\" parameter is expanded to \"yyyyMMddHHmmssSSS\" SimpleDateFormat pattern. The length of the expanded parameter gives the minimal number of decimal digits that the actual SQL type must support. The default value of the parameter is \"YMD\".\n\nThe date and time types of org.exolab.castor.types package support 2 timelines as defined by XML schema specification. One for timezoned values and one for non-timezoned values which are treated to be local. When converting such types to long the timezone information is lost. In most cases it is no problem to loose for which timezone the value was specified if the value get converted to UTC time before. But we also loose if the value had a timezone or not. This causes that we do not know to which timeline the value belongs. If we just treat it as non-timezoned value while it has been a timezoned one we have changed the value.\n\nTherefore we have added support for another parameterized type converter. This one allows you to specify if the date and time values created out of a persisted long value are meant to be timezoned or not. By default, without a parameter, local date or time instances are created without a timezone. If you specify the parameter utc in mapping the date or time values are created based on UTC timezone. It need to be noted that such a mapping can only handle date and time values of one of the 2 timelines defined by XML schema specification. Having said that this only applies to the conversion of such values to long and does not cause issues when converting to string and back.\n\n<field name=\"timeOfBirth\" type=\"org.exolab.castor.types.Time\"> <sql name=\"pers_tob\" type=\"bigint[utc]\"/> </field>\n\n3.5.6. BLOB and CLOB Types\n\nBLOB and CLOB stand for binary and character large objects (or in Sybase, IMAGE and TEXT types, respectively). This means that most likely you don't want to load the whole objects into memory, but instead want to read and write them as streams. Usually these types are not comparable via the WHERE clause of a SQL statement. That is why you should disable dirty checking for such fields, e.g.\n\n<field name=\"text\" type=\"string\"> <sql name=\"text\" type=\"clob\" dirty=\"ignore\" /> </field>\n\nIn this example CLOB field will be read as a String. This may cause OutOfMemoryError if the text is really large, but in many cases mapping CLOB to String is acceptable. The advantage of mapping to String is that we obtain a Serializable value that can be passed via RMI. Similarly you can map BLOB and CLOB to byte[] and char[] types, respectively:\n\n<field name=\"photo\" type=\"bytes\"> <sql name=\"photo\" type=\"blob\" dirty=\"ignore\" /> </field> <field name=\"resume\" type=\"chars\"> <sql name=\"resume\" type=\"clob\" dirty=\"ignore\" /> </field>\n\nNow, assume that mappi"
    }
}