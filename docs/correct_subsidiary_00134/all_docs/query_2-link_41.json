{
    "id": "correct_subsidiary_00134_2",
    "rank": 41,
    "data": {
        "url": "https://www.readkong.com/page/oracle-fusion-middleware-securing-oracle-coherence-12c-9960128",
        "read_more_link": "",
        "language": "en",
        "title": "Oracle Fusion Middleware - Securing Oracle Coherence - 12c (12.2.1.4.0)",
        "top_image": "https://www.readkong.com/static/b7/d8/b7d8baf3b7466f9a73854e308d2786e0/thumb-4.jpg",
        "meta_img": "https://www.readkong.com/static/b7/d8/b7d8baf3b7466f9a73854e308d2786e0/thumb-4.jpg",
        "images": [
            "https://www.readkong.com/img/logo.png",
            "https://www.readkong.com/static/b9/3a/b93ae55b579b8f7f8636fda8604569c0/thumb-4.jpg",
            "https://www.readkong.com/static/08/2e/082ef7ba114dfb1f1b89aa19aaddd0e3/thumb-4.jpg",
            "https://www.readkong.com/static/e5/55/e555344467206e3c94ea9796423d0220/thumb-4.jpg",
            "https://www.readkong.com/static/17/ad/17adddc67344a3f28a4e0fef74acc546/thumb-4.jpg",
            "https://www.readkong.com/static/72/f2/72f2fe2a040f66b6bf615c35964c021d/thumb-4.jpg",
            "https://www.readkong.com/static/d8/70/d870a1a02e6d313549c99bec973dcf25/thumb-4.jpg",
            "https://www.readkong.com/static/06/a5/06a5d4c56f6e4e2a4cccd591ec5d9c30/thumb-4.jpg",
            "https://www.readkong.com/static/34/00/3400ea3eb585b4ac16bb03443b175654/thumb-4.jpg",
            "https://www.readkong.com/static/1d/89/1d895ec7f2c3ede70d1ee87ca5aee402/thumb-4.jpg",
            "https://www.readkong.com/static/1d/b3/1db33c09d09bc52cef09ec4bfe351e0e/thumb-4.jpg",
            "https://www.readkong.com/static/10/50/105003086b7c719d54cd99ef53a89d1f/thumb-4.jpg",
            "https://www.readkong.com/static/95/47/954756cc4488f7c8390040b5ba831c29/thumb-4.jpg",
            "https://www.readkong.com/static/ea/4d/ea4d911d2d49204ccb067fa98684c0dd/thumb-4.jpg",
            "https://www.readkong.com/static/ac/e2/ace223d52c950dc5bbabdabff15dbb41/thumb-4.jpg",
            "https://www.readkong.com/static/2f/a3/2fa31ae5a27df8c97e1cfcfa40100ba3/thumb-4.jpg",
            "https://www.readkong.com/static/c4/7d/c47de3c73401b581bd837f416d4ec1aa/thumb-4.jpg",
            "https://www.readkong.com/static/69/26/69261255d13998f836693940e6734543/thumb-4.jpg",
            "https://www.readkong.com/static/d8/d3/d8d3929cd0e6d5cf030c9db2d439ae6b/thumb-4.jpg",
            "https://www.readkong.com/static/37/e9/37e91e244551c848ab68e277fac9f051/thumb-4.jpg",
            "https://www.readkong.com/static/3e/9e/3e9e846438f3d1af64789efa465d65a4/thumb-4.jpg",
            "https://www.readkong.com/static/53/b7/53b75c13a2fc96ffa734ee7b23983c46/thumb-4.jpg",
            "https://www.readkong.com/static/bf/50/bf5022a8ae97003adb876a353c3d2659/thumb-4.jpg",
            "https://www.readkong.com/static/4e/b0/4eb05714310865c3ca2be9dd55a0f9c4/thumb-4.jpg",
            "https://www.readkong.com/static/30/93/3093c31e1d8e68aa6b3f74f7c6f7b85e/thumb-4.jpg",
            "https://www.readkong.com/static/ed/86/ed8635cbea3dcef3f1b4ce189e42f16c/thumb-4.jpg",
            "https://www.readkong.com/static/c3/81/c381e126ab0480bc58b986559408f8a7/thumb-4.jpg",
            "https://www.readkong.com/static/f8/21/f821dab9940f6f9a1502d5240fb69487/thumb-4.jpg",
            "https://www.readkong.com/static/61/c9/61c9c6e801381cd759d80e439cf4b3de/thumb-4.jpg",
            "https://www.readkong.com/static/bf/b4/bfb4eba5666fd193f861199664604553/thumb-4.jpg",
            "https://www.readkong.com/static/8f/77/8f7762724d7f6670440e41f6113a53c1/thumb-4.jpg",
            "https://www.readkong.com/static/44/ba/44ba99de61dbd02680fb433276e1b7cb/thumb-4.jpg",
            "https://www.readkong.com/static/c1/99/c199e1998f6c08a7f0fcebf11cd6516a/thumb-4.jpg",
            "https://www.readkong.com/static/b0/47/b04746d4505b017d8d40f5d71fb427cf/thumb-4.jpg",
            "https://www.readkong.com/static/25/2e/252e9527e5af2ca5ae16e94673c5731e/thumb-4.jpg",
            "https://www.readkong.com/static/d6/67/d667699651c3380268ec5e3149b59f2b/thumb-4.jpg",
            "https://www.readkong.com/static/0f/39/0f396503e9aa178820e6b0c84ce3de1e/thumb-4.jpg",
            "https://www.readkong.com/static/81/58/8158339c386f90f7f9835b91196b680c/thumb-4.jpg",
            "https://www.readkong.com/static/cb/d0/cbd02a623e6045f9bb5f9e78ce919529/thumb-4.jpg",
            "https://www.readkong.com/static/cd/7b/cd7b6ec64bf940ce8c73952b60775ae3/thumb-4.jpg",
            "https://www.readkong.com/static/c7/fc/c7fcf609802e1501744349f87e16164c/thumb-4.jpg",
            "https://www.readkong.com/static/88/40/8840f36a6d95285327b5ff11eb654a7e/thumb-4.jpg",
            "https://www.readkong.com/static/68/7a/687a34dc70b3635b9a0825886b93ac7a/thumb-4.jpg",
            "https://www.readkong.com/static/6e/ee/6eee7e640e2a0a0ac584af6317e101d3/thumb-4.jpg",
            "https://www.readkong.com/static/4f/d4/4fd4c68cfa0efafa15c8ceaefefabc29/thumb-4.jpg",
            "https://www.readkong.com/static/10/74/107489110bce52bf51cf0bb4ffafcb01/thumb-4.jpg",
            "https://www.readkong.com/static/98/8c/988c6da0d11680185c4219626e92b7b1/thumb-4.jpg",
            "https://www.readkong.com/static/fe/0c/fe0c2f8919b023f32d66e6d6c2bdc068/thumb-4.jpg",
            "https://www.readkong.com/static/fe/3c/fe3c56168fbb6fc111d61ac3c8d92eb0/thumb-4.jpg",
            "https://www.readkong.com/static/c9/ef/c9efff4280443c8a3db6f0c7da0edca2/thumb-4.jpg",
            "https://www.readkong.com/static/1c/07/1c075d09b46c99152256615c1ddce317/thumb-4.jpg",
            "https://www.readkong.com/img/wait.gif",
            "https://c.statcounter.com/11060136/0/d7656383/1/"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Warren Hunt"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Page topic: \"Oracle Fusion Middleware - Securing Oracle Coherence - 12c (12.2.1.4.0)\". Created by: Warren Hunt. Language: english.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.readkong.com/page/oracle-fusion-middleware-securing-oracle-coherence-12c-9960128",
        "text": "Oracle® Fusion Middleware Securing Oracle Coherence 12c (12.2.1.4.0) E90865-03 May 2021\n\nOracle Fusion Middleware Securing Oracle Coherence, 12c (12.2.1.4.0) E90865-03 Copyright © 2008, 2021, Oracle and/or its affiliates. Primary Author: Oracle Corporation This software and related documentation are provided under a license agreement containing restrictions on use and disclosure and are protected by intellectual property laws. Except as expressly permitted in your license agreement or allowed by law, you may not use, copy, reproduce, translate, broadcast, modify, license, transmit, distribute, exhibit, perform, publish, or display any part, in any form, or by any means. Reverse engineering, disassembly, or decompilation of this software, unless required by law for interoperability, is prohibited. The information contained herein is subject to change without notice and is not warranted to be error-free. If you find any errors, please report them to us in writing. If this is software or related documentation that is delivered to the U.S. Government or anyone licensing it on behalf of the U.S. Government, then the following notice is applicable: U.S. GOVERNMENT END USERS: Oracle programs (including any operating system, integrated software, any programs embedded, installed or activated on delivered hardware, and modifications of such programs) and Oracle computer documentation or other Oracle data delivered to or accessed by U.S. Government end users are \"commercial computer software\" or \"commercial computer software documentation\" pursuant to the applicable Federal Acquisition Regulation and agency-specific supplemental regulations. As such, the use, reproduction, duplication, release, display, disclosure, modification, preparation of derivative works, and/or adaptation of i) Oracle programs (including any operating system, integrated software, any programs embedded, installed or activated on delivered hardware, and modifications of such programs), ii) Oracle computer documentation and/or iii) other Oracle data, is subject to the rights and limitations specified in the license contained in the applicable contract. The terms governing the U.S. Government’s use of Oracle cloud services are defined by the applicable contract for such services. No other rights are granted to the U.S. Government. This software or hardware is developed for general use in a variety of information management applications. It is not developed or intended for use in any inherently dangerous applications, including applications that may create a risk of personal injury. If you use this software or hardware in dangerous applications, then you shall be responsible to take all appropriate fail-safe, backup, redundancy, and other measures to ensure its safe use. Oracle Corporation and its affiliates disclaim any liability for any damages caused by use of this software or hardware in dangerous applications. Oracle and Java are registered trademarks of Oracle and/or its affiliates. Other names may be trademarks of their respective owners. Intel and Intel Inside are trademarks or registered trademarks of Intel Corporation. All SPARC trademarks are used under license and are trademarks or registered trademarks of SPARC International, Inc. AMD, Epyc, and the AMD logo are trademarks or registered trademarks of Advanced Micro Devices. UNIX is a registered trademark of The Open Group. This software or hardware and documentation may provide access to or information about content, products, and services from third parties. Oracle Corporation and its affiliates are not responsible for and expressly disclaim all warranties of any kind with respect to third-party content, products, and services unless otherwise set forth in an applicable agreement between you and Oracle. Oracle Corporation and its affiliates will not be responsible for any loss, costs, or damages incurred due to your access to or use of third-party content, products, or services, except as set forth in an applicable agreement between you and Oracle.\n\nContents Preface Audience vii Documentation Accessibility vii Related Documents viii Conventions viii What's New in This Guide New and Changed Features ix Other Significant Changes in This Document x 1 Introduction to Oracle Coherence Security Conceptual Overview of Oracle Coherence Security 1-1 Coherence Security Quick Start 1-2 Overview of Security Configuration 1-2 2 Enabling General Security Measures Using the Java Security Manager 2-1 Enable the Java Security Manager 2-1 Specify Permissions 2-2 Programmatically Specifying Local Permissions 2-2 Using Host-Based Authorization 2-3 Overview of Host-Based Authorization 2-4 Specify Cluster Member Authorized Hosts 2-4 Specify Extend Client Authorized Hosts 2-5 Use a Filter Class to Determine Authorization 2-5 Managing Rogue Clients 2-6 3 Using an Access Controller Overview of Using an Access Controller 3-1 iii\n\nUsing the Default Access Controller Implementation 3-3 Enable the Access Controller 3-4 Create a Keystore 3-4 Include the Login Module 3-4 Create a Permissions File 3-5 Create an Authentication Callback Handler 3-5 Enable Security Audit Logs 3-6 Using a Custom Access Controller Implementation 3-6 4 Authorizing Access to Server-Side Operations Overview of Access Control Authorization 4-1 Creating Access Control Authorization Implementations 4-2 Declaring Access Control Authorization Implementations 4-4 Enabling Access Control Authorization on a Partitioned Cache 4-5 5 Securing Extend Client Connections Using Identity Tokens to Restrict Client Connections 5-1 Overview of Using Identity Tokens 5-1 Creating a Custom Identity Transformer 5-2 Enabling a Custom Identity Transformer 5-3 Creating a Custom Identity Asserter 5-4 Enabling a Custom Identity Asserter 5-4 Using Custom Security Types 5-5 Understanding Custom Identity Token Interoperability 5-5 Associating Identities with Extend Services 5-6 Implementing Extend Client Authorization 5-7 Overview of Extend Client Authorization 5-7 Create Authorization Interceptor Classes 5-8 Enable Authorization Interceptor Classes 5-10 6 Using SSL to Secure Communication Overview of SSL 6-1 Using SSL to Secure TCMP Communication 6-3 Overview of Using SSL to Secure TCMP Communication 6-4 Define an SSL Socket Provider 6-4 Using the Predefined SSL Socket Provider 6-6 Using SSL to Secure Extend Client Communication 6-8 Overview of Using SSL to Secure Extend Client Communication 6-8 Configuring a Cluster-Side SSL Socket Provider 6-9 iv\n\nConfigure an SSL Socket Provider per Proxy Service 6-9 Configure an SSL Socket Provider for All Proxy Services 6-11 Configuring a Java Client-Side SSL Socket Provider 6-12 Configure an SSL Socket Provider per Remote Service 6-12 Configure an SSL Socket Provider for All Remote Services 6-15 Configuring a .NET Client-Side Stream Provider 6-16 Using SSL to Secure Federation Communication 6-17 Encrypting SSL Passwords 6-18 Controlling Cipher Suite and Protocol Version Usage 6-21 Using Host Name Verification 6-22 Using the Default Coherence Host Name Verifier 6-22 Using a Custom Host Name Verifier 6-23 7 Securing Oracle Coherence in Oracle WebLogic Server Overview of Securing Oracle Coherence in Oracle WebLogic Server 7-1 Securing Oracle Coherence Cluster Membership 7-1 Enabling the Oracle Coherence Security Framework 7-2 Specifying an Identity for Use by the Security Framework 7-2 Authorizing Oracle Coherence Caches and Services 7-3 Specifying Cache Authorization 7-3 Specifying Service Authorization 7-4 Securing Extend Client Access with Identity Tokens 7-4 Enabling Identity Transformers for Use in Oracle WebLogic Server 7-5 Enabling Identity Asserters for Use in Oracle WebLogic Server 7-6 8 Securing Oracle Coherence REST Overview of Securing Oracle Coherence REST 8-1 Using HTTP Basic Authentication with Oracle Coherence REST 8-1 Specify Basic Authentication for an HTTP Acceptor 8-1 Specify a Login Module 8-2 Using SSL Authentication With Oracle Coherence REST 8-3 Specify Basic Authentication for an HTTP Acceptor 8-3 Configure an HTTP Acceptor SSL Socket Provider 8-3 Access Secured REST Services 8-5 Using SSL and HTTP Basic Authentication with Oracle Coherence REST 8-7 Implementing Authorization For Oracle Coherence REST 8-8 9 Securing Oracle Coherence HTTP Management Over REST Server About Securing Oracle Coherence HTTP Management Server 9-1 v\n\nBasic Authentication for Coherence HTTP Management Server HTTP Acceptor 9-1 Specify the Basic Authentication for Coherence HTTP Management Server HTTP Acceptor 9-1 Specify a Coherence HTTP Management Server Login Module 9-2 Using SSL Authentication With Oracle Coherence HTTP Management Server 9-2 Configure a Coherence HTTP Management Acceptor SSL Socket Provider 9-3 10 Securing Oracle Coherence Metrics Overview of Securing Oracle Coherence Metrics 10-1 Basic Authentication for Coherence Metrics Http Acceptor 10-1 Specify Basic Authentication for Coherence Metrics HTTP Acceptor 10-1 Specify a Coherence Metrics Login Module 10-1 Specify Basic Authentication for a Coherence Metrics HTTP Client 10-2 Using SSL Authentication With Oracle Coherence Metrics 10-2 Configure a Coherence Metrics HTTP Acceptor SSL Socket Provider 10-2 vi\n\nPreface Securing Oracle Coherence explains key security concepts and provides instructions for implementing various levels of security for Oracle Coherence clusters, Oracle Coherence REST, and Oracle Coherence*Extend clients. This preface includes the following sections: • Audience • Documentation Accessibility • Related Documents • Conventions Audience This guide is intended for the following audiences: • Primary Audience – Application developers and operators who want to secure an Oracle Coherence cluster and secure Oracle Coherence*Extend client communication with the cluster • Secondary Audience – System architects who want to understand the options and architecture for securing an Oracle Coherence cluster and Oracle Coherence*Extend clients The audience must be familiar with Oracle Coherence, Oracle Coherence REST, and Oracle Coherence*Extend to use this guide effectively. In addition, users must be familiar with Java and Secure Socket Layer (SSL). The examples in this guide require the installation and use of the Oracle Coherence product, including Oracle Coherence*Extend. The use of an integrated development environment (IDE) is not required, but it is recommended to facilitate working through the examples. Documentation Accessibility For information about Oracle's commitment to accessibility, visit the Oracle Accessibility Program website at http://www.oracle.com/pls/topic/lookup? ctx=acc&id=docacc. Access to Oracle Support Oracle customers that have purchased support have access to electronic support through My Oracle Support. For information, visit http://www.oracle.com/pls/topic/ lookup?ctx=acc&id=info or visit http://www.oracle.com/pls/topic/lookup?ctx=acc&id=trs if you are hearing impaired. vii\n\nPreface Related Documents For more information, see the following documents in the Oracle Coherence documentation set: • Administering HTTP Session Management with Oracle Coherence*Web • Administering Oracle Coherence • Developing Applications with Oracle Coherence • Developing Remote Clients for Oracle Coherence • Installing Oracle Coherence • Integrating Oracle Coherence • Managing Oracle Coherence • Java API Reference for Oracle Coherence • C++ API Reference for Oracle Coherence • .NET API Reference for Oracle Coherence • Release Notes for Oracle Coherence Conventions The following text conventions are used in this document: Convention Meaning boldface Boldface type indicates graphical user interface elements associated with an action, or terms defined in text or the glossary. italic Italic type indicates book titles, emphasis, or placeholder variables for which you supply particular values. monospace Monospace type indicates commands within a paragraph, URLs, code in examples, text that appears on the screen, or text that you enter. viii\n\nWhat's New in This Guide New and significant changes in Securing Oracle Coherence. This preface includes the following sections: • New and Changed Features New and changed features in Securing Oracle Coherence that are organized by release. • Other Significant Changes in This Document Other significant changes in Securing Oracle Coherence that are organized by release. New and Changed Features New and changed features in Securing Oracle Coherence that are organized by release. New and Changed Features for 12c (12.2.1.4) Oracle Coherence 12c (12.2.1.4) includes the following new and changed features for this document. • Password provider, which allows password encryption in an SSL socket provider configuration. See Encrypting SSL Passwords. New and Changed Features for 12c (12.2.1.3) Oracle Coherence 12c (12.2.1.3) does not contain any new and changed features for this document. New and Changed Features for 12c (12.2.1.2) Oracle Coherence 12c (12.2.1.2) does not contain any new and changed features for this document. New and Changed Features for 12c (12.2.1.1) Oracle Coherence 12c (12.2.1.1) does not contain any new and changed features for this document. New and Changed Features for 12c (12.2.1) Oracle Coherence 12c (12.2.1) includes the following new and changed features for this document. • Programmatic local permissions, which provides a way to set permissions for local (non-clustered) Coherence API operations. See Programmatically Specifying Local Permissions. ix\n\nWhat's New in This Guide • Security audit logs, which report cluster operations being performed by specific users. See Enable Security Audit Logs. • Access control authorization, which allows applications to define their own authorization logic to limit access to cluster operations. See Authorizing Access to Server-Side Operations . • SSL protocol and cipher suites configuration, which controls which SSL protocols and cipher suites can be used. See Controlling Cipher Suite and Protocol Version Usage. Other Significant Changes in This Document Other significant changes in Securing Oracle Coherence that are organized by release. Other Significant Changes in This Document for 12c (12.2.1.4) For 12c (12.2.1.4), no other significant changes have been made to this guide. Other Significant Changes in This Document for 12c (12.2.1.3) For 12c (12.2.1.3), no other significant changes have been made to this guide. Other Significant Changes in This Document for 12c (12.2.1.2) For 12c (12.2.1.2), no other significant changes have been made to this guide. Other Significant Changes in This Document for 12c (12.2.1.1) For 12c (12.2.1.1), no other significant changes have been made to this guide. Other Significant Changes in This Document for 12c (12.2.1) For 12c (12.2.1), no other significant changes have been made to this guide. x\n\n1 Introduction to Oracle Coherence Security Oracle Coherence includes many security features that provide varying levels of security. Understanding the security features and the uses cases they cover are important first steps when learning how to secure a Coherence solution. This chapter includes the following sections: • Conceptual Overview of Oracle Coherence Security • Coherence Security Quick Start • Overview of Security Configuration Conceptual Overview of Oracle Coherence Security Oracle Coherence provide security features that support standards such as Java policies and Secure Sockets Layer (SSL) and also includes features that are native to Oracle Coherence. Evaluate the security feature descriptions and determine which features to use based on your security requirements, concerns, and tolerances. The security features are presented from basic security measures to more advanced security measures. Java Policy Security A Java security policy file is provided that contains the minimum set of security permissions necessary to run Oracle Coherence. Edit the file to change the permissions based on an application's requirement. The security policy protects against malicious use and alterations of the Oracle Coherence library and configuration files. See Using the Java Security Manager. Host-Based Authorization Host-based authorization explicitly specifies which hosts become members of a cluster and which extend clients connect to a cluster. This type of access control is ideal in environments where host names (or IP addresses) are known in advance. Host-based authorization protects against unauthorized hosts joining or accessing a cluster. See Using Host-Based Authorization. Client Suspect Protocol The client suspect protocol automatically determines if an extend client is acting malicious and blocks the client from connecting to a cluster. The suspect protocol protects against denial of service attacks. See Managing Rogue Clients. Client Identity Tokens Client identity tokens control which extend clients access the cluster. A proxy server allows a connection only if the client presents a valid token. Identity tokens are application-specific and typically reuse existing client authentication implementations. Identity tokens protect against unwanted or malicious clients accessing the cluster. See Using Identity Tokens to Restrict Client Connections. 1-1\n\nChapter 1 Coherence Security Quick Start Client Authorization Client authorization controls which actions a particular client can perform based on its access control rights. A proxy server performs the authorization check before an extend client accesses a resource (cache, cache service, or invocation service). Client authorization is application-specific and protects against unauthorized use of cluster resources. See Implementing Extend Client Authorization. Access Controller Security Framework The access controller manages access to clustered resources, such as clustered services and caches, and controls which operations a user can perform on those resources. Cluster members use login modules to provide proof of identity; while, encrypting and decrypting communication acts as proof of trustworthiness. The framework requires the use of a keystore and defines permissions within a permissions file. The access controller prevents malicious cluster members from accessing and creating clustered resources. See Using an Access Controller . SSL SSL secures the Tangosol Cluster Management Protocol (TCMP) communication between cluster nodes. SSL also secures the TCP communication between Oracle Coherence*Extend clients and proxies. SSL uses digital signatures to establish identity and trust, and key-based encryption to ensure that data is secure. SSL is an industry standard that protects against unauthorized access and data tampering by malicious clients and cluster members. See Using SSL to Secure Communication . Coherence Security Quick Start Coherence security features are disabled by default and are enabled as required to address specific security requirements or concerns. Different levels of security can be achieved based on the security features that are enabled. You can quickly get started securing Coherence by configuring a solution to use file permissions, SSL, and role-based authorization. • Configure file system permissions and Java policy permissions to protect against reads and writes of Coherence files. See Using the Java Security Manager. • Configure and enable SSL to secure communication between cluster members and protect against unauthorized members joining the cluster. See Using SSL to Secure TCMP Communication. • When using Coherence*Extend or Coherence REST, configure and enable SSL to secure communication between external clients and Coherence proxy servers. SSL protects against unauthorized clients from using cluster services. See Using SSL to Secure Extend Client Communication and Using SSL Authentication With Oracle Coherence REST, respectively. • Implement authorization policies to restrict client access to specific Coherence operations based on user roles. See Implementing Extend Client Authorization. Overview of Security Configuration Coherence security requires the use of multiple configuration files. The configuration files enable, control, and customize security features as required. See Understanding Configuration in Developing Applications with Oracle Coherence. 1-2\n\nChapter 1 Overview of Security Configuration The following files are used to configure security: • Operational Override File – The tangosol-coherence-override.xml file overrides the operational deployment descriptor, which specifies the operational and runtime settings that maintain clustering, communication, and data management services. This file includes security settings for cluster members. • Cache Configuration File – The coherence-cache-config.xml file is the default cache configuration file. It specifies the various types of caches within a cluster. This configuration file includes security settings for cache services, proxy services, and Coherence*Extend clients. 1-3\n\n2 Enabling General Security Measures You can use general security measures to help protect against unauthorized use of Oracle Coherence APIs, system resources, and cluster connections. General security measures are often enabled as a first step when securing Coherence solutions. This chapter includes the following sections: • Using the Java Security Manager • Using Host-Based Authorization • Managing Rogue Clients Using the Java Security Manager You can control which system resources Coherence accesses and uses by enabling the Java security manager. The security manager uses a policy file that explicitly grants permissions for each resource. The COHERENCE_HOME/lib/security/ security.policy policy configuration file specifies a minimum set of permissions that are required for Coherence. Use the file as provided, or modify the file to set additional permissions. A set of local (non-clustered) permissions is also provided. The section includes the following topics: • Enable the Java Security Manager • Specify Permissions • Programmatically Specifying Local Permissions Enable the Java Security Manager To enable the Java security manager and use the COHERENCE_HOME/lib/security/ security.policy file, set the following properties on a cluster member: 1. Set the java.security.manager property to enable the Java security manager. For example: -Djava.security.manager 2. Set the java.security.policy property to the location of the policy file. For example: -Djava.security.manager -Djava.security.policy=/coherence/lib/security/security.policy 3. Set the coherence.home system property to COHERENCE_HOME. For example: -Djava.security.manager -Djava.security.policy=/coherence/lib/security/security.policy -Dcoherence.home=/coherence 2-1\n\nChapter 2 Using the Java Security Manager Note: The security policy file assumes that the default Java Runtime Environment (JRE) security permissions have been granted. Therefore, you must be careful to use a single equal sign (=) and not two equal signs (==) when setting the java.security.policy system property. Specify Permissions Modify the COHERENCE_HOME/lib/security/security.policy file to include additional permissions as required. See Permissions in the Java Development Kit (JDK) in Java SE Security. To specify additional permissions in the security.policy file: 1. Edit the security.policy file and add a permission for a resource. For example, the following permission grants access to the coherence.jar library: grant codeBase \"file:${coherence.home}/lib/coherence.jar\" { permission java.security.AllPermission; }; 2. When you declare binaries, sign the binaries using the JDK jarsigner tool. The following example signs the coherence.jar resource declared in the previous step: jarsigner -keystore ./keystore.jks -storepass password coherence.jar admin Add the signer in the permission declaration. For example, modify the original permission as follows to add the admin signer. grant SignedBy \"admin\" codeBase \"file:${coherence.home}/lib/coherence.jar\" { permission java.security.AllPermission; }; 3. Use operating system mechanisms to protect all relevant files from malicious modifications. Programmatically Specifying Local Permissions The com.tangosol.net.security.LocalPermission class provides a way to set permissions for local (non-clustered) Coherence API operations. Clients are either allowed or not allowed to perform the declared operations (referred to as targets). For example: LocalPermission lp = new LocalPermission(\"Cluster.shutdown\"); To use local permissions, the Java security manager must be enabled. See Enable the Java Security Manager. Table 2-1 lists and describes the target names that can be declared. 2-2\n\nChapter 2 Using Host-Based Authorization Table 2-1 Local Permission Targets Target Name Description CacheFactory.setCacheFactoryBuilde Protects the programmatic installation of r a custom cache factory builder. Special consideration should be given when granting this permission. Granting this permission allows code to set a cache factory builder and intercept any access or mutation requests to any caches and also allows access to any data that flows into and from those caches. Cluster.shutdown Protects all services from being shutdown. Granting this permission allows code to programmatically shutdown the cluster node. BackingMapManagerContext.getBackin Protects direct access to backing maps. Special gMap consideration should be given when granting this permission. Granting this permission allows code to get a reference to the backing map and access any stored data without any additional security checks. BackingMapManagerContext.setClassL Protect changes to class loaders used for oader storage. The class loader is used by the cache service to load application classes that might not exist in the system class loader. Granting this permission allows code to change which class loader is used for a particular service. Service.getInternalService Protects access to an internal service, cluster or cache reference. Granting this permission allows code to obtain direct access to the underlying service, cluster or cache storage implementation. Service.registerResource Protects service registries. Granting this permission allows code to re-register or unregister various resources associated with the service. Service.registerEventInterceptor Protects the programmatic installation of interceptors. Special consideration should be given when granting this permission. Granting this permission allows code to change or remove event interceptors associated with the cache service thus either getting access to underlying data or removing live events that are designed to protect the data integrity. Using Host-Based Authorization Host-based authorization is a type of access control that allows you to specify which hosts (based on host name or IP address) can connect to a cluster. The feature is available for both cluster member connections and extend client connections. This section includes the following topics: • Overview of Host-Based Authorization • Specify Cluster Member Authorized Hosts • Specify Extend Client Authorized Hosts 2-3\n\nChapter 2 Using Host-Based Authorization • Use a Filter Class to Determine Authorization Overview of Host-Based Authorization Host-based authorization uses the host name and IP address of a cluster member or extend client to determine whether a connection to the cluster is allowed. Specific host names, addresses, and address ranges can be defined. For custom processing, a custom filter can be created to validate hosts. Host-based authorization is ideal for environments where known hosts with relatively static network addresses are joining or accessing the cluster. In dynamic environments, or when updating a DNS server, IP addresses can change and cause a cluster member or extend client to fail authorization. Cache operations may not complete if cluster members or extend clients are no longer authorized. Extend clients are more likely to have access problems because of their transient nature. When using host-based authorization, consider the dynamic nature of the network environment. The need to reconfigure the list of authorized hosts may become impractical. If possible, always use a range of IP addresses instead of using a specific host name. Or, create a custom filter that is capable of resolving address that have changed. If host-based authorization becomes impractical, consider using extend client identity tokens or SSL. See Using Identity Tokens to Restrict Client Connections and Using SSL to Secure Communication , respectively. Specify Cluster Member Authorized Hosts The default behavior of a cluster allows any host to connect to the cluster and become a cluster member. Host-based authorization changes this behavior to allow only hosts with specific host names or IP addresses to connect to the cluster. Configure authorized hosts in an operational override file using the element within the element. Enter specific addresses using the element or a range of addresses using the element. The and elements support an id attribute for uniquely identifying multiple elements. The following example configures a cluster to accept only cluster members whose IP address is either 192.168.0.5, 192.168.0.6, or within the range of 192.168.0.10 to 192.168.0.20 and 192.168.0.30 to 192.168.0.40. 192.168.0.5 192.168.0.6 192.168.0.10 192.168.0.20 192.168.0.30 2-4\n\nChapter 2 Using Host-Based Authorization 192.168.0.40 Specify Extend Client Authorized Hosts The default behavior of an extend proxy server allows any extend client to connect to the cluster. Host-based authorization changes this behavior to allow only hosts with specific host names or IP addresses to connect to the cluster. Configure authorized hosts in a cache configuration file using the element within the element of a proxy scheme definition. Enter specific addresses using the element or a range of addresses using the element. The and elements support an id attribute for uniquely identifying multiple elements. The following example configures an extend proxy to accept only client connections from clients whose IP address is either 192.168.0.5, 192.168.0.6, or within the range of 192.168.0.10 to 192.168.0.20 and 192.168.0.30 to 192.168.0.40. ExtendTcpProxyService 5 ... 192.168.0.5 192.168.0.6 192.168.0.10 192.168.0.20 192.168.0.30 192.168.0.40 ... true Use a Filter Class to Determine Authorization A filter class determines whether to accept a particular host connection. Both extend client connections and cluster member connections support using filter classes. A filter class must implement the com.tangosol.util.Filter interface. The evaluate() method of the interface is passed the java.net.InetAddress of the host. Implementations should return true to accept the connection. To enable a filter class, enter a fully qualified class name using the element within the element. Set initialization parameters using the element. 2-5\n\nChapter 2 Managing Rogue Clients The following example configures a filter named MyFilter, which determines if a host connection is allowed. 192.168.0.5 192.168.0.6 192.168.0.10 192.168.0.20 package.MyFilter sPolicy strict Managing Rogue Clients You can use the suspect protocol to safeguard against rogue extend clients that operate outside of acceptable limits. Rogue clients are slow-to-respond clients or abusive clients that attempt to overuse a proxy— as is the case with denial of service attacks. In both cases, the potential exists for a proxy to run out of memory and become unresponsive. The suspect algorithm monitors client connections looking for abnormally slow or abusive clients. When a rogue client connection is detected, the algorithm closes the connection to protect the proxy server from running out of memory. The protocol works by monitoring both the size (in bytes) and length (in messages) of the outgoing connection buffer backlog for a client. Different levels determine when a client is suspect, when it returns to normal, or when it is considered rogue. Configure the suspect protocol within the element of a proxy scheme definition. See tcp-acceptor in Developing Applications with Oracle Coherence. The suspect protocol is enabled by default. The following example demonstrates configuring the suspect protocol and is similar to the default settings. When the outgoing connection buffer backlog for a client reaches 10 MB or 10000 messages, the client is considered suspect and is monitored. If the connection buffer backlog for a client returns to 2 MB or 2000 messages, then the client is considered safe and the client is no longer monitored. If the connection buffer backlog for a client reaches 95 MB or 60000 messages, then the client is considered unsafe and the proxy closes the connection. ExtendTcpProxyService 5 ... true 10M 10000 2M 2000 2-6\n\nChapter 2 Managing Rogue Clients 95M 60000 true 2-7\n\n3 Using an Access Controller You can enable an access controller to help protect against unauthorized use of cluster resources. The default access controller implementation is based on the key management infrastructure that is part of the HotSpot JDK and uses Java Authentication and Authorization Service (JAAS) for authentication. This chapter includes the following sections: • Overview of Using an Access Controller • Using the Default Access Controller Implementation • Using a Custom Access Controller Implementation Overview of Using an Access Controller Coherence includes an access controller that is used to secure access to cluster resources and operations. A local login module is used to authenticate a caller, and an access controller on one or more cluster nodes verifies the access rights of the caller. See LoginModule in Java Authentication and Authorization Service (JAAS) Reference Guide. An access controller: • Grants or denies access to a protected clustered resource based on the caller's permissions • Encrypts outgoing communications based on the caller's private credentials • Decrypts incoming communications based on the caller's public credentials A default access controller implementation is provided. The implementation is based on the key management infrastructure that ships as a standard part of the HotSpot JDK. See Using the Default Access Controller Implementation. Figure 3-1 shows a conceptual view of securing two cluster members using access controllers. Figure 3-1 Conceptual View of Access Controller Security 3-1\n\nChapter 3 Overview of Using an Access Controller Understanding the Security Context Each clustered service maintains the concept of a senior service member that serves as a controlling agent for a particular service. The senior member does not consult with other members when accessing a clustered resource. However, juniors member that want to join a service must request and receive a confirmation from the senior member. The senior member notifies all other cluster members about the joining member. The security subsystem is designed to operate in a partially hostile environment because data is distributed among cluster members. Every member is considered to be a malicious member. That is, members are assumed to lack sufficient credentials to join a clustered service or obtain access to a clustered resource. File system mechanisms and standard Java security policies guarantee the trustworthiness of a single node. However, there are two scenarios to consider with member communication: • A malicious node surpasses the local access check and attempts to join a clustered service or gain access to a clustered resource that a trusted node controls. • A malicious node creates a clustered service or clustered resource and becomes its controller. The security subsystem uses a two-way encryption algorithm to prevent either of these two scenarios from occurring. All client requests must establish proof of identity, and all service responses must establish proof of trustworthiness. Proof of Identity The following client code sample authenticates a caller and performs necessary actions: import com.tangosol.net.security.Security; import java.security.PrivilegedAction; import javax.security.auth.Subject; ... Subject subject = Security.login(sName, acPassword); PrivilegedAction action = new PrivilegedAction() { public Object run() { // all processing here is taking place with access // rights assigned to the corresponding Subject // for example: CacheFactory.getCache().put(key, value); ... } }; Security.runAs(subject, action); The caller is authenticated using JAAS on the caller's node during the login call. If the authentication is successful, the local access controller: • Determines whether the local caller has sufficient rights to access the protected clustered resource (local access check) 3-2\n\nChapter 3 Using the Default Access Controller Implementation • Encrypts the outgoing communications regarding the access to the resource with the caller's private credentials retrieved during the authentication phase • Decrypts the result of the remote check using the requester's public credentials • Verifies whether the responder has sufficient rights to be granted access The encryption step provides proof of identity for the responder and blocks a malicious node that pretends to pass the local access check phase. There are two additional ways to provide the client authentication information. First, pass a reference to a CallbackHandler class instead of the user name and password. Second, use a previously authenticated Subject. The latter approach is ideal when a Java EE application uses Oracle Coherence and retrieves an authenticated Subject from the application container. If a caller's request does not include any authentication context, a CallbackHandler implementation is instantiated and called. The implementation is declared in an operational override file and retrieves the appropriate credentials. However, this lazy approach is much less efficient, because without an externally defined call scope every access to a protected clustered resource forces repetitive authentication calls. Proof of Trustworthiness Cluster members use explicit API calls to create clustered resources. The senior service member retains the private credentials that are presented during a call as a proof of trustworthiness. When the senior service member receives an access request to a protected clustered resource, the local access controller: • Decrypts the incoming communication using the remote caller's public credentials • Encrypts the access check response using the private credentials of the service. • Determines whether the remote caller has sufficient rights to access the protected clustered resource (remote access check). Using the Default Access Controller Implementation Coherence includes a default access controller implementation that uses a standard Java keystore for authentication. The implementation class is the com.tangosol.net.security.DefaultController class. It is configured within the element in the operational deployment descriptor. See security- config in Developing Applications with Oracle Coherence. This section includes the following topics: • Enable the Access Controller • Create a Keystore • Include the Login Module • Create a Permissions File • Create an Authentication Callback Handler • Enable Security Audit Logs 3-3\n\nChapter 3 Using the Default Access Controller Implementation Enable the Access Controller To enable the default access controller implementation within the element, add an element that is set to true. For example: true The coherence.security system property also enables the access controller. For example: -Dcoherence.security=true Note: When access controller security is enabled, every call to the CacheFactory.getCache() or ConfigurableCacheFactory.ensureCache() API causes a security check. This negatively affects an application's performance if these calls are made frequently. The best practice is for the application to hold on to the cache reference and reuse it so that the security check is performed only on the initial call. With this approach, ensure that your application only uses the references in an authorized way. Create a Keystore An access controller requires a keystore that is used by both the controller and login module. Create a keystore with necessary principals using the Java keytool utility. Ensure that the keystore is found on the classpath at runtime, or use the coherence.security.keystore system property to explicitly enter the name and location of the keystore. For example: -Dcoherence.security.keystore=keystore.jks The following example creates three principals: admin (to be used by the Java Security framework), manager, and worker (to be used by Oracle Coherence). keytool -genkey -v -keystore ./keystore.jks -storepass password -alias admin -keypass password -dname CN=Administrator,O=MyCompany,L=MyCity,ST=MyState keytool -genkey -v -keystore ./keystore.jks -storepass password -alias manager -keypass password -dname CN=Manager,OU=MyUnit keytool -genkey -v -keystore ./keystore.jks -storepass password -alias worker -keypass password -dname CN=Worker,OU=MyUnit Include the Login Module Oracle Coherence includes the COHERENCE_HOME/lib/security/coherence-login.jar Java keystore (JKS) login module, which depends only on standard Java run-time classes. Place the library in the JRE lib/ext (standard extension) directory. The name in the element, within the element, serves 3-4\n\nChapter 3 Using the Default Access Controller Implementation as the application name in the COHERENCE_HOME/lib/security/login.config login module file. The login module declaration contains the path to the keystore. Change the keyStorePath variable to the location of the keystore. // LoginModule Configuration for Oracle Coherence Coherence { com.tangosol.security.KeystoreLogin required keyStorePath=\"${user.dir}${/}security${/}keystore.jks\"; }; Create a Permissions File An access controller requires a permissions.xml file that declares access rights for principals. See the COHERENCE_HOME/lib/security/permissions.xsd schema for the syntax of the permissions file. Ensure that the file is found on the classpath at runtime, or use the coherence.security.permissions system property to explicitly enter the name and location of the permissions file. For example: -Dcoherence.security.permissions=permissions.xml The following example assigns all rights to the Manager principal, only join rights to the Worker principal for caches that have names prefixed by common, and all rights to the Worker principal for the invocation service named invocation. javax.security.auth.x500.X500Principal CN=Manager,OU=MyUnit * all javax.security.auth.x500.X500Principal CN=Worker,OU=MyUnit cache=common* join service=invocation all Create an Authentication Callback Handler An access controller uses an authentication callback handler to authenticate a client when all other authentication methods have been unsuccessful. To create a callback handler, implement the javax.security.auth.callback.CallbackHandler interface. 3-5\n\nChapter 3 Using a Custom Access Controller Implementation Note: the handler approach is much less efficient since without an externally defined call scope every access to a protected clustered resource forces repetitive authentication calls. To configure a custom callback handler within the element, add a element that includes the fully qualified name of the implementation class. The following example configures a callback handler named MyCallbackHandler. package.MyCallbackHandler Enable Security Audit Logs Security audit logs are used to track the cluster operations that are being performed by each user. Each operation results in a log message being emitted. For example: \"Destroy\" action for cache \"Accounts\" has been permitted for the user \"CN=Bob, OU=Accounting\". Security audit logs are not enabled by default. To enable audit logs within the element, override the security log initialization parameter within the element and set the parameter value to true. For example, boolean true The coherence.security.log system property also enables security audit logs. For example: -Dcoherence.security.log=true Using a Custom Access Controller Implementation You can create a custom access controller implementation if you have specific security requirements that are not addressed by the default implementation. Custom access controllers must implement the com.tangosol.net.security.AccessController interface. To configure a custom access controller within the element, add an element that includes the fully qualified name of the 3-6\n\nChapter 3 Using a Custom Access Controller Implementation implementation class. The following example configures a custom access controller called MyAccessController. true package.MyAccessController Specify any required initialization parameters by using the element. The following example includes parameters to pass the MyAccessController class a keystore and a permissions file. true package.MyAccessController java.io.File ./keystore.jks java.io.File ./permissions.xml 3-7\n\n4 Authorizing Access to Server-Side Operations Coherence supports server-side authorization to ensure that only specific users can perform certain operations. Authorization is often used together with authentication to provide increased security assurances. This chapter includes the following sections: • Overview of Access Control Authorization • Creating Access Control Authorization Implementations • Declaring Access Control Authorization Implementations • Enabling Access Control Authorization on a Partitioned Cache Overview of Access Control Authorization Access control authorization allows applications to define their own authorization logic to limit access to cluster operations. Authorization is based on identities that are represented as a Principal within a Subject.Applications are responsible for ensuring that the Subject is present for caller threads. If the Subject is missing or cannot be retrieved, then the operation fails with a SecurityException error. Applications implement the StorageAccessAuthorizer interface to provide authorization logic. The implementations are declared in the operational override configuration file and must also be enabled on a partitioned cache by configuring the backing map of a distributed scheme in a cache configuration file. Access control authorization is only available for partitioned caches. The StorageAccessAuthorizer interface provides methods that are used to perform read, write, read any, and write any authorization checks. Coherence assumes that there is a logical consistency between authorization decisions made by StorageAccessAuthorizer implementations. That is, for a given Subject, the write authorization implies the read authorization for a given entry; the read any authorization implies read authorization for all entries; and, the write any authorization implies write and read authorization for all entries. Table 4-1 lists which authorization checks are caused by NamedCache API and BinaryEntry API methods. 4-1\n\nChapter 4 Creating Access Control Authorization Implementations Table 4-1 Authorization Checks for Common Methods Authorizati NamedCache API Methods BinaryEntry API Methods on Check None • containsKey • containsValue • isEmpty • size • lock • unlock Read • get • getValue • getAll • getBinaryValue • extract • getOriginalValue • getOriginalBinaryValue Write • invoke • setValue • put • update • putAll • updtaeBinaryValue • remove • remove • removeAll • expire Read Any • addMapListener1 • aggregate • entrySet • keySet • removeMapListener1 Write Any • addIndex • clear • invokeAll • removeIndex • values 1 If a listener is a MapTriggerListener, then a Write Any authorization check is performed instead. Creating Access Control Authorization Implementations Access control authorization requires an authorizer implementation that contains user- defined authorization logic. To create access control authorization implementations, create a class that implements the com.tangosol.net.security.StorageAccessAuthorizer interface. The implementation should define which callers (based on the Subject) are authorized to access entries and backing map contexts (BinaryEntry and BackingMapManagerContext, respectively). 4-2\n\nChapter 4 Creating Access Control Authorization Implementations Note: The BinaryEntry and BackingMapManagerContext API provide the ability to retrieve the cache name, the service name, and full access to the service and cluster registries. Example 4-1 Provides a sample StorageAccessAuthorizer implementation that emits a log message for each authorization request. It is based on the AuditingAuthorizer class that is provided with Coherence and used by the default access controller implementation. Example 4-1 Sample StorageAccessAuthorizer Implementation package com.examples.security; import com.tangosol.net.BackingMapContext; import com.tangosol.net.CacheFactory; import com.tangosol.net.security.StorageAccessAuthorizer; import com.tangosol.util.BinaryEntry; import javax.security.auth.Subject; public class MyLogAuthorizer implements StorageAccessAuthorizer { public MyLogAuthorizer() { this(false); } public MyLogAuthorizer(boolean fStrict) { f_fStrict = fStrict; } @Override public void checkRead(BinaryEntry entry, Subject subject, int nReason) { logEntryRequest(entry, subject, false, nReason); if (subject == null && f_fStrict) { throw new SecurityException(\"subject is not provided\"); } } @Override public void checkWrite(BinaryEntry entry, Subject subject, int nReason) { logEntryRequest(entry, subject, true, nReason); if (subject == null && f_fStrict) { throw new SecurityException(\"subject is not provided\"); } } @Override public void checkReadAny(BackingMapContext context, Subject subject, 4-3\n\nChapter 4 Declaring Access Control Authorization Implementations int nReason) { logMapRequest(context, subject, false, nReason); if (subject == null && f_fStrict) { throw new SecurityException(\"subject is not provided\"); } } @Override public void checkWriteAny(BackingMapContext context, Subject subject, int nReason) { logMapRequest(context, subject, true, nReason); if (subject == null && f_fStrict) { throw new SecurityException(\"subject is not provided\"); } } protected void logEntryRequest(BinaryEntry entry, Subject subject, boolean fWrite, int nReason) { CacheFactory.log('\"' + (fWrite ? \"Write\" : \"Read\") + \"\\\" request for key=\\\"\" + entry.getKey() + (subject == null ? \"\\\" from unidentified user\" : \"\\\" on behalf of \" + subject.getPrincipals()) + \" caused by \\\"\" + nReason + \"\\\"\" , CacheFactory.LOG_INFO); } protected void logMapRequest(BackingMapContext context, Subject subject, boolean fWrite, int nReason) { CacheFactory.log('\"' + (fWrite ? \"Write-any\" : \"Read-any\") + \"\\\" request for cache \\\"\" + context.getCacheName() + '\"' + (subject == null ? \" from unidentified user\" : \" on behalf of \" + subject.getPrincipals()) + \" caused by \\\"\" + nReason + \"\\\"\" , CacheFactory.LOG_INFO); } private final boolean f_fStrict; } Declaring Access Control Authorization Implementations Access control authorization implementations must be declared so that the class is loaded when a cluster starts. Multiple authorization implementations can be created and are referenced using a unique identification. To declare access control authorizer implementations, edit the operational override file and include a element, within the element, and declare each authorization implementation using a 4-4\n\nChapter 4 Enabling Access Control Authorization on a Partitioned Cache element. See storage-authorizer in Developing Applications with Oracle Coherence. Each declaration must include a unique id attribute that is used by a partitioned cache to select an implementation. For example: package.MyLogAuthorizer As an alternative, the element supports the use of a element to use a factory class that is responsible for creating instances and a element to specify the static factory method on the factory class that performs object instantiation. For example: package.MyAuthorizerFactory getAuthorizer Any initialization parameters that are required for an implementation can be specified using the element. For example: package.MyLogAuthorizer f_fStrict true Enabling Access Control Authorization on a Partitioned Cache A partition cache service must be configured to use an access control authorization implementation. The implementation is enabled in the cache definition and is reference by name. To enable access control authorization on a partitioned cache, edit the cache configuration file and add a element, within the element of a distributed scheme, whose value is the id attribute value of an authorization implementation that is declared in the operational override file. For example: ... 4-5"
    }
}