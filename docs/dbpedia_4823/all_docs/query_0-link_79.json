{
    "id": "dbpedia_4823_0",
    "rank": 79,
    "data": {
        "url": "https://simple-evcorr.github.io/man.html",
        "read_more_link": "",
        "language": "en",
        "title": "Man page of sec",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "sec\n\nSection: User Commands (1)\n\nUpdated: June 2023\n\nIndex\n\nNAMESYNOPSISDESCRIPTIONOPTIONSCONFIGURATION FILESPATTERNS, PATTERN TYPES AND MATCH VARIABLESCONTEXTS AND CONTEXT EXPRESSIONSACTIONS, ACTION LISTS AND ACTION LIST VARIABLESPARSING ISSUESRULE TYPES\n\nSINGLE RULESINGLEWITHSCRIPT RULESINGLEWITHSUPPRESS RULEPAIR RULEPAIRWITHWINDOW RULESINGLEWITHTHRESHOLD RULESINGLEWITH2THRESHOLDS RULEEVENTGROUP RULESUPPRESS RULECALENDAR RULEJUMP RULEOPTIONS RULE\n\nEVENT CORRELATION OPERATIONSINPUT PROCESSING AND TIMINGINTERNAL EVENTS AND CONTEXTSCHILD PROCESSESPERL INTEGRATIONEXAMPLES\n\nExample 1 - a ruleset for Cisco eventsExample 2 - hierarchically organized rulesets for iptables and sshd events\n\nENVIRONMENTSIGNALSBUGSAUTHORACKNOWLEDGMENTSSEE ALSO\n\nNAME\n\nsec - simple event correlator\n\nSYNOPSIS\n\nsec\n\n[--conf=<file pattern> ...]\n\n[--input=<file pattern>[=<context>] ...]\n\n[--input-timeout=<input timeout>]\n\n[--timeout-script=<timeout script>]\n\n[--reopen-timeout=<reopen timeout>]\n\n[--check-timeout=<check timeout>]\n\n[--poll-timeout=<poll timeout>]\n\n[--socket-timeout=<socket timeout>]\n\n[--blocksize=<io block size>]\n\n[--bufsize=<input buffer size>]\n\n[--evstoresize=<event store size>]\n\n[--cleantime=<clean time>]\n\n[--log=<logfile>]\n\n[--syslog=<facility>]\n\n[--debug=<debuglevel>]\n\n[--pid=<pidfile>]\n\n[--dump=<dumpfile>]\n\n[--user=<username>]\n\n[--group=<groupname> ...]\n\n[--umask=<mode>]\n\n[--ruleperf | --noruleperf]\n\n[--dumpfts | --nodumpfts]\n\n[--dumpfjson | --nodumpfjson]\n\n[--quoting | --noquoting]\n\n[--tail | --notail]\n\n[--fromstart | --nofromstart]\n\n[--detach | --nodetach]\n\n[--jointbuf | --nojointbuf]\n\n[--keepopen | --nokeepopen]\n\n[--rwfifo | --norwfifo]\n\n[--childterm | --nochildterm]\n\n[--intevents | --nointevents]\n\n[--intcontexts | --nointcontexts]\n\n[--testonly | --notestonly]\n\n[--help] [-?]\n\n[--version]\n\nDESCRIPTION\n\nSEC is an event correlation tool for advanced event processing which can be harnessed for event log monitoring, for network and security management, for fraud detection, and for any other task which involves event correlation. Event correlation is a procedure where a stream of events is processed, in order to detect (and act on) certain event groups that occur within predefined time windows. Unlike many other event correlation products which are heavyweight solutions, SEC is a lightweight and platform-independent event correlator which runs as a single process. The user can start it as a daemon, employ it in shell pipelines, execute it interactively in a terminal, run many SEC processes simultaneously for different tasks, and use it in a wide variety of other ways.\n\nSEC reads lines from files, named pipes, or standard input, matches the lines with patterns (regular expressions, Perl subroutines, etc.) for recognizing input events, and correlates events according to the rules in its configuration file(s). Rules are matched against input in the order they are given in the configuration file. If there are two or more configuration files, rule sequence from every file is matched against input (unless explicitly specified otherwise). SEC can produce output by executing external programs (e.g., snmptrap(1) or mail(1)), by writing to files, by sending data to TCP and UDP based servers, by calling precompiled Perl subroutines, etc.\n\nSEC can be run in various ways. For example, the following command line starts it as a daemon, in order to monitor events appended to the /var/log/messages syslog file with rules from /etc/sec/syslog.rules:\n\n/usr/bin/sec --detach --conf=/etc/sec/syslog.rules \\\n\n--input=/var/log/messages\n\nEach time /var/log/messages is rotated, a new instance of /var/log/messages is opened and processed from the beginning. The following command line runs SEC in a shell pipeline, configuring it to process lines from standard input, and to exit when the /usr/bin/nc tool closes its standard output and exits:\n\n/usr/bin/nc -l 8080 | /usr/bin/sec --notail --input=- \\\n\n--conf=/etc/sec/my.conf\n\nSome SEC rules start event correlation operations, while other rules react immediately to input events or system clock. For example, suppose that SEC has been started with the following command line\n\n/usr/bin/sec --conf=/etc/sec/sshd.rules --input=/var/log/secure\n\nin order to monitor the /var/log/secure syslog file for sshd events. Also, suppose that the /etc/sec/sshd.rules configuration file contains the following rule for correlating SSH failed login syslog events:\n\ntype=SingleWithThreshold\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: Failed .+ for (\\S+) from [\\d.]+ port \\d+ ssh2\n\ndesc=Three SSH login failures within 1m for user $1\n\naction=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost\n\nwindow=60\n\nthresh=3\n\nThe pattern field of the rule defines the pattern for recognizing input events, while the ptype field defines its type (regular expression). Suppose that user risto fails to log in over SSH and the following message is logged to /var/log/secure:\n\nDec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5 port 41063 ssh2\n\nThis input message will match the regular expression pattern of the above rule, and the match variable $1 will be set to the string risto (see perlre(1) for details). After a match, SEC will evaluate the operation description string given with the desc field. This is done by substituting $1 with its current value which yields Three SSH login failures within 1m for user risto. SEC will then check if there already exists an event correlation operation identified with this string and triggered by the same rule. If the operation is not found, SEC will create a new operation for the user name risto, and the occurrence time of the input event will be recorded into the operation. Note that for event occurrence time SEC always uses the current time as returned by the time(2) system call, *not* the timestamp extracted from the event.\n\nSuppose that after 25 seconds, a similar SSH login failure event for the same user name is observed. In this case, a running operation will be found for the operation description string Three SSH login failures within 1m for user risto, and the occurrence time of the second event is recorded into the operation. If after 30 seconds a third event for the user name risto is observed, the operation has processed 3 events within 55 seconds. Since the threshold condition \"3 events within 60 seconds\" (as defined by the thresh and window fields) is now satisfied, SEC will execute the action defined with the action field -- it will fork a command\n\n/bin/mail -s 'SSH login alert' root@localhost\n\nwith a pipe connected to its standard input. Then, SEC writes the operation description string Three SSH login failures within 1m for user risto (held by the %s special variable) to the standard input of the command through the pipe. In other words, an e-mail warning is sent to the local root-user. Finally, since there are 5 seconds left until the end of the event correlation window, the operation will consume the following SSH login failure events for user risto without any further action, and finish after 5 seconds.\n\nThe above example illustrates that the desc field of a rule defines the scope of event correlation and influences the number of operations created by the rule. For example, if we set the desc field to Three SSH login failures within 1m, the root-user would be also alerted on 3 SSH login failure events for *different* users within 1 minute. In order to avoid clashes between operations started by different rules, operation ID contains not only the value set by the desc field, but also the rule file name and the rule number inside the file. For example, if the rule file /etc/sec/sshd.rules contains one rule\n\ntype=SingleWithThreshold\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: Failed .+ for (\\S+) from [\\d.]+ port \\d+ ssh2\n\ndesc=Three SSH login failures within 1m for user $1\n\naction=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost\n\nwindow=60\n\nthresh=3\n\nand the event\n\nDec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5 port 41063 ssh2\n\nis the first matching event for the above rule, this event will trigger a new event correlation operation with the ID\n\n/etc/sec/sshd.rules | 0 | Three SSH login failures within 1m for user risto\n\n(0 is the number assigned to the first rule in the file, see EVENT CORRELATION OPERATIONS section for more information).\n\nThe following simple example demonstrates that event correlation schemes can be defined by combining several rules. In this example, two rules harness contexts and synthetic events for achieving their goal:\n\ntype=SingleWithThreshold\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: Failed .+ for (\\S+) from [\\d.]+ port \\d+ ssh2\n\ndesc=Three SSH login failures within 1m for user $1\n\naction=event 3_SSH_LOGIN_FAILURES_FOR_$1\n\nwindow=60\n\nthresh=3\n\ntype=EventGroup\n\nptype=RegExp\n\npattern=3_SSH_LOGIN_FAILURES_FOR_(\\S+)\n\ncontext=!USER_$1_COUNTED && !COUNTING_OFF\n\ncount=create USER_$1_COUNTED 60\n\ndesc=Repeated SSH login failures for 30 distinct users within 1m\n\naction=pipe '%s' /bin/mail -s 'SSH login alert' root@localhost; \\\n\ncreate COUNTING_OFF 3600\n\nwindow=60\n\nthresh=30\n\nThe first rule looks almost identical to the rule from the previous example, but its action field is different -- after three SSH login failures have been observed for the same user name within one minute by an event correlation operation, the operation will emit the synthetic event 3_SSH_LOGIN_FAILURES_FOR_<username>. Although synthetic events are created by SEC, they are treated like regular events received from input sources and are matched against rules.\n\nThe regular expression pattern of the second rule will match the 3_SSH_LOGIN_FAILURES_FOR_<username> event and start a new event correlation operation if no such events have been previously seen. Also, each time a synthetic event for some user name has matched the rule, a context with the lifetime of 1 minute for that user name is created (see the count field). Note that this prevents further matches for the same user name, since a synthetic event for <username> can match the rule only if the context USER_<username>_COUNTED *does not* exist (as requested by the boolean expression in the context field; see CONTEXTS AND CONTEXT EXPRESSIONS section for more information).\n\nThe operation started by the second rule sends an e-mail warning to the local root-user if 30 synthetic events have been observed within 1 minute (see the thresh and window fields). Note that due to the use of the USER_<username>_COUNTED contexts, all synthetic events concern different user names. After sending an e-mail warning, the operation will also create the context COUNTING_OFF with the lifetime of 1 hour, and will continue to run until the 1 minute event correlation window expires. After the operation has finished, the presence of the COUNTING_OFF context will keep the second rule disabled (as requested by the boolean expression in the context field). Therefore, at most one e-mail warning per 1 hour is issued by above rules.\n\nThe above examples have presented the event correlation capabilities of SEC in a very brief fashion. The following sections will provide an in-depth discussion of SEC features.\n\nOPTIONS\n\n--conf=<file_pattern>\n\nexpand <file_pattern> to filenames (with the Perl glob() function) and read event correlation rules from every file. Multiple --conf options can be specified at command line. Each time SEC receives a signal that forces a configuration reload, <file_pattern> is re-evaluated. See also INPUT PROCESSING AND TIMING section for a discussion on rule processing order for multiple configuration files.\n\n--input=<file_pattern>[=<context>]\n\nexpand <file_pattern> to filenames (with the Perl glob() function) and use the files as input sources. An input file can be a regular file, named pipe, or standard input if - was specified. Multiple --input options can be specified at command line. Each time SEC receives the SIGHUP or SIGABRT signal, <file_pattern> is re-evaluated. If SEC experiences a system error when reading from an input file, it will close the file (use the --reopen-timeout option for reopening the file). If <context> is given, SEC will set up the context <context> each time it reads a line from input files that correspond to <file_pattern>. This will help the user to write rules that match data from particular input source(s) only. When there is an --input option with <context> specified, it will automatically enable the --intcontexts option. See INTERNAL EVENTS AND CONTEXTS section for more information.\n\n--input-timeout=<input_timeout>, --timeout-script=<timeout_script>\n\nif SEC has not observed new data in an input file during <input_timeout> seconds (or the file was closed <input_timeout> seconds ago), <timeout_script> will be executed with command line parameters 1 and <the name of the input file>. If fresh data become available again, <timeout_script> will be executed with command line parameters 0 and <the name of the input file>. Setting <input_timeout> to 0 disables this behavior (this is also the default). Note that --input_timeout and --timeout_script options can be used as synonyms for --input-timeout and --timeout-script, respectively.\n\n--reopen-timeout=<reopen_timeout>\n\nif an input file is in the closed state (e.g., SEC fails to open the file at startup, because it has not been created yet), SEC will attempt to reopen the file after every <reopen_timeout> seconds until open succeeds. Setting <reopen_timeout> to 0 disables this behavior (this is also the default). This option has no meaning when the --notail option is also specified. Note that --reopen_timeout is a synonym for --reopen-timeout.\n\n--check-timeout=<check_timeout>\n\nif SEC has not observed new data in an input file, the file will not be polled (both for status and data) during the next <check_timeout> seconds. Setting <check_timeout> to 0 disables this behavior (this is also the default). Note that --check_timeout is a synonym for --check-timeout.\n\n--poll-timeout=<poll_timeout>\n\na real number that specifies how many seconds SEC will sleep when no new data were read from input files. Default is 0.1 seconds. Note that --poll_timeout is a synonym for --poll-timeout.\n\n--socket-timeout=<socket_timeout>\n\nif a network connection to a remote peer can't be established within <socket_timeout> seconds, give up. Default is 60 seconds. Note that --socket_timeout is a synonym for --socket-timeout.\n\n--blocksize=<io_block_size>\n\nthe number of bytes SEC will attempt to read at once from an input file. Default is 8192 bytes (i.e., read from input files by 8KB blocks).\n\n--bufsize=<input_buffer_size>\n\nset all input buffers to hold <input_buffer_size> lines. The content of input buffers will be compared with patterns that are part of rule definitions (i.e., no more than <input_buffer_size> lines can be matched by a pattern at a time). If <input_buffer_size> is set to 0, SEC will determine the proper value for <input_buffer_size> by checking event matching patterns of all SEC rules. Default is 0 (i.e., determine the size of input buffers automatically).\n\n--evstoresize=<event_store_size>\n\nset an upper limit to the number of events in context event stores. Default is 0 which sets no limit.\n\n--cleantime=<clean_time>\n\ntime interval in seconds that specifies how often internal event correlation and context lists are processed, in order to accomplish time-related tasks and to remove obsolete elements. See INPUT PROCESSING AND TIMING section for more information. Default is 1 second.\n\n--log=<logfile>\n\nuse <logfile> for logging SEC activities. Note that if the SEC standard error is connected to a terminal, messages will also be logged there, in order to facilitate debugging.\n\n--syslog=<facility>\n\nuse syslog for logging SEC activities. All messages will be logged with the facility <facility>, e.g., local0 (see syslog(3) for possible facility values). Warning: be careful with using this option if SEC is employed for monitoring syslog log files, because message loops might occur.\n\n--debug=<debuglevel>\n\nset logging verbosity for SEC. Setting debuglevel to <debuglevel> means that all messages of level <debuglevel> and lower are logged (e.g., if <debuglevel> is 3, messages from levels 1-3 are logged). The following levels are recognized by SEC:\n\n1 - critical messages (severe faults that cause SEC to terminate, e.g., a failed system call)\n\n2 - error messages (faults that need attention, e.g., an incorrect rule definition in a configuration file)\n\n3 - warning messages (possible faults, e.g., a command forked from SEC terminated with a non-zero exit code)\n\n4 - notification messages (normal system level events and interrupts, e.g., the reception of a signal)\n\n5 - informative messages (information about external programs forked from SEC)\n\n6 - debug messages (detailed information about all SEC activities)\n\nDefault <debuglevel> is 6 (i.e., log everything). See SIGNALS section for information on how to change <debuglevel> at runtime.\n\n--pid=<pidfile>\n\nSEC will store its process ID to <pidfile> at startup.\n\n--dump=<dumpfile>\n\nSEC will use <dumpfile> as its dump file for writing performance and debug data. With the --dumpfts option, a timestamp suffix is appended to the dump file name. With the --dumpfjson option, dump file is produced in JSON format. See SIGNALS section for more information. Default is /tmp/sec.dump.\n\n--user=<username>, --group=<groupname>\n\nif SEC is started with effective user ID 0, it will drop root privileges by switching to user <username> and group <groupname>. The --group option can't be used without the --user option. If the --user option is given without --group, primary group of the user <username> is assumed for <groupname>. If several groups are provided with multiple --group options, SEC switches to the first group with other groups as supplementary groups.\n\n--umask=<mode>\n\nset file mode creation mask to <mode> at SEC startup, where <mode> is a value from the range 0..0777 (see also umask(2)). Octal, decimal, hexadecimal, and binary values can be specified for <mode> (e.g., octal mask 0027 can also be expressed as 23, 0x17, and 0b000010111).\n\n--ruleperf, --noruleperf\n\nif the --ruleperf option is specified, performance data (e.g., total consumed CPU time) is collected for each rule and reported in dump file. Default is --noruleperf.\n\n--dumpfts, --nodumpfts\n\nif the --dumpfts option is specified, a timestamp suffix (seconds since Epoch) is appended to the dump file name that reflects the file creation time. Default is --nodumpfts.\n\n--dumpfjson, --nodumpfjson\n\nif the --dumpfjson option is specified, dump file is produced in JSON format. Default is --nodumpfjson.\n\n--quoting, --noquoting\n\nif the --quoting option is specified, operation description strings that are supplied to command lines of shellcmd, spawn, and cspawn actions will be put inside single quotes. Each single quote (') that strings originally contain will be masked. This option prevents the shell from interpreting special symbols that operation description strings might contain. Default is --noquoting.\n\n--tail, --notail\n\nif the --notail option is specified, SEC will process all data that are currently available in input files and exit after reaching all EOFs. If all input is received from a pipe and the --notail option is given, SEC terminates when the last writer closes the pipe (EOF condition). Please note that with named pipes --notail should be used with --norwfifo. With the --tail option, SEC will jump to the end of input files and wait for new lines to arrive. Each input file is tracked both by its name and i-node, and input file rotations are handled seamlessly. If the input file is recreated or truncated, SEC will reopen it and process its content from the beginning. If the input file is removed (i.e., there is just an i-node left without a name), SEC will keep the i-node open and wait for the input file recreation. Default is --tail.\n\n--fromstart, --nofromstart\n\nthese flags have no meaning when the --notail option is also specified. When used in combination with --tail (or alone, since --tail is enabled by default), --fromstart will force SEC to read and process input files from the beginning to the end, before the 'tail' mode is entered. Default is --nofromstart.\n\n--detach, --nodetach\n\nif the --detach option is specified, SEC will disassociate itself from the controlling terminal and become a daemon at startup (note that SEC will close its standard input, standard output, and standard error, and change its working directory to the root directory). Default is --nodetach.\n\n--jointbuf, --nojointbuf\n\nif the --jointbuf option is specified, SEC uses joint input buffer for all input sources (the size of the buffer is set with the --bufsize option). The --nojointbuf option creates a separate input buffer for each input file, and a separate buffer for all synthetic and internal events (the sizes of all buffers are set with the --bufsize option). The --jointbuf option allows multiline patterns to match lines from several input sources, while the --nojointbuf pattern restricts the matching to lines from one input source only. See INPUT PROCESSING AND TIMING section for more information. If the size of input buffer(s) is 1 (either explicitly set with --bufsize=1 or automatically determined from SEC rules), --jointbuf option is enabled, otherwise the default is --nojointbuf.\n\n--keepopen, --nokeepopen\n\nif the --keepopen option is specified, SEC will keep input files open across soft restarts. When the SIGABRT signal is received, SEC will not reopen input files which have been opened previously, but will only open input files which are in the closed state. The --nokeepopen option forces SEC to close and (re)open all input files during soft restarts. Default is --keepopen.\n\n--rwfifo, --norwfifo\n\nif the --norwfifo option is specified, named pipe input files are opened in read-only mode. In this mode, the named pipe has to be reopened when the last writer closes the pipe, in order to clear the EOF condition on the pipe. With the --rwfifo option, named pipe input files are opened in read-write mode, although SEC never writes to the pipes. In this mode, the pipe does not need to be reopened when an external writer closes it, since there is always at least one writer on the pipe and EOF will never appear. Therefore, if the --notail option has been given, --norwfifo should also be specified. Default is --rwfifo.\n\n--childterm, --nochildterm\n\nif the --childterm option is specified, SEC will send the SIGTERM signal to all its child processes when it terminates or goes through a full restart. Default is --childterm.\n\n--intevents, --nointevents\n\nSEC will generate internal events when it starts up, when it receives certain signals, and when it terminates gracefully. Specific rules can be written to match those internal events, in order to accomplish special tasks at SEC startup, restart, and shutdown. See INTERNAL EVENTS AND CONTEXTS section for more information. Default is --nointevents.\n\n--intcontexts, --nointcontexts\n\nSEC will create an internal context when it reads a line from an input file. This will help the user to write rules that match data from particular input source only. See INTERNAL EVENTS AND CONTEXTS section for more information. Default is --nointcontexts.\n\n--testonly, --notestonly\n\nif the --testonly option is specified, SEC will exit immediately after parsing the configuration file(s). If the configuration file(s) contained no faulty rules, SEC will exit with 0, otherwise with 1. Default is --notestonly.\n\n--help, -?\n\nSEC will output usage information and exit.\n\n--version\n\nSEC will output version information and exit.\n\nNote that options can be introduced both with the single dash (-) and double dash (--), and both the equal sign (=) and whitespace can be used for separating the option name from the option value. For example, -conf=<file_pattern> and --conf <file_pattern> options are equivalent.\n\nCONFIGURATION FILES\n\nEach SEC configuration file consists of rule definitions which are separated by empty lines, whitespace lines and/or comment lines. Each rule definition consists of keyword=value fields, one keyword and value per line. Values are case insensitive only where character case is not important (like the values specifying rule types, e.g., 'Single' and 'single' are treated identically). The backslash character (\\) may be used at the end of a line to continue the current rule field in the next line. Lines which begin with the number sign (#) are treated as comments and ignored (whitespace characters may precede #). Any comment line, empty line, whitespace line, or end of file will terminate the preceding rule definition. For inserting comments into rule definitions, the rem keyword can be used. For example, the following lines define two rules:\n\ntype=Single\n\nrem=this rule matches any line which contains \\\n\nthree consecutive A characters and writes the string \\\n\n\"three A characters were observed\" to standard output\n\nptype=SubStr\n\npattern=AAA\n\ndesc=Three A characters\n\naction=write - three A characters were observed\n\n# This comment line ends preceding rule definition.\n\n# The following rule works like the previous rule,\n\n# but looks for three consecutive B characters and\n\n# writes the string \"three B characters were observed\"\n\n# to standard output\n\ntype=Single\n\nptype=SubStr\n\npattern=BBB\n\ndesc=Three B characters\n\naction=write - three B characters were observed\n\nApart from keywords that are part of rule definitions, label keywords may appear anywhere in the configuration file. The value of each label keyword will be treated as a label that can be referred to in rule definitions as a point-of-continue. This allows for continuing event processing at a rule that follows the label, after the current rule has matched and processed the event.\n\nThe points-of-continue are defined with continue* fields. Accepted values for these fields are:\n\nTakeNext\n\nafter an event has matched the rule, search for matching rules in the configuration file will continue from the next rule.\n\nGoTo <label>\n\nafter an event has matched the rule, search for matching rules will continue from the location of <label> in the configuration file (<label> must be defined with the label keyword anywhere in the configuration file *after* the current rule definition).\n\nDontCont (default value)\n\nafter an event has matched the rule, search for matching rules ends in the *current* configuration file.\n\nEndMatch\n\nafter an event has matched the rule, search for matching rules ends for *all* configuration files.\n\nSEC rules from the same configuration file are matched against input in the order they have been given in the file. For example, consider a configuration file which contains the following rule sequence:\n\ntype=Single\n\nptype=SubStr\n\npattern=AAA\n\nrem=after this rule has matched, continue from last rule\n\ncontinue=GoTo lastRule\n\ndesc=Three A characters\n\naction=write - three A characters were observed\n\ntype=Single\n\nptype=SubStr\n\npattern=BBB\n\nrem=after this rule has matched, don't consider following rules, \\\n\nsince 'continue' defaults to 'DontCont'\n\ndesc=Three B characters\n\naction=write - three B characters were observed\n\ntype=Single\n\nptype=SubStr\n\npattern=CCC\n\nrem=after this rule has matched, continue from next rule\n\ncontinue=TakeNext\n\ndesc=Three C characters\n\naction=write - three C characters were observed\n\nlabel=lastRule\n\ntype=Single\n\nptype=SubStr\n\npattern=DDD\n\ndesc=Three D characters\n\naction=write - three D characters were observed\n\nFor the input line \"AAABBBCCCDDD\", this ruleset writes strings \"three A characters were observed\" and \"three D characters were observed\" to standard output. If the input line is \"BBBCCCDDD\", the string \"three B characters were observed\" is written to standard output. For the input line \"CCCDDD\", strings \"three C characters were observed\" and \"three D characters were observed\" are sent to standard output, while the input line \"DDD\" produces the output string \"three D characters were observed\".\n\nIf there are two or more configuration files, rule sequence from every file is matched against input (unless explicitly specified otherwise). For example, suppose SEC is started with the command line\n\n/usr/bin/sec --input=- \\\n\n--conf=/etc/sec/sec1.rules --conf=/etc/sec/sec2.rules\n\nand the configuration file /etc/sec/sec1.rules has the following content:\n\ntype=Single\n\nptype=SubStr\n\npattern=AAA\n\ndesc=Three A characters\n\naction=write - three A characters were observed\n\ntype=Single\n\nptype=SubStr\n\npattern=BBB\n\ncontinue=EndMatch\n\ndesc=Three B characters\n\naction=write - three B characters were observed\n\nAlso, suppose the configuration file /etc/sec/sec2.rules has the following content:\n\ntype=Single\n\nptype=SubStr\n\npattern=CCC\n\ndesc=Three C characters\n\naction=write - three C characters were observed\n\nIf SEC receives the line \"AAABBBCCC\" from standard input, rules from both configuration files are tried, and as a result, the strings \"three A characters were observed\" and \"three C characters were observed\" are written to standard output. Note that rules from /etc/sec/sec1.rules are tried first against the input line, since the option --conf=/etc/sec/sec1.rules is given before --conf=/etc/sec/sec2.rules in the SEC command line (see also INPUT PROCESSING AND TIMING section for a more detailed discussion). If SEC receives the line \"BBBCCC\" from standard input, the second rule from /etc/sec/sec1.rules produces a match, and the string \"three B characters were observed\" is written to standard output. Since the rule contains continue=EndMatch statement, the search for matching rules will end for all configuration files, and rules from /etc/sec/sec2.rules will not be not tried. Without this statement, the search for matching rules would continue in /etc/sec/sec2.rules, and the first rule would write the string \"three C characters were observed\" to standard output.\n\nPATTERNS, PATTERN TYPES AND MATCH VARIABLES\n\nPatterns and pattern types are defined with pattern* and ptype* rule fields. Many pattern types define the number of lines N which the pattern matches (if N is omitted, 1 is assumed). If N is greater than 1, the scope of matching is set with the --jointbuf and --nojointbuf options. With --jointbuf, the pattern is used for matching N last input lines taken from the joint input buffer (the lines can come from different input sources). With --nojointbuf, the source of the last input line is identified, and the pattern is matched with N last input lines from the input buffer of the identified source.\n\nSubStr[N]\n\npattern is a string that is searched in the last N input lines L1, L2, ..., LN. If N is greater than 1, the input lines are joined into a string \"L1<NEWLINE>L2<NEWLINE>...<NEWLINE>LN\", and the pattern string will be searched from it. If the pattern string is found in input line(s), the pattern matches. Backslash sequences \\t, \\n, \\r, \\s, and \\0 can be used in the pattern for denoting tabulation, newline, carriage return, space character, and empty string, respectively, while \\\\ denotes backslash itself. For example, consider the following pattern definition:\n\nptype=substr\n\npattern=Backup done:\\tsuccess\n\nThe pattern matches lines containing \"Backup done:<TAB>success\".\n\nNote that since the SubStr[N] pattern type has been designed for fast matching, it does not support match variables.\n\nRegExp[N]\n\npattern is a Perl regular expression (see perlre(1) for more information) for matching the last N input lines L1, L2, ..., LN. If N is greater than 1, the input lines are joined into a string \"L1<NEWLINE>L2<NEWLINE>...<NEWLINE>LN\", and the regular expression is matched with this string. If the regular expression matches, match variables will be set, and these match variables can be used in other parts of the rule definition.\n\nIn addition to numbered match variables ($1, $2, etc.), SEC supports named match variables $+{name} and the $0 variable. The $0 variable holds the entire string of last N input lines that the regular expression has matched. Named match variables can be created in newer versions of Perl regular expression language, e.g., (?<myvar>AB|CD) sets $+{myvar} to AB or CD. Also, SEC creates special named match variables $+{_inputsrc} and $+{_intcontext}. The $+{_inputsrc} variable holds input file name(s) where matching line(s) came from. The $+{_intcontext} variable holds the name of current internal context (see INTERNAL EVENTS AND CONTEXTS section for more information). If internal context has not been set up for the current input source, the variable is set to Perl undefined value.\n\nFor example, the following pattern matches the SSH \"Connection from\" event, and sets $0 to the entire event line, both $1 and $+{ip} to the IP address of the remote node, and $2 to the port number at the remote node:\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: Connection from (?<ip>[\\d.]+) port (\\d+)\n\nIf the matching event comes from input file /var/log/messages with internal context MSGS, the $+{_inputsrc} and $+{_intcontext} variables are set to strings \"/var/log/messages\" and \"MSGS\", respectively.\n\nAlso, SEC allows for match caching and for the creation of additional named match variables through variable maps which are defined with the varmap* fields. Variable map is a list of name=number mappings separated by semicolons, where name is the name for the named variable and number identifies a numbered match variable that is set by the regular expression. Each name must begin with a letter and consist of letters, digits and underscores. After the regular expression has matched, named variables specified by the map are created from corresponding numbered variables. If the same named variable is set up both from the regular expression and variable map, the map takes precedence.\n\nIf name is not followed by the equal sign and number in the varmap* field, it is regarded as a common name for all match variables and their values from a successful match. This name is used for caching a successful match by the pattern -- match variables and their values are stored in the memory-based pattern match cache under name. Cached match results can be reused by Cached and NCached patterns. Note that before processing each new input line, previous content of the pattern match cache is cleared. Also note that a successful pattern match is cached even if the subsequent context expression evaluation yields FALSE (see INPUT PROCESSING AND TIMING section for more information).\n\nFor example, consider the following pattern definition:\n\nptype=regexp\n\npattern=(?i)(\\S+\\.mydomain).*printer: toner\\/ink low\n\nvarmap=printer_toner_or_ink_low; message=0; hostname=1\n\nThe pattern matches \"printer: toner/ink low\" messages in a case insensitive manner from printers belonging to .mydomain. Note that the printer hostname is assigned to $1 and $+{hostname}, while the whole message line is assigned to $0 and $+{message}. If the message comes from file /var/log/test which does not have an internal context defined, the $+{_inputsrc} variable is set to string \"/var/log/test\", while $+{_intcontext} is set to Perl undefined value. Also, these variables and their values are stored to the pattern match cache under the name \"printer_toner_or_ink_low\".\n\nThe following pattern definition produces a match if the last two input lines are AAA and BBB:\n\nptype=regexp2\n\npattern=^AAA\\nBBB$\n\nvarmap=aaa_bbb\n\nNote that with the --nojointbuf option the pattern only matches if the matching lines are coming from the *same* input file, while the --jointbuf option lifts that restriction.\n\nIn the case of a match, $0 is set to \"AAA<NEWLINE>BBB\", $+{_inputsrc} to file name(s) for matching lines, and $+{_intcontext} to the name of current internal context. Also, these variable-value pairs are cached under the name \"aaa_bbb\".\n\nPerlFunc[N]\n\npattern is a Perl function for matching the last N input lines L1, L2, ..., LN. The Perl function is compiled at SEC startup with the Perl eval() function, and eval() must return a code reference for the pattern to be valid (see also PERL INTEGRATION section). The function is called in Perl list context, and with the --jointbuf option, lines L1, L2, ..., LN and the names of corresponding input files F1, F2, ..., FN are passed to the function as parameters:\n\nfunction(L1, L2, ..., LN, F1, F2, ..., FN)\n\nNote that with the --nojointbuf option, the function is called with a single file name parameter F, since lines L1, ..., LN are coming from the same input file:\n\nfunction(L1, L2, ..., LN, F)\n\nAlso note that if the input line is a synthetic event, the input file name is Perl undefined value.\n\nIf the function returns several values or a single value that is true in Perl boolean context, the pattern matches. If the function returns no values or a single value that is false in Perl boolean context (0, empty string or undefined value), the pattern does not match. If the pattern matches, return values will be assigned to numbered match variables ($1, $2, etc.). Like with RegExp patterns, the $0 variable is set to matching input line(s), the $+{_inputsrc} variable is set to input file name(s), the $+{_intcontext} variable is set to the name of current internal context, and named match variables can be created from variable maps. For example, consider the following pattern definition:\n\nptype=perlfunc2\n\npattern=sub { return ($_[0] cmp $_[1]); }\n\nThe pattern compares last two input lines in a stringwise manner ($_[1] holds the last line and $_[0] the preceding one), and matches if the lines are different. Note that the result of the comparison is assigned to $1, while two matching lines are concatenated (with the newline character between them) and assigned to $0. If matching lines come from input file /var/log/mylog with internal context TEST, the $+{_inputsrc} and $+{_intcontext} variables are set to strings \"/var/log/mylog\" and \"TEST\", respectively.\n\nThe following pattern produces a match for any line, and sets $1, $2 and $3 variables to strings \"abc\", \"def\" and \"ghi\", respectively (also, $0 is set to the whole input line, $+{_inputsrc} to the input file name, and $+{_intcontext} to the name of internal context associated with input file $+{_inputsrc}):\n\nptype=perlfunc\n\npattern=sub { return (\"abc\", \"def\", \"ghi\"); }\n\nThe following pattern definition produces a match if the input line is not a synthetic event and contains either the string \"abc\" or \"def\". The $0 variable is set to the matching line. If matching line comes from /var/log/test without an internal context, $+{_intcontext} is set to Perl undefined value, while $1, $+{file} and $+{_inputsrc} are set to string \"/var/log/test\":\n\nptype=perlfunc\n\npattern=sub { if (defined($_[1]) && $_[0] =~ /abc|def/) \\\n\n{ return $_[1]; } return 0; }\n\nvarmap= file=1\n\nFinally, if a function pattern returns a single value which is a reference to a Perl hash, named match variables are created from key-value pairs in the hash. For example, the following pattern matches a line if it contains either the string \"three\" or \"four\". Apart from setting $0, $+{_inputsrc} and $+{_intcontext}, the pattern also creates match variables $+{three} and $+{four}, and sets them to 3 and 4, respectively:\n\nptype=perlfunc\n\npattern=sub { my(%hash); \\\n\nif ($_[0] !~ /three|four/) { return 0; } \\\n\n$hash{\"three\"} = 3; $hash{\"four\"} = 4; return \\%hash; }\n\nCached\n\npattern is a name that is searched in the pattern match cache (entries are stored into the cache with the varmap* fields). If an entry with the given name is found in the cache, the pattern matches, and match variables and values are retrieved from the cache. For example, if the input line matches the following pattern\n\nptype=perlfunc\n\npattern=sub { if (defined($_[1]) && $_[0] =~ /abc|def/) \\\n\n{ return $_[1]; } return 0; }\n\nvarmap=abc_or_def_found; file=1\n\nthen the entry \"abc_or_def_found\" is created in the pattern match cache. Therefore, the pattern\n\nptype=cached\n\npattern=abc_or_def_found\n\nwill also produce a match for this input line, and set the $0, $1, $+{file}, $+{_inputsrc}, and $+{_intcontext} variables to values from the previous match.\n\nNSubStr[N]\n\nlike SubStr[N], except that the result of the match is negated. Note that this pattern type does not support match variables.\n\nNRegExp[N]\n\nlike RegExp[N], except that the result of the match is negated and variable maps are not supported. Note that the only match variables supported by this pattern type are $0, $+{_inputsrc}, and $+{_intcontext}.\n\nNPerlFunc[N]\n\nlike PerlFunc[N], except that the result of the match is negated and variable maps are not supported. Note that the only match variables supported by this pattern type are $0, $+{_inputsrc}, and $+{_intcontext}.\n\nNCached\n\nlike Cached, except that the result of the match is negated. Note that this pattern type does not support match variables.\n\nTValue\n\npattern is a truth value, with TRUE and FALSE being legitimate values. TRUE always matches an input line, while FALSE never matches anything. Note that this pattern type does not support match variables.\n\nWhen match variables are substituted, each \"$$\" sequence is interpreted as a literal dollar sign ($) which allows for masking match variables. For example, the string \"Received $$1\" becomes \"Received $1\" after substitution, while \"Received $$$1\" becomes \"Received $<value_of_1st_var>\". In order to disambiguate numbered match variables from the following text, variable number must be enclosed in braces. For example, the string \"Received ${1}0\" becomes \"Received <value_of_1st_var>0\" after substitution, while the string \"Received $10\" would become \"Received <value_of_10th_var>\".\n\nIf the match variable was not set by the pattern, it is substituted with an empty string (i.e., a zero-width string). Thus the string \"Received $10!\" becomes \"Received !\" after substitution if the pattern did not set $10. (Note that prior to SEC-2.6, unset variables were *not* substituted.)\n\nIn the current version of SEC, names of $+{name} match variables must comply with the following naming convention -- the first character can be a letter or underscore, while remaining characters can be letters, digits, underscores and exclamation marks (!). However, when setting named match variables from a pattern, it is recommended to begin the variable name with a letter, since names of special automatically created variables begin with an underscore (e.g., $+{_inputsrc}).\n\nAfter the pattern has matched an event and match variables have been set, it is also possible to refer to previously cached match variables with the syntax $:{entryname:varname}, where entryname is the name of the pattern match cache entry, and varname is the name of the variable stored under the entry. For example, if the variable $+{ip} has been previously cached under the entry \"SSH\", it can be referred as $:{SSH:ip}. For the reasons of efficiency, the $:{entryname:varname} syntax is not supported for fast pattern types which do not set match variables (i.e., SubStr, NSubStr, NCached and TValue).\n\nNote that since Pair and PairWithWindow rules have two patterns, match variables of the first pattern are shadowed for some rule fields when the second pattern matches and sets variables. In order to refer to shadowed variables, their names must begin with % instead of $ (e.g., %1 refers to match variable $1 set by the first pattern). However, the use of the %-prefix is only valid under the following circumstances -- *both* pattern types support match variables *and* in the given rule field match variables from *both* patterns can be used.\n\nThe %-prefixed match variables are masked with the \"%%\" sequence (like regular match variables with \"$$\"). Similarly, the braces can be used for disambiguating the %-prefixed variables from the following text.\n\nFinally, note that the second pattern of Pair and PairWithWindow rules may contain match variables if the second pattern is of type SubStr, NSubStr, Regexp, or NRegExp. The variables are substituted at runtime with the values set by the first pattern. If the pattern is a regular expression, all special characters inside substituted values are masked with the Perl quotemeta() function and the final expression is checked for correctness.\n\nCONTEXTS AND CONTEXT EXPRESSIONS\n\nA SEC context is a memory based entity which has one or more names, a lifetime, and an event store. Also, an action list can be set up for a context which is executed immediately before the context expires.\n\nFor example, the action create MYCONTEXT 3600 (report MYCONTEXT /bin/mail root@localhost) creates the context MYCONTEXT which has a lifetime of 3600 seconds and empty event store. Also, immediately before MYCONTEXT expires and is dropped from memory, the action report MYCONTEXT /bin/mail root@localhost is executed which mails the event store of MYCONTEXT to root@localhost.\n\nContexts can be used for event aggregation and reporting. Suppose the following actions are executed in this order:\n\ncreate MYCONTEXT\n\nadd MYCONTEXT This is a test\n\nalias MYCONTEXT MYALIAS\n\nadd MYALIAS This is another test\n\nreport MYCONTEXT /bin/mail root@localhost\n\ndelete MYALIAS\n\nThe first action creates the context MYCONTEXT with infinite lifetime and empty event store. The second action appends the string \"This is a test\" to the event store of MYCONTEXT. The third action sets up an alias name MYALIAS for the context (names MYCONTEXT and MYALIAS refer to the same context data structure). The fourth action appends the string \"This is another test\" to the event store of the context. The fifth action writes the lines\n\nThis is a test\n\nThis is another test\n\nto the standard input of the /bin/mail root@localhost command. The sixth action deletes the context data structure from memory and drops its names MYCONTEXT and MYALIAS.\n\nSince contexts are accessible from all rules and event correlation operations, they can be used for data sharing and joining several rules into one event correlation scheme. In order to check for the presence of contexts from rules, context expressions can be employed.\n\nContext expressions are boolean expressions that are defined with the context* rule fields. Context expressions can be used for restricting the matches produced by patterns, since if the expression evaluates FALSE, the rule will not match an input event.\n\nThe context expression accepts context names, Perl miniprograms, Perl functions, and pattern match cache lookups as operands. These operands can be combined with the following operators:\n\n! - logical NOT,\n\n&& - short-circuit logical AND,\n\n|| - short-circuit logical OR.\n\nIn addition, parentheses can be used for grouping purposes.\n\nIf the operand does not contain any special operators (such as -> or :>, see below), it is treated as a context name. Context name operands may contain match variables, but may not contain whitespace. If the context name refers to an existing context, the operand evaluates TRUE, otherwise it evaluates FALSE.\n\nFor example, consider the following rule sequence:\n\ntype=Single\n\nptype=RegExp\n\npattern=Test: (\\d+)\n\ndesc=test\n\naction=create CONT_$1\n\ntype=Single\n\nptype=RegExp\n\npattern=Test2: (\\d+) (\\d+)\n\ncontext=CONT_$1 && CONT_$2\n\ndesc=test\n\naction=write - Both $1 and $2 have been seen in the past\n\nIf the following input lines appear in this order\n\nTest: 19\n\nTest: 261\n\nTest2: 19 787\n\nTest: 787\n\nTest2: 787 261\n\nthe first input line matches the first rule which creates the context CONT_19, and similarly, the second input line triggers the creation of the context CONT_261. The third input line \"Test2: 19 787\" matches the regular expression\n\nTest2: (\\d+) (\\d+)\n\nbut does not match the second rule, since the boolean expression\n\nCONT_19 && CONT_787\n\nevaluates FALSE (context CONT_19 exists, but context CONT_787 doesn't). The fourth input line matches the first rule which creates the context CONT_787. The fifth input line \"Test2: 787 261\" matches the second rule, since the boolean expression\n\nCONT_787 && CONT_261\n\nevaluates TRUE (both context CONT_787 and context CONT_261 exist), and therefore the string \"Both 787 and 261 have been seen in the past\" is written to standard output.\n\nIf the context expression operand contains the arrow operator (->), the text following the arrow must be a valid Perl function definition that is compiled at SEC startup with the Perl eval() function. The eval() must return a code reference (see also PERL INTEGRATION section for more information). If any text precedes the arrow, it is treated as a list of parameters for the function. Parameters must be separated by whitespace and may contain match variables. In order to evaluate the context expression operand, the Perl function is called in the Perl scalar context. If the return value of the function is true in the Perl boolean context, the operand evaluates TRUE, otherwise it evaluates FALSE.\n\nFor example, the following rule matches an SSH login failure event if the login attempt comes from a privileged port of the client host:\n\ntype=Single\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: Failed .+ for (\\S+) from [\\d.]+ port (\\d+) ssh2\n\ncontext=$2 -> ( sub { $_[0] < 1024 } )\n\ndesc=SSH login failure for $1 priv port $2\n\naction=write - SSH login failure for user $1 from a privileged port $2\n\nWhen the following message from SSH daemon appears\n\nDec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5 port 41063 ssh2\n\nthe regular expression of the rule matches this message, and the value of the $2 match variable (41063) is passed to the Perl function\n\nsub { $_[0] < 1024 }\n\nThis function returns true if its input parameter is less than 1024 and false otherwise, and therefore the above message will not match the rule. However, the following message\n\nDec 16 16:25:17 myserver sshd[13689]: Failed password for risto from 10.12.2.5 port 1023 ssh2\n\nmatches the rule, and the string \"SSH login failure for user risto from a privileged port 1023\" is written to standard output.\n\nAs another example, the following context expression evaluates TRUE if the /var/log/messages file does not exist or was last modified more than 1 hour ago (note that the Perl function takes no parameters):\n\ncontext= -> ( sub { my(@stat) = stat(\"/var/log/messages\"); \\\n\nreturn (!scalar(@stat) || time() - $stat[9] > 3600); } )\n\nIf the context expression operand contains the :> operator, the text that follows :> must be a valid Perl function definition that is compiled at SEC startup with the Perl eval() function. The eval() must return a code reference (see also PERL INTEGRATION section for more information). If any text precedes the :> operator, it is treated as a list of parameters for the function. Parameters must be separated by whitespace and may contain match variables. It is assumed that each parameter is a name of an entry in the pattern match cache. If an entry with the given name does not exist, Perl undefined value is passed to the function. If an entry with the given name exists, a reference to the entry is passed to the Perl function. Internally, each pattern match cache entry is implemented as a Perl hash which contains all match variables for the given entry. In the hash, each key-value pair represents some variable name and value, e.g., if cached match variable $+{ip} is holding 10.1.1.1, the hash contains the value 10.1.1.1 with the key ip. In order to evaluate the context expression operand, the Perl function is called in the Perl scalar context. If the return value of the function is true in the Perl boolean context, the operand evaluates TRUE, otherwise it evaluates FALSE.\n\nFor example, consider the following rule sequence:\n\ntype=Single\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: (?<status>Accepted|Failed) .+ \\\n\nfor (?<invuser>invalid user )?(?<user>\\S+) from (?<ip>[\\d.]+) \\\n\nport (?<port>\\d+) ssh2\n\nvarmap=SSH\n\ncontinue=TakeNext\n\ndesc=parse SSH login events and pass them to following rules\n\naction=none\n\ntype=Single\n\nptype=Cached\n\npattern=SSH\n\ncontext=SSH :> ( sub { $_[0]->{\"status\"} eq \"Failed\" && \\\n\n$_[0]->{\"port\"} < 1024 && \\\n\ndefined($_[0]->{\"invuser\"}) } )\n\ndesc=Probe of invalid user $+{user} from privileged port of $+{ip}\n\naction=pipe '%t: %s' /bin/mail -s 'SSH alert' root@localhost\n\nThe first rule matches and parses SSH login messages, and stores parsing results to the pattern match cache under the name SSH. The pattern of the second rule (defined with ptype=Cached and pattern=SSH) matches any input event for which the entry SSH has been previously created in the pattern match cache (in other words, the event has been recognized and parsed as an SSH login message). For each matching event, the second rule passes the reference to the SSH cache entry to the Perl function\n\nsub { $_[0]->{\"status\"} eq \"Failed\" && \\\n\n$_[0]->{\"port\"} < 1024 && \\\n\ndefined($_[0]->{\"invuser\"}) }\n\nThe function checks the values of $+{status}, $+{port}, and $+{invuser} match variables under the SSH entry, and returns true if $+{status} equals to the string \"Failed\" (i.e., login attempt failed), the value of $+{port} is less than 1024, and $+{invuser} holds a defined value (i.e., user account does not exist). If the function (and thus context expression) evaluates TRUE, the rule sends a warning e-mail to root@localhost that a non-existing user account was probed from a privileged port of a client host.\n\nIf the context expression operand begins with the varset keyword, the following string is treated as a name of an entry in the pattern match cache. The operand evaluates TRUE if the given entry exists, and FALSE otherwise.\n\nFor example, the following context expression definition evaluates TRUE if the pattern match cache entry SSH exists and under this entry, the value of the match variable $+{user} equals to the string \"risto\":\n\ncontext=varset SSH && SSH :> ( sub { $_[0]->{\"user\"} eq \"risto\" } )\n\nIf the context expression operand begins with the equal sign (=), the following text must be a Perl miniprogram which is a valid parameter for the Perl eval() function. The miniprogram may contain match variables. In order to evaluate the Perl miniprogram operand, it will be compiled and executed by calling the Perl eval() function in the Perl scalar context (see also PERL INTEGRATION section). If the return value from eval() is true in the Perl boolean context, the operand evaluates TRUE, otherwise it evaluates FALSE. Please note that unlike Perl functions of -> and :> operators which are compiled once at SEC startup, Perl miniprograms are compiled before each execution, and their evaluation is thus considerably more expensive.\n\nFor example, the following context expression evaluates TRUE when neither the context C1 nor the context C2 exists and the value of the $1 variable equals to the string \"myhost.mydomain\":\n\ncontext=!(C1 || C2) && =(\"$1\" eq \"myhost.mydomain\")\n\nSince && is a short-circuiting operator, the Perl code\n\n\"$1\" eq \"myhost.mydomain\"\n\nis *not* evaluated if either C1 or C2 exists.\n\nNote that since Perl functions and miniprograms may contain strings that clash with context expression operators (e.g., '!'), it is recommended to enclose them in parentheses, e.g.,\n\ncontext=$1 $2 -> ( sub { $_[0] != $_[1] } )\n\ncontext= =({my($temp) = 0; !$temp;})\n\nAlso, if function parameter lists contain such strings, they should be enclosed in parentheses in the similar way:\n\ncontext=($1! $2) -> ( sub { $_[0] eq $_[1] } )\n\nIf the whole context expression is enclosed in square brackets [], e.g., [MYCONTEXT1 && !MYCONTEXT2], SEC evaluates the expression *before* pattern matching (normally, the pattern is matched with input line(s) first, so that match variables would be initialized and substituted before the expression is evaluated). However, if the expression does not contain match variables and many input events are known to match the pattern but not the expression, the []-operator could save substantial amount of CPU time.\n\nACTIONS, ACTION LISTS AND ACTION LIST VARIABLES\n\nAction lists are defined with the action* rule fields. An action list consists of action definitions that are separated by semicolons. Each action definition begins with a keyword specifying the action type. Depending on the action type, parameters may follow, and non-constant parameters may contain match variables. For instance, if the $1 and $2 match variables have the values \"test1\" and \"the second test\", respectively, the action create MYCONT_$1 60 creates the context MYCONT_test1 with the lifetime of 60 seconds, while the action write - The names of tests: $1, $2 writes the string \"The names of tests: test1, the second test\" to standard output.\n\nApart from few exceptions explicitly noted, match variables are substituted at the earliest opportunity in action lists. For example, consider the following rule definition:\n\ntype=SingleWithThreshold\n\nptype=RegExp\n\npattern=sshd\\[\\d+\\]: Failed .+ for (\\S+) from [\\d.]+ port \\d+ ssh2\n\ndesc=Three SSH login failures within 1m\n\naction=pipe 'Three SSH login failures, first user is $1' \\\n\n/bin/mail -s 'SSH login alert' root@localhost\n\nwindow=60\n\nthresh=3\n\nWhen this rule matches an SSH login failure event which starts an event correlation operation, the operation substitutes the $1 match variable in the action list definition with the user name from the matching event, and user names from further events processed by this event correlation operation are not considered for $1. For example, if the following events are observed\n\nDec 16 16:24:52 myserver sshd[13671]: Failed password for root from 10.12.2.5 port 29736 ssh2\n\nDec 16 16:24:59 myserver sshd[13685]: Failed password for risto from 10.12.2.5 port 41063 ssh2\n\nDec 16 16:25:01 myserver sshd[13689]: Failed password for oracle from 10.12.2.5 port 11204 ssh2\n\nthen all events are processed by the same operation, and the message \"Three SSH login failures, first user is root\" is mailed to root@localhost.\n\nIn order to use semicolons inside a non-constant parameter, the parameter must be enclosed in parentheses (the outermost set of parentheses will be removed by SEC during configuration file parsing). For example, the following action list consists of delete and shellcmd actions:\n\naction=delete MYCONTEXT; shellcmd (rm /tmp/sec1.tmp; rm /tmp/sec2.tmp)\n\nThe delete action deletes the context MYCONTEXT, while the shellcmd action executes the command line rm /tmp/sec1.tmp; rm /tmp/sec2.tmp. Since the command line contains a semicolon, it has been enclosed in parentheses, since otherwise the semicolon would be mistakenly considered a separator between two actions.\n\nApart from match variables, SEC supports action list variables in action lists which facilitate data sharing between actions and Perl integration. Each action list variable has a name which must begin with a letter and consist of letters, digits and underscores. Names of built-in variables usually start with a dot character (.), so that they can be distinguished from user defined variables. In order to refer to an action list variable, its name must be prefixed by a percent sign (%). Unlike match variables, action list variables can only be used in action lists and they are substituted with their values immediately before the action list execution. Also, action list variables continue to exist after the current action list has been executed and can be employed in action lists of other rules.\n\nThe following action list variables are predefined by SEC:\n\n%s\n\noperation description string (the value of the desc field after match variables have been substituted with their values). Note that for the action2 field of Pair and PairWithWindow rules, the %s variable is set by evaluating the desc2 field of the rule.\n\n%t\n\nthe time in human-readable format, as returned by the Perl localtime() function in the Perl scalar context (e.g., Fri Feb 19 17:54:18 2016).\n\n%u\n\nthe time in seconds since Epoch, as returned by the time(2) system call.\n\n%.sec\n\nnumber of seconds after the minute, in the range 00-59 (the value consists of two digits and is zero padded on the left).\n\n%.min\n\nnumber of minutes after the hour, in the range 00-59 (the value consists of two digits and is zero padded on the left).\n\n%.hour\n\nnumber of hours past midnight, in the range 00-23 (the value consists of two digits and is zero padded on the left).\n\n%.hmsstr\n\nthe time in HH:MM:SS format (hours, minutes and seconds separated by colons, e.g., 09:32:04 or 18:06:02).\n\n%.mday\n\nday of the month, in the range 01-31 (the value consists of two digits and is zero padded on the left).\n\n%.mdaystr\n\nday of the month as a string (the value consists of two characters and is space padded on the left, e.g., \" 1\", \" 4\", \" 9\", or \"25\").\n\n%.mon\n\nmonth, in the range 01-12 (the value consists of two digits and is zero padded on the left).\n\n%.monstr\n\nabbreviated name of the month according to the current locale, as returned by the %b specification of the strftime(3) library call (e.g., Jan, May, or Sep).\n\n%.year\n\nyear (e.g., 1998 or 2016).\n\n%.wday\n\nday of the week, in the range 0-6 (0 denotes Sunday).\n\n%.wdaystr\n\nabbreviated name of the day of the week according to the current locale, as returned by the %a specification of the strftime(3) library call (e.g., Mon, Wed, or Sat).\n\n%.tzname\n\nname of the timezone according to the current locale, as returned by the %Z specification of the strftime(3) library call (e.g., UTC or EET).\n\n%.tzoff\n\ntimezone offset from UTC, as returned by the %z specification of the strftime(3) library call (e.g., -0500 or +0200).\n\n%.tzoff2\n\ntimezone offset from UTC in +hh:mm/-hh:mm format (e.g., -05:00 or +02:00), provided that the %z specification of the strftime(3) library call returns the value in +hhmm/-hhmm format (if the value does not follow this format, %.tzoff2 is set to an empty string).\n\n%.nl\n\nnewline character.\n\n%.cr\n\ncarriage return character.\n\n%.tab\n\ntabulation character.\n\n%.sp\n\nspace character.\n\n%.chr0, ..., %.chr31\n\nASCII 0..31 control characters (e.g., %.chr7 is bell and %.chr12 is form feed character).\n\nFor example, the following action list assigns the current time in human-readable format and the string \"This is a test event\" to the %text action list variable, and mails the value of %text to root@localhost:\n\naction=assign %text %t: This is a test event; \\\n\npipe '%text' /bin/mail root@localhost\n\nIf the action list is executed at Nov 19 10:58:51 2015, the assign action sets the %text action list variable to the string \"Thu Nov 19 10:58:51 2015: This is a test event\", while the pipe action mails this string to root@localhost. Note that unlike match variables, action list variables have a global scope, and accessing the value of the %text variable in action lists of other rules will thus yield the string \"Thu Nov 19 10:58:51 2015: This is a test event\" (until another value is assigned to %text).\n\nIn order to disambiguate the variable from the following text, the variable name must be enclosed in braces. For example, the following action\n\naction=write - %{.year}-%{.mon}-%{.mday}T%{.hmsstr}%{.tzoff2}\n\nwrites a timestamp in ISO 8601 format to standard output, e.g., 2016-02-24T07:34:01+02:00 (replacing %{.mday} with %.mday in the above action would mistakenly create a reference to %.mdayT variable).\n\nWhen action list variables are substituted with their values, each sequence \"%%\" is interpreted as a literal percent sign (%) which allows for masking the variables. For example, the string \"s%%t\" becomes \"s%t\" after substitution, not \"s%<timestamp>\".\n\nHowever, note that if %-prefixed match variables are supported for the action2 field of the Pair or PairWithWindow rule, the sequence \"%%%\" must be used in action2 for masking a variable, since the string goes through *two* variable substitution rounds (first for %-prefixed match variables and then for action list variables, e.g., the string \"s%%%t\" first becomes \"s%%t\" and finally \"s%t\").\n\nWhenever a rule field goes through several substitution rounds, the $ or % characters are masked inside values substituted during earlier rounds, in order to avoid unwanted side effects during later rounds.\n\nIf the action list variable has not been set, it is substituted with an empty string (i.e., a zero-width string). Thus the string \"Value of A is: %a\" becomes \"Value of A is: \" after substitution if the variable %a is unset. (Note that prior to SEC-2.6, unset variables were *not* substituted.)\n\nFinally, the values are substituted as strings, therefore values of other types (e.g., references) lose their original meaning, unless explicitly noted otherwise (e.g., if a Perl function reference is stored to an action list variable, the function can later be invoked through this variable with the call action).\n\nSEC supports the following actions (optional parameters are enclosed in square brackets):\n\nnone\n\nNo action.\n\nlogonly [<string>]\n\nMessage <string> is logged to destinations given with the --log and --syslog options. The level of the log message is set to 4 (see the --debug option for more information on log message levels). Default value for <string> is %s. For example, consider the following action list definition:\n\naction=logonly This is a test\n\nThe above logonly action logs the message \"This is a test\" with level 4.\n\nwrite <filename> [<string>]\n\nString <string> with a terminating newline is written to the file <filename> (<filename> may not contain whitespace). File may be a regular file, named pipe, or standard output (denoted by -). If the file is a regular file, <string> is appended to the end of the file. If the file does not exist, it is created as a regular file before writing. Note that the file will not be closed after the action completes, and the following write actions will access an already open file. However, several signals cause the file to be closed and reopened, and for rotating files created with write action, the SIGUSR2 signal can be used (see SIGNALS section for more information). Default value for <string> is %s. For example, consider the following action list definition:\n\naction=write /var/log/test.log %t $0\n\nThe above write action prepends human-readable timestamp and separating space character to the value of the $0 match variable, and the resulting string is appended to file /var/log/test.log with terminating newline.\n\nwriten <filename> [<string>]\n\nSimilar to the write action, except that the string <string> is written without a terminating newline. Note that write and writen actions share the same filehandle for accessing the file. For example, consider the following action list definition:\n\naction=writen - ab; writen - c; writen - %.nl\n\nThe above action list writes the string \"abc<NEWLINE>\" to standard output, and is thus identical to write - abc (and also to writen - abc%.nl).\n\nclosef <filename>\n\nClose the file <filename> that has been previously opened by the write or writen action (<filename> may not contain whitespace).\n\nowritecl <filename> [<string>]\n\nSimilar to the write action, except that the file <filename> is opened and closed at each write. Also, the string <string> is written without a terminating newline. If the file has already been opened by a previous write action, owritecl does not use existing filehandle, but opens and closes the file separately. For example, consider the following action list definition:\n\naction=owritecl /var/log/test-%{.year}%{.mon}%{.mday} $0%{.nl}\n\nThe above owritecl action appends the value of the $0 match variable with terminating newline to file /var/log/test-YYYYMMDD, where YYYYMMDD reflects the current date (e.g., if the current date is April 1 2018, the file is /var/log/test-20180401). Since the file is closed after each write, the old file will not be left open when date changes.\n\nudgram <filename> [<string>]\n\nString <string> is written to the UNIX datagram socket <filename> (<filename> may not contain whitespace). Note that the socket will not be closed after the action completes, and the following udgram actions will access an already open socket. However, several signals cause the socket to be closed and reopened (see SIGNALS section for more information). Default value for <string> is %s. For example, consider the following action list definition:\n\naction=udgram /dev/log <30>%.monstr %.mdaystr %.hmsstr sec: This is a test\n\nThe above udgram action sends a syslog message to local syslog daemon via /dev/log socket, where message priority is 30 (corresponds to the \"daemon\" facility and \"info\" level), syslog tag is \"sec\" and message text is \"This is a test\". Note that message substring \"%.monstr %.mdaystr %.hmsstr\" evaluates to timestamp in BSD syslog format (e.g., Mar 31 15:36:07).\n\ncloseudgr <filename>\n\nClose the UNIX datagram socket <filename> that has been previously opened by the udgram action (<filename> may not contain whitespace).\n\nustream <filename> [<string>]\n\nString <string> is written to the UNIX stream socket <filename> (<filename> may not contain whitespace). Note that the socket will not be closed after the action completes, and the following ustream actions will access an already open socket. However, several signals cause the socket to be closed and reopened (see SIGNALS section for more information). Default value for <string> is %s.\n\ncloseustr <filename>\n\nClose the UNIX stream socket <filename> that has been previously opened by the ustream action (<filename> may not contain whitespace).\n\nudpsock <host>:<port> [<string>]\n\nString <string> is sent to the UDP port <port> of the host <host>. Note that the UDP socket which is used for communication will not be closed after the action completes, and the following udpsock actions for the same remote peer will use an already existing socket. However, several signals cause the socket to be closed and recreated (see SIGNALS section for more information). Default value for <string> is %s. For example, consider the following action list definition:\n\naction=udpsock mysrv:514 <13>%.monstr %.mdaystr %.hmsstr myhost test: $0\n\nThe above udpsock action sends a BSD syslog message to port 514/udp of remote syslog server mysrv, where message priority is 13 (corresponds to the \"user\" facility and \"notice\" level), name of the local host is \"myhost\", syslog tag is \"test\" and message text is the value if the $0 match variable.\n\ncloseudp <host>:<port>\n\nClose the UDP socket for peer <host>:<port> that has been previously opened by the udpsock action.\n\ntcpsock <host>:<port> [<string>]\n\nString <string> is sent to the TCP port <port> of the host <host>. The timeout value given with the --socket-timeout option determines for how many seconds SEC will attempt to establish a connection to the remote peer. If the connection establishment does not succeed immediately, the tcpsock action buffers <string> in memory for later sending to the remote peer. Note that the relevant TCP socket will not be closed after <string> has been transmitted, and the following tcpsock actions for the same peer will use an already existing socket. However, several signals cause the socket to be closed and recreated (see SIGNALS section for more information). Default value for <string> is %s. For example, consider the following action list definition:\n\naction=tcpsock grsrv:2003 ssh.login.failures %{num} %{u}%{.nl}\n\nThe above tcpsock action sends the value of the action list variable %{num} to port 2003/tcp of the Graphite server grsrv, so that the value is recorded under metric path ssh.login.failures. Note that the %{u} action list variable evaluates to current time in seconds since Epoch and is used for setting the timestamp for recorded value.\n\nclosetcp <host>:<port>\n\nClose the TCP socket for peer <host>:<port> that has been previously opened by the tcpsock action.\n\nshellcmd <cmdline>\n\nFork a process for executing command line <cmdline>. If <cmdline> contains shell metacharacters, <cmdline> is parsed by shell. If the --quoting option was specified and <cmdline> contains %s variables, the value of %s is quoted with single quotes before substituting it into <cmdline>; if the value of %s contains single quotes, they are masked with backslashes (e.g., abc is converted to 'abc' and aa'bb is converted to 'aa'\\''bb'). For additional information, see CHILD PROCESSES section. For example, consider the following action list definition:\n\naction=shellcmd (cat /tmp/report | mail root; rm -f /tmp/report); \\\n\nlogonly Report sent to user root\n\nThe shellcmd action of this action list executes the command line\n\ncat /tmp/report | mail root; rm -f /tmp/report\n\nand the logonly action logs the message \"Report sent to user root\". Since the command line contains a semicolon which is used for separating shellcmd and logonly actions, the command line is enclosed in parentheses.\n\nspawn <cmdline>\n\nSimilar to the shellcmd action, except that each line from the standard output of <cmdline> becomes a synthetic event and will be treated like a line from input file (see the event action for more information). If the --intcontexts command line option is given, internal context _INTERNAL_EVENT is set up before each synthetic event is processed (see INTERNAL EVENTS AND CONTEXTS section for more information). For example, consider the following action list definition:\n\naction=spawn (cat /tmp/events; rm -f /tmp/events)\n\nThe above spawn action will generate synthetic events from all lines in file /tmp/events and remove the file. Since the command line contains a semicolon which is used for separating actions, the command line is enclosed in parentheses.\n\ncspawn <name> <cmdline>\n\nSimilar to the spawn action, except that if the --intcontexts command line option is given, internal context <name> is set up for each synthetic event.\n\ncmdexec <cmdline>\n\nFork a process for executing command line <cmdline>. Unlike shellcmd action, <cmdline> is not parsed by shell, but split into arguments by using whitespace as a separator, and passed to execvp(3) for execution. Note that splitting into arguments is done when cmdexec action is loaded from the configuration file and parsed, not at runtime (e.g., if <cmdline> is /usr/local/bin/mytool $1 $2, the values of $1 and $2 variables are regarded as single arguments even if the values contain whitespace). For additional information, see CHILD PROCESSES section. For example, consider the following action list definition:\n\naction=cmdexec rm /tmp/report*\n\nThe above cmdexec action will remove the file /tmp/report* without treating * as a file pattern character that matches any string.\n\nspawnexec <cmdline>\n\nSimilar to the cmdexec action, except that each line from the standard output of <cmdline> becomes a synthetic event and will be treated like a line from input file (see the event action for more information). If the --intcontexts command line option is given, internal context _INTERNAL_EVENT is set up before each synthetic event is processed (see INTERNAL EVENTS AND CONTEXTS section for more information).\n\ncspawnexec <name> <cmdline>\n\nSimilar to the spawnexec action, except that if the --intcontexts command line option is given, internal context <name> is set up for each synthetic event.\n\npipe '[<string>]' [<cmdline>]\n\nFork a process for executing command line <cmdline>. If <cmdline> contains shell metacharacters, <cmdline> is parsed by shell. The string <string> with a terminating newline is written to the standard input of <cmdline> (single quotes are used for disambiguating <string> from <cmdline>). If <string> contains semicolons, <string> must be enclosed in parentheses (e.g., pipe '($1;$2)' /bin/cat). Default value for <string> is %s. If <cmdline> is omitted, <string> is written to standard output. For additional information, see CHILD PROCESSES section. For example, consider the following action list definition:\n\naction=pipe 'Offending activities from host $1' /bin/mail root@localhost\n\nThe above pipe action writes the line \"Offending activities from host <hostname>\" to the standard input of the /bin/mail root@localhost command which sends this line to root@localhost via e-mail (<hostname> is the value of the $1 match variable).\n\npipeexec '[<string>]' [<cmdline>]\n\nSimilar to the pipe action, except <cmdline> is not parsed by shell, but split into arguments by using whitespace as a separator, and passed to execvp(3) for execution. Note that splitting into arguments is done when pipeexec action is loaded from the configuration file and parsed, not at runtime (e.g., if <cmdline> is /usr/local/bin/mytool $1 $2, the values of $1 and $2 variables are regarded as single arguments even if the values contain whitespace). For example, consider the following action list definition:\n\naction=pipeexec 'Offending activities from host $1' \\\n\n/bin/mail -s SEC%{.sp}alert $2\n\nThe above pipeexec action writes the line \"Offending activities from host <hostname>\" to the standard input of the /bin/mail -s <subject> <user> command which sends this line to <user> via e-mail with subject <subject> (<hostname> is the value of the $1 match variable, while <user> is the value of the $2 match variable). Note that since <subject> is defined as SEC%{.sp}alert and does not contain whitespace, it is treated as a single argument for the -s flag of the /bin/mail command. However, since <subject> contains the %.sp action list variable, the string \"SEC alert\" will be used for the e-mail subject at runtime. Also, if the value of the $2 match variable contains shell metacharacters, they will not be interpreted by the shell.\n\ncreate [<name> [<time> [<action list>] ] ]\n\nCreate a context with the name <name>, lifetime of <time> seconds, and empty event store. The <name> parameter may not contain whitespace and defaults to %s. The <time> parameter must evaluate to an unsigned integer at runtime. Specifying 0 for <time> or omitting the value means infinite lifetime. If <action list> is given, it will be executed when the context expires. If <action list> contains several actions, the list must be enclosed in parentheses. In <action list>, the internal context name _THIS may be used for referring to the current context (see INTERNAL EVENTS AND CONTEXTS section for a detailed discussion). If an already existing context is recreated with create, its remaining lifetime is set to <time> seconds, its action list is reinitialized, and its event store is emptied. For example, consider the following action list definition:\n\naction=write /var/log/test.log $0; create TIMER 3600 \\\n\n( logonly Closing /var/log/test.log; closef /var/log/test.log )\n\nThe write action from the above action list appends the value of the $0 match variable to file /var/log/test.log, while the create action creates the context TIMER which will exist for 3600 seconds. Since this context is recreated at each write, the context can expire only if the action list has not been executed for more than 3600 seconds (i.e., the action list has last updated the file more than 1 hour ago). If that is the case, the action list\n\nlogonly Closing /var/log/test.log; closef /var/log/test.log\n\nis executed which logs the message \"Closing /var/log/test.log\" with the logonly action and closes /var/log/test.log with the closef action. When the execution of this action list is complete, the TIMER context is deleted.\n\ndelete [<name>]\n\nDelete the context <name>. The <name> parameter may not contain whitespace and defaults to %s.\n\nobsolete [<name>]\n\nSimilar to the delete action, except that the action list of the context <name> (if present) is executed before deletion.\n\nset <name> <time> [<action list>]\n\nChange settings for the context <name>. The creation time of the context is set to the current time, and the lifetime of the context is set to <time> seconds. If the <action list> parameter is given, the context action list is set to <action list>, otherwise the context action list is not changed. The <name> parameter may not contain whitespace and defaults to %s. The <time> parameter must evaluate to an unsigned integer or hyphen (-) at runtime. Specifying 0 for <time> means infinite lifetime. If <time> equals to -, the creation time and lifetime of the context are not changed. If <action list> contains several actions, the list must be enclosed in parentheses. In <action list>, the internal context name _THIS may be used for referring to the current context (see INTERNAL EVENTS AND CONTEXTS section for a detailed discussion). For example, consider the following action list definition:\n\naction=set C_$1 30 ( logonly Context C_$1 has expired )\n\nThe above set action sets the context C_<suffix> to expire after 30 seconds with a log message about expiration (<suffix> is the value of the $1 match variable).\n\nalias <name> [<alias>]\n\nCreate an alias name <alias> for the context <name>. After creation, both <alias> and <name> will point to the same context data structure, and can thus be used interchangeably for referring to the context. The <name> and <alias> parameters may not contain whitespace, and <alias> defaults to %s. If the context <name> does not exist, the alias name is not created. If the delete action is called for one of the context names, the context data structure is destroyed, and all context names (which are now pointers to unallocated memory) cease to exist. Also note that when the context expires, its action list is executed only once, no matter how many names the context has.\n\nunalias [<alias>]\n\nDrop an existing context name <alias>, so that it can no longer be used for referring to the given context. The <alias> parameter may not contain whitespace and defaults to %s. If the name <alias> is the last reference to the context, the unalias action is identical to delete.\n\nadd <name> [<string>]\n\nString <string> is appended to the end of the event store of the context <name>. The <name> parameter may not contain whitespace, and the <string> parameter defaults to %s. If the context <name> does not exist, the context is created with an infinite lifetime, empty action list and empty event store (as with create <name>) before adding the string to event store. If <string> is a multi-line string (i.e., it contains newlines), it is split into lines, and each line is appended to the event store separately. For example, consider the following action list definition:\n\naction=add EVENTS This is a test; add EVENTS This is a test2\n\nAfter the execution of this action list, the last two strings in the event store of the EVENTS context are \"This is a test\" and \"This is a test2\" (in that order).\n\nprepend <name> [<string>]\n\nSimilar to the add action, except that the string <string> is prepended to the beginning of the event store of context <name>. For example, consider the following action list definition:\n\naction=prepend EVENTS This is a test; prepend EVENTS This is a test2\n\nAfter the execution of this action list, the first two strings in the event store of the EVENTS context are \"This is a test2\" and \"This is a test\" (in that order).\n\nfill <name> [<string>]\n\nSimilar to the add action, except that the event store of the context <name> is emptied before <string> is added.\n\nreport <name> [<cmdline>]\n\nFork a process for executing command line <cmdline>. If <cmdline> contains shell metacharacters, <cmdline> is parsed by shell. Also, write strings from the event store of the context <name> to the standard input of <cmdline>. Strings are written in the order they appear in the event store, with a terminating newline appended to each string. If the context <name> does not exist or its event store is empty, <cmdline> is not executed. The <name> parameter may not contain whitespace, and if <cmdline> is omitted, strings are written to standard output. For additional information, see CHILD PROCESSES section. For example, consider the following action list definition:\n\naction=create PID_$1 60 ( report PID_$1 /bin/mail root@localhost ); \\\n\nadd PID_$1 Beginning of the report\n\nThe above action list creates the context PID_<suffix> with the lifetime of 60 seconds and sets the first string in the context event store to \"Beginning of the report\" (<suffix> is the value of the $1 match variable). When the context expires, all strings from the event store will be mailed to root@localhost.\n\nreportexec <name> [<cmdline>]\n\nSimilar to the report action, except <cmdline> is not parsed by shell, but split into arguments by using whitespace as a separator, and passed to execvp(3) for execution. Note that splitting into arguments is done when reportexec action is loaded from the configuration file and parsed, not at runtime (e.g., if <cmdline> is /usr/local/bin/mytool $1 $2, the values of $1 and $2 variables are regarded as single arguments even if the values contain whitespace).\n\ncopy <name> %<var>\n\nStrings s1,...,sn from the event store of the context <name> are joined into a multi-line string \"s1<NEWLINE>...<NEWLINE>sn\", and this string is assigned to the action list variable %<var>. If the context <name> does not exist, the value of %<var> does not change.\n\nempty <name> [%<var>]\n\nSimilar to the copy action, except that the event store of the context <name> will be emptied after the assignment. If %<var> is omitted, the content of the event store is dropped without an assignment.\n\npop <name> %<var>\n\nRemove the last string from the event store of context <name>, and assign it to the action list variable %<var>. If the event store is empty, %<var> is set to empty string. If the context <name> does not exist, the value of %<var> does not change.\n\nshift <name> %<var>\n\nRemove the first string from the event store of context <name>, and assign it to the action list variable %<var>. If the event store is empty, %<var> is set to empty string. If the context <name> does not exist, the value of %<var> does not change.\n\nexists %<var> <name>\n\nIf the context <name> exists, set the action list variable %<var> to 1, otherwise set %<var> to 0.\n\ngetsize %<var> <name>\n\nFind the number of strings in the event store of context <name>, and assign this number to the action list variable %<var>. If the context <name> does not exist, %<var> is set to Perl undefined value. For example, consider the following action list definition:\n\naction=fill EVENTS Event1; add EVENTS Event2; add EVENTS Event3; \\\n\npop EVENTS %temp1; shift EVENTS %temp2; getsize %size EVENTS\n\nThis action list sets the %temp1 action list variable to Event3, %temp2 action list variable to Event1, and %size action list variable to 1.\n\ngetaliases %<var> <name>\n\nFind all alias names for context <name>, join the names into a multi-line string \"alias1<NEWLINE>...<NEWLINE>aliasn\", and assign this string to the action list variable %<var>. If the context <name> does not exist, the value of %<var> does not change.\n\ngetltime %<var> <name>\n\nFind the lifetime of context <name>, and assign this number to the action list variable %<var>. If the context <name> does not exist, the value of %<var> does not change. For example, consider the following action list definition:\n\naction=create TEST 10 ( getltime %time TEST; \\\n\nlogonly Context TEST with %time second lifetime has expired )\n\nThe above create action configures the context TEST to log its lifetime when it expires.\n\nsetltime <name> [<time>]\n\nSet the lifetime of context <name> to <time>. Specifying 0 for <time> or omitting the value means infinite lifetime. Note that unlike the set action, setltime does not adjust the context creation time. For example, if context TEST has been created at 12:01:00 with the lifetime of 60 seconds, then after invoking setltime TEST 30 at 12:01:20 the context would exist until 12:01:30, while invoking setltime TEST 10 would immediately expire the context.\n\ngetctime %<var> <name>\n\nFind the creation time of context <name>, and assign this timestamp to the action list variable %<var>. The value assigned to %<var> is measured in seconds since Epoch (as reported by the time(2) system call). If the context <name> does not exist, the value of %<var> does not change.\n\nsetctime <time> <name>\n\nSet the creation time of context <name> to <time>. The <time> parameter must evaluate to seconds since Epoch (as reported by the time(2) system call), and must reflect a time moment between the previous creation time and the current time (both endpoints included). For example, if context TEST has been created at 12:43:00 with the lifetime of 60 seconds, then after invoking setctime %u TEST at 12:43:25 the context would exist until 12:44:25 (the %u action list variable evaluates to current time in seconds since Epoch).\n\nevent [<time>] [<string>]\n\nAfter <time> seconds, create a synthetic event <string>. If <string> is a multi-line string (i.e., it contains newlines), it is split into lines, and from each line a separate synthetic event is created. SEC will treat each synthetic event like a line from an input file -- the event will be matched against rules and it might trigger further actions. If the --intcontexts command line option is given, internal context _INTERNAL_EVENT is set up for synthetic event(s) (see INTERNAL EVENTS AND CONTEXTS section for more information). The <time> parameter is an integer constant. Specifying 0 for <time> or omitting the value means \"now\". Default value for <string> is %s. For example, consider the following action list definition:\n\naction=copy EVENTS %events; event %events\n\nThe above action list will create a synthetic event from each string in the event store of the EVENTS context.\n\ntevent <time> [<string>]\n\nSimilar to the event action, except that the <time> parameter may contain variables and must evaluate to an unsigned integer at runtime.\n\ncevent <name> <time> [<string>]\n\nSimilar to the tevent action, except that if the --intcontexts command line option is given, internal context <name> is set up for synthetic event(s).\n\nreset [<offset>] [<string>]\n\nTerminate event correlation operation(s) with the operation description string <string>. Note that the reset action works only for operations started from the same configuration file. The <offset> parameter is used to refer to a specific rule in the configuration file. If <offset> is given, the operation started by the given rule is terminated (if it exists). If <offset> is an unsigned integer N, it refers to the N-th rule in the configuration file. If <offset> is 0, it refers to the current rule. If <offset> begins with the plus (+) or minus (-) sign, it specifies an offset from the current rule (e.g., -1 denotes the previous and +1 the next rule). Note that since Options rules are only processed when configuration files are loaded and they are not applied at runtime, Options rules are excluded when calculating <offset>. If <offset> is not given, SEC checks for each rule from the current configuration file if an operation with <string> has been started by this rule, and the operation is terminated if it exists. Default value for <string> is %s. For additional information, see EVENT CORRELATION OPERATIONS section. For example, consider the following action list definition:\n\naction=reset -1 Ten login failures observed from $1; reset 0\n\nIf the above action list is executed by an event correlation operation, the first reset action will terminate another event correlation operation which has been started by the previous rule and has the operation description string \"Ten login failures observed from <host>\" (<host> is the value of the $1 match variable). The second reset action will terminate the calling operation itself.\n\ngetwpos %<var> <offset> [<string>]\n\nFind the beginning of the event correlation window for an event correlation operation, and set the action list variable %<var> to this timestamp. The value assigned to %<var> is measured in seconds since Epoch (as reported by the time(2) system call). As with the reset action, the event correlation operation is identified by the operation description string <string> and the rule offset <offset>. If the operation does not exist, the value of %<var> does not change. Default value for <string> is %s. For additional information, see EVENT CORRELATION OPERATIONS section. For example, consider the following action list definition:\n\naction=getwpos %pos -1 Ten login failures observed from $1\n\nThe above getwpos action will find the beginning of the event correlation window for an event correlation operation which has been started by the previous rule and has the operation description string \"Ten login failures observed from <host>\" (<host> is the value of the $1 match variable). If the event correlation window begins at April 6 08:03:53 2018 UTC, the value 1523001833 will be assigned to the %pos action list variable.\n\nsetwpos <time> <offset> [<string>]\n\nSet the beginning of the event correlation window to <time> for an event correlation operation (if it exists). The <time> parameter must evaluate to seconds since Epoch (as reported by the time(2) system call), and must reflect a time moment between the previous window position and the current time (both endpoints included). As with the reset action, the event correlation operation is identified by the operation description string <string> and the rule offset <offset>. Default value for <string> is %s. For additional information, see EVENT CORRELATION OPERATIONS section.\n\nassign %<var> [<string>]\n\nAssign string <string> to the action list variable %<var>. Default value for <string> is %s.\n\nassignsq %<var> [<string>]\n\nSimilar to the assign action, except that <string> is quoted with single quotes before assigning it to %<var>. If <string> contains single quotes, they are masked with backslashes (e.g., if the match variable $1 holds the value abc'123'xyz, the action assignsq %myvar $1 assigns the value 'abc'\\''123'\\''xyz' to the action list variable %myvar). This action is useful for disabling shell interpretation for the values of action list variables that appear in command lines executed by SEC. Default value for <string> is %s.\n\nfree %<var>\n\nUnset the action list variable %<var>.\n\neval %<var> <code>\n\nThe parameter <code> is a Perl miniprogram that is compiled and executed by calling the Perl eval() function in the Perl list context. If the miniprogram returns a single value, it is assigned to the action list variable %<var>. If the miniprogram returns several values s1,...,sn, they are joined into a multi-line string \"s1<NEWLINE>...<NEWLINE>sn\", and this string is assigned to %<var>. If no value is returned, %<var> is set to Perl undefined value. If eval() fails, the value of %<var> does not change. Since most Perl programs contain semicolons which are also employed by SEC as action separators, it is recommended to enclose the <code> parameter in parentheses, in order to mask the semicolons in <code>. For additional information, see PERL INTEGRATION section. For example, consider the following action list definition:\n\naction=assign %div Division error; eval %div ( $1 / $2 )\n\nThe assign action sets the %div action list variable to the string \"Division error\", while the eval action substitutes the values of $1 and $2 match variables into the string \"$1 / $2\". Resulting string is treated as Perl code which is first compiled and then executed. For instance, if the values of $1 and $2 are 12 and 4, respectively, the following Perl code is compiled: 12 / 4. Since executing this code yields 3, the eval action assigns this value to the %div action list variable. Also, if $2 has no value or its value is 0, resulting code leads to compilation or execution error, and %div retains its previous value \"Division error\".\n\ncall %<var> %<ref> [<paramlist>]\n\nCall the precompiled Perl function referenced by the action list variable %<ref>, and assign the result to the action list variable %<var>. The %<ref> parameter must be a code reference that has been previously created with the eval action. The <paramlist> parameter (if given) is a string which specifies parameters for the function. The parameters must be separated by whitespace in the <paramlist> string. If the function returns a single value, it is assigned to %<var>. If the function returns several values s1,...,sn, they are joined into a multi-line string \"s1<NEWLINE>...<NEWLINE>sn\", and this string is assigned to %<var>. If no value is returned, %<var> is set to Perl undefined value. If the function encounters a fatal runtime error or %<ref> is not a code reference, the value of %<var> does not change. For additional information, see PERL INTEGRATION section. For example, consider the following action list definition:\n\naction=eval %func ( sub { return $_[0] + $_[1] } ); \\\n\ncall %sum %func $1 $2\n\nSince the Perl code provided to eval action is a definition of an anonymous function, its compilation yields a code reference which gets assigned to the %func action list variable (the function returns the sum of its two input parameters). The call action will invoke previously compiled function, using the values of $1 and $2 match variables as function parameters, and assigning function return value to the %sum action list variable. Therefore, if the values of $1 and $2 are 2 and 3, respectively, %sum is set to 5.\n\nlcall %<var> [<paramlist>] -> <code> lcall %<var> [<paramlist>] :> <code>\n\nCall the precompiled Perl function <code> and assign the result to the action list variable %<var>. The <code> parameter must be a valid Perl anonymous function definition that is compiled at SEC startup with the Perl eval() function, and eval() must return a code reference. The <paramlist> parameter (if given) is a string which specifies parameters for the function. The parameters must be separated by whitespace in the <paramlist> string. If <paramlist> is followed by -> operator, parameters are passed to function as Perl scalar values. If <paramlist> is followed by :> operator, it is assumed that each parameter is a name of an entry in the pattern match cache. If an entry with the given name does not exist, Perl undefined value is passed to the function. If an entry with the given name exists, a reference to the entry is passed to the function. Internally, each pattern match cache entry is implemented as a Perl hash which contains all match variables for the given entry. If the function returns a single value, it is assigned to %<var>. If the function returns several values s1,...,sn, they are joined into a multi-line string \"s1<NEWLINE>...<NEWLINE>sn\", and this string is assigned to %<var>. If no value is returned, %<var> is set to Perl undefined value. If the function encounters a fatal runtime error, the value of %<var> does not change. Since most Perl functions contain semicolons which are also employed by SEC as action separators, it is recommended to enclose the <code> parameter in parentheses, in order to mask the semicolons in <code>. For additional information, see PERL INTEGRATION section. For example, consider the following action list definition:\n\naction=lcall %len $1 -> ( sub { return length($_[0]) } )\n\nThe above lcall action will take the value of the $1 match variable and find its length in characters, assigning the length to the %len action list variable. Note that the function for finding the length is compiled when SEC loads its configuration, and all invocations of lcall will execute already compiled code. As another example, consider the following action list definition:\n\naction=lcall %o SSH :> ( sub { $_[0]->{\"failure\"} = 1 } )\n\nThe above lcall action will assign 1 to the $+{failure} match variable that has been cached under the SSH entry in the pattern match cache (variable will be created if it did not exist previously).\n\nrewrite <lnum> [<string>]\n\nReplace last <lnum> lines in the input buffer with string <string>. If the --nojointbuf option was specified and the action is triggered by a matching event, the action modifies the buffer which holds this event. If the --nojointbuf option was specified and the action is triggered by the system clock (e.g., the action is executed from the Calendar rule), the action modifies the buffer which holds the last already processed event. With the --jointbuf option, the content of the joint input buffer is rewritten. The <lnum> parameter must evaluate to an unsigned integer at runtime. If <lnum> evaluates to 0, <lnum> is reset to the number of lines in <string>. If the "
    }
}