{
    "id": "correct_subsidiary_00084_3",
    "rank": 23,
    "data": {
        "url": "https://www.slideshare.net/slideshow/name-of-company-for-term-projectstudent-namescourse-mgmtdocx/254116545",
        "read_more_link": "",
        "language": "en",
        "title": "Name of Company for Term ProjectStudent Name(s)Course MGMT.docx",
        "top_image": "https://cdn.slidesharecdn.com/ss_thumbnails/nameofcompanyfortermprojectstudentnamescoursemgmt-221110175136-4bc0af80-thumbnail.jpg?width=640&height=640&fit=bounds",
        "meta_img": "https://cdn.slidesharecdn.com/ss_thumbnails/nameofcompanyfortermprojectstudentnamescoursemgmt-221110175136-4bc0af80-thumbnail.jpg?width=640&height=640&fit=bounds",
        "images": [
            "https://public.slidesharecdn.com/images/next/logo-slideshare-scribd-company.svg?w=128&q=75 1x, https://public.slidesharecdn.com/images/next/logo-slideshare-scribd-company.svg?w=256&q=75 2x",
            "https://image.slidesharecdn.com/nameofcompanyfortermprojectstudentnamescoursemgmt-221110175136-4bc0af80/85/Name-of-Company-for-Term-ProjectStudent-Name-s-Course-MGMT-docx-1-320.jpg 320w, https://image.slidesharecdn.com/nameofcompanyfortermprojectstudentnamescoursemgmt-221110175136-4bc0af80/85/Name-of-Company-for-Term-ProjectStudent-Name-s-Course-MGMT-docx-1-638.jpg 638w, https://image.slidesharecdn.com/nameofcompanyfortermprojectstudentnamescoursemgmt-221110175136-4bc0af80/75/Name-of-Company-for-Term-ProjectStudent-Name-s-Course-MGMT-docx-1-2048.jpg 2048w"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-11-10T17:51:34+00:00",
        "summary": "",
        "meta_description": "Name of Company for Term ProjectStudent Name(s)Course  MGMT.docx - Download as a PDF or view online for free",
        "meta_lang": "en",
        "meta_favicon": "https://public.slidesharecdn.com/_next/static/media/favicon.7bc3d920.ico",
        "meta_site_name": "SlideShare",
        "canonical_link": "https://www.slideshare.net/slideshow/name-of-company-for-term-projectstudent-namescourse-mgmtdocx/254116545",
        "text": "1. Name of Company for Term Project: Student Name(s): Course: MGMT 1209, Introduction to Business Management CATEGORY Exemplary 5 Proficient 3-4 Partially Proficient 2 Incomplete 1 Not Present or Acceptable 0 Score Quality of Content Depth and Breadth of Research Clear evidence that multiple and appropriate sources of research information were used in this project. Adequate evidence that sources of research were used in the creation of this project. Little evidence that sources of research were used in the creation of this project. No evidence that sources of research were used in the creation of this project. Total Possible\n\n2. /5 Application of Content Application of course topics and research used throughout the project. All information is clear, appropriate and correct. Application of course topics and research evident throughout most of the project. Most information is clear, appropriate and correct. Some application of course topics and research is evident. Some information is confusing or incorrect. Application of course topics and research is not evident. Information is confusing or incorrect. Total Possible /5 Mechanics Spelling & Grammar Project is flawless in spelling and grammar. Project follows most rules of spelling and grammar. (3 or less errors) Project minimally follows rules of spelling and grammar. (4 or less errors) Project has numerous errors in spelling and/or grammar (5 or more) Total Possible /5 Structure of ProjectOrganization The sequence of information is logical and intuitive. Information is clear and direct. The sequence of information is logical and intuitive. Most\n\n3. information is clear and direct. The sequence of information is somewhat logical and intuitive. Information is confusing at times. The sequence of information is not logical. Difficult to follow. Total Possible /5 DocumentationGrand Total Comments: Company description – Industry Analysis – Mission Statement/Values – SWOT Analysis – Recommendations - Total Possible /20 e eBook Collection 46 Network Standards LEARNING OBJECTIVES By the end of this chapter, you should be able to: ▪ Explain how internet standards are made and why this approach is valuable. ▪ Provide the definitions of network standards and protocols, message syntax, semantics, and order. ▪ Discuss message ordering in general and in HTTP and TCP. ▪ Discuss message syntax in general and in Ethernet frames, IP\n\n4. packets, TCP segments, UDP datagrams, and HTTP request and response messages. ▪ Explain how to encode application messages into bits (1s and 0s). ▪ Explain vertical communication on hosts. HOW INTERNET STANDARDS CAME TO BE Those who love sausage and revere the law should never see either being made. Attributed to German Chancellor Otto von Bismarck Standards are detailed and precise. You might expect standards creation to be logical and rational. For some standards agencies, this is true. The International Telecommunication Union–Telecommunications Standards Sector (the ITU-T in OSI) is part of the ITU, which is an agency of the United Nations. The secretaries of state of individual countries are the Chapter 2 ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 47 nominal participants, although they rarely participate directly. ITU-T has a methodical process for developing new standards. The International Organization for Standards (ISO)1 also has strict formal processes. With the Internet, standards setting is different. The Internet grew out of the ARPANET research network funded by the Advanced Research Projects Agency (ARPA).2 ARPA funded it to explore the then-new technology of packet switching (what we would now call frame switching). Figure 2-1 shows that\n\n5. when the ARPANET began in 1969, it had four sites: UCLA, the Stanford Research Institute Augmentation Research Center, UCSB, and the University of Utah. Each site had a switch called an interface message processor (IMP). IMPs exchanged packets (actually frames) through 50 kbps lines, which seemed blazingly fast at the time. Bolt Beranek and Newman (BBN) built the IMPs and designed protocols for IMPs to exchange messages. That was all they did. The first four sites were chosen because they had the technical savvy to get their large host computers to work with the IMPs. At meetings during the ARPANET’s development phase, researchers from the four sites met with BBN to discuss the network. They realized that the ARPANET would be useless without many additional standards. There had to be standards for hosts to 1 No, the acronyms do not work well with the names, but these are the standard names and acronyms. ISO, by the way, is not an acronym for International Organization for Standardization in any language. It was chosen because iso means true in Greek. 2 Is it ARPA or DARPA? It depends on the year. It was born ARPA in 1958. In 1972, it became DARPA to emphasize its status as a Department of Defense agency. In 1993, it went back to ARPA. Then it went back to DARPA in 1996. DARPA, “ARPA-DARPA: The Name Chronicles,” undated. http://www.darpa.gov/ arpa-darpa.html. Last viewed August 2009. UCSB IMP SRI ARC\n\n6. IMP University of Utah IMP 50 kbps Line Host Host Host Host Host Host Dumb Terminals UCLA IMP 50 kbps Line 50 kbps Line 50 kbps Line IMP= Interface Message Processor FIGURE 2-1 The Early ARPANET ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 48� ���������� �� ����������������� communicate with their IMPs. Far more fundamentally, there had to be application standards if the network was to be useful. There was nobody to set these standards, so the participants decided to do it themselves. They called their small team the Network Working Group and asked others to join them. When they came up with a standard, they did not call it a standard because they felt that they lacked the authority to do so. Steve Crocker, who led the group and wrote the first document,\n\n7. called it a Request for Comments (RFC). Today, new standards are still RFCs. Group members developed important application standards. In 1971, Ray Tomlinson saw that e-mail could work across sites. He was already working on e-mail for users of a single host. Mail systems on single hosts used usernames as addresses for delivering mail. Tomlinson saw that an ARPANET address would have to include both a host name and a username on the host. Looking at his keyboard, he saw that the @ sign did not seem to be used very much.3 He assigned it to separate the username from the host name. It took him a weekend to write the software. E-mail quickly dominated use of the ARPANET. Born in the late 1960s, the Network Working Group reflected its times. There was a strong focus on egalitarian participation and the recognition of technical merit. A few years later, the Internet Engineering Task Force (IETF) took over Internet standards development. Like the Network Working Group, the IETF has no formal membership. Anyone can participate in the IETF Working Groups that develop individual standards in specific area. Describing the way the IETF works, Dave Clark wrote, in 1992, “We reject: kings, presidents, and voting. We believe in: rough consensus and running code.”4 Rejecting kings and presidents refers to the IETF’s strong egalitarian culture. In general, anyone with a good idea stands a fair chance of being heard. By not suppressing new ideas, this\n\n8. culture accounts for much of the rapid development pace of Internet standards. The rejection of voting and going forward if there was rough consensus also made the IETF action-oriented. The importance of “running code” is not as obvious. Most standards agencies develop full complex standards in committee. When vendors implement these standards, they often find unforeseen ambiguities and even contradictions. When they build their products to these standards, they often find that their products do not interoperate with products from different vendors who supposedly follow the same standard. In addition, committees tend to design standards that are so complex that products take extensive resources to develop and are therefore expensive and slow to develop. In the IETF, almost all standards are created based on running demonstration systems. Experience identifies unforeseen problems and solves them before standards are made. More subtly, demonstration code is simple. This leads to simple standards. Many IETF RFCs even have “simple” in their name; for instance, the Simple Mail Transfer Protocol standardizes communication among mail servers. Simple products emerge quickly, so while OSI development plodded along slowly, simple TCP/IP products 3 Personal communication with Ray Tomlinson, May 1986. 4 Dave Clark, “A Cloudy Chrystal Ball—Visions of the Future,” Proceedings of the Twenty-Fourth Internet Engineering Task Force, Massachusetts Institute of Technology NEARnet, Cambridge, MA, July 13–17, 1992,\n\n9. pp. 539–543. ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 49 appeared fast, at low prices. As something of an insult (although it was not intended to be), the IETF sometimes took bloated OSI standards and created simpler versions of them. These simplified versions often became dominant. Over time, simple IETF standards usually evolve to becoming full-featured, but each step along the way is based on real-world experience. Test Your Understanding 1. a) Why are Internet standards called RFCs? (Do not just spell out the name.) b) What factors in the Internet’s informal development process lead to rapid standards development and low-cost products? INTRODUCTION We looked at network standards briefly in Chapter 1. In this chapter, we will look at standards at a more conceptual level, developing taxonomies of standards types. Much of the rest of this book focuses on specific standards; you will need to understand standards broadly to understand where those specific standards fit into the overall standards picture. This chapter also looks in some detail at the most important standards on the Internet and in corporate networks. These include Ethernet, IP, TCP, UDP, and HTTP. Standard = Protocol\n\n10. In this text, we use the terms standard and protocol to mean the same thing. In fact, standards often have protocol in their names. Examples are the Hypertext Transfer Protocol, the Internet Protocol, the Transmission Control Protocol, and the User Datagram Protocol. April 1 and RFCs The IETF has always had a sense of whimsy. In the United States and some other countries, April 1 is April Fool’s Day—a day to play jokes on people by telling them something completely false. A robust tradition in the IETF is the publishing of a facetious RFC or two on April Fool’s Days. One of the most popular is RFC 2549, IP over Avian Carriers. Written in 1990, this RFC describes how to transmit IP packets using carrier pigeons. This RFC was updated twice, in 1999 (to add quality of service) and 2011 (so that the protocol will work with the new IPv6 protocol). Another April 1 RFC warned of a serious authentication problem at IETF meetings. There were so many heavily bearded guys that it was impossible to tell them apart. RFC 3093 introduced the Firewall Enhancement Protocol, which allows all traffic to pass through firewalls while leaving the firewall in place (and useless). An April 1 RFC from 1998, the Hyper Text Coffee Pot Protocol, has the promise of growing into a real protocol as the Internet of things unfolds. One limitation in the protocol is that decaf coffee was explicitly excluded. The explanation was, “Why bother?” BOX 1 ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by\n\n11. Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 50� ���������� �� ����������������� Network Standards What Are Network Standards? As Figure 2-2 illustrates, network standards are rules of operation that govern the exchange of messages between two hardware or software processes. To give a human analogy, in the first author’s classes, the standard language is American English. Not all of his students are native English speakers, but we are able to communicate because we use a standard language. In this chapter, we will see that network standards govern a number of message characteristics, including semantics, syntax, message order, reliability, and connection orientation. Network standards are rules of operation that govern the exchange of messages between two hardware or software processes. This includes message semantics, syntax, message order, reliability, and connection orientation. Standards Bring Competition Standards are important because they allow products from different vendors to interoperate (work together). In Figure 2-2, the client program might be a Chrome browser from Google, and the server program might be Microsoft’s IIS webserver program. Although these companies may actively dislike each other, their products work together because they exchange messages using the Hypertext Transfer Protocol (HTTP) network standard. With network standards, it is impossible for any company to\n\n12. maintain a monopoly by refusing to allow others to use its proprietary communication protocols. Competition drives down prices. It also spurs companies to add new features so that their products will not be pure commodities that can only compete on price. These new features often appear in the next version of the standard. Network standards are not only the key to competition. They are also the key to networking in general. To work in networking, you need to understand individual standards so that you can design networks, set up network components, and Client Application Server Application Messages Network Standards (Protocols). Govern message semantics, syntax, message order, and reliability. Standards permit interoperability among vendors. This creates competition. Competition lowers prices. Competition encourages growth in functionality. FIGURE 2-2 Network Standards ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 51 troubleshoot problems. Learning networking is heavily about learning standards. In this chapter, we will look broadly at the general characteristics of standards and will also look at some key network standards. Recap of Chapter 1 Standards Concepts In Chapter 1, we saw that standards can be described in terms of\n\n13. their layer of operation. Delivery Layers As Figure 2-3 shows, three layers are involved in the transmission of packets between source hosts and destination hosts. ��Physical links are connections between adjacent devices, such as a host and a switch, two switches, two routers, a host and a switch, and so forth. Physical layer standards are not concerned with messages. Their job is to turn the bits of data link layer messages (frames) into signals. ����������������������������������� ����������������������������������� ����������� two routers, or a host and a router across a single point-to- point, switched, wireless, or hybrid switched/wireless network. The path that a frame takes is called its data link. This layer governs switch operation and frame organization. ����������������������������������� ����������������������������������� ������������� to the destination host, across multiple networks in an internet. The path that a packet takes between the two hosts is called its route. This layer governs router operation and packet organization. A common source of confusion is that concepts are repeated at the data link and internet layers but with different terminology. This occurs because internetworking required the adding of a second layer of standards to those needed for transmission through single networks. Physical Link\n\n14. Data Link Route Switch X1 Switch X2 Switch Z2 Switch Z1 Router 1 Router 2 Source Host A Destination Host B FIGURE 2-3 The Physical, Data Link, and Internet Layers ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 52� ���������� �� ����������������� Also, recall that packets are carried inside frames. When a source host sends a packet to a destination host, the packet travels within a frame in each network along the way. If there are 19 single networks on the route between the source and destination hosts, a single packet will travel in 19 different frames. The Transport and Application Layers The physical, data link, and internet layers are for standards that move packets along their way\n\n15. between the source host and the destination host. In contrast, Figure 2-4 shows that transport and application processes govern processes that exist only on the two communicating hosts. ������transport layer supplements the internet layer. Internet layer operation typically is a best-effort service that does not guarantee that packets will be delivered. The transport layer is a “fix-up” layer that can add reliability and other desirable characteristics to transmission across an internet. In addition, the source host transport layer process fragments application messages. These fragments are sent in individual packets. The destination host transport process reassembles the segments and passes the application message to the application. ������application layer is for application standards. When two e-mail programs need to work together, they use an e-mail application standard. For webservice, HTTP is an application layer standard. There are more application layer standards than there are standards at all other layers combined because there are so many applications and because different applications usually need different application standards. The Five Layers Figure 2-5 recaps the five layers. ����������������������������������� ����������������������������������� ������������ single networks. ����������������������������������� ����������������������������������� ����������-\n\n16. mission through an internet. The internet layer governs packet organization 5. Application Layer Standards 4. Transport Layer Standards Host-to-Host (TCP and UDP) 3. Internet Layer Standards (Mostly IP) Packet Router Y Router X Application B Application A Packet Host 1 Host 2 FIGURE 2-4 Transport and Application Processes ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 53 and raw packet delivery. The transport layer fixes up problems and does fragmentation and assembly. ����������������������������������� ����������������������������������� ������ Test Your Understanding 2. a) Give the definition of network standards that this chapter introduced. b) In this\n\n17. book, do standards and protocols mean the same thing? Network Standard Characteristics Network standards govern communication. Figure 2-6 notes, more specifically, that standards govern five specific things about message exchanges: semantics, syntax, order, and reliability. In this section, we will focus on message order, semantics, and syntax, but we will also introduce the concept of reliability. Message Ordering In medicine and many other fields, a protocol is a prescribed series of actions to be performed in a particular order. In cooking, if you do not process the ingredients of a cake in the right order, the cake is not likely to turn out very well. In this same way, network standards govern message ordering. For the Hypertext Transfer Protocol standard that we saw in Chapter 1, message ordering is very simple. Broad Function Layer Name Specific Function Interoperability of application programs 5 Application Application layer standards govern how two applications work with each other, even if they are from different vendors. Transmission across an internet 4 Transport Transport layer standards govern aspects of endto- end communication between two end hosts that are not handled by the internet layer. These standards also allow hosts to work together even if the two computers are from different vendors or have different internal designs. 3 Internet Internet link layer standards govern the transmission of packets across an internet—typically\n\n18. by sending them through several routers along the route. Internet layer standards also govern packet syntax and reliability. Transmission across a single network 2 Data Link Data link layer standards govern the transmission of frames across a single switched network— typically by sending them through several switches along the data link. Data link layer standards also govern frame syntax and reliability. 1 Physical Physical layer standards govern transmission between adjacent devices connected by a transmission medium. FIGURE 2-5 Layers Recap ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 54� ���������� �� ����������������� The client sends an HTTP request message, and the server sends back an HTTP response message. Many protocols, including the Transmission Control Protocol (TCP) standard, which we will see in this chapter and in Chapter 8, involve many messages being sent in precise order. Human beings are intelligent, so message ordering in human conversations tends to be informal and even chaotic. Software is not intelligent, so message ordering in protocols has to be very rigid and exact. Semantics To limit the complexity of software, protocols usually define only a few message types, and these types usually have only a few options. Put another Network Standards\n\n19. Network standards are rules that govern the exchange of messages between hardware or software processes on different hosts, including message ordering, message syntax, message semantics, and reliability. Message Order Turn taking, order of messages in a complex transaction, who must initiate communication, etc. In the World Wide Web, the client program sends an HTTP request message The webserver program sends back an HTTP response message The client must initiate the interaction Other network standards have more complex turn-taking; for instance TCP Human turn taking is loose and flexible Message order for network standards must be rigid because computers are not intelligent Message Semantics Semantics = the meaning of a message HTTP request message semantics: “Please give me this file” HTTP response message semantics: Here is the file. (Or, I could not comply for the following reason) Network standards normally have a very limited set of possible message meanings For example, HTTP requests have only a few possible meanings GET: Please give me a file PUT: Upload and store this file (not often used) A few more Message Syntax (Organization) Like human grammar, but more rigid Header, data field, and trailer (Figure 2-9) Not all messages have all three parts Field lengths are measured in bits or bytes Bytes are also called octets FIGURE 2-6 Network Standards Concepts ISBN 1-323-07906-8\n\n20. Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 55 way, network protocols greatly limit the semantics (meaning) of their messages. For example, the most common HTTP request message is a GET message, which requests a file. There is also a POST request message, which uploads a file to the webserver. Similarly, the semantics of an HTTP response message are, “Here is the file,” or “Sorry, I can’t deliver the file.” Semantics is the meaning of a message. Syntax In addition, while human grammar is very flexible, network messages have very rigid syntax, that is, message organization. A little later in this chapter, we will look at the syntaxes of several important protocol messages. Syntax is how a message is organized. Test Your Understanding 3. a) What three aspects of message exchanges did we see in this section? b) Give an example not involving networking in which the order in which you do things can make a big difference. c) Distinguish between syntax and semantics. EXAMPLES OF MESSAGE ORDERING We will look at two examples of message ordering. We will look first at the very simple message ordering in HTTP. We will then look at the more complex message ordering in TCP. Message Ordering in HTTP Figure 2-7 illustrates an HTTP request–response cycle. As we\n\n21. have just noted, the client sends a request, and the server sends a response. Note that the cycle is always initiated by the client, not by the server. The server cannot transmit unless the client has sent it an HTTP request message. This is a very simple type of message ordering. Browser Webserver Program Client PC Webserver HTTP Request Message HTTP Response Message The webserver program may not transmit until it receives an HTTP request message. FIGURE 2-7 An HTTP Request–Response Cycle ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 56� ���������� �� ����������������� Message Ordering and Reliability in TCP at the Transport Layer Many protocols have much more complex rules for message ordering. We will look at the Transmission Control Protocol at the transport layer to see an example of this complexity. The Situation Figure 2-8 shows the transport layer processes on Host A and Host B. They are communicating via HTTP at the application layer. The Hypertext Transfer Protocol requires the use of TCP at the transport layer. The figure shows a sample communication session, which is called a connection. Segments In TCP, messages are called TCP segments because each carries a\n\n22. segment (fragment) of a fragmented application message (or is a control segment that does not carry application data). The Three-Step Handshake Opening The communication begins with a threestep handshake. ����������������������������������� ����������������������������������� ������������ It transmits a TCP SYN segment to Host B. This indicates that Host A wishes to communicate. ����������������������������������� ����������������������������������� ������� �������� ��� ������ ���� ��������������� �������� ����� ��� ��� ��������������� ��� Host A’s SYN message. In TCP, all segments are acknowledged, with the primary ����������������������������������� ����������������������������������� ������� ��������������������������� ������� �� ������ ����� �� ����� ���� ���� ��������� ����� ������������� ����� ���� �������� In TCP, all segments are acknowledged, with the primarily exception of pure ACKs. Connections TCP creates connections with distinct openings and closings. This is like a telephone call, in which you informally make sure that the other person can talk at the start of a call and mutually agree to end the call. In technical jargon, TCP is a\n\n23. connection-oriented protocol. Sequence Numbers In a connection-oriented protocol, each message is given a sequence number. This allows the receiver to ensure that no message is missing and allows the receiving process to deal with duplicate segments. (It simply discards duplicates.) Sequence numbers in TCP are important because application message fragments (segments) are delivered in separate packets. Sequence numbers allow the receiver to place the segments in order and reassemble them. Note in Figure 2-8 that each side numbers its own sequence numbers. For simplicity, we have called Host A’s sequence numbers A1, A2, A3, and so forth. We have done the ����������������������������������� ����������������������������������� ������������� ����������������������������������� ��������������������� ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 57 Carrying Application Data The next four segments (A3, B2, B3, and A4) constitute a request–response cycle. ����������������������������� ��������������������� Host A Transport Process Host B Transport Process Data = HTTP request\n\n24. Data = HTTP response ACK (B3) Data = HTTP request (No ACK , so retransmit) Data = HTTP request (error) Data = HTTP response ACK (B5) Second HTTP request and response messages (corrected error) First HTTP request and response messages (no error) ACK (A3) ACK (A5) Time FIN ACK (A7) Data ACK (B7) Normal Four-Way Close SYN SYN/ACK (A1) ACK (B1) Three- Way\n\n25. Open FIN ACK (B8) A1 A8 A5 A4 A3 A2 A5 A6 A7 A9 B1 B2 B6 B5 B4 B3 B8 B7 FIGURE 2-8 A TCP Session ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 58� ���������� �� ����������������� ����������������������������������� ���� ����������������������������������� � Usually, HTTP request messages are small enough to fit in a single TCP segment. However, most HTTP responses are long and must be sent in a number of TCP segments. This does not change the basic picture, however. There would\n\n26. simply be several more exchanges like B3 and A4. Reliability TCP is a reliable protocol. This means that it corrects errors. ����������������������������������� ����������� ����������������������������������� ����������������������������������� ������ segment is received correctly. ����������������������������������� ����������������������������������� ��������������� it retransmits A5. ����������������������������������� ����������������������������������� ������������� acknowledgment of A5. ����������������������������������� ����������������������������������� ���������� Again, sending an HTTP response message tends to take several TCP data/ acknowledgment cycles. In this example, Segment A5 never reached the receiving transport process. What would have happened if A5 had reached the transport process but was damaged during transmission? In this case, the receiving transport process would discard the segment. ����������������������������������� ����������������������������������� �������������������� receives a segment correctly, it does not send an acknowledgment. Unless a transport process receives a segment correctly, it does\n\n27. not send an acknowledgment. The Four-Step Handshake Closing Host A has no more HTTP request messages to send, so it closes the connection. It does so by sending a FIN segment (A7), which Host B acknowledges (B6). This means that Host A will not send new data. However, it will ����������������������������������� �������������� ___________���������������������������� ����������������������������������� ������������������ ����������������������������������� ������������� ������� ����� �� ��� ��������� �������� ������ ��� ������ ���� ���� ���� �������� ����� ���� receives an acknowledgment (A9). ��������������������������� Perspective TCP is a fairly complex protocol. It uses connections so that it can apply sequence numbers to segments. This allows it to fragment long application messages and deliver the segments with an indication of their order. It also uses connections so that it can provide reliable data to the application layer program above it. We will see that almost all other protocols are unreliable. Many standards check for errors, but if they find an error, they simply discard the message. Discarded messages never get to the transport process on the other host, so they are never acknowledged. Receiving no acknowledgment, the sender resends them. ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by\n\n28. Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 59 Why make only TCP reliable? There are two answers. First, TCP sits just below the application layer. This allows it to send clean data to the application program regardless of errors at lower levels, which are corrected by TCP resends. Second, although all routers along the way do internet layer processing, only the two hosts have transport layer processes, so error correction is done only once, on the two hosts. It is not done at each packet hop between routers or in each frame hop between switches. Error correction is a resource-consuming process, so it should be done as little as possible. Doing error correction at the transport layer processes on the two hosts accomplishes this. Test Your Understanding 4. a) Describe the simple message ordering in HTTP. b) In HTTP, can the server transmit if it has not received a request message from the client? c) Describe the three-step handshake in TCP connection openings. d) What kind of message does the destination host send if it does not receive a segment during a TCP connection? e) What kind of message does the destination host send if it receives a segment that has an error during a TCP connection? f) Under what conditions will a source host TCP process retransmit a segment? g) Describe the four-step handshake in TCP connection closes. h) After a side initiates the close of a connection\n\n29. by sending a FIN segment, will it send any more segments? Explain. i) In Figure 2-8, suppose Host A had already sent A6 before it realized that it would need to resend A5. When it then resent A5, A6 would arrive before A5. How would Host B be able to put the information in the two segments back in order? EXAMPLES OF MESSAGE SYNTAX We have just looked at message ordering. Now we will turn to message syntax. In this book, we will be looking at the syntax of many different types of messages. To give you a feeling for message syntax, we will look at the syntax of five important message types. Syntax: General Message Organization Figure 2-9 shows that message syntax in general can have three parts—a header, a data field, and a trailer. Data Field The data field is the heart of the message. It contains the content being delivered by the message. In an HTTP response message, the data field contains the file that the response message is delivering. The data field contains the content being delivered by a message. Header The message header, quite simply, is everything that comes before the data field. The message header is everything that comes before the data field. ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 60� ���������� �� �����������������\n\n30. Trailer Some messages also have trailers, which consist of everything coming after the data field. The message trailer is everything that comes after the data field. Not All Messages Have All Three Parts HTTP messages demonstrate that only a header is present in all messages. Data fields are not always present but are very common. Trailers are not common. Fields in Headers and Trailers The header and trailer usually contain smaller syntactic sections called fields. For example, a frame or packet has a destination address header field, which allows switches or routers along the way to pass on Trailer Data Field Header Data Field Header Header Message without a Trailer Message with Only a Header Message with All Three Parts Field lengths may be measured in bits or bytes. Another name for “byte” is “octet.” FIGURE 2-9 General Message Organization ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 61 the frame or packet they receive. When we look at network standard messages in this chapter and in later chapters, we will be concerned primarily with header fields and trailer fields. The header and trailer usually contain smaller syntactic sections\n\n31. called fields. Octets Field lengths can be measured in bits. Another common measure for field lengths in networking is the octet. An octet is a group of 8 bits. Hey, isn’t that a byte? Yes, exactly. Octet is just another name for byte. The term is widely used in networking, however, so you need to become familiar with it. Octet actually makes more sense than byte, because oct means “eight.” We have octopuses, octagons, and octogenarians.5 An octet is a group of 8 bits. Test Your Understanding 5. a) What are the three general parts of messages? b) What does the data field contain? c) What is the definition of a header? d) Is there always a data field in a message? e) What is the definition of a trailer? f) Are trailers common? g) Distinguish between headers and header fields. h) Distinguish between octets and bytes. The Ethernet Frame Syntax Messages at the data link layer are frames. In wired local area networks (LANs), the dominant network standard is Ethernet. Actually, Ethernet, like most “standards,” is really a family of standards. Ethernet has many different physical layer protocols from which a company can choose. However, generally speaking, it has a single data link layer frame standard, which Figure 2-10 illustrates. The fields in the frame are delimited by their lengths in octets or bits. The destination host or switch first receives the first bit of the destination address field. It then counts bits until, 48 bits later, it gets to the next field, then to\n\n32. the field after it, and so forth. Then it can process the frame. Ethernet has a complex frame syntax. We will look at its components in more detail in Chapter 5. There are only four fields that we need to emphasize at this time: the source and destination address fields, the data field packet, and the Frame Check Sequence field. Source and Destination Address Fields Ethernet has a data link layer destination and address fields. Each address is 48 bits long. Traditionally, these have been called MAC addresses. However, they are now called Extended Unique Identifier 48-bit (EUI-48) addresses. 5 What is the eighth month? (Careful!) ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 62� ���������� �� ����������������� Packet in the Data Field We saw in Chapter 1 that frames carry packets in their data fields. The figure illustrates how this occurs in Ethernet. Frame Check Sequence Field The four-octet Frame Check Sequence field is used for error detection. The sending data link layer process computes a number based on other bits in the frame. It places this number in the Frame Check Sequence field. The receiver recomputes this 32-bit number. If the recomputed number is the same as the number transmitted in the Frame Check Sequence field, then there have been no errors during transmission, and the receiver accepts the\n\n33. frame. If the numbers are different, there was a propagation error and the frame is corrupted. If so, the receiving data link layer process simply discards the frame. This is error detection but not full error correction. Ethernet is not a reliable protocol. Test Your Understanding 6. a) How long are Ethernet EUI-48 addresses? b) What were they called traditionally? c) What devices read Ethernet destination EUI-48 addresses? d) If the receiver detects an error on the basis of the value in the Frame Check Sequence field, what does it do? e) Ethernet does error detection but not error correction. Is Ethernet a reliable protocol? Explain. The Internet Protocol (IP) Packet Syntax 32 Bits per Row Figure 2-11 illustrates the syntax of Internet Protocol (IP) version 4 (IPv4) packets. Later, we will look at the syntax of IP version 6 (IPv6) packets. Destination EUI-48 Address (48 bits) Source EUI-48 Address (48 bits) Tag Protocol ID (Optional) (2 octets) Tag Control Information (Optional) (2 octets) Length (2 octets) Logical Link Control (LLC) Subheader (8 octets) Packet (Variable Length) PAD (Situation-Specific) Frame Check Sequence (4 Octets) Error Checking Field Packet in Data Field Destination and Source\n\n34. Data Link Layer Addresses (EUI-48). Formerly called a MAC Address FIGURE 2-10 Ethernet Frame ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 63 An IP packet, like an Ethernet frame, is a long string of bits (1s and 0s). Of course, drawing the packet this way would require a page several meters wide. Instead, Figure 2-11 shows that we usually depict an IP packet as a series of rows with 32 bits per row. In binary counting, the first bit is zero. Consequently, the first row shows bits 0 through 31. The next row shows bits 32 through 63. This is a different way of showing syntax than we saw with the Ethernet frame, but it is a common way of showing syntax in TCP/IP standards, so you need to be familiar with it. Source and Destination IP Address Fields Each IPv4 packet has source and destination IP addresses. Each is 32 bits long, so each has its own row in the header. Routers use destination IP addresses to decide how to forward packets so that they will get closer to their destination. Unreliability The IPv4 Header Checksum field is like the Frame Check Sequence field in the Ethernet frame. It also is used for error detection. As in the case of Ethernet frames, incorrect IP packets are simply discarded. There is no retransmission.\n\n35. So like Ethernet, IP is not a reliable protocol. Test Your Understanding 7. a) How many octets long is an IPv4 header if there are no options? (Look at Figure 2-11.) b) List the first bit number on each IPv4 header row in Figure 2-11, not including options. Remember that the first bit in Row 1 is Bit 0. c) What is the bit number of the first bit in the destination address field in IPv4? (Remember that the first bit in binary counting is Bit 0.) d) How long are IPv4 addresses? e) What device in an internet besides the destination host reads the destination IP address? f) What is this device’s purpose in doing so? g) Is IP reliable or unreliable? Explain. Internet Protocol Version 4 (IPv4) Bit 0 Bit 31 Version Number (4 bits) Header Length (4 bits) Diff-Serv (8 bits) Total Length (16 bits) Identification (16 bits) Flags (3 bits) Fragment Offset (13 bits) Time to Live (8 bits) Protocol (8 bits) Header Checksum (16 bits) Source IP Address (32 bits)\n\n36. Destination IP Address (32 bits) Options (if any) Padding Data Field (dozens, hundreds, or thousands of bits) Often contains a TCP segment or UDP datagram FIGURE 2-11 The Internet Protocol (IP) Packet Syntax in IPv4 ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 64� ���������� �� ����������������� Transmission Control Protocol Segment Syntax Earlier, we saw message ordering in the transmission of TCP segments. Now we will look at the syntax of TCP segments. Fields in TCP/IP Segments When IP was created, it was designed to be a very simple “best effort” protocol (although its routing tables are complex). The IETF left more complex internetwork transmission control tasks to TCP. Consequently, network professionals need to understand TCP very well. Figure 2-12 shows the organization of TCP messages, which are called TCP segments. TCP Segment Source Port Number (16 bits) Destination Port Number (16 bits) Sequence Number (32 bits) Checksum (16 bits) Data Field *Flag fields are 1-bit fields. They include SYN, ACK, and FIN bits Urgent Pointer (16 bits) Bit 0 Bit 31 Acknowledgment Number (32 bits) Data Offset (4 bits)\n\n37. Reserved (3 bits) Flag Fields* (9 bits) Window Size (16 bits) UDP Datagram Source Port Number (16 bits) Destination Port Number (16 bits) Bit 0 Bit 31 Data Field UDP Length (16 bits) UDP Checksum (16 bits) Options (if any) Padding 0 0 0 FIGURE 2-12 TCP Segment and UDP Datagram ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 65 Flag Fields TCP has nine single-bit fields. Single-bit fields in general are called flag fields. If a flag field has the value 1, it is said to be set. (If it has the value 0, it is said to be not set.) In TCP, flag fields allow the receiving transport process to identify the kind of segment it is receiving. We will look at three of these flag bits: ����������������������������������� ����������������������������������� ���������� ����������������������������������� ����������������������������������� ������������ to indicate which message is being acknowledged. ����������������������������������� �����������������������������������\n\n38. ����������������� a connection opening. ����������������������������������� ����������������������������������� ������������������ Single-bit fields are called flag fields. If a flag field has the value 1, it is said to be set. (If it has the value 0, it is said to be not set.) ����������������������������������� ����������������������������������� ����� ����������������������������������� ����������������������������������� ������������� Sequence Numbers Each TCP segment has a unique 32-bit sequence number. This sequence number increases with each segment. Sequence numbers allow the receiving transport process to put arriving TCP segments in order if IP delivers them out of order. Acknowledgment Numbers Earlier in this chapter, we saw that TCP uses ����������������������������������� ����������������������������������� ��������������� segment correctly, it sends back a TCP segment acknowledging the reception. We saw earlier that if the sending transport process does not receive an acknowledgment, it transmits the TCP segment again. The acknowledgment number field indicates which segment is being acknowledged. One might expect that if a segment has sequence number X, then the acknowledgment number in the segment that acknowledges\n\n39. it would have acknowledgment number X. Later in this book, we will see that the situation actually is more complex. The acknowledgment number indicates which segment is being acknowledged. Test Your Understanding 8. a) Why was TCP designed to be complex? b) Why is it important for networking professionals to understand TCP? c) What are TCP messages called? 9. a) Why are sequence numbers good? b) What are 1-bit fields called? c) If someone ����������������������������������� ����������������������������������� ������������� other field must have a value? e) What is the purpose of the acknowledgment number field? ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 66� ���������� �� ����������������� User Datagram Protocol Datagram Syntax Applications that cannot use the high functionality in TCP or that do not need this functionality can use the User Datagram Protocol (UDP) at the transport layer instead of TCP. UDP does not have openings, closings, or acknowledgments, and so it produces substantially less traffic than TCP. UDP messages are called datagrams. Because of UDP’s simple operation, the syntax of the UDP datagram shown in Figure 2-12 is very simple. Besides two port number fields, which we will see next\n\n40. in this chapter, there are only two header fields. �������������UDP length field so that the receiving transport process can know how long the datagram is. The packet in the datagram’s data field has variable length, so the UDP datagram has variable length. ������������������UDP checksum field that allows the receiver to check for errors in this UDP datagram.6 If an error is found, however, the UDP datagram is discarded. In contrast to TCP, UDP has no mechanism for retransmission. Test Your Understanding 10. a) What are the four fields in a UDP header? b) Describe the third. c) Describe the fourth. d) Is UDP reliable? Explain. Port Numbers Both TCP and UDP headers begin with two port number fields, one specifying the sender’s port number and one specifying the receiver’s port number. Servers and clients use these port number fields differently. Server Port Numbers Computers are multitasking machines, which means that they can run several programs at the same time. Figure 2-13 shows a server running SMTP (the Simple Mail Transfer Protocol), HTTP, and FTP (the File Transfer Protocol) 6 If the UDP checksum field has 16 zeroes, error checking is not to be done at all. Multitasking Server SMTP Application HTTP Application\n\n41. FTP Application Port Port 80 25 Ports 20 and 21 Packet Packet containing a TCP segment with Destination Port 80 FIGURE 2-13 Server Port Numbers ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 67 programs. If a packet arrives, how does the TCP or UDP process know which of the application programs running on the server should receive the message? The answer is that the TCP or UDP process uses a port number. A server’s port number specifies a particular application running on the server. Port 20 or 21 specifies the FTP (file transfer protocol) program, while Port 25 specifies the SMTP (e-mail) program, and Port 80 specifies the HTTP (World Wide Web) application. A server administrator can choose any port number for a program, but there are well-known port numbers that are normally used to specify particular server application programs. Most webservers use this port number for the webserver program. The well-known port numbers have a port number\n\n42. range reserved for their use—port numbers 0 through 1023. To send a TCP or UCP message to the application program on a server, the sender puts the appropriate port number in the destination port number field. Client Port Numbers Clients use port numbers differently. For every conversation a client initiates, it randomly generates an ephemeral port number. On Windows computers, this is the range from port 1024 to Port 4999. These port numbers are ephemeral, in the sense that they are discarded when a conversation between the client and a particular webserver ends. If the client communicates with the same server program later, the client will generate a new ephemeral port number. Figure 2-14 shows a client host (60.171.18.22) communicating with a blue server host (1.33.17.13). The server port number is Port 80, indicating that the client is communicating with the HTTP program on the server. The client has generated ephemeral Port 2707. When the client transmits to the server, the source port number field has the value 2707 and the destination port number 80. When the server replies, the source port number is 80 and the destination port number is 2707. The client is simultaneously connected to an SMTP application on a server (123.30.17.120), which uses the well-known port number 25. For this conversation, the Source: 60.171.18.22:2707 Destination: 1.33.17.13:80 Webserver 1.33.17.13\n\n43. Port 80 Client 60.171.18.22 SMTP Server 123.30.17.120 Port 25 Source: 1.33.17.13:80 Destination: 60.171.18.22:2707 Source: 60.171.18.22:4400 Destination: 123.30.17.120:25 Server Programs use Well-Known Port Numbers (0 to 1023) Clients use Ephemeral Port Numbers (usually 1024 to 4999) FIGURE 2-14 Client Port Numbers and Sockets ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 68� ���������� �� ����������������� client randomly generates ephemeral Port 4400. When the client transmits, the source port number is 4400 and the destination port number is 25. Sockets Figure 2-14 shows that a conversation always involves a source IP address and a source port number, plus a destination IP address and a destination port number. It is common to represent each IP address and port number as a socket, which is simply the IP address, a colon, and the port number. When the client transmits to the webserver, the source socket is 60.171.18.22:2707 and the destination socket is 1.33.17.13:80. When the webserver replies, the source socket is 1.33.17.13:80, and the\n\n44. destination socket is 60.171.18.22:2707. Test Your Understanding 11. a) What type of port numbers do servers use for common server programs? b) What type of port numbers do clients use when they communicate with server programs? c) What is the range of port numbers for each type of port? d) How are ephemeral port numbers generated? e) Why are they called ephemeral? 12. a) What is the syntax of a socket? b) In Figure 2-14, when the client transmits to the mail server, what is the source port number? c) What is the destination port number? d) What is the source socket? e) What is the destination socket? f) When the SMTP server transmits to the client host, what is the source port number? g) What is the destination port number? h) What is the source socket? i) What is the destination socket? HTTP Request and Response Message Syntax The highest layer is the application layer (Layer 5). Standards at this layer govern how application programs talk to one another. We have used HTTP in most of our examples so far. However, there are many application layer standards— more than there are standards at any other layer. There are application layer standards for e-mail, database queries, and every other application. After network professionals master the network and internet work standards that this course presents, they spend much of the rest of their careers mastering application standards. Unfortunately, some students become fixated on examples and\n\n45. lose sight of general principles. At the risk of feeding this fixation, we will look at the syntax for the Hypertext Transfer Protocol. Figure 2-15 illustrates the syntax of HTTP request and response messages. HTTP Request Message The HTTP request message is particularly simple. It consists of only three lines of text. Some HTTP request messages have additional lines, but it is rare to see an HTTP request message with more than a handful of lines. ������ ������ ����� ���������� ���� ���� ������� ������� ��������� �� ����� ������������ ���� location of the file to be retrieved (/panko/home.htm), and the version of HTTP used by the sender (HTTP 1.1). This and other lines end with [CRLF]. This stands for carriage return/line feed. It means to start a new line. ����������������������������������� ����������������������������������� ��������� be sent. ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 69 ������ ������ ����� ���������� ����� ���� ���� ������������ ������� ��� ����� ������� ����� multiple request–response cycles. Without this, the TCP connection would end after each request–response cycle and would have to be reestablished before each\n\n46. request–response cycle. After the first line, fields in the header have a very specific syntax. There is a keyword, a colon, and then a value for the keyword, then a carriage return/line feed. These three lines form the header of the message. The sender is transmitting no data, so there is no data field. Nor is there anything after a data field, so there is no trailer. HTTP Response Message Figure 2-15 also shows the syntax of a relatively simple HTTP response message that responds to the HTTP request message we have just seen. First, there is a header. The header is everything that comes before the data field, which is the file being delivered. ����������������������������������� ����������������������������������� �������������������� of the standard. The 200 is a code that describes the response. The 200 code states that the message is delivering the requested file. The browser uses the code to know HTTP The application layer is the highest layer It has more standards than at any other layer HTTP is not the only application layer standard; it is one of many Many application layer protocols, such as SMTP for e-mail, are much more complex than HTTP HTTP Request Message GET /panko/home.htm HTTP/1.1[CRLF] Host: voyager.shidler.hawaii.edu Connection: Keep-Alive HTTP Response Message\n\n47. HTTP/1.1 200 OK[CRLF] Date: Tuesday, 20-MAR-2014 18:32:15 GMT[CRLF] Server: name of server software[CRLF] MIME-version: 1.0[CRLF] Content-type: text/plain[CRLF] [CRLF] File to be downloaded. A string of bytes that may be text, graphics, sound, video, or other content. Notes A relatively old feeling protocol Fields ended by CRLF, which starts a new line Based on e-mail (an old protocol) for rapid development FIGURE 2-15 Hypertext Transfer Protocol Message Syntax ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 70� ���������� �� ����������������� ����������������������������������� ����������������������������������� ��������� ����������������������������������� ����������������������������������� ��������� 200 code means, that everything is alright. ����������������������������������� ����������������������������������� ����������������� then a value for the keyword. ����������������������������������� ����������������������������������� ������������ message was sent. ������ ������� ��������� ��� ������ ���������� ���� ���������� ��������� �������� ����\n\n48. response. Browsers know that different webserver programs respond somewhat ����������������������������������� ��������������������������������� ����������������������������������� ����������������������������������� �������������� header. Following the header is the file being sent to the browser. This is a long byte stream that constitutes the text document, photograph, video clip, or other type of file being delivered. As usual, there is no trailer. A Text Protocol In contrast to the other protocols we have looked at, HTTP is a fairly primitive protocol. It delimits fields with carriage return/line feeds instead of having fields that end at a certain number of bits. Separating the header from the data field with a blank line also seems rather crude. Most application protocols are much more complex than HTTP. Tim Berners-Lee, who created HTTP, based this standard on e- mail standards. An e-mail header has a number of keywords (e.g., To and From) followed by a colon, the value for the keyword, and a new line. E-mail standards were already very old when HTTP was created, but they got the job done. HTTP also got the job done. In particular, new keywords can be added very easily, given the robust way HTTP has of ending a field and starting a new field. Test Your Understanding 13. a) Is the application layer standard always HTTP? b) Which\n\n49. layer has the most standards? c) At which layer would you find standards for voice over IP? (The answer is not explicitly in this section.) d) Are all application layer standards simple like HTTP? e) In HTTP response headers, what is the syntax of most lines (which are header fields)? f) In HTTP request and response message, how is the end of a field indicated? g) Do HTTP request messages have headers, data fields, and trailers? h) Do HTTP response messages that deliver files have headers, data fields, and trailers? CONVERTING APPLICATION MESSAGES INTO BITS Encoding One function of application layer programs is to convert messages into bits. This conversion is called encoding. At the transport layer and lower layers, all messages consist of bits. Original application layer messages, in contrast, may have text, ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 71 numbers, graphics images, video clips, and other types of information. It is the application layer’s job to convert all of these into bits before putting them in the application layer message. Test Your Understanding 14. a) What is encoding? b) At what layer is encoding done? Encoding Text as ASCII To convert text data to binary, applications use the ASCII code,\n\n50. whose individual symbols are each 7 bits long. Seven bits give 128 possibilities. This is enough for all keys on the keyboard plus some extra control codes. Figure 2-16 shows some ASCII codes. It shows that uppercase letters and lowercase letters have different ASCII codes. This is necessary because the receiver may need to know whether a character is an uppercase or lowercase letter. ASCII can also encode the digits from 0 through 9, as well as punctuation and other characters. There are even ASCII control codes that tell the receiver what to do. For example, when we looked at HTTP, we saw carriage returns and line feeds. A carriage return is 0101110, and a line feed is 0100000. For transmission, the 7 bits of each ASCII character are placed in a byte. The eighth bit in the byte is not used today.7 Test Your Understanding 15. a) Explain how many bytes it will take to transmit “Hello World!” without the quotation marks. (Check Figure: 12.) b) If you go to a search engine, you can easily find converters to represent characters in ASCII. What are the 7-bit ASCII codes for “Hello world” without the quotation marks? (Check: H is 1001000.) 7 Early systems used the eighth bit in each byte as a “parity bit” to detect errors in transmission. The total number of bits in a byte was made a whole odd (or even) number by the value of the parity bit. This could detect a change in a single bit in the byte. At today’s high transmission speeds, however, transmission errors normally generate multibit errors rather than single-bit errors.\n\n51. Consequently, parity is useless and is ignored. Category Meaning 7-Bit ASCII Code 8th bit in Transmitted Byte Upper-Case Letters A 1000001 Unused Lower-Case Letters a 1100001 Unused Digits (0 through 9) 3 0110011 Unused Punctuation Period 0101110 Unused Punctuation Space 0100000 Unused Control Codes Carriage Return 0001101 Unused Control Codes Line Field 0001010 Unused FIGURE 2-16 Encoding Text as ASCII ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 72� ���������� �� ����������������� Converting Integers into Binary Numbers (1s and 0s) Some application data consists of integers, which are whole numbers (0, 1, 2, 3, … 345, etc.). The sending application program encodes integers as binary numbers. Figure 2-17 shows how this is done. Normal arithmetic uses Base 10 representation. A number such as 503 has three decimal positions. Each position has a value that is a power of 10. The position to the farthest right has a value of 100 (1). The next has the value 101 (10). The third has the value 102 (100). Consequently, the number 503 means 5 * 100 + 0 * 10 + 3 * 1. This comes so naturally that we do not notice we are treating numbers this way. Computers use binary (Base 2) arithmetic. Figure 2-17 shows that the positions in binary numbers represent 20, 21, 22, 23, 24, 25, and so forth. These positions have the values 1, 2, 4, 8, 16, 32, and so forth. Consequently, 1010 in\n\n52. binary has the value 1 * 8 + 0 * 0 + 1* 2 + 0 * 0 = 10 in decimal. Given this process, you can convert any binary number into its decimal equivalent. In this case, we converted 1010 in binary to 10 in decimal. Of course, encoding requires conversion in the opposite direction—from decimal to binary. Figure 2-18 shows how to do this conversion. Here, we wish to convert the decimal number 11 into binary. ����������������������������������� ����������������������������������� ������������������ 3 (11 – 8). ����������������������������������� ����������������������������������� ����������������������� now we have 1010 (1000 + 10). The remainder is 1 (3 – 2). ����������������������������������� ����������������������������������� ������������������ remainder is now 0, so we are finished converting the decimal number 11 into binary. Representing Decimal (Base 10) Numbers Position Exponent 104 103 102 101 100 Position Value in decimal 10,000 1,000 100 10 1 Decimal Number 5 0 3 Decimal Representation 503 = 5*100 + 0*10 + 3*1 Representing Binary (Base 2) Numbers Position Exponent 24 23 22 21 20 Position Value in decimal 16 8 4 2 1 Binary Number 0 1 0 1 0 Decimal Equivalents 0 8 0 2 0 Decimal Representation 1010 = 1*8 + 1*2 = 10\n\n53. FIGURE 2-17 Converting Binary Numbers to Decimal ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 73 Test Your Understanding 16. Answer the following without a calculator. a) What is an integer? b) Is 4,307 an integer? c) Is 45.7 an integer? d) Convert the binary number 100 to decimal. (Check Figure: 4.) e) Convert the binary number 1111 to decimal. f) Convert the binary number 10110 to decimal. g) Convert the binary number 100100 to decimal. h) Convert the decimal number 8 to binary. (Check Figure: 1000.) i) Convert 6 to binary (Check Figure: 110.) j) Convert 15 to binary. k) Convert 67 to binary. Encoding Alternatives Some application data can be expressed as alternatives, such as North, South, East, or West. The application layer process will create a field in the application layer message and represent each alternative as a group of bits. For instance, the four cardinal compass points can be represented by a 2-bit field within the application message. North, South, East, and West can be represented as 00, 01, 10, and 11, respectively. (These are the binary numbers for 0, 1, 2, and 3.) There is no order to the alternatives, so any choice can be represented by any pair of bits. We just saw that having four alternatives requires a 2-bit field. More generally,\n\n54. if a field has b bits, it can represent 2b alternatives. This gives us the following equation: Equation 1: a = 2b, where a is the number of alternatives and b is the number of bits We have just seen that a 2-bit field can represent 22 alternatives, or 4. Here, b is 2, so a is 4. What if you need to represent six alternatives? Two bits will not be enough, because 22 is only 4 and we need 6. A three-bit field will give us 23 alternatives, or 8. This gives us enough alternatives. Two alternatives will go unused. If a field has N bits, it can represent 2N alternatives. Position / Value / Step Remainder Binary Position 4 3 2 1 Binary Value 8 4 2 1 Step 0: Decimal number = 11 -- -- -- -- 11 Step 1: 8 is digit largest that will fit into 11 1 0 0 0 11 - 8 = 3 Step 2: 2 is the largest digit that will fit into 3 1 0 1 0 8 - 2 = 1 Step 3: 1 is the largest digit that will fit into 1 1 0 1 1 1 - 1 = 0 (finished) Final binary number 1 0 1 1 FIGURE 2-18 Encoding a Decimal Number into Binary ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 74� ���������� �� ����������������� Figure 2-19 illustrates how alternatives encoding is done for fields that have 1, 2, 4, 8, 16, and 32 bit. It shows that with one bit, you can encode yes or no, male or female, or any other dichotomy. Two bits, as we just saw, are good for the four cardinal compass points. With 4 bits, you can have 16 alternatives. You need 4\n\n55. bits to represent the top 10 security threats, because 3 bits will encode only eight alternatives. Using 4 bits to represent 10 threats will waste six alternatives, but this is necessary. With 8 bits, you can represent 256 alternatives. The a = 2b rule is not only used at the application layer. In many layer messages, fields represent alternatives. A one-octet field has 8 bits, so it can represent 28 possible alternatives (256). You should memorize the number of alternatives that can be represented by 4, 8, and 16 bits, because these are common field sizes. Each added bit doubles the number of alternatives, while each bit subtracted cuts the number of alternatives in half. So if 8 bits can represent 256 alternatives, 7 bits can represent 128 alternatives (half as many), while 9 bits can represent 512 alternatives (twice as many). How many alternatives can 6 and 10 bits represent? Test Your Understanding 17. a) What does the equation a = 2b mean? b) How many alternatives can you represent with a 4-bit field? (Check Figure: 16.) c) For each bit you add to an alternatives field, how many additional alternatives can you represent? d) How many alternatives can you represent with a 10-bit field? (With 8 bits, you can represent 256 alternatives. e) If you need to represent 128 alternatives in a field, how many bits long must the field be? (Check Figure: 7.) f) If you need to represent 18 alternatives in a field, how many bits long must the field be? g) Come up with\n\n56. three examples of things that can be encoded with 3 bits. Bits in Field Number of Alternatives that can be Encoded Possible Bit Sequences Examples 1 21 = 2 0, 1 Yes or No, Male or Female, etc. 2 22 = 4 00, 01,10, 11 North, South, East, West; Red, Green, Blue, Black 4 24 = 16 0000, 0001, 0010, … Top 10 security threats. Three bits would only give 8 alternatives. (With 4 bits, 6 values go unused) 8 28 = 256 00000000, 00000001, … One byte per color gives 256 possible colors levels. 16 216 = 65,536 0000000000000000, 0000000000000001, ‘… Two bytes per color gives 65,536 color levels. 32 232 = 4,294,967,296 000000000000000 0000000000000000, etc. Number of Internet Protocol Version 4 addresses If a field has b bits, it can represent a = 2b alternatives. FIGURE 2-19 Binary Encoding to Represent a Certain Number of Alternatives ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 75 Encoding Voice Increasingly, applications involve voice and even video. Figure 2-20 illustrates how voice encoding is done. Video encoding is done similarly. When\n\n57. you speak into a landline or mobile telephone, your voice loudness rises and falls thousands of times per second at different frequencies. This sends pressure waves into your phone’s microphone. The microphone converts this into increases and decreases in electricity. The resultant electrical signal rises and falls when your voice loudness rises and falls. To put it another way, the electrical signal is analogous to the voice signal. Therefore, we call this electrical signal an analog signal. The analog signal must be converted into 1s and 0s. This is done by an electrical circuit called a codec. Converting outgoing analog signals into digital signals is called encoding. Converting incoming digital signals into analog signals to cause the earpiece to vibrate is called decoding. Codec is a merciful shortening of these two terms. As we will see in Chapter 11, there are many codec standards. Some specify a higher traffic burden in terms of bits per second; these have higher voice quality. Others are more parsimonious about bandwidth but give lower voice quality. A codec converts between analog microphone signals and digital transmitted signals. Test Your Understanding 18. a) Why is the electrical signal generated by a microphone called an analog signal? b) What two things does a codec do? c) Is there a single codec standard? 101110100 Human Microphone Codec Transmission Circuit Human\n\n58. Voice Analog Electrical Signal Binary Signal Mobile Telephone A microphone converts the human voice into analogous (analog) electrical signals. The codec converts between analog electrical signals and digital transmission signals. FIGURE 2-20 Encoding Voice ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 76� ���������� �� ����������������� VERTICAL COMMUNICATION ON HOSTS So far, we have talked about what happens at individual layers. For instance, the transport process on the sending host sends TCP segments or UDP datagrams to the transport process on the receiving host. Obviously, however, there is no direct connection between the two hosts at the transport layer. Barring software telepathy, all communication must somehow travel through the physical layer. In Chapter 1, we saw that Layer 3 packets are carried in the data fields of Layer 2 frames in single networks. Networking people say that the packet is encapsulated (placed) in the data field of the frame. In general, encapsulation is placing a message in the data field of another message. Encapsulation is placing a message in the data field of another\n\n59. message. Figure 2-21 shows that encapsulation actually is a process that occurs repeatedly. ����������������������������������� ����������������������������������� ���������������� the application layer process on the destination host. The source host’s application HTTP Message HTTP Message TCP Hdr HTTP Message HTTP Message Application Process Transport Process Internet Process Data Link Process Physical Process TCP Hdr IP Hdr TCP Hdr IP Hdr\n\n60. Eth Hdr Eth Trlr 1. Encapsulation of HTTP message in data field of TCP segment 2. Encapsulation of TCP segment in data field of IP packet 3. Encapsulation of IP packet in data field of Ethernet frame L2 L5 L4 L3 L2 4. Conversion of bits into outgoing signals FIGURE 2-21 Layered Communication on the Source Host ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 77 process cannot deliver the HTTP message, so it passes the HTTP message down to the transport layer process on the source host. ����������������������������������� ����������������������������������� ����������� a TCP segment. The transport layer then passes the TCP segment down to the internet layer process. ����������������������������������� ����������������������������������� ��������������� packet. It then passes the packet down to the data link layer. ����������������������������������� ����������������������������������� ��������������� If the single network standard is Ethernet, this is an Ethernet frame. If the single\n\n61. network standard is the Point to Point protocol (PPP), this is a PPP frame. The data link layer process may also add a trailer. The whole process is like a set of Russian nesting dolls. So the frame consists of the following: ���������������������� ��������������� ���������������� ��������������������������������� ������ ����� ����� �������� ��� ���� ������� �������� ��������� ���� �� �������� ��� ���� ������ standard. At the physical layer, something very different occurs. When the physical layer process receives the frame from the data link layer process, it does not do encapsulation. It merely converts the bits of the frame into signals and transmits this signal out the physical link connecting it to a switch, router, or host. Test Your Understanding 19. a) What is encapsulation? b) Why is encapsulation necessary for there to be communication between processes operating at the same layer but on different hosts, routers, or switches? c) After the internet layer process in Figure 2-21 receives the TCP segment from the transport layer process, what two things does it do? d) After the data link layer process in Figure 2-21 receives the IP packet from the internet layer process, what two things does it do? e) After the physical layer process receives a frame from the data link layer process, what does the physical layer\n\n62. process do? f) If encapsulation occurs on the source host, what analogous process do you think will occur on the destination host? (The answer is not in the text.) CONCLUSION Synopsis In this chapter, we looked broadly at standards. Most of this book (and the networking profession in general) will focus on standards, which are also called protocols. Standards govern message exchanges. More specifically, they place constraints on message semantics (meaning), message syntax (format), and message order. Standards are connection-oriented or connectionless. In connection-oriented protocols, there is a distinct opening before content messages are sent and a distinct closing ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 78� ���������� �� ����������������� afterward. There also are sequence numbers, which allow fragmentation and are used in supervisory messages (e.g., acknowledgments) to refer to specific messages. In connectionless protocols, there are no such openings and closings. Connectionless protocols are simpler than connection-oriented protocols, but they lose the advantages of sequence numbers. In turn, reliable protocols do error correction, while unreliable protocols do not. Although unreliable protocols may do error detection without error correction, this does not make them reliable. In general, standards below the\n\n63. transport layer are unreliable in order to reduce costs. The transport standard usually is reliable; this allows error correction processes on just the two hosts to correct errors at the transport layer and at lower layers, giving the application clean data. Figure 2-22 compares the main protocols we have seen in this chapter in terms of connection orientation and reliability. To discuss message ordering in more detail, we looked at HTTP and TCP. Message ordering in HTTP is trivial. The browser must initiate the communication by sending an HTTP request message; afterward the webserver program may transmit. TCP, in contrast, has complex message ordering. Correctly received TCP messages (called TCP segments) are acknowledged by the receiver. If the sender does not receive an acknowledgment promptly, it retransmits the unacknowledged segment. This gives reliability. To discuss message syntax in more detail, we looked briefly at the syntax of Ethernet frames, IP packets, TCP segments, UDP datagrams, and HTTP request and response messages. We saw that they represent syntax in three different ways. We will be looking at the syntax of many messages in this course, so you should be familiar with all methods for representing syntax. In the discussion, we saw that octet is another name for byte. We also saw that application programs on multitasking servers are usually represented by wellknown port numbers, while clients use ephemeral port numbers to represent conversations with server programs. A socket consists of an IP address, a\n\n64. colon, and a port number. It represents a particular program (or conversation) on a particular host. The application layer must convert text, graphics, video, and other application layer content into bits (1s and 0s). In this chapter, we looked at how application programs encode ASCII text, integers, a number of alternatives, and voice and video streams into strings of bits. We looked at how layer processes work together on the source host. After each layer creates its message, it immediately passes the message down to the next-lowerlayer process. The data link, internet, and transport processes take every message they are given and encapsulate it in a message suitable for that layer. Layer Protocol Connection-Oriented or Connectionless? Reliable or Unreliable? 5 (Application) HTTP Connectionless Unreliable 4 (Transport) TCP Connection-oriented Reliable 4 (Transport) UDP Connectionless Unreliable 3 (Internet) IP Connectionless Unreliable 2 (Data Link) Ethernet Connectionless Unreliable FIGURE 2-22 Protocols in this Chapter ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ���������� �� ����������������� 79 END-OF-CHAPTER QUESTIONS Thought Questions 2-1. How do you think TCP would handle the problem\n\n65. if an acknowledgment were lost, so that the sender retransmitted the unacknowledged TCP segment, therefore causing the receiving transport process to receive the same segment twice? 2-2. a) In Figure 2-14, what will be the value in the destination port number field if a packet arrives for the e-mail application? b) When the HTTP program on a webserver sends an HTTP response message to a client PC, in what field of what message will it place the value 80? 2-3. Do the following without using a calculator or computer, but check your answers with a calculator or computer. a) Convert 110100 to decimal. (Check Figure: 52.) b). Convert 001100 to decimal. c) Convert 7 to binary. (Check Figure: 111.) d) Convert 47 to binary. e) Convert 3,270 to binary. 2-4. Do the following without using a calculator or computer, but check your answers with a calculator or computer. You need to represent 1,026 different city names. How many bits will this take if you give each city a different binary number? Explain your answer. Brainteaser Questions 2-5. How can you make a connectionless protocol reliable? (You may not be able to answer this question, but try.) 2-6. Spacecraft exploring the outer planets need reliable data transmission. However, the acknowledgments would take hours to arrive. ����������������������������������� ���������� unattractive. Can you think of another way to provide more reliable data transmission to spacecraft without using acknowledgments? (You may not be able to answer this question,\n\n66. but try.) Perspective Questions 2-7. What was the most surprising thing you learned in this chapter? 2-8. What was the most difficult material for you in this chapter? ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 80 INTRODUCTION A good way to practice what you have learned in this chapter is to look at individual packets. Packet capture programs record packets going into and out of your computer. If you capture a brief webserver interaction, you can look at header fields, TCP three-step connection starts, and other information. There are several good packet capture programs. We will look at Wireshark, which is simple to use, popular, and free to download. (At least at the time of this writing.) GETTING WIRESHARK To get Wireshark, go to wireshark.org. Do not go to wireshark.com. Follow the instructions and download the program on your computer. LEARNING OBJECTIVES By the end of this chapter, you should be able to: ▪ Use the Wireshark packet capture program at a novice level. ▪ Capture packets in real time. ▪ Analyze the packets at a novice level. Hands-On: Wireshark Packet Capture Chapter 2a ISBN 1-323-07906-8\n\n67. Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ����������� �� ����������������������������������� 81 USING WIRESHARK Getting Started After installation, open the Wireshark program. You will see the opening screen. It will look like the screen in Figure 2a-1. There will be controls at the top with a blank area below them. You will soon fill this area with your packet capture. Starting a Packet Capture ��� ������ �� ������� ��������� ������ ��� ���� ��� ����� ������ ������ ����� ���� ����������� Capture Interfaces dialog appears, as Figure 2a-2 illustrates, select a network interface and click on Start. FIGURE 2A-1 Initial Wireshark Screen FIGURE 2A-2 Starting a Packet Capture in Wireshark ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. 82� ����������� �� ����������������������������������� Getting Data Your browser should already be open. Switch to your browser and enter a URL. (In this example, the author went to Wikipedia.org.) This creates a flurry of packets between you and the host specified in the URL. These appear on the window below the controls,\n\n68. as shown in Figure 2a-3. FIGURE 2A-3 Collecting Data ISBN 1-323-07906-8 Business Data Networks and Security, Tenth Edition, by Raymond R. Panko and Julia L. Panko. Published by Prentice Hall. Copyright © 2015 by Pearson Education, Inc. � ����������� �� ����������������������������������� 83 Stopping Data Collection To stop the data collection, click on the Capture menu item, as Figure 2a-4 shows. When the dropdown menu appears, select Stop. You now have a packet stream to analyze. Looking at Individual Packets Now you can begin looking at individual packets. To see how to do this, look again at Figure 2a-3. Packet Summary Window In the upper window in the display area, you can see the packets one at a time. The capture begins with two ARP packets, which we will discuss when we get to the TCP/IP chapters. Then comes two DNS packets. In the example, the author typed the host name Wikipedia.org in the URL. The author’s computer (192.168.1.100) sent a DNS request message to its DNS server to get the IP address for Wikipedia.org. The DNS sent back the requested IP address. Now, the author’s computer opened a connection to 208.80.152.2, which is Wireshark.org’s IP address.1 It first sent a TCP SYN segment to 208.80.152.2. This is Frame 5. In Figure 2a-3, the frame has been selected. Information about the contents of this particular frame is shown"
    }
}