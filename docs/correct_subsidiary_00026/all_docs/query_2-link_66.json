{
    "id": "correct_subsidiary_00026_2",
    "rank": 66,
    "data": {
        "url": "https://www.hydrogen18.com/blog/peeking-under-the-hood-of-command-conquer.html",
        "read_more_link": "",
        "language": "en",
        "title": "Peeking under the hood of Command & Conquer",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "code-review",
            "c++",
            "video-games"
        ],
        "tags": null,
        "authors": [
            "Eric Urban"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Looking at the newly released source for Command & Conquer to see what makes it tick.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.hydrogen18.com/blog/peeking-under-the-hood-of-command-conquer.html",
        "text": "The original source code for Command & Conquer as well as Command & Conqueror: Red Alert have been released by Electronic Arts. You can grab it here on GitHub.\n\nEverything is licensed under the GPL v3 and the source code contains all the original comments. The original changelog from whatever VSC was used is not present. It looks like everything was just put into Git very recently.\n\nI decided to take a peak at what goes on inside this game engine. I'm not going to spend my time reviewing every line of code, but it should at least be interesting to find out what game development in C++ was like in the early 1990s.\n\nI'm looking only at the source code for \"Command & Conquer: Red Alert\" as it looks like it is a fork of the original. You can find it under the REDALERT directory.\n\nStatistics\n\n290 C++ Header files\n\n296 C++ implementation files\n\n14 assembler files containing x86 assembler instructions\n\n222090 lines of C++ code\n\nI got the lines of code figure by counting up the non empty lines then subtracting out lines that were obviously just comments.\n\nAlmost all file names are uppercase only.\n\nThere is also a \"RedAlert.vcxproj\" file, so presumably this is ready to build in newer versions of visual studio. I did not confirm this.\n\nIs this everything?\n\nFirst off, there are no assets at all. Not even a test set. So you would need to somehow legally acquire those, for example you might buy the game from EA. Until you do that, even if you compile the code you can't really prove it works.\n\nThe code is littered with #ifdef WIN32, in fact there are at least 430 occurences. There is a folder WIN32LIB that contains some platform specific implementations for Microsoft Windows. There are no other platforms implemented. The compiler directives for #ifdef WIN32 don't have an #else anywhere I saw for other platforms. So I'm not entirely sure what the point was, but DOS was a supported platform. So maybe all the checks allow a build of the game that works on DOS but not Windows.\n\nI thought I found two files LCW.CPP and LCWUNCMP.CPP which reference the playstation platform indirectly\n\nThis file implements the LCW compression algorithm.\n\nBut what the \"PSX\" actually refers to is the POSIX standard through a less than common acronym. There is even another implementation of the same compression function LCW_Comp from LCW.CPP in LCWCOMP.ASM. I think the C++ implementation must have just been used on some platforms where the assembly code wouldn't work.\n\nSo I guess they didn't release the Playstation port. I don't even know if the Playstation port was done by Westwood or if it was just subcontracted out.\n\nInterestingly, LZO & LZW compression algorithms are also implemented. So I guess Westwood studios strategy for choosing which technology was \"all of the above\". LCW should have been sufficient to dodge the Unisys patent claims on LZW, but maybe the LZW code just stuck around. The only usage of the LZW code is in LZWPIPE.CPP which defines the LZWPipe class. The only usage of that code is commented out\n\nIt looks like a few different algorithms were tried in this case and LZO was settled on. So LZW appears to be available, but not used.\n\nUnisys patent claim against LZW expired a long time ago, so there is no longer any concern over this.\n\nWeird headers\n\nA header like this present in LZW.H and other files\n\nThe \"CounterStrike\" here refers to \"Command And Conquer: Counterstrike\" which is an expansion pack. There are 215 occurences of #ifdef FIXIT_CSII that somehow changes things for the expansion pack. The full explanation comes from \"awj\" on 9-28-1998 in a comment\n\nMissing source code\n\nThere is also the question of WOLAPI.dll which seems to mean \"Westwood Online API\". This was used for online matchmaking. The author of Command & Conquer: Red Alert apparently disliked this library enough to write a complete wrapper around it, it is in WOLAPIOB.H. You can probably just go find the original wolsetup.exe file and extract the DLL from it. But it also likely isn't very useful.\n\nFunnily enough, it appears that WOLAPI.dll was actually reverse engineered over 9 years ago\n\nThis is not a full source code release, but should be enough for people to understand the internal game mechanics. EA stated the reason for their release was to help modders, so this probably accomplishes that. With substantial work a standalone game could be built.\n\nHow does the game startup?\n\nI decided to start by looking at how the game starts up. Startup code usually gives you a good idea of how a game engine communicates with the operating system. This is presented roughly in the order that it actually is in the code, but not exactly. Anything not interesting is skipped.\n\nThe C++ main function.\n\nThe main function is defined in STARTUP.CPP. The game appears to have recently been rebuilt as a DLL, presumably for the remastered version that is being released. So the first thing it does is assigns RunningAsDLL = true;\n\nThe main function checks #ifdef MPEGMOVIE as well as #ifdef MCIMPEG all over the place. In DEFINES.H this is commented out entirely\n\nSo presumably the functionality to play MPEG cinematics is missing from the game.\n\nThe first thing that happens is it checks for another copy of the game runing and refuses to start. This seems to have been disabled with a #if (0). There are many sections of code disabled in this manner, each one featuring a //PG. One of the committers in Git is PG-SteveT so I guess the same person who put this project in Git was responsible for porting this to be a DLL rather than a standalone executable. There are many more sections like this in the main function, I am referring to them just as disabled from here forward.\n\nNext up is checking for free memory. The first check is just allocate 13 megabytes of memory and if that works free it. There is another check that is disabled that tries to allocate 13 megabytes of memory in a loop. Each iteration of the loop reduces the requested allocation by 1 kilobyte until it passes. I think it is safe to assume modern computers running Command & Conquer will have the needed 13 megabytes of memory, so it is sensible that this is disabled.\n\nThe next check is to see if the command line contains f:\\\\projects\\\\c&c0 or F:\\\\PROJECTS\\C&C0 and refuse to start if that is the case. If it is, a dialog box saying \"Playing off of the network is not allowed.\" pops up and the game exits. A quick inspection of some header files lead me to find this\n\nSince \"vcs\" is in the path it seems like an early version control system was used, that acted as a mounted drive in Microsoft Windows. The last time I used IBM Rational ClearCase it still works like this. This probably was done to prevent people from running the game from the network share and constantly overwriting each other's save files.\n\nThe game implements its own command line parsing logic, implemented inline in the main function\n\nI didn't really bother proving this works, but it looks like it scans for things being in quotes on the command line and then tries to treat them as groups if they are quoted using \". I guess the Windows command line couldn't handle this so it was done in the game directly. I actually don't know if cmd.exe implements this quoting logic even today.\n\nMain then saves off the original working directory and drive the game was launched from, before changing to the directory with the executable. Interestingly this seems to default to A: which would usually be a floppy drive on Windows. This code path is disabled entirely now.\n\nNext up is the first #ifdef WOLAPI_INTEGRATION. This isn't defined and the source code for the Westwood Online API is not available. If it were defined, the game would try and find a file named wolsetup.exe and run it, before checking for a Windows registry key indicating that setup is complete. A rather interesting comment shows up here\n\nApparently the developers after version 1.08 of the game really needed to not have \"conquer.eng\" be present. So they just try and delete it every time the game starts up. Why this is packed in with the Westwood Online code, I don't know.\n\nNow we move on to a check for #if(TEN) which is not defined. If it were defined, the game would setup for support for the Total Entertainment Network.\n\nRight after that check there is a check for #if(MPATH) which is also not defined. It if were then the game would have support for the MPlayer.\n\nBoth were decently popular online gaming platforms in the last half of the 1990s. My guess is there was a custom build for MPlayer & TEN support. Neither exists today. I discuss these more later in this article.\n\nNow the game starts a Windows timer, sleeps for 1000 milliseconds and makes sure the system clock has advances. If this fails it exits the game. I guess the implementation of sleep on some platforms was sufficiently faulty to warrant such a check during startup. This code has now been disabled.\n\nThen the game checks for free disk space and if it doesn't have enough it exits. This code has now been disabled.\n\nIt's now onwards to loading the configuration generated from the ccsetup program that comae with the original game. This doesn't do anything too interesting, but I did notice this\n\nA \"DebugQuiet\" configuration was added that appears to select an audio output that does nothing. I suppose it would be quite annoying if you were testing the game to be continually subjected to the noise.\n\nAt this point the game is ready to configure the display resolution. This code is exceptionally interesting. The first step is to check for a screen height of 400, which means a mode of 640 x 400 has been selected. If this can't be set it falls back to 640 x 480. Any other screen resolution is uset directly. What is so special about a mode of 640 x 400?\n\nTo actually do rendering the game needs graphics memory access. A screen width of 320 results in a special code path running to initialize the display buffers. My guess is anyone running on a video mode of 320x240 (which is still VGA) is running on such old hardware they don't bother trying to use hardware buffers. Any other screen height results in an attempt to allocate hardware buffers for the visible memory page and a hidden memory page. I suspect double buffering of the graphics is used, hence two buffers. For the visible memory page it is mandatory that hardware memory is available. There is some interesting logic around this allocation\n\nI can only imagine that the \"Aaaarrgghh!\" comment was added after a long session of debugging performance issues on some machines. At some point someone realized that the DirectDraw API (part of DirectX) could return a system memory page even when a hardware video page is asked for.\n\nThe hidden page is a bit more lenient, but has the logic and even better comments\n\nThe same \"double check\" applies to this page as well, but can fallback to system memory. The comment specifically calls out the IBM Aptiva as a source of these issues. I suspect the IBM Aptiva must have been the butt of many jokes during develpoment because DEFINES.H even has a line for #define FIXIT_APTIVA_MODEM which does in fact use special logic for dealing with the IBM Aptiva's modem.\n\nAt this point the game now configures the ScreenHeight to exactly 3072. A graphics buffer is attached to the visible & hidden pages it with dimensions of 3072 x 3072. As far as I can tell almost all the above code around getting hardware memory is in fact disabled by the use of #if statements. It's such a mess it is hard to tell what is enabled and what is not. But all the press releases about the remaster mention \"4K\" support. So maybe the real resolution of this \"4K\" remaster is in fact 3072 x 3072.\n\nAs recently as 2019, some changes were made with comments indicating the date and time. Someone with initials JAS added a check to see if they were running from the editor (presumably the level editor) and avoids taking over the mouse if that is the case. The remaster was announce in Novemeber 2018, so this timeframe makes sense for various changes need to implement & test 4K support with new asset files.\n\nThere is all kinds of now disabled logic about forcing the intro cinematic on the first run through. It's almost bipolar, unable to make its mind up as to whether or not the user really needs to see this cinematic. At some point this was commented out, probably during the remaster development. I imagine developers and testers got very tired of watching the intro cinematic very quick, so I suspect it would have been removed during the original devlopment as well.\n\nThe game is now ready to play! It then runs Main_Game (from CONQUER.CPP) which is the actual game loop. The start date in a comment in this file is \"April 3, 1991\", so the original Command & Conquer had 4 years of development before release in 1995!\n\nOnce the game is complete, the Main_Game function can return. There is a bunch of cleanup code, but before we get there we have this check\n\nSo presumably the DLL leaves the graphics in a weird state and probably leaks memory all over the place.\n\nOther investigations\n\nI decided to spend some time looking at other things I found interesting, based off the filenames.\n\nWindows 95 Stack traces.\n\nThe file W95TRACE.CPP contains the comment\n\nThis seems to suggest development was done on Windows NT, but testing was probably done on Windows 95 to make sure it worked for the intended audience. This would make sense as NT would be available as early as July 1993 to developers working on the game. I suspect the Windows 95 stack traces are woefully unhelpful compared to what Windows NT could provide.\n\nUpdate 2020-06-08 A reddit user by the name of /u/elder_george pointed out that in fact this is not for stack traces, but instead provides logging and tracing. In fact it appears to be based off an article published back in October of 1996.\n\nWatcom compiler\n\nThere is also WATCOM.H that defines lots of \"#pragma\", which are all obviously specific to the then popular Watcom compiler.\n\nThis is sort of interesting, because the Watcom compiler first release was 1993 for C++ support. There are other development notes indicating this project goes back to 1991. Did it start off as a C project and move to C++? Or did they have another C++ compiler available?\n\nThere is also this gem from the same file, I guess some compiler writers could not be bothered to implement true & false at this time\n\nEncryption\n\nBlowfish encryption is implemented in BLOWFISH.CPP, which presumably is the well known Blowfish cipher. The only real use I can think for for this is to obfuscate network traffic.\n\nUpdate 2020-06-09 A reader mentioned that this is used to decrypt the assets. This is documented in OpenAI's source code, which is an open source reimplmentation of the C&C game\n\nEntity system\n\nThe CCPtr class in CCPTR.H is a pointer like type that uses an ID as an offset into a memory heap. This is pretty common, because it makes saving the state of the game to disk easier if all objects are tracked in one place. This functions as a very simple way to have an entity system. If you're curious about what the advantages of an entity system are in a video game, you can read more here.\n\nVectors\n\nThe VECTOR.H class defines a template class vaguely similar to std::vector. Presumably this was developed too early to take advantage of STL.\n\nDipthongs\n\nSo a dipthong is a combination of two adjacent vowel sounds within the same syllable. What does this have to do with video game code? Nothing honestly. The strangest file is WIN32LIHB/DIPTHONG.H. The actual description given of this is found in the header\n\nThis is bascially a simple compression algorithm that assumes you're compressing text and does some subsequence replacement.\n\nIn the code we find the magic number 4567 used when making some defines\n\nThe following code runs as part of decompression\n\nThe array \"InternetTxt\" is just a bunch of predefined strings. It appears anything equal to or above \"4567\" is considered to be a predefined string. My guess is this constant was chosen by the developer pressing the keys 4-5-6-7 on the digits row on their keyboard. When I need to generate a random integer to use as a constant, I prefer this method.\n\nThe Entertainment Network & MPlayer\n\nAs I mentioned up above, there appear to be custom builds for supporting The Entertainment Network & MPlayer. These were online multiplayer services at the time.\n\nEach service got its own custom initialization & teardown code.\n\nThe Entertainment Network (TEN) files\n\nCCTEN.CPP\n\nTENMGR.H\n\nThe following functions are used but have no implementation in the source code\n\ntenArSendToPlayer\n\ntenArExitArena\n\ntenArIdleArena\n\ntenArReturnGameOptions\n\ntenArReturnPlayerOptions\n\ntenArSendToOtherPlayers\n\ntenArSendToPlayer\n\ntenArSetAlertMessageRoutine\n\ntenArSetIncomingPacketRoutine\n\ntenArSetOption\n\ntenArSetPlayerEnteredRoutine\n\ntenArSetPlayerState\n\ntenArSetPregameHookRoutine\n\ntenArUnreliableSendToOtherPlayers\n\ntenArUnreliableSendToPlayer\n\nMPlayer (MPATH) files\n\nCCMPATH.CPP\n\nMPMGRW.H\n\nMPMGRD.H\n\nThe following functions are used but have no implementation in the source code\n\nMGenMoveTo\n\nMGenGetMasterNode\n\nMGenFlushNodes\n\nMGenMCount\n\nMGenSanityCheck\n\nMGenGetNode\n\nMGenGetQueueCtr\n\nI can't find any details on the missing functions from the TEN code.\n\nThe \"MPATH\" code calls a bunch of \"MGen\" functions which are also missing. However, you can just go look them up in the Quake Source code. Quake was also available on both of these networks. The TEN code isn't present in the public Quake source however. I am guessing that MPlayer integration was done by just sharing a standard library with the development studio and having them integrate it.\n\nMy guess is EA was cautious and didn't feel they owned this code, whereas id software may have simply not cared at the time that Quake was released.\n\nOf course, no one actually needs this code. It's just the last thing that remains of what was a staple of late 1990s gaming services.\n\nUpdate 2020-06-08 Larry Hastings reached out to me directly to correct some of my assumptions. It turns out the source code that I presumed was in fact the MPlayer implementation is not. In fact it is a piece of software called the \"chunnel\" which allows a DOS mode application running on Windows 95 to interact with the networking stack provided by Windows. He also shared some details of how MPlayer integrated with games. I've reproduced it here, with the names of other individuals removed.\n\nFirst, most companies didn't do their own integration with Mplayer; they just sent us a code drop and we had to figure out how to build it and do all the integration work ourselves. But I think Westwood was the exception to the rule. I remember one of our \"porting engineers\" took a trip out to visit Westwood before Red Alert shipped. He was very impressed by the RA network model!\n\nSecond, all Mplayer assets were sold to GameSpy, who didn't want any of the online services (Mplayer / POP.X / Global Rankings). All they wanted was the userbase, and... the ad sales team, maybe? Anyway, GameSpy folded in 2013, and their assets were sold to Glu Mobile, so I guess theoretically they own the IP now. Meanwhile, in 1998 TEN pivoted to do \"classic\" online games, in 1999 they rebranded themselves as Pogo.com, and in 2001 they were bought by... EA! So EA is probably safe shipping the TEN code. And I doubt anybody cares about the Mplayer code either, it's long dead.\n\nThird, remember how I said companies tended to do a code drop and Mplayer did the integration work themselves? That was true of id software too. The Mplayer code you saw inside Quake 1 is not integration with the Mplayer gaming service! It's actually technology we licensed to id called the \"chunnel\", written by a British programmer guy named ***. The \"chunnel\" was a library that let 386 protected mode DOS programs running under Windows make calls into Windows 95's Winsock networking stack. Remember, this is circa 1996, gaming under Windows hadn't quite happened yet. Quake initially shipped as a DOS program and wasn't ported to Win32 until a year or two later. The \"chunnel\" solved a real problem for id, letting their 386 protected mode DOS program participate in network play when run under Windows. Part of how they showed their thanks was, Mplayer got every id game (while it was a going concern). Note that if you run early versions of Quake for DOS, like the initial shareware demo, the \"splash screen\" has the original Mplayer logo (the golden waveform), and a note about \"technology licensed from\". And that explains the \"-mpath\" command-line setting for the DOS builds of Quake ;-)\n\nTranslation & Localization\n\nIt's always common to see games ported to other languages, so they can appeal to a wider market than the English speaking world. Interesting, the localization was done at least in part by using #ifdef GERMAN statements sprinkled around as well as being checked in LANGUAGE.H before defining things like TEXT_SETUP_FIRST.\n\nThe check #ifdef GERMAN shows up 28 times, but #ifdef FRENCH shows up 37 times. Maybe the French translation was just a bit more thorough.\n\nOf course DEFINES.H has the best translation implementation\n\nI guess they just never got around to the Spanish translation.\n\nDongle protection\n\nThe hardware dongle was a common method of DRM for all sorts of software at some point in the past. Basically you have this obscure & obfuscated piece of hardware you attach to your PC. The software issues some sort of \"challenge\" to it and refuses to start if it doesn't get an answer it likes.\n\nI don't think Command & Conquer shipped with this as a thing, but DEFINES.H does have a commented out line or two about it\n\nVirgin Interactive\n\nWestwood studios developed Command & Conquer but was owned by Virgin Interactive. There is this uniquely named check\n\nI guess that before release, Virgin Interactive got a special built that allowed them do some play testing on the product.\n\nThe end\n\nThat's it. I didn't look at everything, just what I found interesting and had time to. I learned a little bit about early 1990s video game development and maybe I can put some of that knowledge to use in the present.\n\nMaybe in the future I will visit this again. I was really looking forward seeing how the the Playstation port of the game compared, but I am guessing EA cannot actually release such a thing even if they have the source code still."
    }
}