{
    "id": "wrong_mix_random_nbateam_00096_2",
    "rank": 57,
    "data": {
        "url": "https://www.usenix.org/conference/usenixsecurity15/technical-sessions",
        "read_more_link": "",
        "language": "en",
        "title": "Technical Sessions",
        "top_image": "https://www.usenix.org/sites/default/files/usenix_og_1200x630_2.png",
        "meta_img": "https://www.usenix.org/sites/default/files/usenix_og_1200x630_2.png",
        "images": [
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/facebook_150x50_3.png?itok=j3fA7FR8",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/nsf_150x60_v2.png?itok=cppdWfbE",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/symantec_logo_1.png?itok=g8mHE6Gy",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/google_6.png?itok=44PTsWoC",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/microsoft_150x60_0.png?itok=DGcdOtzO",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/ieee_cybersecurity_150x73.png?itok=SVHOMOY3",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/craigslist_150x35_1.png?itok=O1TU-rcW",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/qualcomm_150x22.png?itok=E5MjWNbx",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/oxford_university_press_150x55.png?itok=SStxrPiX",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/infosecnews_150x38.png?itok=nX284xi8",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/admin_150x60.png?itok=WhBbvI1a",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/hpcwire_150x55_0.png?itok=vkxDBAEf",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/linux_journal_150x72_2.png?itok=FnS1jr_Q",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/crc_press_150x60.png?itok=FBreaCBa",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/linux_pro_150x60.png?itok=v7MdML3Y",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/nostarch_600x240_0.png?itok=-tnLHd_x",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/virus_bulletin_150x60.png?itok=y4MHZfj0",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/userfriendly_150x60.png?itok=Ffl_2fwm",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/acmqueue_150x48_3.png?itok=7iBpCl4E",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/dmtf_600x240.png?itok=0wfJDDDw",
            "https://www.usenix.org/sites/default/files/styles/sponsor_slideshow_front/public/sponsor_images/eff_horizontal_150x66_1.png?itok=5QRRigFZ",
            "https://www.usenix.org/sites/default/files/sec16_button_180.png",
            "https://www.usenix.org/sites/all/themes/waves/css/images/twitter-icon.jpeg",
            "https://www.usenix.org/sites/all/themes/waves/css/images/facebook-icon.jpeg",
            "https://www.usenix.org/sites/all/themes/waves/css/images/in-icon.jpeg",
            "https://www.usenix.org/sites/all/themes/waves/css/images/googleplus-icon.jpg",
            "https://www.usenix.org/sites/all/themes/waves/css/images/youtube-icon.jpg",
            "https://www.usenix.org/modules/file/icons/application-pdf.png",
            "https://www.usenix.org/modules/file/icons/application-pdf.png",
            "https://www.usenix.org/modules/file/icons/application-pdf.png",
            "https://www.usenix.org/modules/file/icons/application-pdf.png",
            "https://www.usenix.org/modules/file/icons/application-octet-stream.png",
            "https://www.usenix.org/modules/file/icons/application-octet-stream.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_files/images/usenix-locked.png",
            "https://www.usenix.org/modules/file/icons/package-x-generic.png",
            "https://www.usenix.org/sites/all/themes/waves/css/images/conference-schedule-pdf.png",
            "https://www.usenix.org/sites/default/files/styles/speaker_photo/public/danzig_richard_115x125.jpg?itok=E-2-_gbN",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/pdf_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/slides_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/video_16.png",
            "https://www.usenix.org/sites/all/modules/usenix/usenix_media/images/audio_16.png",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/facebook_150x50_3.png?itok=dM3lNM8n",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/nsf_150x60_v2.png?itok=b9rji-IA",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/symantec_logo_1.png?itok=S9P66UDW",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/google_6.png?itok=grkHl1YO",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/ieee_cybersecurity_150x73.png?itok=ohnR5Srr",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/microsoft_150x60_0.png?itok=ENY_OzHU",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/craigslist_150x35_1.png?itok=e8A6JvQC",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/qualcomm_150x22.png?itok=nxCiXwWo",
            "https://www.usenix.org/sites/default/files/styles/sponsor_interest_color/public/sponsor_images/oxford_university_press_150x55.png?itok=oIN3Z9m2",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/acmqueue_150x48_3.png?itok=_wfwwCzt",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/admin_150x60.png?itok=bvp8Ir-8",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/crc_press_150x60.png?itok=XyulDjlT",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/dmtf_600x240.png?itok=t9FgkGRQ",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/eff_horizontal_150x66_1.png?itok=iPZRhygT",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/hpcwire_150x55_0.png?itok=W-D-ks8-",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/infosecnews_150x38.png?itok=FGIIFyIA",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/linux_journal_150x72_2.png?itok=sO1HKt-M",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/linux_pro_150x60.png?itok=oRf98chq",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/nostarch_600x240_0.png?itok=OA6SKmZa",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/userfriendly_150x60.png?itok=0aTzbSq8",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/virus_bulletin_150x60.png?itok=ItVoQQER",
            "https://www.usenix.org/sites/default/files/styles/sponsor_front_color/public/sponsor_images/peerj_600x240.png?itok=RtPpj4Ny"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Andrea Lanzi",
            "Elaine Shi",
            "Davide Balzarotti",
            "Marten van Dijk",
            "Michael Bailey",
            "Srinivas Devadas",
            "Mingyan Liu",
            "Mariano Graziano",
            "Yongdae Kim",
            "Peng Liu"
        ],
        "publish_date": "2015-05-20T14:21:40-07:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.usenix.org/sites/default/files/waves_favicon.ico",
        "meta_site_name": "USENIX",
        "canonical_link": "https://www.usenix.org/conference/usenixsecurity15/technical-sessions",
        "text": "Research on botnet mitigation has focused predominantly on methods to technically disrupt the commandand- control infrastructure. Much less is known about the effectiveness of large-scale efforts to clean up infected machines. We analyze longitudinal data from the sinkhole of Conficker, one the largest botnets ever seen, to assess the impact of what has been emerging as a best practice: national anti-botnet initiatives that support largescale cleanup of end user machines. It has been six years since the Conficker botnet was sinkholed. The attackers have abandoned it. Still, nearly a million machines remain infected. Conficker provides us with a unique opportunity to estimate cleanup rates, because there are relatively few interfering factors at work. This paper is the first to propose a systematic approach to transform noisy sinkhole data into comparative infection metrics and normalized estimates of cleanup rates. We compare the growth, peak, and decay of Conficker across countries. We find that institutional differences, such as ICT development or unlicensed software use, explain much of the variance, while the national anti-botnet centers have had no visible impact. Cleanup seems even slower than the replacement of machines running Windows XP. In general, the infected users appear outside the reach of current remediation practices. Some ISPs may have judged the neutralized botnet an insufficient threat to merit remediation. These machines can however be magnets for other threats — we find an overlap between GameoverZeus and Conficker infections. We conclude by reflecting on what this means for the future of botnet mitigation.\n\nMobile money, also known as branchless banking, brings much-needed financial services to the unbanked in the developing world. Leveraging ubiquitous cellular networks, these services are now being deployed as smart phone apps, providing an electronic payment infrastructure where alternatives such as credit cards generally do not exist. Although widely marketed as a more secure option to cash, these applications are often not subject to the traditional regulations applied in the financial sector, leaving doubt as to the veracity of such claims. In this paper, we evaluate these claims and perform the first in-depth measurement analysis of branchless banking applications. We first perform an automated analysis of all 46 known Android mobile money apps across the 246 known mobile money providers and demonstrate that automated analysis fails to provide reliable insights. We subsequently perform comprehensive manual teardown of the registration, login, and transaction procedures of a diverse 15% of these apps. We uncover pervasive and systemic vulnerabilities spanning botched certification validation, do-it-yourself cryptography, and myriad other forms of information leakage that allow an attacker to impersonate legitimate users, modify transactions in flight, and steal financial records. These findings confirm that the majority of these apps fail to provide the protections needed by financial services. Finally, through inspection of providers’ terms of service, we also discover that liability for these problems unfairly rests on the shoulders of the customer, threatening to erode trust in branchless banking and hinder efforts for global financial inclusion.\n\nFebruary 2011 saw the emergence of Silk Road, the first successful online anonymous marketplace, in which buyers and sellers could transact with anonymity properties far superior to those available in alternative online or offline means of commerce. Business on Silk Road, primarily involving narcotics trafficking, rapidly boomed, and competitors emerged. At the same time, law enforcement did not sit idle, and eventually managed to shut down Silk Road in October 2013 and arrest its operator. Far from causing the demise of this novel form of commerce, the Silk Road take-down spawned an entire, dynamic, online anonymous marketplace ecosystem, which has continued to evolve to this day. This paper presents a long-term measurement analysis of a large portion of this online anonymous marketplace ecosystem, including 16 different marketplaces, over more than two years (2013– 2015). By using long-term measurements, and combining our own data collection with publicly available previous efforts, we offer a detailed understanding of the growth of the online anonymous marketplace ecosystem. We are able to document the evolution of the types of goods being sold, and assess the effect (or lack thereof) of adversarial events, such as law enforcement operations or large-scale frauds, on the overall size of the economy. We also provide insights into how vendors are diversifying and replicating across marketplaces, and how vendor security practices (e.g., PGP adoption) are evolving. These different aspects help us understand how traditional, physical-world criminal activities are developing an online presence, in the same manner traditional commerce diversified online in the 1990s.\n\nSoftware bugs are a well-known source of security vulnerabilities. One technique for finding bugs, symbolic execution, considers all possible inputs to a program but suffers from scalability limitations. This paper uses a variant, under-constrained symbolic execution, that improves scalability by directly checking individual functions, rather than whole programs. We present UC-KLEE, a novel, scalable framework for checking C/C++ systems code, along with two use cases. First, we use UC-KLEE to check whether patches introduce crashes. We check over 800 patches from BIND and OpenSSL and find 12 bugs, including two OpenSSL denial-of-service vulnerabilities. We also verify (with caveats) that 115 patches do not introduce crashes. Second, we use UC-KLEE as a generalized checking framework and implement checkers to find memory leaks, uninitialized data, and unsafe user input. We evaluate the checkers on over 20,000 functions from BIND, OpenSSL, and the Linux kernel, find 67 bugs, and verify that hundreds of functions are leak free and that thousands of functions do not access uninitialized data.\n\nTaint analysis has a wide variety of compelling applications in security tasks, from software attack detection to data lifetime analysis. Static taint analysis propagates taint values following all possible paths with no need for concrete execution, but is generally less accurate than dynamic analysis. Unfortunately, the high performance penalty incurred by dynamic taint analyses makes its deployment impractical in production systems. To ameliorate this performance bottleneck, recent research efforts aim to decouple data flow tracking logic from program execution. We continue this line of research in this paper and propose pipelined symbolic taint analysis, a novel technique for parallelizing and pipelining taint analysis to take advantage of ubiquitous multi-core platforms. We have developed a prototype system called TaintPipe. TaintPipe performs very lightweight runtime logging to produce compact control flow profiles, and spawns multiple threads as different stages of a pipeline to carry out symbolic taint analysis in parallel. Our experiments show that TaintPipe imposes low overhead on application runtime performance and accelerates taint analysis significantly. Compared to a state-of-the-art inlined dynamic data flow tracking tool, TaintPipe achieves 2:38 times speedup for taint analysis on SPEC 2006 and 2:43 times for a set of common utilities, respectively. In addition, we demonstrate the strength of TaintPipe such as natural support of multi-tag taint analysis with several security applications.\n\nMany applications such as the Chrome and Firefox browsers are largely implemented in C++ for its performance and modularity. Type casting, which converts one type of an object to another, plays an essential role in enabling polymorphism in C++ because it allows a program to utilize certain general or specific implementations in the class hierarchies. However, if not correctly used, it may return unsafe and incorrectly casted values, leading to so-called bad-casting or type-confusion vulnerabilities. Since a bad-casted pointer violates a programmer’s intended pointer semantics and enables an attacker to corrupt memory, bad-casting has critical security implications similar to those of other memory corruption vulnerabilities. Despite the increasing number of bad-casting vulnerabilities, the bad-casting detection problem has not been addressed by the security community.\n\nIn this paper, we present CAVER, a runtime bad-casting detection tool. It performs program instrumentation at compile time and uses a new runtime type tracing mechanism—the type hierarchy table—to overcome the limitation of existing approaches and efficiently verify type casting dynamically. In particular, CAVER can be easily and automatically adopted to target applications, achieves broader detection coverage, and incurs reasonable runtime overhead. We have applied CAVER to largescale software including Chrome and Firefox browsers, and discovered 11 previously unknown security vulnerabilities: nine in GNU libstdc++ and two in Firefox, all of which have been confirmed and subsequently fixed by vendors. Our evaluation showed that CAVER imposes up to 7.6% and 64.6% overhead for performance-intensive benchmarks on the Chromium and Firefox browsers, respectively.\n\nIn 2014 DARPA launched the Cyber Grand Challenge: a competition that seeks to create automatic defensive systems capable of reasoning about flaws, formulating patches and deploying them on a network in real time. By acting at machine speed and scale, these technologies may someday overturn today’s attacker-dominated status quo. Just as the first autonomous ground vehicles fielded during DARPA’s 2004 Grand Challenge were not initially ready to take to the highways, the first generation of automated network defense systems will not be able to meaningfully compete against expert analysts or defend production networks. The Cyber Grand Challenge aims to give these groundbreaking prototypes a league of their own, allowing them to compete head-to-head to defend a network of bespoke software.\n\nIn this talk, I will describe the experimental setup, measurement, and results of the qualifying year of the DARPA Cyber Grand Challenge. I will cover in depth the DECREE platform, which was developed specifically for the first automated CTF competition, focusing on the experiments it enables, its relevance towards funded research in the computer security domain, and its accessibility to program analysis. On June 3rd, 2015, a 24-hour qualifying event will measure CGC systems in competition and help to select up to seven finalists. I will provide a statistical analysis of the results of the CGC qualifying round, including the visualization of successful automated defensive techniques, successes, failures, rates of efficacy, and other findings backed by post-event reverse engineering. Finally, I will close the talk with some initial thoughts regarding experimentation in the domain of adversarial automation.\n\nMike Walker joined DARPA as a program manager in January 2013. His research interests include machine reasoning about software in situ and the automation of application security lifecycles. Prior to joining DARPA, Mr. Walker worked in industry as a security software developer, Red Team analyst, enterprise security architect and research lab leader. As part of the Computer Science Corporation \"Strikeforce” Red Team, Mr. Walker helped develop the HEAT Vulnerability Scanner and performed Red Team engagements. Serving as a principal at the Intrepidus Group, Mr. Walker worked on Red Teams that tested America's financial and energy infrastructure for security weaknesses. Also, on the DARPA SAFER Red Team, Mr. Walker discovered flaws in prototype communications technologies. Mr. Walker has participated in various roles in numerous applied computer security competitions. He contributed challenges to DEF CON Capture the Flag (CTF) and competed on and helped lead CTF teams at the highest levels of international competition. Mr. Walker was formerly a mentor of the Computer Security Competition Club at Thomas Jefferson High School for Science and Technology (TJHSST).\n\nWe present new biases in RC4, break the Wi-Fi Protected Access Temporal Key Integrity Protocol (WPA-TKIP), and design a practical plaintext recovery attack against the Transport Layer Security (TLS) protocol. To empirically find new biases in the RC4 keystream we use statistical hypothesis tests. This reveals many new biases in the initial keystream bytes, as well as several new longterm biases. Our fixed-plaintext recovery algorithms are capable of using multiple types of biases, and return a list of plaintext candidates in decreasing likelihood. To break WPA-TKIP we introduce a method to generate a large number of identical packets. This packet is decrypted by generating its plaintext candidate list, and using redundant packet structure to prune bad candidates. From the decrypted packet we derive the TKIP MIC key, which can be used to inject and decrypt packets. In practice the attack can be executed within an hour. We also attack TLS as used by HTTPS, where we show how to decrypt a secure cookie with a success rate of 94% using 9•227 ciphertexts. This is done by injecting known data around the cookie, abusing this using Mantin’s ABSAB bias, and brute-forcing the cookie by traversing the plaintext candidates. Using our traffic generation technique, we are able to execute the attack in merely 75 hours.\n\nDespite recent high-profile attacks on the RC4 algorithm in TLS, its usage is still running at about 30% of all TLS traffic. We provide new attacks against RC4 in TLS that are focussed on recovering user passwords, still the pre-eminent means of user authentication on the Internet today. Our new attacks use a generally applicable Bayesian inference approach to transform a priori information about passwords in combination with gathered ciphertexts into a posteriori likelihoods for passwords. We report on extensive simulations of the attacks. We also report on a “proof of concept” implementation of the attacks for a specific application layer protocol, namely BasicAuth. Our work validates the truism that attacks only get better with time: we obtain good success rates in recovering user passwords with 226 encryptions, whereas the previous generation of attacks required around 234 encryptions to recover an HTTP session cookie.\n\nControl-Flow Integrity (CFI) is a defense which prevents control-flow hijacking attacks. While recent research has shown that coarse-grained CFI does not stop attacks, fine-grained CFI is believed to be secure.\n\nWe argue that assessing the effectiveness of practical CFI implementations is non-trivial and that common evaluation metrics fail to do so. We then evaluate fullyprecise static CFI — the most restrictive CFI policy that does not break functionality — and reveal limitations in its security. Using a generalization of non-control-data attacks which we call Control-Flow Bending (CFB), we show how an attacker can leverage a memory corruption vulnerability to achieve Turing-complete computation on memory using just calls to the standard library. We use this attack technique to evaluate fully-precise static CFI on six real binaries and show that in five out of six cases, powerful attacks are still possible. Our results suggest that CFI may not be a reliable defense against memory corruption vulnerabilities.\n\nWe further evaluate shadow stacks in combination with CFI and find that their presence for security is necessary: deploying shadow stacks removes arbitrary code execution capabilities of attackers in three of six cases.\n\nAs defense solutions against control-flow hijacking attacks gain wide deployment, control-oriented exploits from memory errors become difficult. As an alternative, attacks targeting non-control data do not require diverting the application’s control flow during an attack. Although it is known that such data-oriented attacks can mount significant damage, no systematic methods to automatically construct them from memory errors have been developed. In this work, we develop a new technique called data-flow stitching, which systematically finds ways to join data flows in the program to generate data-oriented exploits. We build a prototype embodying our technique in a tool called FLOWSTITCH that works directly on Windows and Linux binaries. In our experiments, we find that FLOWSTITCH automatically constructs 16 previously unknown and three known data-oriented attacks from eight real-world vulnerable programs. All the automatically-crafted exploits respect fine-grained CFI and DEP constraints, and 10 out of the 19 exploits work with standard ASLR defenses enabled. The constructed exploits can cause significant damage, such as disclosure of sensitive information (e.g., passwords and encryption keys) and escalation of privilege.\n\nSecurity operations people worldwide continue to be overwhelmed by global malicious actors who enjoy an asymmetric advantage. In order to level the playing field, innovators continually create new capabilities that enable them to secure their information infrastructures more scalably and efficiently. Often times, these innovations can solve the same or similar problems in many other enterprises—representing an attractive business opportunity by addressing a large unmet need.\n\nHowever, inserting these innovations into existing market ecosystems is significantly more challenging than simply packaging together a few lines of code and selling them. Rather, these technical innovators must often transform themselves into business leaders that embody marketing, finance and product management skill sets for which they may have had little or no formal training.\n\nThis talk will describe that transformation as technology-focused entrepreneurs with disruptive concepts can build companies that can attract the talent, capital, and customers required for their innovations to reach their intended markets.\n\nRick Gordon is an expert on security technology investing, business strategy and early-stage venture development. Rick currently serves as Managing Partner of Mach37™, the premier accelerator for cybersecurity entrepreneurs and startups. MACH37 launches companies that are delivering the next generation of cybersecurity solutions.\n\nPrior to this role, Rick served as Vice President of Product Management at KEYW Corporation, COO of Lookingglass Cyber Solutions, Managing Director at The Civitas Group, CEO of Tovaris, and was a founding board member of Invincea.\n\nWe describe a largely automated and systematic analysis of TLS implementations by what we call ‘protocol state fuzzing’: we use state machine learning to infer state machines from protocol implementations, using only blackbox testing, and then inspect the inferred state machines to look for spurious behaviour which might be an indication of flaws in the program logic. For detecting the presence of spurious behaviour the approach is almost fully automatic: we automatically obtain state machines and any spurious behaviour is then trivial to see. Detecting whether the spurious behaviour introduces exploitable security weaknesses does require manual investigation. Still, we take the point of view that any spurious functionality in a security protocol implementation is dangerous and should be removed.\n\nWe analysed both server- and client-side implementations with a test harness that supports several key exchange algorithms and the option of client certificate authentication. We show that this approach can catch an interesting class of implementation flaws that is apparently common in security protocol implementations: in three of the TLS implementations analysed new security flaws were found (in GnuTLS, the Java Secure Socket Extension, and OpenSSL). This shows that protocol state fuzzing is a useful technique to systematically analyse security protocol implementations. As our analysis of different TLS implementations resulted in different and unique state machines for each one, the technique can also be used for fingerprinting TLS implementations.\n\nTransport Layer Security (TLS) implementations have a history of security flaws. The immediate causes of these are often programming errors, e.g. in memory management, but the root causes are more fundamental: the challenges of interpreting the ambiguous prose specification, the complexities inherent in large APIs and code bases, inherently unsafe programming choices, and the impossibility of directly testing conformance between implementations and the specification.\n\nWe present nqsb-TLS, the result of our re-engineered approach to security protocol specification and implementation that addresses these root causes. The same code serves two roles: it is both a specification of TLS, executable as a test oracle to check conformance of traces from arbitrary implementations, and a usable implementation of TLS; a modular and declarative programming style provides clean separation between its components. Many security flaws are thus excluded by construction.\n\nnqsb-TLS can be used in standalone Unix applications, which we demonstrate with a messaging client, and can also be compiled into Xen unikernels (specialised virtual machine image) with a trusted computing base (TCB) that is 4% of a standalone system running a standard Linux/OpenSSL stack, with all network traffic being handled in a memory-safe language; this supports applications including HTTPS, IMAP, Git, and Websocket clients and servers. Despite the dual-role design, the high-level implementation style, and the functional programming language we still achieve reasonable performance, with the same handshake performance as OpenSSL and 73% – 84% for bulk throughput.\n\nFor increased security during TLS certificate validation, a common recommendation is to use a variation of pinning. Especially non-browser software developers are encouraged to limit the number of trusted certificates to a minimum, since the default CA-based approach is known to be vulnerable to serious security threats.\n\nThe decision for or against pinning is always a tradeoff between increasing security and keeping maintenance efforts at an acceptable level. In this paper, we present an extensive study on the applicability of pinning for non-browser software by analyzing 639,283 Android apps. Conservatively, we propose pinning as an appropriate strategy for 11,547 (1.8%) apps or for 45,247 TLS connections (4.25%) in our sample set. With a more optimistic classification of borderline cases, we propose pinning for consideration for 58,817 (9.1%) apps or for 140,020 (3.8%1) TLS connections. This weakens the assumption that pinning is a widely usable strategy for TLS security in non-browser software. However, in a nominalactual comparison, we find that only 45 apps actually implement pinning. We collected developer feedback from 45 respondents and learned that only a quarter of them grasp the concept of pinning, but still find pinning too complex to use. Based on their feedback, we built an easy-to-use web-application that supports developers in the decision process and guides them through the correct deployment of a pinning-protected TLS implementation.\n\nSource code authorship attribution is a significant privacy threat to anonymous code contributors. However, it may also enable attribution of successful attacks from code left behind on an infected system, or aid in resolving copyright, copyleft, and plagiarism issues in the programming fields. In this work, we investigate machine learning methods to de-anonymize source code authors of C/C++ using coding style. Our Code Stylometry Feature Set is a novel representation of coding style found in source code that reflects coding style from properties derived from abstract syntax trees.\n\nOur random forest and abstract syntax tree-based approach attributes more authors (1,600 and 250) with significantly higher accuracy (94% and 98%) on a larger data set (Google Code Jam) than has been previously achieved. Furthermore, these novel features are robust, difficult to obfuscate, and can be used in other programming languages, such as Python. We also find that (i) the code resulting from difficult programming tasks is easier to attribute than easier tasks and (ii) skilled programmers (who can complete the more difficult tasks) are easier to attribute than less skilled programmers.\n\nThe Tor network is a widely used system for anonymous communication. However, Tor is known to be vulnerable to attackers who can observe traffic at both ends of the communication path. In this paper, we show that prior attacks are just the tip of the iceberg. We present a suite of new attacks, called Raptor, that can be launched by Autonomous Systems (ASes) to compromise user anonymity. First, AS-level adversaries can exploit the asymmetric nature of Internet routing to increase the chance of observing at least one direction of user traffic at both ends of the communication. Second, AS-level adversaries can exploit natural churn in Internet routing to lie on the BGP paths for more users over time. Third, strategic adversaries can manipulate Internet routing via BGP hijacks (to discover the users using specific Tor guard nodes) and interceptions (to perform traffic analysis). We demonstrate the feasibility of Raptor attacks by analyzing historical BGP data and Traceroute data as well as performing real-world attacks on the live Tor network, while ensuring that we do not harm real users. In addition, we outline the design of two monitoring frameworks to counter these attacks: BGP monitoring to detect control-plane attacks, and Traceroute monitoring to detect data-plane anomalies. Overall, our work motivates the design of anonymity systems that are aware of the dynamics of Internet routing.\n\nThis paper sheds light on crucial weaknesses in the design of hidden services that allow us to break the anonymity of hidden service clients and operators passively. In particular, we show that the circuits, paths established through the Tor network, used to communicate with hidden services exhibit a very different behavior compared to a general circuit. We propose two attacks, under two slightly different threat models, that could identify a hidden service client or operator using these weaknesses. We found that we can identify the users’ involvement with hidden services with more than 98% true positive rate and less than 0.1% false positive rate with the first attack, and 99% true positive rate and 0.07% false positive rate with the second. We then revisit the threat model of previous website fingerprinting attacks, and show that previous results are directly applicable, with greater efficiency, in the realm of hidden services. Indeed, we show that we can correctly determine which of the 50 monitored pages the client is visiting with 88% true positive rate and false positive rate as low as 2.9%, and correctly deanonymize 50 monitored hidden service servers with true positive rate of 88% and false positive rate of 7.8% in an open world setting.\n\nIn this paper, we analyze and systematize the state-ofthe- art graph data privacy and utility techniques. Specifically, we propose and develop SecGraph (available at [1]), a uniform and open-source Secure Graph data sharing/publishing system. In SecGraph, we systematically study, implement, and evaluate 11 graph data anonymization algorithms, 19 data utility metrics, and 15 modern Structure-based De-Anonymization (SDA) attacks. To the best of our knowledge, SecGraph is the first such system that enables data owners to anonymize data by state-of-the-art anonymization techniques, measure the data’s utility, and evaluate the data’s vulnerability against modern De-Anonymization (DA) attacks. In addition, SecGraph enables researchers to conduct fair analysis and evaluation of existing and newly developed anonymization/DA techniques. Leveraging SecGraph, we conduct extensive experiments to systematically evaluate the existing graph data anonymization and DA techniques. The results demonstrate that (i) most anonymization schemes can partially or conditionally preserve most graph utilities while losing some application utility; (ii) no DA attack is optimum in all scenarios. The DA performance depends on several factors, e.g., similarity between anonymized and auxiliary data, graph density, and DA heuristics; and (iii) all the state-of-the-art anonymization schemes are vulnerable to several or all of the modern SDA attacks. The degree of vulnerability of each anonymization scheme depends on how much and which data utility it preserves.\n\nUser studies are critical to understanding how users perceive and interact with security and privacy software and features. However, conducting usable privacy and security studies is complicated. In some studies, researchers recruit participants to perform tasks not directly related to security so that they can observe how participants respond to security-related prompts or cues that occur while users are focused on primary tasks. Researchers also try to put users in situations where they believe their security or privacy is at risk, while at the same time making sure that participants will not actually suffer harm. When conducting usable security studies there are a lot of methodological details to get right, and studies don't always go quite as planned. In this talk I will offer a behind-the-scenes look at usable privacy and security study design and present lessons learned from over a decade of user studies at the CyLab Usable Privacy and Security Lab at Carnegie Mellon University.\n\nLorrie Faith Cranor is a Professor of Computer Science and of Engineering and Public Policy at Carnegie Mellon University where she is director of the CyLab Usable Privacy and Security Laboratory (CUPS) and co-director of the MSIT-Privacy Engineering masters program. She is also a co-founder of Wombat Security Technologies, Inc. Cranor has authored over 150 research papers on online privacy, usable security, and other topics. She has played a key role in building the usable privacy and security research community, having co-edited the seminal book Security and Usability (O'Reilly 2005) and founded the Symposium On Usable Privacy and Security (SOUPS). She also chaired the Platform for Privacy Preferences Project (P3P) Specification Working Group at the W3C and authored the book Web Privacy with P3P (O'Reilly 2002). She has served on a number of boards, including the Electronic Frontier Foundation Board of Directors, and on the editorial boards of several journals. In 2003 she was named one of the top 100 innovators 35 or younger by Technology Review magazine, and in 2014 she was named an ACM Fellow for her contributions to usable privacy and security research and education. She was previously a researcher at AT&T Labs Research and taught in the Stern School of Business at New York University. In 2012–13, Cranor spent her sabbatical year as a fellow in the Frank-Ratchye STUDIO for Creative Inquiry at Carnegie Mellon University, where she worked on fiber arts projects that combined her interests in privacy and security, quilting, computers, and technology. She practices yoga, plays soccer, and runs after her three children.\n\nThe Megamos Crypto transponder is used in one of the most widely deployed electronic vehicle immobilizers. It is used among others in most Audi, Fiat, Honda, Volkswagen and Volvo cars. Such an immobilizer is an anti-theft device which prevents the engine of the vehicle from starting when the corresponding transponder is not present. This transponder is a passive RFID tag which is embedded in the key of the vehicle.\n\nIn this paper we have reverse-engineered all proprietary security mechanisms of the transponder, including the cipher and the authentication protocol which we publish here in full detail. This article reveals several weaknesses in the design of the cipher, the authentication protocol and also in their implementation. We exploit these weaknesses in three practical attacks that recover the 96-bit transponder secret key. These three attacks only require wireless communication with the system. Our first attack exploits weaknesses in the cipher design and in the authentication protocol. We show that having access to only two eavesdropped authentication traces is enough to recover the 96-bit secret key with a computational complexity of 256 cipher ticks (equivalent to 249 encryptions). Our second attack exploits a weakness in the key update mechanism of the transponder. This attack recovers the secret key after 3×216 authentication attempts with the transponder and negligible computational complexity. We have executed this attack in practice on several vehicles. We were able to recover the key and start the engine with a transponder emulating device. Executing this attack from beginning to end takes only 30 minutes. Our third attack exploits the fact that some car manufacturers set weak cryptographic keys in their vehicles. We propose a time-memory trade-off which recovers such a weak key after a few minutes of computation on a standard laptop.\n\nIn a provenance-aware system, mechanisms gather and report metadata that describes the history of each object being processed on the system, allowing users to understand how data objects came to exist in their present state. However, while past work has demonstrated the usefulness of provenance, less attention has been given to securing provenance-aware systems. Provenance itself is a ripe attack vector, and its authenticity and integrity must be guaranteed before it can be put to use.\n\nWe present Linux Provenance Modules (LPM), the first general framework for the development of provenance-aware systems. We demonstrate that LPM creates a trusted provenance-aware execution environment, collecting complete whole-system provenance while imposing as little as 2.7% performance overhead on normal system operation. LPM introduces new mechanisms for secure provenance layering and authenticated communication between provenance-aware hosts, and also interoperates with existing mechanisms to provide strong security assurances. To demonstrate the potential uses of LPM, we design a Provenance-Based Data Loss Prevention (PB-DLP) system. We implement PBDLP as a file transfer application that blocks the transmission of files derived from sensitive ancestors while imposing just tens of milliseconds overhead. LPM is the first step towards widespread deployment of trustworthy provenance-aware applications.\n\nSingle root I/O virtualization (SRIOV) is a hardware/ software interface that allows devices to “self virtualize” and thereby remove the host from the critical I/O path. SRIOV thus brings near bare-metal performance to untrusted guest virtual machines (VMs) in public clouds, enterprise data centers, and high-performance computing setups. We identify a design flaw in current Ethernet SRIOV NIC deployments that enables untrusted VMs to completely control the throughput and latency of other, unrelated VMs. The attack exploits Ethernet ”pause” frames, which enable network flow control functionality. We experimentally launch the attack across several NIC models and find that it is effective and highly accurate, with substantial consequences if left unmitigated: (1) to be safe, NIC vendors will have to modify their NICs so as to filter pause frames originating from SRIOV instances; (2) in the meantime, administrators will have to either trust their VMs, or configure their switches to ignore pause frames, thus relinquishing flow control, which might severely degrade networking performance. We present the Virtualization-Aware Network Flow Controller (VANFC), a software-based SRIOV NIC prototype that overcomes the attack. VANFC filters pause frames from malicious virtual machines without any loss of performance, while keeping SRIOV and Ethernet flow control hardware/software interfaces intact.\n\nMandatory protection systems such as SELinux and SEAndroid harden operating system integrity. Unfortunately, policy development is error prone and requires lengthy refinement using audit logs from deployed systems. While prior work has studied SELinux policy in detail, SEAndroid is relatively new and has received little attention. SEAndroid policy engineering differs significantly from SELinux: Android fundamentally differs from traditional Linux; the same policy is used on millions of devices for which new audit logs are continually available; and audit logs contain a mix of benign and malicious accesses. In this paper, we propose EASEAndroid, the first SEAndroid analytic platform for automatic policy analysis and refinement. Our key insight is that the policy refinement process can be modeled and automated using semi-supervised learning. Given an existing policy and a small set of known access patterns, EASEAndroid continually expands the knowledge base as new audit logs become available, producing suggestions for policy refinement. We evaluate EASEAndroid on 1.3 million audit logs from real-world devices. EASEAndroid successfully learns 2,518 new access patterns and generates 331 new policy rules. During this process, EASEAndroid discovers eight categories of attack access patterns in real devices, two of which are new attacks directly against the SEAndroid MAC mechanism.\n\nRecently, a number of obfuscation systems have been developed to aid in censorship circumvention scenarios where encrypted network traffic is filtered. In this paper, we present Marionette, the first programmable network traffic obfuscation system capable of simultaneously controlling encrypted traffic features at a variety of levels, including ciphertext formats, stateful protocol semantics, and statistical properties. The behavior of the system is directed by a powerful type of probabilistic automata and specified in a user-friendly domain-specific language, which allows the user to easily adjust their obfuscation strategy to meet the unique needs of their network environment. In fact, the Marionette system is capable of emulating many existing obfuscation systems, and enables developers to explore a breadth of protocols and depth of traffic features that have, so far, been unattainable. We evaluate Marionette through a series of case studies inspired by censor capabilities demonstrated in the real-world and research literature, including passive network monitors, stateful proxies, and active probing. The results of our experiments not only show that Marionette provides outstanding flexibility and control over traffic features, but it is also capable of achieving throughput of up to 6:7Mbps when generating RFCcompliant cover traffic.\n\nThough journalists are often cited as potential users of computer security technologies, their practices and mental models have not been deeply studied by the academic computer security community. Such an understanding, however, is critical to developing technical solutions that can address the real needs of journalists and integrate into their existing practices. We seek to provide that insight in this paper, by investigating the general and computer security practices of 15 journalists in the U.S. and France via in-depth, semi-structured interviews. Among our findings is evidence that existing security tools fail not only due to usability issues but when they actively interfere with other aspects of the journalistic process; that communication methods are typically driven by sources rather than journalists; and that journalists’ organizations play an important role in influencing journalists’ behaviors. Based on these and other findings, we make recommendations to the computer security community for improvements to existing tools and future lines of research.\n\nWhile we’re all furiously working on new techniques to automate the finding of weaknesses and even vulnerabilities in software, relatively few programmers in the real world are benefiting from our work. The reasons for this situation are myriad, ranging from lack of training, awareness, and economic incentives on the part of the users; complex and only partially useful tools on the part of the assurance tool developers; legal barriers to open reporting of software problems; a confusing regulatory landscape with few standards; and a lack of effective curriculum at most universities for students learning software skills.\n\nAs a step towards improving the state of software assurance tools in the marketplace and increasing the adoption of software assurance practices by programmers, the U.S. Department of Homeland Security funded a 5-year project to establish the Software Assurance Marketplace (SWAMP). The core service of the SWAMP is an open (free) facility where programmers can bring their software to be run against a large suite of both commercial and open source assessment tools. In addition, tool developers can use the SWAMP-developed resources to speed their tool developments, making it easier to compete with established research projects and commercial products. The SWAMP also serves as a resource for classroom instructors and for researchers studying the software assurance process.\n\nI will discuss our experiences trying make an impact on the adoption of software assurance practices, the obstacles to making such an impact, and how the security research community (you!) can make this mission more effective.\n\nBarton Miller is Professor of Computer Sciences at the University of Wisconsin. He is also Chief Scientist for the DHS Software Assurance Marketplace (SWAMP) research facility and co-directs the MIST software vulnerability assessment project in collaboration with his colleagues at the Autonomous University of Barcelona. He also leads the Paradyn Parallel Performance Tool project, which is investigating performance and instrumentation technologies for parallel and distributed applications and systems. His research interests include systems security, binary and malicious code analysis and instrumentation extreme scale systems, parallel and distributed program measurement and debugging, and mobile computing. Miller's research is supported by the U.S. Department of Homeland Security, U.S. Department of Energy, National Science Foundation, NATO, and various corporations.\n\nIn 1988, Miller founded the field of Fuzz random software testing, which is the foundation of many security and software engineering disciplines. In 1992, Miller (working with his then-student, Prof. Jeffrey Hollingsworth), founded the field of dynamic binary code instrumentation and coined the term \"dynamic instrumentation.\" Dynamic instrumentation forms the basis for his current efforts in malware analysis and instrumentation.\n\nMiller was the chair of the IDA Center for Computing Sciences Program Review Committee, a member of the Los Alamos National Laboratory Computing, Communications and Networking Division Review Committee, and has been on the U.S. Secret Service Electronic Crimes Task Force (Chicago Area). Miller is a Fellow of the ACM.\n\nSide-channel attacks monitor some aspect of a computer system’s behavior to infer the values of secret data. Numerous side-channels have been exploited, including those that monitor caches, the branch predictor, and the memory address bus. This paper presents a method of defending against a broad class of side-channel attacks, which we refer to as digital side-channel attacks. The key idea is to obfuscate the program at the source code level to provide the illusion that many extraneous program paths are executed. This paper describes the technical issues involved in using this idea to provide confidentiality while minimizing execution overhead. We argue about the correctness and security of our compiler transformations and demonstrate that our transformations are safe in the context of a modern processor. Our empirical evaluation shows that our solution is 8.9x faster than prior work (GhostRider [20]) that specifically defends against memory trace-based side-channel attacks.\n\nNew big-data analysis platforms can enable distributed computation on encrypted data by utilizing trusted computing primitives available in commodity server hardware. We study techniques for ensuring privacy preserving computation in the popular MapReduce framework. In this paper, we first show that protecting only individual units of distributed computation (e.g. map and reduce units), as proposed in recent works, leaves several important channels of information leakage exposed to the adversary. Next, we analyze a variety of design choices in achieving a stronger notion of private execution that is the analogue of using a distributed oblivious-RAM (ORAM) across the platform. We develop a simple solution which avoids using the expensive ORAM construction, and incurs only an additive logarithmic factor of overhead to the latency. We implement our solution in a system called M2R, which enhances an existing Hadoop implementation, and evaluate it on seven standard MapReduce benchmarks. We show that it is easy to port most existing applications to M2R by changing fewer than 43 lines of code. M2R adds fewer than 500 lines of code to the TCB, which is less than 0:16% of the Hadoop codebase. M2R offers a factor of 1:3x to 44:6x lower overhead than extensions of previous solutions with equivalent privacy. M2R adds a total of 17% to 130% overhead over the insecure baseline solution that ignores the leakage channels M2R addresses.\n\nParameterized password guessability—how many guesses a particular cracking algorithm with particular training data would take to guess a password—has become a common metric of password security. Unlike statistical metrics, it aims to model real-world attackers and to provide per-password strength estimates. We investigate how cracking approaches often used by researchers compare to real-world cracking by professionals, as well as how the choice of approach biases research conclusions. We find that semi-automated cracking by professionals outperforms popular fully automated approaches, but can be approximated by combining multiple such approaches. These approaches are only effective, however, with careful configuration and tuning; in commonly used default configurations, they underestimate the real-world guessability of passwords.\n\nWe find that analyses of large password sets are often robust to the algorithm used for guessing as long as it is configured effectively. However, cracking algorithms differ systematically in their effectiveness guessing passwords with certain common features (e.g., character substitutions). This has important implications for analyzing the security of specific password characteristics or of individual passwords (e.g., in a password meter or security audit). Our results highlight the danger of relying only on a single cracking algorithm as a measure of password strength and constitute the first scientific evidence that automated guessing can often approximate guessing by professionals.\n\nTwo-factor authentication protects online accounts even if passwords are leaked. Most users, however, prefer password-only authentication. One reason why twofactor authentication is so unpopular is the extra steps that the user must complete in order to log in. Currently deployed two-factor authentication mechanisms require the user to interact with his phone to, for example, copy a verification code to the browser. Two-factor authentication schemes that eliminate user-phone interaction exist, but require additional software to be deployed.\n\nIn this paper we propose Sound-Proof, a usable and deployable two-factor authentication mechanism. Sound-Proof does not require interaction between the user and his phone. In Sound-Proof the second authentication factor is the proximity of the user’s phone to the device being used to log in. The proximity of the two devices is verified by comparing the ambient noise recorded by their microphones. Audio recording and comparison are transparent to the user, so that the user experience is similar to the one of password-only authentication. Sound-Proof can be easily deployed as it works with current phones and major browsers without plugins. We build a prototype for both Android and iOS. We provide empirical evidence that ambient noise is a robust discriminant to determine the proximity of two devices both indoors and outdoors, and even if the phone is in a pocket or purse. We conduct a user study designed to compare the perceived usability of Sound-Proof with Google 2-Step Verification. Participants ranked Sound- Proof as more usable and the majority would be willing to use Sound-Proof even for scenarios in which two-factor authentication is optional.\n\nWe instrumented the Android platform to collect data regarding how often and under what circumstances smartphone applications access protected resources regulated by permissions. We performed a 36-person field study to explore the notion of “contextual integrity,” i.e., how often applications access protected resources when users are not expecting it. Based on our collection of 27M data points and exit interviews with participants, we examine the situations in which users would like the ability to deny applications access to protected resources. At least 80% of our participants would have preferred to prevent at least one permission request, and overall, they stated a desire to block over a third of all requests. Our findings pave the way for future systems to automatically determine the situations in which users would want to be confronted with security decisions.\n\nMany security bugs, such as Cross-Site-Scripting (XSS), SQL injection, buffer overruns, etc, are in isolation relatively straightforward to understand and avoid. Nevertheless, it tends to be surprisingly hard to prevent their introduction in large-scale software development: Large pieces of software have many code sites where such a bug could be potentially introduced, and large systems make it difficult to identify bugs once they exist.\n\nThis talk describes our approach to preventing the introduction of certain classes of security bugs in large-scale software development projects at Google. We present design patterns to confine the potential for XSS vulnerabilities to a very small, manually auditable fraction of an application's code base. These patterns have been applied to several of Google's flagship services and their underlying web application frameworks, and have resulted in a drastic reduction of XSS bugs observed. We will discuss the applicability of bug-prevention approaches based on framework and API design to other vulnerabilities classes such as SQL injection, and close with observations on the practicality of their integration into real-world, large scale software development projects.\n\nChristoph Kern has been an Information Security Engineer at Google since 2003. Since 2012, he has been leading a team focused on the prevention and mitigation of security vulnerabilities in Google's applications and services through framework, API, and platform design. Christoph is a founding contributor to the IEEE Computer Society Center for Secure Design, and serves on the CSD's steering committee.\n\nCybercriminals misuse accounts on online services (e.g., webmails and online social networks) to perform malicious activity, such as spreading malicious content or stealing sensitive information. In this paper, we show that accounts that are accessed by botnets are a popular choice by cybercriminals. Since botnets are composed of a finite number of infected computers, we observe that cybercriminals tend to have their bots connect to multiple online accounts to perform malicious activity.\n\nWe present EVILCOHORT, a system that detects online accounts that are accessed by a common set of infected machines. EVILCOHORT only needs the mapping between an online account and an IP address to operate, and can therefore detect malicious accounts on any online service (webmail services, online social networks, storage services) regardless of the type of malicious activity that these accounts perform. Unlike previous work, our system can identify malicious accounts that are controlled by botnets but do not post any malicious content (e.g., spam) on the service. We evaluated EVILCOHORT on multiple online services of different types (a webmail service and four online social networks), and show that it accurately identifies malicious accounts.\n\nIn this work we expose wide-spread efforts by criminals to abuse the Chrome Web Store as a platform for distributing malicious extensions. A central component of our study is the design and implementation of WebEval, the first system that broadly identifies malicious extensions with a concrete, measurable detection rate of 96.5%. Over the last three years we detected 9,523 malicious extensions: nearly 10% of every extension submitted to the store. Despite a short window of operation—we removed 50% of malware within 25 minutes of creation— a handful of under 100 extensions escaped immediate detection and infected over 50 million Chrome users. Our results highlight that the extension abuse ecosystem is drastically different from malicious binaries: miscreants profit from web traffic and user tracking rather than email spam or banking theft.\n\nWebsite defacements and website vandalism can inflict significant harm on the website owner through the loss of sales, the loss in reputation, or because of legal ramifications.\n\nPrior work on website defacements detection focused on detecting unauthorized changes to the web server, e.g., via host-based intrusion detection systems or file-based integrity checks. However, most prior approaches lack the capabilities to detect the most prevailing defacement techniques used today: code and/or data injection attacks, and DNS hijacking. This is because these attacks do not actually modify the code or configuration of the website, but instead they introduce new content or redirect the user to a different website.\n\nIn this paper, we approach the problem of defacement detection from a different angle: we use computer vision techniques to recognize if a website was defaced, similarly to how a human analyst decides if a website was defaced when viewing it in a web browser. We introduce MEERKAT, a defacement detection system that requires no prior knowledge about the website’s content or its structure, but only its URL. Upon detection of a defacement, the system notifies the website operator that his website is defaced, who can then take appropriate action. To detect defacements, MEERKAT automatically learns high-level features from screenshots of defaced websites by combining recent advances in machine learning, like stacked autoencoders and deep neural networks, with techniques from computer vision. These features are then used to create models that allow for the detection of newly-defaced websites.\n\nWe show the practicality ofMEERKAT on the largest website defacement dataset to date, comprising of 10,053,772 defacements observed between January 1998 and May 2014, and 2,554,905 legitimate websites. Overall, MEERKAT achieves true positive rates between 97.422% and 98.816%, false positive rates between 0.547% and 1.528%, and Bayesian detection rates between 98.583% and 99.845%, thus significantly outperforming existing approaches.\n\nFor decades, formal methods have offered the promise of software that doesn’t have exploitable bugs. Until recently, however, it hasn’t been possible to verify software of sufficient complexity to be useful. Recently, that situation has changed. SeL4 is an open-source operating system microkernel efficient enough to be used in a wide range of practical applications. It has been proven to be fully functionally correct, ensuring the absence of buffer overflows, null pointer exceptions, use-after-free errors, etc., and to enforce integrity and confidentiality properties. The CompCert Verifying C Compiler maps source C programs to provably equivalent assembly language, ensuring the absence of exploitable bugs in the compiler. A number of factors have enabled this revolution in the formal methods community, including increased processor speed, better infrastructure like the Isabelle/HOL and Coq theorem provers, specialized logics for reasoning about low-level code, increasing levels of automation afforded by tactic languages and SAT/SMT solvers, and the decision to move away from trying to verify existing artifacts and instead focus on co-developing the code and the correctness proof. In this talk I will explore the promise and limitations of current formal methods techniques for producing useful software that provably does not contain exploitable bugs. I will discuss these issues in the context of DARPA’s HACMS program, which has as its goal the creation of high-assurance software for vehicles, including quad-copters, helicopters, and automobiles.\n\nKathleen Fisher is Professor in the Computer Science Department at Tufts University. Previously, she was a Principal Member of the Technical Staff at AT&T Labs Research, a Consulting Faculty Member in the Computer Science Department at Stanford University, and a program manager at DARPA where she started and managed the HACMS and PPAML programs. Kathleen's research focuses on advancing the theory and practice of programming languages and on applying ideas from the programming language community to the problem of ad hoc data management. The main thrust of her work has been in domain-specific languages to facilitate programming with massive amounts of ad hoc data. Kathleen is an ACM Fellow. She has served as program chair for FOOL, ICFP, CUFP, and OOPSLA. Kathleen is past Chair of the ACM Special Interest Group in Programming Languages (SIGPLAN), past Co-Chair of CRA's Committee on the Status of Women (CRA-W), a former editor of the Journal of Functional Programming, and an associated editor of TOPLAS.\n\nBinary analysis facilitates many important applications like malware detection and automatically fixing vulnerable software. In this paper, we propose to apply artificial neural networks to solve important yet difficult problems in binary analysis. Specifically, we tackle the problem of function identification, a crucial first step in many binary analysis techniques. Although neural networks have undergone a renaissance in the past few years, achieving breakthrough results in multiple application domains such as visual object recognition, language modeling, and speech recognition, no researchers have yet attempted to apply these techniques to problems in binary analysis. Using a dataset from prior work, we show that recurrent neural networks can identify functions in binaries with greater accuracy and efficiency than the state-of-the-art machine-learning-based method. We can train the model an order of magnitude faster and evaluate it on binaries hundreds of times faster. Furthermore, it halves the error rate on six out of eight benchmarks, and performs comparably on the remaining two.\n\nReverse engineering has many important applications in computer security, one of which is retrofitting software for safety and security hardening when source code is not available. By surveying available commercial and academic reverse engineering tools, we surprisingly found that no existing tool is able to disassemble executable binaries into assembly code that can be correctly assembled back in a fully automated manner, even for simple programs. Actually in many cases, the resulted disassembled code is far from a state that an assembler accepts, which is hard to fix even by manual effort. This has become a severe obstacle. People have tried to overcome it by patching or duplicating new code sections for retrofitting of executables, which is not only inefficient but also cumbersome and restrictive on what retrofitting techniques can be applied to.\n\nIn this paper, we present UROBOROS, a tool that can disassemble executables to the extent that the generated code can be assembled back to working binaries without manual effort. By empirically studying 244 binaries, we summarize a set of rules that can make the disassembled code relocatable, which is the key to reassembleable disassembling. With UROBOROS, the disassembly-reassembly process can be repeated thousands of times. We have implemented a prototype of UROBOROS and tested over the whole set of GNU Coreutils, SPEC2006, and a set of other real-world application and server programs. The experiment results show that our tool is effective with a very modest cost.\n\nThroughout the last few decades, computer software has experienced an arms race between exploitation techniques leveraging memory corruption and detection/protection mechanisms. Effective mitigation techniques, such as Address Space Layout Randomization, have significantly increased the difficulty of successfully exploiting a vulnerability. A modern exploit is often two-stage: a first information disclosure step to identify the memory layout, and a second step with the actual exploit. However, because of the wide range of conditions under which memory corruption occurs, retrieving memory layout information from the program is not always possible.\n\nIn this paper, we present a technique that uses the dynamic loader’s ability to identify the locations of critical functions directly and call them, without requiring an information leak. We identified several fundamental weak points in the design of ELF standard and dynamic loader implementations that can be exploited to resolve and execute arbitrary library functions. Through these, we are able to bypass specific security mitigation techniques, including partial and full RELRO, which are specifically designed to protect ELF data-structures from being coopted by attackers. We implemented a prototype tool, Leakless, and evaluated it against different dynamic loader implementations, previous attack techniques, and reallife case studies to determine the impact of our findings. Among other implications, Leakless provides attackers with reliable and non-invasive attacks, less likely to trigger intrusion detection systems.\n\nCybersecurity research within the National Security Agency/Central Security Service Research Directorate is a complex, mission-driven effort that must take into account multiple perspectives from information assurance, intelligence, and U.S. Cyber Command. The Research Directorate’s efforts into securing cyberspace must provide scientific advantages for NSA’s major missions, protect civil liberties, and implement transparency and privacy protections.\n\nThere are numerous facets to the Research Directorate’s cybersecurity research including developing a security for IoT devices, building a basic science of security, and cyber resilience. Other research that ties into the cybersecurity space includes low-power computing, neuromorphic computing, visual analytics, and high-speed stream processing.\n\nThis talk will provide a high-level overview of the National Security Agency/Central Security Service Research Directorate, including a short discussion of the process of the intelligence analysis mission, and highlight some of the directorate’s current research projects in cybersecurity and related fields. As part of her “dive” into cybersecurity, Dr. Frincke will also discuss current challenges in cybersecurity.\n\nDr. Deborah Frincke currently leads the Research Directorate of the National Security Agency/Central Security Service (NSA/CSS), the only “in-house” research organization in the U.S. Intelligence Community to create breakthroughs in mathematics, science, and engineering that support and enable the NSA/CSS. Under her guidance, the Research Directorate recruits personnel and maintains faculties that are world-class in fields as diverse as mathematics, computer science, cybersecurity/trustworthy computing, engineering, physics, neuroscience, cognitive psychology and linguistics. The Research Directorate engages with leading industries, universities, and national laboratories to both advance core competencies and to leverage work in overlapping disciplines. Dr. Frincke recently transitioned to the Research Directorate after leading global education and training for the NSA/CSS as Associate Director for Education and Training (ADET). While leading ADET, Dr. Frincke also served as Commandant of the National Cryptologic School and as the NSA/CSS Training Director.\n\nPrior to joining NSA/CSS, Dr. Frincke had a threefold career encompassing academia, the Department of Energy National Laboratory system, and private industry. A nationally-recognized expert and well-cited author, she has published over 100 articles and technical reports, and she continues to speak nationally on topics from leadership to cybersecurity. She also co-leads the Basic Training Board for IEEE Security and Privacy magazine. Past professional service includes leadership and participation on numerous scientific program committees and editorial boards, such as the Journal of Computer Security, and organizational boards, including the Networking and Information Technology Research and Development Program and National Intelligence Science and Technology Committee. She is a Senior Member of IEEE and an affiliate Full Professor with the Information School at the University of Washington.\n\nAn app market’s vetting process is expected to be scalable and effective. However, today’s vetting mechanisms are slow and less capable of catching new threats. In our research, we found that a more powerful solution can be found by exploiting the way Android malware is constructed and disseminated, which is typically through repackaging legitimate apps with similar malicious components. As a result, such attack payloads often stand out from those of the same repackaging origin and also show up in the apps not supposed to relate to each other.\n\nBased upon this observation, we developed a new technique, called MassVet, for vetting apps at a massive scale, without knowing what malware looks like and how it behaves. Unlike existing detection mechanisms, which often utilize heavyweight program analysis techniques, our approach simply compares a submitted app with all those already on a market, focusing on the difference between those sharing a similar UI structure (indicating a possible repackaging relation), and the commonality among those seemingly unrelated. Once public libraries and other legitimate code reuse are removed, such diff/common program components become highly suspicious. In our research, we built this “DiffCom” analysis on top of an efficient similarity comparison algorithm, which maps the salient features of an app’s UI structure or a method’s control-flow graph to a value for a fast comparison. We implemented MassVet over a stream processing engine and evaluated it nearly 1.2 million apps from 33 app markets around the world, the scale of Google Play. Our study shows that the technique can vet an app within 10 seconds at a low false detection rate. Also, it outperformed all 54 scanners in VirusTotal (NOD32, Symantec, McAfee, etc.) in terms of detection coverage, capturing over a hundred thousand malicious apps, including over 20 likely zero-day malware and those installed millions of times. A close look at these apps brings to light intriguing new observations: e.g., Google’s detection strategy and malware authors’ countermoves that cause the mysterious disappearance and reappearance of some Google Play apps.\n\nIME (input method editor) apps are the primary means of interaction on mobile touch screen devices and thus are usually granted with access to a wealth of private user input. In order to understand the (in)security of mobile IME apps, this paper first performs a systematic study and uncovers that many IME apps may (intentionally or unintentionally) leak users’ sensitive data to the outside world (mainly due to the incentives of improving the user’s experience). To thwart the threat of sensitive information leakage while retaining the benefits of an improved user experience, this paper then proposes I-BOX, an app-transparent oblivious sandbox that minimizes sensitive input leakage by confining untrusted IME apps to predefined security policies. Several key challenges have to be addressed due to the proprietary and closed-source nature of most IME apps and the fact that an IME app can arbitrarily store and transform user input before sending it out. By designing system-level transactional execution, I-BOX works seamlessly and transparently with IME apps. Specifically, I-BOX first checkpoints an IME app’s state before the first keystroke of an input, monitors and analyzes the user’s input, and rolls back the state to the checkpoint if it detects the potential danger that sensitive input may be leaked. A proof of concept I-BOX prototype has been built for Android and tested with a set of popular IME apps. Experimental results show that I-BOX is able to thwart the leakage of sensitive input for untrusted IME apps, while incurring very small runtime overhead and little impact on user experience.\n\nA cookie can contain a “secure” flag, indicating that it should be only sent over an HTTPS connection. Yet there is no corresponding flag to indicate how a cookie was set: attackers who act as a man-in-the-middle even temporarily on an HTTP session can inject cookies which will be attached to subsequent HTTPS connections. Similar attacks can also be launched by a web attacker from a related domain. Although an acknowledged threat, it has not yet been studied thoroughly. This paper aims to fill this gap with an in-depth empirical assessment of cookie injection attacks. We find that cookie-related vulnerabilities are present in important sites (such as Google and Bank of America), and can be made worse by the implementation weaknesses we discovered in major web browsers (such as Chrome, Firefox, and Safari). Our successful attacks have included privacy violation, online victimization, and even financial loss and account hijacking. We also discuss mitigation strategies such as HSTS, possible browser changes, and present a proof-of-concept browser extension to provide better cookie isolation between HTTP and HTTPS, and between related domains.\n\nModern Web sites frequently generate JavaScript on-the-fly via server-side scripting, incorporating personalized user data in the process. In general, cross-domain access to such sensitive resources is prevented by the Same- Origin Policy. The inclusion of remote scripts via the HTML script tag, however, is exempt from this policy. This exemption allows an adversary to import and execute dynamically generated scripts while a user visits an attacker-controlled Web site. By observing the execution behavior and the side effects the inclusion of the dynamic script causes, the attacker is able to leak private user data leading to severe consequences ranging from privacy violations up to full compromise of user accounts.\n\nAlthough this issues has been known for several years under the term Cross-Site Script Inclusion, it has not been analyzed in-depth on the Web. Therefore, to systematically investigate the issue, we conduct a study on its prevalence in a set of 150 top-ranked domains. We observe that a third of the surveyed sites utilize dynamic JavaScript. After evaluating the effectiveness of the deployed countermeasures, we show that more than 80% of the sites are susceptible to attacks via remote script inclusion. Given the results of our study, we provide a secure and functionally equivalent alternative to the use of dynamic scripts.\n\nModern web applications are increasingly moving program code to the client in the form of JavaScript. With the growing adoption of HTML5 APIs such as <code>postMessage</code>, client-side validation (CSV) vulnerabilities are consequently becoming increasingly important to address as well. However, while detecting and preventing attacks against web applications is a well-studied topic on the server, considerably less work has been performed for the client. Exacerbating this issue is the problem that defenses against CSVs must, in the general case, fundamentally exist in the browser, rendering current server-side defenses inadequate.\n\nIn this paper, we present ZigZag, a system for hardening JavaScript-based web applications against clientside validation attacks. ZigZag transparently instruments client-side code to perform dynamic invariant detection on security-sensitive code, generating models that describe how—and with whom—client-side components interact. ZigZag is capable of handling templated JavaScript, avoiding full re-instrumentation when JavaScript programs are structurally similar. Learned invariants are then enforced through a subsequent instrumentation step. Our evaluation demonstrates that ZigZag is capable of automatically hardening client-side code against both known and previously-unknown vulnerabilities. Finally, we show that ZigZag introduces acceptable overhead in many cases, and is compatible with popular websites drawn from the Alexa Top 20 without developer or user intervention.\n\nMobile users are becoming increasingly aware of the privacy threats resulting from apps’ access of their location. Few of the solutions proposed thus far to mitigate these threats have been deployed as they require either app or platform modifications. Mobile operating systems (OSes) also provide users with location access controls. In this paper, we analyze the efficacy of these controls in combating the location-privacy threats. For this analysis, we conducted the first location measurement campaign of its kind, analyzing more than 1000 free apps from Google Play and collecting detailed usage of location by more than 400 location-aware apps and 70 Advertisement and Analytics (A&A) libraries from more than 100 participants over a period ranging from 1 week to 1 year. Surprisingly, 70% of the apps and the A&A libraries pose considerable profiling threats even when they sporadically access the user’s location. Existing OS controls are found ineffective and inefficient in mitigating these threats, thus calling for a finer-grained location access control. To meet this need, we propose LP-Doctor, a light-weight user-level tool that allows Android users to effectively utilize the OS’s location access controls while maintaining the required app’s functionality as our user study (with 227 participants) shows.\n\nUsage behaviors of different smartphone apps capture different views of an individual’s life, and are largely independent of each other. However, in the current mobile app ecosystem, a curious party can covertly link and aggregate usage behaviors of the same user across different apps. We refer to this as unregulated aggregation of app usage behaviors. In this paper, we present a fresh perspective of unregulated aggregation, focusing on monitoring, characterizing and reducing the underlying linkability across apps. The cornerstone of our study is the Dynamic Linkability Graph (DLG) which tracks applevel linkability during runtime. We observed how DLG evolves on real-world users and identified real-world evidence of apps abusing IPCs and OS-level identifying information to establish linkability. Based on these observations, we propose a linkability-aware extension to current mobile operating systems, called LinkDroid,which provides runtime monitoring and mediation of linkability across different apps. LinkDroid is a client-side solution and compatible with the existing smartphone ecosystem. It helps end-users “sense” this emerging threat and provides them intuitive opt-out options.\n\nIn this paper, we investigate the current use of data compression in network services that are at the core of modern web-based applications. While compression reduces network traffic, if not properly implemented it may make an application vulnerable to DoS attacks. Despite the popularity of similar attacks in the past, such as zip bombs or XML bombs, current protocol specifications and design patterns indicate that developers are still mostly unaware of the proper way to handle compressed streams in protocols and web applications. In this paper, we show that denial of services due to improper handling of data compression is a persistent and widespread threat. In our experiments, we review three popular communication protocols and test 19 implementations against highly-compressed protocol messages. Based on the results of our analysis, we list 12 common pitfalls that we observed at the implementation, specification, and configuration levels. Additionally, we discuss a number of previously unknown resource exhaustion vulnerabilities that can be exploited to mount DoS attacks against popular network service implementations.\n\nThe high price of incoming international calls is a common method of subsidizing telephony infrastructure in the developing world. Accordingly, international telephone system interconnects are regulated to ensure call quality and accurate billing. High call tariffs create a strong incentive to evade such interconnects and deliver costly international calls illicitly. Specifically, adversaries use VoIP-GSM gateways informally known as “simboxes” to receive incoming calls over wired data connections and deliver them into a cellular voice network through a local call that appears to originate from a customer’s phone. This practice is not only extremely profitable for simboxers, but also dramatically degrades network experience for legitimate customers, violates telecommunications laws in many countries, and results in significant revenue loss. In this paper, we present a passive detection technique for combating simboxes at a cellular base station. Our system relies on the raw voice data received by the tower during a call to distinguish errors in GSM transmission from the distinct audio artifacts caused by delivering the call over a VoIP link. Our experiments demonstrate that this approach is highly effective, and can detect 87% of real simbox calls in only 30 seconds of audio with no false positives. Moreover, we demonstrate that evading our detection across multiple calls is only possible with a small probability. In so doing, we demonstrate that fraud that degrades network quality and costs telecommunications billions of dollars annually can easily be detected and counteracted in real time.\n\nAir-gapped networks are isolated, separated both logically and physically from public networks. Although the feasibility of invading such systems has been demonstrated in recent years, exfiltration of data from air-gapped networks is still a challenging task. In this paper we present GSMem, a malware that can exfiltrate data through an air-gap over cellular frequencies. Rogue software on an infected target computer modulates and transmits electromagnetic signals at cellular frequencies by invoking specific memory-related instructions and utilizing the multichannel memory architecture to amplify the transmission. Furthermore, we show that the transmitted signals can be received and demodulated by a rootkit placed in the baseband firmware of a nearby cellular phone. We present crucial design issues such as signal generation and reception, data modulation, and transmission detection. We implement a prototype of GSMem consisting of a transmitter and a receiver and evaluate its performance and limitations. Our current results demonstrate its efficacy and feasibility, achieving an effective transmission distance of 1-5.5 meters with a standard mobile phone. When using a dedicated, yet affordable hardware receiver, the effective distance reached over 30 meters.\n\nFor more information, watch the video GSMem Breaking The Air-Gap on YouTube.\n\nSide channels remain a challenge to information flow control and security in modern computing platforms. Resource partitioning techniques that minimise the number of shared resources among processes are often used to address this challenge. In this work, we focus on multicore platforms and we demonstrate that even seemingly strong isolation techniques based on dedicated cores can be circumvented through the use of thermal channels. Specifically, we show that the processor core temperature can be used both as a side channel as well as a covert communication channel even when the system implements strong spatial and temporal partitioning. Our experiments on an Intel Xeon server platform demonstrate covert thermal channels that achieve up to 12.5 bps and weak thermal side channels that can detect processes executed on neighbouring cores. This work therefore shows a limitation in the isolation that can be achieved on existing multi-core systems.\n\nSensing and actuation systems contain sensors to observe the environment and actuators to influence it. However, these sensors can be tricked by maliciously fabricated physical properties. In this paper, we investigated whether an adversary could incapacitate drones equipped with Micro-Electro-Mechanical Systems (MEMS) gyroscopes using intentional sound noise. While MEMS gyroscopes are known to have resonant frequencies that degrade their accuracy, it is not known whether this property can be exploited maliciously to disrupt the operation of drones.\n\nWe first tested 15 kinds of MEMS gyroscopes against sound noise and discovered the resonant frequencies of seven MEMS gyroscopes by scanning the frequencies under 30 kHz using a consumer-grade speaker. The standard deviation of the resonant output from those gyroscopes was dozens of times larger than that of the normal output. After analyzing a target drone’s flight control system, we performed real-world experiments and a software simulation to verify the effect of the crafted gyroscope output. Our real-world experiments showed that in all 20 trials, one of two target drones equipped with vulnerable gyroscopes lost control and crashed shortly after we started our attack. A few interesting applications and countermeasures are discussed at the conclusion of this paper.\n\nRecent work on cache attacks has shown that CPU caches represent a powerful source of information leakage. However, existing attacks require manual identification of vulnerabilities, i.e., data accesses or instruction execution depending on secret information. In this paper, we present Cache Template Attacks. This generic attack technique allows us to profile and exploit cache-based information leakage of any program automatically, without prior knowledge of specific software versions or even specific system information. Cache Template Attacks can be executed online on a remote system without any prior offline computations or measurements.\n\nCache Template Attacks consist of two phases. In the profiling phase, we determine dependencies between the processing of secret information, e.g., specific key inputs or private keys of cryptographic primitives, and specific cache accesses. In the exploitation phase, we derive the secret values based on observed cache accesses. We illustrate the power of the presented approach in several attacks, but also in a useful application for developers. Among the presented attacks is the application of Cache Template Attacks to infer keystrokes and—even more severe—the identification of specific keys on Linux and Windows user interfaces. More specifically, for lowercase only passwords, we can reduce the entropy per character from log2(26) = 4:7 to 1:4 bits on Linux systems. Furthermore, we perform an automated attack on the T-table- based AES implementation of OpenSSL that is as efficient as state-of-the-art manual cache attacks.\n\nPublic infrastructure-as-a-service clouds, such as Amazon EC2, Google Compute Engine (GCE) and Microsoft Azure allow clients to run virtual machines (VMs) on shared physical infrastructure. This practice of multi-tenancy brings economies of scale, but also introduces the risk of sharing a physical server with an arbitrary and potentially malicious VM. Past works have demonstrated how to place a VM alongside a target victim (co-location) in early-generation clouds and how to extract secret information via side-channels. Although there have been numerous works on side-channel attacks, there have been no studies on placement vulnerabilities in public clouds since the adoption of stronger isolation technologies such as Virtual Private Clouds (VPCs).\n\nWe investigate this problem of placement vulnerabilities and quantitatively evaluate three popular public clouds for their susceptibility to co-location attacks. We find that adoption of new technologies (e.g., VPC) makes many prior attacks, such as cloud cartography, ineffective. We find new ways to reliably test for co-location across Amazon EC2, Google GCE, and Microsoft Azure. We also found ways to detect co-location with victim web servers in multi-tiered located behind a load balancer.\n\nWe use our new co-residence tests and multiple customer accounts to launch VM instances under different strategies that seek to maximize the likelihood of co-residency. We find that it is much easier (10x higher success rate) and cheaper (up to $114 less) to achieve co-location in these three clouds when compared to a secure reference placement policy.\n\nKeywords: co-location detection, multi-tenancy, cloud security\n\nAs the most basic cloud service model, Infrastructure as a Service (IaaS) has been widely used for serving the evergrowing computing demand due to the prevalence of the cloud. Using pools of hypervisors within the cloud, IaaS can support a large number of Virtual Machines (VMs) and scale services in a highly dynamic manner. However, it is well-known that the VMs in IaaS are vulnerable to co-residence threat, which can be easily exploited to launch different malicious attacks. In this measurement study, we investigate how IaaS evolves in VM placement, network management, and Virtual Private Cloud (VPC), as well as the impact upon co-residence. Specifically, through intensive measurement probing, we first profile the dynamic environment of cloud instances inside the cloud. Then using real experiments, we quantify the impacts of VM placement and network management upon co-residence. Moreover, we explore VPC, which is a defensive network-based service of Amazon EC2 for security enhancement, from the routing perspective. On one hand, our measurement shows that VPC is widely used and can indeed suppress co-residence threat. On the other hand, we demonstrate a new approach to achieving co-residence in VPC, indicating that co-residence threat still exists in the cloud.\n\nMobile computing is the new norm. As people feel increasingly comfortable computing in public places such as coffee shops and transportation hubs, the threat of exposing sensitive information increases. While solutions exist to guard the communication channels used by mobile devices, the visual channel remains largely open. Shoulder surfing is becoming a viable threat in a world where users are often surrounded by high-power cameras, and sensitive information can be extracted from images using only modest computing power.\n\nIn response, we present Cashtags: a system to defend against attacks on mobile devices based on visual observations. The system allows users to safely access pieces of sensitive information in public by intercepting and replacing sensitive data elements with non-sensitive data elements before they are displayed on the screen. In addition, the system provides a means of computing with sensitive data in a non-observable way, while maintaining full functionality and legacy compatibility across applications.\n\nWhile smartphones and mobile apps have been an essential part of our lives, privacy is a serious concern. Previous mobile privacy related research efforts have largely focused on predefined known sources managed by smartphones. Sensitive user inputs through UI (User Interface), another information source that may contain a lot of sensitive information, have been mostly neglected.\n\nIn this paper, we examine the possibility of scalably detecting sensitive user inputs from mobile apps. In particular, we design and implement SUPOR, a novel static analysis tool that automatically examines the UIs to identify sensitive user inputs containing critical user data, such as user credentials, finance, and medical data. SUPOR enables existing privacy analysis approaches to be applied on sensitive user inputs as well. To demonstrate the usefulness of SUPOR, we build a system that detects privacy disclosures of sensitive user inputs by combining SUPOR with off-the-shelf static taint analysis We apply the system to 16,000 popular Android apps, and conduct a measurement study on the privacy disclosures. SUPOR achieves an average precision of 97.3% and an average recall of 97.3% for sensitive user input identification. SUPOR finds 355 apps with privacy disclosures and the false positive rate is 8.7%. We discover interesting cases related to national ID, username/password, credit card and health information.\n\nIdentifying sensitive user inputs is a prerequisite for privacy protection. When it comes to today’s program analysis systems, however, only those data that go through well-defined system APIs can be automatically labelled. In our research, we show that this conventional approach is far from adequate, as most sensitive inputs are actually entered by the user at an app’s runtime: in our research, we inspect 17, 425 top apps from Google Play, and find that 35.46% of them involve sensitive user inputs. Manually marking them involves a lot of effort, impeding a large-scale, automated analysis of apps for potential information leaks. To address this important issue, we present UIPicker, an adaptable framework for automatic identification of sensitive user inputs. UIPicker is designed to detect the semantic information within the application layout resources and program code, and further analyze it for the locations where security-critical information may show up. This approach can support a variety of existing security analysis on mobile apps. We further develop a runtime protection mechanism on top of the technique, which helps the user make informed decisions when her sensitive data is about to leave the device in an unexpected way. We evaluate our approach over 200 randomly selected popular apps on Google- Play. UIPicker is able to accurately label sensitive user inputs most of the time, with 93.6%precision and 90.1% recall.\n\nIn this study we characterize the extent to which cyber security incidents, such as those referenced by Verizon in its annual Data Breach Investigations Reports (DBIR), can be predicted based on externally observable properties of an organization’s network. We seek to proactively forecast an organization’s breaches and to do so without cooperation of the organization itself. To accomplish this goal, we collect 258 externally measurable features about an organization’s network from two main categories: mismanagement symptoms, such as misconfigured DNS or BGP within a network, and malicious activity time series, which include spam, phishing, and scanning activity sourced from these organizations. Using these features we train and test a Random Forest (RF) classifier against more than 1,000 incident reports taken from the VERIS community database, Hackmageddon, and theWeb Hacking Incidents Database that cover events from mid-2013 to the end of 2014. The resulting classifier is able to achieve a 90% True Positive (TP) rate, a 10% False Positive (FP) rate, and an overall 90% accuracy.\n\nMost modern malware download attacks occur via the browser, typically due to social engineering and driveby downloads. In this paper, we study the “origin” of malware download attacks experienced by real network users, with the objective of improving malware download defenses. Specifically, we study the web paths followed by users who eventually fall victim to different types of malware downloads. To this end, we propose a novel incident investigation system, named WebWitness. Our system targets two main goals: 1) automatically trace back and label the sequence of events (e.g., visited web pages) preceding malware downloads, to highlight how users reach attack pages on the web; and 2) leverage these automatically labeled in-the-wild malware download paths to better understand current attack trends, and to develop more effective defenses.\n\nWe deployed WebWitness on a large academic network for a period of ten months, where we collected and categorized thousands of live malicious download paths. An analysis of this labeled data allowed us to design a new defense against drive-by downloads that rely on injecting malicious content into (hacked) legitimate web pages. For example, we show that by leveraging the incident investigation information output byWebWitness we can decrease the infection rate for this type of drive-by downloads by almost six times, on average, compared to existing URL blacklisting approaches.\n\nIn recent years, the number of software vulnerabilities discovered has grown significantly. This creates a need for prioritizing the response to new disclosures by assessing which vulnerabilities are likely to be exploited and by quickly ruling out the vulnerabilities that are not actually exploited in the real world. We conduct a quantitative and qualitative exploration of the vulnerability-related information disseminated on Twitter. We then describe the design of a Twitter-based exploit detector, and we introduce a threat model specific to our problem. In addition to response prioritization, our detection techniques have applications in risk modeling for cyber-insurance and they highlight the value of information provided by the victims of attacks.\n\nMalware sandboxes are automated dynamic analysis systems that execute programs in a controlled environment. Within the large volumes of samples submitted every day to these services, some submissions appear to be different from others, and show interesting characteristics. For example, we observed that malware samples involved in famous targeted attacks – like the Regin APT framework or the recently disclosed malwares from the Equation Group – were submitted to our sandbox months or even years before they were detected in the wild. In other cases, the malware developers themselves interact with public sandboxes to test their creations or to develop a new evasion technique. We refer to similar cases as malware developments.\n\nIn this paper, we propose a novel methodology to automatically identify malware development cases from the samples submitted to a malware analysis sandbox. The results of our experiments show that, by combining dynamic and static analysis with features based on the file submission, it is possible to achieve a good accuracy in automatically identifying cases of malware development. Our goal is to raise awareness on this problem and on the importance of looking at these samples from an intelligence and threat prevention point of view."
    }
}