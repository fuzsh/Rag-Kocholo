{
    "id": "dbpedia_4792_2",
    "rank": 25,
    "data": {
        "url": "https://patents.google.com/patent/US5983350A/en",
        "read_more_link": "",
        "language": "en",
        "title": "US5983350A - Secure firewall supporting different levels of authentication based on address or encryption status - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/56/1b/8b/adc3b0a155d84e/US5983350-drawings-page-4.png",
            "https://patentimages.storage.googleapis.com/6a/5f/74/c05150774f24e0/US5983350-drawings-page-5.png",
            "https://patentimages.storage.googleapis.com/b7/52/1d/f7400eb3436291/US5983350-drawings-page-6.png",
            "https://patentimages.storage.googleapis.com/d5/f1/6a/290590125ad1e3/US5983350-drawings-page-7.png",
            "https://patentimages.storage.googleapis.com/20/ee/b1/e0f041c3c4c081/US5983350-drawings-page-8.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1996-09-18T00:00:00",
        "summary": "",
        "meta_description": "A system and method for regulating the flow of messages through a firewall having a network protocol stack, wherein the network protocol stack includes an Internet Protocol (IP) layer, the method comprising establishing a security policy, determining, at the IP layer, if a message is encrypted, if the message is not encrypted, passing the unencrypted message up the network protocol stack to an application level proxy, and if the message is encrypted, decrypting the message and passing the decrypted message up the network protocol stack to the application level proxy, wherein decrypting the message includes executing a process at the IP layer to decrypt the message.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US5983350A/en",
        "text": "BACKGROUND OF THE INVENTION\n\n1. Field of the Invention\n\nThe present invention pertains generally to network communications, and in particular to a system and method for securely transferring information between firewalls over an unprotected network.\n\n2. Background Information\n\nFirewalls have become an increasingly important part of network design. Firewalls provide protection of valuable resources on a private network while allowing communication and access with systems located on an unprotected network such as the Internet. In addition, they operate to block attacks on a private network arriving from the unprotected network by providing a single connection with limited services. A well designed firewall limits the security problems of an Internet connection to a single firewall computer system. This allows an organization to focus their network security efforts on the definition of the security policy enforced by the firewall. An example of a firewall is given in \"SYSTEM AND METHOD FOR PROVIDING SECURE INTERNETWORK SERVICES\", U.S. patent application Ser. No. 08/322078, filed Oct. 12, 1994 by Boebert et al., now issued U.S. Pat. No. 5,864,683, the description of which is hereby incorporated by reference. A second example of such a system is described in \"SYSTEM AND METHOD FOR ACHIEVING NETWORK SEPARATION\", U.S. application Ser. No. 08/599,232, filed Feb. 9, 1996 by Gooderum et al., the description of which is hereby incorporated by reference. Both are examples of application level gateways. Application level gateways use proxies operating at the application layer to process traffic through the firewall. As such, they can review not only the message traffic but also message content. In addition, they provide authentication and identification services, access control and auditing.\n\nData to be transferred on unprotected networks like the Internet is susceptible to electronic eavesdropping and accidental (or deliberate) corruption. Although a firewall can protect data within a private network from attacks launched from the unprotected network, even that data is vulnerable to both eavesdropping and corruption when transferred from the private network to an external machine. To address this danger, the Internet Engineering Task Force (IETF) developed a standard for protecting data transferred between firewalls over an unprotected network. The Internet Protocol Security (IPSEC) standard calls for encrypting data before it leaves the first firewall, and then decrypting the data when it is received by the second firewall. The decrypted data is then delivered to its destination, usually a user workstation connected to the second firewall. For this reason IPSEC encryption is sometimes called firewall-to-firewall encryption (FFE) and the connection between a workstation connected to the first firewall and a client or server connected to the second firewall is termed a virtual private network, or VPN.\n\nThe two main components of IPSEC security are data encryption and sender authentication. Data encryption increases the cost and time required for the eavesdropping party to read the transmitted data. Sender authentication ensures that the destination system can verify whether or not the encrypted data was actually sent from the workstation that it was supposed to be sent from. The IPSEC standard defines an encapsulated payload (ESP) as the mechanism used to transfer encrypted data. The standard defines an authentication header (AH) as the mechanism for establishing the sending workstation's identity.\n\nThrough the proper use of encryption, the problems of eavesdropping and corruption can be avoided; in effect, a protected connection is established from the internal network connected to one firewall through to an internal network connected to the second firewall. In addition, IPSEC can be used to provide a protected connection to an external computing system such as a portable personal computer.\n\nIPSEC encryption and decryption work within the IP layer of the network protocol stack. This means that all communication between two IP addresses will be protected because all interfirewall communication must go through the IP layer. Such an approach is preferable over encryption and decryption at higher levels in the network protocol stack since when encryption is performed at layers higher than the IP layer more work is required to ensure that all supported communication is properly protected. In addition, since IPSEC encryption is handled below the Transport layer, IPSEC can encrypt data sent by any application. IPSEC therefore becomes a transparent add-on to such protocols as TCP and UDP.\n\nSince, however, IPSEC decryption occurs at the IP layer, it can be difficult to port IPSEC to an application level gateway while still maintaining control at the proxy over authentication, message content, access control and auditing. Although the IPSEC specification in RFC 1825 suggests the use of a mandatory access control mechanism in a multi-level secure (MLS) network to compare a security level associated with the message with the security level of the receiving process, such an approach provides only limited utility in an application level gateway environment. In fact, implementations on application level gateways to date have simply relied on the fact that the message was IPSEC-encrypted as assurance that the message is legitimate and have simply decoded and forwarded the message to its destination. This creates, however, a potential chink in the firewall by assuming that the encrypted communication has access to all services.\n\nWhat is needed is a method of handling IPSEC messages within an application level gateway which overcomes the above deficiencies. The method should allow control over access by an IPSEC connection to individual services within the internal network..\n\nSUMMARY OF THE INVENTION\n\nThe present invention is a system and method for regulating the flow of messages through a firewall having a network protocol stack, wherein the network protocol stack includes an Internet Protocol (IP) layer, the method comprising the steps of determining, at the IP layer, if a message is encrypted, if the message is not encrypted, passing the unencrypted message up the network protocol stack to an application level proxy, and if the message is encrypted, decrypting the message and passing the decrypted message up the network protocol stack to the application level proxy, wherein the step of decrypting the message includes the step of executing a procedure at the IP layer to decrypt the message.\n\nAccording to another aspect of the present invention, a system and method is described for authenticating the sender of a message within a computer system having a network protocol stack, wherein the network protocol stack includes an Internet Protocol (UP) layer, the method comprising the steps of determining, at the IP layer, if the message is encrypted, if the message is encrypted, decrypting the message, wherein the step of decrypting the message includes the step of executing a procedure at the IP layer to decrypt the message, passing the decrypted message up the network protocol stack to an application level proxy, determining an authentication protocol appropriate for the message, and executing the authentication protocol to authenticate the sender of the message.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nIn the drawings, where like numerals refer to like components throughout the several views:\n\nFIG. 1 is a functional block diagram of an application level gateway-implemented firewall-to-firewall encryption scheme according to the present invention;\n\nFIG. 2 is a block diagram showing access control checking of both encrypted and unencrypted messages in network protocol stack according to the present invention;\n\nFIG. 3 is a block diagram of a representative application level gateway-implemented firewall-to-firewall encryption scheme;\n\nFIG. 4 is a block diagram of one embodiment of a network-separated protocol stack implementing IPSEC according to the present invention; and\n\nFIG. 5 is a functional block diagram of a firewall-to-workstation encryption scheme according to the present invention.\n\nDESCRIPTION OF THE PREFERRED EMBODIMENTS\n\nIn the following detailed description of the preferred embodiment, references made to the accompanying drawings which form a part hereof, and in which is shown by way of illustration specific preferred embodiments in which the invention may be practiced. These embodiments are described in sufficient detail to enable those skilled in the art to practice the invention, and it is to be understood that other embodiments may be utilized and that structural, logical, physical, architectural, and electrical changes may be made without departing from the spirit and scope of the present invention. The following detailed description is, therefore, not to be taken in a limiting sense, and the scope of the present invention is defined only by the appended claims and their equivalents.\n\nA system 10 which can be used for firewall-to-firewall encryption (FFE) is shown in FIG. 1. In FIG. 1, system 10 includes a workstation 12 communicating through a firewall 14 to an unprotected network 16 such as the Internet. System 10 also includes a workstation 20 communicating through a firewall 18 to unprotected network 16. In one embodiment, firewall 18 is an application level gateway.\n\nAs noted above, IPSEC encryption and decryption work within the IP layer of the network protocol stack. This means that all communications between two IP addresses will be protected because all interfirewall communication must pass through the IP layer. IPSEC takes the standard Internet packet and converts it into a carrier packet. The carrier packet is designed to do two things: to conceal the contents of the original packet (encryption) and to provide a mechanism by which the receiving firewall can verify the source of the packet (authentication). In one embodiment of the present invention, each IPSEC carrier packet includes both an authentication header used to authenticate the sending machine and an encapsulated payload containing encrypted data. The authentication header and the encapsulated payload features of IPSEC can, however, be used independently. As required in RFC 1825, DES-CBC is provided for use in encrypting the encapsulated payload while the authentication header uses keyed MD5.\n\nTo use IPSEC, you must create a security association (SA) for each destination IP address. In one embodiment, each SA contains the following information:\n\nSecurity Parameters Index (SPI)--The index used to find a SA on receipt of an IPSEC datagram.\n\nDestination IP address--The address used to find the SA and trigger use of IPSEC processing on output.\n\nThe peer SPI--The SPI value to put on a IPSEC datagram on output.\n\nThe peer IP address--The destination IP address to be put into the packet header if IPSEC Tunnel mode is used.\n\nThe Encryption Security Payload (ESP) algorithm to be used.\n\nThe ESP key to used for decryption of input datagrams.\n\nThe ESP key to used for encryption of output datagrams.\n\nThe authentication (AH) algorithm to be used.\n\nThe AH key to be used for validation of input packets.\n\nThe AH key to be used for generation of the authentication data for output datagrams.\n\nThe combination of a given Security Parameter Index and Destination IP address uniquely identifies a particular \"Security Association.\" In one embodiment, the sending firewall uses the sending userid and Destination Address to select an appropriate Security Association (and hence SPI value). The receiving firewall uses the combination of SPI value and Source address to obtain the appropriate Security Association.\n\nA security association is normally one-way. An authenticated communications session between two firewalls will normally have two Security Parameter Indexes in use (one in each direction). The combination of a particular Security Parameter Index and a particular Destination Address uniquely identifies the Security Association.\n\nMore information on the specifics of an IPSEC FFE implementation can be obtained from the standards developed by the IPSEC work group and documented in Security Architecture for IP (RFC 1825) and in RFC's 1826-1829.\n\nWhen a datagram is received from unprotected network 16 or is to be transmitted to a destination across unprotected network 16, the firewall must be able to determine the algorithms, keys, etc. that must be used to process the datagram correctly. In one embodiment, this information is obtained via a security association lookup. In one such embodiment, the lookup routine is passed several arguments: the source IP address if the datagram is being received from network 16 or the destination IP address if the datagram is to be transmitted across network 16, the SPI, and a flag that is used to indicate whether the lookup is being done to receive or transmit a datagram.\n\nWhen an IPSEC datagram is received by firewall 18 from unprotected network 16, the SPI and source IP address are determined by looking in the datagram. In one embodiment a Security Association Database (SADB) stored within firewall 18 is searched for the entry with a matching SPI. In one such embodiment, security associations can be set up based on network address as well as a more granular host address. This allows the network administrator to create a security association between two firewalls with only a couple of lines in a configuration file on each machine. For such embodiments, the entry in the Security Association Database that has both the matching SPI and the longest address match is selected as the SA entry. In another such embodiment, each SA has a prefix length value associated with the address. An address match on a SA entry means that the addresses match for the number of bits specified by the prefix length value.\n\nThere are two exceptions to this search process. First, when an SA entry is set marked as being dynamic it implies that the user of this SA may not have a fixed IP address. In this case the match is fully determined by the SPI value. Thus it is necessary that the SPI values for such SA entries be unique in the SADB. The second exception is for SA entries marked as tunnel mode entries. In this case it is normally the case that the sending entity will hide its source address so that all that is visible on the public wire is the destination address. In this case, like in the case where the SA entries are for dynamic IP addresses, the search is done exclusively on the basis of the SPI.\n\nWhen transmitting a datagram across unprotected network 16 the SADB is searched using only the destination address as an input. In this case the entry which has the longest address match is selected and returned to the calling routine.\n\nIn one embodiment, if firewall 18 receives datagrams which are identified as either an IP-- PROTO-- IPSEC-- ESP or IP-- PROTO-- IPSEC-- AH protocol datagram, there must be a corresponding SA in the SADB or else firewall 18 will drop the packet and an audit message will be generated. Such an occurrence might indicate a possible attack or it might simply be a symptom of an erroneous key entry in the Security Association Database.\n\nIn a system such as system 10, application level gateway firewall 18 acts as a buffer between unprotected network 16 and workstations such as workstation 20. Messages coming from unprotected network 16 are reviewed and a determination is made as to whether execution of an authentication and identification protocol is warranted. In contrast to previous systems, system 10 also performs this same determination on IPSEC-encrypted messages. If desired, the same authentication and identification can be made on messages to be transferred from workstation 20 to unprotected network 16. FIG. 2 illustrates one way of authenticating both encrypted and unencrypted messages in a system such as system 10.\n\nIn the system of FIG. 2 a network protocol stack 40 includes a physical layer 42, an Internet protocol (IP) layer 44, a Transport layer 46 and an application layer 48. Such a protocol stack exists, for instance on application level gateway firewall 18 of FIG. 1. An application executing in application layer 48 can communicate to an application executing on another system by preparing a message and transmitting it through one of the existing transport services executing on transport layer 46. Transport layer 46 in turn uses a process executing in IP layer 44 to continue the transfer. Physical layer 42 provides the software needed to transfer data through the communication hardware (e.g., a network interface card or a modem). As noted above, IPSEC executes within IP layer 44. Encryption and authentication is transparent to the host as long as the network administrator has the Security Association Database correctly configured and a key management mechanism is in place on the firewall.\n\nIn application level gateway firewall 18, a proxy 50 operating within application layer 48 processes messages transferred between internal and external networks. All network-to-network traffic must pass through one of the proxies within application layer 48 before being the transfer across networks is allowed. A message arriving from external network 16 is examined at IP layer 44 and an SADB is queried to determine if the source address and SPI are associated with an SA. In the embodiment shown in FIG. 2, an SADB Master copy 52 is maintained in persistent memory at application layer 48 while a copy 54 of SADB is maintained in volatile memory within the kernel. If the message is supposed to be encrypted, the message is decrypted based on the algorithm and key associated with the particular SA and the message is transferred up through transport layer 46 to proxy 50. Proxy 50 examines the source and destination addresses and the type of service desired and decides whether authentication of the sender is warranted. If so, proxy 50 initiates an authentication protocol. The protocol may be as simple as requesting a user name and password or it may include a challenge/response authentication process. Proxy 50 also looks to see whether the message coming in was encrypted or not and may factor that into whether a particular type of authentication is needed. In Telnet, for instance, user name/password authentication may be sufficient for an FFE link while the security policy may dictate that a more stringent challenge/response protocol is needed for unencrypted links. In that case, proxy 50 will be a Telnet proxy and it will base its authentication protocol on whether the link was encrypted or not.\n\nSince IPSEC executes within IP layer 44 there is no need for host firewalls to update their applications. Users that already have IPSEC available on their own host machine will, however, have to request that the firewall administrator set up SA's in the SADB for their traffic.\n\nIn the embodiment shown in FIG. 2, a working copy 54 of the Security Association Database consisting of all currently active SA's is kept resident in memory for ready access by IP layer processing as datagrams are received and transmitted. In addition, a working master copy 52 of the SADB is maintained in a file in nonvolatile memory. During system startup and initialization processing the content of all of the required SA's in master SADB 52 is added to the working copy 54 stored in kernel memory.\n\nIn one embodiment, firewall 18 maintains different levels of security on internal and external network interfaces. It is desirable for a firewall to have different levels of security on both the internal and external interfaces. In one embodiment, firewall 18 supports three different levels, numbered 0 through 2. These levels provide a simple policy mechanism that controls permission for both in-bound and out-bound packets.\n\nLevel 0--do not allow any in-bound or out-bound traffic unless there is a security association between the source and destination.\n\nLevel 1--Allow both in-bound and out-bound non-IPSEC traffic but force the use of IPSEC if a SA exists for the address. (To support this firewall 18 must look for a SA for each in-bound datagram.)\n\nLevel 2--allow NULL security associations to exist. NULL associations are just like normal security associations, except no encryption or authentication transform is performed on in-bound or out-bound packets that correspond to this NULL association. With Level 2 enabled, the machine will still receive unprotected traffic, but it will not transmit unless Level 1 is enabled.\n\nThe default protection level established when the Security Association Database (SADB) is initialized at boot time is 1 for in-bound traffic and 2 for out-bound traffic.\n\nIt is desirable for user-level daemons or proxies in firewall 18 to know whether or not a connection (or incoming UDP datagram in the case of a UDP proxy) is being encrypted or not. This information may be used, for example, to control access to services within internal network 19 or to determine the authentication method that will be used to authenticate the sender. One such method of controlling access to services within an internal network is described in GENERALIZED SECURITY POLICY MANAGEMENT SYSTEM AND METHOD, U.S. patent application Ser. No. 08/715,668, filed herewith, which description is hereby incorporated by reference. In addition, the above-mentioned patent disclosure teaches a method of selecting an authentication method based on whether a message was encrypted or not. That description also is hereby incorporated by reference. In the case of a Level 0 policy, it would be safe to assume that all incoming traffic is encrypted or authenticated. In the case of Levels 1 through 2, a determination must be made whether or not a security association exists for a given peer. Otherwise an application may believe that in-bound traffic has been authenticated when it really has not. (That is why it is necessary to look for an SA on input of each non-IPSEC datagram.)\n\nIn one embodiment, a flag which accompanies the message as it is sent from IP layer 44 to proxy 50 indicates whether the incoming message was or was not encrypted. In another embodiment, proxy 50 accesses Security Association Database 54 (the table in the kernel can be queried via an SADB routing socket (PF-SADB)) to determine whether or not a security association exists for a given peer. The SADB socket is much like a routing socket found in the stock BSD 4.4 kernel (protocol family PF-ROUTE) except that PF-SADB sockets are used to maintain the Security Association Database (SADB) instead of the routing table. Because the private keys used for encryption, decryption, and keyed authentication are stored in this table, access must be strictly prohibited and allowed to only administrators and key management daemons. Care must be taken when allowing user-level daemons access to /dev/mem or /dev/kmem as well, since the keys are stored in kernel memory and could be exposed with some creative hacking.\n\nIn one embodiment, a command-line tool called sadb is used to support the generation and maintenance of in-kernel version 54 of SADB. The primary interface between this tool and the SADB is the PF-SADB socket. The kernel provides socket processing to receive client requests to add, update, or change entries in in-kernel SADB 54. As noted above, the default protection level established when the Security Association Database (SADB) is initialized at boot time is 1 for in-bound traffic and 2 for out-bound traffic. This may be changed by the use of the sadb command.\n\nThe existing sadb command was derived from the NIST implementation of IPSEC. As noted above, this tool is much like route in that it uses a special socket to pass data structures in and out of the kernel. There are three commands recognized by the sadb command: get, set, delete. The following simple shell script supports adding and removing a single SA entry to SADB 54. It shows one embodiment of a parameter order for adding a SA to the SADB.\n\n______________________________________ # ! /bin/sh if [ $# -ne 1 ] then echo \"usage: $0 <on>|<off>\" >&2 exit 1 fi ONOFF=$1 addsa () IPADDRESS=$2 PEERADDRESS=0.0.0.0 PREFIXLEN=0 # Num of bits, 0 => full 32 bit match LOCALADDRESS=0.0.0.0 REALADDRESS=0.0.0.0 PORT=0 PROTOCOL=0 UID=0 DESALG=1 # I = DES-CBC IVLEN=4 # bytes DESKEY=0b0b0b0b0b0b0b0b DESKEYLEN=8 # bytes AHALG=1 # 1 = MD5 AHKEY=30313233343536373031323334353637 AHKEYLEN=16 # bytes LOCAL.sub.-- SPI=$1 PEER.sub.-- SPI=$1 TUNNEL.sub.-- MODE=0 AHRESULTLEN=4 COMBINED.sub.-- MODE=1 # On output, 1 = ESP, then AH; 0 = AH, then ESP DYNAMIC.sub.-- FLAG=0 if [ \"$ONOFF\" = \"on\" then ./sadb add dst $IPADDRESS $PREFIXLEN $LOCAL.sub.-- SPI $UID $PEERADDRESS $PEER.sub.-- SPI $TUNNEL.sub.-- MODE $LOCALADDRESS $REALADDRESS $PROTOCOL $PORT $DESALG $IVLEN $DESKEYLEN $DESKEY $DESKEYLEN $DESKEY $AHALG $AHKEYLEN $AHKEY $AHKEYLEN $AHKEY $AHRESULTLEN $COMBINED.sub.-- MODE $DYNAMIC.sub.-- FLAG else ./sadb delete dst $IPADDRESS $LOCAL-SPI fi } # Get down to work: addsa 500 172.17.128.115 # number6.sctc.com ______________________________________\n\nThe current status of in-kernel SADB 54 can be obtained with the sadb command. The get option allows dumping the entire SADB or a single entry. In one embodiment, the complete dump approach uses /dev/kmem to find the information. The information may be presented as follows:\n\n______________________________________ # sadb get dst Local-SPI Address-Family Destination-Addr Preflx.sub.-- length UID Peer-Address Peer-SPI Transport-Type Local-Address Real-Address Protocol Port ESP.sub.-- Alg.sub.-- ID ESP.sub.-- IVEC.sub.-- Length ESP.sub.-- Enc.sub.-- Key.sub.-- length ESP.sub.-- Enc.sub.-- ESP.sub.-- Key ESP.sub.-- Dec.sub.-- Key.sub.-- length ESP.sub.-- Dec.sub.-- ESP.sub.-- Key AH.sub.-- Alg.sub.-- ID AH.sub.-- Data.sub.-- Length AH.sub.-- Gen.sub.-- Key.sub.-- Length AH.sub.-- Gen.sub.-- Key AH.sub.-- Check.sub.-- Key.sub.-- Length AH.sub.-- Check.sub.-- Key Combined.sub.-- Mode Dynamic.sub.-- Flag 500 INET: number6.sctc.com 0 0 0.0.0.0 500 Transport(0) 0 0.0.0.0.0.0.0.0 None None DES/CBC-RFC1829 (1) 4 8 0b0b0b0b0b0b0b0b 8 0b0b0b0b0b0b0b0b MD5-RFC1828 (1) 4 16 30313233343536373031323334353637 16 30313233343536373031323334353637 ESP+AH(1) 0 501 INET: spokes.sctc.com 0 0 0.0.0.0 501 Transport(0) 0 0.0.0.0.0.0.0.0 None None DES/CBC-RFC1829(1) 4 8 0b0b0b0b0b0b0b0b 8 0b0b0b0b0b0b0b0b MD5-RFC1828(1)4 16 30313233343536373031323334353637 16 30313233343536373031323334353637 ESP+AH(1) 0 End of list. ______________________________________\n\nWhen a new entry is added to in-kernel SADB 54, the add process first checks to see that no existing entry will match the values provided in the new entry. If no match is found then the entry is added to the end of the existing SADB list.\n\nTo illustrate the use and administration of an FFE, we'll go through an example using FFE 70 in FIG. 3. Firewalls 14 and 18 are both application level gateway firewalls implemented according to the present invention. Workstations H2 and H3 both want to communicate with H1. For the administrator of firewalls 14 and 18, this is easy to accomplish. The administrator sets up a line something like this (we'll only show the IP address part and SPI parts of the SA, since they're the trickiest values to configure. Also, assume that we are using tunnel mode):\n\n______________________________________ # Hypothetical SW1 Config File # Fields are laid out in the following manner: # srcaddrornet= localSPI= peeraddr= peerSPl= realsrcaddr= localaddr= key= # The following entry sets up a tunnel between hosts behind SW1 # and hosts behind SW2. src=172.16.0.0 localSPI=666 peer=192.168.100.5 peerSPI=777 \\ realsrcaddr=192.168.100.5 localaddrs=0.0.0.0 key=0xdeadbeeffadebabe # Hypothetical SW2 config File # # Fields are laid out in the following manner: # srcaddrornet= localSPI= peeraddr= peerSPl= realsrcaddr= localaddr= key= # The following entry sets up a tunnel between hosts behind SW1 and # hosts behind SW2. src=172.17.0.0 localSPI=777 peer=192.168.20.1 peerSPI=666 \\ realsrcaddr=192.168.20.1 localaddr=0.0.0.0 \\ key=Oxdeadbeeffadebabe ______________________________________\n\nWith this setup, all traffic is encrypted using one key, no matter who is talking to whom. For example, traffic from H2 to HI as well as traffic from H3 to H1 will be encrypted with one key. Although this setup is small and simple, it may not be enough.\n\nWhat happens if H2 cannot trust H3? In this case, the administrator can set up security associations at the host level. In this case, we have to rely on the SPI field of the SA, since the receiving firewall cannot tell from the datagram header which host behind the sending firewall sent the packet. Since the SPI is stored in IPSEC datagrams, we can do a lookup to obtain its value. Below are the sample configuration files for both firewalls again, but this time, each host combination communicates with a different key. Moreover, H2 excludes H3 from communications with H1, and H3 excludes H2 in the same way.\n\n______________________________________ # Hypothetical SW1 Config File # Fields are laid out in the following manner: # srcaddrornet= localSPI= peeraddr= peerSPl= realsrcaddr= localaddr= key= # The following entry sets up a secure link between H2 and H1 src=172.16.0.2 localSPI=666 peer=192.168.100.5 peerSPI=777 \\ realsrcaddr=192.168.100.5 localaddrs=178.17.128.71 \\ key=0x0a0a0a0a0a0a0a0a # The following entry sets up a secure link between H3 and H1 src=172.16.0.1 localSPI=555 peer=l92.l68.l00.5 peerSPI=888 \\ realsrcaddr=192.168.100.5 localaddrs=178.17.128.71 \\ key=0x0b0b0b0b0b0b0b0b # Hypothetical SW2 Config File # # Fields are laid out in the following manner: # srcaddrornet= localSPI= peeraddr= peerSPI= realsrcaddr= localaddr= key= # The following entry sets up a secure link between H2 and H1 src=172.17.128.71 localSPI=777 peer=192.168.20.1 peerSPI=666 \\ realsrcaddr=192.168.20.1 localaddrs=172.16.0.2 \\ key=0x0a0a0a0a0a0a0a0a # The following entry sets up a secure link between H3 and H1 src=172.17.128.71 localSPI=888 peer=192.168.20.1 peerSPI=555 \\ realsrcaddr=192.168.20.1 localaddrs=172.16.0.1 \\ key=0x0b0b0b0b0b0b0b0b ______________________________________\n\nFIG. 4 is a block diagram showing in more detail one embodiment of an IPSEC-enabled application level gateway firewall 18. Application level gateway firewall 18 provides access control checking of both encrypted and unencrypted messages in a more secure environment due to its network-separated architecture. Network separation divides a system into a set of independent regions or burbs, with a domain and a protocol stack assigned to each burb. Each protocol stack 40x has its own independent set of data structures, including routing information and protocol information. A given socket will be bound to a single protocol stack at creation time and no data can pass between protocol stacks 40 without going through proxy space. A proxy 50 therefore acts as the go-between for transfers between domains. Because of this, a malicious attacker who gains control of one of the regions is prevented from being able to compromise processes executing in other regions. Network separation and its application to an application level gateway is described in \"SYSTEM AND METHOD FOR ACHIEVING NETWORK SEPARATION\", U.S. application Ser. No. 08/599,232, filed Feb. 9, 1996 by Gooderum et al., the description of which is hereby incorporated by reference.\n\nIn the system shown in FIG. 4, the in-bound and out-bound datagram processing of a security association continues to follow the conventions defined by the network separation model. Thus all datagrams received on or sent to a given burb remain in that burb once decrypted. In one such embodiment SADB socket 78 has been defined to have the type `sadb`. Each proxy 50 that requires access to SADB socket 78 to execute its query as to whether the received message was encrypted must have create permission to the sadb type.\n\nThe following is list of specific requirements that a system such as is shown in FIG. 4 must provide. Many of the requirements were discussed in the information provided earlier in this document.\n\n1. Firewall applications may query the IPSEC subsystem to determine if traffic with a given address is guaranteed to be encrypted.\n\n2. Receipt of an unencrypted datagram from an address that has a SA results in the datagram being dropped and an audit message being generated.\n\n3. On receipt of encrypted protocol datagrams the SADB searches will be done using the SPI as the primary key. The source address will a secondary key. The SA returned by the search will be the SA which matches the SPI exactly and has the longest match with the address.\n\n4. A search of the SADB for a SPI that finds an entry that is marked as SA for a dynamic IP will not consider the address in the search process.\n\n5. A search of the SADB for a SPI that finds an entry that is marked as a SA for a tunnel mode connection will to consider the address if it is (0.0.0.0) i.e INADDR.\n\n6. On receipt of a non-IPSEC datagram the SADB will be searched for an entry that matches the src address. If a SA is found the datagram will be dropped and an audit message sent.\n\n7. SADB searches on output will be done using the DST address as key. If more than one SA entry in the SADB has that address the first one with the maximum address match will be returned.\n\n8. The SADB must be structured so that searches are fast regardless if the search is done by SPI or by address.\n\n9. The SADB must provide support for connections to a site with a fixed SPI but changing IP address. SA entries for such connections will be referred to as Dynamic Address Sites, or just Dynamic entries.\n\n10. When a dynamic entry is found by a SPI search, the current datagram's SRC address, which is required to ensure that the return datagrams are properly encrypted, will be recorded in the SA only after the AH checking has passed successfully. (This is because if the address is recorded before AH passes then an attacker can cause return packets of an outgoing connection to be transmitted in the clear.)\n\n11. A failure of an AH check on a dynamic entry results in an audit message.\n\n12. In an embodiment where the firewall requires that all connections use both AH and ESP, on receipt the order should be AH first ESP second.\n\n13. The processing structure on both input and output should try to minimize the number of SADB required lookups.\n\nReturning to FIG. 4, in one embodiment firewall 18 includes a crypto engine interface 80 used to encrypt an IPSEC payload. Crypto engine interface 80 may be connected to a software encryption engine 82 or to a hardware encryption engine 84. Engines 82 and 84 perform the actual encryption function using, for example, DES-CBC. In addition, software encryption engine 82 may include the keyed MD5 algorithm used for AH.\n\nIn one embodiment, crypto engine interface 80 is a utility which provides a consistent interface between the software and hardware encryption engines. As shown in FIG. 4, in one such embodiment interface 80 only supports the use of the use of hardware cryptographic engine 84 for IPSEC ESP processing. The significant design issue that interface 80 must deal with is that use of a hardware encryption engine requires that the processing be down in disjoint steps operating in different interrupt contexts as engine 84 completes the various processing steps.\n\nThe required information is stored in a request structure that is bound to the IP datagram being processed. The request is of type crypto-- request-- t. This structure is quite large and definitely does not contain a minimum state set.\n\nIn addition to the definition of the request data structure, this software implementing interface 80 provides two functions which isolate the decision of which cryptographic engine to use. The crypt-- des-- encrypt function is for use by the IP output processing to encrypt a datagram. The crypt-- des-- decrypt function is for use by the IP input processing to decrypt a datagram. If hardware encryption engine 84 is present and other hardware usage criteria are met the request is enqueued on a hardware processing queue and a return code indicating that the cryptographic processing is in progress is returned. If software engine 82 is used, the return code indicates that the cryptographic processing is complete. In the former case, the continuation of the IP processing is delayed until after hardware encryption is done. Otherwise it is completed as immediately in the same processing stream.\n\nThere are two software cryptographic engines 82 provided in the IPSEC software. One provides the MD5 algorithm used by the IPSEC AH processing, and the other provides the DES algorithm used by the IPSEC ESP processing. This software can be obtained from the U.S. Government IPSEC implementation.\n\nIn one embodiment hardware cryptographic engine 84 is provided by a Cylink SafeNode processing board. The interface to this hardware card is provided by the Cylink device driver. A significant aspect of the Cylink card that plays a major part in the design of the IPSEC Cylink driver is that the card functions much like a low level subroutine interface and requires software support to initiate each processing step. Thus to encrypt or decrypt an individual datagram there are a minimum of two steps, one to set the DES initialization vector and one to do the encryption. Since the IP processing can not suspend itself and wait while the hardware completes and then be rescheduled by the hardware interrupt handler, in one embodiment a finite state machine is used to tie sequences of hardware processing elements together. In one such embodiment the interrupt handler looks at the current state, executes a defined after state function, transitions to the state and then executes that state's start function.\n\nOne function, cyl-- enqueue-- request, is used to initiate either an encrypt or a decrypt action. This function is designed to be called by cryptographic engine interface 80. All of the information required to initiate the processing as well as the function to be performed after the encryption operation is completed is provided in the request structure. This function will enqueue the request on the hardware request queue and start the hardware processing if necessary.\n\nA system 30 which can be used for firewall-to-workstation encryption is shown in FIG. 5. In FIG. 5, system 30 includes a workstation 12 communicating through a firewall 14 to an unprotected network 16 such as the Internet. System 30 also includes a workstation 32 communicating directly with firewall 14 through unprotected network 16. Firewall 14 is an application level gateway incorporating IPSEC handling as described above. (It should be noted that IPSEC security cannot be used to authenticate the personal identity of the sender for a firewall to firewall transfer. When IPSEC is used, however, on a single user machine such as a portable personal computer, IPSEC usage should be protected with a personal identification number (PIN). In these cases IPSEC can be used to help with user identification to the firewall.)\n\nAccording to the IPSEC RFC's, you can use either tunnel or transport mode with this embodiment based on your security needs. In certain situations, the communications must be sent in tunnel mode to hide unregistered addresses.\n\nAlthough specific embodiments have been illustrated and described herein, it will be appreciated by those of ordinary skill in the art that any arrangement which is calculated to achieve the same purpose may be substituted for the specific embodiment shown. This application is intended to cover any adaptations or variations of the present invention. Therefore, it is intended that this invention be limited only by the claims and the equivalents thereof."
    }
}