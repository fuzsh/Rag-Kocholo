{
    "id": "dbpedia_110_2",
    "rank": 46,
    "data": {
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
        "read_more_link": "",
        "language": "en",
        "title": "String - JavaScript",
        "top_image": "https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png",
        "meta_img": "https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-07-25T21:32:46+00:00",
        "summary": "",
        "meta_description": "The String object is used to represent and manipulate a\n  sequence of characters.",
        "meta_lang": "en",
        "meta_favicon": "/favicon-48x48.cbbd161b.png",
        "meta_site_name": "MDN Web Docs",
        "canonical_link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String",
        "text": "Use the less-than and greater-than operators to compare strings:\n\njs\n\nconst a = \"a\"; const b = \"b\"; if (a < b) { console.log(`${a} is less than ${b}`); } else if (a > b) { console.log(`${a} is greater than ${b}`); } else { console.log(`${a} and ${b} are equal.`); }\n\nNote that all comparison operators, including === and ==, compare strings case-sensitively. A common way to compare strings case-insensitively is to convert both to the same case (upper or lower) before comparing them.\n\njs\n\nfunction areEqualCaseInsensitive(str1, str2) { return str1.toUpperCase() === str2.toUpperCase(); }\n\nThe choice of whether to transform by toUpperCase() or toLowerCase() is mostly arbitrary, and neither one is fully robust when extending beyond the Latin alphabet. For example, the German lowercase letter Ã and ss are both transformed to SS by toUpperCase(), while the Turkish letter Ä± would be falsely reported as unequal to I by toLowerCase() unless specifically using toLocaleLowerCase(\"tr\").\n\njs\n\nconst areEqualInUpperCase = (str1, str2) => str1.toUpperCase() === str2.toUpperCase(); const areEqualInLowerCase = (str1, str2) => str1.toLowerCase() === str2.toLowerCase(); areEqualInUpperCase(\"Ã\", \"ss\"); areEqualInLowerCase(\"Ä±\", \"I\");\n\nA locale-aware and robust solution for testing case-insensitive equality is to use the Intl.Collator API or the string's localeCompare() method â they share the same interface â with the sensitivity option set to \"accent\" or \"base\".\n\njs\n\nconst areEqual = (str1, str2, locale = \"en-US\") => str1.localeCompare(str2, locale, { sensitivity: \"accent\" }) === 0; areEqual(\"Ã\", \"ss\", \"de\"); areEqual(\"Ä±\", \"I\", \"tr\");\n\nThe localeCompare() method enables string comparison in a similar fashion as strcmp() â it allows sorting strings in a locale-aware manner.\n\nStrings are represented fundamentally as sequences of UTF-16 code units. In UTF-16 encoding, every code unit is exact 16 bits long. This means there are a maximum of 216, or 65536 possible characters representable as single UTF-16 code units. This character set is called the basic multilingual plane (BMP), and includes the most common characters like the Latin, Greek, Cyrillic alphabets, as well as many East Asian characters. Each code unit can be written in a string with \\u followed by exactly four hex digits.\n\nHowever, the entire Unicode character set is much, much bigger than 65536. The extra characters are stored in UTF-16 as surrogate pairs, which are pairs of 16-bit code units that represent a single character. To avoid ambiguity, the two parts of the pair must be between 0xD800 and 0xDFFF, and these code units are not used to encode single-code-unit characters. (More precisely, leading surrogates, also called high-surrogate code units, have values between 0xD800 and 0xDBFF, inclusive, while trailing surrogates, also called low-surrogate code units, have values between 0xDC00 and 0xDFFF, inclusive.) Each Unicode character, comprised of one or two UTF-16 code units, is also called a Unicode code point. Each Unicode code point can be written in a string with \\u{xxxxxx} where xxxxxx represents 1â6 hex digits.\n\nA \"lone surrogate\" is a 16-bit code unit satisfying one of the descriptions below:\n\nIt is in the range 0xD800â0xDBFF, inclusive (i.e. is a leading surrogate), but it is the last code unit in the string, or the next code unit is not a trailing surrogate.\n\nIt is in the range 0xDC00â0xDFFF, inclusive (i.e. is a trailing surrogate), but it is the first code unit in the string, or the previous code unit is not a leading surrogate.\n\nLone surrogates do not represent any Unicode character. Although most JavaScript built-in methods handle them correctly because they all work based on UTF-16 code units, lone surrogates are often not valid values when interacting with other systems â for example, encodeURI() will throw a URIError for lone surrogates, because URI encoding uses UTF-8 encoding, which does not have any encoding for lone surrogates. Strings not containing any lone surrogates are called well-formed strings, and are safe to be used with functions that do not deal with UTF-16 (such as encodeURI() or TextEncoder). You can check if a string is well-formed with the isWellFormed() method, or sanitize lone surrogates with the toWellFormed() method.\n\nOn top of Unicode characters, there are certain sequences of Unicode characters that should be treated as one visual unit, known as a grapheme cluster. The most common case is emojis: many emojis that have a range of variations are actually formed by multiple emojis, usually joined by the <ZWJ> (U+200D) character.\n\nYou must be careful which level of characters you are iterating on. For example, split(\"\") will split by UTF-16 code units and will separate surrogate pairs. String indexes also refer to the index of each UTF-16 code unit. On the other hand, [Symbol.iterator]() iterates by Unicode code points. Iterating through grapheme clusters will require some custom code.\n\njs\n\n\"ð\".split(\"\"); [...\"ðð¿\"]; [...\"ð¨âð¦\"]; [...\"ðºð³\"];"
    }
}