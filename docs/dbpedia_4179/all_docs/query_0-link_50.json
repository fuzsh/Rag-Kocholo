{
    "id": "dbpedia_4179_0",
    "rank": 50,
    "data": {
        "url": "https://stackoverflow.com/questions/18807812/adding-an-average-parameter-to-nets-random-next-to-curve-results",
        "read_more_link": "",
        "language": "en",
        "title": "Adding an \"average\" parameter to .NET's Random.Next() to curve results",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/khzML.png",
            "https://i.sstatic.net/oTUw0.jpg?s=64",
            "https://www.gravatar.com/avatar/2a7d7e9fa2049d4dbf9a508e5eccdb0a?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/X5iEz.png",
            "https://i.sstatic.net/DS8Mx.png",
            "https://i.sstatic.net/1paGg.png",
            "https://www.gravatar.com/avatar/7eacf70ab0eec3bc8aa453a101afcb98?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/X2ciz.png",
            "https://i.sstatic.net/AJLXa.png",
            "https://www.gravatar.com/avatar/8f4f015bc6c748fd2a4e7d700994c51e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/W8lnG.jpg?s=64",
            "https://i.sstatic.net/pci7f.png?s=64",
            "https://i.sstatic.net/uT3JH.png?s=64",
            "https://www.gravatar.com/avatar/3fb8502908ed7d44a0ae339060a3dfa6?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/HdNQj.jpg?s=64",
            "https://i.sstatic.net/KfVuU.png?s=64",
            "https://stackoverflow.com/posts/18807812/ivc/cd78?prg=17b730a9-791a-47f3-833c-554d56cf7057",
            "https://stackoverflow.com/js-false.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2013-09-15T00:41:28",
        "summary": "",
        "meta_description": "I'd like to be able to add a \"average\" parameter to Random.Next(Lower, Upper). This method would have min, max and average parameters. I created a method like this a while back for testing (It used...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/18807812/adding-an-average-parameter-to-nets-random-next-to-curve-results",
        "text": "I'm expanding on the idea of generating n random numbers, and taking their average to get a bell-curve effect. The \"tightness\" parameter controls how steep the curve is.\n\nEdit: Summing a set of random points to get a \"normal\" distribution is supported by the Central Limit Theorem. Using a bias function to sway results in a particular direction is a common technique, but I'm no expert there.\n\nTo address the note at the end of your question, I'm skewing the curve by manipulating the \"inner\" random number. In this example, I'm raising it to the exponent you provide. Since a Random returns values less than one, raising it to any power will still never be more than one. But the average skews towards zero, as squares, cubes, etc of numbers less than one are even smaller than the base number. exp = 1 has no skew, whereas exp = 4 has a pretty significant skew.\n\nprivate Random r = new Random(); public double RandomDist(double min, double max, int tightness, double exp) { double total = 0.0; for (int i = 1; i <= tightness; i++) { total += Math.Pow(r.NextDouble(), exp); } return ((total / tightness) * (max - min)) + min; }\n\nI ran trials for different values for exp, generating 100,000 integers between 0 and 99. Here's how the distributions turned out.\n\nI'm not sure how the peak relates to the exp value, but the higher the exp, the lower the peak appears in the range.\n\nYou could also reverse the direction of the skew by changing the line in the inside of the loop to:\n\ntotal += (1 - Math.Pow(r.NextDouble(), exp));\n\n...which would give the bias on the high side of the curve.\n\nEdit: So, how do we know what to make \"exp\" in order to get the peak where we want it? That's a tricky one, and could probably be worked out analytically, but I'm a developer, not a mathematician. So, applying my trade, I ran lots of trials, gathered peak data for various values of exp, and ran the data through the cubic fit calculator at Wolfram Alpha to get an equation for exp as a function of peak.\n\nHere's a new set of functions which implement this logic. The GetExp(...) function implements the equation found by WolframAlpha.\n\nRandomBiasedPow(...) is the function of interest. It returns a random number in the specified ranges, but tends towards the peak. The strength of that tendency is governed by the tightness parameter.\n\nprivate Random r = new Random(); public double RandomNormal(double min, double max, int tightness) { double total = 0.0; for (int i = 1; i <= tightness; i++) { total += r.NextDouble(); } return ((total / tightness) * (max - min)) + min; } public double RandomNormalDist(double min, double max, int tightness, double exp) { double total = 0.0; for (int i = 1; i <= tightness; i++) { total += Math.Pow(r.NextDouble(), exp); } return ((total / tightness) * (max - min)) + min; } public double RandomBiasedPow(double min, double max, int tightness, double peak) { // Calculate skewed normal distribution, skewed by Math.Pow(...), specifiying where in the range the peak is // NOTE: This peak will yield unreliable results in the top 20% and bottom 20% of the range. // To peak at extreme ends of the range, consider using a different bias function double total = 0.0; double scaledPeak = peak / (max - min) + min; if (scaledPeak < 0.2 || scaledPeak > 0.8) { throw new Exception(\"Peak cannot be in bottom 20% or top 20% of range.\"); } double exp = GetExp(scaledPeak); for (int i = 1; i <= tightness; i++) { // Bias the random number to one side or another, but keep in the range of 0 - 1 // The exp parameter controls how far to bias the peak from normal distribution total += BiasPow(r.NextDouble(), exp); } return ((total / tightness) * (max - min)) + min; } public double GetExp(double peak) { // Get the exponent necessary for BiasPow(...) to result in the desired peak // Based on empirical trials, and curve fit to a cubic equation, using WolframAlpha return -12.7588 * Math.Pow(peak, 3) + 27.3205 * Math.Pow(peak, 2) - 21.2365 * peak + 6.31735; } public double BiasPow(double input, double exp) { return Math.Pow(input, exp); }\n\nHere is a histogram using RandomBiasedPow(0, 100, 5, peak), with the various values of peak shown in the legend. I rounded down to get integers between 0 and 99, set tightness to 5, and tried peak values between 20 and 80. (Things get wonky at extreme peak values, so I left that out, and put a warning in the code.) You can see the peaks right where they should be.\n\nNext, I tried boosting Tightness to 10...\n\nDistribution is tighter, and the peaks are still where they should be. It's pretty fast too!\n\nHere's a simple way to achieve this. Since you already have answers detailing how to generate normal distributions, and there are plenty of resources on that, I won't reiterate that. Instead I'll refer to a method I'll call GetNextNormal() which should generate a value from a normal distribution with mean 0 and standard deviation 1.\n\npublic int Next(int min, int max, int center) { int rand = GetNextNormal(); if(rand >= 0) return center + rand*(max-center); return center + rand*(center-min); }\n\n(This can be simplified a little, I've written it that way for clarity)\n\nFor a rough image of what this is doing, imagine two normal distributions. They're both centered around your center, but for one the min is one standard deviation away, to the left, and for the other, the max is one standard deviation away, to the right. Now imagine chopping them both in half at the center. On the left, you keep the one with the standard deviation corresponding to min, and on the right, the one corresponding to max.\n\nOf course, normal distributions aren't guaranteed to stay within one standard deviation, so there are two things you probably want to do:\n\nAdd an extra parameter which controls how tight the distribution is\n\nIf you want min and max to be hard limits, you will have to add rejection for values outside those bounds.\n\nA complete method, with those two additions (again keeping everything as ints for now), might look like;\n\npublic int Next(int min, int max, int center, int tightness) { int rand = GetNextNormal(); int candidate; do { if(rand >= 0) candidate = center + rand*(max-center)/tightness; else candidate = center + rand*(center-min)/tightness; } while(candidate < min || candidate > max); return candidate; }\n\nIf you graph the results of this (especially a float/double version), it won't be the most beautiful distribution, but it should be adequate for your purposes.\n\nEDIT\n\nAbove I said the results of this aren't particularly beautiful. To expand on that, the most glaring 'ugliness' is a discontinuity at the center point, due to the height of the peak of a normal distribution depending on its standard deviation. Because of this, the distribution you'll end up with will look something like this:\n\n(For min 10, max 100 and center point 70, using a 'tightness' of 3)\n\nSo while the probability of a value below the center is equal to the probability above, results will be much more tightly \"bunched\" around the average on one side than the other. If that's too ugly for you, or you think the results of generating features by a distribution like that will seem too unnatural, we can add an additional modification, weighing which side of the center is picked by the proportions of the range to the left or right of center. Adding that to the code (with the assumption you have access to a Random which I've just called RandomGen) we get:\n\npublic int Next(int min, int max, int center, int tightness) { int rand = Math.Abs(GetNextNormal()); int candidate; do { if(ChooseSide()) candidate = center + rand*(max-center)/tightness; else candidate = center - rand*(center-min)/tightness; } while(candidate < min || candidate > max); return candidate; } public bool ChooseSide(int min, int max, int center) { return RandomGen.Next(min, max) >= center; }\n\nFor comparison, the distribution this will produce with the same min, max, center and tightness is:\n\nAs you can see, this is now continuous in frequency, as well as the first derivative (giving a smooth peak). The disadvantage to this version over the other is now you're more likely to get results on one side of the center than the other. The center is now the modal average, not the mean. So it's up to you whether you prefer a smoother distribution or having the center be the true mean of the distribution."
    }
}