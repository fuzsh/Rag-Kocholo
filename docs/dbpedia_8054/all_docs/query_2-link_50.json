{
    "id": "dbpedia_8054_2",
    "rank": 50,
    "data": {
        "url": "https://docs.python.org/3/library/tkinter.ttk.html",
        "read_more_link": "",
        "language": "en",
        "title": "tkinter.ttk â Tk themed widgets",
        "top_image": "https://docs.python.org/3/_static/og-image.png",
        "meta_img": "https://docs.python.org/3/_static/og-image.png",
        "images": [
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Source code: Lib/tkinter/ttk.py The tkinter.ttk module provides access to the Tk themed widget set, introduced in Tk 8.5. It provides additional benefits including anti-aliased font rendering under...",
        "meta_lang": "en",
        "meta_favicon": "../_static/py.svg",
        "meta_site_name": "Python documentation",
        "canonical_link": "https://docs.python.org/3/library/tkinter.ttk.html",
        "text": "tkinter.ttk â Tk themed widgetsÂ¶\n\nSource code: Lib/tkinter/ttk.py\n\nThe tkinter.ttk module provides access to the Tk themed widget set, introduced in Tk 8.5. It provides additional benefits including anti-aliased font rendering under X11 and window transparency (requiring a composition window manager on X11).\n\nThe basic idea for tkinter.ttk is to separate, to the extent possible, the code implementing a widgetâs behavior from the code implementing its appearance.\n\nSee also\n\nTk Widget Styling Support\n\nA document introducing theming support for Tk\n\nUsing TtkÂ¶\n\nTo start using Ttk, import its module:\n\nfrom tkinter import ttk\n\nTo override the basic Tk widgets, the import should follow the Tk import:\n\nfrom tkinter import * from tkinter.ttk import *\n\nThat code causes several tkinter.ttk widgets (Button, Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale and Scrollbar) to automatically replace the Tk widgets.\n\nThis has the direct benefit of using the new widgets which gives a better look and feel across platforms; however, the replacement widgets are not completely compatible. The main difference is that widget options such as âfgâ, âbgâ and others related to widget styling are no longer present in Ttk widgets. Instead, use the ttk.Style class for improved styling effects.\n\nSee also\n\nConverting existing applications to use Tile widgets\n\nA monograph (using Tcl terminology) about differences typically encountered when moving applications to use the new widgets.\n\nTtk WidgetsÂ¶\n\nTtk comes with 18 widgets, twelve of which already existed in tkinter: Button, Checkbutton, Entry, Frame, Label, LabelFrame, Menubutton, PanedWindow, Radiobutton, Scale, Scrollbar, and Spinbox. The other six are new: Combobox, Notebook, Progressbar, Separator, Sizegrip and Treeview. And all them are subclasses of Widget.\n\nUsing the Ttk widgets gives the application an improved look and feel. As discussed above, there are differences in how the styling is coded.\n\nTk code:\n\nl1 = tkinter.Label(text=\"Test\", fg=\"black\", bg=\"white\") l2 = tkinter.Label(text=\"Test\", fg=\"black\", bg=\"white\")\n\nTtk code:\n\nstyle = ttk.Style() style.configure(\"BW.TLabel\", foreground=\"black\", background=\"white\") l1 = ttk.Label(text=\"Test\", style=\"BW.TLabel\") l2 = ttk.Label(text=\"Test\", style=\"BW.TLabel\")\n\nFor more information about TtkStyling, see the Style class documentation.\n\nWidgetÂ¶\n\nttk.Widget defines standard options and methods supported by Tk themed widgets and is not supposed to be directly instantiated.\n\nStandard OptionsÂ¶\n\nAll the ttk Widgets accept the following options:\n\nOption\n\nDescription\n\nScrollable Widget OptionsÂ¶\n\nThe following options are supported by widgets that are controlled by a scrollbar.\n\nOption\n\nDescription\n\nLabel OptionsÂ¶\n\nThe following options are supported by labels, buttons and other button-like widgets.\n\nOption\n\nDescription\n\nCompatibility OptionsÂ¶\n\nOption\n\nDescription\n\nWidget StatesÂ¶\n\nThe widget state is a bitmap of independent state flags.\n\nFlag\n\nDescription\n\nA state specification is a sequence of state names, optionally prefixed with an exclamation point indicating that the bit is off.\n\nttk.WidgetÂ¶\n\nBesides the methods described below, the ttk.Widget supports the methods tkinter.Widget.cget() and tkinter.Widget.configure().\n\nclasstkinter.ttk.WidgetÂ¶\n\nidentify(x, y)Â¶\n\nReturns the name of the element at position x y, or the empty string if the point does not lie within any element.\n\nx and y are pixel coordinates relative to the widget.\n\ninstate(statespec, callback=None, *args, **kw)Â¶\n\nTest the widgetâs state. If a callback is not specified, returns True if the widget state matches statespec and False otherwise. If callback is specified then it is called with args if widget state matches statespec.\n\nstate(statespec=None)Â¶\n\nModify or inquire widget state. If statespec is specified, sets the widget state according to it and return a new statespec indicating which flags were changed. If statespec is not specified, returns the currently enabled state flags.\n\nstatespec will usually be a list or a tuple.\n\nComboboxÂ¶\n\nThe ttk.Combobox widget combines a text field with a pop-down list of values. This widget is a subclass of Entry.\n\nBesides the methods inherited from Widget: Widget.cget(), Widget.configure(), Widget.identify(), Widget.instate() and Widget.state(), and the following inherited from Entry: Entry.bbox(), Entry.delete(), Entry.icursor(), Entry.index(), Entry.insert(), Entry.selection(), Entry.xview(), it has some other methods, described at ttk.Combobox.\n\nOptionsÂ¶\n\nThis widget accepts the following specific options:\n\nOption\n\nDescription\n\nVirtual eventsÂ¶\n\nThe combobox widgets generates a <<ComboboxSelected>> virtual event when the user selects an element from the list of values.\n\nttk.ComboboxÂ¶\n\nclasstkinter.ttk.ComboboxÂ¶\n\ncurrent(newindex=None)Â¶\n\nIf newindex is specified, sets the combobox value to the element position newindex. Otherwise, returns the index of the current value or -1 if the current value is not in the values list.\n\nget()Â¶\n\nReturns the current value of the combobox.\n\nset(value)Â¶\n\nSets the value of the combobox to value.\n\nSpinboxÂ¶\n\nThe ttk.Spinbox widget is a ttk.Entry enhanced with increment and decrement arrows. It can be used for numbers or lists of string values. This widget is a subclass of Entry.\n\nBesides the methods inherited from Widget: Widget.cget(), Widget.configure(), Widget.identify(), Widget.instate() and Widget.state(), and the following inherited from Entry: Entry.bbox(), Entry.delete(), Entry.icursor(), Entry.index(), Entry.insert(), Entry.xview(), it has some other methods, described at ttk.Spinbox.\n\nOptionsÂ¶\n\nThis widget accepts the following specific options:\n\nOption\n\nDescription\n\nVirtual eventsÂ¶\n\nThe spinbox widget generates an <<Increment>> virtual event when the user presses <Up>, and a <<Decrement>> virtual event when the user presses <Down>.\n\nttk.SpinboxÂ¶\n\nclasstkinter.ttk.SpinboxÂ¶\n\nget()Â¶\n\nReturns the current value of the spinbox.\n\nset(value)Â¶\n\nSets the value of the spinbox to value.\n\nNotebookÂ¶\n\nTtk Notebook widget manages a collection of windows and displays a single one at a time. Each child window is associated with a tab, which the user may select to change the currently displayed window.\n\nOptionsÂ¶\n\nThis widget accepts the following specific options:\n\nOption\n\nDescription\n\nTab OptionsÂ¶\n\nThere are also specific options for tabs:\n\nOption\n\nDescription\n\nTab IdentifiersÂ¶\n\nThe tab_id present in several methods of ttk.Notebook may take any of the following forms:\n\nAn integer between zero and the number of tabs\n\nThe name of a child window\n\nA positional specification of the form â@x,yâ, which identifies the tab\n\nThe literal string âcurrentâ, which identifies the currently selected tab\n\nThe literal string âendâ, which returns the number of tabs (only valid for Notebook.index())\n\nVirtual EventsÂ¶\n\nThis widget generates a <<NotebookTabChanged>> virtual event after a new tab is selected.\n\nttk.NotebookÂ¶\n\nclasstkinter.ttk.NotebookÂ¶\n\nadd(child, **kw)Â¶\n\nAdds a new tab to the notebook.\n\nIf window is currently managed by the notebook but hidden, it is restored to its previous position.\n\nSee Tab Options for the list of available options.\n\nforget(tab_id)Â¶\n\nRemoves the tab specified by tab_id, unmaps and unmanages the associated window.\n\nhide(tab_id)Â¶\n\nHides the tab specified by tab_id.\n\nThe tab will not be displayed, but the associated window remains managed by the notebook and its configuration remembered. Hidden tabs may be restored with the add() command.\n\nidentify(x, y)Â¶\n\nReturns the name of the tab element at position x, y, or the empty string if none.\n\nindex(tab_id)Â¶\n\nReturns the numeric index of the tab specified by tab_id, or the total number of tabs if tab_id is the string âendâ.\n\ninsert(pos, child, **kw)Â¶\n\nInserts a pane at the specified position.\n\npos is either the string âendâ, an integer index, or the name of a managed child. If child is already managed by the notebook, moves it to the specified position.\n\nSee Tab Options for the list of available options.\n\nselect(tab_id=None)Â¶\n\nSelects the specified tab_id.\n\nThe associated child window will be displayed, and the previously selected window (if different) is unmapped. If tab_id is omitted, returns the widget name of the currently selected pane.\n\ntab(tab_id, option=None, **kw)Â¶\n\nQuery or modify the options of the specific tab_id.\n\nIf kw is not given, returns a dictionary of the tab option values. If option is specified, returns the value of that option. Otherwise, sets the options to the corresponding values.\n\ntabs()Â¶\n\nReturns a list of windows managed by the notebook.\n\nenable_traversal()Â¶\n\nEnable keyboard traversal for a toplevel window containing this notebook.\n\nThis will extend the bindings for the toplevel window containing the notebook as follows:\n\nControl-Tab: selects the tab following the currently selected one.\n\nShift-Control-Tab: selects the tab preceding the currently selected one.\n\nAlt-K: where K is the mnemonic (underlined) character of any tab, will select that tab.\n\nMultiple notebooks in a single toplevel may be enabled for traversal, including nested notebooks. However, notebook traversal only works properly if all panes have the notebook they are in as master.\n\nProgressbarÂ¶\n\nThe ttk.Progressbar widget shows the status of a long-running operation. It can operate in two modes: 1) the determinate mode which shows the amount completed relative to the total amount of work to be done and 2) the indeterminate mode which provides an animated display to let the user know that work is progressing.\n\nOptionsÂ¶\n\nThis widget accepts the following specific options:\n\nOption\n\nDescription\n\nttk.ProgressbarÂ¶\n\nclasstkinter.ttk.ProgressbarÂ¶\n\nstart(interval=None)Â¶\n\nBegin autoincrement mode: schedules a recurring timer event that calls Progressbar.step() every interval milliseconds. If omitted, interval defaults to 50 milliseconds.\n\nstep(amount=None)Â¶\n\nIncrements the progress barâs value by amount.\n\namount defaults to 1.0 if omitted.\n\nstop()Â¶\n\nStop autoincrement mode: cancels any recurring timer event initiated by Progressbar.start() for this progress bar.\n\nSeparatorÂ¶\n\nThe ttk.Separator widget displays a horizontal or vertical separator bar.\n\nIt has no other methods besides the ones inherited from ttk.Widget.\n\nOptionsÂ¶\n\nThis widget accepts the following specific option:\n\nOption\n\nDescription\n\nSizegripÂ¶\n\nThe ttk.Sizegrip widget (also known as a grow box) allows the user to resize the containing toplevel window by pressing and dragging the grip.\n\nThis widget has neither specific options nor specific methods, besides the ones inherited from ttk.Widget.\n\nPlatform-specific notesÂ¶\n\nOn macOS, toplevel windows automatically include a built-in size grip by default. Adding a Sizegrip is harmless, since the built-in grip will just mask the widget.\n\nBugsÂ¶\n\nIf the containing toplevelâs position was specified relative to the right or bottom of the screen (e.g. â¦.), the Sizegrip widget will not resize the window.\n\nThis widget supports only âsoutheastâ resizing.\n\nTreeviewÂ¶\n\nThe ttk.Treeview widget displays a hierarchical collection of items. Each item has a textual label, an optional image, and an optional list of data values. The data values are displayed in successive columns after the tree label.\n\nThe order in which data values are displayed may be controlled by setting the widget option displaycolumns. The tree widget can also display column headings. Columns may be accessed by number or symbolic names listed in the widget option columns. See Column Identifiers.\n\nEach item is identified by a unique name. The widget will generate item IDs if they are not supplied by the caller. There is a distinguished root item, named {}. The root item itself is not displayed; its children appear at the top level of the hierarchy.\n\nEach item also has a list of tags, which can be used to associate event bindings with individual items and control the appearance of the item.\n\nThe Treeview widget supports horizontal and vertical scrolling, according to the options described in Scrollable Widget Options and the methods Treeview.xview() and Treeview.yview().\n\nOptionsÂ¶\n\nThis widget accepts the following specific options:\n\nOption\n\nDescription\n\nItem OptionsÂ¶\n\nThe following item options may be specified for items in the insert and item widget commands.\n\nOption\n\nDescription\n\nTag OptionsÂ¶\n\nThe following options may be specified on tags:\n\nOption\n\nDescription\n\nforeground\n\nSpecifies the text foreground color.\n\nbackground\n\nSpecifies the cell or item background color.\n\nfont\n\nSpecifies the font to use when drawing text.\n\nimage\n\nSpecifies the item image, in case the itemâs image option is empty.\n\nColumn IdentifiersÂ¶\n\nColumn identifiers take any of the following forms:\n\nA symbolic name from the list of columns option.\n\nAn integer n, specifying the nth data column.\n\nA string of the form #n, where n is an integer, specifying the nth display column.\n\nNotes:\n\nItemâs option values may be displayed in a different order than the order in which they are stored.\n\nColumn #0 always refers to the tree column, even if show=âtreeâ is not specified.\n\nA data column number is an index into an itemâs option values list; a display column number is the column number in the tree where the values are displayed. Tree labels are displayed in column #0. If option displaycolumns is not set, then data column n is displayed in column #n+1. Again, column #0 always refers to the tree column.\n\nVirtual EventsÂ¶\n\nThe Treeview widget generates the following virtual events.\n\nEvent\n\nDescription\n\n<<TreeviewSelect>>\n\nGenerated whenever the selection changes.\n\n<<TreeviewOpen>>\n\nGenerated just before settings the focus item to open=True.\n\n<<TreeviewClose>>\n\nGenerated just after setting the focus item to open=False.\n\nThe Treeview.focus() and Treeview.selection() methods can be used to determine the affected item or items.\n\nttk.TreeviewÂ¶\n\nclasstkinter.ttk.TreeviewÂ¶\n\nbbox(item, column=None)Â¶\n\nReturns the bounding box (relative to the treeview widgetâs window) of the specified item in the form (x, y, width, height).\n\nIf column is specified, returns the bounding box of that cell. If the item is not visible (i.e., if it is a descendant of a closed item or is scrolled offscreen), returns an empty string.\n\nget_children(item=None)Â¶\n\nReturns the list of children belonging to item.\n\nIf item is not specified, returns root children.\n\nset_children(item, *newchildren)Â¶\n\nReplaces itemâs child with newchildren.\n\nChildren present in item that are not present in newchildren are detached from the tree. No items in newchildren may be an ancestor of item. Note that not specifying newchildren results in detaching itemâs children.\n\ncolumn(column, option=None, **kw)Â¶\n\nQuery or modify the options for the specified column.\n\nIf kw is not given, returns a dict of the column option values. If option is specified then the value for that option is returned. Otherwise, sets the options to the corresponding values.\n\nThe valid options/values are:\n\nid\n\nReturns the column name. This is a read-only option.\n\nanchor: One of the standard Tk anchor values.\n\nSpecifies how the text in this column should be aligned with respect to the cell.\n\nminwidth: width\n\nThe minimum width of the column in pixels. The treeview widget will not make the column any smaller than specified by this option when the widget is resized or the user drags a column.\n\nstretch: True/False\n\nSpecifies whether the columnâs width should be adjusted when the widget is resized.\n\nwidth: width\n\nThe width of the column in pixels.\n\nTo configure the tree column, call this with column = â#0â\n\ndelete(*items)Â¶\n\nDelete all specified items and all their descendants.\n\nThe root item may not be deleted.\n\ndetach(*items)Â¶\n\nUnlinks all of the specified items from the tree.\n\nThe items and all of their descendants are still present, and may be reinserted at another point in the tree, but will not be displayed.\n\nThe root item may not be detached.\n\nexists(item)Â¶\n\nReturns True if the specified item is present in the tree.\n\nfocus(item=None)Â¶\n\nIf item is specified, sets the focus item to item. Otherwise, returns the current focus item, or ââ if there is none.\n\nheading(column, option=None, **kw)Â¶\n\nQuery or modify the heading options for the specified column.\n\nIf kw is not given, returns a dict of the heading option values. If option is specified then the value for that option is returned. Otherwise, sets the options to the corresponding values.\n\nThe valid options/values are:\n\ntext: text\n\nThe text to display in the column heading.\n\nimage: imageName\n\nSpecifies an image to display to the right of the column heading.\n\nanchor: anchor\n\nSpecifies how the heading text should be aligned. One of the standard Tk anchor values.\n\ncommand: callback\n\nA callback to be invoked when the heading label is pressed.\n\nTo configure the tree column heading, call this with column = â#0â.\n\nidentify(component, x, y)Â¶\n\nReturns a description of the specified component under the point given by x and y, or the empty string if no such component is present at that position.\n\nidentify_row(y)Â¶\n\nReturns the item ID of the item at position y.\n\nidentify_column(x)Â¶\n\nReturns the data column identifier of the cell at position x.\n\nThe tree column has ID #0.\n\nidentify_region(x, y)Â¶\n\nReturns one of:\n\nregion\n\nmeaning\n\nheading\n\nTree heading area.\n\nseparator\n\nSpace between two columns headings.\n\ntree\n\nThe tree area.\n\ncell\n\nA data cell.\n\nAvailability: Tk 8.6.\n\nidentify_element(x, y)Â¶\n\nReturns the element at position x, y.\n\nAvailability: Tk 8.6.\n\nindex(item)Â¶\n\nReturns the integer index of item within its parentâs list of children.\n\ninsert(parent, index, iid=None, **kw)Â¶\n\nCreates a new item and returns the item identifier of the newly created item.\n\nparent is the item ID of the parent item, or the empty string to create a new top-level item. index is an integer, or the value âendâ, specifying where in the list of parentâs children to insert the new item. If index is less than or equal to zero, the new node is inserted at the beginning; if index is greater than or equal to the current number of children, it is inserted at the end. If iid is specified, it is used as the item identifier; iid must not already exist in the tree. Otherwise, a new unique identifier is generated.\n\nSee Item Options for the list of available options.\n\nitem(item, option=None, **kw)Â¶\n\nQuery or modify the options for the specified item.\n\nIf no options are given, a dict with options/values for the item is returned. If option is specified then the value for that option is returned. Otherwise, sets the options to the corresponding values as given by kw.\n\nmove(item, parent, index)Â¶\n\nMoves item to position index in parentâs list of children.\n\nIt is illegal to move an item under one of its descendants. If index is less than or equal to zero, item is moved to the beginning; if greater than or equal to the number of children, it is moved to the end. If item was detached it is reattached.\n\nnext(item)Â¶\n\nReturns the identifier of itemâs next sibling, or ââ if item is the last child of its parent.\n\nparent(item)Â¶\n\nReturns the ID of the parent of item, or ââ if item is at the top level of the hierarchy.\n\nprev(item)Â¶\n\nReturns the identifier of itemâs previous sibling, or ââ if item is the first child of its parent.\n\nreattach(item, parent, index)Â¶\n\nAn alias for Treeview.move().\n\nsee(item)Â¶\n\nEnsure that item is visible.\n\nSets all of itemâs ancestors open option to True, and scrolls the widget if necessary so that item is within the visible portion of the tree.\n\nselection()Â¶\n\nReturns a tuple of selected items.\n\nChanged in version 3.8: selection() no longer takes arguments. For changing the selection state use the following selection methods.\n\nselection_set(*items)Â¶\n\nitems becomes the new selection.\n\nChanged in version 3.6: items can be passed as separate arguments, not just as a single tuple.\n\nselection_add(*items)Â¶\n\nAdd items to the selection.\n\nChanged in version 3.6: items can be passed as separate arguments, not just as a single tuple.\n\nselection_remove(*items)Â¶\n\nRemove items from the selection.\n\nChanged in version 3.6: items can be passed as separate arguments, not just as a single tuple.\n\nselection_toggle(*items)Â¶\n\nToggle the selection state of each item in items.\n\nChanged in version 3.6: items can be passed as separate arguments, not just as a single tuple.\n\nset(item, column=None, value=None)Â¶\n\nWith one argument, returns a dictionary of column/value pairs for the specified item. With two arguments, returns the current value of the specified column. With three arguments, sets the value of given column in given item to the specified value.\n\ntag_bind(tagname, sequence=None, callback=None)Â¶\n\nBind a callback for the given event sequence to the tag tagname. When an event is delivered to an item, the callbacks for each of the itemâs tags option are called.\n\ntag_configure(tagname, option=None, **kw)Â¶\n\nQuery or modify the options for the specified tagname.\n\nIf kw is not given, returns a dict of the option settings for tagname. If option is specified, returns the value for that option for the specified tagname. Otherwise, sets the options to the corresponding values for the given tagname.\n\ntag_has(tagname, item=None)Â¶\n\nIf item is specified, returns 1 or 0 depending on whether the specified item has the given tagname. Otherwise, returns a list of all items that have the specified tag.\n\nAvailability: Tk 8.6\n\nxview(*args)Â¶\n\nQuery or modify horizontal position of the treeview.\n\nyview(*args)Â¶\n\nQuery or modify vertical position of the treeview.\n\nTtk StylingÂ¶\n\nEach widget in ttk is assigned a style, which specifies the set of elements making up the widget and how they are arranged, along with dynamic and default settings for element options. By default the style name is the same as the widgetâs class name, but it may be overridden by the widgetâs style option. If you donât know the class name of a widget, use the method Misc.winfo_class() (somewidget.winfo_class()).\n\nSee also\n\nTclâ2004 conference presentation\n\nThis document explains how the theme engine works\n\nclasstkinter.ttk.StyleÂ¶\n\nThis class is used to manipulate the style database.\n\nconfigure(style, query_opt=None, **kw)Â¶\n\nQuery or set the default value of the specified option(s) in style.\n\nEach key in kw is an option and each value is a string identifying the value for that option.\n\nFor example, to change every default button to be a flat button with some padding and a different background color:\n\nfrom tkinter import ttk import tkinter root = tkinter.Tk() ttk.Style().configure(\"TButton\", padding=6, relief=\"flat\", background=\"#ccc\") btn = ttk.Button(text=\"Sample\") btn.pack() root.mainloop()\n\nmap(style, query_opt=None, **kw)Â¶\n\nQuery or sets dynamic values of the specified option(s) in style.\n\nEach key in kw is an option and each value should be a list or a tuple (usually) containing statespecs grouped in tuples, lists, or some other preference. A statespec is a compound of one or more states and then a value.\n\nAn example may make it more understandable:\n\nimport tkinter from tkinter import ttk root = tkinter.Tk() style = ttk.Style() style.map(\"C.TButton\", foreground=[('pressed', 'red'), ('active', 'blue')], background=[('pressed', '!disabled', 'black'), ('active', 'white')] ) colored_btn = ttk.Button(text=\"Test\", style=\"C.TButton\").pack() root.mainloop()\n\nNote that the order of the (states, value) sequences for an option does matter, if the order is changed to [('active', 'blue'), ('pressed', 'red')] in the foreground option, for example, the result would be a blue foreground when the widget were in active or pressed states.\n\nlookup(style, option, state=None, default=None)Â¶\n\nReturns the value specified for option in style.\n\nIf state is specified, it is expected to be a sequence of one or more states. If the default argument is set, it is used as a fallback value in case no specification for option is found.\n\nTo check what font a Button uses by default:\n\nfrom tkinter import ttk print(ttk.Style().lookup(\"TButton\", \"font\"))\n\nlayout(style, layoutspec=None)Â¶\n\nDefine the widget layout for given style. If layoutspec is omitted, return the layout specification for given style.\n\nlayoutspec, if specified, is expected to be a list or some other sequence type (excluding strings), where each item should be a tuple and the first item is the layout name and the second item should have the format described in Layouts.\n\nTo understand the format, see the following example (it is not intended to do anything useful):\n\nfrom tkinter import ttk import tkinter root = tkinter.Tk() style = ttk.Style() style.layout(\"TMenubutton\", [ (\"Menubutton.background\", None), (\"Menubutton.button\", {\"children\": [(\"Menubutton.focus\", {\"children\": [(\"Menubutton.padding\", {\"children\": [(\"Menubutton.label\", {\"side\": \"left\", \"expand\": 1})] })] })] }), ]) mbtn = ttk.Menubutton(text='Text') mbtn.pack() root.mainloop()\n\nelement_create(elementname, etype, *args, **kw)Â¶\n\nCreate a new element in the current theme, of the given etype which is expected to be either âimageâ or âfromâ.\n\nIf âimageâ is used, args should contain the default image name followed by statespec/value pairs (this is the imagespec), and kw may have the following options:\n\nborder=padding\n\npadding is a list of up to four integers, specifying the left, top, right, and bottom borders, respectively.\n\nheight=height\n\nSpecifies a minimum height for the element. If less than zero, the base imageâs height is used as a default.\n\npadding=padding\n\nSpecifies the elementâs interior padding. Defaults to borderâs value if not specified.\n\nsticky=spec\n\nSpecifies how the image is placed within the final parcel. spec contains zero or more characters ânâ, âsâ, âwâ, or âeâ.\n\nwidth=width\n\nSpecifies a minimum width for the element. If less than zero, the base imageâs width is used as a default.\n\nExample:\n\nimg1 = tkinter.PhotoImage(master=root, file='button.png') img1 = tkinter.PhotoImage(master=root, file='button-pressed.png') img1 = tkinter.PhotoImage(master=root, file='button-active.png') style = ttk.Style(root) style.element_create('Button.button', 'image', img1, ('pressed', img2), ('active', img3), border=(2, 4), sticky='we')\n\nIf âfromâ is used as the value of etype, element_create() will clone an existing element. args is expected to contain a themename, from which the element will be cloned, and optionally an element to clone from. If this element to clone from is not specified, an empty element will be used. kw is discarded.\n\nExample:\n\nstyle = ttk.Style(root) style.element_create('plain.background', 'from', 'default')\n\nelement_names()Â¶\n\nReturns the list of elements defined in the current theme.\n\nelement_options(elementname)Â¶\n\nReturns the list of elementnameâs options.\n\ntheme_create(themename, parent=None, settings=None)Â¶\n\nCreate a new theme.\n\nIt is an error if themename already exists. If parent is specified, the new theme will inherit styles, elements and layouts from the parent theme. If settings are present they are expected to have the same syntax used for theme_settings().\n\ntheme_settings(themename, settings)Â¶\n\nTemporarily sets the current theme to themename, apply specified settings and then restore the previous theme.\n\nEach key in settings is a style and each value may contain the keys âconfigureâ, âmapâ, âlayoutâ and âelement createâ and they are expected to have the same format as specified by the methods Style.configure(), Style.map(), Style.layout() and Style.element_create() respectively.\n\nAs an example, letâs change the Combobox for the default theme a bit:\n\nfrom tkinter import ttk import tkinter root = tkinter.Tk() style = ttk.Style() style.theme_settings(\"default\", { \"TCombobox\": { \"configure\": {\"padding\": 5}, \"map\": { \"background\": [(\"active\", \"green2\"), (\"!disabled\", \"green4\")], \"fieldbackground\": [(\"!disabled\", \"green3\")], \"foreground\": [(\"focus\", \"OliveDrab1\"), (\"!disabled\", \"OliveDrab2\")] } } }) combo = ttk.Combobox().pack() root.mainloop()\n\ntheme_names()Â¶\n\nReturns a list of all known themes.\n\ntheme_use(themename=None)Â¶\n\nIf themename is not given, returns the theme in use. Otherwise, sets the current theme to themename, refreshes all widgets and emits a <<ThemeChanged>> event.\n\nLayoutsÂ¶\n\nA layout can be just None, if it takes no options, or a dict of options specifying how to arrange the element. The layout mechanism uses a simplified version of the pack geometry manager: given an initial cavity, each element is allocated a parcel.\n\nThe valid options/values are:\n\nside: whichside\n\nSpecifies which side of the cavity to place the element; one of top, right, bottom or left. If omitted, the element occupies the entire cavity.\n\nsticky: nswe\n\nSpecifies where the element is placed inside its allocated parcel.\n\nunit: 0 or 1\n\nIf set to 1, causes the element and all of its descendants to be treated as a single element for the purposes of Widget.identify() et al. Itâs used for things like scrollbar thumbs with grips.\n\nchildren: [sublayoutâ¦ ]\n\nSpecifies a list of elements to place inside the element. Each element is a tuple (or other sequence type) where the first item is the layout name, and the other is a Layout."
    }
}