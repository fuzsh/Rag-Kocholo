{
    "id": "dbpedia_8054_2",
    "rank": 40,
    "data": {
        "url": "https://pymupdf.readthedocs.io/en/latest/page.html",
        "read_more_link": "",
        "language": "en",
        "title": "PyMuPDF 1.24.9 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://pymupdf.readthedocs.io/en/latest/_static/sidebar-logo-dark.svg",
            "https://pymupdf.readthedocs.io/en/latest/_static/sidebar-logo-light.svg",
            "https://pymupdf.readthedocs.io/en/latest/_images/discord-mark-blue.svg",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-caret-annot.jpg",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-redact.jpg",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-polyline.png",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-markers.jpg",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-findtables.jpg",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-stampannot.jpg",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-rotate.png",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-alpha-1.png",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-alpha-0.png",
            "https://pymupdf.readthedocs.io/en/latest/_images/img-showpdfpage.jpg",
            "https://pymupdf.readthedocs.io/en/latest/_images/discord-mark-blue.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "PDF Text Extraction",
            "PDF Image Extraction",
            "PDF Conversion",
            "PDF Tables",
            "PDF Splitting",
            "PDF Creation",
            "Pyodide",
            "PyScript"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "PyMuPDF is a high-performance Python library for data extraction, analysis, conversion & manipulation of PDF (and other) documents.",
        "meta_lang": "en",
        "meta_favicon": "_static/PyMuPDF.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Back to top\n\nToggle table of contents sidebar\n\nPage#\n\nClass representing a document page. A page object is created by Document.load_page() or, equivalently, via indexing the document like doc[n] - it has no independent constructor.\n\nThere is a parent-child relationship between a document and its pages. If the document is closed or deleted, all page objects (and their respective children, too) in existence will become unusable (“orphaned”): If a page property or method is being used, an exception is raised.\n\nSeveral page methods have a Document counterpart for convenience. At the end of this chapter you will find a synopsis.\n\nNote\n\nMany times in this chapter we are using the term coordinate. It is of high importance to have at least a basic understanding of what that is and that you feel comfortable with the section Coordinates.\n\nModifying Pages#\n\nChanging page properties and adding or changing page content is available for PDF documents only.\n\nIn a nutshell, this is what you can do with PyMuPDF:\n\nModify page rotation and the visible part (“cropbox”) of the page.\n\nInsert images, other PDF pages, text and simple geometrical objects.\n\nAdd annotations and form fields.\n\nNote\n\nMethods require coordinates (points, rectangles) to put content in desired places. Please be aware that these coordinates must always be provided relative to the unrotated page (since v1.17.0). The reverse is also true: except Page.rect, resp. Page.bound() (both reflect when the page is rotated), all coordinates returned by methods and attributes pertain to the unrotated page.\n\nSo the returned value of e.g. Page.get_image_bbox() will not change if you do a Page.set_rotation(). The same is true for coordinates returned by Page.get_text(), annotation rectangles, and so on. If you want to find out, where an object is located in rotated coordinates, multiply the coordinates with Page.rotation_matrix. There also is its inverse, Page.derotation_matrix, which you can use when interfacing with other readers, which may behave differently in this respect.\n\nNote\n\nIf you add or update annotations, links or form fields on the page and immediately afterwards need to work with them (i.e. without leaving the page), you should reload the page using Document.reload_page() before referring to these new or updated items.\n\nReloading the page is generally recommended – although not strictly required in all cases. However, some annotation and widget types have extended features in PyMuPDF compared to MuPDF. More of these extensions may also be added in the future.\n\nReleoading the page ensures all your changes have been fully applied to PDF structures, so you can safely create Pixmaps or successfully iterate over annotations, links and form fields.\n\nClass API\n\nclassPage#\n\nbound()#\n\nDetermine the rectangle of the page. Same as property Page.rect. For PDF documents this usually also coincides with mediabox and cropbox, but not always. For example, if the page is rotated, then this is reflected by this method – the Page.cropbox however will not change.\n\nReturn type:\n\nRect\n\nadd_caret_annot(point)#\n\nPDF only: Add a caret icon. A caret annotation is a visual symbol normally used to indicate the presence of text edits on the page.\n\nParameters:\n\npoint (point_like) – the top left point of a 20 x 20 rectangle containing the MuPDF-provided icon.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. Stroke color blue = (0, 0, 1), no fill color support.\n\nShow/hide history\n\nNew in v1.16.0\n\nadd_text_annot(point, text, icon='Note')#\n\nPDF only: Add a comment icon (“sticky note”) with accompanying text. Only the icon is visible, the accompanying text is hidden and can be visualized by many PDF viewers by hovering the mouse over the symbol.\n\nParameters:\n\npoint (point_like) – the top left point of a 20 x 20 rectangle containing the MuPDF-provided “note” icon.\n\ntext (str) – the commentary text. This will be shown on double clicking or hovering over the icon. May contain any Latin characters.\n\nicon (str) – choose one of “Note” (default), “Comment”, “Help”, “Insert”, “Key”, “NewParagraph”, “Paragraph” as the visual symbol for the embodied text . (New in v1.16.0)\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. Stroke color yellow = (1, 1, 0), no fill color support.\n\nadd_freetext_annot(rect, text, fontsize=12, fontname='helv', border_color=None, text_color=0, fill_color=1, rotate=0, align=TEXT_ALIGN_LEFT)#\n\nPDF only: Add text in a given rectangle.\n\nParameters:\n\nrect (rect_like) – the rectangle into which the text should be inserted. Text is automatically wrapped to a new line at box width. Lines not fitting into the box will be invisible.\n\ntext (str) – the text. May contain any mixture of Latin, Greek, Cyrillic, Chinese, Japanese and Korean characters. The respective required font is automatically determined. (New in v1.17.0)\n\nfontsize (float) – the fontsize. Default is 12.\n\nfontname (str) – the font name. Default is “Helv”. Accepted alternatives are “Cour”, “TiRo”, “ZaDb” and “Symb”. The name may be abbreviated to the first two characters, like “Co” for “Cour”. Lower case is also accepted. Bold or italic variants of the fonts are not accepted (changed in v1.16.0). A user-contributed script provides a circumvention for this restriction – see section Using Buttons and JavaScript in chapter FAQ. The actual font to use is now determined on a by-character level, and all required fonts (or sub-fonts) are automatically included. Therefore, you should rarely ever need to care about this parameter and let it default (except you insist on a serifed font for your non-CJK text parts). (New in v1.17.0)\n\ntext_color (sequence,float) – the text color. Default is black. (New in v1.16.0)\n\nfill_color (sequence,float) – the fill color. Default is white. (New in v1.16.0)\n\ntext_color – the text color. Default is black.\n\nborder_color (sequence,float) – the border color. Default is None. (New in v1.19.6)\n\nalign (int) – text alignment, one of TEXT_ALIGN_LEFT, TEXT_ALIGN_CENTER, TEXT_ALIGN_RIGHT - justify is not supported. (New in v1.17.0)\n\nrotate (int) – the text orientation. Accepted values are 0, 90, 270, invalid entries are set to zero.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. Color properties can only be changed using special parameters of Annot.update(). There, you can also set a border color different from the text color.\n\nShow/hide history\n\nChanged in v1.19.6: add border color parameter\n\nadd_file_annot(pos, buffer, filename, ufilename=None, desc=None, icon='PushPin')#\n\nPDF only: Add a file attachment annotation with a “PushPin” icon at the specified location.\n\nParameters:\n\npos (point_like) – the top-left point of a 18x18 rectangle containing the MuPDF-provided “PushPin” icon.\n\nbuffer (bytes,bytearray,BytesIO) –\n\nthe data to be stored (actual file content, any data, etc.).\n\nChanged in v1.14.13: io.BytesIO is now also supported.\n\nfilename (str) – the filename to associate with the data.\n\nufilename (str) – the optional PDF unicode version of filename. Defaults to filename.\n\ndesc (str) – an optional description of the file. Defaults to filename.\n\nicon (str) – choose one of “PushPin” (default), “Graph”, “Paperclip”, “Tag” as the visual symbol for the attached data . (New in v1.16.0)\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. Stroke color yellow = (1, 1, 0), no fill color support.\n\nadd_ink_annot(list)#\n\nPDF only: Add a “freehand” scribble annotation.\n\nParameters:\n\nlist (sequence) – a list of one or more lists, each containing point_like items. Each item in these sublists is interpreted as a Point through which a connecting line is drawn. Separate sublists thus represent separate drawing lines.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation in default appearance black =(0, 0, 0),line width 1. No fill color support.\n\nadd_line_annot(p1, p2)#\n\nPDF only: Add a line annotation.\n\nParameters:\n\np1 (point_like) – the starting point of the line.\n\np2 (point_like) – the end point of the line.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. It is drawn with line (stroke) color red = (1, 0, 0) and line width 1. No fill color support. The annot rectangle is automatically created to contain both points, each one surrounded by a circle of radius 3 * line width to make room for any line end symbols.\n\nadd_rect_annot(rect)#\n\nadd_circle_annot(rect)#\n\nPDF only: Add a rectangle, resp. circle annotation.\n\nParameters:\n\nrect (rect_like) – the rectangle in which the circle or rectangle is drawn, must be finite and not empty. If the rectangle is not equal-sided, an ellipse is drawn.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. It is drawn with line (stroke) color red = (1, 0, 0), line width 1, fill color is supported.\n\nRedactions#\n\nadd_redact_annot(quad, text=None, fontname=None, fontsize=11, align=TEXT_ALIGN_LEFT, fill=(1, 1, 1), text_color=(0, 0, 0), cross_out=True)#\n\nPDF only: Add a redaction annotation. A redaction annotation identifies content to be removed from the document. Adding such an annotation is the first of two steps. It makes visible what will be removed in the subsequent step, Page.apply_redactions().\n\nParameters:\n\nquad (quad_like,rect_like) – specifies the (rectangular) area to be removed which is always equal to the annotation rectangle. This may be a rect_like or quad_like object. If a quad is specified, then the enveloping rectangle is taken.\n\ntext (str) – text to be placed in the rectangle after applying the redaction (and thus removing old content). (New in v1.16.12)\n\nfontname (str) –\n\nthe font to use when text is given, otherwise ignored. The same rules apply as for Page.insert_textbox() – which is the method Page.apply_redactions() internally invokes. The replacement text will be vertically centered, if this is one of the CJK or PDF Base 14 Fonts. (New in v1.16.12)\n\nNote\n\nFor an existing font of the page, use its reference name as fontname (this is item[4] of its entry in Page.get_fonts()).\n\nFor a new, non-builtin font, proceed as follows:\n\npage.insert_text(point, # anywhere, but outside all redaction rectangles \"something\", # some non-empty string fontname=\"newname\", # new, unused reference name fontfile=\"...\", # desired font file render_mode=3, # makes the text invisible ) page.add_redact_annot(..., fontname=\"newname\")\n\nfontsize (float) – the fontsize to use for the replacing text. If the text is too large to fit, several insertion attempts will be made, gradually reducing the fontsize to no less than 4. If then the text will still not fit, no text insertion will take place at all. (New in v1.16.12)\n\nalign (int) – the horizontal alignment for the replacing text. See insert_textbox() for available values. The vertical alignment is (approximately) centered if a PDF built-in font is used (CJK or PDF Base 14 Fonts). (New in v1.16.12)\n\nfill (sequence) – the fill color of the rectangle after applying the redaction. The default is white = (1, 1, 1), which is also taken if None is specified. To suppress a fill color altogether, specify False. In this cases the rectangle remains transparent. (New in v1.16.12)\n\ntext_color (sequence) – the color of the replacing text. Default is black = (0, 0, 0). (New in v1.16.12)\n\ncross_out (bool) – add two diagonal lines to the annotation rectangle. (New in v1.17.2)\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. Its standard appearance looks like a red rectangle (no fill color), optionally showing two diagonal lines. Colors, line width, dashing, opacity and blend mode can now be set and applied via Annot.update() like with other annotations. (Changed in v1.17.2)\n\nShow/hide history\n\nNew in v1.16.11\n\napply_redactions(images=PDF_REDACT_IMAGE_PIXELS | 2, graphics=PDF_REDACT_LINE_ART_IF_TOUCHED | 2, text=PDF_REDACT_TEXT_REMOVE | 0)#\n\nPDF only: Remove all content contained in any redaction rectangle on the page.\n\nThis method applies and then deletes all redactions from the page.\n\nParameters:\n\nimages (int) – How to redact overlapping images. The default (2) blanks out overlapping pixels. PDF_REDACT_IMAGE_NONE | 0 ignores, and PDF_REDACT_IMAGE_REMOVE | 1 completely removes images overlapping any redaction annotation. Option PDF_REDACT_IMAGE_REMOVE_UNLESS_INVISIBLE | 3 only removes images that are actually visible.\n\ngraphics (int) – How to redact overlapping vector graphics (also called “line-art” or “drawings”). The default (2) removes any overlapping vector graphics. PDF_REDACT_LINE_ART_NONE | 0 ignores, and PDF_REDACT_LINE_ART_IF_COVERED | 1 removes graphics fully contained in a redaction annotation. When removing line-art, please be aware that stroked vector graphics (i.e. type “s” or “sf”) have a larger wrapping rectangle than one might expect: first of all, at least 50% of the path’s line width have to be added in each direction to truly include all of the drawing. If a so-called “miter limit” is provided (see page 121 of the PDF specification), the enlarging value is miter * width / 2. So, when letting everything default (width = 1, miter = 10), the redaction rectangle should be at least 5 points larger in every direction.\n\ntext (int) – Whether to redact overlapping text. The default PDF_REDACT_TEXT_REMOVE | 0 removes all characters whose boundary box overlaps any redaction rectangle. This complies with the original legal / data protection intentions of redaction annotations. Other use cases however may require to keep text while redacting vector graphics or images. This can be achieved by setting text=True|PDF_REDACT_TEXT_NONE | 1. This does not comply with the data protection intentions of redaction annotations. Do so at your own risk.\n\nReturns:\n\nTrue if at least one redaction annotation has been processed, False otherwise.\n\nNote\n\nText contained in a redaction rectangle will be physically removed from the page (assuming Document.save() with a suitable garbage option) and will no longer appear in e.g. text extractions or anywhere else. All redaction annotations will also be removed. Other annotations are unaffected.\n\nAll overlapping links will be removed. If the rectangle of the link was covering text, then only the overlapping part of the text is being removed. Similar applies to images covered by link rectangles.\n\nThe overlapping parts of images will be blanked-out for default option PDF_REDACT_IMAGE_PIXELS (changed in v1.18.0). Option 0 does not touch any images and 1 will remove any image with an overlap.\n\nFor option images=PDF_REDACT_IMAGE_REMOVE only this page’s references to the images are removed - not necessarily the images themselves. Images are completely removed from the file only, if no longer referenced at all (assuming suitable garbage collection options).\n\nFor option images=PDF_REDACT_IMAGE_PIXELS a new image of format PNG is created, which the page will use in place of the original one. The original image is not deleted or replaced as part of this process, so other pages may still show the original. In addition, the new, modified PNG image currently is stored uncompressed. Do keep these aspects in mind when choosing the right garbage collection method and compression options during save.\n\nText removal is done by character: A character is removed if its bbox has a non-empty overlap with a redaction rectangle (changed in MuPDF v1.17). Depending on the font properties and / or the chosen line height, deletion may occur for undesired text parts. Using Tools.set_small_glyph_heights() with a True argument before text search may help to prevent this.\n\nRedactions are a simple way to replace single words in a PDF, or to just physically remove them. Locate the word “secret” using some text extraction or search method and insert a redaction using “xxxxxx” as replacement text for each occurrence.\n\nBe wary if the replacement is longer than the original – this may lead to an awkward appearance, line breaks or no new text at all.\n\nFor a number of reasons, the new text may not exactly be positioned on the same line like the old one – especially true if the replacement font was not one of CJK or PDF Base 14 Fonts.\n\nShow/hide history\n\nNew in v1.16.11\n\nChanged in v1.16.12: The previous mark parameter is gone. Instead, the respective rectangles are filled with the individual fill color of each redaction annotation. If a text was given in the annotation, then insert_textbox() is invoked to insert it, using parameters provided with the redaction.\n\nChanged in v1.18.0: added option for handling images that overlap redaction areas.\n\nChanged in v1.23.27: added option for removing graphics as well.\n\nChanged in v1.24.2: added option keep_text to leave text untouched.\n\nadd_polyline_annot(points)#\n\nadd_polygon_annot(points)#\n\nPDF only: Add an annotation consisting of lines which connect the given points. A Polygon’s first and last points are automatically connected, which does not happen for a PolyLine. The rectangle is automatically created as the smallest rectangle containing the points, each one surrounded by a circle of radius 3 (= 3 * line width). The following shows a ‘PolyLine’ that has been modified with colors and line ends.\n\nParameters:\n\npoints (list) – a list of point_like objects.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe created annotation. It is drawn with line color black, line width 1 no fill color but fill color support. Use methods of Annot to make any changes to achieve something like this:\n\nadd_underline_annot(quads=None, start=None, stop=None, clip=None)#\n\nadd_strikeout_annot(quads=None, start=None, stop=None, clip=None)#\n\nadd_squiggly_annot(quads=None, start=None, stop=None, clip=None)#\n\nadd_highlight_annot(quads=None, start=None, stop=None, clip=None)#\n\nPDF only: These annotations are normally used for marking text which has previously been somehow located (for example via Page.search_for()). But this is not required: you are free to “mark” just anything.\n\nStandard (stroke only – no fill color support) colors are chosen per annotation type: yellow for highlighting, red for striking out, green for underlining, and magenta for wavy underlining.\n\nAll these four methods convert the arguments into a list of Quad objects. The annotation rectangle is then calculated to envelop all these quadrilaterals.\n\nNote\n\nsearch_for() delivers a list of either Rect or Quad objects. Such a list can be directly used as an argument for these annotation types and will deliver one common annotation for all occurrences of the search string:\n\n>>> # prefer quads=True in text searching for annotations! >>> quads = page.search_for(\"pymupdf\", quads=True) >>> page.add_highlight_annot(quads)\n\nNote\n\nObviously, text marker annotations need to know what is the top, the bottom, the left, and the right side of the area(s) to be marked. If the arguments are quads, this information is given by the sequence of the quad points. In contrast, a rectangle delivers much less information – this is illustrated by the fact, that 4! = 24 different quads can be constructed with the four corners of a rectangle.\n\nTherefore, we strongly recommend to use the quads option for text searches, to ensure correct annotations. A similar consideration applies to marking text spans extracted with the “dict” / “rawdict” options of Page.get_text(). For more details on how to compute quadrilaterals in this case, see section “How to Mark Non-horizontal Text” of FAQ.\n\nParameters:\n\nquads (rect_like,quad_like,list,tuple) – the location(s) – rectangle(s) or quad(s) – to be marked. (Changed in v1.14.20) A list or tuple must consist of rect_like or quad_like items (or even a mixture of either). Every item must be finite, convex and not empty (as applicable). Set this parameter to None if you want to use the following arguments (Changed in v1.16.14). And vice versa: if not None, the remaining parameters must be None.\n\nstart (point_like) – start text marking at this point. Defaults to the top-left point of clip. Must be provided if quads is None. (New in v1.16.14)\n\nstop (point_like) – stop text marking at this point. Defaults to the bottom-right point of clip. Must be used if quads is None. (New in v1.16.14)\n\nclip (rect_like) – only consider text lines intersecting this area. Defaults to the page rectangle. Only use if start and stop are provided. (New in v1.16.14)\n\nReturn type:\n\nAnnot or None (changed in v1.16.14).\n\nReturns:\n\nthe created annotation. If quads is an empty list, no annotation is created (changed in v1.16.14).\n\nNote\n\nYou can use parameters start, stop and clip to highlight consecutive lines between the points start and stop (starting with v1.16.14). Make use of clip to further reduce the selected line bboxes and thus deal with e.g. multi-column pages. The following multi-line highlight on a page with three text columns was created by specifying the two red points and setting clip accordingly.\n\ncluster_drawings(clip=None, drawings=None, x_tolerance=3, y_tolerance=3)#\n\nCluster vector graphics (synonyms are line-art or drawings) based on their geometrical vicinity. The method walks through the output of Page.get_drawings() and joins paths whose path[\"rect\"] are closer to each other than some tolerance values (given in the arguments). The result is a list of rectangles that each wrap things like tables (with gridlines), pie charts, bar charts, etc.\n\nParameters:\n\nclip (rect_like) – only consider paths inside this area. The default is the full page.\n\ndrawings (list) – (optional) provide a previously generated output of Page.get_drawings(). If None the method will execute the method.\n\nx_tolerance (float) –\n\nfind_tables(clip=None, strategy=None, vertical_strategy=None, horizontal_strategy=None, vertical_lines=None, horizontal_lines=None, snap_tolerance=None, snap_x_tolerance=None, snap_y_tolerance=None, join_tolerance=None, join_x_tolerance=None, join_y_tolerance=None, edge_min_length=3, min_words_vertical=3, min_words_horizontal=1, intersection_tolerance=None, intersection_x_tolerance=None, intersection_y_tolerance=None, text_tolerance=None, text_x_tolerance=None, text_y_tolerance=None, add_lines=None)#\n\nFind tables on the page and return an object with related information. Typically, the default values of the many parameters will be sufficient. Adjustments should ever only be needed in corner case situations.\n\nParameters:\n\nclip (rect_like) – specify a region to consider within the page rectangle and ignore the rest. Default is the full page.\n\nstrategy (str) –\n\nRequest a table detection strategy. Valid values are “lines”, “lines_strict” and “text”.\n\nDefault is “lines” which uses all vector graphics on the page to detect grid lines.\n\nStrategy “lines_strict” ignores borderless rectangle vector graphics. Sometimes single text pieces have background colors which may lead to false columns or lines. This strategy ignores them and can thus increase detection precision.\n\nIf “text” is specified, text positions are used to generate “virtual” column and / or row boundaries. Use min_words_* to request the number of words for considering their coordinates.\n\nUse parameters vertical_strategy and horizontal_strategy instead for a more fine-grained treatment of the dimensions.\n\nhorizontal_lines (sequence[floats]) – y-coordinates of rows. If provided, there will be no attempt to identify additional table rows. This influences table detection.\n\nvertical_lines (sequence[floats]) – x-coordinates of columns. If provided, there will be no attempt to identify additional table columns. This influences table detection.\n\nmin_words_vertical (int) – relevant for vertical strategy option “text”: at least this many words must coincide to establish a virtual column boundary.\n\nmin_words_horizontal (int) – relevant for horizontal strategy option “text”: at least this many words must coincide to establish a virtual row boundary.\n\nsnap_tolerance (float) – Any two horizontal lines whose y-values differ by no more than this value will be snapped into one. Accordingly for vertical lines. Default is 3. Separate values can be specified instead for the dimensions, using snap_x_tolerance and snap_y_tolerance.\n\njoin_tolerance (float) – Any two lines will be joined to one if the end and the start points differ by no more than this value (in points). Default is 3. Instead of this value, separate values can be specified for the dimensions using join_x_tolerance and join_y_tolerance.\n\nedge_min_length (float) – Ignore a line if its length does not exceed this value (points). Default is 3.\n\nintersection_tolerance (float) – When combining lines into cell borders, orthogonal lines must be within this value (points) to be considered intersecting. Default is 3. Instead of this value, separate values can be specified for the dimensions using intersection_x_tolerance and intersection_y_tolerance.\n\ntext_tolerance (float) – Characters will be combined into words only if their distance is no larger than this value (points). Default is 3. Instead of this value, separate values can be specified for the dimensions using text_x_tolerance and text_y_tolerance.\n\nadd_lines (tuple,list) – Specify a list of “lines” (i.e. pairs of point_like objects) as additional, “virtual” vector graphics. These lines may help with table and / or cell detection and will not otherwise influence the detection strategy. Especially, in contrast to parameters horizontal_lines and vertical_lines, they will not prevent detecting rows or columns in other ways. These lines will be treated exactly like “real” vector graphics in terms of joining, snapping, intersectiing, minimum length and containment in the clip rectangle. Similarly, lines not parallel to any of the coordinate axes will be ignored.\n\nReturns:\n\na TableFinder object that has the following significant attributes:\n\ncells: a list of all bboxes on the page, that have been identified as table cells (across all tables). Each cell is a rect_like tuple (x0, y0, x1, y1) of coordinates or None.\n\ntables: a list of Table objects. This is [] if the page has no tables. Single tables can be found as items of this list. But the TableFinder object itself is also a sequence of its tables. This means that if tabs is a TableFinder object, then table “n” is delivered by tabs.tables[n] as well as by the shorter tabs[n].\n\nThe Table object has the following attributes:\n\nbbox: the bounding box of the table as a tuple (x0, y0, x1, y1).\n\ncells: bounding boxes of the table’s cells (list of tuples). A cell may also be None.\n\nextract(): this method returns the text content of each table cell as a list of list of strings.\n\nto_markdown(): this method returns the table as a string in markdown format (compatible to Github). Supporting viewers can render the string as a table. This output is optimized for small token sizes, which is especially beneficial for LLM/RAG feeds. Pandas DataFrames (see method to_pandas() below) offer an equivalent markdown table output which however is better readable for the human eye.\n\nto_pandas(): this method returns the table as a pandas DataFrame. DataFrames are very versatile objects allowing a plethora of table manipulation methods and outputs to almost 20 well-known formats, among them Excel files, CSV, JSON, markdown-formatted tables and more. DataFrame.to_markdown() generates a Github-compatible markdown format optimized for human readability. This method however requires the package [tablutate](https://pypi.org/project/tabulate/) to installed in addition to pandas itself.\n\nheader: a TableHeader object containing header information of the table.\n\ncol_count: an integer containing the number of table columns.\n\nrow_count: an integer containing the number of table rows.\n\nrows: a list of TableRow objects containing two attributes, bbox is the boundary box of the row, and cells is a list of table cells contained in this row.\n\nThe TableHeader object has the following attributes:\n\nbbox: the bounding box of the header.\n\ncells: a list of bounding boxes containing the name of the respective column.\n\nnames: a list of strings containing the text of each of the cell bboxes. They represent the column names – which are used when exporting the table to pandas DataFrames, markdown, etc.\n\nexternal: a bool indicating whether the header bbox is outside the table body (True) or not. Table headers are never identified by the TableFinder logic. Therefore, if external is true, then the header cells are not part of any cell identified by TableFinder. If external == False, then the first table row is the header.\n\nPlease have a look at these Jupyter notebooks, which cover standard situations like multiple tables on one page or joining table fragments across multiple pages.\n\nShow/hide history\n\nNew in version 1.23.0\n\nChanged in version 1.23.19: new argument add_lines.\n\nImportant\n\nThere is also the pdf2docx extract tables method which is capable of table extraction if you prefer.\n\nadd_stamp_annot(rect, stamp=0)#\n\nPDF only: Add a “rubber stamp” like annotation to e.g. indicate the document’s intended use (“DRAFT”, “CONFIDENTIAL”, etc.).\n\nParameters:\n\nrect (rect_like) – rectangle where to place the annotation.\n\nstamp (int) – id number of the stamp text. For available stamps see Stamp Annotation Icons.\n\nNote\n\nThe stamp’s text and its border line will automatically be sized and be put horizontally and vertically centered in the given rectangle. Annot.rect is automatically calculated to fit the given width and will usually be smaller than this parameter.\n\nThe font chosen is “Times Bold” and the text will be upper case.\n\nThe appearance can be changed using Annot.set_opacity() and by setting the “stroke” color (no “fill” color supported).\n\nThis can be used to create watermark images: on a temporary PDF page create a stamp annotation with a low opacity value, make a pixmap from it with alpha=True (and potentially also rotate it), discard the temporary PDF page and use the pixmap with insert_image() for your target PDF.\n\nadd_widget(widget)#\n\nPDF only: Add a PDF Form field (“widget”) to a page. This also turns the PDF into a Form PDF. Because of the large amount of different options available for widgets, we have developed a new class Widget, which contains the possible PDF field attributes. It must be used for both, form field creation and updates.\n\nParameters:\n\nwidget (Widget) – a Widget object which must have been created upfront.\n\nReturns:\n\na widget annotation.\n\ndelete_annot(annot)#\n\nThe removal will now include any bound ‘Popup’ or response annotations and related objects (changed in v1.16.6).\n\nPDF only: Delete annotation from the page and return the next one.\n\nParameters:\n\nannot (Annot) – the annotation to be deleted.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe annotation following the deleted one. Please remember that physical removal requires saving to a new file with garbage > 0.\n\ndelete_widget(widget)#\n\nPDF only: Delete field from the page and return the next one.\n\nParameters:\n\nwidget (Widget) – the widget to be deleted.\n\nReturn type:\n\nWidget\n\nReturns:\n\nthe widget following the deleted one. Please remember that physical removal requires saving to a new file with garbage > 0.\n\nShow/hide history\n\n(New in v1.18.4)\n\ndelete_link(linkdict)#\n\nPDF only: Delete the specified link from the page. The parameter must be an original item of get_links(), see Description of get_links() Entries. The reason for this is the dictionary’s “xref” key, which identifies the PDF object to be deleted.\n\nParameters:\n\nlinkdict (dict) – the link to be deleted.\n\ninsert_link(linkdict)#\n\nPDF only: Insert a new link on this page. The parameter must be a dictionary of format as provided by get_links(), see Description of get_links() Entries.\n\nParameters:\n\nlinkdict (dict) – the link to be inserted.\n\nPDF only: Modify the specified link. The parameter must be a (modified) original item of get_links(), see Description of get_links() Entries. The reason for this is the dictionary’s “xref” key, which identifies the PDF object to be changed.\n\nParameters:\n\nlinkdict (dict) – the link to be modified.\n\nWarning\n\nIf updating / inserting a URI link (\"kind\": LINK_URI), please make sure to start the value for the \"uri\" key with a disambiguating string like \"http://\", \"https://\", \"file://\", \"ftp://\", \"mailto:\", etc. Otherwise – depending on your browser or other “consumer” software – unexpected default assumptions may lead to unwanted behaviours.\n\nget_label()#\n\nPDF only: Return the label for the page.\n\nReturn type:\n\nstr\n\nReturns:\n\nthe label string like “vii” for Roman numbering or “” if not defined.\n\nShow/hide history\n\nNew in v1.18.6\n\nRetrieves all links of a page.\n\nReturn type:\n\nlist\n\nReturns:\n\nA list of dictionaries. For a description of the dictionary entries, see Description of get_links() Entries. Always use this or the Page.links() method if you intend to make changes to the links of a page.\n\nReturn a generator over the page’s links. The results equal the entries of Page.get_links().\n\nParameters:\n\nkinds (sequence) – a sequence of integers to down-select to one or more link kinds. Default is all links. Example: kinds=(pymupdf.LINK_GOTO,) will only return internal links.\n\nReturn type:\n\ngenerator\n\nReturns:\n\nan entry of Page.get_links() for each iteration.\n\nShow/hide history\n\nNew in v1.16.4\n\nannots(types=None)#\n\nReturn a generator over the page’s annotations.\n\nParameters:\n\ntypes (sequence) – a sequence of integers to down-select to one or more annotation types. Default is all annotations. Example: types=(pymupdf.PDF_ANNOT_FREETEXT, pymupdf.PDF_ANNOT_TEXT) will only return ‘FreeText’ and ‘Text’ annotations.\n\nReturn type:\n\ngenerator\n\nReturns:\n\nan Annot for each iteration.\n\nCaution\n\nYou cannot safely update annotations from within this generator. This is because most annotation updates require reloading the page via page = doc.reload_page(page). To circumvent this restriction, make a list of annotations xref numbers first and then iterate over these numbers:\n\nIn [4]: xrefs = [annot.xref for annot in page.annots(types=[...])] In [5]: for xref in xrefs: ...: annot = page.load_annot(xref) ...: annot.update() ...: page = doc.reload_page(page) In [6]:\n\nShow/hide history\n\nNew in v1.16.4\n\nwidgets(types=None)#\n\nReturn a generator over the page’s form fields.\n\nParameters:\n\ntypes (sequence) – a sequence of integers to down-select to one or more widget types. Default is all form fields. Example: types=(pymupdf.PDF_WIDGET_TYPE_TEXT,) will only return ‘Text’ fields.\n\nReturn type:\n\ngenerator\n\nReturns:\n\na Widget for each iteration.\n\nShow/hide history\n\nNew in v1.16.4\n\nwrite_text(rect=None, writers=None, overlay=True, color=None, opacity=None, keep_proportion=True, rotate=0, oc=0)#\n\nPDF only: Write the text of one or more TextWriter objects to the page.\n\nParameters:\n\nrect (rect_like) – where to place the text. If omitted, the rectangle union of the text writers is used.\n\nwriters (sequence) – a non-empty tuple / list of TextWriter objects or a single TextWriter.\n\nopacity (float) – set transparency, overwrites resp. value in the text writers.\n\ncolor (sequ) – set the text color, overwrites resp. value in the text writers.\n\noverlay (bool) – put the text in foreground or background.\n\nkeep_proportion (bool) – maintain the aspect ratio.\n\nrotate (float) – rotate the text by an arbitrary angle.\n\noc (int) – the xref of an OCG or OCMD. (New in v1.18.4)\n\nNote\n\nParameters overlay, keep_proportion, rotate and oc have the same meaning as in Page.show_pdf_page().\n\nShow/hide history\n\nNew in v1.16.18\n\ninsert_text(point, text, fontsize=11, fontname='helv', fontfile=None, idx=0, color=None, fill=None, render_mode=0, border_width=1, encoding=TEXT_ENCODING_LATIN, rotate=0, morph=None, stroke_opacity=1, fill_opacity=1, overlay=True, oc=0)#\n\nPDF only: Insert text starting at point_like point. See Shape.insert_text().\n\nShow/hide history\n\nChanged in v1.18.4\n\ninsert_textbox(rect, buffer, fontsize=11, fontname='helv', fontfile=None, idx=0, color=None, fill=None, render_mode=0, border_width=1, encoding=TEXT_ENCODING_LATIN, expandtabs=8, align=TEXT_ALIGN_LEFT, charwidths=None, rotate=0, morph=None, stroke_opacity=1, fill_opacity=1, oc=0, overlay=True)#\n\nPDF only: Insert text into the specified rect_like rect. See Shape.insert_textbox().\n\nShow/hide history\n\nChanged in v1.18.4\n\ninsert_htmlbox(rect, text, *, css=None, scale_low=0, archive=None, rotate=0, oc=0, opacity=1, overlay=True)#\n\nPDF only: Insert text into the specified rectangle. The method has similarities with methods Page.insert_textbox() and TextWriter.fill_textbox(), but is much more powerful. This is achieved by letting a Story object do all the required processing.\n\nParameter text may be a string as in the other methods. But it will be interpreted as HTML source and may therefore also contain HTML language elements – including styling. The css parameter may be used to pass in additional styling instructions.\n\nAutomatic line breaks are generated at word boundaries. The “soft hyphen” character \"&#173;\" (or &shy;) can be used to cause hyphenation and thus may also cause line breaks. Forced line breaks however are only achievable via the HTML tag <br> - \"\\n\" is ignored and will be treated like a space.\n\nWith this method the following can be achieved:\n\nStyling effects like bold, italic, text color, text alignment, font size or font switching.\n\nThe text may include arbitrary languages – including right-to-left languages.\n\nScripts like Devanagari and several others in Asia have a highly complex system of ligatures, where two or more unicodes together yield one glyph. The Story uses the software package HarfBuzz , to deal with these things and produce correct output.\n\nOne can also include images via HTML tag <img> – the Story will take care of the appropriate layout. This is an alternative option to insert images, compared to Page.insert_image().\n\nHTML tables (tag <table>) may be included in the text and will be handled appropriately.\n\nLinks are automatically generated when present.\n\nIf content does not fit in the rectangle, the developer has two choices:\n\neither only be informed about this (and accept a no-op, just like with the other textbox insertion methods),\n\nor (scale_low=0 - the default) scale down the content until it fits.\n\nParameters:\n\nrect (rect_like) – rectangle on page to receive the text.\n\ntext (str,Story) – the text to be written. Can contain a mixture of plain text and HTML tags with styling instructions. Alternatively, a Story object may be specified (in which case the internal Story generation step will be omitted). A Story must have been generated with all required styling and Archive information.\n\ncss (str) – optional string containing additional CSS instructions. This parameter is ignored if text is a Story.\n\nscale_low (float) – if necessary, scale down the content until it fits in the target rectangle. This sets the down scaling limit. Default is 0, no limit. A value of 1 means no down-scaling permitted. A value of e.g. 0.2 means maximum down-scaling by 80%.\n\narchive (Archive) – an Archive object that points to locations where to find images or non-standard fonts. If text refers to images or non-standard fonts, this parameter is required. This parameter is ignored if text is a Story.\n\nrotate (int) –\n\none of the values 0, 90, 180, 270. Depending on this, text will be filled:\n\n0: top-left to bottom-right.\n\n90: bottom-left to top-right.\n\n180: bottom-right to top-left.\n\n270: top-right to bottom-left.\n\noc (int) – the xref of an OCG / OCMD or 0. Please refer to Page.show_pdf_page() for details.\n\nopacity (float) – set the fill and stroke opacity of the content. Only values 0 <= opacity < 1 are considered.\n\noverlay (bool) – put the text in front of other content. Please refer to Page.show_pdf_page() for details.\n\nReturns:\n\nA tuple of floats (spare_height, scale).\n\nspare_height: -1 if content did not fit, else >= 0. It is the height of the unused (still available) rectangle stripe. Positive only if scale = 1 (no down-scaling happened).\n\nscale: down-scaling factor, 0 < scale <= 1.\n\nPlease refer to examples in this section of the recipes: How to Fill a Box with HTML Text.\n\nShow/hide history\n\nNew in v1.23.8; rebased-only.\n\nNew in v1.23.9: opacity parameter.\n\nDrawing Methods\n\ndraw_line(p1, p2, color=(0,), width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)#\n\nPDF only: Draw a line from p1 to p2 (point_like s). See Shape.draw_line().\n\nShow/hide history\n\nChanged in v1.18.4\n\ndraw_zigzag(p1, p2, breadth=2, color=(0,), width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)#\n\nPDF only: Draw a zigzag line from p1 to p2 (point_like s). See Shape.draw_zigzag().\n\nShow/hide history\n\nChanged in v1.18.4\n\ndraw_squiggle(p1, p2, breadth=2, color=(0,), width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)#\n\nPDF only: Draw a squiggly (wavy, undulated) line from p1 to p2 (point_like s). See Shape.draw_squiggle().\n\nShow/hide history\n\nChanged in v1.18.4\n\ndraw_circle(center, radius, color=(0,), fill=None, width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)#\n\nPDF only: Draw a circle around center (point_like) with a radius of radius. See Shape.draw_circle().\n\nShow/hide history\n\nChanged in v1.18.4\n\ndraw_curve(p1, p2, p3, color=(0,), fill=None, width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, closePath=False, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)#\n\nPDF only: This is a special case of draw_bezier(). See Shape.draw_curve().\n\nShow/hide history\n\nChanged in v1.18.4\n\ndraw_rect(rect, color=(0,), fill=None, width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, morph=None, stroke_opacity=1, fill_opacity=1, radius=None, oc=0)#\n\nPDF only: Draw a rectangle. See Shape.draw_rect().\n\nShow/hide history\n\nChanged in v1.18.4\n\nChanged in v1.22.0: Added parameter radius.\n\ndraw_quad(quad, color=(0,), fill=None, width=1, dashes=None, lineCap=0, lineJoin=0, overlay=True, morph=None, stroke_opacity=1, fill_opacity=1, oc=0)#\n\nPDF only: Draw a quadrilateral. See Shape.draw_quad().\n\nShow/hide history\n\nChanged in v1.18.4\n\ninsert_font(fontname='helv', fontfile=None, fontbuffer=None, set_simple=False, encoding=TEXT_ENCODING_LATIN)#\n\nPDF only: Add a new font to be used by text output methods and return its xref. If not already present in the file, the font definition will be added. Supported are the built-in Base14_Fonts and the CJK fonts via “reserved” fontnames. Fonts can also be provided as a file path or a memory area containing the image of a font file.\n\nParameters:\n\nfontname (str) –\n\nThe name by which this font shall be referenced when outputting text on this page. In general, you have a “free” choice here (but consult the Adobe PDF References, page 16, section 7.3.5 for a formal description of building legal PDF names). However, if it matches one of the Base14_Fonts or one of the CJK fonts, fontfile and fontbuffer are ignored.\n\nIn other words, you cannot insert a font via fontfile / fontbuffer and also give it a reserved fontname.\n\nNote\n\nA reserved fontname can be specified in any mixture of upper or lower case and still match the right built-in font definition: fontnames “helv”, “Helv”, “HELV”, “Helvetica”, etc. all lead to the same font definition “Helvetica”. But from a Page perspective, these are different references. You can exploit this fact when using different encoding variants (Latin, Greek, Cyrillic) of the same font on a page.\n\nfontfile (str) – a path to a font file. If used, fontname must be different from all reserved names.\n\nfontbuffer (bytes/bytearray) – the memory image of a font file. If used, fontname must be different from all reserved names. This parameter would typically be used with Font.buffer for fonts supported / available via Font.\n\nset_simple (int) – applicable for fontfile / fontbuffer cases only: enforce treatment as a “simple” font, i.e. one that only uses character codes up to 255.\n\nencoding (int) – applicable for the “Helvetica”, “Courier” and “Times” sets of Base14_Fonts only. Select one of the available encodings Latin (0), Cyrillic (2) or Greek (1). Only use the default (0 = Latin) for “Symbol” and “ZapfDingBats”.\n\nRytpe:\n\nint\n\nReturns:\n\nthe xref of the installed font.\n\nNote\n\nBuilt-in fonts will not lead to the inclusion of a font file. So the resulting PDF file will remain small. However, your PDF viewer software is responsible for generating an appropriate appearance – and there exist differences on whether or how each one of them does this. This is especially true for the CJK fonts. But also Symbol and ZapfDingbats are incorrectly handled in some cases. Following are the Font Names and their correspondingly installed Base Font names:\n\nBase-14 Fonts\n\nFont Name\n\nInstalled Base Font\n\nComments\n\nhelv\n\nHelvetica\n\nnormal\n\nheit\n\nHelvetica-Oblique\n\nitalic\n\nhebo\n\nHelvetica-Bold\n\nbold\n\nhebi\n\nHelvetica-BoldOblique\n\nbold-italic\n\ncour\n\nCourier\n\nnormal\n\ncoit\n\nCourier-Oblique\n\nitalic\n\ncobo\n\nCourier-Bold\n\nbold\n\ncobi\n\nCourier-BoldOblique\n\nbold-italic\n\ntiro\n\nTimes-Roman\n\nnormal\n\ntiit\n\nTimes-Italic\n\nitalic\n\ntibo\n\nTimes-Bold\n\nbold\n\ntibi\n\nTimes-BoldItalic\n\nbold-italic\n\nsymb\n\nSymbol\n\nzadb\n\nZapfDingbats\n\nCJK Fonts (China, Japan, Korea)\n\nFont Name\n\nInstalled Base Font\n\nComments\n\nchina-s\n\nHeiti\n\nsimplified Chinese\n\nchina-ss\n\nSong\n\nsimplified Chinese (serif)\n\nchina-t\n\nFangti\n\ntraditional Chinese\n\nchina-ts\n\nMing\n\ntraditional Chinese (serif)\n\njapan\n\nGothic\n\nJapanese\n\njapan-s\n\nMincho\n\nJapanese (serif)\n\nkorea\n\nDotum\n\nKorean\n\nkorea-s\n\nBatang\n\nKorean (serif)\n\ninsert_image(rect, *, alpha=-1, filename=None, height=0, keep_proportion=True, mask=None, oc=0, overlay=True, pixmap=None, rotate=0, stream=None, width=0, xref=0)#\n\nPDF only: Put an image inside the given rectangle. The image may already exist in the PDF or be taken from a pixmap, a file, or a memory area.\n\nParameters:\n\nrect (rect_like) – where to put the image. Must be finite and not empty.\n\nalpha (int) – deprecated and ignored.\n\nfilename (str) – name of an image file (all formats supported by MuPDF – see Supported Input Image Formats).\n\nheight (int) –\n\nkeep_proportion (bool) – maintain the aspect ratio of the image.\n\nmask (bytes,bytearray,io.BytesIO) – image in memory – to be used as image mask (alpha values) for the base image. When specified, the base image must be provided as a filename or a stream – and must not be an image that already has a mask.\n\noc (int) – (xref) make image visibility dependent on this OCG or OCMD. Ignored after the first of multiple insertions. The property is stored with the generated PDF image object and therefore controls the image’s visibility throughout the PDF.\n\noverlay – see Common Parameters.\n\npixmap (Pixmap) – a pixmap containing the image.\n\nrotate (int) – rotate the image. Must be an integer multiple of 90 degrees. Positive values rotate anti-clockwise. If you need a rotation by an arbitrary angle, consider converting the image to a PDF (Document.convert_to_pdf()) first and then use Page.show_pdf_page() instead.\n\nstream (bytes,bytearray,io.BytesIO) – image in memory (all formats supported by MuPDF – see Supported Input Image Formats).\n\nwidth (int) –\n\nxref (int) – the xref of an image already present in the PDF. If given, parameters filename, Pixmap, stream, alpha and mask are ignored. The page will simply receive a reference to the existing image.\n\nReturns:\n\nThe xref of the embedded image. This can be used as the xref argument for very significant performance boosts, if the image is inserted again.\n\nThis example puts the same image on every page of a document:\n\n>>> doc = pymupdf.open(...) >>> rect = pymupdf.Rect(0, 0, 50, 50) # put thumbnail in upper left corner >>> img = open(\"some.jpg\", \"rb\").read() # an image file >>> img_xref = 0 # first execution embeds the image >>> for page in doc: img_xref = page.insert_image(rect, stream=img, xref=img_xref, 2nd time reuses existing image ) >>> doc.save(...)\n\nNote\n\nThe method detects multiple insertions of the same image (like in the above example) and will store its data only on the first execution. This is even true (although less performant), if using the default xref=0.\n\nThe method cannot detect if the same image had already been part of the file before opening it.\n\nYou can use this method to provide a background or foreground image for the page, like a copyright or a watermark. Please remember, that watermarks require a transparent image if put in foreground …\n\nThe image may be inserted uncompressed, e.g. if a Pixmap is used or if the image has an alpha channel. Therefore, consider using deflate=True when saving the file. In addition, there are ways to control the image size – even if transparency comes into play. Have a look at How to Add Images to a PDF Page.\n\nThe image is stored in the PDF at its original quality level. This may be much better than what you need for your display. Consider decreasing the image size before insertion – e.g. by using the pixmap option and then shrinking it or scaling it down (see Pixmap chapter). The PIL method Image.thumbnail() can also be used for that purpose. The file size savings can be very significant.\n\nAnother efficient way to display the same image on multiple pages is another method: show_pdf_page(). Consult Document.convert_to_pdf() for how to obtain intermediary PDFs usable for that method.\n\nShow/hide history\n\nChanged in v1.14.1: By default, the image keeps its aspect ratio.\n\nChanged in v1.14.11: Added args keep_proportion, rotate.\n\nChanged in v1.14.13:\n\nThe image is now always placed centered in the rectangle, i.e. the centers of image and rectangle are equal.\n\nAdded support for stream as io.BytesIO.\n\nChanged in v1.17.6: Insertion rectangle no longer needs to have a non-empty intersection with the page’s Page.cropbox .\n\nChanged in v1.18.1: Added mask arg.\n\nChanged in v1.18.3: Added oc arg.\n\nChanged in v1.18.13:\n\nAllow providing the image as the xref of an existing one.\n\nAdded xref arg.\n\nReturn xref of stored image.\n\nChanged in v1.19.3: deprecate and ignore alpha arg.\n\nreplace_image(xref, filename=None, pixmap=None, stream=None)#\n\nReplace the image at xref with another one.\n\nParameters:\n\nxref (int) – the xref of the image.\n\nfilename – the filename of the new image.\n\npixmap – the Pixmap of the new image.\n\nstream – the memory area containing the new image.\n\nArguments filename, Pixmap, stream have the same meaning as in Page.insert_image(), especially exactly one of these must be provided.\n\nThis is a global replacement: the new image will also be shown wherever the old one has been displayed throughout the file.\n\nThis method mainly exists for technical purposes. Typical uses include replacing large images by smaller versions, like a lower resolution, graylevel instead of colored, etc., or changing transparency.\n\nShow/hide history\n\nNew in v1.21.0\n\ndelete_image(xref)#\n\nDelete the image at xref. This is slightly misleading: actually the image is being replaced with a small transparent Pixmap using above Page.replace_image(). The visible effect however is equivalent.\n\nParameters:\n\nxref (int) – the xref of the image.\n\nThis is a global replacement: the image will disappear wherever the old one has been displayed throughout the file.\n\nIf you inspect / extract a page’s images by methods like Page.get_images(), Page.get_image_info() or Page.get_text(), the replacing “dummy” image will be detected like so (45, 47, 1, 1, 8, 'DeviceGray', '', 'Im1', 'FlateDecode') and also seem to “cover” the same boundary box on the page.\n\nShow/hide history\n\nNew in v1.21.0\n\nget_text(option, *, clip=None, flags=None, textpage=None, sort=False, delimiters=None)#\n\nRetrieves the content of a page in a variety of formats. This is a wrapper for multiple TextPage methods by choosing the output option opt as follows:\n\n“text” – TextPage.extractTEXT(), default\n\n“blocks” – TextPage.extractBLOCKS()\n\n“words” – TextPage.extractWORDS()\n\n“html” – TextPage.extractHTML()\n\n“xhtml” – TextPage.extractXHTML()\n\n“xml” – TextPage.extractXML()\n\n“dict” – TextPage.extractDICT()\n\n“json” – TextPage.extractJSON()\n\n“rawdict” – TextPage.extractRAWDICT()\n\n“rawjson” – TextPage.extractRAWJSON()\n\nParameters:\n\nopt (str) –\n\nA string indicating the requested format, one of the above. A mixture of upper and lower case is supported.\n\nValues “words” and “blocks” are also accepted (changed in v1.16.3).\n\nclip (rect-like) – restrict extracted text to this rectangle. If None, the full page is taken. Has no effect for options “html”, “xhtml” and “xml”. (New in v1.17.7)\n\nflags (int) – indicator bits to control whether to include images or how text should be handled with respect to white spaces and ligatures. See Text Extraction Flags for available indicators and Text Extraction Flags Defaults for default settings. (New in v1.16.2)\n\ntextpage – use a previously created TextPage. This reduces execution time very significantly: by more than 50% and up to 95%, depending on the extraction option. If specified, the ‘flags’ and ‘clip’ arguments are ignored, because they are textpage-only properties. If omitted, a new, temporary textpage will be created. (New in v1.19.0)\n\nsort (bool) – sort the output by vertical, then horizontal coordinates. In many cases, this should suffice to generate a “natural” reading order. Has no effect on (X)HTML and XML. Output option “words” sorts by (y1, x0) of the words’ bboxes. Similar is true for “blocks”, “dict”, “json”, “rawdict”, “rawjson”: they all are sorted by (y1, x0) of the resp. block bbox. If specified for “text”, then internally “blocks” is used. (New in v1.19.1)\n\ndelimiters (str) – use these characters as additional word separators with the “words” output option (ignored otherwise). By default, all white spaces (including non-breaking space 0xA0) indicate start and end of a word. Now you can specify more characters causing this. For instance, the default will return \"john.doe@outlook.com\" as one word. If you specify delimiters=\"@.\" then the four words \"john\", \"doe\", \"outlook\", \"com\" will be returned. Other possible uses include ignoring punctuation characters delimiters=string.punctuation. The “word” strings will not contain any delimiting character. (New in v1.23.5)\n\nReturn type:\n\nstr, list, dict\n\nReturns:\n\nThe page’s content as a string, a list or a dictionary. Refer to the corresponding TextPage method for details.\n\nNote\n\nYou can use this method as a document conversion tool from any supported document type to one of TEXT, HTML, XHTML or XML documents.\n\nThe inclusion of text via the clip parameter is decided on a by-character level: a character becomes part of the output, if its bbox is contained in clip (changed in v1.18.2). This deviates from the algorithm used in redaction annotations: a character will be removed if its bbox intersects any redaction annotation.\n\nShow/hide history\n\nChanged in v1.19.0: added TextPage parameter\n\nChanged in v1.19.1: added sort parameter\n\nChanged in v1.19.6: added new constants for defining default flags per method.\n\nChanged in v1.23.5: added delimiters parameter\n\nget_textbox(rect, textpage=None)#\n\nRetrieve the text contained in a rectangle.\n\nParameters:\n\nrect (rect-like) – rect-like.\n\ntextpage – a TextPage to use. If omitted, a new, temporary textpage will be created.\n\nReturns:\n\na string with interspersed linebreaks where necessary. It is based on dedicated code (changed in v1.19.0). A typical use is checking the result of Page.search_for():\n\n>>> rl = page.search_for(\"currency:\") >>> page.get_textbox(rl[0]) 'Currency:' >>>\n\nShow/hide history\n\nNew in v1.17.7\n\nChanged in v1.19.0: add TextPage parameter\n\nget_textpage(clip=None, flags=3)#\n\nCreate a TextPage for the page.\n\nParameters:\n\nflags (int) – indicator bits controlling the content available for subsequent text extractions and searches – see the parameter of Page.get_text().\n\nclip (rect-like) – restrict extracted text to this area. (New in v1.17.7)\n\nReturns:\n\nTextPage\n\nShow/hide history\n\nNew in v1.16.5\n\nChanged in v1.17.7: introduced clip parameter.\n\nget_textpage_ocr(flags=3, language='eng', dpi=72, full=False, tessdata=None)#\n\nOptical Character Recognition (OCR) technology can be used to extract text data for documents where text is in a raster image format throughout the page. Use this method to OCR a page for text extraction.\n\nThis method returns a TextPage for the page that includes OCRed text. MuPDF will invoke Tesseract-OCR if this method is used. Otherwise this is a normal TextPage object.\n\nParameters:\n\nflags (int) – indicator bits controlling the content available for subsequent test extractions and searches – see the parameter of Page.get_text().\n\nlanguage (str) – the expected language(s). Use “+”-separated values if multiple languages are expected, “eng+spa” for English and Spanish.\n\ndpi (int) – the desired resolution in dots per inch. Influences recognition quality (and execution time).\n\nfull (bool) – whether to OCR the full page, or just the displayed images.\n\ntessdata (str) – The name of Tesseract’s language support folder tessdata. If omitted, this information must be present as environment variable TESSDATA_PREFIX. Can be determined by function get_tessdata().\n\nNote\n\nThis method does not support a clip parameter – OCR will always happen for the complete page rectangle.\n\nReturns:\n\na TextPage. Execution may be significantly longer than Page.get_textpage().\n\nFor a full page OCR, all text will have the font “GlyphlessFont” from Tesseract. In case of partial OCR, normal text will keep its properties, and only text coming from images will have the GlyphlessFont.\n\nNote\n\nOCRed text is only available to PyMuPDF’s text extractions and searches if their TextPage parameter specifies the output of this method.\n\nThis Jupyter notebook walks through an example for using OCR textpages.\n\nShow/hide history\n\nNew in v.1.19.0\n\nChanged in v1.19.1: support full and partial OCRing a page.\n\nget_drawings(extended=False)#\n\nReturn the vector graphics of the page. These are instructions which draw lines, rectangles, quadruples or curves, including properties like colors, transparency, line width and dashing, etc. Alternative terms are “line art” and “drawings”.\n\nReturns:\n\na list of dictionaries. Each dictionary item contains one or more single draw commands belonging together: they have the same properties (colors, dashing, etc.). This is called a “path” in PDF, so we adopted that name here, but the method works for all document types.\n\nThe path dictionary for fill, stroke and fill-stroke paths has been designed to be compatible with class Shape. There are the following keys:\n\nKey\n\nValue\n\nKey \"opacity\" has been replaced by the new keys \"fill_opacity\" and \"stroke_opacity\". This is now compatible with the corresponding parameters of Shape.finish(). (Changed in v1.18.17)\n\nFor paths other than groups or clips, key \"type\" takes one of the following values:\n\n“f” – this is a fill-only path. Only key-values relevant for this operation have a meaning, not applicable ones are present with a value of None: \"color\", \"lineCap\", \"lineJoin\", \"width\", \"closePath\", \"dashes\" and should be ignored.\n\n“s” – this is a stroke-only path. Similar to previous, key \"fill\" is present with value None.\n\n“fs” – this is a path performing combined fill and stroke operations.\n\nEach item in path[\"items\"] is one of the following:\n\n(\"l\", p1, p2) - a line from p1 to p2 (Point objects).\n\n(\"c\", p1, p2, p3, p4) - cubic Bézier curve from p1 to p4 (p2 and p3 are the control points). All objects are of type Point.\n\n(\"re\", rect, orientation) - a Rect. Multiple rectangles within the same path are now detected (changed in v1.18.17). Integer orientation is 1 resp. -1 indicating whether the enclosed area is rotated left (1 = anti-clockwise), or resp. right (changed in v1.19.2).\n\n(\"qu\", quad) - a Quad. 3 or 4 consecutive lines are detected to actually represent a Quad (changed in v1.19.2:). (New in v1.18.17)\n\nUsing class Shape, you should be able to recreate the original drawings on a separate (PDF) page with high fidelity under normal, not too sophisticated circumstances. Please see the following comments on restrictions. A coding draft can be found in section “Extractings Drawings” of chapter FAQ.\n\nSpecifying extended=True significantly alters the output. Most importantly, new dictionary types are present: “clip” and “group”. All paths will now be organized in a hierarchic structure which is encoded by the new integer key “level”, the hierarchy level. Each group or clip establishes a new hierarchy, which applies to all subsequent paths having a larger level value. (New in v1.22.0)\n\nAny path with a smaller level value than its predecessor will end the scope of (at least) the preceding hierarchy level. A “clip” path with the same level as the preceding clip will end the scope of that clip. Same is true for groups. This is best explained by an example:\n\n+------+------+--------+------+--------+ | line | lvl0 | lvl1 | lvl2 | lvl3 | +------+------+--------+------+--------+ | 0 | clip | | | | | 1 | | fill | | | | 2 | | group | | | | 3 | | | clip | | | 4 | | | | stroke | | 5 | | | fill | | ends scope of clip in line 3 | 6 | | stroke | | | ends scope of group in line 2 | 7 | | clip | | | | 8 | fill | | | | ends scope of line 0 +------+------+--------+------+--------+\n\nThe clip in line 0 applies to line including line 7. Group in line 2 applies to lines 3 to 5, clip in line 3 only applies to line 4.\n\n“stroke” in line 4 is under control of “group” in line 2 and “clip” in line 3 (which in turn is a subset of line 0 clip).\n\n“clip” dictionary. Its values (most importantly “scissor”) remain valid / apply as long as following dictionaries have a larger “level” value.\n\nKey\n\nValue\n\n“group” dictionary. Its values remain valid (apply) as long as following dictionaries have a larger “level” value. Any dictionary with an equal or lower level end this group.\n\nKey\n\nValue\n\nNote\n\nThe method is based on the output of Page.get_cdrawings() – which is much faster, but requires somewhat more attention processing its output.\n\nShow/hide history\n\nNew in v1.18.0\n\nChanged in v1.18.17\n\nChanged in v1.19.0: add “seqno” key, remove “clippings” key\n\nChanged in v1.19.1: “color” / “fill” keys now always are either are RGB tuples or None. This resolves issues caused by exotic colorspaces.\n\nChanged in v1.19.2: add an indicator for the “orientation” of the area covered by an “re” item.\n\nChanged in v1.22.0: add new key \"layer\" which contains the name of the Optional Content Group of the path (or None).\n\nChanged in v1.22.0: add parameter extended to also return clipping and group paths.\n\nget_cdrawings(extended=False)#\n\nExtract the vector graphics on the page. Apart from following technical differences, functionally equivalent to Page.get_drawings(), but much faster:\n\nEvery path type only contains the relevant keys, e.g. a stroke path has no \"fill\" color key. See comment in method Page.get_drawings().\n\nCoordinates are given as point_like, rect_like and quad_like tuples – not as Point, Rect, Quad objects.\n\nIf performance is a concern, consider using this method: Compared to versions earlier than 1.18.17, you should see much shorter response times. We have seen pages that required 2 seconds then, now only need 200 ms with this method.\n\nShow/hide history\n\nNew in v1.18.17\n\nChanged in v1.19.0: removed “clippings” key, added “seqno” key.\n\nChanged in v1.19.1: always generate RGB color tuples.\n\nChanged in v1.22.0: added new key \"layer\" which contains the name of the Optional Content Group of the path (or None).\n\nChanged in v1.22.0: added parameter extended to also return clipping paths.\n\nget_fonts(full=False)#\n\nPDF only: Return a list of fonts referenced by the page. Wrapper for Document.get_page_fonts().\n\nget_images(full=False)#\n\nPDF only: Return a list of images referenced by the page. Wrapper for Document.get_page_images().\n\nget_image_info(hashes=False, xrefs=False)#\n\nReturn a list of meta information dictionaries for all images shown on the page. This works for all document types. Technically, this is a subset of the dictionary output of Page.get_text(): the image binary content and any text on the page are ignored.\n\nParameters:\n\nhashes (bool) – Compute the MD5 hashcode for each encountered image, which allows identifying image duplicates. This adds the key \"digest\" to the output, whose value is a 16 byte bytes object. (New in v1.18.13)\n\nxrefs (bool) – PDF only. Try to find the xref for each image. Implies hashes=True. Adds the \"xref\" key to the dictionary. If not found, the value is 0, which means, the image is either “inline” or otherwise undetectable. Please note that this option has an extended response time, because the MD5 hashcode will be computed at least two times for each image with an xref. (New in v1.18.13)\n\nReturn type:\n\nlist[dict]\n\nReturns:\n\nA list of dictionaries. This includes information for exactly those images, that are shown on the page – including “inline images”. In contrast to images included in Page.get_text(), image binary content is not loaded, which drastically reduces memory usage. The dictionary layout is similar to that of image blocks in page.get_text(\"dict\").\n\nKey\n\nValue\n\nMultiple occurrences of the same image are always reported. You can detect duplicates by comparing their digest values.\n\nShow/hide history\n\nNew in v1.18.11\n\nChanged in v1.18.13: added image MD5 hashcode computation and xref search.\n\nget_xobjects()#\n\nPDF only: Return a list of Form XObjects referenced by the page. Wrapper for Document.get_page_xobjects().\n\nget_image_rects(item, transform=False)#\n\nPDF only: Return boundary boxes and transformation matrices of an embedded image. This is an improved version of Page.get_image_bbox() with the following differences:\n\nThere is no restriction on how the image is invoked (by the page or one of its Form XObjects). The result is always complete and correct.\n\nThe result is a list of Rect or (Rect, Matrix) objects – depending on transform. Each list item represents one location of the image on the page. Multiple occurrences might not be detectable by Page.get_image_bbox().\n\nThe method invokes Page.get_image_info() with xrefs=True and therefore has a noticeably longer response time than Page.get_image_bbox().\n\nParameters:\n\nitem (list,str,int) – an item of the list Page.get_images(), or the reference name entry of such an item (item[7]), or the image xref.\n\ntransform (bool) – also return the matrix used to transform the image rectangle to the bbox on the page. If true, then tuples (bbox, matrix) are returned.\n\nReturn type:\n\nlist\n\nReturns:\n\nBoundary boxes and respective transformation matrices for each image occurrence on the page. If the item is not on the page, an empty list [] is returned.\n\nShow/hide history\n\nNew in v1.18.13\n\nget_image_bbox(item, transform=False)#\n\nPDF only: Return boundary box and transformation matrix of an embedded image.\n\nParameters:\n\nitem (list,str) – an item of the list Page.get_images() with full=True specified, or the reference name entry of such an item, which is item[-3] (or item[7] respectively).\n\ntransform (bool) – return the matrix used to transform the image rectangle to the bbox on the page (new in v1.18.11). Default is just the bbox. If true, then a tuple (bbox, matrix) is returned.\n\nReturn type:\n\nRect or (Rect, Matrix)\n\nReturns:\n\nthe boundary box of the image – optionally also its transformation matrix.\n\nShow/hide history\n\n(Changed in v1.16.7): If the page in fact does not display this image, an infinite rectangle is returned now. In previous versions, an exception was raised. Formally invalid parameters still raise exceptions.\n\n(Changed in v1.17.0): Only images referenced directly by the page are considered. This means that images occurring in embedded PDF pages are ignored and an exception is raised.\n\n(Changed in v1.18.5): Removed the restriction introduced in v1.17.0: any item of the page’s image list may be specified.\n\n(Changed in v1.18.11): Partially re-instated a restriction: only those images are considered, that are either directly referenced by the page or by a Form XObject directly referenced by the page.\n\n(Changed in v1.18.11): Optionally also return the transformation matrix together with the bbox as the tuple (bbox, transform).\n\nNote\n\nBe aware that Page.get_images() may contain “dead” entries i.e. images, which the page does not display. This is no error, but intended by the PDF creator. No exception will be raised in this case, but an infinite rectangle is returned. You can avoid this from happening by executing Page.clean_contents() before this method.\n\nThe image’s “transformation matrix” is defined as the matrix, for which the expression bbox / transform == pymupdf.Rect(0, 0, 1, 1) is true, lookup details here: Image Transformation Matrix.\n\nShow/hide history\n\nChanged in v1.18.11: return image transformation matrix\n\nget_svg_image(matrix=pymupdf.Identity, text_as_path=True)#\n\nCreate an SVG image from the page. Only full page images are currently supported.\n\nParameters:\n\nmatrix (matrix_like) – a matrix, default is Identity.\n\ntext_as_path (bool) – – controls how text is represented. True outputs each character as a series of elementary draw commands, which leads to a more precise text display in browsers, but a very much larger output for text-oriented pages. Display quality for False relies on the presence of the referenced fonts on the current system. For missing fonts, the internet browser will fall back to some default – leading to unpleasant appearances. Choose False if you want to parse the text of the SVG. (New in v1.17.5)\n\nReturns:\n\na UTF-8 encoded string that contains the image. Because SVG has XML syntax it can be saved in a text file, the standard extension is .svg.\n\nNote\n\nIn case of a PDF, you can circumvent the “full page image only” restriction by modifying the page’s CropBox before using the method.\n\nget_pixmap(*, matrix=pymupdf.Identity, dpi=None, colorspace=pymupdf.csRGB, clip=None, alpha=False, annots=True)#\n\nCreate a pixmap from the page. This is probably the most often used method to create a Pixmap.\n\nAll parameters are keyword-only.\n\nParameters:\n\nmatrix (matrix_like) – default is Identity.\n\ndpi (int) – desired resolution in x and y direction. If not None, the \"matrix\" parameter is ignored. (New in v1.19.2)\n\ncolorspace (str or Colorspace) – The desired colorspace, one of “GRAY”, “RGB” or “CMYK” (case insensitive). Or specify a Colorspace, ie. one of the predefined ones: csGRAY, csRGB or csCMYK.\n\nclip (irect_like) – restrict rendering to the intersection of this area with the page’s rectangle.\n\nalpha (bool) –\n\nwhether to add an alpha channel. Always accept the default False if you do not really need transparency. This will save a lot of memory (25% in case of RGB … and pixmaps are typically large!), and also processing time. Also note an important difference in how the image will be rendered: with True the pixmap’s samples area will be pre-cleared with 0x00. This results in transparent areas where the page is empty. With False the pixmap’s samples will be pre-cleared with 0xff. This results in white where the page has nothing to show.\n\nShow/hide history\n\nChanged in v1.14.17\n\nThe default alpha value is now False.\n\nGenerated with alpha=True\n\nGenerated with alpha=False\n\nannots (bool) – (new in version 1.16.0) whether to also render annotations or to suppress them. You can create pixmaps for annotations separately.\n\nReturn type:\n\nPixmap\n\nReturns:\n\nPixmap of the page. For fine-controlling the generated image, the by far most important parameter is matrix. E.g. you can increase or decrease the image resolution by using Matrix(xzoom, yzoom). If zoom > 1, you will get a higher resolution: zoom=2 will double the number of pixels in that direction and thus generate a 2 times larger image. Non-positive values will flip horizontally, resp. vertically. Similarly, matrices also let you rotate or shear, and you can combine effects via e.g. matrix multiplication. See the Matrix section to learn more.\n\nNote\n\nThe pixmap will have “premultiplied” pixels if alpha=True. To learn about some background, e.g. look for “Premultiplied alpha” here.\n\nThe method will respect any page rotation and will not exceed the intersection of clip and Page.cropbox. If you need the page’s mediabox (and if this is a different rectangle), you can use a snippet like the following to achieve this:\n\nIn [1]: import pymupdf In [2]: doc=pymupdf.open(\"demo1.pdf\") In [3]: page=doc[0] In [4]: rotation = page.rotation In [5]: cropbox = page.cropbox In [6]: page.set_cropbox(page.mediabox) In [7]: page.set_rotation(0) In [8]: pix = page.get_pixmap() In [9]: page.set_cropbox(cropbox) In [10]: if rotation != 0: ...: page.set_rotation(rotation) ...: In [11]:\n\nShow/hide history\n\nChanged in v1.19.2: added support of parameter dpi.\n\nannot_names()#\n\nPDF only: return a list of the names of annotations, widgets and links. Technically, these are the /NM values of every PDF object found in the page’s /Annots array.\n\nReturn type:\n\nlist\n\nShow/hide history\n\nNew in v1.16.10\n\nannot_xrefs()#\n\nPDF only: return a list of the :data`xref` numbers of annotations, widgets and links – technically of all entries found in the page’s /Annots array.\n\nReturn type:\n\nlist\n\nReturns:\n\na list of items (xref, type) where type is the annotation type. Use the type to tell apart links, fields and annotations, see Annotation Types.\n\nShow/hide history\n\nNew in v1.17.1\n\nload_annot(ident)#\n\nPDF only: return the annotation identified by ident. This may be its unique name (PDF /NM key), or its xref.\n\nParameters:\n\nident (str,int) – the annotation name or xref.\n\nReturn type:\n\nAnnot\n\nReturns:\n\nthe annotation or None.\n\nNote\n\nMethods Page.annot_names(), Page.annot_xrefs() provide lists of names or xrefs, respectively, from where an item may be picked and loaded via this method.\n\nShow/hide history\n\nNew in v1.17.1\n\nload_widget(xref)#\n\nPDF only: return the field identified by xref.\n\nParameters:\n\nxref (int) – the field’s xref.\n\nReturn type:\n\nWidget\n\nReturns:\n\nthe field or None.\n\nNote\n\nThis is similar to the analogous method Page.load_annot() – except that here only the xref is supported as identifier.\n\nShow/hide history\n\nNew in v1.19.6\n\nReturn the first link on a page. Synonym of property first_link.\n\nReturn type:\n\nLink\n\nReturns:\n\nfirst link on the page (or None).\n\nset_rotation(rotate)#\n\nPDF only: Set the rotation of the page.\n\nParameters:\n\nrotate (int) – An integer specifying the required rotation in degrees. Must be an integer multiple of 90. Values will be converted to one of 0, 90, 180, 270.\n\nremove_rotation()#\n\nPDF only: Set page rotation to 0 while maintaining appearance and page content.\n\nReturns:\n\nThe inverted matrix used to achieve this change. If the page was not rotated (rotation 0), Identity is returned. The method automatically recomputes the rectangles of any annotations, links and widgets present on the page.\n\nThis method may come in handy when e.g. used with Page.show_pdf_page().\n\nshow_pdf_page(rect, docsrc, pno=0, keep_proportion=True, overlay=True, oc=0, rotate=0, clip=None)#\n\nPDF only: Display a page of another PDF as a vector image (otherwise similar to Page.insert_image()). This is a multi-purpose method. For example, you can use it to\n\ncreate “n-up” versions of existing PDF files, combining several input pages into one output page (see example combine.py),\n\ncreate “posterized” PDF files, i.e. every input page is split up in parts which each create a separate output page (see posterize.py),\n\ninclude PDF-based vector images like company logos, watermarks, etc., see svg-logo.py, which puts an SVG-based logo on each page (requires additional packages to deal with SVG-to-PDF conversions).\n\nParameters:\n\nrect (rect_like) – where to place the image on current page. Must be finite and its intersection with the page must not be empty.\n\ndocsrc (Document) – source PDF document containing the page. Must be a different document object, but may be the same file.\n\npno (int) – page number (0-based, in -∞ < pno < docsrc.page_count) to be shown.\n\nkeep_proportion (bool) – whether to maintain the width-height-ratio (default). If false, all 4 corners are always positioned on the border of the target rectangle – whatever the rotation value. In general, this will deliver distorted and /or non-rectangular images.\n\noverlay (bool) – put image in foreground (default) or background.\n\noc (int) – (xref) make visibility dependent on this OCG / OCMD (which must be defined in the target PDF) . (New in v1.18.3)\n\nrotate (float) – show the source rectangle rotated by some angle. Any angle is supported (changed in v1.14.11). (New in v1.14.10)\n\nclip (rect_like) – choose which part of the source page to show. Default is the full page, else must be finite and its intersection with the source page must not be empty.\n\nNote\n\nIn contrast to method Document.insert_pdf(), this method does not copy annotations, widgets or links, so these are not included in the target . But all its other resources (text, images, fonts, etc.) will be imported into the current PDF. They will therefore appear in text extractions and in get_fonts() and get_images() lists – even if they are not contained in the visible area given by clip.\n\nExample: Show the same source page, rotated by 90 and by -90 degrees:\n\n>>> doc = pymupdf.open() # new empty PDF >>> page=doc.new_page() # new page in A4 format >>> >>> # upper half page >>> r1 = pymupdf.Rect(0, 0, page.rect.width, page.rect.height/2) >>> >>> # lower half page >>> r2 = r1 + (0, page.rect.height/2, 0, page.rect.height/2) >>> >>> src = pymupdf.open(\"PyMuPDF.pdf\") # show page 0 of this >>> >>> page.show_pdf_page(r1, src, 0, rotate=90) >>> page.show_pdf_page(r2, src, 0, rotate=-90) >>> doc.save(\"show.pdf\")\n\nShow/hide history\n\nChanged in v1.14.11: Parameter reuse_xref has been deprecated. Position the source rectangle centered in target rectangle. Any rotation angle is now supported.\n\nChanged in v1.18.3: New parameter oc.\n\nnew_shape()#\n\nPDF only: Create a new Shape object for the page.\n\nReturn type:\n\nShape\n\nReturns:\n\na new Shape to use for compound drawings. See description there.\n\nsearch_for(needle, *, clip=None, quads=False, flags=TEXT_DEHYPHENATE | TEXT_PRESERVE_WHITESPACE | TEXT_PRESERVE_LIGATURES | TEXT_MEDIABOX_CLIP, textpage=None)#\n\nSearch for needle on a page. Wrapper for TextPage.search().\n\nParameters:\n\nneedle (str) – Text to search for. May contain spaces. Upper / lower case is ignored, but only works for ASCII characters: For example, “COMPÉTENCES” will not be found if needle is “compétences” – “compÉtences” however will. Similar is true for German umlauts and the like.\n\nclip (rect_like) – only search within this area. (New in v1.18.2)\n\nquads (bool) – Return object type Quad instead of Rect.\n\nflags (int) – Control the data extracted by the underlying TextPage. By default, ligatures and white spaces are kept, and hyphenation is detected.\n\ntextpage – use a previously created TextPage. This reduces execution time significantly. If specified, the ‘flags’ and ‘clip’ arguments are ignored. If omitted, a temporary textpage will be created. (New in v1.19.0)\n\nReturn type:\n\nlist\n\nReturns:\n\nA list of Rect or Quad objects, each of which – normally! – surrounds one occurrence of needle. However: if parts of needle occur on more than one line, then a separate item is generated for each these parts. So, if needle = \"search string\", two rectangles may be generated.\n\nShow/hide history\n\nChanges in v1.18.2:\n\nThere no longer is a limit on the list length (removal of the hit_max parameter).\n\nIf a word is hyphenated at a line break, it will still be found. E.g. the needle “method” will be found even if hyphenated as “meth-od” at a line break, and two rectangles will be returned: one surrounding “meth” (without the hyphen) and another one surrounding “od”.\n\nNote\n\nThe method supports multi-line text marker annotations: you can use the full returned list as one single parameter for creating the annotation.\n\nCaution\n\nThere is a tricky aspect: the search logic regards contiguous multiple occurrences of needle as one: assuming needle is “abc”, and the page contains “abc” and “abcabc”, then only two rectangles will be returned, one for “abc”, and a second one for “abcabc”.\n\nYou can always use Page.get_textbox() to check what text actually is being surrounded by each rectangle.\n\nNote\n\nA feature repeatedly asked for is supporting regular expressions when specifying the \"needle\" string: There is no way to do this. If you need something in that direction, first extract text in the desired format and then subselect the result by matching with some regex pattern. Here is an example for matching words:\n\n>>> pattern = re.compile(r\"...\") # the regex pattern >>> words = page.get_text(\"words\") # extract words on page >>> matches = [w for w in words if pattern.search(w[4])]\n\nThe matches list will contain the words matching the given pattern. In the same way you can select span[\"text\"] from the output of page.get_text(\"dict\").\n\nShow/hide history\n\nChanged in v1.18.2: added clip parameter. Remove hit_max parameter. Add default “dehyphenate”.\n\nChanged in v1.19.0: added TextPage parameter.\n\nset_mediabox(r)#\n\nPDF only: Change the physical page dimension by setting mediabox in the page’s object definition.\n\nParameters:\n\nr (rect-like) – the new mediabox value.\n\nNote\n\nThis method also removes the page’s other (optional) rectangles (cropbox, ArtBox, TrimBox and Bleedbox) to prevent inconsistent situations. This will cause those to assume their default values.\n\nCaution\n\nFor non-empty pages this may have undesired effects, because the location of all content depends on this value and will therefore change position or even disappear.\n\nShow/hide history\n\nNew in v1.16.13\n\nChanged in v1.19.4: remove all other rectangle definitions.\n\nset_cropbox(r)#\n\nPDF only: change the visible part of the page.\n\nParameters:\n\nr (rect_like) – the new visible area of the page. Note that this must be specified in unrotated coordinates, not empty, nor infinite and be completely contained in the Page.mediabox.\n\nAfter execution (if the page is not rotated), Page.rect will equal this rectangle, but be shifted to the top-left position (0, 0) if necessary. Example session:\n\n>>> page = doc.new_page() >>> page.rect pymupdf.Rect(0.0, 0.0, 595.0, 842.0) >>> >>> page.cropbox # cropbox and mediabox still equal pymupdf.Rect(0.0, 0.0, 595.0, 842.0) >>> >>> # now set cropbox to a part of the page >>> page.set_cropbox(pymupdf.Rect(100, 100, 400, 400)) >>> # this will also change the \"rect\" property: >>> page.rect pymupdf.Rect(0.0, 0.0, 300.0, 300.0) >>> >>> # but mediabox remains unaffected >>> page.mediabox pymupdf.Rect(0.0, 0.0, 595.0, 842.0) >>> >>> # revert CropBox change >>> # either set it to MediaBox >>> page.set_cropbox(page.mediabox) >>> # or 'refresh' MediaBox: will remove all other rectangles >>> page.set_mediabox(page.mediabox)\n\nset_artbox(r)#\n\nset_bleedbox(r)#\n\nset_trimbox(r)#\n\nPDF only: Set the resp. rectangle in the page object. For the meaning of these objects see Adobe PDF References, page 77. Parameter and restrictions are the same as for Page.set_cropbox().\n\nShow/hide history\n\nNew in v1.19.4\n\nrotation#\n\nContains the rotation of the page in degrees (always 0 for non-PDF types). This is a copy of the value in the PDF file. The PDF documentation says:\n\n“The number of degrees by which the page should be rotated clockwise when displayed or printed. The value must be a multiple of 90. Default value: 0.”\n\nIn PyMuPDF, we make sure that this attribute is always one of 0, 90, 180 or 270.\n\nType:\n\nint\n\ncropbox_position#\n\nContains the top-left point of the page’s /CropBox for a PDF, otherwise Point(0, 0).\n\nType:\n\nPoint\n\ncropbox#\n\nThe page’s /CropBox for a PDF. Always the unrotated page rectangle is returned. For a non-PDF this will always equal the page rectangle.\n\nNote\n\nIn PDF, the relationship between /MediaBox, /CropBox and page rectangle may sometimes be confusing, please do lookup the glossary for MediaBox.\n\nType:\n\nRect\n\nartbox#\n\nbleedbox#\n\ntrimbox#\n\nThe page’s /ArtBox, /BleedBox, /TrimBox, respectively. If not provided, defaulting to Page.cropbox.\n\nType:\n\nRect\n\nmediabox_size#\n\nContains the width and height of the page’s Page.mediabox for a PDF, otherwise the bottom-right coordinates of Page.rect.\n\nType:\n\nPoint\n\nmediabox#\n\nThe page’s mediabox for a PDF, otherwise Page.rect.\n\nType:\n\nRect\n\nNote\n\nFor most PDF documents and for all other document types, page.rect == page.cropbox == page.mediabox is true. However, for some PDFs the visible page is a true subset of mediabox. Also, if the page is rotated, its Page.rect may not equal Page.cropbox. In these cases the above attributes help to correctly locate page elements.\n\ntransformation_matrix#\n\nThis matrix translates coordinates from the PDF space to the MuPDF space. For example, in PDF /Rect [x0 y0 x1 y1] the pair (x0, y0) specifies the bottom-left point of the rectangle – in contrast to MuPDF’s system, where (x0, y0) specify top-left. Multiplying the PDF coordinates with this matrix will deliver the (Py-) MuPDF rectangle version. Obviously, the inverse matrix will again yield the PDF rectangle.\n\nType:\n\nMatrix\n\nrotation_matrix#\n\nderotation_matrix#\n\nThese matrices may be used for dealing with rotated PDF pages. When adding / inserting anything to a PDF page, the coordinates of the unrotated page are always used. These matrices help translating between the two states. Example: if a page is rotated by 90 degrees – what would then be the coordinates of the top-left Point(0, 0) of an A4 page?\n\n>>> page.set_rotation(90) # rotate an ISO A4 page >>> page.rect Rect(0.0, 0.0, 842.0, 595.0) >>> p = pymupdf.Point(0, 0) # where did top-left point land? >>> p * page.rotation_matrix Point(842.0, 0.0) >>>\n\nType:\n\nMatrix\n\nfirst_link#\n\nContains the first Link of a page (or None).\n\nType:\n\nLink\n\nfirst_annot#\n\nContains the first Annot of a page (or None).\n\nType:\n\nAnnot\n\nfirst_widget#\n\nContains the first Widget of a page (or None).\n\nType:\n\nWidget\n\nnumber#\n\nThe page number.\n\nType:\n\nint\n\nparent#\n\nThe owning document object.\n\nType:\n\nDocument\n\nrect#\n\nContains the rectangle of the page. Same as result of Page.bound().\n\nType:\n\nRect\n\nxref#\n\nThe page’s PDF xref. Zero if not a PDF.\n\nType:\n\nRect\n\nHomologous Methods of Document and Page#\n\nThis is an overview of homologous methods on the Document and on the Page level.\n\nDocument Level\n\nPage Level\n\nDocument.get_page_fonts(pno)\n\nPage.get_fonts()\n\nDocument.get_page_images(pno)\n\nPage.get_images()\n\nDocument.get_page_pixmap(pno, …)\n\nPage.get_pixmap()\n\nDocument.get_page_text(pno, …)\n\nPage.get_text()\n\nDocument.search_page_for(pno, …)\n\nPage.search_for()\n\nThe page number “pno” is a 0-based integer -∞ < pno < page_count.\n\nNote\n\nMost document methods (left column) exist for convenience reasons, and are just wrappers for: Document[pno].<page method>. So they load and discard the page on each execution.\n\nHowever, the first two methods work differently. They only need a page’s object definition statement - the page itself will not be loaded. So e.g. Page.get_fonts() is a wrapper the other way round and defined as follows: page.get_fonts == page.parent.get_page_fonts(page.number).\n\nFootnotes"
    }
}