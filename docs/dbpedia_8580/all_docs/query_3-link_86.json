{
    "id": "dbpedia_8580_3",
    "rank": 86,
    "data": {
        "url": "https://handmade.network/forums/t/1338-the_odin_programming_language",
        "read_more_link": "",
        "language": "en",
        "title": "The Odin Programming Language",
        "top_image": "https://handmade.network/public/logo.png",
        "meta_img": "https://handmade.network/public/logo.png",
        "images": [
            "https://assets.media.handmade.network/e25b87a4-5b9d-4e84-bbdc-173dccd267e9/gingerbill.png",
            "https://assets.media.handmade.network/6f3500e3-a625-44bb-a5ad-b7bfe89c61bd/valmar.png",
            "https://assets.media.handmade.network/5fb0ac88-46b5-4eb3-bcfd-eb7d6a5d5cfd/superfunc.jpeg",
            "https://assets.media.handmade.network/e25b87a4-5b9d-4e84-bbdc-173dccd267e9/gingerbill.png",
            "https://assets.media.handmade.network/5fb0ac88-46b5-4eb3-bcfd-eb7d6a5d5cfd/superfunc.jpeg",
            "https://assets.media.handmade.network/6f3500e3-a625-44bb-a5ad-b7bfe89c61bd/valmar.png",
            "https://assets.media.handmade.network/52f68dd3-6d62-460d-98e0-5594d183f4cd/timothy.wright.jpeg",
            "https://assets.media.handmade.network/e25b87a4-5b9d-4e84-bbdc-173dccd267e9/gingerbill.png",
            "https://handmade.network/public/themes/light/empty-avatar.svg?v=1723210861",
            "https://handmade.network/public/themes/light/empty-avatar.svg?v=1723210861",
            "https://assets.media.handmade.network/e25b87a4-5b9d-4e84-bbdc-173dccd267e9/gingerbill.png",
            "https://handmade.network/public/themes/light/empty-avatar.svg?v=1723210861",
            "https://assets.media.handmade.network/e25b87a4-5b9d-4e84-bbdc-173dccd267e9/gingerbill.png",
            "https://assets.media.handmade.network/e25b87a4-5b9d-4e84-bbdc-173dccd267e9/gingerbill.png",
            "https://handmade.network/public/themes/light/empty-avatar.svg?v=1723210861"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2016-07-08T23:42:48+00:00",
        "summary": "",
        "meta_description": "I've finally gotten fed of up of creating external metaprogramming tools to fix C/C++ and thoughtâ€¦",
        "meta_lang": "en",
        "meta_favicon": "https://handmade.network/public/learningjam2024/favicon-16x16.png?v=1723210861",
        "meta_site_name": "Handmade Network",
        "canonical_link": null,
        "text": "July 8, 2016\n\nI've finally gotten fed of up of creating external metaprogramming tools to fix C/C++ and thought why not just create a new language. So for past month I've been developing a new programming language.\n\nThe language is not currently done yet but it is in heavy development.\n\nThe main goal of the language is to replace my need for C/C++ and improve my quality of life. I want the language to be:\n\nSimple to read and write\n\nEasy to comprehend and reason with\n\nFast\n\nLow-level\n\nCompiled, strongly-typed, static language\n\nMetaprogramming:\n\n- Ability to run any code at compile time\n\n- Unified syntax between main language and metaprogramming language\n\n- Built-in introspection for all types\n\nHigher control of data layout and data access\n\nNo need for external tools such as Make/IDE\n\nIf you would like to inspect my current progress or even like to help out, here is the repository to the language so far:\n\nOdin Git Repository\n\nDemos\n\nFirst Talk & Demo\n\nTalk: https://youtu.be/TMCkT-uASaE?t=338\n\nDemo: https://youtu.be/TMCkT-uASaE?t=1800\n\nQ&A: https://youtu.be/TMCkT-uASaE?t=5749\n\nComposition & Refactorability\n\nhttps://www.youtube.com/watch?v=n1wemZfcbXM\n\nIntrospection, Modules, and Record Layout\n\nhttps://www.youtube.com/watch?v=UFq8rhWhx4s\n\npush_allocator & Minimal Dependency Building\n\nhttps://www.youtube.com/watch?v=f_LGVOAMb78\n\nEdited by Ginger Bill on October 6, 2016, 10:52pm\n\nJuly 10, 2016\n\nI like quite a lot of the ideas from Jai however there are two main problems with Jai:\n\nIt's not available to the public yet and there is not ETA[/\n\nI'm not sure if it is what I want\n\nJai is starting to get quite complicated and this is worrying to me. One of the great things about C is that you can actually know everything about the language (compared to C++ which is a beast). I also like being explicit about things (which is one of the reasons I like C) and Jai is tending towards having a lot of implicit stuff (however, none of that is final and may be removed). I want to be able to read the source code and know exactly what is happening.\n\nJai's type system is still not very good. I would love it if it had tagged unions/variants/algebraic types/whatever as a first-class construct as this would solve some of my annoyances I have with C/C++. Also, something like slices would also solve a lot of problems.\n\nIf it turns out that Jai is actually the better option, then I will go with that option but at the moment, it isn't even an option. I want to explore for myself what I can create and to do that, I have to create my own language to do that.\n\nEdited by Ginger Bill on July 11, 2016, 10:00am\n\nJuly 12, 2016\n\nGinger Bill\n\nJai's type system is still not very good. I would love it if it had tagged unions/variants/algebraic types/whatever as a first-class construct as this would solve some of my annoyances I have with C/C++. Also, something like slices would also solve a lot of problems.\n\nSo you're saying the language is too complicated, but that the problem is it's not more complicated.\n\nI don't think it's particularly complicated. It is *tremendously* simpler than C++, and in some dimensions is a lot simpler than C (though of course in others it is more complicated).\n\nI think it's hard to judge how complicated some of the new stuff is (like everything since polymorphism) without actually using the language. In isolated one-hour presentations, of course things are going to go by really fast and viewers won't get all the details. But I think if one is designing a language that people may use for 10+ years of their lives, you actually want to put lots and lots of work into making things powerful enough for experts. And that often means complications -- because things that are simpler don't do as good of a job at helping you get things done as they could in as many situations as they could, and over years that costs the expert programmer a lot of time.\n\nOf course exactly which complications to add is something that is tuned to personal taste.\n\nI think these trade-offs don't become too clear until you have a language that is very simple and you see that it doesn't do enough for you (which is where I was, say, 1.5 years ago).\n\nAlso ... I am not sure what implicit stuff you are talking about? There is almost no implicit stuff in the language currently.\n\nEdited by Jonathan Blow on July 12, 2016, 8:36pm\n\nJuly 12, 2016\n\nLet me explain this more ... by analogy with CPUs.\n\nClearly you want CPUs to be simple because they are a bedrock computing component. All things being equal, you want your CPU to be as simple as possible.\n\nBut it would be a bad idea to say \"we should not add SIMD instructions to our CPU, because that makes the CPU more complicated!\" Because you get a lot of use out of SIMD and there isn't really a way to get those same performance characteristics otherwise. There's a clear trade-off between complexity and capability.\n\nThis is why almost nobody in the real world uses Scheme to build complex software. Yes, ideologically it is very nice that you can have a super-simple language with minimal syntax. But in the real world, there are trade-offs for that, and it turns out that the value of minimal syntax is low compared to the value given by a more-complex syntax (more readability, ability to get better compiler errors just because the grammar provides more context, etc).\n\nSo ... ideally, I think it would be great if the language I am building could be as simple as C. At the same time, though, I feel that the complexity vs capability tradeoff is asking for something more complex than C. BUT, you can also optimize this tradeoff. You can get back a little bit of the complexity budget by eliminating some of the complexities that C introduces (for example, 'int' being an unknown size, or always being forced to only refer to things that were being defined earlier in the file, or the whole structure of header files versus .c files, or types being in their own weird namespace, or the weird syntax of declaring and using pointers to procedures, or all the crazy stuff you have to do if you want to be compilable on C89 or earlier, like only declaring at the start of blocks, or the weird way of declaring structs and then typedeffing them, ... or all the baggage introduced by the fact that K&R-style C, of prototyping procedures with empty argument lists, is still valid and required to work). Once you've eliminated these complexities, you have room in the budget, and can spend that complexity on features.\n\nThis is why I am also saying that the language is probably less complex than you think it is -- because you are very familiar with a lot of the complexities of C, so you don't feel them as complexities ... but those have been dumped, and replaced by other things, which you *do* feel as complexities solely because you aren't used to them.\n\nThat said, I do agree it's more complicated than C, I am just saying there's also an optical illusion involved here.\n\nEdited by Jonathan Blow on July 12, 2016, 9:50pm\n\nJuly 12, 2016\n\njon:\n\nThank you for your reply. I think what you have done with your language, Jai, is absolutely brilliant! I completely agree that it's \"tremedously\" simpler than C++ and in many aspects, simpler than C. C++ is a language which needs pruning not additions but the C++ committee (as a whole) have no idea what they are doing. I have soothed some of my pains with C/C++ with metaprogramming tools but I can only go far without having to create a new language.\n\nIf I spent a long time with Jai, I could get a better judge of its \"complexity\" but I've only seen your demos and demo source code which form all of my basis for my opinions on Jai (which are few).\n\nAs I develop my language further and program more within this language, I may find that I do need more complex concepts to solve the problems that I have.\n\nOne example that I can think of for implicit stuff is iterators. I personally do not use \"iterators\" at all in C++ as I usually only iterate across arrays and linked lists. I understand your reasoning for adding them as it suits your personal style. For my personal style, I do not like them. It may just because I'm not used to them either nor like how many languages do them.\n\nHowever to contradict myself, I do personally love the implicit context for procedures. This would solve most of my problems I have with custom allocations and external library allocation (e.g. no need for my custom allocators to be passed and stored in every structure nor #define LIB_MALLOC(sz) ... (if the library's sane)).\n\nMy years with C/C++ have heavily influenced the way I the think and their complexities may have distorted my views tremendously. A little more complex than C would not be a problem but how do I quantify complexity?\n\n---\n\nOne of the reasons I noted tagged unions is that this is how I prefer to represent hierarchical types (rather than \"inheritance\"). With tagged unions, each subtype is exactly the same size in memory which is easier to control memory allocation and memory layout. In C/C++ it's a pain as it requires a lot of bookkeeping and extra stuff to get it working and is still not type safe. However, C++'s inheritance model is easier to use but does not have the memory layout benefits. (Note: these are C/C++ problems not other languages' problems.)\n\nEven in this compiler, I use tagged unions extensively (ASTNodes, Types, Entities, et al.) as I can just preallocate the space I need and then allocate from the memory arena as I know the size of the allocations. With something like \"inheritance\" I wouldn't know the size as easily.\n\nAnd the last thing I noted was slices. I handle arrays a lot and I commonly have to store the information around everywhere (mainly because of C/C++). A slice is just an extension to an array which is an extension to a pointer. pointer; array=pointer+length; slice=pointer+length+capacity. Having something like this would solve a lot of problems for me having it as a main data type.\n\nThese may be complex concepts but I find them simpler than the C/C++ alternatives.\n\n---\n\n- Bill\n\nEdited by Ginger Bill on July 13, 2016, 12:07am"
    }
}