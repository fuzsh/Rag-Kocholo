{
    "id": "dbpedia_8580_3",
    "rank": 41,
    "data": {
        "url": "https://github.com/jwasham/coding-interview-university",
        "read_more_link": "",
        "language": "en",
        "title": "university: A complete computer science study plan to become a software engineer.",
        "top_image": "https://repository-images.githubusercontent.com/60493101/4ed59900-87ab-11ea-9e39-99741f040a83",
        "meta_img": "https://repository-images.githubusercontent.com/60493101/4ed59900-87ab-11ea-9e39-99741f040a83",
        "images": [
            "https://camo.githubusercontent.com/8e0c045f27e5b34ea98a7eaef2199ec01528f22e9d4edd8864faa05a7436e841/68747470733a2f2f64336a32706b6d6a74696e366f752e636c6f756466726f6e742e6e65742f636f64696e672d61742d7468652d7768697465626f6172642d73696c69636f6e2d76616c6c65792e706e67",
            "https://camo.githubusercontent.com/e501e4e63ca7f6e9b9ea0460e6c1845234ef5f076f4f4e7b97a645e3604ba325/68747470733a2f2f64336a32706b6d6a74696e366f752e636c6f756466726f6e742e6e65742f686f772d746f2d646f776e6c6f61642d61732d7a69702e706e67",
            "https://camo.githubusercontent.com/db1a3a34fd3c7aa09775fb23d5e57ee18cd5377905360fb973313a6280e68c32/68747470733a2f2f64336a32706b6d6a74696e366f752e636c6f756466726f6e742e6e65742f666f726b2d627574746f6e2e706e67",
            "https://camo.githubusercontent.com/87827952d97406eade04839d6201d868748d41ffb9be1443c7a84fb801fc33f8/68747470733a2f2f64336a32706b6d6a74696e366f752e636c6f756466726f6e742e6e65742f6172745f626f6172645f736d5f322e6a7067",
            "https://avatars.githubusercontent.com/u/3771963?s=64&v=4",
            "https://avatars.githubusercontent.com/u/76818211?s=64&v=4",
            "https://avatars.githubusercontent.com/u/24354489?s=64&v=4",
            "https://avatars.githubusercontent.com/u/13459501?s=64&v=4",
            "https://avatars.githubusercontent.com/u/4519586?s=64&v=4",
            "https://avatars.githubusercontent.com/u/40712079?s=64&v=4",
            "https://avatars.githubusercontent.com/u/9573300?s=64&v=4",
            "https://avatars.githubusercontent.com/u/8386780?s=64&v=4",
            "https://avatars.githubusercontent.com/u/4788852?s=64&v=4",
            "https://avatars.githubusercontent.com/u/6526127?s=64&v=4",
            "https://avatars.githubusercontent.com/u/9527681?s=64&v=4",
            "https://avatars.githubusercontent.com/u/42769725?s=64&v=4",
            "https://avatars.githubusercontent.com/u/11988820?s=64&v=4",
            "https://avatars.githubusercontent.com/u/38102582?s=64&v=4"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "A complete computer science study plan to become a software engineer. - jwasham/coding-interview-university",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/jwasham/coding-interview-university",
        "text": "I originally created this as a short to-do list of study topics for becoming a software engineer, but it grew to the large list you see today. After going through this study plan, I got hired as a Software Development Engineer at Amazon! You probably won't have to study as much as I did. Anyway, everything you need is here.\n\nI studied about 8-12 hours a day, for several months. This is my story: Why I studied full-time for 8 months for a Google interview\n\nPlease Note: You won't need to study as much as I did. I wasted a lot of time on things I didn't need to know. More info about that is below. I'll help you get there without wasting your precious time.\n\nThe items listed here will prepare you well for a technical interview at just about any software company, including the giants: Amazon, Facebook, Google, and Microsoft.\n\nBest of luck to you!\n\nTranslations:\n\nBahasa Indonesia\n\nBulgarian\n\nEspañol\n\nGerman\n\nJapanese (日本語)\n\nMarathi\n\nPolish\n\nPortuguês Brasileiro\n\nRussian\n\nTiếng Việt - Vietnamese\n\nUrdu - اردو\n\nUzbek\n\nবাংলা - Bangla\n\nខ្មែរ - Khmer\n\n简体中文\n\n繁體中文\n\nTranslations in progress:\n\nAfrikaans\n\nArabic\n\nFrench\n\nGreek\n\nItalian\n\nKorean(한국어)\n\nMalayalam\n\nPersian - Farsi\n\nTelugu\n\nThai\n\nTurkish\n\nУкраїнська\n\nעברית\n\nहिन्दी\n\nThis is my multi-month study plan for becoming a software engineer for a large company.\n\nRequired:\n\nA little experience with coding (variables, loops, methods/functions, etc)\n\nPatience\n\nTime\n\nNote this is a study plan for software engineering, not frontend engineering or full-stack development. There are really super roadmaps and coursework for those career paths elsewhere (see https://roadmap.sh/ for more info).\n\nThere is a lot to learn in a university Computer Science program, but only knowing about 75% is good enough for an interview, so that's what I cover here. For a complete CS self-taught program, the resources for my study plan have been included in Kamran Ahmed's Computer Science Roadmap: https://roadmap.sh/computer-science\n\nWhat is it?\n\nWhy use it?\n\nHow to use it\n\nDon't feel you aren't smart enough\n\nA Note About Video Resources\n\nChoose a Programming Language\n\nBooks for Data Structures and Algorithms\n\nInterview Prep Books\n\nDon't Make My Mistakes\n\nWhat you Won't See Covered\n\nThe Daily Plan\n\nCoding Question Practice\n\nCoding Problems\n\nAlgorithmic complexity / Big-O / Asymptotic analysis\n\nData Structures\n\nArrays\n\nLinked Lists\n\nStack\n\nQueue\n\nHash table\n\nMore Knowledge\n\nBinary search\n\nBitwise operations\n\nTrees\n\nTrees - Intro\n\nBinary search trees: BSTs\n\nHeap / Priority Queue / Binary Heap\n\nbalanced search trees (general concept, not details)\n\ntraversals: preorder, inorder, postorder, BFS, DFS\n\nSorting\n\nselection\n\ninsertion\n\nheapsort\n\nquicksort\n\nmergesort\n\nGraphs\n\ndirected\n\nundirected\n\nadjacency matrix\n\nadjacency list\n\ntraversals: BFS, DFS\n\nEven More Knowledge\n\nRecursion\n\nDynamic Programming\n\nDesign Patterns\n\nCombinatorics (n choose k) & Probability\n\nNP, NP-Complete and Approximation Algorithms\n\nHow computers process a program\n\nCaches\n\nProcesses and Threads\n\nTesting\n\nString searching & manipulations\n\nTries\n\nFloating Point Numbers\n\nUnicode\n\nEndianness\n\nNetworking\n\nFinal Review\n\nUpdate Your Resume\n\nFind a Job\n\nInterview Process & General Interview Prep\n\nBe thinking of for when the interview comes\n\nHave questions for the interviewer\n\nOnce You've Got The Job\n\n---------------- Everything below this point is optional ----------------\n\nAdditional Books\n\nSystem Design, Scalability, Data Handling (if you have 4+ years experience)\n\nAdditional Learning\n\nCompilers\n\nEmacs and vi(m)\n\nUnix command line tools\n\nInformation theory\n\nParity & Hamming Code\n\nEntropy\n\nCryptography\n\nCompression\n\nComputer Security\n\nGarbage collection\n\nParallel Programming\n\nMessaging, Serialization, and Queueing Systems\n\nA*\n\nFast Fourier Transform\n\nBloom Filter\n\nHyperLogLog\n\nLocality-Sensitive Hashing\n\nvan Emde Boas Trees\n\nAugmented Data Structures\n\nBalanced search trees\n\nAVL trees\n\nSplay trees\n\nRed/black trees\n\n2-3 search trees\n\n2-3-4 Trees (aka 2-4 trees)\n\nN-ary (K-ary, M-ary) trees\n\nB-Trees\n\nk-D Trees\n\nSkip lists\n\nNetwork Flows\n\nDisjoint Sets & Union Find\n\nMath for Fast Processing\n\nTreap\n\nLinear Programming\n\nGeometry, Convex hull\n\nDiscrete math\n\nAdditional Detail on Some Subjects\n\nVideo Series\n\nComputer Science Courses\n\nPapers\n\nIf you want to work as a software engineer for a large company, these are the things you have to know.\n\nIf you missed out on getting a degree in computer science, like I did, this will catch you up and save four years of your life.\n\nWhen I started this project, I didn't know a stack from a heap, didn't know Big-O anything, or anything about trees, or how to traverse a graph. If I had to code a sorting algorithm, I can tell ya it would have been terrible. Every data structure I had ever used was built into the language, and I didn't know how they worked under the hood at all. I never had to manage memory unless a process I was running would give an \"out of memory\" error, and then I'd have to find a workaround. I used a few multidimensional arrays in my life and thousands of associative arrays, but I never created data structures from scratch.\n\nIt's a long plan. It may take you months. If you are familiar with a lot of this already it will take you a lot less time.\n\n⬆ back to top\n\nEverything below is an outline, and you should tackle the items in order from top to bottom.\n\nI'm using GitHub's special markdown flavor, including tasks lists to track progress.\n\nMore about GitHub-flavored markdown\n\nOn this page, click the Code button near the top, then click \"Download ZIP\". Unzip the file and you can work with the text files.\n\nIf you're open in a code editor that understands markdown, you'll see everything formatted nicely.\n\nCreate a new branch so you can check items like this, just put an x in the brackets: [x]\n\nFork the GitHub repo: https://github.com/jwasham/coding-interview-university by clicking on the Fork button.\n\nClone to your local repo:\n\ngit clone https://github.com/<YOUR_GITHUB_USERNAME>/coding-interview-university.git cd coding-interview-university git remote add upstream https://github.com/jwasham/coding-interview-university.git git remote set-url --push upstream DISABLE # so that you don't push your personal progress back to the original repo\n\nMark all boxes with X after you completed your changes:\n\ngit commit -am \"Marked personal progress\" git pull upstream main # keep your fork up-to-date with changes from the original repo git push # just pushes to your fork\n\n⬆ back to top\n\nSuccessful software engineers are smart, but many have an insecurity that they aren't smart enough.\n\nThe following videos may help you overcome this insecurity:\n\nThe myth of the Genius Programmer\n\nIt's Dangerous to Go Alone: Battling the Invisible Monsters in Tech\n\n⬆ back to top\n\nSome videos are available only by enrolling in a Coursera or EdX class. These are called MOOCs. Sometimes the classes are not in session so you have to wait a couple of months, so you have no access.\n\nIt would be great to replace the online course resources with free and always-available public sources, such as YouTube videos (preferably university lectures), so that you people can study these anytime, not just when a specific online course is in session.\n\n⬆ back to top\n\nYou'll need to choose a programming language for the coding interviews you do, but you'll also need to find a language that you can use to study computer science concepts.\n\nPreferably the language would be the same, so that you only need to be proficient in one.\n\nWhen I did the study plan, I used 2 languages for most of it: C and Python\n\nC: Very low level. Allows you to deal with pointers and memory allocation/deallocation, so you feel the data structures and algorithms in your bones. In higher-level languages like Python or Java, these are hidden from you. In day-to-day work, that's terrific, but when you're learning how these low-level data structures are built, it's great to feel close to the metal.\n\nC is everywhere. You'll see examples in books, lectures, videos, everywhere while you're studying.\n\nThe C Programming Language, 2nd Edition\n\nThis is a short book, but it will give you a great handle on the C language and if you practice it a little you'll quickly get proficient. Understanding C helps you understand how programs and memory work.\n\nYou don't need to go super deep in the book (or even finish it). Just get to where you're comfortable reading and writing in C.\n\nPython: Modern and very expressive, I learned it because it's just super useful and also allows me to write less code in an interview.\n\nThis is my preference. You do what you like, of course.\n\nYou may not need it, but here are some sites for learning a new language:\n\nExercism\n\nCodewars\n\nHackerEarth\n\nScaler Topics (Java, C++)\n\nProgramiz PRO Community Challenges)\n\nYou can use a language you are comfortable in to do the coding part of the interview, but for large companies, these are solid choices:\n\nC++\n\nJava\n\nPython\n\nYou could also use these, but read around first. There may be caveats:\n\nJavaScript\n\nRuby\n\nHere is an article I wrote about choosing a language for the interview: Pick One Language for the Coding Interview. This is the original article my post was based on: Choosing a Programming Language for Interviews\n\nYou need to be very comfortable in the language and be knowledgeable.\n\nRead more about choices:\n\nChoose the Right Language for Your Coding Interview\n\nSee language-specific resources here\n\n⬆ back to top\n\nThis book will form your foundation for computer science.\n\nJust choose one, in a language that you will be comfortable with. You'll be doing a lot of reading and coding.\n\nAlgorithms in C, Parts 1-5 (Bundle), 3rd Edition\n\nFundamentals, Data Structures, Sorting, Searching, and Graph Algorithms\n\nData Structures and Algorithms in Python\n\nby Goodrich, Tamassia, Goldwasser\n\nI loved this book. It covered everything and more.\n\nPythonic code\n\nmy glowing book report: https://startupnextdoor.com/book-report-data-structures-and-algorithms-in-python/\n\nYour choice:\n\nGoodrich, Tamassia, Goldwasser\n\nData Structures and Algorithms in Java\n\nSedgewick and Wayne:\n\nAlgorithms\n\nFree Coursera course that covers the book (taught by the authors!):\n\nAlgorithms I\n\nAlgorithms II\n\nYour choice:\n\nGoodrich, Tamassia, and Mount\n\nData Structures and Algorithms in C++, 2nd Edition\n\nSedgewick and Wayne\n\nAlgorithms in C++, Parts 1-4: Fundamentals, Data Structure, Sorting, Searching\n\nAlgorithms in C++ Part 5: Graph Algorithms\n\n⬆ back to top\n\nYou don't need to buy a bunch of these. Honestly \"Cracking the Coding Interview\" is probably enough, but I bought more to give myself more practice. But I always do too much.\n\nI bought both of these. They gave me plenty of practice.\n\nProgramming Interviews Exposed: Coding Your Way Through the Interview, 4th Edition\n\nAnswers in C++ and Java\n\nThis is a good warm-up for Cracking the Coding Interview\n\nNot too difficult. Most problems may be easier than what you'll see in an interview (from what I've read)\n\nCracking the Coding Interview, 6th Edition\n\nanswers in Java\n\nChoose one:\n\nElements of Programming Interviews (C++ version)\n\nElements of Programming Interviews in Python\n\nElements of Programming Interviews (Java version) - Companion Project - Method Stub and Test Cases for Every Problem in the Book\n\n⬆ back to top\n\nThis list grew over many months, and yes, it got out of hand.\n\nHere are some mistakes I made so you'll have a better experience. And you'll save months of time.\n\nI watched hours of videos and took copious notes, and months later there was much I didn't remember. I spent 3 days going through my notes and making flashcards, so I could review. I didn't need all of that knowledge.\n\nPlease, read so you won't make my mistakes:\n\nRetaining Computer Science Knowledge.\n\nTo solve the problem, I made a little flashcard site where I could add flashcards of 2 types: general and code. Each card has a different formatting. I made a mobile-first website, so I could review on my phone or tablet, wherever I am.\n\nMake your own for free:\n\nFlashcards site repo\n\nI DON'T RECOMMEND using my flashcards. There are too many and most of them are trivia that you don't need.\n\nBut if you don't want to listen to me, here you go:\n\nMy flash cards database (1200 cards):\n\nMy flash cards database (extreme - 1800 cards):\n\nKeep in mind I went overboard and have cards covering everything from assembly language and Python trivia to machine learning and statistics. It's way too much for what's required.\n\nNote on flashcards: The first time you recognize you know the answer, don't mark it as known. You have to see the same card and answer it several times correctly before you really know it. Repetition will put that knowledge deeper in your brain.\n\nAn alternative to using my flashcard site is Anki, which has been recommended to me numerous times. It uses a repetition system to help you remember. It's user-friendly, available on all platforms, and has a cloud sync system. It costs $25 on iOS but is free on other platforms.\n\nMy flashcard database in Anki format: https://ankiweb.net/shared/info/25173560 (thanks @xiewenya).\n\nSome students have mentioned formatting issues with white space that can be fixed by doing the following: open the deck, edit the card, click cards, select the \"styling\" radio button, and add the member \"white-space: pre;\" to the card class.\n\nTHIS IS VERY IMPORTANT.\n\nStart doing coding interview questions while you're learning data structures and algorithms.\n\nYou need to apply what you're learning to solve problems, or you'll forget. I made this mistake.\n\nOnce you've learned a topic, and feel somewhat comfortable with it, for example, linked lists:\n\nOpen one of the coding interview books (or coding problem websites, listed below)\n\nDo 2 or 3 questions regarding linked lists.\n\nMove on to the next learning topic.\n\nLater, go back and do another 2 or 3 linked list problems.\n\nDo this with each new topic you learn.\n\nKeep doing problems while you're learning all this stuff, not after.\n\nYou're not being hired for knowledge, but how you apply the knowledge.\n\nThere are many resources for this, listed below. Keep going.\n\nThere are a lot of distractions that can take up valuable time. Focus and concentration are hard. Turn on some music without lyrics and you'll be able to focus pretty well.\n\n⬆ back to top\n\nThese are prevalent technologies but not part of this study plan:\n\nJavascript\n\nHTML, CSS, and other front-end technologies\n\nSQL\n\n⬆ back to top\n\nThis course goes over a lot of subjects. Each will probably take you a few days, or maybe even a week or more. It depends on your schedule.\n\nEach day, take the next subject in the list, watch some videos about that subject, and then write an implementation of that data structure or algorithm in the language you chose for this course.\n\nYou can see my code here:\n\nC\n\nC++\n\nPython\n\nYou don't need to memorize every algorithm. You just need to be able to understand it enough to be able to write your own implementation.\n\n⬆ back to top\n\nWhy is this here? I'm not ready to interview.\n\nThen go back and read this.\n\nWhy you need to practice doing programming problems:\n\nProblem recognition, and where the right data structures and algorithms fit in\n\nGathering requirements for the problem\n\nTalking your way through the problem like you will in the interview\n\nCoding on a whiteboard or paper, not a computer\n\nComing up with time and space complexity for your solutions (see Big-O below)\n\nTesting your solutions\n\nThere is a great intro for methodical, communicative problem-solving in an interview. You'll get this from the programming interview books, too, but I found this outstanding: Algorithm design canvas\n\nWrite code on a whiteboard or paper, not a computer. Test with some sample inputs. Then type it and test it out on a computer.\n\nIf you don't have a whiteboard at home, pick up a large drawing pad from an art store. You can sit on the couch and practice. This is my \"sofa whiteboard\". I added the pen in the photo just for scale. If you use a pen, you'll wish you could erase. Gets messy quickly. I use a pencil and eraser.\n\nCoding question practice is not about memorizing answers to programming problems.\n\n⬆ back to top\n\nDon't forget your key coding interview books here.\n\nSolving Problems:\n\nHow to Find a Solution\n\nHow to Dissect a Topcoder Problem Statement\n\nCoding Interview Question Videos:\n\nIDeserve (88 videos)\n\nTushar Roy (5 playlists)\n\nSuper for walkthroughs of problem solutions\n\nNick White - LeetCode Solutions (187 Videos)\n\nGood explanations of the solution and the code\n\nYou can watch several in a short time\n\nFisherCoder - LeetCode Solutions\n\nChallenge/Practice sites:\n\nLeetCode\n\nMy favorite coding problem site. It's worth the subscription money for the 1-2 months you'll likely be preparing.\n\nSee Nick White and FisherCoder Videos above for code walk-throughs.\n\nHackerRank\n\nTopCoder\n\nCodeforces\n\nCodility\n\nGeeks for Geeks\n\nAlgoExpert\n\nCreated by Google engineers, this is also an excellent resource to hone your skills.\n\nProject Euler\n\nvery math-focused, and not really suited for coding interviews\n\n⬆ back to top\n\nAlright, enough talk, let's learn!\n\nBut don't forget to do coding problems from above while you learn!\n\nNothing to implement here, you're just watching videos and taking notes! Yay!\n\nThere are a lot of videos here. Just watch enough until you understand it. You can always come back and review.\n\nDon't worry if you don't understand all the math behind it.\n\nYou just need to understand how to express the complexity of an algorithm in terms of Big-O.\n\nHarvard CS50 - Asymptotic Notation (video)\n\nBig O Notations (general quick tutorial) (video)\n\nBig O Notation (and Omega and Theta) - best mathematical explanation (video)\n\nSkiena (video)\n\nUC Berkeley Big O (video)\n\nAmortized Analysis (video)\n\nTopCoder (includes recurrence relations and master theorem):\n\nComputational Complexity: Section 1\n\nComputational Complexity: Section 2\n\nCheat sheet\n\n[Review] Analyzing Algorithms (playlist) in 18 minutes (video)\n\nWell, that's about enough of that.\n\nWhen you go through \"Cracking the Coding Interview\", there is a chapter on this, and at the end there is a quiz to see if you can identify the runtime complexity of different algorithms. It's a super review and test.\n\n⬆ back to top\n\nAbout Arrays:\n\nArrays CS50 Harvard University\n\nArrays (video)\n\nUC Berkeley CS61B - Linear and Multi-Dim Arrays (video) (Start watching from 15m 32s)\n\nDynamic Arrays (video)\n\nJagged Arrays (video)\n\nImplement a vector (mutable array with automatic resizing):\n\nPractice coding using arrays and pointers, and pointer math to jump to an index instead of using indexing.\n\nNew raw data array with allocated memory\n\ncan allocate int array under the hood, just not use its features\n\nstart with 16, or if the starting number is greater, use power of 2 - 16, 32, 64, 128\n\nsize() - number of items\n\ncapacity() - number of items it can hold\n\nis_empty()\n\nat(index) - returns the item at a given index, blows up if index out of bounds\n\npush(item)\n\ninsert(index, item) - inserts item at index, shifts that index's value and trailing elements to the right\n\nprepend(item) - can use insert above at index 0\n\npop() - remove from end, return value\n\ndelete(index) - delete item at index, shifting all trailing elements left\n\nremove(item) - looks for value and removes index holding it (even if in multiple places)\n\nfind(item) - looks for value and returns first index with that value, -1 if not found\n\nresize(new_capacity) // private function\n\nwhen you reach capacity, resize to double the size\n\nwhen popping an item, if the size is 1/4 of capacity, resize to half\n\nTime\n\nO(1) to add/remove at end (amortized for allocations for more space), index, or update\n\nO(n) to insert/remove elsewhere\n\nSpace\n\ncontiguous in memory, so proximity helps performance\n\nspace needed = (array capacity, which is >= n) * size of item, but even if 2n, still O(n)\n\nLinked Lists\n\nDescription:\n\nLinked Lists CS50 Harvard University - this builds the intuition.\n\nSingly Linked Lists (video)\n\nCS 61B - Linked Lists 1 (video)\n\nCS 61B - Linked Lists 2 (video)\n\n[Review] Linked lists in 4 minutes (video)\n\nC Code (video) - not the whole video, just portions about Node struct and memory allocation\n\nLinked List vs Arrays:\n\nCore Linked Lists Vs Arrays (video)\n\nIn The Real World Linked Lists Vs Arrays (video)\n\nWhy you should avoid linked lists (video)\n\nGotcha: you need pointer to pointer knowledge: (for when you pass a pointer to a function that may change the address where that pointer points) This page is just to get a grasp on ptr to ptr. I don't recommend this list traversal style. Readability and maintainability suffer due to cleverness.\n\nPointers to Pointers\n\nImplement (I did with tail pointer & without):\n\nsize() - returns the number of data elements in the list\n\nempty() - bool returns true if empty\n\nvalue_at(index) - returns the value of the nth item (starting at 0 for first)\n\npush_front(value) - adds an item to the front of the list\n\npop_front() - remove the front item and return its value\n\npush_back(value) - adds an item at the end\n\npop_back() - removes end item and returns its value\n\nfront() - get the value of the front item\n\nback() - get the value of the end item\n\ninsert(index, value) - insert value at index, so the current item at that index is pointed to by the new item at the index\n\nerase(index) - removes node at given index\n\nvalue_n_from_end(n) - returns the value of the node at the nth position from the end of the list\n\nreverse() - reverses the list\n\nremove_value(value) - removes the first item in the list with this value\n\nDoubly-linked List\n\nDescription (video)\n\nNo need to implement\n\nStacks (video)\n\n[Review] Stacks in 3 minutes (video)\n\nWill not implement. Implementing with the array is trivial\n\nQueue (video)\n\nCircular buffer/FIFO\n\n[Review] Queues in 3 minutes (video)\n\nImplement using linked-list, with tail pointer:\n\nenqueue(value) - adds value at a position at the tail\n\ndequeue() - returns value and removes least recently added element (front)\n\nempty()\n\nImplement using a fixed-sized array:\n\nenqueue(value) - adds item at end of available storage\n\ndequeue() - returns value and removes least recently added element\n\nempty()\n\nfull()\n\nCost:\n\na bad implementation using a linked list where you enqueue at the head and dequeue at the tail would be O(n) because you'd need the next to last element, causing a full traversal of each dequeue\n\nenqueue: O(1) (amortized, linked list and array [probing])\n\ndequeue: O(1) (linked list and array)\n\nempty: O(1) (linked list and array)\n\nHash table\n\nVideos:\n\nHashing with Chaining (video)\n\nTable Doubling, Karp-Rabin (video)\n\nOpen Addressing, Cryptographic Hashing (video)\n\nPyCon 2010: The Mighty Dictionary (video)\n\nPyCon 2017: The Dictionary Even Mightier (video)\n\n(Advanced) Randomization: Universal & Perfect Hashing (video)\n\n(Advanced) Perfect hashing (video)\n\n[Review] Hash tables in 4 minutes (video)\n\nOnline Courses:\n\nCore Hash Tables (video)\n\nData Structures (video)\n\nPhone Book Problem (video)\n\ndistributed hash tables:\n\nInstant Uploads And Storage Optimization In Dropbox (video)\n\nDistributed Hash Tables (video)\n\nImplement with array using linear probing\n\nhash(k, m) - m is the size of the hash table\n\nadd(key, value) - if the key already exists, update value\n\nexists(key)\n\nget(key)\n\nremove(key)\n\n⬆ back to top\n\nBinary search\n\nBinary Search (video)\n\nBinary Search (video)\n\ndetail\n\nblueprint\n\n[Review] Binary search in 4 minutes (video)\n\nImplement:\n\nbinary search (on a sorted array of integers)\n\nbinary search using recursion\n\nBitwise operations\n\nBits cheat sheet\n\nyou should know many of the powers of 2 from (2^1 to 2^16 and 2^32)\n\nGet a really good understanding of manipulating bits with: &, |, ^, ~, >>, <<\n\nwords\n\nGood intro: Bit Manipulation (video)\n\nC Programming Tutorial 2-10: Bitwise Operators (video)\n\nBit Manipulation\n\nBitwise Operation\n\nBithacks\n\nThe Bit Twiddler\n\nThe Bit Twiddler Interactive\n\nBit Hacks (video)\n\nPractice Operations\n\n2s and 1s complement\n\nBinary: Plusses & Minuses (Why We Use Two's Complement) (video)\n\n1s Complement\n\n2s Complement\n\nCount set bits\n\n4 ways to count bits in a byte (video)\n\nCount Bits\n\nHow To Count The Number Of Set Bits In a 32 Bit Integer\n\nSwap values:\n\nSwap\n\nAbsolute value:\n\nAbsolute Integer\n\n⬆ back to top\n\nTrees - Intro\n\nIntro to Trees (video)\n\nTree Traversal (video)\n\nBFS(breadth-first search) and DFS(depth-first search) (video)\n\nBFS notes:\n\nlevel order (BFS, using queue)\n\ntime complexity: O(n)\n\nspace complexity: best: O(1), worst: O(n/2)=O(n)\n\nDFS notes:\n\ntime complexity: O(n)\n\nspace complexity: best: O(log n) - avg. height of tree worst: O(n)\n\ninorder (DFS: left, self, right)\n\npostorder (DFS: left, right, self)\n\npreorder (DFS: self, left, right)\n\n[Review] Breadth-first search in 4 minutes (video)\n\n[Review] Depth-first search in 4 minutes (video)\n\n[Review] Tree Traversal (playlist) in 11 minutes (video)\n\nBinary search trees: BSTs\n\nBinary Search Tree Review (video)\n\nIntroduction (video)\n\nMIT (video)\n\nC/C++:\n\nBinary search tree - Implementation in C/C++ (video)\n\nBST implementation - memory allocation in stack and heap (video)\n\nFind min and max element in a binary search tree (video)\n\nFind the height of a binary tree (video)\n\nBinary tree traversal - breadth-first and depth-first strategies (video)\n\nBinary tree: Level Order Traversal (video)\n\nBinary tree traversal: Preorder, Inorder, Postorder (video)\n\nCheck if a binary tree is a binary search tree or not (video)\n\nDelete a node from Binary Search Tree (video)\n\nInorder Successor in a binary search tree (video)\n\nImplement:\n\ninsert // insert value into tree\n\nget_node_count // get count of values stored\n\nprint_values // prints the values in the tree, from min to max\n\ndelete_tree\n\nis_in_tree // returns true if a given value exists in the tree\n\nget_height // returns the height in nodes (single node's height is 1)\n\nget_min // returns the minimum value stored in the tree\n\nget_max // returns the maximum value stored in the tree\n\nis_binary_search_tree\n\ndelete_value\n\nget_successor // returns the next-highest value in the tree after given value, -1 if none\n\nHeap / Priority Queue / Binary Heap\n\nvisualized as a tree, but is usually linear in storage (array, linked list)\n\nHeap\n\nIntroduction (video)\n\nBinary Trees (video)\n\nTree Height Remark (video)\n\nBasic Operations (video)\n\nComplete Binary Trees (video)\n\nPseudocode (video)\n\nHeap Sort - jumps to start (video)\n\nHeap Sort (video)\n\nBuilding a heap (video)\n\nMIT 6.006 Introduction to Algorithms: Binary Heaps\n\nCS 61B Lecture 24: Priority Queues (video)\n\nLinear Time BuildHeap (max-heap)\n\n[Review] Heap (playlist) in 13 minutes (video)\n\nImplement a max-heap:\n\ninsert\n\nsift_up - needed for insert\n\nget_max - returns the max item, without removing it\n\nget_size() - return number of elements stored\n\nis_empty() - returns true if the heap contains no elements\n\nextract_max - returns the max item, removing it\n\nsift_down - needed for extract_max\n\nremove(x) - removes item at index x\n\nheapify - create a heap from an array of elements, needed for heap_sort\n\nheap_sort() - take an unsorted array and turn it into a sorted array in place using a max heap or min heap\n\n⬆ back to top\n\nNotes:\n\nImplement sorts & know best case/worst case, average complexity of each:\n\nno bubble sort - it's terrible - O(n^2), except when n <= 16\n\nStability in sorting algorithms (\"Is Quicksort stable?\")\n\nSorting Algorithm Stability\n\nStability In Sorting Algorithms\n\nStability In Sorting Algorithms\n\nSorting Algorithms - Stability\n\nWhich algorithms can be used on linked lists? Which on arrays? Which of both?\n\nI wouldn't recommend sorting a linked list, but merge sort is doable.\n\nMerge Sort For Linked List\n\nFor heapsort, see the Heap data structure above. Heap sort is great, but not stable\n\nSedgewick - Mergesort (5 videos)\n\n1. Mergesort\n\n2. Bottom-up Mergesort\n\n3. Sorting Complexity\n\n4. Comparators\n\n5. Stability\n\nSedgewick - Quicksort (4 videos)\n\n1. Quicksort\n\n2. Selection\n\n3. Duplicate Keys\n\n4. System Sorts\n\nUC Berkeley:\n\nCS 61B Lecture 29: Sorting I (video)\n\nCS 61B Lecture 30: Sorting II (video)\n\nCS 61B Lecture 32: Sorting III (video)\n\nCS 61B Lecture 33: Sorting V (video)\n\nCS 61B 2014-04-21: Radix Sort(video)\n\nBubble Sort (video)\n\nAnalyzing Bubble Sort (video)\n\nInsertion Sort, Merge Sort (video)\n\nInsertion Sort (video)\n\nMerge Sort (video)\n\nQuicksort (video)\n\nSelection Sort (video)\n\nMerge sort code:\n\nUsing output array (C)\n\nUsing output array (Python)\n\nIn-place (C++)\n\nQuick sort code:\n\nImplementation (C)\n\nImplementation (C)\n\nImplementation (Python)\n\n[Review] Sorting (playlist) in 18 minutes\n\nQuick sort in 4 minutes (video)\n\nHeap sort in 4 minutes (video)\n\nMerge sort in 3 minutes (video)\n\nBubble sort in 2 minutes (video)\n\nSelection sort in 3 minutes (video)\n\nInsertion sort in 2 minutes (video)\n\nImplement:\n\nMergesort: O(n log n) average and worst case\n\nQuicksort O(n log n) average case\n\nSelection sort and insertion sort are both O(n^2) average and worst-case\n\nFor heapsort, see Heap data structure above\n\nNot required, but I recommended them:\n\nSedgewick - Radix Sorts (6 videos)\n\n1. Strings in Java\n\n2. Key Indexed Counting\n\n3. Least Significant Digit First String Radix Sort\n\n4. Most Significant Digit First String Radix Sort\n\n5. 3 Way Radix Quicksort\n\n6. Suffix Arrays\n\nRadix Sort\n\nRadix Sort (video)\n\nRadix Sort, Counting Sort (linear time given constraints) (video)\n\nRandomization: Matrix Multiply, Quicksort, Freivalds' algorithm (video)\n\nSorting in Linear Time (video)\n\nAs a summary, here is a visual representation of 15 sorting algorithms. If you need more detail on this subject, see the \"Sorting\" section in Additional Detail on Some Subjects\n\n⬆ back to top\n\nGraphs can be used to represent many problems in computer science, so this section is long, like trees and sorting.\n\nNotes:\n\nThere are 4 basic ways to represent a graph in memory:\n\nobjects and pointers\n\nadjacency matrix\n\nadjacency list\n\nadjacency map\n\nFamiliarize yourself with each representation and its pros & cons\n\nBFS and DFS - know their computational complexity, their trade-offs, and how to implement them in real code\n\nWhen asked a question, look for a graph-based solution first, then move on if none\n\nMIT(videos):\n\nBreadth-First Search\n\nDepth-First Search\n\nSkiena Lectures - great intro:\n\nCSE373 2020 - Lecture 10 - Graph Data Structures (video)\n\nCSE373 2020 - Lecture 11 - Graph Traversal (video)\n\nCSE373 2020 - Lecture 12 - Depth First Search (video)\n\nCSE373 2020 - Lecture 13 - Minimum Spanning Trees (video)\n\nCSE373 2020 - Lecture 14 - Minimum Spanning Trees (con't) (video)\n\nCSE373 2020 - Lecture 15 - Graph Algorithms (con't 2) (video)\n\nGraphs (review and more):\n\n6.006 Single-Source Shortest Paths Problem (video)\n\n6.006 Dijkstra (video)\n\n6.006 Bellman-Ford (video)\n\n6.006 Speeding Up Dijkstra (video)\n\nAduni: Graph Algorithms I - Topological Sorting, Minimum Spanning Trees, Prim's Algorithm - Lecture 6 (video)\n\nAduni: Graph Algorithms II - DFS, BFS, Kruskal's Algorithm, Union Find Data Structure - Lecture 7 (video)\n\nAduni: Graph Algorithms III: Shortest Path - Lecture 8 (video)\n\nAduni: Graph Alg. IV: Intro to geometric algorithms - Lecture 9 (video)\n\nCS 61B 2014: Weighted graphs (video)\n\nGreedy Algorithms: Minimum Spanning Tree (video)\n\nStrongly Connected Components Kosaraju's Algorithm Graph Algorithm (video)\n\n[Review] Shortest Path Algorithms (playlist) in 16 minutes (video)\n\n[Review] Minimum Spanning Trees (playlist) in 4 minutes (video)\n\nFull Coursera Course:\n\nAlgorithms on Graphs (video)\n\nI'll implement:\n\nDFS with adjacency list (recursive)\n\nDFS with adjacency list (iterative with stack)\n\nDFS with adjacency matrix (recursive)\n\nDFS with adjacency matrix (iterative with stack)\n\nBFS with adjacency list\n\nBFS with adjacency matrix\n\nsingle-source shortest path (Dijkstra)\n\nminimum spanning tree\n\nDFS-based algorithms (see Aduni videos above):\n\ncheck for a cycle (needed for topological sort, since we'll check for the cycle before starting)\n\ntopological sort\n\ncount connected components in a graph\n\nlist strongly connected components\n\ncheck for bipartite graph\n\n⬆ back to top\n\nStanford lectures on recursion & backtracking:\n\nLecture 8 | Programming Abstractions (video)\n\nLecture 9 | Programming Abstractions (video)\n\nLecture 10 | Programming Abstractions (video)\n\nLecture 11 | Programming Abstractions (video)\n\nWhen it is appropriate to use it?\n\nHow is tail recursion better than not?\n\nWhat Is Tail Recursion Why Is It So Bad?\n\nTail Recursion (video)\n\n5 Simple Steps for Solving Any Recursive Problem(video)\n\nBacktracking Blueprint: Java Python\n\nDynamic Programming\n\nYou probably won't see any dynamic programming problems in your interview, but it's worth being able to recognize a problem as being a candidate for dynamic programming.\n\nThis subject can be pretty difficult, as each DP soluble problem must be defined as a recursion relation, and coming up with it can be tricky.\n\nI suggest looking at many examples of DP problems until you have a solid understanding of the pattern involved.\n\nVideos:\n\nSkiena: CSE373 2020 - Lecture 19 - Introduction to Dynamic Programming (video)\n\nSkiena: CSE373 2020 - Lecture 20 - Edit Distance (video)\n\nSkiena: CSE373 2020 - Lecture 20 - Edit Distance (continued) (video)\n\nSkiena: CSE373 2020 - Lecture 21 - Dynamic Programming (video)\n\nSkiena: CSE373 2020 - Lecture 22 - Dynamic Programming and Review (video)\n\nSimonson: Dynamic Programming 0 (starts at 59:18) (video)\n\nSimonson: Dynamic Programming I - Lecture 11 (video)\n\nSimonson: Dynamic programming II - Lecture 12 (video)\n\nList of individual DP problems (each is short): Dynamic Programming (video)\n\nYale Lecture notes:\n\nDynamic Programming\n\nCoursera:\n\nThe RNA secondary structure problem (video)\n\nA dynamic programming algorithm (video)\n\nIllustrating the DP algorithm (video)\n\nRunning time of the DP algorithm (video)\n\nDP vs. recursive implementation (video)\n\nGlobal pairwise sequence alignment (video)\n\nLocal pairwise sequence alignment (video)\n\nDesign patterns\n\nQuick UML review (video)\n\nLearn these patterns:\n\nstrategy\n\nsingleton\n\nadapter\n\nprototype\n\ndecorator\n\nvisitor\n\nfactory, abstract factory\n\nfacade\n\nobserver\n\nproxy\n\ndelegate\n\ncommand\n\nstate\n\nmemento\n\niterator\n\ncomposite\n\nflyweight\n\nSeries of videos (27 videos)\n\nBook: Head First Design Patterns\n\nI know the canonical book is \"Design Patterns: Elements of Reusable Object-Oriented Software\", but Head First is great for beginners to OO.\n\nHandy reference: 101 Design Patterns & Tips for Developers\n\nCombinatorics (n choose k) & Probability\n\nMath Skills: How to find Factorial, Permutation, and Combination (Choose) (video)\n\nMake School: Probability (video)\n\nMake School: More Probability and Markov Chains (video)\n\nKhan Academy:\n\nCourse layout:\n\nBasic Theoretical Probability\n\nJust the videos - 41 (each are simple and each are short):\n\nProbability Explained (video)\n\nNP, NP-Complete and Approximation Algorithms\n\nKnow about the most famous classes of NP-complete problems, such as the traveling salesman and the knapsack problem, and be able to recognize them when an interviewer asks you them in disguise.\n\nKnow what NP-complete means.\n\nComputational Complexity (video)\n\nSimonson:\n\nGreedy Algs. II & Intro to NP-Completeness (video)\n\nNP Completeness II & Reductions (video)\n\nNP Completeness III (Video)\n\nNP Completeness IV (video)\n\nSkiena:\n\nCSE373 2020 - Lecture 23 - NP-Completeness (video)\n\nCSE373 2020 - Lecture 24 - Satisfiability (video)\n\nCSE373 2020 - Lecture 25 - More NP-Completeness (video)\n\nCSE373 2020 - Lecture 26 - NP-Completeness Challenge (video)\n\nComplexity: P, NP, NP-completeness, Reductions (video)\n\nComplexity: Approximation Algorithms (video)\n\nComplexity: Fixed-Parameter Algorithms (video)\n\nPeter Norvig discusses near-optimal solutions to the traveling salesman problem:\n\nJupyter Notebook\n\nPages 1048 - 1140 in CLRS if you have it.\n\nHow computers process a program\n\nHow CPU executes a program (video)\n\nHow computers calculate - ALU (video)\n\nRegisters and RAM (video)\n\nThe Central Processing Unit (CPU) (video)\n\nInstructions and Programs (video)\n\nLRU cache:\n\nThe Magic of LRU Cache (100 Days of Google Dev) (video)\n\nImplementing LRU (video)\n\nLeetCode - 146 LRU Cache (C++) (video)\n\nCPU cache:\n\nMIT 6.004 L15: The Memory Hierarchy (video)\n\nMIT 6.004 L16: Cache Issues (video)\n\nProcesses and Threads\n\nComputer Science 162 - Operating Systems (25 videos):\n\nfor processes and threads see videos 1-11\n\nOperating Systems and System Programming (video)\n\nWhat Is The Difference Between A Process And A Thread?\n\nCovers:\n\nProcesses, Threads, Concurrency issues\n\nDifference between processes and threads\n\nProcesses\n\nThreads\n\nLocks\n\nMutexes\n\nSemaphores\n\nMonitors\n\nHow do they work?\n\nDeadlock\n\nLivelock\n\nCPU activity, interrupts, context switching\n\nModern concurrency constructs with multicore processors\n\nPaging, segmentation, and virtual memory (video)\n\nInterrupts (video)\n\nProcess resource needs (memory: code, static storage, stack, heap, and also file descriptors, i/o)\n\nThread resource needs (shares above (minus stack) with other threads in the same process but each has its own PC, stack counter, registers, and stack)\n\nForking is really copy on write (read-only) until the new process writes to memory, then it does a full copy.\n\nContext switching\n\nHow context switching is initiated by the operating system and underlying hardware?\n\nthreads in C++ (series - 10 videos)\n\nCS 377 Spring '14: Operating Systems from University of Massachusetts\n\nconcurrency in Python (videos):\n\nShort series on threads\n\nPython Threads\n\nUnderstanding the Python GIL (2010)\n\nreference\n\nDavid Beazley - Python Concurrency From the Ground Up LIVE! - PyCon 2015\n\nKeynote David Beazley - Topics of Interest (Python Asyncio)\n\nMutex in Python\n\nTo cover:\n\nhow unit testing works\n\nwhat are mock objects\n\nwhat is integration testing\n\nwhat is dependency injection\n\nAgile Software Testing with James Bach (video)\n\nOpen Lecture by James Bach on Software Testing (video)\n\nSteve Freeman - Test-Driven Development (that’s not what we meant) (video)\n\nslides\n\nDependency injection:\n\nvideo\n\nTao Of Testing\n\nHow to write tests\n\nString searching & manipulations\n\nSedgewick - Suffix Arrays (video)\n\nSedgewick - Substring Search (videos)\n\n1. Introduction to Substring Search\n\n2. Brute-Force Substring Search\n\n3. Knuth-Morris Pratt\n\n4. Boyer-Moore\n\n5. Rabin-Karp\n\nSearch pattern in a text (video)\n\nIf you need more detail on this subject, see the \"String Matching\" section in Additional Detail on Some Subjects.\n\nNote there are different kinds of tries. Some have prefixes, some don't, and some use strings instead of bits to track the path\n\nI read through the code, but will not implement\n\nSedgewick - Tries (3 videos)\n\n1. R Way Tries\n\n2. Ternary Search Tries\n\n3. Character Based Operations\n\nNotes on Data Structures and Programming Techniques\n\nShort course videos:\n\nIntroduction To Tries (video)\n\nPerformance Of Tries (video)\n\nImplementing A Trie (video)\n\nThe Trie: A Neglected Data Structure\n\nTopCoder - Using Tries\n\nStanford Lecture (real-world use case) (video)\n\nMIT, Advanced Data Structures, Strings (can get pretty obscure about halfway through) (video)\n\nFloating Point Numbers\n\nsimple 8-bit: Representation of Floating Point Numbers - 1 (video - there is an error in calculations - see video description)\n\nThe Absolute Minimum Every Software Developer Absolutely, Positively Must Know About Unicode and Character Sets\n\nWhat Every Programmer Absolutely, Positively Needs To Know About Encodings And Character Sets To Work With Text\n\nBig And Little Endian\n\nBig Endian Vs Little Endian (video)\n\nBig And Little Endian Inside/Out (video)\n\nVery technical talk for kernel devs. Don't worry if most is over your head.\n\nThe first half is enough.\n\nIf you have networking experience or want to be a reliability engineer or operations engineer, expect questions\n\nOtherwise, this is just good to know\n\nKhan Academy\n\nUDP and TCP: Comparison of Transport Protocols (video)\n\nTCP/IP and the OSI Model Explained! (video)\n\nPacket Transmission across the Internet. Networking & TCP/IP tutorial. (video)\n\nHTTP (video)\n\nSSL and HTTPS (video)\n\nSSL/TLS (video)\n\nHTTP 2.0 (video)\n\nVideo Series (21 videos) (video)\n\nSubnetting Demystified - Part 5 CIDR Notation (video)\n\nSockets:\n\nJava - Sockets - Introduction (video)\n\nSocket Programming (video)\n\n⬆ back to top\n\nThis section will have shorter videos that you can watch pretty quickly to review most of the important concepts. It's nice if you want a refresher often.\n\nSeries of 2-3 minutes short subject videos (23 videos)\n\nVideos\n\nSeries of 2-5 minutes short subject videos - Michael Sambol (48 videos):\n\nVideos\n\nCode Examples\n\nSedgewick Videos - Algorithms I\n\nSedgewick Videos - Algorithms II\n\n⬆ back to top\n\nUpdate Your Resume\n\nSee Resume prep information in the books: \"Cracking The Coding Interview\" and \"Programming Interviews Exposed\"\n\n\"This Is What A GOOD Resume Should Look Like\" by Gayle McDowell (author of Cracking the Coding Interview),\n\nNote by the author: \"This is for a US-focused resume. CVs for India and other countries have different expectations, although many of the points will be the same.\"\n\n\"Step-by-step resume guide\" by Tech Interview Handbook\n\nDetailed guide on how to set up your resume from scratch, write effective resume content, optimize it, and test your resume\n\n⬆ back to top\n\nHow to Pass the Engineering Interview in 2021\n\nDemystifying Tech Recruiting\n\nHow to Get a Job at the Big 4:\n\nHow to Get a Job at the Big 4 - Amazon, Facebook, Google & Microsoft (video)\n\nHow to Get a Job at the Big 4.1 (Follow-up video)\n\nCracking The Coding Interview Set 1:\n\nGayle L McDowell - Cracking The Coding Interview (video)\n\nCracking the Coding Interview with Author Gayle Laakmann McDowell (video)\n\nCracking the Facebook Coding Interview:\n\nThe Approach\n\nProblem Walkthrough\n\nPrep Courses:\n\nPython for Data Structures, Algorithms, and Interviews (paid course):\n\nA Python-centric interview prep course that covers data structures, algorithms, mock interviews, and much more.\n\nIntro to Data Structures and Algorithms using Python (Udacity free course):\n\nA free Python-centric data structures and algorithms course.\n\nData Structures and Algorithms Nanodegree! (Udacity paid Nanodegree):\n\nGet hands-on practice with over 100 data structures and algorithm exercises and guidance from a dedicated mentor to help prepare you for interviews and on-the-job scenarios.\n\nGrokking the Behavioral Interview (Educative free course):\n\nMany times, it’s not your technical competency that holds you back from landing your dream job, it’s how you perform on the behavioral interview.\n\nAlgoMonster (paid course with free content):\n\nThe crash course for LeetCode. Covers all the patterns condensed from thousands of questions.\n\nMock Interviews:\n\nGainlo.co: Mock interviewers from big companies - I used this and it helped me relax for the phone screen and on-site interview\n\nPramp: Mock interviews from/with peers - a peer-to-peer model to practice interviews\n\ninterviewing.io: Practice mock interview with senior engineers - anonymous algorithmic/systems design interviews with senior engineers from FAANG anonymously\n\nMeetapro: Mock interviews with top FAANG interviewers - an Airbnb-style mock interview/coaching platform.\n\nHello Interview: Mock Interviews with Expert Coaches and AI - interview directly with AI or with FAANG staff engineers and managers.\n\nCodemia: Practice system design problems with AI or community solutions and feedback - Practice system design problems via AI practice tool. Share your solution with the community to get human feedback as well.\n\n⬆ back to top\n\nThink of about 20 interview questions you'll get, along with the lines of the items below. Have at least one answer for each. Have a story, not just data, about something you accomplished.\n\nWhy do you want this job?\n\nWhat's a tough problem you've solved?\n\nBiggest challenges faced?\n\nBest/worst designs seen?\n\nIdeas for improving an existing product\n\nHow do you work best, as an individual and as part of a team?\n\nWhich of your skills or experiences would be assets in the role and why?\n\nWhat did you most enjoy at [job x / project y]?\n\nWhat was the biggest challenge you faced at [job x / project y]?\n\nWhat was the hardest bug you faced at [job x / project y]?\n\nWhat did you learn at [job x / project y]?\n\nWhat would you have done better at [job x / project y]?\n\n⬆ back to top\n\nSome of mine (I already may know the answers, but want their opinion or team perspective):\n\nHow large is your team?\n\nWhat does your dev cycle look like? Do you do waterfall/sprints/agile?\n\nAre rushes to deadlines common? Or is there flexibility?\n\nHow are decisions made in your team?\n\nHow many meetings do you have per week?\n\nDo you feel your work environment helps you concentrate?\n\nWhat are you working on?\n\nWhat do you like about it?\n\nWhat is the work life like?\n\nHow is the work/life balance?\n\n⬆ back to top\n\nCongratulations!\n\nKeep learning.\n\nYou're never really done.\n\n***************************************************************************************************** ***************************************************************************************************** Everything below this point is optional. It is NOT needed for an entry-level interview. However, by studying these, you'll get greater exposure to more CS concepts and will be better prepared for any software engineering job. You'll be a much more well-rounded software engineer. ***************************************************************************************************** *****************************************************************************************************\n\n⬆ back to top\n\nThese are here so you can dive into a topic you find interesting.\n\nThe Unix Programming Environment\n\nAn oldie but a goodie\n\nThe Linux Command Line: A Complete Introduction\n\nA modern option\n\nTCP/IP Illustrated Series\n\nHead First Design Patterns\n\nA gentle introduction to design patterns\n\nDesign Patterns: Elements of Reusable Object-Oriented Software\n\nAKA the \"Gang Of Four\" book or GOF\n\nThe canonical design patterns book\n\nAlgorithm Design Manual (Skiena)\n\nAs a review and problem-recognition\n\nThe algorithm catalog portion is well beyond the scope of difficulty you'll get in an interview\n\nThis book has 2 parts:\n\nClass textbook on data structures and algorithms\n\nPros:\n\nIs a good review as any algorithms textbook would be\n\nNice stories from his experiences solving problems in industry and academia\n\nCode examples in C\n\nCons:\n\nCan be as dense or impenetrable as CLRS, and in some cases, CLRS may be a better alternative for some subjects\n\nChapters 7, 8, and 9 can be painful to try to follow, as some items are not explained well or require more brain than I have\n\nDon't get me wrong: I like Skiena, his teaching style, and mannerisms, but I may not be Stony Brook material\n\nAlgorithm catalog:\n\nThis is the real reason you buy this book.\n\nThis book is better as an algorithm reference, and not something you read cover to cover.\n\nCan rent it on Kindle\n\nAnswers:\n\nSolutions\n\nErrata\n\nAlgorithm (Jeff Erickson)\n\nWrite Great Code: Volume 1: Understanding the Machine\n\nThe book was published in 2004, and is somewhat outdated, but it's a terrific resource for understanding a computer in brief\n\nThe author invented HLA, so take mentions and examples in HLA with a grain of salt. Not widely used, but decent examples of what assembly looks like\n\nThese chapters are worth the read to give you a nice foundation:\n\nChapter 2 - Numeric Representation\n\nChapter 3 - Binary Arithmetic and Bit Operations\n\nChapter 4 - Floating-Point Representation\n\nChapter 5 - Character Representation\n\nChapter 6 - Memory Organization and Access\n\nChapter 7 - Composite Data Types and Memory Objects\n\nChapter 9 - CPU Architecture\n\nChapter 10 - Instruction Set Architecture\n\nChapter 11 - Memory Architecture and Organization\n\nIntroduction to Algorithms\n\nImportant: Reading this book will only have limited value. This book is a great review of algorithms and data structures, but won't teach you how to write good code. You have to be able to code a decent solution efficiently\n\nAKA CLR, sometimes CLRS, because Stein was late to the game\n\nComputer Architecture, Sixth Edition: A Quantitative Approach\n\nFor a richer, more up-to-date (2017), but longer treatment\n\n⬆ back to top\n\nYou can expect system design questions if you have 4+ years of experience.\n\nScalability and System Design are very large topics with many topics and resources, since there is a lot to consider when designing a software/hardware system that can scale. Expect to spend quite a bit of time on this\n\nConsiderations:\n\nScalability\n\nDistill large data sets to single values\n\nTransform one data set to another\n\nHandling obscenely large amounts of data\n\nSystem design\n\nfeatures sets\n\ninterfaces\n\nclass hierarchies\n\ndesigning a system under certain constraints\n\nsimplicity and robustness\n\ntradeoffs\n\nperformance analysis and optimization\n\nSTART HERE: The System Design Primer\n\nSystem Design from HiredInTech\n\nHow Do I Prepare To Answer Design Questions In A Technical Interview?\n\n8 steps guide to ace your system design interview\n\nDatabase Normalization - 1NF, 2NF, 3NF and 4NF (video)\n\nSystem Design Interview - There are a lot of resources in this one. Look through the articles and examples. I put some of them below\n\nHow to ace a systems design interview\n\nNumbers Everyone Should Know\n\nHow long does it take to make a context switch?\n\nTransactions Across Datacenters (video)\n\nA plain English introduction to CAP Theorem\n\nMIT 6.824: Distributed Systems, Spring 2020 (20 videos)\n\nConsensus Algorithms:\n\nPaxos - Paxos Agreement - Computerphile (video)\n\nRaft - An Introduction to the Raft Distributed Consensus Algorithm (video)\n\nEasy-to-read paper\n\nInfographic\n\nConsistent Hashing\n\nNoSQL Patterns\n\nScalability:\n\nYou don't need all of these. Just pick a few that interest you.\n\nGreat overview (video)\n\nShort series:\n\nClones\n\nDatabase\n\nCache\n\nAsynchronism\n\nScalable Web Architecture and Distributed Systems\n\nFallacies of Distributed Computing Explained\n\nJeff Dean - Building Software Systems At Google and Lessons Learned (video)\n\nIntroduction to Architecting Systems for Scale\n\nScaling mobile games to a global audience using App Engine and Cloud Datastore (video)\n\nHow Google Does Planet-Scale Engineering for Planet-Scale Infra (video)\n\nThe Importance of Algorithms\n\nSharding\n\nEngineering for the Long Game - Astrid Atkinson Keynote(video)\n\n7 Years Of YouTube Scalability Lessons In 30 Minutes\n\nvideo\n\nHow PayPal Scaled To Billions Of Transactions Daily Using Just 8VMs\n\nHow to Remove Duplicates in Large Datasets\n\nA look inside Etsy's scale and engineering culture with Jon Cowie (video)\n\nWhat Led Amazon to its Own Microservices Architecture\n\nTo Compress Or Not To Compress, That Was Uber's Question\n\nWhen Should Approximate Query Processing Be Used?\n\nGoogle's Transition From Single Datacenter To Failover, To A Native Multihomed Architecture\n\nThe Image Optimization Technology That Serves Millions Of Requests Per Day\n\nA Patreon Architecture Short\n\nTinder: How Does One Of The Largest Recommendation Engines Decide Who You'll See Next?\n\nDesign Of A Modern Cache\n\nLive Video Streaming At Facebook Scale\n\nA Beginner's Guide To Scaling To 11 Million+ Users On Amazon's AWS\n\nA 360 Degree View Of The Entire Netflix Stack\n\nLatency Is Everywhere And It Costs You Sales - How To Crush It\n\nWhat Powers Instagram: Hundreds of Instances, Dozens of Technologies\n\nSalesforce Architecture - How They Handle 1.3 Billion Transactions A Day\n\nESPN's Architecture At Scale - Operating At 100,000 Duh Nuh Nuhs Per Second\n\nSee \"Messaging, Serialization, and Queueing Systems\" way below for info on some of the technologies that can glue services together\n\nTwitter:\n\nO'Reilly MySQL CE 2011: Jeremy Cole, \"Big and Small Data at @Twitter\" (video)\n\nTimelines at Scale\n\nFor even more, see the \"Mining Massive Datasets\" video series in the Video Series section\n\nPracticing the system design process: Here are some ideas to try working through on paper, each with some documentation on how it was handled in the real world:\n\nreview: The System Design Primer\n\nSystem Design from HiredInTech\n\ncheat sheet\n\nflow:\n\nUnderstand the problem and scope:\n\nDefine the use cases, with the interviewer's help\n\nSuggest additional features\n\nRemove items that the interviewer deems out of scope\n\nAssume high availability is required, add as a use case\n\nThink about constraints:\n\nAsk how many requests per month\n\nAsk how many requests per second (they may volunteer it or make you do the math)\n\nEstimate reads vs. writes percentage\n\nKeep the 80/20 rule in mind when estimating\n\nHow much data is written per second\n\nTotal storage required over 5 years\n\nHow much data read per second\n\nAbstract design:\n\nLayers (service, data, caching)\n\nInfrastructure: load balancing, messaging\n\nRough overview of any key algorithm that drives the service\n\nConsider bottlenecks and determine solutions\n\nExercises:\n\nDesign a random unique ID generation system\n\nDesign a key-value database\n\nDesign a picture sharing system\n\nDesign a recommendation system\n\nDesign a URL-shortener system: copied from above\n\nDesign a cache system\n\n⬆ back to top\n\nI added them to help you become a well-rounded software engineer and to be aware of certain technologies and algorithms, so you'll have a bigger toolbox.\n\nHow a Compiler Works in ~1 minute (video)\n\nHarvard CS50 - Compilers (video)\n\nC++ (video)\n\nUnderstanding Compiler Optimization (C++) (video)\n\nEmacs and vi(m)\n\nFamiliarize yourself with a UNIX-based code editor\n\nvi(m):\n\nEditing With Vim 01 - Installation, Setup, and The Modes (video)\n\nVIM Adventures\n\nset of 4 videos:\n\nThe vi/vim editor - Lesson 1\n\nThe vi/vim editor - Lesson 2\n\nThe vi/vim editor - Lesson 3\n\nThe vi/vim editor - Lesson 4\n\nUsing Vi Instead of Emacs\n\nemacs:\n\nBasics Emacs Tutorial (video)\n\nset of 3 (videos):\n\nEmacs Tutorial (Beginners) -Part 1- File commands, cut/copy/paste, cursor commands\n\nEmacs Tutorial (Beginners) -Part 2- Buffer management, search, M-x grep and rgrep modes\n\nEmacs Tutorial (Beginners) -Part 3- Expressions, Statements, ~/.emacs file, and packages\n\nEvil Mode: Or, How I Learned to Stop Worrying and Love Emacs (video)\n\nWriting C Programs With Emacs\n\nThe Absolute Beginner's Guide to Emacs (video by David Wilson)\n\nThe Absolute Beginner's Guide to Emacs (notes by David Wilson)\n\nUnix command line tools\n\nI filled in the list below from good tools.\n\nbash\n\ncat\n\ngrep\n\nsed\n\nawk\n\ncurl or wget\n\nsort\n\ntr\n\nuniq\n\nstrace\n\ntcpdump\n\nInformation theory (videos)\n\nKhan Academy\n\nMore about Markov processes:\n\nCore Markov Text Generation\n\nCore Implementing Markov Text Generation\n\nProject = Markov Text Generation Walk Through\n\nSee more in the MIT 6.050J Information and Entropy series below\n\nParity & Hamming Code (videos)\n\nIntro\n\nParity\n\nHamming Code:\n\nError detection\n\nError correction\n\nError Checking\n\nAlso see the videos below\n\nMake sure to watch information theory videos first\n\nInformation Theory, Claude Shannon, Entropy, Redundancy, Data Compression & Bits (video)\n\nAlso see the videos below\n\nMake sure to watch information theory videos first\n\nKhan Academy Series\n\nCryptography: Hash Functions\n\nCryptography: Encryption\n\nMake sure to watch information theory videos first\n\nComputerphile (videos):\n\nCompression\n\nEntropy in Compression\n\nUpside Down Trees (Huffman Trees)\n\nEXTRA BITS/TRITS - Huffman Trees\n\nElegant Compression in Text (The LZ 77 Method)\n\nText Compression Meets Probabilities\n\nCompressor Head videos\n\n(optional) Google Developers Live: GZIP is not enough!\n\nComputer Security\n\nMIT (23 videos)\n\nIntroduction, Threat Models\n\nControl Hijacking Attacks\n\nBuffer Overflow Exploits and Defenses\n\nPrivilege Separation\n\nCapabilities\n\nSandboxing Native Code\n\nWeb Security Model\n\nSecuring Web Applications\n\nSymbolic Execution\n\nNetwork Security\n\nNetwork Protocols\n\nSide-Channel Attacks\n\nGarbage collection\n\nGC in Python (video)\n\nDeep Dive Java: Garbage Collection is Good!\n\nDeep Dive Python: Garbage Collection in CPython (video)\n\nParallel Programming\n\nCoursera (Scala)\n\nEfficient Python for High-Performance Parallel Computing (video)\n\nMessaging, Serialization, and Queueing Systems\n\nThrift\n\nTutorial\n\nProtocol Buffers\n\nTutorials\n\ngRPC\n\ngRPC 101 for Java Developers (video)\n\nRedis\n\nTutorial\n\nAmazon SQS (queue)\n\nAmazon SNS (pub-sub)\n\nRabbitMQ\n\nGet Started\n\nCelery\n\nFirst Steps With Celery\n\nZeroMQ\n\nIntro - Read The Manual\n\nActiveMQ\n\nKafka\n\nMessagePack\n\nAvro\n\nA Search Algorithm\n\nA* Pathfinding (E01: algorithm explanation) (video)\n\nFast Fourier Transform\n\nAn Interactive Guide To The Fourier Transform\n\nWhat is a Fourier transform? What is it used for?\n\nWhat is the Fourier Transform? (video)\n\nDivide & Conquer: FFT (video)\n\nUnderstanding The FFT\n\nBloom Filter\n\nGiven a Bloom filter with m bits and k hashing functions, both insertion and membership testing are O(k)\n\nBloom Filters (video)\n\nBloom Filters | Mining of Massive Datasets | Stanford University (video)\n\nTutorial\n\nHow To Write A Bloom Filter App\n\nHow To Count A Billion Distinct Objects Using Only 1.5KB Of Memory\n\nLocality-Sensitive Hashing\n\nUsed to determine the similarity of documents\n\nThe opposite of MD5 or SHA which are used to determine if 2 documents/strings are exactly the same\n\nSimhashing (hopefully) made simple\n\nvan Emde Boas Trees\n\nDivide & Conquer: van Emde Boas Trees (video)\n\nMIT Lecture Notes\n\nAugmented Data Structures\n\nCS 61B Lecture 39: Augmenting Data Structures\n\nBalanced search trees\n\nKnow at least one type of balanced binary tree (and know how it's implemented):\n\n\"Among balanced search trees, AVL and 2/3 trees are now passé and red-black trees seem to be more popular. A particularly interesting self-organizing data structure is the splay tree, which uses rotations to move any accessed key to the root.\" - Skiena\n\nOf these, I chose to implement a splay tree. From what I've read, you won't implement a balanced search tree in your interview. But I wanted exposure to coding one up and let's face it, splay trees are the bee's knees. I did read a lot of red-black tree code\n\nSplay tree: insert, search, delete functions If you end up implementing a red/black tree try just these:\n\nSearch and insertion functions, skipping delete\n\nI want to learn more about B-Tree since it's used so widely with very large data sets\n\nSelf-balancing binary search tree\n\nAVL trees\n\nIn practice: From what I can tell, these aren't used much in practice, but I could see where they would be: The AVL tree is another structure supporting O(log n) search, insertion, and removal. It is more rigidly balanced than red–black trees, leading to slower insertion and removal but faster retrieval. This makes it attractive for data structures that may be built once and loaded without reconstruction, such as language dictionaries (or program dictionaries, such as the opcodes of an assembler or interpreter)\n\nMIT AVL Trees / AVL Sort (video)\n\nAVL Trees (video)\n\nAVL Tree Implementation (video)\n\nSplit And Merge\n\n[Review] AVL Trees (playlist) in 19 minutes (video)\n\nSplay trees\n\nIn practice: Splay trees are typically used in the implementation of caches, memory allocators, routers, garbage collectors, data compression, ropes (replacement of string used for long text strings), in Windows NT (in the virtual memory, networking and file system code) etc\n\nCS 61B: Splay Trees (video)\n\nMIT Lecture: Splay Trees:\n\nGets very mathy, but watch the last 10 minutes for sure.\n\nVideo\n\nRed/black trees\n\nThese are a translation of a 2-3 tree (see below).\n\nIn practice: Red–black trees offer worst-case guarantees for insertion time, deletion time, and search time. Not only does this make them valuable in time-sensitive applications such as real-time applications, but it makes them valuable building blocks in other data structures that provide worst-case guarantees; for example, many data structures used in computational geometry can be based on red-black trees, and the Completely Fair Scheduler used in current Linux kernels uses red–black trees. In version 8 of Java, the Collection HashMap has been modified such that instead of using a LinkedList to store identical elements with poor hashcodes, a Red-Black tree is used\n\nAduni - Algorithms - Lecture 4 (link jumps to the starting point) (video)\n\nAduni - Algorithms - Lecture 5 (video)\n\nRed-Black Tree\n\nAn Introduction To Binary Search And Red Black Tree\n\n[Review] Red-Black Trees (playlist) in 30 minutes (video)\n\n2-3 search trees\n\nIn practice: 2-3 trees have faster inserts at the expense of slower searches (since height is more compared to AVL trees).\n\nYou would use 2-3 trees very rarely because its implementation involves different types of nodes. Instead, people use Red-Black trees.\n\n23-Tree Intuition and Definition (video)\n\nBinary View of 23-Tree\n\n2-3 Trees (student recitation) (video)\n\n2-3-4 Trees (aka 2-4 trees)\n\nIn practice: For every 2-4 trees, there are corresponding red–black trees with data elements in the same order. The insertion and deletion operations on 2-4 trees are also equivalent to color-flipping and rotations in red–black trees. This makes 2-4 trees an important tool for understanding the logic behind red-black trees, and this is why many introductory algorithm texts introduce 2-4 trees just before red–black trees, even though 2-4 trees are not often used in practice.\n\nCS 61B Lecture 26: Balanced Search Trees (video)\n\nBottom Up 234-Trees (video)\n\nTop Down 234-Trees (video)\n\nN-ary (K-ary, M-ary) trees\n\nnote: the N or K is the branching factor (max branches)\n\nbinary trees are a 2-ary tree, with branching factor = 2\n\n2-3 trees are 3-ary\n\nK-Ary Tree\n\nB-Trees\n\nFun fact: it's a mystery, but the B could stand for Boeing, Balanced, or Bayer (co-inventor).\n\nIn Practice: B-trees are widely used in databases. Most modern filesystems use B-trees (or Variants). In addition to its use in databases, the B-tree is also used in filesystems to allow quick random access to an arbitrary block in a particular file. The basic problem is turning the file block address into a disk block (or perhaps to a cylinder head sector) address\n\nB-Tree\n\nB-Tree Datastructure\n\nIntroduction to B-Trees (video)\n\nB-Tree Definition and Insertion (video)\n\nB-Tree Deletion (video)\n\nMIT 6.851 - Memory Hierarchy Models (video) - covers cache-oblivious B-Trees, very interesting data structures - the first 37 minutes are very technical, and may be skipped (B is block size, cache line size)\n\n[Review] B-Trees (playlist) in 26 minutes (video)\n\nk-D Trees\n\nGreat for finding a number of points in a rectangle or higher-dimensional object\n\nA good fit for k-nearest neighbors\n\nkNN K-d tree algorithm (video)\n\nSkip lists\n\n\"These are somewhat of a cult data structure\" - Skiena\n\nRandomization: Skip Lists (video)\n\nFor animations and a little more detail\n\nNetwork Flows\n\nFord-Fulkerson in 5 minutes — Step by step example (video)\n\nFord-Fulkerson Algorithm (video)\n\nNetwork Flows (video)\n\nDisjoint Sets & Union Find\n\nUCB 61B - Disjoint Sets; Sorting & selection (video)\n\nSedgewick Algorithms - Union-Find (6 videos)\n\nMath for Fast Processing\n\nInteger Arithmetic, Karatsuba Multiplication (video)\n\nThe Chinese Remainder Theorem (used in cryptography) (video)\n\nCombination of a binary search tree and a heap\n\nTreap\n\nData Structures: Treaps explained (video)\n\nApplications in set operations\n\nLinear Programming (videos)\n\nLinear Programming\n\nFinding minimum cost\n\nFinding maximum value\n\nSolve Linear Equations with Python - Simplex Algorithm\n\nGeometry, Convex hull (videos)\n\nGraph Alg. IV: Intro to geometric algorithms - Lecture 9\n\nGeometric Algorithms: Graham & Jarvis - Lecture 10\n\nDivide & Conquer: Convex Hull, Median Finding\n\nDiscrete math\n\nComputer Science 70, 001 - Spring 2015 - Discrete Mathematics and Probability Theory\n\nDiscrete Mathematics by Shai Simonson (19 videos)\n\nDiscrete Mathematics By IIT Ropar NPTEL\n\n⬆ back to top\n\nI added these to reinforce some ideas already presented above, but didn't want to include them above because it's just too much. It's easy to overdo it on a subject. You want to get hired in this century, right?\n\nSOLID\n\nBob Martin SOLID Principles of Object Oriented and Agile Design (video)\n\nS - Single Responsibility Principle | Single responsibility to each Object\n\nmore flavor\n\nO - Open/Closed Principle | On production level Objects are ready for extension but not for modification\n\nmore flavor\n\nL - Liskov Substitution Principle | Base Class and Derived class follow ‘IS A’ Principle\n\nmore flavor\n\nI - Interface segregation principle | Clients should not be forced to implement interfaces they don't use\n\nInterface Segregation Principle in 5 minutes (video)\n\nmore flavor\n\nD -Dependency Inversion principle | Reduce the dependency In composition of objects.\n\nWhy Is The Dependency Inversion Principle And Why Is It Important\n\nmore flavor\n\nUnion-Find\n\nOverview\n\nNaive Implementation\n\nTrees\n\nUnion By Rank\n\nPath Compression\n\nAnalysis Options\n\nMore Dynamic Programming (videos)\n\n6.006: Dynamic Programming I: Fibonacci, Shortest Paths\n\n6.006: Dynamic Programming II: Text Justification, Blackjack\n\n6.006: DP III: Parenthesization, Edit Distance, Knapsack\n\n6.006: DP IV: Guitar Fingering, Tetris, Super Mario Bros.\n\n6.046: Dynamic Programming & Advanced DP\n\n6.046: Dynamic Programming: All-Pairs Shortest Paths\n\n6.046: Dynamic Programming (student recitation)\n\nAdvanced Graph Processing (videos)\n\nSynchronous Distributed Algorithms: Symmetry-Breaking. Shortest-Paths Spanning Trees\n\nAsynchronous Distributed Algorithms: Shortest-Paths Spanning Trees\n\nMIT Probability (mathy, and go slowly, which is good for mathy things) (videos):\n\nMIT 6.042J - Probability Introduction\n\nMIT 6.042J - Conditional Probability\n\nMIT 6.042J - Independence\n\nMIT 6.042J - Random Variables\n\nMIT 6.042J - Expectation I\n\nMIT 6.042J - Expectation II\n\nMIT 6.042J - Large Deviations\n\nMIT 6.042J - Random Walks\n\nSimonson: Approximation Algorithms (video)\n\nString Matching\n\nRabin-Karp (videos):\n\nRabin Karps Algorithm\n\nPrecomputing\n\nOptimization: Implementation and Analysis\n\nTable Doubling, Karp-Rabin\n\nRolling Hashes, Amortized Analysis\n\nKnuth-Morris-Pratt (KMP):\n\nTThe Knuth-Morris-Pratt (KMP) String Matching Algorithm\n\nBoyer–Moore string search algorithm\n\nBoyer-Moore String Search Algorithm\n\nAdvanced String Searching Boyer-Moore-Horspool Algorithms (video)\n\nCoursera: Algorithms on Strings\n\nstarts off great, but by the time it gets past KMP it gets more complicated than it needs to be\n\nnice explanation of tries\n\ncan be skipped\n\nSorting\n\nStanford lectures on sorting:\n\nLecture 15 | Programming Abstractions (video)\n\nLecture 16 | Programming Abstractions (video)\n\nShai Simonson:\n\nAlgorithms - Sorting - Lecture 2 (video)\n\nAlgorithms - Sorting II - Lecture 3 (video)\n\nSteven Skiena lectures on sorting:\n\nCSE373 2020 - Mergesort/Quicksort (video)\n\nCSE373 2020 - Linear Sorting (video)\n\nNAND To Tetris: Build a Modern Computer from First Principles\n\n⬆ back to top\n\nSit back and enjoy.\n\nList of individual Dynamic Programming problems (each is short)\n\nx86 Architecture, Assembly, Applications (11 videos)\n\nMIT 18.06 Linear Algebra, Spring 2005 (35 videos)\n\nExcellent - MIT Calculus Revisited: Single Variable Calculus\n\nSkiena lectures from Algorithm Design Manual - CSE373 2020 - Analysis of Algorithms (26 videos)\n\nUC Berkeley 61B (Spring 2014): Data Structures (25 videos)\n\nUC Berkeley 61B (Fall 2006): Data Structures (39 videos)\n\nUC Berkeley 61C: Machine Structures (26 videos)\n\nOOSE: Software Dev Using UML and Java (21 videos)\n\nMIT 6.004: Computation Structures (49 videos)\n\nCarnegie Mellon - Computer Architecture Lectures (39 videos)\n\nMIT 6.006: Intro to Algorithms (47 videos)\n\nMIT 6.033: Computer System Engineering (22 videos)\n\nMIT 6.034 Artificial Intelligence, Fall 2010 (30 videos)\n\nMIT 6.042J: Mathematics for Computer Science, Fall 2010 (25 videos)\n\nMIT 6.046: Design and Analysis of Algorithms (34 videos)\n\nMIT 6.824: Distributed Systems, Spring 2020 (20 videos)\n\nMIT 6.851: Advanced Data Structures (22 videos)\n\nMIT 6.854: Advanced Algorithms, Spring 2016 (24 videos)\n\nHarvard COMPSCI 224: Advanced Algorithms (25 videos)\n\nMIT 6.858 Computer Systems Security, Fall 2014\n\nStanford: Programming Paradigms (27 videos)\n\nIntroduction to Cryptography by Christof Paar\n\nCourse Website along with Slides and Problem Sets\n\nMining Massive Datasets - Stanford University (94 videos)\n\nGraph Theory by Sarada Herke (67 videos)\n\n⬆ back to top\n\nDirectory of Online CS Courses\n\nDirectory of CS Courses (many with online lectures)\n\n⬆ back to top\n\nMultiple Algorithms implementation by Princeton University\n\n⬆ back to top\n\nLove classic papers?\n\n1978: Communicating Sequential Processes\n\nimplemented in Go\n\n2003: The Google File System\n\nreplaced by Colossus in 2012\n\n2004: MapReduce: Simplified Data Processing on Large Clusters\n\nmostly replaced by Cloud Dataflow?\n\n2006: Bigtable: A Distributed Storage System for Structured Data\n\n2006: The Chubby Lock Service for Loosely-Coupled Distributed Systems\n\n2007: Dynamo: Amazon’s Highly Available Key-value Store\n\nThe Dynamo paper kicked off the NoSQL revolution\n\n2007: What Every Programmer Should Know About Memory (very long, and the author encourages skipping of some sections)\n\n2012: AddressSanitizer: A Fast Address Sanity Checker:\n\npaper\n\nvideo\n\n2013: Spanner: Google’s Globally-Distributed Database:\n\npaper\n\nvideo\n\n2015: Continuous Pipelines at Google\n\n2015: High-Availability at Massive Scale: Building Google’s Data Infrastructure for Ads\n\n2015: How Developers Search for Code: A Case Study\n\nMore papers: 1,000 papers\n\n⬆ back to top"
    }
}