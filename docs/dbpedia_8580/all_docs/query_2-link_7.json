{
    "id": "dbpedia_8580_2",
    "rank": 7,
    "data": {
        "url": "https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c",
        "read_more_link": "",
        "language": "en",
        "title": "The static keyword and its various uses in C++",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ca9a84fecd3f2fea333e8a1ef16edf98?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/50ccdbac5f0f9ff683e4b30a248189bf?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/e0dqd.png?s=64",
            "https://www.gravatar.com/avatar/fb0c398a608edb119f1ba636506ed18d?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/c887ee23ed8dba5874912b279e27198f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5d1e4893fe7a566e6e4b90876b642163?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2ac6b1d58f6014760597e7ef7a48ec74?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/d02ba61ff987df7f821d8790a6213e2d?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wq9T6.jpg?s=64",
            "https://www.gravatar.com/avatar/e85276c8e2da5d2de013a245df5d841e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ebaa8a6a2aad2915e09eef571816430e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/dbf47288de8dd866eb4ec1c9e126afef?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/dNJvC.jpg?s=64",
            "https://stackoverflow.com/posts/15235526/ivc/3e78?prg=4fdf6121-0495-4c4e-98d4-09e71dd66348"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2013-03-05T22:38:26",
        "summary": "",
        "meta_description": "The keyword static is one which has several meanings in C++ that I find very confusing and I can never bend my mind around how its actually supposed to work.\nFrom what I understand there is static",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/15235526/the-static-keyword-and-its-various-uses-in-c",
        "text": "In order to clarify the question, I would rather categorize the usage of 'static' keyword in three different forms:\n\n(A). variables\n\n(B). functions\n\n(C). member variables/functions of classes\n\nthe explanation follows below for each of the subheadings:\n\n(A) 'static' keyword for variables\n\nThis one can be little tricky however if explained and understood properly, it's pretty straightforward.\n\nTo explain this, first it is really useful to know about the scope, duration and linkage of variables, without which things are always difficult to see through the murky concept of static keyword\n\n1. Scope : Determines where in the file, the variable is accessible. It can be of two types: (i) Local or Block Scope. (ii) Global Scope\n\n2. Duration : Determines when a variable is created and destroyed. Again it's of two types: (i) Automatic Storage Duration (for variables having Local or Block scope). (ii) Static Storage Duration (for variables having Global Scope or local variables (in a function or a in a code block) with static specifier).\n\n3. Linkage: Determines whether a variable can be accessed (or linked ) in another file. Again ( and luckily) it is of two types: (i) Internal Linkage (for variables having Block Scope and Global Scope/File Scope/Global Namespace scope) (ii) External Linkage (for variables having only for Global Scope/File Scope/Global Namespace Scope)\n\nLet's refer an example below for a better understanding of plain global and local variables (no local variables with static storage duration) :\n\n//main file #include <iostream> int global_var1; //has global scope const global_var2(1.618); //has global scope int main() { //these variables are local to the block main. //they have automatic duration, i.e, they are created when the main() is // executed and destroyed, when main goes out of scope int local_var1(23); const double local_var2(3.14); { /* this is yet another block, all variables declared within this block have a local scope limited within this block. */ // all variables declared within this block too have automatic duration, i.e, /*they are created at the point of definition within this block, and destroyed as soon as this block ends */ char block_char1; int local_var1(32) //NOTE: this has been re-declared within the block, //it shadows the local_var1 declared outside std::cout << local_var1 <<\"\\n\"; //prints 32 }//end of block //local_var1 declared inside goes out of scope std::cout << local_var1 << \"\\n\"; //prints 23 global_var1 = 29; //global_var1 has been declared outside main (global scope) std::cout << global_var1 << \"\\n\"; //prints 29 std::cout << global_var2 << \"\\n\"; //prints 1.618 return 0; } //local_var1, local_var2 go out of scope as main ends //global_var1, global_var2 go out of scope as the program terminates //(in this case program ends with end of main, so both local and global //variables go out of scope together\n\nNow comes the concept of Linkage. When a global variable defined in one file is intended to be used in another file, the linkage of the variable plays an important role.\n\nThe Linkage of global variables is specified by the keywords: (i) static , and, (ii) extern\n\n( Now you get the explanation )\n\nstatic keyword can be applied to variables with local and global scope, and in both cases, they mean different things. I will first explain the usage of 'static' keyword in variables with global scope ( where I also clarify the usage of keyword 'extern') and later the usage for those with local scope.\n\n1. Static Keyword for variables with global scope\n\nGlobal variables have static duration, meaning they don't go out of scope when a particular block of code (e.g main() ) in which it is used ends . Depending upon the linkage, they can be either accessed only within the same file where they are declared (for static global variable), or outside the file even outside the file in which they are declared (extern type global variables)\n\nIn the case of a global variable having extern specifier, and if this variable is being accessed outside the file in which it has been initialized, it has to be forward declared in the file where it's being used, just like a function has to be forward declared if it's definition is in a file different from where it's being used.\n\nIn contrast, if the global variable has static keyword, it cannot be used in a file outside of which it has been declared.\n\n(see example below for clarification)\n\neg:\n\n//main2.cpp static int global_var3 = 23; /*static global variable, cannot be accessed in any other file */ extern double global_var4 = 71; /*can be accessed outside this file linked to main2.cpp */ int main() { return 0; }\n\nmain3.cpp\n\n//main3.cpp #include <iostream> int main() { extern int gloabl_var4; /*this variable refers to the gloabal_var4 defined in the main2.cpp file */ std::cout << global_var4 << \"\\n\"; //prints 71; return 0; }\n\nnow any variable in c++ can be either a const or a non-const and for each 'const-ness' we get two cases of default c++ linkage, in case none is specified:\n\n(i) If a global variable is non-const, its linkage is extern by default, i.e, the non-const global variable can be accessed in another .cpp file by forward declaration using the extern keyword (in other words, non const global variables have external linkage ( with static duration of course)). Also, usage of extern keyword in the original file where it has been defined is redundant. In this case, to make a non-const global variable inaccessible to external file, use the specifier 'static' before the type of the variable.\n\n(ii) If a global variable is const, its linkage is static by default, i.e a const global variable cannot be accessed in a file other than where it is defined, (in other words, const global variables have internal linkage (with static duration of course)). Also, usage of static keyword to prevent a const global variable from being accessed in another file is redundant. Here, to make a const global variable have an external linkage, use the specifier 'extern' before the type of the variable\n\nHere's a summary of global scope variables with various linkages\n\n//globalVariables1.cpp // defining uninitialized variables int globalVar1; // uninitialized global variable with external linkage static int globalVar2; // uninitialized global variable with internal linkage const int globalVar3; // error, since const variables must be initialized upon declaration const int globalVar4 = 23; //correct, but with static linkage (cannot be accessed outside the file where it has been declared*/ extern const double globalVar5 = 1.57; //this const variable can be accessed outside the file where it has been declared\n\nNext, we investigate how the above global variables behave when accessed in a different file.\n\n//using_globalVariables1.cpp (eg for the usage of global variables above) // Forward declaration via extern keyword: extern int globalVar1; // correct since globalVar1 is not a const or static extern int globalVar2; //incorrect since globalVar2 has internal linkage extern const int globalVar4; /* incorrect since globalVar4 has no extern specifier, limited to internal linkage by default (static specifier for const variables) */ extern const double globalVar5; /*correct since in the previous file, it has extern specifier, no need to initialize the const variable here, since it has already been legitimately defined previously */\n\nStatic Keyword for variables with Local Scope\n\nUpdates (August 2019) on static keyword for variables in local scope\n\nThis further can be subdivided in two categories :\n\n(i) static keyword for variables within a function block, and (ii) static keyword for variables within an unnamed local block.\n\n(i) static keyword for variables within a function block.\n\nEarlier, I mentioned that variables with local scope have automatic duration, i.e they come to exist when the block is entered ( be it a normal block, be it a function block) and cease to exist when the block ends, long story short, variables with local scope have automatic duration and automatic duration variables (and objects) have no linkage meaning they are not visible outside the code block.\n\nIf static specifier is applied to a local variable within a function block, it changes the duration of the variable from automatic to static and its lifetime is the entire duration of the program which means it has a fixed memory location and its value is initialized only once prior to program start up as mentioned in cpp reference(initialization should not be confused with assignment)\n\nlets take a look at an example.\n\n//localVarDemo1.cpp int localNextID() { int tempID = 1; //tempID created here return tempID++; //copy of tempID returned and tempID incremented to 2 } //tempID destroyed here, hence value of tempID lost int newNextID() { static int newID = 0;//newID has static duration, with internal linkage return newID++; //copy of newID returned and newID incremented by 1 } //newID doesn't get destroyed here :-) int main() { int employeeID1 = localNextID(); //employeeID1 = 1 int employeeID2 = localNextID(); // employeeID2 = 1 again (not desired) int employeeID3 = newNextID(); //employeeID3 = 0; int employeeID4 = newNextID(); //employeeID4 = 1; int employeeID5 = newNextID(); //employeeID5 = 2; return 0; }\n\nLooking at the above criterion for static local variables and static global variables, one might be tempted to ask, what the difference between them could be. While global variables are accessible at any point within the code (in the same as well as different translation units depending upon the const-ness and extern-ness), a static variable defined within a function block is not directly accessible. The variable has to be returned by the function value or reference. Lets demonstrate this by using an example:\n\n//localVarDemo2.cpp //static storage duration with global scope //note this variable can be accessed from outside the file //in a different compilation unit by using `extern` specifier //which might not be desirable for certain use cases. static int globalId = 0; int newNextID() { static int newID = 0;//newID has static duration, with internal linkage return newID++; //copy of newID returned and newID incremented by 1 } //newID doesn't get destroyed here int main() { //since globalId is accessible we use it directly const int globalEmployee1Id = globalId++; //globalEmployeeId1 = 0; const int globalEmployee2Id = globalId++; //globalEmployeeId1 = 1; //const int employeeID1 = newID++; //this will lead to compilation error since newID++ is not accessible direcly. int employeeID2 = newNextID(); //employeeID3 = 0; int employeeID2 = newNextID(); //employeeID3 = 1; return 0; }\n\nMore explanation about choice of static global and static local variables could be found on this stackoverflow thread\n\n(ii) static keyword for variables within an unnamed local block.\n\nstatic variables within a local block (not a function block) cannot be accessed outside the block once the local block goes out of scope. No caveats to this rule.\n\n//localVarDemo3.cpp int main() { { const static int static_local_scoped_variable {99}; }//static_local_scoped_variable goes out of scope //the line below causes compilation error //do_something is an arbitrary function do_something(static_local_scoped_variable); return 0; }\n\nC++11 introduced the keyword constexpr which guarantees the evaluation of an expression at compile time and allows the compiler to optimize the code. Now if the value of a static const variable within a scope is known at compile time, the code is optimized similarly to the one with constexpr. Here's a small example\n\nI recommend readers also to look up the difference between constexprand static const for variables in this stackoverflow thread. this concludes my explanation for the static keyword applied to variables.\n\nB. 'static' keyword used for functions\n\nin terms of functions, the static keyword has a straightforward meaning. Here, it refers to linkage of the function Normally all functions declared within a cpp file have external linkage by default, i.e a function defined in one file can be used in another cpp file by forward declaration.\n\nusing a static keyword before the function declaration limits its linkage to internal , i.e a static function cannot be used within a file outside of its definition.\n\nC. Static Keyword used for member variables and functions of classes\n\n1. 'static' keyword for member variables of classes\n\nI start directly with an example here\n\n#include <iostream> class DesignNumber { private: static int m_designNum; //design number int m_iteration; // number of iterations performed for the design public: DesignNumber() { } //default constructor int getItrNum() //get the iteration number of design { m_iteration = m_designNum++; return m_iteration; } static int m_anyNumber; //public static variable }; int DesignNumber::m_designNum = 0; // starting with design id = 0 // note : no need of static keyword here //causes compiler error if static keyword used int DesignNumber::m_anyNumber = 99; /* initialization of inclass public static member */ enter code here int main() { DesignNumber firstDesign, secondDesign, thirdDesign; std::cout << firstDesign.getItrNum() << \"\\n\"; //prints 0 std::cout << secondDesign.getItrNum() << \"\\n\"; //prints 1 std::cout << thirdDesign.getItrNum() << \"\\n\"; //prints 2 std::cout << DesignNumber::m_anyNumber++ << \"\\n\"; /* no object associated with m_anyNumber */ std::cout << DesignNumber::m_anyNumber++ << \"\\n\"; //prints 100 std::cout << DesignNumber::m_anyNumber++ << \"\\n\"; //prints 101 return 0; }\n\nIn this example, the static variable m_designNum retains its value and this single private member variable (because it's static) is shared b/w all the variables of the object type DesignNumber\n\nAlso like other member variables, static member variables of a class are not associated with any class object, which is demonstrated by the printing of anyNumber in the main function\n\nconst vs non-const static member variables in class\n\n(i) non-const class static member variables In the previous example the static members (both public and private) were non constants. ISO standard forbids non-const static members to be initialized in the class. Hence as in previous example, they must be initialized after the class definition, with the caveat that the static keyword needs to be omitted\n\n(ii) const-static member variables of class this is straightforward and goes with the convention of other const member variable initialization, i.e the const static member variables of a class can be initialized at the point of declaration and they can be initialized at the end of the class declaration with one caveat that the keyword const needs to be added to the static member when being initialized after the class definition.\n\nI would however, recommend to initialize the const static member variables at the point of declaration. This goes with the standard C++ convention and makes the code look cleaner\n\nfor more examples on static member variables in a class look up the following link from learncpp.com http://www.learncpp.com/cpp-tutorial/811-static-member-variables/\n\n2. 'static' keyword for member function of classes\n\nJust like member variables of classes can be static, so can member functions of classes. Normal member functions of classes are always associated with a object of the class type. In contrast, static member functions of a class are not associated with any object of the class, i.e they have no *this pointer.\n\nSecondly since the static member functions of the class have no *this pointer, they can be called using the class name and scope resolution operator in the main function (ClassName::functionName(); )\n\nThirdly static member functions of a class can only access static member variables of a class, since non-static member variables of a class must belong to a class object.\n\nfor more examples of static member functions in a class, look up the following link from learncpp.com\n\nhttp://www.learncpp.com/cpp-tutorial/812-static-member-functions/\n\nUpdate April 2021: static keyword and lambda expressions\n\nLambda expressions follow normal name lookup rules and hence the scope (local vs global) and storage class (static vs automatic) affect how the variables are available to the lambda expressions\n\nnon-static global variable is available to lambda expression within a local scope.\n\n//global member int i=10; int main(){ []{std::cout << i;}(); //prints 10 }\n\nNon-Static local variable is not available to lambda expression that appears within the same or a different scope. In this case, as we're mostly used to, the variables have to be captured by value or by reference\n\nint main(){ int i{11}; []{std::cout << i;}(); //compiler error [i]{std::cout << i;}(); //capture by value; correct //or [&i]{std::cout << i;}(); //capture by reference; correct }\n\nStatic variables locally scoped static variables can be captured by lambda expressions within the same or lower/child scope\n\nint main(){ static int i{12}; []{std::cout << i;}(); //prints 12 { []{std::cout << i;}();//also prints 12 } }\n\nHowever static variables in unnamed scope cannot be accessed outside the scope as explained previously"
    }
}