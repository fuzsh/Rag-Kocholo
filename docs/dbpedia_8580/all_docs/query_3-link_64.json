{
    "id": "dbpedia_8580_3",
    "rank": 64,
    "data": {
        "url": "https://fortran-lang.discourse.group/t/backwards-compatibility-in-different-programming-languages/4591",
        "read_more_link": "",
        "language": "en",
        "title": "Backwards compatibility in different programming languages",
        "top_image": "https://canada1.discourse-cdn.com/free1/uploads/fortran_lang/original/1X/50078338be6df8cfc3e2277e9cb3c805f45c6ee6.png",
        "meta_img": "https://canada1.discourse-cdn.com/free1/uploads/fortran_lang/original/1X/50078338be6df8cfc3e2277e9cb3c805f45c6ee6.png",
        "images": [
            "https://avatars.discourse-cdn.com/v4/letter/r/a3d4f5/48.png",
            "https://avatars.discourse-cdn.com/v4/letter/r/a3d4f5/48.png",
            "https://avatars.discourse-cdn.com/v4/letter/f/96bed5/48.png",
            "https://avatars.discourse-cdn.com/v4/letter/r/a3d4f5/48.png",
            "https://avatars.discourse-cdn.com/v4/letter/f/96bed5/48.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/pieru/48/1848_2.png",
            "https://avatars.discourse-cdn.com/v4/letter/f/96bed5/48.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/pieru/48/1848_2.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/jacobwilliams/48/10_2.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/jacobwilliams/48/10_2.png",
            "https://avatars.discourse-cdn.com/v4/letter/f/96bed5/48.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/pieru/48/1848_2.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/pieru/48/1848_2.png",
            "https://avatars.discourse-cdn.com/v4/letter/f/96bed5/48.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/pieru/48/1848_2.png",
            "https://sea1.discourse-cdn.com/free1/user_avatar/fortran-lang.discourse.group/pieru/48/1848_2.png",
            "https://avatars.discourse-cdn.com/v4/letter/r/a3d4f5/48.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-10-21T04:03:46+00:00",
        "summary": "",
        "meta_description": "I would point out that Python has: \n\nintroduced backwards incompatible syntax (in few cases on purpose even if they didn’t have to)\ndid not provide reliable tooling to automatically upgrade large code bases to the new s&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://canada1.discourse-cdn.com/free1/uploads/fortran_lang/optimized/1X/50078338be6df8cfc3e2277e9cb3c805f45c6ee6_2_32x32.png",
        "meta_site_name": "Fortran Discourse",
        "canonical_link": "https://fortran-lang.discourse.group/t/backwards-compatibility-in-different-programming-languages/4591",
        "text": "I would point out that Python has:\n\nintroduced backwards incompatible syntax (in few cases on purpose even if they didn’t have to)\n\ndid not provide reliable tooling to automatically upgrade large code bases to the new syntax\n\nremoved support of the old syntax from the compiler (interpreter)\n\nIn Fortran, even new compilers are implementing features that are even deleted from the standard (e.g., we implemented all kinds of assigned goto statements just a few weeks ago in LFortran). Fortran has introduced backwards incompatible syntax (free form). All compilers (even new ones) support the old syntax (it took us a few months to get a reliable fixed-form parser into LFortran).\n\nIf we introduce backwards incompatible change, we have to provide reliable and automatic tools to upgrade code bases. And we can’t remove support for the old feature from compilers, but as I’ve shown above, this is not even on the table.\n\nAll in all, I think the lesson from Python is not that we can’t introduce backwards incompatible changes, but rather all three points above is what we should not do. Old code must keep running.\n\nThis is entirely a warning without any merit whatsoever in the context of this Discourse that commenced in 2020.\n\nThere are essentially 2 utterly detrimental features that have in essence provided no redeeming benefits since 1980 that are being requested to be removed from the language around a decade from now, only because ripping these two from the “root” in the standard and throwing them out is the only path forward other than status quo:\n\nRemove from the standard implicit mapping, thus implicit none becomes the default in every standard-conforming program unit and interface body\n\nRemove from the standard implied save, so that an assignment-based definition on a type declaration requires an explicit SAVE attribute specification\n\nOf the two, it’s the first one with a wide impact since every new Fortranner would immediately need to be “lectured” on it and many are “lost” at such a “hello”. There is absolutely no basis for any computing enthusiast in 2032 starting to author in Fortran to be encumbered by FORTRAN’s one error-prone legacy imparted around the 1950s when so much else in the language has been deleted outright.\n\nRegardless, it is only the standard-conforming code that would be affected by the requested changes.\n\nA case in point is NASTRAN’s BISLOC as discussed previously on this site. It is an example of legacy code which is already broken in several ways relative to the standard, yet which can still be used with all the Fortran processors today. Removal of implicit mapping will be the least of its problems - how does one break something that is already broken? That is really bulk of legacy FORTRAN code - already broken vis-a-vis every edition of the standard starting ANSI 1966.\n\nAdditionally, with implicit mapping, the codes can easily get back the legacy feature with the introduction of a single line:\n\nimplicit integer(i-n), real(a-h,o-z)\n\nConcurrent to all this is the fact most Fortranners don’t know how to conform and the compiler vendors are more than willing to oblige their “indulgence”. The only compulsion anyone ever feels is having to introduce the ridiculous implicit none statement in every module, main program, and interface body so that they don’t come across as daft. Other than that, the FORTRAN codes are ever ready to “start world war III” given their tendency to not conform and the leeway given to processors to do anything with nonconforming code. This is totally different from the Python 2 / 3 situation.\n\nThere is in effect no comparison with the above 2 requests for backwardly incompatible feature changes in Fortran with what is being “suffered” by Python 2 apps.\n\nold and standard-conforming! That’s a hoot, alright!\n\nThe language standard for Fortran has deleted quite a few features that are error-prone and more detrimental to current and future practitioners than beneficial:\n\narithmetic IF,\n\nnonblock DO construct,\n\nHollerith edit descriptor\n\nto name a few. These features are actually employed in legacy codebases at a far greater frequency than implicit mapping, the latter being understood since 1970s, i.e., over 50 years ago, as pernicious and for which the implicit none alternative as a non-standard extension was immediately accepted by practitioners, so much so that the Fortran 90 standard over a dozen years after the ANSI 77 version had no recourse but to standardize it.\n\nSo did the sky coming falling down because the above features such as arithmetic IF, nonblock DO, Heolleriths, etc. - staple features in “old” codes - were deleted from the standard and because a conforming compiler would throw errors at compile time?\n\nNo. in fact the few and far in between folks, who look at the old FORTRAN code and are mostly revulsed by it, are happy if the compiler can give them some meaningful guidance to move forward. Some processors go out of their way like Intel which forces its users to do extra work to get new, standard-conforming behavior. So what is the problem with old code and future standard revisions? There is none, actually.\n\nOn the other hand, the voting members of the Fortran committee can be quite blasé when it is convenient for them to make subtle breaking changes which can silently and adversely affect program behavior such as the one change in Fortran 2023. None of the voting members nor the Community here appear to be bothered by it. Sure if a Fortran 2018 program being actually used in industry fails, so what - hell with it, they can go pound sand is the attitude, let the industry manager(s) budget for a migration to any one of the 20 or so programming languages / platforms that have >99% of the attention and positive rating of practitioners who want to write better and more performant code than with Fortran that has <0.8% rating and which holds on to implicit mapping when an overwhelming majority want to author type-safe code.\n\nThe alarm by @RonShepard about backward compatibility above, though kept general, is in reality only alluding to a couple of changes, like implicit mapping and implied save. These needless alarms are only hurting the language and its current and future practitioners besides ignoring and being inconsistent with goes on with Fortran.\n\nThe actual history of Fortran is in fact that more than several but consequential backwardly incompatible changes have been made and they continue to happen, like I have listed above.\n\n@PierU, to reiterate for the umpteenth time, no, that is not true at all. It’s entirely up to the processor how it wants to implement the facility, if at all or compel the users to do extra work to get standard-conforming behavior:\n\ninteger :: x(3), i do 5 i = 1, size(x) 5 x(i) = 40 + i do 10 i = 1, size(x) if ( x(i)-42 ) 20, 30, 40 20 print 21, i 21 format( 2Hx(, g0, 51H) holds a value less than the answer to everything ) go to 10 30 print 31, i 31 format( 2Hx(, g0, 33H) holds the answer to everything ) go to 10 40 print 41, i 41 format( 2Hx(, g0, 54H) holds a value greater than the answer to everything ) go to 10 10 continue end\n\nThe compiler processes this without raising any messages, no trouble with the nonconforming program:\n\nC:\\temp>ifort p.f90 Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.7.0 Build 20220726_000000 Copyright (C) 1985-2022 Intel Corporation. All rights reserved. Microsoft (R) Incremental Linker Version 14.33.31630.0 Copyright (C) Microsoft Corporation. All rights reserved. -out:p.exe -subsystem:console p.obj C:\\temp>p.exe x(1) holds a value less than the answer to everything x(2) holds the answer to everything x(3) holds a value greater than the answer to everything\n\nFinally when the program author is compelled by the circumstances to check against the standard and turn on warnings and even treat them as errors:\n\nC:\\temp>ifort /c /stand /warn:errors p.f90 Intel(R) Fortran Intel(R) 64 Compiler Classic for applications running on Intel(R) 64, Version 2021.7.0 Build 20220726_000000 Copyright (C) 1985-2022 Intel Corporation. All rights reserved. p.f90(2): error #8869: The labeled DO loop is an obsolescent feature in Fortran 2018. [5] do 5 i = 1, size(x) ------^ p.f90(3): error #8871: The nonblock form of the DO construct is deleted in Fortran 2018. 5 x(i) = 40 + i -^ p.f90(5): error #8869: The labeled DO loop is an obsolescent feature in Fortran 2018. [10] do 10 i = 1, size(x) ------^ p.f90(6): error #8870: The arithmetic IF statement has been deleted from Fortran 2018. if ( x(i)-42 ) 20, 30, 40 ---------------^ p.f90(14): error #7359: The cH edit descriptor has been deleted in Fortran 2018. [2Hx(] 41 format( 2Hx(, g0, 54H) holds a value greater than the answer to everything ) --------------^ p.f90(14): error #7359: The cH edit descriptor has been deleted in Fortran 2018. [54H) holds a value greater than the answer to ] 41 format( 2Hx(, g0, 54H) holds a value greater than the answer to everything ) ------------------------^ p.f90(11): error #7359: The cH edit descriptor has been deleted in Fortran 2018. [2Hx(] 31 format( 2Hx(, g0, 33H) holds the answer to everything ) --------------^ p.f90(11): error #7359: The cH edit descriptor has been deleted in Fortran 2018. [33H) holds the answer to everything ] 31 format( 2Hx(, g0, 33H) holds the answer to everything ) ------------------------^ p.f90(8): error #7359: The cH edit descriptor has been deleted in Fortran 2018. [2Hx(] 21 format( 2Hx(, g0, 51H) holds a value less than the answer to everything ) --------------^ p.f90(8): error #7359: The cH edit descriptor has been deleted in Fortran 2018. [51H) holds a value less than the answer to ] 21 format( 2Hx(, g0, 51H) holds a value less than the answer to everything ) ------------------------^ compilation aborted for p.f90 (code 1)\n\nA standard conforming compiler would be required to issue an error here.\n\nNo. If the implied save was to be suppressed, the code above would be illegal. This is not the same as accepting a delete feature which can be considered as an extension.\n\nRight, but nothing prevents compilers to issue such warnings right now when implied saves are encountered, without the need to change the standard.\n\nSorry but yes again. Your exemple just shows that by default, compilers usually process deleted features as extensions to the standard, which is nothing but new. A compiler can be fully standard-conforming AND accepting extensions. This is not error-prone, as there’s no way to use an “arithmetic if”, a “hollerith”, or a “do without enddo” by mistake.\n\nIn contrast, if implied saves were to be deleted from the standard, accepting them by default would be a violation of the standard by the compiler, and above all this would actually defeat the whole purpose of having deleted this feature.\n\nDeleting the implied save would also result in some apparent inconstency: module variables are implicitely saved as well, without requiring the save attribute. Should save be mandatory for module variables as well?\n\nIt might also be noted that in the case of Python the transition phase took more than a decade (Eleven years from the first release of Python 3 to the last release of Python 2.). During this phase there was a temporal non-availability of some important libraries for Python 3.\n\nAs Steve noted, the change even lead to the disappearance of some programs.\n\nStill, Python 3 is a successful (i.e. widely used and with a lot of available libraries) language now.\n\nI do not know what are the lessions to be learned, but as the user and developer base of Fortran is smaller than the one of Python, even the existing 20XX language standards are (my personal impression) adapted by the users rather slowly, and the person-hours Compiler vendors can invest in the development are limited, two fully parallel lines are in my opinion (I am not involved in developing compilers or essential libraries) just not acceptable.\n\nSo the situation might be different for Fortran when compared to python.\n\nEdit: Fixed some typos that made my comment hard to understand.\n\nSeveral matters have been inaccurately conflated here.\n\nA “feature”, regardless of whether it’s a “bug” or worse, is a feature. That in practice implied save gets employed by mistake is not relevant to technical aspects with the language standard. The relevance of this “use by mistake” is with the practical justification to delete the goddamn feature.\n\nAlso, the detrimental aspects, e.g., error-prone, around already deleted features, don’t all have to do with oh, someone used the feature by mistake or that they can’t do so. Rather the deletions have do with the accumulated experience where codes and compilers have encountered difficulties, say with nonblock DO, the use of labeled statements in GOTOs and with inner DO loops sharing the labeled statements to end the loops, etc. were leading to significant problems.\n\nNonetheless, the reality is “old codes” in FORTRAN don’t just die simply because of changes in the standard, there is no equivalence whatsoever with Python 2 / 3. Conflating the Python 2 matters with the Fortran standard is not right.\n\nSeparately, the semantics around the SAVE attribute of module variables and main programs are provided separately and there is no need to conflate them with local objects in subprograms.\n\nTo make a long story short, the two “features” of implicit mapping and implied save can be removed from the language standard with the maintainers of “old codes” not even realizing anything had changed unless they went looking for it. But that positive change in the standard, earliest it can happen is likely 2033 or so the standard revision cycles, can help the future practitioners. It is a practical matter involving vision toward the feature.\n\nI agree with this. In my opinion, no programmer should ever use implied save of local variables, the save attribute should always be specified explicitly. Prior to implied save, the semantics of initialization for local variables (including with DATA statements) for variables that were modified was undefined. Even in f77, where SAVE was first introduced to the language, programmers knew that the explicit save declaration was required. Modern fortran should have reinforced that convention. Instead the standard tried to do an end run and make previously nonconforming code conforming, introducing confusion and also causing problems with multithreaded parallelism. This was a mistake, and it was known at the time by most programmers that it was a mistake. I am still, even today, dumbfounded that this was done to my language of choice.\n\nI personally have mixed feelings about changing the standard now. Code has now been written that used this feature over the past 15+ years, so there is a backwards compatibility issue involved. I hope the standard committee doesn’t make these kinds of unforced errors in the future. Too many of them will kill the language.\n\nBut I do agree with the warning idea. Compilers should do this now, preferably by default, and if the standard can be changed to require this warning, with options to make it an error rather than a warning by the programmer, then I would fully support that. That approach does not break backward compatibility, while showing the relatively minor source code change that is required to eliminate the warning messages.\n\nThe elimination of implicit typing to me is a different matter. That would invalidate not only legacy code that programmers already use, but also code from textbooks, from netlib, and other established resources. My opinion is that elimination of implicit typing would also kill the language. If there are changes to implicit typing semantics, or to the syntax, the proponents must find a way to do it that maintains backwards compatibility as much as possible with 65+ years of legacy."
    }
}