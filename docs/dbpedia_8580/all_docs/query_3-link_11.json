{
    "id": "dbpedia_8580_3",
    "rank": 11,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/370135/why-are-multiple-programming-languages-used-in-the-development-of-one-product-or",
        "read_more_link": "",
        "language": "en",
        "title": "Why are multiple programming languages used in the development of one product or piece of software?",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://i.sstatic.net/M0IaD.jpg?s=64",
            "https://lh5.googleusercontent.com/-i4kKf4GsS7g/AAAAAAAAAAI/AAAAAAAABEw/BP0v6rCQFHM/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/a118d9aceb3c0e19b915c858e9860660?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/6b7474c84d6d2a5bc71c68656eb472cd?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Fm52y.png?s=64",
            "https://i.sstatic.net/MH7pk.png?s=64",
            "https://www.gravatar.com/avatar/e73733bc433f2680e270d390b340b66f?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/210c4fe8d0ec1633460a0bb88192d797?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/a56b8390b7457739ed8cc7cbd52bf251?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/599402c77aed8fa96fc13f7b071d31a8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/4tnZ9.jpg?s=64",
            "https://www.gravatar.com/avatar/1894f68e0b15fd3d5b27bfcb021fa11c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/c9c9c02c05c8913372c1cddea9d09a55?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6acc5ad435ce436520c23bad35c344c8?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/df163b8a55fa3258785cca0bfe5f224c?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://softwareengineering.stackexchange.com/posts/370135/ivc/3e78?prg=60ef29c5-0b6e-4618-b807-f1d1b0017de8"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2018-04-29T12:23:14",
        "summary": "",
        "meta_description": "I am a recent grad student aiming to start my Master's in Computer Science. I have come across multiple open source projects that really intrigue me and encourage me to contribute to them (CloudSta...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/370135/why-are-multiple-programming-languages-used-in-the-development-of-one-product-or",
        "text": "This answer has superb coverage and links on why different languages can provide distinct benefits to a project. However, there is quite a bit more than just language suitability involved in why projects end up using multiple languages.\n\nProjects end up using multiple languages for six main reasons:\n\nCost benefits of reusing code written in other languages;\n\nThe need to include and accommodate legacy code;\n\nAvailability of coders for specific languages;\n\nThe need for special languages for specialty needs;\n\nLegacy language biases; and\n\nPoor project management (unplanned multi-language use).\n\nReasons 1-4 are positive reasons in the sense that addressing them directly can help a project conclude faster, more efficiently, with a higher-quality product, and with easier long-term support. Reasons 5 and 6 are negative, symptoms of resistance to needed change, poor planning, ineffective management, or some combination of all of these factors. These negative factors unfortunately are common causes of \"accidental\" multi-language use.\n\nReason 1, the cost benefits of reuse, has become an increasingly powerful reason to allow the use of multiple languages in a project due both to the greater role of open source software and improved capabilities to find the right code components on the web. The \"let's code it all internally\" philosophy of past decades continues to fade in the face of economic realities, and is essentially never the most cost-effective approach for any new projects. This in turn makes opportunities for strict enforcement of the use of a single language within a project less common.\n\nEspecially in the case of a project reusing well-managed open source components, the use of multiple languages can provide huge overall cost benefits because the reused components are both hidden behind well-designed interfaces, and are independently maintained by zero-cost external groups. In best-case scenarios, mixing languages via this kind of reuse is no more costly to the project than using operating system components. I know of no better example of the value of this approach than Microsoft's large-scale adoption of open source software in their browsers.\n\nReason 2, the need to accommodate legacy code, is ignored at the peril of any large project. However much trouble legacy code may cause, naively assuming that it can be replaced easily with new code in a new language can be incredibly risky. Legacy code, even bad legacy code, often includes what amounts to an implicit \"contract\" of features expected by the community that uses the legacy product. That community quite often is a major source of revenue for a company, or the main target of support for government software. Simply discarding that implied contract can chase away customers in droves, and can bankrupt a company overnight if other options are readily available.\n\nAt the same time, not replacing old code in an old language can be just as dangerous as replacing it wholesale. A worst-case example is the U.S. Veterans Administration, which has a large number of vital systems coded in a language called MUMPS (no kidding) that was designed by medical doctors, not computer scientists. No one wants to learn MUMPS, and those who do know it are literally dying off. Programmers must therefore accommodate MUMPS even as they try to move forward to using other more common, more powerful, and better-maintained languages.\n\nThis type of multi-language use requires careful planning. That planning must navigate the knife edge between losing decades of customer knowledge on one hand, and losing the ability to support the software on the other. Techniques that isolate the old code behind well-defined interfaces, and which enable new more powerful code to replace the old code after its behaviors have been well documented, can help. But this legacy scenario is never easy, and has been (and will continue to be) the cause of the demise of many companies and organizations across a broad spectrum of sizes.\n\nReason 3, availability of coders for various languages, is a pragmatic factor that projects ignore at their peril. However much the project organizers may feel (correctly or incorrectly) that a particular language is best for their goals, if that language is in conflict with the language expertise pool available to them, both the schedule and quality of the product will suffer from the learning curved of programmers trying to learn a new language.\n\nA more rational approach is to analyze the language needs of the project based on functional areas. For example, looking carefully at the project may show that there is only a small \"apex\" of high-value code, e.g. for implementing some proprietary algorithm, that requires coding expertise in a some less commonly used language. Other parts of any large project are often easily accommodated by more common languages, or (even better) by well-managed open source products. Analyzing a project by language needs thus can provide a much more realistic and cost-effective approach to hiring or renting special expertise in special languages, and can also help sharpen the interfaces between languages within a single project.\n\nReason 4, using different languages for different needs, follows immediately and smoothly from performing that kind of analysis of project needs. Care should be used in this also, since selecting too many languages for support within a single project can cause a combinatorial explosion of complexity both in support and interfaces between components. The safest route cost-wise is always to find the maximum opportunities for reuse first, especially if there exist good packages that can meet project needs through little more than customization. Next, some kind of decision should be made on some small number of languages that can address the majority of identified needs. In reuse-intensive development, this will often be a type of glue code.\n\nIt is generally not a good idea to choose multiple languages with very similar capabilities just because some members of the project like one and some the other. However, if there are well-identified, well-defined capability subset that would benefit from special language skills, that can be a good reason for using multiple languages for new code development.\n\nReason 5, resistance to needed changes in the languages used, can be a cause of severe project disruption and internal strife. As user Daveo pointed out in a comment on this answer, change can be very difficult for some project personnel. At the same time, resistance to change is never a simple issue, which is precisely why it can cause much strife. Use of legacy language skills can be a powerful boost to the productivity of a project if the legacy language is sufficiently powerful, and can lead to a product with excellent quality in a team that operates smoothly and respects quality. However, legacy language skills must be balanced with the fact that many older languages can no longer compete with more recent languages in terms of advanced features, component availability, open source options, and intelligent tool kit support.\n\nBoth then and now, the single most common (and ironically, most often correct) argument for continuing to use a weaker, less readable, or less productive legacy language has been that the older language enables production of more efficient code. This is an old argument, one that goes all the way back to the 1950s when users of assembly language resented, often bitterly, the emergence of programming in FORTRAN and LISP. An example where even now the code efficiency argument can have validity can be seen in the processing-intensive code such as an operating systems kernel, where C remains the language of choice over C++ (though for reasons that go beyond simple efficiency).\n\nHowever, in the globally networked and powerfully machine-supported project environments of the new millennium, code efficiency as the main argument for choosing a project language has grown even weaker. The same explosion of computing and networking hardware that has enabled mass marketing of artificial intelligence applications also means that the costs of human programming can easily dwarf those of relativity inefficient code execution on spectacularly cheap hardware and cloudware. When that is combined with the greater availability for in more recent languages of component libraries, open source options, and advanced intelligent tool kits, the number of cases where keeping a language for efficiency reasons alone becomes very narrow. Even in cases where it does apply, the focus should be on using languages such as C that continue to have broad community support.\n\nA more compelling reason for a project to stay with legacy languages occurs when for whatever reasons a project has few or no options for changing its staff. This can happen for example when a major legacy product line is coded entirely in a language with which only the existing staff is fluent. In such cases the project must either continue down the path of trying to program in the old language, or attempt to train existing staff in how to use a new language.\n\nTraining legacy language staff in a new language can be a danger all by itself. I still recall a case where a member of a project that had just been trained and transitioned from C to C++ complained to me in all sincerity that he just did not understand the advantages of object-oriented methods. When I looked at his code, he had converted his earlier 103 C functions into 103 methods for a single C++ object class... and rightfully did not see how that helped anything.\n\nThe deeper message is that when people have programmed in a single language and language style for years or decades, the difficulty in getting them to \"think\" in new ways can become almost insurmountable, even with good training programs. In some cases may be no other option but to bring in younger designers and programmers who are more in tune with current trends and methods.\n\nReason 6, poor project management, speaks for itself. Language selection and use in a project should always be considered and assessed explicitly, and not allowed to happen just by accident. At the very least, language selection can make a huge difference in the long-term fate and support costs of a project, and so should always be taken into account and planned out. Don't become a MUMPS!\n\nI can't seem to understand the reason as to why multiple programming languages are used in the same product or software?\n\nIt is quite simple: there is no single programming language suitable for all needs and goals.\n\nRead Michael L. Scott's book Programming Language Pragmatics\n\nBe also aware of Rice's theorem. (it applies to static analyzers like Frama-C and compilers like GCC, and all Turing complete programming languages and implementations).\n\nSome programming languages favor expressiveness and declarativity (a lot of scripting languages, but also high-level programming languages like Agda, Prolog, Lisp, Haskell, Ocaml, ...). When the cost of development is important (human time and cost of developers), it is suitable to use them (even if the runtime performance is not optimal).\n\nOther programming languages favor run-time performance (many low-level languages, with usually compiled implementations, like C++, Rust, Go, C, assembler, also specialized languages like OpenCL ...); often their specification allows some undefined behavior. When the performance of the code matters, it is preferable to use these languages.\n\nOf course the performance is related to the compiler or interpreter of your programming language. Some naive compilers (e.g. for C, tinycc) are generating quickly slow code. Some bigger or more complex compiler (for the same C language, gcc) are able to generate (slowly) efficient code.\n\nSome external libraries are written in and for a particular language and ABI and calling conventions in mind. You may need to use that other language, and follow foreign function interface conventions, perhaps by writing some glue code.\n\nIn practice, it is unlikely to have a programming language which is highly expressive (so improves the productivity of the developer, assuming a skilled enough developer team) and very performant at runtime. In practice, there is a trade-off between expressivity and performance.\n\nNote: however, there has been some slow progress in programming languages: Rust is more expressive than C or perhaps even C++ but its implementation is almost as performant, and probably will improve to generate equally fast executables. So you need to learn new programming languages during your professional life; however there is No Silver Bullet\n\nNotice that the cost of development is more and more significant today (that was not the case in the 1970s -at that time computers where very costly- or in some embedded applications -with large volume of product). The rule of thumb (very approximate) is that a skilled developer is able to write about 25 thousand lines of (debugged & documented) source code each year, and that does not depend much on the programming language used.\n\nA common approach is to embed some scripting language (or some domain specific language) in a large application. This design idea (related to domain-specific language) has been used for decades (a good example is the Emacs source code editor, using Elisp for scripting since the 1980s). Then you'll use an easily embeddable interpreter (like Guile, Lua, Python, ...) inside a larger application. The decision to embed an interpreter inside a large application has to be done very early, and has strong architectural implications. You'll then use two languages: for low level stuff which has to run quickly, some low level language like C or C++; for high level scripts, the other DSL or scripting language.\n\nNotice also that a given software can run, within most current operating systems (including Linux, Windows, Android, MacOSX, Hurd, ...), in several cooperating processes using some kind of inter-process communication techniques. It can even run on several computers (or many of them), using distributed computing techniques (e.g. cloud computing, HPC, client server, web applications, etc...). In both cases, it is easy to use several programming languages (e.g. code each program running on one process or computer in its own programming language). Read Operating Systems: Three Easy Pieces for more. Also, foreign function interfaces (e.g. JNI), ABIs, calling conventions, etc... facilitate mixing several languages in the same program (or executable) - and you'll find code generators like SWIG to help.\n\nIn some cases, you have to mix several programming languages: web applications need Javascript or Webassembly (the only languages running inside most web browsers) for the part running in the browser (there are frameworks generating these, e.g. ocsigen). Kernel code need some stuff (e.g. the scheduler, or the low level handling of interrupts) to be partly written in assembler, because C or C++ cannot express what is needed there, RDBMS queries should use SQL, GPGPUs need computer kernels coded in OpenCL or CUDA managed by C or C++ host code, etc.... Some languages are designed to facilitate such a mixture (e.g. asm statements in C, code chunks in my late GCC MELT, etc...).\n\nIn some cases, you use metaprogramming techniques: some parts of your large software project would have code (e.g. in C or C++) generated by other tools (perhaps project specific tools) from some ad-hoc formalization: parser generators (improperly called compiler-compilers) like bison or ANTLR come to mind, but also SWIG or RPCGEN. And notice that GCC has more than a dozen of specialized C++ code generators (one for every internal DSL inside GCC) inside it. See also this example. Notice that metabugs are hard to find. Read also about bootstrapping compilers, and about homoiconicity and reflection (it is worthwhile to learn Lisp, play with SBCL, and to read SICP; look also into JIT-compiling libraries like GCCJIT; in some large programs you might generate some code at runtime using them; be aware of Greenspun's tenth rule). Look also into the Circuit Less Traveled talk at FOSDEM2018.\n\nSometimes, you want to provide formal annotations of your code (e.g. to help provers, static analyzers, compilers), using some specialized annotation language (which might be viewed as some DSL). Look into ACSL with Frama-C to annotate C programs (safety-critical ones), or OpenMP pragmas for HPC. Caveat: writing such annotations can require a lot of skills and development time.\n\nBTW, this suggests that some skills about compilers and interpreters are useful for every developer (even without working inside compilers). So read the Dragon Book even if you don't work on compilers. If you code your own interpreter (or if you design your DSL), read also Lisp In Small Pieces.\n\nSee also this & that & that & that answers of mine related to your question.\n\nStudy also the source code of several large free software projects (on github or from your Linux distribution) for inspiration and enlightenment.\n\nAlso, some programming languages evolved by adding annotations (as pragmas or comments) to existing languages. For examples, think of ACSL (a comment-extension to annotate C programs to enable their proofs by Frama-C) or of OpenCL (a C dialect to program GPGPUs) or OpenMP or OpenACC #pragmas or Common Lisp type annotations.\n\nPS: there are also social or organizational or historical reasons to mix programming languages; I'm ignoring them here, but I know that in practice such reasons are dominant. Read also The Mythical Man Month\n\nI can contribute an example, of a programming project which has been running for 38 years (as of 2024), and appears to still have plenty of life left in it. It's commercial rather than open-source.\n\nThe core is written in a domain-specific language, created specifically for the project. This has proved extremely useful, notably because it integrates rollback into the basic architecture, but it compiles into C code, which we then compile with the platform's compiler. It has supported about 23 platforms over that time, not counting 32- vs 64-bit variations, and currently ships on nine of those.\n\nIt has an add-on, written in C++, which was started when a past head of the project became convinced that C++/MFC/Windows/x86 was going to displace all other architectures and platforms, so it was necessary to offer C++ work to be able to hire staff. Things did not turn out as he expected.\n\nIn addition to the domain language and C++, developers work in LISP, which is used to write test cases, using an interpreter embedded in the test harness. We considered replacing LISP with Java at one point, but it turned out to be fortunate that we did not.\n\nIt also has a wrapper for its main API, written in C#. This was done when customers demanded it, so that they could re-write their applications in C#. It is created by a Perl script, which reads the C header files for the API, plus a significant configuration file, and writes the C# code for the wrapper. Doing all that text-processing in Perl was just easier than doing it in the domain language, C or C++.\n\nAn API wrapper in Python has also been created. This uses the parser from the C# wrapper generator, and writes the data to a JSON file, read by the Python code generator, which is written in Python.\n\nIt has build systems of its own, and needs them, because the domain language is not amenable to make-based build systems. The one for UNIX-like platforms is written in shell scripts, Perl and some small programs in the domain language. The one for Windows platforms is written in Perl, a little batch language, and the same small programs in the domain language. The old VMS build system was written in DCL, but that has not been used for over a decade. Python is used for writing new development tools that work on both Unix and Windows.\n\nThere's some YACC/Bison programming in the compiler for the special language. There's some testing code for Apple platforms written in Objective-C++. Some of the team's internal websites (used for project management, not part of the deliverables) are written in ASP, and others as CGI-scripts in Perl.\n\nBasically, this started as a project to address a hard problem, so it was worth creating specialised tools, which still seem more suitable for this job than anything else available. The team considers programming to be a skill that's somewhat independent of the language used, so they're willing to use a new language if it will make a task easier. However, fashion does not come high on their list of priorities, so they won't fragment a task by introducing a new language gratuitously.\n\nThe function of this code is mathematical modelling, used on workstations and servers (I can speak a bit more freely if I don't identify the product). It's currently about 25 million LoC, with a total team size of about fifty."
    }
}