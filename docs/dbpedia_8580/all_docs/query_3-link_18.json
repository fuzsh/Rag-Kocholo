{
    "id": "dbpedia_8580_3",
    "rank": 18,
    "data": {
        "url": "https://builtin.com/software-engineering-perspectives/new-programming-languages",
        "read_more_link": "",
        "language": "en",
        "title": "18 New Programming Languages to Learn in 2024",
        "top_image": "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=cover,w=1200,h=635,q=80/https://builtin.com/sites/www.builtin.com/files/hed-new-programming-languages.jpg",
        "meta_img": "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=cover,w=1200,h=635,q=80/https://builtin.com/sites/www.builtin.com/files/hed-new-programming-languages.jpg",
        "images": [
            "https://static.builtin.com/dist/images/bi-header-logo.svg",
            "https://static.builtin.com/dist/images/bi-header-logo.svg",
            "https://builtin.com/software-engineering-perspectives/company.logo",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,w=96,h=96,q=100/https://builtin.com/sites/www.builtin.com/files/2022-09/tatum%20hunter%20%281%29.jpeg",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=cover,w=320,h=200,q=80/https://builtin.com/sites/www.builtin.com/files/hed-new-programming-languages.jpg",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=contain,w=120,h=70,q=80/https://builtin.com/sites/www.builtin.com/files/2022-06/tech-ai-tools.png",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=contain,w=120,h=70,q=80/https://builtin.com/sites/www.builtin.com/files/2022-09/robot-code-robotics-robotic-programming-language.png",
            "https://cdn.builtin.com/cdn-cgi/image/f=auto,fit=contain,w=120,h=70,q=80/https://builtin.com/sites/www.builtin.com/files/2024-05/seaborn-pairplot.jpg",
            "https://static.builtin.com/dist/images/midnight_9.svg",
            "https://static.builtin.com/dist/images/builtin-logo.svg",
            "https://static.builtin.com/dist/images/united-we-tech.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Tatum Hunter"
        ],
        "publish_date": "2023-03-22T04:55:00+00:00",
        "summary": "",
        "meta_description": "Learning new programming languages can make you a better coder. Here are 18 new programming languages to learn now.",
        "meta_lang": "en",
        "meta_favicon": "https://static.builtin.com/dist/images/favicon.png",
        "meta_site_name": "Built In",
        "canonical_link": "https://builtin.com/software-engineering-perspectives/new-programming-languages",
        "text": "Learning a new programming language does more than just educate users on one specific area of coding. It can also help them sharpen problem-solving skills, boost their job opportunities and get a better understanding of technology as a whole.\n\nFor example, Ruby was software engineer Dillon Kearns’ first love, but then the functional programming language Elm entered the picture.\n\n“Even if an experiment is a failure and you decide not to use the language you tried,” Kearns said, “it makes you look at things a different way or leads you down a path where you learn about something else.”\n\nTo that end, here’s a list of newer programming languages you should know.\n\nMore on Software DevelopmentStop Talking About ‘Technical Debt’\n\nFunctional Programming Languages\n\n1. F#\n\nF# is an open-source, cross-platform language that takes on more of a hybrid position between general and functional languages. Many programmers find F# to offer the same kind of simplicity as Python while delivering a more seamless experience than C# and Java. This may be because the language avoids the clutter of semicolons, curly brackets and other symbols, so developers don’t have to worry about clarifying their object type. As a result, tasks such as list processing and applying complex type definitions are easier when working in F#.\n\nThe hybrid nature of F# also makes it compatible with other styles, including databases, websites and .NET entities. Whatever elements designers are working with, they can rely on the programming language’s strong type system to root out common errors. These factors all contribute to the flexibility and convenience of F#, which is why it remains a popular programming language.\n\nKey Takeaways:\n\nHybrid nature supports other styles.\n\nSimple design removes unnecessary symbols.\n\nType system detects common errors.\n\n2. Clojure\n\nClojure is a general-purpose language designed for concurrency, which means it supports multiple computations happening at the same time. But Clojure is also a Lisp language, keeping its syntax to a minimum. These elements facilitate a coding environment where developers can easily preserve code while building on previous projects to make changes as needed.\n\nThis programming language was also made for the Java Virtual Machine (JVM), so it pairs well with any system related to the JVM. It’s no surprise then that many companies have added Closure to their tech stacks, including Adobe, Apple and Netflix.\n\nKey Takeaways:\n\nSupports simultaneous computations.\n\nFeatures minimal syntax.\n\nWorks with JVM and other JVM-related systems.\n\n3. Elixir\n\n“There was this subset of the Ruby community that wandered down the Erlang rabbit hole, and they came out with Elixir,” Grove senior developer David Rogers said.\n\nElixir, however, is easier to write than Erlang, with the functional programming concepts of a language like Haskell. Elixir runs on the Erland virtual machine, which works well for low-latency distributed systems. The platform prioritizes scalability and fault tolerance. Lightweight threads of events, or processes, send messages to each other. Those processes can run concurrently, maximizing machine resources and making it easier to scale vertically or horizontally. If something goes wrong, the platform shows the developer the last known state that’s sure to work.\n\nKey Takeaways:\n\nCompatible with Erlang virtual machine.\n\nLightweight threads support concurrent processes.\n\nEasy vertical and horizontal scalability.\n\n4. PureScript\n\nPureScript is a purely functional programming language that compiles to JavaScript. Most comparable to Haskell, PureScript is best used for developing web applications and server-side apps. Like Haskell, it uses algebraic data types, pattern matching and type classes.\n\nPureScript’s types are expressive and support type inference, meaning that it requires far fewer explicit type annotations than other languages. One of its biggest strengths is its interoperability with other languages that target JavaScript.\n\nKey Takeaways:\n\nBest for developing web and server-side apps.\n\nTypes support type inference.\n\nWorks with other JavaScript-dependent languages.\n\n5. Swift\n\nSwift is a general-purpose compiled programming language developed by Apple that allows developers to write software for phones, servers, desktops or really anything else that runs on code.\n\nOriginally developed as a replacement for Apple’s earlier programming language, Objective-C, Swift combines ideas from other languages like Objective-C, Rust, Ruby and Python to help reduce common programming errors.\n\nThe language combines a powerful type inference with a modernized syntax that helps ideas to be clearly expressed through code. Swift is an especially important skill for those seeking iOS developer roles.\n\nKey Takeaways:\n\nEnables software for phones, desktops and other items.\n\nSuccessor to Apple’s Objective-C.\n\nFeatures modernized type interference and syntax.\n\nProcedural Programming Languages\n\n6. Go\n\nGo is a C-style language created by engineering leads at Google. Sleeker than C++ or Java and more typesafe than Ruby or Python, Go comes with benefits and drawbacks.\n\nSome drawbacks: Typing is strict. You can’t mix signed and unsigned integers, or integer sizes. Go also has some noticeable omissions: There are no generics and no inheritance. And if curly brackets instead of parentheses makes your blood boil — walk away now.\n\nBut Go’s simplicity creates some marked advantages. Namely, the language is easy to use. There’s less hiding behind the written code, and the lack of inheritance helps developers avoid webs of dependencies, making it a solid language for data science. Tight definitions and thread safety seem to be Go priorities, Rogers said.\n\nKey Takeaways:\n\nStrict typing and syntax.\n\nEasier navigation with no inheritance.\n\nPrioritizes thread safety.\n\nObject-Oriented Programming Languages\n\n7. Dart\n\nAnother C-style language from Google, Dart is like JavaScript with type safety. It can easily compile to JavaScript, native machine code or WebAssembly. It can also run back-end code.\n\nDart is good for building user interfaces with event-driven code. The hot reload command lets developers see changes to their applications instantaneously.\n\nSome other Dart advantages, according to one Dart team member: optional static types, minimal compile-time errors and a strong, built-in editor.\n\nKey Takeaways:\n\nCompiles to JavaScript, Java for Android and other platforms.\n\nGreat for designing user interfaces with event-driven code.\n\nDevelopers can view changes instantly.\n\n8. Apache Groovy\n\nApache Groovy integrates with the Java platform and was made with the purpose of making life easier for Java developers. The programming language showcases concise and flexible syntax, allowing developers to reduce the time it takes to complete projects. This trait is also one of many reasons why Apache Groovy comes with a flat learning curve, rivaling the simplicity of languages like Python.\n\nDevelopers don’t have to choose between static and dynamic languages since Apache Groovy supports both types. These features are what make Apache Groovy a great programming language for conducting tests. The syntax is designed to be test-friendly, leading many Java developers to embrace this language.\n\nKey Takeaways:\n\nConcise syntax speeds up projects.\n\nEasy to learn for Java developers.\n\nIdeal for conducting tests.\n\n9. Crystal\n\nCrystal is an object-oriented programming language that employs easy-to-learn syntax, especially for Ruby developers since the language takes its cue from Ruby’s simple syntax. The language is also static, allowing it to catch errors earlier on in the development process. This feature spares teams from making expensive mistakes during runtime, such as overlooking null references.\n\nAs an extra measure, Crystal provides built-in type inference, so developers don’t have to clarify which language they’re using every time. Crystal also supports concurrency with a fiber system, allowing developers to perform more computations without draining memory.\n\nKey Takeaways:\n\nSimple syntax like Ruby’s.\n\nCatches errors early in development process.\n\nBuilt-in type inference streamlines workflows.\n\n10. Pony\n\nPony is a language based on data-race-free typing and garbage collection, and uses the actor model as well as something called reference capabilities.\n\nReference capabilities compel the programmer to label pieces of data as mutable, immutable or isolated. If data is mutable, the compiler doesn’t allow the programmer to exchange the data between actors — when two actors access mutable data at the same time, they may make contradictory updates, or the data could get corrupted. Reference capabilities keep data safe and eliminate the need for locks to prevent concurrent data updates. With no locks, concurrent programs run faster.\n\nDown-sides to Pony are low API stability, few high-quality third-party libraries and limited native tooling.\n\nKey Takeaways:\n\nBased on data-race-free typing and garbage collection.\n\nReference capabilities require data to be labeled.\n\nLacks high-quality third-party libraries.\n\n11. TypeScript\n\nTypeScript is an open-source static type system built on top of JavaScript and maintained by Microsoft. So, it’s JavaScript, but with fewer ways to mess up. The TypeScript compiler checks for type mismatches and doles out compile-time errors to prevent runtime bugs.\n\nFor Java users, TypeScript may look especially familiar: “If you’re glancing at TypeScript — or looking at Angular code, which is all written in TypeScript — the code reads like Java 8. It just needed some annotations and some types, and look! It’s Java,” Rogers said.\n\nKey Takeaways:\n\nBuilt on top of JavaScript with more safety features.\n\nCompiler prevents runtime bugs.\n\nDesigned as a superset of JavaScript.\n\nMore on Software DevelopmentExtreme Programming Creator Kent Beck: Tech Has a Compassion Deficit\n\nOther Programming Languages to Know\n\n12. Julia\n\nJulia is a high-level, general-purpose programming language that can be used to write virtually any application. Though, its fast and heavy-lifting features make it useful for computational science, numerical analysis and especially big data analytics and other data analysis tasks. Julia is known for being a high-performance language that is dynamically typed and reproducible.\n\nJulia has real-world applications in everything from data visualization to machine learning. It’s used by British insurer Aviva for risk calculations, the Federal Reserve Bank of New York for financial modeling and even NASA for climate change modeling. It can also use libraries from Fortran, C++, R, Java, C and Python, making it one of the most highly sought-after new languages to learn.\n\nKey Takeaways:\n\nIdeal for computational science and numerical analysis.\n\nDynamic and reproducible language.\n\nSupports libraries from C/C++, R, Python and other languages.\n\n13. Kotlin\n\nKotlin is like a faster, sleeker version of Java that runs in the Java Virtual Machine. It’s now one the most preferred languages for Android development. According to Android’s developer site, its programmers switched to a Kotlin-first approach because the language comes with less boilerplate code, fewer null pointer exceptions and interoperability with Java.\n\nKotlin is useful for applications that run on both iOS and Android, programs that don’t use additional runtime or virtual machines and server-side applications.\n\nKey Takeaways:\n\nWorks with Java Virtual Machine.\n\nReduced boilerplate code and null pointer exceptions.\n\nGreat for developing iOS and Android applications.\n\n14. Python 3\n\nEven if you’re fluent with Python 2, Python 3 will come with some surprises. It diverges significantly from the 2.0 version, Rogers said.\n\nSo, why make the switch? Python 3 has more intuitive code, with better type safety. The differences between binary code, Unicode and plain text are easier to parse. It also comes with new commands like asyncio, which cuts down on threading issues, and concurrent.futures, which launches parallel tasks.\n\nKey Takeaways:\n\nMore intuitive code with type safety.\n\nClear differences between codes.\n\nConvenient commands like asyncio.\n\n15. Reason\n\nWhat if JavaScript was faster, simpler and typesafe? That’s the question the Facebook developer who created Reason set out to answer. Instead of building a new language from the ground up, though, he took OCaml, a language that’s syntactically similar to JavaScript at runtime, and adjusted it to resemble JavaScript.\n\nReason compiles to equivalent JavaScript using the project Melange and can be run in-browser. It can also compile to barebone assembly.\n\n“You’ll notice that most of these languages are becoming popular because of the faults in JavaScript, and its pervasiveness,” Rogers added.\n\nLike OCaml, Reason is functional and immutable, but allows users to opt in to objects and mutation. Its type system covers every line of code and infers types when none are defined, with guaranteed type accuracy after compiling.\n\nKey Takeaways:\n\nBased on making OCaml look more like JavaScript.\n\nCompiles to JavaScript, iOS and Android.\n\nType inference with guaranteed type accuracy.\n\n16. Red\n\nRed is a programming language originally designed to overcome limitations by the language Rebol. Introduced in 2011 and influenced by languages like Rebol, Lua and Scala, Red is useful for both high- and low-level programming.\n\nThe language can be used to develop everything from high-level GUIs to lower-level operating systems. Red boasts a human-friendly syntax, low memory footprint and is garbage collected. Its second part, Red/System, is similar to C and provides the flexibility to program many low-level programming capabilities.\n\nKey Takeaways:\n\nInfluenced by Rebol, Lua and Scala.\n\nFacilitates high- and low-level programming.\n\nLow memory footprint and intuitive syntax.\n\n17. Rust\n\nRust addresses some of the same problems as Go — thread safety and process safety at the system level — but with a focus on longevity, backwards compatibility and stability.\n\nLike Go, Rust has C-style syntax. But unlike Go and C++, Rust has a memory-safety-focused “borrow checker” that makes sure any data being referenced still exists. This, along with assigning code to potential edge cases to please the compiler, can slow developers down.\n\nBut the language’s static typing and lack of garbage collection can also make things go faster.\n\nDirect access to memory means programmers can write low-level code like operating system kernels. Rust is also a good fit for embedded devices, network services and command line editing.\n\nKey Takeaways:\n\nBrings longevity to safety issues.\n\nBorrow checker validates referenced data.\n\nStatic typing and no garbage collection speeds up processes.\n\n18. Mojo\n\nA programming language created for AI development, Mojo utilizes Python’s syntax and ecosystem, but it also has systems programming and metaprogramming features, giving it performance similar to C and C++. This lets developers program AI systems, including low-level AI hardware, all with one Python-like language. Mojo also uses the MLIR framework, allowing developers to manipulate vectors, threads and AI hardware units as well as leverage parallel processing capabilities. Over time, Mojo is designed to become a superset of Python.\n\nKey Takeaways:\n\nHas usability and syntax of Python and performance of C/C++.\n\nCreated for AI development.\n\nDesigned as a superset of Python.\n\nFrequently Asked Questions"
    }
}