{
    "id": "dbpedia_8580_3",
    "rank": 26,
    "data": {
        "url": "https://discourse.julialang.org/t/advantages-of-julia-vs-mojo/111614",
        "read_more_link": "",
        "language": "en",
        "title": "Advantages of Julia vs Mojo",
        "top_image": "https://global.discourse-cdn.com/julialang/original/3X/4/d/4d76a1d8062ed9397f2f00f22abdd69926b51785.png",
        "meta_img": "https://global.discourse-cdn.com/julialang/original/3X/4/d/4d76a1d8062ed9397f2f00f22abdd69926b51785.png",
        "images": [
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/phil_tomson/48/3575_2.png",
            "https://emoji.discourse-cdn.com/twitter/fire.png?v=12",
            "https://avatars.discourse-cdn.com/v4/letter/s/da6949/48.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/milkshakeforreal/48/32861_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/elrod/48/22461_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/elrod/48/22461_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/palli/48/3380_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-03-14T13:20:54+00:00",
        "summary": "",
        "meta_description": "Tomorrow I have a presentation concerning my package, but questions about Julia will surely arrive and likely about Mojo. \nI haven’t tried it, to those who did it (recently), what do you think are the user cases where Ju&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/julialang/optimized/3X/5/2/52e282d46eadd4022c458057bb740061d8efad72_2_32x32.png",
        "meta_site_name": "Julia Programming Language",
        "canonical_link": "https://discourse.julialang.org/t/advantages-of-julia-vs-mojo/111614",
        "text": "Whatever you do I suggest not being too defensive about Mojo. It’s a bit early to tell anyway, and it’s quite possible that Mojo will prove a brilliant alternative to Julia in various ways. But we’re not there yet.\n\nPersonally I think Mojo might be a great basis for large libraries like we have in Python (numpy, scikit-learn, etc.) while Julia will maintain its edge in terms of composability of unrelated packages. Also I like the unified design of Julia, vs the mix of two worlds that Mojo implements (e.g. with fn vs def).\n\nIt’s a statically-typed language without a garbage collector and requires that you do manual memory management and satisfy the borrow checking. Let’s look beyond the marketing: does that sound like a high-level language like Python? Yes, it’s a whitespace sensitive language, but trivial spelling differences do not make a language but the basic semantics and action do, and in that sense it’s nothing like Python.\n\nYes, you can omit this stuff, but then it will actually call a CPython interpreter and get CPython performance. That effectively means that there’s two backends, one which is Python and the other which is Mojo, and the Mojo one acts like Rust but the fallback + being whitespace sensitive is why it’s claimed as close to Python. However, if all of the code you actually have to write does not act like Python, or if it does it does not use the Mojo compiler, then is it really all that close to Python or is it a Rust-like language with a PyCall.jl feature baked in? I’d say it’s the latter because I would focus on the language, its semantics, and its features rather than just whether it ends for loops with a lack of indentation.\n\nOn the plus side, Rust is growing in popularity, is more memory safe when it comes to data races and consistently ranks very well on benchmarks even among other statically-typed languages. I am not much of a Rust fan myself due to its complexity and boilerplate but I think what may end up happening is that Mojo might lower the barrier of entry further for people with no systems programming background (most Python programmers) to help them dive into systems programming concepts (e.g memory management) to get some extra speed. If Mojo can avoid some of the complexity and boilerplate of Rust, it might be a good competitor in that space.\n\nAt the end of the day, Mojo will be a tool. People use tools to get jobs done. If the fastest and most flexible ML framework is written in Rust, more people will be using Rust and the framework will be wrapped in other programming languages including Python and Julia. If the Mojo team creates a language that makes it possible to: 1) write the fastest ML code (natively or based on their commercial MAX engine), 2) re-use some of the PyTorch/TensorFlow codebase and most of the tutorials, 3) easily call it from Python using Python syntax and a unified JIT compiler, and 4) easily deploy it on cloud, accelerators and edge devices, then more people and companies will likely flock to Mojo. But I guess we will see. We may be many years away from this during which the Julia devs may even choose to introduce Julia’s own no-GC, Rust-like dialect if Mojo proves a success, or allow for more Zig-like manual memory management with custom allocators (like Bumper.jl) and deferred de-allocation.\n\nRust and C++ do this automatically, too.\n\nC++ just doesn’t have the borrow checker (which makes it both a little easier to get code working and much easier to get code compiling-but-not working in C++ than Rust).\n\nManaging memory in languages without GC but that do have some form of scope based resource management (SBRM, aka RAII) isn’t that hard.\n\nYou should (almost?) never manually call malloc/free (or new/delete, or w/e) in a language like Rust or C++.\n\nThese aren’t C.\n\nIf you care about performance, a GC language requires much more manual memory management to work around the GC.\n\nIf performance isn’t a priority, a GC doesn’t take any work from the developer.\n\nEnough people complain about satisfying the borrow checker in Rust that it obviously isn’t trivial, and if someone has a hard time satisfying it in Rust, that might be a reason to be suspicious of code they wrote in C++: most C++ code should still follow all the rules Rust’s borrow checker enforces, you just don’t get one.\n\nMojo does have a minor innovation here, which is that instead of normal SBRM, where destructor calls are inserted at scope exit, they can insert them earlier, immediately after last use.\n\nI’m not sure how this is implemented, but hopefully it doesn’t preclude uses with other kinds of resources. E.g., in C++ to acquire a lock, you construct a lock-guard that frees the lock on scope-exit. You don’t want that to be moved earlier!\n\nThe advantages of being able to move them up are\n\nPotentially greater memory re-use and lower total memory use, thanks to earlier freeing, especially in big scope blocks. An obvious example where this could be big is if you chain a bunch of linear algebra operations.\n\nInserting destructor calls at the end of a function call precludes tail call optimizations.\n\nIMO, Mojo’s biggest innovation as a language is that you don’t need awkward FFI to call a static language from a dynamic one.\n\nLanguages like C++ and Rust are great in many ways for lots of tasks, but writing code you want to call interactively is a weakness. You need lots of boiler plate wrappers. Mojo solves that. This could be huge, IMO.\n\nA non-innovation that is important is that, apparently, you can call anything pythonic and people will just believe you and think it is easy. Marketing matters.\n\nFreeing earlier is “very different”?\n\nSeems like just a matter of removing a semantic guarantee, and then reordering.\n\nI think C++ has too many guarantees around allocations and deallocations being considered observable and thus untouchable by the optimizer, which is the primary thing stopping Clang from being able to do the same there in many cases.\n\nEDIT:\n\nActually\n\nThe “unspecified when and how” wording makes it possible to combine or optimize away heap allocations made by the standard library containers, even though such optimizations are disallowed for direct calls to ::operator new. For example, this is implemented by libc++ ([1] and [2]).\n\nhttps://en.cppreference.com/w/cpp/memory/allocator/allocate\n\nIt sounds like clang or gcc should be aloud to do such things, making it odd that they don’t. Standard containers, and other containers implemented using std::allocator rather than operator new should be able to be optimized in this way, but AFAIK they aren’t.\n\nJust to be clear I think you mean it’s easier to call from dynamic, e.g. Python or Julia, to (static) Mojo. Not from Mojo to any other static language.\n\nI don’t see why it’s it as difficult to call from Julia to e.g. C, or better Zig, or Mojo I guess. I don’t think you claim is it’s easier to call from Mojo, then e.g. from Julia or C++. It can be hard to call to C++ (e.g. because of name mangling, and maybe other issues), because of it rather than Julia (inherently). I believe it’s easy to call Rust, I think no name-mangling issue at least, and you get the full benefit of Rust code libraries, though the benefits may not translate to the full system (as if all the code where written in Rust or with a borrow-checker).\n\nIt’s not too hard to call Julia even with it a dynamic and a GC-language, just not wanted by many because of the GC. I.e. that I recall the Zig claim, you want to call it, reuse code from a non-GC language. With StaticCompiler.jl you get that for a limited subset of Julia. It’s a hassle and limited, but could it get better?"
    }
}