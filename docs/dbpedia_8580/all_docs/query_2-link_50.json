{
    "id": "dbpedia_8580_2",
    "rank": 50,
    "data": {
        "url": "https://www.learn-c.org/en/Linked_lists",
        "read_more_link": "",
        "language": "en",
        "title": "Free Interactive C Tutorial",
        "top_image": "https://www.learn-c.org/static/img/share-logos/learn-c.org.png",
        "meta_img": "https://www.learn-c.org/static/img/share-logos/learn-c.org.png",
        "images": [
            "https://www.learn-c.org/static/img/favicons/learn-c.org.ico",
            "https://www.learn-c.org/static/img/icon20x24px-exported-transparent.png",
            "https://www.learn-c.org/static/img/banners/cfk/cfk-billboard.png",
            "https://www.learn-c.org/static/img/banners/cfk/cfk-billboard.png",
            "https://www.learn-c.org/static/img/banners/cfk/promo_high.png",
            "https://www.learn-c.org/static/img/banners/digital-ocean.svg",
            "https://www.learn-c.org/static/img/logos/spoj.png",
            "https://www.learn-c.org/static/img/masterschool.png",
            "https://www.learn-c.org/static/img/masterschool.png",
            "https://www.learn-c.org/static/img/masterschool.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Learn",
            "C",
            "Tutorial",
            "Interactive",
            "Free"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "learn-c.org is a free interactive C tutorial for people who want to learn C, fast.",
        "meta_lang": "en",
        "meta_favicon": "/static/img/favicons/learn-c.org.ico",
        "meta_site_name": "",
        "canonical_link": "https://www.learn-c.org/",
        "text": "Linked lists\n\nIntroduction\n\nLinked lists are the best and simplest example of a dynamic data structure that uses pointers for its implementation. However, understanding pointers is crucial to understanding how linked lists work, so if you've skipped the pointers tutorial, you should go back and redo it. You must also be familiar with dynamic memory allocation and structures.\n\nEssentially, linked lists function as an array that can grow and shrink as needed, from any point in the array.\n\nLinked lists have a few advantages over arrays:\n\nItems can be added or removed from the middle of the list\n\nThere is no need to define an initial size\n\nHowever, linked lists also have a few disadvantages:\n\nThere is no \"random\" access - it is impossible to reach the nth item in the array without first iterating over all items up until that item. This means we have to start from the beginning of the list and count how many times we advance in the list until we get to the desired item.\n\nDynamic memory allocation and pointers are required, which complicates the code and increases the risk of memory leaks and segment faults.\n\nLinked lists have a much larger overhead over arrays, since linked list items are dynamically allocated (which is less efficient in memory usage) and each item in the list also must store an additional pointer.\n\nWhat is a linked list?\n\nA linked list is a set of dynamically allocated nodes, arranged in such a way that each node contains one value and one pointer. The pointer always points to the next member of the list. If the pointer is NULL, then it is the last node in the list.\n\nA linked list is held using a local pointer variable which points to the first item of the list. If that pointer is also NULL, then the list is considered to be empty.\n\n------------------------------ ------------------------------ | | | \\ | | | | DATA | NEXT |--------------| DATA | NEXT | | | | / | | | ------------------------------ ------------------------------\n\nLet's define a linked list node:\n\ntypedef struct node { int val; struct node * next; } node_t;\n\nNotice that we are defining the struct in a recursive manner, which is possible in C. Let's name our node type node_t.\n\nNow we can use the nodes. Let's create a local variable which points to the first item of the list (called head).\n\nnode_t * head = NULL; head = (node_t *) malloc(sizeof(node_t)); if (head == NULL) { return 1; } head->val = 1; head->next = NULL;\n\nWe've just created the first variable in the list. We must set the value, and the next item to be empty, if we want to finish populating the list. Notice that we should always check if malloc returned a NULL value or not.\n\nTo add a variable to the end of the list, we can just continue advancing to the next pointer:\n\nnode_t * head = NULL; head = (node_t *) malloc(sizeof(node_t)); head->val = 1; head->next = (node_t *) malloc(sizeof(node_t)); head->next->val = 2; head->next->next = NULL;\n\nThis can go on and on, but what we should actually do is advance to the last item of the list, until the next variable will be NULL.\n\nIterating over a list\n\nLet's build a function that prints out all the items of a list. To do this, we need to use a current pointer that will keep track of the node we are currently printing. After printing the value of the node, we set the current pointer to the next node, and print again, until we've reached the end of the list (the next node is NULL).\n\nvoid print_list(node_t * head) { node_t * current = head; while (current != NULL) { printf(\"%d\\n\", current->val); current = current->next; } }\n\nAdding an item to the end of the list\n\nTo iterate over all the members of the linked list, we use a pointer called current. We set it to start from the head and then in each step, we advance the pointer to the next item in the list, until we reach the last item.\n\nvoid push(node_t * head, int val) { node_t * current = head; while (current->next != NULL) { current = current->next; } /* now we can add a new variable */ current->next = (node_t *) malloc(sizeof(node_t)); current->next->val = val; current->next->next = NULL; }\n\nThe best use cases for linked lists are stacks and queues, which we will now implement:\n\nAdding an item to the beginning of the list (pushing to the list)\n\nTo add to the beginning of the list, we will need to do the following:\n\nCreate a new item and set its value\n\nLink the new item to point to the head of the list\n\nSet the head of the list to be our new item\n\nThis will effectively create a new head to the list with a new value, and keep the rest of the list linked to it.\n\nSince we use a function to do this operation, we want to be able to modify the head variable. To do this, we must pass a pointer to the pointer variable (a double pointer) so we will be able to modify the pointer itself.\n\nvoid push(node_t ** head, int val) { node_t * new_node; new_node = (node_t *) malloc(sizeof(node_t)); new_node->val = val; new_node->next = *head; *head = new_node; }\n\nRemoving the first item (popping from the list)\n\nTo pop a variable, we will need to reverse this action:\n\nTake the next item that the head points to and save it\n\nFree the head item\n\nSet the head to be the next item that we've stored on the side\n\nHere is the code:\n\nint pop(node_t ** head) { int retval = -1; node_t * next_node = NULL; if (*head == NULL) { return -1; } next_node = (*head)->next; retval = (*head)->val; free(*head); *head = next_node; return retval; }\n\nRemoving the last item of the list\n\nRemoving the last item from a list is very similar to adding it to the end of the list, but with one big exception - since we have to change one item before the last item, we actually have to look two items ahead and see if the next item is the last one in the list:\n\nint remove_last(node_t * head) { int retval = 0; /* if there is only one item in the list, remove it */ if (head->next == NULL) { retval = head->val; free(head); return retval; } /* get to the second to last node in the list */ node_t * current = head; while (current->next->next != NULL) { current = current->next; } /* now current points to the second to last item of the list, so let's remove current->next */ retval = current->next->val; free(current->next); current->next = NULL; return retval; }\n\nRemoving a specific item\n\nTo remove a specific item from the list, either by its index from the beginning of the list or by its value, we will need to go over all the items, continuously looking ahead to find out if we've reached the node before the item we wish to remove. This is because we need to change the location to where the previous node points to as well.\n\nHere is the algorithm:\n\nIterate to the node before the node we wish to delete\n\nSave the node we wish to delete in a temporary pointer\n\nSet the previous node's next pointer to point to the node after the node we wish to delete\n\nDelete the node using the temporary pointer\n\nThere are a few edge cases we need to take care of, so make sure you understand the code.\n\nint remove_by_index(node_t ** head, int n) { int i = 0; int retval = -1; node_t * current = *head; node_t * temp_node = NULL; if (n == 0) { return pop(head); } for (i = 0; i < n-1; i++) { if (current->next == NULL) { return -1; } current = current->next; } if (current->next == NULL) { return -1; } temp_node = current->next; retval = temp_node->val; current->next = temp_node->next; free(temp_node); return retval; }\n\nExercise"
    }
}