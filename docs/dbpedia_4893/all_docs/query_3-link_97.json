{
    "id": "dbpedia_4893_3",
    "rank": 97,
    "data": {
        "url": "https://www.oracle.com/technical-resources/articles/java/javareflection.html",
        "read_more_link": "",
        "language": "en",
        "title": "Using Java Reflection",
        "top_image": "https://www.oracle.com/asset/web/favicons/favicon-32.png",
        "meta_img": "https://www.oracle.com/asset/web/favicons/favicon-32.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.oracle.com/asset/web/favicons/favicon-32.png",
        "meta_site_name": "",
        "canonical_link": "https://www.oracle.com/technical-resources/articles/java/javareflection.html",
        "text": "Reflection is a feature in the Java programming language. It allows an executing Java program to examine or \"introspect\" upon itself, and manipulate internal properties of the program. For example, it's possible for a Java class to obtain the names of all its members and display them.\n\nThe ability to examine and manipulate a Java class from within itself may not sound like very much, but in other programming languages this feature simply doesn't exist. For example, there is no way in a Pascal, C, or C++ program to obtain information about the functions defined within that program.\n\nOne tangible use of reflection is in JavaBeans, where software components can be manipulated visually via a builder tool. The tool uses reflection to obtain the properties of Java components (classes) as they are dynamically loaded.\n\nA Simple Example\n\nTo see how reflection works, consider this simple example:\n\nFor an invocation of:\n\njava DumpMethods java.util.Stack\n\nthe output is:\n\nThat is, the method names of class java.util.Stack are listed, along with their fully qualified parameter and return types.\n\nThis program loads the specified class using class.forName, and then calls getDeclaredMethods to retrieve the list of methods defined in the class. java.lang.reflect.Method is a class representing a single class method.\n\nSetting Up to Use Reflection\n\nThe reflection classes, such as Method, are found in java.lang.reflect. There are three steps that must be followed to use these classes. The first step is to obtain a java.lang.Class object for the class that you want to manipulate. java.lang.Class is used to represent classes and interfaces in a running Java program.\n\nOne way of obtaining a Class object is to say:\n\nClass c = Class.forName(\"java.lang.String\"); to get the Class object for String. Another approach is to use: Class c = int.class; or Class c = Integer.TYPE; to obtain Class information on fundamental types. The latter approach accesses the predefined TYPE field of the wrapper (such as Integer) for the fundamental type.\n\nThe second step is to call a method such as getDeclaredMethods, to get a list of all the methods declared by the class.\n\nOnce this information is in hand, then the third step is to use the reflection API to manipulate the information. For example, the sequence:\n\nClass c = Class.forName(\"java.lang.String\"); Method m[] = c.getDeclaredMethods(); System.out.println(m[0].toString());\n\nwill display a textual representation of the first method declared in String.\n\nIn the examples below, the three steps are combined to present self contained illustrations of how to tackle specific applications using reflection.\n\nSimulating the instanceof Operator\n\nOnce Class information is in hand, often the next step is to ask basic questions about the Class object. For example, the Class.isInstance method can be used to simulate the instanceof operator:\n\nIn this example, a Class object for A is created, and then class instance objects are checked to see whether they are instances of A. Integer(37) is not, but new A() is.\n\nFinding Out About Methods of a Class\n\nOne of the most valuable and basic uses of reflection is to find out what methods are defined within a class. To do this the following code can be used:\n\nThe program first gets the Class description for method1, and then calls getDeclaredMethods to retrieve a list of Method objects, one for each method defined in the class. These include public, protected, package, and private methods. If you use getMethods in the program instead of getDeclaredMethods, you can also obtain information for inherited methods.\n\nOnce a list of the Method objects has been obtained, it's simply a matter of displaying the information on parameter types, exception types, and the return type for each method. Each of these types, whether they are fundamental or class types, is in turn represented by a Class descriptor. The output of the program is:\n\nObtaining Information About Constructors\n\nA similar approach is used to find out about the constructors of a class. For example:\n\nThere is no return-type information retrieved in this example, because constructors don't really have a true return type.\n\nWhen this program is run, the output is:\n\nFinding Out About Class Fields\n\nIt's also possible to find out which data fields are defined in a class. To do this, the following code can be used:\n\nThis example is similar to the previous ones. One new feature is the use of Modifier. This is a reflection class that represents the modifiers found on a field member, for example \"private int\". The modifiers themselves are represented by an integer, and Modifier.toString is used to return a string representation in the \"official\" declaration order (such as \"static\" before \"final\"). The output of the program is:\n\nAs with methods, it's possible to obtain information about just the fields declared in a class (getDeclaredFields), or to also get information about fields defined in superclasses (getFields).\n\nInvoking Methods by Name\n\nSo far the examples that have been presented all relate to obtaining class information. But it's also possible to use reflection in other ways, for example to invoke a method of a specified name.\n\nTo see how this works, consider the following example:\n\nSuppose that a program wants to invoke the add method, but doesn't know this until execution time. That is, the name of the method is specified during execution (this might be done by a JavaBeans development environment, for example). The above program shows a way of doing this.\n\ngetMethod is used to find a method in the class that has two integer parameter types and that has the appropriate name. Once this method has been found and captured into a Method object, it is invoked upon an object instance of the appropriate type. To invoke a method, a parameter list must be constructed, with the fundamental integer values 37 and 47 wrapped in Integer objects. The return value (84) is also wrapped in an Integer object.\n\nCreating New Objects\n\nThere is no equivalent to method invocation for constructors, because invoking a constructor is equivalent to creating a new object (to be the most precise, creating a new object involves both memory allocation and object construction). So the nearest equivalent to the previous example is to say:\n\nwhich finds a constructor that handles the specified parameter types and invokes it, to create a new instance of the object. The value of this approach is that it's purely dynamic, with constructor lookup and invocation at execution time, rather than at compilation time.\n\nChanging Values of Fields\n\nAnother use of reflection is to change the values of data fields in objects. The value of this is again derived from the dynamic nature of reflection, where a field can be looked up by name in an executing program and then have its value changed. This is illustrated by the following example:\n\nIn this example, the d field has its value set to 12.34.\n\nUsing Arrays\n\nOne final use of reflection is in creating and manipulating arrays. Arrays in the Java language are a specialized type of class, and an array reference can be assigned to an Object reference.\n\nTo see how arrays work, consider the following example:\n\nThis example creates a 10-long array of Strings, and then sets location 5 in the array to a string value. The value is retrieved and displayed.\n\nA more complex manipulation of arrays is illustrated by the following code:\n\nThis example creates a 5 x 10 x 15 array of ints, and then proceeds to set location [3][5][10] in the array to the value 37. Note here that a multi-dimensional array is actually an array of arrays, so that, for example, after the first Array.get, the result in arrobj is a 10 x 15 array. This is peeled back once again to obtain a 15-long array, and the 10th slot in that array is set using Array.setInt.\n\nNote that the type of array that is created is dynamic, and does not have to be known at compile time.\n\nSummary\n\nJava reflection is useful because it supports dynamic retrieval of information about classes and data structures by name, and allows for their manipulation within an executing Java program. This feature is extremely powerful and has no equivalent in other conventional languages such as C, C++, Fortran, or Pascal.\n\nGlen McCluskey has focused on programming languages since 1988. He consults in the areas of Java and C++ performance, testing, and technical documentation."
    }
}