{
    "id": "wrong_mix_property_subsidiary_00101_3",
    "rank": 71,
    "data": {
        "url": "https://openid.net/specs/openid-connect-core-1_0.html",
        "read_more_link": "",
        "language": "en",
        "title": "Final: OpenID Connect Core 1.0 incorporating errata set 2",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "OpenID Connect Core 1.0 incorporating errata set 2",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "TOC\n\nOpenID Connect Core 1.0 incorporating errata set 2\n\nAbstract\n\nOpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 protocol. It enables Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.\n\nThis specification defines the core OpenID Connect functionality: authentication built on top of OAuth 2.0 and the use of Claims to communicate information about the End-User. It also describes the security and privacy considerations for using OpenID Connect.\n\nTable of Contents\n\n1. Introduction\n\n1.1. Requirements Notation and Conventions\n\n1.2. Terminology\n\n1.3. Overview\n\n2. ID Token\n\n3. Authentication\n\n3.1. Authentication using the Authorization Code Flow\n\n3.1.1. Authorization Code Flow Steps\n\n3.1.2. Authorization Endpoint\n\n3.1.2.1. Authentication Request\n\n3.1.2.2. Authentication Request Validation\n\n3.1.2.3. Authorization Server Authenticates End-User\n\n3.1.2.4. Authorization Server Obtains End-User Consent/Authorization\n\n3.1.2.5. Successful Authentication Response\n\n3.1.2.6. Authentication Error Response\n\n3.1.2.7. Authentication Response Validation\n\n3.1.3. Token Endpoint\n\n3.1.3.1. Token Request\n\n3.1.3.2. Token Request Validation\n\n3.1.3.3. Successful Token Response\n\n3.1.3.4. Token Error Response\n\n3.1.3.5. Token Response Validation\n\n3.1.3.6. ID Token\n\n3.1.3.7. ID Token Validation\n\n3.1.3.8. Access Token Validation\n\n3.2. Authentication using the Implicit Flow\n\n3.2.1. Implicit Flow Steps\n\n3.2.2. Authorization Endpoint\n\n3.2.2.1. Authentication Request\n\n3.2.2.2. Authentication Request Validation\n\n3.2.2.3. Authorization Server Authenticates End-User\n\n3.2.2.4. Authorization Server Obtains End-User Consent/Authorization\n\n3.2.2.5. Successful Authentication Response\n\n3.2.2.6. Authentication Error Response\n\n3.2.2.7. Redirect URI Fragment Handling\n\n3.2.2.8. Authentication Response Validation\n\n3.2.2.9. Access Token Validation\n\n3.2.2.10. ID Token\n\n3.2.2.11. ID Token Validation\n\n3.3. Authentication using the Hybrid Flow\n\n3.3.1. Hybrid Flow Steps\n\n3.3.2. Authorization Endpoint\n\n3.3.2.1. Authentication Request\n\n3.3.2.2. Authentication Request Validation\n\n3.3.2.3. Authorization Server Authenticates End-User\n\n3.3.2.4. Authorization Server Obtains End-User Consent/Authorization\n\n3.3.2.5. Successful Authentication Response\n\n3.3.2.6. Authentication Error Response\n\n3.3.2.7. Redirect URI Fragment Handling\n\n3.3.2.8. Authentication Response Validation\n\n3.3.2.9. Access Token Validation\n\n3.3.2.10. Authorization Code Validation\n\n3.3.2.11. ID Token\n\n3.3.2.12. ID Token Validation\n\n3.3.3. Token Endpoint\n\n3.3.3.1. Token Request\n\n3.3.3.2. Token Request Validation\n\n3.3.3.3. Successful Token Response\n\n3.3.3.4. Token Error Response\n\n3.3.3.5. Token Response Validation\n\n3.3.3.6. ID Token\n\n3.3.3.7. ID Token Validation\n\n3.3.3.8. Access Token\n\n3.3.3.9. Access Token Validation\n\n4. Initiating Login from a Third Party\n\n5. Claims\n\n5.1. Standard Claims\n\n5.1.1. Address Claim\n\n5.1.2. Additional Claims\n\n5.2. Claims Languages and Scripts\n\n5.3. UserInfo Endpoint\n\n5.3.1. UserInfo Request\n\n5.3.2. Successful UserInfo Response\n\n5.3.3. UserInfo Error Response\n\n5.3.4. UserInfo Response Validation\n\n5.4. Requesting Claims using Scope Values\n\n5.5. Requesting Claims using the \"claims\" Request Parameter\n\n5.5.1. Individual Claims Requests\n\n5.5.1.1. Requesting the \"acr\" Claim\n\n5.5.2. Languages and Scripts for Individual Claims\n\n5.6. Claim Types\n\n5.6.1. Normal Claims\n\n5.6.2. Aggregated and Distributed Claims\n\n5.6.2.1. Example of Aggregated Claims\n\n5.6.2.2. Example of Distributed Claims\n\n5.7. Claim Stability and Uniqueness\n\n6. Passing Request Parameters as JWTs\n\n6.1. Passing a Request Object by Value\n\n6.1.1. Request using the \"request\" Request Parameter\n\n6.2. Passing a Request Object by Reference\n\n6.2.1. URI Referencing the Request Object\n\n6.2.2. Request using the \"request_uri\" Request Parameter\n\n6.2.3. Authorization Server Fetches Request Object\n\n6.2.4. \"request_uri\" Rationale\n\n6.3. Validating JWT-Based Requests\n\n6.3.1. Encrypted Request Object\n\n6.3.2. Signed Request Object\n\n6.3.3. Request Parameter Assembly and Validation\n\n7. Self-Issued OpenID Provider\n\n7.1. Self-Issued OpenID Provider Discovery\n\n7.2. Self-Issued OpenID Provider Registration\n\n7.2.1. Providing Information with the \"registration\" Request Parameter\n\n7.3. Self-Issued OpenID Provider Request\n\n7.4. Self-Issued OpenID Provider Response\n\n7.5. Self-Issued ID Token Validation\n\n8. Subject Identifier Types\n\n8.1. Pairwise Identifier Algorithm\n\n9. Client Authentication\n\n10. Signatures and Encryption\n\n10.1. Signing\n\n10.1.1. Rotation of Asymmetric Signing Keys\n\n10.2. Encryption\n\n10.2.1. Rotation of Asymmetric Encryption Keys\n\n11. Offline Access\n\n12. Using Refresh Tokens\n\n12.1. Refresh Request\n\n12.2. Successful Refresh Response\n\n12.3. Refresh Error Response\n\n13. Serializations\n\n13.1. Query String Serialization\n\n13.2. Form Serialization\n\n13.3. JSON Serialization\n\n14. String Operations\n\n15. Implementation Considerations\n\n15.1. Mandatory to Implement Features for All OpenID Providers\n\n15.2. Mandatory to Implement Features for Dynamic OpenID Providers\n\n15.3. Discovery and Registration\n\n15.4. Mandatory to Implement Features for Relying Parties\n\n15.5. Implementation Notes\n\n15.5.1. Authorization Code Implementation Notes\n\n15.5.2. Nonce Implementation Notes\n\n15.5.3. Redirect URI Fragment Handling Implementation Notes\n\n15.6. Compatibility Notes\n\n15.7. Related Specifications and Implementer's Guides\n\n16. Security Considerations\n\n16.1. Request Disclosure\n\n16.2. Server Masquerading\n\n16.3. Token Manufacture/Modification\n\n16.4. Access Token Disclosure\n\n16.5. Server Response Disclosure\n\n16.6. Server Response Repudiation\n\n16.7. Request Repudiation\n\n16.8. Access Token Redirect\n\n16.9. Token Reuse\n\n16.10. Eavesdropping or Leaking Authorization Codes (Secondary Authenticator Capture)\n\n16.11. Token Substitution\n\n16.12. Timing Attack\n\n16.13. Other Crypto Related Attacks\n\n16.14. Signing and Encryption Order\n\n16.15. Issuer Identifier\n\n16.16. Implicit Flow Threats\n\n16.17. TLS Requirements\n\n16.18. Lifetimes of Access Tokens and Refresh Tokens\n\n16.19. Symmetric Key Entropy\n\n16.20. Need for Signed Requests\n\n16.21. Need for Encrypted Requests\n\n16.22. HTTP 307 Redirects\n\n16.23. Custom URI Schemes on iOS\n\n17. Privacy Considerations\n\n17.1. Personally Identifiable Information\n\n17.2. Data Access Monitoring\n\n17.3. Correlation\n\n17.4. Offline Access\n\n18. IANA Considerations\n\n18.1. JSON Web Token Claims Registration\n\n18.1.1. Registry Contents\n\n18.2. OAuth Parameters Registration\n\n18.2.1. Registry Contents\n\n18.3. OAuth Extensions Error Registration\n\n18.3.1. Registry Contents\n\n18.4. URI Scheme Registration\n\n18.4.1. Registry Contents\n\n19. References\n\n19.1. Normative References\n\n19.2. Informative References\n\nAppendix A. Authorization Examples\n\nA.1. Example using response_type=code\n\nA.2. Example using response_type=id_token\n\nA.3. Example using response_type=id_token token\n\nA.4. Example using response_type=code id_token\n\nA.5. Example using response_type=code token\n\nA.6. Example using response_type=code id_token token\n\nA.7. RSA Key Used in Examples\n\nAppendix B. Acknowledgements\n\nAppendix C. Notices\n\n§ Authors' Addresses\n\nTOC\n\n1. Introduction\n\nOpenID Connect 1.0 is a simple identity layer on top of the OAuth 2.0 [RFC6749] (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) protocol. It enables Clients to verify the identity of the End-User based on the authentication performed by an Authorization Server, as well as to obtain basic profile information about the End-User in an interoperable and REST-like manner.\n\nThe OpenID Connect Core 1.0 specification defines the core OpenID Connect functionality: authentication built on top of OAuth 2.0 and the use of Claims to communicate information about the End-User. It also describes the security and privacy considerations for using OpenID Connect.\n\nAs background, the OAuth 2.0 Authorization Framework (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749] and OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, “The OAuth 2.0 Authorization Framework: Bearer Token Usage,” October 2012.) [RFC6750] specifications provide a general framework for third-party applications to obtain and use limited access to HTTP resources. They define mechanisms to obtain and use Access Tokens to access resources but do not define standard methods to provide identity information. Notably, without profiling OAuth 2.0, it is incapable of providing information about the authentication of an End-User. Readers are expected to be familiar with these specifications.\n\nOpenID Connect implements authentication as an extension to the OAuth 2.0 authorization process. Use of this extension is requested by Clients by including the openid scope value in the Authorization Request. Information about the authentication performed is returned in a JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Token (JWT),” May 2015.) [JWT] called an ID Token (see Section 2 (ID Token)). OAuth 2.0 Authentication Servers implementing OpenID Connect are also referred to as OpenID Providers (OPs). OAuth 2.0 Clients using OpenID Connect are also referred to as Relying Parties (RPs).\n\nThis specification assumes that the Relying Party has already obtained configuration information about the OpenID Provider, including its Authorization Endpoint and Token Endpoint locations. This information is normally obtained via Discovery, as described in OpenID Connect Discovery 1.0 (Sakimura, N., Bradley, J., Jones, M., and E. Jay, “OpenID Connect Discovery 1.0,” December 2023.) [OpenID.Discovery], or may be obtained via other mechanisms.\n\nLikewise, this specification assumes that the Relying Party has already obtained sufficient credentials and provided information needed to use the OpenID Provider. This is normally done via Dynamic Registration, as described in OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, “OpenID Connect Dynamic Client Registration 1.0,” December 2023.) [OpenID.Registration], or may be obtained via other mechanisms.\n\nThe previous versions of this specification are:\n\nOpenID Connect Core 1.0 incorporating errata set 1 (Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, “OpenID Connect Core 1.0 incorporating errata set 1,” November 2014.) [OpenID.Core.Errata1]\n\nOpenID Connect Core 1.0 (final) (Sakimura, N., Bradley, J., Jones, M., de Medeiros, B., and C. Mortimore, “OpenID Connect Core 1.0 (final),” February 2014.) [OpenID.Core.Final]\n\nTOC\n\n1.1. Requirements Notation and Conventions\n\nThe key words \"MUST\", \"MUST NOT\", \"REQUIRED\", \"SHALL\", \"SHALL NOT\", \"SHOULD\", \"SHOULD NOT\", \"RECOMMENDED\", \"NOT RECOMMENDED\", \"MAY\", and \"OPTIONAL\" in this document are to be interpreted as described in RFC 2119 (Bradner, S., “Key words for use in RFCs to Indicate Requirement Levels,” March 1997.) [RFC2119].\n\nIn the .txt version of this specification, values are quoted to indicate that they are to be taken literally. When using these values in protocol messages, the quotes MUST NOT be used as part of the value. In the HTML version of this specification, values to be taken literally are indicated by the use of this fixed-width font.\n\nAll uses of JSON Web Signature (JWS) (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” May 2015.) [JWS] and JSON Web Encryption (JWE) (Jones, M. and J. Hildebrand, “JSON Web Encryption (JWE),” May 2015.) [JWE] data structures in this specification utilize the JWS Compact Serialization or the JWE Compact Serialization; the JWS JSON Serialization and the JWE JSON Serialization are not used.\n\nTOC\n\n1.2. Terminology\n\nThis specification uses the terms \"Access Token\", \"Authorization Code\", \"Authorization Endpoint\", \"Authorization Grant\", \"Authorization Server\", \"Client\", \"Client Authentication\", \"Client Identifier\", \"Client Secret\", \"Grant Type\", \"Protected Resource\", \"Redirection URI\", \"Refresh Token\", \"Resource Server\", \"Response Type\", and \"Token Endpoint\" defined by OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749], the terms \"Claim Name\", \"Claim Value\", \"JSON Web Token (JWT)\", \"JWT Claims Set\", and \"Nested JWT\" defined by JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Token (JWT),” May 2015.) [JWT], the terms \"Base64url Encoding\", \"Header Parameter\", and \"JOSE Header\" defined by JSON Web Signature (JWS) (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” May 2015.) [JWS], the term \"User Agent\" defined by RFC 7230 (Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing,” June 2014.) [RFC7230], and the term \"Response Mode\" defined by OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses].\n\nThis specification also defines the following terms:\n\nAuthentication\n\nProcess used to achieve sufficient confidence in the binding between the Entity and the presented Identity.\n\nAuthentication Request\n\nOAuth 2.0 Authorization Request using extension parameters and scopes defined by OpenID Connect to request that the End-User be authenticated by the Authorization Server, which is an OpenID Connect Provider, to the Client, which is an OpenID Connect Relying Party.\n\nAuthentication Context\n\nInformation that the Relying Party can require before it makes an entitlement decision with respect to an authentication response. Such context can include, but is not limited to, the actual authentication method used or level of assurance such as ISO/IEC 29115 (International Organization for Standardization, “ISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,” April 2013.) [ISO29115] entity authentication assurance level.\n\nAuthentication Context Class\n\nSet of authentication methods or procedures that are considered to be equivalent to each other in a particular context.\n\nAuthentication Context Class Reference\n\nIdentifier for an Authentication Context Class.\n\nAuthorization Code Flow\n\nOAuth 2.0 flow in which an Authorization Code is returned from the Authorization Endpoint and all tokens are returned from the Token Endpoint.\n\nAuthorization Request\n\nOAuth 2.0 Authorization Request as defined by [RFC6749] (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.).\n\nClaim\n\nPiece of information asserted about an Entity.\n\nClaim Type\n\nSyntax used for representing a Claim Value. This specification defines Normal, Aggregated, and Distributed Claim Types.\n\nClaims Provider\n\nServer that can return Claims about an Entity.\n\nCredential\n\nData presented as evidence of the right to use an identity or other resources.\n\nEnd-User\n\nHuman participant.\n\nEntity\n\nSomething that has a separate and distinct existence and that can be identified in a context. An End-User is one example of an Entity.\n\nEssential Claim\n\nClaim specified by the Client as being necessary to ensure a smooth authorization experience for the specific task requested by the End-User.\n\nHybrid Flow\n\nOAuth 2.0 flow in which an Authorization Code is returned from the Authorization Endpoint, some tokens are returned from the Authorization Endpoint, and others are returned from the Token Endpoint.\n\nID Token\n\nJSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Token (JWT),” May 2015.) [JWT] that contains Claims about the Authentication event. It MAY contain other Claims.\n\nIdentifier\n\nValue that uniquely characterizes an Entity in a specific context.\n\nIdentity\n\nSet of attributes related to an Entity.\n\nImplicit Flow\n\nOAuth 2.0 flow in which all tokens are returned from the Authorization Endpoint and neither the Token Endpoint nor an Authorization Code are used.\n\nIssuer\n\nEntity that issues a set of Claims.\n\nIssuer Identifier\n\nVerifiable Identifier for an Issuer. An Issuer Identifier is a case-sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components and no query or fragment components.\n\nMessage\n\nRequest or a response between an OpenID Relying Party and an OpenID Provider.\n\nOpenID Provider (OP)\n\nOAuth 2.0 Authorization Server that is capable of Authenticating the End-User and providing Claims to a Relying Party about the Authentication event and the End-User.\n\nRequest Object\n\nJWT that contains a set of request parameters as its Claims.\n\nRequest URI\n\nURL that references a resource containing a Request Object. The Request URI contents MUST be retrievable by the Authorization Server.\n\nPairwise Pseudonymous Identifier (PPID)\n\nIdentifier that identifies the Entity to a Relying Party that cannot be correlated with the Entity's PPID at another Relying Party.\n\nPersonally Identifiable Information (PII)\n\nInformation that (a) can be used to identify the natural person to whom such information relates, or (b) is or might be directly or indirectly linked to a natural person to whom such information relates.\n\nRelying Party (RP)\n\nOAuth 2.0 Client application requiring End-User Authentication and Claims from an OpenID Provider.\n\nSector Identifier\n\nHost component of a URL used by the Relying Party's organization that is an input to the computation of pairwise Subject Identifiers for that Relying Party.\n\nSelf-Issued OpenID Provider\n\nPersonal, self-hosted OpenID Provider that issues self-signed ID Tokens.\n\nSubject Identifier\n\nLocally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client.\n\nUserInfo Endpoint\n\nProtected Resource that, when presented with an Access Token by the Client, returns authorized information about the End-User represented by the corresponding Authorization Grant. The UserInfo Endpoint URL MUST use the https scheme and MAY contain port, path, and query parameter components.\n\nValidation\n\nProcess intended to establish the soundness or correctness of a construct.\n\nVerification\n\nProcess intended to test or prove the truth or accuracy of a fact or value.\n\nVoluntary Claim\n\nClaim specified by the Client as being useful but not Essential for the specific task requested by the End-User.\n\nIMPORTANT NOTE TO READERS: The terminology definitions in this section are a normative portion of this specification, imposing requirements upon implementations. All the capitalized words in the text of this specification, such as \"Issuer Identifier\", reference these defined terms. Whenever the reader encounters them, their definitions found in this section must be followed.\n\nFor more background on some of the terminology used, see Internet Security Glossary, Version 2 (Shirey, R., “Internet Security Glossary, Version 2,” August 2007.) [RFC4949], ISO/IEC 29115 Entity Authentication Assurance (International Organization for Standardization, “ISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,” April 2013.) [ISO29115], and ITU-T X.1252 (International Telecommunication Union, “ITU-T Recommendation X.1252 - Cyberspace security - Identity management - Baseline identity management terms and definitions,” April 2010.) [X.1252].\n\nTOC\n\n1.3. Overview\n\nThe OpenID Connect protocol, in abstract, follows the following steps.\n\nThe RP (Client) sends a request to the OpenID Provider (OP).\n\nThe OP authenticates the End-User and obtains authorization.\n\nThe OP responds with an ID Token and usually an Access Token.\n\nThe RP can send a request with the Access Token to the UserInfo Endpoint.\n\nThe UserInfo Endpoint returns Claims about the End-User.\n\nThese steps are illustrated in the following diagram:\n\n+--------+ +--------+ | | | | | |---------(1) AuthN Request-------->| | | | | | | | +--------+ | | | | | | | | | | | End- |<--(2) AuthN & AuthZ-->| | | | | User | | | | RP | | | | OP | | | +--------+ | | | | | | | |<--------(3) AuthN Response--------| | | | | | | |---------(4) UserInfo Request----->| | | | | | | |<--------(5) UserInfo Response-----| | | | | | +--------+ +--------+\n\nTOC\n\n2. ID Token\n\nThe primary extension that OpenID Connect makes to OAuth 2.0 to enable End-Users to be Authenticated is the ID Token data structure. The ID Token is a security token that contains Claims about the Authentication of an End-User by an Authorization Server when using a Client, and potentially other requested Claims. The ID Token is represented as a JSON Web Token (JWT) (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Token (JWT),” May 2015.) [JWT].\n\nThe following Claims are used within the ID Token for all OAuth 2.0 flows used by OpenID Connect:\n\niss\n\nREQUIRED. Issuer Identifier for the Issuer of the response. The iss value is a case-sensitive URL using the https scheme that contains scheme, host, and optionally, port number and path components and no query or fragment components.\n\nsub\n\nREQUIRED. Subject Identifier. A locally unique and never reassigned identifier within the Issuer for the End-User, which is intended to be consumed by the Client, e.g., 24400320 or AItOawmwtWwcT0k51BayewNvutrJUqsvl6qs7A4. It MUST NOT exceed 255 ASCII [RFC20] (Cerf, V., “ASCII format for Network Interchange,” October 1969.) characters in length. The sub value is a case-sensitive string.\n\naud\n\nREQUIRED. Audience(s) that this ID Token is intended for. It MUST contain the OAuth 2.0 client_id of the Relying Party as an audience value. It MAY also contain identifiers for other audiences. In the general case, the aud value is an array of case-sensitive strings. In the common special case when there is one audience, the aud value MAY be a single case-sensitive string.\n\nexp\n\nREQUIRED. Expiration time on or after which the ID Token MUST NOT be accepted by the RP when performing authentication with the OP. The processing of this parameter requires that the current date/time MUST be before the expiration date/time listed in the value. Implementers MAY provide for some small leeway, usually no more than a few minutes, to account for clock skew. Its value is a JSON [RFC8259] (Bray, T., Ed., “The JavaScript Object Notation (JSON) Data Interchange Format,” December 2017.) number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time. See RFC 3339 (Klyne, G. and C. Newman, “Date and Time on the Internet: Timestamps,” July 2002.) [RFC3339] for details regarding date/times in general and UTC in particular. NOTE: The ID Token expiration time is unrelated the lifetime of the authenticated session between the RP and the OP.\n\niat\n\nREQUIRED. Time at which the JWT was issued. Its value is a JSON number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time.\n\nauth_time\n\nTime when the End-User authentication occurred. Its value is a JSON number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time. When a max_age request is made or when auth_time is requested as an Essential Claim, then this Claim is REQUIRED; otherwise, its inclusion is OPTIONAL. (The auth_time Claim semantically corresponds to the OpenID 2.0 PAPE (Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, “OpenID Provider Authentication Policy Extension 1.0,” December 2008.) [OpenID.PAPE] auth_time response parameter.)\n\nnonce\n\nString value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. If present in the ID Token, Clients MUST verify that the nonce Claim Value is equal to the value of the nonce parameter sent in the Authentication Request. If present in the Authentication Request, Authorization Servers MUST include a nonce Claim in the ID Token with the Claim Value being the nonce value sent in the Authentication Request. Authorization Servers SHOULD perform no other processing on nonce values used. The nonce value is a case-sensitive string.\n\nacr\n\nOPTIONAL. Authentication Context Class Reference. String specifying an Authentication Context Class Reference value that identifies the Authentication Context Class that the authentication performed satisfied. The value \"0\" indicates the End-User authentication did not meet the requirements of ISO/IEC 29115 (International Organization for Standardization, “ISO/IEC 29115:2013. Information technology - Security techniques - Entity authentication assurance framework,” April 2013.) [ISO29115] level 1. For historic reasons, the value \"0\" is used to indicate that there is no confidence that the same person is actually there. Authentications with level 0 SHOULD NOT be used to authorize access to any resource of any monetary value. (This corresponds to the OpenID 2.0 PAPE (Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, “OpenID Provider Authentication Policy Extension 1.0,” December 2008.) [OpenID.PAPE] nist_auth_level 0.) An absolute URI or an RFC 6711 (Johansson, L., “An IANA Registry for Level of Assurance (LoA) Profiles,” August 2012.) [RFC6711] registered name SHOULD be used as the acr value; registered names MUST NOT be used with a different meaning than that which is registered. Parties using this claim will need to agree upon the meanings of the values used, which may be context specific. The acr value is a case-sensitive string.\n\namr\n\nOPTIONAL. Authentication Methods References. JSON array of strings that are identifiers for authentication methods used in the authentication. For instance, values might indicate that both password and OTP authentication methods were used. The amr value is an array of case-sensitive strings. Values used in the amr Claim SHOULD be from those registered in the IANA Authentication Method Reference Values registry [IANA.AMR] (IANA, “Authentication Method Reference Values,” .) established by [RFC8176] (Jones, M., Hunt, P., and A. Nadalin, “Authentication Method Reference Values,” June 2017.); parties using this claim will need to agree upon the meanings of any unregistered values used, which may be context specific.\n\nazp\n\nOPTIONAL. Authorized party - the party to which the ID Token was issued. If present, it MUST contain the OAuth 2.0 Client ID of this party. The azp value is a case-sensitive string containing a StringOrURI value. Note that in practice, the azp Claim only occurs when extensions beyond the scope of this specification are used; therefore, implementations not using such extensions are encouraged to not use azp and to ignore it when it does occur.\n\nID Tokens MAY contain other Claims. Any Claims used that are not understood MUST be ignored. See Sections 3.1.3.6 (ID Token), 3.3.2.11 (ID Token), 5.1 (Standard Claims), and 7.4 (Self-Issued OpenID Provider Response) for additional Claims defined by this specification.\n\nID Tokens MUST be signed using JWS (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” May 2015.) [JWS] and optionally both signed and then encrypted using JWS (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” May 2015.) [JWS] and JWE (Jones, M. and J. Hildebrand, “JSON Web Encryption (JWE),” May 2015.) [JWE] respectively, thereby providing authentication, integrity, non-repudiation, and optionally, confidentiality, per Section 16.14 (Signing and Encryption Order). If the ID Token is encrypted, it MUST be signed then encrypted, with the result being a Nested JWT, as defined in [JWT] (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Token (JWT),” May 2015.). ID Tokens MUST NOT use none as the alg value unless the Response Type used returns no ID Token from the Authorization Endpoint (such as when using the Authorization Code Flow) and the Client explicitly requested the use of none at Registration time.\n\nID Tokens SHOULD NOT use the JWS or JWE x5u, x5c, jku, or jwk Header Parameter fields. Instead, references to keys used are communicated in advance using Discovery and Registration parameters, per Section 10 (Signatures and Encryption).\n\nThe following is a non-normative example of the set of Claims (the JWT Claims Set) in an ID Token:\n\n{ \"iss\": \"https://server.example.com\", \"sub\": \"24400320\", \"aud\": \"s6BhdRkqt3\", \"nonce\": \"n-0S6_WzA2Mj\", \"exp\": 1311281970, \"iat\": 1311280970, \"auth_time\": 1311280969, \"acr\": \"urn:mace:incommon:iap:silver\" }\n\nTOC\n\n3. Authentication\n\nOpenID Connect performs authentication to log in the End-User or to determine that the End-User is already logged in. OpenID Connect returns the result of the Authentication performed by the Server to the Client in a secure manner so that the Client can rely on it. For this reason, the Client is called Relying Party (RP) in this case.\n\nThe Authentication result is returned in an ID Token, as defined in Section 2 (ID Token). It has Claims expressing such information as the Issuer, the Subject Identifier, when the authentication was performed, etc.\n\nAuthentication can follow one of three paths: the Authorization Code Flow (response_type=code), the Implicit Flow (response_type=id_token token or response_type=id_token), or the Hybrid Flow (using other Response Type values defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses]). The flows determine how the ID Token and Access Token are returned to the Client.\n\nThe characteristics of the three flows are summarized in the following non-normative table. The table is intended to provide some guidance on which flow to choose in particular contexts.\n\nPropertyAuthorization Code FlowImplicit FlowHybrid Flow All tokens returned from Authorization Endpoint no yes no All tokens returned from Token Endpoint yes no no Tokens not revealed to User Agent yes no no Client can be authenticated yes no yes Refresh Token possible yes no yes Communication in one round trip no yes no Most communication server-to-server yes no varies\n\nOpenID Connect Authentication Flows\n\nThe flow used is determined by the response_type value contained in the Authorization Request. These response_type values select these flows:\n\n\"response_type\" valueFlow code Authorization Code Flow id_token Implicit Flow id_token token Implicit Flow code id_token Hybrid Flow code token Hybrid Flow code id_token token Hybrid Flow\n\nOpenID Connect \"response_type\" Values\n\nAll but the code Response Type value, which is defined by OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749], are defined in the OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses] specification. NOTE: While OAuth 2.0 also defines the token Response Type value for the Implicit Flow, OpenID Connect does not use this Response Type, since no ID Token would be returned.\n\nTOC\n\n3.1. Authentication using the Authorization Code Flow\n\nThis section describes how to perform authentication using the Authorization Code Flow. When using the Authorization Code Flow, all tokens are returned from the Token Endpoint.\n\nThe Authorization Code Flow returns an Authorization Code to the Client, which can then exchange it for an ID Token and an Access Token directly. This provides the benefit of not exposing any tokens to the User Agent and possibly other malicious applications with access to the User Agent. The Authorization Server can also authenticate the Client before exchanging the Authorization Code for an Access Token. The Authorization Code flow is suitable for Clients that can securely maintain a Client Secret between themselves and the Authorization Server.\n\nTOC\n\n3.1.1. Authorization Code Flow Steps\n\nThe Authorization Code Flow goes through the following steps.\n\nClient prepares an Authentication Request containing the desired request parameters.\n\nClient sends the request to the Authorization Server.\n\nAuthorization Server Authenticates the End-User.\n\nAuthorization Server obtains End-User Consent/Authorization.\n\nAuthorization Server sends the End-User back to the Client with an Authorization Code.\n\nClient requests a response using the Authorization Code at the Token Endpoint.\n\nClient receives a response that contains an ID Token and Access Token in the response body.\n\nClient validates the ID token and retrieves the End-User's Subject Identifier.\n\nTOC\n\n3.1.2. Authorization Endpoint\n\nThe Authorization Endpoint performs Authentication of the End-User. This is done by sending the User Agent to the Authorization Server's Authorization Endpoint for Authentication and Authorization, using request parameters defined by OAuth 2.0 and additional parameters and parameter values defined by OpenID Connect.\n\nCommunication with the Authorization Endpoint MUST utilize TLS. See Section 16.17 (TLS Requirements) for more information on using TLS.\n\nTOC\n\n3.1.2.1. Authentication Request\n\nAn Authentication Request is an OAuth 2.0 Authorization Request that requests that the End-User be authenticated by the Authorization Server.\n\nAuthorization Servers MUST support the use of the HTTP GET and POST methods defined in RFC 7231 (Fielding, R., Ed. and J. Reschke, Ed., “Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content,” June 2014.) [RFC7231] at the Authorization Endpoint. Clients MAY use the HTTP GET or POST methods to send the Authorization Request to the Authorization Server. If using the HTTP GET method, the request parameters are serialized using URI Query String Serialization, per Section 13.1 (Query String Serialization). If using the HTTP POST method, the request parameters are serialized using Form Serialization, per Section 13.2 (Form Serialization).\n\nOpenID Connect uses the following OAuth 2.0 request parameters with the Authorization Code Flow:\n\nscope\n\nREQUIRED. OpenID Connect requests MUST contain the openid scope value. If the openid scope value is not present, the behavior is entirely unspecified. Other scope values MAY be present. Scope values used that are not understood by an implementation SHOULD be ignored. See Sections 5.4 (Requesting Claims using Scope Values) and 11 (Offline Access) for additional scope values defined by this specification.\n\nresponse_type\n\nREQUIRED. OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used. When using the Authorization Code Flow, this value is code.\n\nclient_id\n\nREQUIRED. OAuth 2.0 Client Identifier valid at the Authorization Server.\n\nredirect_uri\n\nREQUIRED. Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986] (Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax,” January 2005.) (Simple String Comparison). When using this flow, the Redirection URI SHOULD use the https scheme; however, it MAY use the http scheme, provided that the Client Type is confidential, as defined in Section 2.1 of OAuth 2.0, and provided the OP allows the use of http Redirection URIs in this case. Also, if the Client is a native application, it MAY use the http scheme with localhost or the IP loopback literals 127.0.0.1 or [::1] as the hostname. The Redirection URI MAY use an alternate scheme, such as one that is intended to identify a callback into a native application.\n\nstate\n\nRECOMMENDED. Opaque value used to maintain state between the request and the callback. Typically, Cross-Site Request Forgery (CSRF, XSRF) mitigation is done by cryptographically binding the value of this parameter with a browser cookie.\n\nOpenID Connect also uses the following OAuth 2.0 request parameter, which is defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses]:\n\nresponse_mode\n\nOPTIONAL. Informs the Authorization Server of the mechanism to be used for returning parameters from the Authorization Endpoint. This use of this parameter is NOT RECOMMENDED when the Response Mode that would be requested is the default mode specified for the Response Type.\n\nThis specification also defines the following request parameters:\n\nnonce\n\nOPTIONAL. String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values. For implementation notes, see Section 15.5.2 (Nonce Implementation Notes).\n\ndisplay\n\nOPTIONAL. ASCII string value that specifies how the Authorization Server displays the authentication and consent user interface pages to the End-User. The defined values are:\n\npage\n\nThe Authorization Server SHOULD display the authentication and consent UI consistent with a full User Agent page view. If the display parameter is not specified, this is the default display mode.\n\npopup\n\nThe Authorization Server SHOULD display the authentication and consent UI consistent with a popup User Agent window. The popup User Agent window should be of an appropriate size for a login-focused dialog and should not obscure the entire window that it is popping up over.\n\ntouch\n\nThe Authorization Server SHOULD display the authentication and consent UI consistent with a device that leverages a touch interface.\n\nwap\n\nThe Authorization Server SHOULD display the authentication and consent UI consistent with a \"feature phone\" type display.\n\nThe Authorization Server MAY also attempt to detect the capabilities of the User Agent and present an appropriate display.\n\nIf an OP receives a display value outside the set defined above that it does not understand, it MAY return an error or it MAY ignore it; in practice, not returning errors for not-understood values will help facilitate phasing in extensions using new display values.\n\nprompt\n\nOPTIONAL. Space-delimited, case-sensitive list of ASCII string values that specifies whether the Authorization Server prompts the End-User for reauthentication and consent. The defined values are:\n\nnone\n\nThe Authorization Server MUST NOT display any authentication or consent user interface pages. An error is returned if an End-User is not already authenticated or the Client does not have pre-configured consent for the requested Claims or does not fulfill other conditions for processing the request. The error code will typically be login_required, interaction_required, or another code defined in Section 3.1.2.6 (Authentication Error Response). This can be used as a method to check for existing authentication and/or consent.\n\nlogin\n\nThe Authorization Server SHOULD prompt the End-User for reauthentication. If it cannot reauthenticate the End-User, it MUST return an error, typically login_required.\n\nconsent\n\nThe Authorization Server SHOULD prompt the End-User for consent before returning information to the Client. If it cannot obtain consent, it MUST return an error, typically consent_required.\n\nselect_account\n\nThe Authorization Server SHOULD prompt the End-User to select a user account. This enables an End-User who has multiple accounts at the Authorization Server to select amongst the multiple accounts that they might have current sessions for. If it cannot obtain an account selection choice made by the End-User, it MUST return an error, typically account_selection_required.\n\nThe prompt parameter can be used by the Client to make sure that the End-User is still present for the current session or to bring attention to the request. If this parameter contains none with any other value, an error is returned.\n\nIf an OP receives a prompt value outside the set defined above that it does not understand, it MAY return an error or it MAY ignore it; in practice, not returning errors for not-understood values will help facilitate phasing in extensions using new prompt values.\n\nmax_age\n\nOPTIONAL. Maximum Authentication Age. Specifies the allowable elapsed time in seconds since the last time the End-User was actively authenticated by the OP. If the elapsed time is greater than this value, the OP MUST attempt to actively re-authenticate the End-User. (The max_age request parameter corresponds to the OpenID 2.0 PAPE (Recordon, D., Jones, M., Bufu, J., Ed., Daugherty, J., Ed., and N. Sakimura, “OpenID Provider Authentication Policy Extension 1.0,” December 2008.) [OpenID.PAPE] max_auth_age request parameter.) When max_age is used, the ID Token returned MUST include an auth_time Claim Value. Note that max_age=0 is equivalent to prompt=login.\n\nui_locales\n\nOPTIONAL. End-User's preferred languages and scripts for the user interface, represented as a space-separated list of BCP47 (Phillips, A., Ed. and M. Davis, Ed., “Tags for Identifying Languages,” September 2009.) [RFC5646] language tag values, ordered by preference. For instance, the value \"fr-CA fr en\" represents a preference for French as spoken in Canada, then French (without a region designation), followed by English (without a region designation). An error SHOULD NOT result if some or all of the requested locales are not supported by the OpenID Provider.\n\nid_token_hint\n\nOPTIONAL. ID Token previously issued by the Authorization Server being passed as a hint about the End-User's current or past authenticated session with the Client. If the End-User identified by the ID Token is already logged in or is logged in as a result of the request (with the OP possibly evaluating other information beyond the ID Token in this decision), then the Authorization Server returns a positive response; otherwise, it MUST return an error, such as login_required. When possible, an id_token_hint SHOULD be present when prompt=none is used and an invalid_request error MAY be returned if it is not; however, the server SHOULD respond successfully when possible, even if it is not present. The Authorization Server need not be listed as an audience of the ID Token when it is used as an id_token_hint value.\n\nIf the ID Token received by the RP from the OP is encrypted, to use it as an id_token_hint, the Client MUST decrypt the signed ID Token contained within the encrypted ID Token. The Client MAY re-encrypt the signed ID token to the Authentication Server using a key that enables the server to decrypt the ID Token and use the re-encrypted ID token as the id_token_hint value.\n\nlogin_hint\n\nOPTIONAL. Hint to the Authorization Server about the login identifier the End-User might use to log in (if necessary). This hint can be used by an RP if it first asks the End-User for their e-mail address (or other identifier) and then wants to pass that value as a hint to the discovered authorization service. It is RECOMMENDED that the hint value match the value used for discovery. This value MAY also be a phone number in the format specified for the phone_number Claim. The use of this parameter is left to the OP's discretion.\n\nacr_values\n\nOPTIONAL. Requested Authentication Context Class Reference values. Space-separated string that specifies the acr values that the Authorization Server is being requested to use for processing this Authentication Request, with the values appearing in order of preference. The Authentication Context Class satisfied by the authentication performed is returned as the acr Claim Value, as specified in Section 2 (ID Token). The acr Claim is requested as a Voluntary Claim by this parameter.\n\nOther parameters MAY be sent. See Sections 3.2.2 (Authorization Endpoint), 3.3.2 (Authorization Endpoint), 5.2 (Claims Languages and Scripts), 5.5 (Requesting Claims using the \"claims\" Request Parameter), 6 (Passing Request Parameters as JWTs), and 7.2.1 (Providing Information with the \"registration\" Request Parameter) for additional Authorization Request parameters and parameter values defined by this specification.\n\nThe following is a non-normative example HTTP 302 redirect response by the Client, which triggers the User Agent to make an Authentication Request to the Authorization Endpoint (with line wraps within values for display purposes only):\n\nHTTP/1.1 302 Found Location: https://server.example.com/authorize? response_type=code &scope=openid%20profile%20email &client_id=s6BhdRkqt3 &state=af0ifjsldkj &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb\n\nThe following is the non-normative example request that would be sent by the User Agent to the Authorization Server in response to the HTTP 302 redirect response by the Client above (with line wraps within values for display purposes only):\n\nGET /authorize? response_type=code &scope=openid%20profile%20email &client_id=s6BhdRkqt3 &state=af0ifjsldkj &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb HTTP/1.1 Host: server.example.com\n\nTOC\n\n3.1.2.2. Authentication Request Validation\n\nThe Authorization Server MUST validate the request received as follows:\n\nThe Authorization Server MUST validate all the OAuth 2.0 parameters according to the OAuth 2.0 specification.\n\nVerify that a scope parameter is present and contains the openid scope value. (If no openid scope value is present, the request may still be a valid OAuth 2.0 request but is not an OpenID Connect request.)\n\nThe Authorization Server MUST verify that all the REQUIRED parameters are present and their usage conforms to this specification.\n\nIf the sub (subject) Claim is requested with a specific value for the ID Token, the Authorization Server MUST only send a positive response if the End-User identified by that sub value has an active session with the Authorization Server or has been Authenticated as a result of the request. The Authorization Server MUST NOT reply with an ID Token or Access Token for a different user, even if they have an active session with the Authorization Server. Such a request can be made either using an id_token_hint parameter or by requesting a specific Claim Value as described in Section 5.5.1 (Individual Claims Requests), if the claims parameter is supported by the implementation.\n\nWhen an id_token_hint is present, the OP MUST validate that it was the issuer of the ID Token. The OP SHOULD accept ID Tokens when the RP identified by the ID Token has a current session or had a recent session at the OP, even when the exp time has passed.\n\nAs specified in OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749], Authorization Servers SHOULD ignore unrecognized request parameters.\n\nIf the Authorization Server encounters any error, it MUST return an error response, per Section 3.1.2.6 (Authentication Error Response).\n\nTOC\n\n3.1.2.3. Authorization Server Authenticates End-User\n\nIf the request is valid, the Authorization Server attempts to Authenticate the End-User or determines whether the End-User is Authenticated, depending upon the request parameter values used. The methods used by the Authorization Server to Authenticate the End-User (e.g., username and password, session cookies, etc.) are beyond the scope of this specification. An Authentication user interface MAY be displayed by the Authorization Server, depending upon the request parameter values used and the authentication methods used.\n\nThe Authorization Server MUST attempt to Authenticate the End-User in the following cases:\n\nThe End-User is not already Authenticated.\n\nThe Authentication Request contains the prompt parameter with the value login. In this case, the Authorization Server MUST reauthenticate the End-User even if the End-User is already authenticated.\n\nThe Authorization Server MUST NOT interact with the End-User in the following case:\n\nThe Authentication Request contains the prompt parameter with the value none. In this case, the Authorization Server MUST return an error if an End-User is not already Authenticated or could not be silently Authenticated.\n\nWhen interacting with the End-User, the Authorization Server MUST employ appropriate measures against Cross-Site Request Forgery and Clickjacking as, described in Sections 10.12 and 10.13 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749].\n\nTOC\n\n3.1.2.4. Authorization Server Obtains End-User Consent/Authorization\n\nOnce the End-User is authenticated, the Authorization Server MUST obtain an authorization decision before releasing information to the Relying Party. When permitted by the request parameters used, this MAY be done through an interactive dialogue with the End-User that makes it clear what is being consented to or by establishing consent via conditions for processing the request or other means (for example, via previous administrative consent). Sections 2 (ID Token) and 5.3 (UserInfo Endpoint) describe information release mechanisms.\n\nTOC\n\n3.1.2.5. Successful Authentication Response\n\nAn Authentication Response is an OAuth 2.0 Authorization Response message returned from the OP's Authorization Endpoint in response to the Authorization Request message sent by the RP.\n\nWhen using the Authorization Code Flow, the Authorization Response MUST return the parameters defined in Section 4.1.2 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749] by adding them as query parameters to the redirect_uri specified in the Authorization Request using the application/x-www-form-urlencoded format, unless a different Response Mode was specified.\n\nThe following is a non-normative example successful response using this flow (with line wraps within values for display purposes only):\n\nHTTP/1.1 302 Found Location: https://client.example.org/cb? code=SplxlOBeZQQYbYS6WxSbIA &state=af0ifjsldkj\n\nFor implementation notes on the contents of the Authorization Code, see Section 15.5.1 (Authorization Code Implementation Notes).\n\nTOC\n\n3.1.2.6. Authentication Error Response\n\nAn Authentication Error Response is an OAuth 2.0 Authorization Error Response message returned from the OP's Authorization Endpoint in response to the Authorization Request message sent by the RP.\n\nIf the End-User denies the request or the End-User authentication fails, the OP (Authorization Server) informs the RP (Client) by using the Error Response parameters defined in Section 4.1.2.1 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749]. (HTTP errors unrelated to RFC 6749 are returned to the User Agent using the appropriate HTTP status code.)\n\nUnless the Redirection URI is invalid, the Authorization Server returns the Client to the Redirection URI specified in the Authorization Request with the appropriate error and state parameters. Other parameters SHOULD NOT be returned. If the Redirection URI is invalid, the Authorization Server MUST NOT redirect the User Agent to the invalid Redirection URI.\n\nIf the Response Mode value is not supported, the Authorization Server returns an HTTP response code of 400 (Bad Request) without Error Response parameters, since understanding the Response Mode is necessary to know how to return those parameters.\n\nIn addition to the error codes defined in Section 4.1.2.1 of OAuth 2.0, this specification also defines the following error codes:\n\ninteraction_required\n\nThe Authorization Server requires End-User interaction of some form to proceed. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface for End-User interaction.\n\nlogin_required\n\nThe Authorization Server requires End-User authentication. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface for End-User authentication.\n\naccount_selection_required\n\nThe End-User is REQUIRED to select a session at the Authorization Server. The End-User MAY be authenticated at the Authorization Server with different associated accounts, but the End-User did not select a session. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface to prompt for a session to use.\n\nconsent_required\n\nThe Authorization Server requires End-User consent. This error MAY be returned when the prompt parameter value in the Authentication Request is none, but the Authentication Request cannot be completed without displaying a user interface for End-User consent.\n\ninvalid_request_uri\n\nThe request_uri in the Authorization Request returns an error or contains invalid data.\n\ninvalid_request_object\n\nThe request parameter contains an invalid Request Object.\n\nrequest_not_supported\n\nThe OP does not support use of the request parameter defined in Section 6 (Passing Request Parameters as JWTs).\n\nrequest_uri_not_supported\n\nThe OP does not support use of the request_uri parameter defined in Section 6 (Passing Request Parameters as JWTs).\n\nregistration_not_supported\n\nThe OP does not support use of the registration parameter defined in Section 7.2.1 (Providing Information with the \"registration\" Request Parameter).\n\nThe error response parameters are the following:\n\nerror\n\nREQUIRED. Error code.\n\nerror_description\n\nOPTIONAL. Human-readable ASCII encoded text description of the error.\n\nerror_uri\n\nOPTIONAL. URI of a web page that includes additional information about the error.\n\nstate\n\nOAuth 2.0 state value. REQUIRED if the Authorization Request included the state parameter. Set to the value received from the Client.\n\nWhen using the Authorization Code Flow, the error response parameters are added to the query component of the Redirection URI, unless a different Response Mode was specified.\n\nThe following is a non-normative example error response using this flow (with line wraps within values for display purposes only):\n\nHTTP/1.1 302 Found Location: https://client.example.org/cb? error=invalid_request &error_description= Unsupported%20response_type%20value &state=af0ifjsldkj\n\nTOC\n\n3.1.2.7. Authentication Response Validation\n\nWhen using the Authorization Code Flow, the Client MUST validate the response according to RFC 6749, especially Sections 4.1.2 and 10.12.\n\nTOC\n\n3.1.3. Token Endpoint\n\nTo obtain an Access Token, an ID Token, and optionally a Refresh Token, the RP (Client) sends a Token Request to the Token Endpoint to obtain a Token Response, as described in Section 3.2 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749], when using the Authorization Code Flow.\n\nCommunication with the Token Endpoint MUST utilize TLS. See Section 16.17 (TLS Requirements) for more information on using TLS.\n\nTOC\n\n3.1.3.1. Token Request\n\nA Client makes a Token Request by presenting its Authorization Grant (in the form of an Authorization Code) to the Token Endpoint using the grant_type value authorization_code, as described in Section 4.1.3 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749]. If the Client is a Confidential Client, then it MUST authenticate to the Token Endpoint using the authentication method registered for its client_id, as described in Section 9 (Client Authentication).\n\nThe Client sends the parameters to the Token Endpoint using the HTTP POST method and the Form Serialization, per Section 13.2 (Form Serialization), as described in Section 4.1.3 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749].\n\nThe following is a non-normative example of a Token Request (with line wraps within values for display purposes only):\n\nPOST /token HTTP/1.1 Host: server.example.com Content-Type: application/x-www-form-urlencoded Authorization: Basic czZCaGRSa3F0MzpnWDFmQmF0M2JW grant_type=authorization_code&code=SplxlOBeZQQYbYS6WxSbIA &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb\n\nTOC\n\n3.1.3.2. Token Request Validation\n\nThe Authorization Server MUST validate the Token Request as follows:\n\nAuthenticate the Client if it was issued Client Credentials or if it uses another Client Authentication method, per Section 9 (Client Authentication).\n\nEnsure the Authorization Code was issued to the authenticated Client.\n\nVerify that the Authorization Code is valid.\n\nIf possible, verify that the Authorization Code has not been previously used.\n\nEnsure that the redirect_uri parameter value is identical to the redirect_uri parameter value that was included in the initial Authorization Request. If the redirect_uri parameter value is not present when there is only one registered redirect_uri value, the Authorization Server MAY return an error (since the Client should have included the parameter) or MAY proceed without an error (since OAuth 2.0 permits the parameter to be omitted in this case).\n\nVerify that the Authorization Code used was issued in response to an OpenID Connect Authentication Request (so that an ID Token will be returned from the Token Endpoint).\n\nTOC\n\n3.1.3.3. Successful Token Response\n\nAfter receiving and validating a valid and authorized Token Request from the Client, the Authorization Server returns a successful response that includes an ID Token and an Access Token. The parameters in the successful response are defined in Section 4.1.4 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749]. The response uses the application/json media type.\n\nThe OAuth 2.0 token_type response parameter value MUST be Bearer, as specified in OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, “The OAuth 2.0 Authorization Framework: Bearer Token Usage,” October 2012.) [RFC6750], unless another Token Type has been negotiated with the Client. Servers SHOULD support the Bearer Token Type; use of other Token Types is outside the scope of this specification. Note that the token_type value is case insensitive.\n\nIn addition to the response parameters specified by OAuth 2.0, the following parameters MUST be included in the response:\n\nid_token\n\nID Token value associated with the authenticated session.\n\nAll Token Responses that contain tokens, secrets, or other sensitive information MUST include the following HTTP response header fields and values:\n\nHeader NameHeader Value Cache-Control no-store\n\nHTTP Response Headers and Values\n\nThe following is a non-normative example of a successful Token Response. The ID Token signature in the example can be verified with the key at Appendix A.7 (RSA Key Used in Examples).\n\nHTTP/1.1 200 OK Content-Type: application/json Cache-Control: no-store { \"access_token\": \"SlAV32hkKG\", \"token_type\": \"Bearer\", \"refresh_token\": \"8xLOxBtZp8\", \"expires_in\": 3600, \"id_token\": \"eyJhbGciOiJSUzI1NiIsImtpZCI6IjFlOWdkazcifQ.ewogImlzc yI6ICJodHRwOi8vc2VydmVyLmV4YW1wbGUuY29tIiwKICJzdWIiOiAiMjQ4Mjg5 NzYxMDAxIiwKICJhdWQiOiAiczZCaGRSa3F0MyIsCiAibm9uY2UiOiAibi0wUzZ fV3pBMk1qIiwKICJleHAiOiAxMzExMjgxOTcwLAogImlhdCI6IDEzMTEyODA5Nz AKfQ.ggW8hZ1EuVLuxNuuIJKX_V8a_OMXzR0EHR9R6jgdqrOOF4daGU96Sr_P6q Jp6IcmD3HP99Obi1PRs-cwh3LO-p146waJ8IhehcwL7F09JdijmBqkvPeB2T9CJ NqeGpe-gccMg4vfKjkM8FcGvnzZUN4_KSP0aAp1tOJ1zZwgjxqGByKHiOtX7Tpd QyHE5lcMiKPXfEIQILVq0pc_E2DzL7emopWoaoZTF_m0_N0YzFC6g6EJbOEoRoS K5hoDalrcvRYLSrQAZZKflyuVCyixEoV9GfNQC3_osjzw2PAithfubEEBLuVVk4 XUVrWOLrLl0nx7RkKU8NXNHq-rvKMzqg\" }\n\nAs specified in OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749], Clients SHOULD ignore unrecognized response parameters.\n\nTOC\n\n3.1.3.4. Token Error Response\n\nIf the Token Request is invalid or unauthorized, the Authorization Server constructs the error response. The parameters of the Token Error Response are defined as in Section 5.2 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749]. The HTTP response body uses the application/json media type with HTTP response code of 400.\n\nThe following is a non-normative example Token Error Response:\n\nHTTP/1.1 400 Bad Request Content-Type: application/json Cache-Control: no-store { \"error\": \"invalid_request\" }\n\nTOC\n\n3.1.3.5. Token Response Validation\n\nThe Client MUST validate the Token Response as follows:\n\nFollow the validation rules in RFC 6749, especially those in Sections 5.1 and 10.12.\n\nFollow the ID Token validation rules in Section 3.1.3.7 (ID Token Validation).\n\nFollow the Access Token validation rules in Section 3.1.3.8 (Access Token Validation).\n\nTOC\n\n3.1.3.6. ID Token\n\nThe contents of the ID Token are as described in Section 2 (ID Token). When using the Authorization Code Flow, these additional requirements for the following ID Token Claims apply:\n\nat_hash\n\nOPTIONAL. Access Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url-encode them. The at_hash value is a case-sensitive string.\n\nTOC\n\n3.1.3.7. ID Token Validation\n\nClients MUST validate the ID Token in the Token Response in the following manner:\n\nIf the ID Token is encrypted, decrypt it using the keys and algorithms that the Client specified during Registration that the OP was to use to encrypt the ID Token. If encryption was negotiated with the OP at Registration time and the ID Token is not encrypted, the RP SHOULD reject it.\n\nThe Issuer Identifier for the OpenID Provider (which is typically obtained during Discovery) MUST exactly match the value of the iss (issuer) Claim.\n\nThe Client MUST validate that the aud (audience) Claim contains its client_id value registered at the Issuer identified by the iss (issuer) Claim as an audience. The aud (audience) Claim MAY contain an array with more than one element. The ID Token MUST be rejected if the ID Token does not list the Client as a valid audience, or if it contains additional audiences not trusted by the Client.\n\nIf the implementation is using extensions (which are beyond the scope of this specification) that result in the azp (authorized party) Claim being present, it SHOULD validate the azp value as specified by those extensions.\n\nThis validation MAY include that when an azp (authorized party) Claim is present, the Client SHOULD verify that its client_id is the Claim Value.\n\nIf the ID Token is received via direct communication between the Client and the Token Endpoint (which it is in this flow), the TLS server validation MAY be used to validate the issuer in place of checking the token signature. The Client MUST validate the signature of all other ID Tokens according to JWS (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” May 2015.) [JWS] using the algorithm specified in the JWT alg Header Parameter. The Client MUST use the keys provided by the Issuer.\n\nThe alg value SHOULD be the default of RS256 or the algorithm sent by the Client in the id_token_signed_response_alg parameter during Registration.\n\nIf the JWT alg Header Parameter uses a MAC based algorithm such as HS256, HS384, or HS512, the octets of the UTF-8 [RFC3629] (Yergeau, F., “UTF-8, a transformation format of ISO 10646,” November 2003.) representation of the client_secret corresponding to the client_id contained in the aud (audience) Claim are used as the key to validate the signature. For MAC based algorithms, the behavior is unspecified if the aud is multi-valued.\n\nThe current time MUST be before the time represented by the exp Claim.\n\nThe iat Claim can be used to reject tokens that were issued too far away from the current time, limiting the amount of time that nonces need to be stored to prevent attacks. The acceptable range is Client specific.\n\nIf a nonce value was sent in the Authentication Request, a nonce Claim MUST be present and its value checked to verify that it is the same value as the one that was sent in the Authentication Request. The Client SHOULD check the nonce value for replay attacks. The precise method for detecting replay attacks is Client specific.\n\nIf the acr Claim was requested, the Client SHOULD check that the asserted Claim Value is appropriate. The meaning and processing of acr Claim Values is out of scope for this specification.\n\nIf the auth_time Claim was requested, either through a specific request for this Claim or by using the max_age parameter, the Client SHOULD check the auth_time Claim value and request re-authentication if it determines too much time has elapsed since the last End-User authentication.\n\nTOC\n\n3.1.3.8. Access Token Validation\n\nWhen using the Authorization Code Flow, if the ID Token contains an at_hash Claim, the Client MAY use it to validate the Access Token in the same manner as for the Implicit Flow, as defined in Section 3.2.2.9 (Access Token Validation), but using the ID Token and Access Token returned from the Token Endpoint.\n\nTOC\n\n3.2. Authentication using the Implicit Flow\n\nThis section describes how to perform authentication using the Implicit Flow. When using the Implicit Flow, all tokens are returned from the Authorization Endpoint; the Token Endpoint is not used.\n\nThe Implicit Flow is mainly used by Clients implemented in a browser using a scripting language. The Access Token and ID Token are returned directly to the Client, which may expose them to the End-User and applications that have access to the End-User's User Agent. The Authorization Server does not perform Client Authentication.\n\nTOC\n\n3.2.1. Implicit Flow Steps\n\nThe Implicit Flow follows the following steps:\n\nClient prepares an Authentication Request containing the desired request parameters.\n\nClient sends the request to the Authorization Server.\n\nAuthorization Server Authenticates the End-User.\n\nAuthorization Server obtains End-User Consent/Authorization.\n\nAuthorization Server sends the End-User back to the Client with an ID Token and, if requested, an Access Token.\n\nClient validates the ID token and retrieves the End-User's Subject Identifier.\n\nTOC\n\n3.2.2. Authorization Endpoint\n\nWhen using the Implicit Flow, the Authorization Endpoint is used in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2 (Authorization Endpoint), with the exception of the differences specified in this section.\n\nTOC\n\n3.2.2.1. Authentication Request\n\nAuthentication Requests are made as defined in Section 3.1.2.1 (Authentication Request), except that these Authentication Request parameters are used as follows:\n\nresponse_type\n\nREQUIRED. OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used. When using the Implicit Flow, this value is id_token token or id_token. The meanings of both of these values are defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses]. No Access Token is returned when the value is id_token.\n\nNOTE: While OAuth 2.0 also defines the token Response Type value for the Implicit Flow, OpenID Connect does not use this Response Type, since no ID Token would be returned.\n\nredirect_uri\n\nREQUIRED. Redirection URI to which the response will be sent. This URI MUST exactly match one of the Redirection URI values for the Client pre-registered at the OpenID Provider, with the matching performed as described in Section 6.2.1 of [RFC3986] (Berners-Lee, T., Fielding, R., and L. Masinter, “Uniform Resource Identifier (URI): Generic Syntax,” January 2005.) (Simple String Comparison). When using this flow, the Redirection URI MUST NOT use the http scheme unless the Client is a native application, in which case it MAY use the http scheme with localhost or the IP loopback literals 127.0.0.1 or [::1] as the hostname.\n\nnonce\n\nREQUIRED. String value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values. For implementation notes, see Section 15.5.2 (Nonce Implementation Notes).\n\nThe following is a non-normative example request using the Implicit Flow that would be sent by the User Agent to the Authorization Server in response to a corresponding HTTP 302 redirect response by the Client (with line wraps within values for display purposes only):\n\nGET /authorize? response_type=id_token%20token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile &state=af0ifjsldkj &nonce=n-0S6_WzA2Mj HTTP/1.1 Host: server.example.com\n\nTOC\n\n3.2.2.2. Authentication Request Validation\n\nWhen using the Implicit Flow, the Authentication Request is validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.2 (Authentication Request Validation).\n\nTOC\n\n3.2.2.3. Authorization Server Authenticates End-User\n\nWhen using the Implicit Flow, End-User Authentication is performed in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.3 (Authorization Server Authenticates End-User).\n\nTOC\n\n3.2.2.4. Authorization Server Obtains End-User Consent/Authorization\n\nWhen using the Implicit Flow, End-User Consent is obtained in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.4 (Authorization Server Obtains End-User Consent/Authorization).\n\nTOC\n\n3.2.2.5. Successful Authentication Response\n\nWhen using the Implicit Flow, Authentication Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.5 (Successful Authentication Response), with the exception of the differences specified in this section.\n\nWhen using the Implicit Flow, all response parameters are added to the fragment component of the Redirection URI, as specified in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses], unless a different Response Mode was specified.\n\nThese parameters are returned from the Authorization Endpoint:\n\naccess_token\n\nOAuth 2.0 Access Token. This is returned unless the response_type value used is id_token.\n\ntoken_type\n\nOAuth 2.0 Token Type value. The value MUST be Bearer or another token_type value that the Client has negotiated with the Authorization Server. Clients implementing this profile MUST support the OAuth 2.0 Bearer Token Usage (Jones, M. and D. Hardt, “The OAuth 2.0 Authorization Framework: Bearer Token Usage,” October 2012.) [RFC6750] specification. This profile only describes the use of bearer tokens. This is returned in the same cases as access_token is.\n\nid_token\n\nREQUIRED. ID Token.\n\nstate\n\nOAuth 2.0 state value. REQUIRED if the state parameter is present in the Authorization Request. Clients MUST verify that the state value is equal to the value of state parameter in the Authorization Request.\n\nexpires_in\n\nOPTIONAL. Expiration time of the Access Token in seconds since the response was generated.\n\nPer Section 4.2.2 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749], no code result is returned when using the Implicit Flow.\n\nThe following is a non-normative example of a successful response using the Implicit Flow (with line wraps for the display purposes only):\n\nHTTP/1.1 302 Found Location: https://client.example.org/cb# access_token=SlAV32hkKG &token_type=bearer &id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso &expires_in=3600 &state=af0ifjsldkj\n\nTOC\n\n3.2.2.6. Authentication Error Response\n\nWhen using the Implicit Flow, Authorization Error Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.6 (Authentication Error Response), with the exception of the differences specified in this section.\n\nWhenever Error Response parameters are returned, such as when End-User denies the authorization or the End-User authentication fails, the Authorization Server MUST return the error Authorization Response in the fragment component of the Redirection URI, as defined in Section 4.2.2.1 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749] and OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses], unless a different Response Mode was specified.\n\nTOC\n\n3.2.2.7. Redirect URI Fragment Handling\n\nSince response parameters are returned in the Redirection URI fragment value, the Client needs to have the User Agent parse the fragment encoded values and pass them to on to the Client's processing logic for consumption. See Section 15.5.3 (Redirect URI Fragment Handling Implementation Notes) for implementation notes on URI fragment handling.\n\nTOC\n\n3.2.2.8. Authentication Response Validation\n\nWhen using the Implicit Flow, the Client MUST validate the response as follows:\n\nVerify that the response conforms to Section 5 of [OAuth.Responses] (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.).\n\nFollow the validation rules in RFC 6749, especially those in Sections 4.2.2 and 10.12.\n\nFollow the ID Token validation rules in Section 3.2.2.11 (ID Token Validation).\n\nFollow the Access Token validation rules in Section 3.2.2.9 (Access Token Validation), unless the response_type value used is id_token.\n\nTOC\n\n3.2.2.9. Access Token Validation\n\nTo validate an Access Token issued from the Authorization Endpoint with an ID Token, the Client SHOULD do the following:\n\nHash the octets of the ASCII representation of the access_token with the hash algorithm specified in JWA (Jones, M., “JSON Web Algorithms (JWA),” May 2015.) [JWA] for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n\nTake the left-most half of the hash and base64url-encode it.\n\nThe value of at_hash in the ID Token MUST match the value produced in the previous step.\n\nTOC\n\n3.2.2.10. ID Token\n\nThe contents of the ID Token are as described in Section 2 (ID Token). When using the Implicit Flow, these additional requirements for the following ID Token Claims apply:\n\nnonce\n\nUse of the nonce Claim is REQUIRED for this flow.\n\nat_hash\n\nAccess Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url-encode them. The at_hash value is a case-sensitive string.\n\nIf the ID Token is issued from the Authorization Endpoint with an access_token value, which is the case for the response_type value id_token token, this is REQUIRED; it MAY NOT be used when no Access Token is issued, which is the case for the response_type value id_token.\n\nTOC\n\n3.2.2.11. ID Token Validation\n\nWhen using the Implicit Flow, the contents of the ID Token MUST be validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.7 (ID Token Validation), with the exception of the differences specified in this section.\n\nThe Client MUST validate the signature of the ID Token according to JWS (Jones, M., Bradley, J., and N. Sakimura, “JSON Web Signature (JWS),” May 2015.) [JWS] using the algorithm specified in the alg Header Parameter of the JOSE Header.\n\nThe value of the nonce Claim MUST be checked to verify that it is the same value as the one that was sent in the Authentication Request. The Client SHOULD check the nonce value for replay attacks. The precise method for detecting replay attacks is Client specific.\n\nTOC\n\n3.3. Authentication using the Hybrid Flow\n\nThis section describes how to perform authentication using the Hybrid Flow. When using the Hybrid Flow, some tokens are returned from the Authorization Endpoint and others are returned from the Token Endpoint. The mechanisms for returning tokens in the Hybrid Flow are specified in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses].\n\nTOC\n\n3.3.1. Hybrid Flow Steps\n\nThe Hybrid Flow follows the following steps:\n\nClient prepares an Authentication Request containing the desired request parameters.\n\nClient sends the request to the Authorization Server.\n\nAuthorization Server Authenticates the End-User.\n\nAuthorization Server obtains End-User Consent/Authorization.\n\nAuthorization Server sends the End-User back to the Client with an Authorization Code and, depending on the Response Type, one or more additional parameters.\n\nClient requests a response using the Authorization Code at the Token Endpoint.\n\nClient receives a response that contains an ID Token and Access Token in the response body.\n\nClient validates the ID Token and retrieves the End-User's Subject Identifier.\n\nTOC\n\n3.3.2. Authorization Endpoint\n\nWhen using the Hybrid Flow, the Authorization Endpoint is used in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2 (Authorization Endpoint), with the exception of the differences specified in this section.\n\nTOC\n\n3.3.2.1. Authentication Request\n\nAuthentication Requests are made as defined in Section 3.1.2.1 (Authentication Request), except that these Authentication Request parameters are used as follows:\n\nresponse_type\n\nREQUIRED. OAuth 2.0 Response Type value that determines the authorization processing flow to be used, including what parameters are returned from the endpoints used. When using the Hybrid Flow, this value is code id_token, code token, or code id_token token. The meanings of these values are defined in OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses].\n\nnonce\n\nREQUIRED if the Response Type of the request is code id_token or code id_token token and OPTIONAL when the Response Type of the request is code token. It is a string value used to associate a Client session with an ID Token, and to mitigate replay attacks. The value is passed through unmodified from the Authentication Request to the ID Token. Sufficient entropy MUST be present in the nonce values used to prevent attackers from guessing values. For implementation notes, see Section 15.5.2 (Nonce Implementation Notes).\n\nThe following is a non-normative example request using the Hybrid Flow that would be sent by the User Agent to the Authorization Server in response to a corresponding HTTP 302 redirect response by the Client (with line wraps within values for display purposes only):\n\nGET /authorize? response_type=code%20id_token &client_id=s6BhdRkqt3 &redirect_uri=https%3A%2F%2Fclient.example.org%2Fcb &scope=openid%20profile%20email &nonce=n-0S6_WzA2Mj &state=af0ifjsldkj HTTP/1.1 Host: server.example.com\n\nTOC\n\n3.3.2.2. Authentication Request Validation\n\nWhen using the Hybrid Flow, the Authentication Request is validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.2 (Authentication Request Validation).\n\nTOC\n\n3.3.2.3. Authorization Server Authenticates End-User\n\nWhen using the Hybrid Flow, End-User Authentication is performed in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.3 (Authorization Server Authenticates End-User).\n\nTOC\n\n3.3.2.4. Authorization Server Obtains End-User Consent/Authorization\n\nWhen using the Hybrid Flow, End-User Consent is obtained in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.4 (Authorization Server Obtains End-User Consent/Authorization).\n\nTOC\n\n3.3.2.5. Successful Authentication Response\n\nWhen using the Hybrid Flow, Authentication Responses are made in the same manner as for the Implicit Flow, as defined in Section 3.2.2.5 (Successful Authentication Response), with the exception of the differences specified in this section.\n\nThese Authorization Endpoint results are used in the following manner:\n\naccess_token\n\nOAuth 2.0 Access Token. This is returned when the response_type value used is code token, or code id_token token. (A token_type value is also returned in the same cases.)\n\nid_token\n\nID Token. This is returned when the response_type value used is code id_token or code id_token token.\n\ncode\n\nAuthorization Code. This is always returned when using the Hybrid Flow.\n\nThe following is a non-normative example of a successful response using the Hybrid Flow (with line wraps for the display purposes only):\n\nHTTP/1.1 302 Found Location: https://client.example.org/cb# code=SplxlOBeZQQYbYS6WxSbIA &id_token=eyJ0 ... NiJ9.eyJ1c ... I6IjIifX0.DeWt4Qu ... ZXso &state=af0ifjsldkj\n\nTOC\n\n3.3.2.6. Authentication Error Response\n\nWhen using the Hybrid Flow, Authorization Error Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.2.6 (Authentication Error Response), with the exception of the differences specified in this section.\n\nWhenever Error Response parameters are returned, such as when End-User denies the authorization or the End-User authentication fails, the Authorization Server MUST return the error Authorization Response in the fragment component of the Redirection URI, as defined in Section 4.2.2.1 of OAuth 2.0 (Hardt, D., Ed., “The OAuth 2.0 Authorization Framework,” October 2012.) [RFC6749] and OAuth 2.0 Multiple Response Type Encoding Practices (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.) [OAuth.Responses], unless a different Response Mode was specified.\n\nTOC\n\n3.3.2.7. Redirect URI Fragment Handling\n\nWhen using the Hybrid Flow, the same requirements for Redirection URI fragment parameter handling apply as do for the Implicit Flow, as defined in Section 3.2.2.7 (Redirect URI Fragment Handling). Also see Section 15.5.3 (Redirect URI Fragment Handling Implementation Notes) for implementation notes on URI fragment handling.\n\nTOC\n\n3.3.2.8. Authentication Response Validation\n\nWhen using the Hybrid Flow, the Client MUST validate the response as follows:\n\nVerify that the response conforms to Section 5 of [OAuth.Responses] (de Medeiros, B., Ed., Scurtescu, M., Tarjan, P., and M. Jones, “OAuth 2.0 Multiple Response Type Encoding Practices,” February 2014.).\n\nFollow the validation rules in RFC 6749, especially those in Sections 4.2.2 and 10.12.\n\nFollow the ID Token validation rules in Section 3.3.2.12 (ID Token Validation) when the response_type value used is code id_token or code id_token token.\n\nFollow the Access Token validation rules in Section 3.3.2.9 (Access Token Validation) when the response_type value used is code token or code id_token token.\n\nFollow the Authorization Code validation rules in Section 3.3.2.10 (Authorization Code Validation) when the response_type value used is code id_token or code id_token token.\n\nTOC\n\n3.3.2.9. Access Token Validation\n\nWhen using the Hybrid Flow, Access Tokens returned from the Authorization Endpoint are validated in the same manner as for the Implicit Flow, as defined in Section 3.2.2.9 (Access Token Validation).\n\nTOC\n\n3.3.2.10. Authorization Code Validation\n\nTo validate an Authorization Code issued from the Authorization Endpoint with an ID Token, the Client SHOULD do the following:\n\nHash the octets of the ASCII representation of the code with the hash algorithm specified in JWA (Jones, M., “JSON Web Algorithms (JWA),” May 2015.) [JWA] for the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, the hash algorithm used is SHA-256.\n\nTake the left-most half of the hash and base64url-encode it.\n\nThe value of c_hash in the ID Token MUST match the value produced in the previous step if c_hash is present in the ID Token.\n\nTOC\n\n3.3.2.11. ID Token\n\nThe contents of the ID Token are as described in Section 2 (ID Token). When using the Hybrid Flow, these additional requirements for the following ID Token Claims apply to an ID Token returned from the Authorization Endpoint:\n\nnonce\n\nIf a nonce parameter is present in the Authentication Request, Authorization Servers MUST include a nonce Claim in the ID Token.\n\nat_hash\n\nAccess Token hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the access_token value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is RS256, hash the access_token value with SHA-256, then take the left-most 128 bits and base64url-encode them. The at_hash value is a case-sensitive string.\n\nIf the ID Token is issued from the Authorization Endpoint with an access_token value, which is the case for the response_type value code id_token token, this is REQUIRED; otherwise, its inclusion is OPTIONAL.\n\nc_hash\n\nCode hash value. Its value is the base64url encoding of the left-most half of the hash of the octets of the ASCII representation of the code value, where the hash algorithm used is the hash algorithm used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is HS512, hash the code value with SHA-512, then take the left-most 256 bits and base64url-encode them. The c_hash value is a case-sensitive string.\n\nIf the ID Token is issued from the Authorization Endpoint with a code, which is the case for the response_type values code id_token and code id_token token, this is REQUIRED; otherwise, its inclusion is OPTIONAL.\n\nTOC\n\n3.3.2.12. ID Token Validation\n\nWhen using the Hybrid Flow, the contents of an ID Token returned from the Authorization Endpoint MUST be validated in the same manner as for the Implicit Flow, as defined in Section 3.2.2.11 (ID Token Validation).\n\nTOC\n\n3.3.3. Token Endpoint\n\nWhen using the Hybrid Flow, the Token Endpoint is used in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3 (Token Endpoint), with the exception of the differences specified in this section.\n\nTOC\n\n3.3.3.1. Token Request\n\nWhen using the Hybrid Flow, Token Requests are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.1 (Token Request).\n\nTOC\n\n3.3.3.2. Token Request Validation\n\nWhen using the Hybrid Flow, Token Requests are validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.2 (Token Request Validation).\n\nTOC\n\n3.3.3.3. Successful Token Response\n\nWhen using the Hybrid Flow, Token Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.3 (Successful Token Response).\n\nTOC\n\n3.3.3.4. Token Error Response\n\nWhen using the Hybrid Flow, Token Error Responses are made in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.4 (Token Error Response).\n\nTOC\n\n3.3.3.5. Token Response Validation\n\nWhen using the Hybrid Flow, Token Responses are validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.5 (Token Response Validation).\n\nTOC\n\n3.3.3.6. ID Token\n\nWhen using the Hybrid Flow, the contents of an ID Token returned from the Token Endpoint are the same as for an ID Token returned from the Authorization Endpoint, as defined in Section 3.3.2.11 (ID Token), with the exception of the differences specified in this section.\n\nIf an ID Token is returned from both the Authorization Endpoint and from the Token Endpoint, which is the case for the response_type values code id_token and code id_token token, the iss and sub Claim Values MUST be identical in both ID Tokens. All Claims about the Authentication event present in either SHOULD be present in both. If either ID Token contains Claims about the End-User, any that are present in both SHOULD have the same values in both. Note that the OP MAY choose to return fewer Claims about the End-User from the Authorization Endpoint, for instance, for privacy reasons. The at_hash and c_hash Claims MAY be omitted from the ID Token returned from the Token Endpoint even when these Claims are present in the ID Token returned from the Authorization Endpoint, because the ID Token and Access Token values returned from the Token Endpoint are already cryptographically bound together by the TLS encryption performed by the Token Endpoint.\n\nTOC\n\n3.3.3.7. ID Token Validation\n\nWhen using the Hybrid Flow, the contents of an ID Token returned from the Token Endpoint MUST be validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.7 (ID Token Validation).\n\nTOC\n\n3.3.3.8. Access Token\n\nIf an Access Token is returned from both the Authorization Endpoint and from the Token Endpoint, which is the case for the response_type values code token and code id_token token, their values MAY be the same or they MAY be different. Note that different Access Tokens might be returned be due to the different security characteristics of the two endpoints and the lifetimes and the access to resources granted by them might also be different.\n\nTOC\n\n3.3.3.9. Access Token Validation\n\nWhen using the Hybrid Flow, the Access Token returned from the Token Endpoint is validated in the same manner as for the Authorization Code Flow, as defined in Section 3.1.3.8 (Access Token Validation).\n\nTOC\n\n4. Initiating Login from a Third Party\n\nIn some cases, the login flow is initiated by an OpenID Provider or another party, rather than the Relying Party. In this case, the initiator redirects to the RP at its login initiation endpoint, which requests that the RP send an Authentication Request to a specified OP. Note that this login initiation endpoint can be a different page at the RP than the RP's default landing page. RPs supporting OpenID Connect Dynamic Client Registration 1.0 (Sakimura, N., Bradley, J., and M. Jones, “OpenID Connect Dynamic Client Registration 1.0,” December 2023.) [OpenID.Registration] register this endpoint value using the initiate_login_uri Registration parameter.\n\nThe party initiating the login request does so by redirecting to the login initiation endpoint at the RP, passing the following parameters:\n\niss\n\nREQUIRED. Issuer Identifier for the OP that the RP is to send the Authentication Request to. Its value MUST be a URL using the https scheme.\n\nlogin_hint\n\nOPTIONAL. Hint to the Authorization Server about the End-User to be authenticated. The meaning of this string-valued parameter is left to the OP's discretion. In common use cases, the value will contain an e-mail address, phone number, or username collected by the RP before requesting authentication at the OP. For example, this hint can be used by an RP after it asks the End-User for their e-mail address (or other identifier), passing that identifier as a hint to the OpenID Provider. It is RECOMMENDED that the hint value match the value provided for discovery. Other uses MAY include using the sub claim from the ID Token as the hint value or potentially other kinds of information about the requested authentication.\n\ntarget_link_uri\n\nOPTIONAL. URL that the RP is requested to redirect to after authentication. RPs MUST verify the value of the target_link_uri to prevent being used as an open redirector to external sites.\n\nThe parameters can either be passed as query parameters using the HTTP GET method or be passed as HTML form values that are auto-submitted in the User Agent, and thus are transmitted via the HTTP POST method.\n\nOther parameters MAY be sent, if defined by extensions. Any parameters used that are not understood MUST be ignored by the Client.\n\nClients SHOULD employ frame busting and other techniques to prevent End-Users from being logged in by third party sites without their knowledge through attacks such as Clickjacking. Refer to Section 4.4.1.9 of [RFC6819] (Lodderstedt, T., Ed., McGloin, M., and P. Hunt, “OAuth 2.0 Threat Model and Security Considerations,” January 2013.) for more details.\n\nTOC\n\n5. Claims\n\nThis section specifies how the Client can obtain Claims about the End-User and the Authentication event. It also defines a standard set of basic profile Claims. Pre-defined sets of Claims can be requested using specific scope values or individual Claims can be requested using the claims request parameter. The Claims can come directly from the OpenID Provider or from distributed sources as well.\n\nTOC\n\n5.1. Standard Claims\n\nThis specification defines a set of standard Claims. They can be requested to be returned either in the UserInfo Response, per Section 5.3.2 (Successful UserInfo Response), or in the ID Token, per Section 2 (ID Token).\n\nMemberTypeDescription sub string Subject - Identifier for the End-User at the Issuer. name string End-User's full name in displayable form including all name parts, possibly including titles and suffixes, ordered according to the End-User's locale and preferences. given_name string Given name(s) or first name(s) of the End-User. Note that in some cultures, people can have multiple given names; all can be present, with the names being separated by space characters. family_name string Surname(s) or last name(s) of the End-User. Note that in some cultures, people can have multiple family names or no family name; all can be present, with the names being separated by space characters. middle_name string Middle name(s) of the End-User. Note that in some cultures, people can have multiple middle names; all can be present, with the names being separated by space characters. Also note that in some cultures, middle names are not used. nickname string Casual name of the End-User that may or may not be the same as the given_name. For instance, a nickname value of Mike might be returned alongside a given_name value of Michael. preferred_username string Shorthand name by which the End-User wishes to be referred to at the RP, such as janedoe or j.doe. This value MAY be any valid JSON string including special characters such as @, /, or whitespace. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7 (Claim Stability and Uniqueness). profile string URL of the End-User's profile page. The contents of this Web page SHOULD be about the End-User. picture string URL of the End-User's profile picture. This URL MUST refer to an image file (for example, a PNG, JPEG, or GIF image file), rather than to a Web page containing an image. Note that this URL SHOULD specifically reference a profile photo of the End-User suitable for displaying when describing the End-User, rather than an arbitrary photo taken by the End-User. website string URL of the End-User's Web page or blog. This Web page SHOULD contain information published by the End-User or an organization that the End-User is affiliated with. email string End-User's preferred e-mail address. Its value MUST conform to the RFC 5322 (Resnick, P., Ed., “Internet Message Format,” October 2008.) [RFC5322] addr-spec syntax. The RP MUST NOT rely upon this value being unique, as discussed in Section 5.7 (Claim Stability and Uniqueness). email_verified boolean True if the End-User's e-mail address has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this e-mail address was controlled by the End-User at the time the verification was performed. The means by which an e-mail address is verified is context specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. gender string End-User's gender. Values defined by this specification are female and male. Other values MAY be used when neither of the defined values are applicable. birthdate string End-User's birthday, represented as an ISO 8601-1 (International Organization for Standardization, “ISO 8601-1:2019/Amd 1:2022. Date and time - Representations for information interchange - Part 1: Basic rules,” October 2022.) [ISO8601‑1] YYYY-MM-DD format. The year MAY be 0000, indicating that it is omitted. To represent only the year, YYYY format is allowed. Note that depending on the underlying platform's date related function, providing just year can result in varying month and day, so the implementers need to take this factor into account to correctly process the dates. zoneinfo string String from IANA Time Zone Database [IANA.time‑zones] (IANA, “Time Zone Database,” .) representing the End-User's time zone. For example, Europe/Paris or America/Los_Angeles. locale string End-User's locale, represented as a BCP47 (Phillips, A., Ed. and M. Davis, Ed., “Tags for Identifying Languages,” September 2009.) [RFC5646] language tag. This is typically an ISO 639 Alpha-2 (International Organization for Standardization, “ISO 639:2023. Code for individual languages and language groups,” November 2023.) [ISO639] language code in lowercase and an ISO 3166-1 Alpha-2 (International Organization for Standardization, “ISO 3166-1:2020. Codes for the representation of names of countries and their subdivisions - Part 1: Country codes,” August 2020.) [ISO3166‑1] country code in uppercase, separated by a dash. For example, en-US or fr-CA. As a compatibility note, some implementations have used an underscore as the separator rather than a dash, for example, en_US; Relying Parties MAY choose to accept this locale syntax as well. phone_number string End-User's preferred telephone number. E.164 (International Telecommunication Union, “E.164: The international public telecommunication numbering plan,” 2010.) [E.164] is RECOMMENDED as the format of this Claim, for example, +1 (425) 555-1212 or +56 (2) 687 2400. If the phone number contains an extension, it is RECOMMENDED that the extension be represented using the RFC 3966 (Schulzrinne, H., “The tel URI for Telephone Numbers,” December 2004.) [RFC3966] extension syntax, for example, +1 (604) 555-1234;ext=5678. phone_number_verified boolean True if the End-User's phone number has been verified; otherwise false. When this Claim Value is true, this means that the OP took affirmative steps to ensure that this phone number was controlled by the End-User at the time the verification was performed. The means by which a phone number is verified is context specific, and dependent upon the trust framework or contractual agreements within which the parties are operating. When true, the phone_number Claim MUST be in E.164 format and any extensions MUST be represented in RFC 3966 format. address JSON object End-User's preferred postal address. The value of the address member is a JSON [RFC8259] (Bray, T., Ed., “The JavaScript Object Notation (JSON) Data Interchange Format,” December 2017.) structure containing some or all of the members defined in Section 5.1.1 (Address Claim). updated_at number Time the End-User's information was last updated. Its value is a JSON number representing the number of seconds from 1970-01-01T00:00:00Z as measured in UTC until the date/time.\n\nTable 1: Registered Member Definitions\n\nTOC\n\n5.1.1. Address Claim\n\nThe Address Claim represents a physical mailing address. Implementations MAY return only a subset of the f"
    }
}