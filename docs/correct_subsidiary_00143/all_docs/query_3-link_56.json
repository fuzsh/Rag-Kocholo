{
    "id": "correct_subsidiary_00143_3",
    "rank": 56,
    "data": {
        "url": "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/",
        "read_more_link": "",
        "language": "en",
        "title": "Directory Services 6.5 > Administration Guide",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/shared/images/directory-data.svg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_JXplorer-dsml.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_equality-index.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_index-entry-limit.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_repl-topologies-right.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_repl-topologies-wrong.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/config.svg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/update.svg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/status.svg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_standalone-repl.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_pwd-policy-types.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_subtree-specification.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_api-documentation.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_distribution-vs-load-balancing.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_proxy-load-balancing.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/thumb_keystores.jpg",
            "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/images/inconsistent.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Mark Craig",
            "Nemanja Lukić",
            "Ludovic Poitou",
            "Chris Ridd"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Guide to configuring and using ForgeRock® Directory Services features.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://backstage.forgerock.com/docs/ds/6.5/admin-guide/",
        "text": "Chapter 1. Understanding Directory Services\n\nThis chapter introduces directory concepts and server features. In this chapter you will learn:\n\nWhy directory services exist and what they do well\n\nHow data is arranged in directories that support Lightweight Directory Access Protocol (LDAP)\n\nHow clients and servers communicate in LDAP\n\nWhat operations are standard according to LDAP and how standard extensions to the protocol work\n\nWhy directory servers index directory data\n\nWhat LDAP schemas are for\n\nWhat LDAP directories provide to control access to directory data\n\nWhy LDAP directory data is replicated and what replication does\n\nWhat Directory Services Markup Language (DSML) is for\n\nHow HTTP applications can access directory data in the Representation State Transfer (REST) style\n\nA directory resembles a dictionary or a phone book. If you know a word, you can look it up its entry in the dictionary to learn its definition or its pronunciation. If you know a name, you can look it up its entry in the phone book to find the telephone number and street address associated with the name. If you are bored, curious, or have lots of time, you can also read through the dictionary, phone book, or directory, entry after entry.\n\nWhere a directory differs from a paper dictionary or phone book is in how entries are indexed. Dictionaries typically have one index—words in alphabetical order. Phone books, too—names in alphabetical order. Directories' entries on the other hand are often indexed for multiple attributes, names, user identifiers, email addresses, and telephone numbers. This means you can look up a directory entry by the name of the user the entry belongs to, but also by their user identifier, their email address, or their telephone number, for example.\n\nForgeRock Directory Services are based on the Lightweight Directory Access Protocol (LDAP). Much of this chapter serves therefore as an introduction to LDAP. ForgeRock Directory Services also provide RESTful access to directory data, yet, as directory administrator, you will find it useful to understand the underlying model even if most users are accessing the directory over HTTP rather than LDAP.\n\n1.1. How Directories and LDAP Evolved\n\nPhone companies have been managing directories for many decades. The Internet itself has relied on distributed directory services like DNS since the mid 1980s.\n\nIt was not until the late 1980s, however, that experts from what is now the International Telecommunications Union published the X.500 set of international standards, including Directory Access Protocol. The X.500 standards specify Open Systems Interconnect (OSI) protocols and data definitions for general purpose directory services. The X.500 standards were designed to meet the needs of systems built according to the X.400 standards, covering electronic mail services.\n\nLightweight Directory Access Protocol has been around since the early 1990s. LDAP was originally developed as an alternative protocol that would allow directory access over Internet protocols rather than OSI protocols, and be lightweight enough for desktop implementations. By the mid-1990s, LDAP directory servers became generally available and widely used.\n\nUntil the late 1990s, LDAP directory servers were designed primarily with quick lookups and high availability for lookups in mind. LDAP directory servers replicate data, so when an update is made, that update is applied to other peer directory servers. Thus, if one directory server goes down, lookups can continue on other servers. Furthermore, if a directory service needs to support more lookups, the administrator can simply add another directory server to replicate with its peers.\n\nAs organizations rolled out larger and larger directories serving more and more applications, they discovered that they needed high availability not only for lookups, but also for updates. Around the year 2000, directories began to support multi-master replication; that is, replication with multiple read-write servers. Soon thereafter, the organizations with the very largest directories started to need higher update performance as well as availability.\n\nThe DS code base began in the mid-2000s, when engineers solving the update performance issue decided that the cost of adapting the existing C-based directory technology for high-performance updates would be higher than the cost of building new, high-performance directory using Java technology.\n\n1.2. About Data In LDAP Directories\n\nLDAP directory data is organized into entries, similar to the entries for words in the dictionary, or for subscriber names in the phone book. A sample entry follows:\n\ndn: uid=bjensen,ou=People,dc=example,dc=com uid: bjensen cn: Babs Jensen cn: Barbara Jensen facsimileTelephoneNumber: +1 408 555 1992 gidNumber: 1000 givenName: Barbara homeDirectory: /home/bjensen l: San Francisco mail: bjensen@example.com objectClass: inetOrgPerson objectClass: organizationalPerson objectClass: person objectClass: posixAccount objectClass: top ou: People ou: Product Development roomNumber: 0209 sn: Jensen telephoneNumber: +1 408 555 1862 uidNumber: 1076\n\nBarbara Jensen's entry has a number of attributes, such as uid: bjensen, telephoneNumber: +1 408 555 1862, and objectClass: posixAccount. (The objectClass attribute type indicates which types of attributes are required and allowed for the entry. As the entries object classes can be updated online, and even the definitions of object classes and attributes are expressed as entries that can be updated online, directory data is extensible on the fly.) When you look up her entry in the directory, you specify one or more attributes and values to match. The directory server then returns entries with attribute values that match what you specified.\n\nThe attributes you search for are indexed in the directory, so the directory server can retrieve them more quickly. Attribute values do not have to be strings. Some attribute values, like certificates and photos, are binary.\n\nThe entry also has a unique identifier, shown at the top of the entry, dn: uid=bjensen,ou=People,dc=example,dc=com. DN is an acronym for distinguished name. No two entries in the directory have the same distinguished name. Yet, DNs are typically composed of case-insensitive attributes.\n\nSometimes distinguished names include characters that you must escape. The following example shows an entry that includes escaped characters in the DN:\n\n$ ldapsearch --port 1389 --baseDN dc=example,dc=com \"(uid=escape)\" dn: cn=DN Escape Characters \\\" # \\+ \\, \\; \\< = \\> \\\\,dc=example,dc=com objectClass: person objectClass: inetOrgPerson objectClass: organizationalPerson objectClass: top givenName: DN Escape Characters uid: escape cn: DN Escape Characters \" # + , ; < = > \\ sn: \" # + , ; < = > \\ mail: escape@example.com\n\nLDAP entries are arranged hierarchically in the directory. The hierarchical organization resembles a file system on a PC or a web server, often imagined as an upside down tree structure, or a pyramid. The distinguished name consists of components separated by commas, uid=bjensen,ou=People,dc=example,dc=com. The names are little-endian. The components reflect the hierarchy of directory entries.\n\n\"Directory Data\" shows the hierarchy.\n\nDirectory Data\n\nBarbara Jensen's entry is located under an entry with DN ou=People,dc=example,dc=com, an organization unit and parent entry for the people at Example.com. The ou=People entry is located under the entry with DN dc=example,dc=com, the base entry for Example.com. DC is an acronym for domain component. The directory has other base entries, such as cn=config, under which the configuration is accessible through LDAP. A directory can serve multiple organizations, too. You might find dc=example,dc=com, dc=mycompany,dc=com, and o=myOrganization in the same LDAP directory. Therefore, when you look up entries, you specify the base DN to look under in the same way you need to know whether to look in the New York, Paris, or Tokyo phone book to find a telephone number. The root entry for the directory, technically the entry with DN \"\" (the empty string), is called the root DSE. It contains information about what the server supports, including the other base DNs it serves.\n\nA directory server stores two kinds of attributes in a directory entry: user attributes and operational attributes. User attributes hold the information for users of the directory. All of the attributes shown in the entry at the outset of this section are user attributes. Operational attributes hold information used by the directory itself. Examples of operational attributes include entryUUID, modifyTimestamp, and subschemaSubentry. When an LDAP search operation finds an entry in the directory, the directory server returns all the visible user attributes unless the search request restricts the list of attributes by specifying those attributes explicitly. The directory server does not, however, return any operational attributes unless the search request specifically asks for them. Generally speaking, applications should change only user attributes, and leave updates of operational attributes to the server, relying on public directory server interfaces to change server behavior. An exception is access control instruction (aci) attributes, which are operational attributes used to control access to directory data.\n\n1.3. About LDAP Client and Server Communication\n\nIn some client server communication, like web browsing, a connection is set up and then torn down for each client request to the server. LDAP has a different model. In LDAP the client application connects to the server and authenticates, then requests any number of operations, perhaps processing results in between requests, and finally disconnects when done.\n\nThe standard operations are as follows:\n\nBind (authenticate). The first operation in an LDAP session usually involves the client binding to the LDAP server with the server authenticating the client. Authentication identifies the client's identity in LDAP terms, the identity which is later used by the server to authorize (or not) access to directory data that the client wants to lookup or change.\n\nIf the client does not bind explicitly, the server treats the client as an anonymous client. An anonymous client is allowed to do anything that can be done anonymously. What can be done anonymously depends on access control and configuration settings. The client can also bind again on the same connection.\n\nSearch (lookup). After binding, the client can request that the server return entries based on an LDAP filter, which is an expression that the server uses to find entries that match the request, and a base DN under which to search. For example, to look up all entries for people with the email address bjensen@example.com in data for Example.com, you would specify a base DN such as ou=People,dc=example,dc=com and the filter (mail=bjensen@example.com).\n\nCompare. After binding, the client can request that the server compare an attribute value the client specifies with the value stored on an entry in the directory.\n\nModify. After binding, the client can request that the server change one or more attribute values on an entry. Often administrators do not allow clients to change directory data, so allow appropriate access for client application if they have the right to update data.\n\nAdd. After binding, the client can request to add one or more new LDAP entries to the server.\n\nDelete. After binding, the client can request that the server delete one or more entries. To delete an entry with other entries underneath, first delete the children, then the parent.\n\nModify DN. After binding, the client can request that the server change the distinguished name of the entry. In other words, this renames the entry or moves it to another location. For example, if Barbara changes her unique identifier from bjensen to something else, her DN would have to change. For another example, if you decide to consolidate ou=Customers and ou=Employees under ou=People instead, all the entries underneath must change distinguished names.\n\nRenaming entire branches of entries can be a major operation for the directory, so avoid moving entire branches if you can.\n\nUnbind. When done making requests, the client can request an unbind operation to end the LDAP session.\n\nAbandon. When a request seems to be taking too long to complete, or when a search request returns many more matches than desired, the client can send an abandon request to the server to drop the operation in progress.\n\nFor practical examples showing how to perform the key operations using the command-line tools delivered with DS servers, read \"Performing LDAP Operations\" in the Developer's Guide.\n\n1.4. About LDAP Controls and Extensions\n\nLDAP has standardized two mechanisms for extending the operations directory servers can perform beyond the basic operations listed above. One mechanism involves using LDAP controls. The other mechanism involves using LDAP extended operations.\n\nLDAP controls are information added to an LDAP message to further specify how an LDAP operation should be processed. For example, the Server-Side Sort request control modifies a search to request that the directory server return entries to the client in sorted order. The Subtree Delete request control modifies a delete to request that the server also remove child entries of the entry targeted for deletion.\n\nOne special search operation that DS servers support is Persistent Search. The client application sets up a Persistent Search to continue receiving new results whenever changes are made to data that is in the scope of the search, thus using the search as a form of change notification. Persistent Searches are intended to remain connected permanently, though they can be idle for long periods of time.\n\nThe directory server can also send response controls in some cases to indicate that the response contains special information. Examples include responses for entry change notification, password policy, and paged results.\n\nFor the list of supported LDAP controls, see \"LDAP Controls\" in the Reference.\n\nLDAP extended operations are additional LDAP operations not included in the original standard list. For example, the Cancel Extended Operation works like an abandon operation, but finishes with a response from the server after the cancel is complete. The StartTLS Extended Operation allows a client to connect to a server on an unsecure port, but then starts Transport Layer Security negotiations to protect communications.\n\nFor the list of supported LDAP extended operations, see \"LDAP Extended Operations\" in the Reference.\n\n1.5. About Indexes\n\nAs mentioned early in this chapter, directories have indexes for multiple attributes. By default, DS does not let normal users perform searches that are not indexed, because such searches mean DS servers have to scan an entire directory database when looking for matches.\n\nAs directory administrator, part of your responsibility is making sure directory data is properly indexed. DS software provides tools for building and rebuilding indexes, for verifying indexes, and for evaluating how well indexes are working.\n\nFor help better understanding and managing indexes, read \"Indexing Attribute Values\".\n\n1.6. About LDAP Schema\n\nSome databases are designed to hold huge amounts of data for a particular application. Although such databases might support multiple applications, how their data is organized depends a lot on the particular applications served.\n\nIn contrast, directories are designed for shared, centralized services. Although the first guides to deploying directory services suggested taking inventory of all the applications that would access the directory, many current directory administrators do not even know how many applications use their services. The shared, centralized nature of directory services fosters interoperability in practice, and has helped directory services be successful in the long term.\n\nPart of what makes this possible is the shared model of directory user information, and in particular the LDAP schema. LDAP schema defines what the directory can contain. This means that directory entries are not arbitrary data, but instead tightly codified objects whose attributes are completely predictable from publicly readable definitions. Many schema definitions are in fact standard. They are the same not just across a directory service but across different directory services.\n\nAt the same time, unlike some databases, LDAP schema and the data it defines can be extended on the fly while the service is running. LDAP schema is also accessible over LDAP. One attribute of every entry is its set of objectClass values. This gives you as administrator great flexibility in adapting your directory service to store new data without losing or changing the structure of existing data, and also without ever stopping your directory service.\n\nFor a closer look, see \"Managing Schema\".\n\n1.7. About Access Control\n\nIn addition to directory schema, another feature of directory services that enables sharing is fine-grained access control.\n\nAs directory administrator, you can control who has access to what data when, how, where and under what conditions by using access control instructions (ACI). You can allow some directory operations and not others. You can scope access control from the whole directory service down to individual attributes on directory entries. You can specify when, from what host or IP address, and what strength of encryption is needed in order to perform a particular operation.\n\nAs ACIs are stored on entries in the directory, you can furthermore update access controls while the service is running, and even delegate that control to client applications. DS software combines the strengths of ACIs with separate administrative privileges to help you secure access to directory data.\n\nFor more information, read \"Configuring Privileges and Access Control\".\n\n1.8. About Replication\n\nDS replication consists of copying each update to the directory service to multiple directory servers. This brings both redundancy, in the case of network partitions or of crashes, and scalability for read operations. Most directory deployments involve multiple servers replicating together.\n\nWhen you have replicated servers, all of which are writable, you can have replication conflicts. What if, for example, there is a network outage between two replicas, and meanwhile two different values are written to the same attribute on the same entry on the two replicas? In nearly all cases, DS replication can resolve these situations automatically without involving you, the directory administrator. This makes your directory service resilient and safe even in the unpredictable real world.\n\nOne perhaps counterintuitive aspect of replication is that although you do add directory read capacity by adding replicas to your deployment, you do not add directory write capacity by adding replicas. As each write operation must be replayed everywhere, the result is that if you have N servers, you have N write operations to replay.\n\nAnother aspect of replication to keep in mind is that it is \"loosely consistent.\" Loosely consistent means that directory data will eventually converge to be the same everywhere, but it will not necessarily be the same everywhere right away. Client applications sometimes get this wrong when they write to a pool of load balanced directory servers, immediately read back what they wrote, and are surprised that it is not the same. If your users are complaining about this, either make sure their application always gets sent to the same server, or else ask that they adapt their application to work in a more realistic manner.\n\nTo get started with replication, see \"Managing Data Replication\".\n\n1.9. About DSMLv2\n\nDirectory Services Markup Language (DSMLv2) v2.0 became a standard in 2001. DSMLv2 describes directory data and basic directory operations in XML format, so they can be carried in Simple Object Access Protocol (SOAP) messages. DSMLv2 further allows clients to batch multiple operations together in a single request, to be processed either in sequential order or in parallel.\n\nDS software provides support for DSMLv2 as a DSML gateway, which is a Servlet that connects to any standard LDAPv3 directory. DSMLv2 opens basic directory services to SOAP-based web services and service oriented architectures.\n\nTo set up DSMLv2 access, see \"DSML Client Access\".\n\n1.10. About RESTful Access to Directory Services\n\nDS software can expose directory data as JSON resources over HTTP to REST clients, providing easy access to directory data for developers who are not familiar with LDAP. RESTful access depends on a configuration that describes how the JSON representation maps to LDAP entries.\n\nAlthough client applications have no need to understand LDAP, the underlying implementation still uses the LDAP model for its operations. The mapping adds some overhead. Furthermore, depending on the configuration, individual JSON resources can require multiple LDAP operations. For example, an LDAP user entry represents manager as a DN (of the manager's entry). The same manager might be represented in JSON as an object holding the manager's user ID and full name, in which case the software must look up the manager's entry to resolve the mapping for the manager portion of the JSON resource, in addition to looking up the user's entry. As another example, suppose a large group is represented in LDAP as a set of 100,000 DNs. If the JSON resource is configured so that a member is represented by its name, then listing that resource would involve 100,000 LDAP searches to translate DNs to names.\n\nA primary distinction between LDAP entries and JSON resources is that LDAP entries hold sets of attributes and their values, whereas JSON resources are documents containing arbitrarily nested objects. As LDAP data is governed by schema, almost no LDAP objects are arbitrary collections of data. (LDAP has the object class extensibleObject, but its use should be the exception rather than the rule.) Furthermore, JSON resources can hold arrays, ordered collections that can contain duplicates, whereas LDAP attributes are sets, unordered collections without duplicates. For most directory and identity data, these distinctions do not matter. You are likely to run into them, however, if you try to turn your directory into a document store for arbitrary JSON resources.\n\nDespite some extra cost in terms of system resources, exposing directory data over HTTP can unlock directory services for a new generation of applications. The configuration provides flexible mapping, so that you can configure views that correspond to how client applications need to see directory data.\n\nDS software also give you a deployment choice for HTTP access. You can deploy the REST to LDAP gateway, which is a Servlet that connects to any standard LDAPv3 directory, or you can activate the HTTP connection handler on a server to allow direct and more efficient HTTP and HTTPS access.\n\nFor examples showing how to use RESTful access, see \"Performing RESTful Operations\" in the Developer's Guide.\n\n1.11. About Building Directory Services\n\nThis chapter is meant to serve as an introduction, and so does not even cover everything in this guide, let alone everything you might want to know about directory services.\n\nWhen you have understood enough of the concepts to build the directory services that you want to deploy, you must still build a prototype and test it before you roll out shared, centralized services for your organization. Read \"Tuning Servers For Performance\" for a look at how to meet the service levels that directory clients expect.\n\nChapter 4. Managing Directory Data\n\nThis chapter covers management of LDAP Data Interchange Format (LDIF) data. In this chapter you will learn to:\n\nGenerate test LDIF data\n\nImport and export LDIF data\n\nPerform searches and modifications on LDIF files with command-line tools\n\nCreate and manage database backends to house directory data imported from LDIF\n\nDelete database backends\n\nLDIF provides a mechanism for representing directory data in text format. LDIF data is typically used to initialize directory databases, but also may be used to move data between different directories that cannot replicate directly, or even as an alternative backup format.\n\n4.1. Generating Test Data\n\nWhen you install DS directory servers, you have the option of importing sample data that is generated during the installation. This procedure demonstrates how to generate LDIF by using the makeldif command, described in \"makeldif — generate test LDIF\" in the Reference.\n\nTo Generate Test LDIF Data\n\nThe makeldif command uses templates to provide sample data. Default templates are located in the /path/to/opendj/config/MakeLDIF/ directory. The example.template file can be used to create a suffix with entries of the type inetOrgPerson.\n\nWrite a file to act as the template for your generated LDIF.\n\nThe resulting test data template depends on what data you expect to encounter in production. Base your work on your knowledge of the production data, and on the sample template, /path/to/opendj/config/MakeLDIF/example.template, and associated data.\n\nSee \"makeldif.template — template file for the makeldif command\" in the Reference for reference information about template files.\n\nCreate additional data files for the content in your template to be selected randomly from a file, rather than generated by an expression.\n\nAdditional data files are located in the same directory as your template file.\n\nDecide whether you want to generate the same test data each time you run the makeldif command with your template.\n\nIf so, provide the same randomSeed integer each time you run the command.\n\nBefore generating a very large LDIF file, make sure you have enough space on disk.\n\nRun the makeldif command to generate your LDIF file.\n\nThe following command demonstrates use of the example MakeLDIF template:\n\n$ makeldif \\ --outputLDIF generated.ldif \\ --randomSeed 42 \\ /path/to/opendj/config/MakeLDIF/example.template ...LDIF processing complete....\n\n4.2. Importing and Exporting Data\n\nThe following procedures demonstrate how to use the import-ldif and export-ldif commands, described in \"import-ldif — import directory data from LDIF\" in the Reference and \"export-ldif — export directory data in LDIF\" in the Reference.\n\nTo Import LDIF Data\n\nThe most efficient method of importing LDIF data is to take the DS server offline. Alternatively, you can schedule a task to import the data while the server is online.\n\nNote\n\nImporting from LDIF overwrites all data in the target backend with entries from the LDIF data.\n\nThe following example imports dc=example,dc=com data into the dsEvaluation backend, overwriting existing data:\n\nIf you want to speed up the process—for example because you have millions of directory entries to import—first shut down the server, and then run the import-ldif command:\n\n$ stop-ds --quiet $ import-ldif \\ --offline \\ --backendID dsEvaluation \\ --includeBranch dc=example,dc=com \\ --ldifFile generated.ldif\n\nIf not, schedule a task to import the data while online:\n\n$ start-ds --quiet $ import-ldif \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backendID dsEvaluation \\ --includeBranch dc=example,dc=com \\ --ldifFile generated.ldif \\ --trustAll\n\nThe import task is scheduled through a secure connection to the administration port, by default 4444. You can schedule the import task to start at a particular time using the --start option.\n\nThe --trustAll option trusts all SSL certificates, such as a self-signed DS server certificate.\n\nIf the server is replicated with other servers, initialize replication again after the successful import.\n\nFor details see \"Initializing Replicas\".\n\nInitializing replication overwrites data in the remote servers in the same way that import overwrites existing data with LDIF data.\n\nIf the LDIF was exported from a server rather than generated using the makeldif command, it may contain pre-encoded passwords. By default, password policies do not allow you to use pre-encoded passwords, but you can change this behavior by changing the password policy's configuration property, allow-pre-encoded-passwords. Furthermore, the LDIF may include passwords encrypted using a reversible storage scheme, such as AES or Blowfish. As described in \"Configuring Password Storage\", in order to decrypt the passwords, the server must be a replica of the server that encrypted the passwords.\n\nTo Export LDIF Data\n\nThe following examples export dc=example,dc=com data from the dsEvaluation backend:\n\nTo expedite export, shut down the server and then use the export-ldif command:\n\n$ stop-ds --quiet $ export-ldif \\ --offline \\ --backendID dsEvaluation \\ --includeBranch dc=example,dc=com \\ --ldifFile backup.ldif\n\nTo export the data while online, leave the server running and schedule a task:\n\n$ export-ldif \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backendID dsEvaluation \\ --includeBranch dc=example,dc=com \\ --ldifFile backup.ldif \\ --start 0 \\ --trustAll\n\nThe --start 0 option tells the directory server to start the export task immediately.\n\nYou can specify a time for the task to start using the format yyyymmddHHMMSS. For example, 20250101043000 specifies a start time of 4:30 AM on January 1, 2025.\n\nIf the server is not running at the time specified, it attempts to perform the task after it restarts.\n\n4.4. About Database Backends\n\nDS directory server stores data in a backend. A backend is a private server repository that can be implemented in memory, as a file, or as an embedded database.\n\nDatabase backends are designed to hold large amounts of user data. DS servers have tools for backing up and restoring database backends, as described in \"Backing Up and Restoring Data\". By default, a directory server stores your data in a database backend named userRoot, unless you use a setup profile.\n\nWhen installing the server and importing user data, and when creating a database backend, you choose the backend type. DS directory servers use JE backends for local data.\n\nThe JE backend type is implemented using B-tree data structures. It stores data as key-value pairs, which is different from the relational model exposed to clients of relational databases.\n\nImportant\n\nDo not compress, tamper with, or otherwise alter backend database files directly unless specifically instructed to do so by a qualified ForgeRock technical support engineer. External changes to backend database files can render them unusable by the server. By default, backend database files are located under the /path/to/opendj/db directory.\n\nWhen backing up backend databases at the file system level rather than using the backup command, be aware that you may need to stop the server before running the backup procedure. A database backend performs internal cleanup operations that change the database log files even when there are no pending client or replication operations. An ongoing file system backup operation may therefore record database log files that are not in sync with each other. Such inconsistencies make it impossible for the backend database to recover after the database log files are restored. When the directory server is online during file system backup, successful recovery after restore can only be guaranteed if the backup operation took a fully atomic snapshot, capturing the state of all files at exactly the same time. If the recursive file system copy takes a true snapshot, you may perform the backup with the DS server online. Otherwise, if the file system copy is not a fully atomic snapshot, then you must stop the DS server before performing the backup operation.\n\nA JE backend stores data on disk using append-only log files with names like number.jdb. The JE backend writes updates to the highest-numbered log file. The log files grow until they reach a specified size (default: 1 GB). When the current log file reaches the specified size, the JE backend creates a new log file.\n\nTo avoid an endless increase in database size on disk, JE backends clean their log files in the background. A cleaner thread copies active records to new log files. Log files that no longer contain active records are deleted.\n\nBy default, JE backends let the operating system potentially cache data for a period of time before flushing the data to disk. This setting trades full durability with higher disk I/O for good performance with lower disk I/O. With this setting, it is possible to lose the most recent updates that were not yet written to disk in the event of an underlying OS or hardware failure. You can modify this behavior by changing the advanced configuration settings for the JE backend. If necessary, you can change the advanced setting for durability, db-durability, using the dsconfig set-backend-prop command.\n\nWhen a JE backend is opened, it recovers by recreating its B-tree structure from its log files. This is a normal process, one that allows the backend to recover after an orderly shutdown or after a crash.\n\nDue to the cleanup processes, JE backends can be actively writing to disk even when there are no pending client or replication operations. To back up a server using a file system snapshot, you must stop the server before taking the snapshot.\n\nIn addition to the cleanup process, JE backends run checksum verification periodically on the database logs. If the verification process detects backend database corruption, then the server logs an error message and the backend is taken offline. In this case, restore the corrupted backend from backup so that it can be used again. By default, the verification runs every night at midnight local time. If necessary, you can change this behavior by adjusting the advanced settings, db-run-log-verifier, and db-log-verifier-schedule, using the dsconfig set-backend-prop command.\n\n4.5. Creating a New Database Backend\n\nYou can create new backends using the dsconfig create-backend command, described in \"create-backend\" in the Configuration Reference. When you create a backend, choose the type of backend that fits your purpose.\n\nThe following example creates a database backend named exampleOrgBackend. The backend is of type je, which relies on a JE database for data storage and indexing:\n\n$ dsconfig \\ create-backend \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name exampleOrgBackend \\ --type je \\ --set enabled:true \\ --set base-dn:dc=example,dc=org \\ --trustAll \\ --no-prompt\n\nAfter creating the backend, you can view the settings as in the following example:\n\n$ dsconfig \\ get-backend-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name exampleOrgBackend \\ --trustAll \\ --no-prompt Property : Value(s) ------------------------:--------------------- backend-id : exampleOrgBackend base-dn : \"dc=example,dc=org\" cipher-key-length : 128 cipher-transformation : AES/CBC/PKCS5Padding compact-encoding : true confidentiality-enabled : false db-cache-percent : 50 db-cache-size : 0 b db-directory : db enabled : true writability-mode : enabled\n\nWhen you create a new backend using the dsconfig command, DS directory servers create the following indexes automatically:\n\naci presenceds-sync-conflict equalityds-sync-hist orderingentryUUID equalityobjectClass equality\n\nYou can create additional indexes as described in \"Configuring and Rebuilding Indexes\".\n\n4.6. Splitting Data Across Multiple Backends\n\nIn some cases, such as directory services with subtree replication, you might choose to split directory data across multiple backends.\n\nIn the example in this section, the exampleData backend holds all data under dc=example,dc=com except ou=People,dc=example,dc=com. A separate peopleData backend holds data under ou=People,dc=example,dc=com. Replication for these backends is configured separately as described in \"Subtree Replication\".\n\nThe following example assumes you perform the steps when initially setting up the directory data. It uses the sample data from \"Generating Test Data\":\n\n# Create a backend for the data not in the sub-suffix: $ dsconfig \\ create-backend \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name exampleData \\ --type je \\ --set enabled:true \\ --set base-dn:dc=example,dc=com \\ --trustAll \\ --no-prompt # Create a backend for the data in the sub-suffix: $ dsconfig \\ create-backend \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name peopleData \\ --type je \\ --set enabled:true \\ --set base-dn:ou=People,dc=example,dc=com \\ --trustAll \\ --no-prompt # Import data not in the sub-suffix: $ import-ldif \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backendID exampleData \\ --excludeBranch ou=People,dc=example,dc=com \\ --ldifFile generated.ldif \\ --trustAll # Import data in the sub-suffix: $ import-ldif \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backendID peopleData \\ --includeBranch ou=People,dc=example,dc=com \\ --ldifFile generated.ldif \\ --trustAll\n\nIf, unlike the example, you must split an existing backend, follow these steps:\n\nCreate the new backend.\n\nExport the data for the backend.\n\nImport the data for the sub-suffix into the new backend using the --includeBranch option.\n\nDelete all data under the sub-suffix from the old backend.\n\nFor an example, see \"Delete: Removing a Subtree\" in the Developer's Guide.\n\nWhen you split an existing backend, you must handle the service interruption that results when you move the sub-suffix data out of the original backend. If there is not a maintenance window where you can bring the service down in order to move the data, consider alternatives for replaying changes applied between the time that you exported the data and the time that you retired the old sub-suffix.\n\n4.7. Encrypting Directory Data\n\nDS directory servers can encrypt directory data before storing it in a database backend on disk, keeping the data confidential until it is accessed by a directory client.\n\nData encryption is useful for at least the following cases:\n\nEnsuring Confidentiality and Integrity\n\nEncrypted directory data is confidential, remaining private until decrypted with a proper key.\n\nEncryption ensures data integrity at the moment it is accessed. The DS directory service cannot decrypt corrupted data.\n\nProtection on a Shared Infrastructure\n\nWhen you deploy directory services on a shared infrastructure you relinquish full and sole control of directory data.\n\nFor example, if the DS directory server runs in the cloud, or in a data center with shared disks, the file system and disk management are not under your control.\n\nData confidentiality and encryption come with the following trade-offs:\n\nEquality Indexes Limited to Equality Matching\n\nWhen an equality index is configured without confidentiality, the values can be maintained in sorted order. A non-confidential, cleartext equality index can therefore be used for searches that require ordering and searches that match an initial substring.\n\nAn example of a search that requires ordering is a search with a filter \"(cn<=App)\". The filter matches entries with commonName up to those starting with App (case-insensitive) in alphabetical order.\n\nAn example of a search that matches an initial substring is a search with a filter \"(cn=A*)\". The filter matches entries having a commonName that starts with a (case-insensitive).\n\nIn an equality index with confidentiality enabled, the DS directory server no longer sorts cleartext values. As a result, you must accept that ordering and initial substring searches are unindexed.\n\nPerformance Impact\n\nEncryption and decryption requires more processing than handling cleartext values.\n\nEncrypted values also take up more space than cleartext values.\n\nAs explained in \"Protect DS Server Files\", DS directory servers do not encrypt directory data by default. This means that any user with system access to read directory files can potentially access directory data in cleartext.\n\nYou can verify what a system user could see with read access to backend database files by using the backendstat dump-raw-db command. The backendstat subcommands list-raw-dbs and dump-raw-db help you list and view the low-level databases within a backend. Unlike the output of other subcommands, the output of the dump-raw-db subcommand is neither decrypted nor formatted for readability. Instead, you can see values as they are stored in the backend file.\n\nIn a backend database, the id2entry index holds LDIF representations of directory entries. For a database that is not encrypted, the corresponding low-level database shows the cleartext strings, as is evident in the following example:\n\n$ stop-ds --quiet $ backendstat list-raw-dbs --backendId dsEvaluation ... /dc=com,dc=example/id2entry... ... $ backendstat \\ dump-raw-db \\ --backendId dsEvaluation \\ --dbName /dc=com,dc=example/id2entry ... Key (len 8): 00 00 00 00 00 00 00 1E ........ Value (len 437): 02 00 81 B1 03 01 06 27 75 69 64 3D 62 6A 65 6E .......'uid=bjen 73 65 6E 2C 6F 75 3D 50 65 6F 70 6C 65 2C 64 63 sen,ou=People,dc 3D 65 78 61 6D 70 6C 65 2C 64 63 3D 63 6F 6D 01 =example,dc=com. 06 11 01 08 01 13 62 6A 65 6E 73 65 6E 40 65 78 ......bjensen@ex 61 6D 70 6C 65 2E 63 6F 6D 01 09 01 04 30 32 30 ample.com....020 39 01 16 01 0C 65 6E 2C 20 6B 6F 3B 71 3D 30 2E 9....en, ko;q=0. 38 01 10 01 29 75 69 64 3D 74 72 69 67 64 65 6E 8...)uid=trigden 2C 20 6F 75 3D 50 65 6F 70 6C 65 2C 20 64 63 3D , ou=People, dc= 65 78 61 6D 70 6C 65 2C 64 63 3D 63 6F 6D 01 04 example,dc=com.. 02 13 50 72 6F 64 75 63 74 20 44 65 76 65 6C 6F ..Product Develo 70 6D 65 6E 74 06 50 65 6F 70 6C 65 01 0B 01 07 pment.People.... 42 61 72 62 61 72 61 01 0C 01 0F 2B 31 20 34 30 Barbara....+1 40 38 20 35 35 35 20 31 38 36 32 01 0D 01 06 4A 65 8 555 1862....Je 6E 73 65 6E 01 07 02 0E 42 61 72 62 61 72 61 20 nsen....Barbara 4A 65 6E 73 65 6E 0B 42 61 62 73 20 4A 65 6E 73 Jensen.Babs Jens 65 6E 01 0E 01 0D 2F 68 6F 6D 65 2F 62 6A 65 6E en..../home/bjen 73 65 6E 01 0F 01 0F 2B 31 20 34 30 38 20 35 35 sen....+1 408 55 35 20 31 39 39 32 01 11 01 04 31 30 30 30 01 12 5 1992....1000.. 01 2E 7B 53 53 48 41 7D 33 45 66 54 62 33 70 37 ..{SSHA}3EfTb3p7 71 75 6F 75 73 4B 35 34 2B 41 4F 34 71 44 57 6C quousK54+AO4qDWl 56 33 4F 39 54 58 48 57 49 4A 49 32 4E 41 3D 3D V3O9TXHWIJI2NA== 01 13 01 04 31 30 37 36 01 05 01 14 4F 72 69 67 ....1076....Orig 69 6E 61 6C 20 64 65 73 63 72 69 70 74 69 6F 6E inal description 01 14 01 07 62 6A 65 6E 73 65 6E 01 15 01 0D 53 ....bjensen....S 61 6E 20 46 72 61 6E 63 69 73 63 6F 01 01 02 01 an Francisco.... 24 38 38 37 37 33 32 65 38 2D 33 64 62 32 2D 33 $887732e8-3db2-3 31 62 62 2D 62 33 32 39 2D 32 30 63 64 36 66 63 1bb-b329-20cd6fc 65 63 63 30 35 ecc05 ...\n\nTo maintain data confidentiality on disk, you must configure it explicitly. In addition to preventing read access by other users as described in \"Setting Up a System Account for a Server\", you can configure confidentiality for database backends. When confidentiality is enabled for a backend, the directory server encrypts entries before storing them in the backend.\n\nImportant\n\nEncrypting stored directory data does not prevent it from being sent over the network in the clear.\n\nApply the suggestions in \"Securing Network Connections\" in the Security Guide to protect data sent over the network.\n\nEnable backend confidentiality with the default encryption settings as shown in the following example:\n\n$ dsconfig \\ set-backend-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name dsEvaluation \\ --set confidentiality-enabled:true \\ --no-prompt \\ --trustAll\n\nAfter confidentiality is enabled, entries are encrypted when next written. That is, the DS directory server does not automatically rewrite all entries in encrypted form. Instead, it encrypts each entry on update, for example, when a user updates their entry or when you import data.\n\nIf you import the data again after enabling confidentiality, you can see with the backendstat dump-raw-db command that the low-level database for id2index no longer contains cleartext:\n\n$ stop-ds --quiet $ [../resources/tests/admin-guide/import_export.bash:#export-backup-ldif] $ [../resources/tests/admin-guide/import_export.bash:#import-backup-ldif] $ backendstat \\ dump-raw-db \\ --backendId dsEvaluation \\ --dbName /dc=com,dc=example/id2entry ... Key (len 8): 00 00 00 00 00 00 00 C2 ........ Value (len 437): 02 02 81 82 01 C4 95 87 5B A5 2E 47 97 80 23 F4 ........[..G..#. CE 5D 93 25 97 D4 13 F9 0A A3 A8 31 9A D9 7A 70 .].%.......1..zp FE 3E AC 9D 64 41 EB 7B D5 7F 7E B8 B7 74 52 B8 .>..dA.{.^?~..tR. C7 7F C8 79 19 46 7D C5 5D 5B 83 9C 5B 9F 85 28 .^?.y.F}.][..[..( 83 A2 5F A0 C1 B1 09 FC 2F E3 D8 82 4A AA 8B D9 .._...../...J... 78 43 34 50 AE A1 52 88 5B 70 97 D2 E1 EA 87 CA xC4P..R.[p...... 3B 4D 07 DC F9 F8 30 BB D2 76 51 C8 75 FF FA 80 ;M....0..vQ.u... 77 E1 6A 8B 5B 8F DA A4 F4 0B B5 20 56 B3 19 19 w.j.[...... V... 22 D8 9D 38 04 E3 4D 94 A7 99 4B 81 16 AD 88 46 \"..8..M...K....F FC 3F 7E 78 66 B8 D1 E9 86 A0 F3 AC B6 68 0D A9 .?~xf........h.. 9A A7 3C 30 40 37 97 4E 90 DD 63 16 8E 11 0F 5E ..<0@7.N..c....^ 9D 5B 86 90 AF 4E E2 1F 9E 70 73 14 0A 11 5C DB .[...N...ps...\\. B7 BC B8 A9 31 3F 74 8D 0A 9F F4 6C E1 B0 36 78 ....1?t....l..6x F0 5A 5E CD 7C B3 A2 36 66 8E 88 86 A0 8B 9A 77 .Z^.|..6f......w D5 CD 7E 9C 4E 62 20 0E D0 DB AD E7 7E 99 46 4F ..~.Nb .....~.FO 67 C7 A6 7E 2C 24 82 50 51 9F A7 B2 02 44 5B 30 g..~,$.PQ....D[0 74 41 99 D9 83 69 EF AE 2E C0 FF C4 E6 4F F2 2F tA...i.......O./ 95 FB 93 65 30 2A 2D 8D 20 88 83 B5 DE 35 B6 20 ...e0*-. ....5. 47 17 30 25 60 FD E3 43 B9 D6 A4 F7 47 B6 6C 9F G.0%`..C....G.l. 47 FD 63 8E 7F A5 00 CE 6C 3E BC 95 23 69 ED D0 G.c.^?...l>..#i.. 69 4F BE 61 BD 30 C2 40 66 F6 F9 C3 3E C1 D7 8C iO.a.0.@f...>... B0 C8 4A 2E 27 BE 13 6C 40 88 B0 13 A3 12 F4 50 ..J.'..l@......P CA 92 D8 EB 4A E5 3F E2 64 A3 76 C7 5C 2B D8 89 ....J.?.d.v.\\+.. A3 6E C1 F7 0A C2 37 7A BD AF 14 4B 52 04 6B F2 .n....7z...KR.k. 8F 4F C3 F8 00 90 BA 0F EC 6D B1 2D A8 18 0C A6 .O.......m.-.... 29 96 82 3B 5C BC D0 F4 2B BE 9C C5 8B 18 7A DE )..;\\...+.....z. C7 B5 10 2D 45 50 4F 77 ED F7 23 34 95 AF C3 2E ...-EPOw..#4.... B0 9B FA E9 DF ..... ...\n\nSimilar checks can be run on other low-level databases if you enable confidentiality by backend indexes as described below.\n\nThe settings for data confidentiality depend on the encryption capabilities of the JVM. For example, for details about the Sun/Oracle Java implementation, see the explanations in javax.crypto.Cipher. You can accept the default settings, or choose to specify the following:\n\nThe cipher algorithm defining how the cleartext is encrypted and decrypted.\n\nThe cipher mode of operation defining how a block cipher algorithm should transform data larger than a single block.\n\nThe cipher padding defining how to pad the cleartext to reach appropriate size for the algorithm.\n\nThe cipher key length, where longer key lengths strengthen encryption at the cost of more performance impact.\n\nThe default settings for confidentiality are cipher-transformation: AES/CBC/PKCS5Padding and cipher-key-length: 128. This means the algorithm is the Advanced Encryption Standard (AES), the cipher mode is Cipher Block Chaining (CBC), and the padding is PKCS#5 padding as described in RFC 2898: PKCS #5: Password-Based Cryptography Specification. The syntax for the cipher-transformation is algorithm/mode/padding, and all three must be specified. When the algorithm does not require a mode, use NONE. When the algorithm does not require padding, use NoPadding. Use of larger cipher-key-length values can require that you install JCE policy files such as those for unlimited strength, as described in \"Using Unlimited Strength Cryptography\" in the Security Guide.\n\nDS servers encrypt data using a symmetric key that is stored with the server configuration. The symmetric key is encrypted in turn with the server's public key that is also stored with the server configuration. When multiple servers are configured to replicate data as described in \"Configuring Replication Settings\", the servers replicate the keys as well, allowing any server replica to decrypt the data.\n\nIn addition to entry encryption, you can enable confidentiality by backend index, as long as confidentiality is enabled for the backend itself. Confidentiality hashes keys for equality type indexes using SHA-1, and encrypts the list of entries matching a substring key for substring indexes. The following example shows how to enable confidentiality for the mail index:\n\n$ dsconfig \\ set-backend-index-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name dsEvaluation \\ --index-name mail \\ --set confidentiality-enabled:true \\ --no-prompt \\ --trustAll\n\nAfter changing the index configuration, you can rebuild the index to enforce confidentiality immediately. For details, see \"Configuring and Rebuilding Indexes\".\n\nAvoid using sensitive attributes in VLV indexes. Confidentiality cannot be enabled for VLV indexes.\n\nWhen reading files for an encrypted backend database, be aware that although user data is kept confidential, the following are not encrypted on disk:\n\nAs described above, the server encrypts backend database content the next time it is written.\n\nIf you configure data confidentiality after initial import, and you must make sure that all relevant data are encrypted, export the data to LDIF and then import the data again. For details, see \"Managing Directory Data\".\n\nWith the exception of the items identified below, backend database file content is encrypted. Yet, the files themselves are not encrypted.\n\nThe dn2id index and its keys are not encrypted.\n\nSubstring index keys are not encrypted.\n\nAs described above, the values are encrypted, however.\n\nEncrypting and decrypting data comes with costs in terms of cryptographic processing that reduces throughput and of extra space for larger encrypted values. In general, tests with default settings show that the cost of enabling confidentiality can be quite modest, but your results can vary based on your systems and on the settings used for cipher-transformation and cipher-key-length. Make sure you test your deployment to qualify the impact of confidentiality before enabling it in production.\n\n4.8. Setting Disk Space Thresholds For Database Backends\n\nDirectory data growth depends on applications that use the directory. As a result, when directory applications add more data than they delete, the database backend grows until it fills the available disk space. The system can end up in an unrecoverable state if no disk space is available.\n\nDatabase backends therefore have advanced properties, disk-low-threshold and disk-full-threshold. When available disk space falls below disk-low-threshold, the directory server only allows updates from users and applications that have the bypass-lockdown privilege, as described in \"About Privileges\". When available space falls below disk-full-threshold, the directory server stops allowing updates, instead returning an UNWILLING_TO_PERFORM error to each update request.\n\nA directory server continues to apply replication updates without regard to the thresholds. The server can therefore fill available disk space despite the thresholds, by accepting replication updates made on other servers. You can give yourself more time to react to the situation both by monitoring directory data growth and also by increasing the thresholds.\n\nIf growth across the directory service tends to happen quickly, set the thresholds higher than the defaults to allow more time to react when growth threatens to fill the disk. The following example sets disk-low-threshold to 10 GB disk-full-threshold to 5 GB for the dsEvaluation backend:\n\n$ dsconfig \\ set-backend-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name dsEvaluation \\ --set \"disk-low-threshold:10 GB\" \\ --set \"disk-full-threshold:5 GB\" \\ --trustAll \\ --no-prompt\n\nThe properties disk-low-threshold and disk-full-threshold are listed as advanced properties. To examine their values with the dsconfig command, use the --advanced option as shown in the following example:\n\n$ dsconfig \\ get-backend-prop \\ --advanced \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --backend-name dsEvaluation \\ --property disk-low-threshold \\ --property disk-full-threshold \\ --trustAll \\ --no-prompt Property : Value(s) --------------------:--------- disk-full-threshold : 5 gb disk-low-threshold : 10 gb\n\n4.9. Automating Entry Expiration and Deletion\n\nIf the directory service creates many entries that expire and should be deleted, it is possible to delete the entries by finding them with a time-based search and then deleting them individually. That approach uses replication to delete the entries in all replicas, and works with older versions of the directory service. It has the disadvantage of generating potentially large amounts of replication traffic. With upgraded replicas, you can instead configure the backend database to delete the entries as they expire. This new approach deletes expired entries at the backend database level, without generating replication traffic.\n\nBackend indexes for generalized time (timestamp) attributes have these properties to configure automated, optimized entry expiration and removal:\n\nConfigure this capability by performing the following steps:\n\nPrepare an ordering index for a generalized time (timestamp) attribute on entries that expire.\n\nFor details, see \"Configuring and Rebuilding Indexes\" and \"Search: Listing Active Accounts\" in the Developer's Guide.\n\nUsing the dsconfig set-backend-index-prop command, set ttl-enabled on the index to true, and set ttl-age on the index to the desired entry lifetime duration.\n\nOnce you configure and build the index, the backend can delete expired entries. At intervals of 10 seconds, the backend automatically deletes entries whose timestamps on the attribute are older than the specified lifetime. Entries that expire in the interval between deletions are removed on the next round. Client applications should therefore check that entries have not expired, as it is possible for expired entries to remain available until the next round of deletions.\n\nWhen using this capability, keep the following points in mind:\n\nEntry expiration is per index. The time to live depends on the value of the indexed attribute and the ttl-age setting, and all matching entries are subject to TTL.\n\nIf multiple indexes' ttl-enabled and ttl-age properties are configured, as soon as one of the entry's matching attributes exceeds the TTL, the entry is eligible for deletion.\n\nThe backend deletes the entries directly. Deletion is not visible at the protocol level, and so is not recorded in logs nor returned in persistent searches.\n\nFurthermore, this means that deletion is not replicated. To ensure expired entries are deleted on all replicas, use the same indexes with the same settings on all replicas.\n\nWhen a backend deletes an expired entry, the effect is a subtree delete. In other words, if a parent entry expires, the parent entry and all the parent's child entries are deleted.\n\nIf you do not want parent entries to expire, index a generalized time attribute that is only present on its child entries.\n\nThe backend deletes expired entries atomically.\n\nIf you update the TTL attribute to prevent deletion and the update succeeds, then TTL has effectively been reset.\n\nExpiration fails when the index-entry-limit is exceeded. (For background information, see \"Understanding Index Entry Limits\".)\n\nThis only happens if the timestamp for the indexed attribute matches to the nearest millisecond on more than 4000 entries (for default settings). This corresponds to four million timestamp updates per second, which would be very difficult to reproduce in a real directory service.\n\nIt is possible, however, to construct and import an LDIF file where more than 4000 entries have the same timestamp. Make sure not to reuse the same timestamp for thousands of entries when artificially creating entries that you intend to expire.\n\n4.11. Deleting a Database Backend\n\nYou delete a database backend by using the dsconfig delete-backend command, described in \"delete-backend\" in the Configuration Reference.\n\nWhen you delete a database backend by using the dsconfig delete-backend command, the directory server does not actually remove the database files for two reasons:\n\nA mistake could potentially cause lots of data to be lost.\n\nDeleting a large database backend could cause severe service degradation due to a sudden increase in I/O load.\n\nInstead, after you run the dsconfig delete-backend command you must also manually remove the database backend files.\n\nIf you do run the dsconfig delete-backend command by mistake and have not yet deleted the actual files, then you can recover from the mistake by creating the backend again, reconfiguring the indexes that were removed, and rebuilding the indexes as described in \"Configuring and Rebuilding Indexes\".\n\nChapter 5. Configuring Connection Handlers\n\nThis chapter shows you how to configure servers to listen for directory client requests using connection handlers. You can update the configuration using the dsconfig command, described in \"dsconfig — manage OpenDJ server configuration\" in the Reference.\n\nIn this chapter you will learn to:\n\nEnable client applications to access the directory over LDAP and secure LDAP (LDAPS)\n\nEnable client applications to access the directory over HTTP whether using DSML, or the REST style\n\nEnable monitoring using Java Management Extensions (JMX), or over Simple Network Management Protocol (SNMP)\n\nEnable automated processing of LDIF files\n\nConfigure restrictions for client access such as requiring authentication or limiting the maximum number of concurrent connections\n\nConfigure transport layer security for all relevant protocols\n\n5.1. LDAP Client Access\n\nYou configure LDAP client access using the dsconfig command.\n\nThe reserved port number for LDAP is 389. Most examples in the documentation use 1389, which is accessible to non-privileged users.\n\nTo Change the LDAP Port Number\n\nChange the port number using the dsconfig command.\n\nThe following example changes the LDAP port number to 11389:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAP \\ --set listen-port:11389 \\ --trustAll \\ --no-prompt\n\nRestart the connection handler so the change takes effect.\n\nTo restart the connection handler, you disable it, then enable it again:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAP \\ --set enabled:false \\ --trustAll \\ --no-prompt $ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAP \\ --set enabled:true \\ --trustAll \\ --no-prompt\n\n5.2. Preparing For Secure Communications\n\nThis section shows how to prepare the server to use a file-based keystore to manage the keys essential to secure communications. For more information about the keys, see \"About Certificates, Private Keys, and Secret Keys\" in the Security Guide.\n\nFor instructions on importing trusted certificates on PKCS#11 devices, see the documentation for the device.\n\n5.2.1. Importing Certificates\n\nA client that sets up a secure connection with a server must be able to trust the server certificate. A server that uses mutual authentication (checking the client certificate) must be able to trust the client certificate. In either case, this involves finding the signing certificate in a keystore or a truststore.\n\nIn some cases, DS servers act as clients of external services. For example, REST to LDAP can resolve OAuth 2.0 tokens by sending secure requests to an authorization server. The server can also connect to another LDAP server when using pass-through authentication.\n\nThe default Java truststore contains signing certificates from well-known CAs. If the CA certificate is not in the default truststore, or the certificate is self-signed, then you can import it into a truststore as described here.\n\nTo Import a Trusted Client Certificate\n\nThe following steps demonstrate using the keytool command to add a client application's binary format, self-signed certificate to a new truststore for the DS server. This procedure enables the DS server to recognize a self-signed client application certificate when negotiating a secure connection. To allow a client application to perform an LDAP bind using its certificate, see \"Authenticating Client Applications With a Certificate\" in the Developer's Guide instead.\n\nImport the self-signed client certificate:\n\n$ keytool \\ -import \\ -trustcacerts \\ -alias myapp-cert \\ -file myapp-cert.pem \\ -keystore /path/to/opendj/config/truststore \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -storetype PKCS12 \\ -noprompt Certificate was added to keystore\n\nIn this example, the new truststore uses the same PIN as the default keystore.\n\nAdd a trust manager provider to access the truststore:\n\n$ dsconfig \\ create-trust-manager-provider \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --type file-based \\ --provider-name \"PKCS12 Trust Manager\" \\ --set enabled:true \\ --set trust-store-file:/path/to/opendj/config/truststore \\ --set trust-store-pin:\"&{file:/path/to/opendj/config/keystore.pin}\" \\ --trustAll \\ --no-prompt\n\nConfigure connection handlers to set the trust manager provider as shown, for example in \"LDAP Client Access With Transport Layer Security\" and in \"To Set Up HTTPS Access\".\n\nTo Import the Server Certificate\n\nIf your client uses a Java truststore, import the DS server signing certificate using the keytool command.\n\nExport the server certificate from the server keystore.\n\nThe following example shows the keytool command to export the self-signed server certificate in binary format. Notice that the keystore PIN is stored in a file, which is the default setting:\n\n$ keytool \\ -export \\ -rfc \\ -alias server-cert \\ -file server-cert.pem \\ -keystore /path/to/opendj/config/keystore \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -storetype PKCS12 Certificate stored in file <server-cert.pem>\n\nImport the server certificate into the client truststore:\n\n$ keytool \\ -import \\ -trustcacerts \\ -alias server-cert \\ -file server-cert.pem \\ -keystore my-keystore \\ -storetype PKCS12 \\ -storepass changeit \\ -noprompt Certificate was added to keystore\n\nTo Import a Trusted CA Certificate\n\nIf you use self-signed certificates, or if your CA is not well-known, you can nevertheless import the certificate as a CA certificate into a Java file-based truststore using the keytool command. The application that relies on the truststore can then trust the certificate in the same way it trusts well-known CA certificates.\n\nFollow these steps to import the CA certificate into a truststore for the server:\n\nImport the certificate as a CA certificate:\n\n$ keytool \\ -import \\ -trustcacerts \\ -alias ca-cert \\ -file ca.crt \\ -keystore /path/to/opendj/config/truststore \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -storetype PKCS12 \\ -noprompt Certificate was added to keystore\n\nMake sure the server can use the truststore in one of the following ways:\n\nIf no trust manager provider is configured to access the truststore, add one as shown in \"To Import a Trusted Client Certificate\".\n\nIf a trust manager provider is already configured to access the truststore, restart the server to force it to reload the truststore:\n\n$ stop-ds --restart --quiet\n\nIf necessary, you can avoid restarting the server by disabling the trust manager provider and then enabling it again.\n\nConfigure connection handlers to set the trust manager provider as shown, for example in \"LDAP Client Access With Transport Layer Security\" and in \"To Set Up HTTPS Access\".\n\n5.2.2. Setting Up Server Certificates\n\nWhen you install the DS server, you can choose to configure secure connections and either generate a key pair with a self-signed certificate, or import your own keystore. The default PKCS#12 keystore is /path/to/opendj/config/keystore, and the self-signed public key certificate has the alias server-cert. The password for the keystore and the private key is stored in cleartext in the file /path/to/opendj/config/keystore.pin.\n\nIf you chose to set up a secure connection as part of the installation process, you can skip this section.\n\nTo Set Up a CA-Signed Certificate\n\nThis procedure shows how to prepare a new key pair with a CA-signed certificate for use in setting up secure connections.\n\nThe high-level steps to perform are the following:\n\nGenerate a server private key and public key certificate in your keystore.\n\nIssue a signing request to the CA, who responds with a CA-signed certificate.\n\nImport the CA-signed certificate where appropriate.\n\nSet up a key manager provider to use the keystore.\n\nA detailed example follows:\n\nPrepare the password for the keystore.\n\nBy default, DS servers are configured to hold the password in a file, /path/to/opendj/config/keystore.pin:\n\n$ touch /path/to/opendj/config/keystore.pin $ chmod 600 /path/to/opendj/config/keystore.pin # Add keystore and private key password in cleartext on a single line: $ vi /path/to/opendj/config/keystore.pin\n\nGenerate the server key pair (private key and public key certificate) using the Java keytool command.\n\nOne step in verifying the certificate's validity is checking that the subject's FQDN matches the FQDN obtained from DNS.\n\nThe FQDN for the DS server, visible in the status command output, is set both as a DNSName in the certificate's SubjectAlternativeName list, and also in the CN of the certificate's subject name DN for backwards compatibility:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nNote\n\nNotice that the -storepass and -keypass options take identical password arguments. DS servers use the same password to protect the keystore and the private key.\n\nIf the server can respond on multiple FQDNs, then specify multiple subject alternative names when using the keytool command's -ext option. In the following example the primary FQDN is opendj.example.com and the alternative is ldap.example.com:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com,dns:ldap.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nFor an example showing how to use a wildcard certificate, see \"To Set Up a Key Pair With a Wildcard Certificate\".\n\nCreate a certificate signing request file for the generated certificate:\n\n$ keytool \\ -certreq \\ -alias server-cert \\ -file server-cert.csr \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin\n\nHave the CA sign the request (server-cert.csr).\n\nSee the instructions from your CA on how to provide the request.\n\nThe CA returns the signed certificate.\n\n(Optional) If you have set up your own CA and signed the certificate, or are using a CA whose signing certificate is not included in the Java runtime environment, import the CA certificate into the keystore so that it can be trusted.\n\nOtherwise, when you import the signed certificate from an (unknown) CA, the keytool command fails to import the signed certificate with the message keytool error: java.lang.Exception: Failed to establish chain from reply.\n\nFor an example command, see \"To Import a Trusted CA Certificate\".\n\nImport the signed certificate from the CA reply into the keystore where you generated the server certificate.\n\nIn this example the certificate from the reply is server-cert.crt:\n\n$ keytool \\ -import \\ -alias server-cert \\ -file server-cert.crt \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin \\ -noprompt\n\nConfigure the file-based key manager provider for the keystore that you set up with the keytool command:\n\n$ dsconfig \\ set-key-manager-provider-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --provider-name \"Default Key Manager\" \\ --set enabled:true \\ --trustAll \\ --no-prompt\n\nIf you stored the keystore password somewhere besides the file, /path/to/opendj/config/keystore.pin, shown in the examples in this procedure, also adjust the key-store-* settings accordingly.\n\nAt this point, the DS server can use the CA-signed certificate.\n\nIf you use a CA certificate that is not known to clients, such as a CA that you set up yourself rather than a well-known CA, import the CA certificate into the client application truststore. For an example command, see \"To Import a Trusted CA Certificate\".\n\nOtherwise the client application cannot trust the signature on the server certificate.\n\nTo Set Up a Self-Signed Certificate\n\nThis procedure shows how to prepare a new key pair with a self-signed certificate for use in setting up secure connections.\n\nThe high-level steps to perform are the following:\n\nGenerate a server private key and public key certificate in your keystore.\n\nSelf-sign the certificate.\n\nSet up a key manager provider to use the keystore.\n\nTo replace the existing server key pair with a self-signed certificate and new private key, first, use keytool -delete -alias server-cert to delete the existing keys, then generate a new key pair with the same alias. Either reuse the existing password in keystore.pin, or use a new password as shown in the steps below.\n\nPrepare the password for the keystore.\n\nBy default, DS servers are configured to hold the password in a file, /path/to/opendj/config/keystore.pin:\n\n$ touch /path/to/opendj/config/keystore.pin $ chmod 600 /path/to/opendj/config/keystore.pin # Add keystore and private key password in cleartext on a single line: $ vi /path/to/opendj/config/keystore.pin\n\nGenerate the key pair using the Java keytool command:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nIn this example, the DS server runs on a system with FQDN opendj.example.com. The keystore is created in the server config directory.\n\nNote\n\nNotice that the -storepass and -keypass options take identical password arguments. DS servers use the same password to protect the keystore and the private key.\n\nIf the server can respond on multiple FQDNs, then specify multiple subject alternative names when using the keytool command's -ext option. In the following example the primary FQDN is opendj.example.com and the alternative is ldap.example.com:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com,dns:ldap.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nFor an example showing how to use a wildcard certificate, see \"To Set Up a Key Pair With a Wildcard Certificate\".\n\nSelf-sign the server certificate:\n\n$ keytool \\ -selfcert \\ -alias server-cert \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin\n\nConfigure the file-based key manager provider to access the keystore with keystore/private key password.\n\nIn this example, the alias is server-cert and the password is in the file, /path/to/opendj/config/keystore.pin.\n\nIf you are replacing a key pair with a self-signed certificate, reusing the server-cert alias and password stored in keystore.pin, then you can skip this step:\n\n$ dsconfig \\ set-key-manager-provider-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --provider-name \"Default Key Manager\" \\ --set enabled:true \\ --trustAll \\ --no-prompt\n\nIf you stored the keystore password somewhere besides the file, /path/to/opendj/config/keystore.pin, shown in the examples in this procedure, also adjust the key-store-* settings accordingly.\n\nAt this point, the DS server can use the self-signed certificate, for example, for StartTLS and LDAPS or HTTPS connection handlers.\n\nTo Use an Alternative Keystore Implementation\n\nTo use an alternative keystore implementation, start with a different keystore type when generating the keypair:\n\nUse one of the keystore types supported by the Java runtime environment:\n\nJava Keystore\n\nThe basic Java keystore type is JKS:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore.jks \\ -storetype JKS \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nThis is the keystore type if you do not specify a -storetype option.\n\nJava Cryptography Extension Keystore\n\nThe JCEKS type lets you take advantage of additional Java cryptography extensions and stronger protection for private keys:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore.jceks \\ -storetype JCEKS \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nLDAP Keystore\n\nDS servers implement an OpenDJ security provider for LDAP and LDIF-based keystore services. Its keystore type is LDAP.\n\nFor details, see \"Using an LDAP Keystore\" in the Security Guide.\n\nPKCS#11 device\n\nA PKCS#11 device, such as an HSM, can be used as a keystore.\n\nFor details, see \"Using a Hardware Security Module\" in the Security Guide.\n\nPKCS#12 Keystore\n\nThe PKCS12 type lets you use a PKCS#12 format file. This is the default for DS servers. It is a standard format and is interoperable with other systems that do not necessarily depend on a Java runtime environment:\n\n$ keytool \\ -genkeypair \\ -alias server-cert \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nAfter using an alternate keystore type, make sure that you set up:\n\nThe key manager provider to open the correct keystore with the correct credentials.\n\nAny components using that key manager provider to use the correct certificate alias.\n\n5.2.3. Working With Test Key Pairs\n\nThis section includes procedures for working with test key pairs. The procedures use the openssl command to perform actions that are not necessarily possible with the Java keytool command. OpenSSL software is available from https://www.openssl.org/.\n\nImportant\n\nOpenSSL software is independent from and not associated with the DS project. The examples shown in this section might not work with your version of OpenSSL. See the openssl documentation for your version.\n\nExamples in this section were originally written with OpenSSL version 1.0.2.\n\nTo Set Up a CA Signing Certificate\n\nFollow these steps to set up a CA key pair with a signing certificate:\n\nGenerate a private key for the CA:\n\n$ openssl \\ genpkey \\ -algorithm RSA \\ -out ca.key \\ -pkeyopt rsa_keygen_bits:4096\n\nSelf-sign a corresponding certificate:\n\n$ openssl \\ req \\ -new \\ -x509 \\ -days 7300 \\ -subj \"/C=FR/O=Example Corp/CN=example.com\" \\ -key ca.key \\ -out ca.crt\n\nThe signing certificate is ca.crt, and it corresponds to the private key ca.key.\n\nTo Sign a Certificate Signing Request\n\nFollow these steps to use a CA signing certificate to sign a certificate signing request (CSR):\n\nIf you have not already done so, set up a CA key pair as described in \"To Set Up a CA Signing Certificate\".\n\nObtain a CSR file for the certificate to sign.\n\nCreate a signed certificate from the CSR.\n\nThe following example preserves the SAN for a server certificate generated using the keytool command and the -ext \"san=dns:opendj.example.com\" option:\n\n$ openssl \\ x509 \\ -req \\ -in server-cert.csr \\ -CA ca.crt \\ -CAkey ca.key \\ -CAcreateserial \\ -extfile \\ <(cat /etc/ssl/openssl.cnf \\ <(printf \"[SAN]\\nsubjectAltName=DNS:opendj.example.com\")) \\ -extensions SAN \\ -out server-cert.crt\n\nThe following example preserves the SAN for a wildcard certificate as described in \"To Set Up a Key Pair With a Wildcard Certificate\":\n\n$ openssl \\ x509 \\ -req \\ -in example.com.csr \\ -CA ca.crt \\ -CAkey ca.key \\ -CAcreateserial \\ -extfile \\ <(cat /etc/ssl/openssl.cnf \\ <(printf \"[SAN]\\nsubjectAltName=DNS:*.example.com\")) \\ -extensions SAN \\ -out example.com.crt\n\nIn both examples, the certificates to return to the requestors are the .crt files.\n\nTo Set Up a Key Pair With a Wildcard Certificate\n\nA wildcard certificate uses a * to replace the top-level subdomain in the subject FQDN, and can list domains in the subject alternative domain list.\n\nThe FQDN for a server, visible in the status command output, must also match a DNSName value or pattern in the certificate's SubjectAlternativeName list.\n\nFollow these steps to set up a key pair with a wildcard certificate:\n\nGenerate a private key:\n\n$ openssl \\ genpkey \\ -algorithm RSA \\ -pkeyopt rsa_keygen_bits:2048 \\ -out example.com.key\n\nGenerate a certificate signing request for the CA:\n\n$ openssl \\ req \\ -new \\ -sha256 \\ -key example.com.key \\ -subj \"/C=FR/O=Example Corp/CN=*.example.com\" \\ -reqexts SAN \\ -config \\ <(cat /etc/ssl/openssl.cnf \\ <(printf \"[SAN]\\nsubjectAltName=DNS:*.example.com\")) \\ -out example.com.csr\n\nGet the CA to sign the request and return the certificate.\n\nFor an example of how to do this yourself, see \"To Sign a Certificate Signing Request\".\n\n(Optional) Convert the results into a PKCS#12 format Java keystore file.\n\n$ openssl \\ pkcs12 \\ -export \\ -in example.com.crt \\ -inkey example.com.key \\ -name server-cert \\ -CAfile ca.crt \\ -password file:/path/to/opendj/config/keystore.pin \\ -out /path/to/opendj/config/keystore\n\nThis keystore can be used for testing the wildcard certificate with the DS server as in the following example:\n\n$ ldapsearch \\ --port 1636 \\ --hostname opendj.example.com \\ --baseDN dc=example,dc=com \\ --useSSL \\ \"(uid=bjensen)\" \\ cn The server is using the following certificate: Subject DN: CN=*.example.com, O=Example Corp, C=FR Issuer DN: CN=example.com, O=Example Corp, C=FR Validity: <validity-dates> Do you wish to trust this certificate and continue connecting to the server? Please enter \"yes\" or \"no\":yes dn: uid=bjensen,ou=People,dc=example,dc=com cn: Barbara Jensen cn: Babs Jensen\n\n5.3. LDAP Client Access With Transport Layer Security\n\nStartTLS negotiations start on the unsecure LDAP port, and then protect communication with the client. You can configure StartTLS when setting up a server, or later using the dsconfig command.\n\nTo Enable StartTLS on the LDAP Port\n\nMake sure you have a server certificate installed:\n\n$ keytool \\ -list \\ -alias server-cert \\ -keystore /path/to/opendj/config/keystore \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -storetype PKCS12 ... server-cert, <date>, PrivateKeyEntry ...\n\nActivate StartTLS on the current LDAP port:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAP \\ --set allow-start-tls:true \\ --set key-manager-provider:\"Default Key Manager\" \\ --set trust-manager-provider:\"JVM Trust Manager\" \\ --trustAll \\ --no-prompt\n\nThe change takes effect. No need to restart the server.\n\n5.4. LDAP Client Access Over SSL\n\nAn LDAP connection handler configured to use LDAPS (LDAP/SSL) allows only secure connections from client applications. You can configure LDAPS when setting up a server, or later using the dsconfig command.\n\nThe reserved port number for LDAPS is 636. Most examples in the documentation use 1636, which is accessible to non-privileged users.\n\nTo Set Up LDAPS Access\n\nIf LDAPS access was not configured at during setup, follow these steps:\n\nMake sure a server certificate and associated private key are available:\n\n$ keytool \\ -list \\ -alias server-cert \\ -keystore /path/to/opendj/config/keystore \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -storetype PKCS12 server-cert, <date>, PrivateKeyEntry\n\nConfigure the server to activate LDAPS access:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAPS \\ --set enabled:true \\ --set listen-port:1636 \\ --set use-ssl:true \\ --trustAll \\ --no-prompt\n\n(Optional) If the deployment requires SSL client authentication, set the properties ssl-client-auth-policy and trust-manager-provider appropriately.\n\nTo Change the LDAPS Port Number\n\nChange the port number using the dsconfig command.\n\nThe following example changes the LDAPS port number to 11636:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAPS \\ --set listen-port:11636 \\ --trustAll \\ --no-prompt\n\nRestart the connection handler so the change takes effect.\n\nTo restart the connection handler, you disable it, then enable it again:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAPS \\ --set enabled:false \\ --trustAll \\ --no-prompt $ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAPS \\ --set enabled:true \\ --trustAll \\ --no-prompt\n\n5.5. Restricting Client Access\n\nUsing a server's global configuration properties, you can add global restrictions on how clients access the server. These settings are per server, and so must be set independently on each server.\n\nThese global settings are fairly coarse-grained. For a full discussion of the rich set of administrative privileges and fine-grained access control instructions that DS servers support, see \"Configuring Privileges and Access Control\".\n\nConsider the following global configuration settings:\n\nbind-with-dn-requires-password\n\nWhether the server should reject any simple bind request that contains a DN but no password. Default: true\n\nTo change this setting use the following command:\n\n$ dsconfig \\ set-global-configuration-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --set bind-with-dn-requires-password:false \\ --no-prompt \\ --trustAll\n\nmax-allowed-client-connections\n\nRestricts the number of concurrent client connections to this server. Default: 0, meaning no limit is set.\n\nTo set a limit of 64K use the following command:\n\n$ dsconfig \\ set-global-configuration-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --set max-allowed-client-connections:65536 \\ --no-prompt \\ --trustAll\n\nallowed-client, denied-client\n\nRestrict which clients can connect to the server.\n\nrestricted-client, restricted-client-connection-limit\n\nRestrict the number of concurrent connections per client.\n\nunauthenticated-requests-policy\n\nThis setting can take the following values:\n\nreject\n\nReject requests (other than bind or StartTLS requests) received from a client that has not yet been authenticated, whose last authentication attempt was unsuccessful, or whose last authentication attempt used anonymous authentication.\n\nallow-discovery\n\nLike reject, but allows unauthenticated base object searches of the root DSE.\n\nThis setting supports applications that read the root DSE to discover server capabilities, and applications that target the root DSE for keep-alive heartbeats.\n\nallow\n\nAllow all unauthenticated requests, subject to privileges and access control.\n\nTo prevent anonymous binds except to read the root DSE, use the following command:\n\n$ dsconfig \\ set-global-configuration-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --set unauthenticated-requests-policy:allow-discovery \\ --no-prompt \\ --trustAll\n\nreturn-bind-error-messages\n\nDoes not restrict access, but by default prevents a server from returning extra information about why a bind failed, as that information could be used by an attacker. Instead, the information is written to the server errors log. Default: false.\n\nTo have the server return additional information about why a bind failed use the following command:\n\n$ dsconfig \\ set-global-configuration-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --set return-bind-error-messages:true \\ --no-prompt \\ --trustAll\n\n5.6. TLS Protocols and Cipher Suites\n\nWhen a server and client negotiate a secure connection, they negotiate use of a common protocol and cipher suite. If they cannot negotiate a common protocol and cipher suite, they will fail to set up a secure connection.\n\nFurthermore, researchers continue to find vulnerabilities in protocols and cipher suites. If the server continues to support those protocols and cipher suites, then clients can use them when negotiating connections. Attackers can then exploit the vulnerabilities. It is therefore important to understand how to read and to restrict the list of supported protocols and cipher suites.\n\nDS servers depend on the underlying JVM to support security protocols and cipher suites. By default, all supported protocols and cipher suites are available. For details, see the documentation for the JVM. For Oracle Java, see the Java Cryptography Architecture Oracle Providers Documentation describing the The SunJSSE Provider.\n\nBear in mind that support for protocols and cipher suites can be added and removed in Java update releases. The protocols and cipher suites available are also determined by the security policy. For example, see \"Using Unlimited Strength Cryptography\" in the Security Guide.\n\nTo List Protocols and Cipher Suites\n\nTo list the protocols and cipher suites that DS servers support, read the supportedTLSProtocols and supportedTLSCiphers attributes of the root DSE:\n\n$ ldapsearch \\ --port 1389 \\ --baseDN \"\" \\ --searchScope base \\ \"(objectclass=*)\" \\ supportedTLSCiphers supportedTLSProtocols\n\nA supportedTLSCiphers name, such as TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384, identifies the key attributes of the cipher suite:\n\nTLS\n\nSpecifies the protocol, in this case TLS.\n\nECDHE_RSA\n\nSpecifies the key exchange algorithm used to determine how the client and server authenticate during the handshake phase.\n\nIn this example, an elliptic curve variant of the Diffie-Hellman key exchange is used, where a random value chosen by the client is encrypted with the server's RSA public key.\n\nWITH_AES_256_GCM\n\nSpecifies the bulk encryption algorithm, including the key size or initialization vectors.\n\nThis example specifies the Advanced Encryption Standard (AES) with 256-bit key size and Galois/Counter Mode (GCM) block cipher mode.\n\nSHA384\n\nSpecifies the message authentication code algorithm used to create the message digest, which is a cryptographic hash of each block in the message stream.\n\nIn this example, the SHA-2 hash function, SHA-384, is used.\n\nA supportedTLSProtocols name identifies the protocol and version, such as TLSv1.2.\n\nTo Restrict Protocols and Cipher Suites\n\nChoosing which protocol versions and cipher suites to allow for negotiating secure connections depends on known vulnerabilities, estimations of what is secure, and what peers support.\n\nThe default support is backward-compatible with old clients, meaning that if you do nothing it is possible for a client to use a protocol version that is known to have vulnerabilities, or to negotiate an insecure or very weakly secure connection. To avoid this, limit the protocols and cipher suites that you allow.\n\nYou can limit supported protocols and cipher suites by setting the properties, ssl-protocol and ssl-cipher-suite. These are available on connection handlers, and on components that connect to remote services including the global Crypto Manager component used for replication.\n\nThis procedure is based on server-side TLS recommendations from the Mozilla Operations Security team taken at the time of this writing. Recommendations evolve. Make sure you use current recommendations when configuring security settings.\n\nThe examples in this procedure assume you have installed an unlimited encryption strength policy:\n\nFor each cipher suite key algorithm to support, create a key pair using the supported key algorithm.\n\nThe following example adds two key pairs to the default PKCS#12 keystore, with one key using RSA and the other key using elliptic curve.\n\n$ keytool \\ -genkeypair \\ -alias server-cert-rsa \\ -keyalg RSA \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin $ keytool \\ -genkeypair \\ -alias server-cert-ec \\ -keyalg EC \\ -ext \"san=dns:opendj.example.com\" \\ -dname \"CN=opendj.example.com,O=Example Corp,C=FR\" \\ -keystore /path/to/opendj/config/keystore \\ -storetype PKCS12 \\ -storepass:file /path/to/opendj/config/keystore.pin \\ -keypass:file /path/to/opendj/config/keystore.pin\n\nOn the components you use, explicitly set the supported protocols and cipher suites.\n\nThe following example adjusts settings for the LDAP and LDAPS connection handlers:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAP \\ --add ssl-protocol:TLSv1.2 \\ --add ssl-cipher-suite:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 \\ --add ssl-cipher-suite:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 \\ --add ssl-cipher-suite:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 \\ --add ssl-cipher-suite:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 \\ --add ssl-cipher-suite:TLS_EMPTY_RENEGOTIATION_INFO_SCSV \\ --no-prompt \\ --trustAll $ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAPS \\ --add ssl-protocol:TLSv1.2 \\ --add ssl-cipher-suite:TLS_ECDHE_ECDSA_WITH_AES_256_GCM_SHA384 \\ --add ssl-cipher-suite:TLS_ECDHE_RSA_WITH_AES_256_GCM_SHA384 \\ --add ssl-cipher-suite:TLS_ECDHE_ECDSA_WITH_AES_128_GCM_SHA256 \\ --add ssl-cipher-suite:TLS_ECDHE_RSA_WITH_AES_128_GCM_SHA256 \\ --add ssl-cipher-suite:TLS_EMPTY_RENEGOTIATION_INFO_SCSV \\ --no-prompt \\ --trustAll\n\nThe TLS_ECDHE_EC* cipher suites call for a server certificate with an elliptic curve key algorithm. The TLS_ECDHE_RSA* cipher suites call for a server certificate with an RSA key algorithm.\n\nThe TLS_EMPTY_RENEGOTIATION_INFO_SCSV cipher suite is a renegotiation information extension with a special Signaling Cipher Suite Value (SCSV) to help older clients properly complete a handshake.\n\nOn the components you use, set the multivalued property, ssl-cert-nickname, to identify each certificate alias:\n\n$ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAP \\ --set enabled:true \\ --set listen-port:1389 \\ --set allow-start-tls:true \\ --set ssl-cert-nickname:server-cert-ec \\ --set ssl-cert-nickname:server-cert-rsa \\ --set key-manager-provider:\"Default Key Manager\" \\ --set trust-manager-provider:\"JVM Trust Manager\" \\ --trustAll \\ --no-prompt $ dsconfig \\ set-connection-handler-prop \\ --hostname opendj.example.com \\ --port 4444 \\ --bindDN \"cn=Directory Manager\" \\ --bindPassword password \\ --handler-name LDAPS \\ --set listen-port:1636 \\ --set enabled:true \\ --set use-ssl:true \\ --set ssl-cert-nickname:server-cert-ec \\ --set ssl-cert-nickname:server-cert-rsa \\ --trustAll \\ --no-prompt\n\nWhen negotiating a secure connection, the server can now use either key.\n\nTo Restrict Protocols For Command-Line Tools\n\nYou can specify which protocol versions to allow when command-line tools negotiate secure connections with LDAP servers.\n\nThe command-line tools depend on a system property, org.opends.ldaps.protocols. This property takes a comma-separated list of protocols. The default is constructed from the list of all protocols the JVM supports, removing protocol names starting with SSL. For example, if support is enabled in the JVM for versions 1.0, 1.1, and 1.2 of the TLS protocol, then the default is \"TLSv1,TLSv1.1,TLSv1.2\".\n\nRestrict the protocols to use by setting the property in one of the following ways:\n\nSet the property by editing the java-args for the command in config/java.properties.\n\nFor example, to restrict the protocol to TLS v1.2 when the status command negotiates a secure administrative connection, edit the corresponding line in config/java.properties:\n\nstatus.java-args=-Xms8m -client -Dorg.opends.ldaps.protocols=TLSv1.2\n\nSet the property at runtime when running the command.\n\nThe following example restricts the protocol to TLS v1.2 when the status command negotiates a secure administrative connection:\n\n$ export OPENDJ_JAVA_ARGS=\"-Dorg.opends.ldaps.protocols=TLSv1.2\" $ status \\ --bindDn \"cn=Directory Manager\" \\ --bindPassword password \\ --hostname opendj.example.com \\ --port 4444 \\ --usePkcs12TrustStore /path/to/opendj/config/keystore \\ --trustStorePasswordFile /path/to/opendj/config/keystore.pin\n\n5.7. Client Certificate Validation and the Directory\n\nThis section clarifies the roles that client applications' X.509 digital certificates play in establishing secure connections and in authenticating the client as a directory user. Be aware that establishing a secure connection happens before the server handles the LDAP or HTTP requests that the client sends over the secure connection. Establishing a secure connection is handled separately from authenticating a client as a directory user, even though both processes can involve the client's certificate.\n\nWhen a client and a server negotiate a secure connection over LDAPS or HTTPS, or over LDAP using the StartTLS operation, they can use public key cryptography to authenticate each other. The server, client, or both present certificates to each other. By default, DS LDAPS and HTTPS connection handlers are configured to present the server certificate, and to consider the client certificate optional. The connection handler property ssl-client-auth-policy makes the latter behavior configurable. For the DSML and REST to LDAP gateways, HTTPS negotiation is handled by the web application container where the gateway runs. See the web application container documentation for details on configuring how the container handles the client certificate.\n\nOne step toward establishing a secure connection involves validating the certificate that was presented by the other party. Part of this is trusting the certificate. The certificate identifies the client or server and the CA certificate used to sign the client or server certificate. The validating party checks that the other party corresponds to the one identified by the certificate, and checks that the signature can be trusted. If the signature is valid, and the CA certificate used to sign the certificate can be trusted, then the certificate can be trusted. This part of the validation process is also described briefly in \"How Keys are Used\" in the Security Guide.\n\nCertificates can be revoked after they are signed. Therefore, the validation process can involve checking whether the certificate is still valid. Two different methods for performing this validation use the Online Certificate Status Protocol (OCSP) or Certificate Revocation Lists (CRLs). OCSP is a newer solution that provides an online service to handle the revocation check for a specific certificate. CRLs are potentially large lists of user certificates that are no longer valid or that are on hold. A CRL is signed by the CA. The validating party obtains the CRL and checks that the certificate being validated is not listed. For a brief comparison, see OCSP: Comparison to CRLs. A certificate can include links to contact the OCSP responder or to the CRL distribution point. The validating party can use these links to check whether the the certificate is still valid.\n\nIn both cases, the CA who signed the certificate acts as the OCSP responder or publishes the CRLs. When establishing a secure connection with a client application, the server relies on the CA for OCSP and CRLs. This is the case even when the DS server is the repository for the CRLs.\n\nDS directory services are logical repositories for certificates and CRLs. For example, your DS directory service can store CRLs in a certificateRevocationList attribute as in the following example entry:\n\ndn: cn=My CA,dc=example,dc=com objectClass: top objectClass: applicationProcess objectClass: certificationAuthority cn: My CA authorityRevocationList;binary: Base64-encoded ARL cACertificate;binary:: Base64-encoded CA certificate certificateRevocationList;binary:: Base64-encoded CRL\n\nThe CRL could then be replicated to other DS directory servers for high availability. (Notice the ARL in this entry. An ARL is like a CRL, but for CA certificates.)\n\nAgain, despite being a repository for CRLs, the DS directory service does not use the CRLs directly when checking a client certificate. Instead, when negotiating a secure connection, the server depends on the JVM security configuration. The JVM configuration governs whether validation uses OCSP, CRLs, or both. As described in the Java PKI Programmer's Guide under Support for the CRL Distribution Points Extension, and Appendix C: On-Line Certificate Status Protocol (OCSP) Support, the JVM relies on system properties that define whether to use the CRL distribution points defined in certificates, and how to handle OCSP requests. These system properties can be set system-wide in $JAVA_HOME/lib/security/java.security ($JAVA_HOME/jre/lib/security/java.security for JDK 8). The JVM handles revocation checking without the DS server's involvement.\n\nAfter a connection is negotiated, the server can authenticate a client application at the LDAP level based on the certificate. For details, see \"Authenticating Client Applications With a Certificate\" in the Security Guide.\n\nOCSP and obtaining CRLs depend on network access to the CA. If DS servers or the DSML or REST to LDAP gateways run on a network where the "
    }
}