{
    "id": "correct_subsidiary_00143_3",
    "rank": 71,
    "data": {
        "url": "https://rubyapi.org/2.4/o/DBM.html",
        "read_more_link": "",
        "language": "en",
        "title": "Ruby API (v2.4)",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/assets/safari-pinned-tab-2610d1c1.svg",
        "meta_site_name": "",
        "canonical_link": "https://rubyapi.org/3.3/o/dbm",
        "text": "Introduction\n\nThe DBM class provides a wrapper to a Unix-style dbm or Database Manager library.\n\nDbm databases do not have tables or columns; they are simple key-value data stores, like a Ruby Hash except not resident in RAM. Keys and values must be strings.\n\nThe exact library used depends on how Ruby was compiled. It could be any of the following:\n\nThe original ndbm library is released in 4.3BSD. It is based on dbm library in Unix Version 7 but has different API to support multiple databases in a process.\n\nBerkeley DB versions 1 thru 5, also known as BDB and Sleepycat DB, now owned by Oracle Corporation.\n\nBerkeley DB 1.x, still found in 4.4BSD derivatives (FreeBSD, OpenBSD, etc).\n\ngdbm, the GNU implementation of dbm.\n\nqdbm, another open source reimplementation of dbm.\n\nAll of these dbm implementations have their own Ruby interfaces available, which provide richer (but varying) APIs.\n\nCautions\n\nBefore you decide to use DBM, there are some issues you should consider:\n\nEach implementation of dbm has its own file format. Generally, dbm libraries will not read each other’s files. This makes dbm files a bad choice for data exchange.\n\nEven running the same OS and the same dbm implementation, the database file format may depend on the CPU architecture. For example, files may not be portable between PowerPC and 386, or between 32 and 64 bit Linux.\n\nDifferent versions of Berkeley DB use different file formats. A change to the OS may therefore break DBM access to existing files.\n\nData size limits vary between implementations. Original Berkeley DB was limited to 2GB of data. Dbm libraries also sometimes limit the total size of a key/value pair, and the total size of all the keys that hash to the same value. These limits can be as little as 512 bytes. That said, gdbm and recent versions of Berkeley DB do away with these limits.\n\nGiven the above cautions, DBM is not a good choice for long term storage of important data. It is probably best used as a fast and easy alternative to a Hash for processing large amounts of data.\n\nExample\n\nrequire 'dbm' db = DBM.open('rfcs', 0666, DBM::WRCREAT) db['822'] = 'Standard for the Format of ARPA Internet Text Messages' db['1123'] = 'Requirements for Internet Hosts - Application and Support' db['3068'] = 'An Anycast Prefix for 6to4 Relay Routers' puts db['822']\n\next/dbm/dbm.c View on GitHub\n\nstatic VALUE\n\nfdbm_initialize(int argc, VALUE *argv, VALUE obj)\n\n{\n\nVALUE file, vmode, vflags;\n\nDBM *dbm;\n\nstruct dbmdata *dbmp;\n\nint mode, flags = 0;\n\nif (rb_scan_args(argc, argv, \"12\", &file, &vmode, &vflags) == 1) {\n\nmode = 0666; /* default value */\n\n}\n\nelse if (NIL_P(vmode)) {\n\nmode = -1; /* return nil if DB not exist */\n\n}\n\nelse {\n\nmode = NUM2INT(vmode);\n\n}\n\nif (!NIL_P(vflags))\n\nflags = NUM2INT(vflags);\n\nFilePathValue(file);\n\n/*\n\n* Note:\n\n* gdbm 1.10 works with O_CLOEXEC. gdbm 1.9.1 silently ignore it.\n\n*/\n\n#ifndef O_CLOEXEC\n\n# define O_CLOEXEC 0\n\n#endif\n\nif (flags & RUBY_DBM_RW_BIT) {\n\nflags &= ~RUBY_DBM_RW_BIT;\n\ndbm = dbm_open(RSTRING_PTR(file), flags|O_CLOEXEC, mode);\n\n}\n\nelse {\n\ndbm = 0;\n\nif (mode >= 0) {\n\ndbm = dbm_open(RSTRING_PTR(file), O_RDWR|O_CREAT|O_CLOEXEC, mode);\n\n}\n\nif (!dbm) {\n\ndbm = dbm_open(RSTRING_PTR(file), O_RDWR|O_CLOEXEC, 0);\n\n}\n\nif (!dbm) {\n\ndbm = dbm_open(RSTRING_PTR(file), O_RDONLY|O_CLOEXEC, 0);\n\n}\n\n}\n\nif (dbm) {\n\n/*\n\n* History of dbm_pagfno() and dbm_dirfno() in ndbm and its compatibles.\n\n* (dbm_pagfno() and dbm_dirfno() is not standardized.)\n\n*\n\n* 1986: 4.3BSD provides ndbm.\n\n* It provides dbm_pagfno() and dbm_dirfno() as macros.\n\n* 1991: gdbm-1.5 provides them as functions.\n\n* They returns a same descriptor.\n\n* (Earlier releases may have the functions too.)\n\n* 1991: Net/2 provides Berkeley DB.\n\n* It doesn't provide dbm_pagfno() and dbm_dirfno().\n\n* 1992: 4.4BSD Alpha provides Berkeley DB with dbm_dirfno() as a function.\n\n* dbm_pagfno() is a macro as DBM_PAGFNO_NOT_AVAILABLE.\n\n* 1997: Berkeley DB 2.0 is released by Sleepycat Software, Inc.\n\n* It defines dbm_pagfno() and dbm_dirfno() as macros.\n\n* 2011: gdbm-1.9 creates a separate dir file.\n\n* dbm_pagfno() and dbm_dirfno() returns different descriptors.\n\n*/\n\n#if defined(HAVE_DBM_PAGFNO)\n\nrb_fd_fix_cloexec(dbm_pagfno(dbm));\n\n#endif\n\n#if defined(HAVE_DBM_DIRFNO)\n\nrb_fd_fix_cloexec(dbm_dirfno(dbm));\n\n#endif\n\n#if defined(RUBYDBM_DB_HEADER) && defined(HAVE_TYPE_DBC)\n\n/* Disable Berkeley DB error messages such as:\n\n* DB->put: attempt to modify a read-only database */\n\n((DBC*)dbm)->dbp->set_errfile(((DBC*)dbm)->dbp, NULL);\n\n#endif\n\n}\n\nif (!dbm) {\n\nif (mode == -1) return Qnil;\n\nrb_sys_fail_str(file);\n\n}\n\ndbmp = ALLOC(struct dbmdata);\n\nDATA_PTR(obj) = dbmp;\n\ndbmp->di_dbm = dbm;\n\ndbmp->di_size = -1;\n\nreturn obj;\n\n}\n\nOpen a dbm database with the specified name, which can include a directory path. Any file extensions needed will be supplied automatically by the dbm library. For example, Berkeley DB appends ‘.db’, and GNU gdbm uses two physical files with extensions ‘.dir’ and ‘.pag’.\n\nThe mode should be an integer, as for Unix chmod.\n\nFlags should be one of READER, WRITER, WRCREAT or NEWDB."
    }
}