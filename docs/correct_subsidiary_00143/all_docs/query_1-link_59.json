{
    "id": "correct_subsidiary_00143_1",
    "rank": 59,
    "data": {
        "url": "https://objectcomputing.com/resources/publications/sett/november-2006-getting-to-know-berkeley-db-java-edition",
        "read_more_link": "",
        "language": "en",
        "title": "Getting To Know Berkeley DB Java Edition",
        "top_image": "https://objectcomputing.com/files/4716/4373/9454/favicon.png",
        "meta_img": "https://objectcomputing.com/files/4716/4373/9454/favicon.png",
        "images": [
            "https://objectcomputing.com/themes/objectcomputing/images/header-logo.svg",
            "https://objectcomputing.com/index.php/download_file/view_inline/1257/496",
            "https://objectcomputing.com/index.php/download_file/view_inline/1468/496",
            "https://objectcomputing.com/index.php/download_file/view_inline/1468/496",
            "https://objectcomputing.com/index.php/download_file/view_inline/1258/496",
            "https://objectcomputing.com/index.php/download_file/view_inline/5557/496",
            "https://objectcomputing.com/files/1214/8771/9866/twitter_social_icon.svg",
            "https://objectcomputing.com/files/6314/8771/9865/linkedin_social_icon.svg",
            "https://objectcomputing.com/files/6014/8771/9866/youtube_social_icon.svg",
            "https://objectcomputing.com/files/6314/8771/9865/github_socail_icon.svg",
            "https://objectcomputing.com/files/9516/9712/5686/Medium_social_icon-1_2.png",
            "https://objectcomputing.com/themes/objectcomputing/images/back-to-top.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Learn the basics of Berkeley DB Java Edition.",
        "meta_lang": "en",
        "meta_favicon": "/files/4716/4373/9454/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://objectcomputing.com/resources/publications/sett/november-2006-getting-to-know-berkeley-db-java-edition",
        "text": "By Weiqi Gao, OCI Principal Software Engineer\n\nNovember 2006\n\nIntroduction\n\nBerkeley DB Java Edition is an embedded database written in pure Java. It allows efficient persistence of data into local disks. It provides full ACID transaction semantics for data storage. It uses an in-memory cache to speed up data reads when the working set can fit into memory. And its log-based storage system makes data writes very fast.\n\nBerkeley DB Java Edition also supports Java Transaction API (JTA), J2EE Connector Architecture (JCA) and Java Management Extensions (JMX), making it easily integrated into many Java EE application servers.\n\nThe latest release of Berkeley DB Java Edition contains an API known as the Direct Persistence Layer (DPL), which is similar to the Java Persistence API (API). This layer is built on top of the lower-level byte array based Berkeley DB Java Edition engine. Berkeley DB Java Edition also contains an implementation of the Java Collections API that is backed by the same engine.\n\nOn the administrative side, Berkeley DB Java Edition uses an architecture-neutral file format and supports hot backups.\n\nLicensing and History\n\nThe free software Berkeley DB (the C Edition, or the Core Edition, to distinguish from the Java Edition) has been in existence since 1991. The original authors of Berkeley DB founded the Sleepycat Software company in 1996 to further develop and support, both through a free software license and a commercial license, the Berkeley DB software. Software that redistributes Berkeley DB must be either itself available as free software or use a commercially licensed Berkeley DB.\n\nA JNI-based Java binding for Berkeley DB (Core Edition) was introduced soon after the Java programming language become popular. Sleepycat released a pure Java version Berkeley DB in 2004.\n\nOracle Corporation acquired Sleepycat Software in February 2006 to expand its line of embeddable database products.\n\nOracle has continued both the development and the dual licensing model of Sleepycat's line of database products: Berkeley DB (Core Edition), Berkeley DB XML and Berkeley DB Java Edition.\n\nOracle Berkeley DB Java Edition 3.1.0 was released in September 2006.\n\nContrast with Other Kinds of Databases\n\nWhen thinking about databases, the first thing that comes to a Java developer's mind is probably relational database servers. These servers have a communications layer that allows a remote application to connect to the database process, a SQL compiler that understands and executes SQL queries from the application, and an interactive shell that allows users and administrators to perform ad hoc queries. Berkeley DB Java Edition has none of these.\n\nWhat it does have is a transaction engine that offers full ACID (Atomicity, Consistency, Isolation and Durability) semantics, an in-memory cache that manages the data using B+trees, and a persistence engine that writes log files to local disks. Everything Berkeley DB Java Edition does happens inside the same JVM instance where the application is hosted. In other words, the database is embedded within the application process as a jar file in the classpath.\n\nThese characteristics makes Berkeley DB Java Edition uniquely suitable for a wide class of applications that does not require the additional features from a full-fledged relational database server. These applications tend to have a relatively stable and small data schema, a very dynamic but usually bounded data set, and high throughput requirements.\n\nIn this article, I will take you though a Java application developer's tour of Oracle Berkeley DB Java Edition, henceforth referred to as JE, the shorthand name used in its documentation.\n\nWhat's In the Download\n\nJE is available for download from the Oracle Berkeley DB website. The download bundle can be unzipped or untarred into a single directory je-3.1.0 that contains the following files and subdirectories:\n\nThe src and test directories contain the source code and a set of tests for the JE product. The lib directory contains a single jar file named je-3.1.0.jar. This 1.1MB file is the only jar file needed to use JE. It does not depend on anything but the JDK. The Direct Persistence Layer (DPL) requires Java 5 or later. The rest of the JE requires Java 1.4.2 or later. The jar file contains a Main-Class manifest declaration and can be used to invoke administrative utilities.\n\nThe docs directory contains a rich set of documentation typical of the Berkeley DB family of products. Aside from the usual release notes, installation instructions and javadocs, four books are included, in both HTML and PDF format:\n\nGetting Started with Berkeley DB Java Edition (120 pages)\n\nGetting Started with Direct Persistence Layer (42 pages)\n\nGetting Started with Transaction Processing (62 pages)\n\nJava Collections Tutorial (95 pages)\n\nThe examples directory contains example programs illustrating JE features. The release notes have detailed instructions on how to compile and use the example classes.\n\nThe online books are written in a tutorial style and does not assume any prior database programming experience. Together with the javadocs and the examples, they provide a thorough introduction to JE basics, its transaction engine and the two frameworks built on top of JE: the Direct Persistence Layer and the Java Collections API. And because of the availability of these excellent tutorials, I will try to simply highlight some of the interesting features of JE.\n\nLet's Create A Database\n\nJE's terminology is slightly different from those of the relational database world. To work with JE data, we use Environments. A JE Environment is roughly equivalent to what the relational database world calls a database or a schema, and a JE Database corresponds to an relational database table. However a JE database has only two columns: key and data. In this regard a JE database is more like a Java TreeMap.\n\nThis opens a JE environment in the directory ./envHome and a database named randomBytes within the environment. The variable env is called an environment handle and db a database handle. The environment handle is created with a constructor and it in turn is a factory of database handles.\n\nJE supports many configuration properties for the various handles it creates. These properties are passed in to the constructors or factory methods of the handles as a configuration object parameter. The above example shows the usage of EnvironmentConfig and DatabaseConfig objects and later examples will show the usage of CursorConfig, TransactionConfig and SecondaryConfig objects. A null, or a *Config.DEFAULT object can be passed in if the default properties are desired. Properties can also be set in a je.properties file in the environment home directory. An example.properties file is available in the je-3.1.0 directory that lists all the properties, their default values, and whether they can be modified after creation.\n\nThe same *Config object can be reused in the creation of subsequent handles. Changes made to config objects will not affect handles already opened.\n\nA subset of the environment configuration properties can be modified at run time through a EnvironmentMutableConfig object obtained from the environment handle.\n\nThe environment home directory must exist prior to opening an environment, or a DatabaseException is thrown. If the directory is empty and the allowCreate property is true, an environment will be created. If the directory is empty and allowCreate is false, a DatabaseException is thrown.\n\nFrom the above example, one can see that the transactional properties can be turned on or off for the environment or for individual databases in the environment. However, if transaction is turned off for the environment then it must be off for all databases that are opened in that environment.\n\nWhen JE creates an environment, it simply creates a couple of files: a log file 00000000.jdb and a lock file je.lck. It is not obvious what JE databases are available in an environment by looking into the environment home directory. JE appends all persistent activities such as transactions, insertions, updates and deletions to the log file. When 00000000.jdb is full (the default size is 10MB), 00000001.jdb is created, etc., up to ffffffff.jdb. If an environment is opened as read-write, a log cleaning thread is started that monitors log files utilization. When most of the records in a particular log file have been obsoleted by updates or deletions in later log files, the log cleaning thread copies the remaining records to the end of the latest log file and deletes the old log file. The cleaner chooses which log file to operate based on the current space utilization within the log file.\n\nThe JE log file format is architecture neutral and can be copied from machine to machine regardless of processor types or operating systems. However this file format is not compatible with that of Berkeley DB Core Edition.\n\nByte Arrays Are the Key (and the Data)\n\nAt the lowest level, JE supports only one data type, the byte array type. It encapsulates byte arrays into the DatabaseEntry class. The following class inserts 100000 1k records into the randomBytes database:\n\nWe obtain a transaction from the environment by calling the beginTransaction method, passing in two nulls as parameters. The first parameter is the parent transaction and must be set to null as JE does not yet support nested transactions. The second parameter is a TransactionConfig and we pass in null to use the default properties.\n\nThe sortedDuplicates property of databases is saved on disk when a database is first created. All subsequent opens of the database must use the same property value. This property controls duplicate data in the database. If this property is false, putting a key-data pair with an existing key will overwrite the old data. If it is set to true, putting a key-data pair with an existing key will cause both the new data and the old data to be saved in the database.\n\nHere are the numbers if sortedDuplicates is set to false:\n\nFor the remainder of these article, we will use a version of CreateRandomBytes where sortedDuplicates is false.\n\nTurning Anything into a Byte Array (Data Binding)\n\nAs illustrated in the last section, JE stores only byte arrays. If you want to store anything other than byte arrays, you have to do the conversion when inserting or retrieving values.\n\nJE provides a Bind API to help with this process. It defines the EntryBinding interface:\n\ninterface EntryBinding { Object entryToObject(DatabaseEntry entry); void objectToEntry(Object object, DatabaseEntry entry); }\n\nImplementations of this interface are provided in JE to handle Java primitive types, Strings and Serializable objects. An abstract class TupleBinding can be extended to handle other kinds of objects.\n\nHere is what it takes to convert a long and String key-data pair into DatabaseEntrys (Notice that the TupleBinding abstract class is also the factory for concrete bindings for primitive types and String):\n\nHere is what it takes to extend TupleBinding to handle a custom data structure. The Book class contains a couple of String fields:\n\nThe BookBinding extends TupleBinding and uses TupleInput and TupleOutput objects to convert Bookobjects to byte arrays:\n\nOne thing to note here is that the order that you read data from input must be exactly the same as the order in which it was written to output. Another thing to note is the lack of type safety in this approach. You can put a Book into a database and get out an object of another type that has the same structure as a Book.\n\nJE also contains a SerialBinding class that works with any Serializable objects without having to write a custom TupleBinding. Since Java serialization format contains repetitive classes information, JE uses a revised scheme that puts the classes information into a separate database.\n\nNavigation with Cursors\n\nJE Database objects have a get method that allows you to retrieve the data based on a key. We can read back the random bytes from the randomBytes database using the following program:\n\nWe open the environment and database as read only, reconstructed each key and retrieved the the corresponding data from the database.\n\nTo iterate over the data in a database without prior knowledge of the keys, we use the JECursor class.\n\nHere we call the database handle's openCursor method to get a Cursor. Two parameters are passed in: a Transaction, and a null for CursorConfig to use the default properties. We then use the getNext method to walk through all the records in the database. Executing CreateRandomBytes followed by IterateRandomBytes yields the following results:\n\nAside from the getNext method that moves the cursor to the next record in the database (a newly opened cursor points to one prior to the first record), the Cursor class also has the following cursor position methods:\n\ngetPrev\n\nmoves to the previous record (a newly opened cursor also points to one past the last record) getFirst\n\nmoves to the first record getLast\n\nmoves to the last record getSearchKey\n\nmoves to record with matching key getSearchKeyRange\n\nmoves to first record at or just past the given key getSearchBoth\n\nmoves to record with matching key and data getSearchBothRange\n\nmoves to first record with matching key and data at or just past the given data)\n\nThe search methods account for duplicate data values with the same key.\n\nYou can also insert, update and delete records using the put, putCurrent and delete methods of the Cursor class. More elaborate methods exists to deal with duplicate data situations. Here is a little program that deletes all the random bytes that we created:\n\nWe simply delete each record as we iterate through the cursor. We also call the Environment.cleanLog() method right before we close the environment handle. In our scenario this causes some of the log files, which now contain deleted records, to be removed.\n\nExecuting CreateRandomBytes followed by DeleteRandomBytes yields the following numbers:\n\nSecondary Databases Are Indexes\n\nThe JE cursor allows us to search a database based on the keys of the records. Sometimes an application may wish to search the database using something other than the keys. The way to make this possible in JE is to use a secondary database (an index in relational database terminology.)\n\nThe data in secondary databases are the keys of its associated primary database and the keys are generated from data in the primary database. The primary database handle and the key creator are two pieces of information needed when a secondary database is opened. A primary database cannot allow duplicate records when a secondary database is used. However, a secondary database should generally allow duplicate records.\n\nIn the next example, we create a secondary database keyed off of the tenth byte of the byte array data in the primary database and then use that secondary database to find all primary data whose tenth byte is 42.\n\nWe first implement a TenthByteKeyCreator:\n\nThe SecondaryKeyCreator interface has only one method createSecondaryKey(). We have access to the secondary database itself, the key-data pair of the primary database record, and a result that is to become the key in the secondary database. We simply grab the tenth byte out of the primary data and stuff it into the result.\n\nFor this example we have to use a bigger heap size to avoid excessive garbage collections. Here are the numbers:\n\nFrom a probability point of view, there should be around 100000/256 = 391 records whose tenth byte is 42. So our results are about right. It is worth pointing out that although the data writes are slowed down, the indexed search is a lot faster than a serial search through a primary database cursor.\n\nThe Cache, the OS IO Buffer, and the Physical Disk\n\nOne of the characteristics of embedded databases is the proximity of the data to the applicationâ€”it's right there on a local disk. Consequently, a lot more can be done to tune the database with respect to its disk access behavior. This is markedly different from using an relational database server where the database is always a network call away and there is not a thing the application developer can do about it.\n\nAs a non-JE application writes data to the local disk, the data usually pass through three stages. First, the application gathers the data it wants to write out into an application buffer. Then the application buffer is written into a file system buffer. And finally, the operating system syncs the file system buffer onto the physical disk. And then there is the on-board disk hardware write cache, which needs to be disabled if we really want the data to reach the physical disk.\n\nIn order for a database to achieve the Durability part of the ACID transaction semantics, it is important that the data be synced to the physical disk. That step is expensive compared to writing to the file system.\n\nJE allows the application developer to choose how far their data would go when a transaction is committed, trading a little bit durability of the data in the event of an operating system or an application failure for some usually dramatic throughput gains.\n\nIn JE terms, a transaction can be committed in one of three ways: commitSync, commitWriteNoSync, and commitNoSync. commitSync will take the data all the way to the disk and takes a long time. commitWriteNoSync takes the data to the operating system level but doesn't wait for all of it to be written to disk. The operating system will make sure it happens at a later time. commitNoSync writes the data to JE's cache, and the data will be written to the operating system when JE's write buffer is filled up or when a subsequent sync transaction happens.\n\nHow an application commits its transactions can be configured at different times in an JE application. It can be configured environment wide using EnvironmentConfig, at transaction creation time using TransactionConfig or at commit time by selecting from the different commit methods.\n\nWouldn't It Be Nice If...\n\nUsing the Bind API, the JE application developer can design the database schema with complex data structures and relationships. However writing custom bindings and complex queries still require quite a bit of work.\n\nJE includes two higher level frameworks that ease this burden. The JE Java Collections API allows applications to access JE data through the standard Java Collections API interface. The newer Direct Persistence Layer allows applications to use a mechanism not unlike the Java Persistence API (JPA) to manipulate JE data.\n\nWe give a simple example that highlight some of the DPL features.\n\nThe DPL uses Java 5 annotations to define @Entity classes with @PrimaryKey and @SecondaryKey markings. An entity is an independent class that has a primary key and is accessed through a primary index. A secondary key can be one-to-one, many-to-one, one-to-many or many-to-many. A secondary key can also be a foreign key that relates one entity to another.\n\nThe DPL uses bytecode instrumentation to generate the low level code. The instrumentation can be performed either ahead of time using an Ant task, or at class loading time.\n\nThe DPL uses a high-level construct called an EntityStore instead of the low level Databases to manage persistence. The EntityStore is the factory for the generic PrimaryIndex and SecondaryIndex objects. An entity object can be persisted using PrimaryIndex objects and retrieved using PrimaryIndex, SecondaryIndex and EntityCursor objects. The primary and secondary index classes are like DAOs.\n\nExecuting this class' main method puts three orders into the JE environment.\n\nExecuting this class' main method retrieves and displays the orders in the JE environment. The orders are retrieved twice. First, using the primary index to get all the orders, three orders were retrieved. Secondly, using the secondary index to get all orders with a department Id of 3, two orders were retrieved.\n\nSummary\n\nBerkeley DB Java Edition brings the high performance, small footprint Berkeley DB Core Edition tradition into the Java world. By implementing the core engine in pure Java, the JE developers made it more attractive for Java developers.\n\nJE and other Java-based embedded database engines makes writing a new class of applications feasible in the Java programming language.\n\nThe JE Direct Persistence Layer provides a JPA-like plain Java object persistence mechanism that is powerful and easy-to-use.\n\nReferences"
    }
}