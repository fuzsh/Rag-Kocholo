{
    "id": "dbpedia_2370_2",
    "rank": 85,
    "data": {
        "url": "https://www.w3.org/TR/html401/interact/forms.html",
        "read_more_link": "",
        "language": "en",
        "title": "Forms in HTML documents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.w3.org/TR/html401/images/form_exmpl.gif",
            "https://www.w3.org/TR/html401/images/optgroup_exmpl.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "17 Forms\n\n17.1 Introduction to forms\n\nAn HTML form is a section of a document containing normal content, markup, special elements called controls (checkboxes, radio buttons, menus, etc.), and labels on those controls. Users generally \"complete\" a form by modifying its controls (entering text, selecting menu items, etc.), before submitting the form to an agent for processing (e.g., to a Web server, to a mail server, etc.)\n\nHere's a simple form that includes labels, radio buttons, and push buttons (reset the form or submit it):\n\n<FORM action=\"http://somesite.com/prog/adduser\" method=\"post\"> <P> <LABEL for=\"firstname\">First name: </LABEL> <INPUT type=\"text\" id=\"firstname\"><BR> <LABEL for=\"lastname\">Last name: </LABEL> <INPUT type=\"text\" id=\"lastname\"><BR> <LABEL for=\"email\">email: </LABEL> <INPUT type=\"text\" id=\"email\"><BR> <INPUT type=\"radio\" name=\"sex\" value=\"Male\"> Male<BR> <INPUT type=\"radio\" name=\"sex\" value=\"Female\"> Female<BR> <INPUT type=\"submit\" value=\"Send\"> <INPUT type=\"reset\"> </P> </FORM>\n\nNote. This specification includes more detailed information about forms in the subsections on form display issues.\n\n17.2 Controls\n\nUsers interact with forms through named controls.\n\nA control's \"control name\" is given by its name attribute. The scope of the name attribute for a control within a FORM element is the FORM element.\n\nEach control has both an initial value and a current value, both of which are character strings. Please consult the definition of each control for information about initial values and possible constraints on values imposed by the control. In general, a control's \"initial value\" may be specified with the control element's value attribute. However, the initial value of a TEXTAREA element is given by its contents, and the initial value of an OBJECT element in a form is determined by the object implementation (i.e., it lies outside the scope of this specification).\n\nThe control's \"current value\" is first set to the initial value. Thereafter, the control's current value may be modified through user interaction and scripts.\n\nA control's initial value does not change. Thus, when a form is reset, each control's current value is reset to its initial value. If a control does not have an initial value, the effect of a form reset on that control is undefined.\n\nWhen a form is submitted for processing, some controls have their name paired with their current value and these pairs are submitted with the form. Those controls for which name/value pairs are submitted are called successful controls.\n\n17.2.1 Control types\n\nHTML defines the following control types:\n\nbuttons\n\nAuthors may create three types of buttons:\n\nsubmit buttons: When activated, a submit button submits a form. A form may contain more than one submit button.\n\nreset buttons: When activated, a reset button resets all controls to their initial values.\n\npush buttons: Push buttons have no default behavior. Each push button may have client-side scripts associated with the element's event attributes. When an event occurs (e.g., the user presses the button, releases it, etc.), the associated script is triggered.\n\nAuthors should specify the scripting language of a push button script through a default script declaration (with the META element).\n\nAuthors create buttons with the BUTTON element or the INPUT element. Please consult the definitions of these elements for details about specifying different button types.\n\nNote. Authors should note that the BUTTON element offers richer rendering capabilities than the INPUT element.\n\ncheckboxes\n\nCheckboxes (and radio buttons) are on/off switches that may be toggled by the user. A switch is \"on\" when the control element's checked attribute is set. When a form is submitted, only \"on\" checkbox controls can become successful.\n\nSeveral checkboxes in a form may share the same control name. Thus, for example, checkboxes allow users to select several values for the same property. The INPUT element is used to create a checkbox control.\n\nradio buttons\n\nRadio buttons are like checkboxes except that when several share the same control name, they are mutually exclusive: when one is switched \"on\", all others with the same name are switched \"off\". The INPUT element is used to create a radio button control.\n\nIf no radio button in a set sharing the same control name is initially \"on\", user agent behavior for choosing which control is initially \"on\" is undefined. Note. Since existing implementations handle this case differently, the current specification differs from RFC 1866 ([RFC1866] section 8.1.2.4), which states:\n\nAt all times, exactly one of the radio buttons in a set is checked. If none of the <INPUT> elements of a set of radio buttons specifies `CHECKED', then the user agent must check the first radio button of the set initially.\n\nSince user agent behavior differs, authors should ensure that in each set of radio buttons that one is initially \"on\".\n\nmenus\n\nMenus offer users options from which to choose. The SELECT element creates a menu, in combination with the OPTGROUP and OPTION elements.\n\ntext input\n\nAuthors may create two types of controls that allow users to input text. The INPUT element creates a single-line input control and the TEXTAREA element creates a multi-line input control. In both cases, the input text becomes the control's current value.\n\nfile select\n\nThis control type allows the user to select files so that their contents may be submitted with a form. The INPUT element is used to create a file select control.\n\nhidden controls\n\nAuthors may create controls that are not rendered but whose values are submitted with a form. Authors generally use this control type to store information between client/server exchanges that would otherwise be lost due to the stateless nature of HTTP (see [RFC2616]). The INPUT element is used to create a hidden control.\n\nobject controls\n\nAuthors may insert generic objects in forms such that associated values are submitted along with other controls. Authors create object controls with the OBJECT element.\n\nThe elements used to create controls generally appear inside a FORM element, but may also appear outside of a FORM element declaration when they are used to build user interfaces. This is discussed in the section on intrinsic events. Note that controls outside a form cannot be successful controls.\n\n17.3 The FORM element\n\nStart tag: required, End tag: required\n\nThe FORM element acts as a container for controls. It specifies:\n\nThe layout of the form (given by the contents of the element).\n\nThe program that will handle the completed and submitted form (the action attribute). The receiving program must be able to parse name/value pairs in order to make use of them.\n\nThe method by which user data will be sent to the server (the method attribute).\n\nA character encoding that must be accepted by the server in order to handle this form (the accept-charset attribute). User agents may advise the user of the value of the accept-charset attribute and/or restrict the user's ability to enter unrecognized characters.\n\nA form can contain text and markup (paragraphs, lists, etc.) in addition to form controls.\n\nThe following example shows a form that is to be processed by the \"adduser\" program when submitted. The form will be sent to the program using the HTTP \"post\" method.\n\n<FORM action=\"http://somesite.com/prog/adduser\" method=\"post\"> ...form contents... </FORM>\n\nPlease consult the section on form submission for information about how user agents must prepare form data for servers and how user agents should handle expected responses.\n\nNote. Further discussion on the behavior of servers that receive form data is beyond the scope of this specification.\n\n17.4 The INPUT element\n\nStart tag: required, End tag: forbidden\n\n17.4.1 Control types created with INPUT\n\nThe control type defined by the INPUT element depends on the value of the type attribute:\n\ntext\n\nCreates a single-line text input control.\n\npassword\n\nLike \"text\", but the input text is rendered in such a way as to hide the characters (e.g., a series of asterisks). This control type is often used for sensitive input such as passwords. Note that the current value is the text entered by the user, not the text rendered by the user agent.\n\nNote. Application designers should note that this mechanism affords only light security protection. Although the password is masked by user agents from casual observers, it is transmitted to the server in clear text, and may be read by anyone with low-level access to the network.\n\ncheckbox\n\nCreates a checkbox.\n\nradio\n\nCreates a radio button.\n\nsubmit\n\nCreates a submit button.\n\nimage\n\nCreates a graphical submit button. The value of the src attribute specifies the URI of the image that will decorate the button. For accessibility reasons, authors should provide alternate text for the image via the alt attribute.\n\nWhen a pointing device is used to click on the image, the form is submitted and the click coordinates passed to the server. The x value is measured in pixels from the left of the image, and the y value in pixels from the top of the image. The submitted data includes name.x=x-value and name.y=y-value where \"name\" is the value of the name attribute, and x-value and y-value are the x and y coordinate values, respectively.\n\nIf the server takes different actions depending on the location clicked, users of non-graphical browsers will be disadvantaged. For this reason, authors should consider alternate approaches:\n\nUse multiple submit buttons (each with its own image) in place of a single graphical submit button. Authors may use style sheets to control the positioning of these buttons.\n\nUse a client-side image map together with scripting.\n\nreset\n\nCreates a reset button.\n\nbutton\n\nCreates a push button. User agents should use the value of the value attribute as the button's label.\n\nhidden\n\nCreates a hidden control.\n\nfile\n\nCreates a file select control. User agents may use the value of the value attribute as the initial file name.\n\n17.4.2 Examples of forms containing INPUT controls\n\nIn this next example, the JavaScript function name verify is triggered when the \"onclick\" event occurs:\n\n<HEAD> <META http-equiv=\"Content-Script-Type\" content=\"text/javascript\"> </HEAD> <BODY> <FORM action=\"...\" method=\"post\"> <P> <INPUT type=\"button\" value=\"Click Me\" onclick=\"verify()\"> </FORM> </BODY>\n\nPlease consult the section on intrinsic events for more information about scripting and events.\n\n17.5 The BUTTON element\n\nStart tag: required, End tag: required\n\nButtons created with the BUTTON element function just like buttons created with the INPUT element, but they offer richer rendering possibilities: the BUTTON element may have content. For example, a BUTTON element that contains an image functions like and may resemble an INPUT element whose type is set to \"image\", but the BUTTON element type allows content.\n\nVisual user agents may render BUTTON buttons with relief and an up/down motion when clicked, while they may render INPUT buttons as \"flat\" images.\n\nRecall that authors must provide alternate text for an IMG element.\n\nIt is illegal to associate an image map with an IMG that appears as the contents of a BUTTON element.\n\nILLEGAL EXAMPLE:\n\nThe following is not legal HTML.\n\n<BUTTON> <IMG src=\"foo.gif\" usemap=\"...\"> </BUTTON>\n\n17.6 The SELECT, OPTGROUP, and OPTION elements\n\nStart tag: required, End tag: required\n\nThe SELECT element creates a menu. Each choice offered by the menu is represented by an OPTION element. A SELECT element must contain at least one OPTION element.\n\nThe OPTGROUP element allows authors to group choices logically. This is particularly helpful when the user must choose from a long list of options; groups of related choices are easier to grasp and remember than a single long list of options. In HTML 4, all OPTGROUP elements must be specified directly within a SELECT element (i.e., groups may not be nested).\n\n17.6.1 Pre-selected options\n\nZero or more choices may be pre-selected for the user. User agents should determine which choices are pre-selected as follows:\n\nIf no OPTION element has the selected attribute set, user agent behavior for choosing which option is initially selected is undefined. Note. Since existing implementations handle this case differently, the current specification differs from RFC 1866 ([RFC1866] section 8.1.3), which states:\n\nThe initial state has the first option selected, unless a SELECTED attribute is present on any of the <OPTION> elements.\n\nSince user agent behavior differs, authors should ensure that each menu includes a default pre-selected OPTION.\n\nIf one OPTION element has the selected attribute set, it should be pre-selected.\n\nIf the SELECT element has the multiple attribute set and more than one OPTION element has the selected attribute set, they should all be pre-selected.\n\nIt is considered an error if more than one OPTION element has the selected attribute set and the SELECT element does not have the multiple attribute set. User agents may vary in how they handle this error, but should not pre-select more than one choice.\n\nStart tag: required, End tag: required\n\nStart tag: required, End tag: optional\n\nWhen rendering a menu choice, user agents should use the value of the label attribute of the OPTION element as the choice. If this attribute is not specified, user agents should use the contents of the OPTION element.\n\nThe label attribute of the OPTGROUP element specifies the label for a group of choices.\n\n17.7 The TEXTAREA element\n\nStart tag: required, End tag: required\n\nThe TEXTAREA element creates a multi-line text input control. User agents should use the contents of this element as the initial value of the control and should render this text initially.\n\n17.8 The ISINDEX element\n\nISINDEX is deprecated. This element creates a single-line text input control. Authors should use the INPUT element to create text input controls.\n\nSee the Transitional DTD for the formal definition.\n\nThe ISINDEX element creates a single-line text input control that allows any number of characters. User agents may use the value of the prompt attribute as a title for the prompt.\n\n17.9 Labels\n\nSome form controls automatically have labels associated with them (press buttons) while most do not (text fields, checkboxes and radio buttons, and menus).\n\nFor those controls that have implicit labels, user agents should use the value of the value attribute as the label string.\n\nThe LABEL element is used to specify labels for controls that do not have implicit labels,\n\n17.9.1 The LABEL element\n\nStart tag: required, End tag: required\n\nThe LABEL element may be used to attach information to controls. Each LABEL element is associated with exactly one form control.\n\nThe for attribute associates a label with another control explicitly: the value of the for attribute must be the same as the value of the id attribute of the associated control element. More than one LABEL may be associated with the same control by creating multiple references via the for attribute.\n\nThis example creates a table that is used to align two text input controls and their associated labels. Each label is associated explicitly with one text input:\n\n<FORM action=\"...\" method=\"post\"> <TABLE> <TR> <TD><LABEL for=\"fname\">First Name</LABEL> <TD><INPUT type=\"text\" name=\"firstname\" id=\"fname\"> <TR> <TD><LABEL for=\"lname\">Last Name</LABEL> <TD><INPUT type=\"text\" name=\"lastname\" id=\"lname\"> </TABLE> </FORM>\n\nTo associate a label with another control implicitly, the control element must be within the contents of the LABEL element. In this case, the LABEL may only contain one control element. The label itself may be positioned before or after the associated control.\n\nIn this example, we implicitly associate two labels with two text input controls:\n\n<FORM action=\"...\" method=\"post\"> <P> <LABEL> First Name <INPUT type=\"text\" name=\"firstname\"> </LABEL> <LABEL> <INPUT type=\"text\" name=\"lastname\"> Last Name </LABEL> </P> </FORM>\n\nNote that this technique cannot be used when a table is being used for layout, with the label in one cell and its associated control in another cell.\n\nWhen a LABEL element receives focus, it passes the focus on to its associated control. See the section below on access keys for examples.\n\nLabels may be rendered by user agents in a number of ways (e.g., visually, read by speech synthesizers, etc.)\n\n17.10 Adding structure to forms: the FIELDSET and LEGEND elements\n\nStart tag: required, End tag: required\n\nThe FIELDSET element allows authors to group thematically related controls and labels. Grouping controls makes it easier for users to understand their purpose while simultaneously facilitating tabbing navigation for visual user agents and speech navigation for speech-oriented user agents. The proper use of this element makes documents more accessible.\n\nThe LEGEND element allows authors to assign a caption to a FIELDSET. The legend improves accessibility when the FIELDSET is rendered non-visually.\n\n17.11 Giving focus to an element\n\nIn an HTML document, an element must receive focus from the user in order to become active and perform its tasks. For example, users must activate a link specified by the A element in order to follow the specified link. Similarly, users must give a TEXTAREA focus in order to enter text into it.\n\nThere are several ways to give focus to an element:\n\nDesignate the element with a pointing device.\n\nNavigate from one element to the next with the keyboard. The document's author may define a tabbing order that specifies the order in which elements will receive focus if the user navigates the document with the keyboard (see tabbing navigation). Once selected, an element may be activated by some other key sequence.\n\nSelect an element through an access key (sometimes called \"keyboard shortcut\" or \"keyboard accelerator\").\n\n17.11.1 Tabbing navigation\n\nThe tabbing order defines the order in which elements will receive focus when navigated by the user via the keyboard. The tabbing order may include elements nested within other elements.\n\nElements that may receive focus should be navigated by user agents according to the following rules:\n\nThose elements that support the tabindex attribute and assign a positive value to it are navigated first. Navigation proceeds from the element with the lowest tabindex value to the element with the highest value. Values need not be sequential nor must they begin with any particular value. Elements that have identical tabindex values should be navigated in the order they appear in the character stream.\n\nThose elements that do not support the tabindex attribute or support it and assign it a value of \"0\" are navigated next. These elements are navigated in the order they appear in the character stream.\n\nElements that are disabled do not participate in the tabbing order.\n\nThe following elements support the tabindex attribute: A, AREA, BUTTON, INPUT, OBJECT, SELECT, and TEXTAREA.\n\nTabbing keys. The actual key sequence that causes tabbing navigation or element activation depends on the configuration of the user agent (e.g., the \"tab\" key is used for navigation and the \"enter\" key is used to activate a selected element).\n\nUser agents may also define key sequences to navigate the tabbing order in reverse. When the end (or beginning) of the tabbing order is reached, user agents may circle back to the beginning (or end).\n\n17.11.2 Access keys\n\nPressing an access key assigned to an element gives focus to the element. The action that occurs when an element receives focus depends on the element. For example, when a user activates a link defined by the A element, the user agent generally follows the link. When a user activates a radio button, the user agent changes the value of the radio button. When the user activates a text field, it allows input, etc.\n\nThe following elements support the accesskey attribute: A, AREA, BUTTON, INPUT, LABEL, and LEGEND, and TEXTAREA.\n\nThe invocation of access keys depends on the underlying system. For instance, on machines running MS Windows, one generally has to press the \"alt\" key in addition to the access key. On Apple systems, one generally has to press the \"cmd\" key in addition to the access key.\n\nThe rendering of access keys depends on the user agent. We recommend that authors include the access key in label text or wherever the access key is to apply. User agents should render the value of an access key in such a way as to emphasize its role and to distinguish it from other characters (e.g., by underlining it).\n\n17.12 Disabled and read-only controls\n\nIn contexts where user input is either undesirable or irrelevant, it is important to be able to disable a control or render it read-only. For example, one may want to disable a form's submit button until the user has entered some required data. Similarly, an author may want to include a piece of read-only text that must be submitted as a value along with the form. The following sections describe disabled and read-only controls.\n\n17.12.1 Disabled controls\n\nWhen set, the disabled attribute has the following effects on an element:\n\nDisabled controls do not receive focus.\n\nDisabled controls are skipped in tabbing navigation.\n\nDisabled controls cannot be successful.\n\nThe following elements support the disabled attribute: BUTTON, INPUT, OPTGROUP, OPTION, SELECT, and TEXTAREA.\n\nThis attribute is inherited but local declarations override the inherited value.\n\nHow disabled elements are rendered depends on the user agent. For example, some user agents \"gray out\" disabled menu items, button labels, etc.\n\n17.12.2 Read-only controls\n\nThe readonly attribute specifies whether the control may be modified by the user.\n\nWhen set, the readonly attribute has the following effects on an element:\n\nRead-only elements receive focus but cannot be modified by the user.\n\nRead-only elements are included in tabbing navigation.\n\nRead-only elements may be successful.\n\nThe following elements support the readonly attribute: INPUT and TEXTAREA.\n\nHow read-only elements are rendered depends on the user agent.\n\n17.13 Form submission\n\nThe following sections explain how user agents submit form data to form processing agents.\n\n17.13.1 Form submission method\n\nThe method attribute of the FORM element specifies the HTTP method used to send the form to the processing agent. This attribute may take two values:\n\nget: With the HTTP \"get\" method, the form data set is appended to the URI specified by the action attribute (with a question-mark (\"?\") as separator) and this new URI is sent to the processing agent.\n\npost: With the HTTP \"post\" method, the form data set is included in the body of the form and sent to the processing agent.\n\nThe \"get\" method should be used when the form is idempotent (i.e., causes no side-effects). Many database searches have no visible side-effects and make ideal applications for the \"get\" method.\n\nIf the service associated with the processing of a form causes side effects (for example, if the form modifies a database or subscription to a service), the \"post\" method should be used.\n\n17.13.2 Successful controls\n\nA successful control is \"valid\" for submission. Every successful control has its control name paired with its current value as part of the submitted form data set. A successful control must be defined within a FORM element and must have a control name.\n\nHowever:\n\nControls that are disabled cannot be successful.\n\nIf a form contains more than one submit button, only the activated submit button is successful.\n\nAll \"on\" checkboxes may be successful.\n\nFor radio buttons that share the same value of the name attribute, only the \"on\" radio button may be successful.\n\nFor menus, the control name is provided by a SELECT element and values are provided by OPTION elements. Only selected options may be successful. When no options are selected, the control is not successful and neither the name nor any values are submitted to the server when the form is submitted.\n\nThe current value of a file select is a list of one or more file names. Upon submission of the form, the contents of each file are submitted with the rest of the form data. The file contents are packaged according to the form's content type.\n\nThe current value of an object control is determined by the object's implementation.\n\nIf a control doesn't have a current value when the form is submitted, user agents are not required to treat it as a successful control.\n\nFurthermore, user agents should not consider the following controls successful:\n\nReset buttons.\n\nOBJECT elements whose declare attribute has been set.\n\nHidden controls and controls that are not rendered because of style sheet settings may still be successful. For example:\n\n<FORM action=\"...\" method=\"post\"> <P> <INPUT type=\"password\" style=\"display:none\" name=\"invisible-password\" value=\"mypassword\"> </FORM>\n\nwill still cause a value to be paired with the name \"invisible-password\" and submitted with the form.\n\n17.13.3 Processing form data\n\nWhen the user submits a form (e.g., by activating a submit button), the user agent processes it as follows.\n\nStep one: Identify the successful controls\n\nStep two: Build a form data set\n\nA form data set is a sequence of control-name/current-value pairs constructed from successful controls\n\nStep three: Encode the form data set\n\nThe form data set is then encoded according to the content type specified by the enctype attribute of the FORM element.\n\nStep four: Submit the encoded form data set\n\nFinally, the encoded data is sent to the processing agent designated by the action attribute using the protocol specified by the method attribute.\n\nThis specification does not specify all valid submission methods or content types that may be used with forms. However, HTML 4 user agents must support the established conventions in the following cases:\n\nIf the method is \"get\" and the action is an HTTP URI, the user agent takes the value of action, appends a `?' to it, then appends the form data set, encoded using the \"application/x-www-form-urlencoded\" content type. The user agent then traverses the link to this URI. In this scenario, form data are restricted to ASCII codes.\n\nIf the method is \"post\" and the action is an HTTP URI, the user agent conducts an HTTP \"post\" transaction using the value of the action attribute and a message created according to the content type specified by the enctype attribute.\n\nFor any other value of action or method, behavior is unspecified.\n\nUser agents should render the response from the HTTP \"get\" and \"post\" transactions.\n\n17.13.4 Form content types\n\nThe enctype attribute of the FORM element specifies the content type used to encode the form data set for submission to the server. User agents must support the content types listed below. Behavior for other content types is unspecified.\n\nPlease also consult the section on escaping ampersands in URI attribute values.\n\napplication/x-www-form-urlencoded\n\nThis is the default content type. Forms submitted with this content type must be encoded as follows:\n\nControl names and values are escaped. Space characters are replaced by `+', and then reserved characters are escaped as described in [RFC1738], section 2.2: Non-alphanumeric characters are replaced by `%HH', a percent sign and two hexadecimal digits representing the ASCII code of the character. Line breaks are represented as \"CR LF\" pairs (i.e., `%0D%0A').\n\nThe control names/values are listed in the order they appear in the document. The name is separated from the value by `=' and name/value pairs are separated from each other by `&'.\n\nmultipart/form-data\n\nNote. Please consult [RFC2388] for additional information about file uploads, including backwards compatibility issues, the relationship between \"multipart/form-data\" and other content types, performance issues, etc.\n\nPlease consult the appendix for information about security issues for forms.\n\nThe content type \"application/x-www-form-urlencoded\" is inefficient for sending large quantities of binary data or text containing non-ASCII characters. The content type \"multipart/form-data\" should be used for submitting forms that contain files, non-ASCII data, and binary data.\n\nThe content \"multipart/form-data\" follows the rules of all multipart MIME data streams as outlined in [RFC2045]. The definition of \"multipart/form-data\" is available at the [IANA] registry.\n\nA \"multipart/form-data\" message contains a series of parts, each representing a successful control. The parts are sent to the processing agent in the same order the corresponding controls appear in the document stream. Part boundaries should not occur in any of the data; how this is done lies outside the scope of this specification.\n\nAs with all multipart MIME types, each part has an optional \"Content-Type\" header that defaults to \"text/plain\". User agents should supply the \"Content-Type\" header, accompanied by a \"charset\" parameter.\n\nEach part is expected to contain:\n\na \"Content-Disposition\" header whose value is \"form-data\".\n\na name attribute specifying the control name of the corresponding control. Control names originally encoded in non-ASCII character sets may be encoded using the method outlined in [RFC2045].\n\nThus, for example, for a control named \"mycontrol\", the corresponding part would be specified:\n\nContent-Disposition: form-data; name=\"mycontrol\"\n\nAs with all MIME transmissions, \"CR LF\" (i.e., `%0D%0A') is used to separate lines of data.\n\nEach part may be encoded and the \"Content-Transfer-Encoding\" header supplied if the value of that part does not conform to the default (7BIT) encoding (see [RFC2045], section 6)\n\nIf the contents of a file are submitted with a form, the file input should be identified by the appropriate content type (e.g., \"application/octet-stream\"). If multiple files are to be returned as the result of a single form entry, they should be returned as \"multipart/mixed\" embedded within the \"multipart/form-data\".\n\nThe user agent should attempt to supply a file name for each submitted file. The file name may be specified with the \"filename\" parameter of the 'Content-Disposition: form-data' header, or, in the case of multiple files, in a 'Content-Disposition: file' header of the subpart. If the file name of the client's operating system is not in US-ASCII, the file name might be approximated or encoded using the method of [RFC2045]. This is convenient for those cases where, for example, the uploaded files might contain references to each other (e.g., a TeX file and its \".sty\" auxiliary style description).\n\nThe following example illustrates \"multipart/form-data\" encoding. Suppose we have the following form:\n\n<FORM action=\"http://server.com/cgi/handle\" enctype=\"multipart/form-data\" method=\"post\"> <P> What is your name? <INPUT type=\"text\" name=\"submit-name\"><BR> What files are you sending? <INPUT type=\"file\" name=\"files\"><BR> <INPUT type=\"submit\" value=\"Send\"> <INPUT type=\"reset\"> </FORM>\n\nIf the user enters \"Larry\" in the text input, and selects the text file \"file1.txt\", the user agent might send back the following data:\n\nContent-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\"submit-name\" Larry --AaB03x Content-Disposition: form-data; name=\"files\"; filename=\"file1.txt\" Content-Type: text/plain ... contents of file1.txt ... --AaB03x--\n\nIf the user selected a second (image) file \"file2.gif\", the user agent might construct the parts as follows:\n\nContent-Type: multipart/form-data; boundary=AaB03x --AaB03x Content-Disposition: form-data; name=\"submit-name\" Larry --AaB03x Content-Disposition: form-data; name=\"files\" Content-Type: multipart/mixed; boundary=BbC04y --BbC04y Content-Disposition: file; filename=\"file1.txt\" Content-Type: text/plain ... contents of file1.txt ... --BbC04y Content-Disposition: file; filename=\"file2.gif\" Content-Type: image/gif Content-Transfer-Encoding: binary ...contents of file2.gif... --BbC04y-- --AaB03x--"
    }
}