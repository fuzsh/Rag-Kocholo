{
    "id": "dbpedia_1048_3",
    "rank": 66,
    "data": {
        "url": "https://stackoverflow.com/questions/538666/format-timedelta-to-string",
        "read_more_link": "",
        "language": "en",
        "title": "Format timedelta to string",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/XGN3h.jpg?s=64",
            "https://www.gravatar.com/avatar/a13b1b0721d8006247dc0e257c319f93?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/852534a6dc0ebba676dd18ccf507849c?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/ab82fd8b5ffe4d09c2bb5f9c14d34b09?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/03cdc3c813a8646f783f97f7c66b8f3f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/cdca0dc45085388c1b753104ce4c8648?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/087bc3a6b2fe0dbbf39ca49f40e2bac1?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wJK9n.jpg?s=64",
            "https://www.gravatar.com/avatar/763350fb057d43f204d70cd0d41b4355?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8063844ba80a593f6cf123309ce15c34?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3cc3616d759916fc7587fe664f37597a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/b464064be975b5cd11a74fe78377c0a1?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/70e672f6980b03825917f6d138420c2b?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5ca353c69e98c259967d5feb1995a953?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/c880f325d3b581289aef2423ad3920fe?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5e6ce1def86e084cf06ac3a5a7e2d74f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8f68811d64cd9fd18a9f82205137c8f0?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/7c9b0a8d7e3dfaaef677e873ce2f6ad9?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/ZytQV.png?s=64",
            "https://i.sstatic.net/DHKJ7.jpg?s=64",
            "https://i.sstatic.net/GjIVA.jpg?s=64",
            "https://i.sstatic.net/GHaou.jpg?s=64",
            "https://www.gravatar.com/avatar/28837002091f07ee1f9641358df399ee?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/vg5WA.png?s=64",
            "https://www.gravatar.com/avatar/ee6639a1fd8081b6a1562a44627dfb74?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/W22PA.jpg?s=64",
            "https://www.gravatar.com/avatar/aab62b03d8d6a4493a145e43c6bddaad?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/0470ca542bb1866d0a3cbf6f7084f455?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Gzsvz.png?s=64",
            "https://www.gravatar.com/avatar/8737392cf044113179304b4bca85002a?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/Zqidc.jpg?s=64",
            "https://i.sstatic.net/oc6b4.png?s=64",
            "https://www.gravatar.com/avatar/5d9a66a8bf0fa8e4eca29c82987751e0?s=64&d=identicon&r=PG",
            "https://lh4.googleusercontent.com/-1FfE-n9iDEI/AAAAAAAAAAI/AAAAAAAAAAA/GK9-_0WsIcI/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/20a2503101c11260874af67d15e343d3?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/Md0d6.png?s=64",
            "https://www.gravatar.com/avatar/f3a86f8cc241df775d008c0e57d9323e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/869402f85dcbabcef3da1ee61b88a45a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8462e3ca18ff7a5a50f76671f05c08f1?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://stackoverflow.com/posts/538666/ivc/6309?prg=efb8179d-f04f-449f-bc55-575866d9f6ae"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-02-11T20:40:43",
        "summary": "",
        "meta_description": "I'm having trouble formatting a datetime.timedelta object.\n\nHere's what I'm trying to do: \n  I have a list of objects and one of the members of the class of the object is a timedelta object that sh...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/538666/format-timedelta-to-string",
        "text": "As you know, you can get the total_seconds from a timedelta object by accessing the .seconds attribute.\n\nPython provides the builtin function divmod() which allows for:\n\ns = 13420 hours, remainder = divmod(s, 3600) minutes, seconds = divmod(remainder, 60) print('{:02}:{:02}:{:02}'.format(int(hours), int(minutes), int(seconds))) # result: 03:43:40\n\nor you can convert to hours and remainder by using a combination of modulo and subtraction:\n\n# arbitrary number of seconds s = 13420 # hours hours = s // 3600 # remaining seconds s = s - (hours * 3600) # minutes minutes = s // 60 # remaining seconds seconds = s - (minutes * 60) # total time print('{:02}:{:02}:{:02}'.format(int(hours), int(minutes), int(seconds))) # result: 03:43:40\n\nI personally use the humanize library for this:\n\n>>> import datetime >>> humanize.naturalday(datetime.datetime.now()) 'today' >>> humanize.naturalday(datetime.datetime.now() - datetime.timedelta(days=1)) 'yesterday' >>> humanize.naturalday(datetime.date(2007, 6, 5)) 'Jun 05' >>> humanize.naturaldate(datetime.date(2007, 6, 5)) 'Jun 05 2007' >>> humanize.naturaltime(datetime.datetime.now() - datetime.timedelta(seconds=1)) 'a second ago' >>> humanize.naturaltime(datetime.datetime.now() - datetime.timedelta(seconds=3600)) 'an hour ago'\n\nOf course, it doesn't give you exactly the answer you were looking for (which is, indeed, str(timeA - timeB), but I have found that once you go beyond a few hours, the display becomes quickly unreadable. humanize has support for much larger values that are human-readable, and is also well localized.\n\nIt's inspired by Django's contrib.humanize module, apparently, so since you are using Django, you should probably use that.\n\nHere is a general purpose function for converting either a timedelta object or a regular number (in the form of seconds or minutes, etc.) to a nicely formatted string. I took mpounsett's fantastic answer on a duplicate question, made it a bit more flexible, improved readibility, and added documentation.\n\nYou will find that it is the most flexible answer here so far since it allows you to:\n\nCustomize the string format on the fly instead of it being hard-coded.\n\nLeave out certain time intervals without a problem (see examples below).\n\nFunction:\n\nfrom string import Formatter from datetime import timedelta def strfdelta(tdelta, fmt='{D:02}d {H:02}h {M:02}m {S:02}s', inputtype='timedelta'): \"\"\"Convert a datetime.timedelta object or a regular number to a custom- formatted string, just like the stftime() method does for datetime.datetime objects. The fmt argument allows custom formatting to be specified. Fields can include seconds, minutes, hours, days, and weeks. Each field is optional. Some examples: '{D:02}d {H:02}h {M:02}m {S:02}s' --> '05d 08h 04m 02s' (default) '{W}w {D}d {H}:{M:02}:{S:02}' --> '4w 5d 8:04:02' '{D:2}d {H:2}:{M:02}:{S:02}' --> ' 5d 8:04:02' '{H}h {S}s' --> '72h 800s' The inputtype argument allows tdelta to be a regular number instead of the default, which is a datetime.timedelta object. Valid inputtype strings: 's', 'seconds', 'm', 'minutes', 'h', 'hours', 'd', 'days', 'w', 'weeks' \"\"\" # Convert tdelta to integer seconds. if inputtype == 'timedelta': remainder = int(tdelta.total_seconds()) elif inputtype in ['s', 'seconds']: remainder = int(tdelta) elif inputtype in ['m', 'minutes']: remainder = int(tdelta)*60 elif inputtype in ['h', 'hours']: remainder = int(tdelta)*3600 elif inputtype in ['d', 'days']: remainder = int(tdelta)*86400 elif inputtype in ['w', 'weeks']: remainder = int(tdelta)*604800 f = Formatter() desired_fields = [field_tuple[1] for field_tuple in f.parse(fmt)] possible_fields = ('W', 'D', 'H', 'M', 'S') constants = {'W': 604800, 'D': 86400, 'H': 3600, 'M': 60, 'S': 1} values = {} for field in possible_fields: if field in desired_fields and field in constants: values[field], remainder = divmod(remainder, constants[field]) return f.format(fmt, **values)\n\nDemo:\n\n>>> td = timedelta(days=2, hours=3, minutes=5, seconds=8, microseconds=340) >>> print strfdelta(td) 02d 03h 05m 08s >>> print strfdelta(td, '{D}d {H}:{M:02}:{S:02}') 2d 3:05:08 >>> print strfdelta(td, '{D:2}d {H:2}:{M:02}:{S:02}') 2d 3:05:08 >>> print strfdelta(td, '{H}h {S}s') 51h 308s >>> print strfdelta(12304, inputtype='s') 00d 03h 25m 04s >>> print strfdelta(620, '{H}:{M:02}', 'm') 10:20 >>> print strfdelta(49, '{D}d {H}h', 'h') 2d 1h\n\nHe already has a timedelta object so why not use its built-in method total_seconds() to convert it to seconds, then use divmod() to get hours and minutes?\n\nhours, remainder = divmod(myTimeDelta.total_seconds(), 3600) minutes, seconds = divmod(remainder, 60) # Formatted only for hours and minutes as requested print '%s:%s' % (hours, minutes)\n\nThis works regardless if the time delta has even days or years.\n\nI know that this is an old answered question, but I use datetime.utcfromtimestamp() for this. It takes the number of seconds and returns a datetime that can be formatted like any other datetime.\n\nduration = datetime.utcfromtimestamp((end - begin).total_seconds()) print(duration.strftime('%H:%M'))\n\nAs long as you stay in the legal ranges for the time parts this should work, i.e. it doesn't return 1234:35 as hours are <= 23.\n\nMy datetime.timedelta objects went greater than a day. So here is a further problem. All the discussion above assumes less than a day. A timedelta is actually a tuple of days, seconds and microseconds. The above discussion should use td.seconds as joe did, but if you have days it is NOT included in the seconds value.\n\nI am getting a span of time between 2 datetimes and printing days and hours.\n\nspan = currentdt - previousdt print '%d,%d\\n' % (span.days,span.seconds/3600)\n\nQuestioner wants a nicer format than the typical:\n\n>>> import datetime >>> datetime.timedelta(seconds=41000) datetime.timedelta(0, 41000) >>> str(datetime.timedelta(seconds=41000)) '11:23:20' >>> str(datetime.timedelta(seconds=4102.33)) '1:08:22.330000' >>> str(datetime.timedelta(seconds=413302.33)) '4 days, 18:48:22.330000'\n\nSo, really there's two formats, one where days are 0 and it's left out, and another where there's text \"n days, h:m:s\". But, the seconds may have fractions, and there's no leading zeroes in the printouts, so columns are messy.\n\nHere's my routine, if you like it:\n\ndef printNiceTimeDelta(stime, etime): delay = datetime.timedelta(seconds=(etime - stime)) if (delay.days > 0): out = str(delay).replace(\" days, \", \":\") else: out = \"0:\" + str(delay) outAr = out.split(':') outAr = [\"%02d\" % (int(float(x))) for x in outAr] out = \":\".join(outAr) return out\n\nthis returns output as dd:hh:mm:ss format:\n\n00:00:00:15 00:00:00:19 02:01:31:40 02:01:32:22\n\nI did think about adding years to this, but this is left as an exercise for the reader, since the output is safe at over 1 year:\n\n>>> str(datetime.timedelta(seconds=99999999)) '1157 days, 9:46:39'\n\nOne liner. Since timedeltas do not offer datetime's strftime, bring the timedelta back to a datetime, and use stftime.\n\nThis can not only achieve the OP's requested format Hours:Minutes, now you can leverage the full formatting power of datetime's strftime, should your requirements change to another representation.\n\nimport datetime td = datetime.timedelta(hours=2, minutes=10, seconds=5) print(td) print(datetime.datetime.strftime(datetime.datetime.strptime(str(td), \"%H:%M:%S\"), \"%H:%M\")) Output: 2:10:05 02:10\n\nThis also solves the annoyance that timedeltas are formatted into strings as H:MM:SS rather than HH:MM:SS, which lead me to this problem, and the solution I've shared.\n\ndef seconds_to_time_left_string(total_seconds): s = int(total_seconds) years = s // 31104000 if years > 1: return '%d years' % years s = s - (years * 31104000) months = s // 2592000 if years == 1: r = 'one year' if months > 0: r += ' and %d months' % months return r if months > 1: return '%d months' % months s = s - (months * 2592000) days = s // 86400 if months == 1: r = 'one month' if days > 0: r += ' and %d days' % days return r if days > 1: return '%d days' % days s = s - (days * 86400) hours = s // 3600 if days == 1: r = 'one day' if hours > 0: r += ' and %d hours' % hours return r s = s - (hours * 3600) minutes = s // 60 seconds = s - (minutes * 60) if hours >= 6: return '%d hours' % hours if hours >= 1: r = '%d hours' % hours if hours == 1: r = 'one hour' if minutes > 0: r += ' and %d minutes' % minutes return r if minutes == 1: r = 'one minute' if seconds > 0: r += ' and %d seconds' % seconds return r if minutes == 0: return '%d seconds' % seconds if seconds == 0: return '%d minutes' % minutes return '%d minutes and %d seconds' % (minutes, seconds) for i in range(10): print pow(8, i), seconds_to_time_left_string(pow(8, i)) Output: 1 1 seconds 8 8 seconds 64 one minute and 4 seconds 512 8 minutes and 32 seconds 4096 one hour and 8 minutes 32768 9 hours 262144 3 days 2097152 24 days 16777216 6 months 134217728 4 years\n\nI had a similar problem with the output of overtime calculation at work. The value should always show up in HH:MM, even when it is greater than one day and the value can get negative. I combined some of the shown solutions and maybe someone else find this solution useful. I realized that if the timedelta value is negative most of the shown solutions with the divmod method doesn't work out of the box:\n\ndef td2HHMMstr(td): '''Convert timedelta objects to a HH:MM string with (+/-) sign''' if td < datetime.timedelta(seconds=0): sign='-' td = -td else: sign = '' tdhours, rem = divmod(td.total_seconds(), 3600) tdminutes, rem = divmod(rem, 60) tdstr = '{}{:}:{:02d}'.format(sign, int(tdhours), int(tdminutes)) return tdstr\n\ntimedelta to HH:MM string:\n\ntd2HHMMstr(datetime.timedelta(hours=1, minutes=45)) '1:54' td2HHMMstr(datetime.timedelta(days=2, hours=3, minutes=2)) '51:02' td2HHMMstr(datetime.timedelta(hours=-3, minutes=-2)) '-3:02' td2HHMMstr(datetime.timedelta(days=-35, hours=-3, minutes=-2)) '-843:02'\n\nI continued from MarredCheese's answer and added year, month, millicesond and microsecond\n\nall numbers are formatted to integer except for second, thus the fraction of a second can be customized.\n\n@kfmfe04 asked for fraction of a second so I posted this solution\n\nIn the main there are some examples.\n\nfrom string import Formatter from datetime import timedelta def strfdelta(tdelta, fmt='{D:02}d {H:02}h {M:02}m {S:02.0f}s', inputtype='timedelta'): \"\"\"Convert a datetime.timedelta object or a regular number to a custom- formatted string, just like the stftime() method does for datetime.datetime objects. The fmt argument allows custom formatting to be specified. Fields can include seconds, minutes, hours, days, and weeks. Each field is optional. Some examples: '{D:02}d {H:02}h {M:02}m {S:02.0f}s' --> '05d 08h 04m 02s' (default) '{W}w {D}d {H}:{M:02}:{S:02.0f}' --> '4w 5d 8:04:02' '{D:2}d {H:2}:{M:02}:{S:02.0f}' --> ' 5d 8:04:02' '{H}h {S:.0f}s' --> '72h 800s' The inputtype argument allows tdelta to be a regular number instead of the default, which is a datetime.timedelta object. Valid inputtype strings: 's', 'seconds', 'm', 'minutes', 'h', 'hours', 'd', 'days', 'w', 'weeks' \"\"\" # Convert tdelta to integer seconds. if inputtype == 'timedelta': remainder = tdelta.total_seconds() elif inputtype in ['s', 'seconds']: remainder = float(tdelta) elif inputtype in ['m', 'minutes']: remainder = float(tdelta)*60 elif inputtype in ['h', 'hours']: remainder = float(tdelta)*3600 elif inputtype in ['d', 'days']: remainder = float(tdelta)*86400 elif inputtype in ['w', 'weeks']: remainder = float(tdelta)*604800 f = Formatter() desired_fields = [field_tuple[1] for field_tuple in f.parse(fmt)] possible_fields = ('Y','m','W', 'D', 'H', 'M', 'S', 'mS', 'µS') constants = {'Y':86400*365.24,'m': 86400*30.44 ,'W': 604800, 'D': 86400, 'H': 3600, 'M': 60, 'S': 1, 'mS': 1/pow(10,3) , 'µS':1/pow(10,6)} values = {} for field in possible_fields: if field in desired_fields and field in constants: Quotient, remainder = divmod(remainder, constants[field]) values[field] = int(Quotient) if field != 'S' else Quotient + remainder return f.format(fmt, **values) if __name__ == \"__main__\": td = timedelta(days=717, hours=3, minutes=5, seconds=8, microseconds=3549) print(strfdelta(td,'{Y} years {m} months {W} weeks {D} days {H:02}:{M:02}:{S:02}')) print(strfdelta(td,'{m} months {W} weeks {D} days {H:02}:{M:02}:{S:02.4f}')) td = timedelta( seconds=8, microseconds=8549) print(strfdelta(td,'{S} seconds {mS} milliseconds {µS} microseconds')) print(strfdelta(td,'{S:.0f} seconds {mS} milliseconds {µS} microseconds')) print(strfdelta(pow(10,7),inputtype='s'))\n\nOutput:\n\n1 years 11 months 2 weeks 3 days 01:09:56.00354900211096 23 months 2 weeks 3 days 00:12:20.0035 8.008549 seconds 8 milliseconds 549 microseconds 8 seconds 8 milliseconds 549 microseconds 115d 17h 46m 40s\n\nIf you happen to have IPython in your packages (you should), it has (up to now, anyway) a very nice formatter for durations (in float seconds). That is used in various places, for example by the %%time cell magic. I like the format it produces for short durations:\n\n>>> from IPython.core.magics.execution import _format_time >>> >>> for v in range(-9, 10, 2): ... dt = 1.25 * 10**v ... print(_format_time(dt)) 1.25 ns 125 ns 12.5 µs 1.25 ms 125 ms 12.5 s 20min 50s 1d 10h 43min 20s 144d 16h 13min 20s 14467d 14h 13min 20s\n\ntimedelta to string, use for print running time info.\n\ndef strfdelta_round(tdelta, round_period='second'): \"\"\"timedelta to string, use for measure running time attend period from days downto smaller period, round to minimum period omit zero value period \"\"\" period_names = ('day', 'hour', 'minute', 'second', 'millisecond') if round_period not in period_names: raise Exception(f'round_period \"{round_period}\" invalid, should be one of {\",\".join(period_names)}') period_seconds = (86400, 3600, 60, 1, 1/pow(10,3)) period_desc = ('days', 'hours', 'mins', 'secs', 'msecs') round_i = period_names.index(round_period) s = '' remainder = tdelta.total_seconds() for i in range(len(period_names)): q, remainder = divmod(remainder, period_seconds[i]) if int(q)>0: if not len(s)==0: s += ' ' s += f'{q:.0f} {period_desc[i]}' if i==round_i: break if i==round_i+1: s += f'{remainder} {period_desc[round_i]}' break return s\n\ne.g. auto omit zero leading period:\n\n>>> td = timedelta(days=0, hours=2, minutes=5, seconds=8, microseconds=3549) >>> strfdelta_round(td, 'second') '2 hours 5 mins 8 secs'\n\nor omit middle zero period:\n\n>>> td = timedelta(days=2, hours=0, minutes=5, seconds=8, microseconds=3549) >>> strfdelta_round(td, 'millisecond') '2 days 5 mins 8 secs 3 msecs'\n\nor round to minutes, omit below minutes:\n\n>>> td = timedelta(days=1, hours=2, minutes=5, seconds=8, microseconds=3549) >>> strfdelta_round(td, 'minute') '1 days 2 hours 5 mins'\n\nI wanted to do this so wrote a simple function. It works great for me and is quite versatile (supports years to microseconds, and any granularity level, e.g. you can pick between '2 days, 4 hours, 48 minutes' and '2 days, 4 hours' and '2 days, 4.8 hours', etc.\n\ndef pretty_print_timedelta(t, max_components=None, max_decimal_places=2): ''' Print a pretty string for a timedelta. For example datetime.timedelta(days=2, seconds=17280) will be printed as '2 days, 4 hours, 48 minutes'. Setting max_components to e.g. 1 will change this to '2.2 days', where the number of decimal points can also be set. ''' time_scales = [timedelta(days=365), timedelta(days=1), timedelta(hours=1), timedelta(minutes=1), timedelta(seconds=1), timedelta(microseconds=1000), timedelta(microseconds=1)] time_scale_names_dict = {timedelta(days=365): 'year', timedelta(days=1): 'day', timedelta(hours=1): 'hour', timedelta(minutes=1): 'minute', timedelta(seconds=1): 'second', timedelta(microseconds=1000): 'millisecond', timedelta(microseconds=1): 'microsecond'} count = 0 txt = '' first = True for scale in time_scales: if t >= scale: count += 1 if count == max_components: n = t / scale else: n = int(t / scale) t -= n*scale n_txt = str(round(n, max_decimal_places)) if n_txt[-2:]=='.0': n_txt = n_txt[:-2] txt += '{}{} {}{}'.format('' if first else ', ', n_txt, time_scale_names_dict[scale], 's' if n>1 else '', ) if first: first = False if len(txt) == 0: txt = 'none' return txt\n\nI had the same problem and I am using pandas Timedeltas, didn't want to bring in additional dependencies (another answer mentions humanfriendly) so I wrote this small function to print out only the relevant information:\n\ndef format_timedelta(td: pd.Timedelta) -> str: if pd.isnull(td): return str(td) else: c = td.components._asdict() return \", \".join(f\"{n} {unit}\" for unit, n in c.items() if n)\n\nFor example, pd.Timedelta(hours=3, seconds=12) would print as 3 hours, 12 seconds."
    }
}