{
    "id": "dbpedia_1048_2",
    "rank": 68,
    "data": {
        "url": "https://stackoverflow.com/questions/3443607/how-can-i-tell-where-my-python-script-is-hanging",
        "read_more_link": "",
        "language": "en",
        "title": "How can I tell where my python script is hanging?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/cf2e79eb6971da96eb26b3fc5c9514cd?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6a72c6b580bfbed32b987bad16e88770?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/d1214f1e8d55a5e74924e7c6fb203b69?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/c8053e7d7aac8830f25a47135ce07bec?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/VqecB.png?s=64",
            "https://www.gravatar.com/avatar/d1214f1e8d55a5e74924e7c6fb203b69?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/89d887b50262bbe10225d36d974fdb0c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/9fe764ce8d45fcf5027e811b9cd113c1?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/448da181fc6df1794b855848b84f0be9?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/vAAS0.png?s=64",
            "https://i.sstatic.net/zyvMA.jpg?s=64",
            "https://www.gravatar.com/avatar/4437e31fa0c1333736b30c9543891198?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e4e57654afa125c76a8ae6fea929f356?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/c2c732bbf13dc96670b210b3c0c1ead5?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/4d7362890bb5e054a1f827c31ef96df1?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/0d21ff62ddefec180b387071683fb402?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/34510ef7cec8be1906f986d1c4db497d?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/f9a38df7ddf75a46b36c6a6ef5f98381?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/3443607/ivc/657d?prg=4adeb7d5-4849-4041-b1a6-0d820c1a4d90"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2010-08-09T19:46:47",
        "summary": "",
        "meta_description": "So I'm debugging my python program and have encountered a bug that makes the program hang, as if in an infinite loop. Now, I had a problem with an infinite loop before, but when it hung up I could ...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/3443607/how-can-i-tell-where-my-python-script-is-hanging",
        "text": "Let's assume that you are running your program as:\n\npython YOURSCRIPT.py\n\nTry running your program as:\n\npython -m trace --trace YOURSCRIPT.py\n\nAnd have some patience while lots of stuff is printed on the screen. If you have an infinite loop, it will go on for-ever (halting problem). If it gets stuck somewhere, then mostly you are stuck on I/O or it is a deadlock.\n\nFrom Python 3.3 on there is a built in faulthandler module. To print a stack trace for all the threads when a normally fatal signal occurs:\n\nimport faulthandler faulthandler.enable()\n\nFor a process that is hung, it is more useful to setup faulthandler to print stack traces on demand. This can be done with:\n\nimport faulthandler import signal faulthandler.register(signal.SIGUSR1.value)\n\nThen once the process becomes hung you can send a signal to trigger the printing of the stack trace:\n\n$ python myscript.py & [1] <pid> $ kill -s SIGUSR1 <pid>\n\nThis signal won't kill the process, and you can send multiple times to see stack traces at different points in the execution.\n\nNote that Python 3.5 or later is required for signal.SIGUSR1. For an older version, you can just hardcode the signal number (10 for most common linux architectures).\n\nfaulthandler.dump_traceback can be used together with threading.enumerate to identify threads having daemon=False to narrow down to hanging threads by their hex ID via hex(t.ident).\n\nIf your program is too big and complex to be viable for single stepping with pdb or printing every line with the trace module then you could try a trick from my days of 8-bit games programming. From Python 2.5 onwards pdb has the ability to associate code with a breakpoint by using the commands command. You can use this to print a message and continue running:\n\n(Pdb) commands 1 (com) print \"*** Breakpoint 1 ***\" (com) continue (com) end (Pdb)\n\nThis will print a message and carry on running when breakpoint 1 is hit. Define similar commands for a few other breakpoints.\n\nYou can use this to do a kind of binary search of your code. Attach breakpoints at key places in the code and run it until it hangs. You can tell from the last message which was the last breakpoint it hit. You can then move the other breakpoints and re-run to narrow down the place in the code where it hangs. Rinse and repeat.\n\nIncidentally on the 8-bit micros (Commodore 64, Spectrum etc) you could poke a value into a registry location to change the colour of the border round the screen. I used to set up a few breakpoints to do this with different colours, so when the program ran it would give a psychedelic rainbow display until it hung, then the border would change to a single colour that told you what the last breakpoint was. You could also get a good feel for the relative performance of different sections of code by the amount of each colour in the rainbow. Sometimes I miss that simplicity in these new fangled \"Windows\" machines.\n\nMultithreaded dæmon; using pyrasite to inspect a running program\n\nI had a multithreaded dæmon that would sometimes get stuck after hours, sometimes after weeks. Running it through a debugger would be not feasible and perhaps not even helpful, as debugging multithreaded or multiprocess programs can be painful. Running it through trace might fill up gigabytes if not terabytes before it would get stuck. The second time the dæmon appeared to hang, I wanted to know right away where it was, without restarting it, adding inspection code, running it through a debugger, and waiting for hours, days, or weeks for it to hang again for circumstances yet to be investigated.\n\nI was rescued by pyrasite, which lets the user connect to a running Python process and interactively inspect frames (example inspired by this gist):\n\n$ pyrasite-shell 1071 # 1071 is the Process ID (PID) Pyrasite Shell 2.0 Connected to '/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/bin/python3.8 /opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/bin/satpy_launcher.py -n localhost /opt/pytroll/pytroll_inst/config/trollflow2.yaml' Python 3.8.6 | packaged by conda-forge | (default, Dec 26 2020, 05:05:16) [GCC 9.3.0] on linux Type \"help\", \"copyright\", \"credits\" or \"license\" for more information. (DistantInteractiveConsole) >>> import sys >>> sys._current_frames() {139652793759488: <frame at 0x7f034b2c9040, file '<console>', line 1, code <module>>, 139653520578368: <frame at 0x7f034b232ac0, file '/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py', line 112, code __init__>}\n\nThe first frame is not informative; that's our own pyrasite shell. The second frame, however, reveals that currently our script is stuck in the module pyresample.spherical in line 112. We can use the traceback module to get a full traceback:\n\n>>> import traceback >>> traceback.print_stack(list(sys._current_frames().values())[1]) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/bin/satpy_launcher.py\", line 80, in <module> main() File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/bin/satpy_launcher.py\", line 75, in main run(prod_list, topics=topics, test_message=test_message, File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/trollflow2/launcher.py\", line 152, in run proc.start() File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/process.py\", line 121, in start self._popen = self._Popen(self) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/context.py\", line 224, in _Popen return _default_context.get_context().Process._Popen(process_obj) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/context.py\", line 277, in _Popen return Popen(process_obj) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/popen_fork.py\", line 19, in __init__ self._launch(process_obj) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/popen_fork.py\", line 75, in _launch code = process_obj._bootstrap(parent_sentinel=child_r) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/process.py\", line 315, in _bootstrap self.run() File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/multiprocessing/process.py\", line 108, in run self._target(*self._args, **self._kwargs) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/trollflow2/launcher.py\", line 268, in process cwrk.pop('fun')(job, **cwrk) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/trollflow2/plugins/__init__.py\", line 403, in covers cov = get_scene_coverage(platform_name, start_time, end_time, File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/trollflow2/plugins/__init__.py\", line 425, in get_scene_coverage return 100 * overpass.area_coverage(area_def) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/trollsched/satpass.py\", line 242, in area_coverage inter = self.boundary.contour_poly.intersection(area_boundary) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 494, in intersection return self._bool_oper(other, -1) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 475, in _bool_oper inter, edge2 = edge1.get_next_intersection(narcs2, inter) File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 326, in get_next_intersection return None, None File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 298, in intersection return None File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 264, in intersections return (SCoordinate(lon, lat), File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 62, in cross2cart return res File \"/opt/pytroll/pytroll_inst/miniconda3/envs/pytroll-py38/lib/python3.8/site-packages/pyresample/spherical.py\", line 112, in __init__ self.cart = np.array(cart)\n\nand we can use all the power of Pythons introspection to inspect the stack in order to help us reconstruct the circumstances where this got stuck.\n\nIt's easier to prevent these hang-ups than it is to debug them.\n\nFirst: for loops are very, very hard to get stuck in a situation where the loop won't terminate. Very hard.\n\nSecond: while loops are relatively easy to get stuck in a loop.\n\nThe first pass is to check every while loop to see if it must be a while loop. Often you can replace while constructs with for, and you'll correct your problem by rethinking your loop.\n\nIf you cannot replace a while loop with for, then you simply have to prove that the expression in the while statement must change every time through the loop. This isn't that hard to prove.\n\nLook at all the condition in the loop. Call this T.\n\nLook at all the logic branches in the body of the loop. Is there any way to get through the loop without making a change to the condition, T?\n\nYes? That's your bug. That logic path is wrong.\n\nNo? Excellent, that loop must terminate.\n\nWow ! Seems you added so much code in one go without testing it that you can't say what code was added just before program started to hang... (the most likely cause of problem).\n\nSeriously, you should code by small steps and test each one individually (ideally doing TDD).\n\nFor your exact problem of spotting what python code is running and ctrl-c does not work, I will try a raw guess: did you used some except: catching all exceptions indistinctly. If you did so in a loop (and continue loop after managing exception), it's a very likely reason why ctrl-c does not work : it's catched by this exception. Change to except Exception: and it should not be catched any more (there is other possibilities for ctrl+c not working like thread management as another poster suggested, but I believe the above reason is more likely).\n\nexception KeyboardInterrupt\n\nRaised when the user hits the interrupt key (normally Control-C or Delete).\n\nDuring execution, a check for interrupts is made regularly. Interrupts typed when a built-in function input() or raw_input() is waiting for input also raise this exception. The exception inherits from BaseException so as to not be accidentally caught by code that catches Exception and thus prevent the interpreter from exiting.\n\nChanged in version 2.5: Changed to inherit from BaseException."
    }
}