{
    "id": "correct_starring_00071_3",
    "rank": 17,
    "data": {
        "url": "https://blogs.oracle.com/database/post/genai-rag-likes-explicit-relationships-use-graphs",
        "read_more_link": "",
        "language": "en",
        "title": "GenAI RAG Likes Explicit Relationships: Use Graphs!",
        "top_image": "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT56458F44C29F4706B1B03E4211BC3EF9/Medium?format=jpg&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7",
        "meta_img": "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT56458F44C29F4706B1B03E4211BC3EF9/Medium?format=jpg&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7",
        "images": [
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT35F2F9D366E74ECAB9E51350F88E99FD/Thumbnail?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT56458F44C29F4706B1B03E4211BC3EF9/Medium?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT3B8009C7B21241D6822C6A3BE5722071/Medium?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT2D7A7428336C43D0834A98B896495885/Medium?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONTD5F0F77DAFC04E24B926E70EADCBA3BD/Medium?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT2D7A7428336C43D0834A98B896495885/Medium?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONTD5F0F77DAFC04E24B926E70EADCBA3BD/Medium?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg",
            "https://blogs.oracle.com/content/published/api/v1.1/assets/CONT35F2F9D366E74ECAB9E51350F88E99FD/Thumbnail?cb=_cache_1b4c&channelToken=af5d837e3d34400dbe9ae6cec73ee9b7&format=jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Graph",
            "Artificial Intelligence"
        ],
        "tags": null,
        "authors": [
            "Phil Cannata"
        ],
        "publish_date": "2024-05-16T00:00:00",
        "summary": "",
        "meta_description": "Generative AI is only as good as the data it is trained on.  How can additional data be added?  This is where RAG comes in, RAG can help generate better output.  Graphs provide additional context to RAG because they can model relationships between concepts in any given domain. Let us look at the basics of graphs in this blog and how they can help genAI.",
        "meta_lang": "en",
        "meta_favicon": "../_cache_1b4c/_themesdelivery/Blogs-New-Theme/assets/img/logo.ico",
        "meta_site_name": "",
        "canonical_link": "https://blogs.oracle.com/database/post/genai-rag-likes-explicit-relationships-use-graphs",
        "text": "If you google “rag knowledge graphs” you will find numerous articles and videos extolling the benefit of combining RAG and “Knowledge Graphs”. This benefit mainly comes from making relationships EXPLICIT rather than implicit. We will see how a graph data model can help represent explicit relationships and examine how that can be done with two popular graph models, Property Graphs and RDF Knowledge Graphs. Oracle Graph supports both models.\n\nTo make things confusing, in the fast moving world of genAI people call Property Graphs as Knowledge Graphs but they don’t mean RDF Knowledge Graphs. Many Property Graph vendors highlight how Property Graphs can represent Knowledge Graphs.\n\nAlmost all corporations store data in relational databases as tables like this,\n\nMOVIE_GENRE Table\n\nID\n\nTitle\n\nGenre\n\nM1\n\nThe bird cage\n\nComedy\n\nM2\n\nOliver\n\nMusical\n\nA better database design for this would be to have two tables, one for movies and one for genres like this,\n\nMOVIE Table\n\nID\n\nTitle\n\nGenre\n\nM1\n\nThe bird cage\n\nG1\n\nM2\n\nOliver\n\nG2\n\nGENRE Table\n\nID\n\nType\n\nG1\n\nComedy\n\nG2\n\nMusical\n\nIn these two tables, there is a relationship between a movie and its genre, and that relationship is captured IMPLICITLY by the Genre column in the movie table. Data and implicit relationships can be stored in relational databases in this way.\n\nWe will see how to define relationships explicitly using Property Graphs (with the SQL/PGQ standard) and RDF Knowledge Graphs and the pros and cons of each. But more importantly, we will see that modeling concepts in addition to explicit relationships will be necessary for a proper integration of RAG and Knowledge Graphs. The future still holds a lot of changes for this area, best not to lock yourself into a single solution too early.\n\n1. GenAI RAG and Graphs\n\nWhat if instead of using tables, we stored data using nodes and edges like this,\n\nNow the genre relationship is EXPLICIT as a “Has genre” edge. This is what genAI RAG likes, explicit relationships, especially long chains of explicit relationships, which are very difficult to deal with in relational databases. Data and EXPLICIT relationships can be stored in what is called a Property Graph database. It can also be stored in an RDF Knowledge Graph database.\n\n2. GenAI RAG and SQL/PGQ\n\nIn 2023 an ISO standard for Property Graphs called SQL/PGQ (SQL/Property Graph Query) was defined, see here and here. The great thing about SQL/PGQ is that it makes a relational database look like a Property Graph, which means existing data doesn’t need to be moved into a separate database in order to expose explicit relationships to genAI RAG. In the Oracle Database implementation, the Property Graph is like a view on existing tables, so the data doesn’t even have to be moved to a separate schema. Here’s how it works.\n\nAssume we have the two tables (Movie and Genre) shown at the beginning of this blog. Using SQL/PGQ define the explicit relationships as follows:\n\ncreate property graph explicit_relationship_pg\n\nvertex tables (\n\nmovie\n\nkey (id)\n\nlabel movie\n\nproperties all columns,\n\ngenre\n\nkey (id)\n\nlabel genre\n\nproperties all columns\n\n)\n\nedge tables (\n\nmovie as gives_genre\n\nkey (id)\n\nsource key (id) references movie (id)\n\ndestination key (has_genre) references genre (id)\n\nlabel has_genre\n\nproperties all columns\n\n);\n\nLines 2 – 11 define the nodes (vertexes), lines 12 – 19 defines the edges. Now a query like the following can be used in a genAI prompt,\n\nselect ‘Movie’ as label, t.*\n\nfrom graph_table (explicit_relationship_pg\n\nmatch\n\n(m is movie) -[c is has_genre]-> (g is genre)\n\ncolumns (m.title as title,g.type as type)\n\n) t\n\norder by 1;\n\nLines 3- 5 are similar to the pattern specification syntax in any graph language, here they are wrapped inside a SQL query.\n\nOracle Database has the first implementation of SQL/PGQ.\n\nThe problems with this approach are:\n\nGenAI doesn’t understand SQL/PGQ yet, as it is a new standard.\n\nExplicit relationships can’t be inserted using SQL, as the standard does not yet include INSERT/UPDATE/DELETE for graphs. GenAI would need to be trained for this also.\n\n3. GenAI RAG and RDF Knowledge Graphs\n\nThere is another standard, the W3C Resource Description Framework (RDF) that can be used for implementing explicit relationships. Here’s how the movie example would be defined in an RDF Knowledge Graph. (For something more complete, see the family tree example in the Oracle RDF Graph documentation.)\n\n:M1 rdf:type :Movie .\n\n:M1 :name \"The bird cage\" .\n\n:G1 rdf:type :Genre .\n\n:G1 :type \"Comedy\" .\n\n:M1 :has_genre :G1\n\nLine 1 creates an M1 entity as a type (instance_of) Movie.\n\nLine 2 adds a name attribute with a value of “The bird cage” to the M1 entity.\n\nLine 3 creates a G1 entity as a type (instance_of) Genre.\n\nLine 4 adds a type attribute with a value of “Comedy” to the G1 entity.\n\nLine 5 creates an explicit relationship named “has_genre” between M1 and G1.\n\nNow a query like the following can be used in a genAI prompt (this query uses the W3C SPARQL language),\n\nSELECT ?movie ?title ?type\n\nWHERE\n\n{?movie :has_genre ?genre .\n\n?movie :title ?title .\n\n?genre :type ?type .\n\n}\n\nThis query returns,\n\nMovie Title Type\n\nM1 The bird cage Comedy\n\nIn contrast to Property Graphs and SQL/PGQ, RDF benefits from having been a standard for 20 years and the existence of plenty of linked data on the internet for training. GenAI can generate decent SPARQL queries if prompted with an ontology in a standard RDF serialization, and it seems to already be trained on public datasets like DBPedia.\n\nOracle Database has a complete implementation of RDF, which means you get RDF plus all of the enterprise features of an Oracle Database like transactional support, performance, security and reliability in a converged database. Oracle’s implementation is unique in that it is tightly integrated with SQL. This means an RDF database can be made to look like an SQL database as demonstrated in Building Rule-Based OLTP Systems Using Oracle RDF.\n\nAlthough the approach outlined above requires the RDF data to be stored in native RDF format, Oracle Database also provides a way of viewing and querying relational data as RDF using a mapping specified using the W3C RDB2RDF mapping standard. The need to convert relational data to RDF when presenting as output of SPARQL queries may introduce some performance overhead, however, for more complex queries.\n\n4. GenAI RAG and using RDF Knowledge Graphs to Model Concepts\n\nExplicit relationships are sometimes not enough to model data. The use of Classes and Subclasses, as in the following figure, adds more context.\n\nHere ComedyMovie is a subclass of Movie and “The bird cage” is in instance of ComedyMovie. This can be done in an RDF Knowledge Graph as follows.\n\n:ComedyMovie rdfs:subClassOf :Movie .\n\n:M1 rdf:type :ComedyMovie .\n\n:M1 :title \"The bird cage\" .\n\nHere’s one type of query for this database,\n\nSELECT ?movie ?title\n\nWHERE\n\n{?movie rdf:type :ComedyMovie .\n\n?movie :title ?title .\n\n}\n\nThis query returns the title of all comedy movies like this,\n\nWhat if we want the title of all movies? This query will do it,\n\nSELECT ?movie ?class ?title\n\nWHERE\n\n{?movie rdf:type/rdfs:subClassOf* :Movie .\n\n?movie rdf:type ?class .\n\n?movie :title ?title .\n\n}\n\nWhich returns,\n\nThis is an extremely important query to be able to do when you have classes and subclasses, i.e., to get instances of the subclasses at the class level.\n\nThis is made possible by this syntax “rdf:type/rdfs:subClassOf*”, which is called SPARQL Property Paths. They are defined here. Property paths enable a very flexible and powerful way of navigating possible routes through a graph between two graph nodes\n\nThere are many additional types of concepts that are supported by RDF Knowledge Graphs like attribute value inheritance, automatically providing the inverse of a relationship and inferring that one entity is the same as another entity. All of these help represent concepts and are not easily possible with Property Graphs.\n\nThese concepts and many more will eventually be needed for genAI RAG.\n\nSo, what is the downside of using RDF Knowledge Graphs and for genAI RAG? RDF Knowledge Graphs, while based on formal semantics and a mature standard, can have a steep learning curve. While RDF Knowledge Graphs work best when data is represented in a native RDF format, it is considered verbose and converting existing data into a native RDF format is perceived as a hurdle. The model can also be seen as rigid, while the Property Graph model is perceived as simple and flexible. But what’s discussed in Building Rule-Based OLTP Systems Using Oracle RDF eliminates this problem.\n\nAnother potential problem with this approach is that many of the RDF concepts require an extra step called “entailment” as part of the implementation. Entailment adds extra computational requirements and usually requires materialization of the data.\n\n5. Conclusion\n\nAt this point in time, are RDF Knowledge Graphs the best choice for RAG Knowledge Graphs because they can be used to provide a much more conceptual meaning to the data? Or are Property Graphs better because of their flexibility, and concepts will be handled by genAI in a different way? These questions are actively debated. It remains to be seen which graph model will best help genAI.\n\nAppendix - Oracle RDF Knowledge Graph Code used in this blog post\n\nBEGIN\n\nSEM_APIS.UPDATE_MODEL('movies',\n\n'PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nPREFIX movie: <http://movie.org/>\n\nINSERT DATA {\n\nmovie:M1 rdf:type movie:Movie .\n\nmovie:M1 movie:name \"The bird cage\" .\n\nmovie:G1 rdf:type movie:Genre .\n\nmovie:G1 movie:type \"Comdey\" .\n\nmovie:M1 movie:has_genre movie:G1\n\n}',\n\nnetwork_owner=>'RDFUSER',\n\nnetwork_name=>'NET1');\n\nEND;\n\n/\n\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\n\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\n\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\nPREFIX movie: <http://movie.org/>\n\nSELECT ?movie ?title ?type\n\nWHERE\n\n{?movie movie:has_genre ?genre .\n\n?movie movie:title ?title .\n\n?genre movie:type ?type .\n\n}\n\nBEGIN\n\nSEM_APIS.UPDATE_MODEL('MovieClasses',\n\n'PREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nPREFIX movie: <http://movie.org/>\n\nINSERT DATA {\n\nmovie:ComedyMovie rdfs:subClassOf movie:Movie .\n\nmovie:M1 rdf:type movie:ComedyMovie .\n\nmovie:M1 movie:title \"The bird cage\" .\n\n}',\n\nnetwork_owner=>'RDFUSER',\n\nnetwork_name=>'NET1');\n\nEND;\n\nQuery 1\n\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\n\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\n\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\nPREFIX movie: <http://movie.org/>\n\nSELECT ?movie ?title\n\nWHERE\n\n{?movie rdf:type movie:ComedyMovie .\n\n?movie movie:title ?title .\n\n}\n\nQuery 2\n\nPREFIX rdf: <http://www.w3.org/1999/02/22-rdf-syntax-ns#>\n\nPREFIX rdfs: <http://www.w3.org/2000/01/rdf-schema#>\n\nPREFIX owl: <http://www.w3.org/2002/07/owl#>\n\nPREFIX xsd: <http://www.w3.org/2001/XMLSchema#>\n\nPREFIX dc: <http://purl.org/dc/elements/1.1/>\n\nPREFIX foaf: <http://xmlns.com/foaf/0.1/>\n\nPREFIX movie: <http://movie.org/>\n\nSELECT ?movie ?class ?title\n\nWHERE\n\n{?movie rdf:type/rdfs:subClassOf* movie:Movie .\n\n?movie rdf:type ?class .\n\n?movie movie:title ?title ."
    }
}