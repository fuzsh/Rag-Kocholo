{
    "id": "dbpedia_4770_0",
    "rank": 71,
    "data": {
        "url": "https://wiki.tcl-lang.org/page/Algol",
        "read_more_link": "",
        "language": "en",
        "title": "Algol",
        "top_image": "https://wiki.tcl-lang.org/img/favicon.ico",
        "meta_img": "https://wiki.tcl-lang.org/img/favicon.ico",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Tclers wiki",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "A family of computing languages [L1 ] in the ancestry of nearly all others, but with little discernible direct relation to Tcl.\n\nALGOL has\n\nblock structure with nested scopes\n\ndynamic memory allocation\n\ncall-by-name parameter passing\n\ncall-by-value parameter passing\n\nrecursion\n\nALGOL does not have\n\nrecord structures\n\ncase or switch statements\n\nstandard input/output statements\n\nALGOL is not in the ancestry of FORTRAN (at least the early versions), LISP, COBOL, or SNOBOL.\n\nBut ALGOL is in the ancestry of C, and the list of things above that ALGOL \"has\" is a strong subset of the things that make C what it is. So I think the relation to Tcl is discernible after all.\n\nAM (24 april 2008) I can't resist commenting on this one: if I interpret some publications by Tony Hoare correctly, ALGOL was deliberately designed to not be related to the FORTRAN version of the time. (And as far as dynamic memory allocation is concerned, at that time, computers did not commonly have dynamic memory allocation facilities, so for a language like FORTRAN that was to run on as large a set of machines as possible, that was not an option.)\n\n(escargo - Actually, the FORTRAN-66 standard allowed for dynamic allocation of local data. While it was not usually done, coding that expected it could run into problems when going between compiler implementations that supported static allocations (DEC, for example) and those that supported dynamic allocations (Data General Eclipse, for example). Subroutine locals could be allocated on a stack if a compiler really wanted to minimize memory allocations. There is a difference between standard and industry standard.)\n\nALGOL may have call-by-name parameter passing, but C does not. Call by name is a very difficult to implement feature, if I understand it correctly.\n\nescargo 24 Apr 2008 - See the Wikipedia article on Jensen's Device [L2 ] for some of the power that can be derived from call by name.\n\nAM (24 april 2008) Awesome indeed, but also: awful! It is in no way clear from the function sum() itself that i and term are passed by name. It is only in the context of the actual use that this is clear. Of course, that means you can use the function in a more familiar context too, but still!\n\nescargo - Except call by name is not a choice; it's just the way things are in ALGOL. Tcl could be used to do something similar if all parameters to a proc were subjected to an uplevel so that they would be evaluated in the calling context whenever they were needed. That would essentially be manually coding a thunk [L3 ], which is possible to do in Tcl, but would look really ugly. I suppose somebody could write some scaffold to make it easier, but I don't know why anybody would think it would make things easier.\n\nAM I understand now, still this is a very different argument passing mechanism than C provides (essentially only by value - if you pass the address, you can change the data at that address, but you always need to use the address directly). To pass variables by name (not expressions though!) in Tcl, you could do:\n\nproc procByName {procName arglist body} {\n\nset upleveling {} set newargs {} foreach arg $arglist { lappend newargs __$arg append upleveling \"upvar 1 \\$__$arg $arg\\n\" } proc $procName $newargs \"$upleveling\\n$body\"\n\n}\n\nMind you: untested and it does not work with the args special argument.\n\nLars H: Actually, it seems to me that this call-by-name is very close to what one normally does in Tcl with e.g. foreach -- pass in both variable names and a script which can refer to these variables using their names as stated in the call. Calling this \"call-by-name\" feels strange, but we're familiar with the concept. From this point of view, an ALGOL call-by-name expression parameter could be viewed as being wrapped in the equivalent of an uplevel where it is used. (Wouldn't surprise me if the ALGOL semantics were much messier than that, however.)\n\nescargo 25 Apr 2008 - There is a Wikipedia article about evaluation strategies [L4 ], which includes call by name. That article also compares it to call by macro expansion. In Tcl, perhaps the appropriate way of implementing call by name would be to use subst on the proc body to replace the formal parameters with the actual parameters (which might be expressions) and evaluate the result using an uplevel. (Or something like that.)\n\nThere's no question that the power of Tcl for creating new control structures derives from something like call by name.\n\nI believe it was Edsger W. Dijkstra[L5 ] who observed that ALGOL was a great improvement on many of its successors. - Larry Smith\n\nescargo 24 Apr 2008 - Again, according to Wikipedia, \"Dijkstra was known to be a fan of ALGOL 60, and worked on the team that implemented the first compiler for that language.\"\n\nWJP: ALGOL is also the subject of one of the great literary works of computer science: C. H. Lindsey's Informal Introduction to ALGOL 68. Not only is it beautifully written, it is perhaps the only book ever published that is organizationally two-dimensional: it can be read either column-wise (chapter 1, section 1 -> chapter 1, section 2-> ...) or row-wise (chapter 1, section 1 -> chapter 2, section 1 ->...).\n\nLarry Smith ALGOL-68 is another critter entirely. It extended ALGOL (more correctly known as ALGOL-60) with record types and case statements, complex numbers, and input and output, as well as a lot of clean-up work to make it more orthogonal and easier to compile. It anticipated Oberon and Component Pascal allowing a case to type cast (treating the same variable as real, int or whatever according to the type currently assigned to it), and so on. It anticipated Modula with full control statement bracketing, but rather than just using END (Modula: IF...THEN...ELSIF...ELSE...END) it made the unfortunate choice to use reversal of the keyword (ALGOL-68: IF...THEN...ELIF...ELSE...FI, and CASE...ESAC - this same scheme was used in Bliss, the programming language designed to allow programmers the means to hurt themselves and others to a degree that not even C could aspire to). ALGOL-68 even anticipated C with computed assignments ( a +:= 1 ). [L6 ].\n\nWirth, who was on the committee, felt it was all too complicated for its expressive power, and disliked the ability to redefine operators and the dependence on APL characters. Wirth had proposed the language later called ALGOL-W [L7 ] for ALGOL-68. When it was not accepted, he built on ALGOL-W to design Pascal, which first saw the light of day in 1970."
    }
}