{
    "id": "dbpedia_4770_1",
    "rank": 67,
    "data": {
        "url": "https://www.masswerk.at/algol60/modified_report.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Modified Report on the Algorithmic Language Algol 60",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/omega.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/omega.gif",
            "https://www.masswerk.at/algol60/images/omega.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/omega.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/blank.gif",
            "https://www.masswerk.at/algol60/images/power.gif",
            "https://www.masswerk.at/algol60/images/times.gif",
            "https://www.masswerk.at/algol60/images/le.gif",
            "https://www.masswerk.at/algol60/images/ge.gif",
            "https://www.masswerk.at/algol60/images/ne.gif",
            "https://www.masswerk.at/algol60/images/equiv.gif",
            "https://www.masswerk.at/algol60/images/impl.gif",
            "https://www.masswerk.at/algol60/images/or.gif",
            "https://www.masswerk.at/algol60/images/and.gif",
            "https://www.masswerk.at/algol60/images/gamma.gif",
            "https://www.masswerk.at/algol60/images/theta.gif",
            "https://www.masswerk.at/algol60/images/sigma.gif",
            "https://www.masswerk.at/algol60/images/omega.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "being the\n\nRevised Report on the Algorithmic Language ALGOL 60\n\n(dedicated to the memory of William Turanski)\n\nby J. W. Backus, F. L. Bauer, J. Green, C. Katz, J. McCarthy,\n\nP. Naur, A. J. Perlis, H. Rutishauser, K. Samelson, B. Vauquois,\n\nJ. H. Wegstein, A. van Wijngaarden and M. Woodger\n\nas modified by\n\nR. M. De Morgan, I. D. Hill and B. A. Wichmann\n\nunder the authority of IFIP Working Group 2.1.\n\nIf any man, who shall desire a more particular account of the several\n\nAlterations . . . . shall take the pains to compare the present Book with\n\nthe former; we doubt not but the reason of the change may easily appear. Preface to Book of Common Prayer 1662.\n\nContents\n\nIntroduction Description of the reference language\n\n1. Structure of the language 2. Basic symbols, identifiers, numbers, and strings 3. Expressions 4. Statements 5. Declarations\n\nApependix 1 - Subsets Apependix 2 - The environmental block References Alphabetic index of definitions of concepts and syntactic units Note Note on the edition\n\nIntroduction\n\nFor the history of ALGOL 60 up to April 1962, the Revised Report on ALGOL 60 (Naur, 1963) should be consulted.\n\nFollowing the publication of the Revised Report, responsibility for ALGOL was transferred to Working Group 2.1 of IFIP Technical Committee 2. In 1964 WG2.1 produced reports on a subset of the language (IFIP, 1964a), and on input/output procedures (IFIP, 1964b), but thereafter devoted most of its attention to a proposed new language that was eventually adopted as ALGOL 68  a separate development, with which the present Report is not concerned.\n\nAdditional proposals for a different subset and for input/output were proposed by the European Computer Manufacturers' Association (ECMA) (1965) and by the Association for Computing Machinery (ACM) (Knuth et al, 1964) respectively.\n\nIn 1972 a version of the Revised Report, together with the various proposals on subsets and input/output, was published by the International Organization for Standardization as ISO Recommendation 1538 (1972), but IFIP refused to recognise this document as valid. Three subsets were given as Level 1 (ECMA, with recursion), Level 2 (ECMA) and Level 3 (IFIP), the full language being called Level 0.\n\nMeanwhile, various defects have been noted in the language definition which have unnecessarily hindered the use of ALGOL. Although the existence of subsets has given some assistance to the compiler-writer and user of the language, numerous problems exist, some of which were noted in the Revised Report.\n\nHence the need for a detailed commentary and standard interpretation has become apparent. Such a commentary is now available, defining the modifications necessary to produce this Report from the Revised Report. A preliminary version was discussed at the 1974 meeting of Working Group 2.1 at Breukelen. A revised version appeared in ALGOL Bulletin No. 38, together with a questionnaire and a request for comments. A further revision was based on the replies, and discussed at the 1975 meeting of Working Group 2.1 at Munich, where it was recommended for publication as an IFIP document.\n\n^ top\n\nDescription of the reference language\n\n1. Structure of the language\n\nThe algorithmic language has two different kinds of representation  reference and hardware  and the development described in the sequel is in terms of the reference representation. This means that all objects defined within the language are represented by a given set of symbols  and it is only in the choice of symbols that other representations may differ. Structure and content must be the same for all representations.\n\nReference language\n\nIt is the defining language.\n\nThe characters are determined by ease of mutual understanding and not by any computer limitations, coder's notation, or pure mathematical notation.\n\nIt is the basic reference and guide for compiler builders.\n\nIt is the guide for all hardware representations.\n\nHardware representations\n\nEach one of these:\n\nis a condensation of the reference language enforced by the limited number of characters on standard input equipment;\n\nuses the character set of a particular computer and is the language accepted by a translator for that computer;\n\nmust be accompanied by a special set of rules for transliterating to or from reference language. It should be particularly noted that throughout the reference language underlining in typescript or manuscript, or boldface type in printed copy, is used to represent certain basic symbols (see Sections 2.2.2 and 2.3). These are understood to have no relation to the individual letters of which they are composed. In the reference language underlining or boldface is used for no other purpose.\n\nThe purpose of the algorithmic language is to describe computational processes. The basic concept used for the description of calculating rules is the well-known arithmetic expression containing as constituents numbers, variables, and functions. From such expressions are compounded, by applying rules of arithmetic composition, self-contained units of the language  explicit formulae  called assignment statements.\n\nTo show the flow of computational processes, certain nonarithmetic statements and statement clauses are added which may describe, e.g. alternatives, or iterative repetitions of computing statements. Since it is sometimes necessary for the function of the statements that one statement refers to another, statements may be provided with labels. A sequence of statements may be enclosed between the statement brackets begin and end to form a compound statement.\n\nStatements are supported by declarations which are not themselves computing instructions, but inform the translator of the existence and certain properties of objects appearing in statements, such as the class of numbers taken on as values by a variable, the dimension of an array of numbers, or even the set of rules defining a function. A sequence of declarations followed by a sequence of statements and enclosed between begin and end constitutes a block. Every declaration appears in a block in this way and is valid only for that block.\n\nA program is a block or a compound statement that is contained only within a fictitious block (always assumed to be present and called the environmental block), and that makes no use of statements or declarations not contained within itself, except that it may use such procedure identifiers and function designators as may be assumed to be declared in the environmental block.\n\nThe environmental block contains procedure declarations for standard functions, input and output operations, and possibly other operations to be made available without declaration within the program. It also contains the fictitious declaration, and initialisation, of own variables (see Section 5).\n\nIn the sequel the syntax and semantics of the language will be given.\n\nWhenever the precision of arithmetic is stated as being in general not specified, or the outcome of a certain process is left undefined or said to be undefined, this is to be interpreted in the sense that a program only fully defines a computational process if the accompanying information specifies the precision assumed, the kind of arithmetic assumed, and the course of action to be taken in all such cases as may occur during the execution of the computation.\n\n1.1 Formalism for syntactic description\n\nThe syntax will be described with the aid of metalinguistic formulae (Backus, 1959). Their interpretation is best explained by an example:\n\n<ab> ::= ( | [ | <ab> ( | <ab> <d>\n\nSequences of characters enclosed in the bracket <> represent metalinguistic variables whose values are sequences of symbols. The marks ::= and | (the latter with the meaning of 'or') are metalinguistic connectives. Any mark in a formula, which is not a variable or a connective, denotes itself (or the class of marks which are similar to it). Juxtaposition of marks and/or variables in a formula signifies juxtaposition of the sequences denoted. Thus the formula above gives a recursive rule for the formation of values of the variable <ab>. It indicates that <ab> may have the value ( or [ or that given some legitimate value of <ab>, another may be formed by following it with the character ( or by following it with some value of the variable <d>. If the values of <d> are the decimal digits, some values of <ab> are:\n\n[(((1(37( (12345( ((( [86\n\nIn order to facilitate the study, the symbols used for distinguishing the metalinguistic variables (i.e. the sequence of characters appearing within the brackets <> as ab in the above example) have been chosen to be words describing approximately the nature of the corresponding variable. Where words which have appeared in this manner are used elsewhere in the text they will refer to the corresponding syntactic definition. In addition some formulae have been given in more than one place.\n\nDefinition:\n\n<empty> ::=\n\n(i.e. the null string of symbols).\n\n2. Basic symbols, identifiers, numbers, and strings\n\nBasic concepts\n\nThe reference language is built up from the following basic symbols:\n\n<basic symbol> ::= <letter> | <digit> | <logical value> | <delimiter>\n\n2.1. Letters\n\n<letter> ::= a | b | c | d | e | f | g | h | i | j | k | l | m | n | o | p | q | r | s | t | u | v | w | x | y | z | A | B | C | D | E | F | G | H | I | J | K | L | M | N | O | P | Q | R | S | T | U | V | W | X | Y | Z\n\nThis alphabet may be arbitrarily restricted, or extended with any other distinctive character (i.e. character not coinciding with any digit, logical value or delimiter).\n\nLetters do not have individual meaning. They are used for forming identifiers and strings. They are used for forming identifiers and strings (see Sections 2.4 Identifiers, 2.6 Strings). Within this report the letters (from an extended alphabet) , , and are sometimes used and are understood as not being available to the programmer. If an extended alphabet is in use, that does include any of these letters, then their uses within this report must be systematically changed to other letters that the extended alphabet does not include.\n\n2.2. Digits and logical values\n\n2.2.1 Digits\n\n<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\nDigits are used for forming numbers, identifiers, and strings.\n\n2.2.2 Logical values\n\n<logical value> ::= true | false\n\nThe logical values have a fixed obvious meaning.\n\n2.3. Delimiters\n\n<delimiter> ::= <operator> | <separator> | <bracket> | <declarator> | <specificator> <operator> ::= <arithmetic operator> | <relational operator> | <logical operator> | <sequential operator> <arithmetic operator> ::= + | - | | / | ÷ | <relational operator> ::= < | | = | | > | <logical operator> ::= | | | | ¬ <sequential operator> ::= go to | if | then | else | for | do <separator> ::= , | . | 10 | : | ; | := | | step | until | while | comment <bracket> ::= ( | ) | [ | ] | ` | ' | begin | end <declarator> ::= own | Boolean | integer | real | array | switch | procedure <specificator> ::= string | label | value\n\nDelimiters have a fixed meaning which for the most part is obvious or else will be given at the appropriate place in the sequel.\n\nTypographical features such as blank space or change to a new line have no significance in the reference language. They, however, be used freely for facilitating reading.\n\nFor the purpose of including text among the symbols of a program the following \"comment\" conventions hold:\n\nBy equivalence is here meant that any of the three structures shown in the left hand column may be replaced, in any occurrence outside of strings, by the symbol shown on the same line in the right hand column without any effect on the action of the program. It is further understood that the comment structure encountered first in the text when reading from left to right has precedence in being replaced over later structures contained in the sequence.\n\n2.4. Identifiers\n\n2.4.1. Syntax\n\n<identifier> ::= letter> | <identifier> <letter> | <identifier> <digit>\n\n2.4.2. Examples\n\nq Soup V17a a34kTMNs MARILYN\n\n2.4.3. Semantics\n\nIdentifiers have no inherent meaning, but serve for the identification of simple variables, arrays, labels, switches, and procedures. They may be chosen freely. Identifiers also act as formal parameters of procedures, in which capacity they may represent any of the above entities, or a string.\n\nThe same identifier cannot be used to denote two different quantities except when these quantities have disjoint scopes as defined by the declarations of the program (see Section 2.7 Quantities, kinds and scopes and Section 5 Declarations). This rule applies also to the formal parameters of procedures, whether representing a quantity or a string.\n\n2.5. Numbers\n\n2.5.1 Syntax\n\n<unsigned integer> ::= <digit> | <unsigned integer> <digit> <integer> ::= <unsigned integer> | + <unsigned integer> | - <unsigned integer> <decimal fraction> ::= . <unsigned integer> <exponential part> ::= 10 <integer> <decimal number> ::= <unsigned integer> | <decimal fraction> | <unsigned integer> <decimal fraction> <unsigned number> ::= <decimal number> | <exponential part> | <decimal number> <exponential part> <number> ::= <unsigned number> | + <unsigned number> | - <unsigned number>\n\n2.5.2. Examples\n\n0 -200.084 -.08310-02 177 + 07.43108 -107 .5384 9.3410+10 10-4 +0.7300 210-4 +10+5\n\n2.5.3. Semantics\n\nDecimal numbers have their conventional meaning. The exponent part is scale factor expressed as an integral power of 10.\n\n2.5.4. Types\n\nIntegers are of the type integer. All other numbers are of type real (see Section 5.1 Type declarations).\n\n2.6. Strings\n\n2.6.1. Syntax\n\n<proper string> ::= <any sequence of characters not containing ` or ' > | <empty> <open string> ::= <proper string> | <proper string> <closed string> <open string> <closed string> ::= `<open string>' <string> ::= <closed string> | <closed string> <string>\n\n2.6.2. Examples\n\n`5k,,-`[[[` =/:'Tt'' `This is a `string'' `This is all' ` one string'\n\n2.6.3. Semantics\n\nIn order to enable the language to handle sequences of characters the string quotes ` and ' are introduced.\n\nThe characters available within a string are a question of hardware representation, and further rules are not given in the reference language. However, it is recommended that visible characters, other than and \", should represent themselves, while invisible characters other than space should not occur within a string. To conform with Draft ISO/TR 1672, a space may stand for itself, although in this document the character is used to represent a space.\n\nTo allow invisible, or other exceptional characters to be used, they are represented within either matching string quotes or a matched pair of the \" symbol. The rules within such an inner string are unspecified, so if such an escape mechanism is used a comment is necessary to explain the meaning of the escape sequence.\n\nA string of the form <closed string><string> behaves as if it were the string formed by deleting the closing string quote of the closed string and the opening string quote of the following string (together with any layout characters between them).\n\nStrings are used as actual parameters of procedures (see Sections 3.2 Function designators and 4.7 Procedure statements).\n\n2.7. Quantities, kinds and scopes\n\nThe following kinds of quantities are distinguished: simple variables, arrays, labels, switches, and procedures.\n\nThe scope of a quantity is the set of statements and expressions in which the declaration of the identifier associated with that quantity is valid. For labels see Section 4.1.3.\n\n2.8. Values and types\n\nA value is an ordered set of numbers (special case: a single number), an ordered set of logical values (special case: a single logical value), or a label.\n\nCertain of the syntactic units are said to possess values. These values will in general change during the execution of the program. The values of expressions and their constituents are defined in Section 3. The value of an array identifier is the ordered set of values of the corresponding array of subscripted variables (see Section 3.1.4.1).\n\nThe various types (integer, real, Boolean) basically denote properties of values. The types associated with syntactic units refer to the values of these units.\n\n3. Expressions\n\nIn the language the primary constituents of the programs describing algorithmic processes are arithmetic, Boolean, and designational expressions. Constituents of these expressions, except for certain delimiters, are logical values, numbers, variables, function designators, labels, switch designators, and elementary arithmetic, relational, logical, and sequential operators. Since the syntactic definition of both variables and function designators contains expressions, the definition of expressions, and their constituents, is necessarily recursive.\n\n<expression> ::= <arithmetic expression> | <Boolean expression> | <designational expression>\n\n3.1. Variables\n\n3.1.1. Syntax\n\n<variable identifier> ::= <identifier> <simple variable> ::= <variable identifier> <subscript expression> ::= <arithmetic expression> <subscript list> ::= <subscript expression> | <subscript list> , <subscript expression> <array identifier> ::= <identifier> <subscripted value> ::= <array identifier>[<subscripted list>] <variable> ::= <simple variable> | <subscripted variable>\n\n3.1.2. Examples\n\nepsilon detA a17 Q[7, 2] x[sin(n pi/2), Q[3 ,n ,4]]\n\n3.1.3. Semantics\n\nA variable is a designation given to a single value. This value may be used in expressions for forming other values and may be changed at will by means of assignment statements (see Section 4.2). The type of the value of a particular variable is defined in the declaration for the variable itself (see Section 5.1 Type declarations) or for the corresponding array identifier (see Section 5.2 Array declarations).\n\n3.1.4. Subscripts\n\n3.1.4.1. Subscripted variable designate values which are components of multidimensional arrays (see Section 5.2 Array declarations). Each arithmetic expression of the subscript list occupies one subscript position of the subscripted variable and is called a subscript. The complete list of subscripts is enclosed in the subscript brackets [ ]. The array component referred to by a subscripted variable is specified by the actual numerical value of its subscripts (see Section 3.3 Arithmetic expressions).\n\n3.1.4.2. Each subscript position acts like a variable of integer type and the evaluation of the subscript is understood to be equivalent to an assignment to this fictitious variable (see Section 4.2.4). The value of the subscripted variable is defined only if the value of the subscript expression is within the subscript bounds of the array (see Section 5.2 Array declarations).\n\n3.1.5. Initial values of variables\n\nThe value of a variable, not declared own, is undefined from entry into the block in which it is declared until an assignment is made to it. The value of a variable declared own is zero (if arithmetic) or false (if Boolean) on first entry to the block in which it is declared and at subsequent entries it has the same value as at the preceding exit from the block.\n\n3.2. Function designators\n\n3.2.1. Syntax\n\n<procedure identifier> ::= <identifier> <actual parameter> ::= <string> | <expression> | <array identifier> | <switch identifier> | <procedure identifier> <letter string> ::= <letter> | <letter string> <letter> <parameter delimiter> ::= , | ) <letter string> : ( <actual parameter list> ::= <actual parameter> | <actual parameter list> <parameter delimiter> <actual parameter> <actual parameter part> ::= <empty> | ( <actual parameter list> ) <function designator> ::= <procedure identifier> <actual parameter part>\n\n3.2.2. Examples\n\nsin(a - b) J(v + s, n) R S(s - 5) Temperature:(T) Pressure:(P) Compile(`:=') Stack:(Q)\n\n3.2.3. Semantics\n\nFunction designators define single numerical or logical values which result through the application of given sets of rules defined by a procedure declaration (see Section 5.4 Procedure declarations) to fixed sets of actual parameters. The rules governing specification of actual parameters are given in Section 4.7 Procedure statements. Not every procedure declaration defines rules for determining the value of a function designator.\n\n3.2.4. Standard functions\n\nCertain standard functions and procedures are declared in the environmental block with the following procedure identifiers:\n\nabs, iabs, sign, entier, sqrt, sin, cos, arctan, ln, exp, inchar, outchar, length, outstring, outterminator, stop, fault, ininteger, outinteger, inreal, outreal, maxreal, minreal, maxint and epsilon.\n\nFor details of these functions and procedures, see the specification of the environmental block given as Appendix 2.\n\n3.3. Arithmetic expressions\n\n3.3.1. Syntax\n\n<adding operator> ::= + | - <multiplying operator> ::= | / | ÷ <primary> ::= <unsigned number> | <variable> | <function designator> | ( <arithmetic expression> ) <factor> ::= <primary> | <factor> <primary> <term> ::= <factor> | <term> <multiplying operator> <factor> <simple arithmetic expression> ::= <term> | <adding operator> <term> | <simple arithmetic expression> <adding operator> <term> <if clause> ::= if <Boolean expression> then <arithmetic expression> ::= <simple arithmetic expression> | <if clause> <simple arithmetic expression> else <arithmetic expression>\n\n3.3.2. Examples\n\nPrimaries:\n\n7.39410-8 sum w[i + 2, 8] cos(y + z 3) (a - 3/y + vu 8)\n\nFactors:\n\nomega sum cos(y + z 3) 7.39410 - 8 w[i + 2, 8] (a - 3 /y + vu 8)\n\nTerms:\n\nU omega sum cos(y + z 3)/7.39410-8 w[i + 2 ,8] (a - 3/y + vu 8)\n\nSimple arithmetic expressions:\n\nU - Yu + omega sum cos(y + z 3)/7.39410-8 w[i + 2 ,8] (a - 3/y + vu 8)\n\nArithmetic expressions:\n\nw u - Q(S + Cu) 2 if q > 0 then S + 3 Q/A else 2 S + 3 q if a < 0 then U + V else if a b > 17 then U/V else if k y then V/U else 0 a sin(omega t) 0.571012 a[N (N - 1)/2, 0] (A arctan(y) + Z) (7 + Q) if a < 0 then A/B else if b = 0 then B/A else z\n\n3.3.3. Semantics\n\nAn arithmetic expression is a rule for computing a numerical value. In the case of simple arithmetic expressions this value is obtained by executing the indicated arithmetic operations on the actual numerical values of the primaries of the expression, as explained in detail in Section 3.3.4 below. The actual numerical value of a primary is obvious in the case of numbers. For variables it is the current value (assigned last in the dynamic sense), and for function designators it is the value arising from the computing rules defining the procedure (see Section 5.4.4 Values of function designators) when applied to the current values of the procedure parameters given in the expression. Fi-nally, for arithmetic expression enclosed in parenthesis the value must through a recursive analysis be expressed in terms of the values of primaries of the other three kinds.\n\nIn the more general arithmetic expressions, which include if clauses, one out of several simple arithmetic expressions is selected on the basis of the actual values of the Boolean expressions (see Section 3.4 Boolean expressions). This selection is made as follows: The Boolean expressions of the if clauses are evaluated one by one in sequence from left to right until one having the value true is found. The value of the arithmetic expression is then the value if the first arithmetic expression following this Boolean (the longest arithmetic expression found in this position is understood). If none of the Boolean expressions has the value true, then the value of the arithmetic expression is the value of expression following the final else.\n\nThe order of evaluation of primaries within an expression is not defined. If different orders of evaluation would produce different results, due to the action of side effects of function designators, then the program is undefined.\n\nIn evaluating an arithmetic expression, it is understood that all the primaries within that expression are evaluated, except those within any arithmetic expression that is governed by an if clause but not selected by it. In the special case where an exit is made from a function designator by means of a go to statement (see Section 5.4.4), the evaluation if the expression is abandoned, when the go to statement is executed.\n\n3.3.4. Operators and types\n\nApart from the Boolean expressions of clauses, the constituents of simple arithmetic expressions must be of real or integer types (see Section 5.1 Type declaration). The meaning of the basic operators and the types of the expressions to which they lead are given by the following rules:\n\n3.3.4.1. The operators +, -, and have the conventional meaning (addition, subtraction, and multiplication). The type of the expression will by integer if both of the operands are of integer type, otherwise real.\n\n3.3.4.2. The operations <term> / <factor> and <term> ÷ <factor> both denote division. The operations are undefined if the factor has the value zero, but are otherwise to be understood as a multiplication of the term by the reciprocal of the factor with due regard to the rules of precedence (see Section 3.3.5). Thus for example\n\na/b 7/(p - q) v/s\n\nmeans\n\n((((a (b-1)) 7) ((p - q)-1)) v) (s-1)\n\nThe operator / is defined for all four combinations of real and integer types and will yield results of real type in any case. The operator ÷ is defined only for two operands both of integer type and will yield a result of integer type. If a and b are of integer type, then the value of a ÷ b is given by the function:\n\ninteger procedure div(a, b); value a, b; integer a, b; if b = 0 then fault( `div by zero' , a) else begin integer q, r; q := 0; r := iabs(a); for r := r - iabs(b) while r 0 do q := q + 1; div := if a < 0 b > 0 then -q else q end div;\n\n3.3.4.3. The operation <factor> <factor> denotes exponentiation, where the factor is the base and the primary is the exponent. Thus for example\n\n2 n k means (2 n) k\n\nwhile\n\n2 (n m) means 2 (n m)\n\nIf r is of real type and x of either real or integer type, then the value of xr is given by the function:\n\nreal procedure expr(x, r); value x, r; real x, r; if x > 0.0 then expr := exp(r ln(x)) else if x = 0.0 r > 0.0 then expr := 0.0 else fault( `expr undefined' , x)\n\nIf i and j are both of integer type, then the value of ij is given by the function:\n\ninteger procedure expi(i, j); value i, j; integer i, j; if j < 0 i = 0 j = 0 then fault( `expi undefined' , j) else begin integer k, result; result := 1; for k := 1 step 1 until j do result := result i; expi := result end expi\n\nIf n is of integer type and x of real type, then the value of xn is given by the function:\n\nreal procedure expn(x, n); value x, n; real x; integer n; if n = 0 x = 0.0 then fault( `expn undefined' , x) else begin real result; integer i; result := 1.0; for i := iabs(n) step -1 until 1 do result := result x; expn := if n < 0 then 1.0/result else result end expn\n\nThe call of the procedure fault denotes that the action of the program is undefined. It is understood that the finite deviations (see Section 3.3.6) of using the exponentiation operator may be different from those of using the procedures expr and expn.\n\n3.3.4.4. Type of a conditional expression\n\nThe type of an arithmetic expression of the form\n\nif B then SAE else AE\n\ndoes not depend upon the value of B. The expression is of real type if either SAE or AE is real and is of integer type otherwise.\n\n3.3.5. Precedence of operators\n\nThe sequence of operations within one expression is generally from left to right, with the following additional rules:\n\n3.3.5.1. According to the syntax given in Section 3.3.1 the following rules of precedence hold:\n\nfirst: second: / ÷ third: + -\n\n3.3.5.2. The expression between a left parenthesis and the matching right parenthesis is evaluated by itself and this value is used in subsequent calculations. Consequently the desired order of execution of operations within an expression can always be arranged by appropriate positioning of parentheses.\n\n3.3.6. Arithmetics of real quantities.\n\nNumbers and variables of real type must be interpreted in the sense of numerical analysis, i.e. as entities defined inherently with only a finite accuracy. Similarly, the possibility of the occurrence of a finite deviation from the mathematically defined result in any arithmetic expression is explicitly understood. No exact arithmetic will be specified, however, and it is indeed understood that different implementations may evaluate arithmetic expressions differently. The control of the possible consequences of such differences must be carried out by the methods of numerical analysis. This control must be considered a part of the process to be described, and will therefore be expressed in terms of the language itself.\n\n3.4. Boolean expressions\n\n3.4.1. Syntax\n\n<relational operator> ::= < | | = | | > | <relation> ::= <simple arithmetic expression> <relational operator> <simple arithmetic expression> <Boolean primary> ::= <logical value> | <variable> | <function designator> | <relation> | ( <Boolean expression> ) <Boolean secondary> ::= <Boolean primary> | ¬ <Boolean primary> <Boolean factor> ::= <Boolean secondary> | <Boolean factor> <Boolean secondary> <Boolean term> ::= <Boolean factor> | <Boolean term> <Boolean factor> <implication> ::= <Boolean term> | <implication> <Boolean term> <simple Boolean> ::= <implication> | <simple Boolean> <implication> <Boolean expression> ::= <simple Boolean> | <if clause> <simple Boolean> else <Boolean expression>\n\n3.4.2. Examples\n\nx = -2 Y > V z < q a + b > -5 z - d > q 2 p q x y g ¬a b ¬c d e ¬f if k < 1 then s < w else h c if if if a then b else c then d else f then g else h < k\n\n3.4.3. Semantics\n\nA Boolean expression is a rule for computing a logical value. The principles of evaluation are entirely analogous to those given for arithmetic expressions in Section 3.3.3.\n\n3.4.4. Types\n\nVariables and function designators entered as Boolean primaries must be declared Boolean (see Section 5.1. Type declarations and Section 5.4.4. Value of function designators).\n\n3.4.5. The operators\n\nThe relational operators <, , =, , > and have their conventional meaning (less than, less than or equal to, equal to, greater than or equal to, greater than, not equal to). Relations take on the value true whenever the corresponding relation is satisfied for the expressions involved, otherwise false.\n\nThe meaning of the logical operators ¬ (not), (and), (or), (implies), and (equivalent), is given by the following function table.\n\nb1\n\nb2\n\nfalse\n\nfalse\n\nfalse\n\ntrue\n\ntrue\n\nfalse\n\ntrue\n\ntrue\n\n¬b1\n\nb1 b2\n\nb1 b2\n\nb1 b2\n\nb1 b2\n\ntrue\n\nfalse\n\nfalse\n\ntrue\n\ntrue\n\ntrue\n\nfalse\n\ntrue\n\ntrue\n\nfalse\n\nfalse\n\nfalse\n\ntrue\n\nfalse\n\nfalse\n\nfalse\n\ntrue\n\ntrue\n\ntrue\n\ntrue\n\n3.4.6. Precedence of operators\n\nThe sequence of operations within one expression is generally from left to right, with the following additional rules:\n\n3.4.6.1. According to the syntax given in Section 3.4.1 the following rules of precedence hold:\n\n3.4.6.2. The use of parentheses will be interpreted in the sense given in Section 3.3.5.2.\n\n3.5. Designational expressions\n\n3.5.1. Syntax\n\n<label> ::= <identifier> | <unsigned integer> <switch identifier> ::= <identifier> <switch designator> ::= <switch identifier>[<subscript expression>] <simple designational expression> ::= <label> | <switch designator> | (<designational expression>) <designational expression> ::= <simple designational expression> | <if clause> <simple designational expression> else <designational expression>\n\n3.5.2. Examples\n\n17 p9 Choose[n - 1] Town [if y < 0 then N else N + 1] if Ab < c then 17 else q[if w 0 then 2 else n]\n\n3.5.3. Semantics\n\nA designational expression is a rule for obtaining a label of a statement (see Section 4 Statements). Again the principle of the evaluation is entirely analogous to that of arithmetic expressions (see Section 3.3.3). In the general case the Boolean expressions of the if clauses will select a simple designational expression. If this a label the desired result is already found. A switch designator refers to the corresponding switch declaration (see Section 5.3 Switch declarations) and by the actual numerical value of its subscript expression selects one of the designational expressions listed in the switch declaration by counting these from left to right. Since the designational expression thus selected may again be a switch designator this evaluation is obviously a recursive process.\n\n3.5.4. The subscript expression\n\nThe evaluation of the subscript expression is analogous to that of subscripted variables (see Section 3.1.4.2). The value of a switch designator is defined only if the subscript expression assumes one of the positive values 1, 2, 3, ..., n, where n is the number of entries in the switch list.\n\n4. Statements\n\nThe units of operation within the language are called statements. They will normally be executed consecutively as written. However, this sequence of operations may be broken by go to statements, which define their successor explicitly, shortened by conditional statements, which may cause certain statements to be skipped, and lengthened by for statements which cause certain statements to be repeated.\n\nIn order to make it possible to define a specific dynamic succession, statements may be provided with labels.\n\nSince sequences of statements may be grouped together into compound statements and blocks the definition of statement must necessarily be recursive. Also since declarations, described in Section 5, enter fundamentally into the syntactic structure, the syntactic definition of statements must suppose declarations to be already defined.\n\n4.1. Compound statements and blocks\n\n4.1.1 Syntax\n\n<unlabelled basic statement> ::= <assignment statement> | <go to statement> | <dummy statement> | <procedure statement> <basic statement> ::= <unlabelled basic statement> | <label>: <basic statement> <unconditional statement> ::= <basic statement> | <compound statement> | <block> <statement> ::= <unconditional statement> | <conditional statement> | <for statement> <compound tail> ::= <statement> end | <statement> ; <compound tail> <block head> ::= begin <declaration> | <block head> ; <declaration> <unlabelled compound> ::= begin <compound tail> <unlabelled block> ::= <block head> ; <compound tail> <compound statement> ::= <unlabelled compound> | <label>: <compound statement> <block> ::= <unlabelled block> | <label>: <block> <program> ::= <block> | <compound statement>\n\nThis syntax may be illustrated as follows: Denoting arbitrary statements, declarations, and labels, by the letters S, D, L, respectively, the basic syntactic units take the forms:\n\nCompound statement:\n\nL:L: ... begin S; S; ... S; S end\n\nBlock:\n\nL:L: ... begin D; D; .. D; S; S; ... S; S end\n\nIt should be kept in mind that each of the statements S may again be a complete compound statement or a block.\n\n4.1.2. Examples\n\nBasic statements:\n\na := p + q go to Naples START:CONTINUE: W := 7.993\n\nCompound statements:\n\nbegin x := 0; for y := 1 step 1 until n do x := x + A[y]; if x > q then go to STOP else if x > w-2 then go to S; Aw: St: W := x + bob end\n\nBlock:\n\nQ: begin integer i, k; real w; for i:=1 step 1 until m do for k := i + 1 step 1 until m do begin w := A[i, k]; A[i, k] := A[k, i]; A[k, i] := w end for i and k end block Q\n\n4.1.3. Semantics\n\nEvery block automatically introduces a new level of nomenclature. This is realised as follows: Any identifier occurring within the block may through a suitable declaration (see Section 5 Declarations) be specified to be local to the block in question. This means (a) that the entity specified by this identifier inside the block has no existence outside it and (b) that any entity represented by this identifier outside the block is completely inaccessible inside the block.\n\nIdentifiers (except those representing labels) occurring within a block and not being declared to this block will be non-local to it, i.e. will represent the same entity inside the block and in the level immediately outside it. A label separated by a colon from a statement, i.e. labelling that statement, behaves as though declared in the head if the smallest embracing block, i.e. the smallest block whose brackets begin and end enclose that statement.\n\nA label is said to be implicitly declared in this block head, as distinct from the explicit declaration of all other local identifiers. In this context a procedure body, or the statement following a for clause, must be considered as if it were enclosed by begin and end and treated as a block, this block being nested within the fictitious block of Section 4.7.3.1, in the case of a procedure with parameters by value. A label that is not within any block of the program (nor with a procedure body, or the statement following a for clause) is implicitly declared in the head of the environmental block.\n\nSince a statement of a block may again itself be a block the concepts local and non-local to a block must be understood recursively. Thus an identifier which is non-local to a block A, may or may not be non-local to the block B in which A is one statement.\n\n4.2. Assignment statements\n\n4.2.1. Syntax\n\n<destination> ::= <variable> | <procedure identifier> <left part> ::= <destination> := <left part list> ::= <left part> | <left part list> <left part> <assignment statement> ::= <left part list> <arithmetic expression> | <left part list> <Boolean expression>\n\n4.2.2. Examples\n\ns := p[0] := n := n + 1 + s n := n + 1 A := B/C - v - q S S[v, k + 2] := 3 - arctan(s zeta) V := Q > Y Z\n\n4.2.3. Semantics\n\nAssignment statements serve for assigning the value of an expression to one or several destinations. Assignment to a procedure identifier may only occur within the body of a procedure defining the value of the function designator denoted by that identifier (see Section 5.4.4). If assignment is made to a subscripted variable, the values of all the subscripts must lie within the appropriate subscript bounds. Otherwise the action of the program becomes undefined.\n\nThe process will in the general case be understood to take place in three steps as follows:\n\n4.2.3.1. Any subscript expressions occurring in the destinations are evaluated in sequence from left to right.\n\n4.2.3.2. The expression of the statement is evaluated.\n\n4.2.3.3. The value of the expression is assigned to all the destinations, with any subscript expres-sions having values as evaluated in step 4.2.3.1.\n\n4.2.4. Types\n\nThe type associated with all destinations of a left part list must be the same. If this type is Boolean, the expression must likewise be Boolean. If the type is real or integer, the expression must be arithmetic.\n\nIf the type of the arithmetic expression differs from that associated with the destinations, an appropriate transfer function is understood to be automatically invoked. For transfer from real to integer type the transfer function is understood to yield a result which is the largest integral quantity not exceeding E + 0.5 in the mathematical sense (i.e. without rounding error) where E is the value of the expression. It should be noted that E, being of real type, is defined with only finite accuracy (see Section 3.3.6). The type associated with a procedure identifier is given by the declarator which appears as the first symbol of the corresponding procedure declaration (see Section 5.4.4).\n\n4.3. Go to statements\n\n4.3.1. Syntax\n\n<go to statement> ::= go to <designational expression>\n\n4.3.2. Examples\n\ngo to L8 go to exit[n + 1] go to Town[if y < 0 then N else N + 1] go to if Ab < c then L17 else q [if w < 0 then 2 else n]\n\n4.3.3. Semantics\n\nA go to statement interrupts the normal sequence of operations, by defining its successor explicitly by the value of a designational expression. Thus the next statement to be executed will be the one having this value as its label.\n\n4.3.4. Restriction\n\nSince labels are inherently local, no go to statement can lead from outside into a block. A go to statement may, however, lead from outside into a compound statement.\n\n4.3.5. Go to an undefined switch designator\n\nA go to statement is undefined if the designational expression is a switch designator whose value is undefined.\n\n4.4. Dummy statements\n\n4.4.1. Syntax\n\n<dummy statement> ::= <empty>\n\n4.4.2. Examples\n\nL: begin statements; John: end\n\n4.4.3. Semantics\n\nA dummy statement executes no operation. It may serve to place a label.\n\n4.5. Conditional statements\n\n4.5.1. Syntax\n\n<if clause> ::= if <Boolean expression> then <unconditional statement> ::= <basic statement> | <compound statement> | <block> <if statement> ::= <if clause> <unconditional statement> <conditional statement> ::= <if statement> | <if statement> else <statement> | <if clause> <for statement> | <block>: <conditional statement>\n\n4.5.2. Examples\n\nif x > 0 then n := n + 1 if v > u then V: q := n + m else go to R if s < 0 P Q then AA: begin if q < v then a := v/s else y := 2 a end else if v > s then a := v - q else if v > s - 1 then go to S\n\n4.5.3. Semantics\n\nConditional statements cause certain statements to be executed or skipped depending on the running values of specified Boolean expressions.\n\n4.5.3.1. If statement\n\nAn if statement is of the form\n\nif B then Su\n\nwhere B is a Boolean expression and Su is an unconditional statement. In execution, B is evaluated; if the result is true, Su is executed; if the result is false, Su is not executed.\n\nIf Su contains a label, and a go to statement leads to the label, then B is not evaluated, and the computation continues with execution of the labelled statement.\n\n4.5.3.2. Conditional statement\n\nThree forms of unlabelled conditional statements exist, namely:\n\nif B then Su if B then Sfor if B then Su else S\n\nwhere Su is an unconditional statement, for is a for statement, and S is a statement.\n\nThe meaning of the first form is given in Section 4.5.3.1. The second form is equivalent to\n\nif B then begin Sfor end\n\nThe third form is equivalent to\n\nbegin if B then begin Su; go to G end; : end\n\n(For the use of see Section 2.1 Letters.) If S is conditional and also of this form, a different label must be used instead of following the same rule.\n\n4.5.4. Go to into a conditional statement\n\nThe effect of a go to statement leading into a conditional statement follows directly from the above explanation of the execution of conditional statement..\n\n4.6. For statements\n\n4.6.1. Syntax\n\n<for list element> ::= <arithmetic expression> | <arithmetic expression> step <arithmetic expression> until <arithmetic expression> | <arithmetic expression> while <Boolean expression> <for list> ::= <for list element> | <for list> , <for list element> <for clause> ::= for <variable> := <for list> do <for statement> ::= <for clause> <statement> | <label>: <for statement>\n\n4.6.2. Examples\n\nfor q := 1 step s until n do A[q] := B[q] for k := 1, V1 2 while V1 < N do for j := I + G, L, 1 step 1 until N, C + D do A[k, j] := B[k, j]\n\n4.6.3. Semantics\n\nA for clause causes the statement S which it precedes to be repeatedly executed zero or more times. In addition it performs a sequence of assignments to its controlled variable (the variable after for). The controlled variable must be of real or integer type.\n\n4.6.4. The for list elements\n\nIf the for list contain more than one element then\n\nfor V := X, Y do S\n\nwhere X is a for list element, and Y is a for list (which may consist of one element or more), is equivalent to\n\nbegin procedure S; S; for V := X do ; for V := Y do end\n\n(For the use of see Section 2.1 Letters.)\n\n4.6.4.1. Arithmetic expression\n\nIf X is an arithmetic expression then\n\nfor V := X do S\n\nis equivalent to\n\nbegin V := X; S end\n\nwhere S is treated as if it were a block (see Section 4.1.3).\n\n4.6.4.2. Step-until element\n\nIf A, B, and C are arithmetic expressions then\n\nfor V := A step B until C do S\n\nis equivalent to\n\nbegin <type of B> ; V := A; : := B; if (V - C) sign( ) 0 then begin S; V := V + ; go to end end\n\nwhere S is treated as if it were a block (see Section 4.1.3).\n\nIn the above, <type of B> must be replaced by real or integer according to the type of B. (For the use of and see Section 2.1 Letters.)\n\n4.6.4.3. While element\n\nIf E is an arithmetic expression and F is a Boolean expression then\n\nfor V := E while F do S\n\nis equivalent to\n\nbegin : V := E; if F then begin S; go to G end end\n\nwhere both S and the outermost compound statement of the above expansion are treated as if they were blocks (see Section 4.1.3). (For the use of see Section 2.1 Letters.)\n\n4.6.5. The value of the controlled variable upon exit\n\nUpon exit from the for statement, either through a go to statement, or by exhaustion of the for list, the controlled variable retains the last value assigned to it.\n\n4.6.6. Go to leading into a for statement\n\nThe statement following a for clause always acts like a block, whether it has the form of one or not.\n\nConsequently the scope of any label within this statement can never extend beyond the statement.\n\n4.7. Procedure statements\n\n4.7.1. Syntax\n\n<actual parameter> ::= <string> | <expression> | <array identifier> | <switch identifier> | <procedure identifier> <letter string> ::= <letter> | <letter string> <letter> <parameter delimiter> ::= , | ) <letter string> : ( <actual parameter list> ::= <actual parameter> | <actual parameter list> <parameter delimiter> <actual parameter> <actual parameter part> ::= <empty> | ( <actual parameter list> ) <procedure statement> ::= <procedure identifier> <actual parameter part>\n\n4.7.2. Examples\n\nSpur(A) Order:(7) Result to:(V) Transpose(W, v + 1) Absmax(A, N, M, Yy, I, K) Innerproduct(A[t, P, u], B[P], 10, P, Y)\n\nThese examples correspond to examples given in Section 5.4.2.\n\n4.7.3. Semantics\n\nA procedure statement serves to invoke (call for) the execution of a procedure body (see Section 5.4 Procedure declarations). Where the procedure body is a statement written in ALGOL the effect of this execution will be equivalent to the effect of performing the following operations on the program at the time of execution of the procedure statement:\n\n4.7.3.1. Value assignment (call by value)\n\nAll formal parameters quoted in the value part of the procedure heading (see Section 5.4) are assigned the values (see Section 2.8 Values and types) of the corresponding actual parameters, these assignments being considered as being performed explicitly before entering the procedure body. The effect is as though an additional block embracing the procedure body were created in which these assignments were made to variables local to this fictitious block with types as given in the corresponding specifications (see Section 5.4.5). As a consequence, variables called by value are to be considered as non-local to the body of the procedure, but local to the fictitious block (see Section 5.4.3).\n\n4.7.3.2. Name replacement (call by name)\n\nAny formal parameter not quoted in the value list is replaced, throughout the procedure body, by the corresponding actual parameter, after enclosing this latter in parentheses if it is an expression but not a variable. Possible conflicts between identifiers inserted through this process and other identifiers already present within the procedure body will be avoided by suitable systematic changes of the formal or local identifiers involved.\n\nIf the actual and formal parameters are of different arithmetic types, then the appropriate type conversion must take place, irrespective of the context of use of the parameter.\n\n4.7.3.3. Body replacement and execution\n\nFinally the procedure body, modified as above, is inserted in place of the procedure statement and executed. If the procedure is called from a place outside the scope of any non-local quantity of the procedure body the conflicts between identifiers inserted through this process of body replacement and the identifiers whose declarations are valid at the place of the procedure statement or function designator will be avoided through suitable systematic changes of the latter identifiers.\n\n4.7.4. Actual-formal correspondence\n\nThe correspondence between the actual parameters of the procedure statement and formal parameters of the procedure heading is established as follows: The actual parameter list of the procedure statement must have the same number of entries as the formal parameter list of the procedure declaration heading. The correspondence is obtained by taking the entries of these two lists in the same order.\n\n4.7.5. Restrictions\n\nFor a procedure statement to be defined it is evidently necessary that the operations on the procedure body defined in Sections 4.7.3.1 and 4.7.3.2 lead to a correct ALGOL statement.\n\nThis imposes the restriction on any procedure statement that the kind and type of each actual parameter be compatible with the kind and type of the corresponding formal parameter. Some important particular cases of this general rule, and some additional restrictions, are the following:\n\n4.7.5.1. If a string is supplied as an actual parameter in a procedure statement or function designator, whose defining procedure body is an Algol 60 statement (as opposed to non-Algol code, see Section 4.7.8), then this string can only be used within the procedure body as an actual parameter in further procedure calls. Ultimately it can only be used by a procedure body expressed in non-Algol code.\n\n4.7.5.2. A formal parameter which occurs as a left part variable in an assignment statement within the procedure body and which is not called by value can only correspond to an actual parameter which is a variable (special case of expression).\n\n4.7.5.3. A formal parameter which is used within the procedure body as an array identifier can only correspond to an actual parameter which is an array identifier of an array of the same dimensions. In addition if the formal parameter is called by value the local array created during the call will have the same subscript bounds as the actual array.\n\nSimilarly the number, kind and type of any parameter of a formal procedure parameter must be compatible with those of the actual parameter.\n\n4.7.5.4. A formal parameter which is called by value cannot in general correspond to a switch identifier or a procedure identifier or a string, because latter do not posses values (the exception is the procedure identifier of a procedure declaration which has an empty formal parameter part (see Section 5.4.1) and which defines the value of a function designator (see Section 5.4.4). This procedure identifier is in itself a complete expression).\n\n4.7.5.5. Restrictions imposed by specifications of formal parameters must be observed. The correspondence between actual and formal parameters should be in accordance with the following table.\n\nFormal parameterModeActual parameter integervaluearithmetic expression namearithmetic expression (see 4.7.5.2) realvaluearithmetic expression namearithmetic expression (see 4.7.5.2) BooleanvalueBoolean expression nameBoolean expression (see 4.7.5.2) labelvaluedesignational expression namedesignational expression integer arrayvaluearithmetic array (see 4.7.5.3) nameinteger array (see 4.7.5.3) real arrayvaluearithmetic array (see 4.7.5.3) namereal array (see 4.7.5.3) Boolean arrayvalueBoolean array (see 4.7.5.3) nameBoolean array (see 4.7.5.3) typeless procedurenamearithmetic procedure, or typeless procedure, or Boolean procedure (see 4.7.5.3) integer procedurenamearithmetic procedure (see 4.7.5.3) real procedurenamearithmetic procedure (see 4.7.5.3) Boolean procedurenameBoolean procedure (see 4.7.5.3) switchnameswitch stringnameactual string or string identifier\n\nIf the actual parameter is itself a formal parameter the correspondence (as in the above table) must be with the specification of the immediate actual parameter rather than with the declaration of the ultimate actual parameter.\n\n4.7.6. Label parameters\n\nA label may be called by value, even though variables of type label do not exist.\n\n4.7.7. Parameter delimiters\n\nAll parameter delimiters are understood to be equivalent. No correspondence between the parameter delimiters used in a procedure statement and those used in the procedure heading is expected beyond their number being the same. Thus the information conveyed by using the elaborate ones is entirely optional.\n\n4.7.8. Procedure body expressed in code\n\nThe restrictions imposed on a procedure statement calling a procedure having its body expressed in non-ALGOL code evidently can only be derived from the characteristics of the code used and the intent of the user and thus fall outside the scope of the reference language.\n\n4.7.9. Standard procedures\n\nTen standard procedures are defined, which are declared in the environmental block in an identical manner to the standard functions. These procedures are: inchar, outchar, outstring, ininteger, inreal, outinteger, outreal, outterminator, fault and stop. The input/output procedures identify physical devices or files by means of channel numbers which appear as the first parameter. The method by which this identification is achieved is outside the scope of this report. Each channel is regarded as containing a sequence of characters; basic method of accessing or assigning these characters being via the procedures inchar and outchar.\n\nThe procedures inreal and outreal are converses of each other in the sense that a channel containing characters from successive calls of outreal can be re-input by the same number of calls of inreal, and some accuracy may be lost. The procedures ininteger and outinteger are also a pair, but no accuracy can be lost. The procedure outterminator is called at the end of each of the procedure outreal and outinteger. Its action is machine dependent but it must ensure separation between successive output of numeric data.\n\nPossible implementation of these additional procedures are given in Appendix 2 as examples to illustrate the environmental block.\n\n5. Declarations\n\nDeclarations serve to define certain properties of the quantities used in the program, and to associate them with identifiers. A declaration of an identifier is valid for one block. Outside this block the particular identifier may be used for other purposes (see Section 4.1.3).\n\nDynamically this implies the following: at the time of an entry into a block (through begin since the labels inside are local and therefore inaccessible from outside) all identifiers declared for the block assume the significance implied by the nature of the declarations given. If these identifiers had already been defined by other declarations outside they are for the time being given a new significance. Identifiers which are not declared for the block, on the other hand, retain their old meaning.\n\nAt the the time of an exit from a block (through end, or by a go to statement) all identifiers which are declared for the block lose their local significance.\n\nA declaration may be marked with additional declarator own. This has the following effect: upon a reentry into the block, the values of own quantities will be unchanged from their values at the last exit, while the values of declared variables which are not marked as own are undefined.\n\nApart from labels, formal parameters of procedure declarations and identifiers declared in the environmental block, each identifier appearing in a program must be explicitly declared within a program.\n\nNo identifier may be declared either explicitly or implicitly (see Section 4.1.3) more than once in any one block head.\n\nSyntax\n\n<declaration> ::= <type declaration> | <array declaration> | <switch declaration> | <procedure declaration>\n\n5.1. Type declarations\n\n5.1.1 Syntax\n\n<type list> ::= <simple variable> | <simple variable> , <type list> <type> ::= real | integer | Boolean <local or own> ::= <empty> | own <type declaration> ::= <local or own> <type> <type list>\n\n5.1.2. Examples\n\ninteger p, q, s own Boolean Acryl, n\n\n5.1.3. Semantics\n\nType declarations serve to declare certain identifiers to represent simple variables of a given type. Real declared variables may only assume positive or negative values including zero. Integer declared variables may only assume positive and negative integral values including zero. Boolean declared variables may only assume the values true and false.\n\nA variable declared own behaves as if it had been declared (and initialised to zero or false, see Section 3.1.5) in the environmental block, except that it is accessible only within its own scope. Possible conflicts between identifiers, resulting from this process, resolved by suitable systematic changes of the identifiers involved.\n\n5.2. Array declarations\n\n5.2.1 Syntax\n\n<lower bound> ::= <arithmetic expression> <upper bound> ::= <arithmetic expression> <bound pair> ::= <lower bound> : <upper bound> <bound pair list> ::= <bound pair> | <bound pair list> , <bound pair> <array segment> ::= <array identifier> [ <bound pair list> ] | <array identifier> , <array segment> <array list> ::= <array segment> | <array list> , <array segment> <array declarer> ::= <type> array | array <array declaration> ::= <local or own> <array declarer> <array list>\n\n5.2.2. Examples\n\narray a, b, c[7:n, 2:m], s[-2:10] own integer array A[2:20] real array q [-7: if c < 0 then 2 else 1]\n\n5.2.3. Semantics\n\nAn array declaration declares one or several identifiers to represent multidimensional arrays of subscripted variables and gives the dimensions of the arrays, the bounds of the subscripts, and the types of the variables.\n\n5.2.3.1. Subscript bounds\n\nThe subscript bounds for any array are given in the first subscript brackets following the identifier of this array in the form of a bound pair list. Each item of this list gives the lower and upper bounds of a subscript in the form of two arithmetic expressions separated by the delimiter :. The bound pair list gives the bounds of all subscripts taken in order from left to right.\n\n5.2.3.2. Dimensions\n\nThe dimensions are given as the number of entries in the bound pair lists.\n\n5.2.3.3. Types\n\nAll arrays declared in one declaration are of the same quoted type. If no type declarator is given the real type is understood.\n\n5.2.4. Lower upper bound expressions\n\n5.2.4.1. The expressions will be evaluated in the same way as subscript expression (see Section 3.1.4.2).\n\n5.2.4.2. The expressions cannot include any identifier that is declared, either explicitly or implicitly (see Section 4.1.3), in the same block head as the array in question. The bounds of an array declared as own may only be of the syntactic form integer (see Section 2.5.1).\n\n5.2.4.3. An array is defined only when the values of all upper subscript bounds are not smaller than those of the corresponding lower bounds. If any lower subscript bound is greater that the corresponding upper bound, the array has no component.\n\n5.2.4.4. The expressions will be evaluated once at each entrance into the block.\n\n5.3. Switch designators\n\n5.3.1 Syntax\n\n<switch list> ::= <designational expression> | <switch list> , <designational expression> <switch declaration> ::= switch <switch identifier> := <switch list>\n\n5.3.2. Examples\n\nswitch S := S1, S2, Q[m], if v > -5 then S3 else S4 switch Q := p1, w\n\n5.3.3. Semantics\n\nA switch declaration defines the set of values of the corresponding switch designators. These values are given one by one as the values of the designational expressions entered in the switch list. With each of these designational expressions there is associated a positive integer, 1, 2, . . ., obtained by counting the items in the list from left to right. The value of the switch designator corresponding to a given value of the subscript expression (see Section 3.5 Designational expressions) is the value of the designational expression in the switch list having this given value as its associated integer.\n\n5.3.4. Evaluation of expressions in the switch list\n\nAn expression in the switch list will be evaluated every time the item of the list in which the expression occurs is referred to, using the current values of all variables involved.\n\n5.3.5. Influence of scopes\n\nIf a switch designator occurs outside the scope of a quantity entering into a designational expression in the switch list, and an evaluation of this switch designator selects this designational expression, then the conflicts between the identifiers for the quantities in this expression and the identifiers whose declarations are valid at the place of the switch designator will be avoided through suitable systematic changes of the latter identifiers.\n\n5.4. Procedure declarations\n\n5.4.1 Syntax\n\n<formal parameter> ::= <identifier> <formal parameter list> ::= <formal parameter> | <formal parameter list> <parameter delimiter> <formal parameter> <formal parameter part> ::= <empty> | ( <formal parameter list> ) <identifier list> ::= <identifier> | <identifier list> , <identifier> <value part> ::= value <identifier list> ; | <empty> <specifier> ::= string | <type> | <array declarer> | label | switch | procedure | <type> procedure <specification part> ::= <empty> | <specifier> <identifier list> ; | <specification part> <specifier> <identifier list> <procedure heading> ::= <procedure identifier> <formal parameter part> ; <value part> <specification part> <procedure body> ::= <statement> | <code> <procedure declaration> ::= procedure <procedure heading> <procedure body> | <type> procedure <procedure heading> <procedure body>\n\n5.4.2. Examples (see also the examples in Appendix 2)\n\nprocedure Spur(a) Order:(n) Result:(s); value n; array a; integer n; real s; begin integer k; s := 0; for k := 1 step 1 until n do s := s + a[k, k] end procedure Transpose(a) Order:(n); value n; array a; integer n; begin real w; integer i, k; for i := 1 step 1 until n do for k := 1 + i step 1 until n do begin w := a[i, k]; a[i, k] := a[k, i]; a[k, i] := w end end Transpose integer procedure Step(u); real u; Step := if 0 u u 1 then 1 else 0 procedure Absmax(a) Size:(n, m) Result:(y) Subscripts:(i, k); value n, m; array a; integer n, m, i, k; real y; comment The absolute greatest element of the matrix a, of size n by m is transferred to y, and the subscripts of this element to i and k; begin integer p, q; y := 0; i := k := 1; for p:=1 step 1 until n do for q:=1 step 1 until m do if abs(a[p, q]]) > y then begin y :=a bs(a[p, q]); i := p; k := q end end Absmax procedure Innerproduct(a, b) Order:(k, p) Result:(y); value k; integer k, p; real y, a, b; begin real s; s := 0; for p := 1 step 1 until k do s := s + a b; y := s end Innerproduct real procedure euler(fct, eps, tim); value eps, tim; real procedure fct; real eps; integer tim; comment euler computes the sum of fct(i) for i from zero up to infinity by means of a suitably refined euler transformation. The summation is stopped as soon as tim times in succession the absolute value of the terms of the transformed series are found to be less than eps. Hence one should provide a function fct with one integer argument, an upper bound eps, and an integer tim. euler is particularly efficient in the case of a slowly convergent or divergent alternating series; begin integer i, k, n, r; array m[0:15]; real mn, mp, ds, sum; n := t := 0; m[0] := fct(0); sum := m[0]/2; for i := 1, i + 1 while t < tim do begin mn := fct(i); for k := 0 step 1 until n do begin mp := (mn + m[k])/2; m[k] := mn; mn := mp end means; if abs(mn) < abs(m[n]) n < 15 then begin ds := mn/2; n := n + 1; m[n] := mn end accept else ds := mn; sum := sum + ds; t := if abs(ds) < eps then t + 1 else 0 end; euler := sum end euler\n\n5.4.3. Semantics\n\nA procedure declaration serves to define the procedure associated with a procedure identifier. The principal constituent of a procedure declaration is a statement or a piece of code, the procedure body, which through the use of procedure statements and/or function designators may be activated from other parts of the block in the head of which the procedure declaration appears. Associated with the body is a heading, which specifies certain identifiers occurring within the body to represent formal parameters. Formal parameters in the procedure body will, whenever the procedure is activated (see Section 3.2 Function designators and Section 4.7 Procedure statements) be assigned the values of or replaced by actual parameters. Identifiers in the procedure body which are not formal will be wither local or non-local to the body depending on whether they are declared within the body or not. Those of them which are non-local to the body may well be local to the block in the head of which the procedure declaration appears. The procedure body always acts like a block, whether it has the form of one or not. Consequently the scope of any label labelling a statement within the body or the body itself can never extend beyond the procedure body. In addition, if the identifier of a formal parameter is declared anew within the procedure body (including the case of its use as a label as in Section 4.1.3), it is hereby given a local significance and actual parameters which correspond to it are inaccessible throughout the scope of this inner local quantity.\n\nNo identifier may appear more than once in any one formal parameter list, nor may a formal parameter list contain the procedure identifier of the same procedure heading.\n\n5.4.4. Values of function designators\n\nFor a procedure declaration to define the value of a function designator there must, within the procedure body, occur one or more use of the procedure identifier as a destination; at least one of these must be executed, and the type associated with the procedure identifier must be declared through the appearance of a type declarator as the very first symbol of the procedure declaration. The last value so assigned is used to continue the evaluation of the expression in which the function designator occurs. Any occurrence of the procedure identifier within the body of the procedure other than as a destination in an assignment statement denotes activation of the procedure.\n\nIf a go to statement within the procedure, or within any other procedure activated by it, leads to an exit from the procedure, other than through its end, then the execution, of all statements that has been started but not yet completed and which do not contain a label to which the go to statements leads, is abandoned. The values of all variables that still have significance remain as they were immediately before execution of the go to statement.\n\nIf a function designator is used as a procedure statement, then the resulting value is discarded, but such a statement may be used, if desired, for the purpose of invoking side effects.\n\n5.4.5. Specifications\n\nThe heading includes a specification part, giving information about the kinds and types of the formal parameters. In this part no formal parameter may occur more than once.\n\n5.4.6. Code as procedure body.\n\nIt is understood that the procedure body may be expressed in non-ALGOL language. Since it is intended that the use of this feature should be entirely a question of implementation, no further rules concerning this code language can be given within the reference language.\n\n^ top\n\nAppendix 1 Subsets\n\nTwo subsets of ALGOL 60 are defined, denoted as level 1 and level 2. The full language is level 0.\n\nThe level 1 subset is defined as level 0 with the following additional restrictions:\n\n1.The own declarator is not included. 2.Additional restrictions are placed upon actual parameters as given by the following replacement lines to the table in Section 4.7.5.5. 3.Only one alphabet of 26 letters is provided, which is regarded of being the lower case alphabet of the reference language. 4.If deleting every symbol after the twelfth in every identifier would change the action of the program, then the program is undefined.\n\nThe level 2 subset consists of 1-3 of level 1 and in addition:\n\n5.Procedures may not be called recursively, either directly or indirectly. 6.If a parameter is called by name, then the corresponding actual parameter may only be an identifier or a string. 7.The designational expressions occurring in a switch list may only be lables. 8.The specifiers switch, procedure and <type> procedure are not included. 9.A left part list may only be a left part. 10.If deleting every symbol after the sixth in every identifier would change the action of the program, then the program is undefined.\n\n^ top\n\nAppendix 2 The environmental block\n\nAs an example of the use of ALGOL 60, the structure of the environmental block is given in detail.\n\nbegin comment This description of the standard functions and procedures should be taken as definitive only so far as their effects are concerned. An actual implementation should seek to produce these effects in as efficient a manner as practicable. Furthermore, where arithmetic of real quantities are concerned, even the effects must be regarded as defined with only a finite accuracy (see Section 3.3.6). Thus, for example, there is no guarantee that the value of sqrt(x) is exactly equal to the value x 0.5, or that the effects of inreal and outreal will exactly match those given here. ALGOL coding has been replaced by a metalingustic variable (see Section 1.1) in places where the requirement is clear, and there is no simple way of specifying the operations needed in ALGOL; comment Simple functions; real procedure abs(E); value E; real E; abs := if E 0.0 then E else -E; integer procedure iabs(E); value E; integer E; iabs := if E 0 then E else -E; integer procedure sign(E); value E; real E; sign := if E > 0.0 then 1 else if E < 0.0 then -1 else 0; integer procedure entier(E); value E; real E; comment entier := largest integer not greater than E, i.e. E - 1 < entier E; begin integer j; j := E; entier := if j > E then j - 1 else j end entier; comment Mathematical functions; real procedure sqrt(E); value E; real E; if E < 0.0 then fault(`negative sqrt', E) else sqrt := E 0.5; real procedure sin(E); value E; real E; comment sin := sine of E radians; <body>; real procedure cos(E); value E; real E; comment cos := cosine of E radians; <body>; real procedure arctan(E); value E; real E; comment arctan := principal value, in radians, of arctangent of E, i.e. -π/2 arctan π/2; <body>; real procedure ln(E); value E; real E; comment ln := natural logarithm of E; if E 0.0 then fault(`ln not positive', E) else <statement>; real procedure exp(E); value E; real E; comment exp := exponential function of E; if E > ln(maxreal) then fault(`overflow on exp', E) else <statement>; comment Terminating procedures; procedure stop; comment for the use of , see Section 2.1 Letters; go to ; procedure fault(str, r); value r; string str; real r; comment is assumed to denote a standard output channel. For the use of see Section 2.1 Letters. The following calls of fault appear: integer divide by zero, undefined operation in expr, undefined operation in expn, undefined operation in expi, and in the environmental block: sqrt of negative argument, ln of negative or zero argument, overflow on exp function, invalid parameter for outchar, invalid character in ininteger (twice), invalid character in inreal (three times); begin outstring( , `fault '); outstring( , str); outstring( , ` '); outreal( , r); comment additional diagnostics may be output here; stop end fault; comment Input/output procedures; procedure inchar(channel, str, int); value channel; integer channel, int; string str; comment Set int to value corresponding to the first position in str of current character on channel. Set int to zero if character not in str. Move channel pointer to next character; <body>; procedure outchar(channel, str, int); value channel, int; integer channel, int; string str; comment Pass to channel the character in str, corresponding to the value of int; if int < 1 int > length(str) then fault(`character not in string', int) else <statement>; integer procedure length(str); string str; comment length := number of characters in the open string enclosed by the outermost string quotes, after performing any necessary concatenation as defined in Section 2.6.3. Characters forming an inner string (see Section 2.6.3) are counted in an implementation dependent manner; <body>; procedure outstring(channel, str); value channel; integer channel; string str; begin integer m, n; n := length(str); for m := 1 step 1 until n do outchar(channel, str, m) end outstring; procedure outterminator(channel); value channel; integer channel; comment outputs a terminator for use after a number. To be converted into format control instructions in a machine dependent fashion. The terminator should be a space, a newline or a semicolon if ininteger and inreal are to be able to read representations resulting from outinteger and outreal; <body>; procedure ininteger(channel, int); value channel; integer channel, int; comment int takes the value of an integer, as defined in Section 2.5.1, read from channel. The terminator of the integer may be either a space, a newline or a semicolon (if other terminators are to be allowed, they may be added to the end of the string parameter of the call of inchar. No other change is necessary). Any number of spaces or newlines may precede the first character of the integer; begin integer k, m; Boolean b, d; integer procedure ins; begin integer n; comment read one character, converting newlines to spaces. The inner string `NL' behaves as a single character repre- senting newline; inchar(channel, `0123456789-+ ;`NL'', n); ins := if n = 15 then 13 else n end ins; comment pass over initial spaces or newlines; for k := ins while k = 13 do ; comment fault anything except sign or digit; if k = 0 k > 13 then fault(`invalid character', k); if k > 10 then begin comment sign found, d indicates digit not found yet, b indicates whether + or -, m is value so far; d := b := true; m := k - 1 end; for k := ins while k > 0 k < 11 do begin comment deal with further digits; m := 10 m + k - 1; d := true end k loop; comment fault if no digit has been found, or the terminator was invalid; if d k < 13 then fault(`invalid character', k); int := if b then m else -m end ininteger; procedure outinteger(channel, int); value channel, int; integer channel, int; comment Passes to channel the characters representing the value of int, followed by a terminator; begin procedure digits(int); value int; integer int; begin integer j; comment use recursion to evaluate digits from right to left, but print them from left to right; j := int ÷ 10; int := int - 10 j; if j 0 then digits(j); outchar(channel, `0123456789', int + 1) end digits; if int < 0 then begin outchar(channel, `-', 1); int := -int end; digits(int); outterminator(channel) end outinteger; procedure inreal(channel, re); value channel; integer channel; real re; comment re takes the value of a number, as defined in Section 2.5.1, read from channel. Except for the different definitions of a number and an integer the rules are exactly as for ininteger. Spaces or newlines may follow the symbol 10; begin integer j, k, m; real r, s; Boolean b, d; integer procedure ins; begin integer n; comment read one character, converting newlines to spaces. The inner string `NL' behaves as a single character repre- senting newline; inchar(channel, `0123456789-+.10 ;`NL'', n); ins := if n = 17 then 15 else n end ins; comment pass over initial spaces or newlines; for k := ins while k = 15 do ; comment fault anything except sign, digit, point or ten; if k = 0 k > 15 then fault(`invalid character', k); comment b indicates whether + or -, d indicates whether further digits can have any effect, m will count places after the point, r is the value so far. j indicates whether last character read was sign (j = 1), digit before point (j = 2), point (j = 3), digit after point (j = 4), or ten (j = 5); b := k 11; d := true; m := 1; j := if k < 11 then 2 else iabs(k + k - 23); r := if k < 11 then k - 1 else 0.0; if k 14 then begin comment ten not found. Continue until ten or terminator found; for k := ins while k < 14 do begin comment fault for non-numerical character, sign or second point; if k = 0 k = 11 k = 12 k = 13 j > 2 then fault(`invalid character', k); comment deal with digit unless it cannot affect value; if d then begin if k = 13 then begin comment point found; j := 3 end else begin if j < 3 then begin comment deal with digit before point; r := 10.0 r + k - 1 end else begin comment deal with digit after point; s := 10.0 (-m); m := m + 1; r := r + s (k - 1); comment if r = r + s to machine accuracy, further digits cannot affect value; d := r r + s end; if j = 1 j = 3 then j := j + 1 end end end k loop; comment fault if no digit has been found; if j = 1 k 14 j = 3 then fault(`invalid character', k); end; if k = 14 then begin comment deal with exponent part; ininteger(channel, m); r := (if j = 1 j = 5 then 1.0 else r) 10.0 m end; re := if b then r else - r end inreal; procedure outreal(channel, re); value channel, re; integer channel; real re; comment Passes to channel the characters representing the value of re, following by a terminator; begin integer n; comment n gives number of digits to print. Could be given as a constant in any actual implementation; n := entier(1.0 - ln(epsilon) / ln(10.0)); if re < 0.0 then begin outchar(channel, `-', 1); re := - re end; if re < minreal then outstring(channel, 0.0 ) else begin integer j, k, m, p; Boolean float, nines; comment m will hold number of places point must be moved to standardise value of re to have one digit before point; m := 0; comment standardise value of re; for m := m + 1 while re 10.0 do re := re/10.0; for m := m - 1 while re < 1.0 do re := 10.0 re; if re 10.0 then begin comment this can occur only by rounding error, but is a necessary safeguard; re := 1.0; m := m + 1 end; if m n m < -2 then begin comment printing to be in exponent form; float := true; p := 1 end else begin comment printing to be in non-exponent form; float := false; comment if p = 0 point will not be printed. Otherwise point will be after p digits; p := if m = n - 1 m < 0 then 0 else m + 1; if m < 0 then begin outstring(channel, `0.'); if m = -2 then outchar(channel, `0', 1) end end; nines := false; for j := 1 step 1 until n do begin comment if nines is true, all remaining digits must be 9. This can occur only by rounding error, but is a necessary safeguard; if nines then k := 9 else begin comment find digit to print; k := entier(re); if k > 9 then begin k := 9; nines := true end else begin comment move next digit to before point; re := 10.0 (re - k) end end; outchar(channel, `0123456789', k + 1); if j = p then outchar(channel, `.', 1) end j loop; if float then begin comment print exponent part. outinteger includes a call of outterminator; outchar(channel, `10 , 1); outinteger(channel, m) end else outterminator(channel) end end outreal; comment Environmental enquiries; real procedure maxreal; maxreal := <number>; real procedure minreal; minreal := <number>; integer procedure maxint; maxint := <integer>; comment maxreal, minreal, and maxint are, respectively, the maximum allowable positive real number, the minimum allowable positive real number, and the maximum allowable positive integer, such that any valid expression of the form <primary> <arithmetic operator> <primary> will be correctly evaluated, provided that each of the primaries concerned, and the mathematically correct result lies within the open interval (-maxreal, -minreal) or (minreal, maxreal) or is zero if of real type, or within the open interval (-maxint, maxint) if of integer type. If the result is of real type, the words `correctly evaluated' must be understood in the sense of numerical analysis (see Section 3.3.6); real procedure epsilon; comment The smallest positive real number such that the computational result of 1.0 + epsilon is greater than 1.0 and the computational result of 1.0 - epsilon is less than 1.0; epsilon := <number>; comment In any particular implementation, further standard functions and procedures may be added here, but no additional ones may be regarded as part of the reference language (in particular, a less rudimentary input/output system is desirable); <fictitious declaration of own variables>; <initialisation of own variables>; <program>; : end\n\n^ top\n\nReferences\n\nBACKUS, J. W. (1959) The syntax and Semantics of the Proposed International Algebraic Language.\n\nInformation Processing, Paris, UNESCO. ECMA Subset of ALGOL 60 CACM, Vol, 6 (1963), p. 595; European Computer Manufacturers Association (1965) ECMA Standard for a Subset of ALGOL 60. IFIP (1964a) Report on Subset ALGOL 60, Num. Math., Vol. 6, p. 454; CACM, Vol. 7, p. 626. IFIP (1964b) Report on Input-Output Procedures for ALGOL 60, Num. Math., Vol. 6, p. 459;\n\nCACM, Vol. 7, p. 628. ISO (1972) ISO/R 1538, Programming Language ALGOL. KNUTH, D. E. et al. (1964) A Proposal for Input-Output Conventions in ALGOL 60, CACM, Vol. 7, p. 273. KNUTH, D. E. (1967) The Remaining Trouble Spots in ALGOL 60, CACM, Vol. 10, p. 611. NAUR, P. (Editor) (1963) Revised Report on the Algorithmic Language ALGOL 60, CACM, Vol. 6, p. 1; The Computer Journal, Vol. 9, p. 349; Num. Math., Vol. 4, p. 420. UTMAN, R. E. et al. (1963) Suggestions on the ALGOL 60 (Rome) Issues, CACM, Vol. 6, p. 20.\n\n^ top\n\nAlphabetic index of definitions of concepts and syntactic units\n\nAll references are given through section numbers. The references are given in three groups:\n\ndefFollowing the abbreviation `def', reference to the syntactic definition (if any) is given. syntFollowing the abbreviation `synt', references to the occurrences in metalinguistic formulae are given. References already quoted in the def-group are not repeated. textFollowing the word `text', the references to definitions given in text are given.\n\nIndex: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\n\nSymbols\n\n+ see: plus - see: minus see: multiply / ÷ see: divide see: exponentiation < = > see: <relational operator> ¬ see: <logical operator> , see: comma . see: decimal point 10 see: ten : see: colon ; see: semicolon := see: colon equal ( ) see: parenthese [ ] see: subscript bracket ` ' see: string quote\n\nA\n\n<actual parameter>, def 3.2.1, 4.7.1\n\n<actual parameter list>, def 3.2.1, 4.7.1\n\n<actual parameter part>, def 3.2.1, 4.7.1\n\n<adding operator>, def 3.3.1\n\nalphabet, text 2.1\n\narithmetic, text 3.3.6\n\n<arithmetic expression>, def 3.3.1 synt 3, 3.1.1, 3.4.1, 4.2.1, 4.6.1, 5.2.1 text 3.3.3\n\n<arithmetic operator>, def 2.3 text 3.3.4\n\narray, synt 2.3, 5.2.1\n\narray, text 3.1.4.1\n\n<array declaration>, def 5.2.1 synt 5 text 5.2.3\n\n<array declarer>, def 5.2.1, synt 5.4.1\n\n<array identifier>, def 3.1.1 synt 3.2.1, 4.7.1, 5.2.1 text 2.8\n\n<array list>, def 5.2.1\n\n<array segment>, def 5.2.1\n\n<assignment statement>, def 4.2.1 synt 4.1.1 text 1, 4.2.3\n\n^ index\n\nB\n\n<basic statement>, def 4.1.1 synt 4.5.1\n\n<basic symbol>, def 2\n\nbegin, synt 2.3, 4.1.1\n\n<block>, def 4.1.1 synt 4.5.1 text 1, 4.1.3, 5\n\n<block head>, def 4.1.1\n\nBoolean, synt 2.3, 5.1.1 text 5.1.3\n\n<Boolean expression>, def 3.4.1 synt 3, 3.3.1, 4.2.1, 4.5.1, 4.6.1 text 3.4.3\n\n<Boolean factor>, def 3.4.1\n\n<Boolean primary>, def 3.4.1\n\n<Boolean secondary>, def 3.4.1\n\n<Boolean term>, def 3.4.1\n\n<bound pair>, def 5.2.1\n\n<bound pair list>, def 5.2.1\n\n<bracket>, def 2.3\n\n^ index\n\nC\n\n<closed string>, def 2.6.1\n\n<code>, synt 5.4.1 text 4.7.8, 5.4.6\n\ncolon :, synt 2.3, 3.2.1, 4.1.1, 4.5.1, 4.6.1, 4.7.1, 5.2.1\n\ncolon equal :=, synt 2.3, 4.2.1, 4.6.1, 5.3.1\n\ncomma ,, synt 2.3, 3.1.1, 3.2.1, 4.6.1, 4.7.1, 5.1.1, 5.2.1, 5.3.1, 5.4.1\n\ncomment, synt 2.3\n\ncomment convention, text 2.3\n\n<compound statement>, def 4.1.1 synt 4.5.1 text 1\n\n<compound tail>, def 4.1.1\n\n<conditional statement>, def 4.5.1 synt 4.1.1 text 4.5.3\n\n^ index\n\nD\n\n<decimal fraction>, def 2.5.1\n\n<decimal number>, def 2.5.1 text 2.5.3\n\ndecimal point ., synt 2.3, 2.5.1\n\n<declaration>, def 5 synt 4.1.1 text 1, 5\n\n<declarator>, def 2.3\n\n<delimiter>, def 2.3 synt 2\n\n<designational expression>, def 3.5.1 synt 3, 4.3.1, 5.3.1 text 3.5.3\n\n<destination>, def 4.2.1\n\n<digit>, def 2.2.1 synt 2, 2.4.1, 2.5.1\n\ndimension, text 5.2.3.2\n\ndivide / &devide;, synt 2.3, 3.3.1 text 3.3.4.2\n\ndo, synt 2.3, 4.6.1\n\n<dummy statement>, def 4.4.1 synt 4.1.1 text 4.4.3\n\n^ index\n\nE\n\nelse, synt 2.3, 3.3.1, 3.4.1, 3.5.1, 4.5.1 text 4.5.3.2\n\n<empty>, def 1.1 synt 2.6.1, 3.2.1, 4.4.1, 4.7.1, 5.1.1, 5.4.1\n\nend, synt 2.3, 4.1.1\n\nexponentiation , synt 2.3, 3.3.1 text 3.3.4.3\n\n<exponent part>, def 2.5.1 text 2.5.3\n\n<expression>, def 3 synt 3.2.1, 4.7.1 text 3\n\n^ index\n\nF\n\n<factor>, def 3.3.1\n\nfalse, synt 2.2.2\n\nfor, synt 2.3, 4.6.1\n\n<for clause>, def 4.6.1 text 4.6.3\n\n<for list>, def 4.6.1 text 4.6.4\n\n<for list element>, def 4.6.1 text 4.6.4.1, 4.6.4.2, 4.6.4.3\n\n<formal parameter>, def 5.4.1, text 5.4.3\n\n<formal parameter list>, def 5.4.1\n\n<formal parameter part>, def 5.4.1\n\n<for statement>, def 4.6.1 synt 4.1.1, 4.5.1 text 4.6\n\n<function designator>, def 3.2.1 synt 3.3.1, 3.4.1 text 3.2.3, 5.4.4\n\n^ index\n\nG\n\ngo to, synt 2.3, 4.3.1\n\n<go to statement>, def 4.3.1 synt 4.1.1 text 4.3.3\n\n^ index\n\nI\n\n<identifier>, def 2.4.1 synt 3.1.1, 3.2.1, 3.5.1, 5.4.1 text 2.4.3\n\n<identifier list>, def 5.4.1\n\nif, synt 2.3, 3.3.1, 4.5.1\n\n<if clause>, def 3.3.1, 4.5.1 synt 3.4.1, 3.5.1 text 3.3.3, 4.5.3.2\n\n<if statement>, def 4.5.1 text 4.5.3.1\n\n<implication>, def 3.4.1\n\ninteger, synt 2.3, 5.1.1 text 5.1.3\n\n<integer>, def 2.5.1 text 2.5.4\n\n^ index\n\nL\n\nlabel, synt 2.3, 5.4.1\n\n<label>, def 3.5.1 synt 4.1.1, 4.5.1, 4.6.1 text 1, 4.1.3, 4.7.6\n\n<left part>, def 4.2.1\n\n<left part list>, def 4.2.1\n\n<letter>, def 2.1 synt 2, 2.4.1, 3.2.1, 4.7.1\n\n<letter string>, def 3.2.1, 4.7.1\n\nlocal, text 4.1.2\n\n<local or own>, def 5.1.1, synt 5.4.1\n\n<logical operator>, def 2.3 synt 3.4.1 text 3.4.5\n\n<logical value>, def 2.2.2 synt 2, 3.4.1\n\n<lower bound>, def 5.2.1 text 5.2.4\n\n^ index\n\nM\n\nminus -, synt 2.3, 2.5.1, 3.3.1 text 3.3.4.1\n\nmultiply , synt 2.3, 3.3.1 text 3.3.4.1\n\n<multiplying operator>, def 3.3.1\n\n^ index\n\nN\n\nnon-local, text 4.1.3\n\n<number>, def 2.5.1 text 2.5.3, 2.5.4\n\n^ index\n\nO\n\n<open string>, def 2.6.1\n\n<operator>, def 2.3\n\nown, synt 2.3, 5.1.1 text 5, 5.2.5\n\n^ index\n\nP\n\n<parameter delimiter>, def 3.2.1, 4.7.1 synt 5.4.1 text 4.7.7\n\nparentheses ( ), synt 2.3, 3.2.1, 3.3.1, 3.4.1, 3.5.1, 4.7.1, 5.4.1, text 3.3.5.2\n\nplus +, synt 2.3, 2.5.1, 3.3.1 text 3.3.4.1\n\n<primary>, def 3.3.1\n\nprocedure, synt 2.3, 5.4.1\n\n<procedure body>, def 5.4.1\n\n<procedure declaration>, def 5.4.1 synt 5 text 5.4.3\n\n<procedure heading>, def 5.4.1 text 5.4.3\n\n<procedure identifier>, def 3.2.1 synt 3.2.1, 4.2.1, 4.7.1, 5.4.1 text 4.7.5.4\n\n<procedure statement>, def 4.7.1 synt 4.1.1 text 4.7.3\n\n<program>, def 4.1.1 text 1\n\n<proper string>, def 2.6.1\n\n^ index\n\nQ\n\nquantity, text 2.7\n\n^ index\n\nR\n\nreal, synt 2.3, 5.1.1 text 5.1.3\n\n<relation>, def 3.4.1 text 3.4.5\n\n<relational operator>, def 2.3, 3.4.1\n\n^ index\n\nS\n\nscope, text 2.7\n\nsemicolon ;, synt 2.3, 4.1.1, 5.4.1\n\n<separator>, def 2.3\n\n<sequential operator>, def 2.3\n\n<simple arithmetic expression>, def 3.3.1 synt 3.4.1 text 3.3.3\n\n<simple Boolean>, def 3.4.1\n\n<simple designational expression>, def 3.5.1\n\n<simple variable>, def 3.1.1 synt 5.1.1 text 2.4.3\n\n<specification part>, def 5.4.1 text 5.4.5\n\n<specificator>, def 2.3\n\n<specifier>, def 5.4.1\n\nstandard functions and procedures, text 3.2.4\n\nstandard procedures, text 4.7.9\n\n<statement>, def 4.1.1 synt 4.5.1, 4.6.1, 5.4.1 text 4\n\nstatement bracket see: begin end\n\nstep, synt 2.3, 4.6.1 text 4.6.4.2\n\nstring, synt 2.3, 5.4.1\n\n<string>, def 2.6.1 synt 3.2.1, 4.7.1 text 2.6.3\n\nstring quotes ` ', synt 2.3, 2.6.1 text 2.6.3\n\nsubscript, text 3.1.4.1\n\nsubscript bound, text 5.2.3.1\n\nsubscript brackets [ ], synt 2.3, 3.1.1, 3.5.1, 5.2.1\n\n<subscripted variable>, def 3.3.1 text 3.1.4.1\n\n<subscript expression>, def 3.1.1 synt 3.5.1\n\n<subscript list>, def 3.1.1\n\nsuccessor, text 4\n\nswitch, synt 2.3, 5.3.1, 5.4.1\n\n<switch declaration>, def 5.3.1 synt 5 text 5.3.3\n\n<switch designator>, def 3.5.1 text 3.5.3\n\n<switch identifier>, def 5.3.1\n\n^ index\n\nT\n\n<term>, def 3.3.1\n\nten 10, synt 2.3, 2.5.1\n\nthen, synt 2.3, 3.3.1, 4.5.1\n\ntrue, synt 2.2.2\n\n<type>, def 5.1.1 synt 5.4.1 text 2.8\n\n<type declaration>, def 5.1.1 synt 5 text 5.1.3\n\n<type list>, def 5.1.1\n\n^ index\n\nU\n\n<unconditional statement>, def 4.1.1, 4.5.1\n\n<unlabelled basic statement>, def 4.1.1\n\n<unlabelled block>, def 4.1.1\n\n<unlabelled compound>, def 4.1.1\n\n<unsigned integer>, def 2.5.1\n\n<unsigned number>, def 2.5.1 synt 3.3.1\n\nuntil, synt 2.3, 4.6.1 text 4.6.4.2\n\n<upper bound>, def 5.2.1 text 5.2.4\n\n^ index\n\nV\n\nvalue, synt 2.3, 5.4.1\n\nvalue, text 2.8, 3.3.3\n\n<value part>, def 5.4.1 text 4.7.3.1\n\n<variable>, def 3.1.1 synt 3.3.1, 3.4.1, 4.2.1, text 3.1.3\n\n<variable identifier>, def 3.1.1 synt 4.6.1\n\n^ index\n\nW\n\nwhile, synt 2.3, 4.6.1 text 4.6.4.3\n\n^ index\n\nNote.\n\nInsofar as this Modified Report is a correct application of the Supplement to the Revised Report, reproduction for any purpose, but only of the whole text, is explicitly permitted without formality (see The Computer Journal, Vol. 19, p. 287, final paragraph).\n\n^ top\n\nNote on the edition\n\nList of symbols and their representation:\n\n[ ] A blank. Printed like a half box. [10] The ten for the exponent in a real-type number. Printed as a small lowered ten. [ ] The power operator: an uparrow. [ ] The times sign: a cross like an x. [÷] The integer division operator: a - with a dot above and below. [<] Simple: less than. [ ] Simple: less or equal. [=] Simple: equal. [ ] Simple: greater or equal. [>] Simple: greater than. [ ] Simple: not equal. [ ] Simple: logical equivalence. [ ] Simple: logical implication. [ ] Simple: logical or. [ ] Simple: logical and. [¬] Simple: logical not. [ ] The Greek letter Gamma (upper case). [ ] The Greek letter Theta (upper case). [ ] The Greek letter Sigma (upper case). [ ] The Greek letter Omega (upper case).\n\nHTML-edition: N.Landsteiner (n.landsteiner@masswerk.at) 2001-2002\n\nbased on a PDF-document edited by Andrew Makhorin (mao@mai2.rcnet.ru), Department for Applied Informatics, Moscow Aviation Institute, Moscow, Russia.\n\nOriginal publication:\n\nModified Report on the Algorithmic Language ALGOL 60.\n\nThe Computer Journal, Vol. 19, No. 4, Nov. 1976, pp. 364379.\n\nOther AGOL 60 related documents to be found on this site:\n\nAlgol 60 References\n\nRevised Report on the Algorithmic Language ALGOL 60 (1963)\n\nAlgol 60 Versions of Syntax (differences between the Revised Report & the Modified Report)\n\nAlgol 60 - Sample Implementation and Examples\n\nALGOL 60 syntax (EBNF) as compiled from the Revised Report: Syntax of ALGOL 60.\n\nA step further - SIMULA 67: Syntax of SIMULA 67.\n\n^ top"
    }
}