{
    "id": "yago_31468_2",
    "rank": 34,
    "data": {
        "url": "https://common-lisp.net/features",
        "read_more_link": "",
        "language": "en",
        "title": "features.html",
        "top_image": "https://common-lisp.net/static/imgs/favicon.ico",
        "meta_img": "https://common-lisp.net/static/imgs/favicon.ico",
        "images": [
            "https://common-lisp.net/static/imgs/lisplogo.png",
            "https://i.creativecommons.org/l/by/4.0/88x31.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/imgs/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Interactive development\n\nDevelopment in Common Lisp is interactive. There's no separate compile/run/debug cycle. Instead of that, the program is developed while it runs. Compilation is incremental, and functions can be created and updated on the fly. As the program is running, all objects are available and can be inspected all the time. This is much more than a simple REPL; the whole environment, from the IDE to the language is prepared for this type of development.\n\nRobust\n\nCommon Lisp is a carefully designed language with a long history. It was standarized in 1980 and the language has not changed since but it keeps up with the times thanks to its modability and metaprogramming capabilities. This makes it very likely that your program will continue to run unmodified for several years.\n\nExpressive\n\nBeing a meta language, Lisp approach to problem solving is to define idioms (small Domain Specific Languages) as close to the problem domain as possible. This results in very succint and declarative solutions, at a level which is difficult to achieve in other programming languages. CL flexibility also facilitates a bottom-up programming approach.\n\nFast\n\nMost Common Lisp compilers produce fast code. Programs can be type annotated and the compilers can apply optimizations based on them. CL also supports different levels of debugging, safety and speed. Performance is usually better than interpreted languages like Python and Ruby, and close to C in some cases.\n\nUniform\n\nUniformity is present in both syntax and data structures. Everything being an S-expression, there are not many syntax oddities to think about. And Lisp main data structure is the list.\n\nMultiparadigm\n\nLisp implements and can adapt to several programming paradigms. It supports first class functions, closures and destructuring (among other things), commonly present in functional languages. And comes with CLOS, one of the most powerful object systems in existence. Support for other paradigms can often be implemented as a library as has been done for the logic paradigm.\n\nInnovative / Advanced\n\nMethod combinations. Multiple dispatch. Multiple-values. Meta Object protocol.\n\n\"Programs must be written for people to read, and only incidentally for machines to execute.\"\n\n- Abelson & Sussman, SICP, preface to the first edition\n\n\"Lisp is worth learning for the profound enlightenment experience you will have when you finally get it; that experience will make you a better programmer for the rest of your days, even if you never actually use Lisp itself a lot.\"\n\n- Eric Raymond, \"How to Become a Hacker\""
    }
}