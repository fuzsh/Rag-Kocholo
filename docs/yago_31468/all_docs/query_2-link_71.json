{
    "id": "yago_31468_2",
    "rank": 71,
    "data": {
        "url": "https://codedocs.org/what-is/lisp-programming-language",
        "read_more_link": "",
        "language": "en",
        "title": "Lisp (programming language)",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://codedocs.org/images/search.svg",
            "https://codedocs.org/images/logo.png",
            "https://codedocs.org/images/search.svg",
            "https://codedocs.org/images/search.svg",
            "https://codedocs.org/images/print.svg",
            "https://codedocs.org/images/pdf.svg",
            "https://codedocs.org/images/clock.svg",
            "https://codedocs.org/uploads/120px-Lisp_logo.svg.png",
            "https://codedocs.org/uploads/200px-John_McCarthy_Stanford.jpg",
            "https://codedocs.org/uploads/200px-Steve_Russell.jpg",
            "https://codedocs.org/uploads/220px-LISP_machine.jpg",
            "https://codedocs.org/uploads/220px-4.3_BSD_UWisc_VAX_Emulation_Lisp_Manual.png",
            "https://codedocs.org/uploads/300px-Cons-cells.svg.png",
            "https://codedocs.org/uploads/34109fe397fdcff370079185bfdb65826cb5565a",
            "https://codedocs.org/uploads/27px-Wiktionary-logo-v2.svg.png",
            "https://codedocs.org/uploads/20px-Commons-logo.svg.png",
            "https://codedocs.org/uploads/23px-Wikiquote-logo.svg.png",
            "https://codedocs.org/uploads/26px-Wikisource-logo.svg.png",
            "https://codedocs.org/uploads/27px-Wikibooks-logo.svg.png",
            "https://codedocs.org/uploads/27px-Wikiversity_logo_2017.svg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "CS1 errors: missing periodical",
            "All articles with dead external links",
            "Articles with dead external links from December 2017",
            "Articles with permanently dead external links",
            "Webarchive template wayback links",
            "Articles with short description",
            "Short description is different from Wikidata",
            "All articles with unsourced statements",
            "Articles with unsourced statements from March 2010",
            "Articles containing potentially dated statements from 2010",
            "All articles containing potentially dated statements",
            "All accuracy disputes",
            "Articles with disputed statements from April 2013",
            "Articles with unsourced statements from November 2008",
            "CS1 errors: extra text: volume",
            "CS1: long volume value",
            "Pages using Sister project links with wikidata mismatch",
            "Pages using Sister project links with wikidata namespace mismatch",
            "Pages using Sister project links with hidden wikidata",
            "Articles with Curlie links",
            "Wikipedia articles with GND identifiers",
            "Wikipedia articles with BNE identifiers",
            "Wikipedia articles with BNF identifiers",
            "Wikipedia articles with LCCN identifiers",
            "Wikipedia articles with FAST identifiers",
            "Wikipedia articles with MA identifiers",
            "Wikipedia articles with SUDOC identifiers",
            "Lisp (programming language)",
            "Academic programming languages",
            "American inventions",
            "Articles with example Lisp (programming language) code",
            "Dynamically typed programming languages",
            "Extensible syntax programming languages",
            "Functional languages",
            "Lisp programming language family",
            "Programming languages",
            "Programming languages created in 1958",
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Lisp (historically LISP) is a family of programming languages with a long history and a distinctive, fully parenthesized...",
        "meta_lang": "en",
        "meta_favicon": "/images/icon.ico",
        "meta_site_name": "",
        "canonical_link": "https://codedocs.org/what-is/lisp-programming-language",
        "text": "Syntax and semantics\n\nNote: This article's examples are written in Common Lisp (though most are also valid in Scheme).\n\nSymbolic expressions (S-expressions)\n\nLisp is an expression oriented language. Unlike most other languages, no distinction is made between \"expressions\" and \"statements\";[dubious â€“ discuss] all code and data are written as expressions. When an expression is evaluated, it produces a value (in Common Lisp, possibly multiple values), which can then be embedded into other expressions. Each value can be any data type.\n\nMcCarthy's 1958 paper introduced two types of syntax: Symbolic expressions (S-expressions, sexps), which mirror the internal representation of code and data; and Meta expressions (M-expressions), which express functions of S-expressions. M-expressions never found favor, and almost all Lisps today use S-expressions to manipulate both code and data.\n\nThe use of parentheses is Lisp's most immediately obvious difference from other programming language families. As a result, students have long given Lisp nicknames such as Lost In Stupid Parentheses, or Lots of Irritating Superfluous Parentheses.[54] However, the S-expression syntax is also responsible for much of Lisp's power: the syntax is extremely regular, which facilitates manipulation by computer. However, the syntax of Lisp is not limited to traditional parentheses notation. It can be extended to include alternative notations. For example, XMLisp is a Common Lisp extension that employs the metaobject protocol to integrate S-expressions with the Extensible Markup Language (XML).\n\nThe reliance on expressions gives the language great flexibility. Because Lisp functions are written as lists, they can be processed exactly like data. This allows easy writing of programs which manipulate other programs (metaprogramming). Many Lisp dialects exploit this feature using macro systems, which enables extension of the language almost without limit.\n\nLists\n\nA Lisp list is written with its elements separated by whitespace, and surrounded by parentheses. For example, (1 2 foo) is a list whose elements are the three atoms 1, 2, and foo. These values are implicitly typed: they are respectively two integers and a Lisp-specific data type called a \"symbol\", and do not have to be declared as such.\n\nThe empty list () is also represented as the special atom nil. This is the only entity in Lisp which is both an atom and a list.\n\nExpressions are written as lists, using prefix notation. The first element in the list is the name of a function, the name of a macro, a lambda expression or the name of a \"special operator\" (see below). The remainder of the list are the arguments. For example, the function list returns its arguments as a list, so the expression\n\n(list 1 2 (quote foo))\n\nevaluates to the list (1 2 foo). The \"quote\" before the foo in the preceding example is a \"special operator\" which returns its argument without evaluating it. Any unquoted expressions are recursively evaluated before the enclosing expression is evaluated. For example,\n\n(list 1 2 (list 3 4))\n\nevaluates to the list (1 2 (3 4)). Note that the third argument is a list; lists can be nested.\n\nOperators\n\nArithmetic operators are treated similarly. The expression\n\n(+ 1 2 3 4)\n\nevaluates to 10. The equivalent under infix notation would be \"1 + 2 + 3 + 4\".\n\nLisp has no notion of operators as implemented in Algol-derived languages. Arithmetic operators in Lisp are variadic functions (or n-ary), able to take any number of arguments. A C-style '++' increment operator is sometimes implemented under the name incf giving syntax\n\n(incf x)\n\nequivalent to (setq x (+ x 1)), returning the new value of x.\n\n\"Special operators\" (sometimes called \"special forms\") provide Lisp's control structure. For example, the special operator if takes three arguments. If the first argument is non-nil, it evaluates to the second argument; otherwise, it evaluates to the third argument. Thus, the expression\n\n(if nil (list 1 2 \"foo\") (list 3 4 \"bar\"))\n\nevaluates to (3 4 \"bar\"). Of course, this would be more useful if a non-trivial expression had been substituted in place of nil.\n\nLisp also provides logical operators and, or and not. The and and or operators do short circuit evaluation and will return their first nil and non-nil argument respectively.\n\n(or (and \"zero\" nil \"never\") \"James\" 'task 'time)\n\nwill evaluate to \"James\".\n\nLambda expressions and function definition\n\nAnother special operator, lambda, is used to bind variables to values which are then evaluated within an expression. This operator is also used to create functions: the arguments to lambda are a list of arguments, and the expression or expressions to which the function evaluates (the returned value is the value of the last expression that is evaluated). The expression\n\n(lambda (arg) (+ arg 1))\n\nevaluates to a function that, when applied, takes one argument, binds it to arg and returns the number one greater than that argument. Lambda expressions are treated no differently from named functions; they are invoked the same way. Therefore, the expression\n\n((lambda (arg) (+ arg 1)) 5)\n\nevaluates to 6. Here, we're doing a function application: we execute the anonymous function by passing to it the value 5.\n\nNamed functions are created by storing a lambda expression in a symbol using the defun macro.\n\n(defun foo (a b c d) (+ a b c d))\n\n(defun f (a) b...) defines a new function named f in the global environment. It is conceptually similar to the expression:\n\n(setf (fdefinition 'f) #'(lambda (a) (block f b...)))\n\nwhere setf is a macro used to set the value of the first argument fdefinition 'f to a new function object. fdefinition is a global function definition for the function named f. #' is an abbreviation for function special operator, returning a function object.\n\nAtoms\n\nIn the original LISP there were two fundamental data types: atoms and lists. A list was a finite ordered sequence of elements, where each element is either an atom or a list, and an atom was a number or a symbol. A symbol was essentially a unique named item, written as an alphanumeric string in source code, and used either as a variable name or as a data item in symbolic processing. For example, the list (FOO (BAR 1) 2) contains three elements: the symbol FOO, the list (BAR 1), and the number 2.\n\nThe essential difference between atoms and lists was that atoms were immutable and unique. Two atoms that appeared in different places in source code but were written in exactly the same way represented the same object,[citation needed] whereas each list was a separate object that could be altered independently of other lists and could be distinguished from other lists by comparison operators.\n\nAs more data types were introduced in later Lisp dialects, and programming styles evolved, the concept of an atom lost importance.[citation needed] Many dialects still retained the predicate atom for legacy compatibility,[citation needed] defining it true for any object which is not a cons.\n\nConses and lists\n\nMain article: Cons\n\nA Lisp list is implemented as a singly linked list.[55] Each cell of this list is called a cons (in Scheme, a pair), and is composed of two pointers, called the car and cdr. These are respectively equivalent to the data and next fields discussed in the article linked list.\n\nOf the many data structures that can be built out of cons cells, one of the most basic is called a proper list. A proper list is either the special nil (empty list) symbol, or a cons in which the car points to a datum (which may be another cons structure, such as a list), and the cdr points to another proper list.\n\nIf a given cons is taken to be the head of a linked list, then its car points to the first element of the list, and its cdr points to the rest of the list. For this reason, the car and cdr functions are also called first and rest when referring to conses which are part of a linked list (rather than, say, a tree).\n\nThus, a Lisp list is not an atomic object, as an instance of a container class in C++ or Java would be. A list is nothing more than an aggregate of linked conses. A variable which refers to a given list is simply a pointer to the first cons in the list. Traversal of a list can be done by cdring down the list; that is, taking successive cdrs to visit each cons of the list; or by using any of several higher-order functions to map a function over a list.\n\nBecause conses and lists are so universal in Lisp systems, it is a common misconception that they are Lisp's only data structures. In fact, all but the most simplistic Lisps have other data structures, such as vectors (arrays), hash tables, structures, and so forth.\n\nS-expressions represent lists\n\nParenthesized S-expressions represent linked list structures. There are several ways to represent the same list as an S-expression. A cons can be written in dotted-pair notation as (a . b), where a is the car and b the cdr. A longer proper list might be written (a . (b . (c . (d . nil)))) in dotted-pair notation. This is conventionally abbreviated as (a b c d) in list notation. An improper list[56] may be written in a combination of the two â€“ as (a b c . d) for the list of three conses whose last cdr is d (i.e., the list (a . (b . (c . d))) in fully specified form).\n\nList-processing procedures\n\nLisp provides many built-in procedures for accessing and controlling lists. Lists can be created directly with the list procedure, which takes any number of arguments, and returns the list of these arguments.\n\n(list 1 2 'a 3) ;Output: (1 2 a 3)\n\n(list 1 '(2 3) 4) ;Output: (1 (2 3) 4)\n\nBecause of the way that lists are constructed from cons pairs, the cons procedure can be used to add an element to the front of a list. Note that the cons procedure is asymmetric in how it handles list arguments, because of how lists are constructed.\n\n(cons 1 '(2 3)) ;Output: (1 2 3)\n\n(cons '(1 2) '(3 4)) ;Output: ((1 2) 3 4)\n\nThe append procedure appends two (or more) lists to one another. Because Lisp lists are linked lists, appending two lists has asymptotic time complexity O(n){\\displaystyle O(n)}\n\n(append '(1 2) '(3 4)) ;Output: (1 2 3 4)\n\n(append '(1 2 3) '() '(a) '(5 6)) ;Output: (1 2 3 a 5 6)\n\nShared structure\n\nLisp lists, being simple linked lists, can share structure with one another. That is to say, two lists can have the same tail, or final sequence of conses. For instance, after the execution of the following Common Lisp code:\n\n(setf foo (list 'a 'b 'c)) (setf bar (cons 'x (cdr foo)))\n\nthe lists foo and bar are (a b c) and (x b c) respectively. However, the tail (b c) is the same structure in both lists. It is not a copy; the cons cells pointing to b and c are in the same memory locations for both lists.\n\nSharing structure rather than copying can give a dramatic performance improvement. However, this technique can interact in undesired ways with functions that alter lists passed to them as arguments. Altering one list, such as by replacing the c with a goose, will affect the other:\n\n(setf (third foo) 'goose)\n\nThis changes foo to (a b goose), but thereby also changes bar to (x b goose) â€“ a possibly unexpected result. This can be a source of bugs, and functions which alter their arguments are documented as destructive for this very reason.\n\nAficionados of functional programming avoid destructive functions. In the Scheme dialect, which favors the functional style, the names of destructive functions are marked with a cautionary exclamation point, or \"bang\"â€”such as set-car! (read set car bang), which replaces the car of a cons. In the Common Lisp dialect, destructive functions are commonplace; the equivalent of set-car! is named rplaca for \"replace car.\" This function is rarely seen however as Common Lisp includes a special facility, setf, to make it easier to define and use destructive functions. A frequent style in Common Lisp is to write code functionally (without destructive calls) when prototyping, then to add destructive calls as an optimization where it is safe to do so.\n\nSelf-evaluating forms and quoting\n\nLisp evaluates expressions which are entered by the user. Symbols and lists evaluate to some other (usually, simpler) expression â€“ for instance, a symbol evaluates to the value of the variable it names; (+ 2 3) evaluates to 5. However, most other forms evaluate to themselves: if entering 5 into Lisp, it returns 5.\n\nAny expression can also be marked to prevent it from being evaluated (as is necessary for symbols and lists). This is the role of the quote special operator, or its abbreviation ' (one quotation mark). For instance, usually if entering the symbol foo, it returns the value of the corresponding variable (or an error, if there is no such variable). To refer to the literal symbol, enter (quote foo) or, usually, 'foo.\n\nBoth Common Lisp and Scheme also support the backquote operator (termed quasiquote in Scheme), entered with the ` character (grave accent). This is almost the same as the plain quote, except it allows expressions to be evaluated and their values interpolated into a quoted list with the comma , unquote and comma-at ,@ splice operators. If the variable snue has the value (bar baz) then `(foo ,snue) evaluates to (foo (bar baz)), while `(foo ,@snue) evaluates to (foo bar baz). The backquote is most often used in defining macro expansions.[57][58]\n\nSelf-evaluating forms and quoted forms are Lisp's equivalent of literals. It may be possible to modify the values of (mutable) literals in program code. For instance, if a function returns a quoted form, and the code that calls the function modifies the form, this may alter the behavior of the function on subsequent invocations.\n\n(defun should-be-constant () '(one two three)) (let ((stuff (should-be-constant))) (setf (third stuff) 'bizarre)) ; bad! (should-be-constant) ; returns (one two bizarre)\n\nModifying a quoted form like this is generally considered bad style, and is defined by ANSI Common Lisp as erroneous (resulting in \"undefined\" behavior in compiled files, because the file-compiler can coalesce similar constants, put them in write-protected memory, etc.).\n\nLisp's formalization of quotation has been noted by Douglas Hofstadter (in GÃ¶del, Escher, Bach) and others as an example of the philosophical idea of self-reference.\n\nScope and closure\n\nThe Lisp family splits over the use of dynamic or static (a.k.a. lexical) scope. Clojure, Common Lisp and Scheme make use of static scoping by default, while newLISP, Picolisp and the embedded languages in Emacs and AutoCAD use dynamic scoping. Since version 24.1, Emacs uses both dynamic and lexical scoping.\n\nList structure of program code; exploitation by macros and compilers\n\nA fundamental distinction between Lisp and other languages is that in Lisp, the textual representation of a program is simply a human-readable description of the same internal data structures (linked lists, symbols, number, characters, etc.) as would be used by the underlying Lisp system.\n\nLisp uses this to implement a very powerful macro system. Like other macro languages such as C, a macro returns code that can then be compiled. However, unlike C macros, the macros are Lisp functions and so can exploit the full power of Lisp.\n\nFurther, because Lisp code has the same structure as lists, macros can be built with any of the list-processing functions in the language. In short, anything that Lisp can do to a data structure, Lisp macros can do to code. In contrast, in most other languages, the parser's output is purely internal to the language implementation and cannot be manipulated by the programmer.\n\nThis feature makes it easy to develop efficient languages within languages. For example, the Common Lisp Object System can be implemented cleanly as a language extension using macros. This means that if an application needs a different inheritance mechanism, it can use a different object system. This is in stark contrast to most other languages; for example, Java does not support multiple inheritance and there is no reasonable way to add it.\n\nIn simplistic Lisp implementations, this list structure is directly interpreted to run the program; a function is literally a piece of list structure which is traversed by the interpreter in executing it. However, most substantial Lisp systems also include a compiler. The compiler translates list structure into machine code or bytecode for execution. This code can run as fast as code compiled in conventional languages such as C.\n\nMacros expand before the compilation step, and thus offer some interesting options. If a program needs a precomputed table, then a macro might create the table at compile time, so the compiler need only output the table and need not call code to create the table at run time. Some Lisp implementations even have a mechanism, eval-when, that allows code to be present during compile time (when a macro would need it), but not present in the emitted module.[59]\n\nEvaluation and the readâ€“evalâ€“print loop\n\nLisp languages are often used with an interactive command line, which may be combined with an integrated development environment (IDE). The user types in expressions at the command line, or directs the IDE to transmit them to the Lisp system. Lisp reads the entered expressions, evaluates them, and prints the result. For this reason, the Lisp command line is called a readâ€“evalâ€“print loop (REPL).\n\nThe basic operation of the REPL is as follows. This is a simplistic description which omits many elements of a real Lisp, such as quoting and macros.\n\nThe read function accepts textual S-expressions as input, and parses them into an internal data structure. For instance, if you type the text (+ 1 2) at the prompt, read translates this into a linked list with three elements: the symbol +, the number 1, and the number 2. It so happens that this list is also a valid piece of Lisp code; that is, it can be evaluated. This is because the car of the list names a functionâ€”the addition operation.\n\nNote that a foo will be read as a single symbol. 123 will be read as the number one hundred and twenty-three. \"123\" will be read as the string \"123\".\n\nThe eval function evaluates the data, returning zero or more other Lisp data as a result. Evaluation does not have to mean interpretation; some Lisp systems compile every expression to native machine code. It is simple, however, to describe evaluation as interpretation: To evaluate a list whose car names a function, eval first evaluates each of the arguments given in its cdr, then applies the function to the arguments. In this case, the function is addition, and applying it to the argument list (1 2) yields the answer 3. This is the result of the evaluation.\n\nThe symbol foo evaluates to the value of the symbol foo. Data like the string \"123\" evaluates to the same string. The list (quote (1 2 3)) evaluates to the list (1 2 3).\n\nIt is the job of the print function to represent output to the user. For a simple result such as 3 this is trivial. An expression which evaluated to a piece of list structure would require that print traverse the list and print it out as an S-expression.\n\nTo implement a Lisp REPL, it is necessary only to implement these three functions and an infinite-loop function. (Naturally, the implementation of eval will be complex, since it must also implement all special operators like if or lambda.) This done, a basic REPL is one line of code: (loop (print (eval (read)))).\n\nThe Lisp REPL typically also provides input editing, an input history, error handling and an interface to the debugger.\n\nLisp is usually evaluated eagerly. In Common Lisp, arguments are evaluated in applicative order ('leftmost innermost'), while in Scheme order of arguments is undefined, leaving room for optimization by a compiler.\n\nControl structures\n\nLisp originally had very few control structures, but many more were added during the language's evolution. (Lisp's original conditional operator, cond, is the precursor to later if-then-else structures.)\n\nProgrammers in the Scheme dialect often express loops using tail recursion. Scheme's commonality in academic computer science has led some students to believe that tail recursion is the only, or the most common, way to write iterations in Lisp, but this is incorrect. All oft-seen Lisp dialects have imperative-style iteration constructs, from Scheme's do loop to Common Lisp's complex loop expressions. Moreover, the key issue that makes this an objective rather than subjective matter is that Scheme makes specific requirements for the handling of tail calls, and thus the reason that the use of tail recursion is generally encouraged for Scheme is that the practice is expressly supported by the language definition. By contrast, ANSI Common Lisp does not require[60] the optimization commonly termed a tail call elimination. Thus, the fact that tail recursive style as a casual replacement for the use of more traditional iteration constructs (such as do, dolist or loop) is discouraged[61] in Common Lisp is not just a matter of stylistic preference, but potentially one of efficiency (since an apparent tail call in Common Lisp may not compile as a simple jump) and program correctness (since tail recursion may increase stack use in Common Lisp, risking stack overflow).\n\nSome Lisp control structures are special operators, equivalent to other languages' syntactic keywords. Expressions using these operators have the same surface appearance as function calls, but differ in that the arguments are not necessarily evaluatedâ€”or, in the case of an iteration expression, may be evaluated more than once.\n\nIn contrast to most other major programming languages, Lisp allows implementing control structures using the language. Several control structures are implemented as Lisp macros, and can even be macro-expanded by the programmer who wants to know how they work.\n\nBoth Common Lisp and Scheme have operators for non-local control flow. The differences in these operators are some of the deepest differences between the two dialects. Scheme supports re-entrant continuations using the call/cc procedure, which allows a program to save (and later restore) a particular place in execution. Common Lisp does not support re-entrant continuations, but does support several ways of handling escape continuations.\n\nOften, the same algorithm can be expressed in Lisp in either an imperative or a functional style. As noted above, Scheme tends to favor the functional style, using tail recursion and continuations to express control flow. However, imperative style is still quite possible. The style preferred by many Common Lisp programmers may seem more familiar to programmers used to structured languages such as C, while that preferred by Schemers more closely resembles pure-functional languages such as Haskell.\n\nBecause of Lisp's early heritage in list processing, it has a wide array of higher-order functions relating to iteration over sequences. In many cases where an explicit loop would be needed in other languages (like a for loop in C) in Lisp the same task can be accomplished with a higher-order function. (The same is true of many functional programming languages.)\n\nA good example is a function which in Scheme is called map and in Common Lisp is called mapcar. Given a function and one or more lists, mapcar applies the function successively to the lists' elements in order, collecting the results in a new list:\n\n(mapcar #'+ '(1 2 3 4 5) '(10 20 30 40 50))"
    }
}