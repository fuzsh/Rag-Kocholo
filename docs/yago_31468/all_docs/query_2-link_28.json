{
    "id": "yago_31468_2",
    "rank": 28,
    "data": {
        "url": "https://opensource.com/article/21/5/learn-lisp",
        "read_more_link": "",
        "language": "en",
        "title": "Learn the Lisp programming language in 2021",
        "top_image": "https://opensource.com/sites/default/files/lead-images/OSDC_women_computing_4.png",
        "meta_img": "https://opensource.com/sites/default/files/lead-images/OSDC_women_computing_4.png",
        "images": [
            "https://opensource.com/themes/osdc/assets/img/l_supported-by-redhat-white.svg",
            "https://opensource.com/themes/osdc/logo.svg",
            "https://opensource.com/themes/osdc/assets/img/l_supported-by-redhat-white.svg",
            "https://opensource.com/sites/default/files/lead-images/OSDC_women_computing_4.png",
            "https://opensource.com/sites/default/files/styles/article_teaser/public/lead-images/command_line_hereoes_ep7_blog-header-292x521.png?itok=MacZbslw",
            "https://opensource.com/sites/default/files/styles/article_teaser/public/lead-images/retro_old_unix_computer.png?itok=GgNqekmK",
            "https://opensource.com/sites/default/files/styles/article_teaser/public/lead-images/retro_old_unix_computer.png?itok=GgNqekmK",
            "https://opensource.com/sites/default/files/styles/150x150/public/pictures/seth_headshot-lawrence_0.jpg?itok=jZUHBHx4",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/medium/public/osdc_default_avatar_1.png?itok=G0WcUo3c",
            "https://opensource.com/sites/default/files/styles/222x125/public/lead-images/collab-team-pair-programming-code-keyboard.png?itok=iEiqXXDv",
            "https://opensource.com/sites/default/files/styles/222x125/public/lead-images/programming_keyboard_coding.png?itok=OLBqPd92",
            "https://opensource.com/sites/default/files/styles/222x125/public/lead-images/code_computer_development_programming.png?itok=0kgDZpBf",
            "https://opensource.com/themes/osdc/assets/img/cc-by-sa-4.png",
            "https://opensource.com/themes/osdc/logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Seth Kenlon"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "A lot of Lisp code lurks inside big codebases, so it's smart to get familiar with the language.",
        "meta_lang": "en",
        "meta_favicon": "/themes/osdc/assets/img/favicons/favicon.ico",
        "meta_site_name": "Opensource.com",
        "canonical_link": "https://opensource.com/article/21/5/learn-lisp",
        "text": "Lisp was invented in 1958, which makes it the second-oldest computer programming language. It has spawned several modern derivatives, including Common Lisp, Emacs Lisp (Elisp), Clojure, Racket, Scheme, Fennel, and GNU Guile.\n\nPeople who love thinking about the design of programming languages often love Lisp because of how its syntax and data share the same structure: Lisp code is essentially a list of lists, and its name is an acronym for LISt Processing. People who love thinking about the aesthetics of programming languages often hate Lisp because of its frequent use of parentheses for scoping; in fact, it's a common joke that Lisp stands for Lots of Irritating Superfluous Parentheses.\n\nWhether you love or hate its design philosophies, Lisp is an interesting glimpse at the past and, thanks to Clojure and Guile, into the future. You might be surprised how much Lisp code there is lurking within big codebases in any given industry, so it's a good idea to have at least a passing familiarity with the language.\n\nInstall Lisp\n\nThere are many implementations of Lisp. Popular open source versions include SBCL, GNU Lisp, and GNU Common Lisp (GCL). You can install any of these with your distribution's package manager, but for this article I use clisp.\n\nOn Fedora Linux:\n\n$ sudo dnf install clisp\n\nOn Debian:\n\n$ sudo apt install clisp\n\nFor macOS, you can use MacPorts or Homebrew:\n\n$ sudo port install clisp\n\nFor Windows, you can either use clisp on Cygwin or download a GCL binary from gnu.org/software/gcl.\n\nEven though I'm using the clisp command, most of the principles in this article apply to any Lisp. Should you choose to use a different Lisp implementation, the command to run Lisp code is different from what I use in this article (gcl or sbcl instead of clisp, for example) but everything else is the same.\n\nList processing\n\nThe basic unit of Lisp source code is an expression, which is written as a list. For instance, this is a list of an operator (+) and two integers (1 and 2):\n\n(+ 1 2)\n\nIt's also a Lisp expression, using a symbol (+) that evaluates to a function (addition) and two arguments (1 and 2). You can run this expression and others in an interactive Common Lisp environment called REPL (read-eval-print loop). If you're familiar with Python's IDLE, Lisp's REPL should feel somewhat familiar to you.\n\nTo launch a REPL, launch Common Lisp:\n\n$ clisp [1]>\n\nAt the REPL prompt, type a few expressions:\n\n[1]> (+ 1 2) 3 [2]> (- 1 2) -1 [3]> (- 2 1) 1 [4]> (+ 2 3 4) 9\n\nFunctions\n\nNow that you know the basic structure of a Lisp expression, you can utilize Lisp functions in useful ways. The print function takes any argument you provide and displays it on your terminal, while the pprint function \"pretty\" prints it. There are other variations on the print function, but pprint is nice in REPL:\n\n[1]> (pprint \"hello world\") \"hello world\" [2]>\n\nYou can create your own functions with defun. The defun function requires a name for your function and any parameters you want your function to accept:\n\n[1]> (defun myprinter (s) (pprint s)) MYPRINTER [2]> (myprinter \"hello world\") \"hello world\" [3]>\n\nVariables\n\nYou can create variables in Lisp with setf:\n\n[1]> (setf foo \"hello world\") \"hello world\" [2]> (pprint foo) \"hello world\" [3]>\n\nYou can nest expressions within expressions in a kind of pipeline. For instance, you can pretty print the contents of your variable after invoking the string-upcase function to convert its characters to uppercase:\n\n[3]> (pprint (string-upcase foo)) \"HELLO WORLD\" [4]>\n\nLisp is dynamically typed in the sense that you don't have to declare variable types when setting them. Lisp treats integers as integers by default:\n\n[1]> (setf foo 2) [2]> (setf bar 3) [3]> (+ foo bar) 5\n\nIf you intend for an integer to be interpreted as a string, you can quote it:\n\n[4]> (setf foo \"2\") \"2\" [5]> (setf bar \"3\") \"3\" [6]> (+ foo bar) *** - +: \"2\" is not a number The following restarts are available: USE-VALUE :R1 Input a value to be used instead. ABORT :R2 Abort main loop Break 1 [7]>\n\nIn this sample REPL session, both foo and bar are set to quoted numbers, so Lisp interprets them as strings. Math operators can't be used on strings, so REPL drops into a debugger mode. To get out of the debugger, press Ctrl+D on your keyboard.\n\nYou can do some introspection on objects using the typep function, which tests for a specific data type. The tokens T and NIL represent True and False, respectively.\n\n[4]> (typep foo 'string) NIL [5]> (typep foo 'integer) T\n\nThe single quote (') before string and integer prevents Lisp from (incorrectly) evaluating those keywords as variables:\n\n[6]> (typep foo string) *** - SYSTEM::READ-EVAL-PRINT: variable STRING has no value [...]\n\nIt's a shorthand way to protect the terms, normally done with the quote function:\n\n[7]> (typep foo (quote string)) NIL [5]> (typep foo (quote integer)) T\n\nLists\n\nUnsurprisingly, you can also create lists in Lisp:\n\n[1]> (setf foo (list \"hello\" \"world\")) (\"hello\" \"world\")\n\nLists can be indexed with the nth function:\n\n[2]> (nth 0 foo) \"hello\" [3]> (pprint (string-capitalize (nth 1 foo))) \"World\"\n\nExiting REPL\n\nTo end a REPL session, press Ctrl+D on your keyboard, or use the quit keyword in Lisp:\n\n[99]> (quit) $\n\nScripting\n\nLisp can be compiled or used as an interpreted scripting language. The latter is probably the easiest option when you're starting, especially if you're already familiar with Python or shell scripting.\n\nHere's a simple dice roller script written in GNU Common Lisp:\n\n#!/usr/bin/clisp (defun roller (num) (pprint (random (parse-integer (nth 0 num)))) ) (setf userput *args*) (setf *random-state* (make-random-state t)) (roller userput)\n\nThe first line tells your POSIX terminal what executable to use to run the script.\n\nThe roller function, created with defun, uses the random function to print a pseudo-random number up to, and not including, the zeroth item of the num list. The num list hasn't been created yet in the script, but the function doesn't get executed until it's called.\n\nThe next line assigns any argument provided to the script at launch time to a variable called userput. The userput variable is a list, and it's what becomes num once it's passed to the roller function.\n\nThe penultimate line of the script starts a random seed. This provides Lisp with enough entropy to generate a mostly random number.\n\nThe final line invokes the custom roller function, providing the userput list as its sole argument.\n\nSave the file as dice.lisp and mark it executable:\n\n$ chmod +x dice.lisp\n\nFinally, try running it, providing it with a maximum number from which to choose its random number:\n\n$ ./dice.lisp 21 13 $ ./dice.lisp 21 7 $ ./dice.lisp 21 20\n\nNot bad!\n\nYou may notice that your emulated die has a pontential value of 0, and never reaches the maximum number you provide to it as an argument. In other words, this script never rolls 20 on a 20-sided die (unless you count 0 as 20). There's a simple fix to this, and you only need the knowledge gained from this article to do it. Can you fix this bug?\n\nLearn Lisp\n\nWhether you can imagine using Lisp as a utilitarian language for personal scripts, to advance your career, or just as a fun experiment, you can see some particularly inventive uses at the annual Lisp Game Jam (most submissions are open source, so you can view the code to learn from what you play).\n\nLisp is a fun and unique language with an ever-growing developer base and enough historic and emerging dialects to keep programmers from all disciplines happy."
    }
}