{
    "id": "yago_31468_2",
    "rank": 40,
    "data": {
        "url": "https://www.lispworks.com/products/lisp-overview.html",
        "read_more_link": "",
        "language": "en",
        "title": "Common Lisp Language Overview",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.lispworks.com/images/new_small.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Common Lisp has long been the leading language for software research and advanced development projects. Its ability to tackle the biggest problems is unmatched.\n\nCommon Lisp is rich in data types, supported by a high-level language model and garbage collection. In Common Lisp, all data are represented as objects. There are no out-of-language errors. This model encourages a high-level view of programs and an exploratory programming process that make Lisp programmers among the most productive in the world. Evidence for this is presented in Erann Gat's paper Lisp as an Alternative to Java\n\nCommon Lisp has grown and evolved over time, acquiring features and supporting paradigms as they've entered the world of computer science. It is now supported by an ANSI standard (ANSI X3.226:1994). This standard includes the Common Lisp Object System (CLOS); features like multimethods and dynamic class redefinition make CLOS among the most advanced object systems in the world.\n\nAmong the most important features of Common Lisp are:\n\nMachine-independent language model. All operations are performed in terms of program objects, not raw bits.\n\nIterative design process. Common Lisp supports exploratory programming, making programmers more productive.\n\nDynamic patching. Common Lisp programs can be updated while they are running. The ability to install field patches without interrupting service is important for many mission-critical applications.\n\nHigh-level debugging. All debugging is performed within the language model, preventing system crashes and other out-of-language errors.\n\nCommon Lisp Object System (CLOS). Common Lisp provides advanced object-oriented programming, including multiple inheritance, multimethods, class redefinition in running programs, and dynamic type creation. No other language provides an object system so rich in features.\n\nFirst class functions and classes. First class higher-order functions provide control systems that are elegant and powerful.\n\nFirst class classes let you manipulate the object system in running programs, giving you finer degrees of control.\n\nExtensive data types. Objects, structures, lists, vectors, adjustable arrays, hash-tables, and symbols are just a few of Common Lisp's myriad data types.\n\nAdvanced numeric types. The Common Lisp arithmetic package includes unlimited size integers, fractions, complex numbers, and a complete floating point library. Conversion between numeric types occurs automatically.\n\nComplete IO library. Common Lisp includes a portable interface for streams, the file system, and other IO facilities.\n\nExtensive control structures. Complex looping, guard expressions, non-local transfer of control and lexical closures are among the control structures offered by Common Lisp.\n\nCondition system. The Common Lisp condition system is object-based, and supports recovery as well as escape from errors and other exceptional situations.\n\nConsistent syntax. Common Lisp uses a simple consistent syntax that is easy to learn and easy to use from day one.\n\nMacros. A convenient macro system lets Common Lisp programmers create embedded languages, essentially turning their Lisp environment into a domain-specific problem solving tool.\n\nPrograms as data. Common Lisp is a fully reflective language, supporting genetic algorithms, evolutionary programming, and other self-referential programming techniques.\n\nLate-bound types. By leaving type declarations to the programmer's discretion, programs can be simpler and prototyping faster."
    }
}