{
    "id": "yago_31468_2",
    "rank": 8,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/55284/is-lisp-still-useful-in-todays-world-which-version-is-most-used",
        "read_more_link": "",
        "language": "en",
        "title": "Is LISP still useful in today's world? Which version is most used?",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://softwareengineering.stackexchange.com/posts/55284/ivc/0ddf?prg=31bd0636-b670-40ca-aceb-d8eedfbdf006"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2011-03-06T14:03:13",
        "summary": "",
        "meta_description": "I try to teach myself a new programming language in regular intervals of time. Recently, I've read how Lisp and its dialects are at the complete opposite end of the spectrum from languages like C/C...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/55284/is-lisp-still-useful-in-todays-world-which-version-is-most-used",
        "text": "Is LISP still practiced/used in todays world, or is it a legacy language\n\nYes, it is, but you have to know where to look. People who use LISP don't tend to shout too loudly about it but there's a handful of examples of a few high-profile startups having used it to great effect over the last 20 years. It is also very popular with small companies in Europe.\n\nWhat is the most widely used dialect ?\n\nThis is a valid question, but it's not an easy one to answer. It may also not be a particularly useful one to answer: many implementations have a specific focus so are best chosen if they fit your particular problem rather than based on how widely it is otherwise used. Instead, I'll tell you a little bit about your options and you can decide for yourself.\n\nLISP is a family of languages and each of those languages has a family of dialects and implementations. Broadly dialects fall into two camps \"LISPs\" and \"Schemes\".\n\nLISPs: Until relatively recently, Common LISP was king. It was an attempt to unify all the disparate LISPs and, without being unkind, was the \"C++\" of LISP. That is to say, it was a HUGE language. It had everything. Over the last few years, Clojure has appeared. Clojure is a LISP that runs on the Java Virtual Machine and tries to root itself in a functional programming philosophy. Traditionally, other LISPs have been strictly multi-paradigm. Clojure is interesting because it gets both the very best and very worst of both LISP and the JVM. There's still a lot of the verbosity of Java-based languages and they've been fairly free and easy with the syntax so that has lots of knobs and buttons for different things, but they've got some really interesting ideas around datatypes, especially some of the practical ways they have come up with to apply ideas from functional programming.\n\nSchemes: Schemes are a strict subset of LISPs. Scheme was invented by Steele and Sussman and in early life was notable for being used in the MIT Computing 101 Lecture Course. Scheme is defined in the \"Revised^n Report on the Algorithmic Language Scheme (RnRS)\". Yes: they have a maths joke in there. Scheme is a standardised language in a way that other LISPs are not. This helps greatly with portability between implementations, but it's not a silver bullet. The standardisation efforts have tended to be conservative and innovations in the implementations, especially around things like modules, have tended to be disparate. There is also a series of SRFIs (Scheme Requests For Implementation) which is similar to the IETF's RFC process. People use it to standardise small things as needed.\n\nSchemes are different from LISPs that they have a set of hard requirements that they must satisfy, one of which is \"tail call optimisation\" which helps make recursion efficient. Therefore, recursive styles of programming are much more popular in Scheme than in LISP. Scheme is, also without being unkind, like the \"C\" of LISP. That is to say, it's a small languages and you're supposed to be able to keep all of it in your head at once.\n\nThere are currently two Scheme families: Those based on the 5th version (R5RS) and those based on the 6th version (R6RS). The complexity of R6RS was wildly greater than that of any of its predecessors and so many R5RS implementations have opted to skip it, hoping that R7RS will be more similar to R5RS than R6RS. The R7RS standardisation process is currently ongoing and has tried to include both the R5RS implementers' desires as well as those of the R6RS folk by standardising a small base language in their first working group and then commissioning a second working group to standardise the larger features. This will allow the language to have efficient and useful implementations on both tiny embedded hardware as well as more capable machines.\n\nNow I'll be more specific:\n\nPicoLisp is a really, really cool LISP. It's tiny! It's author wrote it for himself and, as I understand it, he's been making a living off of it since the 1980s. If you ever get the opportunity to attend a talk by him then you should do it: he's really interesting and really knows his stuff and you won't get even the smallest sniff of anything mainstream or boring.\n\nI'm not familiar with Common Lisp implementations so I won't comment further on them.\n\nGuile is the official GNU Scheme.\n\nRacket is an R6RS scheme but lately it seems to have widened the net and is trying \"to serve as a platform for language creation, design, and implementation.\".\n\nChicken aims to be a practical Scheme. It's based on R5RS and compiles down to C. This turns out to be a really, really, important advantage as it makes it absolutely trivial to use existing C libraries. Therefore Chicken is probably the most useful scheme for replacing Perl, Python, Ruby, etc, as your day-to-day scripting language. There are several people who have used it exclusively for all their needs for several years. It has an interactive REPL as well as a compiler. The community (both on the mailing list and IRC) are knowledgeable, friendly and helpful.\n\nLook for an implementation with lots of modules: this shows that it's widely usable and means that it's likely to have something that helps with the task at hand.\n\nLook for an implementation with a compiler or, at the very least, something that isn't strictly IDE or REPL based. A lot of the implementations designed for teaching are very difficult to use for general purpose scripting.\n\nI'd recommend Chicken as that's what I use. I've used it in my personal projects and I've used it (and am currently using it) professionally.\n\nI don't want to invest undue effort in something if its totally obsolete - I'd still learn it if it was professionally \"dead\", but only with an academic perspective...\n\nScheme isn't professionally dead, but you might have to go to some lengths to use it in that context. Something like Chicken is far more than an academic pursuit and it can easily cover almost all the bases of whatever high-level languages you currently use.\n\nI'd like to add some perspective about Common Lisp and Scheme. I've avoided clojure due to the JVM, so I don't have a lot of perspective on it.\n\nScheme is a beautiful concise, well defined language. It took a lot of decisions that CL had to make due to legacy, and took the more pure approach. For instance, variables and functions are in the same namespace. The default language is smaller and more concise, which works well for teaching you the sorts of things that lisp is good at, for instance it pressures usage of recursion instead of iteration, since it by default has no iterative loops, and requires tail call optimization. Scheme has a very interesting hygienic macro system, which there is much value to learning. But IMO, I would recommend learning CL-style Unhygienic macros first, of which most(?) scheme dialects offer at least one implementation of, even if it's not a part of the spec. Since it seems very much that you want to learn a language for learning's sake I'd recommend Scheme, since additionally, many of it's concepts are easily transferred to other lisps, and dynamic languages in general.\n\nHaving said that, Scheme's community is fragmented, and other than in a few small pockets, seems to be mostly dedicated to research over getting real work done... For instance every dialect has their own package manager, and packages are most often not portable across dialects, which is a huge problem in the scheme community.\n\nCommon Lisp on the other hand, seems to be the much more pragmatic approach to developing a language. The standard is such that much lisp code is portable between implementations, many compilers are fast and well-optimized. There is a large set of packages, many of which are portable between implementations. And seemingly a (comparatively) large amount of real products are getting created in the language. And with say quicklisp, it's package management feels reasonably close to what you'd get in a modern community like say Ruby, or Node. CL, is however not without flaws, it has a very large spec at this point compared to scheme, and even it's object system CLOS, something that is traditionally written as a library in Lisps, is part of the spec IIRC. And you can feel legacy entrenched through a large amount of the system. The standard build system approach of extracting an image for compilation feels particular arcane, for example.\n\nOtherwise, I said I couldn't speak on clojure, and Emacs Lisp is clearly the appropriate choice if your goal is to write Emacs extensions, and pretty clearly not the appropriate choice for other software.\n\nTLDR; If your goal is to learn, I recommend Scheme. However, if you want to create software, I'd recommend Common Lisp of the two major lisp variants."
    }
}