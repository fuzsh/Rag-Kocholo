{
    "id": "yago_31468_2",
    "rank": 85,
    "data": {
        "url": "http://cseweb.ucsd.edu/classes/sp00/cse151/q1/crocha.html",
        "read_more_link": "",
        "language": "en",
        "title": "Good Programming Languages for AI",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "CSE 151 - ESSAY 1\n\nCristiano Rocha - A94077651\n\nGood Programming Languages for AI\n\nIt is always a big issue when programming something, which language to use. In AI this is no exception. In Europe and Japan Prolog is the preferred choice while in America LISP is usually the way to go. In this text i will try to point out what a good language for AI should have and compare some of the main languages available. AI applications often manipulate complex information that is most easily represented in a novel form. So an AI language should allow full flexibility in defining and manipulating programs as well as data. All programming languages, by definition, provide a means of defining programs, but many languages limit the ways in which a program can be used, or limit the range of programs that can be defined, or require the programmer to explicitly state irrelevant details.\n\nBecause of this need for flexibility a lot of people say that Lisp is the language to go when talking about AI. According to Peter Norvig in the preface of his book \"Paradigms of Artificial Intelligence Programming : Case Studies in Commom Lisp\" , Lisp's flexibility allows it to adapt as programming styles change, but more importantly, Lisp can adapt to your particular programming problem. In other languages you fit your problem to the language; with Lisp you extend the language to fit your problem. I totally agree with that in a sense that a lot of AI programs deals with symbols and their manipulation, and Lisp is great for that because of it's fast prototyping and the macro utility that helps you extend the language in a great way. Because of its flexibility, Lisp has been successfull as a high-level language for rapid prototyping in such areas as AI, graphics, and user interfaces. Lisp makes it easy to define new languages especially targeted to the problem at hand. Also i agree with Peter Norvig in his text comparing Lisp with Python , when he says that programmers love lisp because of the incresead productivity it provides. I loved the fact that the edit-test-debug cycle is so fast in Lisp in CSE 150. It made complex programs easy and fast to write. For example the search algorithms we had to implement were relatively easy and fast to implement. I had implemented before that course a search algorithm for a game in C and it was much longer and harder than in Lisp. It's fascinating in Lisp how you can do such powerful things easily.\n\nJava is one of the main languages today because of the advent of Internet. It has some Lisp features built in like garbage collection and interpretation. A bad thing about it is that it does not have an interactive environment to try things out like Lisp does. But i think it is a very good multi purpose language and since everything nowadays is moved by Internet, i think Java will be one of the main languages to go in AI. Another good language that has a lot of good things from both Lisp and Java is Python. According to Norvig is his text comparing Lisp to Python, this two languages are very similar to each other with some minor differences. The good news is that there exists JPython, a version of Python that is neatly integrated into Java, giving access to the Java GUIs. That is really a very good feature nowdays and the reason why Peter Norvig chose JPython to translate his programs from his AI book so he could have portable GUI demos, and portable http/ftp/html libraries. So JPython might really turn out as a very good AI language having nice Lisp functionality and nice Java portability.\n\nThe other language that is usually referred when speaking about AI is Prolog. I particularly don't have a lot of experience with Prolog, but after reading chapters 7 and 10 of Russell and Norvig book, i was convinced that it's is the best language to program one of the main fields of AI which is logic programming. According to the book in Logic programming any computation can be viewed as a process of making explicit the consequences of choosing a particular program for a particular machine and providing particular inputs. A logic programming language as Prolog makes it possible to write algorithms by augmenting logical sentences with information to control the inference process. Prolog seems to be good for problems in which logic is intimately involved, or whose solutions have a succinct logical characterization. Like other interactive, symbolic languages, Prolog is also good for rapid prototyping. Really Prolog is the best way to go when doing logic programming because of all the support built in the language to do this kind of reasoning. In other languages you could do the same but it would take a while to implement a lot of the utilities needed for this kind of programming that Prolog alredy has inside of it. It must be mentioned that in Europe and Japan, Prolog has been as popular as Lisp for AI work. Prolog shares most of Lisp's advantages in terms of flexibility and conciseness. Recently, Lisp has gained popularity worldwide, and Prolog is becoming more well known in the United States. As a result, the average AI worker today is likely to be bilingual. I also got some nice information on Prolog from a Prolog FAQ site.\n\nThere is a myth that Lisp (and Prolog) are \"special-purpose\" languages, while languages such as Pascal and C are \"general purpose\". According to Norvig , just the reverse is true. Pascal and C are special-purpose languages for manipulating the registers and memory of a von Neumann-style computer. The majority of their syntax is devoted to arithmetic and Boolean expressions, and while they provide some facilities for forming data structures, they have poor mechanisms for procedural abstraction or control abstraction. In addition, they are designed for the state-oriented style of programming: computing a result by changing the value of variable through assignment statements. I partly agree with it. I agree that when abstraction is needed Lisp is much better than C and Pascal. But in implementing neural networks, i had a much easier time doing it in C. It's true that i am much more used to C than to Lisp, but the process of updating weights in the network for me claimed for assignments statements and a language like C. Talking about neural networks, i don't really think it can be described as a programmimg language. It is certainly a method for solving problems, without reasoning much about a particular algorithm, but i don't see it as a programmimg language. It also proved in the cse150 that depending on the problem a good neural net can be pretty hard to find.\n\nMy conclusion about all this is that there is no better language for AI. If you ask a lot of good programmers which is the best language you will probably come into a whole bunch of different languages. My perception is that a good programmer should know all Prolog, Java, Lisp, C and others and use then all depending on the problem he is trying to solve. If a logic reasoning is a clear way to solve the problem go for Prolog. If on the other hand you have a space search problem that fits perfectly to Lisp list and symbols, go for Lisp. If you are implementing a neural network and want to use all the assignments operators, go for something like C. If you want something portable and ready for Internet go for Java. That is, there's no better language to use. Each problem will be easier to solve in a certain language and it's up to the problem to be solved to determine which language to use.\n\nBibliography"
    }
}