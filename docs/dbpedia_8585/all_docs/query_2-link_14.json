{
    "id": "dbpedia_8585_2",
    "rank": 14,
    "data": {
        "url": "https://medium.com/%40nickuzmenkov/build-your-first-python-package-and-automate-it-74053ed1f535",
        "read_more_link": "",
        "language": "en",
        "title": "Build your first python package… and automate it!",
        "top_image": "https://miro.medium.com/v2/resize:fit:1200/1*x1uA7vwt0vFX0P_aIRkSvQ.jpeg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1200/1*x1uA7vwt0vFX0P_aIRkSvQ.jpeg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*M3v-KXG0tuLEMeQqexxIdQ.jpeg",
            "https://miro.medium.com/v2/resize:fill:144:144/1*M3v-KXG0tuLEMeQqexxIdQ.jpeg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Nick Kuzmenkov",
            "medium.com"
        ],
        "publish_date": "2021-11-27T08:04:13.433000+00:00",
        "summary": "",
        "meta_description": "But let’s take a peek at a few steps ahead. Now having your very own piece of software, you have to maintain it, e.g. release bug fixes and/or some new helpful features. Each time you implement a new…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@nickuzmenkov/build-your-first-python-package-and-automate-it-74053ed1f535",
        "text": "Building your first open-source package is so much fun, even if it’s just a learning side-project.\n\nBut let’s take a peek at a few steps ahead. Now having your very own piece of software, you have to maintain it, e.g. release bug fixes and/or some new helpful features. Each time you implement a new idea or fix something, you have to make sure that the upcoming changes won’t break the code. And when you’re done, you have to rebuild the package and redeploy it. The longer this takes, the greater the chances you start asking yourself: is there a way to automate this routine?\n\nThis question is so common, that there are two special terms referring to it: CI (Continuous Integration) and CD (Continuous deployment). Those are rarely meant standalone, so you would see them both throughout like this: CI/CD.\n\nThe former relates to automated developing routine (e.g. testing, maintaining code style, etc.), and the latter relates to automated deployment. A proper CI/CD, being a nice feature for a small solo project, turns out to be a must-have for long-running team projects.\n\nHere I’ll show you just one simple way for setting up CI/CD for your python package with automated tests, code style checks, and deployment. Furthermore, it’s built into version control and has a pretty web interface like this:\n\nWhat I’m talking about is BitBucket pipelines — a powerful yet easy-to-use CI/CD tool. If you’re interested only in automation, just go straight to section 3.\n\nYou will need some basic knowledge of git, and also BitBucket, PyPI, and TestPyPI accounts.\n\n1. Setup your repository\n\nFirst things first. Go to BitBucket and make sure your two-step authentication is on: go to “Personal settings” — “Security” — “Two-step verification”. If this page looks like this:\n\nyou are ready to go for the next steps. If not, do not worry — just follow the instructions on the page. Two-step verification will keep your account as safe as possible, and it is also required to enable pipelines.\n\nOnce you’ve done, go ahead and create a repository. You can fill the form like this:\n\nThink of “Project” as a folder to store similar repositories. If you don’t have any existing projects, type whatever you would like to call it, so BitBucket can create one for you.\n\nOnce created, go to the “Branches” page, click on “Create branch”, and name it “develop”. We will separate the concerns using the master branch as a release branch and keep all the development inside the develop branch.\n\nGo ahead to the repository main page, click on “Repository settings”, and find a section called “Pipelines”. Go to “Settings” in that section and toggle the “Enable Pipelines” switch:\n\nOur pipelines will need TestPyPI and PyPI credentials to deploy your packages, but you should never keep them as plain text inside the repository. Thankfully, BitBucket has a solution for this: secret variables.\n\nFrom the same page, go to “Repository variables” and add four secured variables: PYPI_USERNAME, PYPI_PASSWORD, TEST_PYPI_USERNAME, and TEST_PYPI_PASSWORD:\n\nNow go to the “Workflow” — “Branching model” section and set the development branch to develop, and the production branch to master.\n\n2. Setup your package\n\nNow it’s time to clone your repository and add in some code. Firstly check out the develop branch:\n\nNow you need to initialize the project file structure. Go ahead and create those files and folders one by one:\n\nFeel free to pick your own names for files and folders as long as you keep them consistent throughout the project. However, do not rename files under the root directory. Those are named by convention, so renaming them would break some features and make your code much less readable.\n\nNext place your package under the autodeploy_template directory. If your package is split into multiple files, just copy all of them. I will place in a placeholder class named BarCounter with a single count method which simply shows a progress bar:\n\nAfter you’re done, mention all the classes, functions, and variables from all the module files in the __init__.py:\n\nWe would usually like to cover the code with tests to make sure any time you add a new feature or fix something, you won’t break something else. If you have a unittest ready, copy it into tests/test.py, if not, just leave it blank for now.\n\nWriting tests is somehow boring yet very important part of your project. The sooner you set up proper testing, the more time you save in future.\n\nNow updateREADME.md to make your package’s homepage nice and pretty:\n\nAnother important part is the license. If you’re deploying your package for learning purposes, an MIT license is a good choice. It grants full access to your code to anyone who finds it useful without any warranties from your side. If you find that’s true, copy this to LICENSE.txt file and add your name and surname:\n\nOur setup script will produce some extra files which should not pollute our commits. Place these three lines at the bottom of the .gitignore file to exclude build artifacts from version control:\n\nNow the most important part: the setup.py file. It configures all your package’s contents and all sorts of auxiliary information. Though it seems complicated at first, it turns out to be pretty straightforward:\n\nLet’s quickly look through the main parameters:\n\nthe name is how your package would be named in PyPI: pip install <name>;\n\nthe packages is a list of folders containing python files. It is also how you reference your package when you import it: from <package>.<file> import <Any>;\n\nthe version typically starts from 0.1.0 and increments each time you make a new release. By convention you increment the last digit each time you make a bug fix, the second digit — each time you add a new feature (e.g. BarCounter now accepts bar length parameter), and the third digit only when you make a backward-incompatible change (e.g. BarCounter is renamed to ProgressBarCounter);\n\nthe install_requires is a list of the package dependencies. Make sure you list all the dependencies with the versions used (e.g. tqdm>=4.62.0 means your package requires tqdm version 4.62.0 or newer).\n\nIf manually listing all the dependencies seems annoying, pipreqs is a great tool to automate it. Just install it pip install pipreqs and run pipreqs . (note the dot at the end) inside the project directory. Unlike pip freeze > requirements.txt, which lists all the packages installed, this command would list only those packages that are used inside .py files in the current or subsequent directories saving you a lot of time.\n\nThat’s it! Now, all we have to do is to test the installation. Firstly make sure setuptools, wheel, and twine packages are installed and up to date. Then create a source distribution and the wheels, and then run checks:\n\nIf you feel confused about the terms source distribution and wheel format, don’t worry, I don’t know much about it either. It’s just two ways to build the package so that twine can publish it to the python package index and pip can handle its download and installation.\n\nOnce the checks have passed, push your changes to develop branch: git commit -am 'initial version' && git push.\n\n3. Setup the pipelines\n\nAt this point at some other tutorials you would probably see the next line: twine upload dist/*. And that’s OK, but we want the magic of automation.\n\nSo go ahead and create bitbucket-pipelines.yml file in the root directory with the very first step in it:\n\nIf you’re not familiar with the YAML format, it’s very similar to JSON: both can be read into python dict and hold serialized dicts. Unlike JSONs, YAML files don’t have any braces. A colon represents a key-value pair, strings can be placed both with and without quotation marks, sequence elements are marked with hyphens.\n\nThe first key is pipelines, followed by the key default storing a sequence of operations, or steps. All steps defined in the default section will be applied to every single commit pushed to origin. BitBucket then copies your repository to a remote server and runs each step in a separate Docker container.\n\nDocker is arguably the most powerful tool for virtual environments. Unlike virtualenv (or similar tools) it not only creates a local version of python with all its dependencies but also places your project folder into a virtual machine (called container) starting from scratch each time you run your code. This prevents all system-related inconsistency and makes sure your code runs equally on any machine.\n\nLet’s breakdown the step contents:\n\nthe name is a string with a step summary. It can be whatever you wish as long as all step names are unique;\n\nthe image is a name of a Docker image to pull from Docker Hub public image storage. The convention is <image_name>:<version>-<type>. If you need to run only python and pip commands, then python-slim is the best option. Here we use python-slim version 3.9;\n\nthe script is a sequence of bash commands to run within that step. Here we simply run tests.py file and exit with error code 1 if tests were unsuccessful;\n\nBut enough talking. Make a commit, push it, go to the repository main page, click on “Pipelines” and see the magic!\n\nCongrats on your first successful pipeline!\n\nLet’s go ahead and add another step with code style and linting checks:\n\nHere we use flake8 for linting and black for code style checks. Notice that this step depends on corresponding libraries which aren’t built-in. We provide the caches: pip instruction to make pipelines run faster. All the rest is the same.\n\nOnce again, make a commit and push it.\n\nAs long as we’ve set up the CI part, let’s focus on CD. Add these two final steps to the end of your bitbucket-pipelines.yml file:\n\nNotice that instead of going on in the default section we add another: branches: master. This means that all the subsequent steps will only apply to new commits in the master branch. As long as we don’t deploy our package from any branch except master, that is exactly what we want!\n\nFirst copy the previous two steps (tests and codestyle) from the default section and add two other: Test PyPI and PyPI. These steps are a bit more complex, so I won’t cover them in detail.\n\nMake sure your complete pipeline looks like this:\n\nOnce you’ve pushed the changes to develop, we’re ready to deploy. Merge your develop branch with master (either via git merge or a pull request). Go to the pipelines of the last merge commit.\n\nNotice the two new steps in the pipeline. But wait, why weren’t they executed straight after the previous ones? It’s because we provided the trigger: manual instructions preventing it from running without your permission.\n\nGo ahead and click on the “Deploy” button. After this step executes, go to TestPyPI and make sure the new package has popped up in your profile:\n\nGreat! We now can test the package by installing it (make sure you add the --index-url instruction):\n\nFine, our package is installable and works as expected. But remember that anything deployed to TestPyPI doesn’t affect the real index. So once you are ready return to the repository and click on the second “Deploy” button to deploy it. After it finishes, your project can be installed simply by pip install autodeploy-template.\n\nFurther reading\n\nOh! It’s been quite a lot to do at once. If you’ve followed me along all the way here, it makes me happy. The full project code is available at BitBucket.\n\nActually, CI/CD is a very complex topic both in terms of concepts and technologies involved. We’ve only touched some of the core concepts and tools and there’s still much, much more you can learn about it!\n\nHere are some links for further reading:"
    }
}