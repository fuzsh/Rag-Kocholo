{
    "id": "dbpedia_8585_2",
    "rank": 24,
    "data": {
        "url": "https://pypi.org/project/packit/",
        "read_more_link": "",
        "language": "en",
        "title": "packit",
        "top_image": "https://pypi.org/static/images/twitter.abaf4b19.webp",
        "meta_img": "https://pypi.org/static/images/twitter.abaf4b19.webp",
        "images": [
            "https://pypi.org/static/images/logo-small.8998e9d1.svg",
            "https://pypi-camo.freetls.fastly.net/46b1b67c59f02e43a71853aa3169e39531d268e5/68747470733a2f2f7365637572652e67726176617461722e636f6d2f6176617461722f62663166646361616639383132303363313731363865353738643965613062353f73697a653d3530",
            "https://pypi-camo.freetls.fastly.net/0ee10e0fd627356c7c76193af525c091c181ba29/68747470733a2f2f7365637572652e67726176617461722e636f6d2f6176617461722f32636666623235326130373536643961313931346631366362303766343633653f73697a653d3530",
            "https://pypi-camo.freetls.fastly.net/46b1b67c59f02e43a71853aa3169e39531d268e5/68747470733a2f2f7365637572652e67726176617461722e636f6d2f6176617461722f62663166646361616639383132303363313731363865353738643965613062353f73697a653d3530",
            "https://pypi-camo.freetls.fastly.net/0ee10e0fd627356c7c76193af525c091c181ba29/68747470733a2f2f7365637572652e67726176617461722e636f6d2f6176617461722f32636666623235326130373536643961313931346631366362303766343633653f73697a653d3530",
            "https://pypi.org/static/images/blue-cube.572a5bfb.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi-camo.freetls.fastly.net/ed7074cadad1a06f56bc520ad9bd3e00d0704c5b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f6177732d77686974652d6c6f676f2d7443615473387a432e706e67",
            "https://pypi-camo.freetls.fastly.net/8855f7c063a3bdb5b0ce8d91bfc50cf851cc5c51/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f64617461646f672d77686974652d6c6f676f2d6668644c4e666c6f2e706e67",
            "https://pypi-camo.freetls.fastly.net/df6fe8829cbff2d7f668d98571df1fd011f36192/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f666173746c792d77686974652d6c6f676f2d65684d3077735f6f2e706e67",
            "https://pypi-camo.freetls.fastly.net/420cc8cf360bac879e24c923b2f50ba7d1314fb0/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f676f6f676c652d77686974652d6c6f676f2d616734424e3774332e706e67",
            "https://pypi-camo.freetls.fastly.net/524d1ce72f7772294ca4c1fe05d21dec8fa3f8ea/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f6d6963726f736f66742d77686974652d6c6f676f2d5a443172685444462e706e67",
            "https://pypi-camo.freetls.fastly.net/d01053c02f3a626b73ffcb06b96367fdbbf9e230/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f70696e67646f6d2d77686974652d6c6f676f2d67355831547546362e706e67",
            "https://pypi-camo.freetls.fastly.net/67af7117035e2345bacb5a82e9aa8b5b3e70701d/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f73656e7472792d77686974652d6c6f676f2d4a2d6b64742d706e2e706e67",
            "https://pypi-camo.freetls.fastly.net/b611884ff90435a0575dbab7d9b0d3e60f136466/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f737461747573706167652d77686974652d6c6f676f2d5467476c6a4a2d502e706e67"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-08-25T23:31:23+00:00",
        "summary": "",
        "meta_description": "Python packaging in declarative way (wrapping pbr to make it flexible)",
        "meta_lang": "en",
        "meta_favicon": "/static/images/favicon.35549fe8.ico",
        "meta_site_name": "PyPI",
        "canonical_link": "https://pypi.org/project/packit/",
        "text": "Contents:\n\nRationale\n\nOverview\n\nUsage\n\nFacilities\n\nIncluding Files Other than Python Libraries\n\nFurther Development\n\nRationale\n\nCreating python packages is routine operation that involves a lot of actions that could be automated. Although there are petty good tools like pbr for that purpose, they miss some features and lack flexibility by trying to enforce some strongly opinionated decisions upon you. PacKit tries to solve this by providing a simple, convenient, and flexible way to create and build packages while aiming for following goals:\n\nsimple declarative way to configure your package through setup.cfg following distutils2 setup.cfg syntax\n\nreasonable defaults\n\nopen for extension\n\nOverview\n\nPacKit is wrapper around pbr though it only uses it for interaction with setuptools/distutils through simplified interface. None of pbr functions are exposed but instead PacKit provides its own interface.\n\nAvailable facilities\n\nHere's a brief overview of currently implemented facilities and the list will be extended as new ones will be added.\n\nauto-version - set package version depending on selected versioning strategy.\n\nauto-description - set package long description\n\nauto-license - include license file into distribution\n\nauto-dependencies - populate install_requires and test_requires from requirement files\n\nauto-packages - discover packages to include in distribution.\n\nauto-extra-meta - add useful options to the metadata config section\n\nauto-package-data - include all files tracked by git from package dirs only.\n\nauto-tests - make python setup.py test run tests with tox or pytest (depending on tox.ini presence).\n\nOn top of that PacKit forces easy_install to honor following PIP's fetch directives:\n\nindex_url\n\nfind_links\n\nPlanned facilities\n\nauto-plate - integration with platter\n\nauto-license - fill out license information\n\nauto-pep8 - produce style-check reports\n\nauto-docs - API docs generation\n\nauto-clean - configurable clean jobs\n\nauto-coverage (?) - produce coverage reports while running tests\n\nIf you don't see desired facilities or have cool features in mind feel free to contact us and tell about your ideas.\n\nUsage\n\nCreate a setup.py in your project dir: :\n\nfrom setuptools import setup setup(setup_requires='packit', packit=True)\n\nThat was the first and the last time you touched that file for your project.\n\nNow let's create a setup.cfg that you will use in order to configure your package:\n\n[metadata] name = cool-package\n\nAnd... if you're not doing anything tricky in your package then that's enough! And if you do, take a look at the section below.\n\nFacilities\n\nCurrently all available facilities are enabled by default. Though you can easily turn them off by using facilities section in your setup.cfg:\n\n[facilities] auto-version = 0 auto-dependencies = f auto-packages = false auto-package-data = n auto-tests = no\n\nIf facility is explicitly disabled it won't be used even if facility-specific configuration section is present.\n\nFacility-specific defaults and configuration options described below.\n\nauto-version\n\nWhen enabled, auto-version will generate and set package version according to selected versioning strategy.\n\nVersioning strategy can be selected using type field under auto-version section within setup.cfg. The default is:\n\n[auto-version] type = git-pep440 output = src/templates/version.html\n\nYou can use output field to ask PacKit to write generated version value into specified filename. The specified filename do not need to exist but the parent directories should exist. Provided path should always use forward slashes.\n\ngit-pep440\n\nGenerate PEP440-compliant version from annotated git tags. It's expected that you are using git tags that follow public version identifier description and git-pep440 will just append number of commits since tag was applied to your tag value (the N in public version identifier description).\n\nIf number of commits since tag equal to 0 (your building the tagged version) the N value won't be appended. Otherwise, it will be appended and local version identifier equal to first 7 chars of commit hash will be also added.\n\nPlease note: you must create an annotated tag, otherwise it will be ignored.\n\nExample: 1. <git tag -a 1.2.3.dev -m \"dev release 1.2.3.dev\"> -> version is 1.2.3.dev\n\n<git commit> -> version is 1.2.3.dev.post1\n\n<git commit> -> version is 1.2.3.dev.post2\n\n<git tag -a 1.2.3.a -m \"Release 1.2.3.a\"> -> version is 1.2.3.a\n\n<git commit> -> version is 1.2.3.a.post1\n\n<git tag -a 1.2.3 -m \"Release 1.2.3\"> -> version is 1.2.3\n\n<git commit> -> version is 1.2.3.post1\n\n<git commit> -> version is 1.2.3.post2\n\nfixed\n\nUse value specified in value (it's required when this strategy is used) under auto-version section in setup.cfg:\n\n[auto-version] type = fixed value = 3.3\n\nfile\n\nRead a line using UTF-8 encoding from the file specified in value (it's required when this strategy is used) under auto-version section in setup.cfg, strip it and use as a version.\n\n[auto-version] type = file value = VERSION.txt\n\nshell\n\nExecute command specified in value (it's required when this strategy is used) under auto-version section in setup.cfg, read a line from stdout, strip it and use as a version\n\ncomposite\n\nThe most advanced version strategy designed for special cases. It allows you to generate complex version values based on other version strategies. The usage is pretty simple though:\n\n[auto-version] type = composite value = {foo}.{bar}+{git} output = main.version [auto-version:foo] type = fixed value = 42 output = 1st.version [auto-version:bar] type = shell value = echo $RANDOM [auto-version:git] type = git-pep440 output = 3rd.version\n\nThe value field in composite version strategy should be a valid string format expression.\n\nPlease note that output directives used here only for reference (to show that they can be used anywhere) and are not required.\n\nIt's OK to define 'extra' version components and not use them but it's an error to not define any of components mentioned in composite version template.\n\nauto-description\n\nWhen enabled will fill out long_description for package from a readme.\n\nThe readme file name could be specified with file field under auto-description section.\n\nIf no file name provided, it will be discovered automatically by trying following list of files:\n\nREADME\n\nreadme\n\nCHANGELOG\n\nchangelog\n\nEach of these files will be tried with following extensions:\n\n<without extension>\n\n.md\n\n.markdown\n\n.mkdn\n\n.text\n\n.rst\n\n.txt\n\nThe readme file will be included in the package data.\n\nauto-license\n\nWhen enabled will include the license file into the distribution.\n\nThe license file name could be specified by the file field within auto-license section.\n\nIf license file name is not provided the facility will try to discover it in the current dir trying following file names:\n\nLICENSE\n\nlicense\n\nEach of these files will be tried with following extensions:\n\n<without extension>\n\n.md\n\n.markdown\n\n.mkdn\n\n.text\n\n.rst\n\n.txt\n\nauto-dependencies\n\nWhen enabled will fill install_requires and test_requires from requirement files.\n\nRequirement files could be specified by install and test fields under the auto-dependencies section of the setup.cfg.\n\nIf requirements file names not provided then the facility will try to discover them automatically.\n\nFor installation requirements following paths will be tried:\n\nrequires\n\nrequirements\n\nrequirements/prod\n\nrequirements/release\n\nrequirements/install\n\nrequirements/main\n\nrequirements/base\n\nFor testing requirements following paths will be tried:\n\ntest-requires\n\ntest_requires\n\ntest-requirements\n\ntest_requirements\n\nrequirements_test\n\nrequirements-test\n\nrequirements/test\n\nFor each path following extensions will be tried\n\n<without extension>\n\n.pip\n\n.txt\n\nOnce a file is found, PacKit stops looking for more files.\n\nYou can use vcs project urls and/or archive urls/paths as described in pip usage - they will be split in dependency links and package names during package creation and will be properly handled by pip/easyinstall during installation. Remember that you can also make \"includes\" relationships between requirements.txt files by including a line like -r other-requires-file.txt.\n\nauto-packages\n\nWhen enabled and no packages provided in setup.cfg through packages option under files section will try to automatically find out all packages in current dir recursively.\n\nIt operates using exclude and include values that can be specified under auto-packages section within setup.cfg.\n\nIf exclude not provided the following defaults will be used: test, docs, .tox and env.\n\nIf include not provided, auto-packages will try the following steps in order to generate it:\n\nIf packages_root value provided under files section in setup.cfg, it will be used.\n\nOtherwise the current working dir will be scanned for any python packages (dirs with __init__.py) while honoring exclude value. This packages also will be included into the resulting list of packages.\n\nOnce include value is determined, the resulting packages list will be generated using following algorithm:\n\nfor path in include: found_packages |= set(find_packages(path, exclude))\n\nauto-extra-meta\n\nWhen enabled, adds a number of additional options to 'metadata' section.\n\nRight now, only 1 extra option supported:\n\nis_pure - allows you to override 'purity' flag for distribution, i.e. you can explicitly say whether your distribution is platform-specific or no.\n\nauto-tests\n\nHas no additional configuration options [yet].\n\nWhen enabled, the python setup.py test is equal to running:\n\ntox if tox.ini is present\n\npytest with pytest-gitignore and teamcity-messages plugins enabled by default otherwise (if you need any other plugins just add them to test requirements) and activate them with additional options (see below)\n\nThe facility automatically downloads underlying test framework and install it - you don't need to worry about it.\n\nYou can pass additional parameters to the underlying test framework with '-a' or '--additional-test-args='.\n\nauto-package-data\n\nSee the next section.\n\nIncluding Files Other than Python Libraries\n\nOften, you need to include a data file, or another program, or some other kind of file, with your Python package. Here are a number of common situations, and how to accomplish them using packit:\n\nPlacing data files with the code that uses them: auto-package-data\n\nThe default is that the auto-package-data facility is enabled. In this configuration, you can include data files for your python library very easily by just:\n\nPlacing them inside a Python package directory (so next to an __init__.py or in a subdirectory), and\n\nAdding them to git version control.\n\nsetup.cfg src/ src/nicelib/ src/nicelib/__init__.py src/nicelib/things.py src/nicelib/somedata.csv\n\nNo change in setup.cfg is required. Putting the files here will cause the packaging system to notice them and install them in the same arrangement next to your Python files, but inside the virtualenv where your package is installed.\n\nOnce this is done, you have several easy options for accessing them, and all of these should work the same way in development and once installed:\n\nThe least magical way is pathlib.Path(__file__).parent / 'somedata.csv', or some equivalent with os.path calls. This makes your package non-zip-safe, so it can't be used in a pex or zipapp application.\n\nThe new hotness is importlib.resources.open_text('nicelib', 'somedata.csv') and related functions, available in the stdlib in Python 3.7+ or as a backport in the importlib_resources PyPI package. One limitation is this does not support putting resources deeper in subdirectories.\n\nThe previous standard has been pkg_resources.resource_stream('nicelib', 'somedata.csv') and related functions. This supports deeper subdirectories, but is much slower than importlib.resources. You shouldn't need to install pkg_resources, it's part of setuptools, which is always available these days.\n\nYou can turn off the auto-package-data facility if you don't want this file inclusion mechanism to happen:\n\n[facilities] auto-package-data = no\n\nauto-package-data will not work if your Python package is not at the root of your git repository (setup.py is not next to .git).\n\nPlacing data files relative to the virtual environment\n\nYou can also place files relative to the virtualenv, rather than inside the package hierarchy (which would be in virtualenv/lib/python*/site-packages/something). This is often used for things like static files in a Django project, so that they are easy to find for an external web server. The syntax for this is:\n\n[files] data_files = dest_dir = src_dir/** dest_dir = file_to_put_there\n\nIn this example, dest_dir will be created within the top level of the virtualenv. The contents of src_dir will be placed inside it, along with file_to_put_there.\n\nIf you need to include a compiled executable file in your package, this is a convenient way to do it - include bin = bin/** for example. See the fastatools package for an example of this. There is also a confluence page with more details on including compiled programs.\n\nIncluding Python scripts\n\nScripts need to be treated specially, and not just dropped into bin using data_files, because Python changes the shebang (#!) line to match the virtualenv's python interpreter. This means you can directly run a script without activating a virtualenv - e.g. env/bin/pip install attrs will work even if env isn't activated.[1]\n\nIf you have some scripts already, the easiest thing is to collect them in one directory, then use scripts:\n\n[files] scripts = bin/*\n\nAlternatively, setuptools has a special way to directly invoke a Python function from the command line, called the console_scripts entry point. pull-sp-sub is an internal package that uses this:\n\n[entry_points] console_scripts = pull-sp-sub = pull_sp_sub:main\n\nTo explain that last line, it's name-of-the-script = dotted-path-of-the-python-module:name-of-the-python-function. So with this configuration, once the package is installed, setuptools creates a script at $VIRTUAL_ENV/bin/pull-sp-sub which activates the virtualenv and then calls the main function in the pull_sp_sub module.\n\nScripts created this way are slightly slower to start up than scripts that directly run a Python file. Also, setuptools seems to do more dependency checking when starting a script like this, so if you regularly live with broken dependencies inside your virtualenv, this will be frustrating for you. On the other hand, scripts made this way will work better on Windows, if that's one of your target environments.\n\nIncluding compiled shared libraries in both source and binary packages\n\nThis works because the NCBI Python/Linux environment is so homogeneous, but it does cause problems - these compiled items are linux- and architecture-specific, but this doesn't tell Python's packaging system about that. So for example if you run pip install applog on a Mac, it will claim to succeed, but the library won't work. See the next section for how to do this in a more robust way.\n\nThis includes things that use the C++ Toolkit (see python-applog and cpp-toolkit-validators for examples). These .so files should get placed inside the python package hierarchy. Presumably, if you're compiling them, they are build artifacts that won't be tracked by git, so they won't be included automatically by auto-package-data. Instead, once they are there, use extra_files to have the packaging system notice them:\n\n[files] extra_files = ncbilog/libclog.so ncbilog/libclog.version\n\nIf your packages live inside a src directory, you do need to include that in the extra_files path:\n\n[files] extra_files = src/mypkg/do_something_quickly.so\n\nNotice that extra_files is different from data_files which we used above.\n\nIncluding uncompiled C extensions (including Cython)\n\nPackit can coexist with setuptools's support for C extensions. Here is an example with a C file that will be compiled on the user's system. In that particular package, the author chose to require Cython for developers but not for end users, so the distribution and the git repo include both the .pyx file and the .c file it's translated to.\n\nKnown Issues\n\nIf your Python package is not in the root of your Git repository (so setup.py is not in the same directory as .git), then auto-package-data will not work.\n\nThe auto-package-data section has configuration options, but they don't do anything right now (PY-504).\n\nFurther Development\n\nAdd tests\n\nImprove docs\n\nMore configuration options for existing facilities\n\nNew facilities\n\nAllow extension through entry points"
    }
}