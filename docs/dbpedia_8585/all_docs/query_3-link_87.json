{
    "id": "dbpedia_8585_3",
    "rank": 87,
    "data": {
        "url": "https://laravel.com/docs/11.x/packages",
        "read_more_link": "",
        "language": "en",
        "title": "The PHP Framework For Web Artisans",
        "top_image": "https://laravel.com/img/og-image.jpg",
        "meta_img": "https://laravel.com/img/og-image.jpg",
        "images": [
            "https://laravel.com/img/logomark.min.svg",
            "https://laravel.com/img/logotype.min.svg",
            "https://laravel.com/img/logomark.min.svg",
            "https://laravel.com/img/logotype.min.svg",
            "https://laravel.com/img/icons/drop_arrow.min.svg",
            "https://laravel.com/img/icons/drop_arrow.dark.min.svg",
            "https://laravel.com/img/logomark.min.svg",
            "https://laravel.com/img/social/x.dark.min.svg",
            "https://laravel.com/img/social/x.min.svg",
            "https://laravel.com/img/social/github.dark.min.svg",
            "https://laravel.com/img/social/github.min.svg",
            "https://laravel.com/img/social/discord.dark.min.svg",
            "https://laravel.com/img/social/discord.min.svg",
            "https://laravel.com/img/social/youtube.dark.min.svg",
            "https://laravel.com/img/social/youtube.min.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Laravel is a PHP web application framework with expressive, elegant syntax. We’ve already laid the foundation — freeing you to create without sweating the small things.",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon/apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": "https://laravel.com/docs/11.x/packages",
        "text": "Package Development\n\nIntroduction\n\nA Note on Facades\n\nPackage Discovery\n\nService Providers\n\nResources\n\nConfiguration\n\nMigrations\n\nRoutes\n\nLanguage Files\n\nViews\n\nView Components\n\n\"About\" Artisan Command\n\nCommands\n\nPublic Assets\n\nPublishing File Groups\n\nIntroduction\n\nPackages are the primary way of adding functionality to Laravel. Packages might be anything from a great way to work with dates like Carbon or a package that allows you to associate files with Eloquent models like Spatie's Laravel Media Library.\n\nThere are different types of packages. Some packages are stand-alone, meaning they work with any PHP framework. Carbon and Pest are examples of stand-alone packages. Any of these packages may be used with Laravel by requiring them in your composer.json file.\n\nOn the other hand, other packages are specifically intended for use with Laravel. These packages may have routes, controllers, views, and configuration specifically intended to enhance a Laravel application. This guide primarily covers the development of those packages that are Laravel specific.\n\nA Note on Facades\n\nWhen writing a Laravel application, it generally does not matter if you use contracts or facades since both provide essentially equal levels of testability. However, when writing packages, your package will not typically have access to all of Laravel's testing helpers. If you would like to be able to write your package tests as if the package were installed inside a typical Laravel application, you may use the Orchestral Testbench package.\n\nPackage Discovery\n\nA Laravel application's bootstrap/providers.php file contains the list of service providers that should be loaded by Laravel. However, instead of requiring users to manually add your service provider to the list, you may define the provider in the extra section of your package's composer.json file so that it is automatically loaded by Laravel. In addition to service providers, you may also list any facades you would like to be registered:\n\nOnce your package has been configured for discovery, Laravel will automatically register its service providers and facades when it is installed, creating a convenient installation experience for your package's users.\n\nOpting Out of Package Discovery\n\nIf you are the consumer of a package and would like to disable package discovery for a package, you may list the package name in the extra section of your application's composer.json file:\n\nYou may disable package discovery for all packages using the * character inside of your application's dont-discover directive:\n\nService Providers\n\nService providers are the connection point between your package and Laravel. A service provider is responsible for binding things into Laravel's service container and informing Laravel where to load package resources such as views, configuration, and language files.\n\nA service provider extends the Illuminate\\Support\\ServiceProvider class and contains two methods: register and boot. The base ServiceProvider class is located in the illuminate/support Composer package, which you should add to your own package's dependencies. To learn more about the structure and purpose of service providers, check out their documentation.\n\nResources\n\nConfiguration\n\nTypically, you will need to publish your package's configuration file to the application's config directory. This will allow users of your package to easily override your default configuration options. To allow your configuration files to be published, call the publishes method from the boot method of your service provider:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->publishes([\n\n__DIR__.'/../config/courier.php'=>config_path('courier.php'),\n\n]);\n\n}\n\nNow, when users of your package execute Laravel's vendor:publish command, your file will be copied to the specified publish location. Once your configuration has been published, its values may be accessed like any other configuration file:\n\n$value=config('courier.option');\n\nDefault Package Configuration\n\nYou may also merge your own package configuration file with the application's published copy. This will allow your users to define only the options they actually want to override in the published copy of the configuration file. To merge the configuration file values, use the mergeConfigFrom method within your service provider's register method.\n\nThe mergeConfigFrom method accepts the path to your package's configuration file as its first argument and the name of the application's copy of the configuration file as its second argument:\n\n/**\n\n* Register any application services.\n\n*/\n\npublicfunctionregister():void\n\n{\n\n$this->mergeConfigFrom(\n\n__DIR__.'/../config/courier.php', 'courier'\n\n);\n\n}\n\nRoutes\n\nIf your package contains routes, you may load them using the loadRoutesFrom method. This method will automatically determine if the application's routes are cached and will not load your routes file if the routes have already been cached:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->loadRoutesFrom(__DIR__.'/../routes/web.php');\n\n}\n\nMigrations\n\nIf your package contains database migrations, you may use the publishesMigrations method to inform Laravel that the given directory or file contains migrations. When Laravel publishes the migrations, it will automatically update the timestamp within their filename to reflect the current date and time:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->publishesMigrations([\n\n__DIR__.'/../database/migrations'=>database_path('migrations'),\n\n]);\n\n}\n\nLanguage Files\n\nIf your package contains language files, you may use the loadTranslationsFrom method to inform Laravel how to load them. For example, if your package is named courier, you should add the following to your service provider's boot method:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');\n\n}\n\nPackage translation lines are referenced using the package::file.line syntax convention. So, you may load the courier package's welcome line from the messages file like so:\n\nechotrans('courier::messages.welcome');\n\nYou can register JSON translation files for your package using the loadJsonTranslationsFrom method. This method accepts the path to the directory that contains your package's JSON translation files:\n\nPublishing Language Files\n\nIf you would like to publish your package's language files to the application's lang/vendor directory, you may use the service provider's publishes method. The publishes method accepts an array of package paths and their desired publish locations. For example, to publish the language files for the courier package, you may do the following:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->loadTranslationsFrom(__DIR__.'/../lang', 'courier');\n\n$this->publishes([\n\n__DIR__.'/../lang'=>$this->app->langPath('vendor/courier'),\n\n]);\n\n}\n\nNow, when users of your package execute Laravel's vendor:publish Artisan command, your package's language files will be published to the specified publish location.\n\nViews\n\nTo register your package's views with Laravel, you need to tell Laravel where the views are located. You may do this using the service provider's loadViewsFrom method. The loadViewsFrom method accepts two arguments: the path to your view templates and your package's name. For example, if your package's name is courier, you would add the following to your service provider's boot method:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');\n\n}\n\nPackage views are referenced using the package::view syntax convention. So, once your view path is registered in a service provider, you may load the dashboard view from the courier package like so:\n\nRoute::get('/dashboard', function() {\n\nreturnview('courier::dashboard');\n\n});\n\nOverriding Package Views\n\nWhen you use the loadViewsFrom method, Laravel actually registers two locations for your views: the application's resources/views/vendor directory and the directory you specify. So, using the courier package as an example, Laravel will first check if a custom version of the view has been placed in the resources/views/vendor/courier directory by the developer. Then, if the view has not been customized, Laravel will search the package view directory you specified in your call to loadViewsFrom. This makes it easy for package users to customize / override your package's views.\n\nPublishing Views\n\nIf you would like to make your views available for publishing to the application's resources/views/vendor directory, you may use the service provider's publishes method. The publishes method accepts an array of package view paths and their desired publish locations:\n\n/**\n\n* Bootstrap the package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->loadViewsFrom(__DIR__.'/../resources/views', 'courier');\n\n$this->publishes([\n\n__DIR__.'/../resources/views'=>resource_path('views/vendor/courier'),\n\n]);\n\n}\n\nNow, when users of your package execute Laravel's vendor:publish Artisan command, your package's views will be copied to the specified publish location.\n\nView Components\n\nIf you are building a package that utilizes Blade components or placing components in non-conventional directories, you will need to manually register your component class and its HTML tag alias so that Laravel knows where to find the component. You should typically register your components in the boot method of your package's service provider:\n\nuse Illuminate\\Support\\Facades\\Blade;\n\nuse VendorPackage\\View\\Components\\AlertComponent;\n\n/**\n\n* Bootstrap your package's services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\nBlade::component('package-alert', AlertComponent::class);\n\n}\n\nOnce your component has been registered, it may be rendered using its tag alias:\n\nAutoloading Package Components\n\nAlternatively, you may use the componentNamespace method to autoload component classes by convention. For example, a Nightshade package might have Calendar and ColorPicker components that reside within the Nightshade\\Views\\Components namespace:\n\nuse Illuminate\\Support\\Facades\\Blade;\n\n/**\n\n* Bootstrap your package's services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\nBlade::componentNamespace('Nightshade\\\\Views\\\\Components', 'nightshade');\n\n}\n\nThis will allow the usage of package components by their vendor namespace using the package-name:: syntax:\n\nBlade will automatically detect the class that's linked to this component by pascal-casing the component name. Subdirectories are also supported using \"dot\" notation.\n\nAnonymous Components\n\nIf your package contains anonymous components, they must be placed within a components directory of your package's \"views\" directory (as specified by the loadViewsFrom method). Then, you may render them by prefixing the component name with the package's view namespace:\n\n\"About\" Artisan Command\n\nLaravel's built-in about Artisan command provides a synopsis of the application's environment and configuration. Packages may push additional information to this command's output via the AboutCommand class. Typically, this information may be added from your package service provider's boot method:\n\nuse Illuminate\\Foundation\\Console\\AboutCommand;\n\n/**\n\n* Bootstrap any application services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\nAboutCommand::add('My Package', fn() => ['Version'=>'1.0.0']);\n\n}\n\nCommands\n\nTo register your package's Artisan commands with Laravel, you may use the commands method. This method expects an array of command class names. Once the commands have been registered, you may execute them using the Artisan CLI:\n\nuse Courier\\Console\\Commands\\InstallCommand;\n\nuse Courier\\Console\\Commands\\NetworkCommand;\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\nif ($this->app->runningInConsole()) {\n\n$this->commands([\n\nInstallCommand::class,\n\nNetworkCommand::class,\n\n]);\n\n}\n\n}\n\nPublic Assets\n\nYour package may have assets such as JavaScript, CSS, and images. To publish these assets to the application's public directory, use the service provider's publishes method. In this example, we will also add a public asset group tag, which may be used to easily publish groups of related assets:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->publishes([\n\n__DIR__.'/../public'=>public_path('vendor/courier'),\n\n], 'public');\n\n}\n\nNow, when your package's users execute the vendor:publish command, your assets will be copied to the specified publish location. Since users will typically need to overwrite the assets every time the package is updated, you may use the --force flag:\n\nPublishing File Groups\n\nYou may want to publish groups of package assets and resources separately. For instance, you might want to allow your users to publish your package's configuration files without being forced to publish your package's assets. You may do this by \"tagging\" them when calling the publishes method from a package's service provider. For example, let's use tags to define two publish groups for the courier package (courier-config and courier-migrations) in the boot method of the package's service provider:\n\n/**\n\n* Bootstrap any package services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\n$this->publishes([\n\n__DIR__.'/../config/package.php'=>config_path('package.php')\n\n], 'courier-config');\n\n$this->publishesMigrations([\n\n__DIR__.'/../database/migrations/'=>database_path('migrations')\n\n], 'courier-migrations');\n\n}"
    }
}