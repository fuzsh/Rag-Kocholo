{
    "id": "dbpedia_8585_2",
    "rank": 15,
    "data": {
        "url": "https://pypi.org/project/autotyping/",
        "read_more_link": "",
        "language": "en",
        "title": "autotyping",
        "top_image": "https://pypi.org/static/images/twitter.abaf4b19.webp",
        "meta_img": "https://pypi.org/static/images/twitter.abaf4b19.webp",
        "images": [
            "https://pypi.org/static/images/logo-small.8998e9d1.svg",
            "https://pypi-camo.freetls.fastly.net/96aac0d362aaad7a810df98f54e229bb9cb45714/68747470733a2f2f7365637572652e67726176617461722e636f6d2f6176617461722f35376461346432653261353237303236626161616162333565363837326661353f73697a653d3530",
            "https://pypi-camo.freetls.fastly.net/96aac0d362aaad7a810df98f54e229bb9cb45714/68747470733a2f2f7365637572652e67726176617461722e636f6d2f6176617461722f35376461346432653261353237303236626161616162333565363837326661353f73697a653d3530",
            "https://pypi.org/static/images/blue-cube.572a5bfb.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi.org/static/images/white-cube.2351a86c.svg",
            "https://pypi-camo.freetls.fastly.net/ed7074cadad1a06f56bc520ad9bd3e00d0704c5b/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f6177732d77686974652d6c6f676f2d7443615473387a432e706e67",
            "https://pypi-camo.freetls.fastly.net/8855f7c063a3bdb5b0ce8d91bfc50cf851cc5c51/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f64617461646f672d77686974652d6c6f676f2d6668644c4e666c6f2e706e67",
            "https://pypi-camo.freetls.fastly.net/df6fe8829cbff2d7f668d98571df1fd011f36192/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f666173746c792d77686974652d6c6f676f2d65684d3077735f6f2e706e67",
            "https://pypi-camo.freetls.fastly.net/420cc8cf360bac879e24c923b2f50ba7d1314fb0/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f676f6f676c652d77686974652d6c6f676f2d616734424e3774332e706e67",
            "https://pypi-camo.freetls.fastly.net/524d1ce72f7772294ca4c1fe05d21dec8fa3f8ea/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f6d6963726f736f66742d77686974652d6c6f676f2d5a443172685444462e706e67",
            "https://pypi-camo.freetls.fastly.net/d01053c02f3a626b73ffcb06b96367fdbbf9e230/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f70696e67646f6d2d77686974652d6c6f676f2d67355831547546362e706e67",
            "https://pypi-camo.freetls.fastly.net/67af7117035e2345bacb5a82e9aa8b5b3e70701d/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f73656e7472792d77686974652d6c6f676f2d4a2d6b64742d706e2e706e67",
            "https://pypi-camo.freetls.fastly.net/b611884ff90435a0575dbab7d9b0d3e60f136466/68747470733a2f2f73746f726167652e676f6f676c65617069732e636f6d2f707970692d6173736574732f73706f6e736f726c6f676f732f737461747573706167652d77686974652d6c6f676f2d5467476c6a4a2d502e706e67"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-03-25T20:24:49+00:00",
        "summary": "",
        "meta_description": "A tool for autoadding simple type annotations.",
        "meta_lang": "en",
        "meta_favicon": "/static/images/favicon.35549fe8.ico",
        "meta_site_name": "PyPI",
        "canonical_link": "https://pypi.org/project/autotyping/",
        "text": "When I refactor code I often find myself tediously adding type annotations that are obvious from context: functions that don't return anything, boolean flags, etcetera. That's where autotyping comes in: it automatically adds those types and inserts the right annotations.\n\nUsage\n\nHere's how to use it:\n\npip install autotyping\n\npython -m autotyping /path/to/my/code\n\nBy default it does nothing; you have to add flags to make it do more transformations. The following are supported:\n\nAnnotating return types:\n\n--none-return: add a -> None return type to functions without any return, yield, or raise in their body\n\n--scalar-return: add a return annotation to functions that only return literal bool, str, bytes, int, or float objects.\n\nAnnotating parameter types:\n\n--bool-param: add a : bool annotation to any function parameter with a default of True or False\n\n--int-param, --float-param, --str-param, --bytes-param: add an annotation to any parameter for which the default is a literal int, float, str, or bytes object\n\n--annotate-optional foo:bar.Baz: for any parameter of the form foo=None, add Baz, imported from bar, as the type. For example, use --annotate-optional uid:my_types.Uid to annotate any uid in your codebase with a None default as Optional[my_types.Uid].\n\n--annotate-named-param foo:bar.Baz: annotate any parameter with no default that is named foo with bar.Baz. For example, use --annotate-named-param uid:my_types.Uid to annotate any uid parameter in your codebase with no default as my_types.Uid.\n\n--guess-common-names: infer certain parameter types from their names based on common patterns in open-source Python code. For example, infer that a verbose parameter is of type bool.\n\nAnnotating magical methods:\n\n--annotate-magics: add type annotation to certain magic methods. Currently this does the following:\n\n__str__ returns str\n\n__repr__ returns str\n\n__len__ returns int\n\n__length_hint__ returns int\n\n__init__ returns None\n\n__del__ returns None\n\n__bool__ returns bool\n\n__bytes__ returns bytes\n\n__format__ returns str\n\n__contains__ returns bool\n\n__complex__ returns complex\n\n__int__ returns int\n\n__float__ returns float\n\n__index__ returns int\n\n__exit__: the three parameters are Optional[Type[BaseException]], Optional[BaseException], and Optional[TracebackType]\n\n__aexit__: same as __exit__\n\n--annotate-imprecise-magics: add imprecise type annotations for some additional magic methods. Currently this adds typing.Iterator return annotations to __iter__, __await__, and __reversed__. These annotations should have a generic parameter to indicate what you're iterating over, but that's too hard for autotyping to figure out.\n\nExternal integrations\n\n--pyanalyze-report: takes types suggested by pyanalyze's suggested_parameter_type and suggested_return_type codes and applies them. You can generate these with a command like: pyanalyze --json-output failures.json -e suggested_return_type -e suggested_parameter_type -v .\n\n--only-without-imports: only apply pyanalyze suggestions that do not require new imports. This is useful because suggestions that require imports may need more manual work.\n\nThere are two shortcut flags to enable multiple transformations at once:\n\n--safe enables changes that should always be safe. This includes --none-return, --scalar-return, and --annotate-magics.\n\n--aggressive enables riskier changes that are more likely to produce new type checker errors. It includes all of --safe as well as --bool-param, --int-param, --float-param, --str-param, --bytes-param, and --annotate-imprecise-magics.\n\nLibCST\n\nAutotyping is built as a LibCST codemod; see the LibCST documentation for more information on how to use codemods.\n\nIf you wish to run things through the libcst.tool interface, you can do this like so:\n\nMake sure you have a .libcst.codemod.yaml with 'autotyping' in the modules list. For an example, see the .libcst.codemod.yaml in this repo.\n\nRun python -m libcst.tool codemod autotyping.AutotypeCommand /path/to/my/code\n\nLimitations\n\nAutotyping is intended to be a simple tool that uses heuristics to find annotations that would be tedious to add by hand. The heuristics may fail, and after you run autotyping you should run a type checker to verify that the types it added are correct.\n\nKnown limitations:\n\nautotyping does not model code flow through a function, so it may miss implicit None returns\n\nChangelog\n\n24.3.0 (March 25, 2024)\n\nAdd simpler ways to invoke autotyping. Now, it is possible to simply use python3 -m autotyping to invoke the tool. (Thanks to Shantanu Jain.)\n\nDrop support for Python 3.7; add support for Python 3.12. (Thanks to Hugo van Kemenade.)\n\nInfer return types for some more magic methods. (Thanks to Dhruv Manilawala.)\n\n23.3.0 (March 3, 2023)\n\nFix crash on certain argument names like iterables (contributed by Marco Gorelli)\n\n23.2.0 (February 3, 2023)\n\nAdd --guess-common-names (contributed by John Litborn)\n\nFix the --safe and --aggressive flags so they don't take ignored arguments\n\n--length-hint should return int (contributed by Nikita Sobolev)\n\nFix bug in import adding (contributed by Shantanu)\n\n22.9.0 (September 5, 2022)\n\nAdd --safe and --aggressive\n\nAdd --pyanalyze-report\n\nDo not add None return types to methods marked with @abstractmethod and to methods in stub files\n\nImprove type inference:\n\n\"string\" % ... is always str\n\nb\"bytes\" % ... is always bytes\n\nAn and or or operator where left and right sides are of the same type returns that type\n\nis, is not, in, and not in always return bool\n\n21.12.0 (December 21, 2021)"
    }
}