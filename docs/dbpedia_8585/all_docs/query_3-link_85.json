{
    "id": "dbpedia_8585_3",
    "rank": 85,
    "data": {
        "url": "https://nx.dev/reference/project-configuration",
        "read_more_link": "",
        "language": "en",
        "title": "Project Configuration",
        "top_image": "https://nx.dev/images/open-graph/reference-project-configuration.jpg",
        "meta_img": "https://nx.dev/images/open-graph/reference-project-configuration.jpg",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Nx is a build system with built-in tooling and advanced CI capabilities. It helps you maintain and scale monorepos, both locally and on CI.",
        "meta_lang": "en",
        "meta_favicon": "/favicon/favicon.svg",
        "meta_site_name": "Nx",
        "canonical_link": "https://nx.dev/reference/project-configuration",
        "text": "A project's configuration is constructed by Nx from three sources:\n\nTasks inferred by Nx plugins from tooling configuration\n\nWorkspace targetDefaults defined in the nx.json file\n\nIndividual project level configuration files (package.json and project.json)\n\nEach source will overwrite the previous source. That means targetDefaults will overwrite inferred tasks and project level configuration will overwrite both targetDefaults and inferred tasks. The combined project configuration can be viewed in the project details view by using Nx Console in your IDE or by running:\n\nThe project details view also shows where each setting is defined so that you know where to change it.\n\nProject Level Configuration Files\n\nIf you need to edit your project settings or modify an inferred task, you can do so in either package.json or project.json files. The examples on this page show both styles, and the only functional difference is that tasks that use executors must be defined in a project.json. Nx merges the two files to get each project's configuration. The full machine readable schema is available on GitHub.\n\nThe following configuration creates build and test targets for Nx.\n\nYou can invoke nx build mylib or nx test mylib without any extra configuration.\n\nBelow are some more complete examples of project configuration files. For a more intuitive understanding of the roles of each option, you can highlight the options in the excerpt below that relate to different categories. Orchestration settings control the way Nx runs tasks. Execution settings control the actual task that is run. Caching settings control when Nx caches a task and what is actually cached.\n\nTask Definitions (Targets)\n\nA large portion of project configuration is related to defining the tasks for the project. In addition, to defining what the task actually does, a task definition also has properties that define the way that Nx should run that task. Those properties are described in detail below.\n\nCache\n\nIn Nx 17 and higher, caching is configured by specifying \"cache\": true in a target's configuration. This will tell Nx that it's ok to cache the results of a given target. For instance, if you have a target that runs tests, you can specify \"cache\": true in the target default configuration for test and Nx will cache the results of running tests.\n\nPer Project Caching + Distribution\n\nIf you are using distributed task execution and disable caching for a given target, you will not be able to use distributed task execution for that target. This is because distributed task execution requires caching to be enabled. This means that the target you have disabled caching for, and any targets which depend on that target will fail the pipeline if you try to run them with Nx Agents enabled.\n\nParallelism\n\nIn Nx 19.5.0+, tasks can be configured to support parallelism or not. By default, tasks are run in parallel with other tasks on a given machine. However, in some cases, tasks can require a shared resource such as a port or memory. For these cases, setting \"parallelism\": false, will ensure that those tasks will not run in parallel with other tasks on a single machine. For example, if the e2e tasks all require port 4200, running them in parallel will conflict so the targets can specify to not support parallelism:\n\nNote: Parallelism is only per machine\n\nIf you are using distributed task execution, tasks will still be run simultaneously on different machines. Because different agents do not share resources with one another, it is perfectly fine for multiple agents to run tasks which do not support parallelism at the same time. Therefore, using Nx Agents is key to running tasks which do not support parallelism quickly and efficiently.\n\nInputs and Named Inputs\n\nEach cacheable task needs to define inputs which determine whether the task outputs can be retrieved from the cache or the task needs to be re-run. The namedInputs defined in nx.json or project level configuration are sets of reusable input definitions.\n\nA typical set of inputs may look like this:\n\nOutputs\n\nTargets may define outputs to tell Nx where the target is going to create file artifacts that Nx should cache. \"outputs\": [\"{workspaceRoot}/dist/libs/mylib\"] tells Nx where the build target is going to create file artifacts.\n\nThis configuration is usually not needed. Nx comes with reasonable defaults (imported in nx.json) which implement the configuration above.\n\nSpecifically, by default, the following locations are cached for builds:\n\n{workspaceRoot}/dist/{projectRoot},\n\n{projectRoot}/build,\n\n{projectRoot}/dist,\n\n{projectRoot}/public\n\nRead the configure outputs for task caching recipe for helpful tips for setting outputs.\n\nBasic Example\n\nUsually, a target writes to a specific directory or a file. The following instructs Nx to cache dist/libs/mylib and build/libs/mylib/main.js:\n\nSpecifying Globs\n\nSometimes, multiple targets might write to the same directory. When possible it is recommended to direct these targets into separate directories.\n\nBut if the above is not possible, globs (parsed by the GlobSet Rust library) can be specified as outputs to only cache a set of files rather than the whole directory.\n\nMore advanced patterns can be used to exclude files and folders in a single line\n\ndependsOn\n\nTargets can depend on other targets. This is the relevant portion of the configuration file:\n\nA common scenario is having to build dependencies of a project first before building the project. This is what the \"dependsOn\": [\"^build\"] property of the build target configures. It tells Nx that before it can build mylib it needs to make sure that mylib's dependencies are built as well. This doesn't mean Nx is going to rerun those builds. If the right artifacts are already in the right place, Nx will do nothing. If they aren't in the right place, but they are available in the cache, Nx will retrieve them from the cache.\n\nAnother common scenario is for a target to depend on another target of the same project. For instance, \"dependsOn\": [\"build\"] of the test target tells Nx that before it can test mylib it needs to make sure that mylib is built, which will result in mylib's dependencies being built as well.\n\nYou can also express task dependencies with an object syntax:\n\nStarting from v19.5.0, wildcards can be used to define dependencies in the dependsOn field.\n\nExamples\n\nYou can write the shorthand configuration above in the object syntax like this:\n\nWith the expanded syntax, you also have a third option available to configure how to handle the params passed to the target. You can either forward them or you can ignore them (default).\n\nThis also works when defining a relation for the target of the project itself using \"projects\": \"self\":\n\nAdditionally, when using the expanded object syntax, you can specify individual projects in version 16 or greater.\n\nThis configuration is usually not needed. Nx comes with reasonable defaults (imported in nx.json) which implement the configuration above.\n\nExecutor/command options\n\nTo define what a task does, you must configure which command or executor will run when the task is executed. In the case of inferred tasks you can provide project-specific overrides. As an example, if your repo has projects with a build inferred target running the vite build command, you can provide some extra options as follows:\n\nFor more details on how to pass args to the underlying command see the Pass Args to Commands recipe.\n\nIn the case of an explicit target using an executor, you can specify the executor and the options specific to that executor as follows:\n\nTarget Metadata\n\nYou can add additional metadata to be attached to a target. For example, you can provide a description stating what the target does:\n\nProject Metadata\n\nThe following properties describe the project as a whole.\n\nYou can annotate your projects with tags as follows:\n\nYou can configure lint rules using these tags to, for instance, ensure that libraries belonging to myteam are not depended on by libraries belong to theirteam.\n\nimplicitDependencies\n\nNx uses powerful source-code analysis to figure out your workspace's project graph. Some dependencies cannot be deduced statically, so you can set them manually like this. The implicitDependencies property is parsed with the minimatch library, so you can review that syntax for more advanced use cases.\n\nYou can also remove a dependency as follows:\n\nAn implicit dependency could also be a glob pattern:\n\nMetadata\n\nYou can add additional metadata to be attached to the project. For example, you can provide a description for your project:\n\nIncluding package.json files as projects in the graph\n\nAny package.json file that is referenced by the workspaces property in the root package.json file will be included as a project in the graph. If you are using Lerna, projects defined in lerna.json will be included. If you are using pnpm, projects defined in pnpm-workspace.yml will be included.\n\nIf you want to ignore a particular package.json file, exclude it from those tools. For example, you can add !packages/myproject to the workspaces property.\n\nIgnoring package.json scripts"
    }
}