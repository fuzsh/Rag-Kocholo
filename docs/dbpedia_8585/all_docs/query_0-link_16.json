{
    "id": "dbpedia_8585_0",
    "rank": 16,
    "data": {
        "url": "https://macblog.org/autopkg-icons/",
        "read_more_link": "",
        "language": "en",
        "title": "Automatically Export and Generate App Icons in AutoPkg Recipes",
        "top_image": "https://macblog.org/processed_images/ogmacblog.54a56e1e150e69eb.webp",
        "meta_img": "https://macblog.org/processed_images/ogmacblog.54a56e1e150e69eb.webp",
        "images": [
            "https://macblog.org/processed_images/all-icons.9697d1810d061335.webp",
            "https://macblog.org/processed_images/example-composited-icons.1354ec2d4ddba6a3.webp",
            "https://macblog.org/processed_images/default-template-icons.6ca9070ab9e182cb.webp",
            "https://macblog.org/processed_images/example-custom-template.4d23aedbf67233f8.webp",
            "https://macblog.org/processed_images/padding-and-position.923b044e40c8580d.webp",
            "https://macblog.org/processed_images/chrome-custom-example.4b9ce254eaff892c.webp"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "macblog.org"
        ],
        "publish_date": "2022-01-31T00:00:00",
        "summary": "",
        "meta_description": "AppIconExtractor examines an app and exports its icon as a PNG image file (reading the CFBundleIconFile property from an app's Info.plist and saving that image as a PNG file. Additionally, AppIconExtractor can create icon variations by compositing a secondary image on top of the app's icon.",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "MacBlog",
        "canonical_link": "https://macblog.org/autopkg-icons",
        "text": "I'm a stickler for including icons for all policies available in Jamf Pro's Self Service app. They help users find items in Self Service, and generally make the app easier to use.\n\nHowever, I don't like manually extracting icons from apps. It's easy enough with a tool like SAP's Icons app, but if I'm automating package and policy creation with AutoPkg, I should similarly be able to automate icon creation, right?\n\nI created the AppIconExtractor AutoPkg processor to fully automate this task.\n\nAt it's core, AppIconExtractor examines an app and exports its icon as a PNG image file.\n\nMore technically, it reads the CFBundleIconFile property from an app's Info.plist and saves that image as a PNG file at the path of your choice.\n\nAdditionally, ApplIconExtractor can create icon variations by compositing a secondary image on top of the app's icon. This makes it simple to automatically create a version of an icon with a destructive \"red X\" icon superimposed over the app icon for use in uninstallation policies, or a version with an \"update\" graphic for use in policies that update an app.\n\nAdd my recipes and install the Pillow library\n\nFirst, you'll need my recipe repository available to your local AutoPkg installation. Add it with autopkg repo-add haircut-recipes.\n\nAppIconExtractor requires installation of the Pillow Python library.\n\nPillow is used to convert and composite icons, and can be easily installed on the Mac you use to run AutoPkg. Use this command:\n\n/usr/local/autopkg/python -m pip install --upgrade Pillow\n\nNote that this installs the Pillow library within the path of AutoPkg's Python framework. This is very important. If you just run pip or pip3 without the explicit path to AutoPkg's Python installation, AutoPkg won't be able to find the library. Recipes will produce an error directing you to install Pillow using the specifc command above.\n\nWith Pillow installed, you're ready to go.\n\nBasic use\n\nUsing AppIconExtractor is as simple as including the processor as a step in a recipe's Process dictionary. Use the shared processor syntax to call com.github.haircut.processors/AppIconExtractor.\n\nIt requires only one argument: source_app, which is the path to the .app from which to extract an icon. If the path to the app points inside a disk image, that .dmg will be mounted automatically.\n\nBy default, the app's icon will be output to the recipe's cache directory as %NAME%.png%. You can optionally override this output path (and filename) by setting the icon_output_path argument.\n\nA simple example in XML format might look like:\n\n<key>Process</key> <array> <dict> <key>Processor</key> <string>com.github.haircut.processors/AppIconExtractor</string> <key>Arguments</key> <dict> <key>source_app</key> <string>%RECIPE_CACHE_DIR%/CoolApp/CoolApp.app</string> </dict> </dict> </array>\n\nThis will extract the icon from \"CoolApp.app\" and save it as a 256px square PNG image to the recipe cache directory.\n\nAs mentioned, adding the icon_output_path argument will give you additional control over the output path and filename. Here's an example in YAML format:\n\nProcess: - Processor: com.github.haircut.processors/AppIconExtractor Arguments: source_app: \"%RECIPE_CACHE_DIR%/CoolApp/CoolApp.app\" icon_output_path: \"%RECIPE_CACHE_DIR%/Icons/Icon-%NAME%.png\"\n\nGenerating composited variations\n\nBeyond extracting the app's icon, AppIconExtractor can also create variation images by compositing a \"template image\" on top of the app icon.\n\nThe processor can output variations for an \"uninstall,\" \"update,\" and \"install\" version of the app icon.\n\nTo generate a variation, add a processor argument to set an output path for that variation. Use one or more of the following arguments:\n\ncomposite_install_path\n\ncomposite_update_path\n\ncomposite_uninstall_path\n\nOmit any variations you don't want to generate. The processor will only create the variations you request be specify an output path.\n\nIf you specify only output paths for variations, AppIconExtractor will use sensible defaults to composite suitable icons. The default templates are glyphs from SF Symbols that will work well in most situations. Each template is 64px in size, and looks nice in the corner.\n\nThese templates are encoded within the processor; you don't need to do anything to use these defaults!\n\nHere's an example in YAML format:\n\nProcess: - Processor: com.github.haircut.processors/AppIconExtractor Arguments: source_app: \"%RECIPE_CACHE_DIR%/CoolApp/CoolApp.app\" icon_output_path: \"%RECIPE_CACHE_DIR%/Icons/Icon-%NAME%.png\" composite_update_path: \"%RECIPE_CACHE_DIR%/Icons/Update-%NAME%.png\" composite_uninstall_path: \"\"%RECIPE_CACHE_DIR%/Icons/Uninstall-%NAME%.png\"\n\nNotice that we included arguments for the \"update\" and \"uninstall\" variations, but did not set the composite_install_path argument. This would output the \"bare\" app icon as well as variations for \"update\" and \"uninstall\" – but no \"install\" variation, since we omitted that argument.\n\nCustom templates\n\nIf you don't like the default variation templates, you can use your own by setting composite_install_template, composite_update_template and/or composite_unsinstall_template. Each argument should be the path to alternative template image to use for that variation.\n\nAppIconExtractor will calculate the size of the template image at the path you specify and correctly anchor that template to the composite_position (see \"Padding and position\" below).\n\nHere's an example of using a custom template to generate an \"uninstall\" variation in XML format:\n\n<key>Process</key> <array> <dict> <key>Processor</key> <string>com.github.haircut.processors/AppIconExtractor</string> <key>Arguments</key> <dict> <key>source_app</key> <string>%RECIPE_CACHE_DIR%/CoolApp/CoolApp.app</string> <key>composite_uninstall_template</key> <string>%RECIPE_DIR%/radical-flame.png</string> <key>composite_uninstall_path</key> <string>%RECIPE_CACHE_DIR%/delete_%NAME%.png</string> </dict> </dict> </array>\n\nPadding and position\n\nAppIconExtractor includes a few additional options to customize your composited icon variations.\n\ncomposite_padding: sets the number of pixels from the edge of the image the superimposed template image is offset. Defaults to 10 pixels.\n\ncomposite_position: sets the corner to which the superimposed template image for composited variations is anchored. Defaults to br for the bottom-right corner. You can change this to bl (bottom left), ur (upper right), or ul (upper left) if you prefer.\n\nCombinations of these options are shown below with the padding highlighted in pink:\n\nClockwise from the upper left, this example shows:\n\ncomposite_padding omitted (so it defaults to 10) and composite_position of ul.\n\ncomposite_padding of 20 and composite_position of ur.\n\ncomposite_padding of 0 and composite_position omitted (so it defaults to br).\n\ncomposite_padding of 5 and composite_position of bl.\n\nSetting these options applies the same settings to all composited variations. This is an intentional design choice to keep the input arguments – and thus the required code – more manageable.\n\nOutput variables\n\nAppIconExtractor sets the path(s) to the extracted app icon, and any composited variations, as output variables during an AutoPkg run. This means you can extract and generate icons, then immediately use those icons in subsequent processors like JamfPolicyUploader.\n\nThe following output variables are set if (and only if) the associated variations are requested:\n\napp_icon_path: path to the extracted, unmodified app icon. Always set.\n\ninstall_icon_path path to the composited \"install\" variation. Only set if this variations is requested.\n\nupdate_icon_path path to the composited \"update\" variation. Only set if this variations is requested.\n\nuninstall_icon_path path to the composited \"uninstall\" variation. Only set if this variations is requested.\n\nExample uses in recipes\n\nHere are two examples of using AppIconExtractor in a child recipe or override.\n\nExtract the icon from an available .app bundle\n\nGreg Neagle's recipe for Sublime Text 4 leaves the unarchived .app available in the recipe cache dir at %RECIPE_CACHE_DIR%/%NAME%/Sublime Text.app. We'll use this to extract the Sublime Text icon using AppIconExtractor's default settings.\n\nProcess: - Processor: com.github.haircut.processors/AppIconExtractor Arguments: source_app: \"%RECIPE_CACHE_DIR%/%NAME%/Sublime Text.app\" - Processor: com.github.grahampugh.jamf-upload.processors/JamfPolicyUploader Arguments: policy_template: \"%POLICY_TEMPLATE%\" policy_name: \"%POLICY_NAME%\" icon: \"%app_icon_path%\" replace_icon: True\n\nThis extracts Sublime Text's icon without generating any composite variations, then feeds that extracted icon to the JamfPolicyUploader processor. We set replace_icon to True to ensure any change to the icon by the vendor is automatically reflected within our Jamf policy.\n\nUnpacking a .pkg to extract an icon\n\nThe recipe for the Google Chrome Enterprise package downloads a .pkg directly from the vendor, so no repackaging is needed. And while the AutoPkg recipe unpacks the package to performe code signature verification, it then runs the PathDeleter processor to clean up that operation. This means a child recipe does not have access to a .app from which to extract an icon.\n\nThat means we'll need to do a little more work to unpack the package again so that we can get to the app bundle. We'll also generate a custom \"uninstall\" variations and override the default composition position and padding.\n\nHere's the Process of this more complex example in XML format:\n\n<key>Process</key> <array> <dict> <key>Processor</key> <string>FlatPkgUnpacker</string> <key>Arguments</key> <dict> <key>destination_path</key> <string>%RECIPE_CACHE_DIR%/unpack</string> <key>flat_pkg_path</key> <string>%pkg_path%</string> </dict> </dict> <dict> <key>Processor</key> <string>PkgPayloadUnpacker</string> <key>Arguments</key> <dict> <key>destination_path</key> <string>%RECIPE_CACHE_DIR%/unpack/pkgpayload</string> <key>pkg_payload_path</key> <string>%RECIPE_CACHE_DIR%/unpack/GoogleChrome.pkg/Payload</string> </dict> </dict> <dict> <key>Processor</key> <string>com.github.haircut.processors/AppIconExtractor</string> <key>Arguments</key> <dict> <key>composite_padding</key> <integer>20</integer> <key>composite_position</key> <string>ul</string> <key>composite_uninstall_path</key> <string>%RECIPE_CACHE_DIR%/Icon-Uninstall-%NAME%.png</string> <key>composite_uninstall_template</key> <string>/Users/haircut/Documents/delete.png</string> <key>icon_output_path</key> <string>%RECIPE_CACHE_DIR%/Icon-%NAME%.png</string> <key>source_app</key> <string>%RECIPE_CACHE_DIR%/unpack/pkgpayload/Google Chrome.app</string> </dict> </dict> <dict> <key>Processor</key> <string>PathDeleter</string> <key>Arguments</key> <dict> <key>path_list</key> <array> <string>%RECIPE_CACHE_DIR%/unpack</string> </array> </dict> </dict> <dict> <key>Processor</key> <string>com.github.grahampugh.jamf-upload.processors/JamfPolicyUploader</string> <key>Arguments</key> <dict> <key>icon</key> <string>%app_icon_path%</string> <key>policy_name</key> <string>Install %NAME%</string> <key>policy_template</key> <string>Self-Service-Policy.xml</string> <key>replace_icon</key> <true/> </dict> </dict> <dict> <key>Processor</key> <string>com.github.grahampugh.jamf-upload.processors/JamfPolicyUploader</string> <key>Arguments</key> <dict> <key>icon</key> <string>%uninstall_icon_path%</string> <key>policy_name</key> <string>Uninstall %NAME%</string> <key>policy_template</key> <string>Uninstall-Policy.xml</string> <key>replace_icon</key> <true/> </dict> </dict> </array>\n\nThis unpacks the Google Chrome enterprise package, extracts the unmodified app icon, and generates an \"uninstall\" composite version with a custom graphic in the upper left corner with 20px of padding.\n\nThe outputs of AppIconExtractor are then used as inputs to JamfPolicyUploader process runs to set the icons for two different policies. Setting the replace_icon argument to True ensures that any changes to the icons are reflected on the Jamf Pro policies.\n\nHopefully this processor will help you extract icons without the manual work, and spiff up those Self Service policies."
    }
}