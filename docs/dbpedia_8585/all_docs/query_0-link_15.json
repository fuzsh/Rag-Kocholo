{
    "id": "dbpedia_8585_0",
    "rank": 15,
    "data": {
        "url": "https://setuptools.pypa.io/en/latest/userguide/package_discovery.html",
        "read_more_link": "",
        "language": "en",
        "title": "setuptools 72.2.0.post20240814 documentation",
        "top_image": "https://setuptools.pypa.io/en/latest/_static/logo-symbol-only.svg",
        "meta_img": "https://setuptools.pypa.io/en/latest/_static/logo-symbol-only.svg",
        "images": [
            "https://setuptools.pypa.io/en/latest/_static/logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../_static/logo-symbol-only.svg",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "src-layout¶\n\nThe project should contain a src directory under the project root and all modules and packages meant for distribution are placed inside this directory:\n\nproject_root_directory ├── pyproject.toml # AND/OR setup.cfg, setup.py ├── ... └── src/ └── mypkg/ ├── __init__.py ├── ... ├── module.py ├── subpkg1/ │ ├── __init__.py │ ├── ... │ └── module1.py └── subpkg2/ ├── __init__.py ├── ... └── module2.py\n\nThis layout is very handy when you wish to use automatic discovery, since you don’t have to worry about other Python files or folders in your project root being distributed by mistake. In some circumstances it can be also less error-prone for testing or when using PEP 420-style packages. On the other hand you cannot rely on the implicit PYTHONPATH=. to fire up the Python REPL and play with your package (you will need an editable install to be able to do that).\n\nflat-layout¶\n\n(also known as “adhoc”)\n\nThe package folder(s) are placed directly under the project root:\n\nproject_root_directory ├── pyproject.toml # AND/OR setup.cfg, setup.py ├── ... └── mypkg/ ├── __init__.py ├── ... ├── module.py ├── subpkg1/ │ ├── __init__.py │ ├── ... │ └── module1.py └── subpkg2/ ├── __init__.py ├── ... └── module2.py\n\nThis layout is very practical for using the REPL, but in some situations it can be more error-prone (e.g. during tests or if you have a bunch of folders or Python files hanging around your project root).\n\nTo avoid confusion, file and folder names that are used by popular tools (or that correspond to well-known conventions, such as distributing documentation alongside the project code) are automatically filtered out in the case of flat-layout:\n\nReserved package names\n\nReserved top-level module names\n\nWarning\n\nIf you are using auto-discovery with flat-layout, setuptools will refuse to create distribution archives with multiple top-level packages or modules.\n\nThis is done to prevent common errors such as accidentally publishing code not meant for distribution (e.g. maintenance-related scripts).\n\nUsers that purposefully want to create multi-package distributions are advised to use Custom discovery or the src-layout.\n\nThere is also a handy variation of the flat-layout for utilities/libraries that can be implemented with a single Python file:\n\nsingle-module distribution¶\n\nA standalone module is placed directly under the project root, instead of inside a package folder:\n\nproject_root_directory ├── pyproject.toml # AND/OR setup.cfg, setup.py ├── ... └── single_file_lib.py\n\nFinding simple packages¶\n\nLet’s start with the first tool. find: (find_packages()) takes a source directory and two lists of package name patterns to exclude and include, and then returns a list of str representing the packages it could find. To use it, consider the following directory:\n\nmypkg ├── pyproject.toml # AND/OR setup.cfg, setup.py └── src ├── pkg1 │ └── __init__.py ├── pkg2 │ └── __init__.py ├── additional │ └── __init__.py └── pkg └── namespace └── __init__.py\n\nTo have setuptools to automatically include packages found in src that start with the name pkg and not additional:\n\nsetup.cfg\n\n[options] packages=find: package_dir= =src [options.packages.find] where=src include=pkg* # alternatively: `exclude = additional*`\n\nNote\n\npkg does not contain an __init__.py file, therefore pkg.namespace is ignored by find: (see find_namespace: below).\n\nsetup.py\n\nsetup( # ... packages=find_packages( where='src', include=['pkg*'], # alternatively: `exclude=['additional*']` ), package_dir={\"\": \"src\"} # ... )\n\nNote\n\npkg does not contain an __init__.py file, therefore pkg.namespace is ignored by find_packages() (see find_namespace_packages() below).\n\npyproject.toml\n\n[tool.setuptools.packages.find] where=[\"src\"] include=[\"pkg*\"]# alternatively: `exclude = [\"additional*\"]` namespaces=false\n\nNote\n\nWhen using tool.setuptools.packages.find in pyproject.toml, setuptools will consider implicit namespaces by default when scanning your project directory. To avoid pkg.namespace from being added to your package list you can set namespaces = false. This will prevent any folder without an __init__.py file from being scanned.\n\nImportant\n\ninclude and exclude accept strings representing glob patterns. These patterns should match the full name of the Python module (as if it was written in an import statement).\n\nFor example if you have util pattern, it will match util/__init__.py but not util/files/__init__.py.\n\nThe fact that the parent package is matched by the pattern will not dictate if the submodule will be included or excluded from the distribution. You will need to explicitly add a wildcard (e.g. util*) if you want the pattern to also match submodules.\n\nFinding namespace packages¶\n\nsetuptools provides find_namespace: (find_namespace_packages()) which behaves similarly to find: but works with namespace packages.\n\nBefore diving in, it is important to have a good understanding of what namespace packages are. Here is a quick recap.\n\nWhen you have two packages organized as follows:\n\n/Users/Desktop/timmins/foo/__init__.py /Library/timmins/bar/__init__.py\n\nIf both Desktop and Library are on your PYTHONPATH, then a namespace package called timmins will be created automatically for you when you invoke the import mechanism, allowing you to accomplish the following:\n\n>>> import timmins.foo >>> import timmins.bar\n\nas if there is only one timmins on your system. The two packages can then be distributed separately and installed individually without affecting the other one.\n\nNow, suppose you decide to package the foo part for distribution and start by creating a project directory organized as follows:\n\nfoo ├── pyproject.toml # AND/OR setup.cfg, setup.py └── src └── timmins └── foo └── __init__.py\n\nIf you want the timmins.foo to be automatically included in the distribution, then you will need to specify:\n\nsetup.cfg\n\n[options] package_dir= =src packages=find_namespace: [options.packages.find] where=src\n\nfind: won’t work because timmins doesn’t contain __init__.py directly, instead, you have to use find_namespace:.\n\nYou can think of find_namespace: as identical to find: except it would count a directory as a package even if it doesn’t contain __init__.py file directly.\n\nsetup.py\n\nsetup( # ... packages=find_namespace_packages(where='src'), package_dir={\"\": \"src\"} # ... )\n\nWhen you use find_packages(), all directories without an __init__.py file will be ignored. On the other hand, find_namespace_packages() will scan all directories.\n\npyproject.toml\n\n[tool.setuptools.packages.find] where=[\"src\"]\n\nWhen using tool.setuptools.packages.find in pyproject.toml, setuptools will consider implicit namespaces by default when scanning your project directory.\n\nAfter installing the package distribution, timmins.foo would become available to your interpreter.\n\nWarning\n\nPlease have in mind that find_namespace: (setup.cfg), find_namespace_packages() (setup.py) and find (pyproject.toml) will scan all folders that you have in your project directory if you use a flat-layout.\n\nIf used naïvely, this might result in unwanted files being added to your final wheel. For example, with a project directory organized as follows:\n\nfoo ├── docs │ └── conf.py ├── timmins │ └── foo │ └── __init__.py └── tests └── tests_foo └── __init__.py\n\nfinal users will end up installing not only timmins.foo, but also docs and tests.tests_foo.\n\nA simple way to fix this is to adopt the aforementioned src-layout, or make sure to properly configure the include and/or exclude accordingly.\n\nTip\n\nAfter building your package, you can have a look if all the files are correct (nothing missing or extra), by running the following commands:\n\ntar tf dist/*.tar.gz unzip -l dist/*.whl\n\nThis requires the tar and unzip to be installed in your OS. On Windows you can also use a GUI program such as 7zip.\n\npkg_resource style namespace package¶\n\nThis is the method setuptools directly supports. Starting with the same layout, there are two pieces you need to add to it. First, an __init__.py file directly under your namespace package directory that contains the following:\n\n__import__(\"pkg_resources\").declare_namespace(__name__)\n\nAnd the namespace_packages keyword in your setup.cfg or setup.py:\n\nsetup.cfg\n\n[options] namespace_packages=timmins\n\nsetup.py\n\nsetup( # ... namespace_packages=['timmins'] )\n\nAnd your directory should look like this\n\nfoo ├── pyproject.toml# AND/OR setup.cfg, setup.py └── src └── timmins ├── __init__.py └── foo └── __init__.py\n\nRepeat the same for other packages and you can achieve the same result as the previous section."
    }
}