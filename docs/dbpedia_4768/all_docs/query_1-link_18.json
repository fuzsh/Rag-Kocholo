{
    "id": "dbpedia_4768_1",
    "rank": 18,
    "data": {
        "url": "https://courses.cs.washington.edu/courses/cse505/99au/imperative/algol.html",
        "read_more_link": "",
        "language": "en",
        "title": "Algol",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "September 1999\n\nIntroduction\n\nIn the late 50's, both ACM and GAMM (a European association) decided that a universal, machine-independent language would be desirable -- a language for the expression of algorithms\n\nAlgol 58: an interim design. Followed by lots of discussions in the Algol Bulletin and CACM.\n\nAlgol 60: result of an intensive 6 day design effort by a committee in Paris. A few revisions made; Algol 60 report published in CACM in Jan 1963.\n\nThe meetings were exhausting, interminable, and exhilarating. ... Progress was steady and the output, ALGOL 60, was more racehorse than camel. This language proved to be an object of stunning beauty. It was sufficiently perfect and complete so that ensuing implementations were able to append necessities, such as input-output, in the style of ALGOL 60 but their addition propagated no significant changes in the body of the original language.\n\nThe ALGOL 60 report (Nauer et al., 1960) was a fitting display for the language. Nicely organized, tantalizingly incomplete, slightly ambiguous, difficult to read, consistent in format, and brief, it was a perfect canvas for a language that possessed those same properties. Like the Bible, it was meant not merely to be read, but to be interpreted.\n\n-- Alan Perlis, \"The American Side of the Development of Algol,\" The History of Programming Languages\n\nOne of the debates: should recursion be allowed?\n\nDeclarations\n\nDeclarations are like those in Fortran, with some improvements\n\nreal, integer, boolean, label\n\narray of real, array of integer, ...\n\nNo complex, no double precision ... Perlis argues against \"dumbbell languages\" that have constructs for various datatypes, with the different parts loosely connected (e.g. a string processing part, a matrix part, etc.)\n\ndynamic array bounds; lower and upper bounds; indefinite number of dimensions\n\nBlock Structure\n\nBlocks support structured programming: if x=3 then begin y:=9; k:=10 end; In Fortran, there can be only a single statement after a logical if: IF (X .NEQ. 3) GOTO 100 Y=9 K=10 100 ... Anywhere a single statement can be used, a block can be used instead.\n\nBlocks define nested scopes:\n\nbegin integer x; procedure squid; begin integer x; ... end; end; Within the procedure squid, the name x refers to a different variable than in the global scope (see Implementation of Block Structured Languages)\n\nAlgol 60 (and Modula-2, Ada, etc) use lexical scoping.\n\nEarly Lisps, APL, etc. use dynamic scoping.\n\nUnlike Fortran, binding of variable names to locations done at block entry time (in general, it can't be done statically)\n\nBlocks for efficient storage management\n\nbegin ... begin real array x[1:1000]; ... end; ... begin real array y[1:2000]; ... end; end; The array x is allocated in the first block, then deallocated, and then the array y is allocated.\n\nCompare with Fortran equivalence statement. The Algol solution is safe, clear, and provides no opportunity for clever abuse of the type system.\n\nThe bounds of array must be known at block entry time for example, in the declaration:\n\nbegin integer array x[1:n]; ... end; n must be declared outside of the block in which x is declared\n\nExcept for procedures as parameters, Algol can be statically type checked. The report doesn't say, but a reasonable implementation will be strongly typed.\n\nControl Structures\n\ngoto\n\nif-then-else\n\nfor loop\n\nswitch\n\ngoto -- like Fortran's, except for scope rules for labels (can only go to a label at the same lexical level, or an enclosing lexical level)\n\nif-then-else: both statement and expression forms\n\ny := if x=3 then 5 else 6; for loop: definite, indefinite iterations: baroque\n\nswitch statement -- supports a kind of computed goto; now obsolete (case statement is better)\n\nparameter passing mechanisms: Algol 60 had call by name, call by value\n\n(see Parameter Passing)\n\nGeneral Issues/Problems\n\nSyntax\n\nGoal of machine independence led to free format (in contrast to assumption of 80 column punchcards in Fortran). This is now the norm in programming languages, and most commonly used languages have an Algol-like flavor. Use of indentation to indicate program structure.\n\n3 levels of representation:\n\nreference language (used in Algol 60 report)\n\npublication language (used for publishing algorithms)\n\nhardware representations\n\npublication language could have Greek letters, subscripts, etc.\n\nhardware representations could vary from implementation to implementation\n\n(cf comma - decimal point controversy)\n\nApproaches to the problem of words such as INTEGER or WHILE:\n\nreserved word approach (now generally used, e.g. in Ada, Java, etc)\n\nkeywords (strict Algol approach)\n\nkeywords in context (Fortran, PL/1)\n\nA few syntactic problems:\n\nSemicolon to separate statements.\n\nUsing the semicolon as a separator is much more error prone than using the semicolon as a statement terminator. (Ada takes the latter approach.) For example, the following Algol code is syntactically incorrect:\n\nif x=4 then y:=5; else y:=6; (The semicolon after the y:=5 actually puts a null statement after the assignment, so that there are two statements after the \"then\", resulting in an error.)\n\noverly long names for common constructs (begin, end, comment); problem with semicolon terminating comments.\n\ndangling else problem\n\nif x=3 then if y=5 then z:=8 else z:=9; Algol's solution: this statement illegal -- need to write if x=3 then begin if y=5 then z:=8 else z:=9 end; or if x=3 then begin if y=5 then z:=8 end else z:=9\n\nInformation about formal parameters too spread out; odd way to indicate return value in a function (by assigning to the name of the function)\n\ninteger procedure double(j); value j; integer j; double := 2*j The zero-one-infinity principle: The only reasonable numbers [in a programming language definition] are zero, one, and infinity. (From Bruce MacLennan, Principles of Programming Languages )\n\nExamples: number of characters in an identifier, number of dimensions in an array, number of arguments to a function\n\nAlgol obeys this principle much better than does Fortran\n\nLots of semantic ambiguities. (BNF used for a precise description of syntax, but semantics specified in English.) Example: are the bounds of a for loop evaluated once before executing the loop, or at the beginning of each loop execution? A literal reading of the Report implies that they are evaluated each time; but this is inefficient and unclear.\n\nAs an example of the problems that can arise from such ambiguity, in the DEC System 20 implementation of SIMULA we used to have, for this loop the upper bound was evaluated once:\n\nfor i:=1 until n+1 do ... but here it is in effect evaluated each time (since the code just references n directly): for i:=1 until n do See Donald Knuth, The Remaining Trouble Spots in ALGOL 60, CACM, Vol 10 No. 10, 1967.\n\nSome other problems: OWN variables, SWITCH, side effects in functions\n\nlabels, procedures, and strings are not first-class citizens in Algol 60. (This allows for more efficient compilation.)\n\nno I/O statements\n\nEpilog\n\nAlgol-60 didn't achieve widespread use\n\nIn the USA, Burroughs supported Algol-60, but IBM supported FORTRAN\n\nAlgol-60 is extremely important language in the history of programming languages\n\nMany successors: Pascal, Modula-2, Ada, Euclid, Mesa, Emerald, ...\n\nLots of good work done on lexical analysis, parsing, compilation techniques for block-structured languages, etc, which is still used in current compilers.\n\nSome issues of enduring interest that are prominent in Algol:\n\nside effects: whether to allow them at all, and if so how to manage them. One place this problem arises in Algol-60 is in expression evaluation, since the order of evaluation isn't specified. But side effects also make life complex for people and compilers trying to reason about programs.\n\ntypes; static type checking\n\nabstraction mechanisms: functions and procedures. Parameter passing.\n\nscoping and name control mechanisms: block structure, its virtues, and its limitations\n\nformal specification of syntax and semantics\n\nstorage allocation and reclamation\n\nExtending Algol\n\nTony Hoare: Algol-60 was an improvement over most of its successors\n\nPL/I -- Swiss army knife language\n\nExtensible languages\n\nkinds of extension:\n\nstatements (procedures!)\n\noperators\n\ncontrol structures\n\nsyntactic extensibility\n\nSmalltalk-72\n\nEL/I\n\nproblems with languages with extensible syntax:"
    }
}