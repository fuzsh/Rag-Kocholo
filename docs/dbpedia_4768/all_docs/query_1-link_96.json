{
    "id": "dbpedia_4768_1",
    "rank": 96,
    "data": {
        "url": "http://www.cs.williams.edu/~kim/cs334/s00/Lectures/Lec1/Lec1.html",
        "read_more_link": "",
        "language": "en",
        "title": "Williams College CS334",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.cs.williams.edu/~kim/CS+logotrans.gif",
            "http://www.cs.williams.edu/~kim/cs334/s00/Lectures/Lec1/Image1.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "CS 334\n\nProgramming Languages\n\nSpring 2000\n\nLecture 1\n\nDo programming languages matter?\n\nAbsolutely!!!\n\nOtherwise, why would the Java folks have rejected C++ for their programming language?\n\nExplore in this course all aspects of programming languages, including their features, type systems, programming styles supported, and implementations.\n\nProgramming languages are the main interface between computers and programmers, allowing us to express or understand algorithms to be executed by the computer.\n\nAbstractions\n\nBy providing abstractions (or mechanisms to create abstractions) they influence the way we think about problems.\n\nData abstractions:\n\nbasic data types: integers, reals, booleans, characters, pointers\n\nstructured: arrays, records\n\nunit: E.g., support for ADT's, modules, packages, classes\n\nControl abstractions:\n\nbasic: assignment, goto, sequencing\n\nstructured: if..then..else.., loops, procedures & functions\n\nunit: separately compiled units, modules, packages, concurrent tasks\n\nSyntax and Semantics\n\nFor all constructs need to have clearly specified syntax and semantics:\n\nsyntax: what is a legal expression?\n\nsemantics: what is the result when it is executed?\n\nSyntax always given formally (as well as informally).\n\nSemantics usually given informally (English), but more and more formally.\n\nBoth necessary in order to ensure programs give predictable results.\n\nHow can programming languages support the software development process?\n\nPhases in the development process are:\n\nRequirements\n\nSpecification\n\nImplementation\n\nCertification or Validation (includes testing and verification)\n\nMaintenance\n\nNeed to evaluate languages with respect to overall picture. Not good if just supports one aspect. Important to evaluate language based on what its goals are.\n\nBASIC - quick development of interactive programs\n\nPascal - instruction\n\nC - low-level systems programming\n\nFORTRAN - number crunching scientific computation\n\nLanguages which are good for quick hacking together of programs may not be suitable for large-scale software development.\n\nBetter choices for large-scale software include:\n\nAda, Modula-2, Clu, object-oriented languages like C++, Eiffel, etc.\n\nI heard two weeks ago at a conference in Boston that 50% of all security problems reported to CERT (center charged with reporting security problems and solutions) are due to one particular feature of one specific programming language. Given the increasing interest in programs communicating over the internet, one has to wonder why those interested in security still write in that language.\n\nMost languages today designed to support specific software development methodology or philosophy. E.g., top-down design, object-based design, encapsulation, information-hiding.\n\nLanguages influence the way people think about programming process.\n\nFaculty always complain about BASIC hackers.\n\nMinimum requirements for programming languages:\n\nUniversal - if can solve on computer then can program it in the language\n\nNatural (expressive) - easy to express ideas.\n\nImplementable\n\nEfficient (for writing, compilation, or execution?)\n\nReliable - writeable (high-level), readable, ability to deal with exceptional behavior)\n\nMaintainable - Easy to make changes, decisions compartmentalized, clean interfaces.\n\nAlternative Programming Language Paradigms\n\nImportant to be aware of different programming language paradigms, allow one to think about problems in different ways.\n\nPartially driven by new architectures (or at least not constrained by old). Procedural paradigm (C, Pascal, FORTRAN, Ada, Modula-2) is closest to machine architecture.\n\nOther paradigms:\n\nfunctional - Popular in AI (LISP & Scheme) and theoretical prog. lang. community.\n\nClosest to theoretical models and mathematics.\n\nlogic - Originally of interest in AI (though fading).\n\nAlso important as database query languages.\n\nNow shifting to \"constraint\" languages.\n\nDeclarative, control implicit in search.\n\nobject-oriented - Latest fad. All major systems must be \"object-oriented\" to be up-to-date. Important, but current languages have some flaws.\n\nBased on discrete simulation, objects responsible for knowing what to do.\n\nPackage state with appropriate operations.\n\nHistory of Programming Languages\n\nMachine language -> Assembly language -> High-level languages\n\nProgrammers: Single highly trained programmer -> large teams which must cooperate\n\nEarly\n\nFORTRAN - Backus @ IBM, 1957, 18 person-years to write first compiler,\n\nGoals & contributions: numerical problems, very efficient compiler, separate compilation\n\nMany revisions FORTRAN II, IV, 66, 77, 90\n\nALGOL 60 - Committee, 1960\n\nGoals & contributions: numeric, block structure, recursion, elegant, very influential\n\nAncestor of ALGOL W, ALGOL 68, Pascal, Modula, Ada, etc.\n\nCOBOL - Committee, 1960\n\nGoals & contributions: business data processing, records\n\nSeveral revisions\n\nEarly Schisms:\n\nLISP - McCarthy @ MIT, 1962, core is functional\n\nGoals & contributions: List processing and symbolic manipulation, AI\n\nScheme & Common LISP are modern descendents\n\nAPL - Iverson @ Harvard, IBM, 1960 (for notation),\n\ncalculator language for array computations.\n\nSNOBOL 4 - Griswold @ Bell Labs, 1966 - string processing via pattern matching\n\nmodern successor is ICON\n\nConsolidation\n\nPL/I - IBM committee, 1967\n\ncombine FORTRAN, COBOL, ALGOL 60 - but not integrated, now considered a failure.\n\nMultipurpose - include ptrs, records, exceptions, etc.\n\nNext Leap Forward\n\nALGOL 68 - Committee, \"orthogonal\" elements, elegant but very hard to understand\n\nSimula 67 - precursor of object-oriented languages - designed for simulation, coroutines\n\nPascal - Wirth, ETH, 1971 - designed only as a teaching language\n\nSupport structured programming, spare & elegant\n\nSuccessful beyond expectations\n\nAbstract Data Types\n\nClu, Mesa, Modula-2, Ada\n\nSupports modules for encapsulation and information hiding\n\nOther paradigms\n\nObject-oriented: Smalltalk (1972), Eiffel, C++, Object Pascal, Java\n\nFunctional: Scheme (1985?), ML (1978), Miranda (1986) & Haskell (1991)\n\nLogic: PROLOG (1972), newer constraint programming languages.\n\n4th generation languages\n\nImportant in business applications\n\nSpecialized packages of powerful commands w/simplified \"user-friendly\" syntax.\n\nTopics to be covered in course:\n\nProgramming language features and organization, including modules, classes, exception handlers, generic types\n\nfunctional and object-oriented, as well as procedural paradigms. (No longer consider logic programming important enough to spend time on.)\n\nProgramming language support for reliable programming:\n\nabstraction, encapsulation, information hiding, polymorphism, higher-order operators.\n\nLanguage support for concurrency\n\nFormal definitions of programming languages\n\nCompilers and interpreters\n\nRun-time behavior of programming languages, including impact of binding time.\n\nThree main concerns:\n\nProgramming language features for reliable programming\n\nRun-time behavior of programming languages\n\nFormal semantics and interpreters for implementing languages.\n\nStart out by learning ML so can explore some new ideas & rapidly program interesting applications.\n\nWrite our own interpreters for simple languages so can see impact of various design decisions.\n\nFunctional Languages\n\nProblems with imperative (command-based) languages\n\nIn his 1978 Turing award lecture (granted in recognition of his role in the development of FORTRAN, ALGOL 60, and BNF-grammars), John Backus attacked the pernicious influence of imperative programming languages and their dependence on the von Neumann architecture.\n\nWhat is problem with imperative languages?\n\nDesigned around architectures available in 1950's.\n\nComponents:\n\nCPU with accumulator and registers.\n\nMemory\n\nTube connecting CPU with Memory which transmits one word at a time.\n\nTo execute an instruction, go through fetch, decode, execute cycle.\n\nEx. To execute statement stored in location 97 (ADD 162):\n\nFetch instruction from memory location 97 (to CPU)\n\nDecode into operation (ADD) and address (162)\n\nFetch contents of address.\n\nAdd contents to accumulator and leave result in accumulator.\n\nSimple statement like A:=B+C results in several accesses to memory through \"Von Neumann bottleneck.\"\n\nImperative program can be seen as control statements guiding execution of a series of assignment statements (accesses and stores to memory).\n\nVariable in programming language refers to location whose contents may vary with time.\n\nHard to reason about variables whose values are always changing, even within same procedure or function.\n\nMath notation not like that. Static. If want to add time, add new parameter. Gives static reasoning about dynamic processes.\n\nImportant notion called referential transparency. Can replace an expression anywhere that it occurs by its value.\n\nVery important for parallelism, since compute once and then reuse.\n\nNot true of imperative languages. Can't compute x+1 once and replace all occurrences by its value.\n\nOrder of execution in imperative programs very important - inhibits parallel execution.\n\nWe will see several advantages of functional programming.\n\nReferentially transparent - easier to reason about, easier to make parallel. Once expression evaluated, it can be reused.\n\nOrder of execution need not be specified. Expressions can automatically be executed when needed, even in parallel.\n\nHigher-level, resulting in shorter, more understandable programs.\n\nCan build new higher-order functions which allow you to put together old programs in more flexible ways.\n\n\"Lazy evaluation\" can allow one to compute with infinite objects.\n\nOther important reasons to study functional languages:\n\nUseful in AI research\n\nUseful in developing executable specifications and prototype implementations.\n\nClosely related to CS theory (e.g., recursive functions, denotational semantics).\n\nBack to:"
    }
}