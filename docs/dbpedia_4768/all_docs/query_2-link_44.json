{
    "id": "dbpedia_4768_2",
    "rank": 44,
    "data": {
        "url": "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Wikipedia, the free encyclopedia",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/150px-Fortran_acs_cover.jpeg",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/320px-Ibm704.gif",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/magnify-clip.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/180px-FortranCardPROJ039.jpg",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/magnify-clip.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/300px-FortranCodingForm.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/magnify-clip.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/Ambox_style.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/50px-Wikibooks-logo-en.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/poweredby_mediawiki_88x31.png",
            "https://web.math.pmf.unizg.hr/~nela/prteme/FORTRAN_files/wikimedia-button.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Fortran",
            "Fortran",
            "10",
            "000 Maniacs",
            "1975",
            "2007",
            "2008",
            "ALGOL 58",
            "ASCII",
            "Abstract data type",
            "Ada (programming language)",
            "Aliasing (computing)"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "http://en.wikipedia.org/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "From Wikipedia, the free encyclopedia\n\n(Redirected from FORTRAN)\n\nJump to: navigation, search\n\nFortran\n\nThe Fortran Automatic Coding System for the IBM 704 (October 15, 1956), the first Programmer's Reference Manual for Fortran Paradigm multi-paradigm: procedural, imperative, structured, object-oriented Appeared in 1957 Designed by John Backus Developer John Backus & IBM Typing discipline strong, static Major implementations Absoft, GFortran, G95, Intel, Lahey/Fujitsu, Open Watcom, Pathscale, PGI, Silverfrost, Sun, XL Fortran, others Influenced ALGOL 58, PL/I\n\nFortran (previously FORTRAN[1]) is a general-purpose,[2] procedural,[3] imperative programming language that is especially suited to numeric computation and scientific computing. Originally developed by IBM in the 1950s for scientific and engineering applications, Fortran came to dominate this area of programming early on and has been in continual use for over half a century in computationally intensive areas such as numerical weather prediction, finite element analysis, computational fluid dynamics (CFD), computational physics, and computational chemistry. It is one of the most popular languages in the area of High-performance computing and programs to benchmark and rank the world's fastest supercomputers are written in Fortran[4].\n\nFortran (a blend word derived from The IBM Mathematical Formula Translating System) encompasses a lineage of versions, each of which evolved to add extensions to the language while usually retaining compatibility with previous versions. Successive versions have added support for processing of character-based data (FORTRAN 77), array programming, module-based programming and object-based programming (Fortran 90 / 95), and object-oriented and generic programming (Fortran 2003).\n\nContents\n\n[hide]\n\n1 History\n\n1.1 FORTRAN\n\n1.2 FORTRAN II\n\n1.2.1 Simple Fortran II program\n\n1.3 FORTRAN III\n\n1.4 FORTRAN IV\n\n1.5 FORTRAN 66\n\n1.6 FORTRAN 77\n\n1.7 Fortran 90\n\n1.7.1 Obsolescence & deletions\n\n1.8 Fortran 95\n\n1.8.1 Conditional compilation and varying length strings\n\n1.9 Fortran 2003\n\n1.10 Fortran 2008\n\n1.11 The legacy of FORTRAN\n\n2 Language features\n\n3 Portability\n\n4 Variants of Fortran\n\n4.1 Specific variants\n\n4.1.1 FOR TRANSIT for the IBM 650\n\n4.2 Fortran-based languages\n\n5 Code examples\n\n6 FORTRAN quotations\n\n6.1 From the historical record\n\n6.2 References in popular culture\n\n7 Letter O considered harmful\n\n8 References\n\n8.1 Textbooks\n\n8.2 \"Core\" language standards\n\n8.3 Related standards\n\n9 Notes\n\n10 See also\n\n11 External links\n\n[edit] History\n\nIn late 1953, John W. Backus submitted a proposal to his superiors at IBM to develop a more efficient alternative to assembly language for programming their IBM 704 mainframe computer. Backus' historic FORTRAN team consisted of programmers Richard Goldberg, Sheldon F. Best, Harlan Herrick, Peter Sheridan, Roy Nutt, Robert Nelson, Irving Ziller, Lois Haibt and David Sayre.[5]\n\nA draft specification for The IBM Mathematical Formula Translating System was completed by mid-1954. The first manual for FORTRAN appeared in October 1956, with the first FORTRAN compiler delivered in April 1957. This was an optimizing compiler, because customers were reluctant to use a high-level programming language unless its compiler could generate code whose performance was comparable to that of hand-coded assembly language.\n\nWhile the community was skeptical that this new method could possibly out-perform hand-coding, it reduced the amount of programming statements necessary to operate a machine by a factor of 20, and quickly gained acceptance. Said creator John Backus during a 1979 interview with Think, the IBM employee magazine, \"Much of my work has come from being lazy. I didn't like writing programs, and so, when I was working on the IBM 701 (an early computer), writing programs for computing missile trajectories, I started work on a programming system to make it easier to write programs.\"[6]\n\nThe language was widely adopted by scientists for writing numerically intensive programs, which encouraged compiler writers to produce compilers that could generate faster and more efficient code. The inclusion of a complex number data type in the language made Fortran especially suited to technical applications such as electrical engineering.\n\nBy 1960, versions of FORTRAN were available for the IBM 709, 650, 1620, and 7090 computers. Significantly, the increasing popularity of FORTRAN spurred competing computer manufacturers to provide FORTRAN compilers for their machines, so that by 1963 over 40 FORTRAN compilers existed. For these reasons, FORTRAN is considered to be the first widely used programming language supported across a variety of computer architectures.\n\nThe development of FORTRAN paralleled the early evolution of compiler technology; indeed many advances in the theory and design of compilers were specifically motivated by the need to generate efficient code for FORTRAN programs.\n\n[edit] FORTRAN\n\nThe initial release of FORTRAN for the IBM 704 contained 32 statements, including:\n\nDIMENSION and EQUIVALENCE statements\n\nAssignment statements\n\nThree-way arithmetic IF statement.[7]\n\nIF statements for checking exceptions (ACCUMULATOR OVERFLOW, QUOTIENT OVERFLOW, and DIVIDE CHECK); and IF statements for manipulating sense switches and sense lights\n\nGOTO, computed GOTO, ASSIGN, and assigned GOTO\n\nDO loops\n\nFormatted I/O: FORMAT, READ, READ INPUT TAPE, WRITE, WRITE OUTPUT TAPE, PRINT, and PUNCH\n\nUnformatted I/O: READ TAPE, READ DRUM, WRITE TAPE, and WRITE DRUM\n\nOther I/O: END FILE, REWIND, and BACKSPACE\n\nPAUSE, STOP, and CONTINUE\n\nFREQUENCY statement (for providing optimization hints to the compiler)[8]\n\n[edit] FORTRAN II\n\nIBM's FORTRAN II appeared in 1958. The main enhancement was to support procedural programming by allowing user-written subroutines and functions. Six new statements were introduced:\n\nSUBROUTINE, FUNCTION, and END\n\nCALL and RETURN\n\nCOMMON\n\nOver the next few years, FORTRAN II would also add support for the DOUBLE PRECISION and COMPLEX data types.\n\n[edit] Simple Fortran II program\n\nThis program, for Heron's formula, has one data card input, with simple zero-data edit check. If one of the input values is zero or negative, then the program will end with an error code of \"STOP 1\" in the job control card listing following the execution of the program. Normal output will be one line printed with A, B, C, and AREA on the \"report\" page following the compilation with no specific units are stated; and with a normal \"STOP\" in the job card listing.\n\nC AREA OF A TRIANGLE WITH A STANDARD SQUARE ROOT FUNCTION C INPUT - CARD READER UNIT 5, INTEGER INPUT C OUTPUT - LINE PRINTER UNIT 6, REAL OUTPUT C INPUT ERROR DISPLAY ERROR OUTPUT CODE 1 IN JOB CONTROL LISTING READ INPUT TAPE 5, 501, IA, IB, IC 501 FORMAT (3I5) C IA, IB, AND IC MAY NOT BE NEGATIVE C FURTHERMORE, THE SUM OF TWO SIDES OF A TRIANGLE C IS GREATER THAN THE THIRD SIDE, SO WE CHECK FOR THAT, TOO IF (IA) 777, 777, 701 701 IF (IB) 777, 777, 702 702 IF (IC) 777, 777, 703 703 IF (IA+IB-IC) 777,777,704 704 IF (IA+IC-IB) 777,777,705 705 IF (IB+IC-IA) 777,777,799 777 STOP 1 C USING HERON'S FORMULA WE CALCULATE THE C AREA OF THE TRIANGLE 799 S = FLOATF (IA + IB + IC) / 2.0 AREA = SQRT( S * (S - FLOATF(IA)) * (S - FLOATF(IB)) * + (S - FLOATF(IC))) WRITE OUTPUT TAPE 6, 601, IA, IB, IC, AREA 601 FORMAT (4H A= ,I5,5H B= ,I5,5H C= ,I5,8H AREA= ,F10.2, + 13H SQUARE UNITS) STOP END\n\n[edit] FORTRAN III\n\nIBM also developed a FORTRAN III in 1958 that allowed for inline assembler code among other features; however, this version was never released as a product. Like the 704 FORTRAN and FORTRAN II, FORTRAN III included machine-dependent features that made code written in it unportable from machine to machine. Early versions of FORTRAN provided by other vendors suffered from the same disadvantage.\n\n[edit] FORTRAN IV\n\nStarting in 1961, as a result of customer demands, IBM began development of a FORTRAN IV that removed the machine-dependent features of FORTRAN II (such as READ INPUT TAPE), while adding new features such as a LOGICAL data type, logical Boolean expressions and the logical IF statement as an alternative to the arithmetic IF statement. FORTRAN IV was eventually released in 1962, first for the IBM 7030 (\"Stretch\") computer, followed by versions for the IBM 7090 and IBM 7094.\n\nBy 1965, Fortran IV was supposed to be the \"standard\" and in compliance with American Standards Association X3.4.3 FORTRAN Working Group.[9]\n\n[edit] FORTRAN 66\n\nPerhaps the most significant development in the early history of FORTRAN was the decision by the American Standards Association (now ANSI) to form a committee to develop an \"American Standard Fortran.\" The resulting two standards, approved in March 1966, defined two languages, FORTRAN (based on FORTRAN IV, which had served as a de facto standard), and Basic FORTRAN (based on FORTRAN II, but stripped of its machine-dependent features). The FORTRAN defined by the first standard became known as FORTRAN 66 (although many continued to refer to it as FORTRAN IV, the language upon which the standard was largely based). FORTRAN 66 effectively became the first \"industry-standard\" version of FORTRAN. FORTRAN 66 included:\n\nMain program, SUBROUTINE, FUNCTION, and BLOCK DATA program units\n\nINTEGER, REAL, DOUBLE PRECISION, COMPLEX, and LOGICAL data types\n\nCOMMON, DIMENSION, and EQUIVALENCE statements\n\nDATA statement for specifying initial values\n\nIntrinsic and EXTERNAL (e.g., library) functions\n\nAssignment statement\n\nGOTO, assigned GOTO, and computed GOTO statements\n\nLogical IF and arithmetic (three-way) IF statements\n\nDO loops\n\nREAD, WRITE, BACKSPACE, REWIND, and ENDFILE statements for sequential I/O\n\nFORMAT statement\n\nCALL, RETURN, PAUSE, and STOP statements\n\nHollerith constants in DATA and FORMAT statements, and as actual arguments to procedures\n\nIdentifiers of up to six characters in length\n\nComment lines\n\n[edit] FORTRAN 77\n\nAfter the release of the FORTRAN 66 standard, compiler vendors introduced a number of extensions to \"Standard Fortran\", prompting ANSI in 1969 to begin work on revising the 1966 standard. Final drafts of this revised standard circulated in 1977, leading to formal approval of the new FORTRAN standard in April 1978. The new standard, known as FORTRAN 77, added a number of significant features to address many of the shortcomings of FORTRAN 66:\n\nBlock IF and END IF statements, with optional ELSE and ELSE IF clauses, to provide improved language support for structured programming\n\nDO loop extensions, including parameter expressions, negative increments, and zero trip counts\n\nOPEN, CLOSE, and INQUIRE statements for improved I/O capability\n\nDirect-access file I/O\n\nIMPLICIT statement\n\nCHARACTER data type, with vastly expanded facilities for character input and output and processing of character-based data\n\nPARAMETER statement for specifying constants\n\nSAVE statement for persistent local variables\n\nGeneric names for intrinsic functions\n\nA set of intrinsics (LGE, LGT, LLE, LLT) for lexical comparison of strings, based upon the ASCII collating sequence.\n\n(ASCII functions were demanded by the U. S. Department of Defense, in their conditional approval vote.)\n\nIn this revision of the standard, a number of features were removed or altered in a manner that might invalidate previously standard-conforming programs. (Removal was the only allowable alternative to X3J3 at that time, since the concept of \"deprecation\" was not yet available for ANSI standards.) While most of the 24 items in the conflict list (see Appendix A2 of X3.9-1978) addressed loopholes or pathological cases permitted by the previous standard but rarely used, a small number of specific capabilities were deliberately removed, such as:\n\nHollerith constants and Hollerith data, such as:\n\nGREET = 12HHELLO THERE!\n\nReading into a H edit (Hollerith field) descriptor in a FORMAT specification.\n\nOverindexing of array bounds by subscripts.\n\nDIMENSION A(10,5)\n\nY= A(11,1)\n\nTransfer of control into the range of a DO loop (also known as \"Extended Range\").\n\nAn important practical extension to FORTRAN 77 was the release of MIL-STD-1753 in 1978. This specification, developed by the U. S. Department of Defense, standardized a number of features implemented by most FORTRAN 77 compilers but not included in the ANSI FORTRAN 77 standard. These features would eventually be incorporated into the Fortran 90 standard.\n\nDO WHILE and END DO statements\n\nINCLUDE statement\n\nIMPLICIT NONE variant of the IMPLICIT statement\n\nBit manipulation intrinsic functions, based on similar functions included in Industrial Real-Time Fortran (ANSI/ISA S61.1 (1976))\n\nThe IEEE 1003.9 POSIX Standard, released in 1991, provided a simple means for Fortran-77 programmers to issue POSIX system calls. Over 100 calls were defined in the document â allowing access to POSIX-compatible process control, signal handling, file system control, device control, procedure pointing, and stream I/O in a portable manner.\n\nThe development of a revised standard to succeed FORTRAN 77 would be repeatedly delayed as the standardization process struggled to keep up with rapid changes in computing and programming practice. In the meantime, as the \"Standard FORTRAN\" for nearly fifteen years, FORTRAN 77 would become the historically most important dialect.\n\nControl Data Corporation computers had another version of FORTRAN 77, called Minnesota FORTRAN, with variations in output constructs, special uses of COMMONs and DATA statements, optimizations code levels for compiling, and detailed error listings, extensive warning messages, and debugs.[10]\n\n[edit] Fortran 90\n\nThe much delayed successor to FORTRAN 77, informally known as Fortran 90, was finally released as an ISO standard in 1991 and an ANSI Standard in 1992. This major revision added many new features to reflect the significant changes in programming practice that had evolved since the 1978 standard:\n\nFree-form source input, also with lowercase Fortran keywords\n\nIdentifiers up to 31 characters in length\n\nInline comments\n\nAbility to operate on arrays (or array sections) as a whole, thus greatly simplifying math and engineering computations.\n\nwhole, partial and masked array assignment statements and array expressions, such as X(1:N)=R(1:N)*COS(A(1:N)))\n\nWHERE statement for selective array assignment\n\narray-valued constants and expressions,\n\nuser-defined array-valued functions and array constructors.\n\nRECURSIVE procedures\n\nModules, to group related procedures and data together, and make them available to other program units, including the capability to limit the accessibility to only specific parts of the module.\n\nA vastly improved argument-passing mechanism, allowing interfaces to be checked at compile time\n\nUser-written interfaces for generic procedures\n\nOperator overloading\n\nDerived/abstract data types\n\nNew data type declaration syntax, to specify the data type and other attributes of variables\n\nDynamic memory allocation by means of the ALLOCATABLE attribute and the ALLOCATE and DEALLOCATE statements\n\nPOINTER attribute, pointer assignment, and NULLIFY statement to facilitate the creation and manipulation of dynamic data structures\n\nStructured looping constructs, with an END DO statement for loop termination, and EXIT and CYCLE statements for \"breaking out\" of normal DO loop iterations in an orderly way\n\nSELECT . . . CASE construct for multi-way selection\n\nPortable specification of numerical precision under the user's control\n\nNew and enhanced intrinsic procedures.\n\n[edit] Obsolescence & deletions\n\nUnlike the previous revision, Fortran 90 did not delete any features. (Appendix B.1 says, \"The list of deleted features in this standard is empty.\") Any standard-conforming FORTRAN 77 program is also standard-conforming under Fortran 90, and either standard should be usable to define its behavior.\n\nA small set of features were identified as \"obsolescent\" and expected to be removed in a future standard.\n\nObsolescent feature Example Status / 95 Arithmetic IF-statement IF (X) 10, 20, 30 Non-integer DO parameters or control variables DO 9 X= 1.7, 1.6, -0.1 Deleted Shared DO-loop termination or\n\ntermination with a statement\n\nother than END DO or CONTINUE DO 9 J= 1, 10\n\nDO 9 K= 1, 10\n\n9 L= J + K\n\nBranching to END IF\n\nfrom outside a block\n\n66 GO TO 77 ; . . .\n\nIF (E) THEN ; . . .\n\n77 END IF\n\nDeleted Alternate return CALL SUBR( X, Y *100, *200 ) PAUSE statement PAUSE 600 Deleted ASSIGN statement\n\nand assigned GO TO statement 100 . . .\n\nASSIGN 100 TO H\n\n. . .\n\nGO TO H . . .\n\nDeleted Assigned FORMAT specifiers ASSIGN F TO 606 Deleted H edit descriptors 606 FORMAT ( 9H1GOODBYE. ) Deleted Computed GO TO statement GO TO (10, 20, 30, 40), index (Obso.) Statement functions FOIL( X, Y )= X**2 + 2*X*Y + Y**2 (Obso.) DATA statements\n\namong executable statements X= 27.3\n\nDATA A, B, C / 5.0, 12.0. 13.0 / . . .\n\n(Obso.) CHARACTER* form of CHARACTER declaration CHARACTER*8 STRING ! Use CHARACTER(8) (Obso.) Assumed character length functions Fixed form source code * Column 1 contains * or ! or C for comments.\n\nC Column 6 for continuation.\n\n[edit] Fortran 95\n\nFortran 95 was a minor revision, mostly to resolve some outstanding issues from the Fortran 90 standard. Nevertheless, Fortran 95 also added a number of extensions, notably from the High Performance Fortran specification:\n\nFORALL and nested WHERE constructs to aid vectorization\n\nUser-defined PURE and ELEMENTAL procedures\n\nPointer initialization and structure default initialization.\n\nA number of intrinsic functions were extended (for example a dim argument was added to the maxloc intrinsic).\n\nSeveral features noted in Fortran 90 to be deprecated were removed from Fortran 95:\n\nREAL and DOUBLE PRECISION DO variables\n\nBranching to an END IF statement from outside its block\n\nPAUSE statement\n\nASSIGN and assigned GOTO statement, and assigned format specifiers\n\nH edit descriptor.\n\nAn important supplement to Fortran 95 was the ISO technical report TR-15581: Enhanced Data Type Facilities, informally known as the Allocatable TR. This specification defined enhanced use of ALLOCATABLE arrays, prior to the availability of fully Fortran 2003-compliant Fortran compilers. Such uses include ALLOCATABLE arrays as derived type components, in procedure dummy argument lists, and as function return values. (ALLOCATABLE arrays are preferable to POINTER-based arrays because ALLOCATABLE arrays are guaranteed by Fortran 95 to be deallocated automatically when they go out of scope, eliminating the possibility of memory leakage. In addition, aliasing is not an issue for optimization of array references, allowing compilers to generate faster code than in the case of pointers.)\n\nAnother important supplement to Fortran 95 was the ISO technical report TR-15580: Floating-point exception handling, informally known as the IEEE TR. This specification defined support for IEEE floating-point arithmetic and floating point exception handling.\n\n[edit] Conditional compilation and varying length strings\n\nIn addition to the mandatory \"Base language\" (defined in ISO/IEC 1539-1 : 1997), the Fortran 95 language also includes two optional modules:\n\nVarying character strings (ISO/IEC 1539-2 : 2000)\n\nConditional compilation (ISO/IEC 1539-3 : 1998)\n\nwhich, together, comprise the multi-part International Standard (ISO/IEC 1539).\n\nAccording to the standards developers, \"the optional parts describe self-contained features which have been requested by a substantial body of users and/or implementors, but which are not deemed to be of sufficient generality for them to be required in all standard-conforming Fortran compilers.\" Nevertheless, if a standard-conforming Fortran does provide such options, then they \"must be provided in accordance with the description of those facilities in the appropriate Part of the Standard.\"\n\n[edit] Fortran 2003\n\nThe most recent standard, Fortran 2003, is a major revision introducing many new features. A comprehensive summary of the new features of Fortran 2003 is available at the Fortran Working Group (WG5) official Web site.[11]\n\nFrom that article, the major enhancements for this revision include:\n\nDerived type enhancements: parameterized derived types, improved control of accessibility, improved structure constructors, and finalizers.\n\nObject oriented programming support: type extension and inheritance, polymorphism, dynamic type allocation, and type-bound procedures.\n\nData manipulation enhancements: allocatable components (incorporating TR 15581), deferred type parameters, VOLATILE attribute, explicit type specification in array constructors and allocate statements, pointer enhancements, extended initialization expressions, and enhanced intrinsic procedures.\n\nInput/output enhancements: asynchronous transfer, stream access, user specified transfer operations for derived types, user specified control of rounding during format conversions, named constants for preconnected units, the FLUSH statement, regularization of keywords, and access to error messages.\n\nProcedure pointers.\n\nSupport for IEEE floating-point arithmetic and floating point exception handling (incorporating TR 15580).\n\nInteroperability with the C programming language.\n\nSupport for international usage: access to ISO 10646 4-byte characters and choice of decimal or comma in numeric formatted input/output.\n\nEnhanced integration with the host operating system: access to command line arguments, environment variables, and processor error messages.\n\nAn important supplement to Fortran 2003 was the ISO technical report TR-19767: Enhanced module facilities in Fortran. This report provided submodules, which make Fortran modules more similar to Modula-2 modules. They are similar to Ada private child subunits. This allows the specification and implementation of a module to be expressed in separate program units, which improves packaging of large libraries, allows preservation of trade secrets while publishing definitive interfaces, and prevents compilation cascades.\n\n[edit] Fortran 2008\n\nEfforts are underway to develop a revision to Fortran 2003, tentatively called Fortran 2008. As with Fortran 95, this is intended to be a minor upgrade, incorporating clarifications and corrections to Fortran 2003, as well as introducing a select few new capabilities. As of February 2007, the proposed new capabilities include[12]\n\nCo-array Fortran â a parallel processing model\n\nBIT data type\n\nIn August 2007, the BIT data type was removed. In February 2008, Coarrays were scaled back: Parallel I/O and teams were removed.\n\nThe complete original work plan is available at http://j3-fortran.org/doc/year/07/07-010.html.\n\n[edit] The legacy of FORTRAN\n\nSince Fortran has been in use for more than fifty years, there is a vast body of Fortran in daily use throughout the scientific and engineering communities. It is the primary language for some of the most intensive supercomputing tasks, such as weather and climate modeling, computational fluid dynamics, computational chemistry, computational economics, and computational physics. Even today, half a century later, many of the floating-point benchmarks to gauge the performance of new computer processors are still written in Fortran (e.g., CFP2006, the floating-point component of the SPEC CPU2006 benchmarks).\n\n[edit] Language features\n\nThe Fortran language features described are intended to be a fairly comprehensive overview of the Fortran language; full details may be found in any of several Fortran textbooks. Only those features widely used in new programs are described, as few of the historic features are used in modern programs. Still, most have been retained in the language to maintain backward compatibility.\n\nFor more details on this topic, see Fortran language features.\n\n[edit] Portability\n\nPortability was a problem in the early days because there was no agreed standardânot even IBM's reference manualâand computer companies vied to differentiate their offerings from others by providing incompatible features. Standards have improved portability. The 1966 standard provided a reference syntax and semantics, but vendors continued to provide incompatible extensions. Although careful programmers were coming to realize that use of incompatible extensions caused expensive portability problems, and were therefore using programs such as The PFORT Verifier, it was not until after the 1977 standard, when the National Bureau of Standards (now NIST) published FIPS PUB 69, that processors purchased by the U.S. Government were required to diagnose extensions of the standard. Rather than offer two processors, essentially every compiler eventually had at least an option to diagnose extensions.\n\nIncompatible extensions were not the only portability problem. For numerical calculations, it is important to take account of the characteristics of the arithmetic. This was addressed by Fox et al. in the context of the 1966 standard by the PORT library. The ideas therein became widely used, and were eventually incorporated into the 1990 standard by way of intrinsic inquiry functions. The widespread (now almost universal) adoption of the IEEE 754 standard for binary floating-point arithmetic has essentially removed this problem.\n\nAccess to the computing environment (e.g. the program's command line, environment variables, textual explanation of error conditions) remained a problem until it was addressed by the 2003 standard.\n\nLarge collections of \"library\" software that could be described as being loosely-related to engineering and scientific calculations, such as graphics libraries, have been written in C, and therefore access to them presented a portability problem. This has been addressed by incorporation of C interoperability into the 2003 standard.\n\nIt is now possible (and relatively easy) to write an entirely portable program in Fortran, even without recourse to a preprocessor.\n\n[edit] Variants of Fortran\n\n[edit] Specific variants\n\nVendors of high-performance scientific computers (e.g., Burroughs, CDC, Cray, Honeywell, IBM, Texas Instruments, and UNIVAC) added extensions to Fortran to take advantage of special hardware features such as instruction cache, CPU pipelines, and vector arrays. For example, one of IBM's FORTRAN compilers (H Extended IUP) had a level of optimization which reordered the machine language instructions to keep multiple internal arithmetic units busy simultaneously. Another example is CFD, a special variant of Fortran designed specifically for the ILLIAC IV supercomputer, running at NASA's Ames Research Center. IBM Research Labs also developed an extended FORTRAN-based language called \"VECTRAN\" for processing of vectors and matricies.\n\nObject-Oriented Fortran was an object-oriented extension of Fortran, in which data items can be grouped into objects, which can be instantiated and executed in parallel. It was available for Sun, Iris, iPSC, and nCUBE, but is no longer supported.\n\nSuch machine-specific extensions have either disappeared over time or have had elements incorporated into the main standards; the major remaining extension is OpenMP, which is a cross-platform extension for shared memory programming. One new extension, CoArray Fortran, is intended to support parallel programming.\n\n[edit] FOR TRANSIT for the IBM 650\n\n\"FOR TRANSIT\" was the name of a reduced version of the IBM 704 FORTRAN language, which was implemented for the IBM 650, using a translator program developed at Carnegie [13] in the late 1950s. The following comment appears in the IBM Reference Manual (\"FOR TRANSIT Automatic Coding System\" C28-4038, Copyright 1957, 1959 by IBM):\n\nThe FORTRAN system was designed for a more complex machine than the 650, and consequently some of the 32 statements found in the FORTRAN Programmer's Reference Manual are not acceptable to the FOR TRANSIT system. In addition, certain restrictions to the FORTRAN language have been added. However, none of these restrictions make a source program written for FOR TRANSIT incompatible with the FORTRAN system for the 704.\n\nThe permissible statements were:\n\nArithmetic assignment statements, e.g. a = b\n\nGO to n\n\nGO TO (n1, n2, ..., nm), i\n\nIF (a) n1, n2, n3\n\nPAUSE\n\nSTOP\n\nDO n i = m1, m2\n\nCONTINUE\n\nEND\n\nREAD n, list\n\nPUNCH n, list\n\nDIMENSION V, V, V, ...\n\nEQUIVALENCE (a,b,c), (d,c), ...\n\nUp to ten subroutines could be used in one program.\n\nFOR TRANSIT statements were limited to columns 7 thru 56, only. Punched cards were used for input and output on the IBM 650. Three passes were required to translate source code to the \"IT\" language, then to compile the IT statements into SOAP assembly language, and finally to produce the object program, which could then be loaded into the machine to run the program (using punched cards for data input, and outputting results onto punched cards.)\n\nTwo versions existed for the 650s with a 2000 word memory drum: FOR TRANSIT I (S) and FOR TRANSIT II, the latter for machines equipped with indexing registers and automatic floating point decimal (bi-quinary) arithmetic. Appendix A of the manual included wiring diagrams for the IBM 533 control panel.\n\n[edit] Fortran-based languages\n\nPrior to FORTRAN 77, a number of preprocessors were commonly used to provide a friendlier language, with the advantage that the preprocessed code could be compiled on any machine with a standard FORTRAN compiler. Popular preprocessors included FLECS, MORTRAN, Ratfor, and Ratfiv. (Ratfor and Ratfiv, for example, implemented a remarkably C-like language, outputting preprocessed code in standard FORTRAN 66.[14])\n\nThe Fortran-95 Standard includes an optional Part 3 which defines an optional conditional compilation capability. This capability is often referred to as \"CoCo\".\n\nMany Fortran compilers have integrated subsets of the C preprocessor into their systems.\n\nSIMSCRIPT is an application specific Fortran preprocessor for modeling and simulating large discrete systems.\n\nF (programming language) was designed to be a clean subset of Fortran 95 that attempted to remove the redundant, unstructured, and deprecated features of Fortran, such as the EQUIVALENCE statement. F retains the array features added in Fortran 90, and removes control statements that were obsoleted by structured programming constructs added both Fortran 77 and Fortran 90. F is described by its creators as \"a compiled, structured, array programming language especially well suited to education and scientific computing.\" \"F Programming Language Homepage)\".\n\n[edit] Code examples\n\nThe sample programs can be compiled and run with any standard Fortran compiler (see the end of this article for lists of compilers). Most modern Fortran compilers expect a file with a .f or .for extension (for FORTRAN 66 or FORTRAN 77 fixed-form source, although the FORTRAN 66 dialect may have to be selected specifically with a command-line option) or .f90/.f95 extension (for Fortran 90/95 free-form source, respectively).\n\nFor more details on this topic, see Wikibooks:Fortran/Fortran examples.\n\n[edit] FORTRAN quotations\n\nFor a programming language with a half-century legacy, FORTRAN not surprisingly has accumulated its share of jokes and folklore.\n\n[edit] From the historical record\n\nGod is Real, unless declared Integer. J. Allan Toogood, FORTRAN programmer[15]\n\nFORTRANâthe \"infantile disorder\"â, by now nearly 20 years old, is hopelessly inadequate for whatever computer application you have in mind today: it is now too clumsy, too risky, and too expensive to use. âEdsger Dijkstra, 1975[16]\n\n\"The sooner the world forgets that FORTRAN ever existed, the better.\" (imputed to Joseph Weizenbaum)\n\n\"95 percent of the people who programmed in the early years would never have done it without Fortran.\" â Ken Thompson, circa 2005[17]\n\n\"The primary purpose of the DATA statement is to give names to constants; instead of referring to pi as 3.141592653589793 at every appearance, the variable PI can be given that value with a DATA statement and used instead of the longer form of the constant. This also simplifies modifying the program, should the value of pi change.\" âEarly FORTRAN manual for Xerox Computers[18]\n\n\"Consistently separating words by spaces became a general custom about the tenth century A.D., and lasted until about 1957, when FORTRAN abandoned the practice.\" âSun FORTRAN Reference Manual\n\n\"People are very flexible and learn to adjust to strange surroundings â they can become accustomed to read Lisp and Fortran programs, for example.\" âArt of PROLOG, Leon Sterling and Ehud Shapiro, MIT Press\n\n\"Warning: Go directly to Jail. Do not pass GO. Do not collect $200.\" â Easter egg in the SDS/Xerox Sigma 7 FORTRAN compiler, when the statement GO TO JAIL was encountered. The message is from a Chance card in Monopoly.\n\n\"A computer without COBOL and FORTRAN is like a piece of chocolate cake without ketchup or mustard.\" â a fortune cookie from the Unix program fortune.\n\n\"The determined Real Programmer can write FORTRAN programs in any language.\" â Real Programmers Don't Use Pascal, Ed Post, 1982\n\n[edit] References in popular culture\n\nIn the pilot episode of the Futurama series, the robot Bender drinks a bottle of Olde FORTRAN Malt Liquor (alluding to \"Olde English\" malt liquor)\n\nComputer folklore has incorrectly attributed the loss of the Mariner 1 space probe to a syntax error in a Fortran program. For example, \"Recall the first American space probe to Venus, reportedly lost because Fortran cannot recognize a missing comma in a DO statementâ¦\"[19].\n\nIn 1982, 10,000 Maniacs released a song named \"Planned Obsolescence\" that includes the repeated line â \"Science [is] truth for life, in Fortran tongue the answer\".\n\n[edit] Letter O considered harmful\n\nDuring the same Fortran Standards Committee meeting at which the name \"FORTRAN 77\" was chosen, a technical proposal was somehow smuggled into the official distribution, bearing the title, \"Letter O considered harmful\". This deceptively simple proposal purported to address the confusion that sometimes arises between the letter \"O\" and the numeral zero, by eliminating the letter from allowable variable names. However, the method proposed was to eliminate the letter from the character set entirely (thereby retaining 48 as the number of lexical characters, which the colon had increased to 49).\n\nAmong the \"PRO\" arguments was the assertion that this would also promote structured programming, by making it impossible to use the notorious GO TO statement as before. (Troublesome FORMAT statements would be eliminated, as well.)\n\nThe sole \"CON\" argument conceded that \"this might invalidate some existing programs\" but noted that most of these \"probably were non-conforming, anyway\".[20]\n\n[edit] References\n\n[edit] Textbooks\n\nAkin, Ed (2003). Object Oriented Programming via Fortran 90/95, 1st ed., Cambridge University Press. ISBN 0-521-52408-3.\n\nEtter, D. M. (1990). Structured FORTRAN 77 for Engineers and Scientists, 3rd ed., The Benjamin/Cummings Publishing Company, Inc.. ISBN 0-8053-0051-1.\n\nChapman, Stephen J. (2007). Fortran 95/2003 for Scientists and Engineers, 3rd ed., McGraw-Hill. ISBN 978-0-07-319157-7.\n\nChapman, Stephen J. (2003). Fortran 90/95 for Scientists and Engineers, 2nd ed., McGraw-Hill. ISBN 0-07-282575-8.\n\nChivers, Ian; Jane Sleightholme (2006). Introduction to Programming with Fortran, 1st ed., Springer. ISBN 1-84628-053-2.\n\nEllis, T. M. R.; Ivor R. Phillips, Thomas M. Lahey (1994). Fortran 90 Programming, 1st ed., Addison Wesley. ISBN 0-201-54446-6.\n\nKupferschmid, Michael (2002). Classical Fortran: Programming for Engineering and Scientific Applications. Marcel Dekker (CRC Press). ISBN 0-8247-0802-4.\n\nMcCracken, Daniel D. (1961). A Guide to Fortran Programming. Wiley.\n\nMcCracken, Daniel D. (1965). A Guide to Fortran IV Programming. Wiley.\n\nMetcalf, Michael; John Reid, Malcolm Cohen (2004). Fortran 95/2003 Explained. Oxford University Press. ISBN 0-19-852693-8.\n\nNyhoff, Larry; Sanford Leestma (1995). FORTRAN 77 for Engineers and Scientists with an Introduction to Fortran 90, 4th ed., Prentice Hall. ISBN 0-13-363003-X.\n\nda Cunha, Rudnei Dias (2005). IntroduÃ§Ã£o Ã Linguagem de ProgramaÃ§Ã£o Fortran 90. Editora da Universidade Federal do Rio Grande do Sul. ISBN 85-7025-829-1.\n\nMartÃ­nez Baena, Javier; Ignario Requena Ramos, NicolÃ¡s MarÃ­n Ruiz (2006). ProgramaciÃ³n estructurada con Fortran 90/95. Universidad de Granada. ISBN 84-338-3923-3.\n\n[edit] \"Core\" language standards\n\nANSI X3.9-1966. USA Standard FORTRAN, informally known as FORTRAN 66, American National Standards Institute.\n\nANSI X3.9-1978. American National Standard â Programming Language FORTRAN, also known as ISO 1539-1980, informally known as FORTRAN 77, American National Standards Institute.\n\nANSI X3.198-1992 (R1997). American National Standard â Programming Language Fortran Extended, informally known as Fortran 90, American National Standards Institute.\n\nISO/IEC 1539-1:1997. Information technology â Programming languages â Fortran â Part 1: Base language, informally known as Fortran 95. There are a further two parts to this standard. Part 1 has been formally adopted by ANSI.\n\nISO/IEC 1539-1:2004. Information technology â Programming languages â Fortran â Part 1: Base language, informally known as Fortran 2003.\n\n[edit] Related standards\n\nWilfried Kneis (October 1981). \"Draft standard Industrial Real-Time FORTRAN\". ACM SIGPLAN Notices 16 (7): 45â60. ACM Press. doi:10.1145/947864.947868.\n\nMIL-STD-1753. DoD Supplement to X3.9-1978. U. S. Government Printing Office.\n\nPOSIX 1003.9-1992. POSIX FORTRAN 77 Language Interface â Part 1: Binding for System Application Program Interface [API]. The Institute of Electrical and Electronics Engineers, Inc.\n\nISO 8651-1:1988 Information processing systems -- Computer graphics -- Graphical Kernel System (GKS) language bindings -- Part 1: FORTRAN\n\n[edit] Notes\n\n[edit] See also\n\nAlphabetical list of programming languages\n\n[edit] External links\n\nHistory\n\n\"The FORTRAN Automatic Coding System\" (1.39 MiB) â 1957 copy describes the design and implementation of the first FORTRAN compiler by the IBM team\n\nEarly Fortran manuals and The very first Fortran manual, by John Backus (6.11 MiB) dated [1956-10-15]\n\nHistory of FORTRAN and Systems Manual for 704/ /709 FORTRAN (13.5 MiB)\n\nFORTRAN at HOPL site\n\n\"The IBM CE Manual for FORTRAN I, II, and 709\" from 1959 (3.82 MiB)\n\n\"A History of Language Processor Technology in IBM\" (1.45 MiB) â by F.E. Allen, IBM Journal of Research and Development, v.25, no.5, September 1981\n\nStandards\n\nComprehensive Fortran Standards Documents by GFortran\n\nJTC1/SC22/WG5 â The ISO/IEC Fortran Working Group\n\nANSI(R) X3.9-1978 Fortran 77 Standard\n\nMIL-STD 1753 DoD Extensions to Fortran 77\n\nISO/IEC 1539:1991 Fortran 90 Standard\n\nfinal draft Fortran 95 Standard\n\nWG5 (2003) ISO/IEC JTC1/SC22/WG5 N1578 Final Committee Draft of Fortran 2003 standard\n\nTutorials\n\nProfessional Programmer's Guide to FORTRAN 77 (493 KiB) â Guide written by Clive G. Page of the University of Leicester\n\nUnit 7.1 FORTRAN 77 and Unit 7.2 Fortran 90 â Part of ASPIRE's \"Computational Science Textbook\" project\n\nUser Notes on FORTRAN Programming (UNFP) â An open cooperative guide\n\nReferences\n\nThe Professional Programmer's Guide to FORTRAN 77\n\nFortran 77, 90, 95, 2003 Information & Resources\n\nFortran 77 â FORTRAN 77 documentation\n\nFortran 77 4.0 Reference Manual (851 KiB)\n\nCode repositories\n\nFortran 90 Software Repository â Numerical Algorithms Group\n\nHigh-Precision Software Directory â Computational Research Division of Lawrence Berkeley National Laboratory\n\nNational HPCC Software Exchange (defunct) Department of Computer Science at the University of Tennessee at Knoxville\n\nNetlib Repository at the University of Tennessee at Knoxville and Oak Ridge National Laboratory\n\nSoftware from Alan J. Miller Logistic Regression, TOMS algorithms, Special code for F, Applied Statistics Algorithms and NAS compilers\n\nOpen source compilers\n\nGFortran â The GNU Fortran compiler, part of GCC. Distributed as part of GCC as of GCC 4.0. Replaced g77.\n\ng95 â Free, open source Fortran 95 compiler and runtime libraries\n\nOpen64 â Open Research Compiler. Suite of optimizing compiler development tools for Intel Itanium (Linux)\n\nOpen Watcom â A joint effort between SciTech Software Inc, Sybase and the Open Source development community to maintain Fortran cross compilers and tools\n\nNon-open source compilers\n\nIntel Fortran Compiler\n\nAbsoft Fortran 95/90/77 and C/C++ compilers for Windows, Mac OS 9 and OS X, Linux IA32 and AMD Opteron and AMD Athlon 64-bit processors\n\nIBM Fortran 95 compilers for AIX, Blue Gene, and Linux\n\nLahey/Fujitsu â Fortran 95 compilers for Linux and Windows\n\nNAGWare Fortran 95 compiler with 2003 features for Linux, Windows, and Unix on many platforms\n\nQlogic Pathscale â Fortran 95, C, and C++ compilers for Linux on AMD Opteron and Intel 64-bit and 32-bit x86 CPUs\n\nPGI Fortran 95, C and C++ Compilers for 32-bit and 64-bit AMD64 and IA32 processor-based Linux and Windows systems\n\nSilverfrost (was Salford) â Personal edition (Windows)\n\nSun Studio Compiler Suite â From Sun Microsystems; compiles optimized and parallelized code for the Solaris OS on SPARC and x86/x64 platforms, and Linux on x86/x64 platforms\n\nIntegrated Development Environment\n\nPhotran â An IDE for Fortran 77, 90, and 95 based on Eclipse and the CDT.\n\nGraphical libraries/GUI\n\nDISLIN â A high-level plotting library for displaying data as curves, polar plots, bar graphs, pie charts, 3D-color plots, surfaces, contours and maps\n\nf90gl â Public domain implementation of the official Fortran 90 bindings for OpenGL (Linux, Mac OS X, Solaris, UNIX, Windows)\n\nftcl â A FortranâTcl/TK interface\n\ng2 graphical library â Portable and 2D graphics library (Linux, Mac OS X, OpenVMS, Solaris, UNIX, Windows)GNU LGPL\n\nGrWin Graphics Library â Free graphics routine library for Fortran (Windows)\n\npilib â Platform Independent Library for Fortran 90/95 (Linux, Mac OS X, UNIX, Windows) GNU LGPL\n\nPLplot â A Scientific Plotting Library (Linux, Mac OS X, MS-DOS, Unix, Windows) GNU LGPL\n\nMATFOR â A Scientific Graphical Numerical Library (Linux, Mac OS X, MS-DOS, SuSe, Windows)\n\nTesting Frameworks\n\nFUnit â a unit testing framework.\n\nMiscellaneous"
    }
}