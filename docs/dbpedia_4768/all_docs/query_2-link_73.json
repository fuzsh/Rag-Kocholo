{
    "id": "dbpedia_4768_2",
    "rank": 73,
    "data": {
        "url": "https://worldwidescience.org/topicpages/f/fortran%2Bprogramming%2Blanguages.html",
        "read_more_link": "",
        "language": "en",
        "title": "fortran programming languages: Topics by WorldWideScience.org",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://worldwidescience.org/sites/www.osti.gov/files/public/image-files/WWSlogo_wTag650px-min.png",
            "https://worldwidescience.org/sites/www.osti.gov/files/public/image-files/OSTIlogo.svg",
            "https://worldwidescience.org/sites/www.osti.gov/files/public/image-files/ICSTIlogo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Comparison of and conversion between different implementations of the FORTRAN programming language\n\nScience.gov (United States)\n\nTreinish, L.\n\n1980-01-01\n\nA guideline for computer programmers who may need to exchange FORTRAN programs between several computers is presented. The characteristics of the FORTRAN language available on three different types of computers are outlined, and procedures and other considerations for the transfer of programs from one type of FORTRAN to another are discussed. In addition, the variance of these different FORTRAN's from the FORTRAN 77 standard are discussed.\n\nScientific Programming in Fortran\n\nDirectory of Open Access Journals (Sweden)\n\nW. Van Snyder\n\n2007-01-01\n\nFull Text Available The Fortran programming language was designed by John Backus and his colleagues at IBM to reduce the cost of programming scientific applications. IBM delivered the first compiler for its model 704 in 1957. IBM's competitors soon offered incompatible versions. ANSI (ASA at the time developed a standard, largely based on IBM's Fortran IV in 1966. Revisions of the standard were produced in 1977, 1990, 1995 and 2003. Development of a revision, scheduled for 2008, is under way. Unlike most other programming languages, Fortran is periodically revised to keep pace with developments in language and processor design, while revisions largely preserve compatibility with previous versions. Throughout, the focus on scientific programming, and especially on efficient generated programs, has been maintained.\n\nA brief description and comparison of programming languages FORTRAN, ALGOL, COBOL, PL/1, and LISP 1.5 from a critical standpoint\n\nScience.gov (United States)\n\nMathur, F. P.\n\n1972-01-01\n\nSeveral common higher level program languages are described. FORTRAN, ALGOL, COBOL, PL/1, and LISP 1.5 are summarized and compared. FORTRAN is the most widely used scientific programming language. ALGOL is a more powerful language for scientific programming. COBOL is used for most commercial programming applications. LISP 1.5 is primarily a list-processing language. PL/1 attempts to combine the desirable features of FORTRAN, ALGOL, and COBOL into a single language.\n\nObject-Oriented Scientific Programming with Fortran 90\n\nScience.gov (United States)\n\nNorton, C.\n\n1998-01-01\n\nFortran 90 is a modern language that introduces many important new features beneficial for scientific programming. We discuss our experiences in plasma particle simulation and unstructured adaptive mesh refinement on supercomputers, illustrating the features of Fortran 90 that support the object-oriented methodology.\n\nPrograms in Fortran language for reporting the results of the analyses by ICP emission spectroscopy\n\nInternational Nuclear Information System (INIS)\n\nRoca, M.\n\n1985-01-01\n\nThree programs, written in FORTRAN IV language, for reporting the results of the analyses by ICP emission spectroscopy from data stored in files on floppy disks have been developed. They are intended, respectively, for the analyses of: 1) waters, 2) granites and slates, and 3) different kinds of geological materials. (Author) 8 refs\n\nFortran\n\nCERN Document Server\n\nMarateck, Samuel L\n\n1977-01-01\n\nFORTRAN is written for students who have no prior knowledge of computers or programming. The book aims to teach students how to program using the FORTRAN language.The publication first elaborates on an introduction to computers and programming, introduction to FORTRAN, and calculations and the READ statement. Discussions focus on flow charts, rounding numbers, strings, executing the program, the WRITE and FORMAT statements, performing an addition, input and output devices, and algorithms. The text then takes a look at functions and the IF statement and the DO Loop, the IF-THEN-ELSE and the WHI\n\nProgramming in Fortran M\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nFoster, I.; Olson, R.; Tuecke, S.\n\n1993-08-01\n\nFortran M is a small set of extensions to Fortran that supports a modular approach to the construction of sequential and parallel programs. Fortran M programs use channels to plug together processes which may be written in Fortran M or Fortran 77. Processes communicate by sending and receiving messages on channels. Channels and processes can be created dynamically, but programs remain deterministic unless specialized nondeterministic constructs are used. Fortran M programs can execute on a range of sequential, parallel, and networked computers. This report incorporates both a tutorial introduction to Fortran M and a users guide for the Fortran M compiler developed at Argonne National Laboratory. The Fortran M compiler, supporting software, and documentation are made available free of charge by Argonne National Laboratory, but are protected by a copyright which places certain restrictions on how they may be redistributed. See the software for details. The latest version of both the compiler and this manual can be obtained by anonymous ftp from Argonne National Laboratory in the directory pub/fortran-m at info.mcs.anl.gov.\n\nAutomatic generation of Fortran programs for algebraic simulation models\n\nInternational Nuclear Information System (INIS)\n\nSchopf, W.; Rexer, G.; Ruehle, R.\n\n1978-04-01\n\nThis report documents a generator program by which econometric simulation models formulated in an application-orientated language can be transformed automatically in a Fortran program. Thus the model designer is able to build up, test and modify models without the need of a Fortran programmer. The development of a computer model is therefore simplified and shortened appreciably; in chapter 1-3 of this report all rules are presented for the application of the generator to the model design. Algebraic models including exogeneous and endogeneous time series variables, lead and lag function can be generated. In addition, to these language elements, Fortran sequences can be applied to the formulation of models in the case of complex model interrelations. Automatically the generated model is a module of the program system RSYST III and is therefore able to exchange input and output data with the central data bank of the system and in connection with the method library modules can be used to handle planning problems. (orig.) [de\n\nC Versus Fortran-77 for Scientific Programming\n\nDirectory of Open Access Journals (Sweden)\n\nTom MacDonald\n\n1992-01-01\n\nFull Text Available The predominant programming language for numeric and scientific applications is Fortran-77 and supercomputers are primarily used to run large-scale numeric and scientific applications. Standard C* is not widely used for numerical and scientific programming, yet Standard C provides many desirable linguistic features not present in Fortran-77. Furthermore, the existence of a standard library and preprocessor eliminates the worst portability problems. A comparison of Standard C and Fortran-77 shows several key deficiencies in C that reduce its ability to adequately solve some numerical problems. Some of these problems have already been addressed by the C standard but others remain. Standard C with a few extensions and modifications could be suitable for all numerical applications and could become more popular in supercomputing environments.\n\nDevelopment of the static analyzer ANALYSIS/EX for FORTRAN programs\n\nInternational Nuclear Information System (INIS)\n\nOsanai, Seiji; Yokokawa, Mitsuo\n\n1993-08-01\n\nThe static analyzer 'ANALYSIS' is the software tool for analyzing tree structure and COMMON regions of a FORTRAN program statically. With the installation of the new FORTRAN compiler, FORTRAN77EX(V12), to the computer system at JAERI, a new version of ANALYSIS, 'ANALYSIS/EX', has been developed to enhance its analyzing functions. In addition to the conventional functions of ANALYSIS, the ANALYSIS/EX is capable of analyzing of FORTRAN programs written in the FORTRAN77EX(V12) language grammar such as large-scale nuclear codes. The analyzing function of COMMON regions are also improved so as to obtain the relation between variables in COMMON regions in more detail. In this report, results of improvement and enhanced functions of the static analyzer ANALYSIS/EX are presented. (author)\n\nMORTRAN-2, FORTRAN Language Extension with User-Supplied Macros\n\nInternational Nuclear Information System (INIS)\n\nCook, A. James; Shustek, L.J.\n\n1980-01-01\n\n1 - Description of problem or function: MORTRAN2 is a FORTRAN language extension that permits a relatively easy transition from FORTRAN to a more convenient and structured language. Its features include free-field format; alphanumeric statement labels; flexible comment convention; nested block structure; for-by-to, do, while, until, loop, if-then-else, if-else, exit, and next statements; multiple assignment statements; conditional compilation; and automatic listing indentation. The language is implemented by a macro-based pre-processor and is further extensible by user-defined macros. 2 - Method of solution: The MORTRAN2 pre-processor may be regarded as a compiler whose object code is ANSI Standard FORTRAN. The MORTRAN2 language is dynamically defined by macros which are input at each use of the pre-processor. 3 - Restrictions on the complexity of the problem: The pre-processor output must be accepted by a FORTRAN compiler\n\nAspects of FORTRAN in large-scale programming\n\nInternational Nuclear Information System (INIS)\n\nMetcalf, M.\n\n1983-01-01\n\nIn these two lectures I examine the following three questions: i) Why did high-energy physicists begin to use FORTRAN. ii) Why do high-energy physicists continue to use FORTRAN. iii) Will high-energy physicists always use FORTRAN. In order to find answers to these questions, it is necessary to look at the history of the language, its present position, and its likely future, and also to consider its manner of use, the topic of portability, and the competition from other languages. Here we think especially of early competition from ALGOL, the more recent spread in the use of PASCAL, and the appearance of a completely new and ambitious language, ADA. (orig.)\n\nAspects of FORTRAN in large-scale programming\n\nCERN Document Server\n\nMetcalf, M\n\n1983-01-01\n\nIn these two lectures I shall try to examine the following three questions: i) Why did high-energy physicists begin to use FORTRAN? ii) Why do high-energy physicists continue to use FORTRAN? iii) Will high-energy physicists always use FORTRAN? In order to find answers to these questions, it is necessary to look at the history of the language, its present position, and its likely future, and also to consider its manner of use, the topic of portability, and the competition from other languages. Here we think especially of early competition from ALGOL, the more recent spread in the use of PASCAL, and the appearance of a completely new and ambitious language, ADA.\n\nDB90: A Fortran Callable Relational Database Routine for Scientific and Engineering Computer Programs\n\nScience.gov (United States)\n\nWrenn, Gregory A.\n\n2005-01-01\n\nThis report describes a database routine called DB90 which is intended for use with scientific and engineering computer programs. The software is written in the Fortran 90/95 programming language standard with file input and output routines written in the C programming language. These routines should be completely portable to any computing platform and operating system that has Fortran 90/95 and C compilers. DB90 allows a program to supply relation names and up to 5 integer key values to uniquely identify each record of each relation. This permits the user to select records or retrieve data in any desired order.\n\nApplication of Modern Fortran to Spacecraft Trajectory Design and Optimization\n\nScience.gov (United States)\n\nWilliams, Jacob; Falck, Robert D.; Beekman, Izaak B.\n\n2018-01-01\n\nIn this paper, applications of the modern Fortran programming language to the field of spacecraft trajectory optimization and design are examined. Modern object-oriented Fortran has many advantages for scientific programming, although many legacy Fortran aerospace codes have not been upgraded to use the newer standards (or have been rewritten in other languages perceived to be more modern). NASA's Copernicus spacecraft trajectory optimization program, originally a combination of Fortran 77 and Fortran 95, has attempted to keep up with modern standards and makes significant use of the new language features. Various algorithms and methods are presented from trajectory tools such as Copernicus, as well as modern Fortran open source libraries and other projects.\n\nModern Fortran in practice\n\nNARCIS (Netherlands)\n\nMarkus, A.\n\n2012-01-01\n\nFrom its earliest days, the Fortran programming language has been designed with computing efficiency in mind. The latest standard, Fortran 2008, incorporates a host of modern features, including object-orientation, array operations, user-defined types, and provisions for parallel computing. This\n\nStrategies and Experiences Using High Performance Fortran\n\nNational Research Council Canada - National Science Library\n\nShires, Dale\n\n2001-01-01\n\n.... High performance Fortran (HPF) is a relative new addition to the Fortran dialect It is an attempt to provide an efficient high-level Fortran parallel programming language for the latest generation of been debatable...\n\nProgramming language structures\n\nCERN Document Server\n\nOrganick, Elliott Irving; Plummer, Robert P\n\n1978-01-01\n\nProgramming Language Structures deals with the structures of programming languages and introduces the reader to five important programming languages: Algol, Fortran, Lisp, Snobol, and Pascal. The fundamental similarities and differences among these languages are discussed. A unifying framework is constructed that can be used to study the structure of other languages, such as Cobol, PL/I, and APL. Several of the tools and methodologies needed to construct large programs are also considered.Comprised of 10 chapters, this book begins with a summary of the relevant concepts and principles about al\n\nMixed language programming\n\nInternational Nuclear Information System (INIS)\n\nBurow, Burkhard D.\n\n1996-01-01\n\nComputing in the next millennium will be using software from this millennium. Programming languages evolve and new ones continue to be created. The use of legacy code demonstrates why some present and future applications may span programming languages. Even a completely new application may mix programming languages, if it allows its components to be more conveniently expressed. Given the need, mixed language programming should be easy and robust. By resolving a variety of difficulties, the well established cfortran.h package provides, the desired convenient interface across the C and Fortran programming languages, as demonstrated using CERN's Book. (author)\n\nThe programming language EFL\n\nScience.gov (United States)\n\nFeldman, S. I.\n\n1978-01-01\n\nEFL is a comprehensive language designed to make it easy to write portable, understandable programs. It provides a rich set of data types and structures, a convenient operator set, and good control flow forms. The lexical form is easy to type and to read. Whenever possible, EFL uses the same forms that Ratfor does; in this sense EFL may be viewed as a superset of Ratfor. EFL is a well-defined language; this distinguishes it from most FORTRAN preprocessors which only add simple flow of control constructs to FORTRAN. The EFL compiler generates (possibly tailored) Standard FORTRAN as its output. EFL should catch and diagnose all syntax errors.\n\nExploiting first-class arrays in Fortran for accelerator programming\n\nInternational Nuclear Information System (INIS)\n\nRasmussen, Craig E.; Weseloh, Wayne N.; Robey, Robert W.; Sottile, Matthew J.; Quinlan, Daniel; Overbey, Jeffrey\n\n2010-01-01\n\nEmerging architectures for high performance computing often are well suited to a data parallel programming model. This paper presents a simple programming methodology based on existing languages and compiler tools that allows programmers to take advantage of these systems. We will work with the array features of Fortran 90 to show how this infrequently exploited, standardized language feature is easily transformed to lower level accelerator code. Our transformations are based on a mapping from Fortran 90 to C++ code with OpenCL extensions. The sheer complexity of programming for clusters of many or multi-core processors with tens of millions threads of execution make the simplicity of the data parallel model attractive. Furthermore, the increasing complexity of todays applications (especially when convolved with the increasing complexity of the hardware) and the need for portability across hardware architectures make a higher-level and simpler programming model like data parallel attractive. The goal of this work has been to exploit source-to-source transformations that allow programmers to develop and maintain programs at a high-level of abstraction, without coding to a specific hardware architecture. Furthermore these transformations allow multiple hardware architectures to be targeted without changing the high-level source. It also removes the necessity for application programmers to understand details of the accelerator architecture or to know OpenCL.\n\nThe comparison and selection of programming languages for high energy physics applications\n\nInternational Nuclear Information System (INIS)\n\nWhite, B.; Stanford Linear Accelerator Center, CA\n\n1989-01-01\n\nIn this paper a comparison is presented of programming languages in the context of high energy physics software applications. The evaluation method uses was specifically devised to address the issues of particular importance to HEP applications, not just the technical features of the languages considered. The candidate languages evaluated were Ada, C, FORTRAN 77, FORTRAN 8x, Pascal and PL/I. Some conclusions are drawn and recommendations made regarding the role of FORTRAN and other programming languages in the current and future development of HEP software. (orig.)\n\nAnalysis of computer programming languages\n\nInternational Nuclear Information System (INIS)\n\nRisset, Claude Alain\n\n1967-01-01\n\nThis research thesis aims at trying to identify some methods of syntax analysis which can be used for computer programming languages while putting aside computer devices which influence the choice of the programming language and methods of analysis and compilation. In a first part, the author proposes attempts of formalization of Chomsky grammar languages. In a second part, he studies analytical grammars, and then studies a compiler or analytic grammar for the Fortran language\n\nFortran programs for the time-dependent Gross-Pitaevskii equation in a fully anisotropic trap\n\nScience.gov (United States)\n\nMuruganandam, P.; Adhikari, S. K.\n\n2009-10-01\n\n, etc.: 122 907 No. of bytes in distributed program, including test data, etc.: 609 662 Distribution format: tar.gz Programming language: FORTRAN 77 and Fortran 90/95 Computer: PC Operating system: Linux, Unix RAM: 1 GByte (i, iv, v), 2 GByte (ii, vi, vii, x, xi), 4 GByte (iii, viii, xii), 8 GByte (ix) Classification: 2.9, 4.3, 4.12 Nature of problem: These programs are designed to solve the time-dependent Gross-Pitaevskii nonlinear partial differential equation in one-, two- or three-space dimensions with a harmonic, circularly-symmetric, spherically-symmetric, axially-symmetric or anisotropic trap. The Gross-Pitaevskii equation describes the properties of a dilute trapped Bose-Einstein condensate. Solution method: The time-dependent Gross-Pitaevskii equation is solved by the split-step Crank-Nicolson method by discretizing in space and time. The discretized equation is then solved by propagation, in either imaginary or real time, over small time steps. The method yields the solution of stationary and/or non-stationary problems. Additional comments: This package consists of 12 programs, see \"Program title\", above. FORTRAN77 versions are provided for each of the 12 and, in addition, Fortran 90/95 versions are included for ii, iii, vi, viii, ix, xii. For the particular purpose of each program please see the below. Running time: Minutes on a medium PC (i, iv, v, vii, x, xi), a few hours on a medium PC (ii, vi, viii, xii), days on a medium PC (iii, ix). Program summary (1)Title of program: imagtime1d.F Title of electronic file: imagtime1d.tar.gz Catalogue identifier: Program summary URL: Program obtainable from: CPC Program Library, Queen's University of Belfast, N. Ireland Distribution format: tar.gz Computers: PC/Linux, workstation/UNIX Maximum RAM memory: 1 GByte Programming language used: Fortran 77 Typical running time: Minutes on a medium PC Unusual features: None Nature of physical problem: This program is designed to solve the time-dependent Gross\n\nStructured Design Language for Computer Programs\n\nScience.gov (United States)\n\nPace, Walter H., Jr.\n\n1986-01-01\n\nBox language used at all stages of program development. Developed to provide improved productivity in designing, coding, and maintaining computer programs. BOX system written in FORTRAN 77 for batch execution.\n\nClassical Fortran programming for engineering and scientific applications\n\nCERN Document Server\n\nKupferschmid, Michael\n\n2009-01-01\n\nIntroductionWhy Study Programming?The Evolution of FORTRANWhy Study FORTRAN?Classical FORTRANAbout This BookAdvice to InstructorsAbout the AuthorAcknowledgmentsDisclaimersHello, World!Case Study: A First FORTRAN ProgramCompiling the ProgramRunning a Program in UNIXOmissionsExpressions and Assignment StatementsConstantsVariables and Variable NamesArithmetic OperatorsFunction ReferencesExpressionsA\n\nPrograms in Fortran language for reporting the results of the analyses by ICP emission spectroscopy; Programas en lenguaje Fortran para la informacion de los resultados de los analisis efectuados mediante Espectroscopia Optica de emision con fuente de plasma\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nRoca, M\n\n1985-07-01\n\nThree programs, written in FORTRAN IV language, for reporting the results of the analyses by ICP emission spectroscopy from data stored in files on floppy disks have been developed. They are intended, respectively, for the analyses of: 1) waters, 2) granites and slates, and 3) different kinds of geological materials. (Author) 8 refs.\n\nHigh Performance Object-Oriented Scientific Programming in Fortran 90\n\nScience.gov (United States)\n\nNorton, Charles D.; Decyk, Viktor K.; Szymanski, Boleslaw K.\n\n1997-01-01\n\nWe illustrate how Fortran 90 supports object-oriented concepts by example of plasma particle computations on the IBM SP. Our experience shows that Fortran 90 and object-oriented methodology give high performance while providing a bridge from Fortran 77 legacy codes to modern programming principles. All of our object-oriented Fortran 90 codes execute more quickly thatn the equeivalent C++ versions, yet the abstraction modelling capabilities used for scentific programming are comparably powereful.\n\nFormula Translation in Blitz++, NumPy and Modern Fortran: A Case Study of the Language Choice Tradeoffs\n\nDirectory of Open Access Journals (Sweden)\n\nSylwester Arabas\n\n2014-01-01\n\nFull Text Available Three object-oriented implementations of a prototype solver of the advection equation are introduced. The presented programs are based on Blitz++ (C++, NumPy (Python and Fortran's built-in array containers. The solvers constitute implementations of the Multidimensional Positive-Definite Advective Transport Algorithm (MPDATA. The introduced codes serve as examples for how the application of object-oriented programming (OOP techniques and new language constructs from C++11 and Fortran 2008 allow to reproduce the mathematical notation used in the literature within the program code. A discussion on the tradeoffs of the programming language choice is presented. The main angles of comparison are code brevity and syntax clarity (and hence maintainability and auditability as well as performance. All performance tests are carried out using free and open-source compilers. In the case of Python, a significant performance gain is observed when switching from the standard interpreter (CPython to the PyPy implementation of Python. Entire source code of all three implementations is embedded in the text and is licensed under the terms of the GNU GPL license.\n\nThe comparison and selection of programming languages for high energy physics applications\n\nInternational Nuclear Information System (INIS)\n\nWhite, B.\n\n1991-06-01\n\nThis paper discusses the issues surrounding the comparison and selection of a programming language to be used in high energy physics software applications. The evaluation method used was specifically devised to address the issues of particular importance to high energy physics (HEP) applications, not just the technical features of the languages considered. The method assumes a knowledge of the requirements of current HEP applications, the data-processing environments expected to support these applications and relevant non-technical issues. The languages evaluated were Ada, C, FORTRAN 77, FORTRAN 99 (formerly 8X), Pascal and PL/1. Particular emphasis is placed upon the past, present and anticipated future role of FORTRAN in HEP software applications. Upon examination of the technical and practical issues, conclusions are reached and some recommendations are made regarding the role of FORTRAN and other programming languages in the current and future development of HEP software. 54 refs\n\nVFC: The Vienna Fortran Compiler\n\nDirectory of Open Access Journals (Sweden)\n\nSiegfried Benkner\n\n1999-01-01\n\nFull Text Available High Performance Fortran (HPF offers an attractive highâlevel language interface for programming scalable parallel architectures providing the user with directives for the specification of data distribution and delegating to the compiler the task of generating an explicitly parallel program. Available HPF compilers can handle regular codes quite efficiently, but dramatic performance losses may be encountered for applications which are based on highly irregular, dynamically changing data structures and access patterns. In this paper we introduce the Vienna Fortran Compiler (VFC, a new sourceâtoâsource parallelization system for HPF+, an optimized version of HPF, which addresses the requirements of irregular applications. In addition to extended data distribution and work distribution mechanisms, HPF+ provides the user with language features for specifying certain information that decisively influence a programâs performance. This comprises data locality assertions, nonâlocal access specifications and the possibility of reusing runtimeâgenerated communication schedules of irregular loops. Performance measurements of kernels from advanced applications demonstrate that with a highâlevel data parallel language such as HPF+ a performance close to handâwritten messageâpassing programs can be achieved even for highly irregular codes.\n\nFortran 90 for scientists and engineers\n\nCERN Document Server\n\nHahn, Brian\n\n1994-01-01\n\nThe introduction of the Fortran 90 standard is the first significant change in the Fortran language in over 20 years. this book is designed for anyone wanting to learn Fortran for the first time or or a programmer who needs to upgrade from Fortran 77 to Fortran 90.Employing a practical, problem-based approach this book provides a comprehensive introduction to the language. More experienced programmers will find it a useful update to the new standard and will benefit from the emphasis on science and engineering applications.\n\nProgramming Language Software For Graphics Applications\n\nScience.gov (United States)\n\nBeckman, Brian C.\n\n1993-01-01\n\nNew approach reduces repetitive development of features common to different applications. High-level programming language and interactive environment with access to graphical hardware and software created by adding graphical commands and other constructs to standardized, general-purpose programming language, \"Scheme\". Designed for use in developing other software incorporating interactive computer-graphics capabilities into application programs. Provides alternative to programming entire applications in C or FORTRAN, specifically ameliorating design and implementation of complex control and data structures typifying applications with interactive graphics. Enables experimental programming and rapid development of prototype software, and yields high-level programs serving as executable versions of software-design documentation.\n\nARBUS: A FORTRAN tool for generating tree structure diagrams\n\nInternational Nuclear Information System (INIS)\n\nFerrero, C.; Zanger, M.\n\n1992-02-01\n\nThe FORTRAN77 stand-alone code ARBUS has been designed to aid the user by providing a tree structure diagram generating utility for computer programs written in FORTRAN language. This report is intended to describe the main purpose and features of ARBUS and to highlight some additional applications of the code by means of practical test cases. (orig.) [de\n\nLanguage constructs for modular parallel programs\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nFoster, I.\n\n1996-03-01\n\nWe describe programming language constructs that facilitate the application of modular design techniques in parallel programming. These constructs allow us to isolate resource management and processor scheduling decisions from the specification of individual modules, which can themselves encapsulate design decisions concerned with concurrence, communication, process mapping, and data distribution. This approach permits development of libraries of reusable parallel program components and the reuse of these components in different contexts. In particular, alternative mapping strategies can be explored without modifying other aspects of program logic. We describe how these constructs are incorporated in two practical parallel programming languages, PCN and Fortran M. Compilers have been developed for both languages, allowing experimentation in substantial applications.\n\nVisualization of Distributed Data Structures for High Performance Fortran-Like Languages\n\nDirectory of Open Access Journals (Sweden)\n\nRainer Koppler\n\n1997-01-01\n\nFull Text Available This article motivates the usage of graphics and visualization for efficient utilization of High Performance Fortran's (HPF's data distribution facilities. It proposes a graphical toolkit consisting of exploratory and estimation tools which allow the programmer to navigate through complex distributions and to obtain graphical ratings with respect to load distribution and communication. The toolkit has been implemented in a mapping design and visualization tool which is coupled with a compilation system for the HPF predecessor Vienna Fortran. Since this language covers a superset of HPF's facilities, the tool may also be used for visualization of HPF data structures.\n\nIFF, Full-Screen Input Menu Generator for FORTRAN Program\n\nInternational Nuclear Information System (INIS)\n\nSeidl, Albert\n\n1991-01-01\n\n1 - Description of program or function: The IFF-package contains input modules for use within FORTRAN programs. This package enables the programmer to easily include interactive menu-directed data input (module VTMEN1) and command-word processing (module INPCOM) into a FORTRAN program. 2 - Method of solution: No mathematical operations are performed. 3 - Restrictions on the complexity of the problem: Certain restrictions of use may arise from the dimensioning of arrays. Field lengths are defined via PARAMETER-statements\n\nSVM Support in the Vienna Fortran Compilation System\n\nOpenAIRE\n\nBrezany, Peter; Gerndt, Michael; Sipkova, Viera\n\n1994-01-01\n\nVienna Fortran, a machine-independent language extension to Fortran which allows the user to write programs for distributed-memory systems using global addresses, provides the forall-loop construct for specifying irregular computations that do not cause inter-iteration dependences. Compilers for distributed-memory systems generate code that is based on runtime analysis techniques and is only efficient if, in addition, aggressive compile-time optimizations are applied. Since these optimization...\n\nNLEdit: A generic graphical user interface for Fortran programs\n\nScience.gov (United States)\n\nCurlett, Brian P.\n\n1994-01-01\n\nNLEdit is a generic graphical user interface for the preprocessing of Fortran namelist input files. The interface consists of a menu system, a message window, a help system, and data entry forms. A form is generated for each namelist. The form has an input field for each namelist variable along with a one-line description of that variable. Detailed help information, default values, and minimum and maximum allowable values can all be displayed via menu picks. Inputs are processed through a scientific calculator program that allows complex equations to be used instead of simple numeric inputs. A custom user interface is generated simply by entering information about the namelist input variables into an ASCII file. There is no need to learn a new graphics system or programming language. NLEdit can be used as a stand-alone program or as part of a larger graphical user interface. Although NLEdit is intended for files using namelist format, it can be easily modified to handle other file formats.\n\nMAPLIB, Thermodynamics Materials Property Generator for FORTRAN Program\n\nInternational Nuclear Information System (INIS)\n\nSchumann, U.; Zimmerer, W. and others\n\n1978-01-01\n\n1 - Nature of physical problem solved: MAPLIB is a program system which is able to incorporate the values of the properties of any material in a form suitable for use in other computer programs. The data are implemented in FORTRAN functions. A utility program is provided to assist in library management. 2 - Method of solution: MAPLIB consists of the following parts: 1) Conventions for the data format. 2) Some integrated data. 3) A data access system (FORTRAN subroutine). 4) An utility program for updating and documentation of the actual library content. The central part is a set of FORTRAN functions, e.g. WL H2O v(t,p) (heat conduction of water vapor as a function of temperature and pressure), which compute the required data and which can be called by the user program. The data content of MAPLIB has been delivered by many persons. There was no systematic evaluation of the material. It is the responsibility of every user to check the data for physical accuracy. MAPLIB only serves as a library system for manipulation and storing of such data. 3 - Restrictions on the complexity of the problem: a) See responsibility as explained above. b) Up to 1000 data functions could be implemented. c) If too many data functions are included in MAPLIB, the storage requirements become excessive for application in users programs\n\nFinal Report, Center for Programming Models for Scalable Parallel Computing: Co-Array Fortran, Grant Number DE-FC02-01ER25505\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nRobert W. Numrich\n\n2008-04-22\n\nThe major accomplishment of this project is the production of CafLib, an 'object-oriented' parallel numerical library written in Co-Array Fortran. CafLib contains distributed objects such as block vectors and block matrices along with procedures, attached to each object, that perform basic linear algebra operations such as matrix multiplication, matrix transpose and LU decomposition. It also contains constructors and destructors for each object that hide the details of data decomposition from the programmer, and it contains collective operations that allow the programmer to calculate global reductions, such as global sums, global minima and global maxima, as well as vector and matrix norms of several kinds. CafLib is designed to be extensible in such a way that programmers can define distributed grid and field objects, based on vector and matrix objects from the library, for finite difference algorithms to solve partial differential equations. A very important extra benefit that resulted from the project is the inclusion of the co-array programming model in the next Fortran standard called Fortran 2008. It is the first parallel programming model ever included as a standard part of the language. Co-arrays will be a supported feature in all Fortran compilers, and the portability provided by standardization will encourage a large number of programmers to adopt it for new parallel application development. The combination of object-oriented programming in Fortran 2003 with co-arrays in Fortran 2008 provides a very powerful programming model for high-performance scientific computing. Additional benefits from the project, beyond the original goal, include a programto provide access to the co-array model through access to the Cray compiler as a resource for teaching and research. Several academics, for the first time, included the co-array model as a topic in their courses on parallel computing. A separate collaborative project with LANL and PNNL showed how to\n\nStandard Fortran\n\nInternational Nuclear Information System (INIS)\n\nMarshall, N.H.\n\n1981-01-01\n\nBecause of its vast software investment in Fortran programs, the nuclear community has an inherent interest in the evolution of Fortran. This paper reviews the impact of the new Fortran 77 standard and discusses the projected changes which can be expected in the future\n\nProgramming a real code in a functional language (part 1)\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nHendrickson, C.P.\n\n1991-09-10\n\nFor some, functional languages hold the promise of allowing ease of programming massively parallel computers that imperative languages such as Fortran and C do not offer. At LLNL, we have initiated a project to write the physics of a major production code in Sisal, a functional language developed at LLNL in collaboration with researchers throughout the world. We are investigating the expressibility of Sisal, as well as its performance on a shared-memory multiprocessor, the Y-MP. An interesting aspect of the project is that Sisal modules can call Fortran modules, and are callable by them. This eliminates the rewriting of 80% of the production code that would not benefit from parallel execution. Preliminary results indicate that the restrictive nature of the language does not cause problems in expressing the algorithms we have chosen. Some interesting aspects of programming in a mixed functional-imperative environment have surfaced, but can be managed. 8 refs.\n\nAlternatives to FORTRAN in control systems\n\nInternational Nuclear Information System (INIS)\n\nHowell, J.A.; Wright, R.M.\n\n1985-01-01\n\nControl system software has traditionally been written in assembly language, FORTRAN, or Basic. Today there exist several high-level languages with features that make them convenient and effective in control systems. These features include bit manipulation, user-defined data types, character manipulation, and high-level logical operations. Some of theses languages are quite different from FORTRAN and yet are easy to read and use. We discuss several languages, their features that make them convenient for control systems, and give examples of their use. We focus particular attention on the language C, developed by Bell Laboratories\n\nProgramming effort analysis of the ELLPACK language\n\nScience.gov (United States)\n\nRice, J. R.\n\n1978-01-01\n\nELLPACK is a problem statement language and system for elliptic partial differential equations which is implemented by a FORTRAN preprocessor. ELLPACK's principal purpose is as a tool for the performance evaluation of software. However, it is used here as an example with which to study the programming effort required for problem solving. It is obvious that problem statement languages can reduce programming effort tremendously; the goal is to quantify this somewhat. This is done by analyzing the lengths and effort (as measured by Halstead's software science technique) of various approaches to solving these problems.\n\nA comparative study of programming languages for next-generation astrodynamics systems\n\nScience.gov (United States)\n\nEichhorn, Helge; Cano, Juan Luis; McLean, Frazer; Anderl, Reiner\n\n2018-03-01\n\nDue to the computationally intensive nature of astrodynamics tasks, astrodynamicists have relied on compiled programming languages such as Fortran for the development of astrodynamics software. Interpreted languages such as Python, on the other hand, offer higher flexibility and development speed thereby increasing the productivity of the programmer. While interpreted languages are generally slower than compiled languages, recent developments such as just-in-time (JIT) compilers or transpilers have been able to close this speed gap significantly. Another important factor for the usefulness of a programming language is its wider ecosystem which consists of the available open-source packages and development tools such as integrated development environments or debuggers. This study compares three compiled languages and three interpreted languages, which were selected based on their popularity within the scientific programming community and technical merit. The three compiled candidate languages are Fortran, C++, and Java. Python, Matlab, and Julia were selected as the interpreted candidate languages. All six languages are assessed and compared to each other based on their features, performance, and ease-of-use through the implementation of idiomatic solutions to classical astrodynamics problems. We show that compiled languages still provide the best performance for astrodynamics applications, but JIT-compiled dynamic languages have reached a competitive level of speed and offer an attractive compromise between numerical performance and programmer productivity.\n\nComputer Language For Optimization Of Design\n\nScience.gov (United States)\n\nScotti, Stephen J.; Lucas, Stephen H.\n\n1991-01-01\n\nSOL is computer language geared to solution of design problems. Includes mathematical modeling and logical capabilities of computer language like FORTRAN; also includes additional power of nonlinear mathematical programming methods at language level. SOL compiler takes SOL-language statements and generates equivalent FORTRAN code and system calls. Provides syntactic and semantic checking for recovery from errors and provides detailed reports containing cross-references to show where each variable used. Implemented on VAX/VMS computer systems. Requires VAX FORTRAN compiler to produce executable program.\n\nFortran interface layer of the framework for developing particle simulator FDPS\n\nScience.gov (United States)\n\nNamekata, Daisuke; Iwasawa, Masaki; Nitadori, Keigo; Tanikawa, Ataru; Muranushi, Takayuki; Wang, Long; Hosono, Natsuki; Nomura, Kentaro; Makino, Junichiro\n\n2018-06-01\n\nNumerical simulations based on particle methods have been widely used in various fields including astrophysics. To date, various versions of simulation software have been developed by individual researchers or research groups in each field, through a huge amount of time and effort, even though the numerical algorithms used are very similar. To improve the situation, we have developed a framework, called FDPS (Framework for Developing Particle Simulators), which enables researchers to develop massively parallel particle simulation codes for arbitrary particle methods easily. Until version 3.0, FDPS provided an API (application programming interface) for the C++ programming language only. This limitation comes from the fact that FDPS is developed using the template feature in C++, which is essential to support arbitrary data types of particle. However, there are many researchers who use Fortran to develop their codes. Thus, the previous versions of FDPS require such people to invest much time to learn C++. This is inefficient. To cope with this problem, we developed a Fortran interface layer in FDPS, which provides API for Fortran. In order to support arbitrary data types of particle in Fortran, we design the Fortran interface layer as follows. Based on a given derived data type in Fortran representing particle, a PYTHON script provided by us automatically generates a library that manipulates the C++ core part of FDPS. This library is seen as a Fortran module providing an API of FDPS from the Fortran side and uses C programs internally to interoperate Fortran with C++. In this way, we have overcome several technical issues when emulating a `template' in Fortran. Using the Fortran interface, users can develop all parts of their codes in Fortran. We show that the overhead of the Fortran interface part is sufficiently small and a code written in Fortran shows a performance practically identical to the one written in C++.\n\nIntroduction to modern Fortran for the Earth system sciences\n\nCERN Document Server\n\nChirila, Dragos B\n\n2014-01-01\n\nThis work provides a short \"getting started\" guide to Fortran 90/95. The main target audience consists of newcomers to the field of numerical computation within Earth system sciences (students, researchers or scientific programmers). Furthermore, readers accustomed to other programming languages may also benefit from this work, by discovering how some programming techniques they are familiar with map to Fortran 95. The main goal is to enable readers to quickly start using Fortran 95 for writing useful programs. It also introduces a gradual discussion of Input/Output facilities relevant for Earth system sciences, from the simplest ones to the more advanced netCDF library (which has become a de facto standard for handling the massive datasets used within Earth system sciences). While related works already treat these disciplines separately (each often providing much more information than needed by the beginning practitioner), the reader finds in this book a shorter guide which links them. Compared to other book...\n\nThe Fortran-P Translator: Towards Automatic Translation of Fortran 77 Programs for Massively Parallel Processors\n\nDirectory of Open Access Journals (Sweden)\n\nMatthew O'keefe\n\n1995-01-01\n\nFull Text Available Massively parallel processors (MPPs hold the promise of extremely high performance that, if realized, could be used to study problems of unprecedented size and complexity. One of the primary stumbling blocks to this promise has been the lack of tools to translate application codes to MPP form. In this article we show how applications codes written in a subset of Fortran 77, called Fortran-P, can be translated to achieve good performance on several massively parallel machines. This subset can express codes that are self-similar, where the algorithm applied to the global data domain is also applied to each subdomain. We have found many codes that match the Fortran-P programming style and have converted them using our tools. We believe a self-similar coding style will accomplish what a vectorizable style has accomplished for vector machines by allowing the construction of robust, user-friendly, automatic translation systems that increase programmer productivity and generate fast, efficient code for MPPs.\n\nOpenMP GNU and Intel Fortran programs for solving the time-dependent Gross-Pitaevskii equation\n\nScience.gov (United States)\n\nYoung-S., Luis E.; Muruganandam, Paulsamy; Adhikari, Sadhan K.; LonÄar, Vladimir; VudragoviÄ, DuÅ¡an; BalaÅ¾, Antun\n\n2017-11-01\n\nWe present Open Multi-Processing (OpenMP) version of Fortran 90 programs for solving the Gross-Pitaevskii (GP) equation for a Bose-Einstein condensate in one, two, and three spatial dimensions, optimized for use with GNU and Intel compilers. We use the split-step Crank-Nicolson algorithm for imaginary- and real-time propagation, which enables efficient calculation of stationary and non-stationary solutions, respectively. The present OpenMP programs are designed for computers with multi-core processors and optimized for compiling with both commercially-licensed Intel Fortran and popular free open-source GNU Fortran compiler. The programs are easy to use and are elaborated with helpful comments for the users. All input parameters are listed at the beginning of each program. Different output files provide physical quantities such as energy, chemical potential, root-mean-square sizes, densities, etc. We also present speedup test results for new versions of the programs. Program files doi:http://dx.doi.org/10.17632/y8zk3jgn84.2 Licensing provisions: Apache License 2.0 Programming language: OpenMP GNU and Intel Fortran 90. Computer: Any multi-core personal computer or workstation with the appropriate OpenMP-capable Fortran compiler installed. Number of processors used: All available CPU cores on the executing computer. Journal reference of previous version: Comput. Phys. Commun. 180 (2009) 1888; ibid.204 (2016) 209. Does the new version supersede the previous version?: Not completely. It does supersede previous Fortran programs from both references above, but not OpenMP C programs from Comput. Phys. Commun. 204 (2016) 209. Nature of problem: The present Open Multi-Processing (OpenMP) Fortran programs, optimized for use with commercially-licensed Intel Fortran and free open-source GNU Fortran compilers, solve the time-dependent nonlinear partial differential (GP) equation for a trapped Bose-Einstein condensate in one (1d), two (2d), and three (3d) spatial dimensions for\n\nOn the tradeoffs of programming language choice for numerical modelling in geoscience. A case study comparing modern Fortran, C++/Blitz++ and Python/NumPy.\n\nScience.gov (United States)\n\nJarecka, D.; Arabas, S.; Fijalkowski, M.; Gaynor, A.\n\n2012-04-01\n\nThe language of choice for numerical modelling in geoscience has long been Fortran. A choice of a particular language and coding paradigm comes with different set of tradeoffs such as that between performance, ease of use (and ease of abuse), code clarity, maintainability and reusability, availability of open source compilers, debugging tools, adequate external libraries and parallelisation mechanisms. The availability of trained personnel and the scale and activeness of the developer community is of importance as well. We present a short comparison study aimed at identification and quantification of these tradeoffs for a particular example of an object oriented implementation of a parallel 2D-advection-equation solver in Python/NumPy, C++/Blitz++ and modern Fortran. The main angles of comparison will be complexity of implementation, performance of various compilers or interpreters and characterisation of the \"added value\" gained by a particular choice of the language. The choice of the numerical problem is dictated by the aim to make the comparison useful and meaningful to geoscientists. Python is chosen as a language that traditionally is associated with ease of use, elegant syntax but limited performance. C++ is chosen for its traditional association with high performance but even higher complexity and syntax obscurity. Fortran is included in the comparison for its widespread use in geoscience often attributed to its performance. We confront the validity of these traditional views. We point out how the usability of a particular language in geoscience depends on the characteristics of the language itself and the availability of pre-existing software libraries (e.g. NumPy, SciPy, PyNGL, PyNIO, MPI4Py for Python and Blitz++, Boost.Units, Boost.MPI for C++). Having in mind the limited complexity of the considered numerical problem, we present a tentative comparison of performance of the three implementations with different open source compilers including CPython and\n\nNumerical methods of mathematical optimization with Algol and Fortran programs\n\nCERN Document Server\n\nKÃ¼nzi, Hans P; Zehnder, C A; Rheinboldt, Werner\n\n1971-01-01\n\nNumerical Methods of Mathematical Optimization: With ALGOL and FORTRAN Programs reviews the theory and the practical application of the numerical methods of mathematical optimization. An ALGOL and a FORTRAN program was developed for each one of the algorithms described in the theoretical section. This should result in easy access to the application of the different optimization methods.Comprised of four chapters, this volume begins with a discussion on the theory of linear and nonlinear optimization, with the main stress on an easily understood, mathematically precise presentation. In addition\n\nFORTRAN programs for transient eddy current calculations using a perturbation-polynomial expansion technique\n\nInternational Nuclear Information System (INIS)\n\nCarpenter, K.H.\n\n1976-11-01\n\nA description is given of FORTRAN programs for transient eddy current calculations in thin, non-magnetic conductors using a perturbation-polynomial expansion technique. Basic equations are presented as well as flow charts for the programs implementing them. The implementation is in two steps--a batch program to produce an intermediate data file and interactive programs to produce graphical output. FORTRAN source listings are included for all program elements, and sample inputs and outputs are given for the major programs\n\nMultidimentional and Multi-Parameter Fortran-Based Curve Fitting ...\n\nAfrican Journals Online (AJOL)\n\nThis work briefly describes the mathematics behind the algorithm, and also elaborates how to implement it using FORTRAN 95 programming language. The advantage of this algorithm, when it is extended to surfaces and complex functions, is that it makes researchers to have a better trust during fitting. It also improves theÂ ...\n\nA FORTRAN program for a least-square fitting\n\nInternational Nuclear Information System (INIS)\n\nYamazaki, Tetsuo\n\n1978-01-01\n\nA practical FORTRAN program for a least-squares fitting is presented. Although the method is quite usual, the program calculates not only the most satisfactory set of values of unknowns but also the plausible errors associated with them. As an example, a measured lateral absorbed-dose distribution in water for a narrow 25-MeV electron beam is fitted to a Gaussian distribution. (auth.)\n\nThe Julia programming language: the future of scientific computing\n\nScience.gov (United States)\n\nGibson, John\n\n2017-11-01\n\nJulia is an innovative new open-source programming language for high-level, high-performance numerical computing. Julia combines the general-purpose breadth and extensibility of Python, the ease-of-use and numeric focus of Matlab, the speed of C and Fortran, and the metaprogramming power of Lisp. Julia uses type inference and just-in-time compilation to compile high-level user code to machine code on the fly. A rich set of numeric types and extensive numerical libraries are built-in. As a result, Julia is competitive with Matlab for interactive graphical exploration and with C and Fortran for high-performance computing. This talk interactively demonstrates Julia's numerical features and benchmarks Julia against C, C++, Fortran, Matlab, and Python on a spectral time-stepping algorithm for a 1d nonlinear partial differential equation. The Julia code is nearly as compact as Matlab and nearly as fast as Fortran. This material is based upon work supported by the National Science Foundation under Grant No. 1554149.\n\nPGHPF â An Optimizing High Performance Fortran Compiler for Distributed Memory Machines\n\nDirectory of Open Access Journals (Sweden)\n\nZeki Bozkus\n\n1997-01-01\n\nFull Text Available High Performance Fortran (HPF is the first widely supported, efficient, and portable parallel programming language for shared and distributed memory systems. HPF is realized through a set of directive-based extensions to Fortran 90. It enables application developers and Fortran end-users to write compact, portable, and efficient software that will compile and execute on workstations, shared memory servers, clusters, traditional supercomputers, or massively parallel processors. This article describes a production-quality HPF compiler for a set of parallel machines. Compilation techniques such as data and computation distribution, communication generation, run-time support, and optimization issues are elaborated as the basis for an HPF compiler implementation on distributed memory machines. The performance of this compiler on benchmark programs demonstrates that high efficiency can be achieved executing HPF code on parallel architectures.\n\nFORTRAN text correction with the CDC-1604-A console typewriter during reading a punched card program\n\nInternational Nuclear Information System (INIS)\n\nKotorobaj, F.; Ruzhichka, Ya.; Stolyarskij, Yu.V.\n\n1977-01-01\n\nThe paper describes FORTRAN text correction with the CDC 1604-A console typewriter during reading a punched card program. This method gives one more possibility of FORTRAN program correction during program's input to the CDC 1604-A computer. This essentially reduced the time necessary for punched card correction with other methods. Possibility of inputting desired number of punched cards one after another allows one writing small FORTRAN programs to computer core storage with simultaneous punching of the cards. The correction program has been written to the CDC 1604 COOP monitor\n\nAn Introduction to Fortran Programming: An IPI Approach.\n\nScience.gov (United States)\n\nFisher, D. D.; And Others\n\nThis text is designed to give individually paced instruction in Fortran Programing. The text contains fifteen units. Unit titles include: Flowcharts, Input and Output, Loops, and Debugging. Also included is an extensive set of appendices. These were designed to contain a great deal of practical information necessary to the course. These appendicesâ¦\n\nThe Transition and Adoption to Modern Programming Concepts for Scientific Computing in Fortran\n\nDirectory of Open Access Journals (Sweden)\n\nCharles D. Norton\n\n2007-01-01\n\nFull Text Available This paper describes our experiences in the early exploration of modern concepts introduced in Fortran90 for large-scale scientific programming. We review our early work in expressing object-oriented concepts based on the new Fortran90 constructs â foreign to most programmers at the time â our experimental work in applying them to various applications, the impact on the WG5/J3 standards committees to consider formalizing object-oriented constructs for later versions of Fortran, and work in exploring how other modern programming techniques such as Design Patterns can and have impacted our software development. Applications will be drawn from plasma particle simulation and finite element adaptive mesh refinement for solid earth crustal deformation modeling.\n\nTOOLPACK1, Tools for Development and Maintenance of FORTRAN 77 Program\n\nInternational Nuclear Information System (INIS)\n\nCowell, Wayne R.\n\n1993-01-01\n\n1 - Description of program or function: TOOLPACK1 consists of the following categories of software; (1) an integrated collection of tools intended to support the development and maintenance of FORTRAN 77 programs, in particular moderate-sized collections of mathematical software; (2) several user/Toolpack interfaces, one of which is selected for use at any particular installation; (3) three implementations of the tool/system interface, called TIE (Tool Interface to the Environment). The tools are written in FORTRAN 77 and are portable among TIE installations. The source contains symbolic constants as macro names and must be expanded with a suitable macro expander before being compiled and loaded. A portable macro expander is supplied in TOOLPACK1. The tools may be divided into three functional areas: general, documentation, and processing. One tool, the macro processor, Can be used in any of these categories. ISTDC: data comparison tool is designed mainly for comparing files of numeric values, and files with embedded text. ISTET Expands tabs. ISTFI: finds all the include files that a file needs. ISTGP Searches multiple files for occurrences of a regular expression. ISTHP: will provide limited help information about tools. ISTMP: The macro processor may be used to pre-process a file. The processor provides macro replacement, inclusion, conditional replacement, and processing capabilities for complex file processing. ISTSP: TIE-conforming version of the SPLIT utility to split up the concatenated files used on the tape. ISTSV: save/restore utility to save and restore sub-trees of the Portable File Store (PFS). ISTTD: text comparison tool. ISTVC: simple text file version controller. ISTAL: aids is a preprocessor that can be used to generate specific information from intermediate files created by other tools. The information that can be generated includes call-graphs, cross reference listings, segment execution frequencies, and symbol information. ISTAL can also strip\n\nFortran code for generating random probability vectors, unitaries, and quantum states\n\nDirectory of Open Access Journals (Sweden)\n\nJonas eMaziero\n\n2016-03-01\n\nFull Text Available The usefulness of generating random configurations is recognized in many areas of knowledge. Fortran was born for scientific computing and has been one of the main programming languages in this area since then. And several ongoing projects targeting towards its betterment indicate that it will keep this status in the decades to come. In this article, we describe Fortran codes produced, or organized, for the generation of the following random objects: numbers, probability vectors, unitary matrices, and quantum state vectors and density matrices. Some matrix functions are also included and may be of independent interest.\n\nMass: Fortran program for calculating mass-absorption coefficients\n\nInternational Nuclear Information System (INIS)\n\nNielsen, Aa.; Svane Petersen, T.\n\n1980-01-01\n\nDeterminations of mass-absorption coefficients in the x-ray analysis of trace elements are an important and time consuming part of the arithmetic calculation. In the course of time different metods have been used. The program MASS calculates the mass-absorption coefficients from a given major element analysis at the x-ray wavelengths normally used in trace element determinations and lists the chemical analysis and the mass-absorption coefficients. The program is coded in FORTRAN IV, and is operational on the IBM 370/165 computer, on the UNIVAC 1110 and on PDP 11/05. (author)\n\nhepawk - A language for scanning high energy physics events\n\nInternational Nuclear Information System (INIS)\n\nOhl, T.\n\n1992-01-01\n\nWe present the programming language hepawk, designed for convenient scanning of data structures arising in the simulation of high energy physics events. The interpreter for this language has been implemented in FORTRAN-77, therefore hepawk runs on any machine with a FORTRAN-77 compiler. (orig.)\n\nCloudy's Journey from FORTRAN to C, Why and How\n\nScience.gov (United States)\n\nFerland, G. J.\n\nCloudy is a large-scale plasma simulation code that is widely used across the astronomical community as an aid in the interpretation of spectroscopic data. The cover of the ADAS VI book featured predictions of the code. The FORTRAN 77 source code has always been freely available on the Internet, contributing to its widespread use. The coming of PCs and Linux has fundamentally changed the computing environment. Modern Fortran compilers (F90 and F95) are not freely available. A common-use code must be written in either FORTRAN 77 or C to be Open Source/GNU/Linux friendly. F77 has serious drawbacks - modern language constructs cannot be used, students do not have skills in this language, and it does not contribute to their future employability. It became clear that the code would have to be ported to C to have a viable future. I describe the approach I used to convert Cloudy from FORTRAN 77 with MILSPEC extensions to ANSI/ISO 89 C. Cloudy is now openly available as a C code, and will evolve to C++ as gcc and standard C++ mature. Cloudy looks to a bright future with a modern language.\n\n1957-2007: 50 Years of Higher Order Programming Languages\n\nDirectory of Open Access Journals (Sweden)\n\nAlen LovrenÄiÄ\n\n2009-06-01\n\nFull Text Available Fifty years ago one of the greatest breakthroughs in computer programming and in the history of computers happened -- the appearance of FORTRAN, the first higher-order programming language. From that time until now hundreds of programming languages were invented, different programming paradigms were defined, all with the main goal to make computer programming easier and closer to as many people as possible. Many battles were fought among scientists as well as among developers around concepts of programming, programming languages and paradigms. It can be said that programming paradigms and programming languages were very often a trigger for many changes and improvements in computer science as well as in computer industry. Definitely, computer programming is one of the cornerstones of computer science.Today there are many tools that give a help in the process of programming, but there is still a programming tasks that can be solved only manually. Therefore, programming is still one of the most creative parts of interaction with computers.Programmers should chose programming language in accordance to task they have to solve, but very often, they chose it in accordance to their personal preferences, their beliefs and many other subjective reasons.Nevertheless, the market of programming languages can be merciless to languages as history was merciless to some people, even whole nations. Programming languages and developers get born, live and die leaving more or less tracks and successors, and not always the best survives. The history of programming languages is closely connected to the history of computers and computer science itself. Every single thing from one of them has its reflexions onto the other. This paper gives a short overview of last fifty years of computer programming and computer programming languages, but also gives many ideas that influenced other aspects of computer science. Particularly, programming paradigms are described, their\n\nPerbandingan Bubble Sort dengan Insertion Sort pada Bahasa Pemrograman C dan Fortran\n\nDirectory of Open Access Journals (Sweden)\n\nReina Reina\n\n2013-12-01\n\nFull Text Available Sorting is a basic algorithm studied by students of computer science major. Sorting algorithm is the basis of other algorithms such as searching algorithm, pattern matching algorithm. Bubble sort is a popular basic sorting algorithm due to its easiness to be implemented. Besides bubble sort, there is insertion sort. It is lesspopular than bubble sort because it has more difficult algorithm. This paper discusses about process time between insertion sort and bubble sort with two kinds of data. First is randomized data, and the second is data of descending list. Comparison of process time has been done in two kinds of programming language that is C programming language and FORTRAN programming language. The result shows that bubble sort needs more time than insertion sort does.\n\nLFK, FORTRAN Application Performance Test\n\nInternational Nuclear Information System (INIS)\n\nMcMahon, F.H.\n\n1991-01-01\n\n1 - Description of program or function: LFK, the Livermore FORTRAN Kernels, is a computer performance test that measures a realistic floating-point performance range for FORTRAN applications. Informally known as the Livermore Loops test, the LFK test may be used as a computer performance test, as a test of compiler accuracy (via checksums) and efficiency, or as a hardware endurance test. The LFK test, which focuses on FORTRAN as used in computational physics, measures the joint performance of the computer CPU, the compiler, and the computational structures in units of Mega-flops/sec or Mflops. A C language version of subroutine KERNEL is also included which executes 24 samples of C numerical computation. The 24 kernels are a hydrodynamics code fragment, a fragment from an incomplete Cholesky conjugate gradient code, the standard inner product function of linear algebra, a fragment from a banded linear equations routine, a segment of a tridiagonal elimination routine, an example of a general linear recurrence equation, an equation of state fragment, part of an alternating direction implicit integration code, an integrate predictor code, a difference predictor code, a first sum, a first difference, a fragment from a two-dimensional particle-in-cell code, a part of a one-dimensional particle-in-cell code, an example of how casually FORTRAN can be written, a Monte Carlo search loop, an example of an implicit conditional computation, a fragment of a two-dimensional explicit hydrodynamics code, a general linear recurrence equation, part of a discrete ordinates transport program, a simple matrix calculation, a segment of a Planck distribution procedure, a two-dimensional implicit hydrodynamics fragment, and determination of the location of the first minimum in an array. 2 - Method of solution: CPU performance rates depend strongly on the maturity of FORTRAN compiler machine code optimization. The LFK test-bed executes the set of 24 kernels three times, resetting the DO\n\nA Fortran Program for Deep Space Sensor Analysis.\n\nScience.gov (United States)\n\n1984-12-14\n\nused to help p maintain currency to the deep space satellite catelog? Research Question Can a Fortran program be designed to evaluate the effectiveness ...Range ( AFETR ) Range p Measurements Laboratory (RML) is located in Malibar, .- Florida. Like GEODSS, Malibar uses a 48 inch telescope with a...phased out. This mode will evaluate the effect of the loss of the 3 Baker-Nunn sites to mode 3 Mode 5 through Mode 8 Modes 5 through 8 are identical to\n\nAn environment for parallel structuring of Fortran programs\n\nInternational Nuclear Information System (INIS)\n\nSridharan, K.; McShea, M.; Denton, C.; Eventoff, B.; Browne, J.C.; Newton, P.; Ellis, M.; Grossbard, D.; Wise, T.; Clemmer, D.\n\n1990-01-01\n\nThe paper describes and illustrates an environment for interactive support of the detection and implementation of macro-level parallelism in Fortran programs. The approach couples algorithms for dependence analysis with both innovative techniques for complexity management and capabilities for the measurement and analysis of the parallel computation structures generated through use of the environment. The resulting environment is complementary to the more common approach of seeking local parallelism by loop unrolling, either by an automatic compiler or manually. (orig.)\n\nImplementation of Neutronics Analysis Code using the Features of Object Oriented Programming via Fortran90/95\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nHan, Tae Young; Cho, Beom Jin [KEPCO Nuclear Fuel, Daejeon (Korea, Republic of)\n\n2011-05-15\n\nThe object-oriented programming (OOP) concept was radically established after 1990s and successfully involved in Fortran 90/95. The features of OOP are such as the information hiding, encapsulation, modularity and inheritance, which lead to producing code that satisfy three R's: reusability, reliability and readability. The major OOP concepts, however, except Module are not mainly used in neutronics analysis codes even though the code was written by Fortran 90/95. In this work, we show that the OOP concept can be employed to develop the neutronics analysis code, ASTRA1D (Advanced Static and Transient Reactor Analyzer for 1-Dimension), via Fortran90/95 and those can be more efficient and reasonable programming methods\n\nInnovative Language-Based & Object-Oriented Structured AMR Using Fortran 90 and OpenMP\n\nScience.gov (United States)\n\nNorton, C.; Balsara, D.\n\n1999-01-01\n\nParallel adaptive mesh refinement (AMR) is an important numerical technique that leads to the efficient solution of many physical and engineering problems. In this paper, we describe how AMR programing can be performed in an object-oreinted way using the modern aspects of Fortran 90 combined with the parallelization features of OpenMP.\n\nUser manual for two simple postscript output FORTRAN plotting routines\n\nScience.gov (United States)\n\nNguyen, T. X.\n\n1991-01-01\n\nGraphics is one of the important tools in engineering analysis and design. However, plotting routines that generate output on high quality laser printers normally come in graphics packages, which tend to be expensive and system dependent. These factors become important for small computer systems or desktop computers, especially when only some form of a simple plotting routine is sufficient. With the Postscript language becoming popular, there are more and more Postscript laser printers now available. Simple, versatile, low cost plotting routines that can generate output on high quality laser printers are needed and standard FORTRAN language plotting routines using output in Postscript language seems logical. The purpose here is to explain two simple FORTRAN plotting routines that generate output in Postscript language.\n\nComputer applications in physics with FORTRAN, BASIC and C\n\nCERN Document Server\n\nChandra, Suresh\n\n2014-01-01\n\nBecause of encouraging response for first two editions of the book and for taking into account valuable suggestion from teachers as well as students, the text for Interpolation, Differentiation, Integration, Roots of an Equation, Solution of Simultaneous Equations, Eigenvalues and Eigenvectors of Matrix, Solution of Differential Equations, Solution of Partial Differential Equations, Monte Carlo Method and Simulation, Computation of some Functions is improved throughout and presented in a more systematic manner by using simple language. These techniques have vast applications in Science, Engineering and Technology. The C language is becoming popular in universities, colleges and engineering institutions. Besides the C language, programs are written in FORTRAN and BASIC languages. Consequently, this book has rather wide scope for its use. Each of the topics are developed in a systematic manner; thus making this book useful for graduate, postgraduate and engineering students. KEY FEATURES: Each topic is self exp...\n\nImplementation of the Next Generation Attenuation (NGA) ground-motion prediction equations in Fortran and R\n\nScience.gov (United States)\n\nKaklamanos, James; Boore, David M.; Thompson, Eric M.; Campbell, Kenneth W.\n\n2010-01-01\n\nThis report presents two methods for implementing the earthquake ground-motion prediction equations released in 2008 as part of the Next Generation Attenuation of Ground Motions (NGA-West, or NGA) project coordinated by the Pacific Earthquake Engineering Research Center (PEER). These models were developed for predicting ground-motion parameters for shallow crustal earthquakes in active tectonic regions (such as California). Of the five ground-motion prediction equations (GMPEs) developed during the NGA project, four models are implemented: the GMPEs of Abrahamson and Silva (2008), Boore and Atkinson (2008), Campbell and Bozorgnia (2008), and Chiou and Youngs (2008a); these models are abbreviated as AS08, BA08, CB08, and CY08, respectively. Since site response is widely recognized as an important influence of ground motions, engineering applications typically require that such effects be modeled. The model of Idriss (2008) is not implemented in our programs because it does not explicitly include site response, whereas the other four models include site response and use the same variable to describe the site condition (VS30). We do not intend to discourage the use of the Idriss (2008) model, but we have chosen to implement the other four NGA models in our programs for those users who require ground-motion estimates for various site conditions. We have implemented the NGA models by using two separate programming languages: Fortran and R (R Development Core Team, 2010). Fortran, a compiled programming language, has been used in the scientific community for decades. R is an object-oriented language and environment for statistical computing that is gaining popularity in the statistical and scientific community. Derived from the S language and environment developed at Bell Laboratories, R is an open-source language that is freely available at http://www.r-project.org/ (last accessed 11 January 2011). In R, the functions for computing the NGA equations can be loaded as an\n\nImplementing embedded artificial intelligence rules within algorithmic programming languages\n\nScience.gov (United States)\n\nFeyock, Stefan\n\n1988-01-01\n\nMost integrations of artificial intelligence (AI) capabilities with non-AI (usually FORTRAN-based) application programs require the latter to execute separately to run as a subprogram or, at best, as a coroutine, of the AI system. In many cases, this organization is unacceptable; instead, the requirement is for an AI facility that runs in embedded mode; i.e., is called as subprogram by the application program. The design and implementation of a Prolog-based AI capability that can be invoked in embedded mode are described. The significance of this system is twofold: Provision of Prolog-based symbol-manipulation and deduction facilities makes a powerful symbolic reasoning mechanism available to applications programs written in non-AI languages. The power of the deductive and non-procedural descriptive capabilities of Prolog, which allow the user to describe the problem to be solved, rather than the solution, is to a large extent vitiated by the absence of the standard control structures provided by other languages. Embedding invocations of Prolog rule bases in programs written in non-AI languages makes it possible to put Prolog calls inside DO loops and similar control constructs. The resulting merger of non-AI and AI languages thus results in a symbiotic system in which the advantages of both programming systems are retained, and their deficiencies largely remedied.\n\nSLACINPT - a FORTRAN program that generates boundary data for the SLAC gun code\n\nInternational Nuclear Information System (INIS)\n\nMichel, W.L.; Hepburn, J.D.\n\n1982-03-01\n\nThe FORTRAN program SLACINPT was written to simplify the preparation of boundary data for the SLAC gun code. In SLACINPT, the boundary is described by a sequence of straight line or arc segments. From these, the program generates the individual boundary mesh point data, required as input by the SLAC gun code\n\nCross-language Babel structsâmaking scientific interfaces more efficient\n\nInternational Nuclear Information System (INIS)\n\nPrantl, Adrian; Epperly, Thomas G W; Ebner, Dietmar\n\n2013-01-01\n\nBabel is an open-source language interoperability framework tailored to the needs of high-performance scientific computing. As an integral element of the Common Component Architecture, it is employed in a wide range of scientific applications where it is used to connect components written in different programming languages. In this paper we describe how we extended Babel to support interoperable tuple data types (structs). Structs are a common idiom in (mono-lingual) scientific application programming interfaces (APIs); they are an efficient way to pass tuples of nonuniform data between functions, and are supported natively by most programming languages. Using our extended version of Babel, developers of scientific codes can now pass structs as arguments between functions implemented in any of the supported languages. In C, C++, Fortran 2003/2008 and Chapel, structs can be passed without the overhead of data marshaling or copying, providing language interoperability at minimal cost. Other supported languages are Fortran 77, Fortran 90/95, Java and Python. We will show how we designed a struct implementation that is interoperable with all of the supported languages and present benchmark data to compare the performance of all language bindings, highlighting the differences between languages that offer native struct support and an object-oriented interface with getter/setter methods. A case study shows how structs can help simplify the interfaces of scientific codes significantly. (paper)\n\nBasic linear algebra subprograms for FORTRAN usage\n\nScience.gov (United States)\n\nLawson, C. L.; Hanson, R. J.; Kincaid, D. R.; Krogh, F. T.\n\n1977-01-01\n\nA package of 38 low level subprograms for many of the basic operations of numerical linear algebra is presented. The package is intended to be used with FORTRAN. The operations in the package are dot products, elementary vector operations, Givens transformations, vector copy and swap, vector norms, vector scaling, and the indices of components of largest magnitude. The subprograms and a test driver are available in portable FORTRAN. Versions of the subprograms are also provided in assembly language for the IBM 360/67, the CDC 6600 and CDC 7600, and the Univac 1108.\n\nspecsim: A Fortran-77 program for conditional spectral simulation in 3D\n\nScience.gov (United States)\n\nYao, Tingting\n\n1998-12-01\n\nA Fortran 77 program, specsim, is presented for conditional spectral simulation in 3D domains. The traditional Fourier integral method allows generating random fields with a given covariance spectrum. Conditioning to local data is achieved by an iterative identification of the conditional phase information. A flowchart of the program is given to illustrate the implementation procedures of the program. A 3D case study is presented to demonstrate application of the program. A comparison with the traditional sequential Gaussian simulation algorithm emphasizes the advantages and drawbacks of the proposed algorithm.\n\nMulti-language Struct Support in Babel\n\nEnergy Technology Data Exchange (ETDEWEB)\n\nEbner, D; Prantl, A; Epperly, T W\n\n2011-03-22\n\nBabel is an open-source language interoperability framework tailored to the needs of high-performance scientific computing. As an integral element of the Common Component Architecture (CCA) it is used in a wide range of research projects. In this paper we describe how we extended Babel to support interoperable tuple data types (structs). Structs are a common idiom in scientific APIs; they are an efficient way to pass tuples of nonuniform data between functions, and are supported natively by most programming languages. Using our extended version of Babel, developers of scientific code can now pass structs as arguments between functions implemented in any of the supported languages. In C, C++ and Fortran 2003, structs can be passed without the overhead of data marshaling or copying, providing language interoperability at minimal cost. Other supported languages are Fortran 77, Fortran 90, Java and Python. We will show how we designed a struct implementation that is interoperable with all of the supported languages and present benchmark data compare the performance of all language bindings, highlighting the differences between languages that offer native struct support and an object-oriented interface with getter/setter methods.\n\nUse of the PASKAL' language for programming in experiment automation systems\n\nInternational Nuclear Information System (INIS)\n\nOstrovnoj, A.I.\n\n1985-01-01\n\nA complex of standard solutions intended for realization of the main functions is suggested; execution of these solutions is provided by any system for experiment automation. They include: recording and accumulation of experimental data; visualization and preliminary processing of incoming data, interaction with the operator and system control; data filing. It is advisable to use standard software, to represent data processing algorithms as parallel processes, to apply the PASCAL' language for programming. Programming using CAMAC equipment is provided by complex of procedures similar to the set of subprograms in the FORTRAN language. Utilization of a simple data file in accumulation and processing programs ensures unified representation of experimental data and uniform access to them on behalf of a large number of programs operating both on-line and off-line regimes. The suggested approach is realized when developing systems on the base of the SM-3, SM-4 and MERA-60 computers with RAFOS operating system\n\nPortable parallel programming in a Fortran environment\n\nInternational Nuclear Information System (INIS)\n\nMay, E.N.\n\n1989-01-01\n\nExperience using the Argonne-developed PARMACs macro package to implement a portable parallel programming environment is described. Fortran programs with intrinsic parallelism of coarse and medium granularity are easily converted to parallel programs which are portable among a number of commercially available parallel processors in the class of shared-memory bus-based and local-memory network based MIMD processors. The parallelism is implemented using standard UNIX (tm) tools and a small number of easily understood synchronization concepts (monitors and message-passing techniques) to construct and coordinate multiple cooperating processes on one or many processors. Benchmark results are presented for parallel computers such as the Alliant FX/8, the Encore MultiMax, the Sequent Balance, the Intel iPSC/2 Hypercube and a network of Sun 3 workstations. These parallel machines are typical MIMD types with from 8 to 30 processors, each rated at from 1 to 10 MIPS processing power. The demonstration code used for this work is a Monte Carlo simulation of the response to photons of a ''nearly realistic'' lead, iron and plastic electromagnetic and hadronic calorimeter, using the EGS4 code system. 6 refs., 2 figs., 2 tabs\n\nMULTITASKER, Multitasking Kernel for C and FORTRAN Under UNIX\n\nInternational Nuclear Information System (INIS)\n\nBrooks, E.D. III\n\n1988-01-01\n\n1 - Description of program or function: MULTITASKER implements a multitasking kernel for the C and FORTRAN programming languages that runs under UNIX. The kernel provides a multitasking environment which serves two purposes. The first is to provide an efficient portable environment for the development, debugging, and execution of production multiprocessor programs. The second is to provide a means of evaluating the performance of a multitasking program on model multiprocessor hardware. The performance evaluation features require no changes in the application program source and are implemented as a set of compile- and run-time options in the kernel. 2 - Method of solution: The FORTRAN interface to the kernel is identical in function to the CRI multitasking package provided for the Cray XMP. This provides a migration path to high speed (but small N) multiprocessors once the application has been coded and debugged. With use of the UNIX m4 macro preprocessor, source compatibility can be achieved between the UNIX code development system and the target Cray multiprocessor. The kernel also provides a means of evaluating a program's performance on model multiprocessors. Execution traces may be obtained which allow the user to determine kernel overhead, memory conflicts between various tasks, and the average concurrency being exploited. The kernel may also be made to switch tasks every cpu instruction with a random execution ordering. This allows the user to look for unprotected critical regions in the program. These features, implemented as a set of compile- and run-time options, cause extra execution overhead which is not present in the standard production version of the kernel\n\nObject oriented programming in simulation of ions transport\n\nInternational Nuclear Information System (INIS)\n\nZhang Wenyong; Wang Tongquan; Xiao Yabin; Dai Hongyi; Chen Yuzhong\n\n2001-01-01\n\nUsing Object Oriented Programming (OOP) method can make our program more reliable and easier to read, debug, maintain and upgrade. This paper compared FORTRAN90-the language widely used in science computing with C ++ --An Object Oriented Language, and the conclusion was made that although FORTRAN90 have many deficiencies, it can be used in Object Oriented programming. Then OOP method was used in programming of Monte Carlo simulation of ions transport and the general process of OOP was given\n\nFASTPLOT, Interface Routines to MS FORTRAN Graphics Library\n\nInternational Nuclear Information System (INIS)\n\n1999-01-01\n\n1 - Description of program or function: FASTPLOT is a library of routines that can be used to interface with the Microsoft FORTRAN Graphics library (GRAPHICS.LIB). The FASTPLOT routines simplify the development of graphics applications and add capabilities such as histograms, Splines, symbols, and error bars. FASTPLOT also includes routines that can be used to create menus. 2 - Methods: FASTPLOT is a library of routines which must be linked with a user's FORTRAN programs that call any FASTPLOT routines. In addition, the user must link with the Microsoft FORTRAN Graphics library (GRAPHICS.LIB). 3 - Restrictions on the complexity of the problem: None noted\n\nGRESS, FORTRAN Pre-compiler with Differentiation Enhancement\n\nInternational Nuclear Information System (INIS)\n\n1999-01-01\n\n1 - Description of program or function: The GRESS FORTRAN pre-compiler (SYMG) and run-time library are used to enhance conventional FORTRAN-77 programs with analytic differentiation of arithmetic statements for automatic differentiation in either forward or reverse mode. GRESS 3.0 is functionally equivalent to GRESS 2.1. GRESS 2.1 is an improved and updated version of the previous released GRESS 1.1. Improvements in the implementation of a the CHAIN option have resulted in a 70 to 85% reduction in execution time and up to a 50% reduction in memory required for forward chaining applications. 2 - Method of solution: GRESS uses a pre-compiler to analyze FORTRAN statements and determine the mathematical operations embodied in them. As each arithmetic assignment statement in a program is analyzed, SYMG generates the partial derivatives of the term on the left with respect to each floating-point variable on the right. The result of the pre-compilation step is a new FORTRAN program that can produce derivatives for any REAL (i.e., single or double precision) variable calculated by the model. Consequently, GRESS enhances FORTRAN programs or subprograms by adding the calculation of derivatives along with the original output. Derivatives from a GRESS enhanced model can be used internally (e.g., iteration acceleration) or externally (e.g., sensitivity studies). By calling GRESS run-time routines, derivatives can be propagated through the code via the chain rule (referred to as the CHAIN option) or accumulated to create an adjoint matrix (referred to as the ADGEN option). A third option, GENSUB, makes it possible to process a subset of a program (i.e., a do loop, subroutine, function, a sequence of subroutines, or a whole program) for calculating derivatives of dependent variables with respect to independent variables. A code enhanced with the GENSUB option can use forward mode, reverse mode, or a hybrid of the two modes. 3 - Restrictions on the complexity of the problem: GRESS\n\nA FORTRAN program for an IBM PC compatible computer for calculating kinematical electron diffraction patterns\n\nInternational Nuclear Information System (INIS)\n\nSkjerpe, P.\n\n1989-01-01\n\nThis report describes a computer program which is useful in transmission electron microscopy. The program is written in FORTRAN and calculates kinematical electron diffraction patterns in any zone axis from a given crystal structure. Quite large unit cells, containing up to 2250 atoms, can be handled by the program. The program runs on both the Helcules graphic card and the standard IBM CGA card\n\nASSIST - a package of Fortran routines for handling input under specified syntax rules and for management of data structures\n\nInternational Nuclear Information System (INIS)\n\nSinclair, J.E.\n\n1991-02-01\n\nThe ASSIST package (A Structured Storage and Input Syntax Tool) provides for Fortran programs a means for handling data structures more general than those provided by the Fortran language, and for obtaining input to the program from a file or terminal according to specified syntax rules. The syntax-controlled input can be interactive, with automatic generation of prompts, and dialogue to correct any input errors. The range of syntax rules possible is sufficient to handle lists of numbers and character strings, keywords, commands with optional clauses, and many kinds of variable-format constructions, such as algebraic expressions. ASSIST was developed for use in two large programs for the analysis of safety of radioactive waste disposal facilities, but it should prove useful for a wide variety of applications. (author)\n\nFORTRAN program for calculating liquid-phase and gas-phase thermal diffusion column coefficients\n\nInternational Nuclear Information System (INIS)\n\nRutherford, W.M.\n\n1980-01-01\n\nA computer program (COLCO) was developed for calculating thermal diffusion column coefficients from theory. The program, which is written in FORTRAN IV, can be used for both liquid-phase and gas-phase thermal diffusion columns. Column coefficients for the gas phase can be based on gas properties calculated from kinetic theory using tables of omega integrals or on tables of compiled physical properties as functions of temperature. Column coefficients for the liquid phase can be based on compiled physical property tables. Program listings, test data, sample output, and users manual are supplied for appendices\n\nComparison of PASCAL and FORTRAN for solving problems in the physical sciences\n\nScience.gov (United States)\n\nWatson, V. R.\n\n1981-01-01\n\nThe paper compares PASCAL and FORTRAN for problem solving in the physical sciences, due to requests NASA has received to make PASCAL available on the Numerical Aerodynamic Simulator (scheduled to be operational in 1986). PASCAL disadvantages include the lack of scientific utility procedures equivalent to the IBM scientific subroutine package or the IMSL package which are available in FORTRAN. Advantages include a well-organized, easy to read and maintain writing code, range checking to prevent errors, and a broad selection of data types. It is concluded that FORTRAN may be the better language, although ADA (patterned after PASCAL) may surpass FORTRAN due to its ability to add complex and vector math, and the specify the precision and range of variables.\n\nObjective Oriented Design of System Thermal Hydraulic Analysis Program and Verification of Feasibility\n\nInternational Nuclear Information System (INIS)\n\nChung, Bub Dong; Jeong, Jae Jun; Hwang, Moon Kyu\n\n2008-01-01\n\nThe system safety analysis code, such as RELAP5, TRAC, CATHARE etc. have been developed based on Fortran language during the past few decades. Refactoring of conventional codes has been also performed to improve code readability and maintenance. TRACE, RELAP5-3D and MARS codes are examples of these activities. The codes were redesigned to have modular structures utilizing Fortran 90 features. However the programming paradigm in software technology has been changed to use objects oriented programming (OOP), which is based on several techniques, including encapsulation, modularity, polymorphism, and inheritance. It was not commonly used in mainstream software application development until the early 1990s. Many modern programming languages now support OOP. Although the recent Fortran language also support the OOP, it is considered to have limited functions compared to the modern software features. In this work, objective oriented program for system safety analysis code has been tried utilizing modern C language feature. The advantage of OOP has been discussed after verification of design feasibility\n\nMixed-Language High-Performance Computing for Plasma Simulations\n\nDirectory of Open Access Journals (Sweden)\n\nQuanming Lu\n\n2003-01-01\n\nFull Text Available Java is receiving increasing attention as the most popular platform for distributed computing. However, programmers are still reluctant to embrace Java as a tool for writing scientific and engineering applications due to its still noticeable performance drawbacks compared with other programming languages such as Fortran or C. In this paper, we present a hybrid Java/Fortran implementation of a parallel particle-in-cell (PIC algorithm for plasma simulations. In our approach, the time-consuming components of this application are designed and implemented as Fortran subroutines, while less calculation-intensive components usually involved in building the user interface are written in Java. The two types of software modules have been glued together using the Java native interface (JNI. Our mixed-language PIC code was tested and its performance compared with pure Java and Fortran versions of the same algorithm on a Sun E6500 SMP system and a Linux cluster of Pentium~III machines.\n\nOptimization of Grillages Using Genetic Algorithms for Integrating Matlab and Fortran Environments\n\nDirectory of Open Access Journals (Sweden)\n\nDarius MaÄiÅ«nas\n\n2013-02-01\n\nFull Text Available The purpose of the paper is to present technology applied for the global optimization of grillage-type pile foundations (further grillages. The goal of optimization is to obtain the optimal layout of pile placement in the grillages. The problem can be categorized as a topology optimization problem. The objective function is comprised of maximum reactive force emerging in a pile. The reactive force is minimized during the procedure of optimization during which variables enclose the positions of piles beneath connecting beams. Reactive forces in all piles are computed utilizing an original algorithm implemented in the Fortran programming language. The algorithm is integrated into the MatLab environment where the optimization procedure is executed utilizing a genetic algorithm. The article also describes technology enabling the integration of MatLab and Fortran environments. The authors seek to evaluate the quality of a solution to the problem analyzing experimental results obtained applying the proposed technology.\n\nOptimization of Grillages Using Genetic Algorithms for Integrating Matlab and Fortran Environments\n\nDirectory of Open Access Journals (Sweden)\n\nDarius MaÄiÅ«nas\n\n2012-12-01\n\nFull Text Available The purpose of the paper is to present technology applied for the global optimization of grillage-type pile foundations (further grillages. The goal of optimization is to obtain the optimal layout of pile placement in the grillages. The problem can be categorized as a topology optimization problem. The objective function is comprised of maximum reactive force emerging in a pile. The reactive force is minimized during the procedure of optimization during which variables enclose the positions of piles beneath connecting beams. Reactive forces in all piles are computed utilizing an original algorithm implemented in the Fortran programming language. The algorithm is integrated into the MatLab environment where the optimization procedure is executed utilizing a genetic algorithm. The article also describes technology enabling the integration of MatLab and Fortran environments. The authors seek to evaluate the quality of a solution to the problem analyzing experimental results obtained applying the proposed technology.\n\nFar-field Lorenz-Mie scattering in an absorbing host medium: Theoretical formalism and FORTRAN program\n\nScience.gov (United States)\n\nMishchenko, Michael I.; Yang, Ping\n\n2018-01-01\n\nIn this paper we make practical use of the recently developed first-principles approach to electromagnetic scattering by particles immersed in an unbounded absorbing host medium. Specifically, we introduce an actual computational tool for the calculation of pertinent far-field optical observables in the context of the classical Lorenz-Mie theory. The paper summarizes the relevant theoretical formalism, explains various aspects of the corresponding numerical algorithm, specifies the input and output parameters of a FORTRAN program available at https://www.giss.nasa.gov/staff/mmishchenko/Lorenz-Mie.html, and tabulates benchmark results useful for testing purposes. This public-domain FORTRAN program enables on"
    }
}