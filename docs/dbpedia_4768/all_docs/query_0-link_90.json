{
    "id": "dbpedia_4768_0",
    "rank": 90,
    "data": {
        "url": "https://viblo.asia/p/programming-languages-milestones-an-overview-from-1960-present-part-1-yMnKMq2rK7P",
        "read_more_link": "",
        "language": "en",
        "title": "Programming languages' milestones: An overview from 1960 - present (Part 1)",
        "top_image": "https://viblo.asia/og-facebook-3.png",
        "meta_img": "https://viblo.asia/og-facebook-3.png",
        "images": [
            "https://viblo.asia/logo_full.svg",
            "https://viblo.asia/images/vi-flag-32x48.png",
            "https://viblo.asia/images/mm.png",
            "https://images.viblo.asia/3eb5c055-ef0b-48e3-877b-c62ab3a318d9.png",
            "https://images.viblo.asia/74336ca5-00ba-4863-b4e3-02db5dc50f58.png",
            "https://images.viblo.asia/3681b025-f583-4b81-83c4-aa368244f889.png",
            "https://images.viblo.asia/1d1538f1-18fc-467d-aa50-dd76ff6caa48.png",
            "https://images.viblo.asia/cda60dfc-47ba-4b7e-b6c2-72fb340dde60.png",
            "https://viblo.asia/images/viblo-code.png",
            "https://viblo.asia/images/viblo-ctf.png",
            "https://viblo.asia/images/viblo-learn.png",
            "https://viblo.asia/favicon.ico",
            "https://viblo.asia/images/viblo-code.png",
            "https://viblo.asia/images/viblo-ctf.png",
            "https://viblo.asia/images/viblo-cv.png",
            "https://viblo.asia/images/viblo-learn.png",
            "https://viblo.asia/images/viblo-partner.png",
            "https://viblo.asia/images/viblo-battle.png",
            "https://viblo.asia/images/viblo-interview.ico",
            "https://play.google.com/intl/en_us/badges/images/generic/en_badge_web_generic.png",
            "https://viblo.asia/_nuxt/img/app-store-badge.8c4986ee4828b47d16f5cd694ef065f2.svg",
            "https://viblo.asia/images/atom-editor.svg",
            "https://images.dmca.com/Badges/dmca-badge-w100-5x1-07.png?ID=41818fcd-5a60-4504-867a-38fde606354e",
            "https://viblo.asia/favicon-white-128.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "programming language",
            "abstraction",
            "history",
            "milestones",
            "Machine Language",
            "FORTRAN",
            "COBOL",
            "ALGOL",
            "PL/I"
        ],
        "tags": null,
        "authors": [
            "Do Ha Long",
            "viblo.asia",
            "do.ha.long"
        ],
        "publish_date": "2017-06-23T02:59:00+00:00",
        "summary": "",
        "meta_description": "Introduction We are living in a world where computers and electronic devices play a pivotal part of our life. No one can alter the fact that wherever we go, whatever we do in this modern life, it is...",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "Viblo",
        "canonical_link": "https://viblo.asia/p/programming-languages-milestones-an-overview-from-1960-present-part-1-yMnKMq2rK7P",
        "text": "Introduction\n\nWe are living in a world where computers and electronic devices play a pivotal part of our life. No one can alter the fact that wherever we go, whatever we do in this modern life, it is not hard to witness the appearance of them. Tiny handheld devices, sparkling traffic lights, even remotes we use regularly, etc. nowadays are the achievements of continuously developing information technology in many years. Back to twentieth century, one of the most remarkable technology events had been taken place, when the whole world was recovering from the wounds of the second World War, the first general-purpose computer became public with the name ENIAC (Electronic Numerical Intergrator and Computer). Although it was developed under wartime pressure, it has been of value not only in producing results but in pointing the way toward improvements for future designs (Brainerd and Sharpless, 1948) because general-purpose computers have the amazing property that a single piece of hardware can do any computation imaginable (Grant, Palmer and Smith, 2017). Before general-purpose computers were born, there had been special-purpose computers for arithmetic calculations, which had to be manually reconfigured to carry out different calculations such as Abacus – The earliest known device for calculation (Gujarat Education Department, n.d.).\n\nIn fact, to make computers and electronic devices as successful as today, the development of programming languages is the most important precondition. This part is going to be described briefly about several milestones during the great history of general-purpose programming languages and about a brief introduction of domain-specific languages.\n\nGeneral-purpose programming languages’ milestones\n\n1. From early twentieth century to 1960\n\nFor general-purpose programming development, it predates the development of computers. In the early 20th century, logicians created their own programming languages originally springing from the concept of a proof system (Grant, Palmer and Smith, 2017). To illustrate this spirit, λ-calculus – an officially abstract language of functions in 1932 designed and implemented by Frege, Church and Curry was born. The λ-calculus provides a simple semantics for computations. One of the clearest example for this point of view is treating every function “anonymously”. After λ-calculus released, there is no reliable material pointing out the first general-purpose programming language, yet the most worth-noting programming language at that time was FORTRAN in 1956 because it was the first programming language equipped with a complete compiler (Backus 1956). Before FORTRAN, almost all programs were done in machine language or assembly language (Wexelblat, 2014). At that time, programmers considered their works as a complicated and creative art that required human inventiveness to produce an efficient program, therefore, FORTRAN was born to solve these problems with the support of index registers, built-in floating point operations, a wide range of instruction sets and primitive input – output arrangements. Since 1956, FORTRAN was developed with lots of variants, namely: FORTRAN II (1958), FORTRAN III (1958), FORTRAN IV (1962), FORTRAN 66 (1966), FORTRAN 77 (1977), Fortran 90 (1991, since this version, FORTRAN was renamed to be in lower-case form), Fortran 95 (1995), Fortran 2003 (2003), Fortran 2008 (2008). However, 2008 was not the last destination for the development of Fortran. According to Intel, Fortran 2015 will be released on July 2018 with up-to-date features, most of them extends the C interoperability features that first appeared in Fortran 2003. Several following years after the release of Fortran, in 1958, a miraculous product that was inspired and influenced by this programming language had been public – ALGOL 58 (Wexelblat, 2014). Basically, ALGOL 58 was developed by a father of Fortran – John Backus with the specific Backus normal form method of describing programming languages. Later, it was revised and expanded by Peter Naur for ALGOL 60, and at Donald Knuth's suggestion renamed Backus–Naur form (Knuth, 1964). Since ALGOL 60’s release, many other general-purpose programming languages were published and followed its spirit and paradigm such as Pascal, C (although C differs from most of ALGOL-like languages in some significant ways), etc. (Mitchell, 2003). As the code snippet illustrated, the most distinctive feature that differed ALGOL60 and Fortran was block-oriented control structures (i.e.: procedure, comment, begin, end) and variable scoping. Last but not least, during this period, the use of computers for business applications began. “Special computers were developed for this purpose, along with special languages. The first successful high-level language for business was COBOL” (Sebesta, 2012). This general-purpose programming language was designed for business applications programming, therefore, its domain primarily applied in business, finance, and administrative systems for companies and governments. According to Mitchell, COBOL is still widely used in legacy applications deployed on mainframe computers, such as large-scale batch and transaction processing jobs. Actually, most programming in COBOL is now purely to maintain existing applications (2006). According to Yatsko and Suslow, the 1950s – 1960s are known as a period of exploiting machine power (2015). Never before has humanity seen a such powerful and innovative revolution of programming languages. Among these brilliant programming languages, as mentioned above, three first and most significant general-purpose programming languages that affect mostly to later generations of languages are FORTRAN, ALGOL and COBOL. In spite of the fact that, each of them was designed to be used in a particular business domain, they were still considered general-purpose languages. A scientific application can still be written in COBOL or a business application with FORTRAN (Dearle, 2015).\n\n2. From 1960 to 1970\n\nAccording to Wegner, the period from 1960 to 1970 was a period of elaboration of programming languages developed in the 1950’s and of analysis for the purpose of constructing models and theories of programming languages (1976). Among all programming languages that were released during this time (such as PL/I, Simula 67, ALGOL 68 and Snobol 4), PL/I was the most remarkable programming language. Discussing about PL/I, Wegner added: “An attempt to combine the good features of FORTRAN, ALGOL, COBOL and other programming languages created in 1950’s”. In fact, Pugh, Johnson and Palmer have pointed out some major goals for PL/I at that time:\n\nCompetitiveness with COBOL's record handling and report writing capabilities was needed.\n\nThe \"scope of usefulness\" of the language grew to include system programming and event-driven programming.\n\nCompetitiveness with FORTRAN in performance of compiled code.\n\nBe extensible for new hardware and application areas (However, this goal was not achieved later then).\n\nImprove the productivity and time scales of the programming process, transferring effort from the programmer to the compiler.\n\nBe machine-independent and operate effectively across the main hardware and operating system ranges. (To be continued...)\n\nReferences"
    }
}