{
    "id": "dbpedia_4768_2",
    "rank": 71,
    "data": {
        "url": "https://www.slideshare.net/slideshow/mind-your-language-57720027/57720027",
        "read_more_link": "",
        "language": "en",
        "title": "Mind Your Language",
        "top_image": "https://cdn.slidesharecdn.com/ss_thumbnails/mindyourlanguage-160201065008-thumbnail.jpg?width=640&height=640&fit=bounds",
        "meta_img": "https://cdn.slidesharecdn.com/ss_thumbnails/mindyourlanguage-160201065008-thumbnail.jpg?width=640&height=640&fit=bounds",
        "images": [
            "https://public.slidesharecdn.com/images/next/svg/logo/slideshare-scribd-company.svg?w=128&q=75 1x, https://public.slidesharecdn.com/images/next/svg/logo/slideshare-scribd-company.svg?w=256&q=75 2x",
            "https://cdn.slidesharecdn.com/profile-photo-Kevlin-48x48.jpg?cb=1719160777",
            "https://image.slidesharecdn.com/mindyourlanguage-160201065008/85/Mind-Your-Language-1-320.jpg 320w, https://image.slidesharecdn.com/mindyourlanguage-160201065008/85/Mind-Your-Language-1-638.jpg 638w, https://image.slidesharecdn.com/mindyourlanguage-160201065008/75/Mind-Your-Language-1-2048.jpg 2048w",
            "https://image.slidesharecdn.com/mindyourlanguage-160201065008/85/Mind-Your-Language-2-320.jpg 320w, https://image.slidesharecdn.com/mindyourlanguage-160201065008/85/Mind-Your-Language-2-638.jpg 638w, https://image.slidesharecdn.com/mindyourlanguage-160201065008/75/Mind-Your-Language-2-2048.jpg 2048w",
            "https://image.slidesharecdn.com/mindyourlanguage-160201065008/85/Mind-Your-Language-3-320.jpg 320w, https://image.slidesharecdn.com/mindyourlanguage-160201065008/85/Mind-Your-Language-3-638.jpg 638w, https://image.slidesharecdn.com/mindyourlanguage-160201065008/75/Mind-Your-Language-3-2048.jpg 2048w"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2016-02-01T06:50:08+00:00",
        "summary": "",
        "meta_description": "Mind Your Language - Download as a PDF or view online for free",
        "meta_lang": "en",
        "meta_favicon": "https://public.slidesharecdn.com/_next/static/media/favicon.7bc3d920.ico",
        "meta_site_name": "SlideShare",
        "canonical_link": "https://www.slideshare.net/slideshow/mind-your-language-57720027/57720027",
        "text": "1. 28 APPLICATION DEVELOPMENT ADVISOR q www.appdevadvisor.com D EBATES on programming languages are always sure to inspire more heat than light. A previous article looked at a number of languages quantitatively as opposed to qualitatively, concluding that once a language has made it into the mainstream, it tends to be quite dif- ficult to kill-off quickly or completely, and that the industry is generally multilingual.1 As an industry it would be fair to describe software development as being strongly fashion-led. As with fashion, there is the per- ception that whatever is at the shows and in the magazines is what everyone is doing. As with fashion this is not the case: people still wear their old clothes and get on with their lives. The call to “wake up and smell the JavaBeans”2 because Java is the answer, everyone is doing it, and C++ and all other languages are in free fall is about as far from reality as the view that Java is an Internet language for a minority of pro- grammers. From the other corner of the debate, the fact that a language may be better (whatever that means) than another language has never stood in the way of it being unsuccessful in the market place. The ele- gant Eiffel is a classic example of this; the mar- ket is a harsh antidote for idealism.The truth is always a subtler blend of opposite views, and tends to have less regard for fashion, logic or conservatism. Silent majority It is easy to fall into a polarised view based on one’s work environment.There are many COBOL shops where the idea of GUIs and curly bracket languages seem distant, faddish, and irrelevant; there are vibrant ecom- merce companies steeped in XML, Java and Perl to the degree that there is almost denial there has ever been another purpose for software; there are Microsoft-only sites where the idea that other viable operating systems exist, and are measurably more reliable, is at best hearsay; there are places in academia where there is still a strong belief that formal methods are viable con- tenders for the mainstream; and so on. The message is that software development is more multicultural, in this respect, than many individuals or consultancy groups would like to admit—it is difficult to take a position of extreme moderation and be heard. For many programming languages the con- cept of the silent majority applies.There are many languages that are definitely not fash- ionable but are still quite widely used, away from the glare of publicity. They are used in the context of continued development of exist- ing systems—euphemistically called main- tenance by many, an unfortunate and inappropriate term that software borrowed from the physical engineering disciplines— and, perhaps surprisingly, for the develop- ment of new systems. With the year 2000 boundary condition out of the way, it is worth taking stock of some of the better known. Fortran Fortran started life to prove a point: a compiled language could produce machine code with efficiency close to that of hand- crafted assembler. John Backus led his team at IBM in this endeavour between 1954 and 1957. He freely admits that they made the syntax up as they went along, preferring to focus on a close match between the language and the features of the underlying IBM 704 on which it was originally developed. This certainly explains something of the language’s syntax and its frequent lack of consistency. Although it has long since outgrown its original acronym (FORmualTRANslation because, at the time, its syntax had a vague resemblance to mathematical notation) its efficiency and ability to be first to market for the numerate disciplines ensured that it would win out of the more elegant ALGOL 58 and ALGOL 60. Fortran has evolved radically through a number of standards and extensions. Modern Fortran is radically different to the FOR- TRAN of the early 1960s (and not simply because Fortran 90 sanctioned the lower case spelling of the name). Programming using exclusively modern Fortran features leads to Enterprise Development Solutions Now that the year 2000 crisis has subsided, Kevlin Henney finds how legacy languages will fare in the future, and charts their past development MindYour Language\n\n2. differences comparable to the difference between Java and classic C. It was once said in the scientific pro- gramming community that whatever language they were using in the year 2000 it would be called Fortran. It would appear that this prophecy has been fulfilled. Fortran is still taught on science and engineering courses around the world, and is used extensively with- in these communities. Although Fortran has enjoyed popularity in commercial pro- gramming domains, it has been largely dis- placed leading to the mistaken perception by many developers in the industry that it has completely disappeared. The greatest threats to Fortran’s position in its tradi- tional market have come from C, C++ and tools such as Mathematica. COBOL When people talk of legacy systems, COBOL is without a doubt the language that most often springs to mind. Along with Fortran it is the language that one can most often expect to find in the history of programmers over the age of 30. It is not simply a mat- ter of history, though. Y2K raised many peo- ple’s awareness of how much COBOL was out there. Although distinctly unfashionable, COBOL code globally constitutes the most code in any single language. Estimates vary, but in terms of lines of code we are talking international telephone numbers. What we now know as COBOL started life as an interim report (the final one was never completed) resulting from a user push for a business-oriented language under the auspices of the US Department of Defense and the newly formed Conference on Data Systems Languages (CODASYL) committee. Because of the perceived urgency, the interim report was published as a stop- gap measure in 1960 until the ‘real’ COBOL could be completed. The final report never happened. Because of the vacuum for suitable busi- ness languages, COBOL rapidly took hold of this niche in the 1960s. Once there, it proved difficult to displace regardless of critique of its elegance, design, and other attributes—“sticks and stones...”. Only with significant changes in development plat- form and software architecture has COBOL’s dominance been challenged—PCs, client serv- er, GUIs, object-orientation and theWeb have all threatened it. However, in these cir- cumstances COBOL has, through propri- etary extensions, been extended to cope. Although these have not led to anywhere near the same market presence as the COBOL mainframe association, they are still sig- nificant. Through such adaptive extensions and a splintering of mainframe dialects, there are many COBOLs out there, and not simply the ones defined through ANSI standards. What is COBOL’s future as the Y2K teams wind down? Although some com- panies have chosen to redevelop their sys- tems to a new architecture and to a different business model, there is less incentive to throw it out of the many environments where errant code has been fixed. The language is still taught on many computing courses, and has refused to be displaced by more transient 4GLs, which have them- selves caused upgrade problems. While the demand for COBOL may drop a little, it is unlikely to do so drastically. PL/1 PL/1 (Programming Language 1) was orig- inally touted as the last programming lan- guage. As is often the case with such ambitions, it certainly wasn’t, finding itself in the company of thousands of other lan- guages during the 1970s inflationary peri- od of language growth. It was conceived in the mid-1960s as a com- plete general purpose programming lan- guage, equally suited to scientific, business, and systems programming. As such it used the ALGOL, FORTRAN, and COBOL of its times as starting points. A further criti- cism often levelled at it was that because it was many languages rather than one, it all too easily allowed developers to program in their original language’s idioms. It has been said that one can program FORTRAN in any language, and PL/1 certainly enabled this to happen in a more complete sense than most. PL/1 was developed by IBM. Originally named NPL (New Programming Language) it was further developed at the company’s Hursley labs in the UK, where it was felt that the name might cause confusion with the National Physical Laboratory. SIMULA killer The only other language at the time with sim- ilar ambitions was Algol 68, which became lost in complexity and committees. Usable implementations of Algol 68 only began appearing in the mid-1970s, long after the original definition. It was competing with PL/1, whose implementations were improv- ing after a shaky start in the 1960s.The back- ing of IBM and an ANSI/ECMA standard in 1976 saw to it that in spite of its signif- icant complexity, PL/1 stayed afloat while Algol 68 persisted only in memory and language design influence. PL/1’s com- plexity led to the formation of subsets, including PL/C and the official 1981 ANSI standard PL/1 subset. PL/1 was always poised for the big time, to the point that it was used as the second language in the classic Elements of Programming Style (the other language in that being FORTRAN 66).3 Its touted posi- tion as the only programming language one would ever need was responsible, in Norway, for preventing major public fund- ing of SIMULA, the first object-oriented lan- guage. However, with the possible exception of ALGOL, PL/1 did not displace those lan- guages that it was intended to supersede. It has been used typically for large systems, and never fully broke away from living on main- frames and minis. IBM sites were the most likely to use it, and so its original status as a vendor-created language was also never fully shaken off. Its use has certainly declined in favour of either newer or other old and established languages, such as FORTRAN and COBOL. C C is the progenitor of the curly bracket family, which includes C++, Java, scripting languages such as Perl, and interface definition languages such as OMG IDL. It is descend- ed from ALGOL 60, via the BCPL rather than the Pascal lineage. Based on his expe- rience of the Multics project, KenThompson at AT&T experimented with a number of languages, including BCPL, for developing the kernel of what was to become Unix. Dennis Ritchie developed C in 1972 as a high-level systems programming language for this purpose, rather than for the gener- al purpose role in which it has since found favour. The fate of C and Unix were intertwined in the early 1980s, but the uptake of C as a general systems programming language spread it far beyond the Unix environ- ment, displacing assembler and other high- level languages as the standard for systems programming on many systems.The 1990s saw C become accepted as general purpose programming language, and it became a typ- ical sight on developer CVs, either as the lan- guage of choice or as a common second language. C is a small language, with only a handful of keywords and concepts. However, some of these concepts and syn- tax rules are tricky for the newcomer (and even the experienced developer, as wit- nessed by the International Obfuscated C Coding Contest). This has often made it a difficult language to move to for develop- ers experienced in languages based on a fundamentally different mindset, such as COBOL. The original de facto standard, the “White Book”, came out in 1978.4 This is commonly known as K&R C or Classic C. ANSI JANUARY–FEBRUARY 2000 29 Enterprise Development Solutions"
    }
}