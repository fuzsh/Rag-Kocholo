{
    "id": "dbpedia_4768_2",
    "rank": 31,
    "data": {
        "url": "https://medium.com/%40romaninsh/from-fortran-to-modern-programming-languages-evolution-of-concepts-and-paradigms-part-3-cf59c3a04a6b",
        "read_more_link": "",
        "language": "en",
        "title": "From Fortran to modern programming languages — evolution of concepts and paradigms (Part 3)",
        "top_image": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_img": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/0*t5OLtrm8aye_5YN1.jpg",
            "https://miro.medium.com/v2/resize:fill:144:144/0*t5OLtrm8aye_5YN1.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Romans Malinovskis",
            "medium.com"
        ],
        "publish_date": "2023-08-29T23:13:18.899000+00:00",
        "summary": "",
        "meta_description": "(Part 2: Control Structures https://medium.com/@romaninsh/from-fortran-to-modern-programming-languages-evolution-of-concepts-and-paradigms-part-2-8c304fcc67e7) Fortran was the first high-level…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@romaninsh/from-fortran-to-modern-programming-languages-evolution-of-concepts-and-paradigms-part-3-cf59c3a04a6b",
        "text": "Romans Malinovskis\n\n·\n\nFollow\n\n12 min read\n\n·\n\nAug 29, 2023\n\n--\n\nFunctions and Subroutines\n\n(Part 2: Control Structures https://medium.com/@romaninsh/from-fortran-to-modern-programming-languages-evolution-of-concepts-and-paradigms-part-2-8c304fcc67e7)\n\nFortran was the first high-level programming language to introduce the concepts of functions and subroutines as we understand them today. While Assembly languages had the concept of “subroutines” or “procedures” (sequences of instructions that could be jumped to from multiple points in the code and then return to the calling point), they were low-level and lacked the abstraction and ease-of-use that Fortran’s functions and subroutines provided.\n\nFunctions: In Fortran, a function is used when you want to return a value. Here’s a simple example of a function that calculates the square of a number:\n\nFUNCTION square(x)\n\nREAL :: x, square\n\nsquare = x * x\n\nEND FUNCTION square\n\nSubroutines: Subroutines are similar to functions but don’t return a value. They are used for procedures that perform an action rather than compute a result to be returned.\n\nSUBROUTINE print_hello()\n\nPRINT *, 'Hello, World!'\n\nEND SUBROUTINE print_hello\n\nBoth functions and subroutines could accept parameters, making them versatile tools for creating more modular and maintainable code.\n\nALGOL 60\n\nAfter Fortran, the next significant language that brought about major refinements to the concept of functions and subroutines was ALGOL 60.\n\nALGOL 60 and Its Innovations:\n\nBlock Structure: ALGOL 60 introduced the idea of lexically scoped block structures. This allowed for variables (and functions) to have limited scope, which was a major advancement in structuring code and preventing accidental variable modifications or name clashes.\n\nbegin\n\ninteger x;\n\nx := 5;\n\nbegin\n\ninteger x;\n\nx := 10;\n\nend;\n\nprint(x); { This will print 5 }\n\nend;\n\nValue and Name Parameters: ALGOL 60 introduced the distinction between passing parameters by value (where the function/subroutine receives a copy) and by name (where it operates on the original). This was an early precursor to the more common pass-by-value and pass-by-reference distinctions in later languages.\n\nprocedure swap(value a, name b);\n\ninteger a, b, temp;\n\nbegin\n\ntemp := a;\n\na := b;\n\nb := temp;\n\nend\n\nRecursive Procedures: ALGOL 60 was one of the first languages to support recursion natively, allowing functions and procedures to call themselves. This opened the door to a wide range of algorithms and programming techniques.\n\nprocedure factorial(n);\n\nvalue n; integer n;\n\nbegin\n\nif n <= 1 then\n\nfactorial := 1\n\nelse\n\nfactorial := n * factorial(n - 1)\n\nend;\n\nLocal Procedures: ALGOL 60 allowed for procedures to be defined inside other procedures. These local procedures could access the variables of the enclosing procedure.\n\nprocedure outer(x);\n\ninteger x;\n\nbegin\n\nprocedure inner(y);\n\ninteger y;\n\nbegin\n\nprint(x + y);\n\nend;\n\ninner(5);\n\nend;\n\nALGOL 60’s refinements set the stage for many of the features we see in modern languages. The idea of block structure became fundamental. The concept of recursion, while mathematically known, became a practical tool for programmers thanks to ALGOL 60.\n\nPascal\n\nAfter ALGOL 60, the next language that brought significant innovations to the concept of functions and subroutines was Pascal. Designed by Niklaus Wirth in the late 1960s and early 1970s, Pascal further advanced structured programming concepts and introduced several features that impacted how functions and procedures were used:\n\nStrong Typing: Pascal emphasized strong typing, which extended to function signatures. This meant that functions and procedures had explicitly defined input and output types, leading to safer and more predictable code.\n\nfunction add(a, b: integer): integer;\n\nbegin\n\nadd := a + b;\n\nend;\n\nProcedures vs. Functions: Pascal made a clear distinction between procedures (which did not return a value) and functions (which did). This explicit distinction improved code readability.\n\nNested Functions and Procedures: Like ALGOL 60, Pascal supported nested functions and procedures, but with more rigorous scoping rules. This allowed for better encapsulation and modular code.\n\nPass-by-Value and Pass-by-Reference: Pascal introduced the var keyword to clearly indicate when a parameter was being passed by reference (and could be modified by the procedure) versus being passed by value (where the procedure received a copy).\n\nprocedure swap(var a, b: integer);\n\nvar\n\ntemp: integer;\n\nbegin\n\ntemp := a;\n\na := b;\n\nb := temp;\n\nend;\n\nDefault Parameters and Overloading: Although these features became more prominent in Object Pascal (like in Delphi), the groundwork was laid in standard Pascal. Default parameters allowed functions and procedures to be called with fewer arguments than they declared, while overloading allowed multiple functions or procedures with the same name but different parameters.\n\nC\n\nAfter Pascal, the next language that brought significant changes to the concept of functions and subroutines was C. Though it was developed roughly around the same time as Pascal, C and its descendants (like C++, C#, and Objective-C) took a different direction and introduced several concepts that have become foundational in modern software development.\n\nFunction Pointers: C introduced the idea of pointers to functions, allowing functions to be passed as arguments, stored in arrays, and more. This laid the groundwork for callback mechanisms and later influenced object-oriented and functional programming paradigms.\n\nint add(int x, int y) {\n\nreturn x + y;\n\n}\n\nint operate(int x, int y, int (*operation)(int, int)) {\n\nreturn operation(x, y);\n\n}\n\nint main() {\n\nprintf(\"%d\", operate(5, 3, add)); // Outputs 8\n\n}\n\nHeader Files and Separate Compilation: While not strictly about functions and subroutines, the way C handles external function declarations with header files (.h) and source files (.c) is significant. It allows for modular development and separate compilation.\n\nVariadic Functions: C introduced functions that could take a variable number of arguments. The printf function is a classic example.\n\nint printf(const char *format, ...);\n\nNo Nested Functions: Unlike Pascal and ALGOL, C does not support nested functions. All functions have file scope.\n\nEverything is a function: In C all the code must reside in some kind of function and the first function to be executed is called main.\n\nWhile C streamlined many concepts, its true power and significance come from the flexibility it offers, especially through pointers and direct memory manipulation. This made it both potent and risky, but with the right practices, it became the backbone of systems programming, influencing a whole lineage of languages that followed.\n\nSmalltalk\n\nAfter C, the language that brought significant innovations to functions and subroutines was Smalltalk. Developed in the 1970s, Smalltalk was one of the first fully object-oriented languages, and its approach to functions (referred to as “methods” in the context of object-oriented programming) was groundbreaking.\n\nSmalltalk and Its Innovations:\n\nMessages Instead of Function Calls: In Smalltalk, you don’t “call a method on an object.” Instead, you “send a message to an object.” The object then decides how to respond to that message, typically by invoking a method. This paradigm shift was foundational to the way object-oriented programming evolved.\n\nresult := anObject aMessage.\n\nPolymorphism: Due to the message-passing paradigm, different objects could respond to the same message in different ways. This is polymorphism, where a single message can have different meanings depending on the object receiving it.\n\nEverything is an Object: In Smalltalk, everything, including numbers and functions (methods), is an object. This consistency made the language incredibly expressive. For example, to increment a number by one and then multiply it, you’d send messages to a number just like you would with any other object:\n\nresult := 3 + 1. \"Sends the message '+ 1' to the object 3\"\n\nBlocks and Closures: Smalltalk introduced the concept of “blocks” which are essentially anonymous functions or lambdas. Blocks can capture variables from their surrounding context, creating closures.\n\naBlock := [ :x | x + 1 ].\n\nresult := aBlock value: 5. \"result will be 6\"\n\nDynamic Typing and Late Binding: Unlike many languages of its time, Smalltalk uses dynamic typing. Methods are bound at runtime, not compile-time. This flexibility allows for powerful programming techniques but also requires more runtime checks.\n\nIntrospection and Reflection: Smalltalk objects can inspect and modify their structure and behavior at runtime. This includes changing their class, examining their methods, or even altering their methods.\n\nNo Distinction Between Functions and Procedures: In Smalltalk, there’s no distinction as in Pascal between functions (which return values) and procedures (which don’t). Instead, every method in Smalltalk returns a value. If a return value isn’t specified, a method returns self (the receiver of the message).\n\nLisp\n\nAfter Smalltalk, Lisp (and its various dialects, especially Scheme and Common Lisp) brought significant innovations and perspectives to the concept of functions and subroutines. While Lisp predates Smalltalk (the first version was created in the late 1950s), its evolution throughout the 1970s and 1980s, especially with the introduction of Scheme, saw the crystallization and popularization of many of its groundbreaking concepts.\n\nLisp and Its Innovations:\n\nFirst-Class Functions: In Lisp, functions are first-class citizens, meaning they can be passed as arguments, returned as values, and assigned to variables. This wasn’t entirely new, but Lisp took it to the core of its design.\n\n(defun apply-twice (f x)\n\n(funcall f (funcall f x)))\n\nLambda Functions: Anonymous functions can be defined on-the-fly using the lambda keyword. These can be used wherever a function is expected.\n\n(mapcar (lambda (x) (* x x)) '(1 2 3 4)) ; Squares each element in the list\n\nClosures: Lisp supports closures, where functions can “capture” variables from their enclosing environment.\n\n(defun make-adder (x) (lambda (y) (+ x y)))\n\nMacros: One of Lisp’s most powerful features. Macros allow for code that generates code, enabling powerful metaprogramming capabilities. This leads to the famous saying, “Code is data, and data is code” in the Lisp community.\n\n(defmacro when (cond &rest body) `(if ,cond (progn ,@body)))\n\nTail Recursion: Scheme, a dialect of Lisp, emphasized tail recursion, allowing for efficient recursive algorithms by reusing the current function’s call frame for the next call, given it’s in the “tail” position.\n\nContinuations: Especially in Scheme, the concept of first-class continuations was introduced. This is a powerful control structure that allows the capture of the current state of the computation, which can be resumed later. (similar to yield?)\n\nDynamic Scoping: Early Lisp used dynamic scoping, where the value of a variable was determined by the calling function, not the defining function. Later dialects, like Scheme, emphasized lexical scoping (similar to most modern languages), but dynamic scoping was an interesting and influential aspect of early Lisp.\n\nMulti-Methods: In Common Lisp, functions (or methods) aren’t tied to a specific object or class. With the Object System (CLOS), methods can be defined on any combination of arguments, not just the first one. This allows for more generalized polymorphism.\n\nLisp’s approach to functions and its overall philosophy of homoiconicity (where the code has the same structure as its data) has been deeply influential, inspiring features in numerous later languages, from JavaScript’s first-class functions to Python’s lambda functions and macros in various languages. Its emphasis on recursion, symbolic computation, and metaprogramming has left a lasting legacy on the field of computer science.\n\nC++\n\nIn the realm of imperative languages, after Lisp, the next major language that brought significant changes to the concept of functions and subroutines was C++.\n\nMember Functions: With the introduction of classes in C++, functions could now be associated directly with a specific class as member functions (often referred to as “methods” in other OOP languages). This was foundational to the object-oriented paradigm in C++.\n\nclass Rectangle {\n\npublic:\n\nvoid setValues(int w, int h) {\n\nwidth = w;\n\nheight = h;\n\n}\n\nprivate:\n\nint width, height;\n\n};\n\nConstructors and Destructors: Special member functions that are called when an object is created and destroyed, respectively.\n\nclass Rectangle {\n\npublic:\n\nRectangle(int w, int h) : width(w), height(h) {}\n\n~Rectangle() {}\n\nprivate:\n\nint width, height;\n\n};\n\nOverloading: C++ introduced the ability to define multiple functions with the same name but different parameters, known as function overloading.\n\nvoid print(int i);\n\nvoid print(double d);\n\nVirtual Functions: These enable polymorphism, where a base class pointer can point to objects of any of its derived classes, and the appropriate function is called based on the actual type of the object.\n\nclass Base {\n\npublic:\n\nvirtual void show() { cout << \"Base\\n\"; }\n\n};\n\nclass Derived : public Base {\n\npublic:\n\nvoid show() { cout << \"Derived\\n\"; }\n\n};\n\nTemplates: C++ introduced the idea of generic programming with templates. You can write a single function (or class) that can operate on multiple data types.\n\ntemplate <typename T> T add(T a, T b) {\n\nreturn a + b;\n\n}\n\nDefault Arguments: Functions in C++ can have default arguments, allowing them to be called with fewer arguments than they declare.\n\nvoid display(int a = 0, int b = 0) {\n\ncout << a << \" \" << b << endl;\n\n}\n\nC++ significantly expanded the concept of functions and subroutines by integrating them into its object-oriented and generic programming features. Its influence is evident in many subsequent languages, especially those that sought to combine procedural, object-oriented, and generic programming paradigms. Object-oriented programming dominated mainstream languages until recently, where languages like Swift, Go and Rust have proposed alternative means of abstraction.\n\nPost-C++\n\nLambda Expressions and Anonymous Functions: While these concepts have roots in languages like Lisp and Scheme, they gained widespread attention in mainstream languages like Java (from Java 8 onwards) and C#.\n\nlist.forEach(item -> System.out.println(item));\n\nClosures: Languages like JavaScript popularized closures, where functions can “capture” variables from their enclosing environment.\n\nfunction outer() {\n\nlet x = 10;\n\nfunction inner() {\n\nconsole.log(x);\n\n}\n\nreturn inner;\n\n}\n\nExtension Methods: C# introduced extension methods, allowing developers to “add” methods to existing types without modifying them.\n\npublic static class StringExtensions {\n\npublic static bool IsNumeric(this string s) {\n\n// Implementation here\n\n}\n\n}\n\nPromises and Futures: Asynchronous programming models in languages like JavaScript and Python introduced promises and futures for more manageable asynchronous code.\n\nfetch(url)\n\n.then(response => response.json())\n\n.then(data => console.log(data));\n\nPattern Matching in Function Parameters: Languages like Haskell, Scala, and more recently Rust and Python, have embraced pattern matching, allowing functions to define multiple “versions” based on the shape and content of their inputs.\n\ndef factorial(n: Int): Int = n match {\n\ncase 0 => 1\n\ncase _ => n * factorial(n-1)\n\n}\n\nVariadic Generics: Languages like TypeScript (though primarily for type-checking) introduced the idea of variadic generics, offering more flexibility in function and type definitions.\n\nfunction concat<T extends string[]>(...strings: T): string {\n\nreturn strings.join(\"\");\n\n}\n\nCoroutines: Languages like Kotlin and Python have emphasized coroutines, allowing functions to be paused and resumed, which is useful for asynchronous programming without deep nesting or callback hell.\n\nsuspend fun fetchData(): DataType {\n\n// Implementation here\n\n}\n\nFunction Type Inference: Modern languages like TypeScript, Rust, and Swift have strong type inference mechanisms, allowing functions to have clearly defined types without always requiring explicit annotations.\n\nPipeline Operators: Some languages, like Elixir and more recently proposed in JavaScript, introduced the concept of a pipeline operator to streamline function chaining.\n\n\"Elixir\" |> String.downcase() |> String.reverse()\n\nTail Call Optimization: While this concept has been around since the Lisp days, languages like Elixir and some modern implementations of older languages have emphasized tail call optimization to allow recursive functions to run with constant stack space.\n\nRust\n\nRust, known for its focus on memory safety without sacrificing performance, introduced several features and paradigms in the realm of functions and subroutines:\n\nOwnership and Borrowing: At the heart of Rust’s memory safety guarantees are the concepts of ownership, borrowing, and lifetimes. They dictate how functions can use and share data.\n\nfn takes_ownership(some_string: String) { ... }\n\nfn borrows_immutable(s: &String) { ... }\n\nfn borrows_mutable(s: &mut String) { ... }\n\nPattern Matching in Function Parameters: Similar to some functional languages, Rust uses pattern matching extensively, including in function parameters.\n\nfn match_example(x: Option<i32>) {\n\nmatch x {\n\nSome(val) => println!(\"Value is: {}\", val),\n\nNone => println!(\"No value\"),\n\n}\n\n}\n\nAssociated Functions and Methods: In Rust’s object-oriented features, you can define functions associated with a type (similar to static methods in other languages) and methods that take a reference to self as their first parameter. (Note — Rust does not have standard implementation for Objects and Classes and instead uses structs and traits)\n\nstruct Circle {\n\nradius: f64,\n\n}\n\nimpl Circle {\n\n// associated function\n\nfn new(radius: f64) -> Circle {\n\nCircle { radius }\n\n}\n\n// method\n\nfn area(&self) -> f64 {\n\n3.14 * self.radius * self.radius\n\n}\n\n}\n\nClosures with Environment Capture: Rust supports closures (anonymous functions) that can capture their environment, with type inference and a concise syntax.\n\nlet add_one = |x| x + 1;\n\nTrait-Based Function Overloading: Rust doesn’t support traditional function overloading, but it does allow function overloading using traits and its impl mechanism.\n\nConcurrency without Data Races: Rust introduces a set of rules and checks that ensure thread safety, preventing data races at compile time. The language’s ownership system is crucial to this.\n\nDiverging Functions: Rust has functions that do not return, indicated by the ! return type. These are called diverging functions.\n\nfn panic_example() -> ! {\n\npanic!(\"This function never returns!\");\n\n}\n\nHigher Order Functions: Rust’s standard library, especially the Iterator trait, offers a rich set of higher-order functions like map, filter, and fold.\n\nlet numbers = vec![1, 2, 3, 4, 5];\n\nlet doubled: Vec<_> = numbers.iter()\n\n.map(|&x| x * 2)\n\n.filter(|&x| x > 5)\n\n.collect();\n\nprintln!(\"{:?}\", doubled); // Outputs: [6, 8, 10]\n\nReturn Type Polymorphism: While Rust doesn’t support traditional generics in the same way as languages like C++ or Java, it does allow for some forms of return type polymorphism using traits and associated types.\n\ntrait ConvertibleFrom<T> {\n\nfn from(T) -> Self;\n\n}\n\nimpl ConvertibleFrom<&str> for i32 {\n\nfn from(s: &str) -> Self {\n\ns.parse().unwrap()\n\n}\n\n}\n\nimpl ConvertibleFrom<&str> for f64 {\n\nfn from(s: &str) -> Self {\n\ns.parse().unwrap()\n\n}\n\n}\n\nfn convert<T, U: ConvertibleFrom<T>>(input: T) -> U {\n\nU::from(input)\n\n}\n\n// Usage:\n\nlet integer: i32 = convert(\"42\");\n\nlet float: f64 = convert(\"42.5\");\n\nMacros: While not functions in the traditional sense, Rust’s macro system deserves mention. They allow for metaprogramming and code generation in ways that functions can’t\n\nmacro_rules! say_hello {\n\n() => {\n\nprintln!(\"Hello, World!\");\n\n};\n\n($name:expr) => {\n\nprintln!(\"Hello, {}!\", $name);\n\n};\n\n}\n\n// Usage:\n\nsay_hello!(); // Outputs: Hello, World!\n\nsay_hello!(\"Alice\"); // Outputs: Hello, Alice!\n\nRust’s innovations in the realm of functions and subroutines largely revolve around its ownership and borrowing system, which ensures memory safety and data race-free concurrency.\n\nPart 4: https://medium.com/@romaninsh/from-fortran-to-modern-programming-languages-evolution-of-concepts-and-paradigms-part-3-b9eb11caee2d"
    }
}