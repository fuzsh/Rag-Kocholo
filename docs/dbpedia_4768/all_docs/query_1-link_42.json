{
    "id": "dbpedia_4768_1",
    "rank": 42,
    "data": {
        "url": "https://heerdebeer.org/ALGOL/notation.html",
        "read_more_link": "",
        "language": "en",
        "title": "Heer de Beer.orgâNotation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://heerdebeer.org/assets/img/heerdebeer.svg",
            "https://heerdebeer.org/ALGOL/images/FORTRAN1954a3NUMBER.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL58aNUMBER.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL58a12EXPRESSIONPART.png",
            "https://heerdebeer.org/ALGOL/images/FORTRAN1954a6EXPRESSIONPART.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL58a14IF.png",
            "https://heerdebeer.org/ALGOL/images/FORTRAN1954a14IF.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL58a12COMPOUNDSTATEMENT.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL58a14PROCEDUREDECLARATION.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL60-128-129-procedure.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL60-124-procedurestatement.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL60-114-expression.png",
            "https://heerdebeer.org/ALGOL/images/ALGOL60-130-131-example1.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "FORTRAN",
            "IAL",
            "ALGOL 60"
        ],
        "tags": null,
        "authors": [
            "Huub de Beer"
        ],
        "publish_date": "2006-08-14T00:00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Notation\n\nFrom IAL to ALGOL 60\n\nHuub de Beer\n\nWhy notation matters?\n\nCommunication between the members of the various working groups on aspects of the new algorithmic language was important because the ALGOL effort was an international effort consisting of different people and groups. A clear and unambiguous understanding of the language in all its facets by all members participating in the effort was necessary to be able to develop and discuss the ALGOL language. Using English or any other natural language to describe a programming language was, and is, insufficient. Natural languages are too ambiguous to define formally or even describe a programming language completely.\n\nA description of a programming language consists of a description of two related aspects of the language: the syntax and the semantics. The syntax of a language is about how to form a string in the language. The semantics is about the meaning of syntactically correct strings in the language. The most obvious way to define formally the semantics is an implementation of the language on some machine. This implementation then fixes the meaning of the language.\n\nSuch an implementation is not a workable description of a language. A typical implementation is too large to be understood easily. Often it is written in some low level programming language or even assembly language. In addition, a compiler is written for a particular machine for which the details should be known to understand the details of the implementation.\n\nFortunately, describing the syntax formally appeared to be an easier task than describing the semantics of a language. During the development of ALGOL a formal notation was invented to describe the syntax of ALGOL. This notation, or metalanguage, was not complete or perfect but it fulfilled its task to prevent the occurrence of many ambiguities in the discussions about ALGOL. Although the new notation was primarily intended for describing the syntax, the semantics were not completely ignored. Actually, the description of the semantics was mixed in with the description of the syntax.\n\nUsually a special notation to describe the syntax also influences the language concepts to be described. Some language concepts are more easily described in one notation than in an other one. A formal notation will result in more coherent and simple concepts: the notation forces the concepts to be described along the rules of the notation.\n\nIn this chapter, both the development of the notation used to describe the syntax and semantics of ALGOL and the development of the language concepts of ALGOL 60 are discussed. To that end, the notation used for describing FORTAN and IAL is explained first. After that the focus is on the first stage of the development of the notation: Backusâs notation. The third topic is the notation of the ALGOL 60 report. Finally, the development of some problematic programming language concepts in ALGOL, especially that of the procedure concept, are treated in more detail.\n\nNotations used to describe early programming languages\n\nThe notations used to describe the early programming languages were, like the languages they described, primitive. During the ALGOL effort this notation was developing into an important aspect of the field of programming languages. Actually, one of the results of this effort was a way to define programming languages: do it as it was done in the ALGOL 60 report.\n\nTo describe this development of notation, the notation used before the ALGOL effort is explained and compared to the notation used to describe IAL. This comparison answers the question if this development of notation started during or before the ALGOL effort. In other words: Was the nature of the ALGOL effort responsible for this development of notation?\n\nThe notation of IAL and FORTRAN compared\n\nIn 1954, the first document describing FORTRAN was published: Preliminary ReportâSpecifications for the IBM Mathematical FORmula TRANslating System FORTRAN. Two years later, at 15 October 1956, a more finalised version of the language was published. The notation used in this later document was the same as in the preliminary report; the notation to describe a programming language had not changed fundamentally during these two years.\n\nAs was the case with FORTRAN, the first publication of IAL was also a preliminary report: Preliminary Report: International Algebraic Language. Actually, both preliminary reports do resemble each other in the sense that both documents were set up in a similar way. To compare the notations used in both reports, the descriptions for some language elements are given and compared.\n\nReal numbers in IAL are described using a pattern reflecting the form of a real number. Compared to the description of real numbers in FORTRAN , where only natural language is used, the form of a number is more obvious.\n\nA more complicated language construct was the expression. Again, in IAL patterns are used to clarify the form of an expression whereas in FORTRAN natural language is used. The difference between the two notations is much smaller than before: a pattern is used in both descriptions. In IALâs description this pattern is more explicit, however.\n\nThe notations used for statements were also alike. For example, the if statement is described in both preliminary reports with a pattern (compare figures). Although this version of FORTAN did not have that much declarations, the description of declarations was more or less similar with those in the IAL report. In a later version of FORTRAN more declarations were added to the language.\n\nIn short, the notation used to describe FORTRAN was similar to the notation used to describe IAL. In the description of FORTRAN natural language was used more often than in the description of IAL. The general form of a language element was described with a pattern in both descriptions. These patterns were the basis of the description of IAL. This was probably the influence of the European part of the designing committee. As we have seen before, the Europeans tended more to logic and mathematics than the Americans did.\n\nThe quality of IALâs notation\n\nThe notations used to describe both FORTRAN and IAL were similar. This does not say anything about the quality of the notation, however. The question is: Was this notation sufficient to describe a programming language formally and completely? To answer this question, a closer look at IAL and its notation is taken.\n\nEven for simple language elements, like algebraic expressions, IALâs notation was not good enough. For example, an algebraic expression has simply one of the forms occurring on the right hand side of the â~â symbols. Although it is assumed that the operators in this definition do have the âconventional meaning,â this definition is ambiguous and it does not say anything about operator precedence, nor about associativity.\n\nWhen defining an element with an unknown number of subelements or when there are constraints on the occurrence of some subelements this notation was problematic. Take, for example, the compound statement (above Figure). The pattern of this compound statement is a number of statements between the begin and end keywords. At first glance, this seems to define this compound statement completely.\n\nUnfortunately it is not clear if it was possible to have a compound statement containing no statements at all, only one statement, or even two statements. After all, there are three âÎ£â symbols in the pattern describing the compound statement. The use of ââ¦â in itself may be clear and completely understandable for most of the readers of the report; those readers were almost all used to read mathematical texts in which these shortscripts occurred often. It does, however, not describe formally and fully what should occur on those ââ¦â.\n\nThis compound statement consists of a number of unconstrained elements only and the use of ââ¦â would be acceptable if the only meaning was zero or more times the repeated element. Unacceptable for a formal notation are constraints on the elements in a pattern added outside the pattern using natural language.\n\nAs an example, part of the definition of the procedure declaration is given in the above Figure. Here the ââ¦â are used not only to denote zero or more occurrences of one element denoted by a single symbol, it has three different meanings in the same pattern:\n\nOne or more occurrences of a procedure signature. The procedure signature itself consisted of more than one symbol and a part of unknown length, namely the parameter part of the procedure signature. Actually the part â¡:(P0) is optional.\n\nZero or more occurrences of a declaration about the input and output parameters defined in the procedure signatures.\n\nZero or more occurrences of two different elements: statements Î£ and â declarations . These different elements can be mixed in any order. For every procedure signature, however, there should be a label identical to the procedure identifier preceding minimally one statement. In addition, each procedure must have a return statement and all output parameters should have an assignment statement assigning the value to output the result.\n\nThis early notation to describe programming languages was not suitable to define a language like IAL fully and formally. To be able to do so was necessary because IAL was intended to be machine independent: IAL was to be implemented on various machines by different people. According to Backus (1959): âthere must exist a precise description of those sequences of symbols which constitute legal IAL programs.â But, âheretofore there has existed no formal description of a machine-independent languageâ. For this reason, Backus started to work on such a formal description.\n\nBackusâs notation\n\nAt the UNESCO International Conference on Information Processing, held at Paris from 15 till 20 June 1959, J.W.Â Backus presented The syntax and semantics of the proposed international algebraic language of the Zurich ACM-GAMM Conference about a formal description of the syntax of IAL. To be able to describe the syntax formally he invented a new metalanguage based on Emile Postâs production system. This notation became known as the Backus Normal Form and later as the Backus Naur Form, it is, however, best known by its abbreviation BNF.\n\nUsing this notation, the syntax of a language could be described by âproduction rulesâ. Each rule was of the shape <metalinguistic variable> :â¡ pattern. A pattern was built up from metalinguistic variables and symbols of the language. All possible patterns for a metalinguistic variable were connected with the or symbol, denoting a choice between the different patterns for the metalinguistic variable.\n\nA simple example of the application of Backusâs notation is the description of integers:\n\n<digit> :â¡ 0 or 1 or 2 or 3 or 4 or 5 or 6 or 7 or 8 or 9 <integer> :â¡ <digit> or <integer><digit>\n\nA digit is clearly a number, or better, a symbol representing a number, between 0 and 9 . An integer is now built up from these simple digits: it is either one simple digit, or it is a integer followed by a simple digit, like 9237.\n\nAnother simple and clear example is the description of arithmetic expressions:\n\n<factor> :â¡ <number> or <function> or <variable> or <subscr var> or ( <ar exp> ) or <factor>â<ar exp>â <term> :â¡ <factor> or <term> Ã <factor> or <term> / <factor> <ar exp> :â¡ <term> or + <term> or - <term> or <ar exp> + <term> or <ar exp> - term <Ar exp A> :â¡ <ar exp> <relation> :â¡ < or > or â¤ or â¥ or â < rel exp> :â¡ ( <ar exp> <relation> <ar exp A>)\n\nComparing this with the previous incarnation, it is immediately clear that the former is a less ambiguous description than the former description. Using his notation Backus was able to denote the operator precedence by splitting up the description of expressions into different parts: factors, terms and expressions.\n\nSome other problems with the older notation were also solved by this new notation: the use of ââ¦â to denote the occurrence of an element a (unknown) number of times was not needed any more. In Backusâs notation, it was possible to use recursion and, hence, to specify that an element could occur a number of times. The use of this recursivity is made clear by describing a parameter list:\n\n<param list> :â¡ <param> or <param list>, <param>\n\nA parameter list is either just one parameter, or it is a parameter list followed by a comma and one parameter.\n\nChoice could be denoted by using the connective: write two patterns, one with the element of choice and one without it. Both recursion and choice were used to describe procedure statements:\n\n<oe> :â¡ <left element> <out list> :â¡ <oe> or <outlist>, <oe> <suc> :â¡ <label> or <id>[<exp>] <succr list> :â¡ <suc> or <succr list>, <suc> <A> :â¡ =:(<out list>) or <blank> <B> :â¡ :(<succr list>) or <blank> <proc stmt> :â¡ <function> <A> <B> or <id> =:(<outlist>) <B> or <id>:(<succr list>) ppol> :â¡ <blank> or <ppol> <oe> <pol> :â¡ <ppol> or <pol>, or <pol>, <oe> <A'> :â¡ =:(<pol>) <ppsl> :â¡ <blank> or <ppsl><suc> <psl> :â¡ <ppsl> or <psl>, or <psl>, <suc> <B'> :â¡ :(<psl>) <F*> :â¡ <function> or <pure funtion> or <id> A*> :â¡ <A> or <A'> <B*> :â¡ <B> or <B'> <pure function> :â¡ <pure function> <A*> <B*> or <F*> <A'> <B'> or <F*> <A*> <B'> [a pure procedure may have any of the forms of a procedure statement but at least one position of one existing list must be empty; at least one input parameter position or one output position or one successor position].\n\nUnfortunately, Backus was not able to write down a formal, clear and understandable description of the procedure statement. Even using his new notation, Backus had to write down some remarks about the statement using natural language to complete the formal description; the procedure statement was too difficult to describe formally. In addition, the description of the declaration of procedures was not included at all.\n\nThe new notation was an huge improvement over the one used earlier. Nonetheless, it was improved further by Peter Naur. He replaced by and by . With this, and with the use of complete words for metalinguistic variables instead of using abbreviations of the same words as did Backus, Naur improved the readability of the description. The most important contribution of Peter Naur to Backusâs notation, however, was the fact that he used it in the ALGOL 60 report. Only after the publication of that report the BNF became more widely known. Before the publication it appeared to Peter Naur that Backusâs description of IAL âwas received with a silence that made it seem that precise syntax description was an idea whose time had not yet comeâ. Naur âthus proved the usefulness of the idea in a widely read paper and it was acceptedâ.\n\nDeveloping ALGOL 60\n\nDuring the eighteen months between the meeting in ZÃ¼rich and the next joint meeting on the international algebraic language, held in Paris, January 1960, the name of the language had changed from the ââunspeakableâ and pompous acronym, IALâ to ALGOL. Furthermore, the language was discussed among interested people from America and various countries of Europe. In these months the ALGOL effort became a truly international effort, but it was still a separated effort. The main development took place at different meetings and in correspondence between members of the various subcommittees. The official communications channels of the development, however, were the Communications of the ACM in the USA and the ALGOL Bulletin in Europe.\n\nMost of the American proposals were related to practical aspects of the language. They wanted to improve the language by extending it, by adding more types, and by adding input and output facilities. Another suggestion to improve the language was to tidy up the syntax a bit. This practical attitude to the ALGOL effort was a result of the state of programming in the USA: programming was becoming a professional field and the experience gained with existing programming languages provided a good feedback to the ALGOL effort.\n\nThe European proposals were often focused on the procedure concept and the scopes of variables. The Europeans aimed to improve the language fundamentally and the main target was the difficult procedure concept in IAL. Both in the preliminary report on IAL and in Backusâs description of IAL this procedure concept could not be described fully and formally in the notation used. Aside from this notational problem, other problems with IALâs procedure concept were also noted and discussed.\n\nThe discussions on the procedure concept focused mainly on parameters. E.T.Â Irons and F.S.Â Acton (1959) sum up some problems with IALâs parameters in A proposed interpretation in ALGOL. Parameters could occur in the procedure body at the left hand side of an assignment statement. When the procedure was called these parameters in the body were replaced with the argument supplied for that parameter. If an argument was not an assignable element (i.e.Â not a variable) it would result in undefined behaviour. Another problem mentioned was the use of one argument as both an input and an output parameter. Actually, one parameter could also be used as both an input and an output parameter.\n\nThese problems with the procedure concept were resolved by various subcommittees at the final meeting in Paris. First, the distinction between input and output parameters was removed. This solved a number of problems but not all of them. Eventually, under great time pressure, the distinction between call-by-name (enabling the so-called Jensenâs device) and call-by-value was invented. Every occurrence of a call-by-name parameter in the body of a procedure was being substituted by the name of the argument supplied to the procedure for that parameter. If a parameter was called by value, however, then the value of the argument was assigned to all occurrences of the corresponding parameter in the procedure body. This call-by-name parameter concept was one of the most controversial features of ALGOL 60.\n\nAnother issue at the Paris meeting was recursion. Recursive procedures were new in 1960 and the usefulness of it was not widely recognised. The proposal to add the keyword to the language to denote a recursive procedure was rejected. When ALGOL 60 was published, however, it appeared that there was no restriction on the occurrence of calls to a procedure in its own procedure body. Without anyone knowing recursion was added to the language. According to Bauer (1978), this was the result of âthe Amsterdam plot in introducing recursivity.â\n\nAt the end of the meeting the procedure concept had become a clear concept. The formal description of the declaration of a procedure is given in the above Figure. As said earlier, Backus (1959) did not define the procedure declarations formally, but he did describe procedure statements. The description of procedure statements in the ALGOL 60 report consists of just six subparts. Backus, on the other hand, needed seventeen subparts for the same task. Using the BNF to define ALGOL 60 had a beneficial effect on the procedure concept and ALGOL 60 as a whole.\n\nBesides the types Boolean, integer, real, and array of those types, the string type was added to ALGOL 60. It could only be used as an actual parameter in procedures, however. Proposals to add extra types like complex numbers and lists, were rejected. Furthermore, IALâs assignment statement was extended into a multiple assignment statement: assignments like were now also allowed.\n\nThe compound statement introduced in IAL was extended and it became a special case of the block concept. In a block, variables, functions, and even procedures can be declared local to the scope of the block. These declarations are only known in the block they are declared in and in all subblocks. They are not known, however, in the encapsulating block. A compound statement was now a block without any declarations. Blocks could be nested to any particular level.\n\nThe case-like statement from IAL was removed and replaced by the else clause in the if statement and conditional arithmetical and Boolean expressions. In the above Figure the description of the arithmetic expression is given, including this conditional expression. An example of the use of a conditional expression is: a := if (b < 23) then b + 23 else b - 21. To the variable the value b + 23 is assigned if b < 23, else the value b - 21 is assigned.\n\nIn Figure below one of the example programs in the ALGOL 60 report is given exemplifying many of the programming language concepts discussed above.\n\nThe meeting in Paris was attended by Bauer, Naur, Rutishauser, Samelson, Vauquois, van Wijngaarden, and Woodger from Europe and by Backus, Green, Katz, McCarty, Perlis, and Wegstein from the USA. The seventh American member, Turanski, had died even before the meeting and was not present. According to Perlis (1978), âThe meetings were exhausting, interminable, and exhilarating. (â¦) diligence persisted during the entire period, The chemistry of the 13 was excellent. (â¦) Progress was steady and the output, Algol60, was more racehorse than camel.â\n\nThe difference between IAL and ALGOL 60 was huge. Instead of âjust adding a few corrections to ALGOL 58, it was necessary to redesign the language from the bottom up.â In addition, the editor of the ALGOL 60 report, Peter Naur, used a changed version of Backusâs notation. The use of the BNF was beneficial for the clean structure of the report. Peter Naur became the editor because he had prepared a draft of the language for the Paris meeting. According to Bauer (1978), the participants of the conference were surprised by Naurâs work. âIt therefor sounds poetic if he has written that his draft Report was âchosenâ as the basis of the discussion; the Committee was simply forced to do soâ.\n\nThe result of the meeting, the ALGOL 60 report, âwas a fitting display for the language. Nicely organised, tantalisingly incomplete, slightly ambiguous, difficult to read, consistent in format, and brief, it was a perfect canvas for a language that possessed those same properties. Like the Bible it was meant, not merely to be read, but to be interpreted.â And although the ALGOL 60 report and the formal notation used in it were frightening many people at first, the ALGOL 60 report would become the standard for defining programming languages.\n\nConclusion\n\nA formal notation to define a programming language is important to allow everyone to read and interpret the definition in the same way. During the development of ALGOL 60, the notation used to describe the ALGOL languages changed fundamentally.\n\nThe notation to describe early programming languages like FORTRAN and IAL was natural language combined with some patterns denoting the form of the various language elements. The disadvantage of this notation was that it resulted in ambiguous descriptions. Even for simple language elements, like numbers, expressions, and simple control structures, this was problematic. For definition of complex structures, like the procedure statement and declarations, the notation was totally insufficient. The description of IALâs procedure concepts was long and incomplete because of the use of the ââ¦â symbol.\n\nTo give a more formal and complete description of the syntax of IAL, Backus invented a new notation: the Backus Normal Form. Using this simple notation, complex structures in the language could be described formally. Unfortunately, the procedure concept of IAL was too complex to describe in this notation. So we can conclude that either the notation was insufficient or the procedure concept in itself was wrong.\n\nDuring the period between the definition of IAL and ALGOL 60, many proposals to improve ALGOL were made. One of the main topics, especially in Europe, was the complex procedure concept. In the ALGOL 60 report the procedure concept was simplified: input and output parameters were removed, call-by-name and call-by-value parameters introduced. Another important aspect of the new language was the notion of a block with its own scope. This block was an extension of the compound statement from IAL. Recursion was a new feature added without anybody knowing it; the proposal to add recursion explicitly was rejected.\n\nThe ALGOL 60 report was edited by Peter Naur. He wrote the draft version and used a slightly modified version of Backusâ notation to describe the language. This draft was used as the basis for the ALGOL meeting. The final report would become the standard method of defining programming languages and Backusâ notation became the standard method to describe the syntax of programming languages.\n\nIn this short period, the ALGOL effort became a major contributor to the field of programming languages. Examples of contributions include the BNF, a method to define a programming language, the block structure, recursive procedures, call by name, call by value, the block, the scope, etc.\n\nReferences"
    }
}