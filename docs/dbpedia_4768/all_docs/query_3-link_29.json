{
    "id": "dbpedia_4768_3",
    "rank": 29,
    "data": {
        "url": "https://craftofcoding.wordpress.com/tag/algol/",
        "read_more_link": "",
        "language": "en",
        "title": "Algol – The Craft of Coding",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://craftofcoding.wordpress.com/wp-content/uploads/2021/03/algorithm35.png?w=572",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2021/02/wirthlanguages1-1.png?w=599",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2021/02/wirthlanguages2.png?w=620",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-04-06T20:03:37+00:00",
        "summary": "",
        "meta_description": "Posts about Algol written by spqr",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "The Craft of Coding",
        "canonical_link": "https://craftofcoding.wordpress.com/tag/algol/",
        "text": "The Sieve of Eratosthenes likely first appeared in computing in 1961 as Algorithm 35 in Communications of the ACM (p.151). It, likely many other algorithms of the time was shown in Algol-60.\n\nTo try and implement it as close as possible to the original syntax, given that there are few if any Algol-60 compilers out there, I chose to reproduce the algorithm in its entirety in Algol-68 using the Algol-68 Genie (a68g) specification. It wasn’t a lot of fun.\n\nPROC sieve = (INT nmax, REF INT j) []INT: ( [nmax]INT primes; INT i; primes[1] := 1; primes[2] := 2; primes[3] := 3; j := 3; FOR n FROM 3 BY 2 TO nmax DO i := 3; l1: IF primes[i] <= sqrt(n) THEN GOTO a1 ELSE GOTO a2 FI; a1: IF n/primes[i] = n%primes[i] THEN GOTO b1 ELSE GOTO b2 FI; b2: i := i + 1; GOTO l1; a2: primes[j] := n; j := j + 1; b1: print(\"\") OD; j := j - 1; primes ); main: ( INT n, numpr; print(\"Upper limit to calculate sieve? \"); read(n); [n]INT primes; primes := sieve(n,numpr); FOR i FROM 1 TO numpr DO print(whole(primes[i],5)); IF i MOD 10 = 0 THEN print(new line) FI OD )\n\nIt was an interesting experience, partially because the documentation for a68g is okay, but it is filled with the same obtuse stuff in the original reports for Algol-68. There is a lot to this language, and trying to find simple things, like how to pass back a variable from a subprogram is trying. There are things I inherently like, like the ability to specify the size of the array to be created within the function (proc seems like a procedure, but behaves more like a function). And I like that assignment is :=, and equality is =. It’s also nice to use a language where it is easy to return an array from a function. Here is the program executed with the value of n set to 1000.\n\nUpper limit to calculate sieve? 1000 +1 +2 +3 +5 +7 +11 +13 +17 +19 +23 +29 +31 +37 +41 +43 +47 +53 +59 +61 +67 +71 +73 +79 +83 +89 +97 +101 +103 +107 +109 +113 +127 +131 +137 +139 +149 +151 +157 +163 +167 +173 +179 +181 +191 +193 +197 +199 +211 +223 +227 +229 +233 +239 +241 +251 +257 +263 +269 +271 +277 +281 +283 +293 +307 +311 +313 +317 +331 +337 +347 +349 +353 +359 +367 +373 +379 +383 +389 +397 +401 +409 +419 +421 +431 +433 +439 +443 +449 +457 +461 +463 +467 +479 +487 +491 +499 +503 +509 +521 +523 +541 +547 +557 +563 +569 +571 +577 +587 +593 +599 +601 +607 +613 +617 +619 +631 +641 +643 +647 +653 +659 +661 +673 +677 +683 +691 +701 +709 +719 +727 +733 +739 +743 +751 +757 +761 +769 +773 +787 +797 +809 +811 +821 +823 +827 +829 +839 +853 +857 +859 +863 +877 +881 +883 +887 +907 +911 +919 +929 +937 +941 +947 +953 +967 +971 +977 +983 +991 +997\n\nLanguage design in the 1960’s was dominated by attempts to improve upon Algol60. Hoare noted in 1973 [1] that ALGOL-60 was “… a language so far ahead of its time, that it was not only an improvement on its predecessors, but also on nearly all its successors”. Niklaus Wirth was a graduate student at University of California, Berkeley when he started playing around with languages. He joined a research group which was engaged with the implementation and improvement of a dialect of ALGOL-58, NELIAC. He described the compiler as “an intricate mess“, and the process one of “1% science, and 99% sorcery” [1].\n\nThe first language Wirth designed leading to his dissertation was Euler, as Wirth himself put it “a trip with the bush knife through the jungle of language features and facilities” [1]. Euler had academic elegance, but no real practical value, however it did catch the attention of the IFIP Working Group, engaged in designing the successor to ALGOL-60. There seemed to be two camps here, one which wanted to push the boundaries of language design and another which wanted to extend ALGOL-60. Wirth belonged to the latter group. In 1965, three reports by Wirth, Seegmüller, and Wijngaarden described three different quasi-complete languages. The complexity of the design process, involving far too many people, eventually led Wirth to become disheartened with the design process, and he went off to develop his own version of ALGOL-60s successor. Designed with contributions from Tony Hoare, this language would become ALGOL-W.\n\nWirth’s first significant language was PL360, a byproduct of the ALGOL-W effort. The IBM 360 upon which ALGOL-W was implemented offered the choice of assembly language or Fortran compilers, neither of which was very attractive. PL360 [2] was a tool with which to implement ALGOL-W. ALGOL-W had a number of applications, but was deficient as a systems programming language. PL360 was to become more successful than ALGOL-W, largely because ALGOL-W was a complex language, and the target computers inadequate. In the fall of 1967, Wirth returned to Switzerland to begin work on the language that would become most closely associated with his language design efforts – Pascal. Wirth would go on to create a trinity of languages, neither of which were that closely related, but all that had one thing in common, they were “ALGOL-like” languages – Pascal, Modula-2 and Oberon.\n\nPascal – Based largely on Algol W, including the use of it’s while and case statements, and record structures. There were syntactic differences, however Algol 60 was almost a subset of Pascal.\n\nModula-2 – Wirth noted that Modula-2 “includes all aspects of Pascal, and extends them with the module concept”.\n\nOberon – Evolved from Modula-2 by very few additions, and several subtractions.\n\nNote that “ALGOL-like” really implied – a procedural paradigm, a rigorously defined syntax, traditional mathematical notation (with the nonsense of symbols like ++), block structure providing identifier scope, the availability of recursion, and a strict, static data typing system. [3]\n\n[1] Wirth, N., “From programming language design to computer construction”, CACM, 28(2), pp. 160-164 (1985)\n\n[2] Wirth, N., “PL360, a programming language for the 360 computers”, Journal of the ACM, 15(1), pp.34-74 (1968)\n\n[3] Wirth, N., “Modula-2 and Oberon”, in ACM Conf. on History of Programming Languages, pp.3-1-3-10 (2007)\n\nThe cool thing about some languages is that you don’t have to be a guru in order to interpret them.\n\nTake Algol 60 for example. Algol wasn’t the best language in the world, but it had some nice features. For example you could use a if statement within an assignment to assign values. Here’s an example:\n\npostage := if weight ≤ 20 then 40 else if weight ≤ 125 then 80 else if weight ≤ 500 then 120 else 200;\n\nOkay, some people will say “But C can do that too!” Yes it can, but certainly not as elegantly. Here is the C expression, using a ternary operator.\n\npostage = (weight <= 20) ? 40 : (weight <= 125) ? 80 : (weight <= 500) ? 120 : 200 ;\n\nIt basically embeds a ternary conditional each time the “else if” is invoked. It just isn’t very elegant to look at, let alone write, or understand.\n\nAfter the freewheeling fifties, programming languages entered a more bohemian time, with many languages appearing, and those 1950s languages evolving, as new programming ideologies evolved. First out of the gate was ALGOL 60 which evolved from the fledgling Algol 58. It was common practice to “re-design” a language quite considerably, rather than make tweaks to an existing language. As such languages such as Algol 58 often fell out of favour as people adopted newer versions of a language. Algol was to spawn what would eventually become quite an issue in the computing community: augmentations, extensions, and derivations, leading to numerous dialects of a language. ALGOL 68 appeared just before its contemporaries C and Pascal, however due to inherent complexities, never really hit it off. (ALGOL 68 was used by European defense agencies, however the US decided to hedge its bets with Ada.) There was some controversy over the design of a successor to Algol 60, with Wirth and Hoare going on to develop their own successor, Algol-W. Algol 68 was a major revision to Algol 60, whereas Algol-W included more subtle changes. The 1960’s also saw a number of updates to both Fortran and Cobol.\n\nLanguages had also begun to diversify into differing realms. In 1964, Kenneth E. Iverson introduced APL, (A Programming Language) a concise symbol-based language adept at dealing with arrays. Early versions of the language contained no control structures, and whilst Cobol may have strayed too far into “English-language” syntax, APL may have gone too far with its mathematical syntax. APL was popular with those doing computer graphics, but its use declined in the 1980s, due in part to the advent of languages such as MATLAB and GNU Octave. The 1960s also saw the second generation of programming languages evolve, those influenced by the likes of Fortran or Algol. In 1964 PL/I (Programming Language One) made its appearance, supposedly for use in data processing, numerical computation, scientific computing, and systems programming. However it was a more complex language than either Fortran or Cobol, from which it had evolved, and was not extremely successful. Algol also influenced the design of Simula, the first OO language which appeared in 1967. In an educational context, Logo appeared in 1967, famous for its use of “turtle graphics”, influenced by Lisp.\n\nP.S. If you want to have some fun with a Logo interpreter, check this out."
    }
}