{
    "id": "dbpedia_4768_0",
    "rank": 25,
    "data": {
        "url": "https://craftofcoding.wordpress.com/category/algol/",
        "read_more_link": "",
        "language": "en",
        "title": "Algol – The Craft of Coding",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://craftofcoding.wordpress.com/wp-content/uploads/2022/11/e_sale_algol60.png?w=680",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2021/03/algorithm35.png?w=572",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-06-11T14:23:12+00:00",
        "summary": "",
        "meta_description": "Posts about Algol written by spqr",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "The Craft of Coding",
        "canonical_link": "https://craftofcoding.wordpress.com/category/algol/",
        "text": "Algol\n\nQuicksort – Algorithm 63, and 64\n\nQuicksort is a well-known sorting algorithm developed by C. A. R. Hoare in 1962 while working for the small British scientific computer manufacturer Elliott Brothers Ltd. [1, 2]. In his 1980 ACM Turing Award Lecture [3] he describes how a course on Algol 60, taken in early 1961 introduced him to the concept of recursive procedures. The presence of recursion in Algol 60 allowed Hoare to write Quicksort, a concept he had invented while trying to improve upon the Shellsort of Shell [4]. The entire algorithm was described in half a page, and comprised of two algorithms (written in Algol 60): Algorithm 63 which described the partition function, and Algorithm 64 which performed the actual Quicksort function. One of the greatest benefits of Algol 60 was the fact that it, unlike Fortran, allowed recursion.\n\nAlgorithm 64\n\nprocedure quicksort (A,M,N); value M,N;\n\narray A; integer M,N;\n\ncomment Quicksort is a very fast and convenient method of\n\nsorting an array in the random-access store of a computer. The\n\nentire contents of the store may be sorted, since no extra space is\n\nrequired. The average number of comparisons made is 2(M-N) ln (N-M),\n\nand the average number of exchanges is one sixth this amount.\n\nSuitable refinements of this method will be desirable for its\n\nimplementation on any actual computer;\n\nbegin integer I,J;\n\nif M < N then begin partition(A,M,N,I,J);\n\nquicksort(A,M,J);\n\nquicksort(A,I,N);\n\nend\n\nend quicksort\n\nAlgorithm 63\n\nThe original Algol algorithm as published in Communications of the ACM, used a series of goto statements to facilitate the partitioning of the array into those items less than the pivot, and those items greater than the pivot.\n\nprocedure partition (A,M,N,I,J); value M,N;\n\narray A; integer M,N,I,J;\n\ncomment I and J are output variables, and A is the array (with\n\nsubscript bounds M:N) which is operated upon by this procedure.\n\nPartition takes the value X of a random element of the array A,\n\nand rearranges the values of the elements of the array in such a\n\nway that there exist integers I and J with the following properties:\n\nM ≦ J < I ≦ N provided M < N\n\nA[R] ≦ X for M ≦ R ≦ J\n\nA[R] = X for J < R < I\n\nA[R] ≧ X for I ≦ R ≦ N\n\nThe procedure uses an integer procedure random(M,N) which\n\nchooses equiprobably a random integer F between M and N, and\n\nalso a procedure exchange, which exchanges the values of its two\n\nparameters;\n\nbegin real X; integer F;\n\nF := random(M,N); X := A[F];\n\nI := M; J := N;\n\nup: for I := I step 1 until N do\n\nif X < A[I] then go to down;\n\nI := N;\n\ndown: for J := J step -1 until M do\n\nif A[J] < X then go to change;\n\nJ := M;\n\nchange: if I < J then begin exchange(A[I],A[J]);\n\nI := I + 1; J := J - 1;\n\ngo to up\n\nend\n\nelse if I < F then begin exchange(A[I],A[F]);\n\nI := I + 1;\n\nend\n\nelse if F < J then begin exchange(A[F],A[J]);\n\nJ := J - 1;\n\nend;\n\nend partition\n\nFurther reading\n\nHoare, C.A.R., “Algorithm 64 Quicksort”, Communications of the ACM, 4(7), p.321 (1961)\n\nHoare, C.A.R., “Algorithm 63 Partition”, Communications of the ACM, 4(7), p.321 (1961)\n\nHoare, C.A.R., “The Emperor’s Old Clothes”, Communications of the ACM, 24(2), p.75-83 (1981)\n\nShell, D.L., A high-speed sorting procedure”, Communications of the ACM, 2(7), pp.30-32 (1959)\n\nTranslating an Algol-60 program to Fortran\n\nThis post deals with the simple task of translating an Algol-60 program to Fortran, and some simple tricks which can be used. The program in question calculates e to many digits.\n\nThere are many algorithms for calculating numbers like π and e. Normally e is calculated using the infinite series. These series often offer fast convergence, and are easy to calculate, however the problem is that computers are generally unable to accommodate more than 10-20 significant digits. For generating an accurate value for e, one has to turn to an alternative algorithm. One such algorithm is provided by Sale [1] in Algol-60 (or thereabouts). As there are no Algol-60 compilers out there, it is then a task of converting the program to another language. Here we have chosen Fortran, for reasons which will become clear as we progress through the discussion.\n\nThe first thing someone will say is that they don’t know Algol-60. While I’m sure that’s true of most people, if you have a basic clue about control structures in programs, and can read a program, deciphering what goes on here should not be that hard. The first thing to do is come reverse engineering. You have to understand what the algorithm embedded in the Algol-60 code does.\n\nThe first thing you might notice about this code is the fact that it allocates dynamic-type arrays within the code. This was not that unusual for Algol-type languages. Inputs to the procedure are n and d: where n is the number of decimal places to be calculated, and d is the array used to store them in. The use of the keyword loop does not in fact indicate a loop, but rather a label for that particular line. The if statement on the next line, if true, uses a goto to “loop” back to loop. In the Fortran this has been replaced by a real do while loop.\n\nm := 4; test := (n + 1) × 2.30258509; loop: m := m + 1; if m × (ln(m)-1.0)+0.5 × ln(6.2831852) × m) ≤ test then go to loop;\n\nm = 4 test = (n+1) * 2.30258509 do while (m * (log(m*1.0)-1.0) + 0.5 * log(6.2831852 * m) <= test) m = m + 1 end do\n\nYou will notice that variables are created when they are needed in the original program. As Fortran does not work in the same manner, these variables will be moved to the declaration block at the top of the subroutine. Here the value of m calculated in the previous code is used to allocate storage for the array coef. Fortran will allow allocate statements anywhere in a program. The loop to set the elements of coef to 1 is replaced with a simple statement in Fortran. The two do loops in Fortran fairly well mimic the for loops in Algol-60 program.\n\nbegin integer i,j,carry,temp integer array coed[2:m]; for l:=2 step 1 until m do coef[j]:=1; d[0] := 2; sweep: for i:=1 step 1 until n do begin carry := 0; for j:=m step -1 until 2 do begin temp := coef[j] × 10 + carry; carry := temp ÷ j; coef[j] := temp - carry × j end d[i] := carry end end\n\nallocate(coef(2:m)) coef(2:m) = 1 d(0) = 2; do i = 1, n carry = 0 do j = m,2,-1 temp = coef(j) * 10 + carry; carry = temp / j coef(j) = temp - carry * j end do d(i) = carry end do\n\nNow we can wrap these code segments inside a subroutine:\n\nprocedure ecalculation(n,d); value n; integer n; integer array d; begin integer m; real test; comment Add code segments 1 and 2 end of ecalculation;\n\nsubroutine ecalculation(n,d) integer, intent(in) :: n integer, allocatable, dimension(:), intent(out):: d integer :: m, i, j, carry, temp integer, allocatable, dimension(:) :: coef real :: test allocate(d(0:n)) ! Add code segments 1 and 2 end subroutine ecalculation\n\nAnd finally add this subroutine into a Fortran main program wrapper:\n\nprogram ecalc implicit none integer :: i,num integer, allocatable, dimension(:) :: eArr print*, \"Number of digits?\" read (*,*) num call ecalculation(num,eArr) print*, \"e (actual) = 2.7182818284590452353602874\" write(*,fmt=\"(a15)\", advance=\"no\") \"e (calc) = 2.\" do i = 1,num write(*,fmt=\"(i1)\", advance=\"no\") eArr(i) end do write(*,*) contains ! Add subroutine ecalculation end program ecalc\n\nNow we can compile the program and run a test:\n\nNumber of digits? 25 e (actual) = 2.7182818284590452353602874 e (calc) = 2.7182818284590452353602874\n\nRefs:\n\nSale, A.H.J., “The calculation of e to many significant digits”, The Computer Journal, 11(2), pp.229-230 (1968)\n\nWirth’s thoughts on the “new Algol” committee.\n\nNiklaus Wirth was a part of the working group that was looking at a successor to Agol-60 – IFIP, International Federation for Information Processing, Working Group 2.1. He would later resign from the committee.\n\nIn 1968 he presented the closing word at the ALGOL Colloquium in Zurich. At the time he considered the world of programming to be in “disorder and disorientation“. He summed up the official IFIP meetings as following a pattern of “disarray and dispute”, followed by “a general feeling of discouragement and despair”. It doesn’t sound like a working group that functioned very well. The idea of specifying a “universal language” lead to what Wirth termed a “monster language“, concluding that the working group had failed and should “dissolve”. His final thought is a comment worth repeating:\n\nIt has been sitting on an ivory tower, and when it was recognized that the tower was leaning, it was too inflexible to make a decision for further action. But this seems to be the fate of committees. Next week, we will carefully watch the tower of Pisa.\n\nWirth, N., “Closing word at Zurich Colloquium“, ALGOL Bulletin, 29, pp.16-19 (1968)\n\nThe Wirth Trinity – Design and examples\n\nThe subject [i.e. computer languages] seemed to consist of 1 percent science and 99 percent sorcery, and this tilt had to be changed.\n\nNiklaus Wirth, Turing Award Lecture (1984)\n\nWirth designed programming languages based on a number of design principles.\n\nOccam’s Razor – In the early 1960s Wirth was concerned that languages were becoming more complex than necessary. In his thesis “A Generalization of ALGOL”, he wrote of eliminating many of the non-fundamental concepts of programming languages.\n\nLucidity First – Wirth’s language designs are models of lucidity, i.e. clarity. The notation of the syntax of the languages serves as a natural extension of the algorithmic thinking underpinning the language.\n\nPrinciple, not technique – Wirth was completely aware of the difference between elements of a language that are essential, and those that are ephemeral. Pascal was designed to emphasize the idea of structured programming, not obscure concepts that could be added to a language, and serve little or no purpose.\n\nPedagogy and practice – Pascal was designed for teaching, yet Wirth himself admitted that he does not distinguish between pedagogy and practice: “…I do not believe in using tools and formalisms in teaching that are inadequate for any practical task.“[1]\n\nWhat better way to illustrate the difference between the languages than actually provide some code? In this case the code for the classic Factorial.\n\nModula-2\n\nMODULE Factorial; FROM InOut IMPORT WriteString, WriteInt, WriteLn, ReadInt; VAR i, n, fact : INTEGER; BEGIN WriteString('Factorial n? '); ReadInt(n); FOR i := 2 TO n DO fact := fact * I; END; WriteInt(n); WriteString('! = '); WriteInt(fact); WriteLn; END Factorial.\n\nOberon\n\nMODULE Factorial; IMPORT In, Out; VAR i, n, fact : INTEGER; BEGIN Out.String('Factorial n? '); In.Int(n); fact := 1; FOR i := 2 TO n DO fact := fact * i; END; Out.Int(n); Out.String('! = '); Out.Int(fact); Out.Ln; END Factorial.\n\nPascal (FPC)\n\nprogram Factorial; var I, n, fact : integer; begin writeln('Factorial n? '); read(n); for i := 2 to n do fact := fact * i; write(n,'! = ',fact); end.\n\nWirth, N., 1984 ACM A.M. Turing Award lecture.\n\nEuler : The beginnings of a journey\n\nThe first experiment led to a dissertation and the language Euler – a trip with a bush knife through the jungle of language features and facilities. The result was academic elegance, but not much or practical utility – almost an antithesis of the later data-typed and structured programming languages.\n\nNiklaus Wirth [4]\n\nAll journey’s have a beginning and for Niklaus Wirth his journey into the design of programming languages likely began with Euler. Euler was developed as part of Wirth PhD dissertation work under supervision of Helmut Weber at Stanford University. It was a generalization of Algol-60. It was a language that was suppose to be simpler, yet more flexible than Algol-60, defined with a rigorous formal definition [1,2]. Euler was experimental in nature but likely the impetus for Wirth to continue in language design.\n\nInfluences?\n\nAlgol-60\n\nWhy was it developed?\n\nAs a simper version of Algol-60.\n\nLanguage features\n\nThe numeric data type number, which could be used for either integer or real.\n\nOther data types were boolean, and symbol (string of characters in quotes)\n\nOne of the first languages to include reference (address of a variable).\n\nList processing using the list (a sequence of elements of any type).\n\nFor control structures, other than procedure calls there was only an if expression, and a goto. A for loop was not provided in Euler, but could be easily programmed as a procedure. Later versions included goto and various other control structures.\n\nUsed the ⟵ as the assignment operator (original, later changed to :=).\n\nExample Programs [3]\n\nreal procedure HORNER (real array A(*); integer value N; real value X); begin real S; S := 0; for I := N step -1 until 0 do S := S * X + A(I); S end procedure COPY (real array U, V(*,*); integer value A, B); for I := 1 until A do for J := 1 until B do U(i,j) := V(i,j)\n\nRefs:\n\nWirth, N., Weber, H., “EULER: A generalization of ALGOL, and its formal definition: Part I”, CACM, 9(1), pp.13-25 (1966)\n\nWirth, N., Weber, H., “EULER: A generalization of ALGOL, and its formal definition: Part II”, CACM, 9(2), pp.89-99 (1966)\n\nAlgol W Reference Manual (1972)\n\nWirth, N., “1984 ACM A.M. Turing Award Recipient Lecture”, CACM, 28(2), pp.159-164 (1985)\n\nAlgol-W : A precursor to Pascal\n\nBefore Pascal, there was a language designed by Niklaus Wirth which heavily influenced Pascal’s design. Algol-W is a language which was based on the proposal for Algol-X, the successor to Algol-60, submitted by Niklaus Wirth [1] to IFIP Working Group 2.1 in August 1965. However at the committee meeting at Grenoble in October 1965, they decided it was not a great advancement over Algol-60, and dropped it as an official working document. The committee instead chose a more complicated design which was to become Algol-68. Wirth then collaborated with Tony Hoare to revise the draft [2], and Algol-W was born. The proposal they published in 1966 [2] had a number of goals. It provided an overview of where the AGOL effort was headed, information which could be used for experimental implementations, and potential further extensions.\n\nAlgol-W represented a somewhat conservative evolution of Algol-60, where some concepts were simplified, and some extensions were added. The most important extension was likely the introduction of the concept of generalized data structures. To supplement the array construct, the record was added. This made Algol-W more powerful than Algol-60 in its ability to handle data structures. The language was first implemented on an IBM 360 using PL/360, Wirth’s other early language. In September 1966, Wirth published a follow-up relating to problems encountered whilst implementing Algol-W [4]. Some of the changes would now be considered syntactic sugar. For example array subscripting was changed from a[i][j] to a[i,j], strings were made static, and the concatenation operator was eliminated. In addition, the for statement was given greater versatility, allowing for:\n\nfor x := A step B until C do for x := A until C do for x := A1, A2, A3, ..., An do\n\nAlgol-W was used mostly in the context of an instructional language at universities like Stanford for a number of years, and formed the basis for Pascal.\n\nInfluences?\n\nAlgol-60\n\nWhy was it developed?\n\nAs a successor to Algol-60.\n\nWhat did it actually do for programming?\n\nIntroduction of the case statement, first proposed by Hoare.\n\nIntroduction of a record as a data structure.\n\nValue-result method of passing parameters.\n\nFeatures simplified from Algol-60\n\nThe switch declaration and designator were abolished, replaced by the case statement.\n\nLabels are simplified, so that they only serve as a link between goto and its destination.\n\nA goto cannot jump from outside into a conditional statement or case statement, or iterative statement.\n\nThe own concept was abandoned.\n\nInteger labels are abolished.\n\nThe for statement confined to simple statements (changed after implementation).\n\nNotational simplification to arrays.\n\nExtensions added\n\nAddition of a record data structure.\n\nAddition of complex, bits (bit sequence) and string types.\n\nOperations for bit sequences.\n\nFor types real and complex, a long variant is provided.\n\nA “result parameter” was added to procedures.\n\nExample Programs\n\nBelow are three example programs from [3]. The first program is a classic iterative Factorial, where goto's are used to construct the “for” loops.\n\nBEGIN COMMENT CALCULATE N FACTORIAL; INTEGER N,M,FACT; START: READ(N); FACT := 1; M := N; IF N >= 0 THEN BEGIN LOOP: IF N > 0 THEN BEGIN FACT := FACT*N; N := N-1; GO TO LOOP END ELSE BEGIN WRITE(M,\"FACTORIAL =\", FACT); GO TO START END END END.\n\nCalculate the squares and cubes of integers:\n\nBEGIN INTEGER SQ, CU; FOR X := 3 STEP 2 UNTIL 13 DO BEGIN SQ := X*X; CU := SQ*X; WRITE(\"X =\",X, \"X**2 =\", SQ, \"X**3 =\", CU) END END.\n\nRead an array of N real numbers and sort them using Bubblesort:\n\nBEGIN INTEGER N; READ(N); BEGIN REAL ARRAY X(1::N); REAL TEMP; LOGICAL INTERCHANGES; WRITE(\"ORIGINAL ARRAY\"); WRITE(\" \"); FOR I := 1 UNTIL N DO BEGIN READON(X(I)); WRITE(X(I)) END; COMMENT BEGIN SORT; FOR J := N-1 STEP -1 UNTIl 1 DO BEGIN INTERCHANGES := FALSE; FOR I := 1 UNTIL J DO IF X(I) > X(I+1) THEN BEGIN TEMP := X(I); X(I) := X(I+1); X(I+1) := TEMP; INTERCHANGES := TRUE; END; IF ¬ INTERCHANGES THEN GO TO XIT END; XIT: WRITE(\" \"); WRITE(\"SORTED ARRAY\"); WRITE(\" \"); FOR I := 1 UNTIL N DO WRITE(X(I)) END END.\n\nIn the last program, notice the use of the symbol ¬, which is one of the mathematical symbols for negation, with the other two being ~ and !. Why did this not take on (only a few languages like PL/I used it), rather than use double symbols like != or ~=, or even Fortran’s horrible /= (one of the few Fortran syntax things that really bugs me).\n\nRefs:\n\nWirth, N., “Proposal for a Report on a Successor of ALGOL 60”, MR75, Stichting Mathematical Centre, Amsterdam (1965)\n\nWirth, N., Hoare, C.A.R., “A contribution to the development of ALGOL”, CACM, 9, pp.413-431 (1966)\n\nBauer, H.R., Introduction to ALGOL W Programming, Computer Science Dept. Stanford University (1969)\n\nWirth, N., “Additional Notes on – Contribution to the development of ALGOL”, ALGOL Bulletin, 24, pp.13-17 (1966)\n\nThe Wirth Trinity – Oberon\n\nOn another leave at Xerox PARC (1984/85), Wirth had the goal of developing a modern multitasking OS. Wirth, together with J. Gutknecht embarked on this project in 1987, intending to implement it in Modula-2. They needed a simple language, so Oberon was born, the last in the line of “ALGOL-like” languages. It appeared with a few additions (e.g. OO) and a number of subtractions (discarded Modula-2 features). Oberon-2 appeared in 1991, and became the version of the language most commonly used. It was the last in the family of “Algol-like” languages.\n\nInfluences?\n\nOberon: Modula-2\n\nOberon-2: Oberon, Pascal, Modula-2\n\nWhy was it developed?\n\nOberon was born of Modula-2, adding support for OO. The principle design guideline was to concentrate on features that are basic and essential, and to omit ephemeral issues [6]. Wirth said that the design of Oberon was driven by “the recognition of the cancerous growth of complexity in languages that had recently emerged, such as C, C++ and Ada, which appeared even less suitable for teaching than for engineering in industry.” [6] He lumped Modula-2 into this category as well, referring to it as “overly bulky, containing features that we had rarely used”.\n\nWhat did it actually do for programming?\n\nTraditional programming supported as well as OO-like constructs.\n\nDesign considerations\n\nThe idea behind Oberon was a language simpler than its predecessors.\n\nLanguage features “dumped” from Modula-2\n\nIt eliminated many superfluous Modula-2 features, e.g. the FOR loop, enumeration types, WITH statement, non-integer array indices [1,4].\n\nVariant records (mostly misused, and issues related to garbage automated garbage collection).\n\nEnumeration types (defy extensibility over module boundaries).\n\nSubrange types (compiler complexity, used almost exclusively for indexing arrays).\n\nSET types (replaced with a single predefined type SET, with elements 0-31)\n\nType CARDINAL (with 32-bit integers, the need for unsigned arithmetic was reduced).\n\nQualified import (every occurrence of an imported identifier must be preceded by the defining modules name)\n\nnested modules\n\nWITH statement (explicit qualification of field identifiers is preferred)\n\nFOR loop (omitted from Oberon, but reintroduced in Oberon-2)\n\nLow-level facilities: ADDRESS, WORD.\n\nLanguage features added\n\nOnly a few new features were added, many of which had a hint of OO [4].\n\nAddition of SHORTINT, LONGINT, and LONGREAL\n\nType extension (inheritance) – construction of new types based on existing types.\n\nType inclusion, binds all arithmetic types together. In Modula-2, numeric types are incompatible.\n\nLONGREAL ⊇ REAL ⊇ LONGINT ⊇ INTEGER ⊇ SHORTINT\n\nPOINTER types restricted to record or array types.\n\nLanguage Genealogy\n\nRefs:\n\nWirth, N., “The development of procedural programming languages – personal contributions and perspectives”, in Modular Programming Languages, JMLC 2000, LNCS, V.1897 (2000)\n\nWirth, N., “The Programming Language Oberon”, Software- Practice and Experience, 18(7), pp.671-690 (1988)\n\nMössenböck, H., Wirth, N., “The Programming Language Oberon-2” (1993)\n\nWirth, N., “From Modula to Oberon” (1990)\n\nWirth, N., “Programming in Oberon” (1992)\n\nWirth, N., “Modula-2 and Oberon”, in ACM Conf. on History of Programming Languages, pp.3-1-3-10 (2007)\n\nWirth, N., “Modula: A language for modular multiprogramming”, Software- Practice and Experience, 7, pp.37-65 (1977)\n\nThe Wirth Trinity – Modula-2\n\nPascal had become quite popular in the 1970s. This was in part attributed to the fact that it was a somewhat easy language to learn. It was not as fast a language, as say Fortran, but it did incorporate the notion of structured programming, so that by the late 1970s programmers had learnt to code without using the dreaded goto statement. Wirth realized that Pascal had its shortcomings [1], and considered Pascal’s I/O to be “inadequate and inflexible“. A new language was to be designed, but instead of being called Pascal-2, it was called Modula-2. To experiment with multiprogramming primitives, Wirth contrived a rudimentary language called Modula [7]. Modula was never intended to be a language like Pascal.\n\nIn 1976 Wirth spent a year at the Xerox Palo Alto Research Center (PARC). Here he learned about hardware design, and on returning to Switzerland began work on what was to become Lilith, a personal workstation [3]. Wirth had some fixed constraints on the system: single-user, single processor, and all software written in a single language [1]. As to the language, Pascal was not capable, nor was Modula, at least not by themselves. The solution? Modula-2, a conglomeration of the bloodlines of Pascal, Modula, and Mesa (a language being developed at Xerox PARC). The Lilith was marketed as “The Modula Computer”, and sold for US$22,750.\n\nModula-2 was based on the concept of a module, which allowed for high level abstraction, and low-level facilities. The language was defined in 1978, and implemented on a PDP-11, with the first Modula-2 compiler was released in 1980. One of the reasons Modula-2 didn’t succeed was the lack of a good free compiler (there is one now, but only for Windows).\n\nInfluences?\n\nModula-2 was influenced by Pascal, Modula, and Mesa (a Pascal offspring).\n\nWhy was it developed?\n\nTo alleviate the shortcomings of Pascal, and to design a language more apt for the time. Whereas Pascal was designed more for teaching, Modula-2 was designed as more of a systems-language.\n\nWhat did it actually do for programming?\n\nModules. Derived from the notion of abstract data types, and incorporating information hiding, it built on the concepts of Mesa. This allowed things like I/O to be removed from the language proper, and encapsulated in a module forming a “standard library”. The module structure isolates its contents from the surrounding program, and modules can be separated into a definition and an implementation part. All communications to other modules occurs through the imported and exported identifiers. The module can also be regarded as a representation of the concept of an “abstract data type” postulated by Liskov in 1974 [10].\n\nLanguage features (Modula) “dumped” from Pascal\n\nVariant records.\n\nBuilt-in I/O – move to libraries.\n\nNo goto statement.\n\nPacking of data – Pascal allowed data in record and array structures to be packed.\n\nImprovements over Pascal (i.e. what was added/modified)\n\nSource code is case-sensitive, reserved words are in UPPERCASE.\n\nOpen arrays.\n\nThe PROCEDURE type.\n\nFlexible declarations: types, variables, and procedures can be mixed together, as\n\nopposed to Pascal’s strict const, type, var, etc.\n\nCASE has an ELSE for matching unspecified values. Also permits subranges.\n\nBoolean expressions are evaluated conditionally.\n\nI/O is relegated to library modules to avoid system dependencies.\n\nReadability was enhanced through the use of control structure terminators:\n\nREPEAT–UNTIL, IF/WHILE/FOR – END. This eliminates the begin-end block construct.\n\nThe FOR statement is augmented by the clause BY. Pascal’s downto clause is missing.\n\nThe type CARDINAL to allow for unsigned (positive) integers.\n\nTwo standard procedures for incrementing and decrementing: INC and DEC.\n\nLONG identifiers.\n\nThere are better control transfers. The statements RETURN and EXIT are used to transfer control from procedures and looping structures. HALT is used to terminate a program.\n\nNo goto statement.\n\nNo syntactic ambiguities in decisions, e.g. no dangling ELSE. IF statements always require an END.\n\nA new looping statement called LOOP, providing an infinite loop.\n\nStandard I/O functions, dynamic storage allocation, files via library modules.\n\nLanguage deficiencies\n\nNo standard procedures for I/O and storage allocation (some found this quite onerous).\n\nFor a list of ambiguities and insecurities, the interested reader is referred to [8], [9], and [12].\n\nLanguage Genealogy\n\nRefs:\n\nWirth, N., “The development of procedural programming languages – personal contributions and perspectives”, in Modular Programming Languages, JMLC 2000, LNCS, V.1897 (2000)\n\nWirth, N., “History and Goals of Modula-2”, BYTE, pp.145-152 (Aug.1984).\n\nOhran, R., “Lilith and Modula-2”, BYTE, pp.181-192 (Aug.1984).\n\nPaul, R.J., “An Introduction to Modula-2”, BYTE, pp.195-210 (Aug.1984).\n\nCoar, D., “Pascal, Ada, and Modula-2”, BYTE, pp.215-232 (Aug.1984).\n\nGutknecht, J., “Tutorial on Modula-2”, BYTE, pp.157-176 (Aug.1984).\n\nWirth, N., “Modula: A language for modular multiprogramming”, Software- Practice and Experience, 7, pp.37-65 (1977)\n\nSpector, D., “Ambiguities and insecurities in Modula-2”, ACM SIGPLAN Notices, 17(8), pp.43-51 (1982)\n\nTorbett, M.A, “More ambiguities and insecurities in Modula-2”, ACM SIGPLAN Notices, 22(5), pp.11-17 (1987)\n\nLiskov, B., Zilles, S., “Programming with abstract data types”, in ACM SIGPLAN Notices, 4, pp.50-59 (1974).\n\nCollins, S., “Comparing Modula-2 with Pascal and Ada”, Data Processing, 26(10), pp.32-34 (1984)\n\nCornelius, B.J., “Problems with the language Modula-2”, Software-Practice and Experience, 18(6), pp.529-543 (1988)\n\nThe Wirth Trinity – Pascal\n\nAlgol was likely minimally successful from the point of view of being used extensively in industry, but was used in academic environments. There were many attempts to extend it’s applicability, which lead to Algol 68, and Algol W. However the complexity of Algol 68 ultimately lead to that variant’s demise. PL/I was an attempt to create Fortran VI, however, combining features from Algol, Fortran and COBOL, but the product was once again an extremely large language. Both Algol 68 and PL/I exemplify the notion of “Swiss army knife” approach to language design – providing every conceivable feature. What was required was a smaller, more compact language – enter Pascal.\n\nWirth began design on Pascal (named after French mathematician Blaise Pascal) in 1968, with a compiler written entirely in Pascal, on a CDC 6000 series mainframe. The first language compiler appeared in 1970. The language was tweaked in 1972, and became an ISO standard in 1982. In describing Pascal, Wirth remarked that “the guiding idea in the layout of the syntax of Pascal was simplicity, due to the recognition that structures difficult to process by compilers are also difficult to master by human readers and writers”. The highlights of Pascal [1] were:\n\nSimple control structures for decisions, and repetitions.\n\nScalar data types = boolean, integer, real, char and enumerations.\n\nAbility to construct complex data structures using records, arrays, and sets.\n\nStrict static typing – every constant, variable, function or parameter had a type.\n\nDynamic data structures built with the use of pointers.\n\nRecursive procedures.\n\nInfluences?\n\nPascal was heavily influenced by Algol, and is often called Algol-like.\n\nWhy was Pascal developed?\n\nPascal was born out of what Wirth terms “an act of liberation”. Liberation from the prospect of using Algol or Fortran as languages to teach programming, and liberation from the design constraint imposed by committee work.\n\nWhat did it actually do for programming?\n\nPascal was one of the first languages built from the ground up with the notion of structured programming.\n\nWith no commercial backing, Pascal succeeded on its own merits, and was implemented on systems ranging from Cray supercomputers to personal computers. Programmers who felt “straitjacketed” by writing programs in BASIC, flocked to Pascal.\n\nIt was an ideal language for teaching programming.\n\nPascal was drafted as the basis for the DOD’s Ada project.\n\nIt introduced records into scientific language (although Algol-W really did this).\n\nIt introduced a usable case statement\n\nDesign considerations\n\nThe general idea dominating the design of Pascal was to provide a language appealing to systematic thinking, mirroring conventional mathematical notation, satisfying the needs of practical programming, and encouraging a structured approach. It should be simple, have the ability to handle non-numeric data, be suitable for teaching programming, and have the compile-time and runtime efficiency of Fortran.\n\nLanguage features\n\nRecords, and variant records.\n\nAlgol-60 had blocks (local declarations + statements) and compound statements\n\n(statements only), whereas Pascal eliminated the block.\n\nMore, yet simpler control structures than Algol-60.\n\nUse of a real assignment operator, :=\n\nStrong type safety.\n\nCase insensitive.\n\nNative set operators.\n\nLanguage deficiencies\n\nKeeping the goto statement.\n\nSyntactic ambiguities inherited from Algol – the lack of explicit closing symbols for\n\nnestable constructs, e.g. dangling-else.\n\nInability to support separate compilation of modules hindered the development of\n\nlarge programs.\n\nThe flawed case statement, which lacked an else clause.\n\nFixed size of arrays, precluded the use of general math and string libraries.\n\nFortran, Cobol programmers felt handcuffed by Pascal’s compulsory declaration of\n\nvariables.\n\nNo exponentiation operator.\n\nCriticisms of the language\n\nLack of block structures.\n\nNo dynamic arrays.\n\nLack of the “2nd” form of conditional (inline if).\n\nLabels and the goto statement.\n\n“Unnatural” unification of subranges, types and structures.\n\nThe difference between procedure and function is marginal.\n\nWirth, N., “The development of procedural programming languages – personal contributions and perspectives”, in Modular Programming Languages, JMLC 2000, LNCS (1897).\n\nAlgorithm 35: The Sieve (in Algol-68)\n\nThe Sieve of Eratosthenes likely first appeared in computing in 1961 as Algorithm 35 in Communications of the ACM (p.151). It, likely many other algorithms of the time was shown in Algol-60.\n\nTo try and implement it as close as possible to the original syntax, given that there are few if any Algol-60 compilers out there, I chose to reproduce the algorithm in its entirety in Algol-68 using the Algol-68 Genie (a68g) specification. It wasn’t a lot of fun.\n\nPROC sieve = (INT nmax, REF INT j) []INT: ( [nmax]INT primes; INT i; primes[1] := 1; primes[2] := 2; primes[3] := 3; j := 3; FOR n FROM 3 BY 2 TO nmax DO i := 3; l1: IF primes[i] <= sqrt(n) THEN GOTO a1 ELSE GOTO a2 FI; a1: IF n/primes[i] = n%primes[i] THEN GOTO b1 ELSE GOTO b2 FI; b2: i := i + 1; GOTO l1; a2: primes[j] := n; j := j + 1; b1: print(\"\") OD; j := j - 1; primes ); main: ( INT n, numpr; print(\"Upper limit to calculate sieve? \"); read(n); [n]INT primes; primes := sieve(n,numpr); FOR i FROM 1 TO numpr DO print(whole(primes[i],5)); IF i MOD 10 = 0 THEN print(new line) FI OD )\n\nIt was an interesting experience, partially because the documentation for a68g is okay, but it is filled with the same obtuse stuff in the original reports for Algol-68. There is a lot to this language, and trying to find simple things, like how to pass back a variable from a subprogram is trying. There are things I inherently like, like the ability to specify the size of the array to be created within the function (proc seems like a procedure, but behaves more like a function). And I like that assignment is :=, and equality is =. It’s also nice to use a language where it is easy to return an array from a function. Here is the program executed with the value of n set to 1000.\n\nUpper limit to calculate sieve? 1000 +1 +2 +3 +5 +7 +11 +13 +17 +19 +23 +29 +31 +37 +41 +43 +47 +53 +59 +61 +67 +71 +73 +79 +83 +89 +97 +101 +103 +107 +109 +113 +127 +131 +137 +139 +149 +151 +157 +163 +167 +173 +179 +181 +191 +193 +197 +199 +211 +223 +227 +229 +233 +239 +241 +251 +257 +263 +269 +271 +277 +281 +283 +293 +307 +311 +313 +317 +331 +337 +347 +349 +353 +359 +367 +373 +379 +383 +389 +397 +401 +409 +419 +421 +431 +433 +439 +443 +449 +457 +461 +463 +467 +479 +487 +491 +499 +503 +509 +521 +523 +541 +547 +557 +563 +569 +571 +577 +587 +593 +599 +601 +607 +613 +617 +619 +631 +641 +643 +647 +653 +659 +661 +673 +677 +683 +691 +701 +709 +719 +727 +733 +739 +743 +751 +757 +761 +769 +773 +787 +797 +809 +811 +821 +823 +827 +829 +839 +853 +857 +859 +863 +877 +881 +883 +887 +907 +911 +919 +929 +937 +941 +947 +953 +967 +971 +977 +983 +991 +997"
    }
}