{
    "id": "dbpedia_4768_1",
    "rank": 10,
    "data": {
        "url": "http://groups.umd.umich.edu/cis/course.des/cis400/maxim/lectures/chp2.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Chapter 2",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Evolution of the Major Programming Languages\n\nZuse�s Plankalk�l\n\n� Plankalk�l is the name of a programming language written by a German scientist by the name of Konrad Zuse, between 1936 and 1945\n\n� This language was never implemented\n\n� Its name means program calculus\n\nMINIMAL HARDWARE PROGRAMMING: PSEUDOCODE\n\n� Deficiencies in machine code and assembly language code led to the development of somewhat higher�level languages\n\n� Short code � developed by John Mauchly in 1949\n\n- Implemented with a pure interpreter\n\n- Simplified the programming process; however, it was approximately 50 times slower than machine code\n\n� Speedcoding � developed by John Backus in 1954\n\n- Extended machine languages to include floating-point operations\n\n- Backus claimed that problems that could take two weeks to program in machine code could be programmed in a few hours using Speedcoding\n\n� The UNIVAC �compiling system � developed by a team led by Grace Hopper between 1951 and 1953\n\n- It made machine code source programs much shorter; however it was still quite primitive\n\nTHE IBM 704 AND FORTRAN\n\n� Historical Background\n\n- The first widely accepted high-level language was FORTRAN\n\n- FORTRAN was developed in large measure for the capabilities of the IBM 704 system\n\n- The IBM 704 system was first introduced in 1954\n\n� Design Process\n\n- Plans for FORTRAN were actually begun before the announcement of the IBM 704 system\n\n- The report titled �The IBM Mathematical FORmula TRANslating System� described the first version of FORTRAN\n\n- It stated that FORTRAN could provide the efficiency of hand-coded programs and the ease of programming the interpretive pseudocode systems\n\n- It also stated that it would eliminate coding errors and the debugging errors\n\n� FORTRAN I Overview\n\n- All of FORTRAN I�s control statements were based on 704 instructions\n\n- There are no data-typing statements; instead variables whose names began with I, J, K, L, M, and N are implicitly integer type, and all others were implicitly floating-point type\n\n- FORTRANS claim that the machine code produced by the compiler was as efficient as what could be produced by hand was nearly achieved\n\n� FORTRAN II Overview\n\n- Introduced in the spring of 1958\n\n- Fixes a lot of the bugs in FORTRAN I and adds some significant features, such as, independent compilation of subroutines\n\n� FORTRAN IV, FORTRAN 77, and FORTRAN 90\n\n- FORTRAN III, although developed, it was never a big success\n\n- FORTRAN IV became one the most widely distributed programming languages until 1978\n\n- FORTRAN IV is a big improvement over FORTRAN II because of additions to it, such as, explicit type declaration for variables, a logical IF construct, and the capability of passing subprograms\n\n- FORTRAN 77 is introduced in 1977, it retains most of the FORTRAN IV features and adds to it, character string handling, logical loop control statements, and an IF with an optional ELSE clause\n\n- FORTRAN 90 is the latest version of FORTRAN is dramatically different than FORTRAN 77\n\n- It supplies a collection of built in functions for array operations\n\n- Arrays can be dynamically allocated and deallocated on command\n\n- New control statements, such as, CASE, EXIT, and CYCLE are added\n\n- Recursion is now possible\n\nFUNCTIONAL PROGRAMMING: LISP\n\n� The first functional programming language was invented to provide language features for list processing, which grew out of the applications in artificial intelligence\n\n� The Beginnings of Artificial Intelligence and List Processing\n\n- Interest in AI appears in the mid-1950�s\n\n- This interest comes from the study of linguistics, psychology, and mathematics\n\n- Linguistics because of the interest in the processing of a natural language\n\n- Psychology because of the interest in modeling human information storage and retrieval, along with other brain processes\n\n- Mathematics because of the interest in mechanizing certain intelligent processes\n\n- The concept of list processing was introduced in 1956 by Allen Newell, J.C. Shaw, and Herbert Simon\n\n- A few languages are developed and implemented for list processing but none become really popular until the development of LISP\n\n� LISP Design Process\n\n- Developed by John McCarthy and Marvin Minsky at MIT, because of their dislike for the other languages developed for AI\n\n� Language Overview\n\n- There are only two data structures, atoms and lists\n\n- Atoms are either symbols or numeric literals\n\n- Lists are specified by delimiting their elements with parentheses and may be simple or nested lists\n\n- A list is stored internally as a single-linked list structure\n\n� Processes in Functional Programming\n\n- All computation in a functional program is accomplished by applying functions to arguments\n\n- Iterative processes can be specified with recursive function calls, which means no loops\n\n� The Syntax of LISP\n\n- Program code and data have exactly the same form\n\n� Evaluation\n\n- LISP is still the most widely used language for AI\n\n- In the 1970�s and 1980�s many different dialects of LISP were developed, which led to the problem of portability\n\n- In order to solve the problem of LISP�s portability issue, COMMON LISP was developed as a standard version\n\n� Two Descendants of LISP\n\n- These two dialects are Scheme and COMMON LISP\n\n- Scheme was developed in 1975\n\n- It is relatively small in size and uses static scooping exclusively\n\n- Scheme functions can be values of expressions and elements of lists; they can be assigned to variables, passed as parameters, and returned as values.� These features were not available in the early versions of LISP\n\n- COMMON LISP was developed in 1984\n\n- It takes the features of a few dialects and scheme and combines them into one language; while Scheme is a relatively small language, COMMON LISP is relatively large language and uses dynamic as well as static scooping\n\n� Related Languages\n\n- Three related functional programming languages are ML, Miranda, and Haskell\n\n- MetaLanguage or ML was designed in the 1980�s by Robin Milner\n\n- ML is a functional language, which supports imperative programming\n\n- Miranda was designed by David Turner in the 1980�s as well; It is based on ML, SASL, and KRC\n\n- Haskell is based on Miranda and was designed by Hudak and Fasel in 1992\n\nTHE FIRST STEP TOWARD SOPHISTICATION: ALGOL 60\n\n� Historical Background\n\n- Efforts to design a universal language inspired the development of the programming language ALGOL 60\n\n- In the late 1950�s, all of the languages that had been developed thus far were for single architectures only\n\n- Two user groups SHARE and USE showed an interest in forming a committee through the ACM organization, in order to study and recommend the design and implementation of a universal programming language\n\n- Another group in Europe (GAMM) also was interested and in 1958 the ACM committee along with GAMM officially agreed to a joint language design project\n\n- FORTRAN was not considered because of its sole ownership by IBM.\n\n� Early Design Process\n\n- The syntax of the language should be close to standard mathematical notation\n\n- It should be possible to use the language for the description of computing processes in publications\n\n- And programs in the new language must be mechanically translatable into machine language\n\n� ALGOL 58 Overview\n\n- The first language designed in this project was ALGOL 58\n\n- ALGOL comes from the original name of the language, which is the International ALGOrithmic Language\n\n- Many of the features in ALGOL 58 were derived from FORTRAN\n\n- It generalized FORTRAN�s features and added several new constructs and concepts\n\n� ALGOL 60 Design Process\n\n- ALGOL 58 was furiously debated, resulting in modifications and additions to the language and the development of ALGOL 60\n\n� ALGOL 60 Overview\n\n- ALGOL 60 is result of the modifications made to ALGOL 58\n\n- Introduces the concept of block structure, which allows parts of programs to localized\n\n- Passing parameters by means of pass by value and pass by name are introduced\n\n- Procedures are allowed to be recursive\n\n- Stack-dynamic arrays are now allowed\n\n� ALGOL 60 Evaluation\n\n- ALGOL 60 succeeded in becoming the only acceptable formal means of communicating algorithms\n\n- All imperative languages formed after 1960 are either direct or indirect descendants to ALGOL 60\n\n- It was the first language whose syntax was formally described\n\n- Unfortunately, ALGOL 60 never achieved widespread use, because it was too flexible and it lacked input and output statements\n\nCOMPUTERIZING BUSINESS RECORDS: COBOL\n\n� Although COBOL has been used more than any other programming language it has ahd little effect on the design of any other languages, with the exception of PL/I.\n\n� Historical Background\n\n- Similar to ALGOL, COBOL was designed by a committee\n\n- Three other languages for business applications that existed before COBOL were FLOW-MATIC, AIMACO, and COMTRAN\n\n� COBOL Design Process\n\n- The biggest concern regarding this new application language was that it be easy to use, even at the expense of being less powerful\n\n- The language specifications for COBOL were published in 1960\n\n� Evaluation\n\n- COBOL originated a number of concepts, such as, constructs for macros, implementation of hierarchical data structures, allowed connotative names\n\n- It was the first language whose use was mandated by the Department of Defense\n\n- The poor performance of the early compilers made COBOL expensive to use, fortunately with the advent of better compiler designs and the mandate of the Defense Department COBOL became very popular\n\nTHE BEGINNINGS OF TIME SHARING: BASIC\n\n� Similar to COBOL, BASIC has had widespread use, however it has gotten little respect\n\n� Design Process\n\n- BASIC was designed at DARTMOUTH University in the 1960�s by John Kemeny and Thomas Kurtz\n\n- The goals of the BASIC system were to make it easy for non-science students to learn, be pleasant and friendly, provide fast turnaround for homework, allow free and private access, and consider user time more important than computer time\n\n- The combination of the second, third, and fourth goals mentioned above led to the timeshared aspect of BASIC\n\n� Language Overview\n\n- The original version was very small having only fourteen different statements, and was not interactive, for there was no way to get user input from the terminal\n\n- Overall, it was very limited making it very easy to learn\n\n� Evaluation\n\n- BASIC was the first widely used method of remote access to a computer\n\n- Most of its design came from FORTRAN with some minor influence by ALGOL 60\n\n- Reasons for BASIC�s success are probably it�s ease for which it can be learned and implemented\n\n- Two contemporary versions of BASIC are QuickBasic and Visual BASIC\n\nEVERYTHING FOR EVERYBODY: PL/I\n\n� PL/I represents the first large-scale attempt to design a language that could be used for a broad spectrum of application areas\n\n� Historical Background\n\n- Developed as an IBM product\n\n- Designed to replace FORTRAN, COBOL, LISP and the systems applications of assembly language\n\n� Design Process\n\n- The first version of PL/I was originally named FORTRAN VI because the initial design was just an extension of FORTRAN IV\n\n- The design along with the name was quickly dropped and the new design was called NPL for new programming language\n\n- The name change to PL/I resulted in the avoidance of confusing the name NPL with the National Physical Laboratory in England, since this was were PL/I was developed\n\n� Language Overview\n\n- PL/I included the best of ALGOL 60 (recursion and block structure), FORTRAN IV (separate compilation with communication through global data), and COBOL (data structures, input/output, and report generating facilities), along with a few new constructs\n\n- PL/I was the first language to have programs allowed to create concurrently executing tasks, the possibility to detect and handle 23 different types of exceptions, procedures allowed to be use recursively, pointers included as a data type, and reference to the cross sections of arrays\n\n� Evaluation\n\n- The problem with PL/I is it�s complexity due to it�s large size\n\n- It also suffered from what are now considered to be poorly designed constructs\n\n- However, it did get significant use in both business and scientific applications\n\nTWO EARLY DYNAMIC LANGUAGES: APL AND SNOBOL\n\n� Neither of these languages are based on any previous language and neither have had much affect on any later languages\n\n� The only similarity between APL and SNOBOL is there dynamic typing and dynamic storage allocation\n\n� Origins and Characteristics of APL\n\n- Kenneth E Iverson designed APL in 1960\n\n- It was intended to be a vehicle for describing computer architecture not as a programming language\n\n- It has many powerful operators in order to allow arrays to be manipulated as if they were scalar variables, however, this� creates a problem for implementers of the language\n\n- Although it is not widely used, it is still in use today.\n\n� Origins and Characteristics of SNOBOL\n\n- Designed by D.J. Farber, R.E. Griswold, and F.P. Polensky in the early 1960�s\n\n- It was designed specifically for text processing.\n\n- However, it is rarely used nowadays because it is slower than some other languages\n\nTHE BEGINNINGS OF DATA ABSTRACTION: SIMULA 67\n\n� Design Process\n\n- Kristen Nygraad and Ole-Johan Dahl developed Simula I between 1962 and 1964\n\n- It was designed exclusively for system simulation\n\n� Language Overview\n\n- SIMULA 67 is an extension of ALGOL 60\n\n- Allowed for support of coroutines using the class construct, which is important because the idea of data abstraction starts here\n\nORTHOGONAL DESIGN: ALGOL 68\n\n� Design Process\n\n- Introduces the design criteria of orthogonality, which results in features, such as, the inclusion of user-defined data types and implicit heap-dynamic arrays\n\n� Evaluation\n\n- Introduces a significant number of features not previously used\n\n- Although it may be contrasted with PL/I, PL/I gained a far greater acceptance than ALGOL 68\n\nSOME IMPORTANT DESCENDANTS OF THE ALGOL�S\n\n� All imperative languages including the object-oriented languages, designed since 1960 owe some of their design to ALGOL 60\n\n� Pascal\n\n- Designed by Niklaus Wirth\n\n- Highly used for teaching programming; because of this it lacks some features, such as, separate compilation and passing an array of variable length\n\n� C\n\n- Originally designed for systems programming by Dennis Ritchie in 1972\n\n- Because of its adequate control structures and data structuring facilities C is adaptive to many application areas\n\n- A reason for both like and dislike of C is its lack of complete type checking\n\n- C tends to be a very flexible language\n\n� Modula-2\n\n- Designed by Niklaus Wirth in 1976 (also designed Pascal)\n\n- Distinguishing features include modules, which provide support for abstract data types, procedures as types, and low-level facilities for systems programming and coroutines\n\n� Modula-3\n\n- Based on Modula-2 and Modula-2+\n\n- To Modula-2 it adds classes and objects for support of object-oriented programming, exception handling, garbagfe collection, and support for concurrency\n\n� Oberon\n\n- Loosely based on Modula-2 was written by Niklaus Wirth\n\n- Although many features were added to Modula-2 to come up with Oberon many were subtracted also.\n\n- The main feature added is type extension, which supports object oriented programming\n\n- Among those removed are variant records, opaque types, enumeration types, sub-range types, the CARDINAL type, non-integer array indexes, the with statement, and the for statement\n\n� Delphi\n\n- A hybrid language, similar to C++ in that it was created by adding object-oriented support, along with other things, to an existing imperative language\n\n- It is derived from Pascal, therefore making it much more elegant and safe than C++\n\nPROGRAMMING BASED ON LOGIC: PROLOG\n\n� The use of a formal logic notation to communicate computational processes to a computer\n\n� Design Processes\n\n- Alain Colmerauer, Phillip Roussel, and Robert Kowalski developed the design of Prolog\n\n- Prolog uses a method for specifying predicate calculus propositions and a restricted form of resolution\n\n� Language Overview\n\n- Prolog�s programs consist of a collection of statements or facts\n\n- The most common use of Prolog is as a kind of database\n\n� Evaluation\n\n- There are two major reasons why logic programming has not become widespread\n\n- The first reason is that it has been proven to highly inefficient\n\n- The second reason is that it has been shown to effective for only few areas of application, such as, certain kinds of database management and some areas of AI\n\nHISTORY�S LARGEST DESIGN EFFORT: ADA\n\n� Ada was originally developed for the Department of Defense\n\n� Historical Background\n\n- The Army, Navy, and Air Force all proposed the development of a high-level language for embedded systems in 1974 as an attempt to standardize their own embedded systems\n\n� Design Process\n\n- The committee assigned to this task was responsible for identifying requirements for a new Department of Defense high-level language, evaluating the existing languages to determine whether there was a viable candidate, and recommend adoption or implementation of a minimal set of programming languages\n\n- The resulting language went through multiple phases and was named Ada\n\n� Language Overview\n\n- There are four major features of the Ada language\n\n- Packages provide the means for encapsulation of data objects\n\n- It includes extensive facilities for exception handling\n\n- Allows program units to be generic\n\n- It provides for concurrent execution of special program units and named tasks\n\n� Evaluation\n\n- The Ada language contains most of the concepts of software engineering and language design\n\n- The development of a compiler was a difficult task and almost four years after the design of the Ada language was completed, did the Ada compiler appear\n\nOBJECT-ORIENTED PROGRAMMING: SMALLTALK\n\n� Design Process\n\n- The concepts that led to the development of Smalltalk came out of the Ph.D. dissertation work of Alan Kay\n\n� Language Overview\n\n- The program units of Smalltalk are objects\n\n- All computing in Smalltalk is done in the same fashion, passing messages to objects in order to invoke one of the methods assosciated with that object\n\nCOMBINING IMPERATIVE AND OBJECT-ORIENTED FEATURES: C++\n\n� C++ uses C as a base for which to support many of the concepts introduced by Smalltalk\n\n� Design Process\n\n- Modifications to C included the addition of function parameter type checking and conversion, and classes\n\n- Later the additions included inline functions, default parameters, and overloading of assignment operators\n\n- With the above additions to C came the name C with Classes\n\n- Not until the inclusion of virtual functions, was the name changed to C++\n\n� Language Overview\n\n- C++ provides a collection of predefined classes, along with the possibility of user-defined classes\n\n- Operators in C++ may be overloaded, meaning that the user may create operators for existing operators\n\n- Dynamic Binding is provided by virtual class functions\n\n- Both functions and classes can be templated, which means that they can be parameterized\n\n- It also includes exception handling\n\n� Evaluation\n\n- C++ has become extremely popular\n\n- On the downside, C++ is extremely large and suffers some drawbacks similar to PL/I\n\n� A Related Language: Eiffel\n\n- Like C++ Eiffel combines both imperative and object-oriented features\n\nPROGRAMMING THE WORLD WIDE WEB: JAVA\n\n� Based on C++ however, numerous constructs have been removed, some changed, and a few others added\n\n� The resulting language provides the power and flexibility of C++, however, it is smaller, simpler, and safer\n\n� Design Process\n\n- Java was designed for an application for which their appeared to be no other language satisfactory enough\n\n- This started out as a programming language for embedded consumer electronics\n\n- Later it proved to be a useful tool in programming for the web\n\n� Language Overview\n\n- Java employs both types and classes\n\n- It does not have pointers, although its reference types provide some of the capabilities of pointers\n\n- Uses a primitive Boolean type mainly for the control expressions of its control statements\n\n- There are no record, union, or enumeration types\n\n- Supports only single inheritance\n\n- Provides garbage collection\n\n� Evaluation\n\n- Designers of Java have eliminated many of the features that are considered unsafe in C++\n\n- Java is still considered a complex language and its lack of multiple inheritance is said to lead to some peculiar designs\n\n- The use of Java has increased much faster than the use of any other language"
    }
}