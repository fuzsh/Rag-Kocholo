{
    "id": "dbpedia_4768_2",
    "rank": 17,
    "data": {
        "url": "https://www.cs.csub.edu/~melissa/cs350-f15/notes/notes02.html",
        "read_more_link": "",
        "language": "en",
        "title": "",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.cs.csub.edu/~melissa/cs350-f15/Images/history.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Chapter 2: Evolution of Major Programming Languages\n\n\"Much of my work has come from being lazy.\"\n\n-- John Backus, co-designer of IBM 704 architecture and developer of Fortran\n\n(full chart)\n\n1 9 4 5 -\n\nZuse's Plankalkul (1945) Never implemented; Advanced data structures; floating point, arrays, records; Invariants\n\nShort Code (1949) A \"pseudocode\" developed by Mauchly for BINAC computers; 1) The poor readability and writability of machine code; 2) Machine deficiencies; - no index registers (required absolute addressing in code) - no floating point hardware\n\n1 9 5 0 -\n\nSpeedcoding (1954)\n\nA \"pseudocode\" developed by John Backus for IBM 701; Index registers became standard (1955-1964) Pseudo operations for arithmetic & math functions; Pseudo operations for conditional & unconditional branching; Auto-increment registers for array access; Slower than machine code\n\nFORTRAN 0 (1954) FORmula TRANslation\n\nlanguage specification only - no subroutines; (brief history of Fortran) & Fortran history & docs\n\n\"Fortran should virtually eliminate coding and debugging errors.\" p. 2. \"Unfortunately we were hopelessly optimistic in 1954 about the problems of debugging Fortran programs.\" p. 168. \"As far as we were aware, we simply made up the language as we went along. We did not regard language design as a difficult problem, merely a simple prelude to the real problem: designing a compiler which could produce efficient programs.\" p. 168. \"...while it was perhaps natural and inevitable that languages like Fortran and its successors should have developed out of the concept of the von Neumann computer as they did, the fact that such languages have dominated our thinking for over twenty years is unfortunate. It is unfortunate because their long-standing familiarity will make it hard for us to understand and adopt new programming styles which one day will offer far greater intellectual and compututational power.\" p. 178. John Backus, \"The history of Fortran I, II, and III.\" ACM SIGPLAN Notices, 13(8):165-180, August 1978.\n\nFORTRAN I (1956 - 1957) > 1st implemented version of Fortran compiler (released 1957) - 18 man years; Designed for IBM 704 with index registers and floating point hardware; Environment of development: Primitive kernel or no kernel; No programming methodology or tools; Computers were small and unreliable; Scientific applications and efficiency primary concern; Impact of environment on design: No need for dynamic storage (no heap) Need good array handling and counting loops; No string handling, decimal arithmetic, or powerful I/O (commercial stuff) Overview: Names could have up to six characters; Post-test counting loop (DO) Formatted I/O; User-defined subprograms; Three-way selection statement ( arithmetic IF - <, >, = ) No data typing statements; Programs larger than 400 lines rarely compiled correctly, mainly due to poor reliability of 704; Code was very fast - quickly became widely used\n\nFORTRAN II (1958) Independent compilation of subroutines (reduced development time)\n\nLISP (1958) - LISt Processing language; Designed at MIT by McCarthy (1958) First functional language AI applications process data in lists rather than arrays Symbolic computation rather than numeric Code + Data has same form Originally only two data types: atoms and lists Syntax based on lambda calculus No need for variables or assignment (as in imperative languages) Control via recursion and conditional expressions Still the dominant language for AI ML, Miranda, and Haskell are related languages\n\nALGOL 58 (1958) The 1st step to platform independent language with formalized grammar in BNF (Backus-Naur form) notation; Language Close to mathematical notation - good for describing ALGOrithms; Language development up to now was for specific machines (Fortran had barely arrived for IBM 70x); No portable or universal language -- all were machine-dependent; No easy way to communicate algorithms; ACM and GAMM met for four days on design (May 27 to June 1, 1958) Must be translatable to machine code; Formalized Concept of \"type\"; Names could be any length; Arrays could have any number of subscripts; Parameters were separated by mode (in & out) Subscripts were placed in brackets; Compound statements (begin ... end) Semicolon as a statement separator; Assignment operator was :=; if had an else-if clause; No I/O - would make I/O machine dependent; IBM initially enthusiastic -- all support dropped by mid 1959 so eventually ALGOL as a language died\n\n1 9 6 0 -\n\nCOBOL (COmmon Business-Oriented Language) Design Process (late 1959 - ) Names up to 12 characters, with embedded hyphens; English names for arithmetic operators (no arithmetic expressions) Verbs the first word in every statement; Design committee members from computer manufacturers and DoD ; Design goals: to work for business applications (based on FLOW-MATIC) to look like simple English -- easy to use at expense of being powerful; to broaden the base of computer users;\n\nFORTRAN IV (1960-62) Explicit type declarations; Logical selection statement; Subprogram names could be parameters;\n\nALGOL 60 (1960) an effort to design a universal language - portability; New features: Block structure (local scope) Two parameter passing methods; Subprogram recursion; Stack-dynamic arrays; No I/O or string handling;\n\nAPL: A Programming Language (1960) Early dynamic language; Designed as a hardware description language at IBM by Ken Iverson; Highly expressive (many operators for scalars and arrays of n-dimensions) Programs are very difficult to read; Still in use; minimal changes;\n\nSNOBOL (1962) Early dynamic language; Designed as a string manipulation language at Bell Labs; Powerful operators for string pattern matching; Slower than alternative languages (no longer used for writing editors) Still used for certain text processing tasks;\n\nBASIC (1964) The beginning of timesharing - Free and private access; Designed at Dartmouth for non-science students - 1st widely used timesharing language ; User time more important than computer time - Fast turnaround for homework; Easy to learn and use for non-science students: pleasant and friendly; Current popular dialect: Visual BASIC\n\nPL/I (1964) Initially called NPL (New Programming Language) changed to PL/I in 1965; Designed by IBM and SHARE: Everything for Everybody ; Computing situation in 1964 (IBM's point of view) 1) Scientific computing IBM 1620 and 7090 computers Fortran; 2) SHARE user group Business computing IBM 1401, 7080 computers COBOL; ; By 1963 scientific users began to need more elaborate I/O like COBOL and business users began to need floating point and arrays ; Two kinds of computers, languages, and support staff--too costly; The solution: Build a new computer to do both (IBM 360) and design a new language for it ; PL/I designed in 5 months by 3 members from IBM, 3 members from SHARE; Initial concept - an extension of Fortran IV;\n\nFORTRAN 66 - First ANSI standard for a high level language ;\n\nSIMULA 67 (1967) Historical Importance: designed for system simulation ; Introduced concept of data abstraction; Designed primarily for system simulation in Norway by Nygaard and Dahl; Based on ALGOL 60 and SIMULA I; Primary Contributions: Co-routines - a kind of subprogram; Implemented in a structure called a class; Classes are the basis for data abstraction; Classes are structures that include both local data and functionality;\n\nALGOL 68 (1968) Orthogonal Design; From ALGOL 60 but not a superset of that language; Source of several new ideas but language never achieved widespread use; Design is based on the concept of orthogonality; A few principle concepts, few combining mechanisms; Contributions: User-defined data structures; Reference types; Dynamic arrays (called flex arrays) Comments\n\n1 9 7 0 -\n\nPROLOG (1970) Programming Based on Formal Logic ; Developed at University of Aix-Marseille, France ; Non-procedural; declarative rather than imperative; Can be summarized as being an intelligent database system that uses an ; inferencing process to infer the truth of given queries; Highly inefficient, small application areas -- formal language research; AI;"
    }
}