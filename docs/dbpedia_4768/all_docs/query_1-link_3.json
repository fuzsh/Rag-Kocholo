{
    "id": "dbpedia_4768_1",
    "rank": 3,
    "data": {
        "url": "https://bulldogjob.com/readme/why-algol-was-an-important-programming-language",
        "read_more_link": "",
        "language": "en",
        "title": "Why ALGOL was an important programming language?",
        "top_image": "https://cdn.bulldogjob.com/system/readables/covers/000/004/237/original/180424_thestoryosalgol.png",
        "meta_img": "https://cdn.bulldogjob.com/system/readables/covers/000/004/237/original/180424_thestoryosalgol.png",
        "images": [
            "https://bulldogjob.com/_next/static/media/bulldogjob-logo.34bbbab5.svg",
            "https://cdn.bulldogjob.com/system/authors/photos/000/000/055/square/dsgsgd.png",
            "https://cdn.bulldogjob.com/system/readables/covers/000/004/237/max_res/180424_thestoryosalgol.png",
            "https://cdn.bulldogjob.com/system/photos/files/000/013/383/original/algol-creators.png",
            "https://cdn.bulldogjob.com/system/photos/files/000/013/384/original/electrologica_x1.jpg",
            "https://bulldogjob.com/next-images/report-vertical-en.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Adam Kukołowicz"
        ],
        "publish_date": "2024-04-23T10:00:00+02:00",
        "summary": "",
        "meta_description": "ALGOL is a more interesting language than you think, both in terms of its story and legacy.",
        "meta_lang": "en",
        "meta_favicon": "/favicons/apple-icon-57x57.png",
        "meta_site_name": "",
        "canonical_link": "https://bulldogjob.com/readme/why-algol-was-an-important-programming-language",
        "text": "Today, I'm taking you on a journey to the past, back to the late 1950s, when the foundations of computer science were being laid, and when computers were seen as the future. As we talk about this period today, names like FORTRAN, Lisp, and COBOL often come up.\n\nYet, there was ALGOL, a pretty obscure, but really important language in the history of programming. The story of the language deserves to be told.\n\nWhat did the world of programming look like then?\n\nIt was a world vastly different from today, mainly because most coding was done in assembly language (or not even that in Europe). If any of you have programmed in assembly, you know it’s a laborious process. That's how it was in the 1950s. At that time, the first programming languages were being developed to make programming easier. Most of these languages had specific applications and were often tied directly to the architecture of the computers on which they ran. Additionally, they were modeled on natural languages and hard to port between platforms.\n\nIn 1955 a symposium on automated computing was held in Darmstadt, Germany. A few of the speakers talked about the need for better and more expressive programming languages. Ideally, that would be one algorithmic language that was platform-independent a that would allow researchers from around the world to collaborate on new computing methods. A universal language was needed, so we could stop thinking in terms of bits and registers and start thinking in terms of algorithms and data structures.\n\nGesellschaft fur Angewandte Mathematik und Mechanik (GAMM) or \"Society for Applied Mathematics and Mechanics\" thought it was a great idea, especially the universal part. They realized that creating a language on their own was possible, but it for sure wouldn't be accepted worldwide.\n\nThat's why they decided to reach out in 1957 to the American Association of Computing Machinery (ACM) and invite them to collaborate. It was a good call, since Americans started to think about similar idea at the time. They agreed to create a brand new language together.\n\nALGOL Enters the Stage\n\nALGOL stands for Algorithmic Language. Initially, it was to be called IAL (International Algebraic Language), but it was soon realized that the acronym was not very convenient. The first version emerged from a meeting of an international committee of scientists from Europe and the United States in Zurich in 1958—hence ALGOL 58. It wasn’t quite a programming language in today’s sense. As John Backus, one of ALGOL's creators, wrote:\n\nThe ACM-GAMM conference in Zurich had two main motives in creating IAL:\n\n(a) to provide a way to communicate numerical methods and other procedures among people\n\n(b) to provide a way to execute a fixed process on various machines.\n\nIn 1958, the goal was to create a standard description of what was happening on computers. Although ALGOL 58 had several implementations, it did not gain wide recognition. It introduced the concept of compound statement, but its use was limited only to control flow. Other than that it had types, loops, conditionals, procedures, and switches. It soon became clear that the outcomes were not satisfying.\n\nBy June 1959, it was evident that further work was needed, and broad consultations were announced to gather material for another meeting, where a new version of the language would be developed.\n\nThe Americans focused on the practical merits of the language—mainly because, in the USA, programming was slowly becoming a profession and the practical merits of ALGOL 58 were not great. Europeans, however, made more proposals concerning the foundations of the language. That was the beginning of ALGOL 60.\n\nYes, you guessed it. ALGOL 60, because it was proposed in 1960. The meeting this time took place in Paris, with thirteen scientists participating. Let me quickly introduce them to show the caliber of people involved:\n\nFriedrich L. Bauer - creator of the term “software engineering”\n\nPeter Naur - editor of the ALGOL 60 report, co-author of the Backus-Naur notation (although he strongly disclaimed this)\n\nHeinz Rutishauser - mathematician, pioneer of modern numerical analysis and computer science\n\nKlaus Samelson - a pioneer in the fields of compilers and stack algorithms\n\nBernard Vauquois - a pioneer in machine translation\n\nAdriaan van Wijngaarden - father of Dutch computer science\n\nMichael Woodger - co-creator of the Pilot ACE, one of the first British computers, co-creator of the Ada language\n\nJohn W. Backus - creator of FORTRAN (led the team), creator of the Backus-Naur notation, and creator of the function-level programming paradigm (not to be confused with functional programming—a very interesting concept that I had never heard of)\n\nJulien Green - also involved in ALGOL 58\n\nCharles Katz - worked on compilers for the first computers\n\nJohn McCarthy - creator of the term “artificial intelligence” and researcher in the field, for which he received the Turing Award; creator of Lisp\n\nAlan Perlis - the first recipient of the Turing Award, awarded for his contributions to advanced programming techniques and compiler construction\n\nJoseph Henry Wegstein - worked on automatic data processing and fingerprint recognition, participated in the work on COBOL\n\nAlan Perlis described the Paris meetings in this way:\n\nThe meetings were exhausting, interminable, and exhilarating. One became aggravated when one's good ideas were discarded along with the bad ones of others. Nevertheless, diligence persisted during the entire period. The chemistry of the 13 was excellent. On every point at issue there were opinions and solutions, with descriptive prose to support them that ranged from the technically clever to the breathtakingly simple. But there was rarely a complete cancellation. Progress was steady and the output, ALGOL 60, was more racehorse than camel.\n\nThe photo shows six participants of the Paris conference in 1960, dedicated to ALGOL. In the top row: John McCarthy, Friedrich Bauer, Joseph Wegstein. In the bottom row: John Backus, Peter Naur, Alan Perlis.\n\nImagine thirteen scientists, engineers, and researchers from several countries. Each threw in their ideas on what the language should look like (okay, preliminary proposals had been selected earlier). In 1960, we were dealing with greenfield - there were no limitations arising from history because the field was new. Although there was already a previous version of ALGOL and FORTRAN and the modest languages of the 50s, all of them lacked a lot in terms of describing algorithms or expressiveness. So there was plenty of room for improvement. From all this, it was necessary to crystallize a coherent, pure language that would be the basic tool used by computer scientists in everyday work. What did the committee come up with?\n\nALGOL 60 Features\n\nCertainly, one of the more spectacular new features was the introduction of blocks. Blocks were denoted with keywords begin and end, Additionally, a block now had its own scope. This also allowed further development of the compound instruction originally introduced in ALGOL 58.\n\nALGOL was the first language to allow the definition of nested functions, which had their lexical scope.\n\nThe authors of the report recommended implementing 9 standard functions: abs, sign, sqrt, sin, cos, arctan, ln, exp, and entier. It's not a lot, considering the standard libraries of contemporary languages. This shows how pure ALGOL was.\n\nAnother important tool was recursion. It was proposed by John McCarthy, who had just completed work on Lisp, where he included this possibility. However, the proposal met with considerable concern from the committee, and the attending members rejected the introduction of the keyword recursive. Ultimately, recursion made it into the standard implicitly - the ALGOL specification does not prohibit recursive calls.\n\nAnother curiosity was two strategies for passing parameters. The first is the well-known pass-by-value. The second, however, is pass-by-name. In this strategy, arguments are not invoked until they appear in the body of the procedure. Theoretically, this can provide a performance advantage, but it creates certain challenges for compilers.\n\nALGOL Reception\n\nThe report produced in 1960 was a wonderful thing, but we must not forget that it was only a dozen-page description of the language. There was no reference implementation. Moreover, ALGOL 60 did not specify input and output operations at all! Thus, it's hard to talk about a \"Hello World\" program written in ALGOL 60. The report itself was incredibly concise, containing very few superfluous words, and—as Alan Perlis said:\n\nLike the Bible, it was meant not merely to be read, but to be interpreted.\n\nSo, one of the challenges waiting for the creators of individual implementations was to interpret input and output operations in the spirit of the specification.\n\nThe first compiler was X1 ALGOL 60, developed by Edsger Dijkstra (yes, the same one from the algorithm lectures) and Jacob Zonneveld - for the Dutch computer Electrologica X1.\n\nElectrologica X1, circa 1960\n\nBy 1963, compilers had appeared for several of the computers of the time, including UNIVAC and Elliot (the compiler creator was Tony Hoare). In the second half of the 60s, implementations of ALGOL also appeared on computers from the Soviet bloc. From 1965, you could program in ALGOL on the MINSK computers, and from 1967 on the Polish computer ZAM.\n\nThe biggest problem with ALGOL was the lack of support. FORTRAN, developed by IBM, was not as advanced, but it had full support from the parent company. IBM themselves wrote reference implementations for subsequent platforms, making it seem more suitable for commercial applications—it was standardized.\n\nThis is how Robert Bemer spoke about the new language in 1961:\n\nNo reasonable mechanism for maintenance seems to exist. No one seems to be able to answer the basic question, ”What is ALGOL?” I foresee a difficult time for ALGOL unless a revised maintenance procedure is devised. The language is too general and has too many ambiguities.\n\nBemer was right in that the report indeed had several omissions and lacked a mechanism for correcting them. Ultimately, neither the creators nor those interested in ALGOL established either a support mechanism or a development mechanism, leading to the fiasco of ALGOL 68, which was rejected by the community.\n\nWhile ALGOL did not achieve spectacular commercial success, scientists received it very enthusiastically. Hence, it became the main language for describing algorithms for the next 20-30 years. Its clean and expressive syntax facilitated communication among people.\n\nThe lack of reference implementations, however, made using the language for human-machine communication difficult. Since the computer industry in America was much more developed than in Europe, practical considerations were paramount there. The issue of support and compatibility was crucial. In Europe, however, computer science was almost exclusively the domain of research centers. Scientists had different priorities, and the new language was very well-suited for researching algorithms. Thus, ALGOL was much better received on the Old Continent.\n\nWhat is the legacy of ALGOL?\n\nThe impact of ALGOL on later languages was huge. It inspired most imperative programming languages. Among the more significant ones are Pascal, Simula (the first object-oriented language), and C.\n\nIn essence, all subsequent programming languages include blocks and recursion. Work on ALGOL 68 also brought about case expressions and the concept of records along with references, as well as pass-by-reference.\n\nALGOL 60 was the first programming language to be defined in BNF, or Backus-Naur form. It's basically about building a language from already defined concepts—with minimal references to natural language.\n\nThe general form is:\n\n<metalinguistic variable> ::= <form>\n\nSimple example:\n\n<digit> ::= 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n\nMore complex example:\n\n<if clause> ::= if <Boolean expression> then <unconditional statement> ::= <basic statement> | <compound statement> | <block> <if statement> ::= <if clause> <unconditional statement> <conditional statement> ::= <if statement> | <if statement> else <statement> | <if clause> <for statement> | <label>: <conditional statement>\n\nThe first example doesn't look too impressive, but the second gives a better understanding of the possibilities. Thanks to this notation, one can effectively describe a programming language without external context. Since then, this notation and its developments have become the standard for describing programming languages. You can see it everywhere, for example in Python or JavaScript.\n\nALGOL became a catalyst in the development of compilers. The first compilers were simple translators of formulas into machine code, but ALGOL required something more—procedures, variable-sized arrays, or recursion didn't fit into the sequential translation technique. To implement them correctly and efficiently, new, much more advanced compilation techniques had to be developed.\n\nAll this means that although it has completely fallen out of use, ALGOL was an extraordinary language. The effort put into its development and implementation elevated computer science to another level. One can imagine that development was inevitable. However, it seems to me that thanks to the quality of ALGOL, it was somewhat faster. Many concepts could be transferred painlessly to other programming languages or developed further—and that's what we benefit from today."
    }
}