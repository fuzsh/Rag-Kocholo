{
    "id": "dbpedia_7729_2",
    "rank": 24,
    "data": {
        "url": "https://research.ibm.com/haifa/dept/vst/tutorial_ccs2023.html",
        "read_more_link": "",
        "language": "en",
        "title": "Tutorial: Advanced HE packing methods with applications to ML.",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://research.ibm.com/haifa/dept/vst/images/hayim_shaul.jpg",
            "https://research.ibm.com/haifa/dept/vst/images/Ehud Aharoni.png",
            "https://research.ibm.com/haifa/dept/vst/images/Nir Drucker.jpg",
            "https://research.ibm.com/haifa/dept/vst/images/hayim_shaul.jpg",
            "https://research.ibm.com/haifa/dept/vst/images/Ehud Aharoni.png",
            "https://research.ibm.com/haifa/dept/vst/images/Nir Drucker.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Advanced homomorphic encryption packing methods with applications to machine learning"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Advanced homomorphic encryption packing methods with applications to machine learning",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Tutorial Description\n\nTopics\n\nSummary\n\nFHE\n\nSecurity models and applications\n\nSIMD packing:\n\n- Challenge and motivation\n\n- Tile tensors\n\nExamples\n\n- Matrix multiplication algorithms\n\n- Simulating large ciphertexts\n\nResearch opportunities\n\nIn Detail\n\nFHE, security models and applications: FHE is an encryption method that allows you to apply additions and multiplications to ciphertexts without decrypting them. This leads to interesting models where two or more parties can collaboratively compute a function over their private data without sharing it. As an example, this allows for inference-as-a-service, in which a client encrypts and uploads her (private) data to a server that uses a pre-trained model to perform inference over the data. In this situation, the server is not exposed to the sensitive data (making it easier to comply with privacy regulations), yet the client receives the resulting computed analytics, which she can decrypt. Traditionally, FHE was considered too slow compared to other privacy-preserving solutions (such as multi-party computations (MPC) or garbled circuit (GC)). However, in recent years, the run-times of FHE solutions have improved dramatically. One of the techniques that boosted FHE performance is packing multiple values into the slots of a single ciphertext. Operators applied on ciphertexts are then applied slot-wise in a single instruction multiple data (SIMD) manner. Taking advantage of these slots became a subject of research and multiple packing schemes were proposed.\n\nIn this tutorial, we discuss: (i) the challenges of designing an algorithm that utilizes slots; (ii) how packings can affect the run-time and RAM requirements of an algorithm; (3) how to write FHE code that can easily switch from one packing to another, and; (4) how to choose the packing technique for your protocol.\n\nSIMD packing, challenges, motivation, and tile tensors: As hinted above, using SIMD improves the running time of an algorithm. Alas, utilizing SIMD is not always trivial. For example, even for the simple problem of matrix multiplication, several packing methods were proposed in several previous works ([1, 6, 9] to name a few). For more complex systems such as neural networks, the problem becomes harder and it's not always clear from the beginning which packing method will provide the best run-time results. To make matters worse, for the same problem, different packing schemes may be better, depending on the parameters of the input.\n\nUntil recently, changing the packing methods required rewriting a lot of the code. This made writing practical solutions with FHE much more expensive and time consuming. In [1, 3], a packing-oblivious language was proposed in which an algorithm is described at a high level, and the details of the packing are filled in later by the compiler, possibly even during run-time. Using the language proposed by [1], an algorithm can be described as operating on tensors. The details of how tensors are packed into ciphertext is given in a concise manner called a tile tensor shape. Changing the packing can then be done easily by changing the shape of the tile tensor.\n\nSpecific demonstrations: As an example, we will show how different packing methods change the way a matrix is packed. In addition, we explore packing for matrix-matrix multiplication, and simulating large ciphertext.\n\nAutomating the packing process: As mentioned above, different packing methods yield different run-times and RAM requirements. To measure run-time, we consider two metrics: (i) latency - the time passed from receiving an input until delivering the output, and (ii) throughput - the number of outputs we can deliver in a given amount of time, give infinite inputs. When implementing a system, we want to choose the packing method that complies with our RAM requirements and achieves the best possible run-time. We describe an optimizer module that scans all possible shapes and reports the best shape that complies with our RAM requirements. Our optimizer considers different shapes for the input and measures the running time and RAM requirements for each shape. To speed up the execution of the optimizer we also consider gradient-descent heuristics.\n\nDemonstration\n\nThe tutorial will be accompanied by online (interactive) demonstrations using HELayers [2, 4, 7, 10], running locally on the participantsâ laptops or through pre-defined Google Colab notebooks.\n\nGoals\n\nExplore and experience a new and exciting data structure called tile tensors that enable writing efficient, non-interactive homomorphic encryption solutions.\n\nExperiment how homomorphic encryption packing affects run-time and memory.\n\nLearn a new language to write packing-oblivious code that allows switching between packing methods easily.\n\nLearn how to use the HELayers library (as a demonstration of the tile tensors technique) to write HE applications, specifically a PPML solution.\n\nExpected background and prerequisites of participants\n\nThis tutorial is intended for researchers and practitioners from academia, government, industry, and anyone else interested in privacy-preserving applications. We will focus on the technical aspects of packing techniques and efficiency, and therefore the material will not be relevant to those interested in legal, ethical, or sociological security considerations. Nonetheless, social scientists and policymakers are welcome to participate and hear about recent real-life applications of privacy-preserving techniques. Prerequisite knowledge: This tutorial assumes college-level knowledge of mathematics, specifically linear algebra. We will demonstrate code in Python and encourage the participants to learn by writing code. Basic Python knowledge is therefore required. The tutorial will include a brief general overview of homomorphic encryption, which is sufficient for achieving the tutorialâs goals. The demonstrations include convolutional neural networks, which we present as a series of algebraic operators. Thus, a deep understanding of machine learning concepts is not required."
    }
}