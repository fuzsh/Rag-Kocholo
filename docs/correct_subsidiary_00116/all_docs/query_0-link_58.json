{
    "id": "correct_subsidiary_00116_0",
    "rank": 58,
    "data": {
        "url": "https://www.cisco.com/c/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc.html",
        "read_more_link": "",
        "language": "en",
        "title": "PTP and SyncE basics with Cisco IOS XR Configuration",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.cisco.com/etc/designs/cdc/fw/i/TAC_lg-icon.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-00.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-01.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-02.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-03.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-04.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-05.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-06.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-07.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-08.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-09.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-10.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-11.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-12.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-13.jpeg",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-14.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-15.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-16.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-17.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-18.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-19.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-20.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-21.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-22.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-23.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-24.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-25.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-26.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-27.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-28.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-29.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-30.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-31.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-32.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-33.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-34.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-35.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-36.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-37.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-38.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-39.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-40.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-41.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-42.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-43.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-44.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-45.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-46.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-47.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-48.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-49.png",
            "https://www.cisco.com/c/dam/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc-50.png",
            "https://www.cisco.com/etc/designs/cdc/fw/i/TAC_lg-icon.png",
            "https://www.cisco.com/c/dam/cdc/i/Feedback_OceanBlue.png",
            "https://www.cisco.com/etc/designs/cdc/fw/i/icon_lock_small.png",
            "https://cisco.112.2o7.net/b/ss/cisco-mobile/5/12345"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-11-30T00:30:14",
        "summary": "",
        "meta_description": "This document describes the working of PTP and SyncE for Cisco IOS® XR devices in 8275.1 and 8275.2 telecom profiles.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "Cisco",
        "canonical_link": "https://www.cisco.com/c/en/us/support/docs/ios-nx-os-software/ios-xr-software/217579-configure-ptp-and-synce-basics-with-cisc.html",
        "text": "Introduction\n\nThis document describes the working of Precision Time Protocol (PTP) and Synchronous Ethernet (SyncE) with sample configurations, examples, and troubleshooting commands for Cisco IOS® XR devices in 8275.1 and 8275.2 telecom profiles.\n\nBackground Information\n\nA clock for us is a wall clock or a wristwatch, but for networking devices, it is a periodic signal of alternate 0’s and 1’s which is used to sample the data bits. Just like a seconds hand in the clock has an angular movement to represent a second, a pair of 0 and 1 represents T (time period [T=1/frequency]). In order to generate this clock, network devices use a crystal oscillator which has a ±100 ppm error (parts per million. for example, a clock with the frequency of 250 MHz and 100 ppm will have a frequency range of 249.975 MHz to 250.025 MHz.) in generating the clock signal. So, ideally, the clock is not completely periodic but is sufficient for the requirement of sampling the data signals out of the interfaces.\n\nTelecom networks (3G/4G/5G) use a very high quality (stratum) clock and all the base stations (NodeB’s/eNodeB’s and so on) should get synchronized to this clock with as little error/delay (approximately 1µs) as possible.\n\nOne option is to install a GPS at all the base stations, which is quite costly and less secure as GPS works on satellite systems.\n\nThe second option is to use the existing Networking Equipment (NE) to transfer the clock information along with the data signal. This option is very cost-effective as the data is already being transferred by NEs and the use of NEs for clock signal transfer will make it cheaper and more secure. However, clock quality might not be as good as compared to the earlier GPS option and will vary on the profile/protocol used in NEs as well as the congestion in the network.\n\nImportance of Phase/Frequency Synchronization\n\nA message signal (for example, voice signal) modulated with a high frequency (carrier signal) wave at the transmitter end must be demodulated at the receiver end with the same carrier signal used at the transmitter end. If any change/offset in frequency or phase of the carrier wave happens at the receiver, the message signal will be corrupted. However, a little offset is always expected between the Rx carrier wave and the Tx carrier wave.\n\nAn analogy is to use a safe box to send a message and lock it with a key. If anyone wants to read the message in the safe box, the same key must be used to unlock the box at the receiver end. If the replica key has any distortions/disfigurement, the message cannot be read.\n\nAcceptable offsets for various telecom services are:\n\nNetwork Clock Synchronization\n\nSynchronization is the alignment of clocks to the same time/phase and frequency.\n\nSynchronization for clocking can be categorized into frequency synchronization (achieving = / = where = also called as same rate), phase synchronization (at same time), and time synchronization (time of day).\n\nFrequency Synchronization\n\nAll the NEs shall match their clock’s frequency to a source clock (derived from a MasterClock).\n\nFrequency synchronization for NE can be achieved with SyncE or PTPv2 which will be discussed further in this section.\n\nSyncE works on deriving the frequency from data packets received on the interface (works on the physical layer) along with ESMC packets received (one packet per second approximately) on the interface which describes the quality of the clock. So, it does not add any control packets and is not affected by traffic congestion which is the best aspect of SyncE.\n\nPTP runs on packets, so there will be a control packets flow and the packets will get affected by congestion which adds to the delay.\n\nPhase Synchronization\n\nPhase synchronization is about the alignment of these clock signals. We can see that the above frequency synchronized signals are not yet aligned, so they have a phase offset.\n\nPTPv2 is used to carry the phase information across the network.\n\nTime Synchronization\n\nTime synchronization, also called Time of day, simply has the same time in all the NEs. That is, t1=t2.\n\nNTP and PTP are used to transfer time information in the network. While NTP provides millisecond accuracy, PTP can provide up to sub-microsecond accuracy.\n\nTime synchronization and phase synchronization are often used synonymously in networking as PTP used to phase synchronize will achieve time synchronization.\n\nNTP will not be part of our discussion now.\n\nSyncE\n\nBasic Principle of SyncE\n\nSyncE works on the basic principle of extracting the clock frequency from the data received on a port.\n\nA simple example is illustrated here. The data signal is processed with the local oscillator and the output data is sent out of the Tx port. You can observe that the clock frequency is present in the Data signal transmitted on the port. SyncE works on the principle of reverse processing the signal received on the Rx port and getting the frequency information of the transmitted clock.\n\nSyncE is a recommendation from ITU-T on how to deliver a frequency in a network. According to the recommendation, the frequency will be recovered from the bitstream in the physical layer as pointed out earlier. The clock that will be distributed in the chain is called the primary reference clock (PRC) and all clocks in the network shall be traceable to that clock. To get a traceable clock all nodes in a chain between the MasterClock and the end device need to be implemented with a synchronous Ethernet Equipment Clock (EEC) according to the SyncE recommendations. The performance of the recovered clock will not depend on the network load since it does not synchronize with any specific packet.\n\nThe MasterClock NE takes external input timing references that come from the network clock (SSU or BITS). These references are then used as input to the EEC clock, typically located on the central timing card of the NE. The EEC output timing reference is then used to sample data and send out the traffic on the SyncE enable Tx port.\n\nAt the SlaveClock NE, the clock is recovered within the transceiver clock data recovery (CDR). In some cases where the RX clock is not available at the transceiver, the use of an external CDR might be required to recover the clock. The clock is then sent through the backplane to reach the SlaveClock’s central timing card. This timing reference then becomes a reference to the EEC (also known as a line-timing reference). As shown in the SlaveClock NE, an EEC can accept line and external references, as well as the input of a ±4.6 ppm local oscillator (used in situations where there are no line or external references available). From this point on, the SlaveClock NE then becomes the MasterClock NE for the next downstream NE, and synchronization is transported on a node-to-node basis, where each node participates in recovery and distribution.\n\nEthernet Synchronization Messaging Channel\n\nThe Ethernet Synchronization Messaging Channel (ESMC) is an ITU-T defined Ethernet slow protocol (that is., the messages are sent to the multicast Ethernet destination address 01-80-C2-00-00-02 and use Ether Type 88-09) to prevent the messages from leaking from a synchronized link to another link.\n\nIt carries the Synchronization Status Message (SSM) information which is the quality level (QL) of the transmitting clock. For example: If the upstream device is in sync with a PRC clock, then the QL value received is QL-PRC and the corresponding SSM value is 0010.\n\nESMC information PDUs are sent periodically at a rate of one PDU per second. Lack of reception of an ESMC PDU within a five-second period results in the SSF=true (QL=QL-FAILED). The default (initial) value for the QL is DNU (SSM=1111) and must only change when a valid QL TLV is received.\n\nWe need to note that if a device is dual-homed and the source of signal for both upstream devices is PRC, then the QL received on the device from both links is QL-PRC. Hence, we need to prioritize the links accordingly to choose the right upstream device with regard to hops, links, and so on.\n\nThe MasterClock-SlaveClock synchronization over several NEs with multiple possible synchronization inputs for protection of synchronization could lead to timing loops between NEs. In order to avoid timing loops, an NE should insert an SSM value of DNU in the direction of the NE, which is used as the actual synchronization source for the NE clock.\n\nSyncE with LAG\n\nSyncE works on the Physical layer and the ESMC packets are also carried by Ethernet slow protocol. LAG is another function that utilizes slow protocols and LAG operates above ESMC. Processing of ESMC messages is therefore required on each synchronous Ethernet-enabled link in the LAG group.\n\nIt is also important to note that the use of parallel links, such as the case with LAG, needs to be carefully considered due to the potential for the creation of timing loops.\n\nIdeally, it is sufficient to run it on the single-member link of the bundle but otherwise, It is left to the operators to configure several synchronous Ethernet-enabled ports.\n\nPTPv2/1588v2\n\nIEEE 1588 is defined by the Institute of Electrical and Electronics Engineers (IEEE) in 2002 as Precision Clock Synchronization Protocol (PTP) for networked measurement and control systems. It is called the Precision Time Protocol (PTP) for short.\n\nIEEE 1588v1 applies to industrial automation and tests and measurements fields. With the development of IP networks and the popularization of 3G networks, the demand for time synchronization on telecommunications networks has increased. To satisfy this need, IEEE drafted IEEE 1588v2 based on IEEE 1588v1 in June 2006, revised IEEE 1588v2 in 2007, and released IEEE 1588v2 at the end of 2008.\n\n1588v2 is a time synchronization protocol that allows for highly accurate time synchronization between devices. It is also used to implement frequency synchronization between devices.\n\nThis packet-based synchronisation mechanism combines frequency and phase synchronisation at sub-microsecond levels, with ToD distribution capabilities via the efficient mechanism of packet exchanges\n\nThe major weakness of PTP is also due to its packet nature, as the synchronisation packets used by PTP are forwarded in the network between MasterClock and hosts, which are subject to all network events such as frame delay (latency), frame delay variation (packet jitter) and frame loss. Even with the best practice of applying high priority to synchronisation flows, these synchronisation packets will still experience congestion and possible routing and forwarding issues such as out-of-sequence and route flaps.\n\nBasic Working Principle of PTP\n\nWe send the time (hh:mm:ss) in a packet and we use packet flow round trip time to find the delay in transmission of a packet and correct the clock time by adjusting with the half of round trip delay.\n\nWorking of PTP\n\nPTP uses a hierarchical MasterClock-SlaveClock architecture for clock distribution.\n\nIt specifies how the real-time clocks in the system synchronize with each other. These clocks are organized into a MasterClock−SlaveClock synchronization hierarchy with the clock at the top of the hierarchy the MasterClock determining the reference time for the entire system. The synchronization is achieved by exchanging PTP timing messages, with the SlaveClocks using the timing information to adjust their clocks to the time of their MasterClock in the hierarchy.\n\nPTP was designed assuming a multicast communication model. PTP also supports a unicast communication model as long as the behaviour of the protocol is preserved. PTP assumes that Announce messages are periodically sent by one port and delivered to all other ports of the ordinary or boundary clocks within a communication path. If the communication path consists of more than two ports, the assumption is that Announce messages are either sent in multicast or the Announce information is replicated to all ports in the communication path using unicast messages. PTP ports discover other ports within a communication path through the receipt of multicast Announce messages.\n\nThe protocol executes within a logical scope called a domain. All PTP messages, data sets, state machines, and all other PTP entities are always associated with a particular domain id\n\nThe protocol defines the event and general PTP messages. Event messages are timed messages i.e., an accurate timestamp (time recorded on the device at entry/exit point but it is not necessary that the message carries the time t) is generated at both transmission and receipt. General messages do not require accurate timestamps.\n\nPTP Domains\n\nA domain consists of a logical grouping of clocks communicating with each other using the PTP protocol.\n\nPTP domains are used to partition a network within an administrative entity. The PTP messages and data sets are associated with a domain and therefore, the PTP protocol is independent for different domains.\n\nMessage Exchange Pattern\n\nThe MasterClock sends a Sync message to the SlaveClock and notes the time at which it was sent.\n\nThe SlaveClock receives the Sync message and notes the time of reception.\n\nThe MasterClock conveys to the SlaveClock the timestamp by:\n\nEmbedding the timestamp in the Sync message. This requires some sort of hardware processing for highest accuracy and precision.\n\nEmbedding the timestamp in a Follow_Up message.\n\nThe SlaveClock sends a Delay_Req message to the MasterClock and notes the time at which it was sent.\n\nThe MasterClock receives the Delay_Req message and notes the time of reception.\n\nThe MasterClock conveys to the SlaveClock the timestamp by embedding it in a Delay_Resp message.\n\nPTP time accuracy is degraded by asymmetry in the paths taken by event messages. Specifically, the time offset error is 1/2 of the asymmetry.\n\nAsymmetry is not detectable by PTP. However, if known, PTP corrects for asymmetry. Asymmetry can be introduced in the physical layer, e.g., via transmission media asymmetry, by bridges and routers, and in large systems by the forward and reverse paths traversed by event messages taking different routes through the network. Systems should be configured, and components selected to minimize these effects guided by the required timing accuracy. In single subnet systems with distances of a few meters, asymmetry is not usually a concern for time accuracies above a few 10s of ns.\n\nVarious Packet Types\n\nThe set of event messages consists of:\n\nSync - Used for synchronization of time between MasterClock and SlaveClock. In Two-step, Sync messages do not carry time but the time will be time-stamped at the MasterClock and will be carried in Follow_Up message. In One-step, the Sync message will carry time. Old devices/hardware couldn’t support measuring and carrying the exit time point when a message was delivered out a port, so two-step was because of hardware limitation. Nowadays, hardware can record the exit time point and send it inside the Sync message. One-step is backwards compatible with two-step.\n\nDelay_Req - A Delay_Req message is a request from the receiving/SlaveClock node to return the time at which the Delay_Req message was received, using a Delay_Resp message. It will be used to calculate the transit time between SlaveClock and MasterClock. This message is time-stamped at the SlaveClock.\n\nPdelay_Req - A Pdelay_Req message is transmitted by a PTP port to another PTP port as part of measuring port-to-port propagation time to determine the delay on the link between them. It is used by P2P transparent clock to calculate the per-hop link delay.\n\nPdelay_Resp - A Pdelay_Resp message is transmitted by a PTP port in response to the receipt of a Pdelay_Req message.\n\nThe set of general messages consists of:\n\nAnnounce - This message is used by the Best MasterClock Algorithm (BMCA) to generate MasterClock-SlaveClock topology. It is used to elect the best MasterClock and keep it in place.\n\nFollow_Up - This message type is used in the two-step mode. It carries the time. (Sync exit time on MasterClock node) in its message.\n\nDelay_Resp - It is used to calculate the transit time from MasterClock to SlaveClock. It carries the time (exit time of Delay_Resp message) in the message.\n\nPdelay_Resp_Follow_Up - This is similar to the Follow_Up message but it is generated by a P2P transparent clock.\n\nManagement: Not part of our discussion.\n\nSignaling - For communication between clocks for all other purposes. For example, signaling messages can be used for the negotiation of the rate of unicast messages between a MasterClock and its SlaveClocks.\n\nThe Sync, Delay_Req, Follow_Up, and Delay_Resp messages are used to generate and communicate the timing information needed to synchronize ordinary and boundary clocks using the delay request-response mechanism.\n\nThe Pdelay_Req, Pdelay_Resp, and Pdelay_Resp_Follow_Up messages are used to measure the link delay between two clock ports implementing the peer delay mechanism. The link delay is used to correct timing information in Sync and Follow_Up messages in systems composed of peer-to-peer transparent clocks.\n\nOrdinary and boundary clocks that implement the peer delay mechanism can synchronize using the measured link delays and the information in the Sync and Follow_Up messages. The Announce message is used to establish the synchronization hierarchy. The management messages are used to query and update the PTP data sets maintained by clocks. These messages are also used to customize a PTP system and for initialization and fault management. Management messages are used between management nodes and clocks (will not be part of our discussion).\n\nThe signalling messages are used for communication between clocks for all other purposes. For example, signalling messages can be used for the negotiation of the rate of unicast messages between a MasterClock and its SlaveClocks.\n\nPTP Device Types\n\nThere are five basic types of PTP devices, as follows:\n\nOrdinary clock - Can only be a Grand MasterClock (GM) or only a SlaveClock.\n\nBoundary clock - Can be both SlaveClock and GM\n\nEnd-to-end transparent clock - The end-to-end transparent clock forwards all messages just as a normal bridge, router, or repeater. However, for PTP event messages, the residence time bridge, shown in Figure below, measures the residence time (the time the message takes to traverse the transparent clock) of PTP event messages. These residence times are accumulated in a special field, the correction Field, of the PTP event message or the associated follow-up message. This correction is based on the difference in the timestamp generated when the event message enters and leaves the transparent clock.\n\nPeer-to-peer transparent clock - Adds the residence time as well as link transit delay time to ptp messages by using the peer delay mechanism (generates its own delay-req-resp packets to calculate the peer link delay).\n\nManagement node (not part of our discussion).\n\nEstablish the MasterClock−SlaveClock Hierarchy\n\nWithin a domain, each port of an ordinary and boundary clock executes an independent copy of the protocol state machine. For “state decision events,” each port examines the contents of all Announce messages received on the port. Using the best MasterClock algorithm, the Announce message contents and the contents of the data sets associated with the ordinary or boundary clock are analysed to determine the state of each port of the clock.\n\nPTP State Machine\n\nEach port of an ordinary and boundary clock maintains a separate copy of the PTP state machine. This state machine defines the allowed states of the port and the transition rules between states. The principal “state decision events” determining the MasterClock−SlaveClock hierarchy are the receipt of an Announce message and the end of an announce Interval (the interval between Announce messages). The port states that determine the MasterClock−SlaveClock hierarchy are as follows:\n\nINIT – Port is not yet ready to participate in PTP.\n\nLISTENING – First state when a port becomes ready to participate in PTP: port listens for PTP MasterClocks for a (configurable) period of time\n\nPRE-MasterClock – The port is about to go into MasterClock state.\n\nMasterClock – The port provides timestamps for any listening SlaveClock/boundary clocks.\n\nUNCALIBRATED – The port receives timestamps from a MasterClock, but the router's clock is not yet synchronized to that MasterClock\n\nSLAVE – The port receives timestamps from a MasterClock, and the router's clock is synchronized to that MasterClock\n\nPASSIVE – The port is aware of a better clock than the one it would advertise if it was in MasterClock state, but is not slaving off that clock\n\nBest MasterClock Algorithm\n\nThe best MasterClock algorithm compares data describing two clocks to determine which data describes the better clock. This algorithm is used to determine which of the clocks described in several Announce messages received by a local clock port is the best clock. It is also used to determine whether a newly discovered clock—a foreign MasterClock—is better than the local clock itself. The data describing a foreign MasterClock is contained in the grandMasterClock fields of an Announce message.\n\nThe data set comparison algorithm is based on pair-wise comparisons of attributes with the following precedence:\n\npriority1 - A user-configurable designation that a clock belongs to an ordered set of clocks from which a MasterClock is selected\n\nclockClass - An attribute defining a clock’s TAI traceability\n\nclockAccuracy - An attribute defining the accuracy of a clock\n\noffsetScaledLogVariance - An attribute defining the stability of a clock\n\npriority2 - A user-configurable designation that provides finer-grained ordering among otherwise equivalent clocks\n\nclockIdentity - A tie-breaker based on unique identifiers\n\nIn addition to this precedence order, the “distance” measured by the number of boundary clocks between the local clock and the foreign MasterClock is used when two Announce messages reflect the same foreign MasterClock. The distance is indicated in the stepsRemoved field of Announce messages. This condition can occur in PTP systems with cyclic paths not removed by a protocol outside of PTP. The data set comparison algorithm unambiguously selects one of the two clocks as “better” or as “topologically better.”\n\nProfiles\n\nThe purpose of a PTP profile is to allow organizations to specify specific selections of attribute values and optional features of PTP that, when using the same transport protocol, inter-work and achieve a performance that meets the requirements of a particular application.\n\nA PTP profile should define:\n\nBest MasterClock algorithm options\n\nConfiguration management options\n\nPath delay mechanisms (peer-delay or delay request-response)\n\nThe range and default values of all PTP configurable attributes and data set members\n\nThe transport mechanisms required, permitted or prohibited\n\nThe node types required, permitted, or prohibited\n\nThe options required, permitted, or prohibited\n\nVarious profiles defined for packet networking with PTP are as follows:\n\n8265.x profiles are used for achieving frequency synchronization with PTP.\n\n8275.x is used for time-of-day/Phase synchronization using PTP. NCS5xx/55xx presently supports 8265.1, 8275.1, 8275.2, and 8273.2.\n\n8265.1 was earlier used for 3G/4G clock synchronization, whereas 8275.x is used now for 5G because of the rise in demand for accuracy with 5G networks.\n\n8275.1\n\nThis annex contains the PTP telecom profile for phase/time distribution with full timing support from the network.\n\nSynchronization Model:\n\nG.8275.1 profile adopts the hop-by-hop synchronization model. Each network device in the path from Server to Client clock synchronizes its local clock to upstream devices and provides synchronization to downstream device\n\nNode Types:\n\nIn this profile, the permitted node types are ordinary clocks, boundary clocks, and end-to-end transparent clocks.\n\nIn this profile, the prohibited node types are peer-to-peer transparent clocks.\n\nDomains:\n\nDomain ids from 24 to 43 can be used. The default domain id is 24\n\nClock Mode:\n\nBoth one-step and two-step clocks are permitted. A clock must be capable of receiving and handling messages transmitted from both one-step and two-step clocks. A clock is not required to support both one-step and two-step modes for transmitting messages.\n\nTransport mechanisms required, permitted, or prohibited\n\nIn this profile, the allowed transport mechanisms are:\n\nIEEE 802.3/Ethernet and\n\nOTN\n\nAt least one of the two transport mechanisms must be supported. For transport over IEEE 802.3/Ethernet, both the non-forwardable multicast address, 01-80-C2-00-00-0E, and the forwardable multicast address, 01-1B-19-00-00-00, are required to be supported for compliance with this profile\n\nUnicast/Multicast Messages:\n\nAll messages are sent multicast, using one of the two multicast addresses (01-80-C2-00-00-0E/01-1B-19-00-00-00). The unicast mode is not permitted in this version of the profile.\n\nBest MasterClock Algorithm Options:\n\nThis profile uses the Alternate BMCA.\n\nFollowing clock-parameters are compared (in order) from each available node to select the best MasterClock:\n\nTable 1. Telcom Profile BMCA Hierarchy\n\nPath Delay Measurement Option (Delay Request/Delay Response):\n\nThe delay request/delay response mechanism is used in this profile. The peer-delay mechanism must not be used in this profile, the delay_req—response method must be used.\n\nThis PTP telecom profile defines an Alternate BMCA that allows using two main approaches to set up the topology of the phase/time synchronization network:\n\nAutomatic Topology Establishment:\n\nWhen configuring the localPriority attributes defined in this Recommendation to their default value, the PTP topology is established automatically by the Alternate BMCA based on the Announce messages exchanged by the PTP clocks. A synchronization tree with the shortest paths to the T-GMs is built after this operation. In this mode, during failure events and topology reconfiguration, the Alternate BMCA will be run again and result in a new synchronization tree. This Alternate BMCA operation ensures that no timing loop will be created without requiring manual intervention or prior analysis of the network. The convergence time to the new PTP topology depends on the size of the network, and on the specific configuration of the PTP parameters.\n\nManual network planning: The use of the localPriority attributes defined in this Recommendation with different values than their default value allows building manually the synchronization network topology, in a similar way as Synchronous Digital Hierarchy (SDH) networks are typically operated based on the synchronization status message (SSM). This option allows full control of the actions during failure events and topology reconfiguration, based on the configured local priorities of the system. However, careful network planning is required prior to the deployment in order to avoid timing loops.\n\nConsiderations on the Use of Priority2:\n\nThe PTP attribute priority2 is configurable in this profile. In some special circumstances, the use of the priority2 attribute can simplify network management. This section describes two use cases; other possible cases are for further study.\n\nCase 1.\n\nOperators can configure the PTP attribute priority2 to make all of the Telecom Boundary Clock (T-BCs) either traceable to one Telecom Grand MasterClock (T-GM) or traceable to two different T-GMs at the same time.\n\nFor example, in this image, if all other PTP attributes of the two T-GMs are the same, and the two T-GMs are configured with the same priority2 value, each T-BC will select the T-GM with the shortest path. If the two T-GMs are configured with different priority2 values, all of the T-BCs will synchronize to the T-GM with the smallest priority2 value.\n\nCase 2.\n\nOperators can configure the PTP attribute priority2 to prevent the T-BCs of an upstream network from synchronizing with the T-BCs of a downstream network when the T-GM is in failure.\n\nFor example, in Figure, if all other PTP attributes of all of the T-BCs are the same, and the PTP attribute priority2 of all of T-BCs are configured with the same value, then when the T-GM is in failure, the T-BCs in the upstream network can synchronize with the T-BCs in the downstream network, depending on the clockIdentity values of all of the T-BCs. If the T-BCs in the upstream network are configured with a smaller priority2 value than the T-BCs in the downstream network then, when the T-GM is in failure, the T-BCs in the downstream network will synchronize to the T-BCs in the upstream network.\n\nOperations over Link Aggregation:\n\nWhen two devices embedding PTP clocks compliant with this profile are connected via a link aggregation (LAG), each physical link should be accessed directly to transmit PTP messages, bypassing the LAG. This method prevents potential asymmetries that may be present when the forward and reverse paths are delivered over different links belonging to the LAG.\n\nConsiderations on the Choice of the PTP Ethernet Multicast Destination Address:\n\nThis PTP profile supports both the non-forwardable multicast address 01-80-C2-00-00-0E and forwardable multicast address 01-1B-19-00-00-00 when the PTP mapping is used.\n\nThe Ethernet multicast address to be used depends on the operator policy; further considerations are provided hereafter.\n\nLayer 2 bridging function associated with the PTP port of a T-BC or T-TC should not forward any frame with destination MAC address 01-1B-19-00-00-00; this could be done by properly provisioning this multicast address in the filtering database.\n\nOption 1 – Use of the non-forwardable multicast address 01-80-C2-00-00-0E.\n\nSome network operators consider that the PTP messages must never be forwarded through PTP-unaware network equipment.\n\nThe use of the non-forwardable multicast address 01-80-C2-00-00-0E guarantees this property most of the time (exceptions exist for some older Ethernet equipment).\n\nTherefore, in the case of network equipment misconfiguration (e.g., if the PTP functions are not enabled in PTP-aware network equipment), the use of this multicast address prevents incorrect distribution of synchronization, since the PTP messages will be blocked by the PTP-unaware network equipment.\n\nOption 2 – Use of the forwardable multicast address 01-1B-19-00-00-00.\n\nSome network operators consider that using a forwardable multicast address is more flexible and that it is preferable to forward the PTP messages to keep the synchronization link running in case some equipment is misconfigured as non-PTP nodes, although there are potential risks of performance degradation. The network management system (NMS) will easily find the misconfiguration and will send alarms.\n\nHowever, it is possible to block the PTP messages by properly provisioning this multicast address in the filtering database of each Ethernet equipment.\n\n8275.2\n\nThis Recommendation defines another PTP profile to allow the distribution of phase and time with Partial Timing Support (PTS) from the network (i.e., no need for every device to run ptp in the network). The major difference between 8275.2 from 8275.1 is that it runs on IPv4 unicast and not all nodes in the network need to run PTP.\n\nTransport Mechanisms:\n\nIn this profile, the required transport mechanism is UDP/IPv4.\n\nUnicast Messages:\n\nAll messages are sent in unicast.\n\nIn this telecom profile, unicast negotiation is enabled per default.\n\nThe SlaveClock will initiate the session by following the unicast message negotiation procedure.\n\nDomains:\n\nDomain ids from 44 to 63 can be used. The default domain id is 44.\n\nBest MasterClock Algorithm Options:\n\nThis profile uses the Alternate BMCA.\n\nProperties lPath delay measurement option (delay request/delay response), Automatic topology establishment and Considerations on the use of priority2 are same as telecom profile 8275.1\n\nConsiderations of PTP over IP Transport in Ring Topologies:\n\nWhen using PTP messaging over an IP transport layer, there are some aspects of the Layer 3 protocol that need to be considered. The PTP layer delivers messages into the IP layer with a destination IP address. The IP layer then ensures the message is delivered to the destination as long as there is some path through the IP transport network from the source node to the destination address. The IP layer includes dynamic routing protocols that can adapt the path through the network based on available links between the IP routers. It can happen that the path taken by the IP transport layer may not be the path 'expected' by the synchronization planner. Applying some restrictions in the IP transport layer to control suboptimal paths for PTP messages may be beneficial. This is likely to be the case in ring topologies.\n\nTaking the topology shown in Figure below as an example, the SlaveClock is configured to request unicast service from both BC3 and BC4. After receiving the Announce messages from both BC3 and BC4, the SlaveClock will run the BMCA and select BC4 as its parent clock based on the fact that the steps- the removed value of BC4 is 1, compared to a steps-removed value of 3 for BC3. The SlaveClock would then request Sync messages from BC4.\n\nIf the connection between BC4 and R6 breaks (see Figure below), then BC4 is not reached through the expected path. However, it can still be reached because routing protocols will retain the connection by routing the IP packets around the ring. BC4 is retained as the parent clock because it is still considered better by the BMCA.\n\nIt is most likely that the desired operation is that the SlaveClock should switch to BC3 for better performance.\n\nThere are a few techniques that can be employed to ensure that in the failure scenario identified above, the SlaveClock will select BC3 as its parent clock. They are based on blocking the PTP IP messages from BC4 to the SlaveClock if those messages are transiting clockwise around the ring. The solution is based on blocking only the PTP messages and not the message of other protocols that might use the same IP addresses.\n\nOption 1. Unique IP Addresses and Static Routes:\n\nIn some deployment models, it might be possible to allocate unique IP addresses for the use of PTP alone. This then allows the use of static routes to control the direction of the PTP flows between the nodes. BC4 would be configured such that the only path to use to reach 11.x.x.141 (SlaveClock) would be the link between BC4 and R6. In addition, R6 could be configured such that the only path to use to reach 11.y.y.104(BC4) would be the link between R6 and BC4. If the link between R6 and BC4 fails, then there is no route available to get the IP packets between 11.x.x.141 and 11.y.y.104 so the SlaveClock will not receive Announces from BC4 and the BMCA will select BC3 as the parent clock. Refer to this image.\n\nOption 2. IP Filters\n\nAll routers support some level of IP filtering. Filters can be used to protect the control plane of the router from unwanted messages. They can be used in this case to control the acceptance of PTP messages on a subset of the routing interfaces.\n\nIn this case, R6 would be configured to protect the SlaveClock from PTP messages taking the wrong route. On the interface on R6 facing BC3, a filter could be applied to only allow messages to UDP port 319 or 320 if the source address matches that of the PTP process on BC3. Any messages sourced from BC4 that are received on that interface would be dropped. Refer to this image.\n\nOption 3. BC Processing of All PTP Messages\n\nA BC could terminate all PTP messages received into any of its ports for any domains used by the BC. Then the PTP messages could either be dropped or forwarded based on decisions within the PTP process itself. The choices might be to drop the message if the destination address of the PTP message was not an address owned by the BC or to deliver it to the forwarding engine to be sent onward to the destination. The latter case might be used if the PTP message is for a different domain than the BC. Also in the latter case, the network element containing the BC might also update the correction field of any forwarded event messages to compensate for the PTP message extraction and processing, i.e., support the transparent clock function for these messages. The message extraction from the IP plane can be accomplished if the router supports the policy-based routing of IP packets.\n\nThis example is shown in this image.\n\nOption 4. Use of the Time to Live (TTL) Mechanism From IP Transport:\n\nA PTP node might send PTP packets with the IP/Transport header carrying a TTL field set to the minimum number of routing hops required to reach the peer PTP port with which it has a PTP contract. In a typical PTP-unaware network having unaware routers between MasterClock and SlaveClock, if the number of PTP unaware routers is larger than the TTL value of the PTP message, the PTP message will be dropped by one of the PTP-unaware routers. This can be used to limit the number of IP hops traversed by PTP packets between adjacent routers and avoid communication through unwanted longer paths.\n\nThis behaviour might be per PTP port, or per PTP clock, and is implementation-specific. It is assumed that in such a ring topology, IP routing will take care of ensuring that a shorter path to the PTP MasterClock is considered as a better route than the longer path around the ring.\n\nAs an example, if a SlaveClock has a directly connected MasterClock that can also be reachable through a longer path, it can use the TTL value of 1 to ensure that PTP packets reach the MasterClock only through the directly connected path rather than the longer path around the ring.\n\nServo Algorithm\n\nDescription of the modes:\n\nFree-Run mode:\n\nThe PTP clock has never been synchronized to a time source and is not in the process of synchronizing to a time source.\n\nAcquiring mode:\n\nThe PTP clock is in process of synchronizing to a time source. The duration and functionality of this mode are implementation-specific. This mode is not required in implementation.\n\nFreq/Phase Locked mode:\n\nPhase Lock-The PTP clock is phase synchronized to a time source and is within some internal acceptable accuracy.\n\nFrequency Lock-The clock is frequency synchronized to a time source and is within some internal acceptable accuracy.\n\nAs it relates to the PTP port state defined in [IEEE 1588], a clock is in Locked mode if there is a PTP port in SLAVE state.\n\nHoldover mode:\n\nThe PTP clock is no longer synchronized to a time source and is using information obtained while it was previously synchronized or other information sources were still available, to maintain performance within the desired specification or are unable to maintain performance within the desired specification. The node may be relying solely on its own facilities for holdover or may use something like a frequency input from the network to achieve a holdover of time and/or phase.\n\nConfiguration Example for 8275.1/8275.2 on NCS 540 (Cisco IOS XR)\n\nThe router allows the ability to select separate sources for frequency and time-of-day (ToD). Frequency selection can be between any source of frequency available to the router, such as BITS, GPS, SyncE or IEEE 1588 PTP. The ToD selection is between the source selected for frequency and PTP, if available (ToD selection is from GPS, DTI or PTP). This is known as hybrid mode, where a physical frequency source (BITS or SyncE) is used to provide frequency synchronization, while PTP is used to provide ToD synchronization.\n\nSyncE (for frequency transfer) and ptp (phase/time-of-day transfer) can be used together in the network while deploying 8275.1 to achieve better accuracies (called as hybrid mode and is the only supported mode for NCS as of version 7.3.x)\n\nThe local priority attribute is not transmitted in Announce messages. This attribute is used as a tie-breaker in the data set comparison algorithm, in the event that all other previous attributes of the data sets being compared are equal\n\n8275.1:\n\n8275.2:\n\nIn case you do not receive ESMC packets on the interface or if SyncE is not configured on the end of the port, but you still wish to enable syncE. You can do so by statically defining the QL value on the interface and disabling SSM.\n\nSyncE\n\nfrequency synchronization\n\nquality itu-t option 1\n\nlog selection changes\n\n!\n\ninterface TenGigE0/0/0/19\n\nfrequency synchronization\n\nssm disable\n\nquality receive exact itu-t option 1 PRC\n\nselection input\n\npriority 15\n\nwait-to-restore 0\n\n!\n\nIn order to use Hybrid mode with 8275.2 use ‘physical-layer-frequency’ under the interface. This enables SyncE for frequency and ptp for phase.\n\nIn order to enable hybrid mode with 8275.2 ‘physical-layer-frequency’ must be configured under global ptp.\n\nptp\n\nclock\n\ndomain 44\n\nprofile g.8275.2 clock-type T-BC\n\n!\n\nprofile 82752\n\ntransport ipv4\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\nphysical-layer-frequency\n\nlog\n\nservo events\n\n!\n\n!\n\nSample topology 8275.1:\n\nDevice A:\n\nptp\n\nclock\n\ndomain 24\n\nprofile g.8275.1 clock-type T-BC\n\n!\n\nprofile T-BC-SLAVE\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ethernet\n\nport state SlaveClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\nprofile T-BC-MasterClock\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ethernet\n\nport state MasterClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\n!\n\nfrequency synchronization\n\nquality itu-t option 1\n\nlog selection changes\n\n!\n\ninterface TenGigE0/0/0/23\n\ndescription ***to PTP GM***\n\nptp\n\nprofile T-BC-SLAVE\n\n!\n\nfrequency synchronization\n\nselection input\n\npriority 10\n\nwait-to-restore 0\n\n!\n\n!\n\ninterface TenGigE0/0/0/19\n\nptp\n\nprofile T-BC-MasterClock\n\n!\n\nfrequency synchronization\n\nwait-to-restore 0\n\n!\n\n!\n\nDevice B:\n\nptp\n\nclock\n\ndomain 24\n\nprofile g.8275.1 clock-type T-BC\n\n!\n\nprofile T-BC-SLAVE\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ethernet\n\nport state SlaveClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\nprofile T-BC-MasterClock\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ethernet\n\nport state MasterClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\n!\n\ninterface TenGigE0/0/0/23\n\nptp\n\nprofile T-BC-MasterClock\n\n!\n\n!\n\ninterface TenGigE0/0/0/19\n\nptp\n\nprofile T-BC-SLAVE\n\n!\n\nfrequency synchronization\n\nselection input\n\n!\n\n!\n\nSample topology 8275.2:\n\nDevice A:\n\nptp\n\nclock\n\ndomain 44\n\nprofile g.8275.2 clock-type T-BC\n\n!\n\nprofile T-BC-SLAVE\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ipv4\n\nport state SlaveClock-only\n\nsync frequency 16\n\nclock operation one-step\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\nprofile T-BC-MasterClock\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ipv4\n\nport state MasterClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\n!\n\nfrequency synchronization\n\nquality itu-t option 1\n\nlog selection changes\n\n!\n\ninterface TenGigE0/0/0/23\n\ndescription ***to PTP GM***\n\nptp\n\nprofile T-BC-SLAVE\n\n!\n\nfrequency synchronization\n\nselection input\n\npriority 10\n\nwait-to-restore 0\n\n!\n\n!\n\ninterface TenGigE0/0/0/19\n\nip address 10.0.0.1 255.255.255.252\n\nptp\n\nprofile T-BC-MasterClock\n\nMasterClock ipv4 10.0.0.2 255.255.255.252\n\n!\n\nfrequency synchronization\n\nwait-to-restore 0\n\n!\n\n!\n\nDevice B:\n\nptp\n\nclock\n\ndomain 44\n\nprofile g.8275.2 clock-type T-BC\n\n!\n\nprofile T-BC-SLAVE\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ipv4\n\nport state SlaveClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\nprofile T-BC-MasterClock\n\nmulticast target-address ethernet 01-80-C2-00-00-0E\n\ntransport ipv4\n\nport state MasterClock-only\n\nsync frequency 16\n\nannounce frequency 8\n\ndelay-request frequency 16\n\n!\n\n!\n\ninterface TenGigE0/0/0/19\n\nmtu 9216\n\nptp\n\nprofile T-BC-SLAVE\n\n!\n\nfrequency synchronization\n\nselection input\n\n!\n\n!\n\nTroubleshoot PTP\n\nSome show commands and describe their outputs.\n\nThe Servo status at the end of the servo algorithm must be Phase_Locked. You can see the for the servo status flow. If the Servo mode is Hybrid, SyncE flow must also be taken care of as Phase lock happens only post of Freq_Lock. If the PTP running device is an ordinary MasterClock the above output may not be valid as the Servo algorithm will not run and it doesn’t have to get phase/frequency synchronised from another MasterClock source.\n\nThe device status doesn’t go to LOCK unless the offset is within an acceptable range. Do check the ‘Offset from MasterClock’ as well.\n\nDevice status:\n\nFREE-RUN/HOLDOVER: Not locked to any clock source.\n\nFREQ_LOCKED: Frequency synchronized to MasterClock\n\nPHASE_LOCKED: Both frequency and phase synchronized to MasterClock\n\nServo mode:\n\nHybrid: Use SyncE for frequency synchronization. PTP is used only for phase synchronization.\n\nDefault: Use PTP for synchronizing both frequency and phase\n\nTime difference observed by servo algorithm b/w SlaveClock and MasterClock.\n\nCounters for timestamps extracted from PTP packets. Should keep increasing.\n\nLast T1/T2/T3/T4 timestamps (sec.nanosec) extracted from PTP packets. Should be close to each other and uniformly increase.\n\nT1/T4: Sent by MasterClock, T2/T3: Calculated at SlaveClock\n\nOffset Calculated based on PTP timestamps.\n\nCoarse (setTime, stepTime) and fine (adjustFreq) adjustments done by a servo to align itself with the MasterClock.\n\n3. show ptp interfaces brief shows the output port state. It should be MasterClock/SlaveClock state.\n\n4. The packet drops by ptp must be significantly low.\n\n5. Check the packet drop reason:\n\n6. Packets not reach PTP.\n\nAre packets reach NPU?\n\nNCS (DNX) platforms: show controllers npu stats traps-all instance all location 0/0/CPU0 | inc 1588\n\nRxTrap1588 0 71 0x47 32040 7148566 0\n\nASR9000 platform: show controller np counters <np> location 0/0/cpu0 | inc PTP\n\nCheck for PTP_ETHERNET / PTP_IPV4 counters\n\nPacket drops at NPU (not specific to PTP)\n\nNCS (DNX) platforms: show controllers fia diagshell <np> \"diag counters g\" location 0/0/cpu0\n\nShows Rx/TX path statistics along with any drops happening in the NPU\n\nASR9000 platform: show drops all location <LC>\n\nCheck drops at SPP:\n\nshow spp node-counters location 0/0/cpu0\n\n# Check for any drop-counters incrementing\n\nNCS (DNX) platforms: show spp trace platform common error last 20 location 0/0/cpu0\n\nDec 10 02:29:38.322 spp/fretta/err 0/0/CPU0 t2902 FRETTA SPP classify RX:\n\nFailed in dpa_punt_mapper; ssp: 0x1e, inlif: 0x2000, rif: 0x11;\n\ntrap_code:FLP_IEEE_1588_PREFIX punt_reason:PTP-PKT pkt_type:L2_LOCALSWITCH rc:\n\n'ixdb' detected the 'fatal' condition 'Not found in database': No such file or directory\n\nASR9000 platforms:\n\nSPP punt path is simpler in ASR9000 with no risk of a lookup failure.\n\nDrops not expected during packet classification.\n\n7. show ptp packet-counters <interface-id> shows the packet flow. Ensure the syncàDelay_ReqàDelay_Resp is followed (and Follow_Up if it is 2 step clock).\n\n8. Check the flag (S) for the selected interface.\n\n9. Check the QL received. On the selected interface the QLsnd will be DNU in order to prevent loops. To alter your interface preference you can change the priority attribute which is 100 by default.\n\n10. Ensure the ‘Output Driven by’ is the elected SyncE interface.\n\n11. show ptp foreign-MasterClocks brief output is the list of ptp devices participating in the BMCA to become MasterClocks. Check the corresponding flags to see the elected MasterClock. You can see announce messages received from those ports via show ptp packet-counters <interface-id>. The device with the best attributes will win the BMCA. If multiple ports have the same attributes local-priority will be the last tie-breaker. However, automatic topology establishment is also possible with ptp without using local-priority.\n\n12. Ptp does not select the intended MasterClock (BMCA).\n\nCheck clock advertised by the remote node:\n\nshow ptp foreign-MasterClocks\n\nInterface TenGigE0/9/0/2 (PTP port number 1)\n\nIPv4, Address X.X.X.X, Unicast\n\nConfigured priority: None (128)\n\nConfigured clock class: None\n\nConfigured delay asymmetry: None\n\nAnnounce granted: every 16 seconds, 1000 seconds\n\nSync granted: every 16 seconds, 1000 seconds\n\nDelay-resp granted: 64 per-second, 1000 seconds\n\nQualified for 4 hours, 50 minutes, 6 seconds\n\nClock ID: 1\n\nReceived clock properties:\n\nDomain: 44, Priority1: 128, Priority2: 128, Class: 6\n\nAccuracy: 0x21, Offset scaled log variance: 0x4e5d\n\nSteps-removed: 1, Time source: Atomic, Timescale: PTP\n\nFrequency-traceable, Time-traceable\n\nCurrent UTC offset: 38 seconds (valid)\n\nParent properties:\n\nClock ID: 1\n\nPort number: 1\n\nList of qualified and selected MasterClocks:\n\nshow ptp foreign-MasterClocks brief\n\nM=Multicast,X=Mixed-mode,Q=Qualified,D=QL-DNU,\n\nGM=GrandMasterClock,LA=PTSF_lossAnnounce,LS=PTSF_lossSync\n\nInterface Transport Address Cfg-Pri Pri1 State\n\n----------------------------------------------------------------------------\n\nTe0/0/0/12 Ethernet 008a.9691.3830 None 128 M,Q,GM\n\nCheck the clock advertised at the MasterClock:\n\nshow ptp advertised-clock\n\nClock ID: 8a96fffe9138d8\n\nClock properties:\n\nDomain: 24, Priority1: 128, Priority2: 128, Class: 6\n\nAccuracy: 0xfe, Offset scaled log variance: 0xffff\n\nTime Source: Internal (configured, overrides Internal)\n\nTimescale: PTP (configured, overrides PTP)\n\nNo frequency or time traceability\n\nCurrent UTC offset: 0 seconds\n\n13. Ptp not synchronizing with the MasterClock:\n\n•Intended PTP MasterClock selected.\n\n•PTP session established\n\n•But not able to synchronize with the MasterClock\n\nshow ptp interface brief\n\nIntf Port Port Line\n\nName Number State Encap State Mechanism\n\n--------------------------------------------------------------------------------\n\nTe0/0/0/12 1 Uncalibrated Ethernet up 1-step DRRM\n\nOR occasional PTP flap in the field\n\nJul 31 09:29:43.114 UTC: ptp_ctrlr[1086]: %PLATFORM-PTP-6-SERVO_EVENTS : PTP Servo state transition from state PHASE_LOCKED to state HOLDOVER\n\nJul 31 09:30:23.116 UTC: ptp_ctrlr[1086]: %PLATFORM-PTP-6-SERVO_EVENTS : PTP Servo state transition from state HOLDOVER to state FREQ_LOCKED\n\nul 31 09:35:28.134 UTC: ptp_ctrlr[1086]: %PLATFORM-PTP-6-SERVO_EVENTS : PTP Servo state transition from state FREQ_LOCKED to state PHASE_LOCKED\n\n14. Check if PTP flapped due to packet loss:\n\nshow ptp trace last 100 location 0/rp0/cpu0\n\nAug 1 02:35:01.616 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] Removed clock 0x8a96fffe9138d8 (Ethernet 008a.9691.3830) from node 0/0/CPU0(0x0) from BMC list\n\nAug 1 02:35:01.616 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] Updated checkpoint record for clock 0x8a96fffe9138d8 (Ethernet 008a.9691.3830) from node 0/0/CPU0(0x0): Checkpoint ID 0x40002f60\n\nAug 1 02:35:01.616 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] Inserted clock 0x8a96fffe9138d8 (Ethernet 008a.9691.3830) from node 0/0/CPU0(0x0) into BMC list at position 0\n\nAug 1 02:35:46.035 ptp/ctrlr/sum 0/RP0/CPU0 t18625 [Comms] Received BMC message from node 0/0/CPU0. Comms is active\n\nAug 1 02:35:46.035 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] Removed clock 0x8a96fffe9138d8 (Ethernet 008a.9691.3830) from node 0/0/CPU0(0x0) from BMC list\n\nAug 1 02:35:46.035 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] GrandMasterClock removed, local clock better than foreign MasterClock(s)\n\nAug 1 02:35:46.035 ptp/ctrlr/sum 0/RP0/CPU0 t18625 [Leap Seconds] GrandMasterClock lost\n\nAug 1 02:35:46.035 ptp/ctrlr/sum 0/RP0/CPU0 t18625 [Platform] Stopping servo\n\nAug 1 02:35:46.035 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] BMC servo stopped, BMC servo not synced\n\nAug 1 02:35:46.035 ptp/ctrlr/det 0/RP0/CPU0 t18625 [Comms] Started grandMasterClock message damping timer\n\nAug 1 02:35:46.035 ptp/ctrlr/sum 0/RP0/CPU0 t18625 [Platform] Sending SlaveClock update to platform. No grandMasterClock available\n\nAug 1 02:35:46.059 ptp/ctrlr/det 0/RP0/CPU0 t18625 [BMC] Received clock update from the platform. Clock active, not using PTP for frequency, using PTP for time. Current local clock is not a primary ref, sync state is 'Sync' and QL is 'Opt-I/PRC'\n\n15. Check the output of show ptp configuration-errors for any configuration mistakes.\n\nSample Packet Captures of Sync, Announce, Delay_Req and Delay_Resp Messages\n\nThe capture of the Announce message (8275.1) shows the characteristics of the transmitted clock:\n\nThe capture of the Sync message shows the time stamp generation (one-step).\n\nRelated Information"
    }
}