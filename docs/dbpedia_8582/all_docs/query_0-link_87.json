{
    "id": "dbpedia_8582_0",
    "rank": 87,
    "data": {
        "url": "https://www.mongodb.com/community/forums/t/issue-with-2-18-to-2-19-nuget-upgrade-of-mongodb-c-driver/211894",
        "read_more_link": "",
        "language": "en",
        "title": "Issue with 2.18 to 2.19 NuGet Upgrade of MongoDB C# Driver",
        "top_image": "https://www.mongodb.com/community/forums/uploads/default/original/3X/0/1/01d4259c8928db8d3f2370429391688f8622654d.png",
        "meta_img": "https://www.mongodb.com/community/forums/uploads/default/original/3X/0/1/01d4259c8928db8d3f2370429391688f8622654d.png",
        "images": [
            "https://www.mongodb.com/community/forums/user_avatar/www.mongodb.com/james_kovacs/48/2900_2.png",
            "https://www.mongodb.com/community/forums/images/emoji/apple/frowning.png?v=12"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "queries",
            "dot-net"
        ],
        "tags": null,
        "authors": [
            "James_Kovacs (James Kovacs)",
            "Mark_Mann (Mark Mann)",
            "system (system) Closed",
            "EMD_LAB (Emd Lab)"
        ],
        "publish_date": "2023-02-03T16:29:51+00:00",
        "summary": "",
        "meta_description": "I recently tried to update the MongoDB C# driver from 2.18 to 2.19 using the standard Visual Studio NuGet package updating process. \nWhile the update itself went smoothly, I had system wide failures every where with the &hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://www.mongodb.com/community/forums/uploads/default/optimized/3X/4/4/4499311543ceb0d3e905ac979d29c6f7090732f5_2_32x32.png",
        "meta_site_name": "MongoDB Developer Community Forums",
        "canonical_link": "https://www.mongodb.com/community/forums/t/issue-with-2-18-to-2-19-nuget-upgrade-of-mongodb-c-driver/211894",
        "text": "I recently tried to update the MongoDB C# driver from 2.18 to 2.19 using the standard Visual Studio NuGet package updating process.\n\nWhile the update itself went smoothly, I had system wide failures every where with the following exception:\n\n“(x as ARoot) is not supported” I went through the patch notes but could not find anything directly related to this other than a small blurb about switching from LINQ2 to the LINQ3. I followed the instructions to manually set to LINQ2 but the issue still persisted. I have now rolled back to 2.18 but I would like to figure this out.\n\nEssentially all objects in my system which are stored in mongo inherit from “AMongoThing”, which has some basic properties like the Mongo ObjectID, CreatedBy/CreatedDate, etc. The specific properties are not important.\n\nThere are a number of queries I make in the system, both get and set, where I don’t care what is actually stored in Mongo(Car, Person, Animal) because I am updating one of those root properties so my mongo call looks something like:\n\ncollection.Find( x => (x as AMongoThing).Created >= DateTime.Now.AddHours(-24))\n\nThis is obviously a super silly example but I can replicate the issue described above with this one line. That line works in 2.18 and fails in 2.19\n\nI’m not sure if this is truly no longer support or I have some serializer or setting as part of my connection process which is causing the issue.\n\nThank you everyone for the feedback and comments.\n\nI ended up creating a simple program using both 2.18 and 2.19, and it seems the LinqProvider.V2 did fix the problem. The problem when I originally tried that was in the way I was setting the linqProvider property/value.\n\nI will however provide my sample program if anyone is interested. The failure will/not occur as you comment out the below line:\n\nmcSettings.LinqProvider = LinqProvider.V2;\n\nI cannot upload the code so I will try to paste it all here, I hope it works…\n\nusing MongoDB.Bson.Serialization.Serializers; using MongoDB.Bson.Serialization; using MongoDB.Bson; using MongoDB.Driver; using System; using System.Collections; using System.Collections.Generic; using System.IO; using System.Linq; using System.Linq.Expressions; using System.Threading.Tasks; using System.Reflection; using static MyFirstCoreApp.ExpressionCombiner; using System.Xml.Linq; using Mongo219; using MongoDB.Driver.Linq; namespace MyFirstCoreApp { public static class ExpressionCombiner { public static Expression<Func<T, bool>> And<T>(this Expression<Func<T, bool>> exp, Expression<Func<T, bool>> newExp) { var visitor = new ParameterUpdateVisitor(newExp.Parameters.First(), exp.Parameters.First()); newExp = visitor.Visit(newExp) as Expression<Func<T, bool>>; var binExp = Expression.And(exp.Body, newExp.Body); return Expression.Lambda<Func<T, bool>>(binExp, newExp.Parameters); } public class CsharpLegacyGuidSerializationProvider : IBsonSerializationProvider { public IBsonSerializer GetSerializer(Type type) { if (type == typeof(Guid)) return new GuidSerializer(GuidRepresentation.Standard); return null; } } public class ParameterUpdateVisitor : System.Linq.Expressions.ExpressionVisitor { private ParameterExpression _oldParameter; private ParameterExpression _newParameter; public ParameterUpdateVisitor(ParameterExpression oldParameter, ParameterExpression newParameter) { _oldParameter = oldParameter; _newParameter = newParameter; } protected override Expression VisitParameter(ParameterExpression node) { if (object.ReferenceEquals(node, _oldParameter)) return _newParameter; return base.VisitParameter(node); } } } public class Program { public static void CreateClassMaps() { var types = Assembly.GetExecutingAssembly().GetTypes(); foreach (var item in types) { try { if (!item.IsInterface) { var classMap = new BsonClassMap(item); classMap.AutoMap(); classMap.SetDiscriminator(item.FullName); if (!BsonClassMap.IsClassMapRegistered(item)) { BsonClassMap.RegisterClassMap(classMap); } } } catch (Exception) { //unable to create specific class map } } } public static void Main(string[] args) { BsonSerializer.RegisterSerializationProvider(new CsharpLegacyGuidSerializationProvider()); MongoClientSettings mcSettings = new MongoClientSettings(); mcSettings.Server = new MongoServerAddress(\"localhost\", 27017); mcSettings.LinqProvider = LinqProvider.V2; MongoClient client = new MongoClient(mcSettings); IMongoDatabase mongoDB = client.GetDatabase(\"MongoTest\"); //clean it for fresh test each time mongoDB.GetCollection<AMongoThing>(\"Animals\").DeleteMany(x => true); CreateClassMaps(); AddSomeData(mongoDB); //just test we get all animals var getAllAnimals = GetThings<AAnimal>( mongoDB, filter: null); //should only get 1 var getAnimalsBasedOnSomething = GetThings<AAnimal>( mongoDB, filter: x => (x as Pig).WillBeFood); } public static void AddSomeData(IMongoDatabase DB) { UpsertThing<Cat>( DB, filter: null, new Cat() { ID = \"63e169c103f81b89b23add99\", // only setting this manually to prevent duplicates when re-running the program IsDomesticated = true, Age = 1, Gender = \"Male\", Name = \"Fluffanutter\" } ); UpsertThing<Cat>( DB, filter: null, new Cat() { ID = \"63e169f4b42641ce7c5e85af\", // only setting this manually to prevent duplicates when re-running the program IsDomesticated = false, Age = 2, Gender = \"Female\", Name = \"Brown Cat\" } ); UpsertThing<Horse>( DB, filter: null, new Horse() { ID = \"63e169f73aad61eaad4a78aa\", // only setting this manually to prevent duplicates when re-running the program LivesOnFarm = true, Age = 6, Gender = \"Male\", Name = \"Neigh Neigh\" } ); UpsertThing<Horse>( DB, filter: null, new Horse() { ID = \"63e169fbbfb45bed8c515fe4\", // only setting this manually to prevent duplicates when re-running the program LivesOnFarm = false, Age = 12, Gender = \"Male\", Name = \"Mr. Ed\" } ); UpsertThing<Pig>( DB, filter: null, new Pig() { ID = \"63e169ffb57d09e93a93251c\", // only setting this manually to prevent duplicates when re-running the program WillBeFood = true, Age = 3, Gender = \"Male\", Name = \"Wilbur\" } ); UpsertThing<Pig>( DB, filter: null, new Pig() { ID = \"63e16a03db8e428dd6240b43\", // only setting this manually to prevent duplicates when re-running the program WillBeFood = false, Age = 15, Gender = \"Female\", Name = \"Sir Oinks\" } ); } public static T UpsertThing<T>( IMongoDatabase DB, Expression<Func<T, bool>> filter, T record) { var collectionName = (record as AMongoThing).StorageGrouping; var coll = DB.GetCollection<T>(collectionName); if ((record as AMongoThing).Created == null) { (record as AMongoThing).Created = DateTime.UtcNow; } (record as AMongoThing).LastModified = DateTime.UtcNow; if (string.IsNullOrEmpty((record as AMongoThing).ID)) { coll.InsertOne(record); return record; } else { if (filter == null) { filter = x => (x as AMongoThing).ID == (record as AMongoThing).ID; } else { filter = filter.And<T>(x => (x as AMongoThing).ID == (record as AMongoThing).ID); } return coll.FindOneAndReplace( filter, record, new FindOneAndReplaceOptions<T, T> { IsUpsert = true, ReturnDocument = ReturnDocument.After }); } } public static List<T> GetThings<T>( IMongoDatabase DB, Expression<Func<T, bool>> filter) { var collectionName = \"Unknown\"; if (typeof(T) == typeof(AMongoThing) || typeof(T).IsSubclassOf(typeof(AMongoThing))) { var temp = Activator.CreateInstance(typeof(T)); collectionName = (temp as AMongoThing).StorageGrouping; } var coll = DB.GetCollection<T>(collectionName); var myCursor = coll.FindSync<T>(filter ?? FilterDefinition<T>.Empty); List<T> returnValue = new List<T>(); while (myCursor.MoveNext()) { returnValue.AddRange(myCursor.Current as List<T>); } return returnValue; } } } using MongoDB.Bson.Serialization.Attributes; using MongoDB.Bson; using System; using System.Collections.Generic; using System.Linq; using System.Text; using System.Threading.Tasks; namespace Mongo219 { [BsonIgnoreExtraElements] public class AMongoThing { [BsonId] [BsonIgnoreIfDefault] [BsonRepresentation(BsonType.ObjectId)] public string? ID { get; set; } public string Name { get; set; } = \"\"; public string StorageGrouping { get; set; } [BsonDateTimeOptions(Kind = DateTimeKind.Utc)] public DateTime? Created { get; set; } [BsonDateTimeOptions(Kind = DateTimeKind.Utc)] public DateTime? LastModified { get; set; } } [BsonIgnoreExtraElements] public class AAnimal : AMongoThing { public string Gender { get; set; } public int Age { get; set; } public AAnimal() { this.StorageGrouping = \"Animals\"; } } [BsonIgnoreExtraElements] public class Cat : AAnimal { public bool IsDomesticated { get; set; } public Cat() { this.StorageGrouping = \"Animals\"; } } [BsonIgnoreExtraElements] public class Horse : AAnimal { public bool LivesOnFarm { get; set; } public Horse() { this.StorageGrouping = \"Animals\"; } } [BsonIgnoreExtraElements] public class Pig : AAnimal { public bool WillBeFood { get; set; } public Pig() { this.StorageGrouping = \"Animals\"; } } }\n\nHi, @Mark_Mann,\n\nThank you for your code example. I understand the problem that you’ve encountered.\n\nYou are creating a filter using x as AMongoThing, which LINQ3 attempts to convert into a server-side $convert operation. The server is not aware of C# class definitions and has no way to know how to cast an arbitrary object to AMongoThing and thus fails.\n\nThis worked by happenstance in LINQ2 because we blindly discarded cast operations that we didn’t understand. This is dangerous as the cast operation may be important to your logic.\n\nFortunately the fix in your code is straightforward. You can use a generic type constraint on your method, which is much safer than the cast.\n\npublic static T UpsertThing<T>( IMongoDatabase DB, Expression<Func<T, bool>> filter, T record) where T: AMongoThing\n\nBy annotating the method with where T: AMongoThing, you can safely eliminate all the as AMongoThing casts. Not only is the code clearer, but it is safer as the compiler prevents you from passing in objects that do not derive from AMongoThing. Previously you would have encountered a NullReferenceException at runtime if the object passed did not derive from AMongoThing.\n\nI hope this resolves your problem.\n\nSincerely,\n\nJames\n\nJames,\n\nInteresting and thank you for that feedback. I think the way I am using Mongo is extremely strange then, but it has been profoundly successful for us from a code management, expansion, and maintenance perspective.\n\nWe decided, for right or wrong I suppose, to put the responsibility on the developer to know what objects they have and derive from. You are correct that it would throw a null exception and we do catch that(and others) and deal with them accordingly.\n\nIn your above example it would me to specify a single “where T: ” at the end, but we actually use filters where there are multiple types assumed/used. So I cannot specify a single “AMongoThing” without sacrificing other aspects of my query\n\nIn my provided example I simplified things just to highlight the error I encountered, but we use mongoDB in some very interesting ways. I would be happy to show you what we’ve done if you were interested.\n\nI will be using my sample project to attempt an upgrade to 2.19 as we encountered some other issues as well. Do you happen to know if/when LINQ2 will no longer be supported?\n\nHi, @Mark_Mann,\n\nThank you for the additional information and continued discussion. It was a design decision to be more rigorous about only removing casts (aka $convert) with LINQ3 as LINQ2 allows you to do strange things like cast a string to a bool - which will fail with LINQ-to-Objects but magically work server-side because the cast is simply stripped out of the expression.\n\nIn your use case, you use the casts to make the C# compiler happy, not to express server-side $convert expressions. While unusual, it is not as uncommon as we may have initially thought. I’m going to discuss this with the engineering team to see if and how we can support use cases such as yours.\n\nIt would be helpful to file a CSHARP ticket in JIRA along with a description of your use case, a repro, and any publicly available code so that we can review and triage it. Thank you in advance.\n\nRemoving LINQ2 support is a breaking change and will not be done until the next major version, 3.0.0. We do not have a timeline for the 3.0.0 release yet, but the soonest would be later this year or early next.\n\nSincerely,\n\nJames"
    }
}