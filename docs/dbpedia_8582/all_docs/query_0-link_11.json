{
    "id": "dbpedia_8582_0",
    "rank": 11,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/448142/best-practices-for-team-development-with-nuget-projects-in-net",
        "read_more_link": "",
        "language": "en",
        "title": "Best practices for team development with NuGet projects in .Net",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://graph.facebook.com/632372009/picture?type=large",
            "https://i.sstatic.net/vPzRc.png?s=64",
            "https://softwareengineering.stackexchange.com/posts/448142/ivc/3e78?prg=4299c038-7c02-4bdb-9a3f-bf203c0bf418"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2023-10-17T00:09:26",
        "summary": "",
        "meta_description": "TL;DR I want to change the way our current enterprise code base is constructed to utilize NuGet packages for the inter-project references, but that seems to present some challenges when considering...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/448142/best-practices-for-team-development-with-nuget-projects-in-net",
        "text": "Tangent: your project structure\n\nFirst of all, a massive elephant that is proving to be a bit of a distraction / cause for general concern: if I understand your explanation correctly, you have separated your codebases by layer, i.e. instead of cutting up a monolith vertically like microservices do (by bounded context), you've cut it up horizontally (by individual layers of those services).\n\nI don't like that approach. I also think it separate some layers further from each other, leading to a significant increase in overhead cost in terms of handling inter-layer dependencies and references. This will inevitably impact how much effort is involved in managing anything related to this (and this question falls squarely into that category).\n\nHowever, the core question you're asking is the same even if you were to assume a more common microservice architecture where you have separated services but not separated layers. So I'm going to answer this question in a way that sidesteps your project organization because it's not the core focus here.\n\nHow to Nuget\n\nIdeally, we would do something similar to what we do now (i.e. build a -beta NuGet package locally and reference it during testing), and then check the whole graph in once the change was complete. But how would you go about doing that without having to do all kinds of gymnastics with the project files, as far as changing the project references and / or repo sources?\n\nI'm going to establish a few points that are necessary to get to what I want to focus on. I'm skipping the justifications because the answer would explode in size.\n\nNuget packages are intentional releases of versions. They indicate an intentional action on the part of the package developer.\n\nBecause the consumer can consume Nuget package versions at their own leisurely pace (and update references to newer versions as they see fit, or not), it is paramount to keep older versions of your package available, ideally without ever expiring.\n\nSemver is the established standard for managing an evolving version that respects older versions and how consumers can choose the right version for their use case.\n\nFor the purposes of testing, it would be bad form to have to change how you consume your dependency, because then you're not testing the real thing anymore. This argument is no different (in spirit) from having different methods for a \"real\" call and a \"test\" call in a class. Any difference between the two is likely going to obfuscate what should have been caught as a test failure. Ideally, you want your tests (even for non-final Nuget packages) to use the real Nuget dependency.\n\nThere are two points I want to make here. The first is a bit of an idealistic principled point, but it is the overall better approach.\n\n1\n\nTL;DR: A Nuget package denotes the boundary between two components that should really have a separate lifecycle. In doing so, you significantly mitigate the need for experimental package release in the first place.\n\nNuget packages are a non-trivial process. You can't feasibly build and release a package for every tiny change you make to your code, plus it would take a non-zero amount of time to get all these changes build and onto your feed. Can it be done? Sure. Will it be nice and quick for a developer who is mid-development and in \"the zone\"? Absolutely not\n\nWhat this means is that Nuget packages act as a slow gate, and you should really be designing your process in a way that minimizes the amount of times you need to release such a Nuget package.\n\nSpeaking in general microservice terms (which I know isn't your specific use case but humor me here), you should try and finalize your changes to Service A before you even begin implementing how Service B consumes the new version of A.\n\nBy minimizing the back-and-forth between developing A and B, you minimize how often you have to cross the slow bridge of Nuget package releasing.\n\nIn an ideal world, I would suggest you hold to the standard of testing A in isolation and fully confirming it follows the standards before you even begin to implement in B. If you do so, you actually don't need to ever use an experimental Nuget package from A in service B, because you will have vetted A before it ever needed to be a Nuget package.\n\nThis is an idealistic point, and not necessarily a fully realistic one. However, the other side of the spectrum, where you actively choose to develop your features across multiple independent services (including Nuget bridges between them) is going to be a really inefficient process with significant complexity both in scheduling their release and avoiding/handling regressions, on top of requiring developers to actively manage several services at the same time.\n\nAll of these things increase the cognitive load on your developers and it will significantly complicate your development process. Try to respect the individual nature of your individual projects. A Nuget package denotes the boundary between two components that should really have a separate lifecycle.\n\n2\n\nTL;DR: Semver pre-release versioning solves the problem for you.\n\nIf you accept these bullet points, and you don't fully adhere to the (admittedly idealistic) previous point, then the remaining question is \"how can I pre-release Nuget packages that are not a final version yet?\". The answer to that will be the answer to your question.\n\n\"Pre-release\" is the operative word here. Semver actually account for the need to have alpha and beta packages, by using an established version number format that indicates the pre-release nature of it. Emphasis mine (link):\n\nA pre-release version MAY be denoted by appending a dash and a series of dot separated identifiers immediately following the patch version. Identifiers MUST be comprised of only ASCII alphanumerics and dash [0-9A-Za-z-]. Pre-release versions satisfy but have a lower precedence than the associated normal version.\n\nIn other words, the following list of versions is considered to be in order of version number:\n\n1.0.0 1.0.1 1.0.2 1.1.0 2.0.0-alpha 2.0.0-beta 2.0.0 2.0.1\n\nSmall detail: alpha and beta are sorted by standard alphabetical order. Make sure that if you have multiple pre-releases of the same version, that you label them accordingly. The name you pick is completely up to you.\n\nIf you still insist on having many experimental releases for the same version, make sure to adequately prefix your numbering to ensure alphabetical sorting is maintained, e.g. 2.0.0-rc001, 2.0.0-rc002, ..., 2.0.0-rc099, 2.0.0-rc100, 2.0.0-rc101, ...\n\nWhat this means is that if a consumer is set to consume the 2.0.0 package, and we're living in a world where 2.0.0-alpha is the most recent release (according to the above chart), then that consumer will take the 2.0.0-alpha version because it falls under the umbrella of 2.0.0.\n\nHowever, without needing to change the consumer, if you then release the actual package 2.0.0, your consumer will automatically take the 2.0.0 (newer, non-experimental) version instead of the 2.0.0-alpha that it used to work with (of course, this requires the consumer to rebuild, but that's inherently how Nuget is designed to work).\n\nWhat this means is that you can set your consuming service to already \"sign up\" for the new version, and the way semver sorts its versions will ensure that it will take the best version available (i.e. experimental only if there is no final version), without you needing to constantly manually update precisely which pre-release version it should consume."
    }
}