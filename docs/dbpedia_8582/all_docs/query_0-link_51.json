{
    "id": "dbpedia_8582_0",
    "rank": 51,
    "data": {
        "url": "https://www.nyckel.com/blog/nuget-packages/",
        "read_more_link": "",
        "language": "en",
        "title": "Local Development and Validation of Nuget Packages",
        "top_image": "https://www.nyckel.com/assets/images/important/nyckel-cover.webp",
        "meta_img": "https://www.nyckel.com/assets/images/important/nyckel-cover.webp",
        "images": [
            "https://www.nyckel.com/assets/images/logos/Nyckel-Dark-500.webp",
            "https://www.nyckel.com/assets/images/icons/industries/marketplaces.webp",
            "https://www.nyckel.com/assets/images/icons/industries/dam.webp",
            "https://www.nyckel.com/assets/images/icons/industries/adtech.webp",
            "https://www.nyckel.com/assets/images/icons/industries/brand.webp",
            "https://www.nyckel.com/assets/images/icons/industries/retail.webp",
            "https://www.nyckel.com/assets/images/icons/industries/iot.webp",
            "https://www.nyckel.com/assets/images/client-logos/retailhub-icon.webp",
            "https://www.nyckel.com/assets/images/client-logos/gardyn-icon.webp",
            "https://www.nyckel.com/assets/images/client-logos/linkedclient.webp",
            "https://www.nyckel.com/assets/images/client-logos/taimi-icon.webp",
            "https://www.nyckel.com/assets/images/client-logos/gust-icon.webp",
            "https://www.nyckel.com/favicon.webp",
            "https://www.nyckel.com/favicon.webp",
            "https://www.nyckel.com/assets/images/icons/nav/blog.webp",
            "https://www.nyckel.com/assets/images/icons/de-wrenches.webp",
            "https://www.nyckel.com/assets/images/icons/nav/invention.webp",
            "https://www.nyckel.com/assets/images/icons/nav/de-gears-3.webp",
            "https://www.nyckel.com/assets/images/icons/nav/support.webp",
            "https://www.nyckel.com/assets/images/team/blog-george.webp",
            "https://www.nyckel.com/assets/images/important/nyckel-cover.webp",
            "https://www.nyckel.com/assets/images/important/soc2white.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "george"
        ],
        "publish_date": "2021-10-19T00:00:00+00:00",
        "summary": "",
        "meta_description": "Learnings from setting up a local development workflow for developing and validating nuget packages",
        "meta_lang": "en",
        "meta_favicon": "/favicon.svg",
        "meta_site_name": "Nyckel",
        "canonical_link": "https://www.nyckel.com/blog/nuget-packages/",
        "text": "Why is an ML company talking about nuget instead of PyTorch or transformers? Because we are C# nerds and because production ML is a whole lot more than training a model. You shouldn’t need to know anything about PyTorch, tensors, or GPUs to use ML. More on that in this short video.\n\nAt Nyckel, we use C# extensively for critical parts of our stack. We publish a set of internal .NET libraries that are then used by our tools and services. Since nuget is the preferred .NET package manager, we publish and consume these libraries as nuget packages hosted on a private nuget repo on AWS CodeArtifact.\n\nMotivation\n\nWe insist on having a local development workflow for our stack. This is for two reason:\n\nWe want to detect problems with code changes as early as possible.\n\nWe want to keep our change –> verify –> fix cycle time as short as possible.\n\nNaturally, we wanted a local development experience for verifying changes to our nuget libraries against their consumers. Setting this up took a surprising amount of research and effort. This post attempts to save you the same effort by showing you where we ended up.\n\nSetup\n\nFor the rest of the post, let’s assume we have the following:\n\nA Nyckel.Common C# library that doesn’t depend on any other library we author.\n\nA Nyckel.Http C# library that depends on Nyckel.Common.\n\nBoth libraries live in the same github repository called dotnet-libraries. The repository has a .sln solution file that contains both projects.\n\nA CI/CD setup that automatically publishes the libraries on each commit to main. The libraries are published to AWS CodeArtifact and versioned as 1.0.<ci-build-number>.\n\nA Nyckel.Server C# service in a separate github repository called server. It depends on a recent 1.0.<ci-build-number> version of Nyckel.Http.\n\ndotnet cli and SDK 5.0 installed on the local development machine. Instructions below have only been tested on Mac and Linux, but I don’t foresee any problems following along on Windows.\n\nLocal Development Requirements\n\nWe wanted the following the following local-development workflows to work in the above setup:\n\nMake a local, uncommitted breaking change to Nyckel.Common that affects Nyckel.Http. Detect the breaking change when building the dotnet-libraries repo. Make the corresponding change to Nyckel.Http and verify that it fixes the build locally.\n\nMake enhancements to Nyckel.Http. Test Nyckel.Server locally using the enhanced Nyckel.Http before we commit those changes. We want to do this even though we have comprehensive unit-tests for our libraries.\n\nAchieve the above two with minimal cycle time and cognitive overhead. Existing local development workflows should require minimal modifications.\n\nSolution\n\nThe solution requires setting up project dependencies for inter-library dependencies, and a local nuget repository for quick testing of library-consumer dependencies. Below I walk through those, build and package steps, and some gotchas like nuget package caching.\n\nProject Dependencies\n\nNyckel.Http.csproj has the following lines it it:\n\nYou’ll notice that there’s nothing special here - it’s just the usual project reference from Nyckel.Http to Nyckel.Common (remember that they are in the same git repository, so the relative path reference works). We were initially worried that it would result in Nyckel.Common.dll being copied over instead of creating a nuget reference. But, as we shall see when we test it out, it actually does the right thing.\n\nThis also ensures that Nyckel.Common is always built before Nyckel.Http. This fulfills requirement #1 above - a breaking change to Nyckel.Common will be detected when building the dotnet-libraries repo. We can make the corresponding change to Nyckel.Http and re-build to verify that it works.\n\nLocal Nuget Source\n\nFor requirement #2, to minimize cycle time, we set up a local nuget repository. Run the following:\n\nThis sets up a local nuget repository at ~/nuget and names it local. We will soon be pushing to it when building locally.\n\nLocal Nuget Package Version and Nuget Caching\n\nCI systems usually have a monotonically increasing build number that you can use to version your nuget packages and publish them as immutable artifacts. We currently use a version number of the form 1.0.<build-number>. For local builds, however, we don’t care about immutability and want to avoid the cognitive overhead of incrementing some version number when publishing and consuming. Instead, we always use the version 1.0.0-local.\n\nThis presents a challenge - nuget caches recently used packages so that they don’t have to be fetched from their (usually remote) repositories each time. Unfortunately, the cache is used even for locally published packages. Given this, and given our fixed 1.0.0-local version number, we could end up in a situation where Nyckel.Server is using an older cached version of Nyckel.Http. To get around this, we add a step to the library .csproj files that clears the local cache before creating a new nuget package. Let’s look at this next.\n\nCsproj File Additions\n\nIn the dotnet-libraries repo, we have a Nuget.targets file that contains the following:\n\nThis does a few things:\n\nIsPackable indicates that the project is a type (library) that can be packaged into a nuget package. See dotnet pack.\n\nA NYCKEL_NUGET_VERSION environment variable is used as the nuget package version. It is set by the CI build script. If it’s not set, we assume that this is a local build and default to 1.0.0-local.\n\nThe DeleteLocalCache target runs before the Pack step (which creates a nuget package) and deletes the cache for this package.\n\nIn each of our library .csproj files (like Nyckel.Common.csproj and Nyckel.Proxy.csproj), we add the following snippet to include the above file:\n\nLocal Build\n\nTo build libraries locally, we run the following from the root of the dotnet-libraries project:\n\nNothing fancy - just the normal build command. It works because we have a .sln solution file in the repo root, and because the project dependencies (and build order) are encoded in .csproj files. We followed instructions here to use the dotnet sln command to create a solution file and add projects to it.\n\nLocal Package and Publish\n\nTo create nuget packages and publish to the local nuget repository, we run the following:\n\nWe can then modify Nyckel.Server.csproj to use version 1.0.0-local of Nyckel.Http, test locally, then commit changes to dotnet-libraries. We then change Nyckel.Server.csproj back to using a non-local version of Nyckel.Http. If we forget to do this for some reason, the error will be caught as a build failure in the CI system.\n\nCI Package and Publish\n\nOn our CI system we set up AWS CodeArtifact as a nuget repo named nyckel/libraries. We run the following from the root of the dotnet-libraries project:\n\nWhen we want Nyckel.Server to use the latest version of Nyckel.Http, we update the version in Nyckel.Server.csproj to 1.0.$CI_BUILD_NUMBER for the latest CI build of the dotnet-libraries repo.\n\nTesting the Workflows\n\nTo make sure that it all works as expected, we ran the following steps:\n\nMake a change in Nyckel.Common that breaks Nyckel.Http.\n\nRun local build. Verify that the build breaks.\n\nFix the build in Nyckel.Http.\n\nRe-run local build. Verify that the build passes.\n\nRun local package and publish.\n\nUse Nuget Package Explorer (Web App or Windows App) to open up dotnet-libraries/nupkgs/Nyckel.Http.1.0.0-local.nupkg. This .nupkg file would have been created in the previous local package step. Go to the Dependencies tab and make sure there is a dependency on Nyckel.Common. Expand the folders in the Contents tab and make sure Nyckel.Common.dll is not included.\n\nChange Nyckel.Server.csproj locally to use version 1.0.0-local of Nyckel.Http. Run Nyckel.Server locally. This will ensure that the nuget cache is populated.\n\nMake a change in Nyckel.Http that breaks Nyckel.Server.\n\nRe-run local package and publish.\n\nRe-run Nyckel.Server. Verify that the build breaks.\n\nConclusion\n\nAs you can see, getting everything to work is not trivial, even without all the research and trial-and-error it took to get here. Despite the level of effort, we are happy with our setup. If you have similar requirements, I hope you find this write-up helpful."
    }
}