{
    "id": "dbpedia_8582_2",
    "rank": 10,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/169920/is-c-development-effectively-inseparable-from-the-ide-you-use",
        "read_more_link": "",
        "language": "en",
        "title": "Is C# development effectively inseparable from the IDE you use?",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/0efdfbc3d7c390992c3525ca5a23d277?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/kMLdh.jpg?s=64",
            "https://www.gravatar.com/avatar/4af3541c00d591e9a518b9c0b3b1190a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/130b8a67fd029b2e6b5e56e7aad04952?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/57c3668e04823e4c9f979fbadad9197c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/eca9d9724ab56d3a977146c9bf7dd75c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/6fc5e3f98fb1113576b50672ae42c05c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/0bce4ecc3649443edeb6eba28f9a6c04?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/inTx6.png?s=64",
            "https://www.gravatar.com/avatar/6a949b13f766f5b1095c9a98dcb94d7f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/89c3645ed352c9f08fae80da29437236?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/021d0d3a0676561486d5ec92339e3bb4?s=64&d=identicon&r=PG",
            "https://softwareengineering.stackexchange.com/posts/169920/ivc/3e78?prg=e74c8c76-3325-4170-bcc6-180d25f143eb"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2012-10-15T10:52:42",
        "summary": "",
        "meta_description": "I'm a Python programmer learning C# who is trying to stop worrying and just love C# for what it is, rather than constantly comparing it back to Python.\n\nI'm caught up on one point: the lack of",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/169920/is-c-development-effectively-inseparable-from-the-ide-you-use",
        "text": "Visual Studio is so convenient that after working with it for a while it is difficult to use a different IDE. It has a lot of handy tools and a bunch of plugins available, so practically it has every feature you would need.\n\nOn the other hand, whatever language you learn, it is recommended to use command line at the beginning, so you can better understand how it works. C# isn't an exception.\n\nis C# development effectively inseparable from the IDE you use?\n\nTheoretically no, but practically yes. It is possible to write in C# using a text editor and command line, but if you have Visual Studio, you'd never do this. In fact very few programmers have ever executed C# code from command line.\n\nBTW If you feel inconvenient with using foo, you can use the whole path when using a type.\n\nThe idea of being dependent on an IDE to understand code at such a basic level seems anathema.\n\nIt is not a question of understanding your code: given sufficient time, you can always locate the right variable with a basic text editor or even in a printout. As far as understanding the code goes, the IDE dependency absolutely does not exist.\n\nLocating your references efficiently is an entirely different subject: I love the ability to find usages of Java variables in Eclipse as much as I love finding declaration points in Visual Studio, for both C# and C++. I prefer spending my time coding, rather than looking for declaration points manually. This is similar to doing math: I can multiply multidigit numbers on a piece of paper, but I prefer using calculator to save myself a minute or two.\n\nStarting at a certain \"critical size\" of the code, a good IDE becomes very useful regardless of the programming language. The size may vary language to language, but once you cross several thousand lines, having an IDE helps regardless of your language. This has more to do with limitations of a human mind than with a particular programming language: at some point, your short-term memory is bound to \"overflow\".\n\nThere are tricks letting you increase that critical size where IDE becomes useful. For example, you could follow a naming convention (Hungarian names were big in the C++ world at some point, especially among the Windows practitioners). Another common trick is qualifying instance variables with this. even in contexts where such qualification is not required.\n\nThese tricks come with trade-offs: almost inevitably, they make your program less readable by obscuring names, or inserting the explicit references the encapsulation was intended to hide. Faced with the choice, I pick clean-looking code plus an IDE over a less-clean-looking code minus an IDE. I fully recognize, however, that other people's choices may differ from mine.\n\nMany Python programmers prefer a text editor approach to coding, using something like Sublime Text 2 or vim, where it's all about the code, plus command line tools and direct access and manipulation of folders and files.\n\nThat's great, but it misses the point of the VS IDE. The point of an IDE like VS is rapid development support via strong code tools like refactoring and intellisense. VS is a very very good editor for C# code.\n\nNow C# lets you code in a style that depends on its IDE to a greater extent (you can use lots of var keywords and the like). Some people prefer to be more explicit, for instance by using namespace aliases to be clear on which namespace a class belongs to (like import in Java or Python). That's more of a coding style choice than a feature of the language.\n\nAs C# is statically typed (although with some dynamic extensions, as of v4) it's always fairly easy to find out what types are being referred to - if they're wrong the code won't compile, and VS isn't the only IDE with support for C# intellisense. It's probably the best though.\n\nDeveloping C# without a powerful IDE (like VS) is rather like hammering in nails by hand when you already have a top of the range nailgun - there might be the odd time you need to do it, but professionals use the right tool for the job.\n\nI'd say the same is probably true of Java too. If there's a powerful IDE with intellisense and code refactor tools out there you should probably be using it.\n\nHowever, look at it the other way round - if you don't want intellisense, compile time code checking and code-analysis/refactoring then a bloated IDE is not the way to go, and neither is a statically typed language. I think it's the other way round:\n\nMany programmers that prefer a text editor approach to coding don't gain as much from statically typed languages (like C# and Java) and so could be better off if they stick to dynamic ones like Python and Javascript.\n\nI think:\n\nDynamic languages suit lightweight tools (heavyweight IDEs confer less benefit here)\n\nStatic languages suit powerful IDEs (tools can help with the code at the cost of flexibility)\n\nTo answer your question: although it's slowly changing, the Microsoft development environment has largely been a monoculture.\n\nThis approach has many positives and negatives, which could be argued at length (e.g. consider the pros and cons of open and closed platforms, such as PCs vs an Xbox), but at the end of the day, the tooling from Microsoft is what most people use. The company has also shown that their decision making is often a kind of \"give the most value to the majority of our users\" process, always looking for practical compromises (most recently - consider Typescript). So basically, I wouldn't be surprised to find that the development of C# was / is done with the tooling (VS) in mind.\n\nAnyone bother to read way down here??\n\nI summarize by saying the massively complex IDE functionality is indispensable and it will (should) evolve to the Zen of Sublime VimNess some day....\n\nOur software is 129 projects of about 2M LOC. Add in the massiveness of the .NET framework and given this all I can say is the IDE is vital, transcending the motivations of this thread's question.\n\nInsight into the Code Base\n\nPeriod. You know the kinds of features we're talking about; except that its convenience becomes indispensable and essential with the kind of code base I deal with.\n\nI write better code because of the IDE. I always add custom messages to my Nunit tests because it's easy, fast and accurate. I favor enumerations over strings due in large part to intellisense. I do not hesitate to use descriptive/long naming - a multi-line statement is composed fast and clean.\n\nBut even this smartness is too much at times. I often use good-old \"find in files\" text searching.\n\nCoding help\n\nHere is where I oft cry \"enough!\". Imagine a screen-full with a dozen colors of mostly obscureatta, some particular variable highlighted everywhere, brace highlighting obscuring what the brace actually is, squiggly underlining everywhere because \"it\" wants me to write literature not code, icons for Resharper context menus (you just gotta click it! then ignore it most of the time), a signature help popup spanning 2/3 of the screen horizontally, vertically displaying several overloads, a popup because of where you just happened to leave the mouse cursor.... I cant even seen the &^!% line*s* of code I'm working on!\n\nVis.Stud. needs to embrace minimalism so I can focus on coding and not go through hundreds (thousands if you count every color coding setting and all those plugins) of settings in a losing battle to reclaim sanity. A \"Pareto\" key would be great.\n\nFor one, C# is not Python.. There are different design methodologies.\n\nNow, to answer your question, it's completely possible to use your Python-esque using statements.\n\nusing FooBar=MyName.Foo.FooBar;\n\nIt's just it is definitely not the norm because it's not nearly so easy. However, I think you should worry less about knowing exactly where exactly each class is coming from. I don't understand the entire point of doing it this way in Python though.\n\nAnd also, C# is a language that lends itself very well to using IDEs to make it easier. Intellisense is amazingly simple to implement, especially compared to dynamic languages such as Ruby and Python. However, you don't have to be stuck to your IDE. I've heard of people using Eclipse. There also is of course MonoDevelop(which I use quite a lot), and you can even work from a command line. On my server sometimes, I'll be editing C# files with vi and then using xbuild to rebuild it... It's just that using an IDE makes things much easier compared to the command line for typical cases.\n\nThis is an interesting view on C# development. What you are asking goes beyond C# though, if you're asking about the IDE.\n\nLike you say, in Python, you can use various editors to write your code. You can do that with the .NET framework too. There are also other IDE tools you can use such as SharpDevelop. Visual Studio is very tightly co-developed with the .NET framework and is relatively expensive. Tools such as SharpDevelop and the \"Express\" versions of VS exist to entice more developers to use .NET. Essentially all an IDE does for you is provide an organised environment, usually with intellisense, add-ons for productivity and a \"helper\" to assemble what can end up being a very scary looking command-line to pass to your compiler. The same is true for Java, tools such as Eclipse just provide the organisation and productivity enhancements for us. Under the hood, nothing magical happens until you build or compile your project and that respect, all IDE's are just pretty faces to the unfriendly compiler.\n\nWhen you talk about the \"using\" statement in C# and compare it to Python, it's not really the same thing going on under the hood. The using statements are used by the compiler to aid it's effort in transforming the C# code into MSIL. In MSIL, there is no \"import all these classes from this namespace\" directive. By the time code is at MSIL level, all the classes have been tagged with their fully qualified names. These \"using\" and \"import\" statements are to aid human readability. They are not compiler optimisation commands. After all this initial \"tagging of fully qualified names\" has gone on, there might be a kind of low-level \"minify\" to the FQNs but this is to aid the compiler/interpreter to execute faster. This is the optimisation - but there is no control of this offered to the developer, unless you are writing your own custom version of the compiler!\n\nOne final fundamental difference between all these languages mentioned on here are that some of them are interpreted by VMs, some are interpreted JIT style and some are fully compiled. How these using directives are implemented across those compilers and interpreters differs greatly.\n\nHTH.\n\nI think that historically the answer is pretty much, yes - getting C# development up and running effectively in anything outside of Visual Studio, Xamarin, or SharpDevelop was just too much an unpleasant experience.\n\nBut recently a lot of projects have emerged that makes it easier, e.g.:\n\nOmniSharp, provides a foundation for intellisense and refactoring, along with vim, emacs, atom, and sublime plugins. I haven't actually used it, so I don't know how well it works, but it does look promising.\n\nYeoman ASP.NET MVC generators, helps bootstrap a new MVC project (maybe other generators exist).\n\npaket, an alternative to NuGet where you can actually add NuGet packages to your project from the command line, and have your .csproj files updated (although there was a NuGet command line tool, actually updating projects to use the packages was part of the IDE integration, not command line tools).\n\nPaket has the implication that you have to adapt your source code to using it - so if you sit as the single member in a team and wants to use a text editor for coding, and everybody else uses Visual Studio, you would have to convince everybody else to adapt the solution to your needs :(\n\nSo you should be able to get up and running, but there is comparably more work to do to get your toolchain up and running efficiently."
    }
}