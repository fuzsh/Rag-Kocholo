{
    "id": "dbpedia_8582_3",
    "rank": 24,
    "data": {
        "url": "https://blog.jetbrains.com/dotnet/2020/11/09/diving-into-nuget-history-for-fun-and-community-insights/",
        "read_more_link": "",
        "language": "en",
        "title": "Diving Into NuGet History For Fun and Community Insights",
        "top_image": "https://resources.jetbrains.com/storage/products/dotnet/img/meta/preview.png",
        "meta_img": "https://resources.jetbrains.com/storage/products/dotnet/img/meta/preview.png",
        "images": [
            "https://blog.jetbrains.com/wp-content/uploads/2024/06/JETBRAINS-Blog.svg",
            "https://blog.jetbrains.com/wp-content/uploads/2019/01/Frame-1321314548.svg",
            "https://blog.jetbrains.com/wp-content/uploads/2023/01/62d2f4d9361a3cab-200x200.gif",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/1-day-one.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/2-published-today.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.13.07-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.15.21-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.22.59-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.35.40-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.44.05-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.47.50-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.49.03-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-13.52.35-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-14.35.41-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-14.00.43-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-14.01.52-2x.png",
            "https://blog.jetbrains.com/wp-content/uploads/2020/11/Screenshot-2020-11-05-at-14.12.50-2x.png",
            "https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/img-form.svg",
            "https://blog.jetbrains.com/wp-content/uploads/2024/08/1280x720_4dotNet_social_share.png",
            "https://blog.jetbrains.com/wp-content/uploads/2022/07/F34E0F9B-D3F0-4DD4-B7C7-B11AF3FC6D25-50x50.jpeg",
            "https://blog.jetbrains.com/wp-content/uploads/2024/08/Featured_Blog_1280x720-2x-11.png",
            "https://blog.jetbrains.com/wp-content/uploads/2022/07/F34E0F9B-D3F0-4DD4-B7C7-B11AF3FC6D25-50x50.jpeg",
            "https://blog.jetbrains.com/wp-content/uploads/2024/08/Featured_Blog_1280x720-2x-10.png",
            "https://blog.jetbrains.com/wp-content/uploads/2022/07/F34E0F9B-D3F0-4DD4-B7C7-B11AF3FC6D25-50x50.jpeg",
            "https://blog.jetbrains.com/wp-content/uploads/2024/08/unreal-debugging-improvements-in-rider-20242-featured.png",
            "https://secure.gravatar.com/avatar/e29361f2b498fb2231dca801f0e8f4e3?s=50&r=g"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Sasha Ivanova",
            "Matt Ellis"
        ],
        "publish_date": "2020-11-09T00:00:00",
        "summary": "",
        "meta_description": "In the dark ages of .NET, developers had to crawl the internet for dependencies, run installers, create bloated lib folders, and possibly introduce assemblies into the Global Assembly Cache. Gross! Th",
        "meta_lang": "en",
        "meta_favicon": "https://blog.jetbrains.com/wp-content/themes/jetbrains/assets/img/favicons/favicon.ico",
        "meta_site_name": "The JetBrains Blog",
        "canonical_link": "https://blog.jetbrains.com/dotnet/2020/11/09/diving-into-nuget-history-for-fun-and-community-insights/",
        "text": ".NET Tools Community How-To's JetBrains\n\nIn the dark ages of .NET, developers had to crawl the internet for dependencies, run installers, create bloated lib folders, and possibly introduce assemblies into the Global Assembly Cache. Gross! Those who remember will agree it was terrible, but it’s better now!\n\nWe can all breathe a deep sigh of relief knowing that package management is central to most modern technology stacks, including our beloved .NET. Today, most developers instinctually reach to the catalog of packages on NuGet to solve mundane to difficult problems. That’s a good thing, but easy access to solutions also can lull us into taking our community for granted.\n\nIn this post, we’ll look at our .NET community’s history through the lens of NuGet data harvested using Maarten’s Azure Functions-based metadata crawler, which produced 2.7 million records and a 1.5GB comma-delimited text file. We loaded the data into Elasticsearch and utilized Kibana to make a dashboard, which you’ll see later in this post.\n\nAPIs, data points, and structure\n\nAs of writing this post, there is no way to get a singular database of NuGet information. Folks looking to recreate this post will need to crawl the NuGet APIs made available to everyone. Again, Maarten’s Azure Functions-based metadata crawler is a great place to start.\n\nAt first, retrieving the data had us worried. NuGet is a critical community infrastructure that everyone relies on working. Having multiple community members coordinate millions of API calls at the same time could damage NuGet’s ability to deliver responses to clients. That said, we were given the “unofficial” go-ahead by NuGet team members to use the APIs.\n\nFor our data, we only retrieved publishing information and not consumer information. For example, Amazon has published the AWSSDK.APIGateway package over 396 times since its first release. Amazon’s release cycle is tame in comparison to other libraries. Paket, a popular package manager client, has published its packages over 2,413 times!\n\nWhile the NuGet API does expose download counts, it’s cumbersome to gather this data for all packages. There is an open GitHub issue about exposing download counts in an easy-to-consume manner, but given the already enormous breadth of information, we decided against download counts (for now).\n\nThe information we were able to retrieve for published packages includes: Package Id, Tags, Authors, Version, License, Publish Date, and Target Frameworks. Each record in our database is for a package version, helping us understand any particular package’s publishing frequency and lifespan.\n\nAssumptions\n\nWe need to get a disclaimer out of the way before we start looking at information.\n\nFirst, we’re making assumptions about folks appropriately tagging packages – likely a significant portion of publishers are not. Lack of tags could mean the results are incomplete. Additionally, while we can compute narrow slices based on tags, authors, and time frames, it gets harder to do larger wedges of data. The computation overwhelms the compute engine.\n\nAdditionally, this post is about data. We’ll try not to assume anything about the state of .NET, OSS, or any other conjectures.\n\nSo let’s get started by looking at some data.\n\nStarted from the bottom…\n\n*If the dashboard images are too small, use the context menu to open the images in a new tab.\n\nAll great things have humble beginnings, and NuGet is no different. On January 7th, 2011, David Bryon published Agatha-rrsl to the NuGet registry. The first NuGet package, followed almost 1 second later by a flood of packages. On January 7th, 177 publish events, and publishers added 155 unique packages to the ecosystem.\n\nAuthors on that day include the Codeplex Foundation, Google, and Microsoft. Significant tags include aspnetwebpages, mvc, t4, and mocking. Seeing that ASP.NET MVC is one of the first projects to be open-sourced by Microsoft, it’s no surprise to see it amongst the first packages released.\n\nSome folks may be wondering what sl3 and sl4 mean regarding target frameworks. Well, that’s Silverlight, the discontinued web version of .NET. Don’t worry though, many of the lessons learned from Silverlight found their way into .NET Core and .NET 5.\n\nFrom those small yet significant beginnings, we now have 229,336+ unique packages on NuGet.\n\nNow we’re here!\n\nLet’s look at the publishing of unique packages from the last 30 days. We’ll see a clear pattern emerging as compared to the first day of NuGet packages.\n\nThe consistent pattern would likely be due to advances in continuous build and deployment processes. Products like TeamCity, AppVeyor, and GitHub Actions help developers ship consistently even for minor changes.\n\nLooking at a complete picture of the last 30 days, we can see service providers have been busy pushing commercial packages to NuGet: Amazon, Google, Microsoft, Uno Platform, and Syncfusion. Amazon has an overwhelmingly large lead in the tag count, with aws being present over 3,000 times.\n\nWhat’s also interesting here is the target frameworks tag cloud. The target framework netstandard2.1 looms large over other versions. While still present, the market share for legacy .NET is relatively smaller. We can see that net50 begins to appear as developers start to support the new version of .NET.\n\n❤️ JetBrains loves OSS\n\nIt wouldn’t be any fun unless we looked at what JetBrains has done to support .NET OSS. For this section, let’s look exclusively at the jetbrains author, which does not include individual JetBrains employees’ contributions to the ecosystem.\n\nJetBrains has contributed 44 unique packages to NuGet, with a primary focus around our .NET tools like ReSharper, dotMemory, and dotCover. We also ship .NET packages to support our other product offerings, such as YouTrack and TeamCity. What’s visible in the dashboard above is our unique versioning approach, which uses years to denote the current release. For example, you’ll see the version prefix 2020.*.* used frequently this year. What’s also amazing is that JetBrains has been part of the .NET OSS ecosystem for over eight years.\n\nASP.NET community\n\nNext, we were curious, outside of Microsoft, who in our community contributes the most to the tags aspnet and aspnetcore. Here is where things get interesting, as we see our Asian friends contributing a good portion of the 2,890 packages to the ASP.NET ecosystem.\n\nDevelopers in China make up 50% of the packages with the aspnet and aspnetcore tags. Chinese is likely an uncommon language for native English speaking developers, so these packages are less frequently used outside of China. These publishers are using the tag applicationframework heavily, which leads us to think many of these packages are part of a philosophical approach to building web applications.\n\nOne of the framworks we found in this data is China .NET, with an extensive set of documentation. This framework has all kinds of utilities tied in, such as an alternative for AutoMapper.\n\nAll this makes us wonder what other sub-cultures can be uncovered simply by looking at NuGet’s data?\n\nXamarin development\n\nXamarin is a cross-platform approach to building mobile applications targeting operating systems like iOS, Android, UWP, and many more. Let’s see what the search query of tags: xamarin* returns.\n\nThe mobile ecosystem is healthy and alive, with a head-spinning 6,393 packages. The trajectory of growth from 0 to over 3000 published packages in a given timeframe is impressive. Additionally, what’s different about mobile development is the support for varying target frameworks, which almost borders on the absurd.\n\nHere’s the complete picture for the Xamarin community.\n\nNot C-Sharp\n\nIt’s hard to argue against C# being the dominant language in the .NET ecosystem, but that’s not to say that F# and VB.NET developers don’t love and champion their languages. Let’s take a look at the two sibling languages and their contributions to NuGet. Let’s start with F#. We’ll filter our results using the tag fsharp.\n\nWhat stands out immediately with the F# dashboard is its continued publishing momentum. This momentum is even more astounding, as it is driven mostly by community members, with Ryan Riley contributing a whopping 21.96% of unique packages.\n\nIn the last 30 days, the F# community has focused on releasing Fable and Fantomas. We recently invited core contributor Florian Verdonck to give a talk about Fantomas to JetBrains .NET Days attendees.\n\nWell, what about VB.NET? Let’s filter by the tag of vb and vb.net and see what we get.\n\nWe can see that the Visual Basic packages come from software vendors like Evo PDF Software, HiQPDF software, and ComponentPro Software. Seeing VB.NET has a following in enterprise development circles, it makes sense to see more business-focused packages.\n\nLicenses\n\nThe data we have is a little sparse when it comes to project licenses. The NuGet spec allows folks to set their license URL, which makes determining the precise value difficult. For this section, we relied on a keyword in the URL string itself, so take this data with a healthy dose of skepticism. For example, if the license URL contains MIT, we assume the project has chosen the MIT license.\n\nLooking at the packages, we see that the MIT and Apache licenses are the most commonly specified. The Custom license could contain MIT, Apache, and BSD variants, but we chose not to follow the URLs to determine the exact values. We also see many publishers leave the license URL value empty altogether, which can be problematic for consumers trying to choose a legally-usable package.\n\nConclusion\n\nWe’ve just started to scratch the surface around the NuGet ecosystem. Sometimes trends are self-evident, and other times we need to have a starting point to query further. Like we mentioned at the start of this post, this information is publisher only, giving us an exciting yet admittedly incomplete picture of our community. What was most exciting to see is the broader .NET community’s sub-cultures, programming languages, platforms, and geography.\n\nIf you folks have any interesting questions you’d like to see answered by this data, please leave a comment below. If you see something in the information we missed, again, we’d love to hear from you. Thank you for reading, and please share this post and discuss it with your developer friends."
    }
}