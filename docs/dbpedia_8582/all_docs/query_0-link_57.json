{
    "id": "dbpedia_8582_0",
    "rank": 57,
    "data": {
        "url": "https://fossa.com/blog/dependency-management-visual-studio-nuget-beyond/",
        "read_more_link": "",
        "language": "en",
        "title": "Dependency Management in Visual Studio: NuGet and Beyond",
        "top_image": "https://fossa.com/blog/content/images/size/w1200/2022/01/visual-studio.png",
        "meta_img": "https://fossa.com/blog/content/images/size/w1200/2022/01/visual-studio.png",
        "images": [
            "https://www.facebook.com/tr?id=1898322167094379&ev=PageView&noscript=1",
            "https://fossa.com/blog/assets/nav-logo.svg?v=43c0eb6c1a",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a4670620b2942c72629_vulnerability-management.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a4496e6ef39b7596644_license-compliance.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a4570620b37eec72624_sbom.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a431407d8e7e4b8b688_continuos-compliance.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a43482d4abfa5015c5d_due-diligence.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a454cc38f10b29497bb_shiftleft-risk-mitigation.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/652411580354b5d855d18a9a_microchip-ai.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a461407d887b0b8b6b5_started.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a4396e6ef5748596643_documentation.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a43482d4a97ae015c52_blog.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a454cc38f7c839497ba_resources.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a44b16556abfedfc4a3_events.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a46f95dcca864224278_tldrlegal.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a43f07e633796a0059a_about.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a435dee79164f5342ba_customers.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a436c0ae0660a54ad75_careers.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a4470620b86a0c7261d_partners.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a4597c263d0940f9c5f_press.svg",
            "https://assets-global.website-files.com/62e82713ebd0a52ef4a76313/635d1a43c8f1b25daf9b5a12_contact-us.svg",
            "https://fossa.com/blog/content/images/size/w600h300/2022/01/visual-studio.png 600w,                                    /blog/content/images/size/w800h400/2022/01/visual-studio.png 800w,                                    /blog/content/images/size/w1200h600/2022/01/visual-studio.png 1200w,                                    /blog/content/images/size/w2400h1200/2022/01/visual-studio.png 2400w",
            "https://fossa.com/blog/content/images/2022/01/visual-studio-32.png",
            "https://fossa.com/blog/content/images/2022/01/VS-33.png",
            "https://fossa.com/blog/content/images/2022/01/vs34.png",
            "https://fossa.com/blog/content/images/2022/01/vs35.png",
            "https://fossa.com/blog/content/images/2022/01/vs36.png",
            "https://fossa.com/blog/content/images/2022/01/vs37.png",
            "https://fossa.com/blog/content/images/2022/01/vs38.png",
            "https://fossa.com/blog/content/images/2022/01/vs39.png",
            "https://fossa.com/blog/content/images/2022/01/vs40.png",
            "https://fossa.com/blog/content/images/2022/01/vs41.png",
            "https://fossa.com/blog/content/images/2022/01/vs42.png",
            "https://fossa.com/blog/content/images/2022/01/vs43.png",
            "https://fossa.com/blog/content/images/2022/01/vs44.png",
            "https://fossa.com/blog/content/images/2022/01/vs45.png",
            "https://fossa.com/blog/content/images/2022/01/vs46.png",
            "https://fossa.com/blog/content/images/size/w600h300/2022/01/npm.png 600w,                        /blog/content/images/size/w800h400/2022/01/npm.png 800w,                        /blog/content/images/size/w1200h600/2022/01/npm.png 1200w,                        /blog/content/images/size/w2400h1200/2022/01/npm.png 2400w",
            "https://fossa.com/blog/content/images/size/w120h120/2022/07/photo.jpeg",
            "https://fossa.com/blog/content/images/size/w600h300/2021/12/AGPL.png 600w,                        /blog/content/images/size/w800h400/2021/12/AGPL.png 800w,                        /blog/content/images/size/w1200h600/2021/12/AGPL.png 1200w,                        /blog/content/images/size/w2400h1200/2021/12/AGPL.png 2400w",
            "https://fossa.com/blog/content/images/size/w120h120/2022/07/photo.jpeg",
            "https://fossa.com/blog/content/images/2022/02/fossa-blog.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Cristian Taran"
        ],
        "publish_date": "2022-01-06T22:49:06+00:00",
        "summary": "",
        "meta_description": "Learn how to manage NuGet package dependencies for your .NET projects using Visual Studio.",
        "meta_lang": "en",
        "meta_favicon": "https://fossa.com/blog/content/images/size/w256h256/2022/02/fossa-blog.png",
        "meta_site_name": "Dependency Heaven",
        "canonical_link": "https://fossa.com/blog/dependency-management-visual-studio-nuget-beyond/",
        "text": "Visual Studio is one of the most-used IDEs for building products on the Microsoft technology stack. Whether you're building on top of .NET Framework, .NET Core, .NET Standard, or another framework, you are or most likely have at some point used Visual Studio. (This piece will focus on .NET projects, but Visual Studio also supports languages like JavaScript, C, and C++, among others.)\n\nIn the Microsoft universe, reusable code comes in the shape of pre-built assemblies (.dlls). When you decide to include these in your project, they are referred to as project dependencies. If your project is small, it might have just a couple of dependencies, but most production-grade software will have lots. This comes with increased complexity in managing these dependencies.\n\nIn this post, we will be looking at how to best manage dependencies for your .NET projects using Visual Studio and NuGet (the package manager for .NET), with a peek behind the scenes at what happens when you’re taking related steps in the Visual Studio UI.\n\nTable of Contents\n\nProject Dependencies\n\nNuGet\n\nAdding/Removing a Package\n\nUpdating a Package\n\nBehind the Scenes in Visual Studio\n\nAdd a Package\n\nUpdate a Package\n\nUninstall a Package\n\nRestoring Packages\n\nAlternatives to Visual Studio UI\n\nPackage Manager Console\n\nDotnet CLI\n\nNuGet CLI\n\nAdditional Tips: Dependency Management in Visual Studio\n\nReinstall a Package\n\nConsolidate\n\nPackages.config\n\nMigrate from packages.config to PackageReference\n\nProject Dependencies in Visual Studio\n\nLet us first have a look at the different types of dependencies you might find in a .NET project.\n\nFor the purposes of this article, we will be focusing on .NET Core projects in Visual Studio 2019, but a lot holds true for previous versions dating back to 2017 and also for version 2022.\n\nWhen you right-click on the “Dependencies” node in your project in Visual Studio, you will be presented with the following list:\n\nSo, what do all these options mean? Let's take a look.\n\nAdd Project Reference: Use this if you want to refer to the output of another project located in the same Visual Studio solution (.sln). Visual Studio can figure out what assembly to use given the path to the project. Also called project-to-project reference, this is preferred to referencing files (assemblies) directly because it creates a dependency between projects in the build system, which helps keep the dependency tree consistent.\n\nAdd Shared Project Reference: Another way to reuse code is via Shared Projects, which allow you to write code that can then be referenced by other projects. A shared project does not have a binary output; instead, the code is compiled as part of each other project that references it.\n\nAdd COM Reference: This allows referencing of COM components.\n\nBrowse: The above three options will open the Reference Manager, which allows for a fourth option: “Browse.” Use this if you want to refer to another component from the local file system (or a trusted network location). However, Microsoft recommends using project-to-project reference instead of direct file reference.\n\nManage Connected Services: Use this if you need to connect your application to external services, like Azure Services, SQL Server databases, or a host of other services which can be installed from the Visual Studio Marketplace.\n\nManage NuGet Packages: One of the most-used options, and our focus for the remainder of this post, is managing references to NuGet Packages.\n\nThank you for submitting details. Your email address is added to our subscription list.\n\nNuGet and Visual Studio\n\nAs the world became more and more connected through the internet, software developers also became increasingly interconnected and aware of each other’s work. As a side effect, sharing and reusing code between projects went from being desirable, to being the norm, to being a necessity.\n\nBut reusing code as assemblies can be a tedious and complex process, especially when dealing with huge projects that have many dependencies. Keeping track of all the required dependencies, making sure they are available in all environments and with the correct version, reconciling versions in the dependency tree, and managing cascading dependencies can be time-consuming and error-prone.\n\nSo, the more developers were interested in sharing and reusing code, the more the need for a managed solution for dependency management became apparent.\n\nFor the .NET world, this solution came in 2010 when NuGet was first launched. NuGet is the package manager for .NET. It is a software-as-a-service solution that enables developers to create, share, and consume useful code in the form of “packages.”\n\nNuGet was initially distributed as an extension for Visual Studio, but starting with Visual Studio 2012, it became fully integrated into the IDE. It can also be used via its native client (nuget.exe), via MSBuild, or via the .NET Core SDK (dotnet.exe). The latest stable version at the time of writing is 5.11.0, launched in August 2021.\n\nNuGet packages are nothing more than zip files (with the .nupkg extension) that contain the compiled code (.dll files) and other files related to that code including a manifest.\n\nNuGet enables developers to:\n\nCreate packages and publish them to a public or private repository\n\nRetrieve packages from repositories, add them to their projects, and call that functionality from their code\n\nLet’s dive a little further into using the Package Manager UI in your Visual Studio project to handle package dependencies. We will be using Visual Studio 2019 and NuGet 5.11.0 as references, but most of this holds true even for older versions of Visual Studio and NuGet.\n\nAdding or Removing a NuGet Package\n\nTo add a NuGet package to your project, after you right-click on the Dependencies node in your Solution explorer, choose the “Manage NuGet packages…” option:\n\nThis will open up the NuGet Package Manager UI, where you are presented with three main areas: Browse, Installed, and Updates; you can also select the Package Source, i.e. the repository where Visual Studio will search for available packages.\n\nGo ahead and select the Browse tab, search for your package, select the desired version of that package, and hit Install.\n\nVisual Studio proceeds to install the package and its dependencies into your project. Once the operation is complete, you can start writing code that calls/uses code from the newly added package.\n\nNow, back in the Package Manager UI, switch over to the Installed tab where you should see your new package. You can choose to Uninstall it or any other package that was previously added to your project.\n\nUpdating a NuGet Package\n\nIf you have installed an earlier version of a package at some point, you might want to update that package to a newer version.\n\nTo do that, back in the Package Manager UI, switch over to the Updates tab, where you can see those packages included in your project for which a newer version is available in the selected repository, in our case nuget.org.\n\nHere, you can choose to:\n\nSelect one or more of the packages in the list and hit Update. This will upgrade all the (selected) packages to their latest version.\n\nSelect one of the packages, then on the right-hand side choose a specific version that you want to upgrade that package to and hit Install. This will upgrade only the selected package to the particular version that you selected.\n\nBehind the Scenes in Visual Studio\n\nA Visual Studio project is defined by a .csproj file, which is an XML file that holds different configuration settings for the project.\n\nThe information about the NuGet package dependencies for your project is stored in this .csproj file.\n\nNOTE: For .NET Framework projects and more generally for non-SDK-style projects, the package dependencies are by default stored separately in a packages.config file in a similar fashion and with a similar dynamic.\n\nHere is a sample of a .csproj for a new .NET Core Console Application:\n\nAdding a Package\n\nWhen you add a new package to the project, Visual Studio will:\n\nDownload the package\n\nUnpack and install it in a dedicated folder on your local machine\n\nAnd finally, add a corresponding PackageReference node in the .csproj file:\n\nNOTE: Adding a package via the NuGet CLI will not update the .csproj file. To achieve that, use one of these approaches:\n\nVS Package Manager UI\n\nVS Package Manager console\n\nDotnet CLI\n\nWhen you update a package in your project, behind the scenes Visual Studio will:\n\nDownload the specific/latest version of the package\n\nUnpack and install it in a local folder\n\nModify the corresponding node in the .csproj file\n\nUninstalling a Package\n\nWhen you uninstall a package from your project, the corresponding PackageReference node will be removed from the .csproj file.\n\nNOTE: These actions can also be achieved by editing the .csproj file directly, but make sure you know what you are doing as this can generate inconsistencies and corrupt the .csproj file.\n\nFor more options offered by the PackageReference structure, you can reference Microsoft's documentation.\n\nRestoring Packages\n\nThe advantage of using NuGet is that your project is self-sufficient even without the actual installed packages (i.e. the .dlls). As long as the package dependencies are correctly described in the .csproj file (or the packages.config file), you can clone/copy your project code to another machine and get it to build and run in no time.\n\nThis can be achieved by doing a Package Restore operation. Package Restore will attempt to install all the package dependencies exactly as they are defined in your .csproj file. It will start by installing the direct dependencies of your project, and then move on to dependencies of dependencies, and so on, until the full dependency graph is covered.\n\nThere are two ways to perform a Package Restore operation from Visual Studio:\n\nBuild Project/Build Solution will automatically perform a package restore\n\nRight-click on Solution and select Restore NuGet Packages\n\nFor more ways to restore packages and other related details, you can reference Microsoft's documentation.\n\nOne scenario where the restore capability is extremely useful is the case of an automated CI/CD pipeline. The pipeline does not need to care about storing the actual binary files of the package dependencies. All it needs to do to deploy a new environment is:\n\nSpin-up the actual host environment\n\nClone the repository locally on the host environment\n\nBuild the project or restore packages explicitly\n\nAlternatives to Visual Studio UI\n\nAlong with the Visual Studio UI, here are some other ways to manipulate packages in your project.\n\nPackage Manager Console\n\nYou can reach this via Tools -> NuGet Package Manager -> Package Manager Console.\n\nIn the console, you can use commands to:\n\nFind the desired package: Find-Package [package_name]\n\nInstall it: Install-Package [package_name]\n\nUninstall it: Uninstall-Package [package_name]\n\nUpdate it: Update-Package [package_name]\n\nFor more details about these commands and the console in general, see the documentation.\n\nDotnet CLI\n\nThe dotnet command-line tool can be used for .NET Core, .NET Standard, or any SDK-style project.\n\nYou can use it by opening a command line, switching to your project’s folder, and typing different commands to:\n\nInstall a package: dotnet add package [package_name]\n\nUninstall a package: dotnet remove package [package_name]\n\nUpdate a package: dotnet add package [package_name] without specifying the [-v] option will install the latest version\n\nList all package references for your project: dotnet list package\n\nRestore packages: dotnet restore and also dotnet build or dotnet run starting with .NET Core 2.0.\n\nFor more details about using the dotnet CLI, see the official documentation.\n\nNuGet CLI\n\nThe NuGet command-line tool can be used for .NET Framework or any non-SDK-style projects that still use the packages.config file to store the description of the package dependencies.\n\nAs a prerequisite, nuget.exe CLI needs to be downloaded from nuget.org and stored in a local folder that is added to the PATH environment variable.\n\nYou can use it by opening a command line, switching to your project’s folder, and typing different commands to:\n\nInstall a package: nuget install <packageID> -OutputDirectory packages\n\nInstall with a specific version: nuget install <packageID | configFilePath> -Version <version>\n\nRemove a package: For this, simply delete the package from the packages folder\n\nList all package references for your project: nuget list -Source <source>\n\nRestore packages: nuget restore MySolution.sln\n\nFor more details about NuGet CLI, see the documentation.\n\nAdditional Tips: Managing Dependencies in Visual Studio\n\nReinstalling a Package\n\nThere are several situations where it might be useful to reinstall a package, such as:\n\nBroken reference after package restore\n\nCorrupted project due to deleted files\n\nBroken project after package update\n\nRetargeting or upgrading a project\n\nDuring package development\n\nIf you find yourself in one of these situations, use one of the following ways to reinstall the package:\n\nPackage Manager Console: Run the Update-Package -reinstall command\n\nPackage Manager UI: Go to Installed tab, hit Uninstall, then go to Browse tab, search for the package name, select it, and hit Install.\n\nDotnet CLI: Run the dotnet restore command\n\nNuGet CLI: Delete the package folder and then run the nuget install <id> command\n\nUsing different versions of the same package in different projects within a solution is considered a bad practice. To check and solve this for your solution, go to Manage Packages for Solution and you will be presented with a fourth tab: Consolidate.\n\nHere, you can see a list of packages for which different versions are used throughout the solution. To solve the issue, simply select the projects you want to update, select the version you want to use in all of them, and then hit the Install button.\n\nPackages.config\n\nSome projects use a file called packages.config to record the package dependencies. This is an alternative to having that information stored in the .csproj file in the PackageReference nodes. The NuGet CLI uses the packages.config file as reference.\n\nVisual Studio allows you to select either packages.config or PackagesReference to use as the default support for package management. You can set this up by going to Tools -> Options -> NuGet Package Manager settings:\n\nMigrate from packages.config to PackageReference\n\nThere are some advantages to using PackageReference and .csproj instead of the packages.config file for storing package dependency information:\n\nAll project dependencies are managed in one place: There’s no need for a secondary file (i.e. packages.config)\n\nSimple view of only top-level dependencies: .csproj only lists the direct dependencies as opposed to packages.config, which lists all dependencies.\n\nPerformance improvements in managing and using dependencies: In the PackageReference approach, the packages themselves are maintained in a folder structure outside of your solution\n\nMultiple options on PackageReference nodes that allow more refined control over dependencies\n\nTo migrate your project from the packages.config setup to PackageReferences, simply right-click on the References node in your Solution Explorer and select Migrate packages.config to PackageReference.\n\nSee the documentation for more details about this operation.\n\nManaging Dependencies in Visual Studio: The Bottom Line\n\nThird-party code is an essential part of software development for essentially every organization. However, using it can create challenges with dependency management, especially for larger projects.\n\nFortunately, package managers have been invented — multiple options exist for different development environments and frameworks.\n\nFor the .NET ecosystem, NuGet is the solution to package management that can simplify and abstract away most of that complexity. Hopefully this article has encouraged you to start using NuGet or has taught you something new about NuGet if you were already using it.\n\nHappy coding!\n\nAbout the Author\n\nCristian Taran is a seasoned full-stack software engineer who specializes in the Microsoft tech stack. His recent weapons of choice include React JS, Python, .NET Core, and MS SQL Server. Whether he is coding, working out, or playing video games, he prefers doing it to the sound of music."
    }
}