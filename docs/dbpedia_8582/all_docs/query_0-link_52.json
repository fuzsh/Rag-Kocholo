{
    "id": "dbpedia_8582_0",
    "rank": 52,
    "data": {
        "url": "https://blog.postsharp.net/singleton",
        "read_more_link": "",
        "language": "en",
        "title": "The Singleton Pattern in C# Today Is Not Your Dad's One!",
        "top_image": "https://blog.postsharp.net/assets/images/2024/2024-08-singleton/singleton-dark.svg.g.png",
        "meta_img": "https://blog.postsharp.net/assets/images/2024/2024-08-singleton/singleton-dark.svg.g.png",
        "images": [
            "https://www.postsharp.net/images/icon/sxs-metalama.svg?etag=a59cbd28dd9d4d687127f3fcc046d3b8",
            "https://www.postsharp.net/images/icon/sxs-postsharp.svg?etag=12df22813495bc1ebfc3fd8dba14ce0b",
            "https://blog.postsharp.net/assets/images/2024/2024-08-singleton/singleton-dark.svg",
            "https://blog.postsharp.net/assets/images/icons/twitter_p.svg",
            "https://blog.postsharp.net/assets/images/icons/linkedin_p.svg",
            "https://blog.postsharp.net/assets/images/icons/rss.svg",
            "https://blog.postsharp.net/assets/images/icons/slack.svg",
            "https://blog.postsharp.net/assets/images/icons/twitter_p.svg",
            "https://blog.postsharp.net/assets/images/icons/linkedin_p.svg",
            "https://blog.postsharp.net/assets/images/icons/rss.svg",
            "https://blog.postsharp.net/assets/images/icons/slack.svg",
            "https://blog.postsharp.net/assets/images/postsharp_logo.svg",
            "https://blog.postsharp.net/assets/images/icons/Microsoft Logo-Negative.svg",
            "https://blog.postsharp.net/assets/images/icons/Visual Studio Logo-Negative.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "singleton in c#",
            "singleton implementation c#",
            "singleton design pattern c#",
            "c# singleton pattern"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-08-01T07:00:01+00:00",
        "summary": "",
        "meta_description": "How to implement the Singleton pattern in C#? How to avoid its pitfalls by using dependency injection and architectural validation? Find out in this article.",
        "meta_lang": "en",
        "meta_favicon": "/assets/images/icons/apple-icon-60x60.png",
        "meta_site_name": "",
        "canonical_link": "https://blog.postsharp.net/singleton",
        "text": "The Singleton pattern is one of the oldest, but its role and implementation in modern C# have evolved. This article presents two versions of Singleton in C#: the classic âGoFâ version and the modern, DI-friendly one. We briefly discuss techniques that ensure that the essence of Singleton classes is respected through the code base, i.e., that instances are not illegally created.\n\nWhat is a Singleton in modern C#?\n\nA Singleton is a class whose a single instance can exist in the application.\n\nItâs one of the original design patterns described in the 1994 Design Patterns book by the âGang of Fourâ.\n\nInitially, the interpretation of the Singleton process was that a single instance could exist per process.\n\nIn modern C#, where dependency injection and unit testing are ubiquitous, the definition of a Singleton has evolved: it now means a class whose a single instance can exist in each application context, and each unit test typically has its own application context, but all share the same process.\n\nWhen should you use the Singleton pattern?\n\nThe Singleton pattern feels so natural that you probably already use it without knowing itâs a pattern.\n\nEnsuring that only a single object instance exists is essential in several cases:\n\nWhen access to an external resource, such as a file, must be synchronized.\n\nWhen shared data must be kept consistent.\n\nTo optimize access to a resource-intensive functionality, where a Singleton can significantly reduce memory and processing overhead.\n\nAs we will see in this article, the Singleton pattern has evolved. Nowadays, most application services managed by the dependency injection container are de facto singletons.\n\nThe classic Singleton pattern\n\nThe classic implementation of the Singleton pattern involves having a private constructor in the class, preventing it from being instantiated from outside and exposing a single instance through a static member.\n\nA performance counter manager serves as an excellent example for the Singleton pattern, as its metrics must be consistently gathered across the entire application:\n\nHere is the implementation of the Singleton pattern:\n\nAs you can see, this class has a private constructor that prevents it from being instantiated from outside and a static Instance property that holds the only class instance. Like any static initializer in .NET, it is guaranteed to be executed a single time before any other member of the type is accessed, ensuring a single instance of the type.\n\nSince the single instance is shared across the whole application, you need to make the type thread-safe, as its public members can be accessed from any thread. In the example above, this is done using ConcurrentDictionary and a lock.\n\nReducing the Singleton boilerplate\n\nImplementing the Singleton pattern requires some boilerplate code, which can be avoided by using either Roslyn source generators or Metalama, a more straightforward code generator for C#.\n\nRegardless of the technique you choose, itâs good practice to mark singletons with a [Singleton] custom attribute. This practice makes it immediately apparent to anyone reading the code, Â without parsing the implementation details, that the class follows the Singleton pattern:\n\nTo check the implementation of the [Singleton] attribute, refer to this example in the Metalama documentation. It generates the same code as above and conveniently reports warnings if the type contains accessible constructors.\n\nIs Singleton an anti-pattern?\n\nThe main problem with the classic Singleton pattern is that it tightly couples singleton consumers with singleton implementations. Tight coupling means you canât easily replace the singleton implementation with a different one or have multiple instances of the class.\n\nThis can be especially problematic when writing unit tests for two reasons:\n\nYou will certainly want to run your tests in parallel, so you must isolate them from each other. In this case, you will often need one instance of some singleton classes for each test. For instance, if I want to test the PerformanceCounterManager class, I will want each test method to have its own instance.\n\nYou might want your tests to use a specific implementation of the Singleton. For instance, we might want our PerformanceCounterManager to use AWS in production but an in-memory mock for unit tests.\n\nThe incompatibility of the classic Singleton pattern with the whole Dependency Injection paradigm is why Singleton is sometimes considered an anti-pattern, i.e., something to avoid.\n\nThese issues can be alleviated by having the Singleton class implement an interface and accessing it through the interface. Now, you are on your way toward the modern version of the Singleton pattern, which uses dependency injection.\n\nThe modern Singleton pattern\n\nThe modern Singleton pattern is an evolution of the classic pattern, allowing one instance of the Singleton class per context. In production, there is typically a single context for the whole application, which means thereâs only one instance of the Singleton class for the entire application. Each unit test, however, would have its own context, which means each test would have its own instance of the Singleton class. In modern .NET, the Singleton concept is built into the concept of a service container, also called a dependency injection (DI) container.\n\nIf youâre using the most common Microsoft.Extensions.DependencyInjection DI framework, you typically add a singleton to an IServiceCollection using the AddSingleton extension method. Today, itâs hard to think of a case where you might want a Singleton but not use IServiceCollection.AddSingleton.\n\nTherefore, todayâs Singletons are almost indistinguishable from other service classes (those managed by the DI framework) because most of these services are indeed singletons. They are regular classes, have a public constructor, can have dependencies, and usually implement an interface.\n\nHere is a modern variation of the PerformanceCounterManager. The significant changes here are that the class is now abstracted by an IPerformanceCounterManager interface, has a public constructor that accepts a dependency to an abstracted IPerformanceCounterUploader, and does not have the landmark static Instance property.\n\nThe only thing that makes this class a Singleton is that we are using AddSingleton to register it into our DI container:\n\nSince we are using AddSingleton, the DI container will create at most one class instance. And since a production application usually has only one DI container, the class will effectively be a Singleton.\n\nThis is different in tests, where each test commonly has its own DI container. This is precisely why we want to isolate the tests from each other.\n\nAnd speaking of tests, you can now write all kinds of tests related to PerformanceCounterManager:\n\nUnit tests for PerformanceCounterManager itself.\n\nUnit tests for classes that generally use PerformanceCounterManager but use a mock implementation for testing.\n\nIntegration tests, where the PerformanceCounterManager is used as an actual implementation.\n\nNone of these are easy or even possible with the classic Singleton pattern.\n\nPreventing illegal uses of a Singleton class\n\nThe modern DI-based approach seems to solve all the problems associated with the classic Singleton pattern.\n\nHowever, it brings its own problems: because of the presence of a public constructor, nothing is stopping you (and your colleagues!) from creating multiple instances of the class. While that is very useful for testing, it can be downright wrong in production code.\n\nHow do we prevent the constructor from being used outside the Startup class or unit tests? No C# feature would allow you to do that. We need another way to express these constraints in the code and a tool to enforce them. A few solutions are available:\n\nRoslyn analyzers tend to be excessively complex for this kind of verification unless youâre building a framework for thousands of developers.\n\nArchitectural unit tests verify your architecture from (almost) regular unit tests.\n\nMetalama can validate your code against your architecture in real time.\n\nLetâs dig into the last two options.\n\nArchitectural unit tests\n\nArchitectural unit testing aims to write unit tests that validate the architecture, running queries and assertions over the code model and failing if the constraints are unmet.\n\nThe leading project for architectural unit testing in .NET is ArchUnitNET.\n\nTo make this general, we first need to detect all modern Singletons in the code. As mentioned above, a practical idea is to mark them with a [Singleton] custom attribute. This attribute can have an empty implementation since it only works as a marker. The test would then look like this:\n\nAs is typical with ArchUnitNET, we first create an Architecture object, which includes all the assemblies to check. We then select all classes with the [Singleton] attribute and finally create a test that checks that none of the constructors of these classes are called.\n\nIf the constraint is violated, running the test will fail with a message like this:\n\nNote that this test ensures that constructors of singletons are never called in your code, leaving the reflection-based DI code as the only place where these constructors are called. If you have a reason to call the constructor of a Singleton manually in your DI code, you can add an exception to the test:\n\nThe problem with most architectural unit testing frameworks is that they behave like unit tests rather than code linters. In case of a violation, you end up with a broken test, while developers usually prefer having a squiggle directly in their code. To achieve this development experience, you must either write your own Roslyn analyzer or use Metalama, which is much simpler.\n\nMetalama Architecture Validation\n\nThe Metalama.Extensions.Architecture open-source package allows you to enforce architectural constraints both on-the-fly, in the IDE, and at build time. The library is quite flexible and offers several approaches. Here, weâll add the validation logic directly into the [Singleton] attribute. If youâve used Metalama aspects before, you may be familiar with the concept of an aspect, which often encapsulates code transformations. Another lesser-known feature of aspects is that they can perform code validation and report errors. This is what we are going to do here.\n\nThe [Singleton] aspect selects all constructors and calls the CanOnlyBeUsedFrom method, which produces a warning if the constructor is called from an unwanted part of the code.\n\nWhen the Singleton is misused, you will get a familiar squiggle in your code:\n\nIf you build your code (whether in your IDE or from your CI), you will get this kind of warning.\n\nAnd of course, double-clicking on the warning will get you straight to the offending line of code.\n\nConclusion\n\nThe Singleton pattern is one of the most classic and ubiquitous ones. With the adoption of unit testing and dependency injection, its implementation rules have widely evolved. Today, what defines a service as a singleton is the use of AddSingleton to add it to the DI container, ensuring that only one instance is created. However, this approach does not prevent multiple instances from being created since other parts of the code, unaware of the singleton nature of the service, may illegally use the public constructor. To address this issue, you can use architectural testing libraries or Metalama to enforce constraints on the Singleton class. Automatic code validation ensures that your Singleton class is used correctly and avoids potential issues in your codebase.\n\nÂ"
    }
}