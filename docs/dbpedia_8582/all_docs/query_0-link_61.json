{
    "id": "dbpedia_8582_0",
    "rank": 61,
    "data": {
        "url": "https://weblog.west-wind.com/posts/2022/Sep/11/Referencing-a-Local-Private-NuGet-Package-in-your-Solution",
        "read_more_link": "",
        "language": "en",
        "title": "Referencing a Local Private NuGet Package in your Solution",
        "top_image": "https://weblog.west-wind.com/images/2022/Referencing-a-Local-Private-NuGet-Package-in-your-Solution/Localz.jpg",
        "meta_img": "https://weblog.west-wind.com/images/2022/Referencing-a-Local-Private-NuGet-Package-in-your-Solution/Localz.jpg",
        "images": [
            "https://weblog.west-wind.com/images/HeroImages/RickHero16.jpg",
            "https://weblog.west-wind.com/images/rick175x175.jpg",
            "https://markdownmonster.west-wind.com/Images/MarkdownMonster_Icon_256.png",
            "https://webconnection.west-wind.com/favicon.png",
            "https://www.west-wind.com/images/foxIcon_small.gif",
            "https://support.west-wind.com/images/icon.png",
            "https://anti-trust.rocks/favicon.png",
            "https://pfy-prod-image-storage.s3.us-east-2.amazonaws.com/16851761/f2ae8be6-67dd-4223-bba0-100a3dcd63f8",
            "https://markdownmonster.west-wind.com/images/MarkdownMonster_Icon_32.png",
            "https://websurge.west-wind.com/favicon.png",
            "https://helpbuilder.west-wind.com/images/wwhelp32.png",
            "https://webconnection.west-wind.com/favicon.png",
            "https://weblog.west-wind.com/images/2022/Referencing-a-Local-Private-NuGet-Package-in-your-Solution/Localz.jpg",
            "https://weblog.west-wind.com/images/Sponsors/MarkdownMonster-Display.png",
            "https://weblog.west-wind.com/images/sponsors/TheMastersOfDisaster-Display.png",
            "https://weblog.west-wind.com/images/2022/Referencing-a-Local-Private-NuGet-Package-in-your-Solution/LocalPackageReferences.png",
            "https://weblog.west-wind.com/images/2022/Referencing-a-Local-Private-NuGet-Package-in-your-Solution/LocalSolutionLayout.png",
            "https://weblog.west-wind.com/images/2022/Referencing-a-Local-Private-NuGet-Package-in-your-Solution/ProjectRelativeNuGet.png",
            "https://weblog.west-wind.com/images/Sponsors/NeedsMoreBassTShirt-Display.png",
            "https://markdownmonster.west-wind.com/favicon.png",
            "https://weblog.west-wind.com/images/donation.png",
            "https://www.gravatar.com/avatar.php?gravatar_id=db3dbf59a3772da9555829eefe237751&size=100&rating=R",
            "https://www.gravatar.com/avatar.php?gravatar_id=beb7fdd4bcd15e35472a96ab8182f034&size=100&rating=R",
            "https://www.gravatar.com/avatar.php?gravatar_id=00&size=100&rating=R",
            "https://www.gravatar.com/avatar.php?gravatar_id=beb7fdd4bcd15e35472a96ab8182f034&size=100&rating=R",
            "https://www.gravatar.com/avatar.php?gravatar_id=00&size=100&rating=R",
            "https://weblog.west-wind.com/images/wwToolbarlogo.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Hood River",
            "facebook.com",
            "Rick Strahl"
        ],
        "publish_date": "2022-09-11T00:00:00",
        "summary": "",
        "meta_description": "I recently needed to add a local reference to my project and I couldn't quite figure out the best way to do it in a transparent way to consumers of the repository, so that they wouldn't have to explicitly configure additional build settings in order to find dependencies. In this post I discuss how to add local references or use a local Nuget source to add non-public packages to your projects without explicit package feed configuration.",
        "meta_lang": "",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://weblog.west-wind.com/posts/2022/Sep/11/Referencing-a-Local-Private-NuGet-Package-in-your-Solution",
        "text": "On this page:\n\nThe other day I needed to reference a 'private' package or reference into a project that otherwise is public and published as a Git repository.\n\nThis is a rare scenario where I have a library that is not public, but that I'm using in an otherwise public project. I want to use the library, but don't necessarily want to publish a NuGet package or the source code as part of the repository for broad access.\n\nFurther, I want to make sure that if somebody pulls down the repository from Git that they can build the Solution without explicit configuration.\n\nThere are a couple of options for this:\n\nUse an Assembly Reference with a local Assembly File\n\nUse a local NuGet Feed\n\nFile Referencing a NuGet Package?\n\nYesterday I publicly mused that it would be nice to actually be able to use a referenced path in a Nuget Package Reference:\n\nIn a nutshell, I wouldn't mind seeing a relative path be able to pull in a NuGet reference from within a package reference in a project:\n\n<ItemGroup> <PackageReference Include=\"../SupportPackages/Westwind.Licensing/WestWind.Licensing.nupkg\" /> </ItemGroup>\n\nThis seems like a quick and logical way to refernece a NuGet package that doesn't come from a feed.\n\nI realize all sorts of things can go wrong with this if you hard code a path or that path is just not available. However, for the specific scenario of referencing project relative NuGet packages it seems like a good and somewhat logical approach for a simple and - judging from the comments to my Tweet - common scenario.\n\nAlas, while that specific scenario isn't supported, it turns out that there are other ways you can achieve this behavior with only a little more extra work by using a local NuGet feed that's specific to your project/solution. More on that in a minute.\n\nAdding Local References and Packages to a Project\n\nAs mentioned there are a couple of ways you can pull private code into a project by using:\n\nA local Assembly Reference\n\nUsing a private or local NuGet Feed\n\nUsing a Library Assembly Reference\n\nIn the past I've always used local assembly references for this scenario. Although it's kind of downplayed in .NET Core in favor of NuGet packages, you can still reference assemblies in Core projects.\n\nYou can use the <Reference> element in a project file and hard reference a .dll file to pull in an assembly reference.\n\nTo do this:\n\nCreate a folder inside of the project/solution\n\nCopy the assembly or build output folder into that folder\n\nFrom projects that need it, add an assembly reference to the DLL\n\nHere's what that looks like in a referencing project:\n\n<ItemGroup> <Reference include=\"../SupportAssemblies/Westwind.Licensing/Westwind.Licensing.dll\" /> <ItemGroup>\n\nwhere ../SupportAssemblies/Westwind.Licensing/ contains the full build output of from the Westwind.Licensing project. In this case it's just a single assembly with no dependencies, but if there were direct dependencies they would also show up in that folder and are required to resolve the dependencies when the assembly is loaded from this reference.\n\nThis works, and I've been using this approach for ages all the way back to .NET 1.x. But in this age of NuGet packages that can reference other dependencies more easily it seems a bit quaint ðŸ˜„. There are also potential complications when it comes to resolving dependencies especially these days when most libraries have other NuGet dependencies which can't be automatically resolved by an Assembly Reference unless the dependencies are explicitly output and copied into the library folder.\n\nSo while direct assembly referencing still works, NuGet referencing would be a better choice if it can be made self-contained.\n\nUsing a Solution or Project Local NuGet Source\n\nSo you can also use a local NuGet Source. I've always known that you can add a local NuGet package source, but in the past I've shied away from this solution because I thought - incorrectly - that would mean consumers of a repository would have to explicitly set up the secondary package source. Turns out that's not correct and you can pre-configure a package source as part of your Solution.\n\nAdditional Package Sources can be set in a number of places:\n\nGlobal Package Source\n\nThe global package source lives in %appdata%\\nuget\\nuget.config and looks like this:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?> <configuration> <packageSources> <add key=\"NuGet Package Source\" value=\"https://api.nuget.org/v3/index.json\" /> <add key=\"Microsoft Visual Studio Offline Packages\" value=\"C:\\Program Files (x86)\\Microsoft SDKs\\NuGetPackages\\\" /> <add key=\"Local NuGet\" value=\"c:\\projects\\nuget\" /> </packageSources> <apikeys> ... </apikeys> </configuration>\n\nThis configuration is set when you make changes to your package source configuration in most IDE tools like Visual Studio, Rider, OmniSharp etc.\n\nSolution Local Package Source\n\nBut you can also override this global nuget.config file with a local nuget.config in your local Solution Root folder. So to override or add additional package sources I can create a local file, add it to the Solution Root Folder and then add a package source like this:\n\n<configuration> <packageSources> <!-- package source is additive --> <add key=\"Westwind.WebStore Local\" value=\"./SupportPackages\" /> </packageSources> </configuration>\n\nI can now add any local packages into the SupportPackages folder and it will now be found on build.\n\nHere's what this looks like:\n\nAnd here's the local folder setup:\n\nWhile this is not as easy as a relative path package reference as per my original musing, it's still a pretty simple solution. As a bonus it works for many packages and doesn't require for projects to use any path references, so it's actually a cleaner solution.\n\nProject Specific PackageSource\n\nAnother even easier way to add a package source at the project level is to use <RestoreAdditionalProjectSources> in an individual .NET project, right inside of your project file.\n\nSo in my Westwind.Webstore.Business project I can now reference a project relative path:\n\n<PropertyGroup> <TargetFramework>net6.0</TargetFramework> <Version>0.1.2</Version> <RestoreAdditionalProjectSources>./_SupportPackages</RestoreAdditionalProjectSources> </PropertyGroup>\n\nwhich keeps the extra NuGet package tied to the project rather than the solution. I can of course still point back to the solution folder as well, but the real value of this option is that I can keep the NuGet reference with my specific project that needs it, keeping the dependency management confined to the project that needs it, rather than pushing it up to the Solution. This makes this approach portable even if the project is attached to another solution later.\n\nHere's what this looks like in my project:\n\nThanks to Patrick Westerhoff for pointing this out on Twitter - another option I had no idea existed.\n\nSummary\n\nI'll be the first to admit I waste a lot of time trying to find simple solutions like this, because I simply don't know about them. The MS Build process has so many components to it, and Microsoft has done a good job of extracting the most common features and defaulting them where everything 'just works' out of the box which is awesome (Kudos!). But when you end up doing a little bit different it's often really hard to discover the customizations that are available. This feature I describe here is great, but judging from responses to my Tweet few know about it. Hopefully a post like this helps out in discovery and taking advantage of this functionality a little bit more easily.\n\nThe ability to add a local Nuget.config to a solution or use <RestoreAdditionalProjectSources> in a project to override behavior are great tools to add a private NuGet feed that is pre-configured and doesn't required consumers of the project to fiddle with setting up a custom package source.\n\nIt ticks all the boxes for features and convenience - once you figured out the functionality is available. Well now I know, and perhaps if you didn't already, you now do too..."
    }
}