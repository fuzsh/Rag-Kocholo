APPLICATION PROGRAM POINT

Info

Publication number

EP1491029A4

EP1491029A4 EP03745136A EP03745136A EP1491029A4 EP 1491029 A4 EP1491029 A4 EP 1491029A4 EP 03745136 A EP03745136 A EP 03745136A EP 03745136 A EP03745136 A EP 03745136A EP 1491029 A4 EP1491029 A4 EP 1491029A4

Authority

EP

European Patent Office

Prior art keywords

application

protocol

allows

api

mssp

Prior art date

2002-03-18

Legal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)

Withdrawn

Application number

EP03745136A

Other languages

German (de)

English (en)

French (fr)

Other versions

EP1491029A1 (en

Inventor

Thomas E Hamilton

Clifford S Atwood

Current Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)

Bytemobile Network Services

Original Assignee

Proquent Systems Corp

Priority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)

2002-03-18

Filing date

2003-03-18

Publication date

2006-05-10

2003-03-18 Application filed by Proquent Systems Corp filed Critical Proquent Systems Corp

2004-12-29 Publication of EP1491029A1 publication Critical patent/EP1491029A1/en

2006-05-10 Publication of EP1491029A4 publication Critical patent/EP1491029A4/en

Status Withdrawn legal-status Critical Current

Links

Espacenet

EPO GPI

EP Register

Global Dossier

Discuss

Classifications

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04W—WIRELESS COMMUNICATION NETWORKS

H04W80/00—Wireless network protocols or protocol adaptations to wireless operation

H04W80/08—Upper layer protocols

H04W80/12—Application layer protocols, e.g. WAP [Wireless Application Protocol]

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04M—TELEPHONIC COMMUNICATION

H04M3/00—Automatic or semi-automatic exchanges

H04M3/42—Systems providing special services or facilities to subscribers

H04M3/4228—Systems providing special services or facilities to subscribers in networks

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04B—TRANSMISSION

H04B7/00—Radio transmission systems, i.e. using radiation field

H04B7/005—Control of transmission; Equalising

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION

H04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04M—TELEPHONIC COMMUNICATION

H04M3/00—Automatic or semi-automatic exchanges

H04M3/42—Systems providing special services or facilities to subscribers

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04M—TELEPHONIC COMMUNICATION

H04M2207/00—Type of exchange or network, i.e. telephonic medium, in which the telephonic communication takes place

H04M2207/18—Type of exchange or network, i.e. telephonic medium, in which the telephonic communication takes place wireless networks

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04M—TELEPHONIC COMMUNICATION

H04M3/00—Automatic or semi-automatic exchanges

H04M3/22—Arrangements for supervision, monitoring or testing

H04M3/36—Statistical metering, e.g. recording occasions when traffic exceeds capacity of trunks

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04Q—SELECTING

H04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems

H04Q2213/13003—Constructional details of switching devices

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04Q—SELECTING

H04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems

H04Q2213/1305—Software aspects

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04Q—SELECTING

H04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems

H04Q2213/13098—Mobile subscriber

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04Q—SELECTING

H04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems

H04Q2213/13109—Initializing, personal profile

H—ELECTRICITY

H04—ELECTRIC COMMUNICATION TECHNIQUE

H04Q—SELECTING

H04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems

H04Q2213/13349—Network management

Definitions

This invention relates to an application program interface (API).

API application program interface

an application program interface is a specific method prescribed by a computer operating system or by another application program by which a programmer writing an application program can make requests of the operating system or another application. More specifically, an API is a formalized set of software calls and routines that can be referenced by an application program in order to access supporting services.

the invention features a method including, in a network, receiving messages from an application program in an application program interface (API), and passing the messages from the API to a control process in a mobile service switching platform (MSSP).

API application program interface

MSSP mobile service switching platform

the network may be a wireless network.

the wireless network be be a second generation wireless network, a GSM network, a GPRS-enabled GSM network or a TDMA network.

the wireless network may be a CDMA network, a UMTS network, a TETRA network or a Tetrapol network.

the wireless network may be a DECT network, an AMPS network, a WLAN or a third generation wireless network.

the API may provide a protocol that allows the application program to control switching and routing functions in the MSSP.

the API may provide a protocol that allows the application program to redirect packet flow through the MSSP on a per-flow basis.

the API may provide a protocol that allows the application program to control policy decisions within the MSSP.

the API may include a protocol that allows the application program to arm initial detection points (IDPs) and services associated IDP events in the control process.

IDPs initial detection points

the API may include a protocol that ahows the application program to disarm IDPs and service associated ICP events in the control process.

the API may include a protocol that allows the application program to request event reports.

the API may include a protocol that allows the application program to specify programmed behavior at a detection point in the control process.

the API may include a protocol that allows the application program to configure data elements that are metered by the control process of the MSSP.

the API may include a protocol that allows the application program to request byte-based reporting.

the reporting may be session-based or flow-based.

the API may include a protocol that allows the application program to specify a cost of services provided.

the API may include a protocol that allows the application program to record a charge plan used in a detail record and a protocol that allows the application program to control when the detail record is written.

the API may include a protocol that allows the application program to obtain statistics for a session managed by the application program.

the API may include a protocol that allows the application program to obtain statistics for a flow managed by the application program.

the API may include a protocol that allows the application program to monitor a status of other applications connected to the control process of the MSSP.

the invention features an application program interface (API) including a set of application layer protocols that allows exchange of messages between an application process and a control process of a Mobile Service Switching Platform (MSSP) using Transmission Control Protocol/Internet Protocol (TCP/IP) network services.

API application program interface

MSSP Mobile Service Switching Platform

TCP/IP Transmission Control Protocol/Internet Protocol

the set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated -DP events in the control process.

the set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated -DP events in the control process.

IDPs initial detection points

the set of application layers protocols may include a protocol that allows the application process to request event reports from the control process.

the set of application layers protocols may include a protocol that allows the application process to specify programmed behavior at a detection point in the control process.

the set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process.

the set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process.

the reporting may include session-based reporting or flow-based reporting.

the set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP.

the set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP.

the set of application layers protocols may include a protocol that allows the application process to control when the detail record is written.

the set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process.

the set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process.

the set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process.

the invention features a system including a Gateway General Packet Radio Service Support Node (GGSN) linked to control process in a Mobile Service Switching Platform (MSSP), a group of globally connected computers linked to the control process, an application program interface (API) connected to the control process, and an application system executing an application process linked to the API.

GGSN Gateway General Packet Radio Service Support Node

MSSP Mobile Service Switching Platform

API application program interface

the system may include a General Packet Radio Service Support Node linked to the GGSN.

the system may include a Base Station Controller (BSC) linked to the General Packet Radio Service Support Node.

BSC Base Station Controller

the system may include a Base Transceiver Station (BTS) linked to the BSC and a mobile station (MS) linked to the BTS.

BTS Base Transceiver Station

MS mobile station

the API may include a set of application layer protocols that allows exchange of messages between the application process and the control process.

the set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated -DP events in the control process.

IDPs initial detection points

the set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated -DP events in the control process.

IDPs initial detection points

the set of application layers protocols may include a protocol that allows the application process to request event reports from the control process.

the set of application layers protocols may include a protocol that allows the application process to specify progr-immed behavior at a detection point in the control process.

the set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process.

the set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process. Reporting may be session-based or flow-based.

the set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP.

the set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP.

the set of application layers protocols may include a protocol that allows the application process to control when the detail record is written.

the set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process.

the set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process.

the set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process.

Embodiments of the invention may have one or more of the following advantages.

the Application Program Interface provides an application layer protocol that exchanges messages with a Mobile Service Switching Platform (MSSP) using simple TCP/IP network services that are available on almost all computer platforms.

the API provides a set of protocols that allow service logic contained in an external application program to control switching/routing functions of a Mobile Service Switching Platform.

the API provides a protocol for an operator to limit the scope of an application's detection points, in which a detection point is a defined place in a state machine of a control entity where application event reporting and/or control is possible.

the API provides a protocol that is common to all applications, regardless of application privileges.

the API provides a protocol that allows an application to arm and disarm Initial Detection Points (IDPs) in a Mobile Service Switching Platform (MSSP) and service associated -DP events, where an -DP is defined as a detection point armed so as to create a new control dialog with an application when conditions match given criteria.

IDPs Initial Detection Points

MSSP Mobile Service Switching Platform

the API provides a protocol that allows an application to request additional event reports subsequent to an Initial Detection Point event.

the application typically requests additional event reports.

the API provides a protocol that allows an application to specify programmed behavior at a Detection Point (DP) that does not require the involvement of the application.

DP Detection Point

Messages are used to match incoming requests to determine if the predefined service interaction should be executed.

the matching process is similar to the process used for Initial Detection Points in general and wildcards may be used in the fields to be matched. If a flow matches the criteria, the actions specified in the remainder of the message will be carried out with no application involvement. Actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.

a message is used to determine which events will be reported in the future for the flow if event reports are required.

Criteria to be matched may not overlap with armed Initial Detection Point criteria. If the request cannot be completed for any reason a message will be returned with a matching RequestlD and an error code indicating the nature of the failure. If the request completes successfully, another message is returned. Service Filtering remains active until cancelled by a specific message request.

the API provides a protocol that allows an application to configure data elements that are metered by a Mobile Service Switching Platform (MSSP).

MSSP Mobile Service Switching Platform

the API provides a protocol that allows an application to request byte based reporting. Reporting may be requested on a session or flow basis. Session based charge notification effectively causes the same charge notification criteria to be applied to all flows in the session. Registering for charge notification events causes the number of bytes of the specified type transferred in uplink and downlink directions to be metered.

a packet is the atomic unit counted and each packet either falls before the count is evaluated or after the count is evaluated. As a result, charge notification may not occur exactly on the byte count specified. For example, if notification was requested every 10K bytes, the notification may occur at 10.5 Kbytes if the packet that brought the count over 10K was slightly greater than 500 bytes. The actual counter values are provided in a message.

the API provides a protocol that allows an application to indicate a cost of the services provided and record a charge plan used in an MSSP detail record.

the API provides a protocol that allows an application to control when MSSP detail records are written.

the API provides a protocol that allows an application to obtain various statistics for a session or flow managed by the application.

the API provides a protocol that allows an application to monitor the status of other applications connected to the same MSSP instance.

the API provides a protocol that allows the redirection of packet flow on a per- flow basis.

FIG. 1 is a block diagram of a network.

FIG. 2 is a flow diagram of an interception process.

FIG. 3 is a flow diagram of the service application startup stage of FIG. 2.

FIG. 4 is a flow diagram of the service initialization stage of FIG. 2.

FIG. 5 is a flow diagram of the service deployment stage of FIG. 2.

FIG. 6 is a flow diagram of the service logic stage of FIG. 2.

FIG. 7 is a flow diagram of the shutdown stage of FIG. 2.

FIG. 8 is a table of data types used by the API of FIG. 1.

FIG. 9 is a block diagram of a communication path.

FIG. 10 is a block diagram of a TCP/IP byte stream divided into session messages by the transport layer.

FIG. 11 shows a table listing sample error codes.

FIG. 12 shows a table listing sample feature categories.

the network 10 may be a wireless network.

the wireless network may be, for example, a second generation wireless network, a Global System for Mobile Communications (GSM) network, or a General Packet Radio System (GPRS) enabled GSM.

the wireless network may be a Time Division Multiple Access (TDMA) network, a Code Division Multiple Access (CDMA) network, or a Universal Mobile Telecommunications System (UMTS) network.

the wireless network may be a TETRA network, a Tetrapol network, a DECT network, .an AMPS network, a wireless local area network (WLAN) or a third generation wireless network.

a GPRS enabled GSM network is described.

the network 10 includes a Mobile Station (MS) 12 connected to a Base Transceiver Station (BTS) 14.

BTS Base Transceiver Station

BSC Base Station Controller

the MS 12 is a station located within a mobile service intended to be used while in motion or during halts at unspecified points.

An example mobile station is a hand held cellular telephone.

the BTS 14 holds radio transceivers that define a cell and coordinates radio- link protocols with the MS 12.

the BTS 14 is a component of the network 10 from which all signals are sent and received.

the BTS 14, often called a cell phone tower, is linked to, and controlled by, a Base Station Controller (BSC) 16.

BSC Base Station Controller

the BSC 16 is a component in the network 10 that manages radio resources for one or more base transceiver stations, such as BTS 14, for example.

the BSC 16 is linked to a SGSN 18.

the SGSN 18 is a General Packet Radio Service Support (GPRS) Node that serves GPRS mobile by sending or receiving packets via the BSC 16.

the SGSN 18 is linked to a Gateway GPRS Support Node (GGSN) 20.

the GGSN 20 acts as a gateway between a General Packet Radio Service (GPRS) network and a Packet Switched Public Data Network (PSPDN).

GPRS General Packet Radio Service Support

PSPDN Packet Switched Public Data Network

the GGSN 20 is linked to a Mobile Service Switching Platform (MSSP) server

MSSP Mobile Service Switching Platform

the MSSP server 22 resides between the GGSN 20 and a globally networked group of computers, such as Internet 24.

the MSSP server 22 analyzes all of the

IP Internet Protocol

a MSSP control process 26 provides the capability to set triggers or event notifications and increment counters based on IP flow characteristics.

An IP flow can be thought of as an abstraction representing a movement of data between two endpoints, such as MS

the MSSP control process 26 uses these capabilities to implement internal services and detail reporting.

API 28 links the MSSP control process 26 to external applications 30.

the API 28 provides a mechanism for the external applications 30 to control the MSSP control process 26 to provide intelligent services.

the API 28, in various embodiments, may be implemented as, for example, a Corba based API, an XML based API, a PARLAY server, an OSA Server, or a JAIN server.

the MSSP server 22 functions as both an Internet router and an IP packet analyzer.

Data contained in a header field of an IP packet is defined in the Internet Engineering Task Force (IETF) RFC 791, incorporated herein by reference (see www.ietf.org).

the IETF is a large open international community of network designers, operators, vendors, and researchers concerned with the evolution of the Internet architecture and the smooth operation of the Internet.

IP Internet Protocol

IP provides for transmitting blocks of data called datagrams from sources to destinations, where sources and destinations are hosts identified by fixed length addresses.

the IP also provides for fragmentation and reassembly of long datagrams and, if necessary, for transmission through "small packet" networks.

the MSSP control process 26 is designed to analyze IP packet headers in real time to manage counters and signal when packet characteristics match specified conditions.

a signal may be an event report or a trigger.

An event report reports an occurrence of some event while continuing to monitor packet flow.

a trigger causes processing of the IP packet to be suspended until the MSSP control process 26 responds with specific instructions for resuming processing of the IP packet.

a trigger response may simply direct IP packet processing to be continued unchanged, or it may altar packet processing by specifying a different destination for the packet or cause the packet to be discarded altogether.

the API 28 provides, in one example, a way for the other applications 30 to communicate with the MSSP control process 26 and manipulate event reports and triggers.

the MSSP control process 26 manages many different types of IP packets.

the MSSP control process 26 is divided into different state machines (not shown), each state machine responsible for different types of packets.

a state machine is any device that stores the status of something at a given time and can operate on input to change the status and/or cause an action or output to take place for any given change.

state machines are used to develop and describe specific device or program interactions.

a detection point is a defined place in a state machine of a control entity where application event reporting and/or control are possible, and manageable through the API 28.

An Event Detection Point is a detection point armed within the context of an existing control dialog. Event detection points do not have explicit criteria; they are only applicable to a specific state machine instance of a control entity that generated the control dialog. In general, event detection points set within one control dialog do not affect a behavior of any other instance of that state machine. A complete set of detection points in a given state machine is known as a detection point class.

TCP Transmission Control Protocol

TCP provides a reliable, connection oriented communication path between two application processes (usually referred to as a client and a server).

the client initiates a connection and the server accepts the connection before any data can be exchanged.

the TCP protocol ensures that all of the data sent is received by the other side correctly and in the order that it was sent.

a client sends an IP packet to the server's IP address containing a TCP header with a "SYN" flag set and specifying a port number of the server application that it wishes to connect to.

the server accepts the connection by sending a similar SYN packet back to the client, and the client acknowledges the SYN from the server by sending an IP packet containing a TCP header with the "ACK" flag set.

Packets pass through the MSSP control process 26 in the MSSP server 22 on their way between a client, e.g., MS 12, and a server (not shown) residing on the Internet 24.

the MSSP control process 26 determines that the IP packet encapsulates TCP data and assigns the packet to TCP control logic.

the TCP control logic can distinguish each segment of the connection establishment.

the service application 30 can instruct the MSSP control process 26 tlirough the API 28 to generate a trigger that watches for a TCP SYN packet that has a destination that matches the server to be intercepted. This is referred to as an Initial Detection Point (-DP).

An -DP is a detection point armed so as to generate a new control dialog with an application when conditions match given criteria.

TCP SYN packets All other TCP packets, and TCP SYN packets directed to a different destination, continue to be processed normally.

a TCP SYN packet with a destination that matches the arming criteria causes processing of that packet to be suspended and an -DP event notification sent to the service application 30 that armed the -DP through the API 28.

the -DP event notification may include, for example, information from the suspended packet that the service application 30 may use to determine a correct destination for the connection.

the service application 30 then directs the MSSP control process 26 through the API 28 to resume packet processing with a different destination address.

the MSSP control process 26 forwards a modified TCP SYN packet to the new destination, where that server responds in a typical manner.

the service application's involvement is completely transparent, i.e., neither the client, e.g., MS 12, nor the server (not shown) on the Internet 24 is aware that any redirection has taken place.

Service applications 30 interact with the MSSP control process 26 by exchanging TCP/IP messages.

the API 28 listens for connections from service applications 30. When an application connection is made, the API 28 authenticates the identity of the connected service application 30 and looks up the features that the application is authorized to access.

the service application 30, once its communication session with the API 28 is established, requests a list of services that it is expected to provide from the MSSP control process 26 and then arms Initial Detection Points needed to implement those services. After that, the service application 30 waits for the MSSP control process 26 to signal when it has a packet that matches the arming criteria.

the service application 30 applies its service logic (not shown) through the API 28.

This service logic may, in addition to directing the packet to a chosen destination, configure additional metering for the packet flow that encountered the detection point, request additional event reports from this flow, indicate a charge plan that is applicable to the flow, request periodic charge notification events, or request flow statistics.

a default behavior of a service interaction between the MSSP control process 26 and the service logic of the application 30 may be specified without the need to implemenet a trigger detection point.

a source address, source port, destination address string within a data portion of a packet and protocol port are used to match incoming requests to determine if a predefined service interaction should be executed. If a flow matches the criteria, the actions specified in the remainder of the message are carried out. Example actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.

the service logic begins execution when an -DP is detected. The service logic receives an event notification that the detection point was encountered.

the service logic responds when the MSSP request instruction within a timeout period.

the response may modify the packet then forward it, release the flow or session, or redirect or connect the packet using the connect request.

Other requests may also be made to program policy filters to be applied to flow or session.

the service filter request may be used by the service logic to specify the service interaction to be carried out when the detection point is encountered.

the API 28 provides a connect request message that instructs the MSSP control process 26 to establish a connection to a specified destination address on a flow that is suspended at a trigger point.

the destination address may be different than the desitination address in the packet that matched the trigger condition. This allows the service logic in the service application 30 to, for example, route connections to a best available resource.

the API 28 provides a release flow message that instructs the MSSP control process 26 to terminate an active flow.

the MSSP control process 26 will terminate the flow and may provide any events or metering messages following confirmation of the termination.

the service application 30 manages and controls sponsored packet switched data services, which include any .and all unique network addresses that identify the packet switched data service, the policy decisions that determine how, and to which, packet switched data service provider the user is directed (e.g., a specific server on the Internet 24), and the policy decisions that determine which sponsor is to be billed for the session and on what basis.

Policy filters may be used to block IP traffic in either direction based on port, protocol, IP address, cookies, or other layer seven protocol characteristics.

the policy filters also allow the service logic to create and manage a wall garden or subscription based model.

the policy filters are dynamic in nature, allowing new services to be purchased dynamically and updated by the service logic.

the policy decisions for selection and billing may include rules that incorporate pre-agreements between an operator and third parties, either sponsors or service providers, as to the selection of the service provider and the method and basis of payment for the sponsor.

a policy decision of which service provider to make a connection to may be made at the time of the service request based upon such factors as a user identity, a location of the user, a time of day, a user class, a service provider class, network conditions, pre-agreement rules, and/or governmental regulations.

a policy decision of which sponsor to bill and on what basis can be made at time of the service request based upon similar factors such as the user identity, the location of the user, time of day, user class, service provider class, network conditions, pre-agreement rules, and/or governmental regulations.

a service interaction is defined by the service logic as having a beginning, middle, and end.

the beginning of service interaction is typically identified by an -DP

the service interaction is bounded by the sequence of events and API calls received and made by the service logic between the -DP and the terminal event.

a service interaction is usually billable event that causes the service logic to write a CDR following the end of the interaction.

the details of service interaction boundaries are determined by the service logic.

a stock quote service for example may begin when an -DP matching the request is reported, and end on the response containing the quote. This same example can be expanded to include, for example, file downloads and email delivery.

the MSSP provides the means to detect and control an interaction and the service logic is responsible for making the API calls and processing events to implement the service.

an interception process 50 includes a service application startup stage 52, a service initialization stage 54, a service deployment stage 56, a service logic stage 58 and a shutdown stage 60.

the service application startup stage 52 includes initializing (70) a tr.ansport layer.

the transport layer is initialized (70) by creating a TCP/IP socket and connecting the socket through the API 28.

the stage 52 initializes (72) a session layer.

the initialization (72) includes sending a session open request to the MSSP server 22.

the MSSP server 22 authenticates the application's credentials.

a session open confirmation is received from the MSSP server 22.

the stage 52 initializes (74) an application layer.

the initialization (74) includes sending a negotiate API version request and receiving a negotiate API version confirmation. An open request is sent and confirmed.

the service initialization stage 54 includes sending (80) a get service list request; the MSSP server 22 looks up the services for this application.

the stage 54 receives (82) a get service list confirmation and sends (84) a get service detail request; the MSSP server 22 looks up configuration data for the service.

the stage 54 receives (86) a get service detail request confirmation.

the service deployment stage 56 includes sending (90) an Arm -DP request and receiving (92) an Arm -DP confirmation.

the MSSP server 22 verifies that the arming criteria meets any restrictions configured for the application and service and programs the ICP criteria into the MSSP server 22.

the service logic stage 58 includes receiving (100) an initial DP event.

the stage 58 determines (102) a new destination for the subscriber connection and sends (104) a connect request to the new destination.

the stage 58 receives (106) a connect confirmation.

the shutdown stage 60 includes sending (110) a disarm IDP request and receiving (112) a disarm -DP confirmation.

the stage 60 sends (114) a close request and receives (116) a close confirmation.

the stage 60 sends (118) a session close request, receives (120) a session close confirmation, and closes (122) the TCP/IP socket.

a table 130 shows a set of data types utilized to define fields within messages used by the API 28.

the table 130 includes a data type name 132, a definition 134, and a byte size 136.

CHAR[n] refers to a UTF-8 character string.

UTF-8 is a character encoding scheme in which the entire set of ASCII characters are encoded in one byte with the same encoding as ASCII while also allowing any of the full range of Unicode characters to be encoded using multiple-byte sequences in which no byte contains an ASCII character value.

All numeric data of more than one byte in length is transmitted in a canonical network byte order defined by TCP/IP standards, i.e., in order of most significant byte to least significant byte. It should be noted that to ensure application correctness and portability, application developers are encouraged to use their platform's host-to- network .and network-to-host conversion functions (such as htonl() and ntohl()) even when the host platform is known to use network byte order.

htonl() is an example UNIX function that converts 32-bit (4-byte) quantities from host byte order to network byte order

ntohl() is an example UNIX function that converts 32-bit quantities from network byte order to host byte order.

a communication path 140 (indicated by the arrows) between an application program 30 and the MSSP server 22 uses a layered architecture.

the application program 30 transmits data through its system's application layer 142, presentation layer 144, session layer 146, transport layer 148, TCP/IP layer 150 and lower layers 152, to corresponding lowers layers 154, TCP/IP layer 156, transport layer 158, session layer 160, presentation layer 162 and application layer 164 of the MSSP SERVER 22.

the tr.ansport layer 158 is used to provide a reliable transport to the session layer 160.

the transport layer 158 is relatively lightweight since it is layered on top of the local TCP/IP layer 156, which by definition is reliable.

the transport layer 158 receives messages from the session layer 160 that are then transmitted.

the transport layer 158 separates the byte stream provided by the TCP/IP layer 156 into messages that are framed by a transport header.

a frame is data that is transmitted between network points as a unit complete with addressing and necessary protocol control information.

a frame is usually transmitted serial bit by bit and contains a header field and a trailer field that "frame" the data.

a frame marker unlike some other protocols, does not itself determine a boundary of a transport message header.

the frame marker data pattern may also be present elsewhere in a TCP/IP byte stream with no adverse effects or special encoding.

the frame marker provides a means to detect common programming errors (such as improper byte ordering or length calculation errors) that might otherwise cause a receiver to incorrectly interpret some other data as a transport message header and take inappropriate action.

the API 28 uses an 8-byte transport message header as the first element in a message.

the 8-byte transport message header includes a 4-byte INIT "framemarker" field that is a constant value used to verify the presence of a valid transport message header. Any other value is indicative of a message framing error.

the 8-byte transport message header also includes a 4-byte "messagelength" field -and contains an UNIT data type representing the length, in bytes, of the message data that follows.

the API 28 utilizes session level interfaces built on top of the reliable TCP/TP transport layer that guarantees a message will arrive.

This session layer provides a set of session level services to the application layer. These services include authentication, session level heartbeats, and session level acknowledgements.

a heartbeat monitors the status of a communication link and identifies when the last of a string of messages is not received. When either end of a connection has not sent any data for a specified number of seconds, it will transmit a heartbeat message. When either end of the connection has not received any data for a specified number of seconds, it will tr.ansmit a test request message. If there is still no heartbeat message received after the same time then the connection is considered lost and corrective action initiated.

All messages exchanged at the session layer include a header of four USHORT 2-byte fields as the first element in the message.

the header is referred to as a session message header and includes a SessionMessage type field, a Sessionlnstance field, a SessionSendSeqNo field and a SessionReceiveSeqNo field.

the SessionMessage Type field contains a value that identifies the type of message and the format of the message data.

the Sessionlnstance field contains a value that uniquely identifies the session instance.

the SessionSendSeqNo field contains the send sequence number of the message.

the SessionReceiveSeqNo field contains the send sequence number from the last received message.

All session messages include a pair of sequence numbers in the Session Message Header that are set by the sender and verified by the receiver. Each sender starts at zero and increments the send sequence number for each message sent, hi addition, each sender keeps track of the next SessionSendSeqNo it expects to receive. Every message sent includes this number pair.

the sequence numbers are used to detect lost session messages as well as provide a means to acknowledge receipt of data.

the periodic exchange of sequence numbers in session heartbeat messages ensures that the sequence numbers remain up to date in the event that the session is idle with respect to SessData messages.

the session layer protocol version is negotiated during .an open sequence. A client specifies a desired version of the protocol to be used for the duration of the session.

the client initially specifies the highest version of the protocol supported by the client.

a server examines the requested version number and compares it against the versions it supports. If the requested version is in the range of versions supported by the server, the acceptance of the version is indicated in a subsequent SessOpenConf message. If the client has requested a version beyond those supported by the server, the server responds with a SessOpenConf message indicating that the session has been established using the highest version supported by the server. This version will be different from what was originally requested by the client, hi the event that the server cannot find a mutually supported protocol version a SessError message with an error code of MSSP_E_INNALID_NERSION is sent and the session is closed.

session layer options are negotiated during the open sequence.

the client specifies the desired protocol options to be used for the duration of the session.

the client should always initially specify all options supported by the client.

the server examines the requested options mask and chooses those options that it supports.

the resulting mutual session options are communicated to the client in the subsequent SessOpenConf message. If the client is unable to function as a result of the options being reduced by the server, a SessError message with an error code of MSSP_E_INVALID_OPTIONS is sent to the server and the session closed.

a heartbeat interval is negotiated during the open sequence.

the client specifies its desired heartbeat interval in the SessOpenReq message, and the server responds with the heartbeat interval that the client should use in the subsequent

SessOpenConf message A client .and server exchange credentials during a session establishment sequence.

the client provides an encrypted Session Security Descriptor that is the MD5 message-digest of the SessOpenReq message (excluding the SessionSecurityDescriptor field) encrypted using a private key of a public/private key pair.

the MD5 message format is designed by RSA Data Security, Inc. and defined in IETF RFC 1321 (see www.ietf.org). Since a given application will likely open its session the same way every time, a random number field is provided in the message in order to prevent generating a "constant" message digest value and a resulting predictable Session Security Descriptor.

the MSSP server 22 configuration of the application contains the public key of the public/private key pair.

the server Upon receipt of the security descriptor in a SessOpenReq message, the server looks up the application in the MSSP server 22 configuration to obtain the client's public key, decrypt the given security descriptor using the public key, and verify that the decrypted result exactly matches the MD5 message-digest generated from the received message. If the credentials fail to validate, the server responds with a SessError message with an error code of MSSP_E_AUTH_FAILURE. If a number of successive failures occur in a unit amount of time, the server suspends listening for connection requests for a period of time not less than one minute.

the server provides a SessionSecurityDescriptor (that is the MD5 message-digest of the SessOpenConf message (excluding the SessionSecurityDescriptor field)) encrypted using the private key of a different public/private key pair) to the client in the SessOpenConf message.

the client decrypts the descriptor using the server's public key and authenticates the server. If the validation of the server credentials fail on the client side of the connection, the client sends a SessError message with an error code of MSSP_E_AUTH_FAILURE. If a number of successive failures occur in a unit amount of time, the client suspends connection requests for a period of time not less than one minute.

the SessOpenReq message is used to begin a session-level exchange of information between .an application and the API 28.

the SessOpenReq message is the first message that is after a transport layer connection has been established as described above.

the SessOpenReq message has the following format:

An 8-byte SessionHeader field that is a session header with a SessionMessage Type equal to Sess_Open_Req.

a 4-byte UNIT SessionNersion field that represents a session protocol version supported by the client.

a 4-byte UNIT SessionOptionsMask field that represents a bitwise combination of all the session layer options supported by the client.

a 4-byte UNIT SessionHeartbeathiterval field that represents the nominal interval between exchanges of session heartbeat messages in seconds.

a 4-byte UINT SessionApplicationlD field that represents a MSSP server 22 determined value uniquely identifying this client application in the MSSP server 22.

a 4-byte UNIT SessionRandonNum field represents any unpredictable value and is used to prevent predictable SessionSecurityDescriptor.

a 16-byte BYTE[16] SessionSecurityDescriptor field representing a session security descriptor that is a MD5 message-digest of the message (excluding this field) encrypted using the client's private key of a public/private key pair. The server decrypts the session security descriptor using its copy of the client's public key to authenticate the client.

the SessOpenConf message is used to complete an establishment of a session and communicate a result of negotiated parameters. This message is sent as the successful response to a SessOpenReq message and has the following format:

a 4-byte UINT SessionNersion field represents a session protocol version chosen for use by the server.

a 4-byte UNIT SessionOptionsMask field representing a bitwise combination of all of the client session layer options chosen by the server.

a 4-byte UNIT SessionHe-irtbeat-hterval field representing a nominal interval between exchanges of session heartbeat messages in seconds.

a 4-byte UNIT Sessions erverlD field represents a value uniquely identifying this MSSP SERVER 22 instance.

a 4-byte UNIT SessionRandonNum field represents any unpredictable value and is used to prevent predictable SessionSecurityDescriptor.

a 16-byte BYTE[16] SessionSecurityDescriptor field representing a session security descriptor that is the MD5 message-digest of the message (excluding this field) encrypted using the server's private key of a public/private key pair.

the client should decrypt the session security descriptor using its copy of the server's public key to authenticate the server.

a session requires that the client and server participate in a session maintenance procedure.

the session maintenance procedure ensures that inactive or idle sessions are functional as well as ensuring that the response time is within reasonable limits.

the session maintenance procedure is performed independent of whether or not other data is transmitted on the session.

the session maintenance procedure includes the exch-ange of a SessHeartbeatReq message, followed by a

SessHeartbeatConf message The session maintenance procedure is initiated from the client side of a connection by sending a SessHeartbeatReq message.

the server performs a set of operations to ensure the server is functioning properly and returns a SessHeartbeatConf message if all is well. If the server fails to respond within the heartbeat interval the client fails the session by sending a SessError message with an error code of MSSP_E_HEARTBEAT_TIMEOUT to the server.

the client makes heartbeat requests at aperiodic interval as specified in the SessOpenConf message at the time the session was established. The first client heartbeat is sent upon receiving the SessOpenConf message.

a client timer Upon sending a SessHeartbeatReq message, a client timer is set to the heartbeat interval and a SessHeartbeatReq sent when the timer expires.

the server expects to see a heartbeat request within the specified heartbeat interval.

the server sets a timer following the transmission of the SessOpenConf message and the timeout will be set to twice the heartbeat interval. If the timer should expire and a heartbeat request is not received, the server fails the session by sending a SessError message with an error code of MSSP_E_HEARTBEAT_TIMEOUT. Each time a new heartbeat request is received, the server side timer is reset. At any given instant only one heartbeat request is outstanding. Note that the heartbeat messages will also be used to acknowledge DATA messages or detect errors related to mismanagement of sequence numbers on an idle session connection.

the SessHeartbeatReq message is used to request verification that the session partner is operating normally and has the following format:

SessionMessageType SESSJHEARTBEATJREQ. A 4-byte UNIT

SessionHeartbeatlnstance field representing a value that uniquely identifies a given heartbeat in the session.

a 4-byte TIME SessionTimeStamp field represents a time that the heartbeat request was issued.

a 4-byte UNIT SessionHeartbeatlnterval field representing a nominal interval between exchanges of session heartbeat messages, in seconds. This may be different than the current heartbeat interval when the sender desires to negotiate a new heartbeat interval.

the SessHeartbeatConf message is used to complete the verification of the session partner's normal operational status. This message is sent as the successful response to a SessHeartbeatReq message.

the SessHeartbeatConf message has the following format:

An 8-byte SessionHeader field represents a session header with SessionMessageType equal to SESS_HEARTBEAT_CONF.

a 4-byte UNIT SessionHeartbeatlnstance field represents the same SessionHeartbeatlnstance value that was given in the corresponding heartbeat request.

a 4-byte TIME SessionTimeStamp field represents the same SessionTimeStamp value that was given in the corresponding heartbeat request.

a 4-byte UNIT SessionHeartbeatlnterval field representing a nominal interval between exchanges of session heartbeat messages, in seconds. This may be different than the current heartbeat interval when a new heartbeat interval has been negotiated.

a session may be closed by either client or server at anytime following successful session establishment.

a client or server initiates the closure procedure by sending a SessCloseReq message to the session partner.

the SessCloseReq message contains a code indicating the reason for the closure.

the requesting session partner shutdowns (in the socket sense) the transport layer following the tr.ansmission of the

SessCloseReq message The receiving session partner notifies the application layer to allow any outstanding requests on the session to be completed. Any queued session messages are sent prior to the transmission of the SessCloseConf message. Once the SessCloseConf message is sent, the transport connection shutdowns and the socket connection is closed from the side that requested the session be closed. A client may time-out a close request if a server fails to respond within a reasonable period of time. If a close request is timed-out by a client, a SessError message is sent to the server with an error code of MSSP_E_CLOSE_TIMEOUT.

a SessError message is sent to the requesting partner with an error code of MSSP_E_NO_SESSION. If a session is active or initialized and the session partner is unable to process a close request for any reason, the receiver sends a SessError message to the requestor with an error code of MSSP_E_UNSPECIFIED_FAILURE.

the SessCloseReq message is used to initiate the orderly termination of a session and has the following format:

SessionMessageType SESS_CLOSE_REQ.

SessionCloseReasonCode field represents a value indicating a reason for the closure of the session.

MSSP reason codes include, for example, normal operation, partial detail during normal operation, normal shutdown, subscriber logout, flow timeout and session timeout.

One purpose of establishing a session is to exchange data between a client and a server. Data messages may be exchanged between parties following the completion of the session open sequence.

the session layer does not interpret data messages. Received data messages are forwarded to the application layer for processing. Only the bytes contained in the SessionData field of a SessData message are forwarded to the application layer. This effectively removes the session portion of the message prior to passing it to the application. Messages received from the transport layer are also devoid of any transport layer headers or data, and the messages are complete prior to processing. The converse is also true when transmitting data.

the session layer encapsulates the application data in a session data message that is forwarded to the transport layer for transmission.

a SessData message SessData is used to transmit application layer data to the session partner and has the following format:

SessionData A variable length SessionData field representing data to be delivered to the application layer.

a session may fail from time to time due to communication or process failures. In the event of a session failure, the failure is reported asynchronously under the context of the session partner detecting the failure.

Either the client or the server side may send a SessError message.

a SessError message may be sent at anytime from the client side following the SessOpenReq message.

a SessError message may be sent at anytime from the server side including as a response to a SessOpenReq.

a SessError message contains an error code indicating the reason for the failure.

the session partner may or may not receive the SessError message depending upon the nature of the error. Following the transmission or receipt of a SessError message, data may not be sent over the session and the underlying transport connection should be shutdown and closed.

the SessError message is used to inform a session partner of an error condition that will prevent further session level communication; it has the following format:

a 4-byte UNIT SessionErrorCode field represents a value indicating a cause of the session failure.

a table 170 containing sample error codes is shown.

Capabilities of the MSSP server 22 maybe grouped into feature categories.

the applications 30 When applications 30 open their session with the MSSP server 22 the applications 30 specify what features they want through the API 28. Each MSSP feature has a corresponding privilege bit.

a configuration entry in a MSSP configuration database 32 residing in a MSSP storage device 34 for an application contains a set of feature privileges that control what features the application 30 is authorized to use. Only the requested features that are authorized for the application 30 are granted, and the application 30 is informed of the features that have successfully been obtained in the response to the request. Application attempts to use messages in a feature category that it has not been granted are refused with a privilege error. Referring to FIG. 12, a table 180 listing feature categories is shown.

Feature categories include a common services feature category 182, an Initial Detection Point feature category 184, an Event Reporting feature category 186, a Service Filter feature category 188, a Meter Configuration feature category 190, a Charge Notification feature category 192, a Charge Plane feature category 194, a Detail Record Control feature, category 196. a Statistics feature category 198, and an Application Monitor feature category 200. Messages associated with each of the feature categories 182- 200, with their respective format, are listed in Appendix A, and incorporated herein by reference.

MSSPNegotiateAPIVersionReq MSSPNegotiateAPIVersionConf

MSSPOpenReq MSSPOpenConf

MSSPCIoseReq MSSPCIoseConf

MSSPFailureConf MSSPFailureEvent

MSSPGetSystemTimeReq MSSPGetSystemTimeConf

MSSPGetServiceListReq MSSPGetServiceListConf

MSSPGetServiceDetailReq MSSPGetServiceDetailConf.

This message is sent by the application to the MSSP 22 to indicate the API version that it would like to use for application-level communication.

the API version must be negotiated before any other application messages can be exchanged since the message formats will vary. Only MSSPNegotiateAPIVersionReq, MSSPNegotiateAPIVersionConf, and MSSPFailureConf are guaranteed to have the same message format in all API versions. This is the first message that should be sent after a communication session has been established as described in the previous section.

the MSSP 22 replies with an MSSPNegotiateAPIVersionConf message specifying the negotiated API version to be used for all further application messages. This will be the highest API version supported by MSSP 22 that is less than or equal to the application requested version. Inability to identify an API version common to both parties results in an MSSPFailureConf message being returned from the MSSP 22 with an error code of MSSP_E_INVALID_VERSION.

This message is sent by the MSSP 22 to acknowledge receipt of an MSSPNegotiateAPIVersionReq request message and provide the API version that has been chosen for all further application layer messages.

This message is used to begin the application-level exchange of information between the application and the MSSP 22. This is the first message that should be sent after the API version has been established as described above. The application uses this message to request access one or more features of the MSSP 22.

Message Flow Diagram :

MSSP 22 Feature Masks MSSPOpenConf

This message is sent by the MSSP 22 to acknowledge receipt of an MSSPOpenReq request message.

the message indicates which of the services that were requested in the MSSPOpenReq have actually been granted.

This message is used to terminate the application-level exchange of information between the application and the MSSP 22.

MSSPFailureConf "" Message Format

This message is sent by the MSSP 22 to acknowledge receipt of an MSSPCIoseReq request message. No further application-level messages will be sent from the MSSP 22 or accepted from the application.

This message is sent by the MSSP 22 when an error condition prevents successful processing of a previous application request message.

the message contains the RequestID that was specified in the application's request message as well as an error code indicating the reason for the failure.

This message is sent by the MSSP 22 when an error condition occurs that is not directly associated with the processing of a previous application request message.

the message contains an error code indicating the reason for the failure.

This message is sent by the MSSP 22 in response to an MSSPGetSystemTimeReq request message.

MSSPGetSystemTimeConf Message Format MSSPGetServiceListReq

This message is used to request the list of MSSP 22 service identifiers that the application has been configured to provide.

This message is sent by the MSSP 22 in response to an MSSPGetServiceListReq request message.

This message is used to request detailed information about the configuration of a specified MSSP 22 service.

the application may only request details for services that it is configured to provide.

This message is sent by the MSSP 22 in response to an MSSPGetServiceDetailReq request message.

This message is sent by the MSSP 22 when a service is removed from the list of services that the application is configured to provide while the application is connected to the MSSP 22. Any service resources (such as detection points) used by the application are automatically released by the MSSP 22.

This message is sent by the MSSP 22 when failure conditions or MSSP 22 hardware reconfiguration has caused a resource used by the application to become unavailable.

An MSSPResourceAvailableEvent message will be sent when the resource is restored to normal operation.

This message is sent by the MSSP 22 when a resource that was previously reported unavailable in an MSSPResourceUnavailableEvent has been restored to normal operation.

MSSPInitialDPEvent MSSPContinueReq

MSSPContinueConf MSSPConnectReq

MSSPReleaseReq MSSPReleaseConf

MSSPActivityTestReq MSSPActivityTestConf.

This request is used to identify an initial detection point and specify the traffic criteria that should cause an application to be notified.

the initial detection point may be armed for simple event notification or as a trigger, depending upon the setting of the TakeControl field. Setting the TakeControl field to MSSP_TRIGGER arms a trigger.

MSSPContinueReq MSSPConnectReq

MSSPControlReq MSSPControlReq

MSSPReleaseReq MSSPReleaseReq

the criteria strings may contain wildcard values that may be used to specify a wide range of triggers.

the MSSP 22 sends an MSSPArmlDPConf message after the IDP is successfully armed. In the event that error conditions prevent arming the IDP an MSSPFailureConf message is returned instead indicating the reason for the failure.

Detection points with "IDPâ attributes may be armed as an initial detection point.

Detection points with "Triggerâ attributes may be armed as either a trigger or an event report. Detection points that are not listed with the "Trigger" attribute are only capable of providing event reports

This class of detection points allows an application to implement policy decisions when various subscriber group limits are exceeded.

the application provides the limiting values in the IDP arming criteria. If the IDP is armed as a trigger, the application may decide whether to allow the limit to be exceeded or not by sending Continue or Release trigger responses, respectively.

This class of detection points allows an application to monitor and control the establishment and termination of mobile subscriber sessions. If the IDP is armed as a trigger, the application may decide whether to allow the subscriber session to proceed or not by sending Continue or Release trigger responses, respectively.

a zero-length StringValue may be specified as a wild-card that matches any subscriber.

This class of detection points allows an application to monitor and control the Remote Authentication Dial In User Service (RADIUS) protocol activity of mobile subscriber sessions. If the -DP is armed as a trigger, the application may issue control operations to control subscriber acceptance and alter RADIUS message attributes.

RADIUS Remote Authentication Dial In User Service

a zero-length StringValue may be specified as a wild- card that matches any subscriber.

Control Operations The following control operations are defined:

DHCP Detection Point Class This class of detection points allows an application to monitor and control the Dynamic Host Configuration Protocol (DHCP) activity of mobile subscriber sessions.

DHCP Dynamic Host Configuration Protocol

the DestinationIP parameters in the Initial DP Event message from the DP_DHCP_ACK detection point contain the IP address being assigned to the subscriber.

StringValue may be specified as a wild-card that matches any subscriber.

This class of detection points allows an application to monitor and control the Domain Name System (DNS) protocol activity of mobile subscriber sessions. Control operations are defined that allow an application to provide an IP address to resolve a mobile subscriber DNS query.

DNS Domain Name System

the DestinationIP parameters in the Initial DP Event message from the DP_DNS_QUERY_RESPONSE detection point contain the IP address returned from the DNS server.

StringValue may specify a partial wild-card of the form "*. domain", such as "*.yahoo.comâ.

a zero-length StringValue may also be specified as a wild-card that matches any hostname.

This class of detection points allows an application to monitor and control the Transmission Control Protocol (TCP) activities of mobile subscriber sessions.

TCP Transmission Control Protocol

Wild-card values may be specified for OperatorlD, SubscriberGroupID,

SourcelPAddress and Destination I PAddress may be specified as a partial wild-card IP address by specifying the number of address bits that must match (from left-to-right).

a zero-length IPAddress may be specified as a wild-card that matches any IP address.

IP Internet Protocol

Wild-card values may be specified for OperatorlD, SubscriberGroupID,

SourcelPAddress and DestinationlPAddress may be specified as a partial wild-card IP address by specifying the number of address bits that must match (from left-to-right).

a zero-length IPAddress may be specified as a wild-card that matches any IP addressA zero-length

StringValue may be specified as a wild-card that matches any subscriber.

This message is sent by the MSSP 22 to acknowledge successful arming of an Initial Detection Point by a previous MSSPArmlDPReq message.

MSSPArmlDPConf Message Format MSSPDisarmlDPReq

This request is used to disarm an initial detection point, causing a previously established set of traffic criteria to be discarded.

This message is sent by the MSSP 22 to acknowledge successful disarming of an Initial Detection Point by a previous MSSPDisarmlDPReq message.

the initial detection point event is used to indicate that the conditions described by the criteria at a previously armed initial detection point have been met. Detection points are armed in order to get visibility or control of data flows matching a particular pattern.

the IDP Event Indication provides fully qualified data for all of the criteria relevant to that detection point whether or not wild cards were used in the arming criteria.

Initial Detection Points that have been armed with the TakeControl option set are known as triggers.

the initial detection point event sent to the associated application to indicate that a trigger or an event detection point has been hit will indicate if the detection point is due to a trigger detection point by setting the TakeControl flag to MSSP TRIGGER in the event message.

the application must respond to a trigger detction event by sending one of the following requests:

MSSPContinueReq MSSPConnectReq

MSSPControlReq MSSPControlReq

MSSPReleaseReq MSSPReleaseReq

the continue request will cause normal processing to resume on a packet that was previously suspended at a trigger point. This request might be used to provide an application synchronization point where the application can pace connection requests.

the packet to be continued and its associated context is identified by the ControllD field within the request message.

an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJ â VALID_CO â TROL_ID. If the ControllD is valid but not waiting at a trigger detection point, an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSPJ â JNVALID_STATE. If the continuation operation is successful an MSSPContinueConfwi ' U be sent to positively confirm that packet processing has been continued.

This message is sent by the MSSP 22 to acknowledge successful continuation of packet processing by a previous MSSPContinueReq message.

the connect request will instruct the MSSP 22 to establish a connection to the specified destination address on a packet that was previously suspended at a trigger point.

the destination address may be different than the destination address in the packet that matched the trigger condition. This will allow the application to route connections to the best available resource as well as supply a means for virtualization of Packet â OO services.

the suspended packet and its associated context is identified by the ControllD field within the request message, and the destination fields will provide IP address and port number on which the connection will be established.

the EventReportMask and TriggerMask can be used to request subsequent event reports and triggers from this instance of the detection point class.

an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJNVALID_CONTROL_ID. If the ControllD is valid but not waiting at a trigger detection point, an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_E_INVALID_STATE. If the connect operation is successful, an MSSPConnectConf Will be sent to positively confirm that packet processing has resumed.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPConnectReq message.

This message will be issued to perform control operations upon the suspended packet.

the suspended packet and its associated context is identified by the ControllD field within the request message. If the ControllD is not valid an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJNVALlD_CONTROLJD. If the ControllD is valid but not waiting at a trigger detection point, an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_E_INVALID_STATE.

an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJNVALID_CONTROL_pP.

An MSSPControlConf will be sent if the control operation is successful.

each field is identified by a two-byte tag, followed by a two-byte length field that specifies the byte size of the following data, followed by the data.

Each additional message field is simply appended to the message. The overall length of the message (provided by the underlying transport mechanism) can be used to determine the presence of these "floating" fields.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPControlReq message.

This message is issued to terminate an active flow.

the flow to be terminated may be suspended at a trigger or may be active.

the MSSP 22 will terminate the flow and provide any events or metering messages following the transmission of an MSSPReleaseConf message. The confirmation will be ordered prior to any events or metering messages resulting from the termination of the flow. If this message is being sent as the response to a trigger the suspended packet and its associated context is identified by the ControllD field within the request message. If the ControllD value in the message is zero then the (active) flow to be terminated is identified by the FlowlD field.

the ReasonCode field will contain a numeric value indicating the reason for terminating the flow.

the ReasonCode value will be stored in any detail records generated for the flow.

An MSSPReleaseConf message will be sent to positively confirm a release flow operation.

An MSSPFailureConf message with an error code of MSSP_E_INVALID_CONTROLJD will be returned in the event the ControllD field is invalid.

An MSSPFailureConf message with an error code of MSSP_EJNVALID_FL0W_1D will be returned in the event the FlowlD field is invalid.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPReleaseReq message.

This request may be used to check the status of a previously reported flow or session.

An MSSPActivityTestConf will be returned if the specified flow is still valid (active). If the flow identified by FlowlD is not valid an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_E_INVALID_FLOWJD.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPActivityTestReq message.

the messages in this section allow an application to request additional event reports subsequent to an Initial Detection Point event.

the application When the IDP that initiates a control dialog is a trigger, the application typically requests additional event reports via the EventReportMask and/or TriggerMask fields in an MSSPContinueReq or MSSPConnectReq response to the IDP event.

the MSSPEventReportReq request is the only means of requesting additional event reports.

MSSPEventReportReq MSSPEventReportConf

MSSPEventReportEvent MSSPEventReportEvent

This message may be used to arm an event reporting detection point.

the detection point will be armed as an event detection point for the indicated flow only, and events will be sent for cases where the flow passes through a control state specified within any of the event report or trigger masks.

the MSSP 22 Upon receiving the event report request the MSSP 22 will arm the detection point(s) and send a confirmation indicating the success of the arming operation. In the event that a failure occurs while trying to arm the requested detection point(s) an MSSPFailureConf ' will be returned indicating the reason for the failure.

This request will result in MSSPEventReportEvent messages being sent to indicate that the flow has transitioned through the specified states.

This request differs from the MSSPArmlDPReq in the sense that it is used to change event reporting for a single, existing flow while the MSSPArmlDPReq request establishes the starting point where flows are first monitored.

An MSSPEventReportReq for a flow that already has event reporting detection points armed has the effect of superceding the previous request.

An MSSPEventReportReq with no EventReportMask or TriggerMask values set may be used to cancel all previously requested event reports and triggers for that control dialog.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPEventReportReq message.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPActivityTestReq message.

the messages in this section allow an application to specify programmed behavior at a detection point that does not require the involvement of the application.

the SourcelPAddress, SourcePort, DestinationlPAddress, and IPProtocolNumber fields will be used to match incoming requests to determine if the predefined service interaction should be executed.

the matching process is similar to the process used for initial detection points in general and wildcards may be used in the fields to be matched.

Actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.

the EventReportMask will be used to determine which events will be reported in the future for the flow if event reports are required. Criteria to be matched may not overlap with armed initial detection point criteria. If the request cannot be completed for any reason an MSSPFailureConf message will be returned with a matching RequestID and an error code indicating the nature of the failure. If the request completes successfully, an MSSPActivateServiceFilterConf is returned. Service Filtering will remain active until cancelled by an MSSPCancelServiceFilterReq request.

MSSPActivateServiceFilterReq MSSPActivateServiceFilterConf

MSSPCancelServiceFilterReq MSSPCancelServiceFiiterConf.

This request is used to I dentify an initial detection point and specify the traffic criteria that should cause a pre-determined behavior to be applied.

the MSSP 22 sends an MSSPActivateServiceFilterConf message after the IDP is successfully armed with the Service Filter. In the event that error conditions prevent arming the IDP an MSSPFailureConf message is returned instead indicating the reason for the failure.

This message is sent by the MSSP 22 to acknowledge successful arming of a Service Filter Initial Detection Point by a previous MSSPActivateServiceFilterReq message.

This request is used to cancel a service filter previously established by an MSSPActivateServiceFilterReq request.

This message is sent by the MSSP 22 to acknowledge successful cancellation of a Service Filter by a previous MSSPCancelServiceFilterReq message.

the messages in this section allow an application to configure the data elements that will be metered by the MSSP 22.

the meter configuration affects the meter elements that are populated in the MSSPGetStatsConf and MSSPPeriodicStatsEvent messages as well as detail records stored in the MSSP 22 database.

MSSPConfigureMetersReq MSSPConfigureMetersConf.

This message is used to configure the metering performed by the MSSP 22 at the lowest level.

the MeterClass field will contain one of two values,

the class field will be used to indicate the scope of the metering request.

the ObjectlD field will identify instance of the object to be metered based on the MeterClass. For instance, if the MeterClass is MSSP_METER_CLASS_SESSION the ObjectlD will represent the session identifier, and if the MeteringType is MSSP_METER_CLASS_FLOW the ObjectlD will represent the flow identifier.

the MetersEnabled field will contain a bit mask identifying the particular meters to be enabled within the class specified by the MeterClass field.

the MetersEnabled field specifies the new meter configuration for the object.

a zero value in the mask position of a previously configured meter causes that meter to be disabled, and a nonzero value in the mask position of a previously unconfigured meter causes that meter to be enabled.

the meter configuration affects the meter elements that are populated in the MSSPGetStatsConf and MSSPPeriodicStatsEvent messages as well as detail records stored in the MSSP 22 database.

the MSSP 22 will process the request and return an MSSPConfigureMetersConf message as a positive acknowledgement if the request is successful. An unsuccessful request will cause an MSSPFailureConf message to be sent as a negative acknowledgement.

the failure code value will contain one of the following values depending on the request parameter that failed validation:

MSSP_E_INVALID_METER_CLASS MSSP_EJNVAL)D_FLOWJD

MSSP_EJNVALID_SESSION_ID MSSP E INVALID FLOW METER MASK.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPConfigureMetersReq message.

Session based charge notification effectively causes the same charge notification criteria to be applied to all flows in the session.

Registering for charge notification events will cause the number of bytes of the specified type transferred in uplink and downlink directions to be metered.

an MSSPNotifyChargeEvent message is sent from the MSSP 22 to the application indicating the number of bytes that have been transferred, and the counters are reset and begin counting towards the threshold again. Charge notification continues until the flow terminates or charge notification is explicitly cancelled by an MSSPCancelNotifyChargeReq request.

a packet is the atomic unit counted and each packet will either fall before the count is evaluated or after the count is evaluated. As a result, charge notification may not occur exactly on the byte count specified. For example, if notification was requested every 10K bytes, the notification may occur at 10.5 Kbytes if the packet that brought the count over 10K was slightly greater than 500 bytes.

the actual counter values are provided in the MSSPNotifyChargeEvent message.

MSSPNotifyChargeReq MSSPNotifyChargeConf

MSSPCancelNotifyChargeReq MSSPCancelNotifyChargeConf

MSSPCancelNotifyChargeConf MSSPNotifyChargeEvent.

This request is used to register byte based reporting on either a session-wide or per-flow basis.

An MSSPNotifyChargeConf message will be sent to indicate that charge notification has successfully been enabled. If charge notification cannot be enabled an STL__FAILURE_CONF message will be sent to indicate failure and the error code field will identify the reason for the failure.

MSSPNotifyChargeReq Message Format MSSPNotifyChargeConf

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPNotifyChargeReq message.

This request is used to cancel byte based reporting established by a previous MSSPNotifyChargeReq request.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPCancelNotifyChargeReq message.

This message is used to notify the application that a previously registered charge notification threshold has been exceeded.

MSSPSetChargePlanReq MSSPSetChargePlanConf.

This message is used to record the charge plan used for a service in the MSSP 22 detail record.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPSetChargePlanReq message.

MSSPWriteDetailRecordReq MSSPWriteDetailRecordConf.

This message allows an application to control when detail records are written to the MSSP 22 database. Detail records that are written by this request automatically have a ReasonCode of MSSP_RC_PARTIAL_DETAIL assigned. Partial detail records are commonly used to guarantee that, in the event of an unrecoverable error, all but the most recent activities of a subscriber interaction are captured for billing purposes.

This message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPWriteDetailRecordReq message.

MSSPGetStatsReq MSSPGetStatsConf

MSSPPeriodicStatsEvent MSSPGetStatsReq

This request is used to request session or flow statistics.

the request may optionally request future updates, either periodically or upon flow or session termination.

Statistical values depend upon the meters configured by previous MSSPConfigureMetersReq requests.

the MSSP 22 will process the request and return an MSSPGetStatsConf message with the current statistical values as a positive acknowledgement if the request is successful.

MSSPPenodicStatsEvent messages will be sent if future updates were requested via the Interval field.

An unsuccessful request will cause an MSSPFailureConf message to be sent as a negative acknowledgement.

the failure code value will contain one of the following values depending on the request parameter that failed validation:

This request is used to return the session or flow statistics requested by a previous MSSPGetStatsReq request. Statistical values depend upon the meters configured by previous MSSPConfigureMetersReq requests.

Fields marked with * contain valid data only when the corresponding meter is configured in the MSSP 22 (as indicated in the EnabledMeterMaskf â e â ).

This request is used to return the periodic updates of session or flow statistics that were requested by a previous MSSPGetStatsReq request. Statistical values depend upon the meters configured by previous MSSPConfigureMetersReq requests.

Fields marked with * contain valid data only when the corresponding meter is configured in the MSSP 22 (as indicated in the

This message is sent by the MSSP 22 to report the occurrence of an application session event. This message is also sent by the MSSP 22 to an application with ApplicationMonitor privileges immediately after its session is opened, informing it of other (preexisting) application sessions.

Landscapes

Engineering & Computer Science (AREA)

Signal Processing (AREA)

Computer Networks & Wireless Communication (AREA)

Computer Security & Cryptography (AREA)

Data Exchanges In Wide-Area Networks (AREA)

Exchange Systems With Centralized Control (AREA)

EP03745136A 2002-03-18 2003-03-18 APPLICATION PROGRAM POINT Withdrawn EP1491029A4 (en)

Applications Claiming Priority (3)

Application Number Priority Date Filing Date Title US100468 2002-03-18 US10/100,468 US20030177283A1 (en) 2002-03-18 2002-03-18 Application program interface PCT/US2003/008401 WO2003081885A1 (en) 2002-03-18 2003-03-18 Application program interface

Publications (2)

Publication Number Publication Date EP1491029A1 EP1491029A1 (en) 2004-12-29 EP1491029A4 true EP1491029A4 (en) 2006-05-10

Family

ID=28039830

Family Applications (1)

Application Number Title Priority Date Filing Date EP03745136A Withdrawn EP1491029A4 (en) 2002-03-18 2003-03-18 APPLICATION PROGRAM POINT

Country Status (7)

Country Link US (1) US20030177283A1 (ja) EP (1) EP1491029A4 (ja) JP (1) JP2005521337A (ja) KR (1) KR20040108673A (ja) CN (1) CN1653790A (ja) AU (1) AU2003225863A1 (ja) WO (1) WO2003081885A1 (ja)

Families Citing this family (25)

* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title JP4365148B2 (ja) * 2002-07-19 2009-11-18 æ ªå¼ä¼ç¤¾ãªã³ã¼ ç»åå½¢æè£ ç½®åã³ã©ããã³ã°å¦çæ¹æ³ä¸¦ã³ã«ãã­ã°ã©ã JP4795247B2 (ja) * 2003-11-26 2011-10-19 ã¨ã¬ã¯ãã­ãã¯ã¹ ã¢ã³ã ãã¬ã³ãã¥ãã±ã¼ã·ã§ã³ãº ãªãµã¼ã ã¤ã³ã¹ããã¥ã¼ã ãã¸ã¿ã«ã¢ã¤ãã ã®ä½¿ç¨ã«å¿ããã¤ãã³ãå ±åã®ããã®ãã¼ã¿æ§é ãä¸¦ã³ã«ãããå©ç¨ããã¤ãã³ãå ±åã·ã¹ãã åã³ãã®æ¹æ³ US20050249190A1 (en) * 2004-05-06 2005-11-10 Oliver Birch Using a CCXML service node to provide call processing functionality for a parlay gateway US7437169B2 (en) * 2004-06-07 2008-10-14 Microsoft Corporation System and method for optimizing network communication in response to network conditions KR100560752B1 (ko) * 2004-07-21 2006-03-13 ì¼ì±ì ìì£¼ìíì¬ ìì¼ ì°ê²° ê´ë¦¬ ìì¤í  ë° ê·¸ ìì¼ ì°ê²° ìí ì²´í¬ ë°©ë² US7743152B2 (en) * 2005-10-31 2010-06-22 Qualcomm Incorporated Method and apparatus for detecting the presence of a terminal in a data session US8484326B2 (en) * 2006-09-28 2013-07-09 Rockstar Bidco Lp Application server billing US20080130660A1 (en) * 2006-10-19 2008-06-05 Jordi Ros-Giralt System and method of real-time control and scheduling for zero-queue distributed systems US8156219B2 (en) * 2007-08-03 2012-04-10 At&T Intellectual Property I, L.P. System and method of health monitoring and fault monitoring in a network system US20090183194A1 (en) * 2008-01-10 2009-07-16 Michael Raftelis Methods and apparatus to handle telecommunication service changes US8842632B2 (en) * 2008-02-14 2014-09-23 Alcatel Lucent Pre-registration, storing of pre-registration session information and session transfer in a wireless communication system US20090234955A1 (en) * 2008-03-13 2009-09-17 Mark Gregory Hanley Methods and Systems for Synchronization of Multiple Applications AU2009231676B2 (en) 2008-04-02 2013-10-03 Twilio Inc. System and method for processing telephony sessions US8837465B2 (en) 2008-04-02 2014-09-16 Twilio, Inc. System and method for processing telephony sessions CN101674327B (zh) * 2009-09-29 2012-12-26 éè¶è½¯ä»¶ï¼ä¸­å½ï¼æéå ¬å¸ å¼æç³»ç»æ¶æ¯éææ¹æ³ãæ¶æåç³»ç» CN102571880B (zh) * 2010-12-27 2014-11-05 ä¸­å½ç§»å¨éä¿¡éå¢å ¬å¸ ä¸ç§æå¡ååæ¹æ³åç³»ç»ä»¥åä¸ç§æå¡ååèç¹ CN103297480B (zh) * 2012-03-05 2017-09-22 è´¢ä»éæ¯ä»ç§ææéå ¬å¸ ä¸ç§åºç¨æå¡èªå¨æ£æµç³»ç»åæ¹æ³ JP2013207495A (ja) * 2012-03-28 2013-10-07 Kddi Corp åç·ç£è¦æ¹æ³ããã³æ¹å¼ US8832321B1 (en) * 2014-02-12 2014-09-09 tw telecom holdings, inc. External injection of cloud based network functions into network services US9118582B1 (en) * 2014-12-10 2015-08-25 Iboss, Inc. Network traffic management using port number redirection CN104519134B (zh) * 2014-12-25 2018-06-19 æ¼³å·é¡¶ç«¹éè®¯ææ¯æéå ¬å¸ ä¸ç§è·¨å¹³å°æä»¶è¯»åç³»ç»åæ¹æ³ US9832627B2 (en) * 2015-04-29 2017-11-28 Tata Consultancy Services Limited Method and system to include TETRA SS-LE member in public safety (PS) long term evolution group call service JP2017084322A (ja) * 2015-10-26 2017-05-18 æ ªå¼ä¼ç¤¾ãªã³ã¼ æ å ±ã·ã¹ãã ããã­ã°ã©ã åã³è¨é²åªä½ CN107273144A (zh) * 2017-08-15 2017-10-20 å¹¿å·å¸ç±è©æ°å»è¯ç§ææéå ¬å¸ å¿«éæå»ºç½ç»åºç¨ç¨åºæ¥å£çè£ ç½® CN107682314A (zh) * 2017-08-30 2018-02-09 åäº¬ææä¸è¾¾ç§æè¡ä»½æéå ¬å¸ ä¸ç§aptæ»å»çæ£æµæ¹æ³åè£ ç½®

Citations (1)

* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title WO2002012976A2 (en) * 2000-08-08 2002-02-14 Phonedo Networks Israel Ltd. Interface for intelligent network services

Family Cites Families (36)

* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title KR970701986A (ko) * 1994-02-28 1997-04-12 ìë¦¬ì¹´ ë¦°ëë ì´ ê·¸ëí ëí¤ íµì ë¤í¸ìí¬ì ëí ìë¹ì¤ë¥¼ êµ¬ì±íë ìë¹ì¤ ì¸ë ìì¤í (service provision in communications networks) US6181703B1 (en) * 1995-09-08 2001-01-30 Sprint Communications Company L. P. System for managing telecommunications US5742905A (en) * 1994-09-19 1998-04-21 Bell Communications Research, Inc. Personal communications internetworking US5546452A (en) * 1995-03-02 1996-08-13 Geotel Communications Corp. Communications system using a central controller to control at least one network and agent system US5940487A (en) * 1996-04-10 1999-08-17 Alcatel Usa Sourcing, L.P. Programmable call processing system and method US6236365B1 (en) * 1996-09-09 2001-05-22 Tracbeam, Llc Location of a mobile station using a plurality of commercial wireless infrastructures ES2275786T3 (es) * 1997-02-14 2007-06-16 Denso Corporation Bobina de encendido tipo varilla, con estructura mejorada contra fisuras o descargas dielectricas. FI103540B1 (fi) * 1997-04-28 1999-07-15 Nokia Mobile Phones Ltd MenetelmÃ¤ pakettikytkentÃ¤isen datan siirtoon matkapuhelinjÃ¤rjestelmÃ¤ssÃ¤ US6122263A (en) * 1997-06-10 2000-09-19 Telefonaktiebolaget Lm Ericsson Internet access for cellular networks US6199068B1 (en) * 1997-09-11 2001-03-06 Abb Power T&D Company Inc. Mapping interface for a distributed server to translate between dissimilar file formats JPH11111543A (ja) * 1997-10-07 1999-04-23 Mitsubishi Electric Corp å çæ©é¢ç¨ç¹ç«ã³ã¤ã«è£ ç½® US6122510A (en) * 1997-11-04 2000-09-19 Telefonaktiebolaget Lm Ericsson Method and apparatus for providing network-specific mobile services US6263437B1 (en) * 1998-02-19 2001-07-17 Openware Systems Inc Method and apparatus for conducting crypto-ignition processes between thin client devices and server devices over data networks FI106515B (fi) * 1998-03-17 2001-02-15 Nokia Networks Oy Ãlyverkkopalvelun konfigurointi US6324547B1 (en) * 1998-04-02 2001-11-27 Lucent Technologies Inc. Method for creating and modifing similar and dissimilar databases for use in intelligent network configurations for telecommunication systems JP2978878B1 (ja) * 1998-05-18 1999-11-15 æ¥æ¬é»æ°éä¿¡ã·ã¹ãã æ ªå¼ä¼ç¤¾ ãã¼ã ä½ç½®ã¬ã¸ã¹ã¿ã®å¶å¾¡è£ ç½®ãæ¹æ³åã³ãã­ã°ã©ã ãè¨é²ããè¨é²åªä½ US6157955A (en) * 1998-06-15 2000-12-05 Intel Corporation Packet processing system including a policy engine having a classification unit US6230005B1 (en) * 1998-10-01 2001-05-08 Nokia Telecommunications, Oy Method and apparatus for providing overlay to support third generation cellular services US6614781B1 (en) * 1998-11-20 2003-09-02 Level 3 Communications, Inc. Voice over data telecommunications network architecture KR100379459B1 (ko) * 1999-02-12 2003-04-10 ìì§ì ì ì£¼ìíì¬ ì´ë íµì ìì¤í ìì í¨í· ë°ì´í° ìë¹ì¤ ì ê³µ ìì¤í  ë° ì´ë¥¼ ì´ì©í ì´ì© ë°©ë² GB2350749A (en) * 1999-06-01 2000-12-06 Motorola Ltd Transferring configuration data to a software defined radio apparatus US6625141B1 (en) * 1999-06-18 2003-09-23 Telefonaktiebolaget L M Ericsson (Publ) System and method for providing value-added services (VAS) in an integrated telecommunications network using session initiation protocol (SIP) US6529948B1 (en) * 1999-08-31 2003-03-04 Accenture Llp Multi-object fetch component US6560327B1 (en) * 1999-10-01 2003-05-06 Sprint Spectrum, L.P. Method and system for providing telecommunications services using mediated service logic JP4318273B2 (ja) * 1999-12-24 2009-08-19 æ ªå¼ä¼ç¤¾ãã³ã½ã¼ ç¹ç«ã³ã¤ã« CN1382347A (zh) * 2000-09-01 2002-11-27 è¯ºåºäºå ¬å¸ æå¡èæ¬æ§è¡åç®¡ççç½ç»ä½ç³»ç»æåæ¹æ³ US6888937B1 (en) * 2000-09-06 2005-05-03 Cisco Technology, Inc. Managing processes of a network component FI20002449A0 (fi) * 2000-11-08 2000-11-08 Nokia Networks Oy Tapahtumien virittÃ¤minen GB0100309D0 (en) * 2001-01-05 2001-02-14 Nokia Networks Oy Provision of services in a communications system US20020131395A1 (en) * 2001-03-19 2002-09-19 Chenghui Wang Session initiation protocol (SIP) user agent in a serving GPRS support node (SGSN) WO2002091692A1 (en) * 2001-04-13 2002-11-14 Girard Gregory D Ditributed edge switching system for voice-over-packet multiservice network US7483411B2 (en) * 2001-06-04 2009-01-27 Nec Corporation Apparatus for public access mobility LAN and method of operation thereof US6891842B2 (en) * 2001-09-21 2005-05-10 Nokia Corporation System and method for enabling mobile edge services JP3979166B2 (ja) * 2001-10-18 2007-09-19 æ ªå¼ä¼ç¤¾ãã³ã½ã¼ ç¹ç«ã³ã¤ã« US20030095566A1 (en) * 2001-11-20 2003-05-22 Bunting Roger L. Providing a camel based service to a subscriber terminal in a win network and vice versa DE602004025952D1 (de) * 2003-08-13 2010-04-22 Roamware Inc Signalisierungs-Gateway mit einem Mehrfach-Imsi-Mit-Mehrfach-MSISDN (MIMM) Dienst in einem einzigen SIM fÃ¼r mehrere Roaming-Partner

2002

2002-03-18 US US10/100,468 patent/US20030177283A1/en not_active Abandoned

2003

2003-03-18 EP EP03745136A patent/EP1491029A4/en not_active Withdrawn

2003-03-18 WO PCT/US2003/008401 patent/WO2003081885A1/en active Application Filing

2003-03-18 AU AU2003225863A patent/AU2003225863A1/en not_active Abandoned

2003-03-18 CN CNA03811223XA patent/CN1653790A/zh active Pending

2003-03-18 KR KR10-2004-7014751A patent/KR20040108673A/ko not_active Application Discontinuation

2003-03-18 JP JP2003579453A patent/JP2005521337A/ja active Pending

Patent Citations (1)

* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title WO2002012976A2 (en) * 2000-08-08 2002-02-14 Phonedo Networks Israel Ltd. Interface for intelligent network services

Also Published As

Publication number Publication date AU2003225863A1 (en) 2003-10-08 WO2003081885A9 (en) 2003-11-27 JP2005521337A (ja) 2005-07-14 US20030177283A1 (en) 2003-09-18 WO2003081885A1 (en) 2003-10-02 CN1653790A (zh) 2005-08-10 KR20040108673A (ko) 2004-12-24 EP1491029A1 (en) 2004-12-29

Similar Documents

Publication Publication Date Title WO2003081885A1 (en) 2003-10-02 Application program interface US7586871B2 (en) 2009-09-08 Platform and method for providing data services in a communication network US8607320B2 (en) 2013-12-10 Systems, methods and computer-readable media for regulating remote access to a data network US20020176377A1 (en) 2002-11-28 Service platform on wireless network US6822954B2 (en) 2004-11-23 Telecommunications gateway EP1064757B1 (en) 2009-01-14 Remote computer communication US9998460B2 (en) 2018-06-12 Diameter redirect between client and server EP1054529A2 (en) 2000-11-22 Method and apparatus for associating network usage with particular users US7136635B1 (en) 2006-11-14 Proxy SIP server interface for session initiation communications WO2003049348A2 (en) 2003-06-12 Mechanisms for policy based umts qos and ip qos management in mobile ip networks CA2430119A1 (en) 2002-06-06 External processor for a distributed network access system WO2003105416A1 (en) 2003-12-18 Method and apparatus for implementing qos in data transmissions MXPA03004671A (es) 2004-10-14 Dispositivo de acceso programable para un sistema de acceso a red distribuida. Martsola et al. 2005 Machine to machine communication in cellular networks Cisco 1997-12-21 Managing the System Cisco 1997-05-27 Managing the System Cisco 1997-05-27 Managing the System US20160301626A1 (en) 2016-10-13 Tunnel consolidation for real-time communications JP4463838B2 (ja) 2010-05-19 ãããã¯ã¼ã¯ã«ããããµã¼ãã¹æ©å¨è¦ç´ ãè¨­å®ããæ¹æ³åã³è£ ç½® KR101074056B1 (ko) 2011-10-17 ë³í ê²ì´í¸ì¨ì´ë¥¼ í¬í¨íë ì ë¬´ì ì¸í°ë· ìë¹ì¤ íµí©ì¸ì¦ ìì¤í  ë° ë°©ë² Agah 0 Active Networks in Mobile Computing Environment

Legal Events

Date Code Title Description