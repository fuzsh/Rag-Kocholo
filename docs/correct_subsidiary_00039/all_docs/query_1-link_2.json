{
    "id": "correct_subsidiary_00039_1",
    "rank": 2,
    "data": {
        "url": "https://patents.google.com/patent/US20030177283A1/en",
        "read_more_link": "",
        "language": "en",
        "title": "US20030177283A1 - Application program interface - Google Patents",
        "top_image": "https://patentimages.storage.googleapis.com/7c/81/20/0e952aef384d97/US20030177283A1-20030918-P00001.png",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/54/46/e4/dab7af86d7813a/US20030177283A1-20030918-D00000.png",
            "https://patentimages.storage.googleapis.com/9f/bf/e9/a8e7f0438785ff/US20030177283A1-20030918-D00001.png",
            "https://patentimages.storage.googleapis.com/52/d9/b9/531a2909713e11/US20030177283A1-20030918-D00002.png",
            "https://patentimages.storage.googleapis.com/6a/31/e2/845e50151d8f8b/US20030177283A1-20030918-D00003.png",
            "https://patentimages.storage.googleapis.com/ac/70/94/43134de40fca69/US20030177283A1-20030918-D00004.png",
            "https://patentimages.storage.googleapis.com/e3/7c/cc/f2ee89edab5bf1/US20030177283A1-20030918-D00005.png",
            "https://patentimages.storage.googleapis.com/c1/78/5c/d7a334e4cfd746/US20030177283A1-20030918-D00006.png",
            "https://patentimages.storage.googleapis.com/f0/84/fd/159dba3cc0cbf4/US20030177283A1-20030918-D00007.png",
            "https://patentimages.storage.googleapis.com/df/6b/e6/2488512e10508f/US20030177283A1-20030918-D00008.png",
            "https://patentimages.storage.googleapis.com/0a/ce/4e/da9a0a90ba563f/US20030177283A1-20030918-D00009.png",
            "https://patentimages.storage.googleapis.com/84/40/a8/f8e42e3173b596/US20030177283A1-20030918-D00010.png",
            "https://patentimages.storage.googleapis.com/82/c6/97/b138bf2c0d5aec/US20030177283A1-20030918-D00011.png",
            "https://patentimages.storage.googleapis.com/7c/81/20/0e952aef384d97/US20030177283A1-20030918-P00001.png",
            "https://patentimages.storage.googleapis.com/22/ee/d9/f79e680db812d0/US20030177283A1-20030918-P00002.png",
            "https://patentimages.storage.googleapis.com/36/67/0e/618e92d424d773/US20030177283A1-20030918-P00003.png",
            "https://patentimages.storage.googleapis.com/a7/be/81/840f56f29c8659/US20030177283A1-20030918-P00004.png",
            "https://patentimages.storage.googleapis.com/28/cb/b6/d6e6cc0820aae2/US20030177283A1-20030918-P00005.png",
            "https://patentimages.storage.googleapis.com/ba/18/19/ffa75a51cba12d/US20030177283A1-20030918-P00006.png",
            "https://patentimages.storage.googleapis.com/12/2d/ce/1df193fbeef4c5/US20030177283A1-20030918-P00007.png",
            "https://patentimages.storage.googleapis.com/b0/bc/ab/521029649669ce/US20030177283A1-20030918-P00008.png",
            "https://patentimages.storage.googleapis.com/1b/9d/bb/e4fe45bfa40605/US20030177283A1-20030918-P00009.png",
            "https://patentimages.storage.googleapis.com/b7/68/41/563b36d4035cf2/US20030177283A1-20030918-P00010.png",
            "https://patentimages.storage.googleapis.com/ca/ee/9b/b58822424a3479/US20030177283A1-20030918-P00011.png",
            "https://patentimages.storage.googleapis.com/04/a7/80/f3a639a9e22eb9/US20030177283A1-20030918-P00012.png",
            "https://patentimages.storage.googleapis.com/15/c0/76/3254f889c7173e/US20030177283A1-20030918-P00013.png",
            "https://patentimages.storage.googleapis.com/43/96/dd/60e5211a029462/US20030177283A1-20030918-P00014.png",
            "https://patentimages.storage.googleapis.com/15/23/a3/46bd2aaaef90f7/US20030177283A1-20030918-P00015.png",
            "https://patentimages.storage.googleapis.com/1a/64/0a/d53a20fc97fa0d/US20030177283A1-20030918-P00016.png",
            "https://patentimages.storage.googleapis.com/ef/3e/48/085d82a8c83373/US20030177283A1-20030918-P00017.png",
            "https://patentimages.storage.googleapis.com/ac/e6/05/81886ba1c2db83/US20030177283A1-20030918-P00018.png",
            "https://patentimages.storage.googleapis.com/16/cf/14/7b33da58c63bfd/US20030177283A1-20030918-P00019.png",
            "https://patentimages.storage.googleapis.com/7d/63/00/d5b5bdda06c4f7/US20030177283A1-20030918-P00020.png",
            "https://patentimages.storage.googleapis.com/24/28/27/e27c6a443bdc38/US20030177283A1-20030918-P00021.png",
            "https://patentimages.storage.googleapis.com/1c/82/44/9fb50805f945f6/US20030177283A1-20030918-P00022.png",
            "https://patentimages.storage.googleapis.com/f7/a7/18/caf6909bba9ebf/US20030177283A1-20030918-P00023.png",
            "https://patentimages.storage.googleapis.com/9a/f0/93/30645752aaba83/US20030177283A1-20030918-P00024.png",
            "https://patentimages.storage.googleapis.com/aa/ba/05/00dedb86b30e23/US20030177283A1-20030918-P00025.png",
            "https://patentimages.storage.googleapis.com/e1/1f/ae/80dc129a353f1a/US20030177283A1-20030918-P00026.png",
            "https://patentimages.storage.googleapis.com/fd/85/f7/821c0a1fc76e8c/US20030177283A1-20030918-P00027.png",
            "https://patentimages.storage.googleapis.com/d8/df/83/fedf8f5b1ff50c/US20030177283A1-20030918-P00028.png",
            "https://patentimages.storage.googleapis.com/5b/b1/70/237bac93aa1294/US20030177283A1-20030918-P00029.png",
            "https://patentimages.storage.googleapis.com/8e/87/00/88e3762cc22130/US20030177283A1-20030918-P00030.png",
            "https://patentimages.storage.googleapis.com/d5/fb/fd/20ee62ff99f99f/US20030177283A1-20030918-P00031.png",
            "https://patentimages.storage.googleapis.com/1a/ff/04/55b13ca0bea4e6/US20030177283A1-20030918-P00032.png",
            "https://patentimages.storage.googleapis.com/64/65/53/d176beb4a8a445/US20030177283A1-20030918-P00033.png",
            "https://patentimages.storage.googleapis.com/22/f9/ae/b60fd035aa010c/US20030177283A1-20030918-P00034.png",
            "https://patentimages.storage.googleapis.com/9e/a3/7b/a28be37121abb8/US20030177283A1-20030918-P00035.png",
            "https://patentimages.storage.googleapis.com/de/a6/e2/88f4e342ad6581/US20030177283A1-20030918-P00036.png",
            "https://patentimages.storage.googleapis.com/01/87/1b/9b6ee6d3e1def4/US20030177283A1-20030918-P00037.png",
            "https://patentimages.storage.googleapis.com/70/ad/51/3f4808dca5e226/US20030177283A1-20030918-P00038.png",
            "https://patentimages.storage.googleapis.com/9e/7b/51/8a09ba0dafa8d1/US20030177283A1-20030918-P00039.png",
            "https://patentimages.storage.googleapis.com/e8/83/8e/87345af6f3fbc6/US20030177283A1-20030918-P00040.png",
            "https://patentimages.storage.googleapis.com/3d/52/f5/ca6b738248d11f/US20030177283A1-20030918-P00041.png",
            "https://patentimages.storage.googleapis.com/2f/1c/b9/59e342c5a606f6/US20030177283A1-20030918-P00042.png",
            "https://patentimages.storage.googleapis.com/eb/21/73/88e8bfe71376fb/US20030177283A1-20030918-P00043.png",
            "https://patentimages.storage.googleapis.com/ee/86/e2/9bd32651f395f4/US20030177283A1-20030918-P00044.png",
            "https://patentimages.storage.googleapis.com/f9/93/e8/535c33d193b9d7/US20030177283A1-20030918-P00045.png",
            "https://patentimages.storage.googleapis.com/32/6e/5b/05f2e3fd91df8d/US20030177283A1-20030918-P00046.png",
            "https://patentimages.storage.googleapis.com/df/a0/09/900bbad675fbcb/US20030177283A1-20030918-P00047.png",
            "https://patentimages.storage.googleapis.com/71/fa/4f/e152c84c044e39/US20030177283A1-20030918-P00048.png",
            "https://patentimages.storage.googleapis.com/98/5b/ed/0da91f765e208f/US20030177283A1-20030918-P00049.png",
            "https://patentimages.storage.googleapis.com/86/53/f5/87a033bc19c1dc/US20030177283A1-20030918-P00050.png",
            "https://patentimages.storage.googleapis.com/1d/ca/45/501c9aab857ff3/US20030177283A1-20030918-P00051.png",
            "https://patentimages.storage.googleapis.com/46/3a/f1/932dd2289331f8/US20030177283A1-20030918-P00052.png",
            "https://patentimages.storage.googleapis.com/43/bd/fe/2f737ffd7ff2bd/US20030177283A1-20030918-P00053.png",
            "https://patentimages.storage.googleapis.com/0a/4e/5e/43976ca9f54ca6/US20030177283A1-20030918-P00054.png",
            "https://patentimages.storage.googleapis.com/f1/5e/bc/30a546444ee4c2/US20030177283A1-20030918-P00055.png",
            "https://patentimages.storage.googleapis.com/7a/7f/28/bc0830a3efa761/US20030177283A1-20030918-P00056.png",
            "https://patentimages.storage.googleapis.com/dc/b8/40/31352a63e7c9de/US20030177283A1-20030918-P00057.png",
            "https://patentimages.storage.googleapis.com/26/af/7b/a2ad73d2e94dc7/US20030177283A1-20030918-P00058.png",
            "https://patentimages.storage.googleapis.com/55/86/6f/7c3cf1686ecd18/US20030177283A1-20030918-P00059.png",
            "https://patentimages.storage.googleapis.com/c4/c6/95/6b228cfd41b291/US20030177283A1-20030918-P00060.png",
            "https://patentimages.storage.googleapis.com/93/cb/2d/614c6b43a74b54/US20030177283A1-20030918-P00061.png",
            "https://patentimages.storage.googleapis.com/77/df/d6/c80b529fbf4e6c/US20030177283A1-20030918-P00062.png",
            "https://patentimages.storage.googleapis.com/82/83/75/b5498a55bdfae7/US20030177283A1-20030918-P00063.png",
            "https://patentimages.storage.googleapis.com/ec/1b/5d/de47cb9703a4dd/US20030177283A1-20030918-P00064.png",
            "https://patentimages.storage.googleapis.com/5c/8c/5a/ebe8e66ab65169/US20030177283A1-20030918-P00065.png",
            "https://patentimages.storage.googleapis.com/d7/91/a6/44f62085810dfe/US20030177283A1-20030918-P00066.png",
            "https://patentimages.storage.googleapis.com/70/8d/9e/ee34f3f58b91ea/US20030177283A1-20030918-P00067.png",
            "https://patentimages.storage.googleapis.com/6e/95/ab/2520c3aa20ed87/US20030177283A1-20030918-P00068.png",
            "https://patentimages.storage.googleapis.com/46/7d/d1/826e8078a3afdf/US20030177283A1-20030918-P00069.png",
            "https://patentimages.storage.googleapis.com/f0/20/4e/216c7140059854/US20030177283A1-20030918-P00070.png",
            "https://patentimages.storage.googleapis.com/ac/77/7c/0a032d5fb9e214/US20030177283A1-20030918-P00071.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2002-03-18T00:00:00",
        "summary": "",
        "meta_description": "A method in a network is provided. The method includes receiving messages from an application program in an application program interface (API), and passing the messages from the API to a control process in a mobile service switching platform (MSSP). A system is also provided. The system includes a Gateway General Packet Radio Service Support Node (GGSN) linked to control process in a Mobile Service Switching Platform (MSSP), a group of globally connected computers linked to the control process, an application program interface (API) connected to the control process, and an application system executing an application process linked to the API.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US20030177283A1/en",
        "text": "Application program interface Download PDF\n\nInfo\n\nPublication number\n\nUS20030177283A1\n\nUS20030177283A1 US10/100,468 US10046802A US2003177283A1 US 20030177283 A1 US20030177283 A1 US 20030177283A1 US 10046802 A US10046802 A US 10046802A US 2003177283 A1 US2003177283 A1 US 2003177283A1\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\napplication\n\nprotocol\n\nallows\n\napi\n\ncontrol process\n\nPrior art date\n\n2002-03-18\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nAbandoned\n\nApplication number\n\nUS10/100,468\n\nInventor\n\nThomas Hamilton\n\nClifford Atwood\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nBytemobile Network Services Corp\n\nOriginal Assignee\n\nAVIAN COMMUNICATIONS\n\nProquent Systems Corp\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n2002-03-18\n\nFiling date\n\n2002-03-18\n\nPublication date\n\n2003-09-18\n\n2002-03-18 Application filed by AVIAN COMMUNICATIONS, Proquent Systems Corp filed Critical AVIAN COMMUNICATIONS\n\n2002-03-18 Priority to US10/100,468 priority Critical patent/US20030177283A1/en\n\n2002-06-06 Assigned to AVIAN COMMUNICATIONS reassignment AVIAN COMMUNICATIONS ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: ATWOOD, CLIFFORD S., HAMILTON, THOMAS E.\n\n2002-11-15 Assigned to SILICON VALLEY BANK DBA SILICON VALLEY EAST reassignment SILICON VALLEY BANK DBA SILICON VALLEY EAST SECURITY AGREEMENT Assignors: PROQUENT SYSTEMS CORPORATION, F/K/A AVIAN COMMUNICATIONS, INC.\n\n2002-11-18 Assigned to ST. PAUL VENTURE CAPITAL VI, LLC reassignment ST. PAUL VENTURE CAPITAL VI, LLC SECURITY AGREEMENT Assignors: PROQUENT SYSTEMS CORPORATION\n\n2003-02-24 Assigned to ST. PAUL VENTURE CAPITAL VI, LLC reassignment ST. PAUL VENTURE CAPITAL VI, LLC TERMINATION AGREEMENT Assignors: PROQUENT SYSTEMS CORPORATION\n\n2003-03-18 Priority to KR10-2004-7014751A priority patent/KR20040108673A/en\n\n2003-03-18 Priority to PCT/US2003/008401 priority patent/WO2003081885A1/en\n\n2003-03-18 Priority to EP03745136A priority patent/EP1491029A4/en\n\n2003-03-18 Priority to CNA03811223XA priority patent/CN1653790A/en\n\n2003-03-18 Priority to JP2003579453A priority patent/JP2005521337A/en\n\n2003-03-18 Priority to AU2003225863A priority patent/AU2003225863A1/en\n\n2003-04-01 Assigned to PROQUENT SYSTEMS CORPORATION reassignment PROQUENT SYSTEMS CORPORATION CHANGE OF NAME (SEE DOCUMENT FOR DETAILS). Assignors: AVIAN COMMUNICATIONS, INC.\n\n2003-04-01 Assigned to PROQUENT SYSTEMS CORPORATION reassignment PROQUENT SYSTEMS CORPORATION CHANGE OF NAME (SEE DOCUMENT FOR DETAILS). Assignors: AVIAN COMMUNICATIONS, INC.\n\n2003-09-10 Assigned to ST. PAUL VENTURE CAPITAL VI, LLC, NOKIA VENTURE PARTNERS II, L.P., YANKEETEK INCUBATOR FUND, L.P., ARGO II: THE WIRELESS-INTERNET FUND LIMITED PARTNERSHIP ARGC V, L.P. reassignment ST. PAUL VENTURE CAPITAL VI, LLC SECURITY AGREEMENT Assignors: PROQUENT SYSTEMS CORPORATION\n\n2003-09-18 Publication of US20030177283A1 publication Critical patent/US20030177283A1/en\n\n2003-12-15 Assigned to ARGC IV, L.P., YANKEETEK INVESTMENT PARTNERS, LLC, AGRO II: THE WIRELESS-INTERNET FUND LIMITED PARTNERSHIP, NOKIA VENTURE PARTNERS II, L.P., NVP II AFFILIATES FUND, L.P., YANKEETEK AFFILIATE FUND, L.P., ST. PAUL VENTURE CAPITAL, YANKEETEK INCUBATOR FUND, L.P. reassignment ARGC IV, L.P. TERMINATION AGREEMENT Assignors: PROQUENT SYSTEMS CORPORATION\n\n2004-11-09 Assigned to ST. PAUL VENTURE CAPITAL VI, LLC, NOKIA VENTURE PARTNERS II, L.P., ARGO II: THE WIRELESS-INTERNET FUND LIMITED PARTNERSHIP reassignment ST. PAUL VENTURE CAPITAL VI, LLC SECURITY INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: PROQUENT SYSTEMS CORPORATION\n\n2005-02-28 Assigned to PROQUENT SYSTEMS CORPORATION reassignment PROQUENT SYSTEMS CORPORATION SECURITY INTEREST RELEASE Assignors: ARGC VI, L.P., ARGO II: THE WIRELESS-INTERNET FUND LIMITED PARTNERSHIP, NOKIA VENTURE PARTNERS II, L.P., NVP II AFFILIATES FUND, L.P., ST. PAUL VENTURE CAPITAL VI, LLC\n\n2005-02-28 Assigned to PROQUENT SYSTEMS CORPORATION reassignment PROQUENT SYSTEMS CORPORATION SECURITY INTEREST RELEASE Assignors: ARGC VI, L.P., ARGO II: THE WIRELESS-INTERNET FUND LIMITED PARTNERSHIP, NOKIA VENTURE PARTNERS II, L.P., NVP II AFFILIATES FUND, L.P., ST. PAUL VENTURE CAPITAL IV, LLC\n\n2005-03-21 Assigned to BYTEMOBILE NETWORK SERVICES CORPORATION reassignment BYTEMOBILE NETWORK SERVICES CORPORATION MERGER (SEE DOCUMENT FOR DETAILS). Assignors: PROQUENT SYSTEMS CORPORATION\n\nStatus Abandoned legal-status Critical Current\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\nImages\n\nClassifications\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04W—WIRELESS COMMUNICATION NETWORKS\n\nH04W80/00—Wireless network protocols or protocol adaptations to wireless operation\n\nH04W80/08—Upper layer protocols\n\nH04W80/12—Application layer protocols, e.g. WAP [Wireless Application Protocol]\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M3/00—Automatic or semi-automatic exchanges\n\nH04M3/42—Systems providing special services or facilities to subscribers\n\nH04M3/4228—Systems providing special services or facilities to subscribers in networks\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04B—TRANSMISSION\n\nH04B7/00—Radio transmission systems, i.e. using radiation field\n\nH04B7/005—Control of transmission; Equalising\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION\n\nH04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M3/00—Automatic or semi-automatic exchanges\n\nH04M3/42—Systems providing special services or facilities to subscribers\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M2207/00—Type of exchange or network, i.e. telephonic medium, in which the telephonic communication takes place\n\nH04M2207/18—Type of exchange or network, i.e. telephonic medium, in which the telephonic communication takes place wireless networks\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M3/00—Automatic or semi-automatic exchanges\n\nH04M3/22—Arrangements for supervision, monitoring or testing\n\nH04M3/36—Statistical metering, e.g. recording occasions when traffic exceeds capacity of trunks\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13003—Constructional details of switching devices\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/1305—Software aspects\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13098—Mobile subscriber\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13109—Initializing, personal profile\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13349—Network management\n\nDefinitions\n\nThis invention relates to an application program interface (API).\n\nAPI application program interface\n\nan application program interface is a specific method prescribed by a computer operating system or by another application program by which a programmer writing an application program can make requests of the operating system or another application. More specifically, an API is a formalized set of software calls and routines that can be referenced by an application program in order to access supporting services.\n\nthe invention features a method including, in a network, receiving messages from an application program in an application program interface (API), and passing the messages from the API to a control process in a mobile service switching platform (MSSP).\n\nAPI application program interface\n\nMSSP mobile service switching platform\n\nEmbodiments may include one or more of the following.\n\nthe network may be a wireless network.\n\nthe wireless network be be a second generation wireless network, a GSM network, a GPRS-enabled GSM network or a TDMA network.\n\nthe wireless network may be a CDMA network, a UMTS network, a TETRA network or a Tetrapol network.\n\nthe wireless network may be a DECT network, an AMPS network, a WLAN or a third generation wireless network.\n\nthe API may provide a protocol that allows the application program to control switching and routing functions in the MSSP.\n\nthe API may provide a protocol that allows the application program to redirect packet flow through the MSSP on a per-flow basis.\n\nthe API may provide a protocol that allows the application program to control policy decisions within the MSSP.\n\nthe API may include a protocol that allows the application program to arm initial detection points (IDPs) and services associated IDP events in the control process.\n\nIDPs initial detection points\n\nthe API may include a protocol that allows the application program to disarm IDPs and service associated ICP events in the control process.\n\nthe API may include a protocol that allows the application program to request event reports.\n\nthe API may include a protocol that allows the application program to specify programmed behavior at a detection point in the control process.\n\nthe API may include a protocol that allows the application program to configure data elements that are metered by the control process of the MSSP.\n\nthe API may include a protocol that allows the application program to request byte-based reporting.\n\nthe reporting may be session-based or flow-based.\n\nthe API may include a protocol that allows the application program to specify a cost of services provided.\n\nthe API may include a protocol that allows the application program to record a charge plan used in a detail record and a protocol that allows the application program to control when the detail record is written.\n\nthe API may include a protocol that allows the application program to obtain statistics for a session managed by the application program.\n\nthe API may include a protocol that allows the application program to obtain statistics for a flow managed by the application program.\n\nthe API may include a protocol that allows the application program to monitor a status of other applications connected to the control process of the MSSP.\n\nthe invention features an application program interface (API) including a set of application layer protocols that allows exchange of messages between an application process and a control process of a Mobile Service Switching Platform (MSSP) using Transmission Control Protocol/Internet Protocol (TCP/IP) network services.\n\nAPI application program interface\n\nMSSP Mobile Service Switching Platform\n\nTCP/IP Transmission Control Protocol/Internet Protocol\n\nthe set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated IDP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated IDP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to request event reports from the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify programmed behavior at a detection point in the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process.\n\nthe reporting may include session-based reporting or flow-based reporting.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to control when the detail record is written.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process.\n\nthe invention features a system including a Gateway General Packet Radio Service Support Node (GGSN) linked to control process in a Mobile Service Switching Platform (MSSP), a group of globally connected computers linked to the control process, an application program interface (API) connected to the control process, and an application system executing an application process linked to the API.\n\nGGSN Gateway General Packet Radio Service Support Node\n\nMSSP Mobile Service Switching Platform\n\nAPI application program interface\n\nthe system may include a General Packet Radio Service Support Node linked to the GGSN.\n\nthe system may include a Base Station Controller (BSC) linked to the General Packet Radio Service Support Node.\n\nBSC Base Station Controller\n\nthe system may include a Base Transceiver Station (BTS) linked to the BSC and a mobile station (MS) linked to the BTS.\n\nBTS Base Transceiver Station\n\nMS mobile station\n\nthe API may include a set of application layer protocols that allows exchange of messages between the application process and the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated IDP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated IDP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to request event reports from the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify programmed behavior at a detection point in the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process. Reporting may be session-based or flow-based.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to control when the detail record is written.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process.\n\nEmbodiments of the invention may have one or more of the following advantages.\n\nAPI Application Program Interface\n\nMSSP Mobile Service Switching Platform\n\nthe API provides a set of protocols that allow service logic contained in an external application program to control switching/routing functions of a Mobile Service Switching Platform.\n\nthe API provides a protocol for an operator to limit the scope of an application's detection points, in which a detection point is a defined place in a state machine of a control entity where application event reporting and/or control is possible.\n\nthe API provides a protocol that is common to all applications, regardless of application privileges.\n\nthe API provides a protocol that allows an application to arm and disarm Initial Detection Points (IDPs) in a Mobile Service Switching Platform (MSSP) and service associated IDP events, where an IDP is defined as a detection point armed so as to create a new control dialog with an application when conditions match given criteria.\n\nIDPs Initial Detection Points\n\nMSSP Mobile Service Switching Platform\n\nthe API provides a protocol that allows an application to request additional event reports subsequent to an Initial Detection Point event.\n\nthe IDP that initiates a control dialog is a trigger, the application typically requests additional event reports.\n\nthe API provides a protocol that allows an application to specify programmed behavior at a Detection Point (DP) that does not require the involvement of the application. Messages are used to match incoming requests to determine if the predefined service interaction should be executed. The matching process is similar to the process used for Initial Detection Points in general and wildcards may be used in the fields to be matched. If a flow matches the criteria, the actions specified in the remainder of the message will be carried out with no application involvement. Actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number. A message is used to determine which events will be reported in the future for the flow if event reports are required.\n\nDP Detection Point\n\nCriteria to be matched may not overlap with armed Initial Detection Point criteria. If the request cannot be completed for any reason a message will be returned with a matching RequestID and an error code indicating the nature of the failure. If the request completes successfully, another message is returned. Service Filtering remains active until cancelled by a specific message request.\n\nthe API provides a protocol that allows an application to configure data elements that are metered by a Mobile Service Switching Platform (MSSP).\n\nMSSP Mobile Service Switching Platform\n\nthe API provides a protocol that allows an application to request byte based reporting. Reporting may be requested on a session or flow basis. Session based charge notification effectively causes the same charge notification criteria to be applied to all flows in the session. Registering for charge notification events causes the number of bytes of the specified type transferred in uplink and downlink directions to be metered. Each time a reporting threshold is reached a message is sent from the MSSP to the application indicating the number of bytes that have been transferred, and counters are reset and begin counting towards the threshold again. Charge notification continues until the flow terminates or charge notification is explicitly cancelled by a cancel request. A packet is the atomic unit counted and each packet either falls before the count is evaluated or after the count is evaluated.\n\ncharge notification may not occur exactly on the byte count specified. For example, if notification was requested every 10K bytes, the notification may occur at 10.5 Kbytes if the packet that brought the count over 10K was slightly greater than 500 bytes.\n\nthe actual counter values are provided in a message.\n\nthe API provides a protocol that allows an application to indicate a cost of the services provided and record a charge plan used in an MSSP detail record.\n\nthe API provides a protocol that allows an application to control when MSSP detail records are written.\n\nthe API provides a protocol that allows an application to obtain various statistics for a session or flow managed by the application.\n\nthe API provides a protocol that allows an application to monitor the status of other applications connected to the same MSSP instance.\n\nthe API provides a protocol that allows the redirection of packet flow on a per-flow basis.\n\nFIG. 1 is a block diagram of a network.\n\nFIG. 2 is a flow diagram of an interception process.\n\nFIG. 3 is a flow diagram of the service application startup stage of FIG. 2.\n\nFIG. 4 is a flow diagram of the service initialization stage of FIG. 2.\n\nFIG. 5 is a flow diagram of the service deployment stage of FIG. 2.\n\nFIG. 6 is a flow diagram of the service logic stage of FIG. 2.\n\nFIG. 7 is a flow diagram of the shutdown stage of FIG. 2.\n\nFIG. 8 is a table of data types used by the API of FIG. 1.\n\nFIG. 9 is a block diagram of a communication path.\n\nFIG. 10 is a block diagram of a TCP/IP byte stream divided into session messages by the transport layer.\n\nFIG. 11 shows a table listing sample error codes.\n\nFIG. 12 shows a table listing sample feature categories.\n\nthe network 10 may be a wireless network.\n\nthe wireless network may be, for example, a second generation wireless network, a Global System for Mobile Communications (GSM) network, or a General Packet Radio System (GPRS) enabled GSM.\n\nthe wireless network may be a Time Division Multiple Access (TDMA) network, a Code Division Multiple Access (CDMA) network, or a Universal Mobile Telecommunications System (UMTS) network.\n\nthe wireless network may be a TETRA network, a Tetrapol network, a DECT network, an AMPS network, a wireless local area network (WLAN) or a third generation wireless network.\n\na GPRS enabled GSM network is described.\n\nthe network 10 includes a Mobile Station (MS) 12 connected to a Base Transceiver Station (BTS) 14 .\n\nthe BTS 14 is connected to a Base Station Controller (BSC) 16 .\n\nBSC Base Station Controller\n\nthe MS 12 is a station located within a mobile service intended to be used while in motion or during halts at unspecified points.\n\nAn example mobile station is a hand held cellular telephone.\n\nthe BTS 14 holds radio transceivers that define a cell and coordinates radio-link protocols with the MS 12 .\n\nthe BTS 14 is a component of the network 10 from which all signals are sent and received.\n\nthe BTS 14 often called a cell phone tower, is linked to, and controlled by, a Base Station Controller (BSC) 16 .\n\nBSC 16 is a component in the network 10 that manages radio resources for one or more base transceiver stations, such as BTS 14 , for example.\n\nthe BSC 16 is linked to a SGSN 18 .\n\nthe SGSN 18 is a General Packet Radio Service Support (GPRS) Node that serves GPRS mobile by sending or receiving packets via the BSC 16 .\n\nthe SGSN 18 is linked to a Gateway GPRS Support Node (GGSN) 20 .\n\nthe GGSN 20 acts as a gateway between a General Packet Radio Service (GPRS) network and a Packet Switched Public Data Network (PSPDN).\n\nGPRS General Packet Radio Service\n\nPSPDN Packet Switched Public Data Network\n\nthe GGSN 20 is linked to a Mobile Service Switching Platform (MSSP) server 22 .\n\nthe MSSP server 22 resides between the GGSN 20 and a globally networked group of computers, such as Internet 24 .\n\nthe MSSP server 22 analyzes all of the Internet Protocol (IP) data packets exchanged between the MS 12 and the Internet 24 .\n\nIP Internet Protocol\n\na MSSP control process 26 provides the capability to set triggers or event notifications and increment counters based on IP flow characteristics.\n\nAn IP flow can be thought of as an abstraction representing a movement of data between two endpoints, such as MS 12 and a server (not shown) residing on the Internet 24 .\n\nthe MSSP control process 26 uses these capabilities to implement internal services and detail reporting.\n\nAn Application Program Interface (API) 28 links the MSSP control process 26 to external applications 30 .\n\nthe API 28 provides a mechanism for the external applications 30 to control the MSSP control process 26 to provide intelligent services.\n\nthe API 28 in various embodiments, may be implemented as, for example, a Corba based API, an XML based API, a PARLAY server, an OSA Server, or a JAIN server.\n\nthe MSSP server 22 functions as both an Internet router and an IP packet analyzer. Data contained in a header field of an IP packet is defined in the Internet Engineering Task Force (IETF) RFC 791, incorporated herein by reference (see www.ietf.org).\n\nIETF Internet Engineering Task Force\n\nthe IETF is a large open international community of network designers, operators, vendors, and researchers concerned with the evolution of the Internet architecture and the smooth operation of the Internet.\n\nIP Internet Protocol\n\nIP provides for transmitting blocks of data called datagrams from sources to destinations, where sources and destinations are hosts identified by fixed length addresses.\n\nthe IP also provides for fragmentation and reassembly of long datagrams and, if necessary, for transmission through âsmall packetâ networks.\n\nthe MS SP control process 26 is designed to analyze 1P packet headers in real time to manage counters and signal when packet characteristics match specified conditions.\n\na signal may be an event report or a trigger.\n\nAn event report reports an occurrence of some event while continuing to monitor packet flow.\n\na trigger causes processing of the IP packet to be suspended until the MSSP control process 26 responds with specific instructions for resuming processing of the IP packet.\n\na trigger response may simply direct IP packet processing to be continued unchanged, or it may altar packet processing by specifying a different destination for the packet or cause the packet to be discarded altogether.\n\nthe API 28 provides, in one example, a way for the other applications 30 to communicate with the MSSP control process 26 and manipulate event reports and triggers.\n\nthe MSSP control process 26 manages many different types of IP packets.\n\nthe MSSP control process 26 is divided into different state machines (not shown), each state machine responsible for different types of packets.\n\na state machine is any device that stores the status of something at a given time and can operate on input to change the status and/or cause an action or output to take place for any given change.\n\nstate machines are used to develop and describe specific device or program interactions.\n\na detection point is a defined place in a state machine of a control entity where application event reporting and/or control are possible, and manageable through the API 28 .\n\nAn Event Detection Point is a detection point armed within the context of an existing control dialog. Event detection points do not have explicit criteria; they are only applicable to a specific state machine instance of a control entity that generated the control dialog. In general, event detection points set within one control dialog do not affect a behavior of any other instance of that state machine. A complete set of detection points in a given state machine is known as a detection point class.\n\nTCP Transmission Control Protocol\n\nTCP provides a reliable, connection oriented communication path between two application processes (usually referred to as a client and a server).\n\nthe client initiates a connection and the server accepts the connection before any data can be exchanged.\n\nthe TCP protocol ensures that all of the data sent is received by the other side correctly and in the order that it was sent.\n\na client In order to initiate a TCP connection to a server, a client sends an IP packet to the server's IP address containing a TCP header with a âSYNâ flag set and specifying a port number of the server application that it wishes to connect to.\n\nthe server accepts the connection by sending a similar SYN packet back to the client, and the client acknowledges the SYN from the server by sending an IP packet containing a TCP header with the âACKâ flag set.\n\nPackets pass through the MSSP control process 26 in the MSSP server 22 on their way between a client, e.g., MS 12 , and a server (not shown) residing on the Internet 24 .\n\nthe MSSP control process 26 determines that the IP packet encapsulates TCP data and assigns the packet to TCP control logic.\n\nthe TCP control logic can distinguish each segment of the connection establishment.\n\nIDP Initial Detection Point\n\nTCP SYN packets All other TCP packets, and TCP SYN packets directed to a different destination, continue to be processed normally.\n\na TCP SYN packet with a destination that matches the arming criteria causes processing of that packet to be suspended and an IDP event notification sent to the service application 30 that armed the IDP through the API 28 .\n\nthe IDP event notification may include, for example, information from the suspended packet that the service application 30 may use to determine a correct destination for the connection.\n\nthe service application 30 then directs the MSSP control process 26 through the API 28 to resume packet processing with a different destination address.\n\nthe MSSP control process 26 forwards a modified TCP SYN packet to the new destination, where that server responds in a typical manner.\n\nthe service application's involvement is completely transparent, i.e., neither the client, e.g., MS 12 , nor the server (not shown) on the Internet 24 is aware that any redirection has taken place.\n\nService applications 30 interact with the MSSP control process 26 by exchanging TCP/IP messages.\n\nthe API 28 listens for connections from service applications 30 .\n\nthe API 28 authenticates the identity of the connected service application 30 and looks up the features that the application is authorized to access.\n\nthe service application 30 once its communication session with the API 28 is established, requests a list of services that it is expected to provide from the MSSP control process 26 and then arms Initial Detection Points needed to implement those services. After that, the service application 30 waits for the MSSP control process 26 to signal when it has a packet that matches the arming criteria.\n\nthe service application 30 applies its service logic (not shown) through the API 28 .\n\nThis service logic may, in addition to directing the packet to a chosen destination, configure additional metering for the packet flow that encountered the detection point, request additional event reports from this flow, indicate a charge plan that is applicable to the flow, request periodic charge notification events, or request flow statistics.\n\na default behavior of a service interaction between the MSSP control process 26 and the service logic of the application 30 may be specified without the need to implemenet a trigger detection point.\n\na source address, source port, destination address string within a data portion of a packet and protocol port are used to match incoming requests to determine if a predefined service interaction should be executed. If a flow matches the criteria, the actions specified in the remainder of the message are carried out.\n\nExample actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.\n\nthe service logic begins execution when an IDP is detected.\n\nthe service logic receives an event notification that the detection point was encountered. If the detection point is registered as a request detection point, the service logic responds when the MSSP request instruction within a timeout period. The response may modify the packet then forward it, release the flow or session, or redirect or connect the packet using the connect request.\n\nOther requests may also be made to program policy filters to be applied to flow or session.\n\nthe service filter request may be used by the service logic to specify the service interaction to be carried out when the detection point is encountered.\n\nthe API 28 provides a connect request message that instructs the MSSP control process 26 to establish a connection to a specified destination address on a flow that is suspended at a trigger point.\n\nthe destination address may be different than the desitination address in the packet that matched the trigger condition. This allows the service logic in the service application 30 to, for example, route connections to a best available resource.\n\nthe API 28 provides a release flow message that instructs the MSSP control process 26 to terminate an active flow.\n\nthe MSSP control process 26 will terminate the flow and may provide any events or metering messages following confirmation of the termination.\n\nthe service application 30 manages and controls sponsored packet switched data services, which include any and all unique network addresses that identify the packet switched data service, the policy decisions that determine how, and to which, packet switched data service provider the user is directed (e.g., a specific server on the Internet 24 ), and the policy decisions that determine which sponsor is to be billed for the session and on what basis.\n\nPolicy filters may be used to block IP traffic in either direction based on port, protocol, IP address, cookies, or other layer seven protocol characteristics.\n\nthe policy filters also allow the service logic to create and manage a wall garden or subscription based model.\n\nthe policy filters are dynamic in nature, allowing new services to be purchased dynamically and updated by the service logic.\n\nthe policy decisions for selection and billing may include rules that incorporate pre-agreements between an operator and third parties, either sponsors or service providers, as to the selection of the service provider and the method and basis of payment for the sponsor.\n\na policy decision of which service provider to make a connection to may be made at the time of the service request based upon such factors as a user identity, a location of the user, a time of day, a user class, a service provider class, network conditions, pre-agreement rules, and/or governmental regulations.\n\na policy decision of which sponsor to bill and on what basis can be made at time of the service request based upon similar factors such as the user identity, the location of the user, time of day, user class, service provider class, network conditions, pre-agreement rules, and/or governmental regulations.\n\na service interaction is defined by the service logic as having a beginning, middle, and end.\n\nthe beginning of service interaction is typically identified by an IDP (Initial Detection Point) event sent to the service logic when the detection point is encountered.\n\nthe service interaction will end when there are no further events registered by the service logic or the service logic explicitly terminates the dialogue.\n\nthe service interaction is bounded by the sequence of events and API calls received and made by the service logic between the IDP and the terminal event.\n\na service interaction is usually billable event that causes the service logic to write a CDR following the end of the interaction.\n\nthe details of service interaction boundaries are determined by the service logic.\n\na stock quote service for example may begin when an IDP matching the request is reported, and end on the response containing the quote. This same example can be expanded to include, for example, file downloads and email delivery.\n\nthe MSSP provides the means to detect and control an interaction and the service logic is responsible for making the API calls and processing events to implement the service.\n\nan interception process 50 includes a service application startup stage 52 , a service initialization stage 54 , a service deployment stage 56 , a service logic stage 58 and a shutdown stage 60 .\n\nthe service application startup stage 52 includes initializing ( 70 ) a transport layer.\n\nthe transport layer is initialized ( 70 ) by creating a TCP/IP socket and connecting the socket through the API 28 .\n\nthe stage 52 initializes ( 72 ) a session layer.\n\nthe initialization ( 72 ) includes sending a session open request to the MSSP server 22 .\n\nthe MSSP server 22 authenticates the application's credentials.\n\na session open confirmation is received from the MSSP server 22 .\n\nthe stage 52 initializes ( 74 ) an application layer.\n\nthe initialization ( 74 ) includes sending a negotiate API version request and receiving a negotiate API version confirmation. An open request is sent and confirmed.\n\nthe service initialization stage 54 includes sending ( 80 ) a get service list request; the MSSP server 22 looks up the services for this application.\n\nthe stage 54 receives ( 82 ) a get service list confirmation and sends ( 84 ) a get service detail request; the MSSP server 22 looks up configuration data for the service.\n\nthe stage 54 receives ( 86 ) a get service detail request confirmation.\n\nthe service deployment stage 56 includes sending ( 90 ) an Arm IDP request and receiving ( 92 ) an Arm IDP confirmation.\n\nthe MSSP server 22 verifies that the arming criteria meets any restrictions configured for the application and service and programs the ICP criteria into the MSSP server 22 .\n\nthe service logic stage 58 includes receiving ( 100 ) an initial DP event.\n\nthe stage 58 determines ( 102 ) a new destination for the subscriber connection and sends ( 104 ) a connect request to the new destination.\n\nthe stage 58 receives ( 106 ) a connect confirmation.\n\nthe shutdown stage 60 includes sending ( 110 ) a disarm IDP request and receiving ( 112 ) a disarm IDP confirmation.\n\nthe stage 60 sends ( 114 ) a close request and receives ( 116 ) a close confirmation.\n\nthe stage 60 sends ( 118 ) a session close request, receives ( 120 ) a session close confirmation, and closes ( 122 ) the TCP/IP socket.\n\na table 130 shows a set of data types utilized to define fields within messages used by the API 28 .\n\nthe table 130 includes a data type name 132 , a definition 134 , and a byte size 136 .\n\nCHAR[n] refers to a UTF-8 character string.\n\nUTF-8 is a character encoding scheme in which the entire set of ASCII characters are encoded in one byte with the same encoding as ASCII while also allowing any of the full range of Unicode characters to be encoded using multiple-byte sequences in which no byte contains an ASCII character value.\n\nAll numeric data of more than one byte in length is transmitted in a canonical network byte order defined by TCP/IP standards, i.e., in order of most significant byte to least significant byte. It should be noted that to ensure application correctness and portability, application developers are encouraged to use their platform's host-to-network and network-to-host conversion functions (such as hton1( ) and ntoh1( ) even when the host platform is known to use network byte order.\n\nhton1( ) is an example UNIX function that converts 32-bit (4-byte) quantities from host byte order to network byte order\n\nntoh1( ) is an example UNIX function that converts 32-bit quantities from network byte order to host byte order.\n\na communication path 140 (indicated by the arrows) between an application program 30 and the MSSP server 22 uses a layered architecture.\n\nthe application program 30 transmits data through its system's application layer 142 , presentation layer 144 , session layer 146 , transport layer 148 , TCP/IP layer 150 and lower layers 152 , to corresponding lowers layers 154 , TCP/IP layer 156 , transport layer 158 , session layer 160 , presentation layer 162 and application layer 164 of the MSSP SERVER 22 .\n\nthe transport layer 158 is used to provide a reliable transport to the session layer 160 .\n\nthe transport layer 158 is relatively lightweight since it is layered on top of the local TCP/IP layer 156 , which by definition is reliable.\n\nthe transport layer 158 receives messages from the session layer 160 that are then transmitted.\n\nthe transport layer 158 separates the byte stream provided by the TCP/IP layer 156 into messages that are framed by a transport header.\n\na frame is data that is transmitted between network points as a unit complete with addressing and necessary protocol control information.\n\na frame is usually transmitted serial bit by bit and contains a header field and a trailer field that âframeâ the data.\n\na frame marker unlike some other protocols, does not itself determine a boundary of a transport message header.\n\nthe frame marker data pattern may also be present elsewhere in a TCP/IP byte stream with no adverse effects or special encoding.\n\nthe frame marker provides a means to detect common programming errors (such as improper byte ordering or length calculation errors) that might otherwise cause a receiver to incorrectly interpret some other data as a transport message header and take inappropriate action.\n\nthe API 28 uses an 8-byte transport message header as the first element in a message.\n\nthe 8-byte transport message header includes a 4-byte INIT âframemarkerâ field that is a constant value used to verify the presence of a valid transport message header. Any other value is indicative of a message framing error.\n\nthe 8-byte transport message header also includes a 4-byte âmessagelengthâ field and contains an UNIT data type representing the length, in bytes, of the message data that follows.\n\nthe API 28 utilizes session level interfaces built on top of the reliable TCP/IP transport layer that guarantees a message will arrive.\n\nThis session layer provides a set of session level services to the application layer. These services include authentication, session level heartbeats, and session level acknowledgements.\n\na heartbeat monitors the status of a communication link and identifies when the last of a string of messages is not received. When either end of a connection has not sent any data for a specified number of seconds, it will transmit a heartbeat message. When either end of the connection has not received any data for a specified number of seconds, it will transmit a test request message. If there is still no heartbeat message received after the same time then the connection is considered lost and corrective action initiated.\n\nAll messages exchanged at the session layer include a header of four USHORT 2-byte fields as the first element in the message.\n\nthe header is referred to as a session message header and includes a SessionMessage type field, a SessionInstance field, a SessionSendSeqNo field and a SessionReceiveSeqNo field.\n\nthe SessionMessage Type field contains a value that identifies the type of message and the format of the message data.\n\nthe SessionInstance field contains a value that uniquely identifies the session instance.\n\nthe SessionSendSeqNo field contains the send sequence number of the message.\n\nthe SessionReceiveSeqNo field contains the send sequence number from the last received message.\n\nAll session messages include a pair of sequence numbers in the Session Message Header that are set by the sender and verified by the receiver. Each sender starts at zero and increments the send sequence number for each message sent. In addition, each sender keeps track of the next SessionSendSeqNo it expects to receive. Every message sent includes this number pair.\n\nthe sequence numbers are used to detect lost session messages as well as provide a means to acknowledge receipt of data.\n\nthe periodic exchange of sequence numbers in session heartbeat messages ensures that the sequence numbers remain up to date in the event that the session is idle with respect to SessData messages.\n\nthe session layer protocol version is negotiated during an open sequence.\n\na client specifies a desired version of the protocol to be used for the duration of the session.\n\nthe client initially specifies the highest version of the protocol supported by the client.\n\na server examines the requested version number and compares it against the versions it supports. If the requested version is in the range of versions supported by the server, the acceptance of the version is indicated in a subsequent SessOpenConf message. If the client has requested a version beyond those supported by the server, the server responds with a SessOpenConf message indicating that the session has been established using the highest version supported by the server. This version will be different from what was originally requested by the client. In the event that the server cannot find a mutually supported protocol version a SessError message with an error code of MSSP_E_INVALID_VERSION is sent and the session is closed.\n\nsession layer options are negotiated during the open sequence.\n\nthe client specifies the desired protocol options to be used for the duration of the session.\n\nthe client should always initially specify all options supported by the client.\n\nthe server examines the requested options mask and chooses those options that it supports.\n\nthe resulting mutual session options are communicated to the client in the subsequent SessOpenConf message. If the client is unable to function as a result of the options being reduced by the server, a SessError message with an error code of MS SP_E_INVALID_OPTIONS is sent to the server and the session closed.\n\na heartbeat interval is negotiated during the open sequence.\n\nthe client specifies its desired heartbeat interval in the SessOpenReq message, and the server responds with the heartbeat interval that the client should use in the subsequent SessOpenConf message.\n\na client and server exchange credentials during a session establishment sequence.\n\nthe client provides an encrypted Session Security Descriptor that is the MD5 message-digest of the SessOpenReq message (excluding the SessionSecurityDescriptor field) encrypted using a private key of a public/private key pair.\n\nthe MD5 message format is designed by RSA Data Security, Inc. and defined in IETF RFC 1321 (see www.ietf.org). Since a given application will likely open its session the same way every time, a random number field is provided in the message in order to prevent generating a âconstantâ message digest value and a resulting predictable Session Security Descriptor.\n\nthe MSSP server 22 configuration of the application contains the public key of the public/private key pair.\n\nthe server Upon receipt of the security descriptor in a SessOpenReq message, the server looks up the application in the MSSP server 22 configuration to obtain the client's public key, decrypt the given security descriptor using the public key, and verify that the decrypted result exactly matches the MD5 message-digest generated from the received message. If the credentials fail to validate, the server responds with a SessError message with an error code of MSSP_E_AUTH_FAILURE. If a number of successive failures occur in a unit amount of time, the server suspends listening for connection requests for a period of time not less than one minute.\n\nthe server provides a SessionSecurityDescriptor (that is the MD5 message-digest of the SessOpenConf message (excluding the SessionSecurityDescriptor field)) encrypted using the private key of a different public/private key pair) to the client in the SessOpenConf message.\n\nthe client decrypts the descriptor using the server's public key and authenticates the server. If the validation of the server credentials fail on the client side of the connection, the client sends a SessError message with an error code of MSSP_E_AUTH_FAILURE. If a number of successive failures occur in a unit amount of time, the client suspends connection requests for a period of time not less than one minute.\n\nthe SessOpenReq message is used to begin a session-level exchange of information between an application and the API 28 .\n\nthe SessOpenReq message is the first message that is after a transport layer connection has been established as described above.\n\nthe SessOpenReq message has the following format:\n\nAn 8-byte SessionHeader field that is a session header with a SessionMessage Type equal to Sess_Open_Req.\n\na 4-byte UNIT SessionVersion field that represents a session protocol version supported by the client.\n\na 4-byte UNIT SessionOptionsMask field that represents a bitwise combination of all the session layer options supported by the client.\n\na 4-byte UNIT SessionHeartbeatInterval field that represents the nominal interval between exchanges of session heartbeat messages in seconds.\n\na 4-byte UINT SessionApplicationID field that represents a MSSP server 22 determined value uniquely identifying this client application in the MSSP server 22 .\n\na 4-byte UNIT SessionRandonNum field represents any unpredictable value and is used to prevent predictable SessionSecurityDescriptor.\n\na 16-byte BYTE[16] SessionSecurityDescriptor field representing a session security descriptor that is a MD5 message-digest of the message (excluding this field) encrypted using the client's private key of a public/private key pair. The server decrypts the session security descriptor using its copy of the client's public key to authenticate the client.\n\nthe SessOpenConf message is used to complete an establishment of a session and communicate a result of negotiated parameters. This message is sent as the successful response to a SessOpenReq message and has the following format:\n\nAn 8-byte SessionHeader field representing a session header with SessionMessageType SESS_OPEN_CONF.\n\na 4-byte UINT SessionVersion field represents a session protocol version chosen for use by the server.\n\na 4-byte UNIT SessionOptionsMask field representing a bitwise combination of all of the client session layer options chosen by the server.\n\na 4-byte UNIT SessionHeartbeatInterval field representing a nominal interval between exchanges of session heartbeat messages in seconds.\n\na 4-byte UNIT SessionServerID field represents a value uniquely identifying this MSSP SERVER 22 instance.\n\na 4-byte UNIT SessionRandonNum field represents any unpredictable value and is used to prevent predictable SessionS ecurityDescriptor.\n\na 16-byte BYTE[16] SessionSecurityDescriptor field representing a session security descriptor that is the MD5 message-digest of the message (excluding this field) encrypted using the server's private key of a public/private key pair.\n\nthe client should decrypt the session security descriptor using its copy of the server's public key to authenticate the server.\n\na session requires that the client and server participate in a session maintenance procedure.\n\nthe session maintenance procedure ensures that inactive or idle sessions are functional as well as ensuring that the response time is within reasonable limits.\n\nthe session maintenance procedure is performed independent of whether or not other data is transmitted on the session.\n\nthe session maintenance procedure includes the exchange of a SessHeartbeatReq message, followed by a SessHeartbeatConf message.\n\nthe session maintenance procedure is initiated from the client side of a connection by sending a SessHeartbeatReq message.\n\nthe server performs a set of operations to ensure the server is functioning properly and returns a SessHeartbeatConf message if all is well.\n\nthe client fails the session by sending a SessError message with an error code of MSSP_E_HEARTBEAT_TIMEOUT to the server.\n\nthe client makes heartbeat requests at a periodic interval as specified in the SessOpenConf message at the time the session was established.\n\nthe first client heartbeat is sent upon receiving the SessOpenConf message.\n\na SessHeartbeatReq message Upon sending a SessHeartbeatReq message, a client timer is set to the heartbeat interval and a SessHeartbeatReq sent when the timer expires.\n\nthe server expects to see a heartbeat request within the specified heartbeat interval.\n\nthe server sets a timer following the transmission of the SessOpenConf message and the timeout will be set to twice the heartbeat interval. If the timer should expire and a heartbeat request is not received, the server fails the session by sending a SessError message with an error code of MSSP_E_HEARTBEAT_TIMEOUT. Each time a new heartbeat request is received, the server side timer is reset. At any given instant only one heartbeat request is outstanding. Note that the heartbeat messages will also be used to acknowledge DATA messages or detect errors related to mismanagement of sequence numbers on an idle session connection.\n\nthe SessHeartbeatReq message is used to request verification that the session partner is operating normally and has the following format:\n\na 4-byte UNIT SessionHeartbeatInstance field representing a value that uniquely identifies a given heartbeat in the session.\n\na 4-byte TIME SessionTimeStamp field represents a time that the heartbeat request was issued.\n\na 4-byte UNIT SessionHeartbeatInterval field representing a nominal interval between exchanges of session heartbeat messages, in seconds. This may be different than the current heartbeat interval when the sender desires to negotiate a new heartbeat interval.\n\nthe SessHeartbeatConf message is used to complete the verification of the session partner's normal operational status. This message is sent as the successful response to a SessHeartbeatReq message.\n\nthe SessHeartbeatConf message has the following format:\n\nAn 8-byte SessionHeader field represents a session header with SessionMessageType equal to SESS_HEARTBEAT_CONF.\n\na 4-byte UNIT SessionHeartbeatInstance field represents the same SessionHeartbeatInstance value that was given in the corresponding heartbeat request.\n\na 4-byte TIME SessionTimeStamp field represents the same SessionTimeStamp value that was given in the corresponding heartbeat request.\n\na 4-byte UNIT SessionHeartbeatInterval field representing a nominal interval between exchanges of session heartbeat messages, in seconds. This may be different than the current heartbeat interval when a new heartbeat interval has been negotiated.\n\na session may be closed by either client or server at anytime following successful session establishment.\n\na client or server initiates the closure procedure by sending a SessCloseReq message to the session partner.\n\nthe SessCloseReq message contains a code indicating the reason for the closure.\n\nthe requesting session partner shutdowns (in the socket sense) the transport layer following the transmission of the SessCloseReq message.\n\nthe receiving session partner notifies the application layer to allow any outstanding requests on the session to be completed. Any queued session messages are sent prior to the transmission of the SessCloseConf message. Once the SessCloseConf message is sent, the transport connection shutdowns and the socket connection is closed from the side that requested the session be closed.\n\na client may time-out a close request if a server fails to respond within a reasonable period of time. If a close request is timed-out by a client, a SessError message is sent to the server with an error code of MSSP_E_CLOSE_TIMEOUT. If a session partner is unable to process a close request because a session has not been previously opened at the time of a close request, a SessError message is sent to the requesting partner with an error code of MSSP_E_NO_SESSION. If a session is active or initialized and the session partner is unable to process a close request for any reason, the receiver sends a SessError message to the requester with an error code of MSSP_E_UNSPECIFIED_FAILURE.\n\nthe SessCloseReq message is used to initiate the orderly termination of a session and has the following format:\n\na 4-byte UNIT SessionCloseReasonCode field represents a value indicating a reason for the closure of the session.\n\nMSSP reason codes include, for example, normal operation, partial detail during normal operation, normal shutdown, subscriber logout, flow timeout and session timeout.\n\nSessCloseConf message is used to complete an orderly termination of a session. This message is sent as the successful response to a SessCloseReq message and has the following format:\n\nOne purpose of establishing a session is to exchange data between a client and a server. Data messages may be exchanged between parties following the completion of the session open sequence.\n\nthe session layer does not interpret data messages. Received data messages are forwarded to the application layer for processing. Only the bytes contained in the SessionData field of a SessData message are forwarded to the application layer. This effectively removes the session portion of the message prior to passing it to the application. Messages received from the transport layer are also devoid of any transport layer headers or data, and the messages are complete prior to processing. The converse is also true when transmitting data.\n\nthe session layer encapsulates the application data in a session data message that is forwarded to the transport layer for transmission.\n\na SessData message SessData is used to transmit application layer data to the session partner and has the following format:\n\nSessionData representing data to be delivered to the application layer.\n\na session may fail from time to time due to communication or process failures. In the event of a session failure, the failure is reported asynchronously under the context of the session partner detecting the failure.\n\nEither the client or the server side may send a SessError message.\n\na SessError message may be sent at anytime from the client side following the SessOpenReq message.\n\na SessError message may be sent at anytime from the server side including as a response to a SessOpenReq.\n\na SessError message contains an error code indicating the reason for the failure.\n\nthe session partner may or may not receive the SessError message depending upon the nature of the error. Following the transmission or receipt of a SessError message, data may not be sent over the session and the underlying transport connection should be shutdown and closed.\n\nthe SessError message is used to inform a session partner of an error condition that will prevent further session level communication; it has the following format:\n\na 4-byte UNIT SessionErrorCode field represents a value indicating a cause of the session failure.\n\nCapabilities of the MSSP server 22 may be grouped into feature categories. When applications 30 open their session with the MSSP server 22 the applications 30 specify what features they want through the API 28 . Each MSSP feature has a corresponding privilege bit.\n\na configuration entry in a MSSP configuration database 32 residing in a MSSP storage device 34 for an application contains a set of feature privileges that control what features the application 30 is authorized to use. Only the requested features that are authorized for the application 30 are granted, and the application 30 is informed of the features that have successfully been obtained in the response to the request. Application attempts to use messages in a feature category that it has not been granted are refused with a privilege error.\n\nFeature categories include a common services feature category 182 , an Initial Detection Point feature category 184 , an Event Reporting feature category 186 , a Service Filter feature category 188 , a Meter Configuration feature category 190 , a Charge Notification feature category 192 , a Charge Plane feature category 194 , a Detail Record Control feature, category 196 . a Statistics feature category 198 , and an Application Monitor feature category 200 . Messages associated with each of the feature categories 182 - 200 , with their respective format, are listed in Appendix A, and incorporated herein by reference.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nSignal Processing (AREA)\n\nComputer Networks & Wireless Communication (AREA)\n\nComputer Security & Cryptography (AREA)\n\nData Exchanges In Wide-Area Networks (AREA)\n\nExchange Systems With Centralized Control (AREA)\n\nAbstract\n\nA method in a network is provided. The method includes receiving messages from an application program in an application program interface (API), and passing the messages from the API to a control process in a mobile service switching platform (MSSP). A system is also provided. The system includes a Gateway General Packet Radio Service Support Node (GGSN) linked to control process in a Mobile Service Switching Platform (MSSP), a group of globally connected computers linked to the control process, an application program interface (API) connected to the control process, and an application system executing an application process linked to the API.\n\nDescription\n\nTECHNICAL FIELD\n\nThis invention relates to an application program interface (API). [0001]\n\nBACKGROUND\n\nIn general, an application program interface (API) is a specific method prescribed by a computer operating system or by another application program by which a programmer writing an application program can make requests of the operating system or another application. More specifically, an API is a formalized set of software calls and routines that can be referenced by an application program in order to access supporting services. [0002]\n\nSUMMARY\n\nIn aspect, the invention features a method including, in a network, receiving messages from an application program in an application program interface (API), and passing the messages from the API to a control process in a mobile service switching platform (MSSP). [0003]\n\nEmbodiments may include one or more of the following. The network may be a wireless network. The wireless network be be a second generation wireless network, a GSM network, a GPRS-enabled GSM network or a TDMA network. The wireless network may be a CDMA network, a UMTS network, a TETRA network or a Tetrapol network. The wireless network may be a DECT network, an AMPS network, a WLAN or a third generation wireless network. [0004]\n\nThe API may provide a protocol that allows the application program to control switching and routing functions in the MSSP. [0005]\n\nThe API may provide a protocol that allows the application program to redirect packet flow through the MSSP on a per-flow basis. [0006]\n\nThe API may provide a protocol that allows the application program to control policy decisions within the MSSP. [0007]\n\nThe API may include a protocol that allows the application program to arm initial detection points (IDPs) and services associated IDP events in the control process. [0008]\n\nThe API may include a protocol that allows the application program to disarm IDPs and service associated ICP events in the control process. [0009]\n\nThe API may include a protocol that allows the application program to request event reports. [0010]\n\nThe API may include a protocol that allows the application program to specify programmed behavior at a detection point in the control process. [0011]\n\nThe API may include a protocol that allows the application program to configure data elements that are metered by the control process of the MSSP. [0012]\n\nThe API may include a protocol that allows the application program to request byte-based reporting. The reporting may be session-based or flow-based. [0013]\n\nThe API may include a protocol that allows the application program to specify a cost of services provided. [0014]\n\nThe API may include a protocol that allows the application program to record a charge plan used in a detail record and a protocol that allows the application program to control when the detail record is written. [0015]\n\nThe API may include a protocol that allows the application program to obtain statistics for a session managed by the application program. [0016]\n\nThe API may include a protocol that allows the application program to obtain statistics for a flow managed by the application program. [0017]\n\nThe API may include a protocol that allows the application program to monitor a status of other applications connected to the control process of the MSSP. [0018]\n\nIn another aspect, the invention features an application program interface (API) including a set of application layer protocols that allows exchange of messages between an application process and a control process of a Mobile Service Switching Platform (MSSP) using Transmission Control Protocol/Internet Protocol (TCP/IP) network services. [0019]\n\nIn embodiments the set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated IDP events in the control process. [0020]\n\nThe set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated IDP events in the control process. [0021]\n\nThe set of application layers protocols may include a protocol that allows the application process to request event reports from the control process. [0022]\n\nThe set of application layers protocols may include a protocol that allows the application process to specify programmed behavior at a detection point in the control process. [0023]\n\nThe set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process. [0024]\n\nThe set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process. The reporting may include session-based reporting or flow-based reporting. [0025]\n\nThe set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP. [0026]\n\nThe set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP. [0027]\n\nThe set of application layers protocols may include a protocol that allows the application process to control when the detail record is written. [0028]\n\nThe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process. [0029]\n\nThe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process. [0030]\n\nThe set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process. [0031]\n\nIn another aspect, the invention features a system including a Gateway General Packet Radio Service Support Node (GGSN) linked to control process in a Mobile Service Switching Platform (MSSP), a group of globally connected computers linked to the control process, an application program interface (API) connected to the control process, and an application system executing an application process linked to the API. [0032]\n\nIn embodiments, the system may include a General Packet Radio Service Support Node linked to the GGSN. The system may include a Base Station Controller (BSC) linked to the General Packet Radio Service Support Node. The system may include a Base Transceiver Station (BTS) linked to the BSC and a mobile station (MS) linked to the BTS. [0033]\n\nThe API may include a set of application layer protocols that allows exchange of messages between the application process and the control process. [0034]\n\nThe set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated IDP events in the control process. [0035]\n\nThe set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated IDP events in the control process. [0036]\n\nThe set of application layers protocols may include a protocol that allows the application process to request event reports from the control process. [0037]\n\nThe set of application layers protocols may include a protocol that allows the application process to specify programmed behavior at a detection point in the control process. [0038]\n\nThe set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process. [0039]\n\nThe set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process. Reporting may be session-based or flow-based. [0040]\n\nThe set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP. [0041]\n\nThe set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP. [0042]\n\nThe set of application layers protocols may include a protocol that allows the application process to control when the detail record is written. [0043]\n\nThe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process. [0044]\n\nThe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process. [0045]\n\nThe set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process. [0046]\n\nEmbodiments of the invention may have one or more of the following advantages. [0047]\n\nThe Application Program Interface (API) provides an application layer protocol that exchanges messages with a Mobile Service Switching Platform (MSSP) using simple TCP/IP network services that are available on almost all computer platforms. [0048]\n\nThe API provides a set of protocols that allow service logic contained in an external application program to control switching/routing functions of a Mobile Service Switching Platform. [0049]\n\nThe API provides a protocol for an operator to limit the scope of an application's detection points, in which a detection point is a defined place in a state machine of a control entity where application event reporting and/or control is possible. [0050]\n\nThe API provides a protocol that is common to all applications, regardless of application privileges. [0051]\n\nThe API provides a protocol that allows an application to arm and disarm Initial Detection Points (IDPs) in a Mobile Service Switching Platform (MSSP) and service associated IDP events, where an IDP is defined as a detection point armed so as to create a new control dialog with an application when conditions match given criteria. [0052]\n\nThe API provides a protocol that allows an application to request additional event reports subsequent to an Initial Detection Point event. When the IDP that initiates a control dialog is a trigger, the application typically requests additional event reports. [0053]\n\nThe API provides a protocol that allows an application to specify programmed behavior at a Detection Point (DP) that does not require the involvement of the application. Messages are used to match incoming requests to determine if the predefined service interaction should be executed. The matching process is similar to the process used for Initial Detection Points in general and wildcards may be used in the fields to be matched. If a flow matches the criteria, the actions specified in the remainder of the message will be carried out with no application involvement. Actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number. A message is used to determine which events will be reported in the future for the flow if event reports are required. Criteria to be matched may not overlap with armed Initial Detection Point criteria. If the request cannot be completed for any reason a message will be returned with a matching RequestID and an error code indicating the nature of the failure. If the request completes successfully, another message is returned. Service Filtering remains active until cancelled by a specific message request. [0054]\n\nThe API provides a protocol that allows an application to configure data elements that are metered by a Mobile Service Switching Platform (MSSP). [0055]\n\nThe API provides a protocol that allows an application to request byte based reporting. Reporting may be requested on a session or flow basis. Session based charge notification effectively causes the same charge notification criteria to be applied to all flows in the session. Registering for charge notification events causes the number of bytes of the specified type transferred in uplink and downlink directions to be metered. Each time a reporting threshold is reached a message is sent from the MSSP to the application indicating the number of bytes that have been transferred, and counters are reset and begin counting towards the threshold again. Charge notification continues until the flow terminates or charge notification is explicitly cancelled by a cancel request. A packet is the atomic unit counted and each packet either falls before the count is evaluated or after the count is evaluated. As a result, charge notification may not occur exactly on the byte count specified. For example, if notification was requested every 10K bytes, the notification may occur at 10.5 Kbytes if the packet that brought the count over 10K was slightly greater than 500 bytes. The actual counter values are provided in a message. [0056]\n\nThe API provides a protocol that allows an application to indicate a cost of the services provided and record a charge plan used in an MSSP detail record. [0057]\n\nThe API provides a protocol that allows an application to control when MSSP detail records are written. [0058]\n\nThe API provides a protocol that allows an application to obtain various statistics for a session or flow managed by the application. [0059]\n\nThe API provides a protocol that allows an application to monitor the status of other applications connected to the same MSSP instance. [0060]\n\nThe API provides a protocol that allows the redirection of packet flow on a per-flow basis. [0061]\n\nOther features, objects, and advantages of the invention will be apparent from the description and drawings, and from the claims.[0062]\n\nDESCRIPTION OF DRAWINGS\n\nFIG. 1 is a block diagram of a network. [0063]\n\nFIG. 2 is a flow diagram of an interception process. [0064]\n\nFIG. 3 is a flow diagram of the service application startup stage of FIG. 2. [0065]\n\nFIG. 4 is a flow diagram of the service initialization stage of FIG. 2. [0066]\n\nFIG. 5 is a flow diagram of the service deployment stage of FIG. 2. [0067]\n\nFIG. 6 is a flow diagram of the service logic stage of FIG. 2. [0068]\n\nFIG. 7 is a flow diagram of the shutdown stage of FIG. 2. [0069]\n\nFIG. 8 is a table of data types used by the API of FIG. 1. [0070]\n\nFIG. 9 is a block diagram of a communication path. [0071]\n\nFIG. 10 is a block diagram of a TCP/IP byte stream divided into session messages by the transport layer. [0072]\n\nFIG. 11 shows a table listing sample error codes. [0073]\n\nFIG. 12 shows a table listing sample feature categories.[0074]\n\nDETAILED DESCRIPTION\n\nReferring to FIG. 1, a [0075] network 10 is shown. The network 10, for example, may be a wireless network. The wireless network may be, for example, a second generation wireless network, a Global System for Mobile Communications (GSM) network, or a General Packet Radio System (GPRS) enabled GSM. The wireless network may be a Time Division Multiple Access (TDMA) network, a Code Division Multiple Access (CDMA) network, or a Universal Mobile Telecommunications System (UMTS) network. The wireless network may be a TETRA network, a Tetrapol network, a DECT network, an AMPS network, a wireless local area network (WLAN) or a third generation wireless network. By way of example, a GPRS enabled GSM network is described.\n\nThe [0076] network 10 includes a Mobile Station (MS) 12 connected to a Base Transceiver Station (BTS) 14. The BTS 14 is connected to a Base Station Controller (BSC) 16. In mobile communications, the MS 12 is a station located within a mobile service intended to be used while in motion or during halts at unspecified points. An example mobile station is a hand held cellular telephone.\n\nThe [0077] BTS 14 holds radio transceivers that define a cell and coordinates radio-link protocols with the MS 12. The BTS 14 is a component of the network 10 from which all signals are sent and received. The BTS 14, often called a cell phone tower, is linked to, and controlled by, a Base Station Controller (BSC) 16. The BSC 16 is a component in the network 10 that manages radio resources for one or more base transceiver stations, such as BTS 14, for example.\n\nThe [0078] BSC 16 is linked to a SGSN 18. The SGSN 18 is a General Packet Radio Service Support (GPRS) Node that serves GPRS mobile by sending or receiving packets via the BSC 16. The SGSN 18 is linked to a Gateway GPRS Support Node (GGSN) 20. The GGSN 20 acts as a gateway between a General Packet Radio Service (GPRS) network and a Packet Switched Public Data Network (PSPDN).\n\nThe [0079] GGSN 20 is linked to a Mobile Service Switching Platform (MSSP) server 22. The MSSP server 22 resides between the GGSN 20 and a globally networked group of computers, such as Internet 24. The MSSP server 22 analyzes all of the Internet Protocol (IP) data packets exchanged between the MS 12 and the Internet 24. A MSSP control process 26 provides the capability to set triggers or event notifications and increment counters based on IP flow characteristics. An IP flow can be thought of as an abstraction representing a movement of data between two endpoints, such as MS 12 and a server (not shown) residing on the Internet 24. The MSSP control process 26 uses these capabilities to implement internal services and detail reporting. An Application Program Interface (API) 28 links the MSSP control process 26 to external applications 30. The API 28 provides a mechanism for the external applications 30 to control the MSSP control process 26 to provide intelligent services. The API 28, in various embodiments, may be implemented as, for example, a Corba based API, an XML based API, a PARLAY server, an OSA Server, or a JAIN server.\n\nBriefly, the [0080] MSSP server 22 functions as both an Internet router and an IP packet analyzer. Data contained in a header field of an IP packet is defined in the Internet Engineering Task Force (IETF) RFC 791, incorporated herein by reference (see www.ietf.org). The IETF is a large open international community of network designers, operators, vendors, and researchers concerned with the evolution of the Internet architecture and the smooth operation of the Internet.\n\nThe Internet Protocol (IP) is designed for use in interconnected systems of packet-switched computer communication networks. IP provides for transmitting blocks of data called datagrams from sources to destinations, where sources and destinations are hosts identified by fixed length addresses. The IP also provides for fragmentation and reassembly of long datagrams and, if necessary, for transmission through âsmall packetâ networks. [0081]\n\nThe MS SP control process [0082] 26 is designed to analyze 1P packet headers in real time to manage counters and signal when packet characteristics match specified conditions. A signal may be an event report or a trigger. An event report reports an occurrence of some event while continuing to monitor packet flow. A trigger causes processing of the IP packet to be suspended until the MSSP control process 26 responds with specific instructions for resuming processing of the IP packet. A trigger response may simply direct IP packet processing to be continued unchanged, or it may altar packet processing by specifying a different destination for the packet or cause the packet to be discarded altogether. The API 28 provides, in one example, a way for the other applications 30 to communicate with the MSSP control process 26 and manipulate event reports and triggers.\n\nThe MSSP control process [0083] 26 manages many different types of IP packets. In one example, the MSSP control process 26 is divided into different state machines (not shown), each state machine responsible for different types of packets. In general, a state machine is any device that stores the status of something at a given time and can operate on input to change the status and/or cause an action or output to take place for any given change. In practice, state machines are used to develop and describe specific device or program interactions.\n\nWithin each state machine of the MSSP control process [0084] 26 there are strategic places where important information becomes available or key decisions are made. These places are called detection points. A detection point (DP) is a defined place in a state machine of a control entity where application event reporting and/or control are possible, and manageable through the API 28.\n\nAn Event Detection Point (EDP) is a detection point armed within the context of an existing control dialog. Event detection points do not have explicit criteria; they are only applicable to a specific state machine instance of a control entity that generated the control dialog. In general, event detection points set within one control dialog do not affect a behavior of any other instance of that state machine. A complete set of detection points in a given state machine is known as a detection point class. [0085]\n\nOne of the most commonly used Internet protocols is the Transmission Control Protocol (TCP), which is defined in IETF RFC 793. By way of example, detection points using a TCP detection point class will be discussed below. However, it should be realized that other protocols might be utilized. [0086]\n\nTCP provides a reliable, connection oriented communication path between two application processes (usually referred to as a client and a server). The client initiates a connection and the server accepts the connection before any data can be exchanged. The TCP protocol ensures that all of the data sent is received by the other side correctly and in the order that it was sent. [0087]\n\nIn order to initiate a TCP connection to a server, a client sends an IP packet to the server's IP address containing a TCP header with a âSYNâ flag set and specifying a port number of the server application that it wishes to connect to. The server accepts the connection by sending a similar SYN packet back to the client, and the client acknowledges the SYN from the server by sending an IP packet containing a TCP header with the âACKâ flag set. [0088]\n\nPackets pass through the MSSP control process [0089] 26 in the MSSP server 22 on their way between a client, e.g., MS 12, and a server (not shown) residing on the Internet 24. By examining the IP header of the packets, the MSSP control process 26 determines that the IP packet encapsulates TCP data and assigns the packet to TCP control logic. By examining the data in the TCP header in conjunction with the data in the IP header, the TCP control logic can distinguish each segment of the connection establishment.\n\nFor example, suppose that one of the [0090] service applications 30 would like to âinterceptâ TCP connections to a specific server on the Internet 24 and redirect them to different servers on the Internet 24, perhaps based on the service application's knowledge of current server load conditions. The service application 30 can instruct the MSSP control process 26 through the API 28 to generate a trigger that watches for a TCP SYN packet that has a destination that matches the server to be intercepted. This is referred to as an Initial Detection Point (IDP). An IDP is a detection point armed so as to generate a new control dialog with an application when conditions match given criteria.\n\nAll other TCP packets, and TCP SYN packets directed to a different destination, continue to be processed normally. A TCP SYN packet with a destination that matches the arming criteria, however, causes processing of that packet to be suspended and an IDP event notification sent to the [0091] service application 30 that armed the IDP through the API 28.\n\nThe IDP event notification may include, for example, information from the suspended packet that the [0092] service application 30 may use to determine a correct destination for the connection. The service application 30 then directs the MSSP control process 26 through the API 28 to resume packet processing with a different destination address. The MSSP control process 26 forwards a modified TCP SYN packet to the new destination, where that server responds in a typical manner. The service application's involvement is completely transparent, i.e., neither the client, e.g., MS 12, nor the server (not shown) on the Internet 24 is aware that any redirection has taken place.\n\n[0093] Service applications 30 interact with the MSSP control process 26 by exchanging TCP/IP messages. The API 28 listens for connections from service applications 30. When an application connection is made, the API 28 authenticates the identity of the connected service application 30 and looks up the features that the application is authorized to access.\n\nThe [0094] service application 30, once its communication session with the API 28 is established, requests a list of services that it is expected to provide from the MSSP control process 26 and then arms Initial Detection Points needed to implement those services. After that, the service application 30 waits for the MSSP control process 26 to signal when it has a packet that matches the arming criteria.\n\nWhen the MSSP control process [0095] 26 signals an IDP event, the service application 30 applies its service logic (not shown) through the API 28. This service logic may, in addition to directing the packet to a chosen destination, configure additional metering for the packet flow that encountered the detection point, request additional event reports from this flow, indicate a charge plan that is applicable to the flow, request periodic charge notification events, or request flow statistics.\n\nIn an example, using an activate service filtering request message of the API [0096] 28, a default behavior of a service interaction between the MSSP control process 26 and the service logic of the application 30 may be specified without the need to implemenet a trigger detection point. A source address, source port, destination address string within a data portion of a packet and protocol port are used to match incoming requests to determine if a predefined service interaction should be executed. If a flow matches the criteria, the actions specified in the remainder of the message are carried out. Example actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.\n\nIn another example, the service logic begins execution when an IDP is detected. The service logic receives an event notification that the detection point was encountered. If the detection point is registered as a request detection point, the service logic responds when the MSSP request instruction within a timeout period. The response may modify the packet then forward it, release the flow or session, or redirect or connect the packet using the connect request. Other requests may also be made to program policy filters to be applied to flow or session. Optionally the service filter request may be used by the service logic to specify the service interaction to be carried out when the detection point is encountered. [0097]\n\nFor example, the API [0098] 28 provides a connect request message that instructs the MSSP control process 26 to establish a connection to a specified destination address on a flow that is suspended at a trigger point. The destination address may be different than the desitination address in the packet that matched the trigger condition. This allows the service logic in the service application 30 to, for example, route connections to a best available resource.\n\nThe API [0099] 28 provides a release flow message that instructs the MSSP control process 26 to terminate an active flow. The MSSP control process 26 will terminate the flow and may provide any events or metering messages following confirmation of the termination.\n\nThus, using the API [0100] 28, the service application 30 manages and controls sponsored packet switched data services, which include any and all unique network addresses that identify the packet switched data service, the policy decisions that determine how, and to which, packet switched data service provider the user is directed (e.g., a specific server on the Internet 24), and the policy decisions that determine which sponsor is to be billed for the session and on what basis. Policy filters may be used to block IP traffic in either direction based on port, protocol, IP address, cookies, or other layer seven protocol characteristics. The policy filters also allow the service logic to create and manage a wall garden or subscription based model. The policy filters are dynamic in nature, allowing new services to be purchased dynamically and updated by the service logic.\n\nThe policy decisions for selection and billing may include rules that incorporate pre-agreements between an operator and third parties, either sponsors or service providers, as to the selection of the service provider and the method and basis of payment for the sponsor. A policy decision of which service provider to make a connection to may be made at the time of the service request based upon such factors as a user identity, a location of the user, a time of day, a user class, a service provider class, network conditions, pre-agreement rules, and/or governmental regulations. For example, a policy decision of which sponsor to bill and on what basis can be made at time of the service request based upon similar factors such as the user identity, the location of the user, time of day, user class, service provider class, network conditions, pre-agreement rules, and/or governmental regulations. [0101]\n\nA service interaction is defined by the service logic as having a beginning, middle, and end. The beginning of service interaction is typically identified by an IDP (Initial Detection Point) event sent to the service logic when the detection point is encountered. The service interaction will end when there are no further events registered by the service logic or the service logic explicitly terminates the dialogue. The service interaction is bounded by the sequence of events and API calls received and made by the service logic between the IDP and the terminal event. A service interaction is usually billable event that causes the service logic to write a CDR following the end of the interaction. The details of service interaction boundaries are determined by the service logic. A stock quote service for example may begin when an IDP matching the request is reported, and end on the response containing the quote. This same example can be expanded to include, for example, file downloads and email delivery. The MSSP provides the means to detect and control an interaction and the service logic is responsible for making the API calls and processing events to implement the service. [0102]\n\nReferring to FIG. 2, using TCP as an example, an [0103] interception process 50 includes a service application startup stage 52, a service initialization stage 54, a service deployment stage 56, a service logic stage 58 and a shutdown stage 60.\n\nReferring to FIG. 3, the service [0104] application startup stage 52 includes initializing (70) a transport layer. The transport layer is initialized (70) by creating a TCP/IP socket and connecting the socket through the API 28. The stage 52 initializes (72) a session layer. The initialization (72) includes sending a session open request to the MSSP server 22. The MSSP server 22 authenticates the application's credentials. A session open confirmation is received from the MSSP server 22. The stage 52 initializes (74) an application layer. The initialization (74) includes sending a negotiate API version request and receiving a negotiate API version confirmation. An open request is sent and confirmed.\n\nReferring to FIG. 4, the [0105] service initialization stage 54 includes sending (80) a get service list request; the MSSP server 22 looks up the services for this application. The stage 54 receives (82) a get service list confirmation and sends (84) a get service detail request; the MSSP server 22 looks up configuration data for the service. The stage 54 receives (86) a get service detail request confirmation.\n\nReferring to FIG. 5, the [0106] service deployment stage 56 includes sending (90) an Arm IDP request and receiving (92) an Arm IDP confirmation. The MSSP server 22 verifies that the arming criteria meets any restrictions configured for the application and service and programs the ICP criteria into the MSSP server 22.\n\nReferring to FIG. 6, the [0107] service logic stage 58 includes receiving (100) an initial DP event. The stage 58 determines (102) a new destination for the subscriber connection and sends (104) a connect request to the new destination. The stage 58 receives (106) a connect confirmation.\n\nReferring to FIG. 7, the [0108] shutdown stage 60 includes sending (110) a disarm IDP request and receiving (112) a disarm IDP confirmation. The stage 60 sends (114) a close request and receives (116) a close confirmation. The stage 60 sends (118) a session close request, receives (120) a session close confirmation, and closes (122) the TCP/IP socket.\n\nReferring to FIG. 8, a table [0109] 130 shows a set of data types utilized to define fields within messages used by the API 28. The table 130 includes a data type name 132, a definition 134, and a byte size 136. CHAR[n] refers to a UTF-8 character string. UTF-8 is a character encoding scheme in which the entire set of ASCII characters are encoded in one byte with the same encoding as ASCII while also allowing any of the full range of Unicode characters to be encoded using multiple-byte sequences in which no byte contains an ASCII character value.\n\nAll numeric data of more than one byte in length is transmitted in a canonical network byte order defined by TCP/IP standards, i.e., in order of most significant byte to least significant byte. It should be noted that to ensure application correctness and portability, application developers are encouraged to use their platform's host-to-network and network-to-host conversion functions (such as hton1( ) and ntoh1( ) even when the host platform is known to use network byte order. hton1( ) is an example UNIX function that converts 32-bit (4-byte) quantities from host byte order to network byte order, while ntoh1( ) is an example UNIX function that converts 32-bit quantities from network byte order to host byte order. [0110]\n\nReferring to FIG. 9, a communication path [0111] 140 (indicated by the arrows) between an application program 30 and the MSSP server 22 uses a layered architecture. The application program 30 transmits data through its system's application layer 142, presentation layer 144, session layer 146, transport layer 148, TCP/IP layer 150 and lower layers 152, to corresponding lowers layers 154, TCP/IP layer 156, transport layer 158, session layer 160, presentation layer 162 and application layer 164 of the MSSP SERVER 22.\n\nThe transport layer [0112] 158 is used to provide a reliable transport to the session layer 160. The transport layer 158 is relatively lightweight since it is layered on top of the local TCP/IP layer 156, which by definition is reliable. The transport layer 158 receives messages from the session layer 160 that are then transmitted. The transport layer 158 separates the byte stream provided by the TCP/IP layer 156 into messages that are framed by a transport header.\n\nIn general, a frame is data that is transmitted between network points as a unit complete with addressing and necessary protocol control information. A frame is usually transmitted serial bit by bit and contains a header field and a trailer field that âframeâ the data. [0113]\n\nReferring to FIG. 10, a representation of a TCP/IP byte stream divided into session messages by the transport layer is shown. A frame marker, unlike some other protocols, does not itself determine a boundary of a transport message header. The frame marker data pattern may also be present elsewhere in a TCP/IP byte stream with no adverse effects or special encoding. The frame marker provides a means to detect common programming errors (such as improper byte ordering or length calculation errors) that might otherwise cause a receiver to incorrectly interpret some other data as a transport message header and take inappropriate action. [0114]\n\nThe API [0115] 28 uses an 8-byte transport message header as the first element in a message. The 8-byte transport message header includes a 4-byte INIT âframemarkerâ field that is a constant value used to verify the presence of a valid transport message header. Any other value is indicative of a message framing error. The 8-byte transport message header also includes a 4-byte âmessagelengthâ field and contains an UNIT data type representing the length, in bytes, of the message data that follows.\n\nThe API [0116] 28 utilizes session level interfaces built on top of the reliable TCP/IP transport layer that guarantees a message will arrive. This session layer provides a set of session level services to the application layer. These services include authentication, session level heartbeats, and session level acknowledgements.\n\nIn general, a heartbeat monitors the status of a communication link and identifies when the last of a string of messages is not received. When either end of a connection has not sent any data for a specified number of seconds, it will transmit a heartbeat message. When either end of the connection has not received any data for a specified number of seconds, it will transmit a test request message. If there is still no heartbeat message received after the same time then the connection is considered lost and corrective action initiated. [0117]\n\nAll messages exchanged at the session layer include a header of four USHORT 2-byte fields as the first element in the message. The header is referred to as a session messa"
    }
}