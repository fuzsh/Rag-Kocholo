{
    "id": "correct_subsidiary_00039_1",
    "rank": 1,
    "data": {
        "url": "https://patents.google.com/patent/EP1491029A4/ja",
        "read_more_link": "",
        "language": "en",
        "title": "EP1491029A4 - APPLICATION PROGRAM POINT - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2002-03-18T00:00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/EP1491029A4/ja",
        "text": "APPLICATION PROGRAM POINT\n\nInfo\n\nPublication number\n\nEP1491029A4\n\nEP1491029A4 EP03745136A EP03745136A EP1491029A4 EP 1491029 A4 EP1491029 A4 EP 1491029A4 EP 03745136 A EP03745136 A EP 03745136A EP 03745136 A EP03745136 A EP 03745136A EP 1491029 A4 EP1491029 A4 EP 1491029A4\n\nAuthority\n\nEP\n\nEuropean Patent Office\n\nPrior art keywords\n\napplication\n\nprotocol\n\nallows\n\napi\n\nmssp\n\nPrior art date\n\n2002-03-18\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nWithdrawn\n\nApplication number\n\nEP03745136A\n\nOther languages\n\nGerman (de)\n\nEnglish (en)\n\nFrench (fr)\n\nOther versions\n\nEP1491029A1 (en\n\nInventor\n\nThomas E Hamilton\n\nClifford S Atwood\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nBytemobile Network Services\n\nOriginal Assignee\n\nProquent Systems Corp\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n2002-03-18\n\nFiling date\n\n2003-03-18\n\nPublication date\n\n2006-05-10\n\n2003-03-18 Application filed by Proquent Systems Corp filed Critical Proquent Systems Corp\n\n2004-12-29 Publication of EP1491029A1 publication Critical patent/EP1491029A1/en\n\n2006-05-10 Publication of EP1491029A4 publication Critical patent/EP1491029A4/en\n\nStatus Withdrawn legal-status Critical Current\n\nLinks\n\nEspacenet\n\nEPO GPI\n\nEP Register\n\nGlobal Dossier\n\nDiscuss\n\nClassifications\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04W—WIRELESS COMMUNICATION NETWORKS\n\nH04W80/00—Wireless network protocols or protocol adaptations to wireless operation\n\nH04W80/08—Upper layer protocols\n\nH04W80/12—Application layer protocols, e.g. WAP [Wireless Application Protocol]\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M3/00—Automatic or semi-automatic exchanges\n\nH04M3/42—Systems providing special services or facilities to subscribers\n\nH04M3/4228—Systems providing special services or facilities to subscribers in networks\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04B—TRANSMISSION\n\nH04B7/00—Radio transmission systems, i.e. using radiation field\n\nH04B7/005—Control of transmission; Equalising\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04L—TRANSMISSION OF DIGITAL INFORMATION, e.g. TELEGRAPHIC COMMUNICATION\n\nH04L9/00—Cryptographic mechanisms or cryptographic arrangements for secret or secure communications; Network security protocols\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M3/00—Automatic or semi-automatic exchanges\n\nH04M3/42—Systems providing special services or facilities to subscribers\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M2207/00—Type of exchange or network, i.e. telephonic medium, in which the telephonic communication takes place\n\nH04M2207/18—Type of exchange or network, i.e. telephonic medium, in which the telephonic communication takes place wireless networks\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04M—TELEPHONIC COMMUNICATION\n\nH04M3/00—Automatic or semi-automatic exchanges\n\nH04M3/22—Arrangements for supervision, monitoring or testing\n\nH04M3/36—Statistical metering, e.g. recording occasions when traffic exceeds capacity of trunks\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13003—Constructional details of switching devices\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/1305—Software aspects\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13098—Mobile subscriber\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13109—Initializing, personal profile\n\nH—ELECTRICITY\n\nH04—ELECTRIC COMMUNICATION TECHNIQUE\n\nH04Q—SELECTING\n\nH04Q2213/00—Indexing scheme relating to selecting arrangements in general and for multiplex systems\n\nH04Q2213/13349—Network management\n\nDefinitions\n\nThis invention relates to an application program interface (API).\n\nAPI application program interface\n\nan application program interface is a specific method prescribed by a computer operating system or by another application program by which a programmer writing an application program can make requests of the operating system or another application. More specifically, an API is a formalized set of software calls and routines that can be referenced by an application program in order to access supporting services.\n\nthe invention features a method including, in a network, receiving messages from an application program in an application program interface (API), and passing the messages from the API to a control process in a mobile service switching platform (MSSP).\n\nAPI application program interface\n\nMSSP mobile service switching platform\n\nthe network may be a wireless network.\n\nthe wireless network be be a second generation wireless network, a GSM network, a GPRS-enabled GSM network or a TDMA network.\n\nthe wireless network may be a CDMA network, a UMTS network, a TETRA network or a Tetrapol network.\n\nthe wireless network may be a DECT network, an AMPS network, a WLAN or a third generation wireless network.\n\nthe API may provide a protocol that allows the application program to control switching and routing functions in the MSSP.\n\nthe API may provide a protocol that allows the application program to redirect packet flow through the MSSP on a per-flow basis.\n\nthe API may provide a protocol that allows the application program to control policy decisions within the MSSP.\n\nthe API may include a protocol that allows the application program to arm initial detection points (IDPs) and services associated IDP events in the control process.\n\nIDPs initial detection points\n\nthe API may include a protocol that ahows the application program to disarm IDPs and service associated ICP events in the control process.\n\nthe API may include a protocol that allows the application program to request event reports.\n\nthe API may include a protocol that allows the application program to specify programmed behavior at a detection point in the control process.\n\nthe API may include a protocol that allows the application program to configure data elements that are metered by the control process of the MSSP.\n\nthe API may include a protocol that allows the application program to request byte-based reporting.\n\nthe reporting may be session-based or flow-based.\n\nthe API may include a protocol that allows the application program to specify a cost of services provided.\n\nthe API may include a protocol that allows the application program to record a charge plan used in a detail record and a protocol that allows the application program to control when the detail record is written.\n\nthe API may include a protocol that allows the application program to obtain statistics for a session managed by the application program.\n\nthe API may include a protocol that allows the application program to obtain statistics for a flow managed by the application program.\n\nthe API may include a protocol that allows the application program to monitor a status of other applications connected to the control process of the MSSP.\n\nthe invention features an application program interface (API) including a set of application layer protocols that allows exchange of messages between an application process and a control process of a Mobile Service Switching Platform (MSSP) using Transmission Control Protocol/Internet Protocol (TCP/IP) network services.\n\nAPI application program interface\n\nMSSP Mobile Service Switching Platform\n\nTCP/IP Transmission Control Protocol/Internet Protocol\n\nthe set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated -DP events in the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated -DP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to request event reports from the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify programmed behavior at a detection point in the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process.\n\nthe reporting may include session-based reporting or flow-based reporting.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to control when the detail record is written.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process.\n\nthe invention features a system including a Gateway General Packet Radio Service Support Node (GGSN) linked to control process in a Mobile Service Switching Platform (MSSP), a group of globally connected computers linked to the control process, an application program interface (API) connected to the control process, and an application system executing an application process linked to the API.\n\nGGSN Gateway General Packet Radio Service Support Node\n\nMSSP Mobile Service Switching Platform\n\nAPI application program interface\n\nthe system may include a General Packet Radio Service Support Node linked to the GGSN.\n\nthe system may include a Base Station Controller (BSC) linked to the General Packet Radio Service Support Node.\n\nBSC Base Station Controller\n\nthe system may include a Base Transceiver Station (BTS) linked to the BSC and a mobile station (MS) linked to the BTS.\n\nBTS Base Transceiver Station\n\nMS mobile station\n\nthe API may include a set of application layer protocols that allows exchange of messages between the application process and the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to arm initial detection points (IDPs) and services associated -DP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to disarm initial detection points (IDPs) and services associated -DP events in the control process.\n\nIDPs initial detection points\n\nthe set of application layers protocols may include a protocol that allows the application process to request event reports from the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify progr-immed behavior at a detection point in the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to configure data elements that are metered by the control process.\n\nthe set of application layers protocols may include a protocol that allows the application process to request byte-based reporting in the control process. Reporting may be session-based or flow-based.\n\nthe set of application layers protocols may include a protocol that allows the application process to specify a cost of services provided by the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to record a charge plan used in a detail record stored in the MSSP.\n\nthe set of application layers protocols may include a protocol that allows the application process to control when the detail record is written.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a session managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to obtain statistics for a flow managed by the application process.\n\nthe set of application layers protocols may include a protocol that allows the application process to monitor a status of other application processes connected to the control process.\n\nEmbodiments of the invention may have one or more of the following advantages.\n\nthe Application Program Interface provides an application layer protocol that exchanges messages with a Mobile Service Switching Platform (MSSP) using simple TCP/IP network services that are available on almost all computer platforms.\n\nthe API provides a set of protocols that allow service logic contained in an external application program to control switching/routing functions of a Mobile Service Switching Platform.\n\nthe API provides a protocol for an operator to limit the scope of an application's detection points, in which a detection point is a defined place in a state machine of a control entity where application event reporting and/or control is possible.\n\nthe API provides a protocol that is common to all applications, regardless of application privileges.\n\nthe API provides a protocol that allows an application to arm and disarm Initial Detection Points (IDPs) in a Mobile Service Switching Platform (MSSP) and service associated -DP events, where an -DP is defined as a detection point armed so as to create a new control dialog with an application when conditions match given criteria.\n\nIDPs Initial Detection Points\n\nMSSP Mobile Service Switching Platform\n\nthe API provides a protocol that allows an application to request additional event reports subsequent to an Initial Detection Point event.\n\nthe application typically requests additional event reports.\n\nthe API provides a protocol that allows an application to specify programmed behavior at a Detection Point (DP) that does not require the involvement of the application.\n\nDP Detection Point\n\nMessages are used to match incoming requests to determine if the predefined service interaction should be executed.\n\nthe matching process is similar to the process used for Initial Detection Points in general and wildcards may be used in the fields to be matched. If a flow matches the criteria, the actions specified in the remainder of the message will be carried out with no application involvement. Actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.\n\na message is used to determine which events will be reported in the future for the flow if event reports are required.\n\nCriteria to be matched may not overlap with armed Initial Detection Point criteria. If the request cannot be completed for any reason a message will be returned with a matching RequestlD and an error code indicating the nature of the failure. If the request completes successfully, another message is returned. Service Filtering remains active until cancelled by a specific message request.\n\nthe API provides a protocol that allows an application to configure data elements that are metered by a Mobile Service Switching Platform (MSSP).\n\nMSSP Mobile Service Switching Platform\n\nthe API provides a protocol that allows an application to request byte based reporting. Reporting may be requested on a session or flow basis. Session based charge notification effectively causes the same charge notification criteria to be applied to all flows in the session. Registering for charge notification events causes the number of bytes of the specified type transferred in uplink and downlink directions to be metered.\n\na packet is the atomic unit counted and each packet either falls before the count is evaluated or after the count is evaluated. As a result, charge notification may not occur exactly on the byte count specified. For example, if notification was requested every 10K bytes, the notification may occur at 10.5 Kbytes if the packet that brought the count over 10K was slightly greater than 500 bytes. The actual counter values are provided in a message.\n\nthe API provides a protocol that allows an application to indicate a cost of the services provided and record a charge plan used in an MSSP detail record.\n\nthe API provides a protocol that allows an application to control when MSSP detail records are written.\n\nthe API provides a protocol that allows an application to obtain various statistics for a session or flow managed by the application.\n\nthe API provides a protocol that allows an application to monitor the status of other applications connected to the same MSSP instance.\n\nthe API provides a protocol that allows the redirection of packet flow on a per- flow basis.\n\nFIG. 1 is a block diagram of a network.\n\nFIG. 2 is a flow diagram of an interception process.\n\nFIG. 3 is a flow diagram of the service application startup stage of FIG. 2.\n\nFIG. 4 is a flow diagram of the service initialization stage of FIG. 2.\n\nFIG. 5 is a flow diagram of the service deployment stage of FIG. 2.\n\nFIG. 6 is a flow diagram of the service logic stage of FIG. 2.\n\nFIG. 7 is a flow diagram of the shutdown stage of FIG. 2.\n\nFIG. 8 is a table of data types used by the API of FIG. 1.\n\nFIG. 9 is a block diagram of a communication path.\n\nFIG. 10 is a block diagram of a TCP/IP byte stream divided into session messages by the transport layer.\n\nFIG. 11 shows a table listing sample error codes.\n\nFIG. 12 shows a table listing sample feature categories.\n\nthe network 10 may be a wireless network.\n\nthe wireless network may be, for example, a second generation wireless network, a Global System for Mobile Communications (GSM) network, or a General Packet Radio System (GPRS) enabled GSM.\n\nthe wireless network may be a Time Division Multiple Access (TDMA) network, a Code Division Multiple Access (CDMA) network, or a Universal Mobile Telecommunications System (UMTS) network.\n\nthe wireless network may be a TETRA network, a Tetrapol network, a DECT network, .an AMPS network, a wireless local area network (WLAN) or a third generation wireless network.\n\na GPRS enabled GSM network is described.\n\nthe network 10 includes a Mobile Station (MS) 12 connected to a Base Transceiver Station (BTS) 14.\n\nBTS Base Transceiver Station\n\nBSC Base Station Controller\n\nthe MS 12 is a station located within a mobile service intended to be used while in motion or during halts at unspecified points.\n\nAn example mobile station is a hand held cellular telephone.\n\nthe BTS 14 holds radio transceivers that define a cell and coordinates radio- link protocols with the MS 12.\n\nthe BTS 14 is a component of the network 10 from which all signals are sent and received.\n\nthe BTS 14, often called a cell phone tower, is linked to, and controlled by, a Base Station Controller (BSC) 16.\n\nBSC Base Station Controller\n\nthe BSC 16 is a component in the network 10 that manages radio resources for one or more base transceiver stations, such as BTS 14, for example.\n\nthe BSC 16 is linked to a SGSN 18.\n\nthe SGSN 18 is a General Packet Radio Service Support (GPRS) Node that serves GPRS mobile by sending or receiving packets via the BSC 16.\n\nthe SGSN 18 is linked to a Gateway GPRS Support Node (GGSN) 20.\n\nthe GGSN 20 acts as a gateway between a General Packet Radio Service (GPRS) network and a Packet Switched Public Data Network (PSPDN).\n\nGPRS General Packet Radio Service Support\n\nPSPDN Packet Switched Public Data Network\n\nthe GGSN 20 is linked to a Mobile Service Switching Platform (MSSP) server\n\nMSSP Mobile Service Switching Platform\n\nthe MSSP server 22 resides between the GGSN 20 and a globally networked group of computers, such as Internet 24.\n\nthe MSSP server 22 analyzes all of the\n\nIP Internet Protocol\n\na MSSP control process 26 provides the capability to set triggers or event notifications and increment counters based on IP flow characteristics.\n\nAn IP flow can be thought of as an abstraction representing a movement of data between two endpoints, such as MS\n\nthe MSSP control process 26 uses these capabilities to implement internal services and detail reporting.\n\nAPI 28 links the MSSP control process 26 to external applications 30.\n\nthe API 28 provides a mechanism for the external applications 30 to control the MSSP control process 26 to provide intelligent services.\n\nthe API 28, in various embodiments, may be implemented as, for example, a Corba based API, an XML based API, a PARLAY server, an OSA Server, or a JAIN server.\n\nthe MSSP server 22 functions as both an Internet router and an IP packet analyzer.\n\nData contained in a header field of an IP packet is defined in the Internet Engineering Task Force (IETF) RFC 791, incorporated herein by reference (see www.ietf.org).\n\nthe IETF is a large open international community of network designers, operators, vendors, and researchers concerned with the evolution of the Internet architecture and the smooth operation of the Internet.\n\nIP Internet Protocol\n\nIP provides for transmitting blocks of data called datagrams from sources to destinations, where sources and destinations are hosts identified by fixed length addresses.\n\nthe IP also provides for fragmentation and reassembly of long datagrams and, if necessary, for transmission through \"small packet\" networks.\n\nthe MSSP control process 26 is designed to analyze IP packet headers in real time to manage counters and signal when packet characteristics match specified conditions.\n\na signal may be an event report or a trigger.\n\nAn event report reports an occurrence of some event while continuing to monitor packet flow.\n\na trigger causes processing of the IP packet to be suspended until the MSSP control process 26 responds with specific instructions for resuming processing of the IP packet.\n\na trigger response may simply direct IP packet processing to be continued unchanged, or it may altar packet processing by specifying a different destination for the packet or cause the packet to be discarded altogether.\n\nthe API 28 provides, in one example, a way for the other applications 30 to communicate with the MSSP control process 26 and manipulate event reports and triggers.\n\nthe MSSP control process 26 manages many different types of IP packets.\n\nthe MSSP control process 26 is divided into different state machines (not shown), each state machine responsible for different types of packets.\n\na state machine is any device that stores the status of something at a given time and can operate on input to change the status and/or cause an action or output to take place for any given change.\n\nstate machines are used to develop and describe specific device or program interactions.\n\na detection point is a defined place in a state machine of a control entity where application event reporting and/or control are possible, and manageable through the API 28.\n\nAn Event Detection Point is a detection point armed within the context of an existing control dialog. Event detection points do not have explicit criteria; they are only applicable to a specific state machine instance of a control entity that generated the control dialog. In general, event detection points set within one control dialog do not affect a behavior of any other instance of that state machine. A complete set of detection points in a given state machine is known as a detection point class.\n\nTCP Transmission Control Protocol\n\nTCP provides a reliable, connection oriented communication path between two application processes (usually referred to as a client and a server).\n\nthe client initiates a connection and the server accepts the connection before any data can be exchanged.\n\nthe TCP protocol ensures that all of the data sent is received by the other side correctly and in the order that it was sent.\n\na client sends an IP packet to the server's IP address containing a TCP header with a \"SYN\" flag set and specifying a port number of the server application that it wishes to connect to.\n\nthe server accepts the connection by sending a similar SYN packet back to the client, and the client acknowledges the SYN from the server by sending an IP packet containing a TCP header with the \"ACK\" flag set.\n\nPackets pass through the MSSP control process 26 in the MSSP server 22 on their way between a client, e.g., MS 12, and a server (not shown) residing on the Internet 24.\n\nthe MSSP control process 26 determines that the IP packet encapsulates TCP data and assigns the packet to TCP control logic.\n\nthe TCP control logic can distinguish each segment of the connection establishment.\n\nthe service application 30 can instruct the MSSP control process 26 tlirough the API 28 to generate a trigger that watches for a TCP SYN packet that has a destination that matches the server to be intercepted. This is referred to as an Initial Detection Point (-DP).\n\nAn -DP is a detection point armed so as to generate a new control dialog with an application when conditions match given criteria.\n\nTCP SYN packets All other TCP packets, and TCP SYN packets directed to a different destination, continue to be processed normally.\n\na TCP SYN packet with a destination that matches the arming criteria causes processing of that packet to be suspended and an -DP event notification sent to the service application 30 that armed the -DP through the API 28.\n\nthe -DP event notification may include, for example, information from the suspended packet that the service application 30 may use to determine a correct destination for the connection.\n\nthe service application 30 then directs the MSSP control process 26 through the API 28 to resume packet processing with a different destination address.\n\nthe MSSP control process 26 forwards a modified TCP SYN packet to the new destination, where that server responds in a typical manner.\n\nthe service application's involvement is completely transparent, i.e., neither the client, e.g., MS 12, nor the server (not shown) on the Internet 24 is aware that any redirection has taken place.\n\nService applications 30 interact with the MSSP control process 26 by exchanging TCP/IP messages.\n\nthe API 28 listens for connections from service applications 30. When an application connection is made, the API 28 authenticates the identity of the connected service application 30 and looks up the features that the application is authorized to access.\n\nthe service application 30, once its communication session with the API 28 is established, requests a list of services that it is expected to provide from the MSSP control process 26 and then arms Initial Detection Points needed to implement those services. After that, the service application 30 waits for the MSSP control process 26 to signal when it has a packet that matches the arming criteria.\n\nthe service application 30 applies its service logic (not shown) through the API 28.\n\nThis service logic may, in addition to directing the packet to a chosen destination, configure additional metering for the packet flow that encountered the detection point, request additional event reports from this flow, indicate a charge plan that is applicable to the flow, request periodic charge notification events, or request flow statistics.\n\na default behavior of a service interaction between the MSSP control process 26 and the service logic of the application 30 may be specified without the need to implemenet a trigger detection point.\n\na source address, source port, destination address string within a data portion of a packet and protocol port are used to match incoming requests to determine if a predefined service interaction should be executed. If a flow matches the criteria, the actions specified in the remainder of the message are carried out. Example actions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.\n\nthe service logic begins execution when an -DP is detected. The service logic receives an event notification that the detection point was encountered.\n\nthe service logic responds when the MSSP request instruction within a timeout period.\n\nthe response may modify the packet then forward it, release the flow or session, or redirect or connect the packet using the connect request.\n\nOther requests may also be made to program policy filters to be applied to flow or session.\n\nthe service filter request may be used by the service logic to specify the service interaction to be carried out when the detection point is encountered.\n\nthe API 28 provides a connect request message that instructs the MSSP control process 26 to establish a connection to a specified destination address on a flow that is suspended at a trigger point.\n\nthe destination address may be different than the desitination address in the packet that matched the trigger condition. This allows the service logic in the service application 30 to, for example, route connections to a best available resource.\n\nthe API 28 provides a release flow message that instructs the MSSP control process 26 to terminate an active flow.\n\nthe MSSP control process 26 will terminate the flow and may provide any events or metering messages following confirmation of the termination.\n\nthe service application 30 manages and controls sponsored packet switched data services, which include any .and all unique network addresses that identify the packet switched data service, the policy decisions that determine how, and to which, packet switched data service provider the user is directed (e.g., a specific server on the Internet 24), and the policy decisions that determine which sponsor is to be billed for the session and on what basis.\n\nPolicy filters may be used to block IP traffic in either direction based on port, protocol, IP address, cookies, or other layer seven protocol characteristics.\n\nthe policy filters also allow the service logic to create and manage a wall garden or subscription based model.\n\nthe policy filters are dynamic in nature, allowing new services to be purchased dynamically and updated by the service logic.\n\nthe policy decisions for selection and billing may include rules that incorporate pre-agreements between an operator and third parties, either sponsors or service providers, as to the selection of the service provider and the method and basis of payment for the sponsor.\n\na policy decision of which service provider to make a connection to may be made at the time of the service request based upon such factors as a user identity, a location of the user, a time of day, a user class, a service provider class, network conditions, pre-agreement rules, and/or governmental regulations.\n\na policy decision of which sponsor to bill and on what basis can be made at time of the service request based upon similar factors such as the user identity, the location of the user, time of day, user class, service provider class, network conditions, pre-agreement rules, and/or governmental regulations.\n\na service interaction is defined by the service logic as having a beginning, middle, and end.\n\nthe beginning of service interaction is typically identified by an -DP\n\nthe service interaction is bounded by the sequence of events and API calls received and made by the service logic between the -DP and the terminal event.\n\na service interaction is usually billable event that causes the service logic to write a CDR following the end of the interaction.\n\nthe details of service interaction boundaries are determined by the service logic.\n\na stock quote service for example may begin when an -DP matching the request is reported, and end on the response containing the quote. This same example can be expanded to include, for example, file downloads and email delivery.\n\nthe MSSP provides the means to detect and control an interaction and the service logic is responsible for making the API calls and processing events to implement the service.\n\nan interception process 50 includes a service application startup stage 52, a service initialization stage 54, a service deployment stage 56, a service logic stage 58 and a shutdown stage 60.\n\nthe service application startup stage 52 includes initializing (70) a tr.ansport layer.\n\nthe transport layer is initialized (70) by creating a TCP/IP socket and connecting the socket through the API 28.\n\nthe stage 52 initializes (72) a session layer.\n\nthe initialization (72) includes sending a session open request to the MSSP server 22.\n\nthe MSSP server 22 authenticates the application's credentials.\n\na session open confirmation is received from the MSSP server 22.\n\nthe stage 52 initializes (74) an application layer.\n\nthe initialization (74) includes sending a negotiate API version request and receiving a negotiate API version confirmation. An open request is sent and confirmed.\n\nthe service initialization stage 54 includes sending (80) a get service list request; the MSSP server 22 looks up the services for this application.\n\nthe stage 54 receives (82) a get service list confirmation and sends (84) a get service detail request; the MSSP server 22 looks up configuration data for the service.\n\nthe stage 54 receives (86) a get service detail request confirmation.\n\nthe service deployment stage 56 includes sending (90) an Arm -DP request and receiving (92) an Arm -DP confirmation.\n\nthe MSSP server 22 verifies that the arming criteria meets any restrictions configured for the application and service and programs the ICP criteria into the MSSP server 22.\n\nthe service logic stage 58 includes receiving (100) an initial DP event.\n\nthe stage 58 determines (102) a new destination for the subscriber connection and sends (104) a connect request to the new destination.\n\nthe stage 58 receives (106) a connect confirmation.\n\nthe shutdown stage 60 includes sending (110) a disarm IDP request and receiving (112) a disarm -DP confirmation.\n\nthe stage 60 sends (114) a close request and receives (116) a close confirmation.\n\nthe stage 60 sends (118) a session close request, receives (120) a session close confirmation, and closes (122) the TCP/IP socket.\n\na table 130 shows a set of data types utilized to define fields within messages used by the API 28.\n\nthe table 130 includes a data type name 132, a definition 134, and a byte size 136.\n\nCHAR[n] refers to a UTF-8 character string.\n\nUTF-8 is a character encoding scheme in which the entire set of ASCII characters are encoded in one byte with the same encoding as ASCII while also allowing any of the full range of Unicode characters to be encoded using multiple-byte sequences in which no byte contains an ASCII character value.\n\nAll numeric data of more than one byte in length is transmitted in a canonical network byte order defined by TCP/IP standards, i.e., in order of most significant byte to least significant byte. It should be noted that to ensure application correctness and portability, application developers are encouraged to use their platform's host-to- network .and network-to-host conversion functions (such as htonl() and ntohl()) even when the host platform is known to use network byte order.\n\nhtonl() is an example UNIX function that converts 32-bit (4-byte) quantities from host byte order to network byte order\n\nntohl() is an example UNIX function that converts 32-bit quantities from network byte order to host byte order.\n\na communication path 140 (indicated by the arrows) between an application program 30 and the MSSP server 22 uses a layered architecture.\n\nthe application program 30 transmits data through its system's application layer 142, presentation layer 144, session layer 146, transport layer 148, TCP/IP layer 150 and lower layers 152, to corresponding lowers layers 154, TCP/IP layer 156, transport layer 158, session layer 160, presentation layer 162 and application layer 164 of the MSSP SERVER 22.\n\nthe tr.ansport layer 158 is used to provide a reliable transport to the session layer 160.\n\nthe transport layer 158 is relatively lightweight since it is layered on top of the local TCP/IP layer 156, which by definition is reliable.\n\nthe transport layer 158 receives messages from the session layer 160 that are then transmitted.\n\nthe transport layer 158 separates the byte stream provided by the TCP/IP layer 156 into messages that are framed by a transport header.\n\na frame is data that is transmitted between network points as a unit complete with addressing and necessary protocol control information.\n\na frame is usually transmitted serial bit by bit and contains a header field and a trailer field that \"frame\" the data.\n\na frame marker unlike some other protocols, does not itself determine a boundary of a transport message header.\n\nthe frame marker data pattern may also be present elsewhere in a TCP/IP byte stream with no adverse effects or special encoding.\n\nthe frame marker provides a means to detect common programming errors (such as improper byte ordering or length calculation errors) that might otherwise cause a receiver to incorrectly interpret some other data as a transport message header and take inappropriate action.\n\nthe API 28 uses an 8-byte transport message header as the first element in a message.\n\nthe 8-byte transport message header includes a 4-byte INIT \"framemarker\" field that is a constant value used to verify the presence of a valid transport message header. Any other value is indicative of a message framing error.\n\nthe 8-byte transport message header also includes a 4-byte \"messagelength\" field -and contains an UNIT data type representing the length, in bytes, of the message data that follows.\n\nthe API 28 utilizes session level interfaces built on top of the reliable TCP/TP transport layer that guarantees a message will arrive.\n\nThis session layer provides a set of session level services to the application layer. These services include authentication, session level heartbeats, and session level acknowledgements.\n\na heartbeat monitors the status of a communication link and identifies when the last of a string of messages is not received. When either end of a connection has not sent any data for a specified number of seconds, it will transmit a heartbeat message. When either end of the connection has not received any data for a specified number of seconds, it will tr.ansmit a test request message. If there is still no heartbeat message received after the same time then the connection is considered lost and corrective action initiated.\n\nAll messages exchanged at the session layer include a header of four USHORT 2-byte fields as the first element in the message.\n\nthe header is referred to as a session message header and includes a SessionMessage type field, a Sessionlnstance field, a SessionSendSeqNo field and a SessionReceiveSeqNo field.\n\nthe SessionMessage Type field contains a value that identifies the type of message and the format of the message data.\n\nthe Sessionlnstance field contains a value that uniquely identifies the session instance.\n\nthe SessionSendSeqNo field contains the send sequence number of the message.\n\nthe SessionReceiveSeqNo field contains the send sequence number from the last received message.\n\nAll session messages include a pair of sequence numbers in the Session Message Header that are set by the sender and verified by the receiver. Each sender starts at zero and increments the send sequence number for each message sent, hi addition, each sender keeps track of the next SessionSendSeqNo it expects to receive. Every message sent includes this number pair.\n\nthe sequence numbers are used to detect lost session messages as well as provide a means to acknowledge receipt of data.\n\nthe periodic exchange of sequence numbers in session heartbeat messages ensures that the sequence numbers remain up to date in the event that the session is idle with respect to SessData messages.\n\nthe session layer protocol version is negotiated during .an open sequence. A client specifies a desired version of the protocol to be used for the duration of the session.\n\nthe client initially specifies the highest version of the protocol supported by the client.\n\na server examines the requested version number and compares it against the versions it supports. If the requested version is in the range of versions supported by the server, the acceptance of the version is indicated in a subsequent SessOpenConf message. If the client has requested a version beyond those supported by the server, the server responds with a SessOpenConf message indicating that the session has been established using the highest version supported by the server. This version will be different from what was originally requested by the client, hi the event that the server cannot find a mutually supported protocol version a SessError message with an error code of MSSP_E_INNALID_NERSION is sent and the session is closed.\n\nsession layer options are negotiated during the open sequence.\n\nthe client specifies the desired protocol options to be used for the duration of the session.\n\nthe client should always initially specify all options supported by the client.\n\nthe server examines the requested options mask and chooses those options that it supports.\n\nthe resulting mutual session options are communicated to the client in the subsequent SessOpenConf message. If the client is unable to function as a result of the options being reduced by the server, a SessError message with an error code of MSSP_E_INVALID_OPTIONS is sent to the server and the session closed.\n\na heartbeat interval is negotiated during the open sequence.\n\nthe client specifies its desired heartbeat interval in the SessOpenReq message, and the server responds with the heartbeat interval that the client should use in the subsequent\n\nSessOpenConf message A client .and server exchange credentials during a session establishment sequence.\n\nthe client provides an encrypted Session Security Descriptor that is the MD5 message-digest of the SessOpenReq message (excluding the SessionSecurityDescriptor field) encrypted using a private key of a public/private key pair.\n\nthe MD5 message format is designed by RSA Data Security, Inc. and defined in IETF RFC 1321 (see www.ietf.org). Since a given application will likely open its session the same way every time, a random number field is provided in the message in order to prevent generating a \"constant\" message digest value and a resulting predictable Session Security Descriptor.\n\nthe MSSP server 22 configuration of the application contains the public key of the public/private key pair.\n\nthe server Upon receipt of the security descriptor in a SessOpenReq message, the server looks up the application in the MSSP server 22 configuration to obtain the client's public key, decrypt the given security descriptor using the public key, and verify that the decrypted result exactly matches the MD5 message-digest generated from the received message. If the credentials fail to validate, the server responds with a SessError message with an error code of MSSP_E_AUTH_FAILURE. If a number of successive failures occur in a unit amount of time, the server suspends listening for connection requests for a period of time not less than one minute.\n\nthe server provides a SessionSecurityDescriptor (that is the MD5 message-digest of the SessOpenConf message (excluding the SessionSecurityDescriptor field)) encrypted using the private key of a different public/private key pair) to the client in the SessOpenConf message.\n\nthe client decrypts the descriptor using the server's public key and authenticates the server. If the validation of the server credentials fail on the client side of the connection, the client sends a SessError message with an error code of MSSP_E_AUTH_FAILURE. If a number of successive failures occur in a unit amount of time, the client suspends connection requests for a period of time not less than one minute.\n\nthe SessOpenReq message is used to begin a session-level exchange of information between .an application and the API 28.\n\nthe SessOpenReq message is the first message that is after a transport layer connection has been established as described above.\n\nthe SessOpenReq message has the following format:\n\nAn 8-byte SessionHeader field that is a session header with a SessionMessage Type equal to Sess_Open_Req.\n\na 4-byte UNIT SessionNersion field that represents a session protocol version supported by the client.\n\na 4-byte UNIT SessionOptionsMask field that represents a bitwise combination of all the session layer options supported by the client.\n\na 4-byte UNIT SessionHeartbeathiterval field that represents the nominal interval between exchanges of session heartbeat messages in seconds.\n\na 4-byte UINT SessionApplicationlD field that represents a MSSP server 22 determined value uniquely identifying this client application in the MSSP server 22.\n\na 4-byte UNIT SessionRandonNum field represents any unpredictable value and is used to prevent predictable SessionSecurityDescriptor.\n\na 16-byte BYTE[16] SessionSecurityDescriptor field representing a session security descriptor that is a MD5 message-digest of the message (excluding this field) encrypted using the client's private key of a public/private key pair. The server decrypts the session security descriptor using its copy of the client's public key to authenticate the client.\n\nthe SessOpenConf message is used to complete an establishment of a session and communicate a result of negotiated parameters. This message is sent as the successful response to a SessOpenReq message and has the following format:\n\na 4-byte UINT SessionNersion field represents a session protocol version chosen for use by the server.\n\na 4-byte UNIT SessionOptionsMask field representing a bitwise combination of all of the client session layer options chosen by the server.\n\na 4-byte UNIT SessionHe-irtbeat-hterval field representing a nominal interval between exchanges of session heartbeat messages in seconds.\n\na 4-byte UNIT Sessions erverlD field represents a value uniquely identifying this MSSP SERVER 22 instance.\n\na 4-byte UNIT SessionRandonNum field represents any unpredictable value and is used to prevent predictable SessionSecurityDescriptor.\n\na 16-byte BYTE[16] SessionSecurityDescriptor field representing a session security descriptor that is the MD5 message-digest of the message (excluding this field) encrypted using the server's private key of a public/private key pair.\n\nthe client should decrypt the session security descriptor using its copy of the server's public key to authenticate the server.\n\na session requires that the client and server participate in a session maintenance procedure.\n\nthe session maintenance procedure ensures that inactive or idle sessions are functional as well as ensuring that the response time is within reasonable limits.\n\nthe session maintenance procedure is performed independent of whether or not other data is transmitted on the session.\n\nthe session maintenance procedure includes the exch-ange of a SessHeartbeatReq message, followed by a\n\nSessHeartbeatConf message The session maintenance procedure is initiated from the client side of a connection by sending a SessHeartbeatReq message.\n\nthe server performs a set of operations to ensure the server is functioning properly and returns a SessHeartbeatConf message if all is well. If the server fails to respond within the heartbeat interval the client fails the session by sending a SessError message with an error code of MSSP_E_HEARTBEAT_TIMEOUT to the server.\n\nthe client makes heartbeat requests at aperiodic interval as specified in the SessOpenConf message at the time the session was established. The first client heartbeat is sent upon receiving the SessOpenConf message.\n\na client timer Upon sending a SessHeartbeatReq message, a client timer is set to the heartbeat interval and a SessHeartbeatReq sent when the timer expires.\n\nthe server expects to see a heartbeat request within the specified heartbeat interval.\n\nthe server sets a timer following the transmission of the SessOpenConf message and the timeout will be set to twice the heartbeat interval. If the timer should expire and a heartbeat request is not received, the server fails the session by sending a SessError message with an error code of MSSP_E_HEARTBEAT_TIMEOUT. Each time a new heartbeat request is received, the server side timer is reset. At any given instant only one heartbeat request is outstanding. Note that the heartbeat messages will also be used to acknowledge DATA messages or detect errors related to mismanagement of sequence numbers on an idle session connection.\n\nthe SessHeartbeatReq message is used to request verification that the session partner is operating normally and has the following format:\n\nSessionMessageType SESSJHEARTBEATJREQ. A 4-byte UNIT\n\nSessionHeartbeatlnstance field representing a value that uniquely identifies a given heartbeat in the session.\n\na 4-byte TIME SessionTimeStamp field represents a time that the heartbeat request was issued.\n\na 4-byte UNIT SessionHeartbeatlnterval field representing a nominal interval between exchanges of session heartbeat messages, in seconds. This may be different than the current heartbeat interval when the sender desires to negotiate a new heartbeat interval.\n\nthe SessHeartbeatConf message is used to complete the verification of the session partner's normal operational status. This message is sent as the successful response to a SessHeartbeatReq message.\n\nthe SessHeartbeatConf message has the following format:\n\nAn 8-byte SessionHeader field represents a session header with SessionMessageType equal to SESS_HEARTBEAT_CONF.\n\na 4-byte UNIT SessionHeartbeatlnstance field represents the same SessionHeartbeatlnstance value that was given in the corresponding heartbeat request.\n\na 4-byte TIME SessionTimeStamp field represents the same SessionTimeStamp value that was given in the corresponding heartbeat request.\n\na 4-byte UNIT SessionHeartbeatlnterval field representing a nominal interval between exchanges of session heartbeat messages, in seconds. This may be different than the current heartbeat interval when a new heartbeat interval has been negotiated.\n\na session may be closed by either client or server at anytime following successful session establishment.\n\na client or server initiates the closure procedure by sending a SessCloseReq message to the session partner.\n\nthe SessCloseReq message contains a code indicating the reason for the closure.\n\nthe requesting session partner shutdowns (in the socket sense) the transport layer following the tr.ansmission of the\n\nSessCloseReq message The receiving session partner notifies the application layer to allow any outstanding requests on the session to be completed. Any queued session messages are sent prior to the transmission of the SessCloseConf message. Once the SessCloseConf message is sent, the transport connection shutdowns and the socket connection is closed from the side that requested the session be closed. A client may time-out a close request if a server fails to respond within a reasonable period of time. If a close request is timed-out by a client, a SessError message is sent to the server with an error code of MSSP_E_CLOSE_TIMEOUT.\n\na SessError message is sent to the requesting partner with an error code of MSSP_E_NO_SESSION. If a session is active or initialized and the session partner is unable to process a close request for any reason, the receiver sends a SessError message to the requestor with an error code of MSSP_E_UNSPECIFIED_FAILURE.\n\nthe SessCloseReq message is used to initiate the orderly termination of a session and has the following format:\n\nSessionMessageType SESS_CLOSE_REQ.\n\nSessionCloseReasonCode field represents a value indicating a reason for the closure of the session.\n\nMSSP reason codes include, for example, normal operation, partial detail during normal operation, normal shutdown, subscriber logout, flow timeout and session timeout.\n\nOne purpose of establishing a session is to exchange data between a client and a server. Data messages may be exchanged between parties following the completion of the session open sequence.\n\nthe session layer does not interpret data messages. Received data messages are forwarded to the application layer for processing. Only the bytes contained in the SessionData field of a SessData message are forwarded to the application layer. This effectively removes the session portion of the message prior to passing it to the application. Messages received from the transport layer are also devoid of any transport layer headers or data, and the messages are complete prior to processing. The converse is also true when transmitting data.\n\nthe session layer encapsulates the application data in a session data message that is forwarded to the transport layer for transmission.\n\na SessData message SessData is used to transmit application layer data to the session partner and has the following format:\n\nSessionData A variable length SessionData field representing data to be delivered to the application layer.\n\na session may fail from time to time due to communication or process failures. In the event of a session failure, the failure is reported asynchronously under the context of the session partner detecting the failure.\n\nEither the client or the server side may send a SessError message.\n\na SessError message may be sent at anytime from the client side following the SessOpenReq message.\n\na SessError message may be sent at anytime from the server side including as a response to a SessOpenReq.\n\na SessError message contains an error code indicating the reason for the failure.\n\nthe session partner may or may not receive the SessError message depending upon the nature of the error. Following the transmission or receipt of a SessError message, data may not be sent over the session and the underlying transport connection should be shutdown and closed.\n\nthe SessError message is used to inform a session partner of an error condition that will prevent further session level communication; it has the following format:\n\na 4-byte UNIT SessionErrorCode field represents a value indicating a cause of the session failure.\n\na table 170 containing sample error codes is shown.\n\nCapabilities of the MSSP server 22 maybe grouped into feature categories.\n\nthe applications 30 When applications 30 open their session with the MSSP server 22 the applications 30 specify what features they want through the API 28. Each MSSP feature has a corresponding privilege bit.\n\na configuration entry in a MSSP configuration database 32 residing in a MSSP storage device 34 for an application contains a set of feature privileges that control what features the application 30 is authorized to use. Only the requested features that are authorized for the application 30 are granted, and the application 30 is informed of the features that have successfully been obtained in the response to the request. Application attempts to use messages in a feature category that it has not been granted are refused with a privilege error. Referring to FIG. 12, a table 180 listing feature categories is shown.\n\nFeature categories include a common services feature category 182, an Initial Detection Point feature category 184, an Event Reporting feature category 186, a Service Filter feature category 188, a Meter Configuration feature category 190, a Charge Notification feature category 192, a Charge Plane feature category 194, a Detail Record Control feature, category 196. a Statistics feature category 198, and an Application Monitor feature category 200. Messages associated with each of the feature categories 182- 200, with their respective format, are listed in Appendix A, and incorporated herein by reference.\n\nMSSPNegotiateAPIVersionReq MSSPNegotiateAPIVersionConf\n\nMSSPOpenReq MSSPOpenConf\n\nMSSPCIoseReq MSSPCIoseConf\n\nMSSPFailureConf MSSPFailureEvent\n\nMSSPGetSystemTimeReq MSSPGetSystemTimeConf\n\nMSSPGetServiceListReq MSSPGetServiceListConf\n\nMSSPGetServiceDetailReq MSSPGetServiceDetailConf.\n\nThis message is sent by the application to the MSSP 22 to indicate the API version that it would like to use for application-level communication.\n\nthe API version must be negotiated before any other application messages can be exchanged since the message formats will vary. Only MSSPNegotiateAPIVersionReq, MSSPNegotiateAPIVersionConf, and MSSPFailureConf are guaranteed to have the same message format in all API versions. This is the first message that should be sent after a communication session has been established as described in the previous section.\n\nthe MSSP 22 replies with an MSSPNegotiateAPIVersionConf message specifying the negotiated API version to be used for all further application messages. This will be the highest API version supported by MSSP 22 that is less than or equal to the application requested version. Inability to identify an API version common to both parties results in an MSSPFailureConf message being returned from the MSSP 22 with an error code of MSSP_E_INVALID_VERSION.\n\nThis message is sent by the MSSP 22 to acknowledge receipt of an MSSPNegotiateAPIVersionReq request message and provide the API version that has been chosen for all further application layer messages.\n\nThis message is used to begin the application-level exchange of information between the application and the MSSP 22. This is the first message that should be sent after the API version has been established as described above. The application uses this message to request access one or more features of the MSSP 22.\n\nMessage Flow Diagram :\n\nMSSP 22 Feature Masks MSSPOpenConf\n\nThis message is sent by the MSSP 22 to acknowledge receipt of an MSSPOpenReq request message.\n\nthe message indicates which of the services that were requested in the MSSPOpenReq have actually been granted.\n\nThis message is used to terminate the application-level exchange of information between the application and the MSSP 22.\n\nMSSPFailureConf \"\" Message Format\n\nThis message is sent by the MSSP 22 to acknowledge receipt of an MSSPCIoseReq request message. No further application-level messages will be sent from the MSSP 22 or accepted from the application.\n\nThis message is sent by the MSSP 22 when an error condition prevents successful processing of a previous application request message.\n\nthe message contains the RequestID that was specified in the application's request message as well as an error code indicating the reason for the failure.\n\nThis message is sent by the MSSP 22 when an error condition occurs that is not directly associated with the processing of a previous application request message.\n\nthe message contains an error code indicating the reason for the failure.\n\nThis message is sent by the MSSP 22 in response to an MSSPGetSystemTimeReq request message.\n\nMSSPGetSystemTimeConf Message Format MSSPGetServiceListReq\n\nThis message is used to request the list of MSSP 22 service identifiers that the application has been configured to provide.\n\nThis message is sent by the MSSP 22 in response to an MSSPGetServiceListReq request message.\n\nThis message is used to request detailed information about the configuration of a specified MSSP 22 service.\n\nthe application may only request details for services that it is configured to provide.\n\nThis message is sent by the MSSP 22 in response to an MSSPGetServiceDetailReq request message.\n\nThis message is sent by the MSSP 22 when a service is removed from the list of services that the application is configured to provide while the application is connected to the MSSP 22. Any service resources (such as detection points) used by the application are automatically released by the MSSP 22.\n\nThis message is sent by the MSSP 22 when failure conditions or MSSP 22 hardware reconfiguration has caused a resource used by the application to become unavailable.\n\nAn MSSPResourceAvailableEvent message will be sent when the resource is restored to normal operation.\n\nThis message is sent by the MSSP 22 when a resource that was previously reported unavailable in an MSSPResourceUnavailableEvent has been restored to normal operation.\n\nMSSPInitialDPEvent MSSPContinueReq\n\nMSSPContinueConf MSSPConnectReq\n\nMSSPReleaseReq MSSPReleaseConf\n\nMSSPActivityTestReq MSSPActivityTestConf.\n\nThis request is used to identify an initial detection point and specify the traffic criteria that should cause an application to be notified.\n\nthe initial detection point may be armed for simple event notification or as a trigger, depending upon the setting of the TakeControl field. Setting the TakeControl field to MSSP_TRIGGER arms a trigger.\n\nMSSPContinueReq MSSPConnectReq\n\nMSSPControlReq MSSPControlReq\n\nMSSPReleaseReq MSSPReleaseReq\n\nthe criteria strings may contain wildcard values that may be used to specify a wide range of triggers.\n\nthe MSSP 22 sends an MSSPArmlDPConf message after the IDP is successfully armed. In the event that error conditions prevent arming the IDP an MSSPFailureConf message is returned instead indicating the reason for the failure.\n\nDetection points with \"IDPâ attributes may be armed as an initial detection point.\n\nDetection points with \"Triggerâ attributes may be armed as either a trigger or an event report. Detection points that are not listed with the \"Trigger\" attribute are only capable of providing event reports\n\nThis class of detection points allows an application to implement policy decisions when various subscriber group limits are exceeded.\n\nthe application provides the limiting values in the IDP arming criteria. If the IDP is armed as a trigger, the application may decide whether to allow the limit to be exceeded or not by sending Continue or Release trigger responses, respectively.\n\nThis class of detection points allows an application to monitor and control the establishment and termination of mobile subscriber sessions. If the IDP is armed as a trigger, the application may decide whether to allow the subscriber session to proceed or not by sending Continue or Release trigger responses, respectively.\n\na zero-length StringValue may be specified as a wild-card that matches any subscriber.\n\nThis class of detection points allows an application to monitor and control the Remote Authentication Dial In User Service (RADIUS) protocol activity of mobile subscriber sessions. If the -DP is armed as a trigger, the application may issue control operations to control subscriber acceptance and alter RADIUS message attributes.\n\nRADIUS Remote Authentication Dial In User Service\n\na zero-length StringValue may be specified as a wild- card that matches any subscriber.\n\nControl Operations The following control operations are defined:\n\nDHCP Detection Point Class This class of detection points allows an application to monitor and control the Dynamic Host Configuration Protocol (DHCP) activity of mobile subscriber sessions.\n\nDHCP Dynamic Host Configuration Protocol\n\nthe DestinationIP parameters in the Initial DP Event message from the DP_DHCP_ACK detection point contain the IP address being assigned to the subscriber.\n\nStringValue may be specified as a wild-card that matches any subscriber.\n\nThis class of detection points allows an application to monitor and control the Domain Name System (DNS) protocol activity of mobile subscriber sessions. Control operations are defined that allow an application to provide an IP address to resolve a mobile subscriber DNS query.\n\nDNS Domain Name System\n\nthe DestinationIP parameters in the Initial DP Event message from the DP_DNS_QUERY_RESPONSE detection point contain the IP address returned from the DNS server.\n\nStringValue may specify a partial wild-card of the form \"*. domain\", such as \"*.yahoo.comâ.\n\na zero-length StringValue may also be specified as a wild-card that matches any hostname.\n\nThis class of detection points allows an application to monitor and control the Transmission Control Protocol (TCP) activities of mobile subscriber sessions.\n\nTCP Transmission Control Protocol\n\nWild-card values may be specified for OperatorlD, SubscriberGroupID,\n\nSourcelPAddress and Destination I PAddress may be specified as a partial wild-card IP address by specifying the number of address bits that must match (from left-to-right).\n\na zero-length IPAddress may be specified as a wild-card that matches any IP address.\n\nIP Internet Protocol\n\nWild-card values may be specified for OperatorlD, SubscriberGroupID,\n\nSourcelPAddress and DestinationlPAddress may be specified as a partial wild-card IP address by specifying the number of address bits that must match (from left-to-right).\n\na zero-length IPAddress may be specified as a wild-card that matches any IP addressA zero-length\n\nStringValue may be specified as a wild-card that matches any subscriber.\n\nThis message is sent by the MSSP 22 to acknowledge successful arming of an Initial Detection Point by a previous MSSPArmlDPReq message.\n\nMSSPArmlDPConf Message Format MSSPDisarmlDPReq\n\nThis request is used to disarm an initial detection point, causing a previously established set of traffic criteria to be discarded.\n\nThis message is sent by the MSSP 22 to acknowledge successful disarming of an Initial Detection Point by a previous MSSPDisarmlDPReq message.\n\nthe initial detection point event is used to indicate that the conditions described by the criteria at a previously armed initial detection point have been met. Detection points are armed in order to get visibility or control of data flows matching a particular pattern.\n\nthe IDP Event Indication provides fully qualified data for all of the criteria relevant to that detection point whether or not wild cards were used in the arming criteria.\n\nInitial Detection Points that have been armed with the TakeControl option set are known as triggers.\n\nthe initial detection point event sent to the associated application to indicate that a trigger or an event detection point has been hit will indicate if the detection point is due to a trigger detection point by setting the TakeControl flag to MSSP TRIGGER in the event message.\n\nthe application must respond to a trigger detction event by sending one of the following requests:\n\nMSSPContinueReq MSSPConnectReq\n\nMSSPControlReq MSSPControlReq\n\nMSSPReleaseReq MSSPReleaseReq\n\nthe continue request will cause normal processing to resume on a packet that was previously suspended at a trigger point. This request might be used to provide an application synchronization point where the application can pace connection requests.\n\nthe packet to be continued and its associated context is identified by the ControllD field within the request message.\n\nan MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJ â VALID_CO â TROL_ID. If the ControllD is valid but not waiting at a trigger detection point, an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSPJ â JNVALID_STATE. If the continuation operation is successful an MSSPContinueConfwi ' U be sent to positively confirm that packet processing has been continued.\n\nThis message is sent by the MSSP 22 to acknowledge successful continuation of packet processing by a previous MSSPContinueReq message.\n\nthe connect request will instruct the MSSP 22 to establish a connection to the specified destination address on a packet that was previously suspended at a trigger point.\n\nthe destination address may be different than the destination address in the packet that matched the trigger condition. This will allow the application to route connections to the best available resource as well as supply a means for virtualization of Packet â OO services.\n\nthe suspended packet and its associated context is identified by the ControllD field within the request message, and the destination fields will provide IP address and port number on which the connection will be established.\n\nthe EventReportMask and TriggerMask can be used to request subsequent event reports and triggers from this instance of the detection point class.\n\nan MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJNVALID_CONTROL_ID. If the ControllD is valid but not waiting at a trigger detection point, an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_E_INVALID_STATE. If the connect operation is successful, an MSSPConnectConf Will be sent to positively confirm that packet processing has resumed.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPConnectReq message.\n\nThis message will be issued to perform control operations upon the suspended packet.\n\nthe suspended packet and its associated context is identified by the ControllD field within the request message. If the ControllD is not valid an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJNVALlD_CONTROLJD. If the ControllD is valid but not waiting at a trigger detection point, an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_E_INVALID_STATE.\n\nan MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_EJNVALID_CONTROL_pP.\n\nAn MSSPControlConf will be sent if the control operation is successful.\n\neach field is identified by a two-byte tag, followed by a two-byte length field that specifies the byte size of the following data, followed by the data.\n\nEach additional message field is simply appended to the message. The overall length of the message (provided by the underlying transport mechanism) can be used to determine the presence of these \"floating\" fields.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPControlReq message.\n\nThis message is issued to terminate an active flow.\n\nthe flow to be terminated may be suspended at a trigger or may be active.\n\nthe MSSP 22 will terminate the flow and provide any events or metering messages following the transmission of an MSSPReleaseConf message. The confirmation will be ordered prior to any events or metering messages resulting from the termination of the flow. If this message is being sent as the response to a trigger the suspended packet and its associated context is identified by the ControllD field within the request message. If the ControllD value in the message is zero then the (active) flow to be terminated is identified by the FlowlD field.\n\nthe ReasonCode field will contain a numeric value indicating the reason for terminating the flow.\n\nthe ReasonCode value will be stored in any detail records generated for the flow.\n\nAn MSSPReleaseConf message will be sent to positively confirm a release flow operation.\n\nAn MSSPFailureConf message with an error code of MSSP_E_INVALID_CONTROLJD will be returned in the event the ControllD field is invalid.\n\nAn MSSPFailureConf message with an error code of MSSP_EJNVALID_FL0W_1D will be returned in the event the FlowlD field is invalid.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPReleaseReq message.\n\nThis request may be used to check the status of a previously reported flow or session.\n\nAn MSSPActivityTestConf will be returned if the specified flow is still valid (active). If the flow identified by FlowlD is not valid an MSSPFailureConf message will be sent as a confirmation with a failure code of MSSP_E_INVALID_FLOWJD.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPActivityTestReq message.\n\nthe messages in this section allow an application to request additional event reports subsequent to an Initial Detection Point event.\n\nthe application When the IDP that initiates a control dialog is a trigger, the application typically requests additional event reports via the EventReportMask and/or TriggerMask fields in an MSSPContinueReq or MSSPConnectReq response to the IDP event.\n\nthe MSSPEventReportReq request is the only means of requesting additional event reports.\n\nMSSPEventReportReq MSSPEventReportConf\n\nMSSPEventReportEvent MSSPEventReportEvent\n\nThis message may be used to arm an event reporting detection point.\n\nthe detection point will be armed as an event detection point for the indicated flow only, and events will be sent for cases where the flow passes through a control state specified within any of the event report or trigger masks.\n\nthe MSSP 22 Upon receiving the event report request the MSSP 22 will arm the detection point(s) and send a confirmation indicating the success of the arming operation. In the event that a failure occurs while trying to arm the requested detection point(s) an MSSPFailureConf ' will be returned indicating the reason for the failure.\n\nThis request will result in MSSPEventReportEvent messages being sent to indicate that the flow has transitioned through the specified states.\n\nThis request differs from the MSSPArmlDPReq in the sense that it is used to change event reporting for a single, existing flow while the MSSPArmlDPReq request establishes the starting point where flows are first monitored.\n\nAn MSSPEventReportReq for a flow that already has event reporting detection points armed has the effect of superceding the previous request.\n\nAn MSSPEventReportReq with no EventReportMask or TriggerMask values set may be used to cancel all previously requested event reports and triggers for that control dialog.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPEventReportReq message.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPActivityTestReq message.\n\nthe messages in this section allow an application to specify programmed behavior at a detection point that does not require the involvement of the application.\n\nthe SourcelPAddress, SourcePort, DestinationlPAddress, and IPProtocolNumber fields will be used to match incoming requests to determine if the predefined service interaction should be executed.\n\nthe matching process is similar to the process used for initial detection points in general and wildcards may be used in the fields to be matched.\n\nActions that may be specified include the reporting of events as well as redirecting a request to a specified redirection address and port number.\n\nthe EventReportMask will be used to determine which events will be reported in the future for the flow if event reports are required. Criteria to be matched may not overlap with armed initial detection point criteria. If the request cannot be completed for any reason an MSSPFailureConf message will be returned with a matching RequestID and an error code indicating the nature of the failure. If the request completes successfully, an MSSPActivateServiceFilterConf is returned. Service Filtering will remain active until cancelled by an MSSPCancelServiceFilterReq request.\n\nMSSPActivateServiceFilterReq MSSPActivateServiceFilterConf\n\nMSSPCancelServiceFilterReq MSSPCancelServiceFiiterConf.\n\nThis request is used to I dentify an initial detection point and specify the traffic criteria that should cause a pre-determined behavior to be applied.\n\nthe MSSP 22 sends an MSSPActivateServiceFilterConf message after the IDP is successfully armed with the Service Filter. In the event that error conditions prevent arming the IDP an MSSPFailureConf message is returned instead indicating the reason for the failure.\n\nThis message is sent by the MSSP 22 to acknowledge successful arming of a Service Filter Initial Detection Point by a previous MSSPActivateServiceFilterReq message.\n\nThis request is used to cancel a service filter previously established by an MSSPActivateServiceFilterReq request.\n\nThis message is sent by the MSSP 22 to acknowledge successful cancellation of a Service Filter by a previous MSSPCancelServiceFilterReq message.\n\nthe messages in this section allow an application to configure the data elements that will be metered by the MSSP 22.\n\nthe meter configuration affects the meter elements that are populated in the MSSPGetStatsConf and MSSPPeriodicStatsEvent messages as well as detail records stored in the MSSP 22 database.\n\nMSSPConfigureMetersReq MSSPConfigureMetersConf.\n\nThis message is used to configure the metering performed by the MSSP 22 at the lowest level.\n\nthe MeterClass field will contain one of two values,\n\nthe class field will be used to indicate the scope of the metering request.\n\nthe ObjectlD field will identify instance of the object to be metered based on the MeterClass. For instance, if the MeterClass is MSSP_METER_CLASS_SESSION the ObjectlD will represent the session identifier, and if the MeteringType is MSSP_METER_CLASS_FLOW the ObjectlD will represent the flow identifier.\n\nthe MetersEnabled field will contain a bit mask identifying the particular meters to be enabled within the class specified by the MeterClass field.\n\nthe MetersEnabled field specifies the new meter configuration for the object.\n\na zero value in the mask position of a previously configured meter causes that meter to be disabled, and a nonzero value in the mask position of a previously unconfigured meter causes that meter to be enabled.\n\nthe meter configuration affects the meter elements that are populated in the MSSPGetStatsConf and MSSPPeriodicStatsEvent messages as well as detail records stored in the MSSP 22 database.\n\nthe MSSP 22 will process the request and return an MSSPConfigureMetersConf message as a positive acknowledgement if the request is successful. An unsuccessful request will cause an MSSPFailureConf message to be sent as a negative acknowledgement.\n\nthe failure code value will contain one of the following values depending on the request parameter that failed validation:\n\nMSSP_E_INVALID_METER_CLASS MSSP_EJNVAL)D_FLOWJD\n\nMSSP_EJNVALID_SESSION_ID MSSP E INVALID FLOW METER MASK.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPConfigureMetersReq message.\n\nSession based charge notification effectively causes the same charge notification criteria to be applied to all flows in the session.\n\nRegistering for charge notification events will cause the number of bytes of the specified type transferred in uplink and downlink directions to be metered.\n\nan MSSPNotifyChargeEvent message is sent from the MSSP 22 to the application indicating the number of bytes that have been transferred, and the counters are reset and begin counting towards the threshold again. Charge notification continues until the flow terminates or charge notification is explicitly cancelled by an MSSPCancelNotifyChargeReq request.\n\na packet is the atomic unit counted and each packet will either fall before the count is evaluated or after the count is evaluated. As a result, charge notification may not occur exactly on the byte count specified. For example, if notification was requested every 10K bytes, the notification may occur at 10.5 Kbytes if the packet that brought the count over 10K was slightly greater than 500 bytes.\n\nthe actual counter values are provided in the MSSPNotifyChargeEvent message.\n\nMSSPNotifyChargeReq MSSPNotifyChargeConf\n\nMSSPCancelNotifyChargeReq MSSPCancelNotifyChargeConf\n\nMSSPCancelNotifyChargeConf MSSPNotifyChargeEvent.\n\nThis request is used to register byte based reporting on either a session-wide or per-flow basis.\n\nAn MSSPNotifyChargeConf message will be sent to indicate that charge notification has successfully been enabled. If charge notification cannot be enabled an STL__FAILURE_CONF message will be sent to indicate failure and the error code field will identify the reason for the failure.\n\nMSSPNotifyChargeReq Message Format MSSPNotifyChargeConf\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPNotifyChargeReq message.\n\nThis request is used to cancel byte based reporting established by a previous MSSPNotifyChargeReq request.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPCancelNotifyChargeReq message.\n\nThis message is used to notify the application that a previously registered charge notification threshold has been exceeded.\n\nMSSPSetChargePlanReq MSSPSetChargePlanConf.\n\nThis message is used to record the charge plan used for a service in the MSSP 22 detail record.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPSetChargePlanReq message.\n\nMSSPWriteDetailRecordReq MSSPWriteDetailRecordConf.\n\nThis message allows an application to control when detail records are written to the MSSP 22 database. Detail records that are written by this request automatically have a ReasonCode of MSSP_RC_PARTIAL_DETAIL assigned. Partial detail records are commonly used to guarantee that, in the event of an unrecoverable error, all but the most recent activities of a subscriber interaction are captured for billing purposes.\n\nThis message is sent by the MSSP 22 to acknowledge successful execution of a previous MSSPWriteDetailRecordReq message.\n\nMSSPGetStatsReq MSSPGetStatsConf\n\nMSSPPeriodicStatsEvent MSSPGetStatsReq\n\nThis request is used to request session or flow statistics.\n\nthe request may optionally request future updates, either periodically or upon flow or session termination.\n\nStatistical values depend upon the meters configured by previous MSSPConfigureMetersReq requests.\n\nthe MSSP 22 will process the request and return an MSSPGetStatsConf message with the current statistical values as a positive acknowledgement if the request is successful.\n\nMSSPPenodicStatsEvent messages will be sent if future updates were requested via the Interval field.\n\nAn unsuccessful request will cause an MSSPFailureConf message to be sent as a negative acknowledgement.\n\nthe failure code value will contain one of the following values depending on the request parameter that failed validation:\n\nThis request is used to return the session or flow statistics requested by a previous MSSPGetStatsReq request. Statistical values depend upon the meters configured by previous MSSPConfigureMetersReq requests.\n\nFields marked with * contain valid data only when the corresponding meter is configured in the MSSP 22 (as indicated in the EnabledMeterMaskf â e â ).\n\nThis request is used to return the periodic updates of session or flow statistics that were requested by a previous MSSPGetStatsReq request. Statistical values depend upon the meters configured by previous MSSPConfigureMetersReq requests.\n\nFields marked with * contain valid data only when the corresponding meter is configured in the MSSP 22 (as indicated in the\n\nThis message is sent by the MSSP 22 to report the occurrence of an application session event. This message is also sent by the MSSP 22 to an application with ApplicationMonitor privileges immediately after its session is opened, informing it of other (preexisting) application sessions.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nSignal Processing (AREA)\n\nComputer Networks & Wireless Communication (AREA)\n\nComputer Security & Cryptography (AREA)\n\nData Exchanges In Wide-Area Networks (AREA)\n\nExchange Systems With Centralized Control (AREA)\n\nEP03745136A 2002-03-18 2003-03-18 APPLICATION PROGRAM POINT Withdrawn EP1491029A4 (en)\n\nApplications Claiming Priority (3)\n\nApplication Number Priority Date Filing Date Title US100468 2002-03-18 US10/100,468 US20030177283A1 (en) 2002-03-18 2002-03-18 Application program interface PCT/US2003/008401 WO2003081885A1 (en) 2002-03-18 2003-03-18 Application program interface\n\nPublications (2)\n\nPublication Number Publication Date EP1491029A1 EP1491029A1 (en) 2004-12-29 EP1491029A4 true EP1491029A4 (en) 2006-05-10\n\nFamily\n\nID=28039830\n\nFamily Applications (1)\n\nApplication Number Title Priority Date Filing Date EP03745136A Withdrawn EP1491029A4 (en) 2002-03-18 2003-03-18 APPLICATION PROGRAM POINT\n\nCountry Status (7)\n\nCountry Link US (1) US20030177283A1 (ja) EP (1) EP1491029A4 (ja) JP (1) JP2005521337A (ja) KR (1) KR20040108673A (ja) CN (1) CN1653790A (ja) AU (1) AU2003225863A1 (ja) WO (1) WO2003081885A1 (ja)\n\nFamilies Citing this family (25)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title JP4365148B2 (ja) * 2002-07-19 2009-11-18 æ ªå¼ä¼ç¤¾ãªã³ã¼ ç»åå½¢æè£ ç½®åã³ã©ããã³ã°å¦çæ¹æ³ä¸¦ã³ã«ãã­ã°ã©ã JP4795247B2 (ja) * 2003-11-26 2011-10-19 ã¨ã¬ã¯ãã­ãã¯ã¹ ã¢ã³ã ãã¬ã³ãã¥ãã±ã¼ã·ã§ã³ãº ãªãµã¼ã ã¤ã³ã¹ããã¥ã¼ã ãã¸ã¿ã«ã¢ã¤ãã ã®ä½¿ç¨ã«å¿ããã¤ãã³ãå ±åã®ããã®ãã¼ã¿æ§é ãä¸¦ã³ã«ãããå©ç¨ããã¤ãã³ãå ±åã·ã¹ãã åã³ãã®æ¹æ³ US20050249190A1 (en) * 2004-05-06 2005-11-10 Oliver Birch Using a CCXML service node to provide call processing functionality for a parlay gateway US7437169B2 (en) * 2004-06-07 2008-10-14 Microsoft Corporation System and method for optimizing network communication in response to network conditions KR100560752B1 (ko) * 2004-07-21 2006-03-13 ì¼ì±ì ìì£¼ìíì¬ ìì¼ ì°ê²° ê´ë¦¬ ìì¤í  ë° ê·¸ ìì¼ ì°ê²° ìí ì²´í¬ ë°©ë² US7743152B2 (en) * 2005-10-31 2010-06-22 Qualcomm Incorporated Method and apparatus for detecting the presence of a terminal in a data session US8484326B2 (en) * 2006-09-28 2013-07-09 Rockstar Bidco Lp Application server billing US20080130660A1 (en) * 2006-10-19 2008-06-05 Jordi Ros-Giralt System and method of real-time control and scheduling for zero-queue distributed systems US8156219B2 (en) * 2007-08-03 2012-04-10 At&T Intellectual Property I, L.P. System and method of health monitoring and fault monitoring in a network system US20090183194A1 (en) * 2008-01-10 2009-07-16 Michael Raftelis Methods and apparatus to handle telecommunication service changes US8842632B2 (en) * 2008-02-14 2014-09-23 Alcatel Lucent Pre-registration, storing of pre-registration session information and session transfer in a wireless communication system US20090234955A1 (en) * 2008-03-13 2009-09-17 Mark Gregory Hanley Methods and Systems for Synchronization of Multiple Applications AU2009231676B2 (en) 2008-04-02 2013-10-03 Twilio Inc. System and method for processing telephony sessions US8837465B2 (en) 2008-04-02 2014-09-16 Twilio, Inc. System and method for processing telephony sessions CN101674327B (zh) * 2009-09-29 2012-12-26 éè¶è½¯ä»¶ï¼ä¸­å½ï¼æéå ¬å¸ å¼æç³»ç»æ¶æ¯éææ¹æ³ãæ¶æåç³»ç» CN102571880B (zh) * 2010-12-27 2014-11-05 ä¸­å½ç§»å¨éä¿¡éå¢å ¬å¸ ä¸ç§æå¡ååæ¹æ³åç³»ç»ä»¥åä¸ç§æå¡ååèç¹ CN103297480B (zh) * 2012-03-05 2017-09-22 è´¢ä»éæ¯ä»ç§ææéå ¬å¸ ä¸ç§åºç¨æå¡èªå¨æ£æµç³»ç»åæ¹æ³ JP2013207495A (ja) * 2012-03-28 2013-10-07 Kddi Corp åç·ç£è¦æ¹æ³ããã³æ¹å¼ US8832321B1 (en) * 2014-02-12 2014-09-09 tw telecom holdings, inc. External injection of cloud based network functions into network services US9118582B1 (en) * 2014-12-10 2015-08-25 Iboss, Inc. Network traffic management using port number redirection CN104519134B (zh) * 2014-12-25 2018-06-19 æ¼³å·é¡¶ç«¹éè®¯ææ¯æéå ¬å¸ ä¸ç§è·¨å¹³å°æä»¶è¯»åç³»ç»åæ¹æ³ US9832627B2 (en) * 2015-04-29 2017-11-28 Tata Consultancy Services Limited Method and system to include TETRA SS-LE member in public safety (PS) long term evolution group call service JP2017084322A (ja) * 2015-10-26 2017-05-18 æ ªå¼ä¼ç¤¾ãªã³ã¼ æ å ±ã·ã¹ãã ããã­ã°ã©ã åã³è¨é²åªä½ CN107273144A (zh) * 2017-08-15 2017-10-20 å¹¿å·å¸ç±è©æ°å»è¯ç§ææéå ¬å¸ å¿«éæå»ºç½ç»åºç¨ç¨åºæ¥å£çè£ ç½® CN107682314A (zh) * 2017-08-30 2018-02-09 åäº¬ææä¸è¾¾ç§æè¡ä»½æéå ¬å¸ ä¸ç§aptæ»å»çæ£æµæ¹æ³åè£ ç½®\n\nCitations (1)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title WO2002012976A2 (en) * 2000-08-08 2002-02-14 Phonedo Networks Israel Ltd. Interface for intelligent network services\n\nFamily Cites Families (36)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title KR970701986A (ko) * 1994-02-28 1997-04-12 ìë¦¬ì¹´ ë¦°ëë ì´ ê·¸ëí ëí¤ íµì ë¤í¸ìí¬ì ëí ìë¹ì¤ë¥¼ êµ¬ì±íë ìë¹ì¤ ì¸ë ìì¤í (service provision in communications networks) US6181703B1 (en) * 1995-09-08 2001-01-30 Sprint Communications Company L. P. System for managing telecommunications US5742905A (en) * 1994-09-19 1998-04-21 Bell Communications Research, Inc. Personal communications internetworking US5546452A (en) * 1995-03-02 1996-08-13 Geotel Communications Corp. Communications system using a central controller to control at least one network and agent system US5940487A (en) * 1996-04-10 1999-08-17 Alcatel Usa Sourcing, L.P. Programmable call processing system and method US6236365B1 (en) * 1996-09-09 2001-05-22 Tracbeam, Llc Location of a mobile station using a plurality of commercial wireless infrastructures ES2275786T3 (es) * 1997-02-14 2007-06-16 Denso Corporation Bobina de encendido tipo varilla, con estructura mejorada contra fisuras o descargas dielectricas. FI103540B1 (fi) * 1997-04-28 1999-07-15 Nokia Mobile Phones Ltd MenetelmÃ¤ pakettikytkentÃ¤isen datan siirtoon matkapuhelinjÃ¤rjestelmÃ¤ssÃ¤ US6122263A (en) * 1997-06-10 2000-09-19 Telefonaktiebolaget Lm Ericsson Internet access for cellular networks US6199068B1 (en) * 1997-09-11 2001-03-06 Abb Power T&D Company Inc. Mapping interface for a distributed server to translate between dissimilar file formats JPH11111543A (ja) * 1997-10-07 1999-04-23 Mitsubishi Electric Corp å çæ©é¢ç¨ç¹ç«ã³ã¤ã«è£ ç½® US6122510A (en) * 1997-11-04 2000-09-19 Telefonaktiebolaget Lm Ericsson Method and apparatus for providing network-specific mobile services US6263437B1 (en) * 1998-02-19 2001-07-17 Openware Systems Inc Method and apparatus for conducting crypto-ignition processes between thin client devices and server devices over data networks FI106515B (fi) * 1998-03-17 2001-02-15 Nokia Networks Oy Ãlyverkkopalvelun konfigurointi US6324547B1 (en) * 1998-04-02 2001-11-27 Lucent Technologies Inc. Method for creating and modifing similar and dissimilar databases for use in intelligent network configurations for telecommunication systems JP2978878B1 (ja) * 1998-05-18 1999-11-15 æ¥æ¬é»æ°éä¿¡ã·ã¹ãã æ ªå¼ä¼ç¤¾ ãã¼ã ä½ç½®ã¬ã¸ã¹ã¿ã®å¶å¾¡è£ ç½®ãæ¹æ³åã³ãã­ã°ã©ã ãè¨é²ããè¨é²åªä½ US6157955A (en) * 1998-06-15 2000-12-05 Intel Corporation Packet processing system including a policy engine having a classification unit US6230005B1 (en) * 1998-10-01 2001-05-08 Nokia Telecommunications, Oy Method and apparatus for providing overlay to support third generation cellular services US6614781B1 (en) * 1998-11-20 2003-09-02 Level 3 Communications, Inc. Voice over data telecommunications network architecture KR100379459B1 (ko) * 1999-02-12 2003-04-10 ìì§ì ì ì£¼ìíì¬ ì´ë íµì ìì¤í ìì í¨í· ë°ì´í° ìë¹ì¤ ì ê³µ ìì¤í  ë° ì´ë¥¼ ì´ì©í ì´ì© ë°©ë² GB2350749A (en) * 1999-06-01 2000-12-06 Motorola Ltd Transferring configuration data to a software defined radio apparatus US6625141B1 (en) * 1999-06-18 2003-09-23 Telefonaktiebolaget L M Ericsson (Publ) System and method for providing value-added services (VAS) in an integrated telecommunications network using session initiation protocol (SIP) US6529948B1 (en) * 1999-08-31 2003-03-04 Accenture Llp Multi-object fetch component US6560327B1 (en) * 1999-10-01 2003-05-06 Sprint Spectrum, L.P. Method and system for providing telecommunications services using mediated service logic JP4318273B2 (ja) * 1999-12-24 2009-08-19 æ ªå¼ä¼ç¤¾ãã³ã½ã¼ ç¹ç«ã³ã¤ã« CN1382347A (zh) * 2000-09-01 2002-11-27 è¯ºåºäºå ¬å¸ æå¡èæ¬æ§è¡åç®¡ççç½ç»ä½ç³»ç»æåæ¹æ³ US6888937B1 (en) * 2000-09-06 2005-05-03 Cisco Technology, Inc. Managing processes of a network component FI20002449A0 (fi) * 2000-11-08 2000-11-08 Nokia Networks Oy Tapahtumien virittÃ¤minen GB0100309D0 (en) * 2001-01-05 2001-02-14 Nokia Networks Oy Provision of services in a communications system US20020131395A1 (en) * 2001-03-19 2002-09-19 Chenghui Wang Session initiation protocol (SIP) user agent in a serving GPRS support node (SGSN) WO2002091692A1 (en) * 2001-04-13 2002-11-14 Girard Gregory D Ditributed edge switching system for voice-over-packet multiservice network US7483411B2 (en) * 2001-06-04 2009-01-27 Nec Corporation Apparatus for public access mobility LAN and method of operation thereof US6891842B2 (en) * 2001-09-21 2005-05-10 Nokia Corporation System and method for enabling mobile edge services JP3979166B2 (ja) * 2001-10-18 2007-09-19 æ ªå¼ä¼ç¤¾ãã³ã½ã¼ ç¹ç«ã³ã¤ã« US20030095566A1 (en) * 2001-11-20 2003-05-22 Bunting Roger L. Providing a camel based service to a subscriber terminal in a win network and vice versa DE602004025952D1 (de) * 2003-08-13 2010-04-22 Roamware Inc Signalisierungs-Gateway mit einem Mehrfach-Imsi-Mit-Mehrfach-MSISDN (MIMM) Dienst in einem einzigen SIM fÃ¼r mehrere Roaming-Partner\n\n2002\n\n2002-03-18 US US10/100,468 patent/US20030177283A1/en not_active Abandoned\n\n2003\n\n2003-03-18 EP EP03745136A patent/EP1491029A4/en not_active Withdrawn\n\n2003-03-18 WO PCT/US2003/008401 patent/WO2003081885A1/en active Application Filing\n\n2003-03-18 AU AU2003225863A patent/AU2003225863A1/en not_active Abandoned\n\n2003-03-18 CN CNA03811223XA patent/CN1653790A/zh active Pending\n\n2003-03-18 KR KR10-2004-7014751A patent/KR20040108673A/ko not_active Application Discontinuation\n\n2003-03-18 JP JP2003579453A patent/JP2005521337A/ja active Pending\n\nPatent Citations (1)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title WO2002012976A2 (en) * 2000-08-08 2002-02-14 Phonedo Networks Israel Ltd. Interface for intelligent network services\n\nAlso Published As\n\nPublication number Publication date AU2003225863A1 (en) 2003-10-08 WO2003081885A9 (en) 2003-11-27 JP2005521337A (ja) 2005-07-14 US20030177283A1 (en) 2003-09-18 WO2003081885A1 (en) 2003-10-02 CN1653790A (zh) 2005-08-10 KR20040108673A (ko) 2004-12-24 EP1491029A1 (en) 2004-12-29\n\nSimilar Documents\n\nPublication Publication Date Title WO2003081885A1 (en) 2003-10-02 Application program interface US7586871B2 (en) 2009-09-08 Platform and method for providing data services in a communication network US8607320B2 (en) 2013-12-10 Systems, methods and computer-readable media for regulating remote access to a data network US20020176377A1 (en) 2002-11-28 Service platform on wireless network US6822954B2 (en) 2004-11-23 Telecommunications gateway EP1064757B1 (en) 2009-01-14 Remote computer communication US9998460B2 (en) 2018-06-12 Diameter redirect between client and server EP1054529A2 (en) 2000-11-22 Method and apparatus for associating network usage with particular users US7136635B1 (en) 2006-11-14 Proxy SIP server interface for session initiation communications WO2003049348A2 (en) 2003-06-12 Mechanisms for policy based umts qos and ip qos management in mobile ip networks CA2430119A1 (en) 2002-06-06 External processor for a distributed network access system WO2003105416A1 (en) 2003-12-18 Method and apparatus for implementing qos in data transmissions MXPA03004671A (es) 2004-10-14 Dispositivo de acceso programable para un sistema de acceso a red distribuida. Martsola et al. 2005 Machine to machine communication in cellular networks Cisco 1997-12-21 Managing the System Cisco 1997-05-27 Managing the System Cisco 1997-05-27 Managing the System US20160301626A1 (en) 2016-10-13 Tunnel consolidation for real-time communications JP4463838B2 (ja) 2010-05-19 ãããã¯ã¼ã¯ã«ããããµã¼ãã¹æ©å¨è¦ç´ ãè¨­å®ããæ¹æ³åã³è£ ç½® KR101074056B1 (ko) 2011-10-17 ë³í ê²ì´í¸ì¨ì´ë¥¼ í¬í¨íë ì ë¬´ì ì¸í°ë· ìë¹ì¤ íµí©ì¸ì¦ ìì¤í  ë° ë°©ë² Agah 0 Active Networks in Mobile Computing Environment\n\nLegal Events\n\nDate Code Title Description"
    }
}