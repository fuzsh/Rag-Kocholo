{
    "id": "dbpedia_4201_1",
    "rank": 83,
    "data": {
        "url": "https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses",
        "read_more_link": "",
        "language": "en",
        "title": "Spring RestTemplate - how to enable full debugging/logging of requests/responses?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/AMkY5.jpg?s=64",
            "https://i.sstatic.net/7FzQK.jpg?s=64",
            "https://www.gravatar.com/avatar/e990c7cdac81e570939c4d5b17303b42?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/cd7d5ad7f0cd49262fcb6136f8db7760?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/2zXYT.png?s=64",
            "https://i.sstatic.net/CJL0b.png?s=64",
            "https://i.sstatic.net/upGrB.png?s=64",
            "https://www.gravatar.com/avatar/976dc9df3ea3d05a18e90f0cd9c29b7a?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/TUFNg.jpg?s=64",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/AMkY5.jpg?s=64",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/deb4446b33506242c883e644d33c5bb5?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5c999a83e9a479fea7efaf65feb1e6fc?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/3tgaf.jpg?s=64",
            "https://i.sstatic.net/qSnDm.jpg?s=64",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Ykmgs.jpg?s=64",
            "https://www.gravatar.com/avatar/b867b7871c56b1308ee19a2a08b45563?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/xDFWm.png?s=64",
            "https://www.gravatar.com/avatar/d2f7f1f027cec71204b51b5336dac6fe?s=64&d=identicon&r=PG",
            "https://lh6.googleusercontent.com/-JdgXKLLbaoQ/AAAAAAAAAAI/AAAAAAAAKcA/rrk0JyvYX-0/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/fbc2d1301aa451d97c0515bdd8b368ef?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7351ccfd05b43437c617f81934d47433?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/61631f8c2dec374fd3fd30a3cb7b50ce?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7303f11c48b9c62a68e2f55ca56ed6f7?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/pX1Vz.jpg?s=64",
            "https://www.gravatar.com/avatar/823f81aff17aad91616b98bcb3beeb75?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/0980dbc563c1c4421e046bca59a475ec?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/42b855d5bc3f528308d96a7cd465e034?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2180fdd5cb07bfe0aa58f171c299c38e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e88b33b9be8342951b5da383f3c8e5d7?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e61ba3f93dea724865872ced666abca6?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/I37dk.jpg?s=64",
            "https://i.sstatic.net/3HqGO.jpg?s=64",
            "https://lh3.googleusercontent.com/-XdUIqdMkCWA/AAAAAAAAAAI/AAAAAAAAAAA/4252rscbv5M/photo.jpg?sz=64",
            "https://www.gravatar.com/avatar/ac5181769f5e6614e3bfc6b56b72a613?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://stackoverflow.com/posts/7952154/ivc/a19f?prg=161880af-fe70-4d23-8964-7a2378c4ff7c",
            "https://stackoverflow.com/js-false.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2011-10-31T09:58:48",
        "summary": "",
        "meta_description": "I have been using the Spring RestTemplate for a while and I consistently hit a wall when I'am trying to debug it's requests and responses. I'm basically looking to see the same things as I see when...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/7952154/spring-resttemplate-how-to-enable-full-debugging-logging-of-requests-responses",
        "text": "Just to complete the example with a full implementation of ClientHttpRequestInterceptor to trace request and response:\n\nimport java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.HttpRequest; import org.springframework.http.client.ClientHttpRequestExecution; import org.springframework.http.client.ClientHttpRequestInterceptor; import org.springframework.http.client.ClientHttpResponse; public class LoggingRequestInterceptor implements ClientHttpRequestInterceptor { final static Logger log = LoggerFactory.getLogger(LoggingRequestInterceptor.class); @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { traceRequest(request, body); ClientHttpResponse response = execution.execute(request, body); traceResponse(response); return response; } private void traceRequest(HttpRequest request, byte[] body) throws IOException { log.info(\"===========================request begin================================================\"); log.debug(\"URI : {}\", request.getURI()); log.debug(\"Method : {}\", request.getMethod()); log.debug(\"Headers : {}\", request.getHeaders() ); log.debug(\"Request body: {}\", new String(body, \"UTF-8\")); log.info(\"==========================request end================================================\"); } private void traceResponse(ClientHttpResponse response) throws IOException { StringBuilder inputStringBuilder = new StringBuilder(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(response.getBody(), \"UTF-8\")); String line = bufferedReader.readLine(); while (line != null) { inputStringBuilder.append(line); inputStringBuilder.append('\\n'); line = bufferedReader.readLine(); } log.info(\"============================response begin==========================================\"); log.debug(\"Status code : {}\", response.getStatusCode()); log.debug(\"Status text : {}\", response.getStatusText()); log.debug(\"Headers : {}\", response.getHeaders()); log.debug(\"Response body: {}\", inputStringBuilder.toString()); log.info(\"=======================response end=================================================\"); } }\n\nThen instantiate RestTemplate using a BufferingClientHttpRequestFactory and the LoggingRequestInterceptor:\n\nRestTemplate restTemplate = new RestTemplate(new BufferingClientHttpRequestFactory(new SimpleClientHttpRequestFactory())); List<ClientHttpRequestInterceptor> interceptors = new ArrayList<>(); interceptors.add(new LoggingRequestInterceptor()); restTemplate.setInterceptors(interceptors);\n\nThe BufferingClientHttpRequestFactory is required as we want to use the response body both in the interceptor and for the initial calling code. The default implementation allows to read the response body only once.\n\nin Spring Boot you can get the full request/response by setting this in properties (or other 12 factor method)\n\nlogging.level.org.apache.http=DEBUG\n\nthis outputs\n\n-DEBUG .i.c.DefaultHttpClientConnectionOperator : Connecting to localhost/127.0.0.1:41827 -DEBUG .i.c.DefaultHttpClientConnectionOperator : Connection established 127.0.0.1:39546<->127.0.0.1:41827 -DEBUG o.a.http.impl.execchain.MainClientExec : Executing request POST /v0/users HTTP/1.1 -DEBUG o.a.http.impl.execchain.MainClientExec : Target auth state: UNCHALLENGED -DEBUG o.a.http.impl.execchain.MainClientExec : Proxy auth state: UNCHALLENGED -DEBUG org.apache.http.headers : http-outgoing-0 >> POST /v0/users HTTP/1.1 -DEBUG org.apache.http.headers : http-outgoing-0 >> Content-Type: application/json;charset=UTF-8 -DEBUG org.apache.http.headers : http-outgoing-0 >> Content-Length: 56 -DEBUG org.apache.http.headers : http-outgoing-0 >> Host: localhost:41827 -DEBUG org.apache.http.headers : http-outgoing-0 >> Connection: Keep-Alive -DEBUG org.apache.http.headers : http-outgoing-0 >> User-Agent: Apache-HttpClient/4.5.2 (Java/1.8.0_102) -DEBUG org.apache.http.headers : http-outgoing-0 >> Accept-Encoding: gzip,deflate -DEBUG org.apache.http.wire : http-outgoing-0 >> \"POST /v0/users HTTP/1.1[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Content-Type: application/json;charset=UTF-8[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Content-Length: 56[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Host: localhost:41827[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Connection: Keep-Alive[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"User-Agent: Apache-HttpClient/4.5.2 (Java/1.8.0_102)[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Accept-Encoding: gzip,deflate[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"{\"id\":null,\"email\":\"[email protected]\",\"new\":true}\"\n\nand response\n\n-DEBUG .i.c.DefaultHttpClientConnectionOperator : Connecting to localhost/127.0.0.1:41827 -DEBUG .i.c.DefaultHttpClientConnectionOperator : Connection established 127.0.0.1:39546<->127.0.0.1:41827 -DEBUG o.a.http.impl.execchain.MainClientExec : Executing request POST /v0/users HTTP/1.1 -DEBUG o.a.http.impl.execchain.MainClientExec : Target auth state: UNCHALLENGED -DEBUG o.a.http.impl.execchain.MainClientExec : Proxy auth state: UNCHALLENGED -DEBUG org.apache.http.headers : http-outgoing-0 >> POST /v0/users HTTP/1.1 -DEBUG org.apache.http.headers : http-outgoing-0 >> Content-Type: application/json;charset=UTF-8 -DEBUG org.apache.http.headers : http-outgoing-0 >> Content-Length: 56 -DEBUG org.apache.http.headers : http-outgoing-0 >> Host: localhost:41827 -DEBUG org.apache.http.headers : http-outgoing-0 >> Connection: Keep-Alive -DEBUG org.apache.http.headers : http-outgoing-0 >> User-Agent: Apache-HttpClient/4.5.2 (Java/1.8.0_102) -DEBUG org.apache.http.headers : http-outgoing-0 >> Accept-Encoding: gzip,deflate -DEBUG org.apache.http.wire : http-outgoing-0 >> \"POST /v0/users HTTP/1.1[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Content-Type: application/json;charset=UTF-8[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Content-Length: 56[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Host: localhost:41827[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Connection: Keep-Alive[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"User-Agent: Apache-HttpClient/4.5.2 (Java/1.8.0_102)[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"Accept-Encoding: gzip,deflate[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"[\\r][\\n]\" -DEBUG org.apache.http.wire : http-outgoing-0 >> \"{\"id\":null,\"email\":\"[email protected]\",\"new\":true}\"\n\nor just logging.level.org.apache.http.wire=DEBUG which seems to contain all of the relevant information\n\nNone of these answers actually solve 100% of the problem. mjj1409 gets most of it, but conveniently avoids the issue of logging the response, which takes a bit more work. Paul Sabou provides a solution that seems realistic, but doesn't provide enough details to actually implement (and it didn't work at all for me). Sofiene got the logging but with a critical problem: the response is no longer readable because the input stream has already been consumed!\n\nI recommend using a BufferingClientHttpResponseWrapper to wrap the response object to allow reading the response body multiple times:\n\npublic class LoggingRequestInterceptor implements ClientHttpRequestInterceptor { private static final Logger logger = LoggerFactory.getLogger(LoggingRequestInterceptor.class); @Override public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException { ClientHttpResponse response = execution.execute(request, body); response = log(request, body, response); return response; } private ClientHttpResponse log(final HttpRequest request, final byte[] body, final ClientHttpResponse response) { final ClientHttpResponse responseCopy = new BufferingClientHttpResponseWrapper(response); logger.debug(\"Method: \", request.getMethod().toString()); logger.debug(\"URI: \", , request.getURI().toString()); logger.debug(\"Request Body: \" + new String(body)); logger.debug(\"Response body: \" + IOUtils.toString(responseCopy.getBody())); return responseCopy; } }\n\nThis will not consume the InputStream because the response body is loaded into memory and can be read multiple times. If you do not have the BufferingClientHttpResponseWrapper on your classpath, you can find the simple implementation here:\n\nhttps://github.com/spring-projects/spring-android/blob/master/spring-android-rest-template/src/main/java/org/springframework/http/client/BufferingClientHttpResponseWrapper.java\n\nFor setting up the RestTemplate:\n\nLoggingRequestInterceptor loggingInterceptor = new LoggingRequestInterceptor(); restTemplate.getInterceptors().add(loggingInterceptor);\n\nI finally found a way to do this in the right way. Most of the solution comes from How do I configure Spring and SLF4J so that I can get logging?\n\nIt seems there are two things that need to be done :\n\nAdd the following line in log4j.properties : log4j.logger.httpclient.wire=DEBUG\n\nMake sure spring doesn't ignore your logging config\n\nThe second issue happens mostly to spring environments where slf4j is used (as it was my case). As such, when slf4j is used make sure that the following two things happen :\n\nThere is no commons-logging library in your classpath : this can be done by adding the exclusion descriptors in your pom :\n\n<exclusions><exclusion> <groupId>commons-logging</groupId> <artifactId>commons-logging</artifactId> </exclusion> </exclusions>\n\nThe log4j.properties file is stored somewhere in the classpath where spring can find/see it. If you have problems with this, a last resort solution would be to put the log4j.properties file in the default package (not a good practice but just to see that things work as you expect)\n\n---- July 2019 ----\n\n(using Spring Boot)\n\nI was surprised that Spring Boot, with all it's Zero Configuration magic, doesn't provide an easy way to inspect or log a simple JSON response body with RestTemplate. I looked through the various answers and comments provided here, and am sharing my own distilled version of what (still) works and seems to me like a reasonable solution, given the current options (I'm using Spring Boot 2.1.6 with Gradle 4.4)\n\n1. Using Fiddler as http proxy\n\nThis is actually quite an elegant solution, as it bypasses all the cumbersome efforts of creating your own interceptor or changing the underlying http client to apache (see below).\n\nInstall and run Fiddler\n\nand then\n\nadd -DproxySet=true -Dhttp.proxyHost=localhost -Dhttp.proxyPort=8888 to your VM Options\n\n2. Using Apache HttpClient\n\nAdd Apache HttpClient to your Maven or Gradle dependencies.\n\n<dependency> <groupId>org.apache.httpcomponents</groupId> <artifactId>httpclient</artifactId> <version>4.5.9</version> </dependency>\n\nUse HttpComponentsClientHttpRequestFactory as RequestFactory for RestTemplate. The simplest way to do that would be:\n\nRestTemplate restTemplate = new RestTemplate();\n\nrestTemplate.setRequestFactory(new HttpComponentsClientHttpRequestFactory());\n\nEnable DEBUG in your application.properties file (if you're using Spring Boot)\n\nlogging.level.org.apache.http=DEBUG\n\nIf you're using Spring Boot, you'll need to make sure you have a logging framework set up, e.g. by using a spring-boot-starter dependency that includes spring-boot-starter-logging.\n\n3. Use an Interceptor\n\nI'll let you read through the proposals, counter-proposals, and gotchas in the other answers and comments and decide for yourself if you want to go down that path.\n\n4. Log URL and Response Status without Body\n\nAlthough this doesn't meet the stated requirements of logging the body, it's a quick and simple way to start logging your REST calls. It displays the full URL and response status.\n\nSimply add the following line to your application.properties file (assuming you're using Spring Boot, and assuming you are using a spring boot starter dependency that includes spring-boot-starter-logging)\n\nlogging.level.org.springframework.web.client.RestTemplate=DEBUG\n\nThe output will look something like this:\n\n2019-07-29 11:53:50.265 DEBUG o.s.web.client.RestTemplate : HTTP GET http://www.myrestservice.com/Endpoint?myQueryParam=myValue 2019-07-29 11:53:50.276 DEBUG o.s.web.client.RestTemplate : Accept=[application/json] 2019-07-29 11:53:50.584 DEBUG o.s.web.client.RestTemplate : Response 200 OK 2019-07-29 11:53:50.585 DEBUG o.s.web.client.RestTemplate : Reading to [org.mynamespace.MyJsonModelClass]\n\nAs stated in the other responses, the response body needs special treatment so it can be read repeatedly (by default, its contents get consumed on the first read).\n\nInstead of using the BufferingClientHttpRequestFactory when setting up the request, the interceptor itself can wrap the response and make sure the content is retained and can be repeatedly read (by the logger as well as by the consumer of the response):\n\nMy interceptor, which\n\nbuffers the response body using a wrapper\n\nlogs in a more compact way\n\nlogs the status code identifier as well (e.g. 201 Created)\n\nincludes a request sequence number allowing to easily distinguish concurrent log entries from multiple threads\n\nCode:\n\npublic class LoggingInterceptor implements ClientHttpRequestInterceptor { private final Logger log = LoggerFactory.getLogger(getClass()); private AtomicInteger requestNumberSequence = new AtomicInteger(0); @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { int requestNumber = requestNumberSequence.incrementAndGet(); logRequest(requestNumber, request, body); ClientHttpResponse response = execution.execute(request, body); response = new BufferedClientHttpResponse(response); logResponse(requestNumber, response); return response; } private void logRequest(int requestNumber, HttpRequest request, byte[] body) { if (log.isDebugEnabled()) { String prefix = requestNumber + \" > \"; log.debug(\"{} Request: {} {}\", prefix, request.getMethod(), request.getURI()); log.debug(\"{} Headers: {}\", prefix, request.getHeaders()); if (body.length > 0) { log.debug(\"{} Body: \\n{}\", prefix, new String(body, StandardCharsets.UTF_8)); } } } private void logResponse(int requestNumber, ClientHttpResponse response) throws IOException { if (log.isDebugEnabled()) { String prefix = requestNumber + \" < \"; log.debug(\"{} Response: {} {} {}\", prefix, response.getStatusCode(), response.getStatusCode().name(), response.getStatusText()); log.debug(\"{} Headers: {}\", prefix, response.getHeaders()); String body = StreamUtils.copyToString(response.getBody(), StandardCharsets.UTF_8); if (body.length() > 0) { log.debug(\"{} Body: \\n{}\", prefix, body); } } } /** * Wrapper around ClientHttpResponse, buffers the body so it can be read repeatedly (for logging & consuming the result). */ private static class BufferedClientHttpResponse implements ClientHttpResponse { private final ClientHttpResponse response; private byte[] body; public BufferedClientHttpResponse(ClientHttpResponse response) { this.response = response; } @Override public HttpStatus getStatusCode() throws IOException { return response.getStatusCode(); } @Override public int getRawStatusCode() throws IOException { return response.getRawStatusCode(); } @Override public String getStatusText() throws IOException { return response.getStatusText(); } @Override public void close() { response.close(); } @Override public InputStream getBody() throws IOException { if (body == null) { body = StreamUtils.copyToByteArray(response.getBody()); } return new ByteArrayInputStream(body); } @Override public HttpHeaders getHeaders() { return response.getHeaders(); } } }\n\nConfiguration:\n\n@Bean public RestTemplateBuilder restTemplateBuilder() { return new RestTemplateBuilder() .additionalInterceptors(Collections.singletonList(new LoggingInterceptor())); }\n\nExample log output:\n\n2018-10-08 10:58:53 [main] DEBUG x.y.z.LoggingInterceptor - 2 > Request: POST http://localhost:53969/payment/v4/private/payment-lists/10022/templates 2018-10-08 10:58:53 [main] DEBUG x.y.z.LoggingInterceptor - 2 > Headers: {Accept=[application/json, application/json], Content-Type=[application/json;charset=UTF-8], Content-Length=[986]} 2018-10-08 10:58:53 [main] DEBUG x.y.z.LoggingInterceptor - 2 > Body: {\"idKey\":null, ...} 2018-10-08 10:58:53 [main] DEBUG x.y.z.LoggingInterceptor - 2 < Response: 200 OK 2018-10-08 10:58:53 [main] DEBUG x.y.z.LoggingInterceptor - 2 < Headers: {Content-Type=[application/json;charset=UTF-8], Transfer-Encoding=[chunked], Date=[Mon, 08 Oct 2018 08:58:53 GMT]} 2018-10-08 10:58:53 [main] DEBUG x.y.z.LoggingInterceptor - 2 < Body: { \"idKey\" : \"10022\", ... }\n\nSo many responses here require coding changes and customized classes and it really is not necessary. Gte a debugging proxy such as fiddler and set your java environment to use the proxy on the command line (-Dhttp.proxyHost and -Dhttp.proxyPort) then run fiddler and you can see the requests and responses in their entirety. Also comes with many ancillary advantages such as the ability to tinker with the results and responses before and after they are sent to run experiments before committing to modification of the server.\n\nLast bit of an issue that can come up is if you must use HTTPS, you will need to export the SSL cert from fiddler and import it into the java keystore (cacerts) hint: default java keystore password is usually \"changeit\".\n\nMost of the above solution doesn't work properly when RestTemplate is used and there is a 4xx or 5xx response type as ClientHttpResponse's body is empty. Here is the solution that I used to log the whole HTTP request/response in RestTemplate without losing the response body information in all cases. The Spring boot version is <version>2.7.5</version>\n\n1.Create LoggingInterceptor class\n\nimport lombok.extern.slf4j.Slf4j; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpRequest; import org.springframework.http.HttpStatus; import org.springframework.http.client.ClientHttpRequestExecution; import org.springframework.http.client.ClientHttpRequestInterceptor; import org.springframework.http.client.ClientHttpResponse; import org.springframework.stereotype.Component; import org.springframework.util.StreamUtils; import java.io.*; @Component @Slf4j public class LoggingInterceptor implements ClientHttpRequestInterceptor { @Override public ClientHttpResponse intercept(final HttpRequest request, final byte[] body, final ClientHttpRequestExecution execution) throws IOException { traceRequest(request, body); ClientHttpResponse response = execution.execute(request, body); response = traceResponse(response); return response; } private void traceRequest(HttpRequest request, byte[] body) throws IOException { if (!log.isDebugEnabled()) { return; } log.debug(\"=========================== Request Begin ===========================\"); log.debug(\"URI : \" + request.getURI()); log.debug(\"Method : \" + request.getMethod()); log.debug(\"Headers : \" + request.getHeaders()); log.debug(\"Body : \" + new String(body, \"utf-8\")); log.debug(\"============================ Request End ============================\"); } private ClientHttpResponse traceResponse(ClientHttpResponse response) throws IOException { if (!log.isDebugEnabled()) { return response; } ClientHttpResponse newCopiedResponse = new BufferingClientHttpResponseWrapper(response); StringBuilder inputStringBuilder = new StringBuilder(); // ClientHttpResponse there is no body in response in case of 4xx or 5xx code, so we skip the body part if (isSuccessStatus(response.getRawStatusCode())) { inputStringBuilder = new StringBuilder(); BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(newCopiedResponse.getBody(), \"UTF-8\")); String line = bufferedReader.readLine(); while (line != null) { inputStringBuilder.append(line); line = bufferedReader.readLine(); } } log.debug(\"=========================== Response Begin ===========================\"); log.debug(\"Status code : {}\", response.getStatusCode()); log.debug(\"Status text : {}\", response.getStatusText()); log.debug(\"Headers : {}\", response.getHeaders()); if (isSuccessStatus(response.getRawStatusCode())) { log.debug(\"Response Body : {}\", inputStringBuilder.toString()); log.debug(\"============================ Response End ============================\"); } return newCopiedResponse; } private static boolean isSuccessStatus(int statusCode) { return (statusCode / 100) == 2; } /** * Wrapper around ClientHttpResponse, buffers the body so it can be read repeatedly (for logging & consuming the result). */ private static class BufferingClientHttpResponseWrapper implements ClientHttpResponse { private final ClientHttpResponse response; private byte[] body; public BufferingClientHttpResponseWrapper(ClientHttpResponse response) { this.response = response; } @Override public InputStream getBody() throws IOException { if (body == null) { body = StreamUtils.copyToByteArray(response.getBody()); } return new ByteArrayInputStream(body); } @Override public HttpStatus getStatusCode() throws IOException { return this.response.getStatusCode(); } @Override public int getRawStatusCode() throws IOException { return this.response.getRawStatusCode(); } @Override public String getStatusText() throws IOException { return this.response.getStatusText(); } @Override public HttpHeaders getHeaders() { return this.response.getHeaders(); } @Override public void close() { this.response.close(); } }\n\n}\n\n2.Attach it to the RestTemplate bean\n\n@Configuration public class RestTemplateConfig { @Bean public RestTemplate createRestTemplate(LoggingInterceptor loggingInterceptor) { RestTemplate restTemplate = new RestTemplate(); restTemplate.setInterceptors(Collections.singletonList(loggingInterceptor)); return restTemplate; } }\n\n3.Apply the appropriate level in the application\n\nlogging: level: com: test: DEBUG\n\nThe trick of configuring your RestTemplate with a BufferingClientHttpRequestFactory doesn't work if you are using any ClientHttpRequestInterceptor, which you will if you are trying to log via interceptors. This is due to the way that InterceptingHttpAccessor (which RestTemplate subclasses) works.\n\nLong story short... just use this class in place of RestTemplate (note this uses the SLF4J logging API, edit as needed):\n\nimport java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.lang.reflect.Constructor; import java.nio.charset.StandardCharsets; import java.util.List; import java.util.Map; import javax.annotation.PostConstruct; import org.slf4j.Logger; import org.slf4j.LoggerFactory; import org.springframework.http.HttpHeaders; import org.springframework.http.HttpRequest; import org.springframework.http.HttpStatus; import org.springframework.http.client.ClientHttpRequestExecution; import org.springframework.http.client.ClientHttpRequestInterceptor; import org.springframework.http.client.ClientHttpResponse; import org.springframework.web.client.RestTemplate; /** * A {@link RestTemplate} that logs every request and response. */ public class LoggingRestTemplate extends RestTemplate { // Bleh, this class is not public private static final String RESPONSE_WRAPPER_CLASS = \"org.springframework.http.client.BufferingClientHttpResponseWrapper\"; private Logger log = LoggerFactory.getLogger(this.getClass()); private boolean hideAuthorizationHeaders = true; private Class<?> wrapperClass; private Constructor<?> wrapperConstructor; /** * Configure the logger to log requests and responses to. * * @param log log destination, or null to disable */ public void setLogger(Logger log) { this.log = log; } /** * Configure the logger to log requests and responses to by name. * * @param name name of the log destination, or null to disable */ public void setLoggerName(String name) { this.setLogger(name != null ? LoggerFactory.getLogger(name) : null); } /** * Configure whether to hide the contents of {@code Authorization} headers. * * <p> * Default true. * * @param hideAuthorizationHeaders true to hide, otherwise false */ public void setHideAuthorizationHeaders(boolean hideAuthorizationHeaders) { this.hideAuthorizationHeaders = hideAuthorizationHeaders; } /** * Log a request. */ protected void traceRequest(HttpRequest request, byte[] body) { this.log.debug(\"xmit: {} {}\\n{}{}\", request.getMethod(), request.getURI(), this.toString(request.getHeaders()), body != null && body.length > 0 ? \"\\n\\n\" + new String(body, StandardCharsets.UTF_8) : \"\"); } /** * Log a response. */ protected void traceResponse(ClientHttpResponse response) { final ByteArrayOutputStream bodyBuf = new ByteArrayOutputStream(); HttpStatus statusCode = null; try { statusCode = response.getStatusCode(); } catch (IOException e) { // ignore } String statusText = null; try { statusText = response.getStatusText(); } catch (IOException e) { // ignore } try (final InputStream input = response.getBody()) { byte[] b = new byte[1024]; int r; while ((r = input.read(b)) != -1) bodyBuf.write(b, 0, r); } catch (IOException e) { // ignore } this.log.debug(\"recv: {} {}\\n{}{}\", statusCode, statusText, this.toString(response.getHeaders()), bodyBuf.size() > 0 ? \"\\n\\n\" + new String(bodyBuf.toByteArray(), StandardCharsets.UTF_8) : \"\"); } @PostConstruct private void addLoggingInterceptor() { this.getInterceptors().add(new ClientHttpRequestInterceptor() { @Override public ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { // Log request if (LoggingRestTemplate.this.log != null && LoggingRestTemplate.this.log.isDebugEnabled()) LoggingRestTemplate.this.traceRequest(request, body); // Perform request ClientHttpResponse response = execution.execute(request, body); // Log response if (LoggingRestTemplate.this.log != null && LoggingRestTemplate.this.log.isDebugEnabled()) { final ClientHttpResponse bufferedResponse = LoggingRestTemplate.this.ensureBuffered(response); if (bufferedResponse != null) { LoggingRestTemplate.this.traceResponse(bufferedResponse); response = bufferedResponse; } } // Done return response; } }); } private ClientHttpResponse ensureBuffered(ClientHttpResponse response) { try { if (this.wrapperClass == null) this.wrapperClass = Class.forName(RESPONSE_WRAPPER_CLASS, false, ClientHttpResponse.class.getClassLoader()); if (!this.wrapperClass.isInstance(response)) { if (this.wrapperConstructor == null) { this.wrapperConstructor = this.wrapperClass.getDeclaredConstructor(ClientHttpResponse.class); this.wrapperConstructor.setAccessible(true); } response = (ClientHttpResponse)this.wrapperConstructor.newInstance(response); } return response; } catch (Exception e) { this.log.error(\"error creating {} instance: {}\", RESPONSE_WRAPPER_CLASS, e); return null; } } private String toString(HttpHeaders headers) { final StringBuilder headerBuf = new StringBuilder(); for (Map.Entry<String, List<String>> entry : headers.entrySet()) { if (headerBuf.length() > 0) headerBuf.append('\\n'); final String name = entry.getKey(); for (String value : entry.getValue()) { if (this.hideAuthorizationHeaders && name.equalsIgnoreCase(HttpHeaders.AUTHORIZATION)) value = \"[omitted]\"; headerBuf.append(name).append(\": \").append(value); } } return headerBuf.toString(); } }\n\nI agree it's silly that it takes this much work just to do this.\n\nWanted to add my implementation of this as well. I apologize for all the missing semi-colons, this is written in Groovy.\n\nI needed something more configurable than the accepted answer provided. Here's a rest template bean that's very agile and will log everything like the OP is looking for.\n\nCustom Logging Interceptor Class:\n\nimport org.springframework.http.HttpRequest import org.springframework.http.client.ClientHttpRequestExecution import org.springframework.http.client.ClientHttpRequestInterceptor import org.springframework.http.client.ClientHttpResponse import org.springframework.util.StreamUtils import java.nio.charset.Charset class HttpLoggingInterceptor implements ClientHttpRequestInterceptor { private final static Logger log = LoggerFactory.getLogger(HttpLoggingInterceptor.class) @Override ClientHttpResponse intercept(HttpRequest request, byte[] body, ClientHttpRequestExecution execution) throws IOException { logRequest(request, body) ClientHttpResponse response = execution.execute(request, body) logResponse(response) return response } private void logRequest(HttpRequest request, byte[] body) throws IOException { if (log.isDebugEnabled()) { log.debug(\"===========================request begin================================================\") log.debug(\"URI : {}\", request.getURI()) log.debug(\"Method : {}\", request.getMethod()) log.debug(\"Headers : {}\", request.getHeaders()) log.debug(\"Request body: {}\", new String(body, \"UTF-8\")) log.debug(\"==========================request end================================================\") } } private void logResponse(ClientHttpResponse response) throws IOException { if (log.isDebugEnabled()) { log.debug(\"============================response begin==========================================\") log.debug(\"Status code : {}\", response.getStatusCode()) log.debug(\"Status text : {}\", response.getStatusText()) log.debug(\"Headers : {}\", response.getHeaders()) log.debug(\"Response body: {}\", StreamUtils.copyToString(response.getBody(), Charset.defaultCharset())) log.debug(\"=======================response end=================================================\") } } }\n\nRest Template Bean Definition:\n\n@Bean(name = 'myRestTemplate') RestTemplate myRestTemplate(RestTemplateBuilder builder) { RequestConfig requestConfig = RequestConfig.custom() .setConnectTimeout(10 * 1000) // 10 seconds .setSocketTimeout(300 * 1000) // 300 seconds .build() PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager() connectionManager.setMaxTotal(10) connectionManager.closeIdleConnections(5, TimeUnit.MINUTES) CloseableHttpClient httpClient = HttpClients.custom() .setConnectionManager(connectionManager) .setDefaultRequestConfig(requestConfig) .disableRedirectHandling() .build() RestTemplate restTemplate = builder .rootUri(\"https://domain.server.com\") .basicAuthorization(\"username\", \"password\") .requestFactory(new BufferingClientHttpRequestFactory(new HttpComponentsClientHttpRequestFactory(httpClient))) .interceptors(new HttpLoggingInterceptor()) .build() return restTemplate }\n\nImplementation:\n\n@Component class RestService { private final RestTemplate restTemplate private final static Logger log = LoggerFactory.getLogger(RestService.class) @Autowired RestService( @Qualifier(\"myRestTemplate\") RestTemplate restTemplate ) { this.restTemplate = restTemplate } // add specific methods to your service that access the GET and PUT methods private <T> T getForObject(String path, Class<T> object, Map<String, ?> params = [:]) { try { return restTemplate.getForObject(path, object, params) } catch (HttpClientErrorException e) { log.warn(\"Client Error (${path}): ${e.responseBodyAsString}\") } catch (HttpServerErrorException e) { String msg = \"Server Error (${path}): ${e.responseBodyAsString}\" log.error(msg, e) } catch (RestClientException e) { String msg = \"Error (${path})\" log.error(msg, e) } return null } private <T> T putForObject(String path, T object) { try { HttpEntity<T> request = new HttpEntity<>(object) HttpEntity<T> response = restTemplate.exchange(path, HttpMethod.PUT, request, T) return response.getBody() } catch (HttpClientErrorException e) { log.warn(\"Error (${path}): ${e.responseBodyAsString}\") } catch (HttpServerErrorException e) { String msg = \"Error (${path}): ${e.responseBodyAsString}\" log.error(msg, e) } catch (RestClientException e) { String msg = \"Error (${path})\" log.error(msg, e) } return null } }\n\nRelated to the response using ClientHttpInterceptor, I found a way of keeping the whole response without Buffering factories. Just store the response body input stream inside byte array using some utils method that will copy that array from body, but important, surround this method with try catch because it will break if response is empty (that is the cause of Resource Access Exception) and in catch just create empty byte array, and than just create anonymous inner class of ClientHttpResponse using that array and other parameters from the original response. Than you can return that new ClientHttpResponse object to the rest template execution chain and you can log response using body byte array that is previously stored. That way you will avoid consuming InputStream in the actual response and you can use Rest Template response as it is. Note, this may be dangerous if your's response is too big"
    }
}