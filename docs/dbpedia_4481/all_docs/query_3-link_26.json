{
    "id": "dbpedia_4481_3",
    "rank": 26,
    "data": {
        "url": "https://timdietrich.me/blog/netsuite-suiteql-work-order-queries/",
        "read_more_link": "",
        "language": "en",
        "title": "NetSuite: SuiteQL Queries for Work Orders",
        "top_image": "https://timdietrich.me/resources/favicon_large.png",
        "meta_img": "https://timdietrich.me/resources/favicon_large.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://timdietrich.me/resources/large.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "I've recently been working on a custom application for a NetSuite client to help them with production planning. It's been a very interesting project, requiring the use of work orders, assembly items, and more.\n\nIn this post, I'm going to share some of the queries that I developed for the application. Specifically, I'll share queries involving work orders, show how you can get the sales orders that they were created for, and more.\n\nWork Order Transactions\n\nLet's start with a simple query that returns all of the work orders that are released. Work orders are stored in the Transaction table, and their transaction type is \"WorkOrd.\"\n\nHere's the query.\n\nSELECT WorkOrder.ID, WorkOrder.TranID, BUILTIN.DF( WorkOrder.Status ) AS Status, BUILTIN.DF( WorkOrder.Entity ) AS Customer FROM Transaction AS WorkOrder WHERE ( WorkOrder.Type = 'WorkOrd' ) AND ( BUILTIN.CF( WorkOrder.Status ) = 'WorkOrd:B' )\n\nNotice the use of the BUILTIN.DF function, which I'm using to get the names of the work order statuses and the names of the customers associated with the work orders.\n\nAlso notice that I'm using the BUILTIN.CF function in the WHERE clause to indicate that I only want work orders that have been released. I wrote about the BUILTIN.CF function in a post titled SuiteQL-Based Sales Reports, Transaction Statuses, and the WITH Clause back in December. Think of BUILTIN.CF as the WHERE clause-equivalent of the SELECT clause's BUILTIN.DF function.\n\nWork Order Statuses\n\nIf you're interested in seeing the other work order statuses, run this query. It returns a complete list of the various statuses that work orders are currently in.\n\nSELECT DISTINCT Status, BUILTIN.DF( Status ) AS DFStatus, BUILTIN.CF( Status ) AS CFStatus FROM Transaction WHERE ( Transaction.Type = 'WorkOrd' ) ORDER BY Status\n\nIf you're interested in seeing the number of work orders in each status, you can use this query:\n\nSELECT Status, BUILTIN.DF( Status ) AS DFStatus, BUILTIN.CF( Status ) AS CFStatus, COUNT(*) FROM Transaction WHERE ( Transaction.Type = 'WorkOrd' ) GROUP BY Status, BUILTIN.DF( Status ), BUILTIN.CF( Status ) ORDER BY Status\n\nRelated Sales Orders\n\nSuppose that in the results we also want to see the sales order associated with each of the work orders. There are two things to keep in mind.\n\nFirst, the ID of the sales order that a work order was created for is not stored at the header level of the work order. In other words, there's no column on the Transaction table that contains the sales order ID. Instead, that value is stored at the lineitem level.\n\nSecond, we also need to keep in mind that it is entirely possible for a work order to exist without it having been originated from a sales order. So we need to be careful with regards to the types of joins that we're using.\n\nLet's look at the query and then review it.\n\nSELECT WO.ID AS WOID, WO.TranID AS WONumber, BUILTIN.DF( WO.Status ) AS WOStatus, BUILTIN.DF( WO.Entity ) AS Customer, SO.ID AS SOID, SO.TranID AS SONumber FROM Transaction AS WO INNER JOIN TransactionLine AS WOLine ON ( WOLine.Transaction = WO.ID ) AND ( WOLine.MainLine = 'T' ) LEFT OUTER JOIN Transaction AS SO ON ( SO.ID = WOLine.CreatedFrom ) WHERE ( WO.Type = 'WorkOrd' ) AND ( BUILTIN.CF( WO.Status ) = 'WorkOrd:B' )\n\nNotice that I'm now joining from the Transaction table to the TransactionLine table. I'm joining on the Transaction ID value, and specifying that I only want the \"mainline.\" The mainline filter prevents a single work order from being returned multiple times.\n\nTo get to the Sales Order, I'm using the TransactionLine's \"CreatedFrom\" value, and joining to the Transaction table a second time. By using a table alias, I can refer to the same table in multiple ways. This is one of the reasons that table aliases are so important and helpful.\n\nAnd finally, notice that in the join from the lineitem to the sales order transaction, I'm using a LEFT OUTER JOIN. Had I used an INNER JOIN, I would have inadvertently excluded work orders that did not originate from sales orders.\n\nWhat's Being Produced?\n\nSo far we've looked at queries that give you work orders at the header level. But what if we're interested in the lineitem level information? For example, suppose we want to know the total quantities of the assembly items on the released work orders.\n\nHere's a query that returns that information.\n\nSELECT BUILTIN.DF( WOLine.Item ) AS ItemID, Item.ItemType, SUM( WOLine.Quantity ) FROM Transaction AS WO INNER JOIN TransactionLine AS WOLine ON ( WOLine.Transaction = WO.ID ) INNER JOIN Item ON ( Item.ID = WOLine.Item ) WHERE ( WO.Type = 'WorkOrd' ) AND ( BUILTIN.CF( WO.Status ) = 'WorkOrd:B' ) AND ( Item.ItemType = 'Assembly' ) GROUP BY BUILTIN.DF( WOLine.Item ), Item.ItemType ORDER BY ItemID\n\nIf you're interested in seeing all of the items that will need to produced and the components that will be needed, you can remove the \"AND ( Item.ItemType = 'Assembly' )\" statement from the WHERE clause.\n\nBasic Production Planning\n\nNow that we have the work orders and their related sales orders, we can use values from each to do some very basic analysis and production planning.\n\nOn the work order we have the Production End Date, which NetSuite defines as \"the date you expect to complete assembly production.\" On the sales order, we have the Customer Ship Date, which is the shipping date for the order. Using those two dates and a basic date arithmetic function, we can determine the number of days between the two dates.\n\nHere's a revised query.\n\nSELECT WO.ID AS WOID, WO.TranID AS WONumber, BUILTIN.DF( WO.Status ) AS WOStatus, BUILTIN.DF( WO.Entity ) AS Customer, SO.ID AS SOID, SO.TranID AS SONumber, SO.ShipDate, WO.EndDate, ( TRUNC ( SO.ShipDate ) - TRUNC ( WO.EndDate ) ) AS DeltaDays FROM Transaction AS WO INNER JOIN TransactionLine AS WOLine ON ( WOLine.Transaction = WO.ID ) AND ( WOLine.MainLine = 'T' ) LEFT OUTER JOIN Transaction AS SO ON ( SO.ID = WOLine.CreatedFrom ) WHERE ( WO.Type = 'WorkOrd' ) AND ( BUILTIN.CF( WO.Status ) = 'WorkOrd:B' )\n\nAs you can see, I've included the two date columns to the results, and I'm subtracting the work order's \"production end date\" from the sales order's \"ship date.\" (I'm using the TRUNC function on the dates so that the calculation is based only date portions of the two columns, which are actually timestamps.) That value represents the number of days between the date that we're expecting the work order to be completed, and the date that the customer is expecting their order to ship. If that value is negative, then we're likely going to be shipping the order late. If the delta is low, then we don't have much \"wiggle room\" so to speak. So if we're doing production planning, we might want to prioritize these work orders.\n\nAgain, this is a very, very basic approach to production planning. In reality, there's usually much more to this process. But it does give you some idea as to what's possible.\n\nWhat's In The Pipeline?\n\nLet's look at one more query that might be helpful to you. Suppose that we want to know what's in the pipeline that we might want to plan for. In other words, what sales orders are queued up, pending approval, that are likely going to result in the creation of work orders?\n\nHere's a query that shows that information, including the customers, the assembly items, the quantities involved, and the ship dates.\n\nSELECT SO.ID, SO.TranID, BUILTIN.DF( SO.Status ) AS SOStatus, BUILTIN.DF( SO.Entity ) AS Customer, Item.ItemID, SOLine.Quantity, SO.ShipDate FROM Transaction AS SO INNER JOIN TransactionLine AS SOLine ON ( SOLine.Transaction = SO.ID ) INNER JOIN Item ON ( Item.ID = SOLine.Item ) WHERE ( SO.Type = 'SalesOrd' ) AND ( BUILTIN.CF( SO.Status ) = 'SalesOrd:A' ) AND ( Item.ItemType = 'Assembly' )\n\nWe can also look at quotes / estimates that are in the pipeline. To do that, we'd query the Transaction tables for Estimates that have a status of Open.\n\nHere's that query.\n\nSELECT Estimate.ID, Estimate.TranID, BUILTIN.DF( Estimate.Status ) AS EstimateStatus, BUILTIN.DF( Estimate.Entity ) AS Customer, Item.ItemID, Item.ItemType, EstimateLine.Quantity, Estimate.ShipDate, Estimate.Probability, Estimate.ExpectedCloseDate FROM Transaction AS Estimate INNER JOIN TransactionLine AS EstimateLine ON ( EstimateLine.Transaction = Estimate.ID ) INNER JOIN Item ON ( Item.ID = EstimateLine.Item ) WHERE ( Estimate.Type = 'Estimate' ) AND ( BUILTIN.CF( Estimate.Status ) = 'Estimate:A' ) AND ( Item.ItemType = 'Assembly' )\n\nI've added a few potentially helpful columns to the results: Probability (the probability that an estimate will be converted to a sale) and ExpectedCloseDate (the date the estimate is expected to close).\n\nWrapping Up\n\nIn this post, I've discussed Work Orders and provided a few examples of queries that I think you'll find helpful - especially if you're trying to report on and/or analyze your production process. I've only scratched the surface of what's possible.\n\nIn a future post, I'll discuss assembly items, and show how you can query for their components."
    }
}