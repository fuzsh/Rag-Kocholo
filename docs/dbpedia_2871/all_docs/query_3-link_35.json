{
    "id": "dbpedia_2871_3",
    "rank": 35,
    "data": {
        "url": "https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning",
        "read_more_link": "",
        "language": "en",
        "title": "A gentle introduction to automated reasoning",
        "top_image": "https://assets.amazon.science/dims4/default/31d3d82/2147483647/strip/true/crop/800x420+0+15/resize/1200x630!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F5c%2F52%2Fe474238142849259b23d9c3c8163%2Fpolicy-code.still.gif",
        "meta_img": "https://assets.amazon.science/dims4/default/31d3d82/2147483647/strip/true/crop/800x420+0+15/resize/1200x630!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F5c%2F52%2Fe474238142849259b23d9c3c8163%2Fpolicy-code.still.gif",
        "images": [
            "https://assets.amazon.science/dims4/default/84daefc/2147483647/strip/true/crop/54x30+0+12/resize/1440x810!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F85%2Fcd%2F36ef075d49dc9ee4f0502f9cc72e%2Fsubscribe-icon.png",
            "https://assets.amazon.science/07/d9/d204ca2242bea8215dbf9ca5c43e/amazon-science-logo.svg",
            "https://assets.amazon.science/dims4/default/84daefc/2147483647/strip/true/crop/54x30+0+12/resize/1440x810!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F85%2Fcd%2F36ef075d49dc9ee4f0502f9cc72e%2Fsubscribe-icon.png",
            "https://assets.amazon.science/dims4/default/f91627d/2147483647/strip/true/crop/200x200+0+0/resize/295x295!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F3e%2Fd5%2Fd96a8ca3df840f33c8fa97ee14a5%2Fa-gentle-introduction-to-automated-reasoningqrcode",
            "https://assets.amazon.science/dims4/default/ac70ec3/2147483647/strip/true/crop/800x450+0+0/resize/1200x675!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2Fe4%2F73%2F45f43a434b28b094b8609ec8c129%2Fpolicy-code.gif",
            "https://assets.amazon.science/dims4/default/904ca2b/2147483647/strip/true/crop/1017x570+0+2/resize/535x300!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F41%2Fad%2F75576be04568aa5a011408123c26%2Fgraviton-chip.png",
            "https://assets.amazon.science/dims4/default/908fc8f/2147483647/strip/true/crop/1508x845+0+12/resize/535x300!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2Fa2%2F7f%2Fc0888d404c8c973469b40df41582%2Fmix-1728x1080.jpg",
            "https://assets.amazon.science/dims4/default/d6f95b4/2147483647/strip/true/crop/1920x1077+0+2/resize/535x300!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F25%2F2e%2F5177cfe447e58532c2c9435275a7%2Fredrawn-hexagon.gif",
            "https://assets.amazon.science/17/83/40ea1c0845b88a6e9f3b42613d82/amazon-science-logo-white.svg",
            "https://assets.amazon.science/dims4/default/29c19bf/2147483647/strip/true/crop/1014x877+4+346/resize/326x282!/quality/90/?url=http%3A%2F%2Famazon-topics-brightspot.s3.amazonaws.com%2Fscience%2F20%2Fc4%2Fc36de9f643dab18e2f27ea071590%2Famazon-science-newsletter-project-kuiper.jpg"
        ],
        "movies": [
            "https://www.youtube.com/embed/9NEQbFLtDmg?enablejsapi=1"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Byron Cook",
            "www.amazon.science",
            "byron-cook"
        ],
        "publish_date": "2021-12-01T16:48:25.200000+00:00",
        "summary": "",
        "meta_description": "Meet Amazon Science’s newest research area.",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "Amazon Science",
        "canonical_link": "https://www.amazon.science/blog/a-gentle-introduction-to-automated-reasoning",
        "text": "This week, Amazon Science added automated reasoning to its list of research areas. We made this change because of the impact that automated reasoning is having here at Amazon. For example, Amazon Web Services’ customers now have direct access to automated-reasoning-based features such as IAM Access Analyzer, S3 Block Public Access, or VPC Reachability Analyzer. We also see Amazon development teams integrating automated-reasoning tools into their development processes, raising the bar on the security, durability, availability, and quality of our products.\n\nThe goal of this article is to provide a gentle introduction to automated reasoning for the industry professional who knows nothing about the area but is curious to learn more. All you will need to make sense of this article is to be able to read a few small C and Python code fragments. I will refer to a few specialist concepts along the way, but only with the goal of introducing them in an informal manner. I close with links to some of our favorite publicly available tools, videos, books, and articles for those looking to go more in-depth.\n\nLet’s start with a simple example. Consider the following C function:\n\nTake a few moments to answer the question “Could f ever return false?” This is not a trick question: I’ve purposefully used a simple example to make a point.\n\nTo check the answer with exhaustive testing, we could try executing the following doubly nested test loop, which calls f on all possible pairs of values of the type unsigned int:\n\nUnfortunately, even on modern hardware, this doubly nested loop will run for a very long time. I compiled it and ran it on a 2.6 GHz Intel processor for over 48 hours before giving up.\n\nWhy does testing take so long? Because UINT_MAX is typically 4,294,967,295, there are 18,446,744,065,119,617,025 separate f calls to consider. On my 2.6 GHz machine, the compiled test loop called f approximately 430 million times a second. But to test all 18 quintillion cases at this performance, we would need over 1,360 years.\n\nWhen we show the above code to industry professionals, they almost immediately work out that f can't return false as long as the underlying compiler/interpreter and hardware are correct. How do they do that? They reason about it. They remember from their school days that x + y can be rewritten as y + x and conclude that f always returns true.\n\nAn automated reasoning tool does this work for us: it attempts to answer questions about a program (or a logic formula) by using known techniques from mathematics. In this case, the tool would use algebra to deduce that x + y == y + x can be replaced with the simple expression true.\n\nAutomated-reasoning tools can be incredibly fast, even when the domains are infinite (e.g., unbounded mathematical integers rather than finite C ints). Unfortunately, the tools may answer “Don’t know” in some instances. We'll see a famous example of that below.\n\nThe science of automated reasoning is essentially focused on driving the frequency of these “Don’t know” answers down as far as possible: the less often the tools report \"Don't know\" (or time out while trying), the more useful they are.\n\nToday’s tools are able to give answers for programs and queries where yesterday’s tools could not. Tomorrow’s tools will be even more powerful. We are seeing rapid progress in this field, which is why at Amazon, we are increasingly getting so much value from it. In fact, we see automated reasoning forming its own Amazon-style virtuous cycle, where more input problems to our tools drive improvements to the tools, which encourages more use of the tools.\n\nA slightly more complex example. Now that we know the rough outlines of what automated reasoning is, the next small example gives a slightly more realistic taste of the sort of complexity that the tools are managing for us.\n\nOr, alternatively, consider a similar Python program over unbounded integers:\n\nTry to answer this question: “Does g always eventually return control back to its caller?”\n\nWhen we show this program to industry professionals, they usually figure out the right answer quickly. A few, especially those who are aware of results in theoretical computer science, sometimes mistakenly think that we can't answer this question, with the rationale “This is an example of the halting problem, which has been proved insoluble”. In fact, we can reason about the halting behavior for specific programs, including this one. We’ll talk more about that later.\n\nHere’s the reasoning that most industry professionals use when looking at this problem:\n\nIn the case where y is not positive, execution jumps to the end of the function g. That’s the easy case.\n\nIf, in every iteration of the loop, the value of the variable x decreases, then eventually, the loop condition x > y will fail, and the end of g will be reached.\n\nThe value of x always decreases only if y is always positive, because only then does the update to x (i.e., x = x - y) decrease x. But y’s positivity is established by the conditional expression, so x always decreases.\n\nThe experienced programmer will usually worry about underflow in the x = x - y command of the C program but will then notice that x > y before the update to x and thus cannot underflow.\n\nIf you carried out the three steps above yourself, you now have a very intuitive view of the type of thinking an automated-reasoning tool is performing on our behalf when reasoning about a computer program. There are many nitty-gritty details that the tools have to face (e.g., heaps, stacks, strings, pointer arithmetic, recursion, concurrency, callbacks, etc.), but there’s also decades of research papers on techniques for handling these and other topics, along with various practical tools that put these ideas to work.\n\nThe main takeaway is that automated-reasoning tools are usually working through the three steps above on our behalf: Item 1 is reasoning about the program’s control structure. Item 2 is reasoning about what is eventually true within the program. Item 3 is reasoning about what is always true in the program.\n\nNote that configuration artifacts such as AWS resource policies, VPC network descriptions, or even makefiles can be thought of as code. This viewpoint allows us to use the same techniques we use to reason about C or Python code to answer questions about the interpretation of configurations. It’s this insight that gives us tools like IAM Access Analyzer or VPC Reachability Analyzer.\n\nAn end to testing?\n\nAs we saw above when looking at f and g, automated reasoning can be dramatically faster than exhaustive testing. With tools available today, we can show properties of f or g in milliseconds, rather than waiting lifetimes with exhaustive testing.\n\nCan we throw away our testing tools now and just move to automated reasoning? Not quite. Yes, we can dramatically reduce our dependency on testing, but we will not be completely eliminating it any time soon, if ever. Consider our first example:\n\nRecall the worry that a buggy compiler or microprocessor could in fact cause an executable program constructed from this source code to return false. We might also need to worry about the language runtime. For example, the C math library or the Python garbage collector might have bugs that cause a program to misbehave.\n\nWhat’s interesting about testing, and something we often forget, is that it’s doing much more than just telling us about the C or Python source code. It’s also testing the compiler, the runtime, the interpreter, the microprocessor, etc. A test failure could be rooted in any of those tools in the stack.\n\nAutomated reasoning, in contrast, is usually applied to just one layer of that stack — the source code itself, or sometimes the compiler or the microprocessor. What we find so valuable about reasoning is it allows us to clearly define both what we do know and what we do not know about the layer under inspection.\n\nFurthermore, the models of the surrounding environment (e.g., the compiler or the procedure calling our procedure) used by the automated-reasoning tool make our assumptions very precise. Separating the layers of the computational stack helps make better use of our time, energy, and money and the capabilities of the tools today and tomorrow.\n\nUnfortunately, we will almost always need to make assumptions about something when using automated reasoning — for example, the principles of physics that govern our silicon chips. Thus, testing will never be fully replaced. We will want to perform end-to-end testing to try and validate our assumptions as best we can.\n\nAn impossible program\n\nI previously mentioned that automated-reasoning tools sometimes return “Don’t know” rather than “yes” or “no”. They also sometimes run forever (or time out), thus never returning an answer. Let’s look at the famous \"halting problem\" program, in which we know tools cannot return “yes” or “no”.\n\nImagine that we have an automated-reasoning API, called terminates, that returns “yes” if a C function always terminates or “no” when the function could execute forever. As an example, we could build such an API using the tool described here (shameless self-promotion of author’s previous work). To get the idea of what a termination tool can do for us, consider two basic C functions, g (from above),\n\nand g2:\n\nFor the reasons we have already discussed, the function g always returns control back to its caller, so terminates(g) should return true. Meanwhile, terminates(g2) should return false because, for example, g2(5, 0) will never terminate.\n\nNow comes the difficult function. Consider h:\n\nNotice that it's recursive. What’s the right answer for terminates(h)? The answer cannot be \"yes\". It also cannot be \"no\". Why?\n\nImagine that terminates(h) were to return \"yes\". If you read the code of h, you’ll see that in this case, the function does not terminate because of the conditional statement in the code of h that will execute the infinite loop while(1){}. Thus, in this case, the terminates(h) answer would be wrong, because h is defined recursively, calling terminates on itself.\n\nSimilarly, if terminates(h) were to return \"no\", then h would in fact terminate and return control to its caller, because the if case of the conditional statement is not met, and there is no else branch. Again, the answer would be wrong. This is why the “Don’t know” answer is actually unavoidable in this case.\n\nThe program h is a variation of examples given in Turing’s famous 1936 paper on decidability and Gödel’s incompleteness theorems from 1931. These papers tell us that problems like the halting problem cannot be “solved”, if by“solved” we mean that the solution procedure itself always terminates and answers either “yes” or “no” but never “Don’t know”. But that is not the definition of “solved” that many of us have in mind. For many of us, a tool that sometimes times out or occasionally returns “Don’t know” but, when it gives an answer, always gives the right answer is good enough.\n\nThis problem is analogous to airline travel: we know it’s not 100% safe, because crashes have happened in the past, and we are sure that they will happen in the future. But when you land safely, you know it worked that time. The goal of the airline industry is to reduce failure as much as possible, even though it’s in principle unavoidable.\n\nTo put that in the context of automated reasoning: for some programs, like h, we can never improve the tool enough to replace the \"Don't know\" answer. But there are many other cases where today's tools answer \"Don't know\", but future tools may be able to answer \"yes\" or \"no\". The modern scientific challenge for automated-reasoning subject-matter experts is to get the practical tools to return “yes” or “no” as often as possible. As an example of current work, check out CMU professor and Amazon scholar Marijn Heule and his quest to solve the Collatz termination problem.\n\nAnother thing to keep in mind is that automated-reasoning tools are regularly trying to solve “intractable” problems, e.g., problems in the NP complexity class. Here, the same thinking applies that we saw in the case of the halting problem: automated-reasoning tools have powerful heuristics that often work around the intractability problem for specific cases, but those heuristics can (and sometimes do) fail, resulting in “Don’t know” answers or impractically long execution time. The science is to improve the heuristics to minimize that problem.\n\nNomenclature\n\nA host of names are used in the scientific literature to describe interrelated topics, of which automated reasoning is just one. Here’s a quick glossary:\n\nA logic is a formal and mechanical system for defining what is true and untrue. Examples: propositional logic or first-order logic.\n\nA theorem is a true statement in logic. Example: the four-color theorem.\n\nA proof is a valid argument in logic of a theorem. Example: Gonthier's proof of the four-color theorem.\n\nA mechanical theorem prover is a semi-automated-reasoning tool that checks a machine-readable expression of a proof often written down by a human. These tools often require human guidance. Example: HOL-light, from Amazon researcher John Harrison.\n\nFormal verification is the use of theorem proving when applied to models of computer systems to prove desired properties of the systems. Example: the CompCert verified C compiler.\n\nFormal methods is the broadest term, meaning simply the use of logic to reason formally about models of systems.\n\nAutomated reasoning focuses on the automation of formal methods.\n\nA semi-automated-reasoning tool is one that requires hints from the user but still finds valid proofs in logic.\n\nAs you can see, we have a choice of monikers when working in this space. At Amazon, we’ve chosen to use automated reasoning, as we think it best captures our ambition for automation and scale. In practice, some of our internal teams use both automated and semi-automated reasoning tools, because the scientists we've hired can often get semi-automated reasoning tools to succeed where the heuristics in fully automated reasoning might fail. For our externally facing customer features, we currently use only fully automated approaches.\n\nNext steps\n\nIn this essay, I’ve introduced the idea of automated reasoning, with the smallest of toy programs. I haven’t described how to handle realistic programs, with heap or concurrency. In fact, there are a wide variety of automated-reasoning tools and techniques, solving problems in all kinds of different domains, some of them quite narrow. To describe them all and the many branches and sub-disciplines of the field (e.g. “SMT solving”, “higher-order logic theorem proving”, “separation logic”) would take thousands of blogs posts and books.\n\nAutomated reasoning goes back to the early inventors of computers. And logic itself (which automated reasoning attempts to solve) is thousands of years old. In order to keep this post brief, I’ll stop here and suggest further reading. Note that it’s very easy to get lost in the weeds reading depth-first into this area, and you could emerge more confused than when you started. I encourage you to use a bounded depth-first search approach, looking sequentially at a wide variety of tools and techniques in only some detail and then moving on, rather than learning only one aspect deeply.\n\nSuggested books:\n\nHandbook of Practical Logic and Automated Reasoning\n\nTemporal Verification of Reactive Systems\n\nDecision Procedures\n\nModel Checking\n\nSoftware Foundations\n\nSpecifying Systems\n\nIntroduction to Static Analysis\n\nLogic in Computer Science: Modelling and Reasoning about Systems\n\nFunctional Algorithms, Verified!\n\nHandbook of Satisfiability\n\nThe Calculus of Computation\n\nInternational conferences/workshops:\n\nhttps://etaps.org/2020/tacas\n\nhttp://i-cav.org/2020/\n\nhttps://ijcar2020.org/\n\nhttps://popl21.sigplan.org/\n\nhttps://sat2020.idea-researchlab.org/\n\nhttp://smt-workshop.cs.uiowa.edu/\n\nTool competitions:\n\nhttp://termination-portal.org/wiki/Termination_Competition\n\nhttps://sv-comp.sosy-lab.org/2020/\n\nhttps://smt-comp.github.io/2020/\n\nhttp://www.satcompetition.org/\n\nhttp://www.tptp.org/CASC/27/\n\nSome tools:\n\nAGREE: http://loonwerks.com/tools/agree.html\n\nAlloy: https://alloytools.org/\n\nAprove: https://aprove.informatik.rwth-aachen.de/\n\nBioModelAnalzyer: https://biomodelanalyzer.com/\n\nBoogie: https://github.com/boogie-org/boogie.git\n\nCBMC: https://www.cprover.org/cbmc/\n\nChecked C: https://plum-umd.github.io/projects/checkedc.html\n\nChecker Framework: https://checkerframework.org/\n\nCoCoSim: https://github.com/NASA-SW-VnV/CoCoSim\n\nCoq: https://coq.inria.fr/\n\nCPA Checker: https://cpachecker.sosy-lab.org/\n\nCVC4: https://cvc4.github.io/\n\nDafny: https://github.com/dafny-lang/dafny\n\nDreal: https://github.com/dreal/dreal4\n\nHOL light: https://www.cl.cam.ac.uk/~jrh13/hol-light/\n\nInfer: https://fbinfer.com\n\nIris: https://iris-project.org/\n\nIsabelle: https://isabelle.in.tum.de/\n\nJava PathFinder: https://github.com/javapathfinder\n\nJKind: https://github.com/loonwerks/jkind\n\nKeymaera X: https://keymaerax.org/\n\nKind2: https://kind2-mc.github.io/kind2\n\nKLEE: https://klee.github.io\n\nLean: https://leanprover.github.io/\n\nMiniSat: http://minisat.se/\n\nNagini: https://github.com/marcoeilers/nagini\n\nP: https://github.com/p-org/P\n\nPRISM:https://www.prismmodelchecker.org\n\nPVS: https://pvs.csl.sri.com\n\nRosette: http://emina.github.io/rosette/\n\nRust programming language: https://www.rust-lang.org/ [When you are programming in Rust you are essentially proving the absence of memory corruption in a type system (assuming you're not using \"unsafe\" regions)]\n\nSally: https://github.com/SRI-CSL/sally\n\nSAW: https://saw.galois.com/\n\nSeaHorn: http://seahorn.github.io/\n\nSMACK: https://smackers.github.io\n\nSoot: http://soot-oss.github.io/soot/\n\nSPIN: http://spinroot.com/spin/whatispin.html\n\nT2: https://mmjb.github.io/T2/\n\nTLA+: https://lamport.azurewebsites.net/tla/tla.html\n\nVampire: https://vprover.github.io/\n\nVCC: https://github.com/microsoft/vcc\n\nVerifast: https://github.com/verifast/verifast\n\nZ3: https://github.com/Z3Prover/z3\n\nInterviews of Amazon staff about their use of automated reasoning:\n\nByron Cook PLDI'20 Ask Me Anything\n\nByron Cook on The CUBE\n\nNeha Rungta on The CUBE\n\nNeha Rungta discusses constraint-based reasoning tools in AWS Config Rules\n\nSerdar Tasiran CAV'21 Ask Me Anything\n\nLogMeIn: How LogMeIn Automates Governance and Empowers Developers at Scale\n\nAWS Lectures aimed at customers and industry:\n\nAutomating Compliance Verification on AWS Using Provable Security, lecture with AWS VP of compliance Chad Woolf, and compliance auditor Coalfire's CEO Tom McAndrew\n\nAn AWS Approach to Higher Standards of Assurance w/ Provable Security, Byron Cook\n\nDive Deep into IAM Access Analyze, lecture by Andrew Gacek and others\n\nThe Evolution of automated reasoning Technology at AWS, lecture with AWS VP of security Eric Brandwine\n\nLecture by AWS CISO and VP of security Steve Schmidt about on the development and use of formal/constraint-based tools in AWS\n\nRe:Invent Keynote, lecture by CTO Werner Vogels\n\nAWS talks aimed at the automated-reasoning science community:\n\nDebugging Network Reachability with Blocked Paths, CAV'21\n\nEmbedded World 2021: Formally Verifying the FreeRTOS IPC Mechanism, Embedded World '21\n\nFormal reasoning about the security of Amazon Web Services, FLoC 2018 plenary lecture\n\nFormal reasoning about the security of Amazon Web Services, OOPSLA/SPLASH 2018 keynote lecture\n\nHow I learned to stop worrying and start applying automated reasoning, FACC'21 (other relevant talks at FACC website)\n\nOn automated reasoning for compliance certification, CAV workshop on Formal Approaches to Certifying Compliance (FACC)\n\nPre-Deployment Security Assessment for Cloud Services through Semantic Reasoning, CAV'21\n\nProvable Security at AWS, USENIX Enigma 2019\n\n[Skip to 30mins in]: SideTrail: Verifying Time-Balancing of Cryptosystems\n\nStratified abstraction of access control policies, CAV'20\n\nVerified Cryptographic Code for Everybody, CAV'21\n\nWhat is automated reasoning? How Is it Used at AWS?\n\nAWS blog posts and informational videos:\n\nA simpler way to assess the network exposure of EC2 instances: AWS releases new network reachability assessments in Amazon Inspector\n\nAWS CTO blogs about automated reasoning Group: Proving security at scale with automated reasoning\n\nAWS CTO discusses S3 consistency\n\nAWS Podcast interview: Provable security podcast: Byron interviews Moshe Vardi\n\nAWS Podcast interview: Next Generation Security with automated reasoning, an Artificial Intelligence Technology\n\nBlog post about event-driven checks in AWS Config powered by automated constraint solving techniques over IAM policies [attend this session at NY summit] ... and more detail\n\nBlog post on the use of constraint-based reasoning about policies in the Amazon Web Services S3 console\n\nBlogs 1, 2, and 3 about work with Galois to prove the correctness of Amazon's crypto infrastructure component s2n\n\nChad Wolff (VP of compliance at AWS) discusses his interest in using automated reasoning to simplify and raise the bar on compliance certification\n\nDaniel Schwartz-Narbonne shares how automated reasoning is helping achieve the provable security of AWS boot code\n\nHow automated reasoning helps us innovate at S3 scale\n\nHow automated reasoning improves Prime Vdeo experience\n\nHow AWS SideTrail verifies key AWS cryptography code\n\nHow AWS uses automated reasoning to help you achieve security at scale\n\nJeff Barr about tools for IoT configuration verification\n\nOn VPC Reachablity Analyzer\n\nNew (Zelkova-based) AWS Config rules s3-blacklisted-actions-prohibited and bucket-policy-not-more-permissive are released\n\nPodcast: AI tech named automated reasoning provides next-gen cloud security\n\nSome detail about constraint-based IAM policy analysis used in Amazon Macie can be found here\n\nTightening application security with Amazon CodeGuru\n\nUsing Formal Methods to validate OTA Protocol\n\n... more AWS blogs\n\nSome course notes by Amazon Scholars who are also university professors:\n\nhttps://courses.cs.washington.edu/courses/cse507/21au/\n\nhttp://www.cs.cmu.edu/~mheule/15816-f21/\n\nhttps://www.cs.cmu.edu/~mheule/15217-f21/\n\nA fun deep track:"
    }
}