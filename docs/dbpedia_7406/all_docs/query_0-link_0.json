{
    "id": "dbpedia_7406_0",
    "rank": 0,
    "data": {
        "url": "https://en.wikipedia.org/wiki/P4_(programming_language)",
        "read_more_link": "",
        "language": "en",
        "title": "P4 (programming language)",
        "top_image": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "meta_img": "https://en.wikipedia.org/static/favicon/wikipedia.ico",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/b/b4/Ambox_important.svg/40px-Ambox_important.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a4/Text_document_with_red_question_mark.svg/40px-Text_document_with_red_question_mark.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2015-04-08T01:13:33+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/P4_(programming_language)",
        "text": "Language for controlling network data forwarding\n\nP4Paradigmcompiled, domain-specific, imperativeDeveloperOpen Networking FoundationFirst appeared2013; 11 years ago ( )Stable release\n\nversion 1.2.2[1] / May 2021; 3 years ago ( )\n\nLicenseApache-styleFilename extensions.p4Websitep4 .org\n\nP4 is a programming language for controlling packet forwarding planes in networking devices, such as routers and switches. In contrast to a general purpose language such as C or Python, P4 is a domain-specific language with a number of constructs optimized for network data forwarding. P4 is distributed as open-source, permissively licensed code, and is maintained by the P4 Project (formerly the P4 Language Consortium), a not-for-profit organization hosted by the Open Networking Foundation.\n\nHistory\n\n[edit]\n\nP4 was originally described in a 2014 SIGCOMM CCR paper titled “Programming Protocol-Independent Packet Processors”[2]—the alliterative name shortens to \"P4\". The first P4 workshop took place in June 2015 at Stanford University.[3] An updated specification of P4, called P4-16, was released between 2016 and 2017,[4] replacing P4-14, the original specification of P4.\n\nDesign\n\n[edit]\n\nAs the language is specifically targeted at packet forwarding applications, the list of requirements or design choices is somewhat specific to those use cases. The language is designed to meet several goals:\n\nTarget independence\n\n[edit]\n\nP4 programs are designed to be implementation-independent: they can be compiled against many different types of execution machines such as general-purpose CPUs, FPGAs, system(s)-on-chip, network processors, and ASICs. These different types of machines are known as P4 targets, and each target must be provided along with a compiler that maps the P4 source code into a target switch model. The compiler may be embedded in the target device, an externally running software, or even a cloud service. As many of the initial targets for P4 programs were used for simple packet switching it is very common to hear the term \"P4 switch\" used, even though \"P4 target\" is more formally correct.\n\nProtocol independence\n\n[edit]\n\nP4 is designed to be protocol-independent: the language has no native support for even common protocols such as IP, Ethernet, TCP, VxLAN, or MPLS. Instead, the P4 programmer describes the header formats and field names of the required protocols in the program, which are in turn interpreted and processed by the compiled program and target device.\n\nReconfigurability\n\n[edit]\n\nProtocol independence and the abstract language model allow for reconfigurability–P4 targets should be able to change the way they process packets (perhaps multiple times) after they are deployed. This capability is traditionally associated with forwarding planes built on general-purpose CPUs or network processors, rather than the fixed function ASICs. Although within the language there is nothing to prevent a given target from optimizing around a certain set of protocols, these optimizations are invisible to the language author and may ultimately reduce the system's flexibility and reconfigurability goals.\n\nComponents\n\n[edit]\n\nP4 programs typically have the following components:\n\nParsing logic\n\n[edit]\n\nP4 allows the specification of custom packet header parsing logic[4] including but not limited to parsing typical headers used in the TCP/IP protocol suite and application specific headers.\n\nHeaders\n\n[edit]\n\nHeader definitions describe packet formats and provide names for the fields within the packet. The language allows customized header names and fields of arbitrary length, although many header definitions use widely known protocol names and fields widths. For example, an 802.3 Ethernet header definition might be called “Ethernet” and consist of a 48-bit field named “dest” followed by a 48-bit “src” field, followed by a 16-bit “type” field. The names in a header definition are used later in the P4 program to reference these fields.\n\nParsers\n\n[edit]\n\nThe P4 parser is a finite state machine that walks an incoming byte-stream and extracts headers based on the programmed parse graph. A simple example would be a parser that extracts the Ethernet source and destination and type fields, then performs a further extraction based on the value in the type field (common values might be ipv4, ipv6, or MPLS).\n\nStateful processing\n\n[edit]\n\nP4 allows the programmer to maintain state in the form of registers, counters and meters.[4]\n\nGeneric match action tables\n\n[edit]\n\nThe primary component of a P4 program is a set of user-defined match action tables. P4 treats all match action tables as generic, leaving the user to add their match-action rules via the control plane.[4]\n\nMatch-action processing\n\n[edit]\n\nFundamental to P4 is the concept of match-action pipelines. Conceptually, forwarding network packets or frames can be broken down into a series of table lookups and corresponding header manipulations. In P4 these manipulations are known as actions and generally consist of things such as copying byte fields from one location to another based on the lookup results on learned forwarding state. P4 addresses only the data plane of a packet forwarding device. It does not specify the control plane nor any exact protocol for communicating state between the control and data planes. Instead, P4 uses the concept of tables to represent forwarding plane state. An interface between the control plane and the various P4 tables must be provided to allow the control plane to inject/modify state in the program. This interface is generally referred to as the program API.\n\nTables\n\n[edit]\n\nP4 tables contain the state used to forward packets. Tables are composed of lookup keys and a corresponding set of actions and their parameters. A trivial example might be to store a set of destination MAC addresses as the lookup keys, and the corresponding action could set the output port on the device, and/or increment a counter. Tables and their associated actions are almost always chained together in sequence to realize the full packet forwarding logic, although in the abstract it is possible to build a single table that includes all the lookup key information and the full output action set.\n\nActions\n\n[edit]\n\nActions in P4 describe packet field and metadata manipulations. In P4 context, metadata is information about a packet that is not directly derived from the parser, such as the input interface that the frame arrived on. English descriptions of an example action might be \"decrement the IPv4 TTL field by one\" or \"copy the MAC address from the output port table into the outgoing packet header.\"[5] P4 defines both standard metadata that must be provided by all targets as well as target-specific metadata, which is provided by the author of specific targets.\n\nControl flow\n\n[edit]\n\nThe control flow in P4 determines the relative sequence of tables, and allows for conditional execution of tables based on if/then/else constructions.\n\nReferences\n\n[edit]"
    }
}