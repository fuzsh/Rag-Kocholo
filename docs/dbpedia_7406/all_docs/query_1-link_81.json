{
    "id": "dbpedia_7406_1",
    "rank": 81,
    "data": {
        "url": "https://docs.redhat.com/en/documentation/red_hat_process_automation_manager/7.5/html-single/designing_a_decision_service_using_drl_rules/index",
        "read_more_link": "",
        "language": "en",
        "title": "Designing a decision service using DRL rules",
        "top_image": "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/edd90a9d5f43163dfca87f1c10f636a7/RuleEvaluation_Enterprise.png",
        "meta_img": "",
        "images": [
            "https://docs.redhat.com/Logo-Red_Hat-Documentation-A-Reverse-RGB.svg",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/bcd24b777caedcaaaeacd7ba70b472a5/error_message.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/3aeb568d81bf454a4763f281a5c4b0aa/DataModelerNewField2-new.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/4f75f63244bb3b8fc9f5f89d5ceb19c6/drl-rules-sample.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/67d2c91aa261066c3285def787129aa6/drools-examples-run-all.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/a83f3bebf6f880e8644183e6e4d133ad/droolsjbpm-examples-run-all.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/6ace17436b7d529610d3d755bc76b7e8/helloworld_auditview1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/edd90a9d5f43163dfca87f1c10f636a7/RuleEvaluation_Enterprise.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/fd9d15b5ff21d462d7271c986c33ab7d/state_example_audit1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/dc13faa1a1fcd6fa98d4cc438e50eea7/state_example_agenda1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/af7790dbc8de46a064d98b4fa6b088ca/fibonacci1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/16a92c370e942cb0c67a9828a174cffd/fibonacci_agenda1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/0a48811fa60f0c5bb1d9b60b77d5ce68/fibonacci_agenda2.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/0fa42fbf60d23aef32aaa164fd59b526/fibonacci4.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/b2a67d849f467c24f92135156ea44298/DT_Config.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/7dd0782f29ae96dcb683c32e4cdbcb67/DT_Table1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/faa293aa94d87f847c0e884fe7ddafc2/DT_Table2.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/89828e62d26988abd38ff5d7e24ddcae/1-PetStore-Start-Screen.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/e6ac8c9b13ac9d20f78932cd139022e9/2-stock-added-to-order-list.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/2a3b26c2368f5869db815f4acba256c4/3-purchase-suggestion.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/9cf22c5c33a33df8974244861742a57c/4-Petstore-final-screen.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/4b024c91100422e146bc24d4e0fad3ec/honest_politician_audit.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/8399efad412d5ecfe852aed410d3c7e8/sudoku1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/367dfeba5b77ad7089dc794513b60381/sudoku2.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/4e8ac19faebc58900ca2b845d0a6a22e/sudoku3.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/b7b3d849502012d7d5287df1a4fb6034/sudoku4.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/7e1dd1cfa0153ac88b5242e4c23e089c/sudoku5.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/b891d6c40e0db39f4ed58805d1889ad7/conway1.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/0543a67ffc6b8644d189a74faa40ddf8/conway2.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/5c157956f70b1d1443d9bf5b097d782c/conway_ruleflow_generation.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/edd90a9d5f43163dfca87f1c10f636a7/RuleEvaluation_Enterprise.png",
            "https://access.redhat.com/webassets/avalon/d/Red_Hat_Process_Automation_Manager-7.5-Designing_a_decision_service_using_DRL_rules-en-US/images/c40277b42819c07fdfb0b6ca916855d0/TransitiveReasoning_Enterprise.png",
            "https://docs.redhat.com/Logo-Red_Hat-Documentation-A-Reverse-RGB.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Designing a decision service using DRL rules | Red Hat Documentation",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://docs.redhat.com/en/documentation/red_hat_process_automation_manager/7.5/html-single/designing_a_decision_service_using_drl_rules/index",
        "text": "download PDF\n\nRed Hat Process Automation Manager 7.5\n\nRed Hat Customer Content Services\n\nbrms-docs@redhat.com\n\nAbstract\n\nThis document describes how to design a decision service using DRL rules in Red Hat Process Automation Manager 7.5.\n\nPreface\n\nAs a business rules developer, you can define business rules using the DRL (Drools Rule Language) designer in Business Central. DRL rules are defined directly in free-form .drl text files instead of in a guided or tabular format like other types of rule assets in Business Central. These DRL files form the core of the decision service for your project.\n\nNote\n\nYou can also design your decision service using Decision Model and Notation (DMN) models instead of rule-based or table-based assets. For information about DMN support in Red Hat Process Automation Manager 7.5, see the following resources:\n\nGetting started with decision services (step-by-step tutorial with a DMN decision service example)\n\nDesigning a decision service using DMN models (overview of DMN support and capabilities in Red Hat Process Automation Manager)\n\nPrerequisites\n\nThe space and project for the DRL rules have been created in Business Central. Each asset is associated with a project assigned to a space. For details, see Getting started with decision services.\n\nChapter 1. Decision-authoring assets in Red Hat Process Automation Manager\n\nRed Hat Process Automation Manager supports several assets that you can use to define business decisions for your decision service. Each decision-authoring asset has different advantages, and you might prefer to use one or a combination of multiple assets depending on your goals and needs.\n\nThe following table highlights the main decision-authoring assets supported in Red Hat Process Automation Manager projects to help you decide or confirm the best method for defining decisions in your decision service.\n\nTable 1.1. Decision-authoring assets supported in Red Hat Process Automation ManagerAssetHighlightsAuthoring toolsDocumentation\n\nDecision Model and Notation (DMN) models\n\nAre decision models based on a notation standard defined by the Object Management Group (OMG)\n\nUse graphical decision requirements diagrams (DRDs) with one or more decision requirements graphs (DRGs) to trace business decision flows\n\nUse an XML schema that allows the DMN models to be shared between DMN-compliant platforms\n\nSupport Friendly Enough Expression Language (FEEL) to define decision logic in DMN decision tables and other DMN boxed expressions\n\nCan be integrated efficiently with Business Process Model and Notation (BPMN) process models\n\nAre optimal for creating comprehensive, illustrative, and stable decision flows\n\nBusiness Central or other DMN-compliant editor\n\nDesigning a decision service using DMN models\n\nGuided decision tables\n\nAre tables of rules that you create in a UI-based table designer in Business Central\n\nAre a wizard-led alternative to spreadsheet decision tables\n\nProvide fields and options for acceptable input\n\nSupport template keys and values for creating rule templates\n\nSupport hit policies, real-time validation, and other additional features not supported in other assets\n\nAre optimal for creating rules in a controlled tabular format to minimize compilation errors\n\nBusiness Central\n\nDesigning a decision service using guided decision tables\n\nSpreadsheet decision tables\n\nAre XLS or XLSX spreadsheet decision tables that you can upload into Business Central\n\nSupport template keys and values for creating rule templates\n\nAre optimal for creating rules in decision tables already managed outside of Business Central\n\nHave strict syntax requirements for rules to be compiled properly when uploaded\n\nSpreadsheet editor\n\nDesigning a decision service using spreadsheet decision tables\n\nGuided rules\n\nAre individual rules that you create in a UI-based rule designer in Business Central\n\nProvide fields and options for acceptable input\n\nAre optimal for creating single rules in a controlled format to minimize compilation errors\n\nBusiness Central\n\nDesigning a decision service using guided rules\n\nGuided rule templates\n\nAre reusable rule structures that you create in a UI-based template designer in Business Central\n\nProvide fields and options for acceptable input\n\nSupport template keys and values for creating rule templates (fundamental to the purpose of this asset)\n\nAre optimal for creating many rules with the same rule structure but with different defined field values\n\nBusiness Central\n\nDesigning a decision service using guided rule templates\n\nDRL rules\n\nAre individual rules that you define directly in .drl text files\n\nProvide the most flexibility for defining rules and other technicalities of rule behavior\n\nCan be created in certain standalone environments and integrated with Red Hat Process Automation Manager\n\nAre optimal for creating rules that require advanced DRL options\n\nHave strict syntax requirements for rules to be compiled properly\n\nBusiness Central or integrated development environment (IDE)\n\nDesigning a decision service using DRL rules\n\nPredictive Model Markup Language (PMML) models\n\nAre predictive data-analytic models based on a notation standard defined by the Data Mining Group (DMG)\n\nUse an XML schema that allows the PMML models to be shared between PMML-compliant platforms\n\nSupport Regression, Scorecard, Tree, Mining, and other model types\n\nCan be included with a standalone Red Hat Process Automation Manager project or imported into a project in Business Central\n\nAre optimal for incorporating predictive data into decision services in Red Hat Process Automation Manager\n\nPMML or XML editor\n\nDesigning a decision service using PMML models\n\nChapter 2. DRL (Drools Rule Language) rules\n\nDRL (Drools Rule Language) rules are business rules that you define directly in .drl text files. These DRL files are the source in which all other rule assets in Business Central are ultimately rendered. You can create and manage DRL files within the Business Central interface, or create them externally as part of a Maven or Java project using Red Hat CodeReady Studio or another integrated development environment (IDE). A DRL file can contain one or more rules that define at a minimum the rule conditions (when) and actions (then). The DRL designer in Business Central provides syntax highlighting for Java, DRL, and XML.\n\nDRL files consist of the following components:\n\nComponents in a DRL file\n\npackage import function // Optional query // Optional declare // Optional global // Optional rule \"rule name\" // Attributes when // Conditions then // Actions end rule \"rule2 name\" ...\n\nThe following example DRL rule determines the age limit in a loan application decision service:\n\nExample rule for loan application age limit\n\nrule \"Underage\" salience 15 agenda-group \"applicationGroup\" when $application : LoanApplication() Applicant( age < 21 ) then $application.setApproved( false ); $application.setExplanation( \"Underage\" ); end\n\nA DRL file can contain single or multiple rules, queries, and functions, and can define resource declarations such as imports, globals, and attributes that are assigned and used by your rules and queries. The DRL package must be listed at the top of a DRL file and the rules are typically listed last. All other DRL components can follow any order.\n\nEach rule must have a unique name within the rule package. If you use the same rule name more than once in any DRL file in the package, the rules fail to compile. Always enclose rule names with double quotation marks (rule \"rule name\") to prevent possible compilation errors, especially if you use spaces in rule names.\n\nAll data objects related to a DRL rule must be in the same project package as the DRL file in Business Central. Assets in the same package are imported by default. Existing assets in other packages can be imported with the DRL rule.\n\n2.1. Packages in DRL\n\nA package is a folder of related assets in Red Hat Process Automation Manager, such as data objects, DRL files, decision tables, and other asset types. A package also serves as a unique namespace for each group of rules. A single rule base can contain multiple packages. You typically store all the rules for a package in the same file as the package declaration so that the package is self-contained. However, you can import objects from other packages that you want to use in the rules.\n\nThe following example is a package name and namespace for a DRL file in a mortgage application decision service:\n\nExample package definition in a DRL file\n\npackage org.mortgages;\n\n2.2. Import statements in DRL\n\nSimilar to import statements in Java, imports in DRL files identify the fully qualified paths and type names for any objects that you want to use in the rules. You specify the package and data object in the format packageName.objectName, with multiple imports on separate lines. The decision engine automatically imports classes from the Java package with the same name as the DRL package and from the package java.lang.\n\nThe following example is an import statement for a loan application object in a mortgage application decision service:\n\nExample import statement in a DRL file\n\nimport org.mortgages.LoanApplication;\n\n2.3. Functions in DRL\n\nFunctions in DRL files put semantic code in your rule source file instead of in Java classes. Functions are especially useful if an action (then) part of a rule is used repeatedly and only the parameters differ for each rule. Above the rules in the DRL file, you can declare the function or import a static method from a helper class as a function, and then use the function by name in an action (then) part of the rule.\n\nThe following examples illustrate a function that is either declared or imported in a DRL file:\n\nExample function declaration with a rule (option 1)\n\nfunction String hello(String applicantName) { return \"Hello \" + applicantName + \"!\"; } rule \"Using a function\" when // Empty then System.out.println( hello( \"James\" ) ); end\n\nExample function import with a rule (option 2)\n\nimport function my.package.applicant.hello; rule \"Using a function\" when // Empty then System.out.println( hello( \"James\" ) ); end\n\n2.4. Queries in DRL\n\nQueries in DRL files search the working memory of the decision engine for facts related to the rules in the DRL file. You add the query definitions in DRL files and then obtain the matching results in your application code. Queries search for a set of defined conditions and do not require when or then specifications. Query names are global to the KIE base and therefore must be unique among all other rule queries in the project. To return the results of a query, you construct a QueryResults definition using ksession.getQueryResults(\"name\"), where \"name\" is the query name. This returns a list of query results, which enable you to retrieve the objects that matched the query. You define the query and query results parameters above the rules in the DRL file.\n\nThe following example is a query definition in a DRL file for underage applicants in a mortgage application decision service, with the accompanying application code:\n\nExample query definition in a DRL file\n\nquery \"people under the age of 21\" $person : Person( age < 21 ) end\n\nExample application code to obtain query results\n\nQueryResults results = ksession.getQueryResults( \"people under the age of 21\" ); System.out.println( \"we have \" + results.size() + \" people under the age of 21\" );\n\nYou can also iterate over the returned QueryResults using a standard for loop. Each element is a QueryResultsRow that you can use to access each of the columns in the tuple.\n\nExample application code to obtain and iterate over query results\n\nQueryResults results = ksession.getQueryResults( \"people under the age of 21\" ); System.out.println( \"we have \" + results.size() + \" people under the age of 21\" ); System.out.println( \"These people are under the age of 21:\" ); for ( QueryResultsRow row : results ) { Person person = ( Person ) row.get( \"person\" ); System.out.println( person.getName() + \"\\n\" ); }\n\n2.5. Type declarations and metadata in DRL\n\nDeclarations in DRL files define new fact types or metadata for fact types to be used by rules in the DRL file:\n\nNew fact types: The default fact type in the java.lang package of Red Hat Process Automation Manager is Object, but you can declare other types in DRL files as needed. Declaring fact types in DRL files enables you to define a new fact model directly in the decision engine, without creating models in a lower-level language like Java. You can also declare a new type when a domain model is already built and you want to complement this model with additional entities that are used mainly during the reasoning process.\n\nMetadata for fact types: You can associate metadata in the format @key(value) with new or existing facts. Metadata can be any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. The metadata can be queried at run time by the decision engine and used in the reasoning process.\n\n2.5.1. Type declarations without metadata in DRL\n\nA declaration of a new fact does not require any metadata, but must include a list of attributes or fields. If a type declaration does not include identifying attributes, the decision engine searches for an existing fact class in the classpath and raises an error if the class is missing.\n\nThe following example is a declaration of a new fact type Person with no metadata in a DRL file:\n\nExample declaration of a new fact type with a rule\n\ndeclare Person name : String dateOfBirth : java.util.Date address : Address end rule \"Using a declared type\" when $p : Person( name == \"James\" ) then // Insert Mark, who is a customer of James. Person mark = new Person(); mark.setName( \"Mark\" ); insert( mark ); end\n\nIn this example, the new fact type Person has the three attributes name, dateOfBirth, and address. Each attribute has a type that can be any valid Java type, including another class that you create or a fact type that you previously declared. The dateOfBirth attribute has the type java.util.Date, from the Java API, and the address attribute has the previously defined fact type Address.\n\nTo avoid writing the fully qualified name of a class every time you declare it, you can define the full class name as part of the import clause:\n\nExample type declaration with the fully qualified class name in the import\n\nimport java.util.Date declare Person name : String dateOfBirth : Date address : Address end\n\nWhen you declare a new fact type, the decision engine generates at compile time a Java class representing the fact type. The generated Java class is a one-to-one JavaBeans mapping of the type definition.\n\nFor example, the following Java class is generated from the example Person type declaration:\n\nGenerated Java class for the Person fact type declaration\n\npublic class Person implements Serializable { private String name; private java.util.Date dateOfBirth; private Address address; // Empty constructor public Person() {...} // Constructor with all fields public Person( String name, Date dateOfBirth, Address address ) {...} // If keys are defined, constructor with keys public Person( ...keys... ) {...} // Getters and setters // `equals` and `hashCode` // `toString` }\n\nYou can then use the generated class in your rules like any other fact, as illustrated in the previous rule example with the Person type declaration:\n\nExample rule that uses the declared Person fact type\n\nrule \"Using a declared type\" when $p : Person( name == \"James\" ) then // Insert Mark, who is a customer of James. Person mark = new Person(); mark.setName( \"Mark\" ); insert( mark ); end\n\n2.5.2. Enumerative type declarations in DRL\n\nDRL supports the declaration of enumerative types in the format declare enum <factType>, followed by a comma-separated list of values ending with a semicolon. You can then use the enumerative list in the rules in the DRL file.\n\nFor example, the following enumerative type declaration defines days of the week for an employee scheduling rule:\n\nExample enumerative type declaration with a scheduling rule\n\ndeclare enum DaysOfWeek SUN(\"Sunday\"),MON(\"Monday\"),TUE(\"Tuesday\"),WED(\"Wednesday\"),THU(\"Thursday\"),FRI(\"Friday\"),SAT(\"Saturday\"); fullName : String end rule \"Using a declared Enum\" when $emp : Employee( dayOff == DaysOfWeek.MONDAY ) then ... end\n\n2.5.3. Extended type declarations in DRL\n\nDRL supports type declaration inheritance in the format declare <factType1> extends <factType2>. To extend a type declared in Java by a subtype declared in DRL, you repeat the parent type in a declaration statement without any fields.\n\nFor example, the following type declarations extend a Student type from a top-level Person type, and a LongTermStudent type from the Student subtype:\n\nExample extended type declarations\n\nimport org.people.Person declare Person end declare Student extends Person school : String end declare LongTermStudent extends Student years : int course : String end\n\n2.5.4. Type declarations with metadata in DRL\n\nYou can associate metadata in the format @key(value) (the value is optional) with fact types or fact attributes. Metadata can be any kind of data that is not represented by the fact attributes and is consistent among all instances of that fact type. The metadata can be queried at run time by the decision engine and used in the reasoning process. Any metadata that you declare before the attributes of a fact type are assigned to the fact type, while metadata that you declare after an attribute are assigned to that particular attribute.\n\nIn the following example, the two metadata attributes @author and @dateOfCreation are declared for the Person fact type, and the two metadata items @key and @maxLength are declared for the name attribute. The @key metadata attribute has no required value, so the parentheses and the value are omitted.\n\nExample metadata declaration for fact types and attributes\n\nimport java.util.Date declare Person @author( Bob ) @dateOfCreation( 01-Feb-2009 ) name : String @key @maxLength( 30 ) dateOfBirth : Date address : Address end\n\nFor declarations of metadata attributes for existing types, you can identify the fully qualified class name as part of the import clause for all declarations or as part of the individual declare clause:\n\nExample metadata declaration for an imported type\n\nimport org.drools.examples.Person declare Person @author( Bob ) @dateOfCreation( 01-Feb-2009 ) end\n\nExample metadata declaration for a declared type\n\ndeclare org.drools.examples.Person @author( Bob ) @dateOfCreation( 01-Feb-2009 ) end\n\n2.5.6. Property-change settings and listeners for fact types\n\nBy default, the decision engine does not re-evaluate all fact patterns for fact types each time a rule is triggered, but instead reacts only to modified properties that are constrained or bound inside a given pattern. For example, if a rule calls modify() as part of the rule actions but the action does not generate new data in the KIE base, the decision engine does not automatically re-evaluate all fact patterns because no data was modified. This property reactivity behavior prevents unwanted recursions in the KIE base and results in more efficient rule evaluation. This behavior also means that you do not always need to use the no-loop rule attribute to avoid infinite recursion.\n\nYou can modify or disable this property reactivity behavior with the following KnowledgeBuilderConfiguration options, and then use a property-change setting in your Java class or DRL files to fine-tune property reactivity as needed:\n\nALWAYS: (Default) All types are property reactive, but you can disable property reactivity for a specific type by using the @classReactive property-change setting.\n\nALLOWED: No types are property reactive, but you can enable property reactivity for a specific type by using the @propertyReactive property-change setting.\n\nDISABLED: No types are property reactive. All property-change listeners are ignored.\n\nExample property reactivity setting in KnowledgeBuilderConfiguration\n\nKnowledgeBuilderConfiguration config = KnowledgeBuilderFactory.newKnowledgeBuilderConfiguration(); config.setOption(PropertySpecificOption.ALLOWED); KnowledgeBuilder kbuilder = KnowledgeBuilderFactory.newKnowledgeBuilder(config);\n\nAlternatively, you can update the drools.propertySpecific system property in the standalone.xml file of your Red Hat Process Automation Manager distribution:\n\nExample property reactivity setting in system properties\n\n<system-properties> ... <property name=\"drools.propertySpecific\" value=\"ALLOWED\"/> ... </system-properties>\n\nThe decision engine supports the following property-change settings and listeners for fact classes or declared DRL fact types:\n\n@classReactive\n\nIf property reactivity is set to ALWAYS in the decision engine (all types are property reactive), this tag disables the default property reactivity behavior for a specific Java class or a declared DRL fact type. You can use this tag if you want the decision engine to re-evaluate all fact patterns for the specified fact type each time the rule is triggered, instead of reacting only to modified properties that are constrained or bound inside a given pattern.\n\nExample: Disable default property reactivity in a DRL type declaration\n\ndeclare Person @classReactive firstName : String lastName : String end\n\nExample: Disable default property reactivity in a Java class\n\n@classReactive public static class Person { private String firstName; private String lastName; }\n\n@propertyReactive\n\nIf property reactivity is set to ALLOWED in the decision engine (no types are property reactive unless specified), this tag enables property reactivity for a specific Java class or a declared DRL fact type. You can use this tag if you want the decision engine to react only to modified properties that are constrained or bound inside a given pattern for the specified fact type, instead of re-evaluating all fact patterns for the fact each time the rule is triggered.\n\nExample: Enable property reactivity in a DRL type declaration (when reactivity is disabled globally)\n\ndeclare Person @propertyReactive firstName : String lastName : String end\n\nExample: Enable property reactivity in a Java class (when reactivity is disabled globally)\n\n@propertyReactive public static class Person { private String firstName; private String lastName; }\n\n@watch\n\nThis tag enables property reactivity for additional properties that you specify in-line in fact patterns in DRL rules. This tag is supported only if property reactivity is set to ALWAYS in the decision engine, or if property reactivity is set to ALLOWED and the relevant fact type uses the @propertyReactive tag. You can use this tag in DRL rules to add or exclude specific properties in fact property reactivity logic.\n\nDefault parameter: None\n\nSupported parameters: Property name, * (all), ! (not), !* (no properties)\n\n<factPattern> @watch ( <property> )\n\nExample: Enable or disable property reactivity in fact patterns\n\n// Listens for changes in both `firstName` (inferred) and `lastName`: Person(firstName == $expectedFirstName) @watch( lastName ) // Listens for changes in all properties of the `Person` fact: Person(firstName == $expectedFirstName) @watch( * ) // Listens for changes in `lastName` and explicitly excludes changes in `firstName`: Person(firstName == $expectedFirstName) @watch( lastName, !firstName ) // Listens for changes in all properties of the `Person` fact except `age`: Person(firstName == $expectedFirstName) @watch( *, !age ) // Excludes changes in all properties of the `Person` fact (equivalent to using `@classReactivity` tag): Person(firstName == $expectedFirstName) @watch( !* )\n\nThe decision engine generates a compilation error if you use the @watch tag for properties in a fact type that uses the @classReactive tag (disables property reactivity) or when property reactivity is set to ALLOWED in the decision engine and the relevant fact type does not use the @propertyReactive tag. Compilation errors also arise if you duplicate properties in listener annotations, such as @watch( firstName, ! firstName ).\n\n@propertyChangeSupport\n\nFor facts that implement support for property changes as defined in the JavaBeans Specification, this tag enables the decision engine to monitor changes in the fact properties.\n\nExample: Declare property change support in JavaBeans object\n\ndeclare Person @propertyChangeSupport end\n\n2.5.7. Access to DRL declared types in application code\n\nDeclared types in DRL are typically used within the DRL files while Java models are typically used when the model is shared between rules and applications. Because declared types are generated at KIE base compile time, an application cannot access them until application run time. In some cases, an application needs to access and handle facts directly from the declared types, especially when the application wraps the decision engine and provides higher-level, domain-specific user interfaces for rules management.\n\nTo handle declared types directly from the application code, you can use the org.drools.definition.type.FactType API in Red Hat Process Automation Manager. Through this API, you can instantiate, read, and write fields in the declared fact types.\n\nThe following example code modifies a Person fact type directly from an application:\n\nExample application code to handle a declared fact type through the FactType API\n\nimport java.util.Date; import org.kie.api.definition.type.FactType; import org.kie.api.KieBase; import org.kie.api.runtime.KieSession; ... // Get a reference to a KIE base with the declared type: KieBase kbase = ... // Get the declared fact type: FactType personType = kbase.getFactType(\"org.drools.examples\", \"Person\"); // Create instances: Object bob = personType.newInstance(); // Set attribute values: personType.set(bob, \"name\", \"Bob\" ); personType.set(bob, \"dateOfBirth\", new Date()); personType.set(bob, \"address\", new Address(\"King's Road\",\"London\",\"404\")); // Insert the fact into a KIE session: KieSession ksession = ... ksession.insert(bob); ksession.fireAllRules(); // Read attributes: String name = (String) personType.get(bob, \"name\"); Date date = (Date) personType.get(bob, \"dateOfBirth\");\n\nThe API also includes other helpful methods, such as setting all the attributes at once, reading values from a Map collection, or reading all attributes at once into a Map collection.\n\nAlthough the API behavior is similar to Java reflection, the API does not use reflection and relies on more performant accessors that are implemented with generated bytecode.\n\n2.6. Global variables in DRL\n\nGlobal variables in DRL files typically provide data or services for the rules, such as application services used in rule consequences, and return data from rules, such as logs or values added in rule consequences. You set the global value in the working memory of the decision engine through a KIE session configuration or REST operation, declare the global variable above the rules in the DRL file, and then use it in an action (then) part of the rule. For multiple global variables, use separate lines in the DRL file.\n\nThe following example illustrates a global variable list configuration for the decision engine and the corresponding global variable definition in the DRL file:\n\nExample global list configuration for the decision engine\n\nList<String> list = new ArrayList<>(); KieSession kieSession = kiebase.newKieSession(); kieSession.setGlobal( \"myGlobalList\", list );\n\nExample global variable definition with a rule\n\nglobal java.util.List myGlobalList; rule \"Using a global\" when // Empty then myGlobalList.add( \"My global list\" ); end\n\nWarning\n\nDo not use global variables to establish conditions in rules unless a global variable has a constant immutable value. Global variables are not inserted into the working memory of the decision engine, so the decision engine cannot track value changes of variables.\n\nDo not use global variables to share data between rules. Rules always reason and react to the working memory state, so if you want to pass data from rule to rule, assert the data as facts into the working memory of the decision engine.\n\nA use case for a global variable might be an instance of an email service. In your integration code that is calling the decision engine, you obtain your emailService object and then set it in the working memory of the decision engine. In the DRL file, you declare that you have a global of type emailService and give it the name \"email\", and then in your rule consequences, you can use actions such as email.sendSMS(number, message).\n\nIf you declare global variables with the same identifier in multiple packages, then you must set all the packages with the same type so that they all reference the same global value.\n\n2.7. Rule attributes in DRL\n\nRule attributes are additional specifications that you can add to business rules to modify rule behavior. In DRL files, you typically define rule attributes above the rule conditions and actions, with multiple attributes on separate lines, in the following format:\n\nrule \"rule_name\" // Attribute // Attribute when // Conditions then // Actions end\n\nThe following table lists the names and supported values of the attributes that you can assign to rules:\n\nTable 2.1. Rule attributesAttributeValue\n\n2.7.1. Timer and calendar rule attributes in DRL\n\nTimers and calendars are DRL rule attributes that enable you to apply scheduling and timing constraints to your DRL rules. These attributes require additional configurations depending on the use case.\n\nThe timer attribute in DRL rules is a string identifying either int (interval) or cron timer definitions for scheduling a rule and supports the following formats:\n\nTimer attribute formats\n\ntimer ( int: <initial delay> <repeat interval> ) timer ( cron: <cron expression> )\n\nExample interval timer attributes\n\n// Run after a 30-second delay timer ( int: 30s ) // Run every 5 minutes after a 30-second delay each time timer ( int: 30s 5m )\n\nExample cron timer attribute\n\n// Run every 15 minutes timer ( cron:* 0/15 * * * ? )\n\nInterval timers follow the semantics of java.util.Timer objects, with an initial delay and an optional repeat interval. Cron timers follow standard Unix cron expressions.\n\nThe following example DRL rule uses a cron timer to send an SMS text message every 15 minutes:\n\nExample DRL rule with a cron timer\n\nrule \"Send SMS message every 15 minutes\" timer ( cron:* 0/15 * * * ? ) when $a : Alarm( on == true ) then channels[ \"sms\" ].insert( new Sms( $a.mobileNumber, \"The alarm is still on.\" ); end\n\nGenerally, a rule that is controlled by a timer becomes active when the rule is triggered and the rule consequence is executed repeatedly, according to the timer settings. The execution stops when the rule condition no longer matches incoming facts. However, the way the decision engine handles rules with timers depends on whether the decision engine is in active mode or in passive mode.\n\nBy default, the decision engine runs in passive mode and evaluates rules, according to the defined timer settings, when a user or an application explicitly calls fireAllRules(). Conversely, if a user or application calls fireUntilHalt(), the decision engine starts in active mode and evaluates rules continually until the user or application explicitly calls halt().\n\nWhen the decision engine is in active mode, rule consequences are executed even after control returns from a call to fireUntilHalt() and the decision engine remains reactive to any changes made to the working memory. For example, removing a fact that was involved in triggering the timer rule execution causes the repeated execution to terminate, and inserting a fact so that some rule matches causes that rule to be executed. However, the decision engine is not continually active, but is active only after a rule is executed. Therefore, the decision engine does not react to asynchronous fact insertions until the next execution of a timer-controlled rule. Disposing a KIE session terminates all timer activity.\n\nWhen the decision engine is in passive mode, rule consequences of timed rules are evaluated only when fireAllRules() is invoked again. However, you can change the default timer-execution behavior in passive mode by configuring the KIE session with a TimedRuleExecutionOption option, as shown in the following example:\n\nKIE session configuration to automatically execute timed rules in passive mode\n\nKieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration(); ksconf.setOption( TimedRuleExecutionOption.YES ); KSession ksession = kbase.newKieSession(ksconf, null);\n\nYou can additionally set a FILTERED specification on the TimedRuleExecutionOption option that enables you to define a callback to filter those rules, as shown in the following example:\n\nKIE session configuration to filter which timed rules are automatically executed\n\nKieSessionConfiguration ksconf = KieServices.Factory.get().newKieSessionConfiguration(); conf.setOption( new TimedRuleExecutionOption.FILTERED(new TimedRuleExecutionFilter() { public boolean accept(Rule[] rules) { return rules[0].getName().equals(\"MyRule\"); } }) );\n\nFor interval timers, you can also use an expression timer with expr instead of int to define both the delay and interval as an expression instead of a fixed value.\n\nThe following example DRL file declares a fact type with a delay and period that are then used in the subsequent rule with an expression timer:\n\nExample rule with an expression timer\n\ndeclare Bean delay : String = \"30s\" period : long = 60000 end rule \"Expression timer\" timer ( expr: $d, $p ) when Bean( $d : delay, $p : period ) then // Actions end\n\nThe expressions, such as $d and $p in this example, can use any variable defined in the pattern-matching part of the rule. The variable can be any String value that can be parsed into a time duration or any numeric value that is internally converted in a long value for a duration in milliseconds.\n\nBoth interval and expression timers can use the following optional parameters:\n\nstart and end: A Date or a String representing a Date or a long value. The value can also be a Number that is transformed into a Java Date in the format new Date( ((Number) n).longValue() ).\n\nrepeat-limit: An integer that defines the maximum number of repetitions allowed by the timer. If both the end and the repeat-limit parameters are set, the timer stops when the first of the two is reached.\n\nExample timer attribute with optional start, end, and repeat-limit parameters\n\ntimer (int: 30s 1h; start=3-JAN-2020, end=4-JAN-2020, repeat-limit=50)\n\nIn this example, the rule is scheduled for every hour, after a delay of 30 seconds each hour, beginning on 3 January 2020 and ending either on 4 January 2020 or when the cycle repeats 50 times.\n\nIf the system is paused (for example, the session is serialized and then later deserialized), the rule is scheduled only one time to recover from missing activations regardless of how many activations were missed during the pause, and then the rule is subsequently scheduled again to continue in sync with the timer setting.\n\nThe calendar attribute in DRL rules is a Quartz calendar definition for scheduling a rule and supports the following format:\n\nCalendar attribute format\n\ncalendars \"<definition or registered name>\"\n\nExample calendar attributes\n\n// Exclude non-business hours calendars \"* * 0-7,18-23 ? * *\" // Weekdays only, as registered in the KIE session calendars \"weekday\"\n\nYou can adapt a Quartz calendar based on the Quartz calendar API and then register the calendar in the KIE session, as shown in the following example:\n\nAdapting a Quartz Calendar\n\nCalendar weekDayCal = QuartzHelper.quartzCalendarAdapter(org.quartz.Calendar quartzCal)\n\nRegistering the calendar in the KIE session\n\nksession.getCalendars().set( \"weekday\", weekDayCal );\n\nYou can use calendars with standard rules and with rules that use timers. The calendar attribute can contain one or more comma-separated calendar names written as String literals.\n\nThe following example rules use both calendars and timers to schedule the rules:\n\nExample rules with calendars and timers\n\nrule \"Weekdays are high priority\" calendars \"weekday\" timer ( int:0 1h ) when Alarm() then send( \"priority high - we have an alarm\" ); end rule \"Weekends are low priority\" calendars \"weekend\" timer ( int:0 4h ) when Alarm() then send( \"priority low - we have an alarm\" ); end\n\n2.8. Rule conditions in DRL (WHEN)\n\nThe when part of a DRL rule (also known as the Left Hand Side (LHS) of the rule) contains the conditions that must be met to execute an action. Conditions consist of a series of stated patterns and constraints, with optional bindings and supported rule condition elements (keywords), based on the available data objects in the package. For example, if a bank requires loan applicants to have over 21 years of age, then the when condition of an \"Underage\" rule would be Applicant( age < 21 ).\n\nNote\n\nDRL uses when instead of if because if is typically part of a procedural execution flow during which a condition is checked at a specific point in time. In contrast, when indicates that the condition evaluation is not limited to a specific evaluation sequence or point in time, but instead occurs continually at any time. Whenever the condition is met, the actions are executed.\n\nIf the when section is empty, then the conditions are considered to be true and the actions in the then section are executed the first time a fireAllRules() call is made in the decision engine. This is useful if you want to use rules to set up the decision engine state.\n\nThe following example rule uses empty conditions to insert a fact every time the rule is executed:\n\nExample rule without conditions\n\nrule \"Always insert applicant\" when // Empty then // Actions to be executed once insert( new Applicant() ); end // The rule is internally rewritten in the following way: rule \"Always insert applicant\" when eval( true ) then insert( new Applicant() ); end\n\nIf rule conditions use multiple patterns with no defined keyword conjunctions (such as and, or, or not), the default conjunction is and:\n\nExample rule without keyword conjunctions\n\nrule \"Underage\" when application : LoanApplication() Applicant( age < 21 ) then // Actions end // The rule is internally rewritten in the following way: rule \"Underage\" when application : LoanApplication() and Applicant( age < 21 ) then // Actions end\n\n2.8.1. Patterns and constraints\n\nA pattern in a DRL rule condition is the segment to be matched by the decision engine. A pattern can potentially match each fact that is inserted into the working memory of the decision engine. A pattern can also contain constraints to further define the facts to be matched.\n\nIn the simplest form, with no constraints, a pattern matches a fact of the given type. In the following example, the type is Person, so the pattern will match against all Person objects in the working memory of the decision engine:\n\nExample pattern for a single fact type\n\nPerson()\n\nThe type does not need to be the actual class of some fact object. Patterns can refer to superclasses or even interfaces, potentially matching facts from many different classes. For example, the following pattern matches all objects in the working memory of the decision engine:\n\nExample pattern for all objects\n\nObject() // Matches all objects in the working memory\n\nThe parentheses of a pattern enclose the constraints, such as the following constraint on the personâ€™s age:\n\nExample pattern with a constraint\n\nPerson( age == 50 )\n\nA constraint is an expression that returns true or false. Pattern constraints in DRL are essentially Java expressions with some enhancements, such as property access, and some differences, such as equals() and !equals() semantics for == and != (instead of the usual same and not same semantics).\n\nAny JavaBeans property can be accessed directly from pattern constraints. A bean property is exposed internally using a standard JavaBeans getter that takes no arguments and returns something. For example, the age property is written as age in DRL instead of the getter getAge():\n\nDRL constraint syntax with JavaBeans properties\n\nPerson( age == 50 ) // This is the same as the following getter format: Person( getAge() == 50 )\n\nRed Hat Process Automation Manager uses the standard JDK Introspector class to achieve this mapping, so it follows the standard JavaBeans specification. For optimal decision engine performance, use the property access format, such as age, instead of using getters explicitly, such as getAge().\n\nWarning\n\nDo not use property accessors to change the state of the object in a way that might affect the rules because the decision engine caches the results of the match between invocations for higher efficiency.\n\nFor example, do not use property accessors in the following ways:\n\npublic int getAge() { age++; // Do not do this. return age; }\n\npublic int getAge() { Date now = DateUtil.now(); // Do not do this. return DateUtil.differenceInYears(now, birthday); }\n\nInstead of following the second example, insert a fact that wraps the current date in the working memory and update that fact between fireAllRules() as needed.\n\nHowever, if the getter of a property cannot be found, the compiler uses the property name as a fallback method name, without arguments:\n\nFallback method if object is not found\n\nPerson( age == 50 ) // If `Person.getAge()` does not exist, the compiler uses the following syntax: Person( age() == 50 )\n\nYou can also nest access properties in patterns, as shown in the following example. Nested properties are indexed by the decision engine.\n\nExample pattern with nested property access\n\nPerson( address.houseNumber == 50 ) // This is the same as the following format: Person( getAddress().getHouseNumber() == 50 )\n\nWarning\n\nIn stateful KIE sessions, use nested accessors carefully because the working memory of the decision engine is not aware of any of the nested values and does not detect when they change. Either consider the nested values immutable while any of their parent references are inserted into the working memory, or, if you want to modify a nested value, mark all of the outer facts as updated. In the previous example, when the houseNumber property changes, any Person with that Address must be marked as updated.\n\nYou can use any Java expression that returns a boolean value as a constraint inside the parentheses of a pattern. Java expressions can be mixed with other expression enhancements, such as property access:\n\nExample pattern with a constraint using property access and Java expression\n\nPerson( age == 50 )\n\nYou can change the evaluation priority by using parentheses, as in any logical or mathematical expression:\n\nExample evaluation order of constraints\n\nPerson( age > 100 && ( age % 10 == 0 ) )\n\nYou can also reuse Java methods in constraints, as shown in the following example:\n\nExample constraints with reused Java methods\n\nPerson( Math.round( weight / ( height * height ) ) < 25.0 )\n\nWarning\n\nDo not use constraints to change the state of the object in a way that might affect the rules because the decision engine caches the results of the match between invocations for higher efficiency. Any method that is executed on a fact in the rule conditions must be a read-only method. Also, the state of a fact should not change between rule invocations unless those facts are marked as updated in the working memory on every change.\n\nFor example, do not use a pattern constraint in the following ways:\n\nPerson( incrementAndGetAge() == 10 ) // Do not do this.\n\nPerson( System.currentTimeMillis() % 1000 == 0 ) // Do not do this.\n\nStandard Java operator precedence applies to constraint operators in DRL, and DRL operators follow standard Java semantics except for the == and != operators.\n\nThe == operator uses null-safe equals() semantics instead of the usual same semantics. For example, the pattern Person( firstName == \"John\" ) is similar to java.util.Objects.equals(person.getFirstName(), \"John\"), and because \"John\" is not null, the pattern is also similar to \"John\".equals(person.getFirstName()).\n\nThe != operator uses null-safe !equals() semantics instead of the usual not same semantics. For example, the pattern Person( firstName != \"John\" ) is similar to !java.util.Objects.equals(person.getFirstName(), \"John\").\n\nIf the field and the value of a constraint are of different types, the decision engine uses type coercion to resolve the conflict and reduce compilation errors. For instance, if \"ten\" is provided as a string in a numeric evaluator, a compilation error occurs, whereas \"10\" is coerced to a numeric 10. In coercion, the field type always takes precedence over the value type:\n\nExample constraint with a value that is coerced\n\nPerson( age == \"10\" ) // \"10\" is coerced to 10\n\nFor groups of constraints, you can use a delimiting comma , to use implicit and connective semantics:\n\nExample patterns with multiple constraints\n\n// Person is at least 50 years old and weighs at least 80 kilograms: Person( age > 50, weight > 80 ) // Person is at least 50 years old, weighs at least 80 kilograms, and is taller than 2 meters: Person( age > 50, weight > 80, height > 2 )\n\nNote\n\nAlthough the && and , operators have the same semantics, they are resolved with different priorities. The && operator precedes the || operator, and both the && and || operators together precede the , operator. Use the comma operator at the top-level constraint for optimal decision engine performance and human readability.\n\nYou cannot embed a comma operator in a composite constraint expression, such as in parentheses:\n\nExample of misused comma in composite constraint expression\n\n// Do not use the following format: Person( ( age > 50, weight > 80 ) || height > 2 ) // Use the following format instead: Person( ( age > 50 && weight > 80 ) || height > 2 )\n\n2.8.2. Bound variables in patterns and constraints\n\nYou can bind variables to patterns and constraints to refer to matched objects in other portions of a rule. Bound variables can help you define rules more efficiently or more consistently with how you annotate facts in your data model. To differentiate more easily between variables and fields in a rule, use the standard format $variable for variables, especially in complex rules. This convention is helpful but not required in DRL.\n\nFor example, the following DRL rule uses the variable $p for a pattern with the Person fact:\n\nPattern with a bound variable\n\nrule \"simple rule\" when $p : Person() then System.out.println( \"Person \" + $p ); end\n\nSimilarly, you can also bind variables to properties in pattern constraints, as shown in the following example:\n\n// Two persons of the same age: Person( $firstAge : age ) // Binding Person( age == $firstAge ) // Constraint expression\n\nNote\n\nEnsure that you separate constraint bindings and constraint expressions for clearer and more efficient rule definitions. Although mixed bindings and expressions are supported, they can complicate patterns and affect evaluation efficiency.\n\n// Do not use the following format: Person( $age : age * 2 < 100 ) // Use the following format instead: Person( age * 2 < 100, $age : age )\n\nThe decision engine does not support bindings to the same declaration, but does support unification of arguments across several properties. While positional arguments are always processed with unification, the unification symbol := exists for named arguments.\n\nThe following example patterns unify the age property across two Person facts:\n\nExample pattern with unification\n\nPerson( $age := age ) Person( $age := age )\n\nUnification declares a binding for the first occurrence and constrains to the same value of the bound field for sequence occurrences.\n\n2.8.3. Nested constraints and inline casts\n\nIn some cases, you might need to access multiple properties of a nested object, as shown in the following example:\n\nExample pattern to access multiple properties\n\nPerson( name == \"mark\", address.city == \"london\", address.country == \"uk\" )\n\nYou can group these property accessors to nested objects with the syntax .( <constraints> ) for more readable rules, as shown in the following example:\n\nExample pattern with grouped constraints\n\nPerson( name == \"mark\", address.( city == \"london\", country == \"uk\") )\n\nNote\n\nThe period prefix . differentiates the nested object constraints from a method call.\n\nWhen you work with nested objects in patterns, you can use the syntax <type>#<subtype> to cast to a subtype and make the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes, as shown in the following examples:\n\nExample patterns with inline casting to a subtype\n\n// Inline casting with subtype name: Person( name == \"mark\", address#LongAddress.country == \"uk\" ) // Inline casting with fully qualified class name: Person( name == \"mark\", address#org.domain.LongAddress.country == \"uk\" ) // Multiple inline casts: Person( name == \"mark\", address#LongAddress.country#DetailedCountry.population > 10000000 )\n\nThese example patterns cast Address to LongAddress, and additionally to DetailedCountry in the last example, making the parent getters available to the subtypes in each case.\n\nYou can use the instanceof operator to infer the results of the specified type in subsequent uses of that field with the pattern, as shown in the following example:\n\nPerson( name == \"mark\", address instanceof LongAddress, address.country == \"uk\" )\n\nIf an inline cast is not possible (for example, if instanceof returns false), the evaluation is considered false.\n\n2.8.5. Supported operators in DRL pattern constraints\n\nDRL supports standard Java semantics for operators in pattern constraints, with some exceptions and with some additional operators that are unique in DRL. The following list summarizes the operators that are handled differently in DRL constraints than in standard Java semantics or that are unique in DRL constraints.\n\n.(), #\n\nUse the .() operator to group property accessors to nested objects, and use the # operator to cast to a subtype in nested objects. Casting to a subtype makes the getters from the parent type available to the subtype. You can use either the object name or fully qualified class name, and you can cast to one or multiple subtypes.\n\nExample patterns with nested objects\n\n// Ungrouped property accessors: Person( name == \"mark\", address.city == \"london\", address.country == \"uk\" ) // Grouped property accessors: Person( name == \"mark\", address.( city == \"london\", country == \"uk\") )\n\nNote\n\nThe period prefix . differentiates the nested object constraints from a method call.\n\nExample patterns with inline casting to a subtype\n\n// Inline casting with subtype name: Person( name == \"mark\", address#LongAddress.country == \"uk\" ) // Inline casting with fully qualified class name: Person( name == \"mark\", address#org.domain.LongAddress.country == \"uk\" ) // Multiple inline casts: Person( name == \"mark\", address#LongAddress.country#DetailedCountry.population > 10000000 )\n\n!.\n\nUse this operator to dereference a property in a null-safe way. The value to the left of the !. operator must be not null (interpreted as != null) in order to give a positive result for pattern matching.\n\nExample constraint with null-safe dereferencing\n\nPerson( $streetName : address!.street ) // This is internally rewritten in the following way: Person( address != null, $streetName : address.street )\n\n[]\n\nUse this operator to access a List value by index or a Map value by key.\n\nExample constraints with List and Map access\n\n// The following format is the same as `childList(0).getAge() == 18`: Person(childList[0].age == 18) // The following format is the same as `credentialMap.get(\"jdoe\").isValid()`: Person(credentialMap[\"jdoe\"].valid)\n\n<, <=, >, >=\n\nUse these operators on properties with natural ordering. For example, for Date fields, the < operator means before, and for String fields, the operator means alphabetically before. These properties apply only to comparable properties.\n\nExample constraints with before operator\n\nPerson( birthDate < $otherBirthDate ) Person( firstName < $otherFirstName )\n\n==, !=\n\nUse these operators as equals() and !equals() methods in constraints, instead of the usual same and not same semantics.\n\nExample constraint with null-safe equality\n\nPerson( firstName == \"John\" ) // This is similar to the following formats: java.util.Objects.equals(person.getFirstName(), \"John\") \"John\".equals(person.getFirstName())\n\nExample constraint with null-safe not equality\n\nPerson( firstName != \"John\" ) // This is similar to the following format: !java.util.Objects.equals(person.getFirstName(), \"John\")\n\n&&, ||\n\nUse these operators to create an abbreviated combined relation condition that adds more than one restriction on a field. You can group constraints with parentheses () to create a recursive syntax pattern.\n\nExample constraints with abbreviated combined relation\n\n// Simple abbreviated combined relation condition using a single `&&`: Person(age > 30 && < 40) // Complex abbreviated combined relation using groupings: Person(age ((> 30 && < 40) || (> 20 && < 25))) // Mixing abbreviated combined relation with constraint connectives: Person(age > 30 && < 40 || location == \"london\")\n\nmatches, not matches\n\nUse these operators to indicate that a field matches or does not match a specified Java regular expression. Typically, the regular expression is a String literal, but variables that resolve to a valid regular expression are also supported. These operators apply only to String properties. If you use matches against a null value, the resulting evaluation is always false. If you use not matches against a null value, the resulting evaluation is always true. As in Java, regular expressions that you write as String literals must use a double backslash \\\\ to escape.\n\nExample constraint to match or not match a regular expression\n\nPerson( country matches \"(USA)?\\\\S*UK\" ) Person( country not matches \"(USA)?\\\\S*UK\" )\n\ncontains, not contains\n\nUse these operators to verify whether a field that is an Array or a Collection contains or does not contain a specified value. These operators apply to Array or Collection properties, but you can also use these operators in place of String.contains() and !String.contains() constraints checks.\n\nExample constraints with contains and not contains for a Collection\n\n// Collection with a specified field: FamilyTree( countries contains \"UK\" ) FamilyTree( countries not contains \"UK\" ) // Collection with a variable: FamilyTree( countries contains $var ) FamilyTree( countries not contains $var )\n\nExample constraints with contains and not contains for a String literal\n\n// Sting literal with a specified field: Person( fullName contains \"Jr\" ) Person( fullName not contains \"Jr\" ) // String literal with a variable: Person( fullName contains $var ) Person( fullName not contains $var )\n\nNote\n\nFor backward compatibility, the excludes operator is a supported synonym for not contains.\n\nmemberOf, not memberOf\n\nUse these operators to verify whether a field is a member of or is not a member of an Array or a Collection that is defined as a variable. The Array or Collection must be a variable.\n\nExample constraints with memberOf and not memberOf with a Collection\n\nFamilyTree( person memberOf $europeanDescendants ) FamilyTree( person not memberOf $europeanDescendants )\n\nsoundslike\n\nUse this operator to verify whether a word has almost the same sound, using English pronunciation, as the given value (similar to the matches operator). This operator uses the Soundex algorithm.\n\nExample constraint with soundslike\n\n// Match firstName \"Jon\" or \"John\": Person( firstName soundslike \"John\" )\n\nstr\n\nUse this operator to verify whether a field that is a String starts with or ends with a specified value. You can also use this operator to verify the length of the String.\n\nExample constraints with str\n\n// Verify what the String starts with: Message( routingValue str[startsWith] \"R1\" ) // Verify what the String ends with: Message( routingValue str[endsWith] \"R2\" ) // Verify the length of the String: Message( routingValue str[length] 17 )\n\nin, notin\n\nUse these operators to specify more than one possible value to match in a constraint (compound value restriction). This functionality of compound value restriction is supported only in the in and not in operators. The second operand of these operators must be a comma-separated list of values enclosed in parentheses. You can provide values as variables, literals, return values, or qualified identifiers. These operators are internally rewritten as a list of multiple restrictions using the operators == or !=.\n\nExample constraints with in and notin\n\nPerson( $color : favoriteColor ) Color( type in ( \"red\", \"blue\", $color ) ) Person( $color : favoriteColor ) Color( type notin ( \"red\", \"blue\", $color ) )\n\n2.8.6. Operator precedence in DRL pattern constraints\n\nDRL supports standard Java operator precedence for applicable constraint operators, with some exceptions and with some additional operators that are unique in DRL. The following table lists DRL operator precedence where applicable, from highest to lowest precedence:\n\nTable 2.2. Operator precedence in DRL pattern constraintsOperator typeOperatorsNotes\n\n2.8.7. Supported rule condition elements in DRL (keywords)\n\nDRL supports the following rule condition elements (keywords) that you can use with the patterns that you define in DRL rule conditions:\n\nand\n\nUse this to group conditional components into a logical conjunction. Infix and prefix and are supported. You can group patterns explicitly with parentheses (). By default, all listed patterns are combined with and when no conjunction is specified.\n\nExample patterns with and\n\n//Infix `and`: Color( colorType : type ) and Person( favoriteColor == colorType ) //Infix `and` with grouping: (Color( colorType : type ) and (Person( favoriteColor == colorType ) or Person( favoriteColor == colorType )) // Prefix `and`: (and Color( colorType : type ) Person( favoriteColor == colorType )) // Default implicit `and`: Color( colorType : type ) Person( favoriteColor == colorType )\n\nNote\n\nDo not use a leading declaration binding with the and keyword (as you can with or, for example). A declaration can only reference a single fact at a time, and if you use a declaration binding with and, then when and is satisfied, it matches both facts and results in an error.\n\nExample misuse of and\n\n// Causes compile error: $person : (Person( name == \"Romeo\" ) and Person( name == \"Juliet\"))\n\nor\n\nUse this to group conditional components into a logical disjunction. Infix and prefix or are supported. You can group patterns explicitly with parentheses (). You can also use pattern binding with or, but each pattern must be bound separately.\n\nExample patterns with or\n\n//Infix `or`: Color( colorType : type ) or Person( favoriteColor == colorType ) //Infix `or` with grouping: (Color( colorType : type ) or (Person( favoriteColor == colorType ) and Person( favoriteColor == colorType )) // Prefix `or`: (or Color( colorType : type ) Person( favoriteColor == colorType ))\n\nExample patterns with or and pattern binding\n\npensioner : (Person( sex == \"f\", age > 60 ) or Person( sex == \"m\", age > 65 )) (or pensioner : Person( sex == \"f\", age > 60 ) pensioner : Person( sex == \"m\", age > 65 ))\n\nThe behavior of the or condition element is different from the connective || operator for constraints and restrictions in field constraints. The decision engine does not directly interpret the or element but uses logical transformations to rewrite a rule with or as a number of sub-rules. This process ultimately results in a rule that has a single or as the root node and one sub-rule for each of its condition elements. Each sub-rule is activated and executed like any normal rule, with no special behavior or interaction between the sub-rules.\n\nTherefore, consider the or condition element a shortcut for generating two or more similar rules that, in turn, can create multiple activations when two or more terms of the disjunction are true.\n\nexists\n\nUse this to specify facts and constraints that must exist. This option is triggered on only the first match, not subsequent matches. If you use this element with multiple patterns, enclose the patterns with parentheses ().\n\nExample patterns with exists\n\nexists Person( firstName == \"John\") exists (Person( firstName == \"John\", age == 42 )) exists (Person( firstName == \"John\" ) and Person( lastName == \"Doe\" ))\n\nnot\n\nUse this to specify facts and constraints that must not exist. If you use this element with multiple patterns, enclose the patterns with parentheses ().\n\nExample patterns with not\n\nnot Person( firstName == \"John\") not (Person( firstName == \"John\", age == 42 )) not (Person( firstName == \"John\" ) and Person( lastName == \"Doe\" ))\n\nforall\n\nUse this to verify whether all facts that match the first pattern match all the remaining patterns. When a forall construct is satisfied, the rule evaluates to true. This element is a scope delimiter, so it can use any previously bound variable, but no variable bound inside of it is available for use outside of it.\n\nExample rule with forall\n\nrule \"All full-time employees have red ID badges\" when forall( $emp : Employee( type == \"fulltime\") Employee( this == $emp, badgeColor = \"red\" ) ) then // True, all full-time employees have red ID badges. end\n\nIn this example, the rule selects all Employee objects whose type is \"fulltime\". For each fact that matches this pattern, the rule evaluates the patterns that follow (badge color) and if they match, the rule evaluates to true.\n\nTo state that all facts of a given type in the working memory of the decision engine must match a set of constraints, you can use forall with a single pattern for simplicity.\n\nExample rule with forall and a single pattern\n\nrule \"All full-time employees have red ID badges\" when forall( Employee( badgeColor = \"red\" ) ) then // True, all full-time employees have red ID badges. end\n\nYou can use forall constructs with multiple patterns or nest them with other condition elements, such as inside a not element construct.\n\nExample rule with forall and multiple patterns\n\nrule \"All employees have health and dental care programs\" when forall( $emp : Employee() HealthCare( employee == $emp ) DentalCare( employee == $emp ) ) then // True, all employees have health and dental care. end\n\nExample rule with forall and not\n\nrule \"Not all employees have health and dental care\" when not ( forall( $emp : Employee() HealthCare( employee == $emp ) DentalCare( employee == $emp ) ) ) then // True, not all employees have health and dental care. end\n\nNote\n\nThe format forall( p1 p2 p3 â€¦â€‹) is equivalent to not( p1 and not( and p2 p3 â€¦â€‹ ) ).\n\nfrom\n\nUse this to specify a data source for a pattern. This enables the decision engine to reason over data that is not in the working memory. The data source can be a sub-field on a bound variable or the result of a method call. The expression used to define the object source is any expression that follows regular MVEL syntax. Therefore, the from element enables you to easily use object property navigation, execute method calls, and access maps and collection elements.\n\nExample rule with from and pattern binding\n\nrule \"Validate zipcode\" when Person($personAddress : address) Address(zipcode == \"23920W\") from $personAddress then // Zip code is okay. end\n\nExample rule with from and a graph notation\n\nrule \"Validate zipcode\" when $p : Person() $a : Address(zipcode == \"23920W\") from $p.address then // Zip code is okay. end\n\nExample rule with from to iterate over all objects\n\nrule \"Apply 10% discount to all items over US$ 100 in an order\" when $order : Order() $item : OrderItem( value > 100) from $order.items then // Apply discount to `$item`. end\n\nExample rule with from and lock-on-active rule attribute\n\nrule \"Assign people in North Carolina (NC) to sales region 1\" ruleflow-group \"test\" lock-on-active true when $p : Person() $a : Address( state == \"NC\") from $p.address then modify ($p) {} // Assign the person to sales region 1. end rule \"Apply a discount to people in the city of Raleigh\" ruleflow-group \"test\" lock-on-active true when $p : Person() $a : Address( city == \"Raleigh\") from $p.address then modify ($p) {} // Apply discount to the person. end\n\nImportant\n\nUsing from with lock-on-active rule attribute can result in rules not being executed. You can address this issue in one of the following ways:\n\nAvoid using the from element when you can insert all facts into the working memory of the decision engine or use nested object references in your constraint expressions.\n\nPlace the variable used in the modify() block as the last sentence in your rule condition.\n\nAvoid using the lock-on-active rule attribute when you can explicitly manage how rules within the same ruleflow group place activations on one another.\n\nThe pattern that contains a from clause cannot be followed by another pattern starting with a parenthesis. The reason for this restriction is that the DRL parser reads the from expression as \"from $l (String() or Number())\" and it cannot differentiate this expression from a function call. The simplest workaround to this is to wrap the from clause in parentheses, as shown in the following example:\n\nExample rules with from used incorrectly and correctly\n\n// Do not use `from` in this way: rule R when $l : List() String() from $l (String() or Number()) then // Actions end // Use `from` in this way instead: rule R when $l : List() (String() from $l) (String() or Number()) then // Actions end\n\nentry-point\n\nUse this to define an entry point, or event stream, corresponding to a data source for the pattern. This element is typically used with the from condition element. You can declare an entry point for events so that the decision engine uses data from only that entry point to evaluate the rules. You can declare an entry point either implicitly by referencing it in DRL rules or explicitly in your Java application.\n\nExample rule with from entry-point\n\nrule \"Authorize withdrawal\" when WithdrawRequest($ai : accountId, $am : amount) from entry-point \"ATM Stream\" CheckingAccount(accountId == $ai, balance > $am) then // Authorize withdrawal. end\n\nExample Java application code with EntryPoint object and inserted facts\n\nimport org.kie.api.runtime.KieSession; import org.kie.api.runtime.rule.EntryPoint; // Create your KIE base and KIE session as usual: KieSession session = ... // Create a reference to the entry point: EntryPoint atmStream = session.getEntryPoint(\"ATM Stream\"); // Start inserting your facts into the entry point: atmStream.insert(aWithdrawRequest);\n\ncollect\n\nUse this to define a collection of objects that the rule can use as part of the condition. The rule obtains the collection either from a specified source or from the working memory of the decision engine. The result pattern of the collect element can be any concrete class that implements the java.util.Collection interface and provides a default no-arg public constructor. You can use Java collections like List, LinkedList, and HashSet, or your own class. If variables are bound before the collect element in a condition, you can use the variables to constrain both your source and result patterns. However, any binding made inside the collect element is not available for use outside of it.\n\nExample rule with collect\n\nimport java.util.List rule \"Raise priority when system has more than three pending alarms\" when $system : System() $alarms : List( size >= 3 ) from collect( Alarm( system == $system, status == 'pending' ) ) then // Raise priority because `$system` has three or more `$alarms` pending. end\n\nIn this example, the rule assesses all pending alarms in the working memory of the decision engine for each given system and groups them in a List. If three or more alarms are found for a given system, the rule is executed.\n\nYou can also use the collect element with nested from elements, as shown in the following example:\n\nExample rule with collect and nested from\n\nimport java.util.LinkedList; rule \"Send a message to all parents\" when $town : Town( name == 'Paris' ) $mothers : LinkedList() from collect( Person( children > 0 ) from $town.getPeople() ) then // Send a message to all parents. end\n\naccumulate\n\nUse this to iterate over a collection of objects, execute custom actions for each of the elements, and return one or more result objects (if the constraints evaluate to true). This element is a more flexible and powerful form of the collect condition element. You can use predefined functions in your accumulate conditions or implement custom functions as needed. You can also use the abbreviation acc for accumulate in rule conditions.\n\nUse the following format to define accumulate conditions in rules:\n\nPreferred format for accumulate\n\naccumulate( <source pattern>; <functions> [;<constraints>] )\n\nNote\n\nAlthough the decision engine supports alternate formats for the accumulate element for backward compatibility, this format is preferred for optimal performance in rules and applications.\n\nThe decision engine supports the following predefined accumulate functions. These functions accept any expression as input.\n\naverage\n\nmin\n\nmax\n\ncount\n\nsum\n\ncollectList\n\ncollectSet\n\nIn the following example rule, min, max, and average are accumulate functions that calculate the minimum, maximum, and average temperature values over all the readings for each sensor:\n\nExample rule with accumulate to calculate temperature values\n\nrule \"Raise alarm\" when $s : Sensor() accumulate( Reading( sensor == $s, $temp : temperature ); $min : min( $temp ), $max : max( $temp ), $avg : average( $temp ); $min < 20, $avg > 70 ) then // Raise the alarm. end\n\nThe following example rule uses the average function with accumulate to calculate the average profit for all items in an order:\n\nExample rule with accumulate to calculate average profit\n\nrule \"Average profit\" when $order : Order() accumulate( OrderItem( order == $order, $cost : cost, $price : price ); $avgProfit : average( 1 - $cost / $price ) ) then // Average profit for `$order` is `$avgProfit`. end\n\nTo use custom, domain-specific functions in accumulate conditions, create a Java class that implements the org.kie.api.runtime.rule.AccumulateFunction interface. For example, the following Java class defines a custom implementation of an AverageData function:\n\nExample Java class with custom implementation of average function\n\n// An implementation of an accumulator capable of calculating average values public class AverageAccumulateFunction implements org.kie.api.runtime.rule.AccumulateFunction<AverageAccumulateFunction.AverageData> { public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { } public void writeExternal(ObjectOutput out) throws IOException { } public static class AverageData implements Externalizable { public int count = 0; public double total = 0; public AverageData() {} public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException { count = in.readInt(); total = in.readDouble(); } public void writeExternal(ObjectOutput out) throws IOException { out.writeInt(count); out.writeDouble(total); } } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#createContext() */ public AverageData createContext() { return new AverageData(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#init(java.io.Serializable) */ public void init(AverageData context) { context.count = 0; context.total = 0; } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#accumulate(java.io.Serializable, java.lang.Object) */ public void accumulate(AverageData context, Object value) { context.count++; context.total += ((Number) value).doubleValue(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#reverse(java.io.Serializable, java.lang.Object) */ public void reverse(AverageData context, Object value) { context.count--; context.total -= ((Number) value).doubleValue(); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#getResult(java.io.Serializable) */ public Object getResult(AverageData context) { return new Double( context.count == 0 ? 0 : context.total / context.count ); } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#supportsReverse() */ public boolean supportsReverse() { return true; } /* (non-Javadoc) * @see org.kie.api.runtime.rule.AccumulateFunction#getResultType() */ public Class< ? > getResultType() { return Number.class; } }\n\nTo use the custom function in a DRL rule, import the function using the import accumulate statement:\n\nFormat to import a custom function\n\nimport accumulate <class_name> <function_name>\n\nExample rule with the imported average function\n\nimport accumulate AverageAccumulateFunction.AverageData average rule \"Average profit\" when $order : Order() accumulate( OrderItem( order == $order, $cost : cost, $price : price ); $avgProfit : average( 1 - $cost / $price ) ) then // Average profit for `$order` is `$avgProfit`. end\n\n2.8.8. OOPath syntax with graphs of objects in DRL rule conditions\n\nOOPath is an object-oriented syntax extension of XPath that is designed for browsing graphs of objects in DRL rule condition constraints. OOPath uses the compact notation from XPath for navigating through related elements while handling collections and filtering constraints, and is specifically useful for graphs of objects.\n\nWhen the field of a fact is a collection, you can use the from condition element (keyword) to bind and reason over all the items in that collection one by one. If you need to browse a graph of objects in the rule condition constraints, the extensive use of the from condition element results in a verbose and repetitive syntax, as shown in the following example:\n\nExample rule that browses a graph of objects with from\n\nrule \"Find all grades for Big Data exam\" when $student: Student( $plan: plan ) $exam: Exam( course == \"Big Data\" ) from $plan.exams $grade: Grade() from $exam.grades then // Actions end\n\nIn this example, the domain model contains a Student object with a Plan of study. The Plan can have zero or more Exam instances and an Exam can have zero or more Grade instances. Only the root object of the graph, the Student in this case, needs to be in the working memory of the decision engine for this rule setup to function.\n\nAs a more efficient alternative to using extensive from statements, you can use the abbreviated OOPath syntax, as shown in the following example:\n\nExample rule that browses a graph of objects with OOPath syntax\n\nrule \"Find all grades for Big Data exam\" when Student( $grade: /plan/exams[course == \"Big Data\"]/grades ) then // Actions end\n\nFormally, the core grammar of an OOPath expression is defined in extended Backus-Naur form (EBNF) notation in the following way:\n\nEBNF notation for OOPath expressions\n\nOOPExpr = [ID ( \":\" | \":=\" )] ( \"/\" | \"?/\" ) OOPSegment { ( \"/\" | \"?/\" | \".\" ) OOPSegment } ; OOPSegment = ID [\"#\" ID] [\"[\" ( Number | Constraints ) \"]\"]\n\nIn practice, an OOPath expression has the following features and capabilities:\n\nStarts with a forward slash / or with a question mark and forward slash ?/ if it is a non-reactive OOPath expression (described later in this section).\n\nCan dereference a single property of an object with the period . operator.\n\nCan dereference multiple properties of an object with the forward slash / operator. If a collection is returned, the expression iterates over the values in the collection.\n\nCan filter out traversed objects that do not satisfy one or more constraints. The constraints are written as predicate expressions between square brackets, as shown in the following example:\n\nConstraints as a predicate expression\n\nStudent( $grade: /plan/exams[ course == \"Big Data\" ]/grades )\n\nCan downcast a traversed object to a subclass of the class declared in the generic collection. Subsequent constraints can also safely access the properties declared only in that subclass, as shown in the following example. Objects that are not instances of the class specified in this inline cast are automatically filtered out.\n\nConstraints with downcast objects\n\nStudent( $grade: /plan/exams#AdvancedExam[ course == \"Big Data\", level > 3 ]/grades )\n\nCan backreference an object of the graph that was traversed before the currently iterated graph. For example, the following OOPath expression matches only the grades that are above the average for the passed exam:\n\nConstraints with backreferenced object\n\nStudent( $grade: /plan/exams/grades[ result > ../averageResult ] )\n\nCan recursively be another OOPath expression, as shown in the following example:\n\nRecursive constraint expression\n\nStudent( $exam: /plan/exams[ /grades[ result > 20 ] ] )\n\nCan access objects by their index between square brackets [], as shown in the following example. To adhere to Java convention, OOPath indexes are 0-based, while XPath indexes are 1-based.\n\nConstraints with access to objects by index\n\nStudent( $grade: /plan/exams[0]/grades )\n\nOOPath expressions can be reactive or non-reactive. The decision engine does not react to updates involving a deeply nested object that is traversed during the evaluation of an OOPath expression.\n\nTo make these objects reactive to changes, modify the objects to extend the class org.drools.core.phreak.ReactiveObject. After you modify an object to extend the ReactiveObject class, the domain object invokes the inherited method notifyModification to notify the decision engine when one of the fields has been updated, as shown in the following example:\n\nExample object method to notify the decision engine that an exam has been moved to a different course\n\npublic void setCourse(String course) { this.course = course; notifyModification(this); }\n\nWith the following corresponding OOPath expression, when an exam is moved to a different course, the rule is re-executed and the list of grades matching the rule is recomputed:\n\nExample OOPath expression from \"Big Data\" rule\n\nStudent( $grade: /plan/exams[ course == \"Big Data\" ]/grades )\n\nYou can also use the ?/ separator instead of the / separator to disable reactivity in only one sub-portion of an OOPath expression, as shown in the following example:\n\nExample OOPath expression that is partially non-reactive\n\nStudent( $grade: /plan/exams[ course == \"Big Data\" ]?/grades )\n\nWith this example, the decision engine reacts to a change made to an exam or if an exam is added to the plan, but not if a new grade is added to an existing exam.\n\nIf an OOPath portion is non-reactive, all remaining portions of the OOPath expression also become non-reactive. For example, the following OOPath expression is completely non-reactive:\n\nExample OOPath expression that is completely non-reactive\n\nStudent( $grade: ?/plan/exams[ course == \"Big Data\" ]/grades )\n\nFor this reason, you cannot use the ?/ separator more than once in the same OOPath expression. For example, the following expression causes a compilation error:\n\nExample OOPath expression with duplicate non-reactivity markers\n\nStudent( $grade: /plan?/exams[ course == \"Big Data\" ]?/grades )\n\nAnother alternative for enabling OOPath expression reactivity is to use the dedicated implementations for List and Set interfaces in Red Hat Process Automation Manager. These implementations are the ReactiveList and ReactiveSet classes. A ReactiveCollection class is also available. The implementations also provide reactive support for performing mutable operations through the Iterator and ListIterator classes.\n\nThe following example class uses these classes to configure OOPath expression reactivity:\n\nExample Java class to configure OOPath expression reactivity\n\npublic class School extends AbstractReactiveObject { private String name; private final List<Child> children = new ReactiveList<Child>(); 1 public void setName(String name) { this.name = name; notifyModification(); 2 } public void addChild(Child child) { children.add(child); 3 // No need to call `notifyModification()` here } }\n\n1\n\nUses the ReactiveList instance for reactive support over the standard Java List instance.\n\n2\n\nUses the required notifyModification() method for when a field is changed in reactive support.\n\n3\n\nThe children field is a ReactiveList instance, so the notifyModification() method call is not required. The notification is handled automatically, like all other mutating operations performed over the children field.\n\n2.9. Rule actions in DRL (THEN)\n\nThe then part of the rule (also known as the Right Hand Side (RHS) of the rule) contains the actions to be performed when the conditional part of the rule has been met. Actions consist of one or more methods that execute consequences based on the rule conditions and on available data objects in the package. For example, if a bank requires loan applicants to have over 21 years of age (with a rule condition Applicant( age < 21 )) and a loan applicant is under 21 years old, the then action of an \"Underage\" rule would be setApproved( false ), declining the loan because the applicant is under age.\n\nThe main purpose of rule actions is to to insert, delete, or modify data in the working memory of the decision engine. Effective rule actions are small, declarative, and readable. If you need to use imperative or conditional code in rule actions, then divide the rule into multiple smaller and more declarative rules.\n\nExample rule for loan application age limit\n\nrule \"Underage\" when application : LoanApplication() Applicant( age < 21 ) then application.setApproved( false ); application.setExplanation( \"Underage\" ); end\n\n2.9.1. Supported rule action methods in DRL\n\nDRL supports the following rule action methods that you can use in DRL rule actions. You can use these methods to modify the working memory of the decision engine without having to first reference a working memory instance. These methods act as shortcuts to the methods provided by the KnowledgeHelper class in your Red Hat Process Automation Manager distribution.\n\nFor all rule action methods, download the Red Hat Process Automation Manager 7.5.1 Source Distribution ZIP file from the Red Hat Customer Portal and navigate to ~/rhpam-7.5.1-sources/src/drools-$VERSION/drools-core/src/main/java/org/drools/core/spi/KnowledgeHelper.java.\n\nset\n\nUse this to set the value of a field.\n\nset<field> ( <value> )\n\nExample rule action to set the values of a loan application approval\n\n$application.setApproved ( false ); $application.setExplanation( \"has been bankrupt\" );\n\nmodify\n\nUse this to specify fields to be modified for a fact and to notify the decision engine of the change. This method provides a structured approach to fact updates. It combines the update operation with setter calls to change object fields.\n\nmodify ( <fact-expression> ) { <expression>, <expression>, ... }\n\nExample rule action to modify a loan application amount and approval\n\nmodify( LoanApplication ) { setAmount( 100 ), setApproved ( true ) }\n\nupdate\n\nUse this to specify fields and the entire related fact to be updated and to notify the decision engine of the change. After a fact has changed, you must call update before changing another fact that might be affected by the updated values. To avoid this added step, use the modify method instead.\n\nupdate ( <object, <handle> ) // Informs the decision engine that an object has changed update ( <object> ) // Causes `KieSession` to search for a fact handle of the object\n\nExample rule action to update a loan application amount and approval\n\nLoanApplication.setAmount( 100 ); update( LoanApplication );\n\nNote\n\nIf you provide property-change listeners, you do not need to call this method when an object changes. For more information about property-change listeners, see Decision engine in Red Hat Process Automation Manager.\n\ninsert\n\nUse this to insert a new fact into the working memory of the decision engine and to define resulting fields and values as needed for the fact.\n\ninsert( new <object> );\n\nExample rule action to insert a new loan applicant object\n\ninsert( new Applicant() );\n\ninsertLogical\n\nUse this to insert a new fact logically into the decision engine. The decision engine is responsible for logical decisions on insertions and retractions of facts. After regular or stated insertions, facts must be retracted explicitly. After logical insertions, the facts that were inserted are automatically retracted when the conditions in the rules that inserted the facts are no longer true.\n\ninsertLogical( new <object> );\n\nExample rule action to logically insert a new loan applicant object\n\ninsertLogical( new Applicant() );\n\ndelete\n\nUse this to remove an object from the decision engine. The keyword retract is also supported in DRL and executes the same action, but delete is typically preferred in DRL code for consistency with the keyword insert.\n\ndelete( <object> );\n\nExample rule action to delete a loan applicant object\n\ndelete( Applicant );\n\n2.9.2. Other rule action methods from drools and kcontext variables\n\nIn addition to the standard rule action methods, the decision engine supports methods in conjunction with the predefined drools and kcontext variables that you can also use in rule actions.\n\nYou can use the drools variable to call methods from the KnowledgeHelper class in your Red Hat Process Automation Manager distribution, which is also the class that the standard rule action methods are based on. For all drools rule action options, download the Red Hat Process Automation Manager 7.5.1 Source Distribution ZIP file from the Red Hat Customer Portal and navigate to ~/rhpam-7.5.1-sources/src/drools-$VERSION/drools-core/src/main/java/org/drools/core/spi/KnowledgeHelper.java.\n\nThe following examples are common methods that you can use with the drools variable:\n\ndrools.halt(): Terminates rule execution if a user or application has previously called fireUntilHalt(). When a user or application calls fireUntilHalt(), the decision engine starts in active mode and evaluates rules continually until the user or application explicitly calls halt(). Otherwise, by default, the decision engine runs in passive mode and evaluates rules only when a user or an application explicitly calls fireAllRules().\n\ndrools.getWorkingMemory(): Returns the WorkingMemory object.\n\ndrools.setFocus( \"<agenda_group>\" ): Sets the focus to a specified agenda group to which the rule belongs.\n\ndrools.getRule().getName(): Returns the name of the rule.\n\ndrools.getTuple(), drools.getActivation(): Returns the Tuple that matches the currently executing rule and then delivers the corresponding Activation. These calls are useful for logging and debugging purposes.\n\nYou can use the kcontext variable with the getKieRuntime() method to call other methods from the KieContext class and, by extension, the RuleContext class in your Red Hat Process Automation Manager distribution. The full Knowledge Runtime API is exposed through the kcontext variable and provides extensive rule action methods. For all kcontext rule action options, download the Red Hat Process Automation Manager 7.5.1 Source Distribution ZIP file from the Red Hat Customer Portal and navigate to ~/rhpam-7.5.1-sources/src/kie-api-parent-$VERSION/kie-api/src/main/java/org/kie/api/runtime/rule/RuleContext.java.\n\nThe following examples are common methods that you can use with the kcontext.getKieRuntime() variable-method combination:\n\nkcontext.getKieRuntime().halt(): Terminates rule execution if a user or application has previously called fireUntilHalt(). This method is equivalent to the drools.halt() method. When a user or application calls fireUntilHalt(), the decision engine starts in active mode and evaluates rules continually until the user or application explicitly calls halt(). Otherwise, by default, the decision engine runs in passive mode and evaluates rules only when a user or an application explicitly calls fireAllRules().\n\nkcontext.getKieRuntime().getAgenda(): Returns a reference to the KIE session Agenda, and in turn provides access to rule activation groups, rule agenda groups, and ruleflow groups.\n\nExample call to access agenda group \"CleanUp\" and set the focus\n\nkcontext.getKieRuntime().getAgenda().getAgendaGroup( \"CleanUp\" ).setFocus();\n\nThis example is equivalent to drools.setFocus( \"CleanUp\" ).\n\nkcontext.getKieRuntime().getQueryResults(<string> query): Runs a query and returns the results. This method is equivalent to drools.getKieRuntime().getQueryResults().\n\nkcontext.getKieRuntime().getKieBase(): Returns the KieBase object. The KIE base is the source of all the knowledge in your rule system and the originator of the current KIE session.\n\nkcontext.getKieRuntime().setGlobal(), ~.getGlobal(), ~.getGlobals(): Sets or retrieves global variables.\n\nkcontext.getKieRuntime().getEnvironment(): Returns the runtime Environment, similar to your operating system environment.\n\n2.9.3. Advanced rule actions with conditional and named consequences\n\nIn general, effective rule actions are small, declarative, and readable. However, in some cases, the limitation of having a single consequence for each rule can be challenging and lead to verbose and repetitive rule syntax, as shown in the following example rules:\n\nExample rules with verbose and repetitive syntax\n\nrule \"Give 10% discount to customers older than 60\" when $customer : Customer( age > 60 ) then modify($customer) { setDiscount( 0.1 ) }; end rule \"Give free parking to customers older than 60\" when $customer : Customer( age > 60 ) $car : Car( owner == $customer ) then modify($car) { setFreeParking( true ) }; end\n\nA partial solution to the repetition is to make the second rule extend the first rule, as shown in the following modified example:\n\nPartially enhanced example rules with an extended condition\n\nrule \"Give 10% discount to customers older than 60\" when $customer : Customer( age > 60 ) then modify($customer) { setDiscount( 0.1 ) }; end rule \"Give free parking to customers older than 60\" extends \"Give 10% discount to customers older than 60\" when $car : Car( owner == $customer ) then modify($car) { setFreeParking( true ) }; end\n\nAs a more efficient alternative, you can consolidate the two rules into a single rule with modified conditions and labelled corresponding rule actions, as shown in the following consolidated example:\n\nConsolidated example rule with conditional and named consequences\n\nrule \"Give 10% discount and free parking to customers older than 60\" when $customer : Customer( age > 60 ) do[giveDiscount] $car : Car( owner == $customer ) then modify($car) { setFreeParking( true ) }; then[giveDiscount] modify($customer) { setDiscount( 0.1 ) }; end\n\nThis example rule uses two actions: the usual default action and another action named giveDiscount. The giveDiscount action is activated in the condition with the keyword do when a customer older than 60 years old is found in the KIE base, regardless of whether or not the customer owns a car.\n\nYou can configure the activation of a named consequence with an additional condition, such as the if statement in the following example. The condition in the if statement is always evaluated on the pattern that immediately precedes it.\n\nConsolidated example rule with an additional condition\n\nrule \"Give free parking to customers older than 60 and 10% discount to golden ones among them\" when $customer : Customer( age > 60 ) if ( type == \"Golden\" ) do[giveDiscount] $car : Car( owner == $customer ) then modify($car) { setFreeParking( true ) }; then[giveDiscount] modify($customer) { setDiscount( 0.1 ) }; end\n\nYou can also evaluate different rule conditions using a nested if and else if construct, as shown in the following more complex example:\n\nConsolidated example rule with more complex conditions\n\nrule \"Give free parking and 10% discount to over 60 Golden customer and 5% to Silver ones\" when $customer : Customer( age > 60 ) if ( type == \"Golden\" ) do[giveDiscount10] else if ( type == \"Silver\" ) break[giveDiscount5] $car : Car( owner == $customer ) then modify($car) { setFreeParking( true ) }; then[giveDiscount10] modify($customer) { setDiscount( 0.1 ) }; then[giveDiscount5] modify($customer) { setDiscount( 0.05 ) }; end\n\nThis example rule gives a 10% discount and free parking to Golden customers over 60, but only a 5% discount without free parking to Silver customers. The rule activates the consequence named giveDiscount5 with the keyword break instead of do. The keyword do schedules a consequence in the decision engine agenda, enabling the remaining part of the rule conditions to continue being evaluated, while break blocks any further condition evaluation. If a named consequence does not correspond to any condition with do but is activated with break, the rule fails to compile because the conditional part of the rule is never reached.\n\n2.11. Error messages for DRL troubleshooting\n\nRed Hat Process Automation Manager provides standardized messages for DRL errors to help you troubleshoot and resolve problems in your DRL files. The error messages use the following format:\n\nFigure 2.1. Error message format for DRL file problems\n\n1st Block: Error code\n\n2nd Block: Line and column in the DRL source where the error occurred\n\n3rd Block: Description of the problem\n\n4th Block: Component in the DRL source (rule, function, query) where the error occurred\n\n5th Block: Pattern in the DRL source where the error occurred (if applicable)\n\nRed Hat Process Automation Manager supports the following standardized error messages:\n\n101: no viable alternative\n\nIndicates that the parser reached a decision point but could not identify an alternative.\n\nExample rule with incorrect spelling\n\n1: rule \"simple rule\" 2: when 3: exists Person() 4: exits Student() // Must be `exists` 5: then 6: end\n\nError message\n\n[ERR 101] Line 4:4 no viable alternative at input 'exits' in rule \"simple rule\"\n\nExample rule without a rule name\n\n1: package org.drools.examples; 2: rule // Must be `rule \"rule name\"` (or `rule rule_name` if no spacing) 3: when 4: Object() 5: then 6: System.out.println(\"A RHS\"); 7: end\n\nError message\n\n[ERR 101] Line 3:2 no viable alternative at input 'when'\n\nIn this example, the parser encountered the keyword when but expected the rule name, so it flags when as the incorrect expected token.\n\nExample rule with incorrect syntax\n\n1: rule \"simple rule\" 2: when 3: Student( name == \"Andy ) // Must be `\"Andy\"` 4: then 5: end\n\nError message\n\n[ERR 101] Line 0:-1 no viable alternative at input '<eof>' in rule \"simple rule\" in pattern Student\n\nNote\n\nA line and column value of 0:-1 means the parser reached the end of the source file (<eof>) but encountered incomplete constructs, usually due to missing quotation marks \"â€¦â€‹\", apostrophes 'â€¦â€‹', or parentheses (â€¦â€‹).\n\n102: mismatched input\n\nIndicates that the parser expected a particular symbol that is missing at the current input position.\n\nExample rule with an incomplete rule statement\n\n1: rule simple_rule 2: when 3: $p : Person( // Must be a complete rule statement\n\nError message\n\n[ERR 102] Line 0:-1 mismatched input '<eof>' expecting ')' in rule \"simple rule\" in pattern Person\n\nNote\n\nA line and column value of 0:-1 means the parser reached the end of the source file (<eof>) but encountered incomplete constructs, usually due to missing quotation marks \"â€¦â€‹\", apostrophes 'â€¦â€‹', or parentheses (â€¦â€‹).\n\nExample rule with incorrect syntax\n\n1: package org.drools.examples; 2: 3: rule \"Wrong syntax\" 4: when 5: not( Car( ( type == \"tesla\", price == 10000 ) || ( type == \"kia\", price == 1000 ) ) from $carList ) // Must use `&&` operators instead of commas `,` 6: then 7: System.out.println(\"OK\"); 8: end\n\nError messages\n\n[ERR 102] Line 5:36 mismatched input ',' expecting ')' in rule \"Wrong syntax\" in pattern Car [ERR 101] Line 5:57 no viable alternative at input 'type' in rule \"Wrong syntax\" [ERR 102] Line 5:106 mismatched input ')' expecting 'then' in rule \"Wrong syntax\"\n\nIn this example, the syntactic problem results in multiple error messages related to each other. The single solution of replacing the commas , with && operators resolves all errors. If you encounter multiple errors, resolve one at a time in case errors are consequences of previous errors.\n\n103: failed predicate\n\nIndicates that a validating semantic predicate evaluated to false. These semantic predicates are typically used to identify component keywords in DRL files, such as declare, rule, exists, not, and others.\n\nExample rule with an invalid keyword\n\n1: package nesting; 2: 3: import org.drools.compiler.Person 4: import org.drools.compiler.Address 5: 6: Some text // Must be a valid DRL keyword 7: 8: rule \"test something\" 9: when 10: $p: Person( name==\"Michael\" ) 11: then 12: $p.name = \"other\"; 13: System.out.println(p.name); 14: end\n\nError message\n\n[ERR 103] Line 6:0 rule 'rule_key' failed predicate: {(validateIdentifierKey(DroolsSoftKeywords.RULE))}? in rule\n\nThe Some text line is invalid because it does not begin with or is not a part of a DRL keyword construct, so the parser fails to validate the rest of the DRL file.\n\nNote\n\nThis error is similar to 102: mismatched input, but usually involves DRL keywords.\n\n104: trailing semi-colon not allowed\n\nIndicates that an eval() clause in a rule condition uses a semicolon ; but must not use one.\n\nExample rule with eval() and trailing semicolon\n\n1: rule \"simple rule\" 2: when 3: eval( abc(); ) // Must not use semicolon `;` 4: then 5: end\n\nError message\n\n[ERR 104] Line 3:4 trailing semi-colon not allowed in rule \"simple rule\"\n\n105: did not match anything\n\nIndicates that the parser reached a sub-rule in the grammar that must match an alternative at least once, but the sub-rule did not match anything. The parser has entered a branch with no way out.\n\nExample rule with invalid text in an empty condition\n\n1: rule \"empty condition\" 2: when 3: None // Must remove `None` if condition is empty 4: then 5: insert( new Person() ); 6: end\n\nError message\n\n[ERR 105] Line 2:2 required (...)+ loop did not match anything at input 'WHEN' in rule \"empty condition\"\n\nIn this example, the condition is intended to be empty but the word None is used. This error is resolved by removing None, which is not a valid DRL keyword, data type, or pattern construct.\n\nNote\n\nIf you encounter other DRL error messages that you cannot resolve, contact your Red Hat Technical Account Manager.\n\n2.12. Rule units in DRL rule sets\n\nRule units are groups of data sources, global variables, and DRL rules that function together for a specific purpose. You can use rule units to partition a rule set into smaller units, bind different data sources to those units, and then execute the individual unit. Rule units are an enhanced alternative to rule-grouping DRL attributes such as rule agenda groups or activation groups for execution control.\n\nRule units are helpful when you want to coordinate rule execution so that the complete execution of one rule unit triggers the start of another rule unit and so on. For example, assume that you have a set of rules for data enrichment, another set of rules that processes that data, and another set of rules that extract the output from the processed data. If you add these rule sets into three distinct rule units, you can coordinate those rule units so that complete execution of the first unit triggers the start of the second unit and the complete execution of the second unit triggers the start of third unit.\n\nTo define a rule unit, implement the RuleUnit interface as shown in the following example:\n\nExample rule unit class\n\npackage org.mypackage.myunit; public static class AdultUnit implements RuleUnit { private int adultAge; private DataSource<Person> persons; public AdultUnit( ) { } public AdultUnit( DataSource<Person> persons, int age ) { this.persons = persons; this.age = age; } // A data source o"
    }
}