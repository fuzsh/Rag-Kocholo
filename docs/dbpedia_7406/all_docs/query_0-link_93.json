{
    "id": "dbpedia_7406_0",
    "rank": 93,
    "data": {
        "url": "https://ar5iv.labs.arxiv.org/html/1904.07088",
        "read_more_link": "",
        "language": "en",
        "title": "P4-MACsec: Dynamic Topology Monitoring and Data Layer Protection with MACsec in P4-SDN",
        "top_image": "https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png",
        "meta_img": "https://ar5iv.labs.arxiv.org/assets/ar5iv_card.png",
        "images": [
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x1.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x2.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x3.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x4.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x5.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x6.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x7.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x8.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x9.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x10.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x11.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x12.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x13.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x14.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x15.png",
            "https://ar5iv.labs.arxiv.org/html/1904.07088/assets/x16.png",
            "https://ar5iv.labs.arxiv.org/assets/ar5iv.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "We propose P4-MACsec to protect network links between P4 switches through automated deployment of MACsec, a widespread IEEE standard for securing Layer 2 infrastructures.\nIt is supported by switches and routers from ma…",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "ar5iv",
        "canonical_link": "https://ar5iv.labs.arxiv.org/html/1904.07088",
        "text": "Frederik Hauser, Mark Schmidt, Marco Häberle, and Michael Menth This work was supported by the bwNET100G+ project which is funded by the Ministry of Science, Research and the Arts Baden-Württemberg (MWK). The authors alone are responsible for the content of this paper.\n\nAbstract\n\nWe propose P4-MACsec to protect network links between P4 switches through automated deployment of MACsec, a widespread IEEE standard for securing Layer 2 infrastructures. It is supported by switches and routers from major manufacturers and has only little performance limitations compared to VPN technologies such as IPsec. P4-MACsec introduces a data plane implementation of MACsec including AES-GCM encryption and decryption directly on P4 switches. P4-MACsec features a two-tier control plane structure where local controllers running on the P4 switches interact with a central controller. We propose a novel secure link discovery mechanism that leverages protected LLDP frames and the two-tier control plane structure for secure and efficient management of a global link map. Automated deployment of MACsec creates secure channel, generates keying material, and configures the P4 switches for each detected link between two P4 switches. It detects link changes and performs rekeying to provide a secure, configuration-free operation of MACsec. In this paper, we review the technological background of P4-MACsec and explain its architecture. To demonstrate the feasibility of P4-MACsec, we implement it on the BMv2 P4 software switch and validate the prototype through experiments. We evaluate its performance through experiments that focus on TCP throughput and round-trip time. We publish the prototype and experiment setups on Github.\n\nI Introduction\n\nMACsec is a widespread IEEE standard that protects the Layer 2 with cryptographic integrity checks or symmetric encryption. MACsec prevents man-in-the-middle attackers from inspecting, inserting or even modifying network packets that are transmitted between two network peers. In contrast to VPN technologies such as IPsec, MACsec processing is implemented on forwarding chips without notable overhead in line rate performance [1]. Packets are protected in a point-to-point manner between MACsec peers so that control plane functions targeting higher layers can be still applied. Although mechanisms for distributed key exchange exist, MACsec deployment is still time-consuming and complex. It requires knowledge about the network topology, large efforts in switch configuration, and typically maintenance of a key server. Currently, automated deployments using a network management system with legacy switches is not feasible. Legacy network switches only support the Link Layer Discovery Protocol (LLDP) that lacks in detecting topology changes in a timely manner. In addition, it is vulnerable to several attacks that may result in a incorrect topology view. Also, current legacy network switches do not support an automated configuration of MACsec through a southbound protocol. Although a MIB for manipulating MACsec configuration with SNMP exists [2], only basic MACsec parameters can be modified so that distributed protocols and a key server would be still required.\n\nSoftware-defined networking (SDN) splits the strong binding between data and control plane. OpenFlow (OF) [3] is the most widespread standard for SDN. It consists of SDN switches with a fixed-function data plane that are steered by a central SDN controller. P4 [4] is a novel domain-specific language that introduces programmability to the data plane of P4-capable packet forwarding devices such as ASICs, CPU-based targets, and FPGAs. Data plane behaviour can be described in P4 programs that run on P4 switches so that network operators can constantly program the packet processing on deployed switches. The P4 Runtime [5] extends P4 switches by an API to an SDN controller similar to OF.\n\nIn this paper, we consider MACsec to dynamically protect links between switches in SDN. We propose to utilize an SDN controller for automated deployment of MACsec on SDN switches instead of relying on distributed protocols. The SDN controller continuously monitors the topology of the network and sets up MACsec for detected links. SDN switches implement the header structures and functionalities of MACsec, including encryption and decryption using AES-GCM. OF only supports control plane programmability, i.e., MACsec data plane functionality cannot be implemented on the SDN switches. Therefore, we propose a concept for MACsec in P4-based SDN and call it P4-MACsec. P4 switches implement packet switching based on MAC addresses and MACsec, i.e., MACsec encryption, decryption, and integrity checks of packets. For efficiency reasons, P4 switches are steered by a two-tier control plane. Each P4 switch runs a local controller that connects to a central controller. Functions of the control plane may be solely part of the local controller or part of both tiers. The control plane implements MAC address learning for packet switching, a novel process for secure link discovery with encrypted LLDP packets, and automated deployment of MACsec. To demonstrate the feasibility of P4-MACsec, we provide a prototype based on the BMv2 P4 software switch [6]. We perform a functional validation of P4-MACsec in a Mininet testbed through experiments and investigate on TCP throughput and round-trip time (RTT) by conducting a performance evaluation. We publish the source code of the prototype and all experiments on Github [7]. In addition, we report on experiences in implementing P4-MACsec for the NetFPGA SUME [8] platform.\n\nThe rest of the paper is structured as follows. In Section II, we review technical background and related work for IEEE 802.1AE (MACsec). Section III discusses technical background and related work on link discovery in SDN. In Section IV, we give an overview on P4. Section V describes the architecture of P4-MACsec. In Section VI, we describe the prototypical implementation of P4-MACsec with Mininet that is validated in Section VII. In Section VIII, we present a performance evaluation of the Mininet prototype. In Section IX, we report on experiences in implementing P4-MACsec on the NetFPGA SUME platform. Section X concludes this work.\n\nII MACsec: Foundations and Related Work\n\nWe give an overview of IEEE 802.1AE (MACsec) and explain how it protects the Ethernet layer. We describe mechanisms for configuration and key management and review related work on the application of MACsec in SDN.\n\nII-A Overview of MACsec\n\nIEEE 802.1AE [9] introduces the media access control security (MACsec) protocol. It provides point-to-point security between MACsec peers that are connected to the same local area network (LAN). Examples are links between two switches or routers, links between switches or routers and hosts, and links between hosts. MACsec ensures the integrity, confidentiality, and authenticity of Ethernet (IEEE 802) frames through applying symmetric encryption and cryptographic hash functions. In addition, it provides replay protection and a key exchange protocol to ensure perfect forward secrecy, i.e., session keys are not affected by a compromised private key.\n\nFigure 1 visualizes the principle and the core components of MACsec. The network hosts A, B, and C are part of a LAN. Each network host has a MAC security entity (SecY) and a MAC security key agreement entity (KaY). The SecY provides secure MAC services over an insecure MAC service, i.e., it performs packet encryption and decryption. The KaY discovers other KaYs in the LAN that participate in the same connectivity association (CA). It ensures that all network hosts are mutually authenticated and authorized. Afterwards, it creates and maintains secure channels (SCs) between the MACsec peers that are used by the SecY to transmit and receive network packets. SCs are sender-specific, unidirectional, point-to-multipoint channels. Each SC holds multiple secure associations (SAs) that have a secure association key (SAK) used for encrypting, decrypting, and authenticating packets.\n\nMACsec leverages cipher suites for packet encryption, decryption, and authentication. The standard defines the Advanced Encryption Standard in Galois/Counter mode (AES-GCM) with a block length of 128 bit (AES-GCM-128) as required cipher suite. If only packet authentication but no encryption is configured, MACsec applies the Galois Message Authentication Code (GMAC). Further specifications [10, 11] add GCM-AES-256, GCM-AES-XPN-128, and GCM-AES-XPN-256, but other cipher suites that meet several requirements defined in the standard may also be applied.\n\nFigure 2 depicts the packet structure of MACsec. The Ethernet source and destination addresses of the MACsec packet are adopted from the original Ethernet packet. The secure data field either contains the encrypted user data of the original Ethernet packet or the user data in plaintext if only MACsec packet authentication is configured. The integrity check value (ICV) field holds the result of a cryptographic hash function that is applied on the whole Ethernet packet (1) including all header fields. The secure data and ICV is calculated by the chosen cypher suite (2). The security tag (SecTAG) contains MACsec information, e.g., the SC or SA identifier to choose the corresponding SAK for packet encryption, decryption, or authentication. SecYs store multiple SAs with SAKs for each SC. When SAKs should be changed in rekeying, one SecY uses a new SA and signals the usage within the SecTAG so that the receiving SecY can also change to the new SA.\n\nMACsec is supported by most managed access, distribution, and core switches from major manufacturers. In addition, it is part of the Linux kernel since version 4.6 [12] so that even switch-to-host or host-to-host links can be protected.\n\nII-B MACsec Key Exchange Protocol\n\nThe 802.1AE standard does not define processes for key management or establishment of CAs and SAs between KaYs on MACsec peers. Therefore, network administrators are required to configure the CA affiliation and SAs with SAKs on every MACsec peer. IEEE 802.1X-2010 [13] introduces the MACsec Key Agreement Protocol (MKA) for automated peer discovery and exchange of SA data. With MKA, the initial CA affiliation and SA with SAK is derived from a connectivity association key (CAK). CAKs are either defined as pre-shared secret, derived from a master session key of an EAP process, or distributed by a MKA key server. Switches are required to implement additional functionalities to either exchange keying information via EAP with an AAA server or with an MKA key server. Therefore, additional configuration effort is still required for each switch.\n\nII-C Comparison to VPNs\n\nVPN technologies such as IPsec, OpenVPN, or WireGuard operate on Layer 3 or above. MACsec operates on Layer 2 and therefore provides link security for any higher-layer protocol. It applies point-to-point protection while VPNs aim at end-to-end protection. On every switch, router, or host in the network, MACsec packets are decrypted at the ingress port so that control plane functions targeting Layer 2 to 7 can be still applied. Access control lists (ACL) that provide filtering based on IP addresses are an example. Then, packets are encrypted again at the egress port. MACsec is configured per Ethernet link so that administrators do not need to define additional policies for specific traffic to be encrypted. On routers and switches, MACsec is implemented on the packet forwarding chips, i.e., packet encryption and decryption is performed in line rate. In contrast, VPN technologies mostly encrypt and decrypt packets on ASICs that have limited bandwidth capacity. According to [1], IPsec traffic typically cannot exceed 40 Gb/s of bidirectional traffic while MACsec encryption and decryption scales with line rate.\n\nII-D Application of MACsec in SDN\n\nThe authors of [14] adopt MACsec to secure communication in vehicular networks between Linux-based electronic control units (ECUs). An SDN controller is responsible for automated setup of MACsec between ECUs to provide an end-to-end protection for network traffic. However, MACsec deployment is limited to the ECUs, i.e., MACsec deployment on SDN switches that connect the ECUs is not considered. The authors of [15] develop an intent-based multilayer orchestrator as application that interfaces an SDN controller. It automatically deploys protection technologies such as IPsec or MACsec on legacy switches through different southbound protocols, e.g., OpenFlow, NETCONF, or RESTCONF. However, MACsec deployment on SDN switches is not considered. The authors of [16] propose to implement MACsec for SDN but do not formulate any concrete approach. The authors of [17] discuss implementation experiences and design challenges for WAN overlays using SDN and propose MACsec as viable option to implement link layer encryption. However, the presented implementation is limited to OpenVPN. Automated configuration of MACsec on SDN switches is proposed, but not part of the presented implementation. The authors of [18] describe a mechanism for MACsec key distribution of particular MACsec flows to switches. MACsec flows are end-to-end SCs that break up the point-to-point concept of the original standard. They are realized by configuring MACsec keys only on both end peers, but not on the peers in between. As prerequisite, all MACsec peers are expected to forward MACsec packets if no key for the received packet is found.\n\nIII Link Discovery in SDN: Foundations and Related Work\n\nAutomated deployment of MACsec by a SDN controller requires a topology view that is maintained through topology monitoring with link discovery between SDN switches. We give an overview on link discovery in SDN and describe the OpenFlow Discovery Protocol (OFDP). We review related work on variants of the OFDP that are optimized regarding security, efficiency, and applicability in hybrid SDN networks.\n\nIII-A Topology Monitoring and Link Discovery in SDN\n\nTopology monitoring in SDN maintains a network map on the SDN controller that consists of SDN switches and links in between. In contrast to legacy networks, topology monitoring in SDN can be limited to link discovery. In OpenFlow (OF), SDN switches establish a connection to a pre-configured SDN controller during the start. The SDN controller receives information about the SDN switch, e.g., a list of all physical ports, within the OF handshake at connection setup. With the P4 Runtime API, the SDN controller may connect to P4 switches during the start. In both cases, the SDN controller already identified all SDN switches so that only links need to be detected.\n\nIII-B OpenFlow Discovery Protocol (OFDP)\n\nThe OpenFlow Discovery Protocol (OFDP) was the first de-facto standard for link discovery in SDN. It leverages the Link Layer Discovery Protocol (LLDP) [19], the most widely used protocol for link detection in legacy networks. The Cisco Discovery Protocol (CDP) [20] is a proprietary alternative but less widely used. LLDP advertisements include information about the identity of a host, its capabilities, and its current status. LLDP protocol data units (PDUs) are periodically sent as payload of Ethernet frames with a multicast receiver address and the EtherType 0x88cc. Figure 3 depicts their structure. The PDUs may contain various type-length value (TLV) blocks, the standard defines three required TLV blocks. First, the Chassis ID TLV identifies the sending host, e.g., by its MAC address. Second, the Port ID TLV identifies the sender’s port, e.g., its physical port number. Last, the Time-to-Live TLV defines the time validity of the information. Optional TLV blocks, e.g., the system’s name defined by the administrator, and custom TLVs may be used as well. Network hosts that implement LLDP can receive, but not request LLDP information. Legacy switches periodically send out LLDP packets on each active port as described before. The packets are received, processed, and dropped by neighbouring LLDP agents on switches. They store the received information in the management information bases (MIBs) that can be queried by SNMP.\n\nThe OFDP leverages LLDP as introduced before but delegates all functionalities to the SDN controller. It uses packet-out messages to send out created network packets over particular ports of a SDN switch and packet-in messages to receive packets from the SDN switch that match specific criterias, e.g., an LLDP EtherType. Figure 4 depicts the process of link discovery with OFDP. First, the SDN controller learns about the switch identity and its ports within the OF handshake (1). Afterwards, it creates dedicated LLDP packets for all ports of a switch that are sent out via packet-out messages (2). For incoming LLDP packets, the OF switches are configured to forward any LLDP packet as packet-in message to the SDN controller (3). The packet-in message includes the LLDP packet with the Chassis and Port ID of the sender along the identity and the ingress port of the receiving SDN switch. By repeating this process for each port on each switch, the SDN controller performs link discovery.\n\nIII-C Optimized Variants of OFDP\n\nWe review related work on optimized variants of OFDP that can be subdivided into publications investigating the security of OFDP, efficiency of OFDP, and applicability of OFDP in hybrid networks.\n\nIII-C1 Security of OFDP\n\nThe authors of [21], [22], [23], and [24] show that OFDP is vulnerable to spoofing attacks. Injected LLDP control messages may create fake links that redirect traffic to the host of an attacker. The authors of [23] show that OFDP is additionally vulnerable to controller fingerprinting, switch fingerprinting, and LLDP flooding attacks. The authors of [24] show that OFDP is vulnerable to replay attacks of LLDP packets that result in incorrect link information of the topology. As improvement, the authors of [21] and [22] propose to add a message authentication code (MAC) and a message identifier to each packet to provide authentication, packet integrity, and to prevent replay attacks. sOFTDP [25] encrypts LLDP packets to further prevent fingerprinting attacks.\n\nIII-C2 Efficiency of OFDP\n\nThe authors of [23] and [26] show that OFDP results in too many packet-out messages as the SDN controller has to create and send out one message for every port on each SDN switch. As an improvement, the authors of [27] propose to apply LLDP with Port IDs set to zero. The SDN controller creates one LLDP packet for every SDN switch that are configured to output the LLDP packet on all ports. This process is repeated for all SDN switches. Adjacent SDN switches are configured to forward received LLDP packets to the SDN controller so that it learns about the unidirectional link. The authors of [28] propose to reduce the number of packet-out messages through rewriting LLDP packets on the SDN switch. sOFTDP [25] introduces several mechanisms to shift large parts of link discovery back to the SDN switch. It adds liveliness detection mechanisms for switch ports and memorizes topology information locally on the SDN switch that asynchronously notifies the SDN controller about specific events. The authors of [26] propose the Tree Exploration Discovery Protocol. SDN controllers create and send out specific frames flooded in the network that explore its topology. However, all concepts that shift functionality back to the SDN switches require extensive functional changes on the fixed-function data plane of typical SDN switches.\n\nIII-C3 Applicability of OFDP in Hybrid Networks\n\nHybrid networks consist of SDN and non-SDN switches. OFDP can be only applied to detect links in networks that consist of SDN switches. Legacy switches that may connect SDN switches process and discard received LLDP packets. The Broadcast Domain Discovery Protocol (BDDP) is a non-standardized approach that is implemented by several SDN controllers [29, 30, 31]. BDDP messages adapt the LLDP packet structure but use a broadcast Ethernet address instead of a multicast Ethernet address and the custom EtherType 0x8999. SDN switches are programmed to forward received BDDP packets to the SDN controller, just as with LLDP. Legacy switches flood the packet through all ports because of the broadcast address. They relay BDDP packets so that links will appear as single hops no matter how many legacy devices are on the path between two SDN switches. However, the authors of [32] show that the usage of broadcast packets leads to inefficient and excessive utilization of network resources. The authors propose a two-phase process for topology detection. First, the SDN controller performs link discovery using OFDP as described before. Afterwards, it outputs BDDP packets on any active port for which it does not detect a direct link to another SDN switch via LLDP. This way, the SDN controller detects direct links via LLDP and indirect links via BDDP.\n\nVI Prototypical Implementation with Mininet\n\nIn the following, we describe a prototypical implementation of P4-MACsec. We review the Mininet testbed environment and describe the three components of P4-MACsec in detail.\n\nVI-A Testbed Environment\n\nWe use the Mininet [45] network emulator to build the testbed environment for the prototypical implementation. We leverage the BMv2 P4 software switch [46] for implementing the P4 switch and run the local controllers and the central controller as Python applications. For testing purposes, we additionally run Mininet network hosts that are connected to the P4 switches. All testbed components are executed within a KVM/QEMU virtual machine (VM) that runs Ubuntu 16.04. with 4 CPU cores and 4GB RAM. The hypervisor host features an Intel Core i5 8250U CPU, 16GB RAM, and an SSD.\n\nVI-B P4 Switch\n\nWe extend the simple_switch_grpc [47] P4 target of the BMv2 P4 software switch [46] to later run our P4 program that describes the data plane functions. Figure 12 depicts its parts. First, we implement the MACsec protect and validate functions as P4 externs within the simple_switch_grpc P4 target. We program the extensions in C++ and leverage the envelope (EVP) interface of OpenSSL [48] to apply AES-GCM for encryption, decryption, and packet authentication. Both functions can be used as P4 externs within the P4 processing pipeline. When accessing the functions from the P4 processing pipeline, packet header data is exchanged using P4 attributes where packet payload data can be accessed directly. Second, we implement an interface to the local controller. It leverages the P4 runtime API via gRPC and allows the local controller to modify entries of the P4 tables in the processing pipeline. In addition, it holds the CPU port interface that provides packet-in and packet-out messages as known from OpenFlow. Packets sent from the P4 pipeline to the CPU port are forwarded to the local controller, packets received from the CPU port are injected into the P4 processing pipeline. The data plane functions of P4-MACsec described as P4 processing pipeline in Section V are implemented as P4_16 program using known P4 constructs as introduced in Section IV. The P4 program then is executed on the modified simple_switch_grpc P4 target as P4 switch.\n\nVI-C Local Controller\n\nWe implement the local controller as Python 2.7 application. Figure 12 depicts its parts. We leverage the gRPC library [49] to program the interfaces to the associated P4 switch and to the central controller. We use the Scapy library [50] to create and parse LLDP packets and the cryptography library [51] for applying AES-GCM to encrypt and decrypt LLDP packets. For development and testing purposes, the local controller features a simple CLI. It allows to write and read table entries and to display status changes on the P4 switch.\n\nVI-D Central Controller\n\nWe implement the central controller similar to the local controller as Python 2.7 application. Figure 12 depicts its parts. It also leverages the gRPC library [49] to build an gRPC interface to the local controller. It also features a simple CLI for development and testing purposes that displays information about the current topology and active MACsec secure channels (SCs). The control plane functions of P4-MACsec can also be integrated in ONOS [31] or other controller frameworks. However, our objectives was a lightweight prototype using a slim and easy-to-understand controller implementation which directly leverages the P4 runtime and gRPC library for communication. Thereby, we avoided dependencies on other controller frameworks which increase error space and implementation complexity.\n\nVII Functional Validation\n\nWe describe the experiment setup and validation experiments executed on the testbed from Section VI.\n\nVII-A Experiment I: Compliance to the MACsec Standard\n\nWe first perform an experiment to examine the compliance of P4-MACsec to the IEEE 802.1AE standard. Therefore, we set up a virtualized testbed that consists of a KVM virtual machine running Ubuntu Server in Version 18.04.1 LTS and our implementation of P4-MACsec on the BMv2 P4 software switch as described in Section VI. The P4 switch connects another Ubuntu Server 18.04.1 LTS KVM/QEMU virtual machine that represents a network host behind a MACsec-enabled switch. We configure a static MACsec connection between a P4 switch and a Linux host to check whether the MACsec implementation for BMv2 is compatible with the Linux implementation of MACsec. On the Ubuntu server, we set up the static MACsec connection using the iproute2 tools. For MACsec setup on the P4 switch, we use a simple Python script that adds the corresponding entries in the EG-SC, IG-SC, and SA tables of the P4 processing pipeline. We successfuly validate that the Ubuntu server communicates with the P4 switch via MACsec in different communication scenarios, e.g., ICMP or streaming random data via TCP connections with netcat. This does not validate a full compliance to all parts of the MACsec standard but demonstrates, that the P4 switch can communicate via MACsec with legacy devices.\n\nVII-B Experiment II: Complete P4-MACsec Scenario\n\nWe now investigate the complete set of functionality of P4-MACsec. Therefore, we create the topology depicted in Figure 13. It follows the model of hierarchical network switches that consists of core, aggregation, and access switches. A set of 12 network hosts is split into four groups, each attached to an access switch. The four access switches are connected to two aggregation switches that are connected by a single core switch. The testbed network is a single Layer 2 domain, i.e., network packets are forwarded based on their MAC address. After starting the Mininet testbed, we verify the following aspects. First, we examine that topology monitoring works correctly. In initial link discovery, we verify that the detected topology matches the actual network topology. Afterwards, we sporadically remove and re-add links between switches and supervise the process of link monitoring on the central controller via a CLI. Second, we examine that automated deployment of MACsec and rekeying works correctly. We investigate MACsec setup after changes in link monitoring through supervising the EG-SC, IG-SC, and SA tables on all P4-MACsec switches. Last, we examine packet switching and correct setup of MACsec protection. Therefore, we use ICMP and netcat to create network traffic between various pairs of network hosts in the experiment scenario. We investigate packet traces on links between switches and verify that all packets are protected by MACsec.\n\nVIII Performance Evaluation\n\nWe describe the evaluation setup and experiments for performance evaluation executed on the testbed from Section VI.\n\nVIII-A Evaluation Setup\n\nFigure 14 depicts the evaluation setup. It consists of two network hosts that are attached to two P4 switches with 00 to 666 P4 switches in between. We perform performance evaluation experiments to investigate the throughput and round-trip time (RTT). We vary the number of P4 switches between the two network hosts and measure throughput and RTT for 111 to 888 hops. For each evaluation experiment, we consider three scenarios. In the first scenario, MACsec is disabled, i.e., the P4 switches between Host 1 and Host 2 only perform MAC address learning and L2 forwarding. In the second scenario, we enable MACsec so that all packets between Host 1 and Host 2 are protected with AES-GCM implemented as P4 Extern. In the third scenario, we enable MACsec but skip AES-GCM encryption and decryption in the P4 extern so that only cleartext payloads are sent within the MACsec packets. This third scenario is not part of the MACsec standard but a modification for the performance evaluation that allows us to measure the impact of AES-GCM in comparison to the impact of exchanging network packets with an P4 extern.\n\nVIII-B TCP Throughput\n\nWe first investigate on the TCP throughput in P4-MACsec. Therefore, we measure TCP transmissions between Host 1 and Host 2 with iperf3 [52]. Host 1 runs an iperf server, Host 2 runs an iperf client. We perform three runs, each with a duration of 30 seconds. Figure 15 depicts the results calculated as average over the three runs. As expected, the throughput for all scenarios decreases with the number of P4 switches that run on the testbed. Enabled MACsec processing causes a large degradation in throughput. However, applying or omitting AES-GCM in the P4 extern does not cause large differences in throughput. The large decrease in throughput is not the result of encryption or decryption with AES-GCM but an effect of the interaction between the P4 pipeline and the MACsec protect and MACsec validate P4 externs in BMv2.\n\nVIII-C Round-Trip Time (RTT)\n\nIn the second experiment, we investigate the round-trip time (RTT) between the two network hosts that are connected by 111 to 888 P4 switches in between. We use the ping [53] tool on Host 1 to send 100010001000 consecutive ICMP echo requests to Host 2. We set an idle period of 0.010.010.01 seconds between two ICMP packets and perform three runs of the experiment. Figure 16 depicts the RTTs calculated as average over the three runs. The evaluation results are similar to those of the experiment on TCP throughput. Enabled MACsec causes an increase of the RTT. Again, applying or omitting AES-GCM in the P4 extern does not cause large differences in the RTT. As in the experiment on TCP throughput, the interaction between the P4 pipeline and the MACsec protect and MACsec validate P4 externs in BMv2 seems to cause the negative effects on the RTT.\n\nVIII-D MACsec Setup Time\n\nAs described in Section V, the two-tier control plane automatically configures and enables MACsec on all assigned P4 switches. As described in Section II-B, MACsec deployments require configuration effort whether static key setup on all switches or MKA is applied. With P4-MACsec, that configuration effort to deploy MACsec completely disappears. The process of link discovery, MACsec setup, and the periodically reiterations are performed within nearly not measureable time intervals. The two-tier control plane performs all actions sequentially, i.e., delays might turn up with a very large number of controlled P4 switches.\n\nIX Implementation on NetFPGA SUME\n\nIn the following, we briefly describe the NetFPGA SUME [8] platform and outline our experiences in implementing P4-MACsec for that platform.\n\nIX-A NetFPGA SUME Platform\n\nThe NetFPGA SUME board is a platform for rapid prototyping of network applications with bandwidths up to 10 Gb/s. It features a Virtex-7 690T field-programmable gate array (FPGA), four SFP+ network transceivers, and an PCI Express interface to the host system [37]. The P4-NetFPGA project [54] transforms the NetFPGA SUME board into a hardware P4 switch. P4 programs are transformed into SDNet descriptions by the P4-SDNet compiler that creates HDL modules that run as part of the reference architecture of the NetFPGA SUME board.\n\nIX-B Implementation of P4-MACsec\n\nWe modify the P4 processing pipeline of our software prototype to cope with limitations of the architecture, e.g., a missing lookahead function in packet parsing or the limitation to a single instead of multiple control blocks in the P4 processing pipeline. We implemented AES-GCM based on a publicly available Verilog module from OpenCores [55]. However, we were not able to create a fully working P4-MACsec switch due to two severe limitations. First, the NetFPGA SUME platform does not provide functions to parse or access variable-length payloads of network packets. Therefore, payloads of network packets need to be parsed as headers, which limits the implementation to fixed-length packets. Last, exchange of packet data between the P4 processing pipeline and the P4 external function is limited. Currently, data that is transferred from the P4 processing pipeline to a P4 external function needs to be transmitted within one clock cycle of the FPGA. Due to timing limitations, it is only possible to transmit very small amounts of data. The developers from the P4-NetFPGA project confirmed that the current version does not allow to process complete network packets within P4 externs. We were able to increase the amount of data to be exchangeable by reducing the base clock frequency of the NetFPGA to 128 bytes. However, this is still far away from real-world applicability. A packet streaming function through P4 external functions was announced, but is not available so far. Summing up, both limitations did not allow us to build a prototype that is suitable for real-world scenarios with variable-length packets exceeding a total length of 128 bytes.\n\nX Conclusion\n\nIn this work we proposed P4-MACsec, a concept to automatically protect links between switches with MACsec in P4-SDN. Our concept features a P4 data plane implementation for MACsec including encryption and decryption using AES-GCM. P4 switches are steered by a novel two-tier control plane that consists of local controllers running on all P4 switches that connect to a central controller. We presented a novel mechanism for link discovery using encrypted LLDP packets and automated deployment of MACsec link protection. We presented the architecture of P4-MACsec and demonstrated its feasability in a prototypical implementation for the BMv2 P4 software switch. We used that prototype to experimentally validate P4-MACsec in a virtualized testbed built with Mininet and performed evaluation experiments. We discussed experiences with implementing P4-MACsec for the NetFPGA SUME platform. We discovered that both P4 targets have major constraints regarding the implementation of P4-MACsec. Using the P4 externs for MACsec on the NetFPGA SUME platform was not feasible at all. Only fixed-lenght packets that do not exceed a total size of 128 bytes can be exchanged. Using the P4 externs for MACsec on the BMv2 P4 target results in large degradations in TCP througput and latency in RTTs. However, use-cases that aim at securing the network by applying authentication, encryption, and integrity checks are important. P4-MACsec completely eliminates previous configuration efforts for MACsec as network security mechanism. Similar approaches for traffic protection on different layers, e.g., L3 or L4 VPN, are imaginable. Therefore, P4 switches should offer native functional blocks for encryption and decryption and overhead-free interfaces to P4 externs.\n\nAcknowledgment\n\nThe authors thank Joshua Harmann for fruitful discussions and programming contributions.\n\nReferences\n\n[1] “Cisco: Innovations in Ethernet Encryption (802.1AE - MACsec),” https://www.cisco.com/c/dam/en/us/td/docs/solutions/Enterprise/Security/MACsec/WP-High-Speed-WAN-Encrypt-MACsec.pdf, 2016, accessed 12-02-2018.\n\n[2] “IEEE8021-SECY-MIB: Definitions of Managed Objects Supporting IEEE 802.1AE MACsec.” http://www.ieee802.org/1/files/public/MIBs/IEEE8021-SECY-MIB-200601100000Z.txt, accessed 04-14-2019.\n\n[3] N. McKeown et al., “OpenFlow: Enabling Innovation in Campus Networks,” ACM SIGCOMM Computer Communication Review, vol. 38, no. 2, pp. 69–74, 2008.\n\n[4] P. Bosshart et al., “P4: Programming Protocol-independent Packet Processors,” SIGCOMM Comput. Commun. Rev., vol. 44, no. 3, pp. 87–95, Jul. 2014.\n\n[5] “P4 Runtime Spec. 1.0.0-rc3,” https://s3-us-west-2.amazonaws.com/p4runtime/docs/v1.0.0-rc3/P4Runtime-Spec.html, accessed 10-09-2018.\n\n[6] “Github: p4lang/bmv2,” https://github.com/p4lang/behavioral-model, accessed 10-09-2018.\n\n[7] “Github: uni-tue-kn/p4-macsec,” https://github.com/uni-tue-kn/p4-macsec.\n\n[8] “NetFPGA project website,” https://netfpga.org, accessed 10-09-2018.\n\n[9] IEEE, “802.1AE-2006 IEEE Standard for Local and Metropolitan Area Networks - Media Access Control (MAC) Security,” 2006.\n\n[10] ——, “802.1AEbn-2011 IEEE Standard for Local and Metropolitan Area Networks - Media Access Control (MAC) Security Amendment 1: Galois Counter Mode - Advanced Encryption Standard - 256 (GCM-AES-256) Cipher Suite,” 2011.\n\n[11] ——, “802.1AEbw-2013 IEEE Standard for Local and Metropolitan Area Networks — Media Access Control (MAC) Security Amendment 2: Extended Packet Numbering,” 2013.\n\n[12] “RHD Blog: MACsec: a different solution to encrypt network traffic,” https://developers.redhat.com/blog/2016/10/14/macsec-a-different-solution-to-encrypt-network-traffic/, accessed 01-03-2019.\n\n[13] IEEE, “802.1X-2010 IEEE Standard for Local and Metropolitan Area Networks - Port-Based Network Access Control,” 2010.\n\n[14] J. Choi et al., “MACsec Extension over Software-Defined Networks for in-Vehicle Secure Communication,” in 2018 Tenth International Conference on Ubiquitous and Future Networks (ICUFN), July 2018, pp. 180–185.\n\n[15] T. Szyrkowiec et al., “Automatic Intent-Based Secure Service Creation Through a Multilayer SDN Network Orchestration,” CoRR, vol. abs/1803.03106, 2018. [Online]. Available: http://arxiv.org/abs/1803.03106\n\n[16] O. I. Bentstuen and J. Flathagen, “On Bootstrapping In-Band Control Channels in Software Defined Networks,” in 2018 IEEE International Conference on Communications Workshops (ICC Workshops), May 2018, pp. 1–6.\n\n[17] M. Vajaranta et al., “Implementation Experiences and Design Challenges for Resilient SDN Based Secure WAN Overlays,” in 2016 11th Asia Joint Conference on Information Security (AsiaJCIS), Aug 2016, pp. 17–23.\n\n[18] P. S. Mohamed et al., “Network Controller Provisioned MACsec Keys,” Dec. 17 2015, US Patent App. 14/763,484.\n\n[19] IEEE, “802.1AB-2009 IEEE Standard for Local and Metropolitan Area Networks - Station and Media Access Control Connectivity Discovery, Corrigendum 2: Technical and Editorial Corrections,” 2015.\n\n[20] “Cisco Discovery Protocol Configuration Guide,” https://www.cisco.com/c/en/us/td/docs/ios-xml/ios/cdp/configuration/15-mt/cdp-15-mt-book/nm-cdp-discover.html, accessed 10-15-2018.\n\n[21] T. Alharbi et al., “The (In)Security of Topology Discovery in Software Defined Networks,” in 2015 IEEE 40th Conference on Local Computer Networks (LCN), Oct 2015, pp. 502–505.\n\n[22] ——, “The (In)Security of Topology Discovery in Openflow-Based Software Defined Network,” International Journal of Network Security & Its Applications, vol. 10, pp. 01–16, 05 2018.\n\n[23] A. Azzouni et al., “Limitations of OpenFlow Topology Discovery Protocol,” in 2017 16th Annual Mediterranean Ad Hoc Networking Workshop (Med-Hoc-Net), June 2017, pp. 1–3.\n\n[24] T.-H. Nguyen and M. Yoo, “Analysis of Link Discovery Service Attacks in SDN Controllers,” in 2017 International Conference on Information Networking (ICOIN), Jan 2017, pp. 259–261.\n\n[25] A. Azzouni et al., “sOFTDP: Secure and Efficient Topology Discovery Protocol for SDN,” ArXiv e-prints, May 2017.\n\n[26] E. Rojas et al., “TEDP: An Enhanced Topology Discovery Service for Software-Defined Networking,” IEEE Communications Letters, vol. 22, no. 8, pp. 1540–1543, Aug 2018.\n\n[27] “ONOS Wiki: Network Discovery,” https://wiki.onosproject.org/display/ONOS/Network+Discovery, accessed 10-09-2018.\n\n[28] F. Pakzad et al., “Efficient Topology Discovery in Software Defined Networks,” in 2014 8th International Conference on Signal Processing and Communication Systems (ICSPCS), Dec 2014, pp. 1–8.\n\n[29] “OpenDaylight Platform,” https://www.opendaylight.org/, accessed 10-14-2018.\n\n[30] “Floodlight: OpenSource SDN Controller,” http://www.projectfloodlight.org/floodlight/, accessed 10-14-2018.\n\n[31] “ONOS - Carrier-grade SDN Network Operating System,” https://onosproject.org/, accessed 04-05-2019.\n\n[32] L. Ochoa Aday et al., “Current Trends of Topology Discovery in OpenFlow-based Software Defined Networks,” 2015.\n\n[33] “P4 Language Consortium,” https://p4.org/, accessed 04-14-2019.\n\n[34] “P4_16 Language Specification, Version 1.1.0,” https://p4.org/p4-spec/docs/P4-16-v1.1.0-spec.html#sec-external-units, accessed 10-09-2018.\n\n[35] “gRPC: A high-performance, open-source universal RPC framework,” https://grpc.io/, accessed 04-14-2019.\n\n[36] “Google Protocol Buffers,” https://developers.google.com/protocol-buffers/, accessed 04-14-2019.\n\n[37] N. Zilberman et al., “NetFPGA SUME: Toward 100 Gbps as Research Commodity,” IEEE Micro, vol. 34, no. 5, pp. 32–41, Sep. 2014.\n\n[38] “Netcope FPGA Boards,” https://www.netcope.com/en/products/fpga-boards, accessed 04-12-2019.\n\n[39] “Barefoot Networks: Tofino 2,” https://www.barefootnetworks.com/products/brief-tofino-2/, accessed 12-26-2018.\n\n[40] “Datasheet: Wedge100BF-32X/65X Switch 100GbE,” https://www.edge-core.com/_upload/images/Wedge100BF-32X_65X_DS_R04_20180531.pdf, accessed 04-10-2019.\n\n[41] Y. Fu, J. Bi, K. Gao, Z. Chen, J. Wu, and B. Hao, “Orion: A hybrid hierarchical control plane of software-defined networking for large-scale networks,” in 2014 IEEE 22nd International Conference on Network Protocols, Oct 2014, pp. 569–576.\n\n[42] S. Hassas Yeganeh and Y. Ganjali, “Kandoo: A framework for efficient and scalable offloading of control applications,” in Proceedings of the First Workshop on Hot Topics in Software Defined Networks, ser. HotSDN ’12. New York, NY, USA: ACM, 2012, pp. 19–24. [Online]. Available: http://doi.acm.org/10.1145/2342441.2342446\n\n[43] T. Kohler, F. Dürr, and K. Rothermel, “Zerosdn: A highly flexible and modular architecture for full-range distribution of event-based network control,” IEEE Transactions on Network and Service Management, vol. 15, no. 4, pp. 1207–1221, Dec 2018.\n\n[44] F. Bannour, S. Souihi, and A. Mellouk, “Distributed SDN Control: Survey, Taxonomy, and Challenges,” IEEE Communications Surveys Tutorials, vol. 20, no. 1, pp. 333–354, Firstquarter 2018.\n\n[45] “Mininet,” http://mininet.org/, accessed 12-08-2018.\n\n[46] “Github: p4lang/behavioral-model,” https://github.com/p4lang/behavioral-model, accessed 12-05-2018.\n\n[47] “SimpleSwitchGrpc,” https://github.com/p4lang/behavioral-model/tree/master/targets/simple_switch_grpc, accessed 12-26-2018.\n\n[48] “OpenSSL,” https://www.openssl.org/, accessed 12-05-2018.\n\n[49] “Github: gRPC Python,” https://github.com/grpc/grpc/tree/master/src/python/grpcio, accessed 12-26-2018.\n\n[50] “Scapy,” https://scapy.net/, accessed 12-26-2018.\n\n[51] “pyca/cryptography Documentation,” https://cryptography.io/en/latest/, accessed 12-26-2018.\n\n[52] “iPerf,” https://iperf.fr/, accessed 04-05-2019.\n\n[53] “ping(8) - Linux man page,” https://linux.die.net/man/8/ping, accessed 04-05-2019.\n\n[54] “Wiki of the P4->NetFPGA project,” https://github.com/NetFPGA/P4-NetFPGA-public, accessed 12-26-2018.\n\n[55] “OpenCores: gcm-aes Project,” https://opencores.org/projects/gcm-aes, accessed 12-26-2018."
    }
}