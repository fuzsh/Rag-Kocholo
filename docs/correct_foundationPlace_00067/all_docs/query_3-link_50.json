{
    "id": "correct_foundationPlace_00067_3",
    "rank": 50,
    "data": {
        "url": "https://github.com/CatacombGames/CatacombArmageddon/blob/master/LZW.C",
        "read_more_link": "",
        "language": "en",
        "title": "CatacombArmageddon/LZW.C at master Â· CatacombGames/CatacombArmageddon",
        "top_image": "https://opengraph.githubassets.com/4bd240de1013b60f1a6c299c3db21db8ed812c26aa001378db6108dfeb236f90/CatacombGames/CatacombArmageddon",
        "meta_img": "https://opengraph.githubassets.com/4bd240de1013b60f1a6c299c3db21db8ed812c26aa001378db6108dfeb236f90/CatacombGames/CatacombArmageddon",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Catacomb Armageddon source code. Contribute to CatacombGames/CatacombArmageddon development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/CatacombGames/CatacombArmageddon/blob/master/LZW.C",
        "text": "/* Catacomb Armageddon Source Code\n\n* Copyright (C) 1993-2014 Flat Rock Software\n\n*\n\n* This program is free software; you can redistribute it and/or modify\n\n* it under the terms of the GNU General Public License as published by\n\n* the Free Software Foundation; either version 2 of the License, or\n\n* (at your option) any later version.\n\n*\n\n* This program is distributed in the hope that it will be useful,\n\n* but WITHOUT ANY WARRANTY; without even the implied warranty of\n\n* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the\n\n* GNU General Public License for more details.\n\n*\n\n* You should have received a copy of the GNU General Public License along\n\n* with this program; if not, write to the Free Software Foundation, Inc.,\n\n* 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA.\n\n*/\n\n//===========================================================================\n\n//\n\n// LZW COMPRESSION ROUTINES\n\n// VERSION 1.1\n\n//\n\n// Compression algrythim by Haruhiko OKUMURA\n\n// Implementation by Jim T. Row\n\n//\n\n//\n\n// Copyright (c) 1992 - Softdisk Publishing inc. - All rights reserved\n\n//\n\n//===========================================================================\n\n//\n\n//\n\n//---------------------------------------------------------------------------\n\n#include <stdio.h>\n\n#include <stdlib.h>\n\n#include <string.h>\n\n#include <ctype.h>\n\n#include <alloc.h>\n\n#include <fcntl.h>\n\n#include <dos.h>\n\n#include <io.h>\n\n#include \"lzw.h\"\n\n#include \"jam_io.h\"\n\n//===========================================================================\n\n//\n\n// SWITCHES\n\n//\n\n// NOTE : Make sure the appropriate switches are set in SOFT.c for Softlib\n\n// archive support.\n\n//\n\n//===========================================================================\n\n#define INCLUDE_LZW_COMP 0\n\n#define INCLUDE_LZW_DECOMP 1\n\n//===========================================================================\n\n//\n\n// DEFINES\n\n//\n\n//===========================================================================\n\n#define LZW_N 4096\n\n#define LZW_F 18\n\n#define LZW_THRESHOLD 2 // encode string into position and\n\n// length if match_length is greater\n\n// than this\n\n#define LZW_NIL LZW_N // index for root of bin search trees\n\n//============================================================================\n\n//\n\n// GLOBAL VARIABLES NECESSARY FOR\n\n//\n\n// COMP/DECOMP ROUTINES.\n\n//\n\n//============================================================================\n\nunsigned char far LZW_ring_buffer[LZW_N + LZW_F - 1]; // ring buffer of size\n\n// LZW_N, with extra\n\n// LZW_F-1 bytes to\n\n// facilitate\n\n// string comparison\n\n#if INCLUDE_LZW_COMP\n\nint LZW_match_pos, // MAtchLength of longest match. These are set by the\n\n// InsertNode() procedure.\n\nLZW_match_len,\n\n// left & right children & parents -- These constitute binary search trees. */\n\nLZW_left_child[LZW_N + 1],\n\nLZW_right_child[LZW_N + 257],\n\nLZW_parent[LZW_N + 1];\n\n#endif\n\n//============================================================================\n\n//\n\n// LZW DISPLAY VECTORS\n\n//\n\n// These vectors allow you to hook up any form of display you desire for\n\n// displaying the compression/decompression status.\n\n//\n\n// These routines are called inside of the compression/decompression routines\n\n// and pass the orginal size of data and current position within that\n\n// data. This allows for any kind of \"% Done\" messages.\n\n//\n\n// Your functions MUST have the following parameters in this order...\n\n//\n\n// void VectorRoutine(unsigned long OrginalSize,unsigned long CurPosition)\n\n//\n\n//\n\nvoid (*LZW_CompressDisplayVector)() = NULL;\n\nvoid (*LZW_DecompressDisplayVector)() = NULL;\n\n//============================================================================\n\n//\n\n// SUPPORT ROUTINES FOR LZW COMPRESSION\n\n//\n\n//============================================================================\n\n#if INCLUDE_LZW_COMP\n\nstatic void InitLZWTree(void) /* initialize trees */\n\n{\n\nint i;\n\n/* For i = 0 to LZW_N - 1, LZW_right_child[i] and LZW_left_child[i] will be the right and\n\nleft children of node i. These nodes need not be initialized.\n\nAlso, LZW_parent[i] is the parent of node i. These are initialized to\n\nLZW_NIL (= LZW_N), which stands for 'not used.'\n\nFor i = 0 to 255, LZW_right_child[LZW_N + i + 1] is the root of the tree\n\nfor strings that begin with character i. These are initialized\n\nto LZW_NIL. Note there are 256 trees. */\n\nfor (i = LZW_N + 1; i <= LZW_N + 256; i++)\n\nLZW_right_child[i] = LZW_NIL;\n\nfor (i = 0; i < LZW_N; i++)\n\nLZW_parent[i] = LZW_NIL;\n\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nstatic void InsertLZWNode(unsigned long r)\n\n/* Inserts string of length LZW_F, LZW_ring_buffer[r..r+LZW_F-1], into one of the\n\ntrees (LZW_ring_buffer[r]'th tree) and returns the longest-match position\n\nand length via the global variables LZW_match_pos and LZW_match_len.\n\nIf LZW_match_len = LZW_F, then removes the old node in favor of the new\n\none, because the old one will be deleted sooner.\n\nNote r plays double role, as tree node and position in buffer. */\n\n{\n\nint i, p, cmp;\n\nunsigned char *key;\n\ncmp = 1;\n\nkey = &LZW_ring_buffer[r];\n\np = LZW_N + 1 + key[0];\n\nLZW_right_child[r] = LZW_left_child[r] = LZW_NIL;\n\nLZW_match_len = 0;\n\nfor ( ; ; )\n\n{\n\nif (cmp >= 0)\n\n{\n\nif (LZW_right_child[p] != LZW_NIL)\n\np = LZW_right_child[p];\n\nelse\n\n{\n\nLZW_right_child[p] = r;\n\nLZW_parent[r] = p;\n\nreturn;\n\n}\n\n}\n\nelse\n\n{\n\nif (LZW_left_child[p] != LZW_NIL)\n\np = LZW_left_child[p];\n\nelse\n\n{\n\nLZW_left_child[p] = r;\n\nLZW_parent[r] = p;\n\nreturn;\n\n}\n\n}\n\nfor (i = 1; i < LZW_F; i++)\n\nif ((cmp = key[i] - LZW_ring_buffer[p + i]) != 0)\n\nbreak;\n\nif (i > LZW_match_len)\n\n{\n\nLZW_match_pos = p;\n\nif ((LZW_match_len = i) >= LZW_F)\n\nbreak;\n\n}\n\n}\n\nLZW_parent[r] = LZW_parent[p];\n\nLZW_left_child[r] = LZW_left_child[p];\n\nLZW_right_child[r] = LZW_right_child[p];\n\nLZW_parent[LZW_left_child[p]] = r;\n\nLZW_parent[LZW_right_child[p]] = r;\n\nif (LZW_right_child[LZW_parent[p]] == p)\n\nLZW_right_child[LZW_parent[p]] = r;\n\nelse\n\nLZW_left_child[LZW_parent[p]] = r;\n\nLZW_parent[p] = LZW_NIL; /* remove p */\n\n}\n\n////////////////////////////////////////////////////////////////////////////\n\nstatic void DeleteLZWNode(unsigned long p) /* deletes node p from tree */\n\n{\n\nint q;\n\nif (LZW_parent[p] == LZW_NIL)\n\nreturn; /* not in tree */\n\nif (LZW_right_child[p] == LZW_NIL)\n\nq = LZW_left_child[p];\n\nelse\n\nif (LZW_left_child[p] == LZW_NIL)\n\nq = LZW_right_child[p];\n\nelse\n\n{\n\nq = LZW_left_child[p];\n\nif (LZW_right_child[q] != LZW_NIL)\n\n{\n\ndo {\n\nq = LZW_right_child[q];\n\n} while (LZW_right_child[q] != LZW_NIL);\n\nLZW_right_child[LZW_parent[q]] = LZW_left_child[q];\n\nLZW_parent[LZW_left_child[q]] = LZW_parent[q];\n\nLZW_left_child[q] = LZW_left_child[p];\n\nLZW_parent[LZW_left_child[p]] = q;\n\n}\n\nLZW_right_child[q] = LZW_right_child[p];\n\nLZW_parent[LZW_right_child[p]] = q;\n\n}\n\nLZW_parent[q] = LZW_parent[p];\n\nif (LZW_right_child[LZW_parent[p]] == p)\n\nLZW_right_child[LZW_parent[p]] = q;\n\nelse\n\nLZW_left_child[LZW_parent[p]] = q;\n\nLZW_parent[p] = LZW_NIL;\n\n}\n\n//--------------------------------------------------------------------------\n\n//\n\n// lzwCompress() - Compresses data from an input ptr to a dest ptr\n\n//\n\n// PARAMS:\n\n// infile - Pointer at the BEGINNING of the data to compress\n\n// outfile - Pointer to the destination (no header).\n\n// DataLength - Number of bytes to compress.\n\n// PtrTypes - Type of pointers being used (SRC_FILE,DEST_FILE,SRC_MEM etc).\n\n//\n\n// RETURNS:\n\n// Length of compressed data.\n\n//\n\n// COMPTYPE : ct_LZW\n\n//\n\n// NOTES : Does not write ANY header information!\n\n//\n\nunsigned long lzwCompress(void far *infile, void far *outfile,unsigned long DataLength,unsigned PtrTypes)\n\n{\n\nshort i;\n\nshort c, len, r, s, last_LZW_match_len, code_buf_ptr;\n\nunsigned char code_buf[17], mask;\n\nunsigned long complen = 0;\n\nunsigned CodeCount = 0;\n\nunsigned long OrgDataLen = DataLength;\n\n// initialize trees\n\nInitLZWTree();\n\ncode_buf[0] = 0;\n\n//\n\n// code_buf[1..16] saves eight units of code, and code_buf[0] works\n\n// as eight flags, \"1\" representing that the unit is an unencoded\n\n// letter (1 byte), \"0\" a position-and-length pair (2 bytes). Thus,\n\n// eight units require at most 16 bytes of code.\n\n//\n\ncode_buf_ptr = mask = 1;\n\ns = 0;\n\nr = LZW_N - LZW_F;\n\n// Clear the buffer with any character that will appear often.\n\n//\n\nfor (i = s; i < r; i++)\n\nLZW_ring_buffer[i] = ' ';\n\n// Read LZW_F bytes into the last LZW_F bytes of the buffer\n\n//\n\nfor (len = 0; (len < LZW_F) && DataLength; len++)\n\n{\n\nc = ReadPtr((long)&infile,PtrTypes);\n\nDataLength--;\n\n// text of size zero\n\nLZW_ring_buffer[r + len] = c;\n\n}\n\nif (!(len && DataLength))\n\nreturn(0);\n\n//\n\n// Insert the LZW_F strings, each of which begins with one or more\n\n// 'space' characters. Note the order in which these strings\n\n// are inserted. This way, degenerate trees will be less likely\n\n// to occur.\n\n//\n\nfor (i = 1; i <= LZW_F; i++)\n\nInsertLZWNode(r - i);\n\n//\n\n// Finally, insert the whole string just read. The global\n\n// variables LZW_match_len and LZW_match_pos are set. */\n\n//\n\nInsertLZWNode(r);\n\ndo {\n\n// LZW_match_len may be spuriously long near the end of text.\n\n//\n\nif (LZW_match_len > len)\n\nLZW_match_len = len;\n\nif (LZW_match_len <= LZW_THRESHOLD)\n\n{\n\n// Not long enough match. Send one byte.\n\n//\n\nLZW_match_len = 1;\n\n// 'send one byte' flag\n\n//\n\ncode_buf[0] |= mask;\n\n// Send uncoded.\n\n//\n\ncode_buf[code_buf_ptr++] = LZW_ring_buffer[r];\n\n}\n\nelse\n\n{\n\ncode_buf[code_buf_ptr++] = (unsigned char) LZW_match_pos;\n\ncode_buf[code_buf_ptr++] = (unsigned char) (((LZW_match_pos >> 4) & 0xf0) | (LZW_match_len - (LZW_THRESHOLD + 1)));\n\n// Send position and length pair.\n\n// Note LZW_match_len > LZW_THRESHOLD.\n\n}\n\nif ((mask <<= 1) == 0)\n\n{\n\n// Shift mask left one bit.\n\n// Send at most 8 units of data\n\nfor (i = 0; i < code_buf_ptr; i++)\n\nWritePtr((long)&outfile,code_buf[i],PtrTypes);\n\ncomplen += code_buf_ptr;\n\ncode_buf[0] = 0;\n\ncode_buf_ptr = mask = 1;\n\n}\n\nlast_LZW_match_len = LZW_match_len;\n\nfor (i = 0; i < last_LZW_match_len && DataLength; i++)\n\n{\n\nc = ReadPtr((long)&infile,PtrTypes);\n\nDataLength--;\n\nDeleteLZWNode(s); // Delete old strings and\n\nLZW_ring_buffer[s] = c; // read new bytes\n\n// If the position is near the end of buffer, extend the\n\n// buffer to make string comparison easier.\n\nif (s < LZW_F - 1)\n\nLZW_ring_buffer[s + LZW_N] = c;\n\n// Since this is a ring buffer, inc the position modulo LZW_N.\n\n//\n\ns = (s + 1) & (LZW_N - 1);\n\nr = (r + 1) & (LZW_N - 1);\n\n// Register the string in LZW_ring_buffer[r..r+LZW_F-1]\n\n//\n\nInsertLZWNode(r);\n\n}\n\n//\n\n// MANAGE DISPLAY VECTOR\n\n//\n\nif (LZW_CompressDisplayVector)\n\n{\n\n// Update display every 1k!\n\n//\n\nif ((CodeCount += i) > 1024)\n\n{\n\nLZW_CompressDisplayVector(OrgDataLen,OrgDataLen-DataLength);\n\nCodeCount = 0;\n\n}\n\n}\n\n//\n\n// Manage Compression tree..\n\n//\n\nwhile (i++ < last_LZW_match_len)\n\n{\n\n// After the end of text,\n\nDeleteLZWNode(s); // no need to read, but\n\ns = (s + 1) & (LZW_N - 1);\n\nr = (r + 1) & (LZW_N - 1);\n\nif (--len)\n\nInsertLZWNode(r); // buffer may not be empty.\n\n}\n\n} while (len > 0); // until length of string to be processed is zero\n\nif (code_buf_ptr > 1)\n\n{\n\n// Send remaining code.\n\n//\n\nfor (i = 0; i < code_buf_ptr; i++)\n\nWritePtr((long)&outfile,code_buf[i],PtrTypes);\n\ncomplen += code_buf_ptr;\n\n}\n\nif (LZW_CompressDisplayVector)\n\n{\n\nif ((CodeCount += i) > 1024)\n\n{\n\nLZW_CompressDisplayVector(OrgDataLen,OrgDataLen-DataLength);\n\n}\n\n}\n\nreturn(complen);\n\n}\n\n#endif\n\n//============================================================================\n\n//\n\n// SUPPORT ROUTINES FOR LZW DECOMPRESSION\n\n//\n\n//============================================================================\n\n#if INCLUDE_LZW_DECOMP\n\n//--------------------------------------------------------------------------\n\n//\n\n// lzwDecompress() - Compresses data from an input ptr to a dest ptr\n\n//\n\n// PARAMS:\n\n// infile - Pointer at the BEGINNING of the compressed data (no header!)\n\n// outfile - Pointer to the destination.\n\n// DataLength - Number of bytes to decompress.\n\n// PtrTypes - Type of pointers being used (SRC_FILE,DEST_FILE,SRC_MEM etc).\n\n//\n\n// RETURNS:\n\n// Length of compressed data.\n\n//\n\n// COMPTYPE : ct_LZW\n\n//\n\n// NOTES : Does not write ANY header information!\n\n//\n\nvoid lzwDecompress(void far *infile, void far *outfile,unsigned long DataLength,unsigned PtrTypes)\n\n{\n\nint i, j, k, r, c;\n\nunsigned int flags;\n\nunsigned char Buffer[8];\n\n// unsigned char LZW_ring_buffer[LZW_N + LZW_F - 1];\n\nunsigned CodeCount = 0;\n\nunsigned long OrgDataLen = DataLength;\n\nfor (i = 0; i < LZW_N - LZW_F; i++)\n\nLZW_ring_buffer[i] = ' ';\n\nr = LZW_N - LZW_F;\n\nflags = 0;\n\nfor ( ; ; )\n\n{\n\nif (((flags >>= 1) & 256) == 0)\n\n{\n\nc = ReadPtr((long)&infile,PtrTypes);\n\nflags = c | 0xff00; // uses higher byte cleverly to count 8\n\n}\n\nif (flags & 1)\n\n{\n\nc = ReadPtr((long)&infile,PtrTypes); // Could test for EOF iff FFILE type\n\nWritePtr((long)&outfile,c,PtrTypes);\n\nif (!--DataLength)\n\nreturn;\n\nLZW_ring_buffer[r++] = c;\n\nr &= (LZW_N - 1);\n\n}\n\nelse\n\n{\n\ni = ReadPtr((long)&infile,PtrTypes);\n\nj = ReadPtr((long)&infile,PtrTypes);\n\ni |= ((j & 0xf0) << 4);\n\nj = (j & 0x0f) + LZW_THRESHOLD;\n\nfor (k = 0; k <= j; k++)\n\n{\n\nc = LZW_ring_buffer[(i + k) & (LZW_N - 1)];\n\nWritePtr((long)&outfile,c,PtrTypes);\n\nif (!--DataLength)\n\nreturn;\n\nLZW_ring_buffer[r++] = c;\n\nr &= (LZW_N - 1);\n\n}\n\n}\n\n//\n\n// MANAGE DISPLAY VECTOR\n\n//\n\nif (LZW_DecompressDisplayVector)\n\n{\n\n//\n\n// Update DisplayVector every 1K\n\n//\n\nif ((CodeCount+=k) > 1024)\n\n{\n\nLZW_DecompressDisplayVector(OrgDataLen,OrgDataLen-DataLength);\n\nCodeCount = 0;\n\n}\n\n}\n\n}\n\n}"
    }
}