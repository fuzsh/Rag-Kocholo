{
    "id": "yago_31618_0",
    "rank": 64,
    "data": {
        "url": "http://www.scholarpedia.org/article/MATLAB",
        "read_more_link": "",
        "language": "en",
        "title": "Scholarpedia",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.scholarpedia.org/w/skins/vector/images/search-ltr.png?303",
            "http://www.scholarpedia.org/w/skins/vector/images/twitter.png?303",
            "https://ssl.gstatic.com/images/icons/gplus-16.png",
            "http://www.scholarpedia.org/w/skins/vector/images/facebook.png?303",
            "http://www.scholarpedia.org/w/skins/vector/images/linkedin.png?303",
            "http://www.scholarpedia.org/w/skins/common/images/poweredby_mediawiki_88x31.png",
            "http://www.scholarpedia.org/w/skins/common/images/MathJaxBadge.gif",
            "http://www.scholarpedia.org/w/skins/common/88x31.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Rob Schreiber"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/w/images/6/64/Favicon.ico",
        "meta_site_name": "",
        "canonical_link": "http://www.scholarpedia.org/article/MATLAB",
        "text": "MATLAB is an interactive programming environment for scientific computing. MATLAB is heavily used in many technical fields for data analysis, problem solving, and for experimentation and algorithm development. Discipline-specific software written in MATLAB, organized into libraries of functions called toolboxes, is widely used as well. MATLAB has found extensive use as the basis for computational laboratory work in technical education; more than 1000 textbooks use MATLAB as a teaching vehicle. MATLAB is a product of The Mathworks of Natick, Massachusetts, USA.\n\nThere is general agreement in the technical computing community that the main reasons for MATLAB's success are its intuitive, concise syntax, the use of complex matrices as the default numeric data object, the power of the built-in operators, easily used graphics, and its simple and friendly programming environment, allowing easy extension of the language. To this one can add the reliability of the numerical methods on which the operators are based.\n\nContents\n\n1 The MATLAB language\n\n1.1 MATLAB notation\n\n1.2 Avoiding exceptions\n\n1.3 Empty matrices\n\n1.4 Sparse matrices\n\n1.5 Other supported data objects\n\n2 History of MATLAB\n\n2.1 Origins\n\n2.2 Growth and Development\n\n3 Interpretation, just-in-time compilation, and performance\n\n4 Similar software\n\n5 MATLAB and parallel computers\n\n6 References\n\n7 See Also\n\nThe MATLAB language\n\nMATLAB has a number of features that distinguish it from standard scientific programming languages (C and FORTRAN). It is interactive, interpreted rather than compiled. There are no variable declarations; any value can be assigned to any variable:\n\n>> a = 'i am a string' a = i am a string >> a = sqrt(-[1 2; 3 4]) a = 0 +1.0000e+000i 0 +1.4142e+000i 0 +1.7321e+000i 0 +2.0000e+000i\n\nFirst a string, then a 2 by 2 matrix of complex numbers are assigned to the variable \"a\". Numbers are, by default, represented as complex, double precision floating point values. Numeric values are, by default, two-dimensional arrays (matrices). Thus one may ask for the eigenvalues of an integer constant ( eig(3) ) with no consideration of type conversion to double or to matrix. Vectors and scalars are not separate types, but rather arrays with one or both dimensions equal to one. When appropriate, a matrix that has one (or both) dimensions equal to one is treated as a vector; one may ask for example for the inner product of a 1 by n and an n by 1 array. The methods that MATLAB offers as built-in functions include computation of the matrix inverse, the rank, the eigenvalues, the singular value decomposition, the Moore-Penrose generalized inverse, the LU and QR factorizations, and other standard operations of linear algebra.\n\nMATLAB notation\n\nMATLAB introduced some notational conveniences that make it easy to express ideas about matrices more compactly than had been possible. Most notable are the concatenation operations: [A, B] (the matrix whose columns are the columns of A followed by those of B) and [A; B] (the vertical concatenation, whose rows are the rows of A followed by those of B). Other notational innovations include A' for the transpose of the matrix A, A .* B for the Hadamard (element by element) product of two matrices, and A\\b for the computation of the product of the inverse of a matrix (A) with a vector (b). MATLAB allows a function to have several outputs, with the syntax [x,y,z] = f(a,b,c). The m by n matrix all of whose elements are 1 is generated by the function ones(m,n), while zeros(m,n) and rand(m,n) generate the zero matrix and a matrix with independent uniform random elements. The identity of order n is known in MATLAB as eye(n).\n\nAvoiding exceptions\n\nCertain common bugs that cause early termination or unpredictable behavior in FORTRAN and C programs do not do so in MATLAB. Plus and minus infinity are supported values in MATLAB; they can be the result of a computation and can be written as literal values (Inf, -Inf). Taking advantage of features in the IEEE-754 standard for floating point, MATLAB returns appropriate values on divide by zero ( 1 / 0 yields positive infinity, -1 / 0 yields negative infinity, and 0 / 0 yields Not a Number. ) Writing \"past the end\" of a matrix does not cause an error in and of itself, rather the matrix is enlarged (with zeros) to make it big enough.\n\nEmpty matrices\n\nA matrix may have no rows, or no columns, or neither rows nor columns:\n\n>> a = ones(0,3) a = Empty matrix: 0-by-3 >> size(a) ans = 0 3\n\nThe sum of the zero elements in each of the three columns of a is:\n\n>> sum(a, 1) ans = 0 0 0\n\nThe sum of the three elements in each of the zero rows of a is\n\n>> sum(a, 2) ans = Empty matrix: 0-by-1\n\nEmpty matrices are natural stating points when a large matrix is created by the accretion of rows or columns.\n\nSparse matrices\n\nA MATLAB matrix may be stored internally as a full matrix or as a sparse matrix. An m by n real, full matrix takes mn 8-byte words to store the elements (twice this if its imaginary part is nonzero) in addition to a few dozen bytes to store its other attributes, such as its size. If stored internally as a sparse matrix, then the storage requirement for a real matrix that has z nonzero elements is z 8-byte words for the nonzero values, and z + n + 1 integer values for indices and pointers that encode the locations of these nonzeros. The matrix is stored using a compressed sparse columns storage scheme that is common for sparse matrix software. If only a small fraction of the elements differ from zero, use of the sparse form can yield a substantial savings in storage. Moreover, MATLAB's operators take advantage of sparsity and can be far faster when applied to sparse operands. This is particularly true for the matrix factorization and inversion operators. Some MATLAB functions produce sparse outputs in all cases:\n\n>> a = speye(3) a = (1,1) 1 (2,2) 1 (3,3) 1 >> full(a) ans = 1 0 0 0 1 0 0 0 1\n\nNote that sparse matrices are displayed as a list of the nonzero elements with their (row, column) coordinates. The choice of storage format is made by the MATLAB user or programmer rather than by the MATLAB implementation. The default is full. A matrix can be coerced to full or to sparse form by use of the functions full and sparse. The nonzeros can be explicitly listed using ( [row_index, column_index, value] = find(A) ).\n\nOther supported data objects\n\nSigned and unsigned integer data can be created and manipulated. Some operators are, however, only implemented for doubles. Matrices of short integer types require less storage than the default 64-bit floating point types.\n\nMultidimensional (more than two dimensions), strings, and lists of arbitrary MATLAB objects are also supported:\n\n>> c = cell(1,3) c = [] [] [] >> c{1} = 1 c = [1] [] [] >> c{2} = [1 2; 3 4] c = [1] [2x2 double] [] >> c{3} = cell(2,1) c = [1] [2x2 double] {2x1 cell} >> c{4} = 'four' c = [1] [2x2 double] {2x1 cell} 'four'\n\nUser-defined data types (classes, objects) can be defined.\n\nMATLAB includes a variety of plotting and visualization tools for datasets and functions.\n\nHistory of MATLAB\n\nOrigins\n\nCleve Moler is the creator of MATLAB. Moler was a numerical analyst specializing in matrix computation. In the early 1970s, Moler participated in an effort organized by Argonne National Laboratory to produce a library of reliable, efficient FORTRAN subroutines for computing the eigenvalues of matrices (EISPACK) and solving systems of linear equations (LINPACK). In order to make these packages easier for students to use, Moler created MATLAB, whose name is a contraction of \"Matrix Laboratory.\" The original MATLAB was a FORTRAN program, designed for the era of timesharing and ASCII terminals. It had only one data type (the matrix of complex doubles) and a fixed collection of 80 functions. Moler used the FORTRAN MATLAB in teaching numerical analysis at Stanford in 1979. Word of the program reached Jack Little, who grasped the potential of MATLAB in signal processing and control, and the possibility of making a successful software product based on MATLAB for the new IBM PC.\n\nLittle and Steve Bangert developed PC MATLAB by porting Moler's code from FORTRAN to C, adding user-defined functions (in effect making MATLAB into a programming language rather than a calculator), improved graphics, and libraries of MATLAB routines, the toolboxes. Moler, Little, and Bangert formed the Mathworks in 1984, with PC MATLAB as the first product. Their first sale was an order for ten copies placed by Professor Nick Trefethen at MIT.\n\nGrowth and Development\n\nJack Little's 100-word, 1983 business plan predicted that the new product would do for the technical world what Lotus 1-2-3 had done in the business world. MATLAB has indeed been a commercial success from the beginning, growing to more than 1,000,000 users and by 2006 to 1,200 Mathworkers, as the employees of Mathworks are known. MATLAB has, in effect, become the common language for the informal exchange of software and for algorithmic experiment in technical computing. The company remains privately held.\n\nThere have been several major revisions and enhancements to MATLAB, including an extended set of graphics tools and primitives, multidimensional arrays and lists (known in MATLAB as cell arrays), classes and objects, economical storage schemes and algorithms for sparse matrices, a debugger, a profiler, a GUI builder, a lower cost student edition, and Just-In-Time (JIT) compilation for improved performance. The computational core has been upgraded through the incorporation LAPACK (a state-of-the-art library for matrix computation), as well as software for computation of definite integrals, integration of ordinary differential equations, and root finders. Toolboxes created by the Mathworks and other contributors have expanded the scope of MATLAB, adding capabilities in areas such as optimization, signal and image processing, fuzzy logic, splines, wavelets, statistics, partial differential equations, bioinformatics, and mathematical finance. SIMULINK, an extensible block diagram environment for simulation and model-based design appeared as a second Mathworks product in 1990.\n\nThe Mathworks logo is a picture (generated by MATLAB) of a numerical approximation to the fundamental mode of a vibrating L-shaped membrane, a topic that Moler discussed in his Stanford Ph.D. thesis in 1965.\n\nInterpretation, just-in-time compilation, and performance\n\nA simple experiment reveals the performance implications of the MATLAB interpreter and the improvement possible with JIT compilation. Consider the MATLAB code snippet\n\n>> n = 10^6; a = rand(n,1); >> tic; a = a + a; toc Elapsed time is 0.018469 seconds.\n\nThis indicates that the library routine used by MATLAB to add two vectors performs this operation at a rate of about 54 million elements per second (a rate determined by the memory bandwidth of the machine on which the experiment was run). When the code is rewritten as a MATLAB loop, the rate is reduced:\n\n>> tic; for i = 1:length(a), a(i) = a(i) + a(i); end, toc Elapsed time is 0.964865 seconds.\n\nSo the interpreter runs this code roughly 50 times slower. When the vector add is placed in an M-file, however, the JIT compiler is invoked, and the runtime drops to roughly 1.5 times the time taken by the library code.\n\nNaively written MATLAB code can suffer a performance meltdown. Consider\n\n>> clear b; tic; for i = 1:10^5, b(i) = a(i) + a(i); end, toc Elapsed time is 34.178847 seconds.\n\nHere, the array b is extended by every assignment statement. There being no room in the previously allocated value to store the new element b(i), the entire array is copied into a new and larger space. The number of bytes copied grows as the square of the length of the vectors, a performance disaster. Adding the space allocating statement b = zeros(size(a)) just before the loop avoids this trap. In MATLAB version 7.4.0 (release R2007a), current at the time this article was written, the JIT was not powerful enough to automate this optimization.\n\nIn writing a function definition, an input variable can be recycled as an output, providing preallocated space. Thus, one can write\n\nfunction a = double(a) for i = 1:length(a), a(i) = a(i) + a(i); end\n\nand achieve reuse of the storage space of the input variable, avoiding even a single allocation and an explicit preallocation statement such as result = zeros(size(a)).\n\nSimilar software\n\nThere are a number of popular, competitive alternatives to MATLAB that offer a similar interactive environment for numerical computation, for example: GNU Octave (free), Scilab (semi-free), and Mathematica (non-free).\n\nMATLAB and parallel computers\n\nWith the shift to multi-core processor chips, parallel computers, long in use for demanding scientific applications, have become the norm in servers, desktops, and laptops. Programmers have found them quite difficult to use, and there has been widespread speculation that a parallel version of MATLAB would make parallel machines easier to use. Many research efforts have aimed at architecting and implementing a parallel MATLAB-like programming environment (there is an online survey of these). Mathworks has recently moved to incorporate first a distributed computing model (of loosely coupled parallel tasks) and now a more complete, parallel version of MATLAB in which multiple copies of MATLAB, each with its own workspace, can communicate via message passing and can also cooperatively carry out operation of shared arrays whose elements are distributed among them.\n\nReferences\n\nCleve Moler. The Origins of MATLAB. Cleve's Corner (in the Mathworks Newsletter), December 2004.\n\nCleve Moler. The Growth of MATLAB and MathWorks over Two Decades. Cleve's Corner (in The Mathworks Newsletter), January 2006.\n\nJohn R. Gilbert, Cleve Moler, and Robert Schreiber. Sparse Matrices in MATLAB: Design and Implementation. SIAM Journal on Matrix Analysis and Applications: 13:1, pp. 333-356 (1992).\n\nInternal references\n\nWilly Govaerts, Yuri A. Kuznetsov, Bart Sautois (2006) MATCONT. Scholarpedia, 1(9):1375.\n\nKendall E. Atkinson (2007) Numerical analysis. Scholarpedia, 2(8):3163.\n\nBard Ermentrout (2007) XPPAUT. Scholarpedia, 2(1):1399.\n\nSee Also"
    }
}