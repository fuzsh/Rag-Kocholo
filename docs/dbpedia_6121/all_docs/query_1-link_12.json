{
    "id": "dbpedia_6121_1",
    "rank": 12,
    "data": {
        "url": "https://www.copetti.org/writings/consoles/playstation/",
        "read_more_link": "",
        "language": "en",
        "title": "PlayStation Architecture",
        "top_image": "https://www.copetti.org/images/consoles/covers_top/playstation_hu5def09f99dcd1eba201436aaecb57b2f_376188_1420f2d0bbad0935cfe7992ce3f440d1.c5a833fbccd99c18a964fb9bcee93f47.jpg",
        "meta_img": "https://www.copetti.org/images/consoles/covers_top/playstation_hu5def09f99dcd1eba201436aaecb57b2f_376188_1420f2d0bbad0935cfe7992ce3f440d1.c5a833fbccd99c18a964fb9bcee93f47.jpg",
        "images": [
            "https://www.copetti.org/images/consoles/_covers/en/playstation_hu3d5204b417e6971d11626a0642134344_439162_330x0_resize_q90_box.jpg",
            "https://www.copetti.org/images/consoles/ps1/original.2a3aff5f6683494856d889707dd6d91e183565dcd4802b6bc5a904c46a7ea9f8.png",
            "https://www.copetti.org/images/consoles/ps1/slim.5d32805d20fe9e46a804a59e976fb9f24709169d862c5d47f02e1f613b693a9e.png",
            "https://www.copetti.org/images/consoles/ps1/motherboard.53772eccd0c3590bb5e4a2218cd7fe1d3b2d8046c9a6a83751d3a85c5b837153.png",
            "https://www.copetti.org/images/consoles/ps1/motherboard_marked.296c4452c4ccc8b99055a7fdbe250bff18120bb822214e2b89ca3ab88ec5e695.png",
            "https://www.copetti.org/images/consoles/ps1/diagram.27d7ed4f6432dd68e84847dec4ccf26d2f595b96e477a959f42626c2e7059bbf.png",
            "https://www.copetti.org/images/consoles/ps1/_hu9cacd5a751bffea9a611483dde185975_51234_37dafd8f5f9c0184015770265c914126.png",
            "https://www.copetti.org/images/consoles/ps1/_huc50729c8723998624444f12050d38b1a_38598_42b5267d6f36453c666c7a9f474399ab.png",
            "https://www.copetti.org/images/consoles/ps1/cpu_chip.008e74d7bdfa1375cbdc1b606658115ea5e82c2613fedaa52f0f3ba996b1f6f7.jpg",
            "https://www.copetti.org/images/consoles/ps1/delay_slots.ccc1846a7b3daf73fd4ec5596d8f6b3b551b47c9eed8d5a60b992942dba7941b.jpg",
            "https://www.copetti.org/images/consoles/ps1/vram/vram.1a8177d7a614a4d0eb2f75c61a212382dcea4f22fcff07a8498d912bd7bf7285.png",
            "https://www.copetti.org/images/consoles/ps1/vram/sgram.e8368f326f6f41fbfd78c7cf85713b5f2c017778a6bbc2c0591c769559e4e61a.png",
            "https://www.copetti.org/images/consoles/ps1/commands.03145249a36c0b11ecad6619716db4aacc3ebf8ce5c9a55a941e5ef27d5fdb58.png",
            "https://www.copetti.org/images/consoles/ps1/crash.27299c815f5930ce9e9abcde59760ae3e9a534d4cd90008b308b8205965f4d93.jpg",
            "https://www.copetti.org/images/consoles/ps1/spyro/wireframes.65937f283216f59a9a35c5ec0fa2cf35b777e1ec83325a60dc31ca96503cb2d5.png",
            "https://www.copetti.org/images/consoles/ps1/spyro/shaders.93bb3b855190b1cb9b25737e98279eaca97ba94612004eed485ab5ae7267f833.png",
            "https://www.copetti.org/images/consoles/ps1/spyro/result.e7283ad64b991d1f5d7d111bb684705ac0afa4b4382ccc6b3d1e933206a93aae.png",
            "https://www.copetti.org/images/consoles/models/spyro_ps1.846e3044ef7fe1240ab38b01839feb39b2536a45d6304654cb3df82048f7e37a.png",
            "https://www.copetti.org/images/consoles/models/crash_ps1.3e5acc770983364f113fb8e9aa3101d8f09fb995b54d201146f92f2d887eec5d.png",
            "https://www.copetti.org/images/consoles/ps1/vram.aef7b905c10a46a3d349d5d19e6e8fd0e2344986138ca08eb24ee772a8be2690.jpg",
            "https://www.copetti.org/images/consoles/ps1/prerendered.a985e518fa6fcc9c09f099855a78dd73789473ab614ec2b8d04eb72f914fdaaa.png",
            "https://www.copetti.org/images/consoles/ps1/cd.68b79df8471360fcbda95b8b8995de50bce4c1ffc9161592b0b6c932259cc6fc.png",
            "https://www.copetti.org/images/consoles/ps1/bios/splash.157cfb0ef9f9b66b0198b257fdf1b82b8d8b61aa291f53bffa2518279d4bf87c.png",
            "https://www.copetti.org/images/consoles/ps1/bios/valid.c8c04b9e4da4ecc93c09f8b64ae384bf89b6150f9ee2bdfb3764b4bec0ea7b16.png",
            "https://www.copetti.org/images/consoles/ps1/bios/shell.ad0b52b2853a3d7039df41d8b9f89df5b6114625bf009ba15dc9e35d46d62a7c.png",
            "https://www.copetti.org/images/paypal_donate.png",
            "https://www.copetti.org/images/patreon.png",
            "https://www.copetti.org/images/consoles/ebooks_banner.0d180c0136e4c9345bc0ab4f7a0224849a292326d2679d610ea945054383a996.jpg",
            "https://www.copetti.org/favicon/favicon.png"
        ],
        "movies": [
            "https://www.copetti.org/videos/consoles/ps1/ffviii.b65437715508333c5aa0bb5592aec740bdcde8ec1380f5cf0643aebd47b0aeaf.mp4"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Rodrigo Copetti"
        ],
        "publish_date": "2019-08-08T00:00:00",
        "summary": "",
        "meta_description": "An in-depth analysis that explains how this console works internally",
        "meta_lang": "en",
        "meta_favicon": "/favicons/apple-touch-icon.png",
        "meta_site_name": "The Copetti site",
        "canonical_link": "https://www.copetti.org/writings/consoles/playstation/",
        "text": "A practical analysis by Rodrigo Copetti\n\nIf you use accessibility tools or old browsers, switch to the â€˜classicâ€™ edition.\n\neBook edition\n\nThis article is also published on many digital book stores for the benefit of eBook readers. The new edition is DRM-free and can be read whilst offline. Furthermore, it's updated at the same pace as the website.\n\nYou can find the eBook at Amazon Kindle, Apple Books, Kobo and other stores. The profits contribute towards the improvement of current articles and the development of future ones.\n\nFor more information, please take a look at here.\n\nSupporting imagery\n\nModel\n\nMotherboard\n\nDiagram\n\nA quick introduction\n\nSony knew that 3D hardware could get very messy to develop for. Thus, their debuting console will keep its design simple and practicalâ€¦ Although this may come with a cost!\n\nCPU\n\nThis section dissects the Sony CXD8530BQ, one of the two big chips this console houses. Itâ€™s what we would call a â€˜System-on-Chipâ€™ in todayâ€™s world.\n\nThe origins\n\nThe main processor is one of those â€˜x designed by y, based on z and second-sourced from wâ€™ which is a bit dense to summarise in a few sentences, so why donâ€™t we start with some historical context?\n\nA bit of history\n\nThe early nineties were marked by a change in the fates of many popular CPUs. The once-leading 8-bit CPUs, such as the Z80 and 6502, were already out of spotlight and Motorolaâ€™s famous 68000, along with other 16-bit designs that enjoyed success in the late 80s, had become candidates for replacement. Even at this time in the PC world, Tanenbaum, in his celebrated debate with Torvalds, gave Intelâ€™s x86 architecture only five more years until its demise from the home market.\n\nAt first, it may look as if technological development had hit a wall at this point. But in reality, there was a new wave of relatively unknown CPUs making their way into mainstream devices. Many of these designs had originated in academia, and so existed to prove particular sets of design ideas. Examples of novel CPUs of that era included:\n\nMIPS: Adopted by Silicon Graphics Incorporated (targeting graphics workstations).\n\nPowerPC: Adopted by Apple (targeting desktop publishing).\n\nSPARC: Created by Sun Microsystems (targeting servers and business workstations).\n\nARM: Created by Acorn (initially targeting the consumer market and then, PDAs and cell phones).\n\nâ€¦ and many more â€˜microcontrollerâ€™ chips yet to be finalised or adopted by any industry, such as Hitachiâ€™s SH or NECâ€™s V810. To their surprise, these were subsequently selected for the Sega Saturn and the Nintendo Virtual Boy, respectively.\n\nAll of these processors had something in common: They followed the Reduced Instruction Set Computer (RISC) discipline, which radically shifted how these chips had to be designed and programmed. One rule of RISC CPUs dictated that a single instruction canâ€™t mix memory with register operations, allowing hardware designers to simplify the circuitry that executes instructionsâ€¦ and then enhance it with parallelism techniques.\n\nMIPS and Sony\n\nMIPS Computer Systems originated from the eagerness of its founders (Stanford faculty) to turn their research into physical processors, something that Silicon Valley-based venture capitalists in the 80s were also anxious to invest in [2]. Their debuting CPU, the â€˜MIPS R2000â€™, is considered the first commercial CPU to incorporate a RISC design; and it found a space in many UNIX workstations.\n\nHowever, it wasnâ€™t until 1987 that MIPSâ€™ chips became a topic of conversation, all due to being adopted (and later acquired) by Silicon Graphics Incorporated (SGI) to power their equipment. SGI was an influential innovator in the computer graphics market, especially with the development of hardware-accelerated vertex pipelines, whose task was originally carried out by software (within the CPU). After the acquisition, SGI had a leading position in both CPU and graphics sectors.\n\nBefore the development of the PlayStation, MIPS switched to a business model based on IP licensing, where their CPU designs would be sold in the form of licenses, and licensees were then free to customise and manufacture the designs. Part of their offerings included the R3000A CPU, found in their low-end catalogue. Consequently, the R3000A wasnâ€™t associated with the flagship line-up (unlike the R4000, which others would later choose), but it was an attractive investment in terms of cost.\n\nBack to the main topic, Sony designed their audio and graphics chips in-house, but they still needed the leading chip that could drive those two. The selected CPU had to be powerful enough to show off the impressive capabilities of Sonyâ€™s chips, but also affordable to keep the console at a competitive price.\n\nLSI and the commission\n\nAt the same time, LSI Logic (a semiconductor manufacturer) was a MIPS licensee that provided a â€˜build-your-ownâ€™ CPU program for businesses. This service was referred to as CoreWare and it enabled clients to build their own CPU packages by choosing a series of building blocks [3]. Part of the CoreWare library included the â€˜CW33300â€™ block, a CPU core derived from the LSI LR33300, an off-the-shelf CPU chip that LSI also commercialised.\n\nNow, where am I going with all this? It turns out LSIâ€™s LR33300 and CW33300 are a binary-compatible version of the MIPS R3000A family. Their architectures slightly differ in some areas but the programming interface (MIPS I ISA) remains the same.\n\nIn the end, Sony commissioned LSI to build their CPU package. They chose the CW33000, changed some bits and combined it with other blocks to form the chip you find on the PlayStationâ€™s motherboard.\n\nThe offering\n\nThe resulting CPU core runs at 33.87 MHz and features:\n\nThe MIPS I ISA: The first version of the MIPS instruction set. Among many things, words are 32-bit long and the instruction set includes multiplication and division instructions.\n\n32 general-purpose registers and 2 multiplication/division registers: These are 32-bit as well. One general-purpose register is always zero (R0), which is common in RISC processors.\n\n32-bit data bus: In the PS1, the data bus forks into two buses.\n\nMain Bus (32-bit) â†’ Connects the MDEC and GPU.\n\nSub Bus (16/8-bit) â†’ Connects the rest of the chips and I/O. This bus is bridged by the Bus Interface Unit, which also enables access to special ports of the GPU and SPU.\n\n32-bit address bus: Up to 4 GB of physical memory (i.e. RAM, memory-mapped I/O, etc) can be accessed.\n\n5-stage pipeline: Up to five instructions can be executed simultaneously (a detailed explanation can be found in a previous article).\n\n4 KB of instruction cache: It can be â€˜isolatedâ€™ as well, allowing the program to manipulate the instruction cache directly.\n\nOddly, there is no data cache. The 1 KB of memory normally used for the data cache is mapped to a fixed address [4]. This area is also called Scratchpad (fast SRAM).\n\nTo do something meaningful, Sony provided 2 MB of RAM for general-purpose use. Curiously enough, they fitted Extended Data Out (EDO) chips on the motherboard. These are slightly more efficient than typical DRAM, obtaining lower latency.\n\nTaking over the CPU\n\nAt some point, any subsystem (graphics, audio or CD) will require large chunks of data at a fast rate. However, the CPU will not always be able to keep up with the demand.\n\nFor this reason, the CD-ROM Controller, MDEC, GPU, SPU and the Parallel port have access to an exclusive DMA controller whenever they require it. DMA takes control of the main bus and performs a data transfer. The resulting rate is a lot faster than relying on the CPU, though the latter is still needed to set up a DMA transfer.\n\nAlso, bear in mind that once DMA kicks in, the CPU canâ€™t access the main bus. This means the CPU will be idling unless itâ€™s got something in Scratchpad to keep it busy!\n\nComplementing the core\n\nLike other MIPS R3000-based CPUs, the CW33000 supports configurations with up to four coprocessors, Sony customised it with three:\n\nSystem Control Coprocessor\n\nIdentified as â€˜CP0â€™, the System Control Coprocessor is a common block found on MIPS CPUs. In R3000-based systems, like this one, the CP0 controls how the cache is implemented. Thus, enabling direct access to data cache (in the form of â€˜Scratchpadâ€™) and instruction cache (using â€˜cache isolationâ€™). The control coprocessor is also responsible for handling interrupts, exceptions and breakpoints, the latter is useful during debugging.\n\nWait, shouldnâ€™t co-processors only expand CPU functions? Why is CP0 tightly coupled to the CPU?\n\nIndeed, R3000 cores depend on the system control coprocessor to be able to make use of many components, but whether this should be â€˜legalâ€™ or not comes down to the interpretation of the word â€˜co-processorâ€™. According to MIPS, a co-processor is not strictly an optional part of the CPU, it may also command the CPUâ€™s surroundings (cache, interrupts, etc). Hence, a co-processor can be an integral part of the system. This is just something to bear in mind while talking about MIPS-related systems.\n\nLater R4000-based systems incorporated a Memory Management Unit (MMU) and a Translation Lookaside Buffer (TLB) into this block, thereby increasing its capabilities and taking up new roles.\n\nGeometry Transformation Engine\n\nThe â€˜CP2â€™ or Geometry Transformation Engine (GTE) is a special math processor that accelerates vector and matrix calculations.\n\nWhile only operating fixed-point types, it still provides useful operations for 3D graphics such as:\n\nMatrix or vector multiplication and addition; and vector square.\n\nPerspective transformation (used for 3D projections).\n\nOuter product of two or three vectors (the latter is used for clipping).\n\nMany interpolation functions that use different parameters.\n\nDepth Cueing and colour value from a light source (used for lighting and colour operations).\n\nZ/depth average (I suspect this is for the â€˜ordering tableâ€™, more details in the â€˜Graphicsâ€™ section).\n\nYou donâ€™t have to remember all these to follow the rest of the article! Just keep in mind that the GTE will be taking care of the first stages of the graphics pipeline, such as 3D projection, lighting and clipping. This will help to generate the required data that will be sent to the GPU for rendering.\n\nMotion Decoder\n\nThe Motion Decoder, also called â€˜MDECâ€™ or â€˜Macroblock Decoderâ€™, is another processor living next to the CPU. This time, it decompresses â€˜Macroblocksâ€™ into a format the GPU can understand. A Macroblock is a data structure that houses a picture with similar encoding to JPEG.\n\nThe MDEC decompresses bitmaps made of 8x8 24 bpp pixels at a time. Walkerâ€™s programming guide states the MDEC can compute 9,000 macroblocks per second. This would allow to stream a 320x240 px full-motion video (FMV) at 30 frames per second.\n\nDMA is used to send compressed data through CD-ROM â†’ RAM â†’ MDEC. The same path is taken in the opposite direction, though in this case, the destination is VRAM.\n\nWhile this component is sitting inside the SoC and shares the same data bus, itâ€™s not a MIPS co-processor, so the CPU/DMA access it through the memory map (as opposed to intercepting instructions).\n\nFor more info about the MDEC unit, I suggest checking out Sabinâ€™s [5] and CzekaÅ„skiâ€™s [6] resources.\n\nMissing units?\n\nSo far, we got a â€˜CP0â€™ and a â€˜CP2â€™, but whereâ€™s the â€˜CP1â€™? Well, thatâ€™s reserved for a Floating Point Unit (FPU) and Iâ€™m afraid Sony didnâ€™t provide one. This doesnâ€™t mean the CPU canâ€™t perform arithmetic with decimal numbers, it just wonâ€™t be fast enough (software-emulated FPU) or too precise (fixed-point arithmetic instead).\n\nGame logic (involving physics, collision detection, etc) still can get around with fixed-point arithmetic. Fixed-point encoding stores decimal numbers with an immutable number of decimal places. This implies a loss in precision after certain operations, but remember, this is a video-game console, not a professional flight simulator. Hence, the precision-performance trade-off is somewhat feasible.\n\nBy the way, if youâ€™d like to refresh concepts like â€˜fixed-pointâ€™, â€˜floating-pointâ€™, â€˜decimalâ€™ and â€˜integerâ€™, I recommend taking a look at Gabriel Ivancescuâ€™s post for a quick summary [7].\n\nDelay galore\n\nAs weâ€™ve seen before, the CW33300 is a pipelined processor, meaning that it queues up multiple instructions and executes them in parallel at different stages. This hugely improves instruction throughput, but if itâ€™s not controlled properly, it can lead to pipeline hazards, resulting in computational errors.\n\nThe MIPS I architecture is susceptible to [8]:\n\nControl hazards: Instructions may get executed when they shouldnâ€™t be\n\nData hazards: Instructions may operate with outdated data before itâ€™s been updated.\n\nConsequently, MIPS I CPUs exhibit the following behaviour:\n\nAny instruction following a â€˜branchâ€™ or â€˜jumpâ€™ type opcode is executed unconditionally: Thus, developers have to manually fill the pipeline with modest instructions (such as calculate 0 plus 0) after the branch or jump to mitigate the hazard. These fillers are called branch delay slots.\n\nModern CPUs converted this phenomenon into an advantage: Branch prediction. By adding extra circuitry to detect the hazard, the CPU discards the new computations if the branch/jump condition isnâ€™t met. But if it did, then the CPU has saved some time.\n\nâ€˜Loadâ€™ instructions donâ€™t stall the pipeline until the retrieved data is made available: The second stage of the pipeline (called RD or â€˜Read and Decodeâ€™) gathers the operators [9], which will be used to perform a computation at the third stage (ALU). The fourth stage (MEM, from â€˜access MEMoryâ€™) looks for data in memory (i.e. main RAM, CD reader, etc). Now, hereâ€™s the problem: by the time a load instruction gathered the data from outside, the following instruction had already fetched the operators. This means that an instruction depending on the values of the previous load instruction requires a filler in-between, so the correct operators can be fetched on time.\n\nAs we can see from the example, some delay slots are filled with meaningful instructions, which perform computations that are not affected by the hazard. Hence, delay slots donâ€™t always imply a waste of cycles.\n\nHaving explained this, you may be wondering why a processor with these kinds of flaws could ever be commercialised. Well, one philosophy about RISC is that the burden of CPU programming is shifted from the developer to the compiler. MIPS, in particular, prioritised the production of good quality compilers (including assemblers) to accompany their new CPUs [10]. Hence, developers could use a higher-level language (for instance, C) while the toolchain dealt with the hazards (by re-arranging instructions to fill in slots; or adding useless fillers as a last measure). So, all in all, while I donâ€™t find it pleasant to see a CPU being filled with bubbles, I think MIPS tackled this in a very clever way.\n\nGraphics\n\nTo recap, a large part of the graphics pipeline is carried out by the GTE. This includes perspective transformation (which projects the 3D space onto a 2D plane using the cameraâ€™s perspective) and lighting. The processed data is then sent to Sonyâ€™s proprietary GPU for rendering.\n\nOrganising the content\n\nThe system features 1 MB of VRAM that will be used to store the frame buffer, textures and other resources the GPU will require to render the scene. The CPU can fill this area using DMA.\n\nThe type of chip fitted (VRAM) is dual-ported, like the Virtual Boyâ€™s. VRAM uses two 16-bit buses, which enables concurrent access between the CPU/DMA/GPU and the Video encoder.\n\nThough in later revisions of this console, Sony switched to SGRAM chips (the single-ported option using an individual 32-bit data bus). Boo!â€¦ Well, to be fair, each one comes with its pros and cons. One thing for sure is that due to the timing differences, later games (such as Jet Moto 3) will display glitched graphics when ran on VRAM-based systems. If you want to know the details, Martin Korthâ€™s â€˜Nocash PSX Specificationsâ€™ document the different timings and such [11].\n\nDrawing the scene\n\nIf youâ€™ve been reading the Sega Saturn article, let me tell you that the design of this GPU a lot simpler!\n\nNow, to show how a scene is drawn, Iâ€™ll mainly use Insomniacâ€™s Spyro: Year of the Dragon as an example. Please bear in mind that the internal resolution of this game is too cramped (292x217 px), preventing me from clearly dissecting it at each stage, so Iâ€™ve upscaled it a bit for demonstration purposes. Here is a sample at original scale if you are curious.\n\nCommands\n\nTo start with, the CPU sends geometry data (vertices) to the GPU by filling its internal 64-byte FIFO buffer with commands (up to three). These commands may request to GPU to render something, change a setting or manipulate VRAM.\n\nEssentially, a render command states how and where to draw a primitive. The GPU can individually draw lines, rectangles and triangles - the latter is the fundamental ingredient for composing rich 3D models.\n\nOnce the geometry is received, clipping is applied to skip operations over unseen polygons (residing outside the cameraâ€™s viewport).\n\nThe location of the primitive is stated with an X/Y coordinate system pointing to the frame buffer. The PS1â€™s GPU employs an integer coordinate model, where each coordinate corresponds to the centre point of a pixel (called sampling point). In other words, there are no fractional coordinates.\n\nVisibility approach\n\nJust like the competition, the PS1 doesnâ€™t include any hardware feature that solves the visibility problem. Nonetheless, the GPU handles sorted polygons by providing an ordering table: A dedicated table where each entry is indexed using a depth value (also called â€˜Z-valueâ€™) and contains the address where the GPU command resides [13].\n\nThe CPU needs to manually sort the polygons first, and then reference them in the correct entry of the table. Finally, the CPU orders DMA to send the table to the GPU. This process will enable the GPU to render the geometry in the correct order.\n\nMultiple DMA functions are also provided to assist both CPU and GPU with the creation and traversal of this table.\n\nRasterisation\n\nOnce the commands are decoded by the GPU, itâ€™s time to convert the geometry received (vertices) into pixels. This will enable the system to apply texture mapping, effects and ultimately display it on a two-dimensional panel (your TV or monitor). To do this, the GPU allocates a pixel matrix that is used as a working area, this is called a frame buffer. Compared to the more complex Sega Saturn, the GPU only needs a single frame buffer.\n\nThe rasteriser is the unit in charge of converting vectors into lines, triangles or rectangles; and then into pixels. Now, the process differs drastically depending on the primitive requested [14]:\n\nTriangles are the most complex (and versatile) type, which can be textured and shaded.\n\nLines are quicker to draw but naturally unfeasible for textured surfaces. They can still be shaded.\n\nRectangles are also faster but can only fit a sprite of up to 256 x 256 pixels (a larger rectangle will duplicate the spriteâ€™s graphic). Even so, they offer no affine transformation (except X/Y flip), shading or effects. I suspect this was implemented to assist the implementation of 2D games.\n\nIn the case of the triangle, being the only textured polygon, the rasteriser will:\n\nGrab each three-point vertex and calculate the edges. This forms a triangle.\n\nAnalyse the area of the triangle to identify which pixels of the frame buffer they occupy. Only the section of the polygon covering the sampling points get turned into pixels.\n\nThe generated pixels are not written into the frame buffer right away. Instead, they are sent to the next stages of the pipeline for further processing, which weâ€™ll see in the following paragraphs.\n\nShaders\n\nIn order to apply lighting effects over triangles or lines, the GPU provides two algorithms:\n\nFlat shading: Each primitive has a constant light level.\n\nGouraud shading: Each primitiveâ€™s vertex embeds its own light level. Then, the brightness between each point is automatically interpolated.\n\nAs you can imagine, this type offers more realistic results than flat shading.\n\nThe reason for having this choice comes down to the fact that flat shading fills ~2.5 times more polygons per second than Gouraud, so itâ€™s important to optimise which polygons need a more realistic shading than others.\n\nTextures\n\nTriangle surfaces may also be blended with textures (2D bitmaps) to produce the final result.\n\nThe GPU performs inverse texture mapping, where the GPU traverses each rasterised pixel and looks for its corresponding pixel in the texture map (called texel). Texels are calculated by linearly interpolating the texture map (found in VRAM) to conform to the shape of the polygon. The routine used for interpolation is called Affine Texture Mapping, this technique only operates using 2D coordinates (X-Y values) while discarding the third coordinate (Z or â€˜depthâ€™) used for perspective.\n\nBecause texture maps rarely have the exact dimension of the rasterised polygon, aliasing (incorrect results) may appear. This is manifested with unwanted distortions, such as missing or enlarged texels. To remedy this, sophisticated GPUs employ texture filtering to smooth out (interpolate) sudden colour changes. Now, The PS1â€™s GPU doesnâ€™t implement any filter, so it resorts to an algorithm named nearest neighbour to correct scales without smoothing out the results. This is very fast (and cheap) but it also explains why textured models may look â€˜blockyâ€™.\n\nThe GPU also includes the following effects available to use (on triangles):\n\nSemi-Transparency: Simulates light passing through multiple textures.\n\nDithering: Soften sudden changes in colour while adhering to the same colour palette.\n\nItâ€™s worth mentioning that the PS1 happened to excel at those effects!\n\nRemaining steps\n\nOnce finished, the GPU writes the pixels into the frame buffer area in VRAM, which is in turn picked up by the video encoder and broadcasted to the screen.\n\nDesigns\n\nLetâ€™s take a break now from all this theory. Here are some examples of game characters designed from the ground up for the 3D era, they are interactive so I encourage you to check them out!\n\nPlaying with VRAM\n\nWith the available amount of VRAM (1 whole megabyte), one could allocate a massive frame buffer of 1024Ã—512 pixels with 16-bit colours or a realistic one of 960Ã—512 pixels with 24-bit colours - allowing one to draw the best frames any game has ever shownâ€¦ This sounds pretty impressive, right? Well, it does raise a couple of issues, for instance:\n\nThose dimensions will have to be rescaled to follow a standardised definition (i.e. 480 NTSC, 576 PAL) so the video encoder can broadcast it to consumer TVs.\n\nHow is the GPU going to be able to draw anything decent if there isnâ€™t any space left for the rest of the materials (i.e. textures, colour tables, etc)?\n\nThe PS1â€™s GPU can only draw frame buffers with up to 640Ã—480 pixels and 16 bpp colours.\n\nAll right, so letâ€™s have a 16 bpp 640x480 buffer instead, which leaves 424 KB of VRAM for materials. So far so good? Again, such resolution may be fine on CRT monitors, but not particularly noticeable on those 90s TVs everyone had in their homes. Then, is there any way to optimise the frame-buffer? Introducing adjustable frame-buffers.\n\nIn essence, instead of wasting valuable VRAM by using â€˜unappreciatedâ€™ resolutions, this consoleâ€™s GPU allows decreasing the dimensions of the frame buffer to effectively increment the space available for other resources. In â€˜Gears Episode 2â€™ [15], Halkun shows a setup that divides the 640x480 frame buffer into two 320x480 ones, and then relies on a technique called page-flipping to render multiple scenes at the same time.\n\nPage-flipping consists of switching the location of the frame for display between the two available whenever the game wants it, allowing the game to render one scene while displaying another. Thus, hiding any flickering effect and improving loading times (something that the player will certainly appreciate!).\n\nOverall, Halkunâ€™s layout only consumes 600 KB of VRAM. The rest (424 KB) can be used to store colour lookup tables and textures that, combined with 2 KB of texture cache available, result in a very convenient and efficient setup.\n\nFinally, it is worth mentioning that VRAM can be mapped using multiple colour depths simultaneously, meaning that programmers can allocate a 16 bpp frame buffer next to 24 bpp bitmaps (used by FMV frames, for instance). This is another feature facilitating further optimisation of space.\n\nSecrets and Limitations\n\nWhereas the PS1 had a very simple and suitable architecture, problems ended up arising anyway. Surprisingly, certain issues were tackled with very clever workarounds!\n\nDistorted models/textures\n\nThe routines used for handling geometry and applying textures are known to carry some inaccuracies.\n\nFirstly, the rasteriser only handles pixel units: While vertex coordinates are integers, the calculated triangle edges may only occupy a fraction of a pixel. However, the rasteriser will only draw the pixel if the triangle area covers the pixelâ€™s sampling point, and it wonâ€™t keep track of the fraction occupied [16]. This brings up some problems:\n\nExternal edges of models make sudden jumps when moved slightly.\n\nTriangles within a mesh (sharing the same vertices and edges) will be â€˜fightingâ€™ to draw over the same pixels. With the ordering table, the GPU will draw following a â€˜last-come first servedâ€™ basis, which can lead to triangle intersections flickering or overlapping when moved slightly.\n\nThis is commonly tackled by implementing sub-pixel resolution, from which the rasteriser keeps track of the fractions of pixels occupied by each triangle area [17]. Consequently, anti-aliasing methods can then be added to soften jagged edges or sudden changes in colour.\n\nMoving on, the ordering table puts the burden on the developer/program to show the geometry in the right order. In some cases, the calculations implemented rely on too many approximations to gain performance. This may result in flickering or occluded surfaces that should have been displayed.\n\nFurthermore, setting a low-resolution frame buffer may amplify all these aliasing issues.\n\nFinally, as you know, affine transformations have no sense of depth, which may confuse the userâ€™s perception when the camera is close to the model and is positioned perpendicular to the viewer [18]. The effect is also referred to as texture warping. Hence, some games resorted to tessellation (dividing a big polygon into smaller ones) to reduce distortion, others just swapped textures in favour of solid colours. In general, a GPU ultimately tackles this issue by implementing perspective correction, which interpolates textures using the depth value.\n\nContradicting claims\n\nIf you check other technical channels or forums, youâ€™ll find alternative explanations about the PS1â€™s wobbling/warping/distorted effects. While some of them will coincide with what I explained before, others will argue differently. So, Iâ€™d like to give my opinion on why the following statements are not accurate:\n\nModels/textures wobble due to lack of FPU\n\nAn FPU doesnâ€™t dictate whether a computer can operate or not fractional numbers. The PS1, like any other computer without an FPU, can still perform fixed-point arithmetic. Furthermore, using software emulation, floating-point numbers can also be computed (just slower). To sum up, FPUs are just accelerators, do not confuse them with an ALU (the critical portion of a CPU that performs arithmetic) or decimal numbers.\n\nModels/textures wobble due to the GPUâ€™s integer coordinate system\n\nEmploying integer coordinates is a common approach to make calculations less expensive in the GPU. Itâ€™s the fact of not employing sub-pixel resolution that turns this into a visible problem. To sum up, anti-aliasing could be applied to smooth out sudden changes of colours if the rasteriser kept count of the pixelâ€™s fraction occupied by the triangle.\n\nTextures warp due to lack of mipmapping\n\nGPUs that implement inverse texture mapping such as this one, are subject to a measurement error called â€˜undersamplingâ€™ (one pixel is mapped to multiple texels). Thus, this creates aliasing (wrong results). The behaviour is noticeable when rendering geometry far away from the camera. To remedy this, modern texture mappers apply â€˜trilinear filteringâ€™, which softens texels using the same texture stored at different scales (mipmaps) and does some interpolation in-between. To sum up, mipmapping is an approach to solve aliasing. Itâ€™s affine texture mapping (with its lack of perspective correction) that interpolates textures on three-point surfaces without taking into account the depth. Hence, the â€˜warpingâ€™ effect.\n\nModels/textures flicker due to lack of Z-buffering\n\nA GPU with Z-buffer solves the Visible surfaces determination problem at a hardware level. The PS1 relies on an ordering table, meaning developers are in charge of determining what geometry is in front of others. To sum up, any model exhibiting flickering triangles is caused by the sorting routines (software), so itâ€™s remedied on the same software.\n\nPre-rendered graphics\n\nLetâ€™s mention a â€˜positiveâ€™ feature now for a changeâ€¦\n\nIf a game strived for a more realistic scenery than the GPU could provide, one available option was to stack two triangles and use the Motion Decoder to feed pre-rendered cinematic on them. FMV video could weigh a lot of space, luckily the CD-ROM was prepared for this.\n\nSome games relied on it specifically for composing backgrounds and, honestly, it was quite convincing to see them on a CRT TV, obviously modern emulators with upscaling capabilities will tell on very quickly.\n\nVideo out\n\nThe first revision of this console carries a surprising amount of video signals with the following ports:\n\nRFU DC: This one got removed pretty quickly, it was meant to be connected to an RF modulator.\n\nRCA: Provides composite video.\n\nS-Video: Provides Luma + Sync (combined) and Chroma.\n\nAV Multi Out: Provides all the previous signals, except RFU, plus RGB and a 5+ Volts line.\n\nLater revisions of the console removed these ports and at the end, only â€˜AV Multi Outâ€™ was left.\n\nAudio\n\nSonyâ€™s signature Sound Processing Unit (SPU) takes care of this. This chip supports the enormous amount of 24 channels of 16-bit ADPCM samples (a more efficient version of the well-known PCM sampling) with a sampling rate of 44.1 kHz (Audio CD quality).\n\nThis chip also provides the following capabilities:\n\nPitch modulation: As the name suggests, games can automatically alter the pitch of their samples instead of needing to store extra ones. This is useful for music sequencing.\n\nFrequency modulation: Voices can be assigned to alter the frequency of others. Comparable to FM synthesis.\n\nADSR Envelope: These are a set of properties available for amplitude modulation.\n\nLooping: Instructs the system to play a piece of audio repeatedly.\n\nDigital reverb: Simulates the sample being played within a specific atmosphere to immerse the player.\n\n512 KB of DRAM (called â€˜Sound RAMâ€™) are provided as audio buffer. This memory is accessible from the CPU (only through DMA) and the CD controller. Although games only have 508 KB available to store samples, the rest is reserved by the SPU to process Audio CD music. This amount is reduced even further if reverb is activated.\n\nThe CD controller is also able to send samples directly to the audio mixer without going through the audio buffer or requiring CPU intervention. Samples can also be compressed using the â€˜XAâ€™ encoding, which the SPU can decode on the fly.\n\nThe streaming era\n\nSimilarly to the Saturn, games are no longer dependent on music sequencing or pre-defined waveforms, and thanks to the amount of storage available on the CD-ROM medium, developers can store fully produced samples and just stream them to the audio chip.\n\nI/O\n\nThere are two I/O ports (Serial and Parallel) available for add-ons. However, these were removed in later revisions of the console due to lack of adoption and the fact that they could potentially be used to crack the copy protection system.\n\nCD subsystem\n\nThe block controlling the CD drive is an interesting area, you can imagine it as a separate computer living inside the PlayStation.\n\nThis subsystem is composed of:\n\nA DSP: controls the motor and laser, and processes the RF signal coming from the laser.\n\nA Sub-CPU: A CPU package made of a Motorola 68HC05 microcontroller, 512 B of RAM and 16 KB of ROM [19]. In a nutshell, the Sub-CPU runs a local program stored in ROM and controls the DSP. The Sub-CPU program implements copy-protection measures and they are enforced whether the main CPU â€˜likes it or notâ€™.\n\nA CD Controller: This is the middle-man between the CD subsystem and the rest of the console, receiving commands from main CPU (in a FIFO manner) and triggering interrupts after certain events. As a controller, the chip talks to the Sub-CPU and receives CD data from the DSP. Furthermore, the controller contains a DMA unit and itâ€™s connected to the SPU, which allows it to stream audio directly.\n\n32 KB of SRAM connected to the controller: This is presumably used as a buffer for data read from the disc.\n\nThe subsystem somewhat resembles a typical CD reader everyone had at their home, except with the tweaks Sony implemented in the Sub-CPU program to perform anti-piracy checks.\n\nFront ports\n\nThe controller and the Memory Card slots are electrically identical [20], so the address of each one is hardcoded. Additionally, Sony altered the physical shape of the ports to avoid accidents.\n\nCommunication with these devices is accomplished using a serial interface. Commands sent from the console will be delivered to one of the two slots (either â€˜mem. card 0â€™ and â€˜controller 0â€™, or â€˜mem. card 1â€™ and â€˜controller 1â€™). Then, both accessories will answer with their unique identifiers, this will allow the console to focus on a particular type of device (memory card or controller) from now on.\n\nOperating System\n\nThe system includes a 512 KB ROM that stores a â€˜BIOSâ€™. This program performs many services, including taking care of the startup process, displaying a user shell and finally, exposing a collection of I/O routines [21].\n\nBIOS/Kernel\n\nThe BIOS is a critical dependency for games, as this program bootstraps them from the CD drive. Moreover, the BIOS serves as a â€˜middle manâ€™ to interact with the consoleâ€™s hardware. The latter methodology is similar to what IBM implemented with their IBM PC BIOS, which encouraged developers to make use of a standard interrupt table (containing I/O routines) instead of platform-dependent I/O ports.\n\nHaving said that, the PS1 BIOS exposes routines such as:\n\nCommands for the CD-ROM drive.\n\nFilesystem operations (from CD-ROM and memory card).\n\nMultithreading.\n\nStandard C functions (string manipulation, memory operations, etc).\n\nSince BIOS ROM access is very slow (itâ€™s connected to an 8-bit data bus), the APIs are packaged in the form of a Kernel and copied to main RAM during boot. Thus, 64 KB of main RAM are reserved for said Kernel. By the way, the Kernel is also referred to as PlayStation OS.\n\nBoot process\n\nThe CPUâ€™s reset vector is at 0xBFC00000, which points to the BIOS ROM.\n\nSimilarly to the Saturnâ€™s boot process, after receiving power, the PS1 will:\n\nLook for the BIOS ROM and execute routines to initialise the hardware.\n\nLoad PlayStation OS.\n\nDisplay the splash screen.\n\nIf there is a CD inserted, the CD-ROM controller will check if itâ€™s genuine:\n\nIt is â†’ The controller will allow to read its content.\n\nThe CPU will look for â€˜SYSTEM.CNFâ€™ and continue execution from there.\n\nItâ€™s not â†’ The CPU will display an error message.\n\nWith no CD inserted, the CPU will display the shell. The user is now in control.\n\nThe shell is a simple graphical interface that enables the user to copy or delete saves from the memory card; or play an audio CD.\n\nGames\n\nJust like the Sega Saturn and any other console that made the switch to the CD medium, games are now provided with a new set of facilities: Large storage (640 MB), good audio quality and a â€˜not-so-slowâ€™ read speed thanks to the 2x drive.\n\nIf youâ€™d like to know how the Compact Disc (CD) works, Iâ€™ve written a quick explanation on the Sega Saturn article.\n\nDevelopment ecosystem\n\nThe official SDK provided C libraries which are linked to BIOS routines to access the hardware. If you wonder, this is the main factor that helped to emulate the PS1 on a wide range of platforms.\n\nAlong with the SDK, Sony also distributed specialised hardware like the DTL-H2000: a dual-slot ISA card containing the internals and I/O of the PS1 [22], plus extra circuitry for debugging purposes. The board has access to the hostâ€™s hard drive and can execute PS1 software without restrictions. The respective software required a PC with Windows 3.1 or 95 installed.\n\nAnti-piracy / Region Lock\n\nAs you may know, to fetch data from a CD, a laser beam is used to detect the pits and lands from the track of the disc.\n\nNow, conventional discs are not 100% flat and they often have tiny fluctuations in their tracks. These defects are completely unnoticeable while reading the data since lasers can automatically calibrate themselves as they read.\n\nThis is what Sony based their copy protection on: The Sub-CPU will allow reading discs whose Table of Contents (TOC) are engraved using a defined frequency informally known as Wobble Groove, which is only applied during mastering and cannot be replicated through conventional burners. The TOC is found in the inner section of the CD (called â€˜Lead-Inâ€™ area) and instructs the laser on how to navigate throughout the disc [23]. Moreover, itâ€™s repeated many times as a fault-tolerance mechanism.\n\nWithin the PS1 gameâ€™s TOC, one of the following character strings is embedded:\n\nSCEA â†’ Sony Computer Entertainment of America.\n\nSCEE â†’ Sony Computer Entertainment of Europe.\n\nSCEI â†’ Sony Computer Entertainment of Japan.\n\nAs you can imagine, the reader applies region-locking using this technique as well.\n\nDefeat\n\nOn the other side, this check is only executed once at the start, so manually swapping the disc just after passing the check can defeat this protectionâ€¦ with the risk of damaging the drive. Later on, some games took matters into their own hands and often reinitialised the drive in-game so the check would be executed again, this was done to prevent users from performing the â€˜swap trickâ€™.\n\nAlternatively, tiny boards programmed to mock the wobble signal could be soldered in the console. These boards are known as Modchips and, while legally questionable, they were incredibly popular.\n\nRetaliation\n\nThe use of emulators was seen as a threat for publishers as well. As a result, some games included their own checks (mostly checksums) to combat any type of unauthorised use or modification.\n\nOne of the checks I was told consisted of deliberately reinitialising the drive and then making it read specific sectors that would not pass the wobble groove check. If this managed to unlock the drive anyway, the game (still residing in RAM) would happily reveal its anti-piracy material. Notice that this approach can also affect modded consoles using genuine games.\n\nLater on, Sony provided a library called Libcrypt which fortified copy protection with the use of two approaches [24]:\n\nFrom the hardware side, checksums of sectors are stored in sub-channels of the disc.\n\nCD-ROM sub-channels traditionally store metadata, mostly to guide the drive. These arenâ€™t user-accessible and conventional readers rarely allow to manually write over them.\n\nFrom the software side, a set of routines that get the checksum values and mix them with others are embedded at different points of the game. This attempted to mitigate both emulators and modchips.\n\nThatâ€™s all folks\n\nContributing\n\nThis article is part of the Architecture of Consoles series. If you found it interesting then please consider donating. Your contribution will be used to fund the purchase of tools and resources that will help me to improve the quality of existing articles and upcoming ones.\n\nYou can also buy the eBook edition in English. I treat profits as donations.\n\nA list of desirable tools and latest acquisitions for this article are tracked in here:\n\n### Interesting hardware to get (ordered by priority) - First PS1 revision with a controller (Â£5 - Â£20 ?) - Any game (Â£5 ?)\n\nAlternatively, you can help out by suggesting changes and/or adding translations.\n\nCopyright and permissions\n\nThis work is licensed under a Creative Commons Attribution 4.0 International License. You may use it for your work at no cost, even for commercial purposes. But you have to respect the license and reference the article properly. Please take a look at the following guidelines and permissions:\n\nArticle information and referencing\n\nFor any referencing style, you can use the following information:\n\nTitle of article: PlayStation Architecture - A Practical Analysis\n\nAuthor: Rodrigo Copetti\n\nURL: https://www.copetti.org/writings/consoles/playstation/\n\nDate of publication: August 8, 2019\n\nLast modified: August 28, 2024\n\nFor instance, to use with BibTeX:\n\n@misc{copetti-ps1, url = {https://www.copetti.org/writings/consoles/playstation/}, title = {PlayStation Architecture - A Practical Analysis}, author = {Rodrigo Copetti}, year = {2019} }\n\nor a IEEE style citation:\n\n[1]R. Copetti, \"PlayStation Architecture - A Practical Analysis\", Copetti.org, 2019. [Online]. Available: https://www.copetti.org/writings/consoles/playstation/. [Accessed: day- month- year].\n\nSpecial use in multimedia (Youtube, Twitch, etc)\n\nI only ask that you at least state the authorâ€™s name, the title of the article and the URL of the article, using any style of choice.\n\nYou donâ€™t have to include all the information in the same place if itâ€™s not feasible. For instance, if you use the articleâ€™s imagery in a Youtube video, you may state either the authorâ€™s name or URL of the article at the bottom of the image, and then include the complete reference in the video description. In other words, for any resource used from this website, let your viewers know where it originates from.\n\nThis is a very nice example because the channel shows this website directly and their viewers know where to find it. In fact, I was so impressed with their content and commentary that I gave them an interview ðŸ™‚.\n\nAppreciated additions\n\nIf this article has significantly contributed to your work, I would appreciate it if you could dedicate an acknowledgement section, just like I do with the people and communities that helped me.\n\nThis is of course optional and beyond the requirements of the CC license, but I think itâ€™s a nice detail that makes us, the random authors on the net, feel part of something bigger.\n\nThird-party publishing\n\nIf you are interested in publishing this article on a third-party website, please get in touch.\n\nIf you have translated an article and wish to publish it on a third-party website, I tend to be open about it, but please contact me first.\n\nSources / Keep Reading\n\nCopy protection\n\nTechnology Connections, Sonyâ€™s clever but flawed PlayStation copy protectionâ€“and how they might have fixed it. Youtube.\n\nkalymos, PsNee (open-source modchip using an arduino). Github.\n\nconsolecopyworld.com, PSX libcrypt tutorial.\n\nCPU\n\nMartin Korth, Nocash PSX specifications.\n\nMAMEdev, MAME. Github.\n\nMAMEdev, MAME. Github.\n\nJakub CzekaÅ„ski, CPU access time logs.\n\nIntegrated Device Technology, R30xx family software reference manual.\n\nLSI Logic, LR33300 userâ€™s manual.\n\nRaymond Chen, The MIPS R4000, part 8: Control transfer.\n\nGabriel Ivancescu, Fixed point arithmetic and tricks.\n\nMichael Sabin, The PlayStation 1 video (STR format).\n\nJakub CzekaÅ„ski, Encode.cpp (MDEC encoder in c++). Github.\n\nComputer History Museum, MIPS: Risking it all on RISC. Youtube.\n\nGerhard Lenerz, Professional iris.\n\nGames\n\nShadow, Sony DTL-H2000 troubleshooting, info, setup, parts & help. Archived.\n\nGraphics\n\nAndy Gavin, Making crash bandicoot.\n\nPSXSPX contributors, Graphics processing unit (GPU).\n\nSN Systems Limited, PlayStation ordering table tutorial.\n\nTomas Akenine-MÃ¶ller, Some notes on graphics hardware.\n\nHalkun, Gears episode 2 - PlayStation architecture. Youtube.\n\nmicrosoft.com, Rasterization rules (Direct3D 9).\n\nRetrocomputing, Why do 3D models on the PlayStation 1 â€œwobbleâ€ so much?.\n\nDevon CM, PSX unstable polygons. Youtube.\n\nI/O\n\nSony, SCPH-9000 series service manual - 3rd edition.\n\norg (psxdev), CD-decoder ROM dumped.\n\nAndrea Uccheddu, PSX â€“ diving into custom CDROM i/o functions in xenogears.\n\nOperating System\n\npsxdev, PSX BIOS (translation).\n\nOther Media\n\nThe Models Resource, 3D models. Archived.\n\nPhotography\n\nEvan Amos, The vanamo online game museum.\n\nRodrigo Copetti (Me), Diagrams, motherboard, slim model photos, screenshots and videos.\n\nChangelog\n\nItâ€™s always nice to keep a record of changes. For a complete report, you can check the commit log. Alternatively, hereâ€™s a simplified list:\n\n### 2021-06-30 - Corrected load delay info (see https://github.com/flipacholas/Architecture-of-consoles/issues/45 and https://github.com/flipacholas/Architecture-of-consoles/issues/48). Thanks u/meancoot, Cat coherence and saveriomiroddi. ### 2021-06-29 - Corrected data cache info (see https://github.com/flipacholas/Architecture-of-consoles/issues/42). Thanks pnp2084, Jakub Czekanski and Cat coherence. ### 2021-06-18 - Corrected buses of the main diagram, thanks repeto and Jakub Czekanski. ### 2021-06-17 - Corrected diagram and system control coprocessor statements, thanks repeto and Nicolas Noble. - Added more resources to understand the MDEC, thanks Jakub Czekanski. ### 2021-06-14 General overhaul with lots of changes: - New sections: I/O and Operating System. - More diagrams and improved current ones. - CPU: Added history, co-processors features and delay slots. - GPU: Added more info about the rasterizer and texture mapping, distorted effects and video out. - Audio: Corrected SRAM to DRAM, mentioned streaming capabilities. Thanks dpt, Nicolas Noble and the Emulation Development discord. ### 2021-02-13 - Improved layout and sources. ### 2020-04-24 - Improved audio section. - More anti-piracy and I/O content. Thanks simias and /u/impiaaa from HackerNews and /r/programming, respectively. ### 2020-04-19 - Expanded anti-piracy section after finding more info ### 2020-04-11 - Dedicated more text to the visibility approach ### 2020-02-28 - Expanded VRAM section ### 2020-01-27 - Expanded 'Models' section - Added more reasons textures wobble ### 2019-10-29 - Added some 3d models to fiddle with ### 2019-10-09 - Improved Scratchpad term ### 2019-09-17 - Added a quick introduction ### 2019-08-29 - Better explanations ### 2019-08-09 - Corrected vague CPU info ### 2019-08-08 - Ready for publication"
    }
}