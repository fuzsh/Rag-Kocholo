{
    "id": "dbpedia_4874_2",
    "rank": 55,
    "data": {
        "url": "https://stackoverflow.com/questions/1026069/how-do-i-make-the-first-letter-of-a-string-uppercase-in-javascript",
        "read_more_link": "",
        "language": "en",
        "title": "How do I make the first letter of a string uppercase in JavaScript?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/5ed02658b2440179f00eeff8beb7aa4c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3836be42aafd22765e6988e5f995226b?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/UIrGI.jpg?s=64",
            "https://www.gravatar.com/avatar/681487482f67fa33387464e33bf36f75?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e886030108e8a73b1330db08811f3b15?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a766a4de48fafd68645e018dd7abf0a4?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Pub1I.png?s=64",
            "https://www.gravatar.com/avatar/7bf666b0d6c029e01b10b5dc32e06676?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://www.gravatar.com/avatar/d7ac5071cf9a5bb6a7c57b4a5de50057?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/tNwKk.png",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/K877D.png?s=64",
            "https://i.sstatic.net/BtSlV.jpg?s=64",
            "https://i.sstatic.net/TWIPf.jpg?s=64",
            "https://www.gravatar.com/avatar/8a87fef841167a2f4df0ccaa2e72fdbf?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/3MBg6.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/99ee6ef772d361fe937246e984a1ebd5?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://lh3.googleusercontent.com/-PawVF0qwzwY/AAAAAAAAAAI/AAAAAAAAABc/XCIKhmWmXdk/photo.jpg?sz=64",
            "https://i.sstatic.net/CQkj0.png",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://www.gravatar.com/avatar/ce4cdee924af3e6acb9cb1d333a65f0e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/12f137c77c28be81c89021769817f6ca?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/a270a77d53992e26e8207fd6112eb3e8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://i.sstatic.net/WtfBG.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/Zq3Qi.jpg?s=64",
            "https://i.sstatic.net/WfG1n.jpg?s=64",
            "https://www.gravatar.com/avatar/f59bf88218f7061d4562ad6b6bad9ff3?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f772a84e2faeff336ba1ad32021752f9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3836be42aafd22765e6988e5f995226b?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://www.gravatar.com/avatar/1e4f8a3ddaa5065089f160acb05d8ab8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/4b3d722df1b0c7ed6c352cff71006012?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/RiFQ7.jpg?s=64",
            "https://www.gravatar.com/avatar/12f137c77c28be81c89021769817f6ca?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/55cf11304b76b862d255efbc577ce805?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/b0bc8f9943932f966f1423d87e3f5cfe?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/ea3f4c87ac0733f5734f66962daa68c5?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/F2Ocm.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/2bf82c23cff41c0297041b13d7706e31?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://i.sstatic.net/dymec.png?s=64",
            "https://i.sstatic.net/WhpGs.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/9294ae442bee6ba7189f7fa7d7e7c3d6?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/fN5VN.jpg?s=64",
            "https://lh5.googleusercontent.com/-p8nrFSzhmkQ/AAAAAAAAAAI/AAAAAAAAICY/DkOb8x4fzNM/photo.jpg?sz=64",
            "https://i.sstatic.net/MTG05.jpg?s=64",
            "https://stackoverflow.com/posts/1026069/ivc/fc3a?prg=d1da3a90-53ef-4ac7-bc99-deb8918e903c",
            "https://stackoverflow.com/js-false.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-06-22T08:25:31",
        "summary": "",
        "meta_description": "How do I make the first character of a string uppercase if it's a letter, but not change the case of any of the other letters?\nFor example:\n\n&quot;this is a test&quot; → &quot;This is a test&quot;\n...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/1026069/how-do-i-make-the-first-letter-of-a-string-uppercase-in-javascript",
        "text": "I didn’t see any mention in the existing answers of issues related to astral plane code points or internationalization. “Uppercase” doesn’t mean the same thing in every language using a given script.\n\nInitially I didn’t see any answers addressing issues related to astral plane code points. There is one, but it’s a bit buried (like this one will be, I guess!)\n\nOverview of the hidden problem and various approaches to it\n\nMost of the proposed functions look like this:\n\nfunction capitalizeFirstLetter(str) { return str[0].toUpperCase() + str.slice(1); }\n\nHowever, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:\n\ncapitalizeFirstLetter(\"𐐶𐐲𐑌𐐼𐐲𐑉\"); // \"𐐶𐐲𐑌𐐼𐐲𐑉\"\n\nThe first character here fails to capitalize because the array-indexed properties of strings don’t access “characters” or code points*. They access UTF-16 code units. This is true also when slicing — the index values point at code units.\n\nIt happens to be that UTF-16 code units are 1:1 with USV (Unicode scalar value) code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.\n\nFrom ES2015 on, dealing with this became a bit easier. String.prototype[@@iterator] yields strings corresponding to code points**. So for example, we can do this:\n\nfunction capitalizeFirstLetter([ first='', ...rest ]) { return [ first.toUpperCase(), ...rest ].join(''); } capitalizeFirstLetter(\"𐐶𐐲𐑌𐐼𐐲𐑉\") // \"𐐎𐐲𐑌𐐼𐐲𐑉\"\n\nFor longer strings, this is probably not terribly efficient*** — we don’t really need to iterate the remainder. We could use String.prototype.codePointAt to get at that first (possible) letter, but we’d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isn’t, the slice begins at 1, and if it is, the slice begins at 2.\n\nfunction capitalizeFirstLetter(str) { if (!str) return ''; const firstCodePoint = str.codePointAt(0); const index = firstCodePoint > 0xFFFF ? 2 : 1; return String.fromCodePoint(firstCodePoint).toUpperCase() + str.slice(index); } capitalizeFirstLetter(\"𐐶𐐲𐑌𐐼𐐲𐑉\") // \"𐐎𐐲𐑌𐐼𐐲𐑉\"\n\nYou could use bitwise math instead of > 0xFFFF there, but it’s probably easier to understand this way and either would achieve the same thing.\n\nWe can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:\n\nfunction capitalizeFirstLetter(str) { if (!str) return ''; var firstCodeUnit = str[0]; if (firstCodeUnit < '\\uD800' || firstCodeUnit > '\\uDFFF') { return str[0].toUpperCase() + str.slice(1); } return str.slice(0, 2).toUpperCase() + str.slice(2); } capitalizeFirstLetter(\"𐐶𐐲𐑌𐐼𐐲𐑉\") // \"𐐎𐐲𐑌𐐼𐐲𐑉\"\n\nDeeper into internationalization (whose capitalization?)\n\nAt the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of what language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph \"mb\" capitalizes as \"mB\" at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (“ß”) capitalizes to “SS,” but “SS” could lowercase to either “ß” or “ss” — you require out-of-band knowledge of the German language to know which is correct!\n\nThe most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is İ, while the lowercase form of I is ı — they’re two different letters. Fortunately we do have a way to account for this:\n\nfunction capitalizeFirstLetter([ first='', ...rest ], locale) { return [ first.toLocaleUpperCase(locale), ...rest ].join(''); } capitalizeFirstLetter(\"italy\", \"en\") // \"Italy\" capitalizeFirstLetter(\"italya\", \"tr\") // \"İtalya\"\n\nIn a browser, the user’s most-preferred language tag is indicated by navigator.language, a list in order of preference is found at navigator.languages, and a given DOM element’s language can be obtained (usually) with Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE in multilanguage documents.\n\nIn agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters we’re interested in:\n\nfunction capitalizeFirstLetter(str, locale=navigator.language) { return str.replace(/^\\p{CWU}/u, char => char.toLocaleUpperCase(locale)); }\n\nThis could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy for at least some languages, though outlying cases will be hard to avoid completely if doing so no matter what the primary language is.\n\nThe \\p{CWU} or Changes_When_Uppercased character property matches all code points which change when uppercased in the generic case where specific locale data is absent. There are other interesting case-related Unicode character properties that you may wish to play around with. It’s a cool zone to explore but we’d go on all day if we enumerated em all here. Here’s something to get your curiosity going if you’re unfamiliar, though: \\p{Lower} is a larger group than \\p{LowercaseLetter} (aka \\p{Ll}) — conveniently illustrated by the default character set comparison in this tool provided by Unicode. (NB: not everything you can reference there is also available in ES regular expressions, but most of the stuff you’re likely to want is).\n\nAlternatives to case-mapping in JS (Firefox & CSS love the Dutch!)\n\nIf digraphs with unique locale/language/orthography capitalization rules happen to have a single-codepoint “composed” representation in Unicode, these might be used to make one’s capitalization expectations explicit even in the absence of locale data. For example, we could prefer the composed i-j digraph, ĳ / U+133, associated with Dutch, to ensure a case-mapping to uppercase Ĳ / U+132:\n\ncapitalizeFirstLetter('ĳsselmeer'); // \"Ĳsselmeer\"\n\nOn the other hand, precomposed digraphs and similar are sometimes deprecated (like that one, it seems!) and may be undesirable in interchanged text regardless due to the potential copypaste nuisance if that’s not the normal way folks type the sequence in practice. Unfortunately, in the absence of the precomposition “hint,” an explicit locale won’t help here (at least as far as I know). If we spell ijsselmeer with an ordinary i + j, capitalizeFirstLetter will produce the wrong result even if we explicitly indicate nl as the locale:\n\ncapitalizeFirstLetter('ijsselmeer', 'nl'); // \"Ijsselmeer\" :(\n\n(I’m not entirely sure whether there are some such cases where the behavior comes down to ICU data availability — perhaps someone else could say.)\n\nIf the point of the transformation is to display textual content in a web browser, though, you have an entirely different option available that will likely be your best bet: leveraging features of the web platform’s other core languages, HTML and CSS. Armed with HTML’s lang=... and CSS’s text-transform:..., you’ve got a (pseudo-)declarative solution that leaves extra room for the user agent to be “smart.” A JS API needs to have predictable outcomes across all browsers (generally) and isn’t free to experiment with heuristics. The user-agent itself is obligated only to its user, though, and heuristic solutions are fair game when the output is for a human being. If we tell it “this text is Dutch, but please display it capitalized,” the particular outcome might now vary between browsers, but it’s likely going to be the best each of them could do. Let’s see:\n\nIn Chromium at the time of writing, both the English and Dutch lines come out as Ijsselmeer — so it does no better than JS. But try it in current Firefox! The element that we told the browser contains Dutch will be correctly rendered as IJsselmeer there.\n\nThis solution is purpose-specific (it’s not gonna help you in Node, anyway) but it was silly of me not to draw attention to it previously given some folks might not realize they’re googling the wrong question. Thanks @paul23 for clarifying more about the nature of the IJ digraph in practice and prompting further investigation!\n\nAs of January 2021, all major engines have implemented the Unicode property character class feature, but depending on your target support range you may not be able to use it safely yet. The last browser to introduce support was Firefox (78; June 30, 2020). You can check for support of this feature with the Kangax compat table. Babel can be used to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code can sometimes be enormous. You probably would not want to do this unless you’re certain the tradeoff is justified for your use case.\n\nIn all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But it’s good to be aware of these issues because there’s a good chance you’ll encounter them eventually even if they aren’t concerns presently. They’re not “edge” cases, or rather, they’re not by-definition edge cases — there’s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!\n\n* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but that’s not what it “means” here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).\n\n** Though if a surrogate code unit is “orphaned” — i.e., not part of a logical pair — you could still get surrogates here, too.\n\n*** maybe. I haven’t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldn’t sweat it — choose whatever you believe is most clear and readable.\n\n**** such a function might wish to test both the first and second code units instead of just the first, since it’s possible that the first unit is an orphaned surrogate. For example the input \"\\uD800x\" would capitalize the X as-is, which may or may not be expected."
    }
}