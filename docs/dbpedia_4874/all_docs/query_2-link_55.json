{
    "id": "dbpedia_4874_2",
    "rank": 55,
    "data": {
        "url": "https://stackoverflow.com/questions/1026069/how-do-i-make-the-first-letter-of-a-string-uppercase-in-javascript",
        "read_more_link": "",
        "language": "en",
        "title": "How do I make the first letter of a string uppercase in JavaScript?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/5ed02658b2440179f00eeff8beb7aa4c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3836be42aafd22765e6988e5f995226b?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/UIrGI.jpg?s=64",
            "https://www.gravatar.com/avatar/681487482f67fa33387464e33bf36f75?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e886030108e8a73b1330db08811f3b15?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a766a4de48fafd68645e018dd7abf0a4?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Pub1I.png?s=64",
            "https://www.gravatar.com/avatar/7bf666b0d6c029e01b10b5dc32e06676?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://www.gravatar.com/avatar/d7ac5071cf9a5bb6a7c57b4a5de50057?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/tNwKk.png",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/K877D.png?s=64",
            "https://i.sstatic.net/BtSlV.jpg?s=64",
            "https://i.sstatic.net/TWIPf.jpg?s=64",
            "https://www.gravatar.com/avatar/8a87fef841167a2f4df0ccaa2e72fdbf?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/3MBg6.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/99ee6ef772d361fe937246e984a1ebd5?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://lh3.googleusercontent.com/-PawVF0qwzwY/AAAAAAAAAAI/AAAAAAAAABc/XCIKhmWmXdk/photo.jpg?sz=64",
            "https://i.sstatic.net/CQkj0.png",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://www.gravatar.com/avatar/ce4cdee924af3e6acb9cb1d333a65f0e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/12f137c77c28be81c89021769817f6ca?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/a270a77d53992e26e8207fd6112eb3e8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://i.sstatic.net/WtfBG.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/Zq3Qi.jpg?s=64",
            "https://i.sstatic.net/WfG1n.jpg?s=64",
            "https://www.gravatar.com/avatar/f59bf88218f7061d4562ad6b6bad9ff3?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f772a84e2faeff336ba1ad32021752f9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3836be42aafd22765e6988e5f995226b?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://www.gravatar.com/avatar/1e4f8a3ddaa5065089f160acb05d8ab8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/4b3d722df1b0c7ed6c352cff71006012?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/RiFQ7.jpg?s=64",
            "https://www.gravatar.com/avatar/12f137c77c28be81c89021769817f6ca?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/55cf11304b76b862d255efbc577ce805?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/b0bc8f9943932f966f1423d87e3f5cfe?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/ea3f4c87ac0733f5734f66962daa68c5?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/F2Ocm.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/2bf82c23cff41c0297041b13d7706e31?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wECdC.jpg?s=64",
            "https://i.sstatic.net/dymec.png?s=64",
            "https://i.sstatic.net/WhpGs.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/9294ae442bee6ba7189f7fa7d7e7c3d6?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/fN5VN.jpg?s=64",
            "https://lh5.googleusercontent.com/-p8nrFSzhmkQ/AAAAAAAAAAI/AAAAAAAAICY/DkOb8x4fzNM/photo.jpg?sz=64",
            "https://i.sstatic.net/MTG05.jpg?s=64",
            "https://stackoverflow.com/posts/1026069/ivc/fc3a?prg=d1da3a90-53ef-4ac7-bc99-deb8918e903c",
            "https://stackoverflow.com/js-false.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-06-22T08:25:31",
        "summary": "",
        "meta_description": "How do I make the first character of a string uppercase if it's a letter, but not change the case of any of the other letters?\nFor example:\n\n&quot;this is a test&quot; â†’ &quot;This is a test&quot;\n...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/1026069/how-do-i-make-the-first-letter-of-a-string-uppercase-in-javascript",
        "text": "I didnâ€™t see any mention in the existing answers of issues related to astral plane code points or internationalization. â€œUppercaseâ€ doesnâ€™t mean the same thing in every language using a given script.\n\nInitially I didnâ€™t see any answers addressing issues related to astral plane code points. There is one, but itâ€™s a bit buried (like this one will be, I guess!)\n\nOverview of the hidden problem and various approaches to it\n\nMost of the proposed functions look like this:\n\nfunction capitalizeFirstLetter(str) { return str[0].toUpperCase() + str.slice(1); }\n\nHowever, some cased characters fall outside the BMP (basic multilingual plane, code points U+0 to U+FFFF). For example take this Deseret text:\n\ncapitalizeFirstLetter(\"ğ¶ğ²ğ‘Œğ¼ğ²ğ‘‰\"); // \"ğ¶ğ²ğ‘Œğ¼ğ²ğ‘‰\"\n\nThe first character here fails to capitalize because the array-indexed properties of strings donâ€™t access â€œcharactersâ€ or code points*. They access UTF-16 code units. This is true also when slicing â€” the index values point at code units.\n\nIt happens to be that UTF-16 code units are 1:1 with USV (Unicode scalar value) code points within two ranges, U+0 to U+D7FF and U+E000 to U+FFFF inclusive. Most cased characters fall into those two ranges, but not all of them.\n\nFrom ES2015 on, dealing with this became a bit easier. String.prototype[@@iterator] yields strings corresponding to code points**. So for example, we can do this:\n\nfunction capitalizeFirstLetter([ first='', ...rest ]) { return [ first.toUpperCase(), ...rest ].join(''); } capitalizeFirstLetter(\"ğ¶ğ²ğ‘Œğ¼ğ²ğ‘‰\") // \"ğğ²ğ‘Œğ¼ğ²ğ‘‰\"\n\nFor longer strings, this is probably not terribly efficient*** â€” we donâ€™t really need to iterate the remainder. We could use String.prototype.codePointAt to get at that first (possible) letter, but weâ€™d still need to determine where the slice should begin. One way to avoid iterating the remainder would be to test whether the first codepoint is outside the BMP; if it isnâ€™t, the slice begins at 1, and if it is, the slice begins at 2.\n\nfunction capitalizeFirstLetter(str) { if (!str) return ''; const firstCodePoint = str.codePointAt(0); const index = firstCodePoint > 0xFFFF ? 2 : 1; return String.fromCodePoint(firstCodePoint).toUpperCase() + str.slice(index); } capitalizeFirstLetter(\"ğ¶ğ²ğ‘Œğ¼ğ²ğ‘‰\") // \"ğğ²ğ‘Œğ¼ğ²ğ‘‰\"\n\nYou could use bitwise math instead of > 0xFFFF there, but itâ€™s probably easier to understand this way and either would achieve the same thing.\n\nWe can also make this work in ES5 and below by taking that logic a bit further if necessary. There are no intrinsic methods in ES5 for working with codepoints, so we have to manually test whether the first code unit is a surrogate****:\n\nfunction capitalizeFirstLetter(str) { if (!str) return ''; var firstCodeUnit = str[0]; if (firstCodeUnit < '\\uD800' || firstCodeUnit > '\\uDFFF') { return str[0].toUpperCase() + str.slice(1); } return str.slice(0, 2).toUpperCase() + str.slice(2); } capitalizeFirstLetter(\"ğ¶ğ²ğ‘Œğ¼ğ²ğ‘‰\") // \"ğğ²ğ‘Œğ¼ğ²ğ‘‰\"\n\nDeeper into internationalization (whose capitalization?)\n\nAt the start I also mentioned internationalization considerations. Some of these are very difficult to account for because they require knowledge not only of what language is being used, but also may require specific knowledge of the words in the language. For example, the Irish digraph \"mb\" capitalizes as \"mB\" at the start of a word. Another example, the German eszett, never begins a word (afaik), but still helps illustrate the problem. The lowercase eszett (â€œÃŸâ€) capitalizes to â€œSS,â€ but â€œSSâ€ could lowercase to either â€œÃŸâ€ or â€œssâ€ â€” you require out-of-band knowledge of the German language to know which is correct!\n\nThe most famous example of these kinds of issues, probably, is Turkish. In Turkish Latin, the capital form of i is Ä°, while the lowercase form of I is Ä± â€” theyâ€™re two different letters. Fortunately we do have a way to account for this:\n\nfunction capitalizeFirstLetter([ first='', ...rest ], locale) { return [ first.toLocaleUpperCase(locale), ...rest ].join(''); } capitalizeFirstLetter(\"italy\", \"en\") // \"Italy\" capitalizeFirstLetter(\"italya\", \"tr\") // \"Ä°talya\"\n\nIn a browser, the userâ€™s most-preferred language tag is indicated by navigator.language, a list in order of preference is found at navigator.languages, and a given DOM elementâ€™s language can be obtained (usually) with Object(element.closest('[lang]')).lang || YOUR_DEFAULT_HERE in multilanguage documents.\n\nIn agents which support Unicode property character classes in RegExp, which were introduced in ES2018, we can clean stuff up further by directly expressing what characters weâ€™re interested in:\n\nfunction capitalizeFirstLetter(str, locale=navigator.language) { return str.replace(/^\\p{CWU}/u, char => char.toLocaleUpperCase(locale)); }\n\nThis could be tweaked a bit to also handle capitalizing multiple words in a string with fairly good accuracy for at least some languages, though outlying cases will be hard to avoid completely if doing so no matter what the primary language is.\n\nThe \\p{CWU} or Changes_When_Uppercased character property matches all code points which change when uppercased in the generic case where specific locale data is absent. There are other interesting case-related Unicode character properties that you may wish to play around with. Itâ€™s a cool zone to explore but weâ€™d go on all day if we enumerated em all here. Hereâ€™s something to get your curiosity going if youâ€™re unfamiliar, though: \\p{Lower} is a larger group than \\p{LowercaseLetter} (aka \\p{Ll}) â€” conveniently illustrated by the default character set comparison in this tool provided by Unicode. (NB: not everything you can reference there is also available in ES regular expressions, but most of the stuff youâ€™re likely to want is).\n\nAlternatives to case-mapping in JS (Firefox & CSS love the Dutch!)\n\nIf digraphs with unique locale/language/orthography capitalization rules happen to have a single-codepoint â€œcomposedâ€ representation in Unicode, these might be used to make oneâ€™s capitalization expectations explicit even in the absence of locale data. For example, we could prefer the composed i-j digraph, Ä³ / U+133, associated with Dutch, to ensure a case-mapping to uppercase Ä² / U+132:\n\ncapitalizeFirstLetter('Ä³sselmeer'); // \"Ä²sselmeer\"\n\nOn the other hand, precomposed digraphs and similar are sometimes deprecated (like that one, it seems!) and may be undesirable in interchanged text regardless due to the potential copypaste nuisance if thatâ€™s not the normal way folks type the sequence in practice. Unfortunately, in the absence of the precomposition â€œhint,â€ an explicit locale wonâ€™t help here (at least as far as I know). If we spell ijsselmeer with an ordinary i + j, capitalizeFirstLetter will produce the wrong result even if we explicitly indicate nl as the locale:\n\ncapitalizeFirstLetter('ijsselmeer', 'nl'); // \"Ijsselmeer\" :(\n\n(Iâ€™m not entirely sure whether there are some such cases where the behavior comes down to ICU data availability â€” perhaps someone else could say.)\n\nIf the point of the transformation is to display textual content in a web browser, though, you have an entirely different option available that will likely be your best bet: leveraging features of the web platformâ€™s other core languages, HTML and CSS. Armed with HTMLâ€™s lang=... and CSSâ€™s text-transform:..., youâ€™ve got a (pseudo-)declarative solution that leaves extra room for the user agent to be â€œsmart.â€ A JS API needs to have predictable outcomes across all browsers (generally) and isnâ€™t free to experiment with heuristics. The user-agent itself is obligated only to its user, though, and heuristic solutions are fair game when the output is for a human being. If we tell it â€œthis text is Dutch, but please display it capitalized,â€ the particular outcome might now vary between browsers, but itâ€™s likely going to be the best each of them could do. Letâ€™s see:\n\nIn Chromium at the time of writing, both the English and Dutch lines come out as Ijsselmeer â€” so it does no better than JS. But try it in current Firefox! The element that we told the browser contains Dutch will be correctly rendered as IJsselmeer there.\n\nThis solution is purpose-specific (itâ€™s not gonna help you in Node, anyway) but it was silly of me not to draw attention to it previously given some folks might not realize theyâ€™re googling the wrong question. Thanks @paul23 for clarifying more about the nature of the IJ digraph in practice and prompting further investigation!\n\nAs of January 2021, all major engines have implemented the Unicode property character class feature, but depending on your target support range you may not be able to use it safely yet. The last browser to introduce support was Firefox (78; June 30, 2020). You can check for support of this feature with the Kangax compat table. Babel can be used to compile RegExp literals with property references to equivalent patterns without them, but be aware that the resulting code can sometimes be enormous. You probably would not want to do this unless youâ€™re certain the tradeoff is justified for your use case.\n\nIn all likelihood, people asking this question will not be concerned with Deseret capitalization or internationalization. But itâ€™s good to be aware of these issues because thereâ€™s a good chance youâ€™ll encounter them eventually even if they arenâ€™t concerns presently. Theyâ€™re not â€œedgeâ€ cases, or rather, theyâ€™re not by-definition edge cases â€” thereâ€™s a whole country where most people speak Turkish, anyway, and conflating code units with codepoints is a fairly common source of bugs (especially with regard to emoji). Both strings and language are pretty complicated!\n\n* The code units of UTF-16 / UCS2 are also Unicode code points in the sense that e.g. U+D800 is technically a code point, but thatâ€™s not what it â€œmeansâ€ here ... sort of ... though it gets pretty fuzzy. What the surrogates definitely are not, though, is USVs (Unicode scalar values).\n\n** Though if a surrogate code unit is â€œorphanedâ€ â€” i.e., not part of a logical pair â€” you could still get surrogates here, too.\n\n*** maybe. I havenâ€™t tested it. Unless you have determined capitalization is a meaningful bottleneck, I probably wouldnâ€™t sweat it â€” choose whatever you believe is most clear and readable.\n\n**** such a function might wish to test both the first and second code units instead of just the first, since itâ€™s possible that the first unit is an orphaned surrogate. For example the input \"\\uD800x\" would capitalize the X as-is, which may or may not be expected."
    }
}