{
    "id": "dbpedia_988_2",
    "rank": 80,
    "data": {
        "url": "https://patents.google.com/patent/US6069633A/en",
        "read_more_link": "",
        "language": "en",
        "title": "US6069633A - Sprite engine - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/33/f3/33/10a47eccee9eda/US6069633-drawings-page-2.png",
            "https://patentimages.storage.googleapis.com/8a/c1/0b/bb50bc6ed57ae9/US6069633-drawings-page-3.png",
            "https://patentimages.storage.googleapis.com/e7/0a/cf/cac59363fc9b45/US6069633-drawings-page-4.png",
            "https://patentimages.storage.googleapis.com/2a/34/18/126e7982c2d598/US6069633-drawings-page-5.png",
            "https://patentimages.storage.googleapis.com/6e/ce/75/0a1e0e0002d78c/US6069633-drawings-page-6.png",
            "https://patentimages.storage.googleapis.com/fa/79/79/ff8aad01f465f0/US6069633-drawings-page-7.png",
            "https://patentimages.storage.googleapis.com/d2/6a/8a/db9734d058d0cd/US6069633-drawings-page-8.png",
            "https://patentimages.storage.googleapis.com/0e/4f/ae/1162b689f340bc/US6069633-drawings-page-9.png",
            "https://patentimages.storage.googleapis.com/8d/07/71/737547979265b9/US6069633-drawings-page-10.png",
            "https://patentimages.storage.googleapis.com/09/e2/d9/22c11b55a4b963/US6069633-drawings-page-11.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1997-09-18T00:00:00",
        "summary": "",
        "meta_description": "A sprite engine or compositor that is well-adapted to a variety ofadaptable to a host platforms and that minimizes the amount of drawing that occurs on a refresh of a framebuffer display area. The invention exploits the host platform's abilities to perform both back-to-front and front-to-back drawing algorithms, where the choice of algorithm used depends upon whether a sprite is opaque or transparent. Each sprite registers itself with a sprite engine, identifying whether or not the sprite is wholly opaque or notis transparent, the bounding area of the sprite, and the function that the sprite uses to draw. The function can be the drawing routine that is available from the host platform or operating system. The sprite engine keeps track of the Z position of each sprite and examines each sprite to determine if the sprite overlaps a particular region that needs to be refreshed. Sprites that are rectangular and opaque are considered special cases that can be easily drawn using athe host platform's front-to-back drawing algorithm. In a top-down manner, by Z position, all sprites that are opaque are allowed to draw. All other kinds of sprites are drawn in a back-to-front manner. When a transparent sprite is found, the sprite engine searches the remaining sprites in a bottom-up manner and draws the sprites with a Z position below the transparent sprite, finishing with the transparent sprite, using a back-to-front algorithm in the remaining region.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US6069633A/en",
        "text": "Sprite engine Download PDF\n\nInfo\n\nPublication number\n\nUS6069633A\n\nUS6069633A US08/933,146 US93314697A US6069633A US 6069633 A US6069633 A US 6069633A US 93314697 A US93314697 A US 93314697A US 6069633 A US6069633 A US 6069633A\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\nentity\n\nsprite\n\narea\n\noverlapping\n\nmodule\n\nPrior art date\n\n1997-09-18\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nExpired - Lifetime\n\nApplication number\n\nUS08/933,146\n\nInventor\n\nVidur Apparao\n\nScott Furman\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nMeta Platforms Inc\n\nOriginal Assignee\n\nNetscape Communications Corp\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n1997-09-18\n\nFiling date\n\n1997-09-18\n\nPublication date\n\n2000-05-30\n\n1997-09-18 Application filed by Netscape Communications Corp filed Critical Netscape Communications Corp\n\n1997-09-18 Priority to US08/933,146 priority Critical patent/US6069633A/en\n\n1997-09-18 Assigned to NETSCAPE COMMUNICATIONS CORPORATION reassignment NETSCAPE COMMUNICATIONS CORPORATION ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: FURMAN, SCOTT, APPARAO, VIDUR\n\n2000-05-30 Application granted granted Critical\n\n2000-05-30 Publication of US6069633A publication Critical patent/US6069633A/en\n\n2009-12-14 Assigned to BANK OF AMERICAN, N.A. AS COLLATERAL AGENT reassignment BANK OF AMERICAN, N.A. AS COLLATERAL AGENT SECURITY AGREEMENT Assignors: AOL ADVERTISING INC., AOL INC., BEBO, INC., GOING, INC., ICQ LLC, LIGHTNINGCAST LLC, MAPQUEST, INC., NETSCAPE COMMUNICATIONS CORPORATION, QUIGO TECHNOLOGIES LLC, SPHERE SOURCE, INC., TACODA LLC, TRUVEO, INC., YEDDA, INC.\n\n2010-11-16 Assigned to AOL ADVERTISING INC, TRUVEO, INC, QUIGO TECHNOLOGIES LLC, SPHERE SOURCE, INC, MAPQUEST, INC, TACODA LLC, LIGHTNINGCAST LLC, GOING INC, AOL INC, YEDDA, INC, NETSCAPE COMMUNICATIONS CORPORATION reassignment AOL ADVERTISING INC TERMINATION AND RELEASE OF SECURITY INTEREST IN PATENT RIGHTS Assignors: BANK OF AMERICA, N A\n\n2012-06-20 Assigned to NEW AURORA CORPORATION reassignment NEW AURORA CORPORATION CHANGE OF NAME (SEE DOCUMENT FOR DETAILS). Assignors: NETSCAPE COMMUNICATIONS CORPORATION\n\n2014-09-29 Assigned to FACEBOOK, INC. reassignment FACEBOOK, INC. ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: NEW AURORA CORPORATION\n\n2017-09-18 Anticipated expiration legal-status Critical\n\n2021-12-20 Assigned to META PLATFORMS, INC. reassignment META PLATFORMS, INC. CHANGE OF NAME (SEE DOCUMENT FOR DETAILS). Assignors: FACEBOOK, INC.\n\nStatus Expired - Lifetime legal-status Critical Current\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\nImages\n\nClassifications\n\nG—PHYSICS\n\nG09—EDUCATION; CRYPTOGRAPHY; DISPLAY; ADVERTISING; SEALS\n\nG09G—ARRANGEMENTS OR CIRCUITS FOR CONTROL OF INDICATING DEVICES USING STATIC MEANS TO PRESENT VARIABLE INFORMATION\n\nG09G5/00—Control arrangements or circuits for visual indicators common to cathode-ray tube indicators and other visual indicators\n\nG09G5/36—Control arrangements or circuits for visual indicators common to cathode-ray tube indicators and other visual indicators characterised by the display of a graphic pattern, e.g. using an all-points-addressable [APA] memory\n\nG09G5/39—Control of the bit-mapped memory\n\nG09G5/393—Arrangements for updating the contents of the bit-mapped memory\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06T—IMAGE DATA PROCESSING OR GENERATION, IN GENERAL\n\nG06T15/00—3D [Three Dimensional] image rendering\n\nG06T15/10—Geometric effects\n\nG06T15/40—Hidden part removal\n\nG06T15/405—Hidden part removal using Z-buffer\n\nG—PHYSICS\n\nG09—EDUCATION; CRYPTOGRAPHY; DISPLAY; ADVERTISING; SEALS\n\nG09G—ARRANGEMENTS OR CIRCUITS FOR CONTROL OF INDICATING DEVICES USING STATIC MEANS TO PRESENT VARIABLE INFORMATION\n\nG09G2340/00—Aspects of display data processing\n\nG09G2340/12—Overlay of images, i.e. displayed pixel being the result of switching between the corresponding input pixels\n\nG—PHYSICS\n\nG09—EDUCATION; CRYPTOGRAPHY; DISPLAY; ADVERTISING; SEALS\n\nG09G—ARRANGEMENTS OR CIRCUITS FOR CONTROL OF INDICATING DEVICES USING STATIC MEANS TO PRESENT VARIABLE INFORMATION\n\nG09G5/00—Control arrangements or circuits for visual indicators common to cathode-ray tube indicators and other visual indicators\n\nG09G5/42—Control arrangements or circuits for visual indicators common to cathode-ray tube indicators and other visual indicators characterised by the display of patterns using a display memory without fixed position correspondence between the display memory contents and the display position on the screen\n\nDefinitions\n\nthe invention relates to the generation and display of an image that includes multiple planes of information. More particularly, the invention relates to displaying a plurality of opaque and/or transparent graphical entities, where each entity has a specific X and Y position and Z order relative to the other entities in the composite image.\n\nComputer-controlled game devices and personal computers use a similar approach for generating graphical images.\n\nthese graphical images are generated using an animation engine, while on personal computers they are generated using a windowing system.\n\nthe overall image that is displayed consists of opaque or partially transparent entities that can be drawn onto the computer screen.\n\nEach such entity has a X and Y position on the display, a width and height which indicate its maximum dimensions, as well as a depth indicator, its Z position.\n\nsprites On game systems, these graphical entities are called \"sprites.\" Often, A common example of a sprite simply consists ofis a bitmapped image.\n\na \"sprite engineâ is used in framebuffer-oriented game systems to control where and in what order sprites are drawn on a display. It is the responsibility of the sprite engine to calculate the minimal area of the display to be redrawn as characteristics of sprites (such as their position) change. Consider the case where two sprites move from initial positions p1 and p2 respectively to final positions p3 and p4.\n\na sprite can also have transparent areas of arbitrary complexitybe of arbitrary transparency, e.g. text.\n\nthe areas surrounding the pixels that constitute a text character can be transparent to allow another sprite behind it, for example, an image, to show through.\n\nthe calculation of the overlapping regions between sprites may beis significantly more expensive computationally because the opaque regions do not have simple rectangular boundaries.\n\nwindowing systems are similar in many ways to sprite engines, although each has different motivations and performance requirementsdifferent needs for performance.\n\nWindowing systems have windows that correspond to different applications; each application may have multiple windows.\n\nwindows have a Z dimension, which is used to determine a total ordering of depth between all windows in a windowing system.\n\nwindows are rectangular.\n\na windowing system endeavors to avoid redrawing any pixel more than once. Since windows are almost always rectangular, this is relatively easy to accomplish efficiently.\n\nwindowing systems support subwindows, that is, within one window there may be multiple subwindows.\n\nSome windowing systems also provide a root window, where the entire display is taken up by the root window in which subwindows provide applications windows.\n\nthe application windows may have their own subwindows, which may be different documents within the application.\n\nthe windowing system must calculate the minimal set of windows it must draw to complete a refresh in the same manner as the sprite engine.\n\nWindows also include a Z order dimension, in addition to the subwindow concept.\n\nMost windowing systems place subwindows in Z order in front of the parent window, such that the parent window and all of its subwindows are a single unit that can be at some position with respect to the siblings of the parent window. In summary, there is a total ordering of depth between all windows in a windowing system.\n\nBack-to-front drawing is sometimes referred to as thea painter's algorithm. That is, a painting is made using multiple layers and, in the same manner, a painter's algorithm draws the lowest layer first, then each subsequent layer, one on top of the other. The painter's algorithm may cause excessiverequires more drawing because portions of sprites are always drawn even though they may be overlapped by another sprite.\n\nDetermining the minimal subset of pixels to draw for each sprite can be a computationallymathematically intensive operation and one way to minimize that is using the painter's algorithm because no calculations are necessary to determine overlapinvolved when all sprites areeverything is drawn onto the display.\n\na video overlay board is included to overlay a video image over certain pixels containing a chroma-key value.\n\nthe topmost layer is drawn first. After the topmost layer is drawn, that portion of it that is opaqueits area is subtracted from the area that will be drawn by any sprite below this one. Then the next layer down is drawn, except for pixels outside the aforementioned drawing area that needs to be redrawn. The next layer is drawn and its area is subtracted from the remaining area to be redrawn. Its opaque pixels are subtracted from the drawing area. Each subsequent layer is drawn in the same manner.\n\nthe front-to-back algorithm may perform less drawingis more efficient than the back-to-front algorithm because it does not draw portions of sprites that are not visible when they are obscured by other spritesnot displayed.\n\na sprite consists of text with transparent areas surrounding the text\n\nthe text is drawn first.\n\nthe area of the pixels that make up the text is then subtracted from the next underlying sprite to be drawn.\n\nthe remaining part of that sprite is then drawn.\n\na region is used herein to refer to an arbitrary set of pixels on the display.\n\na region is typically not a complex area. Rather, it is a combination of rectangles.\n\na region can be very complex. Therefore, efficiently implementing a front-to-back algorithm with sprites that include portions having transparency requires a sophisticated region format.\n\nOS operating system\n\nthe native region format that is available from the operating system (OS) is not that sophisticated and cannot efficiently represent or efficiently operate on complex regions.\n\nPerforming geometric operations such as intersection, union or subtraction with complex regions on those platforms is both central processing unit (CPU) intensive and memory-intensive and is, therefore, expensive.\n\nthe algorithm requires that a record be maintained of the portion of the composited image that remains to be drawn as each layer is handled.\n\nthe algorithm does require a record of the portion of the composited image that must be redrawn at every layer.\n\nthe opaque area of each layer that is drawn is must be subtracted from thisthe remaining area. This is a computationally tractablestraightforward approach when the sprites are opaque rectangles, but whenever any portion of a sprite is transparent, the calculations required become time-consumingcomplex.\n\na sprite contains text with transparent areas surrounding the text\n\nthe text is drawn first.\n\nthe area of the text is then subtracted from the next underlying sprite to be drawn.\n\nthe remaining part of that sprite is then drawn.\n\nthe operation of determining which pixel the text picks up and then subtracting that pixel from the next underlying sprite is mathematically expensive.\n\nU.S. Pat. No. 5,216,413 issued to Seiler et al. on Jun. 1, 1993, discloses a system that defines windows as a priority-ordered list of rectangles. For a given pixel to be drawn, the highest priority rectangle containing the pixel is found. This rectangle is the only rectangle drawn. This is a front-to-back system.\n\nU.S. Pat. No. 5,487,145 issued to Marsh et al. on Jan. 23, 1996 discloses a compositing architecture for correct rendering of overlapping opaque and translucent regions of respective graphic images.\n\nThis system provides rapid pixel restoration by buffering data corresponding to a portion of a graphic image which is beneath another graphic image. If the overlapping image is moved, the data in this buffer associated with the next lowest layer (in the Z-axis) are available for immediate display.\n\nthe method in which the contents of the buffers are displayed is a front-to-back algorithm.\n\na region is used herein to refer to an arbitrary area of the display.\n\na region is not considered a complex area. Rather, it is a combination of rectangles.\n\na region is a very complex area of the display. Therefore, using a front-to-back algorithm with sprites that include portions having transparency requires a sophisticated region format.\n\nthe native region format that is available from the operating system (OS) is not that sophisticated and cannot efficiently represent complex regions.\n\nOS operating system\n\nPerforming various operations with sprites that include portions having transparency on those platforms is central processing unit (CPU) intensive and, therefore, expensive.\n\nthe invention provides a sprite engine or compositor that is well-adapted for a variety of host platforms. adaptable to the host platform.\n\nthe invention minimizes the amount of drawing that occurs on a refresh of a display area. This is achieved by efficiently using the host platform's graphic capabilitiesabilities and combining both back-to-front and front-to-back drawing algorithms.\n\nAn application registers each sprite and its characteristics with the sprite engine when the sprite is createdAn application creates a sprite knowing whether it has opaque or transparent properties. Each sprite identifies its characteristics and registers itself with the sprite engine. The characteristics of a sprite include such factors as whether or not the sprite contains transparent areasis transparent, itsthe position, bounding area, and Z-orderz-order of the sprite. The application is responsible for notifying the sprite engine of any subsequent alterations in these characteristics.\n\nSprites that are rectangular and opaque are considered special cases that can be easily drawn using the front-to-back drawing algorithm.\n\nthe native region formats are not efficientsophisticated enough onin many host platforms to efficiently support front-to-back drawing where there are overlapping sprites that exhibit arbitrarily complex areas ofy transparency.\n\nthe algorithm reverts to back-to-front drawing.\n\nthe sprite engine keeps track of the Z position of each sprite. Whenever a region needs to be refreshed, the sprite engine examines each sprite to determine if the sprite overlaps that region. The drawing occurs in two passes:\n\nthe first pass occurs in a front-to-backtop-down manner, by Z position. Only wholly opaque sprites sprites that are not overlapped by any transparent sprites may be drawn in this pass. As each sprite is considered, the algorithm keeps track of that portion of the display that remains to be drawn and which is not obscured by other wholly opaque sprites, R unobscured . Additionally, the algorithm retains a region for every sprite that represents the unobscured area of that sprite, R i . All drawing is limited to the area represented by R i , whether a sprite is drawn in the first or second pass.\n\nthe algorithm keeps track of three regions--the total area to be drawn (R1), the area not yet drawn to with sprites in this pass (R2) and the area covered by transparent sprites (R3).\n\nR1 the area not yet drawn to with sprites in this pass\n\nR3 the area covered by transparent sprites\n\nR2 is the same as R1 and R3 is empty. If a sprite encountered in the top-down pass is transparent and its bounding rectangle overlaps the area R2, its bounding rectangle is added to R3. Note that, since it is transparent, it is not drawn in this pass. If a sprite is opaque and its bounding box overlaps the area R2, it may be drawn in this pass only if it is not overlapped by a transparent sprite, i.e. if its bounding box does not intersect the region R3.\n\nthe second pass traverses the sprites in a back-to-front manner, by Z positionoccurs in a bottom-up manner.\n\nTransparent sprites are drawn in this pass, as are opaque sprites that were not drawn in the top-down pass since they were overlapped by transparent sprites.\n\nthis pass no Only sprites that contain transparent areas are drawn in this pass. Drawing is limited to the region, R i , computed for each sprite in the first pass. No region maintenance need happen since we are using the painter's algorithm.\n\nthis algorithm combines both front-to-backtop-down and back-to-frontbottom-up drawing to minimize drawing for opaque areas of a display, while still maintaining the simplicity of the painter's algorithm for areas of the display that include sprites with transparent areastransparent sprites.\n\nFIG. 1 is a block schematic diagram of a display subsystem\n\nFIG. 2 is a block diagram of an area on a display that includes rectangular opaque sprites according to the invention\n\nFIG. 3 is a block diagram showing three sprites on a display according to the invention.\n\nFIG. 4 is a block diagram showing an image on a display, where the image is composited using a back-to-front algorithm according to the invention\n\nFIG. 5 is a block diagram showing three sprites, as shown in FIG. 4, where the image is composited using front-to-back area subtraction according to the invention\n\nFIG. 6 is a block schematic diagram showing sprite registration with a sprite engine according to the invention.\n\nFIG. 7 is a block schematic diagram showing game system registration of sprite bitmapbit maps with a sprite engine according to the invention.\n\nFIG. 8 is a block schematic diagram showing a sprite and an engine interface for a display subsystem according to the invention.\n\nFIG. 9 is a flow diagram showing operation of a preferred embodiment of the invention.\n\nFIG. 10 is a flow diagram showing a front-to-back drawing phase of a preferred embodiment of the invention.\n\nFIG. 11 is a flow diagram showing a back-to-front drawing phase of a preferred embodiment of the invention.\n\nAn operating system (OS) or host platform 101 contains a graphics subsystem 102.\n\nthe graphics subsystem 102 fills a frame buffer 103 with display information.\n\nthe display information is taken out of the frame buffer 103 by a display controller 104 and displayed on the display or monitor 105 by the display controller 104.\n\nRegions are arbitrarily defined in the display area by a game or windowing system. On Microsoft Windows and X-Windows, regions are not sophisticated and are essentially stored as a list of rectangles.\n\nFIG. 2 in a front-to-back drawing with rectangular opaque sprites, an area is selected to be redrawn. That area is represented as a region 201. This is a very simple region consisting of a single rectangle. A sprite 202 is drawn into the region. The sprite area is subtracted from the original drawing region. There are many ways that the region may be divided into rectangles. Thus, those areas of the region 201 that remain after the sprite 202 is drawn are divided into rectangles. The region is represented as a list of rectangles 203, 204, 205, and 206.\n\nAnother way of representing the region is to use a single bitmapbit map, where each pixel is a separate bit. This type of representation can beis expensive memory-wise when compared to the use of rectangles where the region can be represented simply, with rectangles, as in this caseas four rectangles.\n\nregions are represented as lists of rectangles and not as bitmapspixels. It is therefore more efficient to use rectangle listss to manipulatewhenever regions when they can be represented with short listspossible. If rectangles are used for front-to-back drawing, then a bit map is only necessary with the back-to-front drawing.\n\none constraint is the representation provided by the native operating system. This is one reason why the hybrid system disclosed herein is beneficialnecessary.\n\nthe invention is designed to adapt a sophisticated sprite technique to the constraints of the operating system, particularly Microsoft Windows and X-Windows.\n\nthe decision of when to use a front-to-back algorithm or a back-to-front algorithm for a given sprite in a given drawing pass is made on- the- fly by the sprite engine.\n\na particular sprite is drawn at mostonly drawn once, in one of these two passes. If, for example, it is known that part of a sprite is drawn such that it is obscured by another sprite that has transparency and thus part of it would be drawn back-to-front, the sprite engine avoids having to draw only part of it back-to-front. It draws the entire sprite back-to-front, which is more efficient.\n\nFIG. 3 With regard to FIG. 3, three sprites 301, 302, and 303 are shown. Sprite 303 is at the topmost Z level, with sprite 302 at the next level, and sprite 301 at the lowest level.\n\na painter's algorithm draws the lowest layer first, then each subsequent layer, one on top of the other.\n\nFIG. 4 shows the resultant image 401 after sprite 301 is drawn first, then sprite 302, and finally sprite 303.\n\nthe painter's algorithm requires more drawing because exposed portions of sprites are always drawn, even though they are overlapped by another sprite.\n\nFIG. 5 shows each of the sprites with the higher level sprite opaque areas subtracted from its image.\n\nSprite 503 is intact because it is at the highest Z level.\n\nSprite 502 has sprite 503's overlapping opaque area subtracted from it.\n\nsprite 501 has both sprite 502 and 503's opaque areas subtracted from it because it is at the lowest Z level and is overlapped by both of the other sprites.\n\nthe resultant image is identical to the image 401 depicted in FIG. 4.\n\nthe front-to-back algorithm requires less drawingis more efficient than the back-to-front algorithm because it does not unnecessarily draw obscuredunnecessary portions of sprites.\n\nsprites 601 are registered with the sprite engine or compositor 602 and are essentially put in a list 603 maintained by the sprite engine or compositor 602.\n\nthe list 603 is effectively in Z order in front-to-back or back-to-front sortingorder. Additionally, for each sprite there is an indication of whether or not it has transparent areasis transparent, the bounding rectanglebox of the sprite, and a reference to the function responsible for drawing the spritethe drawing function.\n\nan application When an application creates a sprite, it provides a bounding rectangle which encompasses any portions of the sprite that are non-transparent, i.e. the bounding rectangle must enclose the visible portions of the sprite.\n\nthe application is responsible for notifying the sprite engine of any changes in a sprite's bounding rectangle as the sprite's shape or size change.\n\nthe sprite engine uses the bounding rectangle information to optimize its operation. When the sprite engine is instructed to draw a particular area of the display and a sprite's bounding rectangle does not fall in that area of the display, the sprite engine will not invoke the sprite's drawing function for that particular case.\n\nthe sprite engine is not necessarily concerned with what is inside a sprite. It only knows that something needs to be drawn, and that it is either entirely opaque or it is potentially partially transparent. It also knows that the sprite cannot be larger than a certain size. When an application creates a sprite it must tell the sprite engine that the sprite is never bigger than a certain size. The sprite engine uses that information to optimize its operation. When the sprite engine is instructed to draw a particular area of the display and a sprite does not fall in that area of the display, the sprite engine never tells that sprite to draw for that particular case.\n\nwindowing systems support subwindows, that is, within one window there may be multiple subwindows.\n\nSome windowing systems also provide a root window, where the entire display is taken up by the root window in which subwindows provide applications windows.\n\nthe application windows may have their own subwindows, which may be different documents within the application.\n\nwindows also have the notion of Z order, in addition to the subwindow concept.\n\nMost windowing systems place subwindows in Z order in front of the parent window, such that the parent window and all of its subwindows are a single unit that can be at some position with respect to the siblings of the parent window. The registration between the parent and the children remains constant, even though the parent may be moved. Therefore, one skilled in the art can readily appreciate that these techniques can be applied to windowing systems as well as to sprite engines. Windows and subwindows are drawn in the order of their Z position using a front-to-back or back-to-front algorithm, in the same manner as sprites.\n\nbit maps 701 that correspond to the sprites. It then takes the bit maps and registers them as sprites with the sprite engine 702.\n\na sprite is drawn using a single static bitmap that does not change its bounding rectangle or opacity over time.the concept of a display is a single bit map that is static, and, as it is drawn, it does not change along with its transparent areas.\n\nthe invention is intended for application to any system element that can draw.\n\na sprite registers, it does not register a bit map to be drawn. Rather, it registers a function to be called when a draw needs to occur. That function can draw whatever it wants. For example, a function might draw a different bit of text every time it is told to draw, which means that the transparency is not something that stays true across every draw. In other words, a sprite is an object, and it has a draw method.\n\nthe invention is intended for application to any system element that can be drawn.\n\nthe sprite engine possesses no specific information regarding the appearance of the sprite other than its bounding rectangle and whether or not the sprite is wholly opaque within the bounding rectangle.\n\na game system might provide a function which draws a static bitmap.\n\na drawing function might display a different text string every time it is invoked, which means that the opaque areas of the sprite need not remain the same across every draw. (However, the application is responsible for keeping the sprite engine informed of changes in an objects opacity.)\n\na sprite is an object, and it has a draw method.\n\na window In the context of a windowing system, a window is something that an application creates and that application has control of the drawing withinits own concept of what to draw into that window. Therefore, it is similar to a sprite because a window has its own drawing function in the same manner as sprites have their own draw method.\n\nsprites 801 are registered with the sprite engine or compositor 802.\n\nthe sprite engine 802 determines where and when the sprites 801 draw and the sprites 801 draw using the graphics subsystem 803.\n\nthe graphics subsystem 803 is a component of the OS or host platform 804.\n\nthe graphic subsystem 803 draws into the frame buffer 805.\n\nthe frame buffer 805 is the area of video memory that corresponds to what is displayed on the monitor 807.\n\nthe sprite engine 802 also uses the graphics subsystem 803 for its drawing.\n\nthe sprite engine 802 may be combined with the graphic subsystem 803 to form a single subsystem.\n\nthe sprite engine's determination of the order in which spriteswhen the sprites should draw is based on either the back-to-front or the front-to-back approach.\n\nthe sprite engine instructs a sprite, e.g. Sprite 12, to draw and Sprite 12 then uses the graphics subsystem to draw.\n\nthe sprite engine then instructs Sprite 21 to draw, and Sprite 21 does the same.\n\nthe main function of the sprite engine is to maintain a list of the ordering of the sprites and to tell the sprites when and in what order to draw.\n\nan application creates uses a mechanism to create a sprite, it registers the sprite with the sprite engine. As long as the sprite remains active, the application is responsible for keeping the sprite engine informed of its current characteristics: It informs the sprite engine what sprite number it is, its bounding rectanglebox, drawing function, and the presence or absence of transparent areas within the bounding rectangleif it is transparent or opaque.\n\nthe sprite engine internally maintains its list of sprites as a linear list or a doubly-linked list. The list is maintained in Z order, so the sprite engine can identify, for example, the topmost sprite in Z order and the bottom most sprite in Z order.\n\nthe sprite engine When the sprite engine is told to redraw areas of the display, it decides which sprites need to draw, or which sprites overlap the area that needs to be redrawn. It then decides on a per-sprite basis whether it should draw the sprites in the front-to-back pass or wait until the back-to-front pass to actually draw them.\n\nFIG. 9 is a flow diagram showing operation of a preferred embodiment of the invention.\n\na front-to-back drawing phase 910 is first commenced.\n\na back-to-front drawing phase 920 is entered.\n\nthe process ends 930.\n\nFIG. 10 is a flow diagram showing a front-to-back drawing phase of a preferred embodiment of the invention.\n\nthe sprite engine starts 1001 with the region to be drawndraw area parameters which are passed to it by a calling routine.\n\nthe sprite engine contains a list of all the sprites that have been registered with the sprite engine.\n\nEach sprite is registered with the sprite engine by the application that created the sprite.\n\nthe creating application passes the sprite engine the sprite's Z order, bounding rectanglebox parameters, whether or not the sprite containsis transparent areas, and the drawing routine for the sprite.\n\nthe sprite engine records all of the information in the list. The list is organized in an increasing or decreasing order of each sprite's Z position.\n\nthe sprite engine keeps track of the Z position of each sprite. Whenever a region needs to be refreshed, the sprite engine examines each sprite to determine if the sprite overlaps that region. The drawing occurs in two passes:\n\nthe first pass occurs in a top-down manner, by Z position. Only opaque sprites that are not overlapped by any transparent sprites may be drawn in this pass. In this pass, the algorithm keeps track of three regions--the total area to be drawn (R1), the area not yet drawn to by sprites in this pass (R2) and the area covered by transparent sprites (R3).\n\nR1 the area not yet drawn to by sprites in this pass\n\nR3 the area covered by transparent sprites\n\nR2 is the same as R1 and R3 is empty. If a sprite encountered in the top-down pass is transparent and its bounding rectangle overlaps the area R2, its bounding rectangle is added to R3. Note that, since it is transparent, it is not drawn in this pass. If a sprite is opaque and its bounding box overlaps the area R2, it may be drawn in this pass only if it is not overlapped by a transparent sprite, i.e. if its bounding box does not intersect the region\n\nthe sprite engine instructs the sprite to draw that portion of the sprite that overlaps the remaining area to be drawn 1009.\n\nthe sprite uses its registeredwhatever drawing routine that it requires to draw the portion of the sprite covered by its drawing area, R i , intoonto the draw area in the frame buffer.\n\nAn optimization is provided that tests to determine if the entire area to be drawn is covered (R unobscured (0) 1011. If the entire area to be drawn is already covered, then there is no need to continue examining the sprites and this phase of the process is complete 1013. Otherwise, the front-to-back search continues until the last sprite is reached 1012 and the task is completed 1013, or when the front-to-back search finds a sprite that overlaps the draw area but has transparent properties 1011.\n\nthe sprite is marked for drawing in the second, back-to-front drawing pass 1015.\n\nthe sprite's unobscured area, R i calculated in the front-to-back pass, is preserved for use in that back-to-front drawing operation.Thus, if the sprite intersects with region R3, the sprite engine records that the sprite has to be drawn in the back-to-front search rather than in the front-to-back search. Because that sprite has to be drawn back-to-front, other sprites behind that sprite need to be drawn back-to-front.\n\nthe second pass is begun 1100 (see FIG. 11).\n\nthe second pass occurs in a back-to-frontbottom-up manner.\n\nTransparent sprites are drawn in this pass, as are opaque sprites that were not drawn in the front-to-backtop-down pass because they were overlapped by transparent sprites.\n\nthis pass no region maintenance need happen because the system is using the painter's algorithm.\n\nthis algorithm combines both front-to-backtop-down and back-to-frontbottom-up drawing to minimize drawing for opaque areas of a display, while still maintaining the simplicity of the painter's algorithm for areas of the display that include transparent sprites.\n\nFIG. 11 is a flow diagram showing a back-to-front drawing phase of a preferred embodiment of the invention.\n\nthe sprite engine searches the list in back-to-front order 1101. When a sprite is found that overlaps the draw area and the sprite was marked for drawing back-to-front during the first pass 1102, the sprite engine draws the sprite onto the draw area in the frame buffer by calling the draw routine that was registered with the sprite, using the sprite's draw region, R i computed in the first pass 1103. Each remaining sprite is treated in the same manner until each transparent sprite that was previously marked is drawn 1104. If the last sprite has been processed, then the draw area has been completed and the sprite engine's task is completed 1105.\n\nthe sprite engine walks down the list, going from the top to the very bottom sprite, and for each sprite it keeps track of a particular arbitrary region as well as an overall region. Then it walks backwards, going from the bottom most sprite up to the topmost sprite, taking into account those particular regions that tells it which parts of the sprite need to be drawn and which do not.\n\nthe sprite engine walks down the list in Z order, going from the top to the very bottom sprite, and for each sprite it computes a region containing that portion of the sprite not obscured by opaque sprites above. The visible parts of any wholly sprites that are wholly opaque are drawn in this pass. Then the sprite engine walks backwards, going from the bottom most sprite up to the topmost sprite, taking into account those regions constructed in the first pass that tell it which parts of each sprite need to be drawn and which do not. It takes the sprites that it did not draw in the front-to-back phase and draws them in the back-to-front phase.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nPhysics & Mathematics (AREA)\n\nGeneral Physics & Mathematics (AREA)\n\nTheoretical Computer Science (AREA)\n\nComputer Hardware Design (AREA)\n\nGeometry (AREA)\n\nComputer Graphics (AREA)\n\nControls And Circuits For Display Device (AREA)\n\nAbstract\n\nA sprite engine or compositor that is well-adapted to a variety ofadaptable to a host platforms and that minimizes the amount of drawing that occurs on a refresh of a framebuffer display area. The invention exploits the host platform's abilities to perform both back-to-front and front-to-back drawing algorithms, where the choice of algorithm used depends upon whether a sprite is opaque or transparent. Each sprite registers itself with a sprite engine, identifying whether or not the sprite is wholly opaque or notis transparent, the bounding area of the sprite, and the function that the sprite uses to draw. The function can be the drawing routine that is available from the host platform or operating system. The sprite engine keeps track of the Z position of each sprite and examines each sprite to determine if the sprite overlaps a particular region that needs to be refreshed. Sprites that are rectangular and opaque are considered special cases that can be easily drawn using athe host platform's front-to-back drawing algorithm. In a top-down manner, by Z position, all sprites that are opaque are allowed to draw. All other kinds of sprites are drawn in a back-to-front manner. When a transparent sprite is found, the sprite engine searches the remaining sprites in a bottom-up manner and draws the sprites with a Z position below the transparent sprite, finishing with the transparent sprite, using a back-to-front algorithm in the remaining region.\n\nDescription\n\nTECHNICAL FIELD\n\n1. Background of the Invention\n\nThe invention relates to the generation and display of an image that includes multiple planes of information. More particularly, the invention relates to displaying a plurality of opaque and/or transparent graphical entities, where each entity has a specific X and Y position and Z order relative to the other entities in the composite image.\n\n2. Description of the Prior Art\n\nComputer-controlled game devices and personal computers use a similar approach for generating graphical images. On game devices these graphical images are generated using an animation engine, while on personal computers they are generated using a windowing system. The overall image that is displayed consists of opaque or partially transparent entities that can be drawn onto the computer screen. Each such entity has a X and Y position on the display, a width and height which indicate its maximum dimensions, as well as a depth indicator, its Z position. When two such graphical entities overlap, there is a definite order so that one is above the other and each entity has a relative Z position in relation to all of the other entities which is the same at each location on the display.\n\nOn game systems, these graphical entities are called \"sprites.\" Often, A common example of a sprite simply consists ofis a bitmapped image. A \"sprite engine\" is used in framebuffer-oriented game systems to control where and in what order sprites are drawn on a display. It is the responsibility of the sprite engine to calculate the minimal area of the display to be redrawn as characteristics of sprites (such as their position) change. Consider the case where two sprites move from initial positions p1 and p2 respectively to final positions p3 and p4. It is evident that there are four parts of the display that need to be redrawn--the original positions of the sprites because they need to be erased, and the new positions of the sprites, in that order. If p1, p2, p3 and p4 are distinct, non-overlapping positions, each pixel needs to be area can be drawn exactly once. However, if any two or more of these positions are overlapping, the amount of drawing can be minimized by not drawing the overlapping pixels multiple times.\n\nIn the case of opaque, rectangular sprites, the calculation of the overlapping regions is relatively easy--the regions are calculated as a result of simple union and intersection operations of the rectangular boundaries of the sprites. However, a sprite can also have transparent areas of arbitrary complexitybe of arbitrary transparency, e.g. text. The areas surrounding the pixels that constitute a text character can be transparent to allow another sprite behind it, for example, an image, to show through. In the case of these partially opaquetransparent sprites, the calculation of the overlapping regions between sprites may beis significantly more expensive computationally because the opaque regions do not have simple rectangular boundaries.\n\nOn personal computers, screen images are often generated using a windowing system. Windowing systems are similar in many ways to sprite engines, although each has different motivations and performance requirementsdifferent needs for performance. Windowing systems have windows that correspond to different applications; each application may have multiple windows. As with sprites, windows have a Z dimension, which is used to determine a total ordering of depth between all windows in a windowing system. In general, windows are rectangular. When drawing windows, the same issues as with sprites must be taken into account. Thus, that portion of every window that needs to be redrawna window to be displayed must be calculated when an area of the display needs to be refreshed. As with sprite engines, a windowing system endeavors to avoid redrawing any pixel more than once. Since windows are almost always rectangular, this is relatively easy to accomplish efficiently.\n\nMany windowing systems support subwindows, that is, within one window there may be multiple subwindows. Some windowing systems also provide a root window, where the entire display is taken up by the root window in which subwindows provide applications windows. The application windows, in turn, may have their own subwindows, which may be different documents within the application.\n\nThe windowing system must calculate the minimal set of windows it must draw to complete a refresh in the same manner as the sprite engine. Windows also include a Z order dimension, in addition to the subwindow concept. Most windowing systems place subwindows in Z order in front of the parent window, such that the parent window and all of its subwindows are a single unit that can be at some position with respect to the siblings of the parent window. In summary, there is a total ordering of depth between all windows in a windowing system.\n\nThere are generally two methods of compositing or building up what needs to be drawn on the display, i.e. back-to-front and front-to-back. Back-to-front drawing is sometimes referred to as thea painter's algorithm. That is, a painting is made using multiple layers and, in the same manner, a painter's algorithm draws the lowest layer first, then each subsequent layer, one on top of the other. The painter's algorithm may cause excessiverequires more drawing because portions of sprites are always drawn even though they may be overlapped by another sprite. Determining the minimal subset of pixels to draw for each sprite can be a computationallymathematically intensive operation and one way to minimize that is using the painter's algorithm because no calculations are necessary to determine overlapinvolved when all sprites areeverything is drawn onto the display.\n\nU.S. Pat. No. 5,546,518 issued to Blossom et al. on Aug. 13, 1996, discloses a back-to-front, pixel-based system that uses a data processing device to write pixel values of individual sprites to a display composition buffer. Writing begins with the sprite having the greatest depth and proceeds with the remaining sprites in order of decreasing sprite depth. In addition, a video overlay board is included to overlay a video image over certain pixels containing a chroma-key value.\n\nIn the front-to-back algorithm, the topmost layer is drawn first. After the topmost layer is drawn, that portion of it that is opaqueits area is subtracted from the area that will be drawn by any sprite below this one. Then the next layer down is drawn, except for pixels outside the aforementioned drawing area that needs to be redrawn. The next layer is drawn and its area is subtracted from the remaining area to be redrawn. Its opaque pixels are subtracted from the drawing area. Each subsequent layer is drawn in the same manner. The front-to-back algorithm may perform less drawingis more efficient than the back-to-front algorithm because it does not draw portions of sprites that are not visible when they are obscured by other spritesnot displayed.\n\nIn a front-to-back implementation, if a sprite consists of text with transparent areas surrounding the text, the text is drawn first. The area of the pixels that make up the text is then subtracted from the next underlying sprite to be drawn. The remaining part of that sprite is then drawn.\n\nThe ability to create and manipulate a \"region\" is necessary when implementing a front-to-back algorithm. A region is used herein to refer to an arbitrary set of pixels on the display. With regard to opaque rectangular sprites, for example, a region is typically not a complex area. Rather, it is a combination of rectangles. However, in the case of transparent text, a region can be very complex. Therefore, efficiently implementing a front-to-back algorithm with sprites that include portions having transparency requires a sophisticated region format. On most of the popular platforms (e.g. Microsoft Windows and X-Windows), the native region format that is available from the operating system (OS) is not that sophisticated and cannot efficiently represent or efficiently operate on complex regions. Performing geometric operations such as intersection, union or subtraction with complex regions on those platforms is both central processing unit (CPU) intensive and memory-intensive and is, therefore, expensive.\n\nAlthough the front-to-back approach may perform less drawing, the algorithm requires that a record be maintained of the portion of the composited image that remains to be drawn as each layer is handled. The algorithm does require a record of the portion of the composited image that must be redrawn at every layer. The opaque area of each layer that is drawn is must be subtracted from thisthe remaining area. This is a computationally tractablestraightforward approach when the sprites are opaque rectangles, but whenever any portion of a sprite is transparent, the calculations required become time-consumingcomplex.\n\nIf a sprite contains text with transparent areas surrounding the text, the text is drawn first. The area of the text is then subtracted from the next underlying sprite to be drawn. The remaining part of that sprite is then drawn. The operation of determining which pixel the text picks up and then subtracting that pixel from the next underlying sprite is mathematically expensive.\n\nU.S. Pat. No. 5,216,413 issued to Seiler et al. on Jun. 1, 1993, discloses a system that defines windows as a priority-ordered list of rectangles. For a given pixel to be drawn, the highest priority rectangle containing the pixel is found. This rectangle is the only rectangle drawn. This is a front-to-back system.\n\nU.S. Pat. No. 5,487,145 issued to Marsh et al. on Jan. 23, 1996, discloses a compositing architecture for correct rendering of overlapping opaque and translucent regions of respective graphic images. This system provides rapid pixel restoration by buffering data corresponding to a portion of a graphic image which is beneath another graphic image. If the overlapping image is moved, the data in this buffer associated with the next lowest layer (in the Z-axis) are available for immediate display. The method in which the contents of the buffers are displayed is a front-to-back algorithm.\n\nThe concept of a region is maintained when using a front-to-back algorithm. A region is used herein to refer to an arbitrary area of the display. With regard to opaque rectangular sprites, for example, a region is not considered a complex area. Rather, it is a combination of rectangles. However, in the case of transparent text, a region is a very complex area of the display. Therefore, using a front-to-back algorithm with sprites that include portions having transparency requires a sophisticated region format. On most of the popular platforms (e.g. Microsoft Windows and X-Windows), the native region format that is available from the operating system (OS) is not that sophisticated and cannot efficiently represent complex regions. Performing various operations with sprites that include portions having transparency on those platforms is central processing unit (CPU) intensive and, therefore, expensive.\n\nIt would be advantageous to provide a sprite engine that balances the simplicity of the back-to-front algorithm and the efficiency of the front-to-back algorithm. It would further be advantageous to provide a sprite engine that performs display region refreshes while minimizing the redrawing of unnecessary portions of underlying sprites.\n\nSUMMARY OF THE INVENTION\n\nThe invention provides a sprite engine or compositor that is well-adapted for a variety of host platforms. adaptable to the host platform. The invention minimizes the amount of drawing that occurs on a refresh of a display area. This is achieved by efficiently using the host platform's graphic capabilitiesabilities and combining both back-to-front and front-to-back drawing algorithms.\n\nAn application registers each sprite and its characteristics with the sprite engine when the sprite is createdAn application creates a sprite knowing whether it has opaque or transparent properties. Each sprite identifies its characteristics and registers itself with the sprite engine. The characteristics of a sprite include such factors as whether or not the sprite contains transparent areasis transparent, itsthe position, bounding area, and Z-orderz-order of the sprite. The application is responsible for notifying the sprite engine of any subsequent alterations in these characteristics.\n\nSprites that are rectangular and opaque are considered special cases that can be easily drawn using the front-to-back drawing algorithm. However, the native region formats are not efficientsophisticated enough onin many host platforms to efficiently support front-to-back drawing where there are overlapping sprites that exhibit arbitrarily complex areas ofy transparency. To draw other kinds oftransparent sprites, the algorithm reverts to back-to-front drawing.\n\nThe sprite engine keeps track of the Z position of each sprite. Whenever a region needs to be refreshed, the sprite engine examines each sprite to determine if the sprite overlaps that region. The drawing occurs in two passes:\n\nThe first pass occurs in a front-to-backtop-down manner, by Z position. Only wholly opaque sprites sprites that are not overlapped by any transparent sprites may be drawn in this pass. As each sprite is considered, the algorithm keeps track of that portion of the display that remains to be drawn and which is not obscured by other wholly opaque sprites, Runobscured. Additionally, the algorithm retains a region for every sprite that represents the unobscured area of that sprite, Ri. All drawing is limited to the area represented by Ri, whether a sprite is drawn in the first or second pass. In this pass, the algorithm keeps track of three regions--the total area to be drawn (R1), the area not yet drawn to with sprites in this pass (R2) and the area covered by transparent sprites (R3). At the beginning of the top-down pass, R2 is the same as R1 and R3 is empty. If a sprite encountered in the top-down pass is transparent and its bounding rectangle overlaps the area R2, its bounding rectangle is added to R3. Note that, since it is transparent, it is not drawn in this pass. If a sprite is opaque and its bounding box overlaps the area R2, it may be drawn in this pass only if it is not overlapped by a transparent sprite, i.e. if its bounding box does not intersect the region R3.\n\nThe second pass traverses the sprites in a back-to-front manner, by Z positionoccurs in a bottom-up manner. Transparent sprites are drawn in this pass, as are opaque sprites that were not drawn in the top-down pass since they were overlapped by transparent sprites. In this pass, no Only sprites that contain transparent areas are drawn in this pass. Drawing is limited to the region, Ri, computed for each sprite in the first pass. No region maintenance need happen since we are using the painter's algorithm. Thus, this algorithm combines both front-to-backtop-down and back-to-frontbottom-up drawing to minimize drawing for opaque areas of a display, while still maintaining the simplicity of the painter's algorithm for areas of the display that include sprites with transparent areastransparent sprites.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nFIG. 1 is a block schematic diagram of a display subsystem;\n\nFIG. 2 is a block diagram of an area on a display that includes rectangular opaque sprites according to the invention;\n\nFIG. 3 is a block diagram showing three sprites on a display according to the invention;\n\nFIG. 4 is a block diagram showing an image on a display, where the image is composited using a back-to-front algorithm according to the invention;\n\nFIG. 5 is a block diagram showing three sprites, as shown in FIG. 4, where the image is composited using front-to-back area subtraction according to the invention;\n\nFIG. 6 is a block schematic diagram showing sprite registration with a sprite engine according to the invention;\n\nFIG. 7 is a block schematic diagram showing game system registration of sprite bitmapbit maps with a sprite engine according to the invention;\n\nFIG. 8 is a block schematic diagram showing a sprite and an engine interface for a display subsystem according to the invention;\n\nFIG. 9 is a flow diagram showing operation of a preferred embodiment of the invention;\n\nFIG. 10 is a flow diagram showing a front-to-back drawing phase of a preferred embodiment of the invention; and\n\nFIG. 11 is a flow diagram showing a back-to-front drawing phase of a preferred embodiment of the invention.\n\nDETAILED DESCRIPTION OF THE INVENTION\n\nReferring to FIG. 1, it can be seen that typical game and windowing systems have similar display subsystems. An operating system (OS) or host platform 101 contains a graphics subsystem 102. The graphics subsystem 102 fills a frame buffer 103 with display information. The display information is taken out of the frame buffer 103 by a display controller 104 and displayed on the display or monitor 105 by the display controller 104.\n\nRegions are arbitrarily defined in the display area by a game or windowing system. On Microsoft Windows and X-Windows, regions are not sophisticated and are essentially stored as a list of rectangles. With regard to FIG. 2, in a front-to-back drawing with rectangular opaque sprites, an area is selected to be redrawn. That area is represented as a region 201. This is a very simple region consisting of a single rectangle. A sprite 202 is drawn into the region. The sprite area is subtracted from the original drawing region. There are many ways that the region may be divided into rectangles. Thus, those areas of the region 201 that remain after the sprite 202 is drawn are divided into rectangles. The region is represented as a list of rectangles 203, 204, 205, and 206.\n\nAnother way of representing the region is to use a single bitmapbit map, where each pixel is a separate bit. This type of representation can beis expensive memory-wise when compared to the use of rectangles where the region can be represented simply, with rectangles, as in this caseas four rectangles.\n\nAs previously mentioned, on Microsoft Windows and X-Windows, regions are represented as lists of rectangles and not as bitmapspixels. It is therefore more efficient to use rectangle listss to manipulatewhenever regions when they can be represented with short listspossible. If rectangles are used for front-to-back drawing, then a bit map is only necessary with the back-to-front drawing. In the case of Microsoft Windows and X-Windows, one constraint is the representation provided by the native operating system. This is one reason why the hybrid system disclosed herein is beneficialnecessary. Thus, the invention is designed to adapt a sophisticated sprite technique to the constraints of the operating system, particularly Microsoft Windows and X-Windows.\n\nThe decision of when to use a front-to-back algorithm or a back-to-front algorithm for a given sprite in a given drawing pass is made on- the- fly by the sprite engine. A particular sprite is drawn at mostonly drawn once, in one of these two passes. If, for example, it is known that part of a sprite is drawn such that it is obscured by another sprite that has transparency and thus part of it would be drawn back-to-front, the sprite engine avoids having to draw only part of it back-to-front. It draws the entire sprite back-to-front, which is more efficient.\n\nWith regard to FIG. 3, three sprites 301, 302, and 303 are shown. Sprite 303 is at the topmost Z level, with sprite 302 at the next level, and sprite 301 at the lowest level. A painter's algorithm draws the lowest layer first, then each subsequent layer, one on top of the other. FIG. 4 shows the resultant image 401 after sprite 301 is drawn first, then sprite 302, and finally sprite 303. The painter's algorithm requires more drawing because exposed portions of sprites are always drawn, even though they are overlapped by another sprite.\n\nIn the front-to-back algorithm, the topmost layer is drawn first. After the topmost layer is drawn, then its opaque area is subtracted from the total area that needs to be redrawn. The next layer is drawn and its opaque area subtracted from the remaining area to be redrawn. Each subsequent layer is drawn in the same manner. FIG. 5 shows each of the sprites with the higher level sprite opaque areas subtracted from its image. Sprite 503 is intact because it is at the highest Z level. Sprite 502 has sprite 503's overlapping opaque area subtracted from it. Finally, sprite 501 has both sprite 502 and 503's opaque areas subtracted from it because it is at the lowest Z level and is overlapped by both of the other sprites. The resultant image is identical to the image 401 depicted in FIG. 4. The front-to-back algorithm requires less drawingis more efficient than the back-to-front algorithm because it does not unnecessarily draw obscuredunnecessary portions of sprites.\n\nReferring to FIG. 6, sprites 601 are registered with the sprite engine or compositor 602 and are essentially put in a list 603 maintained by the sprite engine or compositor 602. The list 603 is effectively in Z order in front-to-back or back-to-front sortingorder. Additionally, for each sprite there is an indication of whether or not it has transparent areasis transparent, the bounding rectanglebox of the sprite, and a reference to the function responsible for drawing the spritethe drawing function.\n\nWhen an application creates a sprite, it provides a bounding rectangle which encompasses any portions of the sprite that are non-transparent, i.e. the bounding rectangle must enclose the visible portions of the sprite. The application is responsible for notifying the sprite engine of any changes in a sprite's bounding rectangle as the sprite's shape or size change. The sprite engine uses the bounding rectangle information to optimize its operation. When the sprite engine is instructed to draw a particular area of the display and a sprite's bounding rectangle does not fall in that area of the display, the sprite engine will not invoke the sprite's drawing function for that particular case. It is therefore advantageous for the application to specify the minimum possible bounding rectangle for a sprite.The sprite engine is not necessarily concerned with what is inside a sprite. It only knows that something needs to be drawn, and that it is either entirely opaque or it is potentially partially transparent. It also knows that the sprite cannot be larger than a certain size. When an application creates a sprite it must tell the sprite engine that the sprite is never bigger than a certain size. The sprite engine uses that information to optimize its operation. When the sprite engine is instructed to draw a particular area of the display and a sprite does not fall in that area of the display, the sprite engine never tells that sprite to draw for that particular case.\n\nMany windowing systems support subwindows, that is, within one window there may be multiple subwindows. Some windowing systems also provide a root window, where the entire display is taken up by the root window in which subwindows provide applications windows. The application windows, in turn, may have their own subwindows, which may be different documents within the application.\n\nAs previously mentioned, windows also have the notion of Z order, in addition to the subwindow concept. Most windowing systems place subwindows in Z order in front of the parent window, such that the parent window and all of its subwindows are a single unit that can be at some position with respect to the siblings of the parent window. The registration between the parent and the children remains constant, even though the parent may be moved. Therefore, one skilled in the art can readily appreciate that these techniques can be applied to windowing systems as well as to sprite engines. Windows and subwindows are drawn in the order of their Z position using a front-to-back or back-to-front algorithm, in the same manner as sprites.\n\nReferring to FIG. 7, if a game system uses a typical sprite engine, it first loads bit maps 701 that correspond to the sprites. It then takes the bit maps and registers them as sprites with the sprite engine 702. For many game sprite engines a sprite is drawn using a single static bitmap that does not change its bounding rectangle or opacity over time.the concept of a display is a single bit map that is static, and, as it is drawn, it does not change along with its transparent areas.\n\nThe invention is intended for application to any system element that can draw. When a sprite registers, it does not register a bit map to be drawn. Rather, it registers a function to be called when a draw needs to occur. That function can draw whatever it wants. For example, a function might draw a different bit of text every time it is told to draw, which means that the transparency is not something that stays true across every draw. In other words, a sprite is an object, and it has a draw method.\n\nThe invention is intended for application to any system element that can be drawn. The sprite engine possesses no specific information regarding the appearance of the sprite other than its bounding rectangle and whether or not the sprite is wholly opaque within the bounding rectangle. There is no bitmap registered for each sprite. Rather, when a sprite must be drawn, the sprite engine invokes the sprite's registered drawing function. That function can draw anything within the sprite's bounding rectangle. For example, a game system might provide a function which draws a static bitmap. Alternatively, a drawing function might display a different text string every time it is invoked, which means that the opaque areas of the sprite need not remain the same across every draw. (However, the application is responsible for keeping the sprite engine informed of changes in an objects opacity.) In object-oriented terms, a sprite is an object, and it has a draw method.\n\nIn the context of a windowing system, a window is something that an application creates and that application has control of the drawing withinits own concept of what to draw into that window. Therefore, it is similar to a sprite because a window has its own drawing function in the same manner as sprites have their own draw method.\n\nWith regard to FIG. 8, in a preferred embodiment of the invention, sprites 801 are registered with the sprite engine or compositor 802. The sprite engine 802 determines where and when the sprites 801 draw and the sprites 801 draw using the graphics subsystem 803. The graphics subsystem 803 is a component of the OS or host platform 804. The graphic subsystem 803 draws into the frame buffer 805. The frame buffer 805 is the area of video memory that corresponds to what is displayed on the monitor 807. The sprite engine 802 also uses the graphics subsystem 803 for its drawing. The sprite engine 802 may be combined with the graphic subsystem 803 to form a single subsystem.\n\nThe sprite engine's determination of the order in which spriteswhen the sprites should draw is based on either the back-to-front or the front-to-back approach. In a simple back-to-frontfront-to-back system with rectangular opaque sprites, the sprite engine instructs a sprite, e.g. Sprite 12, to draw and Sprite 12 then uses the graphics subsystem to draw. The sprite engine then instructs Sprite 21 to draw, and Sprite 21 does the same. Once again, the main function of the sprite engine is to maintain a list of the ordering of the sprites and to tell the sprites when and in what order to draw.\n\nWhen an application creates uses a mechanism to create a sprite, it registers the sprite with the sprite engine. As long as the sprite remains active, the application is responsible for keeping the sprite engine informed of its current characteristics: It informs the sprite engine what sprite number it is, its bounding rectanglebox, drawing function, and the presence or absence of transparent areas within the bounding rectangleif it is transparent or opaque. The sprite engine internally maintains its list of sprites as a linear list or a doubly-linked list. The list is maintained in Z order, so the sprite engine can identify, for example, the topmost sprite in Z order and the bottom most sprite in Z order. When the sprite engine is told to redraw areas of the display, it decides which sprites need to draw, or which sprites overlap the area that needs to be redrawn. It then decides on a per-sprite basis whether it should draw the sprites in the front-to-back pass or wait until the back-to-front pass to actually draw them.\n\nFIG. 9 is a flow diagram showing operation of a preferred embodiment of the invention. When the drawing process begins 900 a front-to-back drawing phase 910 is first commenced. Upon completion of this first phase, a back-to-front drawing phase 920 is entered. At the conclusion of the back-to-front drawing phase, the process ends 930.\n\nFIG. 10 is a flow diagram showing a front-to-back drawing phase of a preferred embodiment of the invention. With regard to FIG. 10, the sprite engine starts 1001 with the region to be drawndraw area parameters which are passed to it by a calling routine. The sprite engine is initialized 1002, such that the remaining region to be drawn is not obscured by any other spritesunobscured (Runobscured =Rdraw,) and, all sprites have their drawing area, Ri, initialized to their entire bounding rectangle, and all sprites are unmarked. The sprite engine contains a list of all the sprites that have been registered with the sprite engine. Each sprite is registered with the sprite engine by the application that created the sprite. The creating application passes the sprite engine the sprite's Z order, bounding rectanglebox parameters, whether or not the sprite containsis transparent areas, and the drawing routine for the sprite. The sprite engine records all of the information in the list. The list is organized in an increasing or decreasing order of each sprite's Z position.\n\nThe sprite engine keeps track of the Z position of each sprite. Whenever a region needs to be refreshed, the sprite engine examines each sprite to determine if the sprite overlaps that region. The drawing occurs in two passes:\n\nThe first pass occurs in a top-down manner, by Z position. Only opaque sprites that are not overlapped by any transparent sprites may be drawn in this pass. In this pass, the algorithm keeps track of three regions--the total area to be drawn (R1), the area not yet drawn to by sprites in this pass (R2) and the area covered by transparent sprites (R3). At the beginning of the top-down pass, R2 is the same as R1 and R3 is empty. If a sprite encountered in the top-down pass is transparent and its bounding rectangle overlaps the area R2, its bounding rectangle is added to R3. Note that, since it is transparent, it is not drawn in this pass. If a sprite is opaque and its bounding box overlaps the area R2, it may be drawn in this pass only if it is not overlapped by a transparent sprite, i.e. if its bounding box does not intersect the region R3.\n\nDuring the first pass, the sprite engine initially examines each sprite in the list in front-to-back Z order (i=1 . . . n) 1003 and determines the overlap of the sprite drawing area with the remainingif the sprite overlaps the area to be drawn 1004 (Ri =-Ri (Runobscured). The sprite engine then determines if the sprite is not entirely obscured by opaque sprites above it (Ri (0) 1005. If a sprite does overlap the area to be drawn and is not entirely obscured, the sprite engine checks if the sprite is registered as having transparent or whollyentirely opaque properties 1006. If the sprite is entirely opaque, then the sprite engine instructs the sprite to draw that portion of the sprite that overlaps the remaining area to be drawn 1009. The sprite uses its registeredwhatever drawing routine that it requires to draw the portion of the sprite covered by its drawing area, Ri, intoonto the draw area in the frame buffer. The remaining area to be drawn is updated by subtracting the area of the sprite from its current value (Runobscured =Runobscured -Ri) 1007.\n\nAn optimization is provided that tests to determine if the entire area to be drawn is covered (Runobscured (0) 1011. If the entire area to be drawn is already covered, then there is no need to continue examining the sprites and this phase of the process is complete 1013. Otherwise, the front-to-back search continues until the last sprite is reached 1012 and the task is completed 1013, or when the front-to-back search finds a sprite that overlaps the draw area but has transparent properties 1011.\n\nIf the sprite is not entirely opaque 1006, then the sprite is marked for drawing in the second, back-to-front drawing pass 1015. The sprite's unobscured area, Ri, calculated in the front-to-back pass, is preserved for use in that back-to-front drawing operation.Thus, if the sprite intersects with region R3, the sprite engine records that the sprite has to be drawn in the back-to-front search rather than in the front-to-back search. Because that sprite has to be drawn back-to-front, other sprites behind that sprite need to be drawn back-to-front.\n\nOnce the last sprite has been processed during the first pass 1013, the second pass is begun 1100 (see FIG. 11). The second pass occurs in a back-to-frontbottom-up manner. Transparent sprites are drawn in this pass, as are opaque sprites that were not drawn in the front-to-backtop-down pass because they were overlapped by transparent sprites. In this pass, no region maintenance need happen because the system is using the painter's algorithm. Thus, this algorithm combines both front-to-backtop-down and back-to-frontbottom-up drawing to minimize drawing for opaque areas of a display, while still maintaining the simplicity of the painter's algorithm for areas of the display that include transparent sprites.\n\nFIG. 11 is a flow diagram showing a back-to-front drawing phase of a preferred embodiment of the invention. In the second pass, the sprite engine then searches the list in back-to-front order 1101. When a sprite is found that overlaps the draw area and the sprite was marked for drawing back-to-front during the first pass 1102, the sprite engine draws the sprite onto the draw area in the frame buffer by calling the draw routine that was registered with the sprite, using the sprite's draw region, Ri computed in the first pass 1103. Each remaining sprite is treated in the same manner until each transparent sprite that was previously marked is drawn 1104. If the last sprite has been processed, then the draw area has been completed and the sprite engine's task is completed 1105.\n\nAt a higher level, the sprite engine walks down the list, going from the top to the very bottom sprite, and for each sprite it keeps track of a particular arbitrary region as well as an overall region. Then it walks backwards, going from the bottom most sprite up to the topmost sprite, taking into account those particular regions that tells it which parts of the sprite need to be drawn and which do not. It takes the sprites that it did not handle on the top-down phase and draws them in the bottom-up phase.At a higher level, the sprite engine walks down the list in Z order, going from the top to the very bottom sprite, and for each sprite it computes a region containing that portion of the sprite not obscured by opaque sprites above. The visible parts of any wholly sprites that are wholly opaque are drawn in this pass. Then the sprite engine walks backwards, going from the bottom most sprite up to the topmost sprite, taking into account those regions constructed in the first pass that tell it which parts of each sprite need to be drawn and which do not. It takes the sprites that it did not draw in the front-to-back phase and draws them in the back-to-front phase.\n\nAlthough the invention is described herein with reference to the preferred embodiment, one skilled in the art will readily appreciate that other applications may be substituted for those set forth herein without departing from the spirit and scope of the present invention. Accordingly, the invention should only be limited by the Claims included below.\n\nClaims (17)\n\nWhat is claimed is:\n\n1. A process for displaying multiple planes of information on a selected area of a display or computer monitor, comprising the steps of:\n\ncreating and maintaining a list of entities wherein each entity corresponds to at least one of said multiple planes;\n\ndetermining if any entity in said entity list overlaps said selected area;\n\ndynamically determining during assembly of said multiple planes whether to draw said overlapping entities in a front-to-back or back-to-front fashion based upon the traits of each entity;\n\ninitializing the renderable area of all entities to be the same area as its bounding rectangle;\n\ninitially searching said list in a front-to-back order during a first pass;\n\nchecking each individual entity's rendering area for overlap with said selected area;\n\nrepeating said search step if said entity does not overlap said selected area;\n\nhalting said process if said entity is the last entity on said list;\n\ndetermining if said overlapping entity is wholly opaque;\n\nreducing the renderable area of the entity by intersecting it with said selected area;\n\ndetermining if an overlapping, non-transparent entity intersects with an area covered by a transparent entity;\n\nmarking said overlapping entity as requiring back-to-front drawing if said overlapping entity is not wholly opaque and said overlapping entity does not have an empty rendering area;\n\nsearching said list in a back-to-front order during a second pass;\n\nchecking each individual entity to see if it has been marked for back-to-front drawing;\n\ncontinuing said back-to-front search step if said entity is not marked as a back-to-front entity;\n\nidentifying if said entity is marked as a back-to-front entity;\n\ndrawing the renderable area of said entity in said selected area if said entity overlaps said selected area and said entity is marked as a back-to-front entity;\n\ndetermining if the last entity in said list has been reached;\n\ncontinuing said search step until said last entity is reached; and\n\nterminating said process when said last entity is reached.\n\n2. An apparatus for displaying multiple planes of information on a selected area of a display or computer monitor, comprising:\n\na sprite engine, said sprite engine containing a list of entities wherein each entity corresponds to at least one of said multiple planes;\n\nsaid sprite engine comprising a module for determining if an overlapping entity exists between said entities and said selected area; and\n\nsaid sprite engine comprising a module for determining during assembly of said multiple planes whether to draw said overlapping entities in a front-to-back or back-to-front fashion based upon the traits of each entity.\n\n3. The apparatus of claim 2, wherein said list further comprises:\n\na field that indicates the parameters of a bounding rectanglebounding box of said entity.\n\n4. The apparatus of claim 2, wherein said list further comprises:\n\na field that indicates whether said entity is whollytransparent or opaque or not.\n\n5. The apparatus of claim 2, wherein said list further comprises:\n\na field that indicates a drawing function for said entity.\n\n6. The apparatus of claim 2, said sprite engine further comprising:\n\na module for placing said entity in said list in said entity's Z order.\n\n7. The apparatus of claim 2, said sprite engine further comprising:\n\na module for initializing the renderable area of all entities to be the same area as its bounding rectangle;\n\na module for searching said list in a front-to-back order during a first pass; and\n\na module for checking each individual entity for overlap with said selected area.\n\n8. The apparatus of claim 7, said sprite engine further comprising:\n\nmeans for continuing said search if said entity does not overlap said selected area; and\n\nmeans for halting said search if said entity is the last entity on said list.\n\n9. The apparatus of claim 8, said sprite engine further comprising:\n\na module for determining if said overlapping entity is wholly opaque.\n\n10. The apparatus of claim 9, said sprite engine further comprising:\n\na module for reducing the renderable area of the entity by intersecting it with said selected area; and\n\nmeans for determining if an overlapping, opaque entity intersects with an area covered by a transparent entity.\n\n11. The apparatus of claim 9, said sprite engine further comprising:\n\nmeans for allowing said overlapping entity to draw its renderable area in said selected area if said overlapping entity is wholly opaque and does not intersect with an area covered by a transparent entity; and\n\nmeans for reducing the total size of said selected area by subtracting said overlapping entity's area from said selected area.\n\n12. The apparatus of claim 11, said sprite engine further comprising:\n\nmeans for terminating said search if said overlapping entity is the last entity in said list and continuing said search if said last entity has not been reached or if the selected area becomes empty.\n\n13. The apparatus of claim 10, said sprite engine further comprising:\n\na module for marking said overlapping entity as requiring back-to-front drawing if said overlapping entity is not wholly opaque and said overlapping entity does not have an empty rendering area.\n\n14. The apparatus of claim 13, said sprite engine further comprising:\n\na module for searching said list in a back-to-front order during a second pass; and\n\na module for checking each individual entity for overlap with said selected area.\n\n15. The apparatus of claim 14, said sprite engine further comprising:\n\na module for checking each individual entity to identify if said entity is marked for back-to-front drawing.\n\n16. The apparatus of claim 15, said sprite engine further comprising:\n\nmeans for continuing said back-to-front search if said entity either does not overlap said selected area or is not marked for back-to-front drawing; and\n\na module for drawing the renderable area of said entity in said selected area if said entity is an overlapping entity and is marked for back-to-front drawing.\n\n17. A computer system including a frame buffer, display controller, monitor, and graphic subsystem, said graphic subsystem displaying multiple planes of information on a selected area of said monitor, wherein said graphic subsystem comprises:\n\na sprite engine, said sprite engine containing a list of entities wherein each entity corresponds to at least one of said multiple planes;\n\nsaid sprite engine comprising a module for determining if an overlapping area exists between said entities and said selected area;\n\nsaid sprite engine comprising a module for determining during assembly of said multiple planes whether to draw said overlapping entities in a front-to-back or back-to-front fashion based upon the traits of each entity;\n\na module for initializing the renderable area of all entities to be the same area as its bounding rectangle;\n\na module for searching said list in a front-to-back order;\n\na module for checking each individual entity's rendering area for overlap with said selected area;\n\nmeans for continuing said search if said entity does not overlap said selected area;\n\nmeans for halting said search if said entity is the last entity on said list;\n\na module for determining if said overlapping entity is wholly opaque;\n\nmeans for reducing the renderable area of the entity by intersecting it with said selected area;\n\nmeans for allowing the renderable area of said overlapping entity to draw in said selected area if said overlapping entity is wholly opaque;\n\nmeans for reducing the total size of said selected area by subtracting said overlapping entity's area from said selected area;\n\nmeans for terminating said search if said overlapping entity is the last entity in said list and continuing said search if said last entity has not been reached or if said selected area becomes empty;\n\na module for marking said overlapping entity as requiring back-to-front drawing if said overlapping entity is not wholly opaque and said overlapping entity does not have an empty rendering area;\n\na module for searching said list in a back-to-front order;\n\na module for checking each individual entity for overlap with said selected area;\n\nmeans for continuing said back-to-front search if said entity is not marked for back-to-front drawing;\n\na module for drawing the renderable area of said entity in said selected area if said entity is marked for back-to-front drawing; and\n\nmeans for halting said back-to-front search if said entity is last entity on said list.\n\nUS08/933,146 1997-09-18 1997-09-18 Sprite engine Expired - Lifetime US6069633A (en)\n\nPriority Applications (1)\n\nApplication Number Priority Date Filing Date Title US08/933,146 US6069633A (en) 1997-09-18 1997-09-18 Sprite engine\n\nApplications Claiming Priority (1)\n\nApplication Number Priority Date Filing Date Title US08/933,146 US6069633A (en) 1997-09-18 1997-09-18 Sprite engine\n\nPublications (1)\n\nPublication Number Publication Date US6069633A true US6069633A (en) 2000-05-30\n\nFamily\n\nID=25463446\n\nFamily Applications (1)\n\nApplication Number Title Priority Date Filing Date US08/933,146 Expired - Lifetime US6069633A (en) 1997-09-18 1997-09-18 Sprite engine\n\nCountry Status (1)\n\nCountry Link US (1) US6069633A (en)\n\nCited By (42)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20020057285A1 (en) * 2000-08-04 2002-05-16 Nicholas James J. Non-intrusive interactive notification system and method US20020084999A1 (en) * 1998-01-06 2002-07-04 Tomohisa Shiga Information recording and replaying apparatus and method of controlling same US20020171671A1 (en) * 2001-05-16 2002-11-21 Vibrant Graphics, Inc. Automatic draw order US6518966B1 (en) * 1998-03-11 2003-02-11 Matsushita Institute Industrial Co., Ltd. Method and device for collision detection and recording medium recorded with collision detection method US6597364B1 (en) * 2000-08-04 2003-07-22 Silicon Integrated Systems Corp. Method and system for eliminating frame tears from an output display US20030184554A1 (en) * 2002-03-27 2003-10-02 Fujitsu Limited Graphics drawing device US20040101204A1 (en) * 2001-03-07 2004-05-27 King Tony Richard Method of processing video into an encoded bitstream US20040261039A1 (en) * 2003-06-19 2004-12-23 International Business Machines Corporation Method and system for ordering on-screen windows for display US6865719B1 (en) 1999-05-19 2005-03-08 Transparence, Inc. Cursor movable interactive message US20050052455A1 (en) * 2002-02-01 2005-03-10 Canon Kabushiki Kaisha Effecient display update from changing object graphics US20050168475A1 (en) * 2004-01-29 2005-08-04 Yamaha Corporation Image processing method and apparatus US20050231532A1 (en) * 2004-03-31 2005-10-20 Canon Kabushiki Kaisha Image processing method and image processing apparatus US20050280659A1 (en) * 2004-06-16 2005-12-22 Paver Nigel C Display controller bandwidth and power reduction US20060001679A1 (en) * 2001-05-17 2006-01-05 Adobe Systems Incorporated, A Delaware Corporation Combining raster and vector data in the presence of transparency US20060077210A1 (en) * 2004-10-13 2006-04-13 Morris John D Rasterizing stacked graphics objects from top to bottom US20060117356A1 (en) * 2004-12-01 2006-06-01 Microsoft Corporation Interactive montages of sprites for indexing and summarizing video US20060203011A1 (en) * 2005-03-14 2006-09-14 Fuji Xerox Co., Ltd. Image processing apparatus, image processing method, and storage medium storing a program for causing image processing to be executed US20060232603A1 (en) * 2005-04-19 2006-10-19 Adobe Systems Incorporated Modifying a path in a drawing US20070006062A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management US20070006065A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Conditional event timing for interactive multimedia presentations US20070006079A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation State-based timing for interactive multimedia presentations US20070005757A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Distributing input events to multiple applications in an interactive media environment US20070006063A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management US20070006233A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Queueing events in an interactive media environment US20070002045A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Rendering and compositing multiple applications in an interactive media environment US20070005758A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Application security in an interactive media environment US20070006238A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Managing application states in an interactive media environment US20070211052A1 (en) * 2006-03-10 2007-09-13 Samsung Electronics Co., Ltd. System, method and media processing 3-dimensional graphic data WO2008156437A1 (en) 2006-04-10 2008-12-24 Avaworks Incorporated Do-it-yourself photo realistic talking head creation system and method US20090009526A1 (en) * 2007-07-03 2009-01-08 Sun Microsystems, Inc. Method and system for rendering a shape US20090064013A1 (en) * 2007-09-04 2009-03-05 Apple Inc. Opaque views for graphical user interfaces US7502028B1 (en) * 2005-04-19 2009-03-10 Adobe Systems Incorporated Assigning region attributes in a drawing US7633504B2 (en) 2005-04-19 2009-12-15 Adobe Systems Incorporated Assigning subpath attributes in a drawing US7667716B1 (en) * 1998-12-09 2010-02-23 Nec Corporation Apparatus and method for converting an object display description document US20100066731A1 (en) * 2008-09-16 2010-03-18 James Calvin Vecore Configurator Process and System US7721308B2 (en) 2005-07-01 2010-05-18 Microsoft Corproation Synchronization aspects of interactive multimedia presentation management US8020084B2 (en) 2005-07-01 2011-09-13 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management US20140306957A1 (en) * 2013-04-15 2014-10-16 Broadcom Corporation Regional compositing US20140340413A1 (en) * 2013-05-14 2014-11-20 Mstar Semiconductor, Inc. Layer access method, data access device and layer access arrangement method US9524075B2 (en) 2009-09-01 2016-12-20 James J. Nicholas, III System and method for cursor-based application management US10417814B2 (en) 2017-08-04 2019-09-17 Nxp Usa, Inc. Method and apparatus for blending layers within a graphics display component US10593103B2 (en) 2017-08-04 2020-03-17 Nxp Usa, Inc. Method and apparatus for managing graphics layers within a data processing system\n\nCitations (10)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US5001469A (en) * 1988-06-29 1991-03-19 Digital Equipment Corporation Window-dependent buffer selection US5128658A (en) * 1988-06-27 1992-07-07 Digital Equipment Corporation Pixel data formatting US5216413A (en) * 1988-06-13 1993-06-01 Digital Equipment Corporation Apparatus and method for specifying windows with priority ordered rectangles in a computer video graphics system US5396263A (en) * 1988-06-13 1995-03-07 Digital Equipment Corporation Window dependent pixel datatypes in a computer video graphics system EP0652524A1 (en) * 1993-05-21 1995-05-10 Sega Enterprises, Ltd. Image processing device and method US5487145A (en) * 1993-07-09 1996-01-23 Taligent, Inc. Method and apparatus for compositing display items which minimizes locked drawing areas US5546518A (en) * 1995-01-06 1996-08-13 Microsoft Corporation System and method for composing a display frame of multiple layered graphic sprites US5831628A (en) * 1995-08-31 1998-11-03 Fujitsu Limited Polygon overlap extraction method, and polygon grouping method and apparatus US5831622A (en) * 1990-12-28 1998-11-03 Apple Computer, Inc. Method and apparatus for intersecting color regions of multiple shapes for graphics systems US5898437A (en) * 1995-04-28 1999-04-27 Sun Microsystems, Inc. Method for fast rendering of three-dimensional objects by generating lists of like-facing coherent primitives\n\n1997\n\n1997-09-18 US US08/933,146 patent/US6069633A/en not_active Expired - Lifetime\n\nPatent Citations (11)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US5216413A (en) * 1988-06-13 1993-06-01 Digital Equipment Corporation Apparatus and method for specifying windows with priority ordered rectangles in a computer video graphics system US5396263A (en) * 1988-06-13 1995-03-07 Digital Equipment Corporation Window dependent pixel datatypes in a computer video graphics system US5128658A (en) * 1988-06-27 1992-07-07 Digital Equipment Corporation Pixel data formatting US5001469A (en) * 1988-06-29 1991-03-19 Digital Equipment Corporation Window-dependent buffer selection US5831622A (en) * 1990-12-28 1998-11-03 Apple Computer, Inc. Method and apparatus for intersecting color regions of multiple shapes for graphics systems EP0652524A1 (en) * 1993-05-21 1995-05-10 Sega Enterprises, Ltd. Image processing device and method US5487145A (en) * 1993-07-09 1996-01-23 Taligent, Inc. Method and apparatus for compositing display items which minimizes locked drawing areas US5546518A (en) * 1995-01-06 1996-08-13 Microsoft Corporation System and method for composing a display frame of multiple layered graphic sprites US5892521A (en) * 1995-01-06 1999-04-06 Microsoft Corporation System and method for composing a display frame of multiple layered graphic sprites US5898437A (en) * 1995-04-28 1999-04-27 Sun Microsystems, Inc. Method for fast rendering of three-dimensional objects by generating lists of like-facing coherent primitives US5831628A (en) * 1995-08-31 1998-11-03 Fujitsu Limited Polygon overlap extraction method, and polygon grouping method and apparatus\n\nNon-Patent Citations (1)\n\n* Cited by examiner, â Cited by third party Title Memo from Scott Furman regarding Microsoft Win32 Software Development Kit. *\n\nCited By (70)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20020084999A1 (en) * 1998-01-06 2002-07-04 Tomohisa Shiga Information recording and replaying apparatus and method of controlling same US6496196B2 (en) * 1998-01-06 2002-12-17 Sony Corporation Information recording and replaying apparatus and method of controlling same US6518966B1 (en) * 1998-03-11 2003-02-11 Matsushita Institute Industrial Co., Ltd. Method and device for collision detection and recording medium recorded with collision detection method US7667716B1 (en) * 1998-12-09 2010-02-23 Nec Corporation Apparatus and method for converting an object display description document US20080133748A1 (en) * 1999-05-19 2008-06-05 Transparence, Inc. Non-intrusive interactive notification system and method US7548955B2 (en) 1999-05-19 2009-06-16 Transparence, Inc. Non-intrusive interactive notification system and method US6865719B1 (en) 1999-05-19 2005-03-08 Transparence, Inc. Cursor movable interactive message US6597364B1 (en) * 2000-08-04 2003-07-22 Silicon Integrated Systems Corp. Method and system for eliminating frame tears from an output display US20020057285A1 (en) * 2000-08-04 2002-05-16 Nicholas James J. Non-intrusive interactive notification system and method US20040101204A1 (en) * 2001-03-07 2004-05-27 King Tony Richard Method of processing video into an encoded bitstream US20020171671A1 (en) * 2001-05-16 2002-11-21 Vibrant Graphics, Inc. Automatic draw order US8665293B2 (en) * 2001-05-16 2014-03-04 Autodesk, Inc. Automatic draw order US20060001679A1 (en) * 2001-05-17 2006-01-05 Adobe Systems Incorporated, A Delaware Corporation Combining raster and vector data in the presence of transparency US7602403B2 (en) * 2001-05-17 2009-10-13 Adobe Systems Incorporated Combining raster and vector data in the presence of transparency US20050052455A1 (en) * 2002-02-01 2005-03-10 Canon Kabushiki Kaisha Effecient display update from changing object graphics US20030184554A1 (en) * 2002-03-27 2003-10-02 Fujitsu Limited Graphics drawing device US6961059B2 (en) * 2002-03-27 2005-11-01 Fujitsu Limited Graphics drawing device US7765488B2 (en) 2003-06-19 2010-07-27 International Business Machines Corporation System and computer-readable medium for ordering on-screen windows for display US20040261039A1 (en) * 2003-06-19 2004-12-23 International Business Machines Corporation Method and system for ordering on-screen windows for display US20080229237A1 (en) * 2003-06-19 2008-09-18 International Business Machines Corporation System and computer-readable medium for ordering on-screen windows for display field of the invention US20050168475A1 (en) * 2004-01-29 2005-08-04 Yamaha Corporation Image processing method and apparatus US7362339B2 (en) * 2004-01-29 2008-04-22 Yamaha Corporation Image processing method and apparatus US7728852B2 (en) * 2004-03-31 2010-06-01 Canon Kabushiki Kaisha Image processing method and image processing apparatus US20050231532A1 (en) * 2004-03-31 2005-10-20 Canon Kabushiki Kaisha Image processing method and image processing apparatus US20050280659A1 (en) * 2004-06-16 2005-12-22 Paver Nigel C Display controller bandwidth and power reduction US20060077210A1 (en) * 2004-10-13 2006-04-13 Morris John D Rasterizing stacked graphics objects from top to bottom US20060117356A1 (en) * 2004-12-01 2006-06-01 Microsoft Corporation Interactive montages of sprites for indexing and summarizing video US7982738B2 (en) * 2004-12-01 2011-07-19 Microsoft Corporation Interactive montages of sprites for indexing and summarizing video US20060203011A1 (en) * 2005-03-14 2006-09-14 Fuji Xerox Co., Ltd. Image processing apparatus, image processing method, and storage medium storing a program for causing image processing to be executed US7728850B2 (en) * 2005-03-14 2010-06-01 Fuji Xerox Co., Ltd. Apparatus and methods for processing layered image data of a document US7502028B1 (en) * 2005-04-19 2009-03-10 Adobe Systems Incorporated Assigning region attributes in a drawing US20060232603A1 (en) * 2005-04-19 2006-10-19 Adobe Systems Incorporated Modifying a path in a drawing US7646386B2 (en) 2005-04-19 2010-01-12 Adobe Systems Incorporated Modifying a path in a drawing US7633504B2 (en) 2005-04-19 2009-12-15 Adobe Systems Incorporated Assigning subpath attributes in a drawing US20070006062A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management WO2007005327A2 (en) 2005-07-01 2007-01-11 Microsoft Corporation Rendering and compositing multiple applications in an interactive media environment US8799757B2 (en) 2005-07-01 2014-08-05 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management JP2009505170A (en) * 2005-07-01 2009-02-05 ãã¤ã¯ã­ã½ãã ã³ã¼ãã¬ã¼ã·ã§ã³ Rendering and compositing multiple applications in an interactive media environment US20070006238A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Managing application states in an interactive media environment US20070006063A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management US20070005757A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Distributing input events to multiple applications in an interactive media environment US20070006079A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation State-based timing for interactive multimedia presentations US20070006233A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Queueing events in an interactive media environment US20070002045A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Rendering and compositing multiple applications in an interactive media environment US20070006065A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Conditional event timing for interactive multimedia presentations US8656268B2 (en) 2005-07-01 2014-02-18 Microsoft Corporation Queueing events in an interactive media environment US7721308B2 (en) 2005-07-01 2010-05-18 Microsoft Corproation Synchronization aspects of interactive multimedia presentation management US20070005758A1 (en) * 2005-07-01 2007-01-04 Microsoft Corporation Application security in an interactive media environment KR101311111B1 (en) * 2005-07-01 2013-10-14 ë§ì´í¬ë¡ìíí¸ ì½í¬ë ì´ì  Rendering and compositing multiple applications in an interactive media environment WO2007005327A3 (en) * 2005-07-01 2007-06-21 Microsoft Corp Rendering and compositing multiple applications in an interactive media environment US7941522B2 (en) 2005-07-01 2011-05-10 Microsoft Corporation Application security in an interactive media environment US8305398B2 (en) 2005-07-01 2012-11-06 Microsoft Corporation Rendering and compositing multiple applications in an interactive media environment US8020084B2 (en) 2005-07-01 2011-09-13 Microsoft Corporation Synchronization aspects of interactive multimedia presentation management US8108787B2 (en) 2005-07-01 2012-01-31 Microsoft Corporation Distributing input events to multiple applications in an interactive media environment US20070211052A1 (en) * 2006-03-10 2007-09-13 Samsung Electronics Co., Ltd. System, method and media processing 3-dimensional graphic data WO2008156437A1 (en) 2006-04-10 2008-12-24 Avaworks Incorporated Do-it-yourself photo realistic talking head creation system and method US20090009526A1 (en) * 2007-07-03 2009-01-08 Sun Microsystems, Inc. Method and system for rendering a shape US8201102B2 (en) * 2007-09-04 2012-06-12 Apple Inc. Opaque views for graphical user interfaces US20090064013A1 (en) * 2007-09-04 2009-03-05 Apple Inc. Opaque views for graphical user interfaces US20100066731A1 (en) * 2008-09-16 2010-03-18 James Calvin Vecore Configurator Process and System US10521570B2 (en) 2009-09-01 2019-12-31 James J. Nicholas, III System and method for cursor-based application management US9524075B2 (en) 2009-09-01 2016-12-20 James J. Nicholas, III System and method for cursor-based application management US11475109B2 (en) 2009-09-01 2022-10-18 James J. Nicholas, III System and method for cursor-based application management US11960580B2 (en) 2009-09-01 2024-04-16 Transparence Llc System and method for cursor-based application management US9412196B2 (en) * 2013-04-15 2016-08-09 Broadcom Corporation Region"
    }
}