{
    "id": "dbpedia_988_2",
    "rank": 24,
    "data": {
        "url": "https://www.oreilly.com/library/view/making-isometric-social/9781449309664/ch01.html",
        "read_more_link": "",
        "language": "en",
        "title": "Time Games with HTML5, CSS3, and JavaScript [Book]",
        "top_image": "https://www.oreilly.com/library/cover/9781449309664/1200w630h/",
        "meta_img": "https://www.oreilly.com/library/cover/9781449309664/1200w630h/",
        "images": [
            "https://cdn.oreillystatic.com/images/sitewide-headers/oreilly_logo_mark_red.svg",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889129.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889131.png.jpg",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889133.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889135.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889137.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889139.png.jpg",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889141.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889143.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889145.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889147.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889149.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889151.png",
            "https://www.oreilly.com/api/v2/epubs/9781449309664/files/httpatomoreillycomsourceoreillyimages889153.png",
            "https://cdn.oreillystatic.com/oreilly/images/app-store-logo.png",
            "https://cdn.oreillystatic.com/oreilly/images/google-play-logo.png",
            "https://cdn.oreillystatic.com/oreilly/images/roku-tv-logo.png",
            "https://cdn.oreillystatic.com/oreilly/images/amazon-appstore-logo.png",
            "https://cdn.oreillystatic.com/images/sitewide-headers/oreilly_logo_mark_red.svg",
            "https://cdn.oreillystatic.com/oreilly/images/report-software-architecture-patterns-553x420.jpg",
            "https://cdn.oreillystatic.com/oreilly/images/laptop-flat-topics-ml-1124x638.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Mario Andres Pagella"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Chapter 1. Graphics Foundations: Canvas and Sprites HTML5’s canvas element makes it much easier to create complex graphic games, offering far more flexibility and speed than older approaches that relied …  - Selection from Making Isometric Social Real-Time Games with HTML5, CSS3, and JavaScript [Book]",
        "meta_lang": "en",
        "meta_favicon": "//www.oreilly.com/favicon.ico",
        "meta_site_name": "O’Reilly Online Learning",
        "canonical_link": "https://www.oreilly.com/library/view/making-isometric-social/9781449309664/ch01.html",
        "text": "Now that you know how to get the color of a particular pixel in the canvas, including its alpha value (the transparency), we can solve a very common problem in web development that previously could be solved only by using very intricate and inefficient hacks (involving the use of JavaScript and CSS to click through the transparent areas of a PNG image, a div, or another element). The problem is that though some areas of the image are transparent, they still act as a solid rectangle, and thus clicking on the transparent areas returns a reference to the original of the image instead of returning a reference to the next solid object below it.\n\nWith these tools in our hands, there are many ways to solve this particular problem, but they all mostly consist of either:\n\nThe first approach can be implemented by using the document.elementFromPoint() DOM function to determine which element was clicked and if it is an image or an object with a background (either a solid color or an image which may or may not have transparent areas), we can use getImageData() to detect whether the selected pixel is transparent. If that’s the case, we can select the parent (and if it’s not, we can look for siblings). We can keep traversing the DOM until we find a “solid” color and select that element instead of the image. However, this approach can be nonfunctional, impractical, or downright inefficient if:\n\nThe second approach requires us to do things in a completely different way than most web developers are used to: keeping track of the coordinates of the objects we present on the screen, and upon a click action, do a hit test to see whether the X and Y coordinates of the mouse are inside the area of any given object. The way to do this is to store the position x, position y, width, and height of every element, as well as the order in which they are being presented on the screen. Then, there are many methods that you can use to cycle through all the elements in order to see which one you have clicked on. Having the position x, position y, width, and height for every object that you present allows you to create rectangles that you can later use to test whether the clientX and clientY values returned by a mouse event (such as mousedown, mousemove, mouseup, click, etc.) are inside them. Figure 1-5 shows how we can keep track of all the objects presented on the screen. MX and MY (Mouse X and Mouse Y) represent the click coordinates. Then we can check whether the mouse coordinates are inside any of the other objects (in this case, the object being clicked would be #4).\n\nIn our case, we’re going to eliminate the two downsides of using document.elementFromPoint() by combining it with pointer-events: none, a CSS attribute that lets the browser know that the mouse should not interact with an individual element, completely eliminating the need to traverse the DOM or keeping track of every single object in our screen.\n\nFigure 1-6 shows how our page is going to be organized. Clicks made in the transparent areas of the “Smiley” img should go through the image, and we should get a reference to the “Cheese” div, unless, of course, we click through the transparent areas of the Smiley, and a hole of the Cheese, which should return a reference to the HTML document.\n\nTo do this, we need to start off by detecting that the page has finished loading:\n\nwindow.onload = function () { var MIN_ALPHA_THRESHOLD = 10; var canvas = document.getElementById('myCanvas'); var c = canvas.getContext('2d'); document.addEventListener('click', detectElement, false);\n\nNotice a variable called MIN_ALPHA_THRESHOLD, which specifies how solid something must be (on a scale of 0–255, which is included in the pixel-level data returned by context.getImageData()) so as to not be considered transparent. All the clicks that we make on the document call a function called detectElement().\n\nThe idea behind detectElement() is simple; first, we need to detect the object returned by invoking document.elementFromPoint() and test for transparency. If it is transparent, add the object to an array of objects we’re going to make “invisible” to pointer events, and try again. Keep doing that until we find a solid object or body, show the result in an alert box, and roll back all the changes:\n\nfunction detectElement (e) { var invisibleObjects = new Array(); var solidPixel = false; var obj; do { obj = document.elementFromPoint(e.clientX, e.clientY); if (obj == null || obj.tagName == 'BODY' || obj.tagName == 'HTML') { break; } if (isTransparent(obj, e.clientX, e.clientY)) { invisibleObjects.push(obj); setObjectEventVisibility(obj, false); } else { solidPixel = true; } } while(!solidPixel); for (var i = 0; i < invisibleObjects.length; i++) { setObjectEventVisibility(invisibleObjects[i], true); } invisibleObjects = null; alert(obj.tagName); }\n\nThe setObjectEventVisibility() function makes elements visible or invisible to pointer events by passing a reference to the object, and a boolean parameter indicating whether we want to make objects visible or invisible. All it does is set the value of the pointerEvents CSS attribute to either visiblePainted (the default) or none. Other valid values for pointerEvents are visibleFill, visibleStroke, visible, painted, fill, stroke, all, and inherit. You can see the complete list and what each is for in the relevant W3C specification page: http://www.w3.org/TR/SVG/interact.html#PointerEventsProperty. Notice that we’re going to be assuming that we are not going to be using values for pointerEvents other than visiblePainted or none. Extending the functionality of the function shown here to support all other pointerEvents is left as an exercise to the reader:\n\nfunction setObjectEventVisibility(obj, visible) { if (visible) { obj.style.pointerEvents = 'visiblePainted'; } else { obj.style.pointerEvents = 'none'; } }\n\nThe function that we’re going to be using to detect if an specific coordinate of an image is transparent is called isPixelTransparent(). In order to make this function work correctly, we must take into account all the different use-cases in which it will be used. For example, let’s say that we have a 300×300-pixel div, but as a background we are using a 600×300-pixel image with a horizontal background offset of 300 pixels.\n\nFigure 1-7 shows how the div could look (in reality, our background image will be the “cheese” texture) and also shows the complete image being used as its background. Notice that the background of that div has a horizontal offset of 300 pixels. If we didn’t take that offset into account, clicking on the center of the image would result in a transparent pixel instead of the solid blue one. Another thing to keep in mind (not taken into account in this script) is that in the case of non-img elements (such as divs), we might be using the CSS3 background-size attribute, which allows us to adjust how the background image is presented relative to the div that is containing it.\n\nTherefore, in the case of non-img elements, we’re going to use the following helper function:\n\nfunction getBackgroundPosition(src, property) { property = property.split(' '); /** * Modifying the code to find out if its inheriting any properties * from a parent would be too inefficient. We're going to be * assuming that if the element has 'auto', it means 0 */ var left = (property[0] != 'auto') ? property[0].substr(0, property[0].length - 2) : 0; var top = (property[1] != 'auto') ? property[1].substr(0, property[1].length - 2) : 0; return { x: left, y: top }; }\n\nFor the sake of simplicity, we’re going to assume that all background images are not being repeated either horizontally or vertically and that we will be using a single background per element (CSS3 supports multiple backgrounds). However, extending the functions to support multiple backgrounds can be done very easily by loading all of them in an array.\n\nThat said, our isPixelTransparent() function is going to look like this:\n\nfunction isPixelTransparent (src, x, y, oWidth, oHeight, offsetX, offsetY) { var img = new Image() img.src = src; // If parameters are not being passed on to this function, use \"default\" values oWidth = (!oWidth) ? img.width : oWidth; oHeight = (!oHeight) ? img.height : oHeight; offsetX = (!offsetX) ? 0 : offsetX; offsetY = (!offsetY) ? 0 : offsetY; // 'Reset' the canvas before painting over it again c.clearRect(0, 0, 1, 1); c.drawImage(img, offsetX - x, offsetY - y, img.width, img.height); var idata = c.getImageData(0, 0, 1, 1); var data = idata.data; var alpha = data[3]; return (alpha < MIN_ALPHA_THRESHOLD); }\n\nFinally, the isTransparent() function will be in charge of getting the element located at the X and Y coordinates returned by document.elementFromPoint() and figuring out how to interpret it before calling isPixelTransparent().\n\nTo do this correctly, we first need to calculate the relative coordinates of the click depending on the position of the object on the screen:\n\nfunction isTransparent(obj, x, y) { var robj = obj; var rx = robj.x; var ry = robj.y; var offset = { x: 0, y: 0 }; var padding = { x: 0, y: 0 }; var margin = { x: 0, y: 0 }; // Calculate the X (left) and Y (top) coordinates relative to the // parent until we get to the \"top\" if (robj.offsetParent) { rx = 0; ry = 0; while(robj.offsetParent) { rx += robj.offsetLeft; ry += robj.offsetTop; robj = robj.offsetParent; } }\n\nIn addition to the separation between the object and its parent objects, they might also have a padding or a margin defined, so we need to take that possibility into account as well. Figure 1-8 will give you an idea of what a particular scenario might look like.\n\nWe have detected a click inside the D container, and we also know that:\n\ndocument.addEventListener('click', detectElement, false);\n\nreturns coordinates relative to the edges of the window (container A). Thus if we want to figure out the X and Y coordinates relative to the D container, we need to cycle through all of D’s parent containers (C and B) until we get to the top (A). In this case, that would be:\n\n/* Pseudocode */ xCoord = Mouse.x - 12 (C) - 55 (B) - 10 (A) yCoord = Mouse.y - 8 (C) - 10 (B) - 15 (A)\n\nThis separation between the container and all of its children could be because:\n\nAnd so on. However, there are a few “gotchas” in which some of these rules don’t apply. For example, if the parent container has defined a padding but its children are using position: absolute, they won’t be affected by it.\n\nUsually, to get a CSS attribute, many developers use:\n\ndocument.getElementById('ObjectName').style.property\n\nThe problem with that approach is that it doesn’t take into account CSS attributes defined via a CSS Stylesheet; it can be used only when styles are defined inline. Modern browsers usually support window.getComputedStyle. Here’s how to access a property:\n\nvar cs = document.defaultView.getComputedStyle(obj, null); paddingLeft = cs.getPropertyValue('padding-left');\n\nThe name of the computed styles is the same as the CSS attribute that we’re trying to access; for example, the left padding would be getPropertyValue('padding-left') and a background image would be getPropertyValue('background-image').\n\nThen we need to figure out what sort of DOM element we’re dealing with. Images should be handled in a different way than, say, a div or a td. Elements that do not support background images or “image source” attributes will be considered transparent:\n\nswitch(obj.tagName) { case 'IMG': // Handle image source break; case 'DIV': case 'TD': case 'P': case 'SPAN': case 'A': // handle background image or solid color break; default: return true; break; }\n\nConventional img tags are the easiest to handle, as the path to the image is declared in the source attribute:\n\ncase 'IMG': return isPixelTransparent(obj.src, (x - rx), (y - ry), obj.width, obj.height); break;\n\nHowever, all other elements require a trickier way to figure out if the object has a solid color or an image background—and if they do, how the image is positioned and presented inside it.\n\nThe complete code for this example is ex5-clickthrough.html in the examples folder of the code repository."
    }
}