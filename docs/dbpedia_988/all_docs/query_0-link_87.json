{
    "id": "dbpedia_988_0",
    "rank": 87,
    "data": {
        "url": "https://superuser.com/questions/461022/how-does-the-cpu-and-gpu-interact-in-displaying-computer-graphics",
        "read_more_link": "",
        "language": "en",
        "title": "How does the CPU and GPU interact in displaying computer graphics?",
        "top_image": "https://cdn.sstatic.net/Sites/superuser/Img/apple-touch-icon@2.png?v=e869e4459439",
        "meta_img": "https://cdn.sstatic.net/Sites/superuser/Img/apple-touch-icon@2.png?v=e869e4459439",
        "images": [
            "https://cdn.sstatic.net/Sites/superuser/Img/logo.svg?v=4bc8a703ebac",
            "https://i.sstatic.net/HxF1D.png",
            "https://www.gravatar.com/avatar/1375f202e61682cc4963295f4b0430dc?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/40909afbdc397444acebc91b63958a99?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/DD5Mz.png",
            "https://i.sstatic.net/6op74.png",
            "https://i.sstatic.net/hFS3C.gif",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/ec198cb6fc38d98bb88dd390e0bed8e3?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/346ca03edfbde2a468adc289867ab975?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/zbK6X.png",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/e5e04.jpg?s=64",
            "https://www.gravatar.com/avatar/b036ae5b0728ad3827a6695e18f7a53f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/da26e799270ce5e8b62659ed77b11cef?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/1762c2acf8724ee326d2aa89642d3b2a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/eb126290d67ebd6fa1e4d3ca396d3114?s=64&d=identicon&r=PG",
            "https://superuser.com/posts/461022/ivc/6189?prg=bb3f1212-7f64-4ef4-8dcc-c0a7bfc248b5"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2012-08-13T12:02:12",
        "summary": "",
        "meta_description": "Here you can see a screenshot of a small C++ program called Triangle.exe with a rotating triangle based on the OpenGL API. \r\nAdmittedly a very basic example but I think it's applicable to other gra...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/superuser/Img/favicon.ico?v=4852d6fb3f5d",
        "meta_site_name": "Super User",
        "canonical_link": "https://superuser.com/questions/461022/how-does-the-cpu-and-gpu-interact-in-displaying-computer-graphics",
        "text": "I decided to write a bit about the programming aspect and how components talk to each other. Maybe it'll shed some light on certain areas.\n\nThe Presentation\n\nWhat does it take to even have that single image, that you posted in your question, drawn on the screen?\n\nThere are many ways to draw a triangle on the screen. For simplicity, let's assume no vertex buffers were used. (A vertex buffer is an area of memory where you store coordinates.) Let's assume the program simply told the graphics processing pipeline about every single vertex (a vertex is just a coordinate in space) in a row.\n\nBut, before we can draw anything, we first have to run some scaffolding. We'll see why later:\n\n// Clear The Screen And The Depth Buffer glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT); // Reset The Current Modelview Matrix glMatrixMode(GL_MODELVIEW); glLoadIdentity(); // Drawing Using Triangles glBegin(GL_TRIANGLES); // Red glColor3f(1.0f,0.0f,0.0f); // Top Of Triangle (Front) glVertex3f( 0.0f, 1.0f, 0.0f); // Green glColor3f(0.0f,1.0f,0.0f); // Left Of Triangle (Front) glVertex3f(-1.0f,-1.0f, 1.0f); // Blue glColor3f(0.0f,0.0f,1.0f); // Right Of Triangle (Front) glVertex3f( 1.0f,-1.0f, 1.0f); // Done Drawing glEnd();\n\nSo what did that do?\n\nWhen you write a program that wants to use the graphics card, you'll usually pick some kind of interface to the driver. Some well known interfaces to the driver are:\n\nOpenGL\n\nDirect3D\n\nCUDA\n\nFor this example we'll stick with OpenGL. Now, your interface to the driver is what gives you all the tools you need to make your program talk to the graphics card (or the driver, which then talks to the card).\n\nThis interface is bound to give you certain tools. These tools take the shape of an API which you can call from your program.\n\nThat API is what we see being used in the example above. Let's take a closer look.\n\nThe Scaffolding\n\nBefore you can really do any actual drawing, you'll have to perform a setup. You have to define your viewport (the area that will actually be rendered), your perspective (the camera into your world), what anti-aliasing you will be using (to smooth out the edged of your triangle)...\n\nBut we won't look at any of that. We'll just take a peek at the stuff you'll have to do every frame. Like:\n\nClearing the screen\n\nThe graphics pipeline is not going to clear the screen for you every frame. You'll have to tell it. Why? This is why:\n\nIf you don't clear the screen, you'll simply draw over it every frame. That's why we call glClear with the GL_COLOR_BUFFER_BIT set. The other bit (GL_DEPTH_BUFFER_BIT) tells OpenGL to clear the depth buffer. This buffer is used to determine which pixels are in front (or behind) other pixels.\n\nTransformation\n\nImage source\n\nTransformation is the part where we take all the input coordinates (the vertices of our triangle) and apply our ModelView matrix. This is the matrix that explains how our model (the vertices) are rotated, scaled, and translated (moved).\n\nNext, we apply our Projection matrix. This moves all coordinates so that they face our camera correctly.\n\nNow we transform once more, with our Viewport matrix. We do this to scale our model to the size of our monitor. Now we have a set of vertices that are ready to be rendered!\n\nWe'll come back to transformation a bit later.\n\nDrawing\n\nTo draw a triangle, we can simply tell OpenGL to start a new list of triangles by calling glBegin with the GL_TRIANGLES constant.\n\nThere are also other forms you can draw. Like a triangle strip or a triangle fan. These are primarily optimizations, as they require less communication between the CPU and the GPU to draw the same amount of triangles.\n\nAfter that, we can provide a list of sets of 3 vertices which should make up each triangle. Every triangle uses 3 coordinates (as we're in 3D-space). Additionally, I also provide a color for each vertex, by calling glColor3f before calling glVertex3f.\n\nThe shade between the 3 vertices (the 3 corners of the triangle) is calculated by OpenGL automatically. It will interpolate the color over the whole face of the polygon.\n\nInteraction\n\nNow, when you click the window. The application only has to capture the window message that signals the click. Then you can run any action in your program you want.\n\nThis gets a lot more difficult once you want to start interacting with your 3D scene.\n\nYou first have to clearly know at which pixel the user clicked the window. Then, taking your perspective into account, you can calculate the direction of a ray, from the point of the mouse click into your scene. You can then calculate if any object in your scene intersects with that ray. Now you know if the user clicked an object.\n\nSo, how do you make it rotate?\n\nTransformation\n\nI am aware of two types of transformations that are generally applied:\n\nMatrix-based transformation\n\nBone-based transformation\n\nThe difference is that bones affect single vertices. Matrices always affect all drawn vertices in the same way. Let's look at an example.\n\nExample\n\nEarlier, we loaded our identity matrix before drawing our triangle. The identity matrix is one that simply provides no transformation at all. So, whatever I draw, is only affected by my perspective. So, the triangle will not be rotated at all.\n\nIf I want to rotate it now, I could either do the math myself (on the CPU) and simply call glVertex3f with other coordinates (that are rotated). Or I could let the GPU do all the work, by calling glRotatef before drawing:\n\n// Rotate The Triangle On The Y axis glRotatef(amount,0.0f,1.0f,0.0f);\n\namount is, of course, just a fixed value. If you want to animate, you'll have to keep track of amount and increase it every frame.\n\nSo, wait, what happened to all the matrix talk earlier?\n\nIn this simple example, we don't have to care about matrices. We simply call glRotatef and it takes care of all that for us.\n\nglRotate produces a rotation of angle degrees around the vector x y z . The current matrix (see glMatrixMode) is multiplied by a rotation matrix with the product replacing the current matrix, as if glMultMatrix were called with the following matrix as its argument:\n\nx 2 ⁡ 1 - c + c x ⁢ y ⁡ 1 - c - z ⁢ s x ⁢ z ⁡ 1 - c + y ⁢ s 0 y ⁢ x ⁡ 1 - c + z ⁢ s y 2 ⁡ 1 - c + c y ⁢ z ⁡ 1 - c - x ⁢ s 0 x ⁢ z ⁡ 1 - c - y ⁢ s y ⁢ z ⁡ 1 - c + x ⁢ s z 2 ⁡ 1 - c + c 0 0 0 0 1\n\nWell, thanks for that!\n\nConclusion\n\nWhat becomes obvious is, there's a lot of talk to OpenGL. But it's not telling us anything. Where is the communication?\n\nThe only thing that OpenGL is telling us in this example is when it's done. Every operation will take a certain amount of time. Some operation take incredibly long, others are incredibly quick.\n\nSending a vertex to the GPU will be so fast, I wouldn't even know how to express it. Sending thousands of vertices from the CPU to the GPU, every single frame, is, most likely, no issue at all.\n\nClearing the screen can take a millisecond or worse (keep in mind, you usually only have about 16 milliseconds of time to draw each frame), depending on how large your viewport is. To clear it, OpenGL has to draw every single pixel in the color you want to clear to, that could be millions of pixels.\n\nOther than that, we can pretty much only ask OpenGL about the capabilities of our graphics adapter (max resolution, max anti-aliasing, max color depth, ...).\n\nBut we can also fill a texture with pixels that each have a specific color. Each pixel thus holds a value and the texture is a giant \"file\" filled with data. We can load that into the graphics card (by creating a texture buffer), then load a shader, tell that shader to use our texture as an input and run some extremely heavy calculations on our \"file\".\n\nWe can then \"render\" the result of our computation (in the form of new colors) into a new texture.\n\nThat's how you can make the GPU work for you in other ways. I assume CUDA performs similar to that aspect, but I never had the opportunity to work with it.\n\nWe really only slightly touched the whole subject. 3D graphics programming is a hell of a beast.\n\nImage Source\n\nI was just curious and wanted to know the whole process from double clicking on Triangle.exe under Windows XP until I can see the triangle rotating on the monitor. What happens, how do CPU (which first handles the .exe) and GPU (which finally outputs the triangle on the screen) interact?\n\nLet's take the assumption you actually know how an executable runs on an operating system and how that executable is sent from your GPU to the monitor, but don't know about what is happening in between. So, let's take a look from a hardware aspect and extend further on the programmer aspect answer...\n\nWhat is the interface between CPU and GPU?\n\nUsing a driver, the CPU can talk through motherboard features like PCI to the graphics card and sent commands to it to execute some GPU instructions, access / update the GPU memory, load in a code to be executed on the GPU and more...\n\nBut, you can't really talk straight to the hardware or driver from code; so, this will have to happen through APIs like OpenGL, Direct3D, CUDA, HLSL, Cg. While the former run GPU instructions and / or update the GPU memory, the latter will actually execute code on the GPU as they are physics / shader languages.\n\nWhy run code on the GPU and not on the CPU?\n\nWhile the CPU is good at running our daily workstation and server programs, there wasn't thought much about all those shiny graphics you see in games of these days. Back in the days there were software renderers which did the trick from some 2D and 3D things, but they were very limiting. So, here is where the GPU came into play.\n\nThe GPU is optimized for one of the most important calculations in graphics, Matrix Manipulation. While the CPU has to compute each multiplication in a matrix manipulation one-by-one (later, things like 3DNow! and SSE catched up), the GPU can do all those multiplications at once! Parallelism.\n\nBut parallel computations isn't the only reason, another reason is that the GPU is much closer to the video memory which makes it much faster than having to do round trips through the CPU, etc...\n\nHow do these GPU instructions / memory / code show graphics?\n\nThere is one missing piece to make this all work, we need something we can write to which we can then read and sent to the screen. We can do this by creating a framebuffer. Whatever operation you do, you will eventually update the pixels in the framebuffer; which besides location also hold information about color and depth.\n\nLet's give you an example where you wanted to draw a blood sprite (an image) somewhere; first, the tree texture itself is loaded into GPU memory which makes it easy to redraw it at wish. Next, to do actually draw the sprite somewhere we can translate the sprite using vertexes (putting it in the right position), rasterising it (turning it from a 3D object into pixels) and update the framebuffer. To get a better idea, here is an OpenGL pipeline flow chart from Wikipedia:\n\nThis is the main gist of the whole graphics idea, more research is homework for the reader."
    }
}