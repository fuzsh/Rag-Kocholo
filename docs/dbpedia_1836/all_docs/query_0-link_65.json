{
    "id": "dbpedia_1836_0",
    "rank": 65,
    "data": {
        "url": "https://docs.generic-mapping-tools.org/5.4/GMT_Docs.html",
        "read_more_link": "",
        "language": "en",
        "title": "1. The Generic Mapping Tools — GMT 5.4.6",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT5_Summit_2016.jpg",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_Defaults_1a.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_Defaults_1b.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_Defaults_1c.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-R.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-J.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_geo_1.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_geo_2.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_linear.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_log.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_pow.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time1.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time2.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time3.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time4.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time5.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time6.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_time7.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-B_custom.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-P.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-OK.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-U.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_-XY.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_registration.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_linecap.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_lineoffset.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_bezier.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_linearrow.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_pstext_justify.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_pstext_clearance.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_hinge.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_cyclic.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_CPTscale.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_arrows.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_arrows_types.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_anchor.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_panel.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_mapscale.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_dir_rose.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_mag_rose.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_colorbar.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_legend.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_images.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_coverlogo.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_insert.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_linear.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_linear_d.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_linear_cal.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_log.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_pow.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_polar.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_albers.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_equidistant_conic.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_lambert_conic.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_polyconic.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_lambert_az_rect.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_lambert_az_hemi.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_stereonets.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_stereographic_polar.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_stereographic_rect.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_stereographic_general.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_perspective.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_orthographic.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_az_equidistant.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_gnomonic.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_mercator.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_transverse_merc.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_TM.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_utm_zones.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_obl_merc.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_obl_nz.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_cassini.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_equi_cyl.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_general_cyl.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_miller.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_gall_stereo.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_hammer.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_mollweide.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_winkel.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_robinson.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_eckert4.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_eckert6.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_sinusoidal.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_sinus_int.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_grinten.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_chunking.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/rendering.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/formatpicture.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_E.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_F_stand+_iso+.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_F_symbol_dingbats.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_G.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/gimp-sliders+panel.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_RGBchart_a4.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/hsv-cone.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_color_interpolate.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_J_1.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_J_2.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_J_3.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_K_1.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_K_2.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_K_3.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_K_4.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_K_5.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_M_1a.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_M_1b.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_M_2.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_N_1.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_1.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_2.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_3.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_4.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_5.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_6.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_7.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_8.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_O_9.png",
            "https://docs.generic-mapping-tools.org/5.4/_images/GMT_App_P_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "10. Introduction¶\n\nMost scientists are familiar with the sequence: raw data → processing → final illustration. In order to finalize papers for submission to scientific journals, prepare proposals, and create illustrations for various presentations, many scientists spend large amounts of time and money to create high-quality figures. This process can be tedious and is often done manually, since available commercial or in-house software usually can do only part of the job. To expedite this process we introduce the Generic Mapping Tools (GMT for short), which is a free software package that can be used to manipulate columns of tabular data, time-series, and gridded data sets, and display these data in a variety of forms ranging from simple x--y plots to maps and color-coded, perspective, and shaded-relief illustrations. GMT uses the PostScript page description language [Adobe Systems Inc., 1990]. With PostScript, multiple plot files can easily be superimposed to create arbitrarily complex images in gray tones or full color. Line drawings, bitmapped images, and text can be easily combined in one illustration. PostScript plot files are device-independent: The same file can be printed at 300 dots per inch (dpi) on a cheap printer or converted to a high-resolution PNG image for online usage. GMT software is written as a set of UNIX tools and is totally self-contained and fully documented. The system is offered free of charge and is distributed over the Internet [Wessel and Smith, 1991; 1995; 1998; Wessel et al., 2013].\n\nThe original version 1.0 of GMT was released in the summer of 1988 when the authors were graduate students at Lamont-Doherty Earth Observatory of Columbia University. During our tenure as graduate students, LDEO changed its computing environment to a distributed network of UNIX workstations, and we wrote GMT to run in this environment. It became a success at LDEO, and soon spread to numerous other institutions in the US, Canada, Europe, and Japan. The current version benefits from the many suggestions contributed by users of the earlier versions, and now includes more than 100 tools, more than 30 projections, and many other new, more flexible features. GMT provides scientists with a variety of tools for data manipulation and display, including routines to sample, filter, compute spectral estimates, and determine trends in time series, grid or triangulate arbitrarily spaced data, perform mathematical operations (including filtering) on 2-D data sets both in the space and frequency domain, sample surfaces along arbitrary tracks or onto a new grid, calculate volumes, and find trend surfaces. The plotting programs will let the user make linear, log\\(_{10}\\), and \\(x^a - y^b\\) diagrams, polar and rectangular histograms, maps with filled continents and coastlines choosing from many common map projections, contour plots, mesh plots, monochrome or color images, and artificially illuminated shaded-relief and 3-D perspective illustrations.\n\nGMT is written in the highly portable ANSI C programming language [Kernighan and Ritchie, 1988], is fully POSIX compliant [Lewine, 1991], and may be used with any hardware running some flavor of UNIX. In writing GMT, we have followed the modular design philosophy of UNIX: The raw data → processing → final illustration flow is broken down to a series of elementary steps; each step is accomplished by a separate GMT or UNIX tool. This modular approach brings several benefits: (1) only a few programs are needed, (2) each program is small and easy to update and maintain, (3) each step is independent of the previous step and the data type and can therefore be used in a variety of applications, and (4) the programs can be chained together in shell scripts or with pipes, thereby creating a process tailored to do a user-specific task. The decoupling of the data retrieval step from the subsequent massage and plotting is particularly important, since each institution will typically have its own data base formats. To use GMT with custom data bases, one has only to write a data extraction tool which will put out data in a form readable by GMT (discussed below). After writing the extractor, all other GMT modules will work as they are.\n\nGMT is thoroughly documented and comes with a technical reference and cookbook which explains the purpose of the package and its many features, and provides numerous examples to help new users quickly become familiar with the operation and philosophy of the system. The cookbook contains the shell scripts that were used for each example; PostScript files of each illustration are also provided. All programs have individual manual pages which can be installed as part of the on-line documentation under the UNIX man utility or as web pages. In addition, the programs offer friendly help messages which make them essentially self-teaching -- if a user enters invalid or ambiguous command arguments, the program will print a warning to the screen with a synopsis of the valid arguments. All the documentation is available for web browsing and may be installed at the user’s site.\n\nThe processing and display routines within GMT are completely general and will handle any (x,y) or (x,y,z) data as input. For many purposes the (x,y) coordinates will be (longitude, latitude) but in most cases they could equally well be any other variables (e.g., wavelength, power spectral density). Since the GMT plot tools will map these (x,y) coordinates to positions on a plot or map using a variety of transformations (linear, log-log, and several map projections), they can be used with any data that are given by two or three coordinates. In order to simplify and standardize input and output, by default GMT uses two file formats only. Arbitrary sequences of (x,y) or (x,y,z) data are read from multi-column ASCII tables, i.e., each file consists of several records, in which each coordinate is confined to a separate column . This format is straightforward and allows the user to perform almost any simple (or complicated) reformatting or processing task using GMT processing tools (and in a pinch standard UNIX utilities such as cut, paste, grep, sed and awk). Two-dimensional data that have been sampled on an equidistant grid are read and written by GMT in a binary grid file using the functions provided with the netCDF library (a free, public-domain software library available separately from UCAR, the University Corporation of Atmospheric Research [Treinish and Gough, 1987]). This XDR (External Data Representation) based format is architecture independent, which allows the user to transfer the binary data files from one computer system to another . GMT contains programs that will read ASCII (x,y,z) files and produce grid files. One such program, surface, includes new modifications to the gridding algorithm developed by Smith and Wessel [1990] using continuous splines in tension. Optionally, GMT can also read various binary and netCDF tables, as well as a variety of grid formats, especially if built with GDAL support.\n\nMost of the programs will produce some form of output, which falls into four categories. Several of the programs may produce more than one of these types of output:\n\n1-D ASCII Tables — For example, a (x,y) series may be filtered and the filtered values output. ASCII output is written to the standard output stream.\n\n2-D binary (netCDF or user-defined) grid files -- Programs that grid ASCII (x,y,z) data or operate on existing grid files produce this type of output.\n\nPostScript -- The plotting programs all use the PostScript page description language to define plots. These commands are stored as ASCII text and can be edited should you want to customize the plot beyond the options available in the programs themselves.\n\nReports -- Several GMT programs read input files and report statistics and other information. Nearly all programs have an optional “verbose” operation, which reports on the progress of computation. All programs feature usage messages, which prompt the user if incorrect commands have been given. Such text is written to the standard error stream and can therefore be separated from ASCII table output.\n\nGMT is available over the Internet at no charge. To obtain a copy, goto GMT home page http://gmt.soest.hawaii.edu/ and follow instructions. We also maintain user forums and a bug and feature tracking system on the same page.\n\nGMT has served a multitude of scientists very well, and their responses have prompted us to develop these programs even further. It is our hope that the new version will satisfy these users and attract new users as well. We present this system to the community in order to promote sharing of research software among investigators in the US and abroad.\n\n10.1. References¶\n\nAdobe Systems Inc., PostScript Language Reference Manual, 2nd edition, 764, Addison-Wesley, Reading, Massachusetts, 1990.\n\nKernighan, B. W., and D. M. Ritchie, The C programming language, 2nd edition, 272, Prentice-Hall, Englewood Cliffs, New Jersey, 1988.\n\nLewine, D., POSIX programmer’s guide, 1st edition, 607, O’Reilly & Associates, Sebastopol, California, 1991.\n\nTreinish, L. A., and M. L. Gough, A software package for the data-independent management of multidimensional data, EOS Trans. AGU, 68(28), 633--635, 1987. doi:10.1029/EO068i028p00633.\n\n12. General Features¶\n\nThis section explains features common to all the programs in GMT and summarizes the philosophy behind the system. Some of the features described here may make more sense once you reach the cook-book section where we present actual examples of their use.\n\n12.1. GMT units¶\n\nWhile GMT has default units for both actual Earth distances and plot lengths (i.e., dimensions) of maps, it is recommended that you explicitly indicate the units of your arguments by appending the unit character, as discussed below. This will aid you in debugging, let others understand your scripts, and remove any uncertainty as to what unit you thought you wanted.\n\n12.1.1. Distance units¶\n\nd Degree of arc M Statute mile e Meter [Default] n Nautical mile f Foot s Second of arc k Kilometer u US Survey foot m Minute of arc\n\nFor Cartesian data and scaling the data units do not normally matter (they could be kg or Lumens for all we know) and are never entered. Geographic data are different, as distances can be specified in a variety of ways. GMT programs that accept actual Earth length scales like search radii or distances can therefore handle a variety of units. These choices are listed in Table distunits; simply append the desired unit to the distance value you supply. A value without a unit suffix will be consider to be in meters. For example, a distance of 30 nautical miles should be given as 30n.\n\n12.1.2. Distance calculations¶\n\nThe calculation of distances on Earth (or other planetary bodies) depends on the ellipsoidal parameters of the body (via PROJ_ELLIPSOID) and the method of computation. GMT offers three alternatives that trade off accuracy and computation time.\n\n12.1.2.1. Flat Earth distances¶\n\nQuick, but approximate “Flat Earth” calculations make a first-order correction for the spherical nature of a planetary body by computing the distance between two points A and B as\n\n\\[d_f = R \\sqrt{(\\theta_A - \\theta_B)^2 + \\cos \\left [ \\frac{\\theta_A + \\theta_B}{2} \\right ] \\Delta \\lambda^2}, \\label{eq:flatearth}\\]\n\nwhere R is the representative (or spherical) radius of the planet, \\(\\theta\\) is latitude, and the difference in longitudes, \\(\\Delta \\lambda = \\lambda_A - \\lambda_B\\), is adjusted for any jumps that might occur across Greenwich or the Dateline. As written, the geographic coordinates are given in radians. This approach is suitable when the points you use to compute \\(d_f\\) do not greatly differ in latitude and computation speed is paramount. You can specify this mode of computation by using the - prefix to the specified distance (or to the unit itself in cases where no distance is required and only a unit is expected). For instance, a search radius of 50 statute miles using this mode of computation might be specified via -S-50M.\n\n12.1.2.2. Great circle distances¶\n\nThis is the default distance calculation, which will also approximate the planetary body by a sphere of mean radius R. However, we compute an exact distance between two points A and B on such a sphere via the Haversine equation\n\n\\[d_g = 2R \\sin^{-1} {\\sqrt{\\sin^2\\frac{\\theta_A - \\theta_B}{2} + \\cos \\theta_A \\cos \\theta_B \\sin^2 \\frac{\\lambda_A - \\lambda_B}{2}} }, \\label{eq:greatcircle}\\]\n\nThis approach is suitable for most situations unless exact calculations for an ellipsoid is required (typically for a limited surface area). For instance, a search radius of 5000 feet using this mode of computation would be specified as -S5000f.\n\nNote: There are two additional GMT defaults that control how great circle (and Flat Earth) distances are computed. One concerns the selection of the “mean radius”. This is selected by PROJ_MEAN_RADIUS, which selects one of several possible representative radii. The second is PROJ_AUX_LATITUDE, which converts geodetic latitudes into one of several possible auxiliary latitudes that are better suited for the spherical approximation. While both settings have default values to best approximate geodesic distances (authalic mean radius and latitudes), expert users can choose from a range of options as detailed in the gmt.conf man page. Note that these last two settings are only used if the PROJ_ELLIPSOID is not set to “sphere”.\n\n12.1.2.3. Geodesic distances¶\n\nFor the most accurate calculations we use a full ellipsoidal formulation. Currently, we are using Vincenty’s [1975] formula which is accurate to 0.5 mm. You select this mode of computation by using the + prefix to the specified distance (or to the unit itself in cases where no distance is required). For instance, a search radius of 20 km using this mode of computation would be set by -S+20k. You may use the setting PROJ_GEODESIC which defaults to Vincenty but may also be set to Rudoe for old GMT4-style calculations or Andoyer for an approximate geodesic (within a few tens of meters) that is much faster to compute.\n\n12.1.3. Length units¶\n\nGMT programs can accept dimensional quantities and plot lengths in cm, inch, or point (1/72 of an inch) . There are two ways to ensure that GMT understands which unit you intend to use:\n\nAppend the desired unit to the dimension you supply. This way is explicit and clearly communicates what you intend, e.g., -X4c means the length being passed to the -X switch is 4 cm.\n\nSet the parameter PROJ_LENGTH_UNIT to the desired unit. Then, all dimensions without explicit unit will be interpreted accordingly.\n\nThe latter method is less secure as other users may have a different unit set and your script may not work as intended. We therefore recommend you always supply the desired unit explicitly.\n\n12.2. GMT defaults¶\n\n12.2.1. Overview and the gmt.conf file¶\n\nThere are almost 150 parameters which can be adjusted individually to modify the appearance of plots or affect the manipulation of data. When a program is run, it initializes all parameters to the GMTdefaults , then tries to open the file gmt.conf in the current directory . If not found, it will look for that file in a sub-directory /.gmt of your home directory, and finally in your home directory itself. If successful, the program will read the contents and set the default values to those provided in the file. By editing this file you can affect features such as pen thicknesses used for maps, fonts and font sizes used for annotations and labels, color of the pens, dots-per-inch resolution of the hardcopy device, what type of spline interpolant to use, and many other choices. A complete list of all the parameters and their default values can be found in the gmt.conf manual pages. Figures GMT Parameters a, b, and c show the parameters that affect plots. You may create your own gmt.conf files by running gmtdefaults and then modify those parameters you want to change. If you want to use the parameter settings in another file you can do so by copying that file to the current directory and call it gmt.conf. This makes it easy to maintain several distinct parameter settings, corresponding perhaps to the unique styles required by different journals or simply reflecting font changes necessary to make readable overheads and slides. At the end of such scripts you should then delete the (temporary) gmt.conf file. Note that any arguments given on the command line (see below) will take precedent over the default values. E.g., if your gmt.conf file has x offset = 1i as default, the -X1.5i option will override the default and set the offset to 1.5 inches.\n\nThere are at least two good reasons why the GMT default options are placed in a separate parameter file:\n\nIt would not be practical to allow for command-line syntax covering so many options, many of which are rarely or never changed (such as the ellipsoid used for map projections).\n\nIt is convenient to keep separate gmt.conf files for specific projects, so that one may achieve a special effect simply by running GMT commands in the directory whose gmt.conf file has the desired settings. For example, when making final illustrations for a journal article one must often standardize on font sizes and font types, etc. Keeping all those settings in a separate gmt.conf file simplifies this process and will allow you to generate those illustrations with the same settings later on. Likewise, GMT scripts that make figures for PowerPoint presentations often use a different color scheme and font size than output intended for laser printers. Organizing these various scenarios into separate gmt.conf files will minimize headaches associated with micro-editing of illustrations.\n\n12.2.2. Changing GMT defaults¶\n\nAs mentioned, GMT programs will attempt to open a file named gmt.conf. At times it may be desirable to override that default. There are several ways in which this can be accomplished.\n\nOne method is to start each script by saving a copy of the current gmt.conf, then copying the desired gmt.conf file to the current directory, and finally reverting the changes at the end of the script. Possible side effects include premature ending of the script due to user error or bugs which means the final resetting does not take place (unless you write your script very carefully.)\n\nTo permanently change some of the GMT parameters on the fly inside a script the gmtset utility can be used. E.g., to change the primary annotation font to 12 point Times-Bold in red we run\n\ngmt set FONT_ANNOT_PRIMARY 12p,Times-Bold,red\n\nThese changes will remain in effect until they are overridden.\n\nIf all you want to achieve is to change a few parameters during the execution of a single command but otherwise leave the environment intact, consider passing the parameter changes on the command line via the --PAR=value mechanism. For instance, to temporarily set the output format for floating points to have lots of decimals, say, for map projection coordinate output, append --FORMAT_FLOAT_OUT=%.16lg to the command in question.\n\nFinally, GMT provides to possibility to override the settings only during the running of a single script, reverting to the original settings after the script is run, as if the script was run in “isolation”. The isolation mode is discussed in Section Running GMT in isolation mode.\n\nIn addition to those parameters that directly affect the plot there are numerous parameters than modify units, scales, etc. For a complete listing, see the gmt.conf man pages. We suggest that you go through all the available parameters at least once so that you know what is available to change via one of the described mechanisms. The gmt.conf file can be cleared by running gmt clear conf.\n\n12.3. Command line arguments¶\n\nEach program requires certain arguments specific to its operation. These are explained in the manual pages and in the usage messages. We have tried to choose letters of the alphabet which stand for the argument so that they will be easy to remember. Each argument specification begins with a hyphen (except input file names; see below), followed by a letter, and sometimes a number or character string immediately after the letter. Do not space between the hyphen, letter, and number or string. Do space between options. Example:\n\ngmt pscoast -R0/20/0/20 -Ggray -JM6i -Wthin -B5 -V -P > map.ps\n\n12.4. Standardized command line options¶\n\nMost of the programs take many of the same arguments such as those related to setting the data region, the map projection, etc. The 26 switches in Table switches have the same meaning in all the programs (although some programs may not use all of them). These options will be described here as well as in the manual pages, as is vital that you understand how to use these options. We will present these options in order of importance (some are used a lot more than others).\n\n-B Define tick marks, annotations, and labels for basemaps and axes -J Select a map projection or coordinate transformation -K Allow more plot code to be appended to this plot later -O Allow this plot code to be appended to an existing plot -P Select Portrait plot orientation [Default is landscape] -R Define the extent of the map/plot region -U Plot a time-stamp, by default in the lower left corner of page -V Select verbose operation; reporting on progress -X Set the x-coordinate for the plot origin on the page -Y Set the y-coordinate for the plot origin on the page -a Associate aspatial data from OGR/GMT files with data columns -b Select binary input and/or output -d Replace user nodata values with IEEE NaNs -e Only process data records that match a pattern -f Specify the data format on a per column basis -g Identify data gaps based on supplied criteria -h Specify that input/output tables have header record(s) -i Specify which input columns to read -n Specify grid interpolation settings -o Specify which output columns to write -p Control perspective views for plots -r Set the grid registration to pixel [Default is gridline] -s Control output of records containing one or more NaNs -t Change layer PDF transparency -x Set number of cores to be used in multi-threaded applications -: Assume input geographic data are (lat,lon) and not (lon,lat)\n\n12.4.1. Data domain or map region: The -R option¶\n\nThe -R option defines the map region or data domain of interest. It may be specified in one of four ways, two of which are shown in Figure Map region:\n\n-Rxmin/xmax/ymin/ymax. This is the standard way to specify Cartesian data domains and geographical regions when using map projections where meridians and parallels are rectilinear.\n\n-Rxlleft/ylleft/xuright/yuright+r. This form is used with map projections that are oblique, making meridians and parallels poor choices for map boundaries. Here, we instead specify the lower left corner and upper right corner geographic coordinates, followed by the modifier +r. This form guarantees a rectangular map even though lines of equal longitude and latitude are not straight lines.\n\n-Rgridfile. This will copy the domain settings found for the grid in specified file. Note that depending on the nature of the calling program, this mechanism will also set grid spacing and possibly the grid registration (see Section Grid registration: The -r option).\n\n-Rcodex0/y0/nx/ny. This method can be used when creating grids. Here, code is a 2-character combination of L, C, R (for left, center, or right) and T, M, B for top, middle, or bottom. e.g., BL for lower left. This indicates which point on a rectangular grid region the x0/y0 coordinates refer to, and the grid dimensions nx and ny are used with grid spacings given via -I to create the corresponding region.\n\nFor rectilinear projections the first two forms give identical results. Depending on the selected map projection (or the kind of expected input data), the boundary coordinates may take on several different formats:\n\nGeographic coordinates:\n\nThese are longitudes and latitudes and may be given in decimal degrees (e.g., -123.45417) or in the [±]ddd[:mm[:ss[.xxx]]][W|E|S|N] format (e.g., 123:27:15W). Note that -Rg and -Rd are shorthands for “global domain” -R0/360/-90/90 and -R-180/180/-90/90, respectively.\n\nWhen used in conjunction with the Cartesian Linear Transformation (-Jx or -JX) —which can be used to map floating point data, geographical coordinates, as well as time coordinates— it is prudent to indicate that you are using geographical coordinates in one of the following ways:\n\nUse -Rg or -Rd to indicate the global domain.\n\nUse -Rgxmin/xmax/ymin/ymax to indicate a limited geographic domain.\n\nAdd W, E, S, or N to the coordinate limits or add the generic D or G. Example: -R0/360G/-90/90N.\n\nAlternatively, you may indicate geographical coordinates by supplying -fg; see Section Data type selection: The -f option.\n\nProjected coordinates:\n\nThese are Cartesian projected coordinates compatible with the chosen projection and are given in a length unit set via the +u modifier, (e.g., -200/200/-300/300+uk for a 400 by 600 km rectangular area centered on the projection center (0, 0). These coordinates are internally converted to the corresponding geographic (longitude, latitude) coordinates for the lower left and upper right corners. This form is convenient when you want to specify a region directly in the projected units (e.g., UTM meters). For allowable units, see Table distunits.\n\nCalendar time coordinates:\n\nThese are absolute time coordinates referring to a Gregorian or ISO calendar. The general format is [date]T[clock], where date must be in the yyyy[-mm[-dd]] (year, month, day-of-month) or yyyy[-jjj] (year and day-of-year) for Gregorian calendars and yyyy[-Www[-d]] (year, week, and day-of-week) for the ISO calendar. If no date is given we assume the current day. The T flag is required if a clock is given.\n\nThe optional clock string is a 24-hour clock in hh[:mm[:ss[.xxx]]] format. If no clock is given it implies 00:00:00, i.e., the start of the specified day. Note that not all of the specified entities need be present in the data. All calendar date-clock strings are internally represented as double precision seconds since proleptic Gregorian date Monday January 1 00:00:00 0001. Proleptic means we assume that the modern calendar can be extrapolated forward and backward; a year zero is used, and Gregory’s reforms are extrapolated backward. Note that this is not historical.\n\nRelative time coordinates:\n\nThese are coordinates which count seconds, hours, days or years relative to a given epoch. A combination of the parameters TIME_EPOCH and TIME_UNIT define the epoch and time unit. The parameter TIME_SYSTEM provides a few shorthands for common combinations of epoch and unit, like j2000 for days since noon of 1 Jan 2000. The default relative time coordinate is that of UNIX computers: seconds since 1 Jan 1970. Denote relative time coordinates by appending the optional lower case t after the value. When it is otherwise apparent that the coordinate is relative time (for example by using the -f switch), the t can be omitted.\n\nOther coordinates:\n\nThese are simply any coordinates that are not related to geographic or calendar time or relative time and are expected to be simple floating point values such as [±]xxx.xxx[E|e|D|d[±]xx], i.e., regular or exponential notations, with the enhancement to understand FORTRAN double precision output which may use D instead of E for exponents. These values are simply converted as they are to internal representation.\n\n12.4.2. Coordinate transformations and map projections: The -J option¶\n\nThis option selects the coordinate transformation or map projection. The general format is\n\n-J\\(\\delta\\)[parameters/]scale. Here, \\(\\delta\\) is a lower-case letter of the alphabet that selects a particular map projection, the parameters is zero or more slash-delimited projection parameter, and scale is map scale given in distance units per degree or as 1:xxxxx.\n\n-J\\(\\Delta\\)[parameters/]width. Here, \\(\\Delta\\) is an upper-case letter of the alphabet that selects a particular map projection, the parameters is zero or more slash-delimited projection parameter, and width is map width (map height is automatically computed from the implied map scale and region).\n\nSince GMT version 4.3.0, there is an alternative way to specify the projections: use the same abbreviation as in the mapping package Proj4. The options thus either look like:\n\n-Jabbrev/[parameters/]scale. Here, abbrev is a lower-case abbreviation that selects a particular map projection, the parameters is zero or more slash-delimited projection parameter, and scale is map scale given in distance units per degree or as 1:xxxxx.\n\n-JAbbrev/[parameters/]width. Here, Abbrev is an capitalized abbreviation that selects a particular map projection, the parameters is zero or more slash-delimited projection parameter, and width is map width (map height is automatically computed from the implied map scale and region).\n\nThe projections available in GMT are presented in Figure The over-30 map projections and coordinate transformations available in GMT. For details on all GMT projections and the required parameters, see the psbasemap man page. We will also show examples of every projection in the next Chapters, and a quick summary of projection syntax was given in Chapter GMT Overview and Quick Reference.\n\n12.4.3. Map frame and axes annotations: The -B option¶\n\nThis is potentially the most complicated option in GMT, but most examples of its usage are actually quite simple. We distinguish between to sets of information: Frame settings and Axes parameters. These are set separately by their own -B invocations; hence multiple -B specifications may be specified. The frame settings covers things such as which axes should be plotted, canvas fill, plot title, and what type of gridlines be drawn, whereas the Axes settings deal with annotation, tick, and gridline intervals, axes labels, and annotation units.\n\nThe Frame settings are specified by\n\n-B[axes][+b][+gfill][+n][+olon/lat][+ttitle]\n\nHere, the optional axes dictates which of the axes should be drawn and possibly annotated. By default, all 4 map boundaries (or plot axes) are plotted (denoted W, E, S, N). To change this selection, append the codes for those you want (e.g., WSn). In this example, the lower case n denotes to draw the axis and (major and minor) tick marks on the “northern” (top) edge of the plot. The upper case WS will annotate the “western” and “southern” axes with numerals and plot the any axis labels in addition to draw axis/tick-marks. For 3-D plots you can also specify Z or z. By default a single vertical axes will then be plotted at the most suitable map corner. You can override this by appending any combination of corner ids 1234, where 1 represents the lower left corner and the order goes counter-clockwise. Append +b to draw the outline of the 3-D box defined by -R; this modifier is also needed to display gridlines in the x--z, y--z planes. You may paint the map canvas by appending the +gfill modifier [Default is no fill]. If gridlines are specified via the Axes parameters (discussed below) then by default these are referenced to the North pole. If, however, you wish to produce oblique gridlines about another pole you can append +olon/lat to change this behavior (the modifier is ignored if no gridlines are requested). Append +n to have no frame and annotations at all [Default is controlled by the codes]. Finally, you may optionally add +ttitle to place a title that will appear centered above the plot frame.\n\nThe Axes settings are specified by\n\n-B[p|s][x|x|z]intervals[+llabel][+pprefix][+uunit]\n\nbut you may also split this into two separate invocations for clarity, i.e.,\n\n-B[p|s][x|y|z][+llabel][+pprefix][+uunit]\n\n-B[p|s][x|y|z]intervals\n\nThe first optional flag following -B selects p (rimary) [Default] or s (econdary) axes information (which is mostly used for time axes annotations; see examples below). The next optional flags specifies which axes you are providing information for. This can be an individual axis (e.g., just x) or a combination (e.g., xz). If none are given then we default to xy. Thus, if you wish to give different annotation intervals or labels for the various axes then you must repeat the B option for each axis. To add a label to an axis, just append +llabel. If the axis annotation should have a leading text prefix (e.g., dollar sign for those plots of your net worth) you can append +pprefix. For geographic maps the addition of degree symbols, etc. is automatic (and controlled by the GMT default setting FORMAT_GEO_MAP). However, for other plots you can add specific units by adding +uunit. If any of these text strings contain spaces or special UNIX characters you will need to enclose them in quotes. The intervals specification is a concatenated string made up of substrings of the form\n\n[t]stride[phase][u].\n\nThe t flag sets the axis item of interest; the available items are listed in Table inttype. Normally, equidistant annotations occur at multiples of stride; you can phase-shift this by appending phase, which can be a positive or negative number.\n\nFlag Description a Annotation and major tick spacing f Minor tick spacing g Grid line spacing\n\nNote that the appearance of certain time annotations (month-, week-, and day-names) may be affected by the GMT_LANGUAGE, FORMAT_TIME_PRIMARY_MAP, and FORMAT_TIME_SECONDARY_MAP settings.\n\nFor automated plots the region may not always be the same and thus it can be difficult to determine the appropriate stride in advance. Here GMT provides the opportunity to auto-select the spacing between the major and minor ticks and the grid lines, by not specifying the stride value. For example, -Bafg will select all three spacings automatically for both axes. In case of longitude--latitude plots, this will keep the spacing the same on both axes. You can also use -Bafg/afg to auto-select them separately.\n\nIn the case of automatic spacing, when the stride argument is omitted after g, the grid line spacing is chosen the same as the minor tick spacing; unless g is used in consort with a, then the grid lines are spaced the same as the annotations.\n\nThe unit flag u can take on one of 18 codes; these are listed in Table units. Almost all of these units are time-axis specific. However, the m and s units will be interpreted as arc minutes and arc seconds, respectively, when a map projection is in effect.\n\nFlag Unit Description Y year Plot using all 4 digits y year Plot using last 2 digits O month Format annotation using FORMAT_DATE_MAP o month Plot as 2-digit integer (1--12) U ISO week Format annotation using FORMAT_DATE_MAP u ISO week Plot as 2-digit integer (1--53) r Gregorian week 7-day stride from start of week (see TIME_WEEK_START) K ISO weekday Plot name of weekday in selected language k weekday Plot number of day in the week (1--7) (see TIME_WEEK_START) D date Format annotation using FORMAT_DATE_MAP d day Plot day of month (1--31) or day of year (1--366) (see FORMAT_DATE_MAP R day Same as d; annotations aligned with week (see TIME_WEEK_START) H hour Format annotation using FORMAT_CLOCK_MAP h hour Plot as 2-digit integer (0--24) M minute Format annotation using FORMAT_CLOCK_MAP m minute Plot as 2-digit integer (0--60) S seconds Format annotation using FORMAT_CLOCK_MAP s seconds Plot as 2-digit integer (0--60)\n\nAs mentioned, there may be two levels of annotations. Here, “primary” refers to the annotation that is closest to the axis (this is the primary annotation), while “secondary” refers to the secondary annotation that is plotted further from the axis. The examples below will clarify what is meant. Note that the terms “primary” and “secondary” do not reflect any hierarchical order of units: The “primary” annotation interval is usually smaller (e.g., days) while the “secondary” annotation interval typically is larger (e.g., months).\n\n12.4.3.1. Geographic basemaps¶\n\nGeographic basemaps may differ from regular plot axis in that some projections support a “fancy” form of axis and is selected by the MAP_FRAME_TYPE setting. The annotations will be formatted according to the FORMAT_GEO_MAP template and MAP_DEGREE_SYMBOL setting. A simple example of part of a basemap is shown in Figure Geographic map border.\n\nThe machinery for primary and secondary annotations introduced for time-series axes can also be utilized for geographic basemaps. This may be used to separate degree annotations from minutes- and seconds-annotations. For a more complicated basemap example using several sets of intervals, including different intervals and pen attributes for grid lines and grid crosses, see Figure Complex basemap.\n\n12.4.3.2. Cartesian linear axes¶\n\nFor non-geographic axes, the MAP_FRAME_TYPE setting is implicitly set to plain. Other than that, cartesian linear axes are very similar to geographic axes. The annotation format may be controlled with the FORMAT_FLOAT_OUT parameter. By default, it is set to “%g”, which is a C language format statement for floating point numbers , and with this setting the various axis routines will automatically determine how many decimal points should be used by inspecting the stride settings. If FORMAT_FLOAT_OUT is set to another format it will be used directly (.e.g, “%.2f” for a fixed, two decimals format). Note that for these axes you may use the unit setting to add a unit string to each annotation (see Figure Axis label).\n\n12.4.3.3. Cartesian log10 axes¶\n\nDue to the logarithmic nature of annotation spacings, the stride parameter takes on specific meanings. The following concerns are specific to log axes (see Figure Logarithmic projection axis):\n\nstride must be 1, 2, 3, or a negative integer -n. Annotations/ticks will then occur at 1, 1-2-5, or 1,2,3,4,…,9, respectively, for each magnitude range. For -n the annotations will take place every n’th magnitude.\n\nAppend l to stride. Then, log10 of the annotation is plotted at every integer log10 value (e.g., x = 100 will be annotated as “2”) [Default annotates x as is].\n\nAppend p to stride. Then, annotations appear as 10 raised to log10 of the value (e.g., 10-5).\n\n12.4.3.4. Cartesian exponential axes¶\n\nNormally, stride will be used to create equidistant (in the user’s unit) annotations or ticks, but because of the exponential nature of the axis, such annotations may converge on each other at one end of the axis. To avoid this problem, you can append p to stride, and the annotation interval is expected to be in transformed units, yet the annotation itself will be plotted as un-transformed units (see Figure Power projection axis). E.g., if stride = 1 and power = 0.5 (i.e., sqrt), then equidistant annotations labeled 1, 4, 9, … will appear.\n\n12.4.3.5. Cartesian time axes¶\n\nWhat sets time axis apart from the other kinds of plot axes is the numerous ways in which we may want to tick and annotate the axis. Not only do we have both primary and secondary annotation items but we also have interval annotations versus tick-mark annotations, numerous time units, and several ways in which to modify the plot. We will demonstrate this flexibility with a series of examples. While all our examples will only show a single x-axis (south, selected via -BS), time-axis annotations are supported for all axes.\n\nOur first example shows a time period of almost two months in Spring 2000. We want to annotate the month intervals as well as the date at the start of each week:\n\ngmt set FORMAT_DATE_MAP=-o FONT_ANNOT_PRIMARY +9p gmt psbasemap -R2000-4-1T/2000-5-25T/0/1 -JX5i/0.2i -Bpa7Rf1d -Bsa1O -BS -P > GMT_-B_time1.ps\n\nThese commands result in Figure Cartesian time axis. Note the leading hyphen in the FORMAT_DATE_MAP removes leading zeros from calendar items (e.g., 02 becomes 2).\n\nThe next example shows two different ways to annotate an axis portraying 2 days in July 1969:\n\ngmt set FORMAT_DATE_MAP \"o dd\" FORMAT_CLOCK_MAP hh:mm FONT_ANNOT_PRIMARY +9p gmt psbasemap -R1969-7-21T/1969-7-23T/0/1 -JX5i/0.2i -Bpa6Hf1h -Bsa1K -BS -P -K > GMT_-B_time2.ps gmt psbasemap -R -J -Bpa6Hf1h -Bsa1D -BS -O -Y0.65i >> GMT_-B_time2.ps\n\nThe lower example (Figure Cartesian time axis, example 2) chooses to annotate the weekdays (by specifying a1K) while the upper example choses dates (by specifying a1D). Note how the clock format only selects hours and minutes (no seconds) and the date format selects a month name, followed by one space and a two-digit day-of-month number.\n\nThe third example (Figure Cartesian time axis, example 3) presents two years, annotating both the years and every 3rd month.\n\ngmt set FORMAT_DATE_MAP o FORMAT_TIME_PRIMARY_MAP Character FONT_ANNOT_PRIMARY +9p gmt psbasemap -R1997T/1999T/0/1 -JX5i/0.2i -Bpa3Of1o -Bsa1Y -BS -P > GMT_-B_time3.ps\n\nNote that while the year annotation is centered on the 1-year interval, the month annotations must be centered on the corresponding month and not the 3-month interval. The FORMAT_DATE_MAP selects month name only and FORMAT_TIME_PRIMARY_MAP selects the 1-character, upper case abbreviation of month names using the current language (selected by GMT_LANGUAGE).\n\nThe fourth example (Figure Cartesian time axis, example 4) only shows a few hours of a day, using relative time by specifying t in the -R option while the TIME_UNIT is d (for days). We select both primary and secondary annotations, ask for a 12-hour clock, and let time go from right to left:\n\ngmt set FORMAT_CLOCK_MAP=-hham FONT_ANNOT_PRIMARY +9p TIME_UNIT d gmt psbasemap -R0.2t/0.35t/0/1 -JX-5i/0.2i -Bpa15mf5m -Bsa1H -BS -P > GMT_-B_time4.ps\n\nThe fifth example shows a few weeks of time (Figure Cartesian time axis, example 5). The lower axis shows ISO weeks with week numbers and abbreviated names of the weekdays. The upper uses Gregorian weeks (which start at the day chosen by TIME_WEEK_START); they do not have numbers.\n\ngmt set FORMAT_DATE_MAP u FORMAT_TIME_PRIMARY_MAP Character \\ FORMAT_TIME_SECONDARY_MAP full FONT_ANNOT_PRIMARY +9p gmt psbasemap -R1969-7-21T/1969-8-9T/0/1 -JX5i/0.2i -Bpa1K -Bsa1U -BS -P -K > GMT_-B_time5.ps gmt set FORMAT_DATE_MAP o TIME_WEEK_START Sunday FORMAT_TIME_SECONDARY_MAP Chararacter gmt psbasemap -R -J -Bpa3Kf1k -Bsa1r -BS -O -Y0.65i >> GMT_-B_time5.ps\n\nOur sixth example (Figure Cartesian time axis, example 6) shows the first five months of 1996, and we have annotated each month with an abbreviated, upper case name and 2-digit year. Only the primary axes information is specified.\n\ngmt set FORMAT_DATE_MAP \"o yy\" FORMAT_TIME_PRIMARY_MAP Abbreviated gmt psbasemap -R1996T/1996-6T/0/1 -JX5i/0.2i -Ba1Of1d -BS -P > GMT_-B_time6.ps\n\nOur seventh and final example (Figure Cartesian time axis, example 7) illustrates annotation of year-days. Unless we specify the formatting with a leading hyphen in FORMAT_DATE_MAP we get 3-digit integer days. Note that in order to have the two years annotated we need to allow for the annotation of small fractional intervals; normally such truncated interval must be at least half of a full interval.\n\ngmt set FORMAT_DATE_MAP jjj TIME_INTERVAL_FRACTION 0.05 FONT_ANNOT_PRIMARY +9p gmt psbasemap -R2000-12-15T/2001-1-15T/0/1 -JX5i/0.2i -Bpa5Df1d -Bsa1Y -BS -P > GMT_-B_time7.ps\n\n12.4.3.6. Custom axes¶\n\nIrregularly spaced annotations or annotations based on look-up tables can be implemented using the custom annotation mechanism. Here, we given the c (custom) type to the -B option followed by a filename that contains the annotations (and tick/grid-lines specifications) for one axis. The file can contain any number of comments (lines starting with #) and any number of records of the format\n\ncoord type [label]\n\nThe coord is the location of the desired annotation, tick, or grid-line, whereas type is a string composed of letters from a (annotation), i interval annotation, f frame tick, and g gridline. You must use either a or i within one file; no mixing is allowed. The coordinates should be arranged in increasing order. If label is given it replaces the normal annotation based on the coord value. Our last example (Figure Custom and irregular annotations) shows such a custom basemap with an interval annotations on the x-axis and irregular annotations on the y-axis.\n\ncat << EOF > xannots.txt 416.0 ig Devonian 443.7 ig Silurian 488.3 ig Ordovician 542 ig Cambrian EOF cat << EOF > yannots.txt 0 a 1 a 2 f 2.71828 ag e 3 f 3.1415926 ag @~p@~ 4 f 5 f 6 f 6.2831852 ag 2@~p@~ EOF gmt psbasemap -R416/542/0/6.2831852 -JX-5i/2.5i -Bpx25f5g25+u\" Ma\" -Bpycyannots.txt \\ -BWS+glightblue -P -K > GMT_-B_custom.ps gmt psbasemap -R416/542/0/6.2831852 -JX-5i/2.5i -Bsxcxannots.txt -BWS -O \\ --MAP_ANNOT_OFFSET_SECONDARY=10p --MAP_GRID_PEN_SECONDARY=2p >> GMT_-B_custom.ps rm -f [xy]annots.txt\n\n12.4.4. Portrait plot orientation: The -P option¶\n\nThe -P option selects Portrait plotting mode . In general, a plot has an x-axis increasing from left to right and a y-axis increasing from bottom to top. If the paper is turned so that the long dimension of the paper is parallel to the x-axis then the plot is said to have Landscape orientation. If the long dimension of the paper parallels the y-axis the orientation is called Portrait (think of taking pictures with a camera and these words make sense). The default Landscape orientation is obtained by translating the origin in the x-direction (by the width of the chosen paper PS_MEDIA) and then rotating the coordinate system counterclockwise by 90. By default the PS_MEDIA is set to Letter (or A4 if SI is chosen); this value must be changed when using different media, such as 11” x 17” or large format plotters (Figure Plot orientation).\n\n12.4.5. Plot overlays: The -K -O options¶\n\nThe -K and -O options control the generation of PostScript code for multiple overlay plots. All PostScript files must have a header (for initializations), a body (drawing the figure), and a trailer (printing it out) (see Figure Multiple overlay plots). Thus, when overlaying several GMT plots we must make sure that the first plot call omits the trailer, that all intermediate calls omit both header and trailer, and that the final overlay omits the header. The -K omits the trailer which implies that more PostScript code will be appended later [Default terminates the plot system]. The -O selects Overlay plot mode and omits the header information [Default initializes a new plot system]. Most unexpected results for multiple overlay plots can be traced to the incorrect use of these options. If you run only one plot program, ignore both the -O and -K options; they are only used when stacking plots.\n\n12.4.7. Verbose feedback: The -V option¶\n\nThe -V option selects verbose mode, which will send progress reports to standard error. Even more verbose levels are -Vl (long verbose) and -Vd (debug). Normal verbosity level produces only error and warning messages. This is the default or can be selected by using -Vn. If compiled with backward-compatibility support, the default is -Vc, which includes warnings about deprecated usage. Finally, -Vq can be used to run without any warnings or errors. This option can also be set by specifying the default GMT_VERBOSE, as quiet, normal, compat, verbose, long_verbose, or debug, in order of increased verbosity.\n\n12.4.8. Plot positioning and layout: The -X -Y options¶\n\nThe -X and -Y options shift origin of plot by (xoff,yoff) inches (Default is (MAP_ORIGIN_X, MAP_ORIGIN_Y) for new plots and (0,0) for overlays (-O)). By default, all translations are relative to the previous origin (see Figure Plot positioning). Supply offset as c to center the plot in that direction relative to the page margin. Absolute translations (i.e., relative to a fixed point (0,0) at the lower left corner of the paper) can be achieve by prepending “a” to the offsets. Subsequent overlays will be co-registered with the previous plot unless the origin is shifted using these options. The offsets are measured in the current coordinates system (which can be rotated using the initial -P option; subsequent -P options for overlays are ignored).\n\n12.4.9. OGR/GMT GIS i/o: The -a option¶\n\nGMT relies on external tools to translate geospatial files such as shapefiles into a format we can read. The tool ogr2ogr in the GDAL package can do such translations and preserve the aspatial metadata via a new OGR/GMT format specification (See Chapter The GMT Vector Data Format for OGR Compatibility). For this to be useful we need a mechanism to associate certain metadata values with required input and output columns expected by GMT programs. The -a option allows you to supply one or more comma-separated associations col=name, where name is the name of an aspatial attribute field in a OGR/GMT file and whose value we wish to as data input for column col. The given aspatial field thus replaces any other value already set. Note that col = 0 is the first data columns. Note that if no aspatial attributes are needed then the -a option is not needed -- GMT will still process and read such data files.\n\n12.4.9.1. OGR/GMT input with -a option¶\n\nIf you need to populate GMT data columns with (constant) values specified by aspatial attributes, use -a and append any number of comma-separated col=name associations. E.g., 2=depth will read the spatial x,y columns from the file and add a third (z) column based on the value of the aspatial field called depth. You can also associate aspatial fields with other settings such as labels, fill colors, pens, and values used to look-up colors. Do so by letting the col value be one of D, G, L, T, W, or Z. This works analogously to how standard multi-segment files can pass such options via its segment headers (See Chapter GMT file formats).\n\n12.4.9.2. OGR/GMT output with -a option¶\n\nYou can also make GMT table-writing tools output the OGR/GMT format directly. Again, specify if certain GMT data columns with constant values should be stored as aspatial metadata using the col=name[:type], where you can optionally specify what data type it should be (double, integer, string, logical, byte, or datetime) [double is default]. As for input, you can also use the special col entries of D, G, L, T, W, or Z to have values stored as options in segment headers be used as the source for the name aspatial field. Finally, for output you must append +ggeometry, where geometry can be any of [M]POINT|LINE|POLY; the M represent the multi-versions of these three geometries. Use upper-case +G to signal that you want to split any line or polygon features that straddle the Dateline.\n\n12.4.10. Binary table i/o: The -b option¶\n\nAll GMT programs that accept table data input may read ASCII, native binary, or netCDF tables. Native binary files may have a header section and the -hn option (see Section Header data records: The -h option) can be used to skip the first n bytes. The data record can be in any format, you may mix different data types and even byte-swap individual columns or the entire record. When using native binary data the user must be aware of the fact that GMT has no way of determining the actual number of columns in the file. You must therefore pass that information to GMT via the binary -bi nt option, where n is the number of data columns of given type t, where t must be one of c (signed 1-byte character, int8_t), u (unsigned 1-byte character, uint8_t), h (signed 2-byte int, int16_t), H (unsigned 2-byte int, uint16_t), i (signed 4-byte int, int32_t), I (unsigned 4-byte int, uint32_t), l (signed 8-byte int, int64_t), L (unsigned 8-byte int, uint64_t), f (4-byte single-precision float), and d (8-byte double-precision float). In addition, use x to skip n bytes anywhere in the record. For a mixed-type data record you can concatenate several [n]t combinations, separated by commas. You may append w to any of the items to force byte-swapping. Alternatively, append +L|B to indicate that the entire data file should be read or written as little- or big-endian, respectively. Here, n is the number of each item in your binary file. Note that n may be larger than m, the number of columns that the GMT program requires to do its task. If n is not given then it defaults to m and all columns are assumed to be of the single specified type t [d (double), if not set]. If n < m an error is generated. Multiple segment files are allowed and the segment headers are assumed to be records where all the fields equal NaN.\n\nFor native binary output, use the -bo option; see -bi for further details.\n\nBecause of its meta data, reading netCDF tables (i.e., netCDF files containing 1-dimensional arrays) is quite a bit less complex than reading native binary files. When feeding netCDF tables to programs like psxy, the program will automatically recognize the format and read whatever amount of columns are needed for that program. To steer which columns are to be read, the user can append the suffix ?var1/var2/… to the netCDF file name, where var1, var2, etc. are the names of the variables to be processed. No -bi option is needed in this case.\n\nCurrently, netCDF tables can only be input, not output. For more information, see Chapter GMT file formats.\n\n12.4.11. Missing data conversion: The -d option¶\n\nWithin GMT, any missing values are represented by the IEEE NaN value. However, there are occasionally the need to handle user data where missing data are represented by some unlikely data value such as -99999. Since GMT cannot guess that in your data set -99999 is a special value, you can use the -d option to have such values replaced with NaNs. Similarly, should your GMT output need to conform to such a requirement you can replace all NaNs with the chosen nodata value. If only input or output should be affected, use -di or -do, respectably.\n\n12.4.12. Data record pattern matching: The -e option¶\n\nModules that read ASCII tables will normally process all the data records that are read. The -e option offers a built in pattern scanner that will only pass records that match the given patterns or regular expressions. The test can also be inverted to only pass data records that do not match the pattern. The test does not apply to header or segment headers.\n\n12.4.13. Data type selection: The -f option¶\n\nWhen map projections are not required we must explicitly state what kind of data each input or output column contains. This is accomplished with the -f option. Following an optional i (for input only) or o (for output only), we append a text string with information about each column (or range of columns) separated by commas. Each string starts with the column number (0 is first column) followed by either x (longitude), y (latitude), T (absolute calendar time) or t (relative time). If several consecutive columns have the same format you may specify a range of columns rather than a single column, i.e., 0--4 for the first 5 columns. For example, if our input file has geographic coordinates (latitude, longitude) with absolute calendar coordinates in the columns 3 and 4, we would specify fi0y,1x,3--4T. All other columns are assumed to have the default, floating point format and need not be set individually. The shorthand -f[i|o]g means -f[i|o]0x,1y (i.e., geographic coordinates). A special use of -f is to select -fp[unit], which requires -J and lets you use projected map coordinates (e.g., UTM meters) as data input. Such coordinates are automatically inverted to longitude, latitude during the data import. Optionally, append a length unit (see Table distunits) [meter]. For more information, see Sections Input data formats and Output data formats.\n\n12.4.14. Data gap detection: The -g option¶\n\nGMT has several mechanisms that can determine line segmentation. Typically, data segments are separated by multiple segment header records (see Chapter GMT file formats). However, if key data columns contain a NaN we may also use that information to break lines into multiple segments. This behavior is modified by the parameter IO_NAN_RECORDS which by default is set to skip, meaning such records are considered bad and simply skipped. If you wish such records to indicate a segment boundary then set this parameter to pass. Finally, you may wish to indicate gaps based on the data values themselves. The -g option is used to detect gaps based on one or more criteria (use -g+ if all the criteria must be met; otherwise only one of the specified criteria needs to be met to signify a data gap). Gaps can be based on excessive jumps in the x- or y-coordinates (-gx or -gy), or on the distance between points (-gd). Append the gap distance and optionally a unit for actual distances. For geographic data the optional unit may be arc degree, minute, and second, or meter [Default], feet, kilometer, Miles, or nautical miles. For programs that map data to map coordinates you can optionally specify these criteria to apply to the projected coordinates (by using upper-case -gX, -gY or -gD). In that case, choose from centimeter, inch or point [Default unit is controlled by PROJ_LENGTH_UNIT]. Note: For -gx or -gy with time data the unit is instead controlled by TIME_UNIT.\n\n12.4.15. Header data records: The -h option¶\n\nThe -h[i|o][n_recs] option lets GMT know that input file(s) have n_recs header records [0]. If there are more than one header record you must specify the number after the -h option, e.g., -h4. Note that blank lines and records that start with the character # are automatically considered header records and skipped. Thus, n_recs refers to general text lines that do not start with # and thus must specifically be skipped in order for the programs to function properly. The default number of such header records if -h is used is one of the many parameters in the gmt.conf file (IO_N_HEADER_RECS, by default 0), but can be overridden by -hn_header_recs. Normally, programs that both read and write tables will output the header records that are found on input. Use -hi to suppress the writing of header records. You can use the -h options modifiers to to tell programs to output extra header records for titles, remarks or column names identifying each data column.\n\nWhen -b is used to indicate binary data the -h takes on a slightly different meaning. Now, the n_recs argument is taken to mean how many bytes should be skipped (on input) or padded with the space character (on output).\n\n12.4.16. Input columns selection: The -i option¶\n\nThe -icolumns option allows you to specify which input file data columns to use and in what order. By default, GMT will read all the data columns in the file, starting with the first column (0). Using -i modifies that process. For instance, to use the 4th, 7th, and 3rd data column as the required x,y,z to blockmean you would specify -i3,6,2 (since 0 is the first column). The chosen data columns will be used as is. Optionally, you can specify that input columns should be transformed according to a linear or logarithmic conversion. Do so by appending [l][sscale][ooffset] to each column (or range of columns). All items are optional: The l implies we should first take \\(\\log_{10}\\) of the data [leave as is]. Next, we may scale the result by the given scale [1]. Finally, we add in the specified offset [0].\n\n12.4.17. Grid interpolation parameters: The -n option¶\n\nThe -ntype option controls parameters used for 2-D grids resampling. You can select the type of spline used (-nb for B-spline smoothing, -nc for bicubic [Default], -nl for bilinear, or -nn for nearest-node value). For programs that support it, antialiasing is by default on; optionally, append +a to switch off antialiasing. By default, boundary conditions are set according to the grid type and extent. Change boundary conditions by appending +bBC, where BC is either g for geographic boundary conditions or one (or both) of n and p for natural or periodic boundary conditions, respectively. Append x or y to only apply the condition in one dimension. E.g., -nb+nxpy would imply natural boundary conditions in the x direction and periodic conditions in the y direction. Finally, append +tthreshold to control how close to nodes with NaN the interpolation should go. A threshold of 1.0 requires all (4 or 16) nodes involved in the interpolation to be non-NaN. 0.5 will interpolate about half way from a non-NaN value; 0.1 will go about 90% of the way, etc.\n\n12.4.18. Output columns selection: The -o option¶\n\nThe -ocolumns option allows you to specify which columns to write on output and in what order. By default, GMT will write all the data columns produced by the program. Using -o modifies that process. For instance, to write just the 4th and 2nd data column to the output you would use -o3,1 (since 0 is the first column). You can also use a column more than once, e.g., -o3,1,3, to duplicate a column on output.\n\n12.4.19. Perspective view: The -p option¶\n\nAll plotting programs that normally produce a flat, two-dimensional illustration can be told to view this flat illustration from a particular vantage point, resulting in a perspective view. You can select perspective view with the -p option by setting the azimuth and elevation of the viewpoint [Default is 180/90]. When -p is used in consort with -Jz or -JZ, a third value can be appended which indicates at which z-level all 2-D material, like the plot frame, is plotted (in perspective) [Default is at the bottom of the z-axis]. For frames used for animation, you may want to append + to fix the center of your data domain (or specify a particular world coordinate point with +wlon0/lat[z]) which will project to the center of your page size (or you may specify the coordinates of the projected view point with +vx0/y0. When -p is used without any further arguments, the values from the last use of -p in a previous GMT command will be used. Alternatively, you can perform a simple rotation about the z-axis by just giving the rotation angle. Optionally, use +v or +w to select another axis location than the plot origin.\n\n12.4.20. Grid registration: The -r option¶\n\nAll 2-D grids in GMT have their nodes organized in one of two ways, known as gridline- and pixel- registration. The GMT default is gridline registration; programs that allow for the creation of grids can use the -r option to select pixel registration instead. Most observed data tend to be in gridline registration while processed data sometime may be distributed in pixel registration. While you may convert between the two registrations this conversion looses the Nyquist frequency and dampens the other high frequencies. It is best to avoid any registration conversion if you can help it. Planning ahead may be important.\n\n12.4.20.1. Gridline registration¶\n\nIn this registration, the nodes are centered on the grid line intersections and the data points represent the average value in a cell of dimensions (\\(x_{inc} \\cdot y_{inc}\\)) centered on each node (left side of Figure Grid registration). In the case of grid line registration the number of nodes are related to region and grid spacing by\n\n\\[\\begin{split}\\begin{array}{ccl} nx & = & (x_{max} - x_{min}) / x_{inc} + 1 \\\\ ny & = & (y_{max} - y_{min}) / y_{inc} + 1 \\end{array}\\end{split}\\]\n\nwhich for the example in left side of Figure Gridline registration yields nx = ny = 4.\n\n12.4.20.2. Pixel registration¶\n\nHere, the nodes are centered in the grid cells, i.e., the areas between grid lines, and the data points represent the average values within each cell (right side of Figure Grid registration). In the case of pixel registration the number of nodes are related to region and grid spacing by\n\n\\[\\begin{split}\\begin{array}{ccl} nx & = & (x_{max} - x_{min}) / x_{inc} \\\\ ny & = & (y_{max} - y_{min}) / y_{inc} \\end{array}\\end{split}\\]\n\nThus, given the same region (-R) and grid spacing, the pixel-registered grids have one less column and one less row than the gridline-registered grids; here we find nx = ny = 3.\n\n12.4.21. NaN-record treatment: The -s option¶\n\nWe can use this option to suppress output for records whose z-value equals NaN (by default we output all records). Alternatively, append r to reverse the suppression, i.e., only output the records whose z-value equals NaN. Use -sa to suppress output records where one or more fields (and not necessarily z) equal NaN. Finally, you can supply a comma-separated list of all columns or column ranges to consider for this NaN test.\n\n12.4.22. Layer PDF transparency: The -t option¶\n\nWhile the PostScript language does not support transparency, PDF does, and via PostScript extensions one can manipulate the transparency levels of objects. The -t option allows you to change the transparency level for the current overlay by appending a percentage in the 0--100 range; the default is 0, or opaque. Transparency may also be controlled on a feature by feature basis when setting color or fill (see section Specifying area fill attributes).\n\n12.4.23. Latitude/Longitude or Longitude/Latitude?: The -: option¶\n\nFor geographical data, the first column is expected to contain longitudes and the second to contain latitudes. To reverse this expectation you must apply the -: option. Optionally, append i or o to restrict the effect to input or output only. Note that command line arguments that may take geographic coordinates (e.g., -R) always expect longitude before latitude. Also, geographical grids are expected to have the longitude as first (minor) dimension.\n\n12.5. Command line history¶\n\nGMT programs “remember” the standardized command line options (See Section Standardized command line options) given during their previous invocations and this provides a shorthand notation for complex options. For example, if a basemap was created with an oblique Mercator projection, specified as\n\n-Joc170W/25:30S/33W/56:20N/1:500000\n\nthen a subsequent psxy command to plot symbols only needs to state -Jo in order to activate the same projection. In contrast, note that -J by itself will pick the most recently used projection. Previous commands are maintained in the file gmt.history, of which there will be one in each directory you run the programs from. This is handy if you create separate directories for separate projects since chances are that data manipulations and plotting for each project will share many of the same options. Note that an option spelled out on the command line will always override the previous entry in the gmt.history file and, if execution is successful, will replace this entry as the previous option argument in the gmt.history file. If you call several GMT modules piped together then GMT cannot guarantee that the gmt.history file is processed in the intended order from left to right. The only guarantee is that the file will not be clobbered since GMT uses advisory file locking. The uncertainty in processing order makes the use of shorthands in pipes unreliable. We therefore recommend that you only use shorthands in single process command lines, and spell out the full command option when using chains of commands connected with pipes. The history can be cleared by running gmt clear history.\n\n12.6. Usage messages, syntax- and general error messages¶\n\nEach program carries a usage message. If you enter the program name without any arguments, the program will write the complete usage message to standard error (your screen, unless you redirect it). This message explains in detail what all the valid arguments are. If you enter the program name followed by a hyphen (-) only you will get a shorter version which only shows the command line syntax and no detailed explanations. If you incorrectly specify an option or omit a required option, the program will produce syntax errors and explain what the correct syntax for these options should be. If an error occurs during the running of a program, the program will in some cases recognize this and give you an error message. Usually this will also terminate the run. The error messages generally begin with the name of the program in which the error occurred; if you have several programs piped together this tells you where the trouble is.\n\n12.7. Standard input or file, header records¶\n\nMost of the programs which expect table data input can read either standard input or input in one or several files. These programs will try to read stdin unless you type the filename(s) on the command line without the above hyphens. (If the program sees a hyphen, it reads the next character as an instruction; if an argument begins without a hyphen, it tries to open this argument as a filename). This feature allows you to connect programs with pipes if you like. If your input is ASCII and has one or more header records that do not begin with #, you must use the -h option (see Section Header data records: The -h option). ASCII files may in many cases also contain segment-headers separating data segments. These are called “multi-segment files”. For binary table data the -h option may specify how many bytes should be skipped before the data section is reached. Binary files may also contain segment-headers separating data segments. These segment-headers are simply data records whose fields are all set to NaN; see Chapter GMT file formats for complete documentation.\n\nIf filenames are given for reading, GMT programs will first look for them in the current directory. If the file is not found, the programs will look in other directories pointed to by the directory parameters DIR_DATA, directory parameters DIR_CACHE and or by the environmental parameters $GMT_USERDIR, $GMT_CACHEDIR and $GMT_DATADIR (if set). They may be set by the user to point to directories that contain data sets of general use, thus eliminating the need to specify a full path to these files. Usually, the DIR_DATA directory will hold data sets of a general nature (tables, grids), whereas the $GMT_USERDIR directory (its default value is $HOME/.gmt) may hold miscellaneous data sets more specific to the user; this directory also stores GMT defaults and other configuration files. The DIR_CACHE will typically contain data files downloaded automatically by GMT modules. See directory parameters for details. Program output is always written to the current directory unless a full path has been specified.\n\n12.8. URLs and special files¶\n\nThree classes of files are given special treatment in GMT.\n\nSome data sets are ubiquitous and used by nearly all GMT users. At the moment this set is limited to Earth relief grids. If you reference files called earth_relief_res.grd on a command line then that grid will automatically be downloaded from the GMT Data Site and placed in $GMT_USERDIR [~/.gmt]. The resolution res allows a choice among 13 command grid spacings: 60m, 30m, 20m, 15m, 10m, 6m, 5m, 4m, 3m, 2m, 1m, 30s, and 15s (with file sizes 111 kb, 376 kb, 782 kb, 1.3 Mb, 2.8 Mb, 7.5 Mb, 11 Mb, 16 Mb, 27 Mb, 58 Mb, 214 Mb, 778 Mb, and 2.6 Gb respectively). Once one of these have been downloaded any future reference will simply obtain the file from $GMT_USERDIR (except if explicitly removed by the user). Note: The four highest resolutions are the original data sets SRTM15+, SRTM30+, ETOPO1 and ETOPO2V2. Lower resolutions are spherically Gaussian-filtered versions of ETOPO1.\n\nIf a file is given as a full URL, starting with http://, https://, or ftp://, then the file will be downloaded to DIR_CACHE and subsequently read from there (until removed by the user). If the URL is actually a CGI Get command (i.e., ends in ?par=val1&par2=val2…) then we download the file each time we encounter the URL.\n\nDemonstration files used in online documentation, example scripts, or even the large test suite may be given in the format @filename. When such a file is encountered on the command line it is understood to be a short-hand representation of the full URL to filename on the GMT Cache Data FTP site. Since this address may change over time we use the leading @ to simplify access to these files. Such files will also be downloaded to DIR_CACHE and subsequently read from there (until removed by the user).\n\nThe user cache (DIR_CACHE) and all its contents can be cleared any time via the command gmt clear cache.\n\n12.9. Verbose operation¶\n\nMost of the programs take an optional -V argument which will run the program in the “verbose” mode (see Section Verbose feedback: The -V option). Verbose will write to standard error information about the progress of the operation you are running. Verbose reports things such as counts of points read, names of data files processed, convergence of iterative solutions, and the like. Since these messages are written to stderr, the verbose talk remains separate from your data output. You may optionally choose among five models of verbosity; each mode adds more messages with an increasing level of details. The modes are\n\nq Complete silence, not even fatal error messages.\n\nn Warnings and progress messages [Default].\n\nc Warnings about deprecated usage (if compiled for compatibility).\n\nl Detailed progress messages.\n\nd Debugging messages.\n\nThe verbosity is cumulative, i.e., mode l means all messages of mode n as well. will be reported.\n\n12.10. Program output¶\n\nMost programs write their results, including PostScript plots, to standard output. The exceptions are those which may create binary netCDF grid files such as surface (due to the design of netCDF a filename must be provided; however, alternative binary output formats allowing piping are available; see Section Grid file format specifications). Most operating systems let you can redirect standard output to a file or pipe it into another process. Error messages, usage messages, and verbose comments are written to standard error in all cases. You can usually redirect standard error as well, if you want to create a log file of what you are doing. The syntax for redirection differ among the main shells (Bash and C-shell) and is a bit limited in DOS.\n\n12.11. Input data formats¶\n\nMost of the time, GMT will know what kind of x and y coordinates it is reading because you have selected a particular coordinate transformation or map projection. However, there may be times when you must explicitly specify what you are providing as input using the -f switch. When binary input data are expected (-bi) you must specify exactly the format of the records. However, for ASCII input there are numerous ways to encode data coordinates (which may be separated by white-space or commas). Valid input data are generally of the same form as the arguments to the -R option (see Section Data domain or map region: The -R option), with additional flexibility for calendar data. Geographical coordinates, for example, can be given in decimal degrees (e.g., -123.45417) or in the [±]ddd[:mm[:ss[.xxx]]][W|E|S|N] format (e.g., 123:27:15W). With -fp you may even supply projected data like UTM coordinates.\n\nBecause of the widespread use of incompatible and ambiguous formats, the processing of input date components is guided by the template FORMAT_DATE_IN in your gmt.conf file; it is by default set to yyyy-mm-dd. Y2K-challenged input data such as 29/05/89 can be processed by setting FORMAT_DATE_IN to dd/mm/yy. A complete description of possible formats is given in the gmt.conf man page. The clock string is more standardized but issues like 12- or 24-hour clocks complicate matters as well as the presence or absence of delimiters between fields. Thus, the processing of input clock coordinates is guided by the template FORMAT_CLOCK_IN which defaults to hh:mm:ss.xxx.\n\nGMT programs that require a map projection argument will implicitly know what kind of data to expect, and the input processing is done accordingly. However, some programs that simply report on minimum and maximum values or just do a reformatting of the data will in general not know what to expect, and furthermore there is no way for the programs to know what kind of data other columns (beyond the leading x and y columns) contain. In such instances we must explicitly tell GMT that we are feeding it data in the specific geographic or calendar formats (floating point data are assumed by default). We specify the data type via the -f option (which sets both input and output formats; use -fi and -fo to set input and output separately). For instance, to specify that the the first two columns are longitude and latitude, and that the third column (e.g., z) is absolute calendar time, we add -fi0x,1y,2T to the command line. For more details, see the man page for the program you need to use.\n\n12.12. Output data formats¶\n\nThe numerical output from GMT programs can be binary (when -bo is used) or ASCII [Default]. In the latter case the issue of formatting becomes important. GMT provides extensive machinery for allowing just about any imaginable format to be used on output. Analogous to the processing of input data, several templates guide the formatting process. These are FORMAT_DATE_OUT and FORMAT_CLOCK_OUT for calendar-time coordinates, FORMAT_GEO_OUT for geographical coordinates, and FORMAT_FLOAT_OUT for generic floating point data. In addition, the user have control over how columns are separated via the IO_COL_SEPARATOR parameter. Thus, as an example, it is possible to create limited FORTRAN-style card records by setting FORMAT_FLOAT_OUT to %7.3lf and IO_COL_SEPARATOR to none [Default is tab].\n\n12.13. PostScript features¶\n\nPostScript is a command language for driving graphics devices such as laser printers. It is ASCII text which you can read and edit as you wish (assuming you have some knowledge of the syntax). We prefer this to binary metafile plot systems since such files cannot easily be modified after they have been created. GMT programs also write many comments to the plot file which make it easier for users to orient themselves should they need to edit the file (e.g., % Start of x-axis) . All GMT programs create PostScript code by calling the PSL plot library (The user may call these functions from his/her own C or FORTRAN plot programs. See the manual pages for PSL syntax). Although GMT programs can create very individualized plot code, there will always be cases not covered by these programs. Some knowledge of PostScript will enable the user to add such features directly into the plot file. By default, GMT will produce freeform PostScript output with embedded printer directives. To produce Encapsulated PostScript (EPS) that can be imported into graphics programs such as CorelDraw, Illustrator or InkScape for further embellishment, simply run gmt psconvert -Te. See Chapter Including GMT Graphics into your Documents for an extensive discussion of converting PostScript to other formats.\n\n12.14. Specifying pen attributes¶\n\nA pen in GMT has three attributes: width, color, and style. Most programs will accept pen attributes in the form of an option argument, with commas separating the given attributes, e.g.,\n\n-W[width[c|i|p]],[color],[style[c|i|p|]]\n\nWidth is by default measured in points (1/72 of an inch). Append c, i, or p to specify pen width in cm, inch, or points, respectively. Minimum-thickness pens can be achieved by giving zero width. The result is device-dependent but typically means that as you zoom in on the feature in a display, the line thickness stays at the minimum. Finally, a few predefined pen names can be used: default, faint, and {thin, thick, fat}[er|est], and obese. Table pennames shows this list and the corresponding pen widths.\n\nfaint 0 thicker 1.5p default 0.25p thickest 2p thinnest 0.25p fat 3p thinner 0.50p fatter 6p thin 0.75p fattest 12p thick 1.0p obese 18p\n\nThe color can be specified in five different ways:\n\nGray. Specify a gray shade in the range 0--255 (linearly going from black [0] to white [255]).\n\nRGB. Specify r/g/b, each ranging from 0--255. Here 0/0/0 is black, 255/255/255 is white, 255/0/0 is red, etc.\n\nHSV. Specify hue-saturation-value, with the former in the 0--360 degree range while the latter two take on the range 0--1 .\n\nCMYK. Specify cyan/magenta/yellow/black, each ranging from 0--100%.\n\nName. Specify one of 663 valid color names. Use man gmtcolors to list all valid names. A very small yet versatile subset consists of the 29 choices white, black, and [light|dark]{red, orange, yellow, green, cyan, blue, magenta, gray|grey, brown}. The color names are case-insensitive, so mixed upper and lower case can be used (like DarkGreen).\n\nThe style attribute controls the appearance of the line. Giving “dotted” or “.” yields a dotted line, whereas a dashed pen is requested with “dashed” or “-“. Also combinations of dots and dashes, like “.-” for a dot-dashed line, are allowed. To override a default style and secure a solid line you can specify “solid” for style. The lengths of dots and dashes are scaled relative to the pen width (dots has a length that equals the pen width while dashes are 8 times as long; gaps between segments are 4 times the pen width). For more detailed attributes including exact dimensions you may specify string:offset, where string is a series of numbers separated by underscores. These numbers represent a pattern by indicating the length of line segments and the gap between segments. The offset phase-shifts the pattern from the beginning the line. For example, if you want a yellow line of width 0.1 cm that alternates between long dashes (4 points), an 8 point gap, then a 5 point dash, then another 8 point gap, with pattern offset by 2 points from the origin, specify -W0.1c,yellow,4_8_5_8:2p. Just as with pen width, the default style units are points, but can also be explicitly specified in cm, inch, or points (see width discussion above).\n\nTable penex contains additional examples of pen specifications suitable for, say, psxy.\n\n-W0.5p 0.5 point wide line of default color and style -Wgreen Green line with default width and style -Wthin,red,- Dashed, thin red line -Wfat,. Fat dotted line with default color -W0.1c,120-1-1 Green (in h-s-v) pen, 1 mm thick -Wfaint,100/0/0/0,..- Very thin, cyan (in c/m/y/k), dot-dot-dashed line\n\nIn addition to these pen settings there are several PostScript settings that can affect the appearance of lines. These are controlled via the GMT defaults settings PS_LINE_CAP, PS_LINE_JOIN, and PS_MITER_LIMIT. They determine how a line segment ending is rendered, be it at the termination of a solid line or at the end of all dashed line segments making up a line, and how a straight lines of finite thickness should behave when joined at a common point. By default, line segments have rectangular ends, but this can change to give rounded ends. When PS_LINE_CAP is set to round the a segment length of zero will appear as a circle. This can be used to created circular dotted lines, and by manipulating the phase shift in the style attribute and plotting the same line twice one can even alternate the color of adjacent items. Figure Line appearance shows various lines made in this fashion. See the gmt.conf man page for more information.\n\n12.15. Specifying line attributes¶\n\nA line is drawn with the texture provided by the chosen pen (Specifying pen attributes). However, depending on the module, a line also may have other attributes that can be changed in some modules. Given as modifiers to a pen specification, one or more modifiers may be appended to a pen specification. The line attribute modifiers are:\n\n+ooffset[u]\n\nLines are normally drawn from the beginning to the end point. You can modify this behavior by requesting a gap between these terminal points and the start and end of the visible line. Do this by specifying the desired offset between the terminal point and the start of the visible line. Unless you are giving distances in Cartesian data units, please append the distance unit, u. Depending on your desired effect, you can append plot distance units (i.e., cm, inch, point; Section Length units)) or map distance units, such as km, degrees, and many other standard distance units listed in Section GMT units. If only one offset is given then it applies equally to both ends of the line. Give two slash-separated distances to indicate different offsets at the beginning and end of the line (and use 0 to indicate no offset at one end).\n\n+s\n\nNormally, all PostScript line drawing is implemented as a linear spline, i.e., we simply draw straight line-segments between the given data points. Use this modifier to render the line using Bezier splines for a smoother curve.\n\n+v[b|e]vspecs\n\nBy default, lines are normally drawn from start to end. Using the +v modifier you can place arrow-heads pointing outward at one (or both) ends of the line. Use +v if you want the same vector attributes for both ends, or use +vb and +ve to specify a vector only at the beginning or end of the line, respectively. Finally, these two modifiers may both be given to specify different attributes for the two vectors. The vector specification is very rich and you may place other symbols, such as circle, square, or a terminal cross-line, in lieu of the vector head (see psxy for more details).\n\n12.16. Specifying area fill attributes¶\n\nMany plotting programs will allow the user to draw filled polygons or symbols. The fill specification may take two forms:\n\n-Gfill\n\n-Gppattern[+bcolor][+fcolor][+rdpi]\n\nfill:\n\nIn the first case we may specify a gray shade (0--255), RGB color (r/g/b all in the 0--255 range or in hexadecimal #rrggbb), HSV color (hue-saturation-value in the 0--360, 0--1, 0--1 range), CMYK color (cyan/magenta/yellow/black, each ranging from 0--100%), or a valid color name; in that respect it is similar to specifying the pen color settings (see pen color discussion under Section Specifying pen attributes).\n\npattern:\n\nThe second form allows us to use a predefined bit-image pattern. pattern can either be a number in the range 1--90 or the name of a 1-, 8-, or 24-bit image raster file. The former will result in one of the 90 predefined 64 x 64 bit-patterns provided with GMT and reproduced in Chapter Predefined Bit and Hachure Patterns in GMT. The latter allows the user to create customized, repeating images using image raster files. The optional +rdpi modifier sets the resolution of this image on the page; the area fill is thus made up of a series of these “tiles”. The default resolution is 1200. By specifying upper case -GP instead of -Gp the image will be bit-reversed, i.e., white and black areas will be interchanged (only applies to 1-bit images or predefined bit-image patterns). For these patterns and other 1-bit images one may specify alternative background and foreground colors (by appending +bcolor and/or +fcolor) that will replace the default white and black pixels, respectively. Setting one of the fore- or background colors to - yields a transparent image where only the back- or foreground pixels will be painted.\n\nDue to PostScript implementation limitations the raster images used with -G must be less than 146 x 146 pixels in size; for larger images see psimage. The format of Sun raster files is outlined in Chapter GMT file formats. However, if you built GMT with GDAL then other image formats can be used as well. Note that under PostScript Level 1 the patterns are filled by using the polygon as a clip path. Complex clip paths may require more memory than the PostScript interpreter has been assigned. There is therefore the possibility that some PostScript interpreters (especially those supplied with older laserwriters) will run out of memory and abort. Should that occur we recommend that you use a regular gray-shade fill instead of the patterns. Installing more memory in your printer may or may not solve the problem!\n\nTable fillex contains a few examples of fill specifications.\n\n-G128 Solid gray -G127/255/0 Chartreuse, R/G/B-style -G#00ff00 Green, hexadecimal RGB code -G25-0.86-0.82 Chocolate, h-s-v-style -GDarkOliveGreen1 One of the named colors -Gp7+r300 Simple diagonal hachure pattern in b/w at 300 dpi -Gp7+bred+r300 Same, but with red lines on white -Gp7+bred+f-+r300 Now the gaps between red lines are transparent -Gpmarble.ras+r100 Using user image of marble as the fill at 100 dpi\n\n12.17. Specifying Fonts¶\n\nThe fonts used by GMT are typically set indirectly via the GMT defaults parameters. However, some programs, like pstext may wish to have this information passed directly. A font is specified by a comma-delimited attribute list of size, fonttype and fill, each of which is optional. The size is the font size (usually in points) but c, i or p can be added to indicate a specific unit. The fonttype is the name (case sensitive!) of the font or its equivalent numerical ID (e.g., Helvetica-Bold or 1). fill specifies the gray shade, color or pattern of the text (see section Specifying area fill attributes above). Optionally, you may append =pen to the fill value in order to draw the text outline with the specified pen; if used you may optionally skip the filling of the text by setting fill to -. If any of the attributes is omitted their default or previous setting will be retained. See Chapter PostScript fonts used by GMT for a list of all fonts recognized by GMT.\n\n12.18. Stroke, Fill and Font Transparency¶\n\nThe PostScript language has no built-in mechanism for transparency. However, PostScript extensions make it possible to request transparency, and tools that can render such extensions will produce transparency effects. We specify transparency in percent: 0 is opaque [Default] while 100 is fully transparent (i.e., the feature will be invisible). As noted in section Layer PDF transparency: The -t option, we can control transparency on a layer-by-layer basis using the -t option. However, we may also set transparency as an attribute of stroke or fill (including for fonts) settings. Here, transparency is requested by appending @transparency to colors or pattern fills. The transparency mode can be changed by using the GMT default parameter PS_TRANSPARENCY; the default is Normal but you can choose among Color, ColorBurn, ColorDodge, Darken, Difference, Exclusion, HardLight, Hue, Lighten, Luminosity, Multiply, Normal, Overlay, Saturation, SoftLight, and Screen. For more information, see for instance (search online for) the Adobe pdfmark Reference Manual. Most printers and many PostScript viewers can neither print nor show transparency. They will simply ignore your attempt to create transparency and will plot any material as opaque. Ghostscript and its derivatives such as GMT’s psconvert support transparency (if compiled with the correct build option). Note: If you use Acrobat Distiller to create a PDF file you must first change some settings to make transparency effective: change the parameter /AllowTransparency to true in your *.joboptions file.\n\n12.19. Placement of text¶\n\nMany text labels placed on maps are part of the standard basemap machinery (e.g., annotations, axis labels, plot titles) and GMT automatically takes care of where these are placed and how they are justified. However, when you wish to add extra text to a plot in locations of your choice you will need to understand how we reference text to locations on the map. Figure Text justification discusses the various ways to do this.\n\nNotice how the anchor points refers to the text baseline and do not change for text whose letters extend below the baseline.\n\nThe concept of anchor points extends to entire text paragraphs that you may want to typeset with pstext.\n\nA related point involves the footprint of the text and any background panel on the map. We determine the bounding box for any text string, but very often we wish to extend this box outwards to allow for some clearance between the text and the space surrounding it. Programs that allows for such clearance will let you specify offsets dx and dy that is used to enlarge the bounding box, as illustrated in Figure Text clearance.\n\n12.20. Color palette tables¶\n\nSeveral programs need to relate user data to colors, shades, or even patterns. For instance, programs that read 2-D gridded data sets and create colored images or shaded reliefs need to be told what colors to use and over what z-range each color applies. Other programs may need to associate a user value with a color to be applied to a symbol, line, or polygon. This is the purpose of the color palette table (CPT). For most applications, you will simply create a CPT using the tool makecpt which will take an existing dynamic master color table and stretch it to fit your chosen data range, or use grd2cpt to build a CPT based on the data distribution in one or more given grid files. However, in rare situations you may need to make a CPT by hand or using text tools like awk or perl. Finally, if you have your own preferred color table you can convert it into a dynamic CPT and place it in your GMT user directory and it will be found and behave like other GMT master CPTs.\n\nColor palette tables (CPT) comes in two flavors: (1) Those designed to work with categorical data (e.g., data where interpolation of values is undefined) and (2) those designed for regular, continuously-varying data. In both cases the fill information follows the format given in Section Specifying area fill attributes. The z-values in CPTs can be scaled by using the +u|Uunit mechanism. Append these modifiers to your CPT names when used in GMT commands. The +uunit modifier will scale z from unit to meters, while +Uunit does the inverse (scale z from meters to unit).\n\nSince GMT supports several coordinate systems for color specification, many master (or user) CPTs will contain the special comment\n\n# COLOR_MODEL = model\n\nwhere model specifies how the color-values in the CPT should be interpreted. By default we assume colors are given as red/green/blue triplets (each in the 0-255 range) separated by slashes (model = rgb), but alternative representations are the HSV system of specifying hue-saturation-value triplets (with hue in 0-360 range and saturation and value ranging from 0-1) separated by hyphens (model = hsv), or the CMYK system of specifying cyan/magenta/yellow/black quadruples in percent, separated by slashes (model = cmyk).\n\n12.20.1. Categorical CPTs¶\n\nCategorical data are information on which normal numerical operations are not defined. As an example, consider various land classifications (desert, forest, glacier, etc.) and it is clear that even if we assigned a numerical value to these categories (e.g., desert = 1, forest = 2, etc) it would be meaningless to compute average values (what would 1.5 mean?). For such data a special format of the CPTs are provided. Here, each category is assigned a unique key, a color or pattern, and an optional label (usually the category name) marked by a leading semi-colon. Keys must be monotonically increasing but do not need to be consecutive. The format is\n\nkey1 Fill [;label] … keyn Fill [;label]\n\nThe Fill information follows the format given in Section Specifying area fill attributes. While not always applicable to categorical data, the background color (for key-values < \\(key_1\\)), foreground color (for key-values > \\(key_{n}\\)), and not-a-number (NaN) color (for key-values = NaN) are all defined in the gmt.conf file, but can be overridden by the statements\n\nB Fillback F Fillfore N Fillnan\n\n12.20.2. Regular CPTs¶\n\nSuitable for continuous data types and allowing for color interpolations, the format of the regular CPTs is:\n\nz0 Colormin z1 Colormax [A] [;label] … zn-2 Colormin zn-1 Colormax [A] [;label]\n\nThus, for each “z-slice”, defined as the interval between two boundaries (e.g., \\(z_0\\) to \\(z_1\\)), the color can be constant (by letting Color\\(_{max}\\) = Color\\(_{min}\\) or -) or a continuous, linear function of z. If patterns are used then the second (max) pattern must be set to -. The optional flag A is used to indicate annotation of the color scale when plotted using psscale. The optional flag A may be L, U, or B to select annotation of the lower, upper, or both limits of the particular z-slice, respectively. However, the standard -B option can be used by psscale to affect annotation and ticking of color scales. Just as other GMT programs, the stride can be omitted to determine the annotation and tick interval automatically (e.g., -Baf). The optional semicolon followed by a text label will make psscale, when used with the -L option, place the supplied label instead of formatted z-values.\n\nAs for categorical tables, the background color (for z-values < \\(z_0\\)), foreground color (for z-values > \\(z_{n-1}\\)), and not-a-number (NaN) color (for z-values = NaN) are all defined in the gmt.conf file, but can be overridden by the statements\n\nB Fillback F Fillfore N Fillnan\n\nwhich can be inserted into the beginning or end of the CPT. If you prefer the HSV system, set the gmt.conf parameter accordingly and replace red, green, blue with hue, saturation, value. Color palette tables that contain gray-shades only may replace the r/g/b triplets with a single gray-shade in the 0--255 range. For CMYK, give c/m/y/k values in the 0--100 range.\n\nA few programs (i.e., those that plot polygons such as grdview, psscale, psxy and psxyz) can accept pattern fills instead of gray-shades. You must specify the pattern as in Section Specifying area fill attributes (no leading -G of course), and only the first pattern (for low z) is used (we cannot interpolate between patterns). Finally, some programs let you skip features whose z-slice in the CPT file has gray-shades set to -. As an example, consider\n\n30 p16+r200 80 - 80 - 100 - 100 200/0/0 200 255/255/0 200 yellow 300 green\n\nwhere slice 30 < z < 80 is painted with pattern # 16 at 200 dpi, slice 80 < z < 100 is skipped, slice 100 < z < 200 is painted in a range of dark red to yellow, whereas the slice 200 < z < 300 will linearly yield colors from yellow to green, depending on the actual value of z.\n\nSome programs like grdimage and grdview apply artificial illumination to achieve shaded relief maps. This is typically done by finding the directional gradient in the direction of the artificial light source and scaling the gradients to have approximately a normal distribution on the interval [-1,+1]. These intensities are used to add “white” or “black” to the color as defined by the z-values and the CPT. An intensity of zero leaves the color unchanged. Higher values will brighten the color, lower values will darken it, all without changing the original hue of the color (see Chapter Color Space: The Final Frontier for more details). The illumination is decoupled from the data grid file in that a separate grid file holding intensities in the [-1,+1] range must be provided. Such intensity files can be derived from the data grid using grdgradient and modified with grdhisteq, but could equally well be a separate data set. E.g., some side-scan sonar systems collect both bathymetry and backscatter intensities, and one may want to use the latter information to specify the illumination of the colors defined by the former. Similarly, one could portray magnetic anomalies superimposed on topography by using the former for colors and the latter for shading.\n\n12.20.3. Master (dynamic) CPTs¶\n\nThe CPTs distributed with GMT are dynamic. This means they have several special properties that modify the behavior of programs that use them. All dynamic CPTs are normalized in one of two ways: If a CPT was designed to behave differently across a hinge value (e.g., a CPT designed specifically for topographic relief may include a discontinuity in color across the coastline at z = 0), then the CPT’s z-values will range from -1, via 0 at the hinge, to +1 at the other end. The hinge value is specified via the special comment\n\n# HINGE = <hinge-value>\n\nCPTs without a hinge are instead normalized with z-values from 0 to 1. Dynamic CPTs will need to be stretched to the user’s preferred range, and there are two modes of such scaling: Some CPTs designed for a specific application (again, the topographic relief is a good example) have a default range specified in the master table via the special comment\n\n# RANGE = <zmin/zmax>\n\nand when used by applications the normalized z-values will be stretched to reflect this natural range. In c"
    }
}