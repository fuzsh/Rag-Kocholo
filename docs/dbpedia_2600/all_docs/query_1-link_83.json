{
    "id": "dbpedia_2600_1",
    "rank": 83,
    "data": {
        "url": "https://swcarpentry.github.io/r-novice-inflammation/aio.html",
        "read_more_link": "",
        "language": "en",
        "title": "Programming with R: All in One View",
        "top_image": "https://swcarpentry.github.io/r-novice-inflammation/favicon-32x32.png",
        "meta_img": "https://swcarpentry.github.io/r-novice-inflammation/favicon-32x32.png",
        "images": [
            "https://swcarpentry.github.io/r-novice-inflammation/assets/images/software-logo.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/assets/images/software-logo-sm.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/tag-variables.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/arithmetic-variables.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/reassign-variables.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/new-variables.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/memory-variables.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/mass-age-assign-1.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/mass-age-assign-2.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/r-operations-across-margins.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/01-starting-with-data-rendered-plot-avg-inflammation-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/01-starting-with-data-rendered-plot-max-inflammation-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/01-starting-with-data-rendered-plot-min-inflammation-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/function-terminology.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-inflammation-01-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-inflammation-01-2.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-inflammation-01-3.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-inflammation-02-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-inflammation-02-2.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-inflammation-02-3.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-2.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-3.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-4.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-5.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-6.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-7.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-8.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/03-loops-R-rendered-loop-analyze-9.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-flowchart-conditional.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-using-conditions-01-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-using-conditions-01-2.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-conditional-challenge-hist-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-conditional-challenge-hist-2.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-conditional-challenge-hist-3.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-inflammation-01-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-inflammation-01-2.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/04-cond-rendered-inflammation-01-3.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/R-package-structure.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/10-supp-addressing-data-rendered-logical_vectors_indexing2-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/10-supp-addressing-data-rendered-plot-logical-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/12-supp-factors-rendered-reordering-factors-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/12-supp-factors-rendered-reordering-factors-2-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/12-supp-factors-rendered-gender-counts-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/12-supp-factors-rendered-updating-factors-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/12-supp-factors-rendered-dropping-levels-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/12-supp-factors-rendered-adjusting-levels-1.png",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-01.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-02.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-03.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-04.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-05.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-06.svg",
            "https://swcarpentry.github.io/r-novice-inflammation/fig/python-call-stack-07.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2014-12-18T00:00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Loading Data\n\nNow that we are set up with an Rstudio project, we are sure that the data and scripts we are using are all in our working directory. The data files should be located in the directory data, inside the working directory. Now we can load the data into R using read.csv:\n\nR\n\nread.csv(file = \"data/inflammation-01.csv\", header = FALSE)\n\nThe expression read.csv(...) is a function call that asks R to run the function read.csv.\n\nread.csv has two arguments: the name of the file we want to read, and whether the first line of the file contains names for the columns of data. The filename needs to be a character string (or string for short), so we put it in quotes. Assigning the second argument, header, to be FALSE indicates that the data file does not have column headers. We’ll talk more about the value FALSE, and its converse TRUE, in lesson 04. In case of our inflammation-01.csv example, R auto-generates column names in the sequence V1 (for “variable 1”), V2, and so on, until V40.\n\nOther Options for Reading CSV Files\n\nread.csv actually has many more arguments that you may find useful when importing your own data in the future. You can learn more about these options in this supplementary lesson.\n\nLoading Data with Headers\n\nWhat happens if you forget to put header = FALSE? The default value is header = TRUE, which you can check with ?read.csv or help(read.csv). What do you expect will happen if you leave the default value of header? Before you run any code, think about what will happen to the first few rows of your data frame, and its overall size. Then run the following code and see if your expectations agree:\n\nR\n\nread.csv(file = \"data/inflammation-01.csv\")\n\nR will construct column headers from values in your first row of data, resulting in X0 X0.1 X1 X3 X1.1 X2 ....\n\nNote that the character X is prepended: a standalone number would not be a valid variable name. Because column headers are variables, the same naming rules apply. Appending .1, .2 etc. is necessary to avoid duplicate column headers.\n\nReading Different Decimal Point Formats\n\nDepending on the country you live in, your standard can use the “dot” or the “comma” as decimal mark. Also, different devices or software can generate data with different kinds of decimal marks. Take a look at ?read.csv and write the code to load a file called commadec.txt that has numeric values with commas as decimal mark, separated by semicolons.\n\nR\n\nread.csv(file = \"data/commadec.txt\", sep = \";\", dec = \",\")\n\nor the built-in shortcut:\n\nR\n\nread.csv2(file = \"data/commadec.txt\")\n\nA function will perform its given action on whatever value is passed to the argument(s). For example, in this case if we provided the name of a different file to the argument file, read.csv would read that instead. We’ll learn more about the details of functions and their arguments in the next lesson.\n\nSince we didn’t tell it to do anything else with the function’s output, the console will display the full contents of the file inflammation-01.csv. Try it out.\n\nread.csv reads the file, but we can’t use the data unless we assign it to a variable. We can think of a variable as a container with a name, such as x, current_temperature, or subject_id that contains one or more values. We can create a new variable and assign a value to it using <-.\n\nR\n\nweight_kg <- 55\n\nOnce a variable is created, we can use the variable name to refer to the value it was assigned. The variable name now acts as a tag. Whenever R reads that tag (weight_kg), it substitutes the value (55).\n\nTo see the value of a variable, we can print it by typing the name of the variable and hitting CTRL + Return (or CTRL + Enter) while working in the “script.R” file in the editor which is recommended. If we are working in the console directly, we need to hit Return (or Enter). In general, R will print to the console any object returned by a function or operation unless we assign it to a variable.\n\nR\n\nweight_kg\n\nOUTPUT\n\n[1] 55\n\nWe can treat our variable like a regular number, and do arithmetic with it:\n\nR\n\n# weight in pounds: 2.2 * weight_kg\n\nOUTPUT\n\n[1] 121\n\nWe can also change a variable’s value by assigning it a new value:\n\nR\n\nweight_kg <- 57.5 # weight in kilograms is now weight_kg\n\nOUTPUT\n\n[1] 57.5\n\nVariable Naming Conventions\n\nHistorically, R programmers have used a variety of conventions for naming variables. The . character in R can be a valid part of a variable name; thus the above assignment could have easily been weight.kg <- 57.5. This is often confusing to R newcomers who have programmed in languages where . has a more significant meaning. Today, most R programmers 1) start variable names with lower case letters, 2) separate words in variable names with underscores, and 3) use only lowercase letters, underscores, and numbers in variable names. The Tidyverse Style Guide includes a section on this and other style considerations.\n\nAssigning a new value to a variable breaks the connection with the old value; R forgets that number and applies the variable name to the new value.\n\nWhen you assign a value to a variable, R only stores the value, not the calculation you used to create it. This is an important point if you’re used to the way a spreadsheet program automatically updates linked cells. Let’s look at an example.\n\nFirst, we’ll convert weight_kg into pounds, and store the new value in the variable weight_lb:\n\nR\n\nweight_lb <- 2.2 * weight_kg # weight in kg... weight_kg\n\nOUTPUT\n\n[1] 57.5\n\nR\n\n# ...and in pounds weight_lb\n\nOUTPUT\n\n[1] 126.5\n\nIn words, we’re asking R to look up the value we tagged weight_kg, multiply it by 2.2, and tag the result with the name weight_lb:\n\nIf we now change the value of weight_kg:\n\nR\n\nweight_kg <- 100.0 # weight in kg now... weight_kg\n\nOUTPUT\n\n[1] 100\n\nR\n\n# ...and weight in pounds still weight_lb\n\nOUTPUT\n\n[1] 126.5\n\nSince weight_lb doesn’t “remember” where its value came from, it isn’t automatically updated when weight_kg changes. This is different from the way spreadsheets work.\n\nPrinting with Parentheses\n\nAn alternative way to print the value of a variable is to use ( parentheses ) around the assignment statement. As an example: (total_weight <- weight_kg*2.2 + weight_lb) adds the values of weight_kg*2.2 and weight_lb, assigns the result to the total_weight, and finally prints the assigned value of the variable total_weight.\n\nNow that we know how to assign things to variables, let’s re-run read.csv and save its result into a variable called dat:\n\nR\n\ndat <- read.csv(file = \"data/inflammation-01.csv\", header = FALSE)\n\nThis statement doesn’t produce any output because the assignment doesn’t display anything. If we want to check if our data has been loaded, we can print the variable’s value by typing the name of the variable dat. However, for large data sets it is convenient to use the function head to display only the first few rows of data.\n\nR\n\nhead(dat)\n\nOUTPUT\n\nV1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 V13 V14 V15 V16 V17 V18 V19 V20 V21 1 0 0 1 3 1 2 4 7 8 3 3 3 10 5 7 4 7 7 12 18 6 2 0 1 2 1 2 1 3 2 2 6 10 11 5 9 4 4 7 16 8 6 18 3 0 1 1 3 3 2 6 2 5 9 5 7 4 5 4 15 5 11 9 10 19 4 0 0 2 0 4 2 2 1 6 7 10 7 9 13 8 8 15 10 10 7 17 5 0 1 1 3 3 1 3 5 2 4 4 7 6 5 3 10 8 10 6 17 9 6 0 0 1 2 2 4 2 1 6 4 7 6 6 9 9 15 4 16 18 12 12 V22 V23 V24 V25 V26 V27 V28 V29 V30 V31 V32 V33 V34 V35 V36 V37 V38 V39 V40 1 13 11 11 7 7 4 6 8 8 4 4 5 7 3 4 2 3 0 0 2 4 12 5 12 7 11 5 11 3 3 5 4 4 5 5 1 1 0 1 3 14 12 17 7 12 11 7 4 2 10 5 4 2 2 3 2 2 1 1 4 4 4 7 6 15 6 4 9 11 3 5 6 3 3 4 2 3 2 1 5 14 9 7 13 9 12 6 7 7 9 6 3 2 2 4 2 0 1 1 6 5 18 9 5 3 10 3 12 7 8 4 7 3 5 4 4 3 2 1\n\nAssigning Values to Variables\n\nDraw diagrams showing what variables refer to what values after each statement in the following program:\n\nR\n\nmass <- 47.5 age <- 122 mass <- mass * 2.0 age <- age - 20\n\nR\n\nmass <- 47.5 age <- 122\n\nR\n\nmass <- mass * 2.0 age <- age - 20\n\nManipulating Data\n\nNow that our data are loaded into R, we can start doing things with them. First, let’s ask what type of thing dat is:\n\nR\n\nclass(dat)\n\nOUTPUT\n\n[1] \"data.frame\"\n\nThe output tells us that it’s a data frame. Think of this structure as a spreadsheet in MS Excel that many of us are familiar with. Data frames are very useful for storing data and you will use them frequently when programming in R. A typical data frame of experimental data contains individual observations in rows and variables in columns.\n\nWe can see the shape, or dimensions, of the data frame with the function dim:\n\nR\n\ndim(dat)\n\nOUTPUT\n\n[1] 60 40\n\nThis tells us that our data frame, dat, has 60 rows and 40 columns.\n\nIf we want to get a single value from the data frame, we can provide an index in square brackets. The first number specifies the row and the second the column:\n\nR\n\n# first value in dat, row 1, column 1 dat[1, 1]\n\nOUTPUT\n\n[1] 0\n\nR\n\n# middle value in dat, row 30, column 20 dat[30, 20]\n\nOUTPUT\n\n[1] 16\n\nThe first value in a data frame index is the row, the second value is the column. If we want to select more than one row or column, we can use the function c, which combines the values you give it into one vector or list. For example, to pick columns 10 and 20 from rows 1, 3, and 5, we can do this:\n\nR\n\ndat[c(1, 3, 5), c(10, 20)]\n\nOUTPUT\n\nV10 V20 1 3 18 3 9 10 5 4 17\n\nWe frequently want to select contiguous rows or columns, such as the first ten rows, or columns 3 through 7. You can use c for this, but it’s more convenient to use the : operator. This special function generates sequences of numbers:\n\nR\n\n1:5\n\nOUTPUT\n\n[1] 1 2 3 4 5\n\nR\n\n3:12\n\nOUTPUT\n\n[1] 3 4 5 6 7 8 9 10 11 12\n\nFor example, we can select the first ten columns of values for the first four rows like this:\n\nR\n\ndat[1:4, 1:10]\n\nOUTPUT\n\nV1 V2 V3 V4 V5 V6 V7 V8 V9 V10 1 0 0 1 3 1 2 4 7 8 3 2 0 1 2 1 2 1 3 2 2 6 3 0 1 1 3 3 2 6 2 5 9 4 0 0 2 0 4 2 2 1 6 7\n\nor the first ten columns of rows 5 to 10 like this:\n\nR\n\ndat[5:10, 1:10]\n\nOUTPUT\n\nV1 V2 V3 V4 V5 V6 V7 V8 V9 V10 5 0 1 1 3 3 1 3 5 2 4 6 0 0 1 2 2 4 2 1 6 4 7 0 0 2 2 4 2 2 5 5 8 8 0 0 1 2 3 1 2 3 5 3 9 0 0 0 3 1 5 6 5 5 8 10 0 1 1 2 1 3 5 3 5 8\n\nIf you want to select all rows or all columns, leave that index value empty.\n\nR\n\n# All columns from row 5 dat[5, ]\n\nOUTPUT\n\nV1 V2 V3 V4 V5 V6 V7 V8 V9 V10 V11 V12 V13 V14 V15 V16 V17 V18 V19 V20 V21 5 0 1 1 3 3 1 3 5 2 4 4 7 6 5 3 10 8 10 6 17 9 V22 V23 V24 V25 V26 V27 V28 V29 V30 V31 V32 V33 V34 V35 V36 V37 V38 V39 V40 5 14 9 7 13 9 12 6 7 7 9 6 3 2 2 4 2 0 1 1\n\nR\n\n# All rows from column 16-18 dat[, 16:18]\n\nOUTPUT\n\nV16 V17 V18 1 4 7 7 2 4 7 16 3 15 5 11 4 8 15 10 5 10 8 10 6 15 4 16 7 13 5 12 8 9 15 11 9 11 9 10 10 6 13 8 11 3 7 13 12 8 14 11 13 12 4 17 14 3 10 13 15 5 7 17 16 10 7 8 17 11 12 5 18 4 14 7 19 11 15 17 20 13 6 5 21 15 13 6 22 5 12 12 23 14 5 5 24 13 7 14 25 4 12 9 26 9 5 16 27 13 4 13 28 6 15 6 29 7 6 11 30 6 8 7 31 14 12 8 32 3 8 10 33 15 15 10 34 4 12 9 35 15 9 17 36 11 5 7 37 7 4 7 38 10 6 7 39 15 12 13 40 6 8 15 41 5 7 5 42 6 10 13 43 15 11 12 44 11 6 10 45 15 12 15 46 6 7 11 47 11 16 12 48 15 5 15 49 14 4 6 50 4 7 9 51 10 13 6 52 15 15 12 53 11 15 13 54 6 11 12 55 13 8 9 56 8 8 16 57 4 16 11 58 13 13 9 59 12 15 5 60 9 14 11\n\nIf you leave both index values empty (i.e., dat[,]), you get the entire data frame.\n\nAddressing Columns by Name\n\nColumns can also be addressed by name, with either the $ operator (ie. dat$V16) or square brackets (ie. dat[, 'V16']). You can learn more about subsetting by column name in this supplementary lesson.\n\nNow let’s perform some common mathematical operations to learn more about our inflammation data. When analyzing data we often want to calculate statistics for specific subsets or groups of the data frame, such as the maximum value per patient or the average value per day. One way to do this is to select the data we want to create a new temporary data frame, and then perform the calculation on this subset:\n\nR\n\n# first row, all of the columns patient_1 <- dat[1, ] # max inflammation for patient 1 max(patient_1)\n\nOUTPUT\n\n[1] 18\n\nWe don’t actually need to store the row in a variable of its own. Instead, we can combine the selection and the function call:\n\nR\n\n# max inflammation for patient 2 max(dat[2, ])\n\nOUTPUT\n\n[1] 18\n\nR also has functions for other common calculations, e.g. finding the minimum, mean, median, and standard deviation of the data:\n\nR\n\n# minimum inflammation on day 7 min(dat[, 7])\n\nOUTPUT\n\n[1] 1\n\nR\n\n# mean inflammation on day 7 mean(dat[, 7])\n\nOUTPUT\n\n[1] 3.8\n\nR\n\n# median inflammation on day 7 median(dat[, 7])\n\nOUTPUT\n\n[1] 4\n\nR\n\n# standard deviation of inflammation on day 7 sd(dat[, 7])\n\nOUTPUT\n\n[1] 1.725187\n\nForcing Conversion\n\nNote that R may return an error when you attempt to perform similar calculations on subsetted rows of data frames. This is because some functions in R automatically convert the object type to a numeric vector, while others do not (e.g. max(dat[1, ]) works as expected, while mean(dat[1, ]) returns NA and a warning). You get the expected output by including an explicit call to as.numeric(), e.g. mean(as.numeric(dat[1, ])). By contrast, calculations on subsetted columns always work as expected, since columns of data frames are already defined as vectors.\n\nR also has a function that summaries the previous common calculations:\n\nR\n\n# Summarize function summary(dat[, 1:4])\n\nOUTPUT\n\nV1 V2 V3 V4 Min. :0 Min. :0.00 Min. :0.000 Min. :0.00 1st Qu.:0 1st Qu.:0.00 1st Qu.:1.000 1st Qu.:1.00 Median :0 Median :0.00 Median :1.000 Median :2.00 Mean :0 Mean :0.45 Mean :1.117 Mean :1.75 3rd Qu.:0 3rd Qu.:1.00 3rd Qu.:2.000 3rd Qu.:3.00 Max. :0 Max. :1.00 Max. :2.000 Max. :3.00\n\nFor every column in the data frame, the function “summary” calculates: the minimum value, the first quartile, the median, the mean, the third quartile and the max value, giving helpful details about the sample distribution.\n\nWhat if we need the maximum inflammation for all patients, or the average for each day? As the diagram below shows, we want to perform the operation across a margin of the data frame:\n\nTo support this, we can use the apply function.\n\nGetting Help\n\nTo learn about a function in R, e.g. apply, we can read its help documentation by running help(apply) or ?apply.\n\napply allows us to repeat a function on all of the rows (MARGIN = 1) or columns (MARGIN = 2) of a data frame.\n\nThus, to obtain the average inflammation of each patient we will need to calculate the mean of all of the rows (MARGIN = 1) of the data frame.\n\nR\n\navg_patient_inflammation <- apply(dat, 1, mean)\n\nAnd to obtain the average inflammation of each day we will need to calculate the mean of all of the columns (MARGIN = 2) of the data frame.\n\nR\n\navg_day_inflammation <- apply(dat, 2, mean)\n\nSince the second argument to apply is MARGIN, the above command is equivalent to apply(dat, MARGIN = 2, mean). We’ll learn why this is so in the next lesson.\n\nEfficient Alternatives\n\nSome common operations have more efficient alternatives. For example, you can calculate the row-wise or column-wise means with rowMeans and colMeans, respectively.\n\nSubsetting Data\n\nWe can take subsets of character vectors as well:\n\nR\n\nanimal <- c(\"m\", \"o\", \"n\", \"k\", \"e\", \"y\") # first three characters animal[1:3]\n\nOUTPUT\n\n[1] \"m\" \"o\" \"n\"\n\nR\n\n# last three characters animal[4:6]\n\nOUTPUT\n\n[1] \"k\" \"e\" \"y\"\n\nIf the first four characters are selected using the subset animal[1:4], how can we obtain the first four characters in reverse order?\n\nWhat is animal[-1]? What is animal[-4]? Given those answers, explain what animal[-1:-4] does.\n\nUse a subset of animal to create a new character vector that spells the word “eon”, i.e. c(\"e\", \"o\", \"n\").\n\nanimal[4:1]\n\n\"o\" \"n\" \"k\" \"e\" \"y\" and \"m\" \"o\" \"n\" \"e\" \"y\", which means that a single - removes the element at the given index position. animal[-1:-4] remove the subset, returning \"e\" \"y\", which is equivalent to animal[5:6].\n\nanimal[c(5,2,3)] combines indexing with the c function.\n\nSubsetting More Data\n\nSuppose you want to determine the maximum inflammation for patient 5 across days three to seven. To do this you would extract the relevant subset from the data frame and calculate the maximum value. Which of the following lines of R code gives the correct answer?\n\nmax(dat[5, ])\n\nmax(dat[3:7, 5])\n\nmax(dat[5, 3:7])\n\nmax(dat[5, 3, 7])\n\nAnswer: 3\n\nExplanation: You want to extract the part of the dataframe representing data for patient 5 from days three to seven. In this dataframe, patient data is organised in rows and the days are represented by the columns. Subscripting in R follows the [i, j] principle, where i = rows and j = columns. Thus, answer 3 is correct since the patient is represented by the value for i (5) and the days are represented by the values in j, which is a subset spanning day 3 to 7.\n\nSubsetting and Re-Assignment\n\nUsing the inflammation data frame dat from above: Let’s pretend there was something wrong with the instrument on the first five days for every second patient (#2, 4, 6, etc.), which resulted in the measurements being twice as large as they should be.\n\nWrite a vector containing each affected patient (hint: ?seq)\n\nCreate a new data frame in which you halve the first five days’ values in only those patients\n\nPrint out the corrected data frame to check that your code has fixed the problem\n\nR\n\nwhichPatients <- seq(2, 60, 2) # i.e., which rows whichDays <- seq(1, 5) # i.e., which columns dat2 <- dat # check the size of your subset: returns `30 5`, that is 30 [rows=patients] by 5 [columns=days] dim(dat2[whichPatients, whichDays]) dat2[whichPatients, whichDays] <- dat2[whichPatients, whichDays] / 2 dat2\n\nUsing the Apply Function on Patient Data\n\nChallenge: the apply function can be used to summarize datasets and subsets of data across rows and columns using the MARGIN argument. Suppose you want to calculate the mean inflammation for specific days and patients in the patient dataset (i.e. 60 patients across 40 days).\n\nPlease use a combination of the apply function and indexing to:\n\ncalculate the mean inflammation for patients 1 to 5 over the whole 40 days\n\ncalculate the mean inflammation for days 1 to 10 (across all patients).\n\ncalculate the mean inflammation for every second day (across all patients).\n\nThink about the number of rows and columns you would expect as the result before each apply call and check your intuition by applying the mean function.\n\nR\n\n# 1. apply(dat[1:5, ], 1, mean) # 2. apply(dat[, 1:10], 2, mean) # 3. apply(dat[, seq(2, 40, by = 2)], 2, mean)\n\nError Handling\n\nWhat happens if we have missing data (NA values) in the data argument we provide to center?\n\nR\n\n# new data object and set one value in column 4 to NA datNA <- dat datNA[10,4] <- NA # returns all NA values center(datNA[,4], 0)\n\nOUTPUT\n\n[1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [51] NA NA NA NA NA NA NA NA NA NA\n\nThis is likely not the behavior we want, and is caused by the mean function returning NA when the na.rm=TRUE is not provided. We may wish to not consider NA values in our center function. We can provide the na.rm=TRUE argument and solve this issue.\n\nR\n\ncenter <- function(data, midpoint) { new_data <- (data - mean(data, na.rm=TRUE)) + midpoint return(new_data) } center(datNA[,4], 0)\n\nOUTPUT\n\n[1] 1.2542373 -0.7457627 1.2542373 -1.7457627 1.2542373 0.2542373 [7] 0.2542373 0.2542373 1.2542373 NA -1.7457627 -1.7457627 [13] -0.7457627 -1.7457627 -0.7457627 -1.7457627 -1.7457627 -0.7457627 [19] -0.7457627 -1.7457627 1.2542373 1.2542373 1.2542373 -0.7457627 [25] -0.7457627 -0.7457627 0.2542373 -0.7457627 0.2542373 -0.7457627 [31] -1.7457627 1.2542373 0.2542373 -0.7457627 0.2542373 1.2542373 [37] 0.2542373 0.2542373 1.2542373 1.2542373 0.2542373 1.2542373 [43] 1.2542373 1.2542373 1.2542373 0.2542373 1.2542373 1.2542373 [49] 1.2542373 0.2542373 -0.7457627 0.2542373 0.2542373 -0.7457627 [55] -0.7457627 1.2542373 0.2542373 -0.7457627 -0.7457627 -1.7457627\n\nHowever, what happens if the user were to accidentally hand this function a factor or character vector?\n\nR\n\ndatNA[,1] <- as.factor(datNA[,1]) datNA[,2] <- as.character(datNA[,2]) center(datNA[,1], 0)\n\nWARNING\n\nWarning in mean.default(data, na.rm = TRUE): argument is not numeric or logical: returning NA\n\nWARNING\n\nWarning in Ops.factor(data, mean(data, na.rm = TRUE)): '-' not meaningful for factors\n\nOUTPUT\n\n[1] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [26] NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA NA [51] NA NA NA NA NA NA NA NA NA NA\n\nR\n\ncenter(datNA[,2], 0)\n\nWARNING\n\nWarning in mean.default(data, na.rm = TRUE): argument is not numeric or logical: returning NA\n\nERROR\n\nError in data - mean(data, na.rm = TRUE): non-numeric argument to binary operator\n\nBoth of these attempts result in errors. Luckily, the errors are quite informative. In other cases, we may need to add in error handling using the warning and stop functions.\n\nFor instance, the center function only works on numeric vectors. Recognizing this and adding warnings and errors provides feedback to the user and makes sure the output of the function is what the user wanted."
    }
}