{
    "id": "dbpedia_5009_2",
    "rank": 79,
    "data": {
        "url": "https://pythonassets.com/posts/background-tasks-with-pyqt/",
        "read_more_link": "",
        "language": "en",
        "title": "Background Tasks With PyQt",
        "top_image": "https://pythonassets.com/images/background-tasks-with-pyqt/background-tasks-with-pyqt.png",
        "meta_img": "https://pythonassets.com/images/background-tasks-with-pyqt/background-tasks-with-pyqt.png",
        "images": [
            "https://pythonassets.com/images/background-tasks-with-pyqt/pyqt-download-file-urllib.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Python Assets"
        ],
        "publish_date": "2021-08-21T01:25:06-03:00",
        "summary": "",
        "meta_description": "How to run background tasks in a Python & Qt desktop application without freezing the window.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "Python Assets",
        "canonical_link": "https://pythonassets.com/posts/background-tasks-with-pyqt/",
        "text": "Every library for desktop applications development works with a main loop that manages events such as displaying, moving, or resizing the window, responding to a button or keyboard press, or any other interaction with the user interface. Some of those events might be connected to our own functions; for example, a button1_pressed() method might be invoked by a library when the user presses the button1 widget. When working with Qt, the proper way to respond to those events is by connecting a signal to a slot.\n\nBut the problem arises when, while responding to a certain event or during the interface setup, we execute a task whose duration is not negligible (we could say that any task that lasts for more than one second is not negligible). When this happens, the processor is busy executing our heavy task and is not able to execute our application's main loop, thus our interface stops responding: we cannot move it, close it, resize it, nor interact with it in any other way.\n\nLet's see a real case. The following code draws a window with a label (QLabel) and a button (QPushButton) that, when pressed, downloads a file via HTTP using the urllib.request standard module.\n\nYou will notice that during the file download, which for me takes near to five seconds, the window is totally frozen. We already mention the reason for this behaviour: in this particular code, the line number 29, where r.read() is called (the function that downloads the content of the remote file), blocks Qt's main loop.\n\nWe shall consider three different workarounds for this same problem, each one with its own pros and cons.\n\nFirst workaround. ThreadsÂ¶\n\nThis solution involves throwing a new thread that executes our heavy task. Since Qt's main loop runs in our application's main thread, and our task runs in a secondary thread, the user interface remains active while the file is downloaded in the background. To achieve this we will employ the QThread class, that provides a cross-platform API to work with threads.\n\nfrom urllib.request import urlopen from PyQt5.QtCore import QThread from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QPushButton class Downloader(QThread): Â Â Â Â def __init__(self, url, filename): Â Â Â Â Â Â Â Â super().__init__() Â Â Â Â Â Â Â Â self._url = url Â Â Â Â Â Â Â Â self._filename = filename Â Â Â Â def run(self): Â Â Â Â Â Â Â Â # Open the URL address. Â Â Â Â Â Â Â Â with urlopen(self._url) as r: Â Â Â Â Â Â Â Â Â Â Â Â with open(self._filename, \"wb\") as f: Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # Read the remote file and write the local one. Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â f.write(r.read()) class MainWindow(QMainWindow): Â Â Â Â def __init__(self): Â Â Â Â Â Â Â Â super().__init__() Â Â Â Â Â Â Â Â self.setWindowTitle(\"Threaded File Download with PyQt\") Â Â Â Â Â Â Â Â self.resize(400, 300) Â Â Â Â Â Â Â Â self.label = QLabel(\"Press the button to start the download.\", Â Â Â Â Â Â Â Â Â Â Â Â self) Â Â Â Â Â Â Â Â self.label.setGeometry(20, 20, 200, 25) Â Â Â Â Â Â Â Â self.button = QPushButton(\"Start download\", self) Â Â Â Â Â Â Â Â self.button.move(20, 60) Â Â Â Â Â Â Â Â self.button.pressed.connect(self.initDownload) Â Â Â Â def initDownload(self): Â Â Â Â Â Â Â Â self.label.setText(\"Downloading file...\") Â Â Â Â Â Â Â Â # Disable the button while downloading the file. Â Â Â Â Â Â Â Â self.button.setEnabled(False) Â Â Â Â Â Â Â Â # Execute the download in a new thread. Â Â Â Â Â Â Â Â self.downloader = Downloader( Â Â Â Â Â Â Â Â Â Â Â Â \"https://www.python.org/ftp/python/3.7.2/python-3.7.2.exe\", Â Â Â Â Â Â Â Â Â Â Â Â \"python-3.7.2.exe\" Â Â Â Â Â Â Â Â ) Â Â Â Â Â Â Â Â # Qt will invoke the `downloadFinished()` method once the Â Â Â Â Â Â Â Â # thread has finished. Â Â Â Â Â Â Â Â self.downloader.finished.connect(self.downloadFinished) Â Â Â Â Â Â Â Â self.downloader.start() Â Â Â Â def downloadFinished(self): Â Â Â Â Â Â Â Â self.label.setText(\"Â¡File downloaded!\") Â Â Â Â Â Â Â Â # Restore the button. Â Â Â Â Â Â Â Â self.button.setEnabled(True) Â Â Â Â Â Â Â Â # Delete the thread when no longer needed. Â Â Â Â Â Â Â Â del self.downloader if __name__ == \"__main__\": Â Â Â Â app = QApplication([]) Â Â Â Â window = MainWindow() Â Â Â Â window.show() Â Â Â Â app.exec_()\n\nThe main point of this code is the Downloader class that inherits from QThread and re-implements the run() method (line 14), whose content will be executed within a new thread when we create an instance and call the start() method (lines 40 and 47). In the line 46 we connect the finished signal (that is emitted by Qt when the thread finishes its execution) with our downloadFinished() method.\n\nAlthough this specific example downloads a file, this method allows us to move any heavy task into the new thread: it requires no more than to put it inside the run() method.\n\nHowever, multi-threading programming must be done extremely carefully. Only the run() method runs in the new thread, while the rest (even the Downloader.__init__() method itself) runs in the main thread. Also, we must make sure to not share objects that might be accessed at the same time from two or more threads.\n\nSecond workaround. Events processingÂ¶\n\nAn alternative to throwing a new thread of execution is to make the whole work in the main thread, but letting Qt periodically process the application events so the user interface doesn't freeze. This can be done via the QCoreApplication.processEvents() function.\n\nIn our former code, the function that executed the heavy task and blocked the main loop for some seconds was r.read(). Since this method doesn't return any value until the file has been completelly downloaded (i.e., we don't have the control of the code until the function finishes), we need to create our own loop that fetches the remote file by little chunks (128 bytes) and at the same time lets Qt process the application events. We're lucky because read() takes an optional argument that let us indicate how many bytes we want to fetch.\n\nfrom urllib.request import urlopen from PyQt5.QtCore import QCoreApplication from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QPushButton class MainWindow(QMainWindow): Â Â Â Â def __init__(self): Â Â Â Â Â Â Â Â super().__init__() Â Â Â Â Â Â Â Â self.setWindowTitle(\"File Download with PyQt\") Â Â Â Â Â Â Â Â self.resize(400, 300) Â Â Â Â Â Â Â Â self.label = QLabel(\"Press the button to start the download.\", Â Â Â Â Â Â Â Â Â Â Â Â self) Â Â Â Â Â Â Â Â self.label.setGeometry(20, 20, 200, 25) Â Â Â Â Â Â Â Â self.button = QPushButton(\"Start download\", self) Â Â Â Â Â Â Â Â self.button.move(20, 60) Â Â Â Â Â Â Â Â self.button.pressed.connect(self.downloadFile) Â Â Â Â def downloadFile(self): Â Â Â Â Â Â Â Â self.label.setText(\"Descargando archivo...\") Â Â Â Â Â Â Â Â # Disable the button while downloading the file. Â Â Â Â Â Â Â Â self.button.setEnabled(False) Â Â Â Â Â Â Â Â # Open the URL address. Â Â Â Â Â Â Â Â url = \"https://www.python.org/ftp/python/3.7.2/python-3.7.2.exe\" Â Â Â Â Â Â Â Â filename = \"python-3.7.2.exe\" Â Â Â Â Â Â Â Â with urlopen(url) as r: Â Â Â Â Â Â Â Â Â Â Â Â with open(filename, \"ab\") as f: Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â while True: Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # Let Qt process its events so the window Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # doesn't freeze. Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â QCoreApplication.processEvents() Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # Read a chunk of the file we are downloading. Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â chunk = r.read(128) Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # If the result is `None`, that means there Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # is no downloaded data yet. Just keep Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # waiting. Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â if chunk is None: Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â continue Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # If the result is an empty `bytes` instance, Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # that means the file is complete. Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â elif chunk == b\"\": Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â break Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â # Write the downladed chunk into the local file. Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â f.write(chunk) Â Â Â Â Â Â Â Â self.label.setText(\"Â¡File downloaded!\") Â Â Â Â Â Â Â Â # Restore the button. Â Â Â Â Â Â Â Â self.button.setEnabled(True) if __name__ == \"__main__\": Â Â Â Â app = QApplication([]) Â Â Â Â window = MainWindow() Â Â Â Â window.show() Â Â Â Â app.exec_()\n\nThe main point here is between the lines 29 and 45, where we set up the loop that process the application events, fetches a little chunk of data from the network, and throws it in a local file until there's no more data to be received.\n\nSince the whole code runs in a single thread, we don't need to care about the problems concerning accessing and modifying objects, as we did in the previous code. However, r.read(128) is still a blocking call that freezes the code execution, although during a very little (and probably imperceptible) time. Be the internet connection incredibly slow, and even this little amount of bytes might freeze the user interface, so consider changing the chunk size accordingly.\n\nThird workaround. TwistedÂ¶\n\nThe qt5reactor module let us use Twisted and Qt within a single application, which give us access to the rich set of asynchronous functions provided by the networking library. For this third workaround we will also use the treq library (which is similar to Requests, but built on top of Twisted) to connect to the URL address and download its content. So let's first install these tools:\n\npip install qt5reactor treq\n\n(Twisted will be automatically installed since its required by both modules.)\n\nOnce installed, the code is the following:\n\nfrom PyQt5.QtCore import QCoreApplication from PyQt5.QtWidgets import QApplication, QMainWindow, QLabel, QPushButton from twisted.internet.defer import inlineCallbacks class MainWindow(QMainWindow): Â Â Â Â def __init__(self): Â Â Â Â Â Â Â Â super().__init__() Â Â Â Â Â Â Â Â self.setWindowTitle(\"File Download with PyQt & Twisted\") Â Â Â Â Â Â Â Â self.resize(400, 300) Â Â Â Â Â Â Â Â self.label = QLabel(\"Press the button to start the download.\", Â Â Â Â Â Â Â Â Â Â Â Â self) Â Â Â Â Â Â Â Â self.label.setGeometry(20, 20, 200, 25) Â Â Â Â Â Â Â Â self.button = QPushButton(\"Start download\", self) Â Â Â Â Â Â Â Â self.button.move(20, 60) Â Â Â Â Â Â Â Â self.button.pressed.connect(self.initDownload) Â Â Â Â def initDownload(self): Â Â Â Â Â Â Â Â self.label.setText(\"Descargando archivo...\") Â Â Â Â Â Â Â Â # Disable the button while downloading the file. Â Â Â Â Â Â Â Â self.button.setEnabled(False) Â Â Â Â Â Â Â Â url = \"https://www.python.org/ftp/python/3.7.2/python-3.7.2.exe\" Â Â Â Â Â Â Â Â # The `requestSucceeded()` will be invoked when the connection Â Â Â Â Â Â Â Â # to the URL address has been successfully established. Â Â Â Â Â Â Â Â treq.get(url).addCallback(self.requestSucceeded) Â Â Â Â @inlineCallbacks Â Â Â Â def requestSucceeded(self, response): Â Â Â Â Â Â Â Â # Get the content of the remote file. Note that Â Â Â Â Â Â Â Â # this operation doesn't block the execution of Â Â Â Â Â Â Â Â # the code. Â Â Â Â Â Â Â Â content = yield response.content() Â Â Â Â Â Â Â Â # We write the content in a local file. Â Â Â Â Â Â Â Â with open(\"python-3.7.2.exe\", \"wb\") as f: Â Â Â Â Â Â Â Â Â Â Â Â f.write(content) Â Â Â Â Â Â Â Â self.label.setText(\"Â¡File downloaded!\") Â Â Â Â Â Â Â Â # Restore the button. Â Â Â Â Â Â Â Â self.button.setEnabled(True) Â Â Â Â def closeEvent(self, event): Â Â Â Â Â Â Â Â QCoreApplication.instance().quit() if __name__ == \"__main__\": Â Â Â Â app = QApplication([]) Â Â Â Â import qt5reactor Â Â Â Â qt5reactor.install() Â Â Â Â window = MainWindow() Â Â Â Â window.show() Â Â Â Â from twisted.internet import reactor Â Â Â Â import treq Â Â Â Â import os Â Â Â Â import certifi Â Â Â Â # Required for HTTPS connections. Â Â Â Â os.environ[\"SSL_CERT_FILE\"] = certifi.where() Â Â Â Â reactor.run()\n\nTwisted is a right option when our heavy tasks are network-related and its usage is recurrent in the code. treq's HTTP requests are built on top of Twisted's deferreds, which are similar to Qt signals when we need to call a user-defined event. Here we don't have to take care of the problem concerning sharing objects between threads neither, since Twisted is single-threaded.\n\nThose who are well-versed in Twisted will find this workaround very satisfactory. And, indeed, it is: Qt and Twisted work really well together, since they have an alike structure, philosophy and even naming conventions (mixedCase instead of lower_case).\n\nConclusionÂ¶\n\nSo let's summarize the three workarounds we have seen. The threads approach works for any heavy task, although must be implemented prudently since thread-safety is hard to achieve. If your application makes HTTP requests very often or interacts with other network resources, and if you feel comfortable with Twisted, you will like the qt5reactor and treq solution. Finally, if your heavy task can be decomposed into little steps (such as calling r.read(128) multiple times), then just adding a QCoreApplication.processEvents() call in the right place will prevent your user interface from freezing."
    }
}