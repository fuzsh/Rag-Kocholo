{
    "id": "dbpedia_5009_3",
    "rank": 33,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/88685/why-arent-more-desktop-apps-written-with-qt",
        "read_more_link": "",
        "language": "en",
        "title": "Why aren't more desktop apps written with Qt?",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://softwareengineering.stackexchange.com/posts/88685/ivc/60dd?prg=f55ca845-c212-426c-b384-7683f225437d"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2011-07-01T05:58:08",
        "summary": "",
        "meta_description": "As far as I know and have understood in my experience with Qt, it's a very good and easy to learn library. It has a very well designed API and is cross-platform, and these are just two of the many",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/88685/why-arent-more-desktop-apps-written-with-qt",
        "text": "As people say, each tool fits to each problem and situation...\n\nBut if you're C++ programmer, Qt is your framework. No rival.\n\nWe develop a complex medical imaging commercial application, and Qt holds on.\n\nI don't say that the 'cons' that people say about it are false, but I have the feeling that they don't have tried Qt for a long time (its continously improving on each new version...) And, mostly all of the issues they comment are not a problem if you take care.\n\nUI platform inconsistency: only if you use the UI widgets 'as they are', with no customization or custom art.\n\nQt preprocessor overload: Only if you abuse of signal-slot mechanism, or QObject inheritance, when there is no really need.\n\nBy the way, We still write applications in C#.NET, and been doing it for a long time. So I think I have enouch perspective.\n\nAs I said, each tool for each situation,\n\nbut Qt is with no doubt a consistent and useful framework.\n\nOf all the things I don't like about Qt, the fact that it doesn't play well with templates bugs me the most. You can't do this:\n\ntemplate < typename T > struct templated_widget : QWidget { Q_OBJECT; public signals: void something_happened(T); };\n\nIt also doesn't play well with the preprocessor. You can't do this:\n\n#define CREATE_WIDGET(name,type) \\ struct name ## _widget : QWidget \\ { \\ Q_OBJECT; \\ \\ public signals: \\ void something_happened(type); \\ }\n\nThat, mixed with the fact that everything that responds to a signal has to be a Q_OBJECT, makes Qt hard to work in for a C++ programmer. People used to Java or Python style programming probably fair better actually.\n\nI actually spent a lot of time and effort researching and devising a way to gain type safety back and connect a Qt signal to any functor object: http://crazyeddiecpp.blogspot.com/2011/01/quest-for-sane-signals-in-qt-step-1.html\n\nThe kind of thing I want to do there is basic, everyday C++ development made next to impossible by the Qt moc...which itself is entirely unnecessary now days, if it ever actually was.\n\nFrankly though, I'm stuck with it because if you want to do automated UI testing, Qt is pretty much the only game in town short of MFC...which is so 1980 (it sucks working in that shit really hard). Some might say WX but it's got even more serious problems. GTKmm would have been my first choice but since it's all owner drawn and doesn't do accessibility...can't be driven by industry standard testing software. Qt is hard enough in that regard (barely works when you modify the accessibility plugin).\n\nOne reason to not use Qt is that if you only write for one architecture, such as Windows, you may want to use C#/.NET (or Cocoa on Mac) because they will invariably be able to take advantage of the latest bells-and-whistles of the OS.\n\nIf you are writing cross-platform apps, then you may already be heavily vested in another technology such as Java (i.e. you work in a \"Java Shop\"). Your choice of technology might be dictated by the ecosystem in which you are developing, such as language-specific APIs. In these sorts of cases, minimizing the number of technologies may be beneficial.\n\nA third reason that I can think of is that Qt is based around C++, and C++ is a comparatively difficult/dangerous language to program in. I think it is a language for professionals. If you need to have top performance and are capable of being meticulous, then C++ is probably still the best game in town. Actually, Qt ameliorates a lot of the memory management problems if you set things up to fall out of scope. Also, Qt itself does a good job insulating the user from a lot of the nasty C++ issues. Every language and framework has its pros and cons. It is a very, very complicated issue that usually can be summarized by the addage often seen in diners: Speed, Quality, and Price (but you can only pick two).\n\nAlthough the rules say I should keep focused on answering the question, I do want to rebut some of the issues raised by Billy ONeal, who I think does a good job summarizing the commonly cited reasons to not use Qt:\n\nQt is indeed a C++ library/framework/header files. It is augmented by a macro processor (moc) which enables signals and slots, among many other things. It transforms additional macro commands (such as Q_OBJECT) so that classes have introspection and all sorts of other goodies that you might think of as adding Objective-C functionality to C++. If you know enough about C++ to be offended by this lack of purity, i.e. you are a pro, then 1) don't use Q_OBJECT and its ilk or 2) be grateful that it does this, and program around the very limited corner cases where this causes a problem. For folks who say \"Use Boost for signals and slots!\" then I would retort that you are exchanging one \"problem\" for another. Boost is huge, and it has its own commonly-cited issues such as poor documentation, horrendous API, and cross-platform horrors (think old compilers like gcc 3.3 and big iron compilers like AIX).\n\nFor editor support, this also follows from 1, I somewhat agree. Actually, Qt Creator is IMHO the best graphical C++ editor, period, even if you don't use the Qt stuff. Many professional programmers use emacs and vim. Also, I think Eclipse handles the additional syntax. Thus, no problems with the Qt macros (Q_OBJECT) or signals/slots additions. You will probably not find these macros in Visual Studio, because (I concede) they are additions to C++. But by and large, C#/.NET folks aren't going to be using Qt anyway, due to the fact that they have a lot of the functionality covered with their own proprietary techniques.\n\nAs to the size of the Qt source, so long as it compiles overnight, who cares? I compiled Qt 4 on my dual core Macbook in \"less than overnight.\" I certainly hope this is not what is driving your decision to use or not use a particular technology. If this is truly a problem, then you can download the precompiled SDKs for Mac, Linux, and Windows from the Qt website.\n\nLicensing is available in three choices: 1) Proprietary license in case you wish to modify Qt ITSELF and not share, or hide the fact that one is using Qt and not willing to give attribution (could be very important for branding and image!) 2) GPL and 3) LGPL. Yes, there are issues with static linking (rolling all of Qt into the binary) -- but I think that's more because one can't peek inside and notice that you are using Qt (attribution!). I tried to buy a proprietary license from Digia, and they told me \"for what you are doing, you really don't need it.\" Wow. From a business who is in the business of selling licenses.\n\nThe size of the binary/bundle is because you have to distribute the Qt stuff to folks who don't have it: Windows already has? the Visual Studio stuff or you have to install the run-time. Mac already comes with the enormous Cocoa, and can be dynamically linked. Though I don't do a lot of distribution, I have never found much issue with distributing the ~50 megabyte static file (which I can make even smaller with some of the binary stripper/compression utilities like UPX). I just don't care enough to do this, but if bandwidth were ever an issue, I would add a UPX step to my build script.\n\nWhat defines \"Native Look and Feel?\" I think \"most\" would agree that Mac comes closest to unified look and feel. But here I sit, looking at Safari, iTunes, Aperture, Final Cut Pro, Pages, etc. and they look nothing alike despite the fact that they are made by the OS vendor. I think the \"feel\" aspect is more relevant: widget styling, responsiveness, etc. If you care about responsiveness, then here is a good reason to use C++ rather than Java, or some other highly dynamic language. (Objective C also rocks, but I'm trying to dispel myths about Qt)\n\nIn summary, it's a complicated issue. But I would like to point out that I think there are less reasons to \"not use Qt\" as one might think based on myths and decade-out-of-date information.\n\nSome of it is licensing. See https://en.wikipedia.org/wiki/Qt_(software)#Licensing for some of the licensing history. Until 2000, people who cared strongly about open source, did not use Qt. Period. (This was, in fact, the original motivation for the development of Gnome.) Until 2005, people who wanted to be able to release free software for Windows did not use Qt. Even after that date people who wanted free software under something other than the GPL, simply did not have the option of using Qt. Thus any free software project that is older than those dates, couldn't use Qt. And, of course, people writing proprietary code had to pay for the privilege.\n\nFurthermore it is not as if there is a shortage of other options. For instance WxWidgets, GTK+, and Tk are all open source, cross-platform toolkits.\n\nFurthermore for a long time Windows was so dominant on the desktop that a lot of software was content to only run on Windows. If you install the Microsoft toolchain, it is easier just to use Microsoft's proprietary stuff than it is to worry about anything else, and a lot of programmers did just that.\n\nI agree with nearly all of the reasons discussed above however a lot of people here have said they wouldn't use Qt because of the extra overhead that it brings with it. I disagree with that because all the most common languages today (Java, C# and Python) carry a fair bit of overhead themselves.\n\nSecondly, Qt makes programming with C++ so easy and straight-forward that it makes up for the extra resources it uses. I've come across quite a few console applications written in Qt rather than standard C++ because of the ease in which they can be written.\n\nI would say that the productivity of Qt is greater than that of C/C++ but less than languages like Python.\n\nThis genuinely isn't an attempt to start a flame war, I just wanted to address some of the points.\n\nProbably the real reason that Qt isn't more widely used is that it's C++ and fewer people use c++ for desktop apps.\n\nQt is not a C++ library. It requires a separate compilation step, which makes the build process much more complicated when compared with most other libraries.\n\nThe vs-addin for visual studio does this automatically as does Qt's own commandline make process. The resource compiler used to build the dialogs for MFC is also a separate step but that's still c++.\n\nQt is a large amount of source, which must be present and preinstalled on any machine you use before compiling. This can make setting up a build environment much more tedious.\n\nThere is a binary download for each version of visual studio and the build from source is a single command. I don't see SDK source size is so much of a deal these days. Visual studio now installs all the C++ libs rather than letting you pick and choose, as a result the install size of the compiler is >1Gb.\n\nIt's available only under LGPL, which makes it difficult to use single-binary-deployment when one needs to release under a more restrictive or less restrictive license.\n\nThe LGPL only applies to the lib, it doesn't affect your code. Yes it means you have to ship DLLs rather than a single binary (unless you pay), but in a world where you need to download a Java runtime or a .Net update for a tiny util this isn't such a big deal. It's also less of a problem on platforms with a single ABI so that other Qt apps can share the libs.\n\nIn some cases, it just doesn't look like native programs look. Designing a single UI for all platforms inherently is not going to look right when moved from machine to machine, for various visual styling reasons.\n\nIt's supposed to use native widgets and themes. I must admit I do mostly technical apps so my users aren't too concerned about style. Especially on windows the new fashion for having everything style itself as a smartphone widget means that there is less and less of a standard anyway.\n\nThe reason is simple: it does not have good bindings to all mainstream languages, and it is not magically always appropriate for the job at hand.\n\nUse the right tool for the job. If I'm writing a simple command-line application, why would I bloat that up with Qt just for the sake of it?\n\nAs a more general answer (which I can give because I'm relevant here), some programmers will simply never have given it a go and decided to use it. In some cases there is no particular reason other than the programmer has never found a need for it and looked into it.\n\nI agree that Qt is a nice framework to work with. Still, there are a number of issues I have with it:\n\nIt is written in C++, which is a really low level language. The fact alone that it is C++ will make every Qt programmer significantly less productive compared to Frameworks written in other languages. My main beef with C++ as a GUI development language is that it has next to no notion of automatic memory management, which makes the development process a lot more prone to errors. It is not introspective, which makes debugging a lot more difficult. Most of the other major GUI toolkits have some notion of automatic memory management and introspection.\n\nEvery cross-platform toolkit suffers from the problem that it only ever can implement the least common denominator of all supported platforms. That, and different UI guidelines on different platforms very much questions the desirability of cross-platform GUIs at a whole.\n\nQt is very much centered on coding up all your UI. Even though you can use QtDesigner to build some parts of your UI, it is seriously lacking in comparison to, say, (Cocoa/Obj-C) Interface Builder or the .Net tools.\n\nEven though Qt does include a lot of low-level application functionality, it can not compare to having a framework hand-tailored for a certain platform. The native operating system libraries for both Windows and OSX are significantly more powerful than Qt's implementations. (Think audio frameworks, low level file system access etc.)\n\nThat said, I love using PyQt for rapid application prototyping or in-house applications. Using Python to do all the coding alleviates the concerns with C++ and actually makes Qt a very pleasant place.\n\nEdit, in response to some comments:\n\nWhen I wrote about Qt being written in C++, I was not so much complaining about Qt itself, but more about the environment it lives in. It is true that Qt manages its own resources very well, but all your GUI-related-but-not-Qt code has to be written in C++, too. Even there, Qt provides many nice tools, but ultimately, you have to deal with C++ at that level. Qt makes C++ bearable, but it is still C++.\n\nAs for introspection, what I mean is this: The hardest cases to debug are when you have a pointer to some object that does not behave the way you think it should. With C++, your debugger might be able to look inside that object a bit (if it happens to have type information at thwt point), but even that does not always work. Take, on the other hand, Cocoa in the same situation. In Cocoa/Obj-C, you would be able to send messages ('call functions') to an object right within the debugger. You can change the objects state, you can query it for its attributes, you can ask it for its type and its function names... This can make debugging a lot more convenient. Qt/C++ has nothing even close to that.\n\nThe most important but not mentioned thing. In big project one thing causes so much problems and non necessary code. Qt's signal slot mechanisms is inefficient. Qt widgets does not provide necessary signals for event simple widgets. For example you can not set signals for onHover, onMouseEnter, onMouseLeave, onKeyReleased, onLostFocus, onGainFocus and etc. Even the most complex widget such as QTreeWidget does provide one or two ultra simple useless signals.\n\nYes, you can use events BUT !!! you have create new class for each widget with custom event. This is huge efficiency lost;\n\nYou have rewrite each customized widget object event there is small changes.\n\nYou lose all of Qt Designer stuff. You have to promote every widget with custom events.\n\nProject became bigger and hard to maintain.\n\nYou started dislike qt because of this. And starting to talk about how .net provides delegates, how it is much much much more better than signal slot, how .net components (widgets) generally provides every event that you can imagine. And etc.\n\nOne of my college has wrote made new combo box class for each combo box widget because he had to use some non signal event. True story...\n\nHowever, Qt is the best C++ UI framework so far with downs and ups.\n\nI really like Qt, but it's a bit heavyweight for a lot of applications. Sometimes you just don't need that level of complexity. Sometimes you just need something simple without all the overhead of Qt. Not every application needs to be event driven and C++ provides a reasonable set of templates. Boost provides another very good set and includes a lot of the low-level functionality (file, socket, managed pointers, etc) that QT does.\n\nOther applications have licensing requirements that don't play nice with GPL, LGPL or Qt's commercial license. The GPL is inappropriate for commercial software. The LGPL is inappropriate for statically linked software and the commercial license costs money - something that many are unwilling to pay.\n\nSome have security or stability considerations that don't allow complex libraries like Qt.\n\nYou need to run moc to pre-process your sources. That's not a huge issue, but it can be daunting for the new user. A lot of programmers think you need to use qmake with Qt, but that's a misnomer. It is possible to plug Qt into other build systems pretty easily.\n\nSome targets are very memory or CPU constrained.\n\nThere some platform-specific gotchas in it. Most of those gotchas are undocumented. Build a sufficiently large application and you will run into them and wonder what's going on (disclaimer, the last time I used Qt in anger was over 18 months ago, so it may have improved).\n\nIt's C++ only. Other language bindings exist, but they tend to hide or poorly expose a lot of the functionality that you'd want Qt for.\n\nThere's a lot of reasons to not use Qt, that's why there are alternatives. If all you have is a hammer then every problem will look like a nail."
    }
}