{
    "id": "dbpedia_5009_3",
    "rank": 82,
    "data": {
        "url": "https://decovar.dev/blog/2018/02/17/build-qt-statically/",
        "read_more_link": "",
        "language": "en",
        "title": "At last, let's build Qt statically",
        "top_image": "https://decovar.dev/favicon-32x32.png",
        "meta_img": "https://decovar.dev/favicon-32x32.png",
        "images": [
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/qt-configure.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dynamic-vs-static.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/visual-studio-installer.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/install-qt-msvc.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/win-libgcc.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/qt-creator-versions.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/qt-creator-kits.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/qt-creator-build.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dependency-walker-dynamic-msvc.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dependency-walker-static-msvc.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dependency-walker-dynamic-mingw.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dependency-walker-static-mingw.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/static-vs-dynamic-ram-mac.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/static-vs-dynamic-ram-windows.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/static-vs-dynamic-ram-linux.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/d3d12-is-missing-ru.jpg",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/d3d12-is-missing.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-compiler-c.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-compiler-cpp.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-debugger.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-qt-version.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-kit.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-dependency-walker-qmake.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-missing-dll-libgcc.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-missing-dll-libzstd.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-dependency-walker-cmake.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-qmake-cmake-imports-diff.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/mingw-x32-qmake-cmake-imports-diff-fixed.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/shock.jpg",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/m2-qt-creator-compiler-c.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/m2-qt-creator-compiler-cpp.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/m2-qt-creator-qt-version.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/m2-qt-creator-kit.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/m2-otool-diff.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dynamic-qt-missing-platform-platform.png",
            "https://decovar.dev/blog/2018/02/17/build-qt-statically/images/dynamic-qt-missing-unknown-dlls.png",
            "https://decovar.dev/images/avas/spike.png",
            "https://decovar.dev/images/rss.png",
            "https://decovar.dev/images/telegram.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "retif"
        ],
        "publish_date": "2018-02-17T00:00:00",
        "summary": "",
        "meta_description": "At last, let's build Qt statically",
        "meta_lang": "",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": "https://decovar.dev/blog/2018/02/17/build-qt-statically/",
        "text": "For quite a long time statically built Qt was kind of a mystery to me. I always used dynamic builds and had lots of involuntary sexual intercourses with macdeployqt/windeployqt (perhaps I should write about this too).\n\nBut not anymore, because I finally overcame my fears/stupidity/laziness, RTFMed and managed to build Qt statically.\n\nAlthough the article is (mostly) about making a static build, it also covers building Qt from sources in general and other related activities (such as linking with the resulting build, deploying applications and so on).\n\nTLDR\n\nThe article has really exploded in volume over the years, so here are some general commands for configuration and building static Qt.\n\nOn Windows:\n\nOn GNU/Linux:\n\nOn Mac OS:\n\nAlso note that this article was written when Qt 5.x was the latest version available, so it doesn’t account for all the peculiarities of building Qt 6.x or newer (although the process is mostly the same). But here is a more recent partly related article about installing Qt without official installer, which covers Qt 6.x too.\n\nWhy build Qt statically\n\nThere are 3 main reasons:\n\nEasier deployment;\n\nSmaller binaries size;\n\nBetter security.\n\nDeployment of dynamically linked Qt applications always was (is) not a trivial task. While everything works on your development machine, being deployed on another machine your applications most likely will complain about all sorts of missing libraries.\n\nWhat I did in the past - I just copied the entire set of Qt libraries to the application directory and then application started working. But, first of all, copying just Qt libraries is not enough, there are some other libraries that need to be deployed along, and secondly, the final size of the deployed application can easily exceed a couple of hundreds of megabytes, which is not really okay even for desktop targets, not to say about embedded devices with quite a limited space available.\n\nHaving built your application statically linked, you get everything all-in-one - a single executable file which is very easy to deploy and it will have a smaller size comparing with its dynamically linked equivalent.\n\nHowever, if your deployment target has several Qt-based applications, then static linking is not that attractive in terms of saving space, because in case of dynamic linking every Qt-based application can use the same set of shared Qt libraries, which you need to deploy only once. Here’s a simplified picture about it:\n\nAs you can see, even though 1 statically linked application takes less space than 1 dynamically linked, but when you have 4 applications, then you can save more space on your disk by using dynamic linking: 620 - 220 = 400 MB of space saved. Not bad indeed, but again - this is just a simplified example, and real numbers probably won’t be that exciting.\n\nSpeaking about security - that one usually refers to the fact that application relying on shared libraries is easier to hack (because you can replace libraries with the modified ones). But I am not sure if it’s really the case, because if shared libraries are exposed for hacking then it probably means that the whole OS is compromised, so there is no much point to fight the fire in the ashtray when entire building is in flames. And also as far as I know it is possible to sign shared libraries and perform checks before actually loading them.\n\nAbout Open Source licenses compliance\n\nBe aware, that if you are using Qt under LGPL, then using static linking might make it harder for you to comply with the license terms and keep your code private at the same time.\n\nBut if you are using Qt under GPL, then it doesn’t matter to you anyway as your code already belongs to community.\n\nPlease note, that I am not a lawyer, and this is just my interpretation of the license text, so don’t make business decisions based only on my comments - consult with a proper legal specialist.\n\nHow to build Qt statically\n\nConfiguration\n\nIt is actually embarrassingly easy. You only need to run the configure utility with the right set of parameters.\n\nI’ll describe the process for Mac OS (works like a charm), Linux (there are some tiny problems) and Windows (doesn’t fucking work lots of problems).\n\nThe first step is the same for all platforms: create a folder for shadow build and run configure command from there:\n\nNote how configure doesn’t care about short/long options and just has a single - for everything.\n\nHere’s a description for the options I used:\n\n-static - this one tells to build exactly a static version;\n\n-release - because I need static build only for publishing my apps, therefore there is no need in static debug build, so it can be skipped. For debugging/profiling I’ll keep using dynamic build;\n\n-no-pch - no precompiled headers, meaning that all the header files (.h) will not be precompiled, so you’ll get all the benefits from #ifdef. Moreover, for some platforms Qt won’t even build with precompiled headers turned on;\n\n-prefix \"/path/to/qt/510-static\" - where to put the result;\n\n-skip webengine - I don’t need WebEngine;\n\n-nomake tools - I don’t need static tools (Qt Creator, Designer, etc);\n\n-nomake tests - I don’t need tests;\n\n-nomake examples - I don’t need examples.\n\nThe set of options can differ from platform to platform. In my case it was the same for Mac and Linux, but for Windows I had to add two additional ones.\n\nFull list of all possible options you can find in the documentation. Or you can get it from configure itself. Here’s an output from Qt 5.11.1 on Mac OS:\n\nCore options section refers to 3rd-party libraries, and quite often I see in different places people putting options like -qt-zlib, -qt-libpng and so on for configure. Although, if you won’t set them, it doesn’t mean that you won’t have those libraries in your build - they just will be included with default values: some with Qt implementations and some with system ones. You can check which ones exactly are set in the configure summary output (after you run it).\n\nOptimization options\n\nQt build can be configured with so-called optimization options:\n\n-ltcg - Link-Time Code Generation, optimizes something. I took it from here\n\n-optimize-size - seems to be optimizing release builds in terms of resulting binaries size (by sacrificing build time)\n\nTo see the actual effect of such optimization, I built Qt 5.12.3 on Mac OS twice, first time with these options:\n\nand second time without them:\n\nResults are here:\n\nSo, indeed, -optimize-size does provide smaller application binaries, but at the same time you lose in Qt build time, its size and also applications build time.\n\nWhat -ltcg actually does - that I still don’t know and have no idea how to measure it.\n\nI had these options enabled for most of the builds described below, and on Windows it caused certain problems, so perhaps I would recommend not to set those in your builds.\n\nCleaning the build directory\n\nNote, that if you were building Qt before, then you should clean out the old build first (and the folder you’ve set with -prefix):\n\nor:\n\nPlatforms\n\nMac OS\n\nSo, you ran configure and now it asks you which edition you would like to build and also if you accept the license (these two are also available as options for configure):\n\nAfter that it will generate configuration summary and perform some checks:\n\nNow you need to actually build it. It is done by running make command, and it is important to note that it will be doing it for ages, because by default it doesn’t parallelize the process. So, if you, like me, have 8 cores in your CPU (4 physical and 4 logical), you can run it like that:\n\nWith -j8 provided, it took 32 minutes to build Qt statically on my MacBookPro with 2.8 GHz Intel Core i7.\n\nHowever, if there will be any error, the only output you’ll get will be:\n\nAnd to see the errors you’ll have to run make without -j8.\n\nLast step is to “install” your new static Qt:\n\nThat should take a couple of minutes (usually less than a minute), and then you can go to /path/to/qt/510-static to see the result. If installation runs for more than 5 minutes, than it likely means that something is wrong and it might actually fail. This concerns not only Mac OS but other platforms too.\n\nLinux\n\nAll the same as for Mac OS, but I encountered 2 problems.\n\nFirst one was missing g++, which is fixed by installing build tools:\n\nSecond one was this:\n\nWhich is fixed by installing Mesa libraries:\n\nAnd actually documentation says about that, but I didn’t notice at first.\n\nNote here, that even after you install the missing stuff, configure won’t know about it, because it performs all the checks only once, and after that it relies on the generated config.cache, so every time you change something - delete config.cache before launching configure again.\n\nI have Linux on Lenovo T540p laptop with 2.5 GHz Intel Core i7, and there it takes 43 minutes (with make -j8) to built Qt statically.\n\nAfter executing the last step (make -j8 install) you will get your static Qt in the folder specified with -prefix parameter.\n\nWindows\n\nI was trying to build Qt on Windows from time to time, and usually it fails, but sometimes it actually does build.\n\nQt 5.10.1, Windows 10 and MinGW x32\n\nI have Windows 10 running on the same Lenovo laptop, and there I use Qt (d:\\Programs\\Qt) with MinGW (you should have \\path\\to\\Qt\\Tools\\mingw530_32\\bin in your PATH).\n\nFirst I tried to do it with Qt 5.10, but it failed with some error about dummy platforms. I wanted to investigate that, but then suddenly Qt 5.10.1 was released, so I tried with this version and this time it didn’t give me that error.\n\nBut I got another error anyway, and it was about OpenGL:\n\nSo I added -opengl desktop to the list of configure options. In addition to that, in some article I read about the option -platform win32-g++, which apparently would have fixed the dummy platform error. So, the final command line now looks like this:\n\nI executed it and after a while (like, 10 times slower than on Linux) I got the following output:\n\nNext step was to run make:\n\nBut it failed:\n\nI tried setting flags in qmake.conf like it is said here, but that didn’t help (I found the actual reason later).\n\nOkay then, let’s try another computer - who knows, maybe my environment is messed up somehow. So I installed Qt to another machine with Windows and tried to perform configure. There it gave me a different type of error:\n\nOkay, I provided -platform win32-g++ (and -opengl desktop) and relaunched configure. It asked me about edition, I chose commercial, and…\n\nBut I do have a commercial license! And the license file is where it should be. But okay, let’s try Open Source option:\n\nYeah, fuck this shit.\n\nQt 5.11.1, Windows 7 and MSVC2015 x64\n\nAfter quite a while I gave it another shot as I needed to build static Qt for Windows 7 with MSVC2015.\n\nSo, here are the steps.\n\nInstall DirectX and DirectX SDK. Most likely it is not required, but I would do it just in case;\n\nInstall Python (I took 3.7), Perl and make sure that both are added to PATH. Thank you, Qt documentation, for not mentioning Python and Perl at all, because I discovered it by getting the following error:\n\nWhich does not explain anything, but having googled it, I found out that it’s exactly due to the missing Python and Perl.\n\nInstall .NET 4.6, which is needed for Visual Studio installer. Choose the following components from VS:\n\nYes, even though you’re on Windows 7, install Windows 8.1 SDK. Although, it could be that only UCRT component is needed.\n\nNow install Qt:\n\nIt is actually not required to install pre-built MSVC Qt (you only need Sources), but I wanted to compare dynamic with static, so I installed it.\n\nGet jom and add it to PATH. If you won’t do this, Qt will be built with nmake, which will take ages as it cannot use more than one CPU core (no -j option).\n\nCreate a folder for shadow build, launch VS2015 x64 Native Tools Command Prompt from your Start menu and go to this folder. Then build Qt from there:\n\nIt took 35 minutes (on the same Lenovo laptop) to build 487 MB of binaries, and then it took a 1 hour and 40 minutes to perform install, which resulted in 560 MB. I don’t know why it takes so long to perform install, but what’s more amusing is that sometimes it takes just a couple of minutes as it should - no idea what Windows “magic” is behind that.\n\nNote that I don’t have -ltcg option this time. I actually had it, but it resulted in something ridiculous: the build itself occupied fucking 46 GB of space, and after install command I got another 22 GB. What is the actual fuck. Apparently, it has something to do with the compiler (hello, Microsoft), because the .lib files were matching the .obj folder (someone told me that, I’ve no idea what it means).\n\nDuring both build and install phases I got several occasional freezes of my PC when it became totally unresponsive so I had to hard-reset the machine and start over. Windows is definitely my favorite development platform.\n\nBut okay, most importantly thing is that it has successfully built and that it works.\n\nAlso note, that I haven’t set any special flags which you can find being mentioned all over the internet (QMAKE_CFLAGS_X and others) and didn’t edit any configs - everything just builds as it is with out-of-the-box configuration.\n\nQt 5.11.1, Windows 10 and MSVC2017 x64\n\nJust in case I decided to try Windows 10 and MSVC2017.\n\nAgain, it’s all the same: Python and Perl in your PATH, Visual Studio installed but this time with MSVC2017, you launched VS2017 x64 Native Tools Command Prompt.\n\nAnd again, with -ltcg option it produced 14.5 GB after build, then increased that to 52.6 GB, having installed 25.7 GB of static Qt. Compilation took 18 minutes, and installation was going for 59 minutes.\n\nWithout -ltcg it produced 480 MB after build, increased that to 1.34 GB and installed 606 MB of static Qt. Compilation took 15 minutes, and installation was going for 44 minutes.\n\nQt 5.11.2, Windows 10 and MinGW x32\n\nAfter I succeeded building Qt with MSVC, I decided to try MinGW again with just released Qt 5.11.2.\n\nIt’s all the same as for Windows 7, except for installed Python and Perl.\n\nConfiguration went okay, but mingw32-make failed literally within a couple of minutes:\n\nI almost cursed everything forever, but then suddenly I decided to… try without -ltcg option. And it fucking worked! Hallelujah.\n\nAlthough, in case of MinGW there is one more thing you should know about - its runtime doesn’t link statically by default. Surprise! So having deployed your statically linked Qt application to some other computer, you can get the following error:\n\nIn order to link MinGW runtime too, you need to set yet another option: -static-runtime.\n\nSo, the final configure options for building static Qt with MinGW on Windows is the following:\n\nBuilding took 1 hour and 14 minutes and 1.02 GB. Installing took 8 minutes and resulted in 460 MB.\n\nNow I can finally state that MinGW static builds of Qt do actually work. By the way, contrary to many manuals from the internet, I haven’t used any additional scripts or MSYS environment - everything just works within regular cmd.\n\nHow to use static Qt\n\nYou need to add static Qt in your Qt Creator settings:\n\nAfter that you just need to add this kit to your existing project and build with it:\n\nHow exactly static build is different\n\nLet’s see how to use static Qt in your projects and also let’s compare some metrics between dynamic and static builds. I took Cinematic Experience demo for experiments.\n\nNo more shared libraries\n\nYou can see for yourself that dynamically linked applications have dependency on Qt shared libraries and statically linked ones do not.\n\nMac OS\n\nDynamic:\n\nStatic:\n\nI’ve no idea why why it has a much longer list of some other stuff.\n\nLinux\n\nOn Linux it makes more sense.\n\nDynamic:\n\nStatic:\n\nWindows\n\nOn Windows there is no out of the box tool to track dependencies, so I used Dependency Walker.\n\nAnd it’s worth to mention that MSVC and MinGW builds have different set of dependencies.\n\nMSVC\n\nDynamic MSVC:\n\nStatic MSVC:\n\nMinGW\n\nDynamic MinGW:\n\nOh, by the way, in case of dynamic linking it’s not a trivial task to gather all the required Qt libraries based on what Dependency Walker shows you. For instance, here we can see that only 3 Qt libraries are required, but after I deployed those, my application complained about one more, and when I added that one, it stopped complaining, however having launched it I never saw its window, even though application was present among the running processes at Task Manager. And only after a set of tests and trials I’ve managed to collect the full pack:\n\nFrom that perspective MinGW static linking on Windows is really a savior:\n\nIf you are confused by longer list for static builds - this whole bunch of system libraries is actually from the SHELL32.DLL tree, and you can find them in dynamic build too by expanding its node. What matters is that there are no Qt libraries (and no MinGW runtime) among dependencies anymore.\n\nSmaller builds\n\nNaturally, static build gives you smaller size for your application binary.\n\nOn Mac OS:\n\ndynamic (with all required Qt libraries): 33.4 MB;\n\nstatic: 26.1 MB.\n\nOn Windows (MinGW):\n\ndynamic (with all required Qt libraries and MinGW runtime): 28.2 MB;\n\nstatic: 19.9 MB.\n\nLess RAM\n\nI saw people claiming that RAM consumption is different too. On Mac it’s not really the case:\n\ndynamic: 118.7 MB;\n\nstatic: 116.8 MB.\n\nWindows (MinGW) has some difference, but not that big:\n\ndynamic: 168.9 MB;\n\nstatic: 160.7 MB.\n\nAnd there is some notable difference on Linux:\n\ndynamic: 141.0 MB;\n\nstatic: 115.2 MB.\n\nSlower building\n\nBut there is also a trade-off in terms of compilation time (measured on Mac OS):\n\ndynamic: 5 seconds;\n\nstatic: 210 seconds.\n\nPossible problems\n\nThere could be all sorts of problems along the road. And those are not necessarily your fault - on the contrary, in most cases it will be Qt bugs, which you should definitely report at Qt’s bug-tracker. Seriously, do that, because they give highest priority to that kind of issues (especially if it’s reported against a pre-release version) and fix those pretty fast.\n\nNow about the problems I’ve encountered myself.\n\nShadow builds not working\n\nSometimes, shadow builds just get broken, meaning that it is impossible to built a particular Qt version using shadow build, whatever the reason might be, and so you’ll have to do it right in the Src directory.\n\nTrailing backslash in prefix\n\nHaving a trailing \\ in prefix on Windows can cause the following problem:\n\nRemove the trailing \\ and try again. So:\n\n-prefix \"d:\\programs\\qt\\5122-static\\\" - fails;\n\n-prefix \"d:\\programs\\qt\\5122-static\" - works.\n\nText is not visible, because there are no fonts\n\nOne of the issues you might encounter with your applications built with static Qt is the absence of fonts for your GUI. Literally, all the text controls will have no text at all. Also, your application will print the following to the console:\n\nAs I understood, that happens on GNU/Linux only.\n\nThere are several ways of fixing this. First, obviously, it might be enough to just deploy some fonts to /path/to/qt/5.15.2-static/lib/fonts folder.\n\nSecond option would be to “embed” a font into your application - add a font file to resources and “activate” it in main.cpp:\n\nFinally, you can re-configure (and rebuild) Qt with -fontconfig option. First, install these packages just in case:\n\nand then configure Qt (having deleted the old build and cache files):\n\nYou should see the following in the configuration output:\n\nNon-existent module or unknown command line option\n\nSometimes you might get this error trying to run configure:\n\nor even this one:\n\nI’ve got both after unpacking Qt sources from a snapshot archive with default Archive Manager application on Elementary OS. I figured it did something wrong during unpacking, and so I unpacked the archive using tar from command line instead, and then the exactly same configure command ran without problems.\n\nQQmlApplicationEngine failed to load component, qtquick2plugin not found\n\nAt some point, having built Qt 5.15.2, I got this error, trying to launch my application:\n\nSo the application builds fine, but throws this error on launch.\n\nAt first I did not find a solution for this, so I just re-built Qt dynamically (without -static configuration option), and then my application was able to launch.\n\nBut then I did some digging and discovered that some Qt plugins/modules (including qtquick2plugin, apparently) require some additional massaging if Qt is built statically, and actually Qt warns about this in the end of the configuration output:\n\nWhy cannot it just take care of this on its own, so one could get a working build out of the box - I don’t know, apparently one just can not. Well, actually, if you are using qmake, then it will work out of the box (but here’s also some documentation on the matter, just in case), and you won’t need to change anything in your project file, but with CMake that is not the case.\n\nWhen using Qt static build and CMake, one needs to call qt5_import_qml_plugins function in his project:\n\nHopefully, there is also qt6_import_qml_plugins in Qt 6, at least it is mentioned in QTBUG-86827.\n\nThis function is available only from Qt 5.14, but for versions older than 5.14 there seems to be nothing for that in the official resources, but fortunately there is this external CMake module. I did some modifications to it, and here’s how I used it in my project:\n\nThe last bit about linking to QmlWorkerScript is a required crutch, otherwise you’ll get the following error on linking:\n\nWith my glorious Color Corners application as an example, both the standard function and this module produced identical .cpp files in the build directory:\n\nPlus certain linking instructions were added.\n\nIf you are curious to see where this list of plugins originates from, you can inspect your application imports with qmlimportscanner tool yourself:\n\nFor me it was the following:\n\nWhich matches the generated list of imports.\n\nCould not find the Qt platform plugin XCB\n\nOn Linux, even though the Qt builds fine, and even your applications build fine, you might get the following error, trying to launch them:\n\nThere is a one kilometer long thread on Qt’s forum, where you might find an absolutely retarded advice (что за уебан догадался такое посоветовать) to remove libqt5gui5 from the system - don’t do that, not only it won’t help, but it will actually pretty much ruin your system.\n\nSome replies there and also here say that installing/reinstalling libxcb-xinerama0 resolved the problem for them, but it didn’t for me.\n\nThere is also a shorter thread on a similar topic here, and this one did point to this comment, which finally got me to the right place - Qt wiki, which had the full list of packets that you need to install:\n\nQt’s documentation also provides a list of those, but it’s not as full as the one from wiki, and installing only the ones listed in documentation was not enough in my case.\n\nAnyway, here’s how your Qt configuration output might look like without required XCB packages installed:\n\nhere’s the resulting platform plugins folder contents:\n\nThat’s how you know that your applications will build but will not launch. Pretty amazing how you can get get a Qt build, which did not complain about anything neither during configuration nor during the build, succeeded without errors, and yet it ended up being actually useless for you.\n\nAnd here’s a Qt configuration output when all the required XCB packages are installed:\n\nand resulting platform plugins folder contents:\n\nSo now libqxcb plugin is in place, and your applications will not only build but also actually work.\n\nd3d12.dll is missing\n\nHaving built your application with static Qt, you can get this error trying to launch the application on a different computer:\n\nThat could be because you might have built Qt on a system with DirectX 12, but this other computer might not have it. To avoid this problem you’ll need to re-configure Qt with -no-feature-d3d12 and re-build it.\n\nCannot open compiler generated file\n\nThat one I got trying to build Qt 5.15.2 on Windows 10, and this problem seems to be specific to Windows only, as it cannot handle paths longer than certain length. The error message is not very descriptive, though:\n\nThe solution for this is to have sources and build folder somewhere closer to the disk root, such as d:\\qt\\build.\n\nVariable has incomplete type struct stat64\n\nI got this one trying to build Qt 5.15.2 on Mac OS 11.2 with Apple silicon processor (so my configuration command had QMAKE_APPLE_DEVICE_ARCHS=arm64):\n\nI did not find a solution for this, so I just disabled 3D stuff with -skip qt3d -skip qtquick3d (I don’t use it anyway). Probably later Qt versions already have a fix for this, but for now I only found this bugreport, and it is still open.\n\nCannot open input file qwebp.lib\n\nI got this one trying to build Qt 5.15.6 on Windows 11 with MSVC 143 (VS 2022). But I think I also had this problem with 5.15.2 on Windows 10 with MSVC 142 (VS 2019):\n\nI don’t know why it happens and how to resolve it, so I just disabled WebP (yeah, fuck WebP anyway) with -no-webp configuration option.\n\nUnknown type name CGColorSpaceRef\n\nGot this one trying to build Qt 6.2.0:\n\nThe fix is to edit /path/to/qt/src/6.2.0/qtbase/src/plugins/platforms/cocoa/qiosurfacegraphicsbuffer.h and add missing header CoreGraphics/CGColorSpace.h:\n\nUndefined symbols GSSAPI\n\nStarted to get this one all of the sudden even with versions that were for sure building fine before:\n\nThat turned out to be caused by vcpkg that I had installed at some point. Apparently, something collides or overlaps somewhere with the things found in VCPKG_ROOT path. So the workaround is to unset this variable before building Qt (and do a clean build, if you have remains from the previous build):\n\n2021-11-12 | Некоторый итог\n\nНу что сказать. Я просто труба тех шатал, кто писал документацию на тему. Ни хера нормально не расписано, пердолься сам до посинения, собирай инфу по кусочкам со всего интернета, может чего и получится, но скорее всего нет. Понятно, что Шиндошс не в почёте, и реальные пацаны сидят на Линупсе, но это же документация продукта, который (помимо GPL/LGPL) продаётся за (немаленькие) деньги, так что можно наверное ради такого дела написать на пару строчек побольше?\n\nДа ладно Шиндошс, там и на других платформах полно неочевидных проблем, особенно на ЖМУ/Пинусе. Пытаться собрать статический Qt я начал ну наверное году в 2012, к 2018 у меня это стало в основном получаться и я написал эту статью, но сейчас 2021 год, а я до сих натыкаюсь на проблемы, решение которых надо выискивать по всем интернетам, потому что документация о них скромно умалчивает. Ну и конечно с появлением новых версий Qt появляются новые проблемы со сборкой.\n\nПиздец нахуй блядь!\n\n2023-09-19 | Qt 5.15.2, Windows 10/11, MinGW x32 from MSYS2\n\nAll of a sudden today I needed to do something horrible: I needed to build static Qt 5.15.2 on Windows 10 (and then on Windows 11) x64 host using MinGW x32 toolchain. The Qt version, MinGW and x32 target were strict requirements, so I had to make it work with exactly those.\n\nMSVC x32\n\nFirst I tried to build static Qt 5.15.2 with MSVC 143 (VS 2022) x32, just to check that it does build at all:\n\nThe build went just fine out of the box, I didn’t need to touch the original sources at all.\n\nMinGW x32\n\nAnd then I started my in-and-out-twenty-minutes-adventure of building static Qt with MinGW.\n\nThe very first issue I’ve stumbled upon is: where does one get the MinGW from? Before I was getting it from Qt installer, but I stopped using that anal probe some years ago, so this isn’t an option anymore.\n\nLong story short, I didn’t find a MinGW that would work, as apparently just MinGW alone is not enough, because I was getting errors like:\n\nAnd so apparently one needs to have some environment for it to run in, and one such environment is MSYS2. I do have Git BASH too, but there was something still missing there.\n\nSo, download MSYS2 installer, install it and, as we are targeting x32 build, launch /path/to/msys2/mingw32.exe. Then, based on these instructions, update the system packages:\n\nYes, to my surprise, it uses a proper package manager (that being pacman), which certainly helps with getting the right stuff.\n\nThat command will eventually close the MSYS2 terminal during the update, so launch it again (/path/to/msys2/mingw32.exe) and repeat the last command to finish the update.\n\nThen install MinGW x32 toolchain (if you’ll later need x64 toolchain, that one is available as mingw-w64-x86_64-toolchain):\n\nI got the following versions after the installation was done:\n\nCheck that the tools are available:\n\nSet an “alias” for make:\n\n…otherwise it will fail complaining that there is no make available:\n\nConfigure Qt:\n\nThe -platform win32-g++ is important, otherwise you’ll get:\n\nAnyway, the configuration will fail like this:\n\nTo fix that, add #include <limits> to e:/tools/qt/src/5.15.2/qtbase/src/corelib/global/qfloat16.h and e:/tools/qt/src/5.15.2/qtbase/src/corelib/text/qbytearraymatcher.h and run configuration again. Then it should configure, but there will likely be a warning about OpenGL:\n\nSo add that option (-opengl desktop) to the configure command and run it again. Then it should succeed for good. Here’s my configuration output, just in case:\n\nYou can now try to build it:\n\nBut soon enough it will fail with this:\n\nYou can try to reconfigure Qt with -c++std c++11 (and check that it now has C++11 in the configuration summary) and try building again. I’d actually recommend to use exactly C++11 standard, since it’s a rather old Qt version, and probably it is to be expected to encounter more errors trying to compile with C++17.\n\nWith C++11 standard the error will still be there, but a little bit different:\n\n…which is actually the same error that we already saw during configuration, so add #include <limits> to /e/tools/qt/src/5.15.2/qtdeclarative/src/3rdparty/masm/yarr/Yarr.h too and… except that it is already there. But actually it’s not, because it’s wrong: you need to replace #include <limits.h> with #include <limits>. Then try building again.\n\nIt will proceed, but will fail with a different error later:\n\nThis one is about not finding fxc.exe, as it seems, which you should have somewhere in your variant of e:\\Windows Kits\\10\\bin\\10.0.20348.0\\x86\\fxc.exe (use the x86 version, since we are in x32). So add it to PATH and try again:\n\nAnd indeed, that helps it to proceed further. But then I got this weird error on Windows 11:\n\nWhat the fuck is this shit. And I didn’t get it on Windows 10, by the way. I googled for that one and found the following workaround:\n\nThen the build continues. But! When I needed to build the whole thing again after cleaning the build folder, the configuration suddenly failed like this:\n\nGood thing I remembered exporting this variable, so I unset it:\n\nand re-run the configuration, and then it succeeded. And then I exported that variable again, since it does resolve the qmltyperegistrar error.\n\nAnyway, coming back to the build at hand, after that it failed with several other errors:\n\nTo fix those edit e:\\tools\\qt\\src\\5.15.2\\qtdeclarative\\src\\plugins\\scenegraph\\d3d12\\qsgd3d12engine.cpp:\n\n…or you could probably just reconfigure Qt with -no-feature-d3d12, especially if you or/and your users will be building applications for running on machines without DirectX 12.\n\nTrying to continue the build, you’ll get this one again:\n\nAdd #include <limits> to e:/tools/qt/src/5.15.2/qtdeclarative/src/qmldebug/qqmlprofilerevent_p.h too.\n\nThen it will proceed, but will fail with something else later:\n\nPatch for that problem is here. I would have never figured it out on my own. Apply the changes and continue the build.\n\nNext error will be this:\n\nPatch for this problem is here. Again, it is very unlikely that I would ever be able to figure it out myself. Apply the changes and continue.\n\nAnd then it fucking finally builds to the end! To make sure that it did in fact succeed, check the exit code:\n\nIf it is non-zero but the build has finished without printing any errors in the end, run the build again, first with -j and check the exit code, and if it is still non-zero, then try yet again but this time without -j, so it would stop on the first error without spamming the output with other jobs leftovers.\n\nAnyway, mine has succeeded, but at some point later I realized that I forgot to add configuration option for the static runtime, so I needed to reconfigure and rebuild again. And so the final configure command with all the additions is now this:\n\nAnd also just in case here’s a diff output for all the changes to the original Qt sources that I had to make in order to build static Qt 5.15.2 with MinGW.\n\nIf you are curious, the build time on Intel Core i9-9900K CPU with 8/16 cores was about 31 minute (30:47).\n\nUsing the MinGW build in Qt Creator\n\nLet’s now add this build to Qt Creator and try to use it.\n\nFirst add C and C++ compilers (note the ABI value, it should auto-detect when you’ll browse for gcc and g++ executables):\n\nThen debugger:\n\nThen the Qt version that you’ve just built:\n\nAnd finally the kit:\n\nAs for the application to be built with this kit, of course we’ll take Color Corners.\n\nWith qmake\n\nFirst I tried to build it with qmake (by the way, just look at how big that project file is (4 lines) in comparison with CMake (bloody 157 lines)).\n\nConfiguration and build output:\n\nResulting application launched fine both from Qt Creator environment and without Qt Creator, and it didn’t require any DLLs. Everything as expected.\n\nHere’s a Dependency Walker report:\n\nWith CMake\n\nThen I tried to build it with CMake.\n\nConfiguration output:\n\nBuild output:\n\nAnd I could launch the application from Qt Creator, but surprisingly, trying to launch the executable without Qt Creator, I got an error about missing MinGW runtime DLL, even though Qt was built with -static-runtime:\n\nThen I got an error about missing zstd DLL:\n\nAnd looks like it will also complain about missing zlib DLL, because here’s what Dependency Walker reports:\n\nTo highlight the imports difference between executables produced by qmake and CMake:\n\nWell, what the fuck.\n\nThere is also a big difference in executables sizes:\n\nSo CMake-produced executable is so much bigger and yet it is the one failing to launch due to missing DLLs? What is the actual f…\n\nOkay, the MinGW runtime issue can be fixed like this:\n\nbut what about zstd and zlib, where did they come from? And why they are shared libraries in CMake build, while qmake got static variants?\n\nI couldn’t find answers on the internets, so I just inspected the qmake output and I saw that it links to a lot of stuff, out of which the following seemed to be the most relevant: E:/tools/qt/5.15.2-static-x32-mingw/lib/libQt5Core.a, -lzstd and -lz. So I added those to CMake project:\n\nand then resulting executable was able to launch without Qt Creator environment, as it didn’t require those DLLs anymore.\n\nJust in case, here’s a comparison of imports between executable created with qmake and this new executable from fixed CMake build:\n\nOne other change is that executable size got even bigger:\n\nbut that’s a minor detail.\n\nSo yeah, it is definitely possible to build static Qt with MinGW, but I didn’t fucking enjoy it at all.\n\n2023-10-01 | Qt 6.5.1, Mac OS 13.6, Apple M2 Pro\n\nI got the latest MacBook Pro with Apple M2 Pro processor, and of course I wanted to check how fast it can build Qt and that Qt does build there at all.\n\nMy environment:\n\nIf you have vcpkg installed, unset VCPKG_ROOT environment variable (as it will probably cause troubles with GSSAPI):\n\nAnd then configure and try building Qt as usual:\n\nThe build will fail with the following:\n\nThis one is likely because of missing LLVM. There are probably other ways of fixing this, but I know only one - install LLVM with Homebrew and use that one. And since Homebrew has come up, I noticed that some features were disabled in the configuration output, for instance FFmpeg backend for Multimedia, so yes, let’s try with Homebrew prefix:\n\nThat will fail already on configure:\n\nI’ve already encountered this one when I was building Qt on Steam Deck, the workaround is to remove zstd::libzstd_shared from /opt/homebrew/lib/cmake/zstd/zstdTargets.cmake. Don’t forget to return it back afterwards.\n\nTry to configure the build again. There will be another error in the end of configure:\n\nI tried to install Mesa packages:\n\nbut that didn’t help. Then I realized that this problem originates in GStreamer backend, so it probably can be just disabled, because FFmpeg is now the default backend anyway:\n\nThat helped, and Qt has successfully configured. I started building it and got this error:\n\nI thought this is because I don’t have protobuf installed:\n\nbut no, I did have it. Then I checked what headers it has in /opt/homebrew/include/google/protobuf/stubs/, and logging.h wasn’t there. As it turned out, protobof migrated to a different logger, so I needed to downgrade my protobuf to version 21.12:\n\nHopefully, later versions of Qt will switch to newer versions of protobuf. Meanwhile, do keep in mind that you might brake other packages in your environment by force-downgrading with --ignore-dependencies, because they might require exactly the latest protobuf.\n\nThen the build proceeded, and I got that same error about monotonic_buffer_resource:\n\nSo first I checked that I actually have LLVM installed:\n\nBut I did, and then I realized that it is not linked anywhere (it’s a new Mac, I didn’t have time to set it up properly). But probably don’t link it to the main prefix, instead add the following to your ~/.bash_profile (or whichever shell you are using):\n\nI re-configured Qt again, and it still warns about not finding LLVM for QDoc, so probably you can try adding -DLLVM_INSTALL_DIR=\"/opt/homebrew/opt/llvm\" after -DCMAKE_PREFIX_PATH=\"...\" (or export LLVM_INSTALL_DIR=\"/opt/homebrew/opt/llvm\" in ~/.bash_profile), but it doesn’t matter for the main build.\n\nJust in case, here’s the final configure command:\n\nand configuration summary:\n\nSo, configuration succeeded, and I started the build again. It passed that problem with monotonic_buffer_resource, but failed later with something different:\n\nApparently, this function was removed from C++17, which means that Qt 6.5.1 doesn’t support C++17? Or at least that is how it is with Xcode 15. I found a seemingly relevant workaround about setting _LIBCPP_ENABLE_CXX17_REMOVED_UNARY_BINARY_FUNCTION preprocessor definition. I tried to do that in /path/to/qt/qtmultimedia/src/plugins/multimedia/darwin/CMakeLists.txt:\n\nit didn’t help. Then I tried this:\n\nit didn’t help either. Then I tried this:\n\nbut that didn’t help either. Then I just edited /path/to/qt/qtmultimedia/src/plugins/multimedia/darwin/camera/avfcamerautility.mm:\n\nAnd that did help, the build continued and then succeeded. Installation too:\n\nThe entire build (measured from scratch, after all the problems were solved) and installation took… 12 minutes (12:15)!\n\nFuck me sideways, it sure is nice to live in the future. For comparison, here are the build times of the same static Qt 6.5.1 on other machines that I have.\n\nThe installation size is 851 MB (according to du). Binaries are arm64:\n\nBy the way, I didn’t need to provide -DCMAKE_OSX_ARCHITECTURES=\"arm64\" to the configure, as I assumed that it should be the default one. If I wanted to build universal binaries, then yes, I would’ve provided -DCMAKE_OSX_ARCHITECTURES=\"arm64;x86_64\" (some say the order should be exactly x86_64;arm64, because it might be important for Qt somehow).\n\nRight, so let’s add this build to Qt Creator then. The procedure is the same as always, but with one little surprise:\n\nSo for some reasons it couldn’t auto-detect system compilers, and you’ll need to set them manually.\n\nHere’s C compiler:\n\nAnd here’s C++ compiler:\n\nThe rest goes fine:\n\nBuilding the greatest application in the world succeeds:\n\nNot sure what this warning with duplicate libraries is about.\n\nThe executable is arm64:\n\nChecking its dependencies shows that there are no Qt libraries:\n\nHowever, there is one other surprising dependency, because trying to launch the application fails:\n\nSo all of a sudden it cannot find C++/LLVM runtime library. I don’t know yet, how to link to it statically or how to set the right path to it, but the “workaround” is well known:\n\nAnd then it launches fine.\n\nAt the same time, building without Qt Creator produces a different result. Here’s a build from bare CLI:\n\nAnd it launches just fine without setting DYLD_LIBRARY_PATH. Huh.\n\nI compared otool output for both executables (left one is produced by Qt Creator, right one is built from CLI), and they are the same except for that exact C++ library:\n\nAs we can see, basic CMake/Ninja build from CLI is capable of setting the dependencies paths correctly, but Qt Creator build is not. Not to mention Qt Creator’s inability to auto-detect default system C/C++ compilers. Hah, by the way, it still requires manually setting CMAKE_MAKE_PROGRAM to Ninja path for every project, despite it being available in system’s PATH.\n\nYeah, so much progress has happened in Qt Creator from its last 4.x version in 2021 till the current 11.0.3 version in 2023 - fucking seven major versions in just two years. Not every IDE is developed so rapidly and with so many great new features! Too bad I can’t recall a single such feature that would be worth increasing the major version number.\n\n2024-01-02 | Qt 5.15.12, Mac OS 13.6, Xcode 15\n\nGot these problems trying to build Qt 5.15.12 on Mac OS 13.6.3 (on Apple M2 Pro) with Xcode 15.0.1 (and then 15.1).\n\nFailed to parse default search paths from compiler output\n\nFirst the configuration failed:\n\nThat is because of this bug, which is probably Apple’s fault. The patch (until a newer Qt version is released) is the following (this is supposed to be applied on /path/to/qt/src/5.15.12/qtbase/mkspecs/features/toolchain.prf):\n\nAlso, even though that was on Apple M2 Pro, I didn’t need to provide QMAKE_APPLE_DEVICE_ARCHS=arm64.\n\nSymbol not found monotonic_buffer_resource\n\nSo configuration succeeded, but build failed:\n\nSo it’s missing vtable for std::__1::pmr::monotonic_buffer_resource, for some reason. From the discussions on the internet, it seems to be cause by this new Xcode linker problem, but I did have LDFLAGS=\"$LDFLAGS -Wl,-ld_classic\" in my ~/.bash_profile, so I don’t know what else it needs.\n\nThen I found this bugreport and this patch (which seems to be derived from this one). So you need to patch /path/to/qt/src/5.15.12/qtbase/src/corelib/global/qcompilerdetection.h:\n\nand /path/to/qt/src/5.15.12/qtbase/src/corelib/tools/qduplicatetracker_p.h:\n\nNo template named unary_function in namespace std\n\nAfter patching those two files the build progressed further, but failed with another error:\n\nThat one I’ve seen before, you’ll need to edit /path/to/qt/src/5.15.12/qtmultimedia/src/plugins/avfoundation/camera/avfcamerautility.mm:\n\nNo member named move in namespace std\n\nHaving fixed the previous problem, I got some other errors later:\n\nFrom these I can only guess that there is still something wrong with C++ runtime detection/discovery, and the way I fixed this particular error is by adding #include <utility> to /path/to/qt/src/5.15.12/qtlocation/src/3rdparty/mapbox-gl-native/include/mbgl/util/unique_any.hpp.\n\nAfter that the build succeeded. And by the way, it succeeded with Xcode 15.1 too, so I didn’t need to have -Wl,-ld_classic appended to the LDFLAGS environment variable anymore.\n\n2024-06-11 | Even more unknown runtime dependencies with dynamic Qt 6.7.1\n\nWith Qt 6.7.1 dynamic build on Windows I noticed that this set of runtime dependencies is no longer(?) correct, and it could have been so for quite some time now.\n\nFirst of all, since we are all using CMake, right, here’s how one can try to use CMake for collecting all the application’s runtime dependencies:\n\nSadly, it doesn’t always find all the dependencies, and in case of Qt for one of my applications it only copied the following set:\n\nAnd when I tried to launch the application, I got an error about missing platform plugin:\n\nHere’s also a screenshot, just in case:\n\nTo resolve that I needed to copy /path/to/qt/plugins/platforms/qwindows.dll to my application installation folder, keeping the folder structure. And then the application launched but with an “empty” application window:\n\nWhen you see this with a Qt-based application, that’s a symptom of some more DLLs missing, which aren’t required at launch (so you can’t track them with Dependency Walker, DIE or a similar tool?), but apparently are attempted to be loaded a bit later at runtime (and produce no error on failure?). After quite some trial and error I discovered that it’s also Qt6QmlWorkerScript.dll that was missing, which I then deployed too.\n\nBut even after that something was still missing, because I was still getting an “empty” application window. When you find yourself in a situation like this, the last resort is to just drop your executable into /path/to/qt/bin/ and launch it from there, and if it launches fine, then you can copy the entiry Qt prefix and start throwing things out of it. That is how I discovered that my application also needs /path/to/qt/qml/QtQml/WorkerScript/{qmldir,workerscriptplugin.dll} files.\n\nSo here’s the final deployment folder structure:\n\nNaturally, for your application this set might be different, as your application might be using different parts of Qt functionality and so depending on different Qt modules.\n\n2024-07-09 | Ещё один некоторый итог\n\nПрошло ещё сколько-то времени, я узнал ещё немного нового, а главное сам поучаствовал в сборке нескольких кросс-платформенных проектов. И теперь я могу сказать, что мой предыдущий итог трёхлетней давности конечно смешной, но не очень справедливый.\n\nГлядя на размеры Qt, сколько в него входит компонентов, что он ими умеет делать, а также принимая во внимание количество сторонних зависимостей - это большое чудо и достижение, что он вообще собирается, не говоря уже о том, что делает он это на нескольких платформах. Более того, теперь, когда я такой крутой специалист, я бы даже сказал, что Qt везде собирается почти из коробки - это же вообще умопомрачительно, сколько труда ушло, чтобы такое обеспечить.\n\nДа, безусловно, для рядового пользователя/погроммиста собрать Qt из исходников это (очень) сложно, и действительно, очень много чего нужного не указано в документации. Но как я сейчас вижу, многое из того, что я считал недостатком документации Qt, на самом деле является достаточно общими сведениями, относящимися к теме сборки чего бы то ни было вообще. И как бы ожидается, что ты должен быть в курсе всего этого, раз уж полез сюда, и Qt не обязан водить каждого начинающего инженегра за ручку и вытирать за ним сопли."
    }
}