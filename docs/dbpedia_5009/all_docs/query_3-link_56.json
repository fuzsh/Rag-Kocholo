{
    "id": "dbpedia_5009_3",
    "rank": 56,
    "data": {
        "url": "https://felgo.com/doc/qt/qmake-variable-reference/",
        "read_more_link": "",
        "language": "en",
        "title": "Qt Documentation (Pro)",
        "top_image": "https://felgo.com/wp-content/themes/felgo/images/favicon.ico",
        "meta_img": "https://felgo.com/wp-content/themes/felgo/images/favicon.ico",
        "images": [
            "https://felgo.com/wp-content/themes/felgo/images/felgo.png",
            "https://felgo.com/wp-content/themes/felgo/images/navigation-icons/visualstudio-logo.png",
            "https://felgo.com/wp-content/themes/felgo/images/navigation-icons/visualstudio-code-logo.png",
            "https://felgo.com/wp-content/themes/felgo/images/footer/numero-uno-footer.png",
            "https://felgo.com/wp-content/themes/felgo/images/footer/Qt-Technology-Partner-white.png",
            "https://felgo.com/wp-content/themes/felgo/images/footer/Qt-Service-Partner-white.png",
            "https://felgo.com/wp-content/themes/felgo/images/felgo.png",
            "https://hs.felgo.com/hubfs/Qt_Technology_Partner_RGB_475.png",
            "https://hs.felgo.com/hubfs/Qt_Service_Partner_RGB_475_padded.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://felgo.com/wp-content/themes/felgo/images/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://felgo.com/doc/qt/qmake-variable-reference/",
        "text": "The fundamental behavior of qmake is influenced by variable declarations that define the build process of each project. Some of these declare resources, such as headers and source files, that are common to each platform. Others are used to customize the behavior of compilers and linkers on specific platforms.\n\nPlatform-specific variables follow the naming pattern of the variables which they extend or modify, but include the name of the relevant platform in their name. For example, a makespec may use QMAKE_LIBS to specify a list of libraries that each project needs to link against, and QMAKE_LIBS_X11 would be used to extend this list.\n\nANDROID_ABIS\n\nSpecifies a list of Android target ABIs. Valid values are: armeabi-v7a, arm64-v8a, x86, x86_64.\n\nYou can provide the ABIs as a qmake argument:\n\nqmake ANDROID_ABIS=\"armeabi-v7a arm64-v8a\"\n\nANDROID_API_VERSION\n\nSpecifies the Android API level number. For more information, see Android Build Numbers.\n\nANDROID_APPLICATION_ARGUMENTS\n\nSpecifies extra command-line arguments to the Android app using the AndroidManifest.xml with the tag \"android.app.arguments\". This takes a string of arguments:\n\nANDROID_APPLICATION_ARGUMENTS = \"arg1 arg2 arg3\"\n\nANDROID_BUNDLED_JAR_DEPENDENCIES\n\nThis is useful when writing a Qt module. It specifies a list of pre-bundled dependencies used by the module in a .jar format, for example:\n\nANDROID_BUNDLED_JAR_DEPENDENCIES += jar/Qt6Android.jar\n\nANDROID_DEPLOYMENT_DEPENDENCIES\n\nBy default, androiddeployqt will detect the dependencies of your application. However, since run-time usage of plugins cannot be detected, there could be false positives, as your application might depend on any plugin that is a potential dependency. If you want to minimize the size of your APK, it's possible to override the automatic detection using the this variable. This should contain a list of all Qt files which need to be included, with paths relative to the Qt install root.\n\nANDROID_DEPLOYMENT_SETTINGS_FILE\n\nSpecifies the path to the android-deployment-settings.json file needed by androiddeployqt and androidtestrunner. This overrides the path to the settings file generated by qmake, thus you have to make sure to provide a valid settings file.\n\nANDROID_EXTRA_LIBS\n\nA list of external libraries that will be copied into your application's libs folder and loaded on start-up. This can be used, for instance, to enable OpenSSL in your application. For more information, see Adding OpenSSL Support for Android.\n\nTo include external libraries for multiple ABIs, where each ABIs has its own directory, use the following:\n\nfor (abi, ANDROID_ABIS): ANDROID_EXTRA_LIBS += $$PWD/$${abi}/library_name.so\n\nOtherwise, if the ABI is included in the library name, use the following:\n\nfor (abi, ANDROID_ABIS): ANDROID_EXTRA_LIBS += $$PWD/library_name_$${abi}.so\n\nANDROID_EXTRA_PLUGINS\n\nSpecifies a path to C++ plugins or resources that your application has to bundle but that cannot be delivered through the assets system, such as QML plugins. With this variable, androiddeployqt will make sure everything is packaged and deployed properly.\n\nANDROID_EXTRA_PLUGINS must point to the directory where the extra plugin(s) are built. In addition, the build directory structure must follow a naming convention similar to Qt plugins, that is, plugins/<plugin name>.\n\nThe plugins libraries should have the name format libplugins_<type>_<name>_<abi>.so. To achieve that the plugin pro file could be defined as follows:\n\nTEMPLATE = lib CONFIG += plugin PLUGIN_TYPE = imageformats DESTDIR = $$top_builddir/plugins/myplugin TARGET = $$qt5LibraryTarget(myplugin, \"plugins/$$PLUGIN_TYPE/\")\n\nwith top_builddir defined in .qmake.conf as:\n\ntop_builddir=$$shadowed($$PWD)\n\nThis will ensure that the correct name mangling is applied to the plugin library (plugins/myplugin/libplugins_imageformats_myplugin_armeabi-v7a.so).\n\nThen, assuming an extra image format plugin myplugin is built as $$DESTDIR/plugins/myplugin/, the following ensures it is packaged correctly:\n\nANDROID_EXTRA_PLUGINS += $$top_builddir/plugins\n\nANDROID_FEATURES\n\nSpecifies a module's features list:\n\nANDROID_FEATURES += android.hardware.location.gps\n\nFor more information, see Android <uses-feature> Docs.\n\nANDROID_LIB_DEPENDENCIES\n\nThis is useful when writing a Qt module. It specifies a list of pre-built dependencies used by the module, for example:\n\nANDROID_LIB_DEPENDENCIES += \\ plugins/libplugins_platforms_qtforandroid.so\n\nANDROID_MIN_SDK_VERSION\n\nSpecifies the minimum Android API level for the project. By default, this variable is set to API level 23.\n\nANDROID_PACKAGE_SOURCE_DIR\n\nSpecifies the path for a custom Android package template. The Android package template contains:\n\nAndroidManifest.xml file\n\nbuild.gradle file and other Gradle scripts\n\nres/values/libs.xml file\n\nThe path specified by this variable can contain custom Java classes under src directory. By default, the androiddeployqt tool copies the application template from the Qt for Android installation path into your project's build directory, then it copies the contents of the path specified by this variable on top of that, overwriting any existing files. For instance, you can make a custom AndroidManifest.xml for your application, then place this directly into the directory specified by this variable.\n\nANDROID_PERMISSIONS\n\nSpecifies a module's permissions list:\n\nANDROID_PERMISSIONS += android.permission.ACCESS_FINE_LOCATION\n\nFor more information, see Android <uses-permission> Docs.\n\nANDROID_TARGET_SDK_VERSION\n\nSpecifies the target Android API level for the project. By default, this variable is set to API level 30.\n\nANDROID_VERSION_CODE\n\nSpecifies the application's version number. For more information, see Android App Versioning.\n\nANDROID_VERSION_NAME\n\nSpecifies the application's version in as a human readable string. For more information, see Android App Versioning.\n\nCONFIG\n\nSpecifies project configuration and compiler options. The values are recognized internally by qmake and have special meaning.\n\nThe following CONFIG values control compiler and linker flags:\n\nWhen you use the debug_and_release option (which is the default under Windows), the project will be processed three times: one time to produce a \"meta\" Makefile, and two more times to produce a Makefile.Debug and a Makefile.Release.\n\nDuring the latter passes, build_pass and the respective debug or release option is appended to CONFIG. This makes it possible to perform build-specific tasks. For example:\n\nbuild_pass:CONFIG(debug, debug|release) { unix: TARGET = $$join(TARGET,,,_debug) else: TARGET = $$join(TARGET,,,d) }\n\nAs an alternative to manually writing build type conditionals, some variables offer build-specific variants, for example QMAKE_LFLAGS_RELEASE in addition to the general QMAKE_LFLAGS. These should be used when available.\n\nThe meta Makefile makes the sub-builds invokable via the debug and release targets, and a combined build via the all target. When the build_all CONFIG option is used, the combined build is the default. Otherwise, the last specified CONFIG option from the set (debug, release) determines the default. In this case, you can explicitly invoke the all target to build both configurations at once:\n\nmake all\n\nWhen linking a library, qmake relies on the underlying platform to know what other libraries this library links against. However, if linking statically, qmake will not get this information unless we use the following CONFIG options:\n\nThe following options define the application or library type:\n\nThese options define specific features on Windows only:\n\nSee Platform Notes for more information about the options for embedding manifest files.\n\nThe following options take an effect only on macOS:\n\nThe build process for bundles is also influenced by the contents of the QMAKE_BUNDLE_DATA variable.\n\nThe following options take an effect only on Linux/Unix platforms:\n\nThe CONFIG variable will also be checked when resolving scopes. You may assign anything to this variable.\n\nFor example:\n\nCONFIG += console newstuff ... newstuff { SOURCES += new.cpp HEADERS += new.h }\n\nDEFINES\n\nqmake adds the values of this variable as compiler C preprocessor macros (-D option).\n\nFor example:\n\nDEFINES += USE_MY_STUFF\n\nDEFINES_DEBUG\n\nSpecifies preprocessor defines for the debug configuration. The values of this variable get added to DEFINES after the project is loaded. This variable is typically set in qmake.conf and rarely needs to be modified.\n\nThis variable was introduced in Qt 5.13.2.\n\nDEFINES_RELEASE\n\nSpecifies preprocessor defines for the release configuration. The values of this variable get added to DEFINES after the project is loaded. This variable is typically set in qmake.conf and rarely needs to be modified.\n\nThis variable was introduced in Qt 5.13.2.\n\nDEF_FILE\n\nSpecifies a .def file to be included in the project.\n\nDEPENDPATH\n\nSpecifies a list of directories for qmake to scan, to resolve dependencies. This variable is used when qmake crawls through the header files that you #include in your source code.\n\nDESTDIR\n\nSpecifies where to put the target file.\n\nFor example:\n\nDESTDIR = ../../lib\n\nDISTFILES\n\nSpecifies a list of files to be included in the dist target. This feature is supported by UnixMake specs only.\n\nFor example:\n\nDISTFILES += ../program.txt\n\nDLLDESTDIR\n\nSpecifies where to copy the target dll.\n\nEXTRA_TRANSLATIONS\n\nSpecifies a list of translation (.ts) files that contain translations of the user interface text into non-native languages.\n\nIn contrast to TRANSLATIONS, translation files in EXTRA_TRANSLATIONS will be processed only by lrelease, not lupdate.\n\nYou can use CONFIG += lrelease to automatically compile the files during the build, and CONFIG += lrelease embed_translations to make them available in The Qt Resource System.\n\nSee the Qt Linguist Manual for more information about internationalization (i18n) and localization (l10n) with Qt.\n\nFORMS\n\nSpecifies the UI files (see Qt Designer Manual) to be processed by uic before compiling. All dependencies, headers and source files required to build these UI files will automatically be added to the project.\n\nFor example:\n\nFORMS = mydialog.ui \\ mywidget.ui \\ myconfig.ui\n\nGUID\n\nSpecifies the GUID that is set inside a .vcproj file. The GUID is usually randomly determined. However, should you require a fixed GUID, it can be set using this variable.\n\nThis variable is specific to .vcproj files only; it is ignored otherwise.\n\nHEADERS\n\nDefines the header files for the project.\n\nqmake automatically detects whether moc is required by the classes in the headers, and adds the appropriate dependencies and files to the project for generating and linking the moc files.\n\nFor example:\n\nHEADERS = myclass.h \\ login.h \\ mainwindow.h\n\nSee also SOURCES.\n\nICON\n\nThis variable is used only on Mac OS to set the application icon. Please see the application icon documentation for more information.\n\nIDLSOURCES\n\nThis variable is used only on Windows for the Visual Studio project generation to put the specified files in the Generated Files folder.\n\nINCLUDEPATH\n\nSpecifies the #include directories which should be searched when compiling the project.\n\nFor example:\n\nINCLUDEPATH = c:/msdev/include d:/stl/include\n\nTo specify a path containing spaces, quote the path using the technique described in Whitespace.\n\nwin32:INCLUDEPATH += \"C:/mylibs/extra headers\" unix:INCLUDEPATH += \"/home/user/extra headers\"\n\nINSTALLS\n\nSpecifies a list of resources that will be installed when make install or a similar installation procedure is executed. Each item in the list is typically defined with attributes that provide information about where it will be installed.\n\nFor example, the following target.path definition describes where the build target will be installed, and the INSTALLS assignment adds the build target to the list of existing resources to be installed:\n\ntarget.path += $$[QT_INSTALL_PLUGINS]/imageformats INSTALLS += target\n\nINSTALLS has a .CONFIG member that can take several values:\n\nFor more information, see Installing Files.\n\nThis variable is also used to specify which additional files will be deployed to embedded devices.\n\nJAVA_HOME\n\nSpecifies the JDK/OpenJDK installation path used for building the project.\n\nLEXIMPLS\n\nSpecifies a list of Lex implementation files. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nLEXOBJECTS\n\nSpecifies the names of intermediate Lex object files. The value of this variable is typically handled by qmake and rarely needs to be modified.\n\nLEXSOURCES\n\nSpecifies a list of Lex source files. All dependencies, headers and source files will automatically be added to the project for building these lex files.\n\nFor example:\n\nLEXSOURCES = lexer.l\n\nLIBS\n\nSpecifies a list of libraries to be linked into the project. If you use the Unix -l (library) and -L (library path) flags, qmake handles the libraries correctly on Windows (that is, passes the full path of the library to the linker). The library must exist for qmake to find the directory where a -l lib is located.\n\nFor example:\n\nunix:LIBS += -L/usr/local/lib -lmath win32:LIBS += c:/mylibs/math.lib\n\nTo specify a path containing spaces, quote the path using the technique described in Whitespace.\n\nwin32:LIBS += \"C:/mylibs/extra libs/extra.lib\" unix:LIBS += \"-L/home/user/extra libs\" -lextra\n\nBy default, the list of libraries stored in LIBS is reduced to a list of unique names before it is used. To change this behavior, add the no_lflags_merge option to the CONFIG variable:\n\nCONFIG += no_lflags_merge\n\nLIBS_PRIVATE\n\nSpecifies a list of libraries to be linked privately into the project. The behavior of this variable is identical to LIBS, except that shared library projects built for Unix do not expose these dependencies in their link interface.\n\nThe effect of this is that if project C depends on library B which depends on library A privately, but C also wants to use symbols from A directly, it needs to link to A explicitly. Put differently, libraries linked privately are not exposed transitively at build time.\n\nLITERAL_HASH\n\nThis variable is used whenever a literal hash character (#) is needed in a variable declaration, perhaps as part of a file name or in a string passed to some external application.\n\nFor example:\n\n# To include a literal hash character, use the $$LITERAL_HASH variable: urlPieces = http://doc.qt.io/qt-5/qtextdocument.html pageCount message($$join(urlPieces, $$LITERAL_HASH))\n\nBy using LITERAL_HASH in this way, the # character can be used to construct a URL for the message() function to print to the console.\n\nMAKEFILE\n\nSpecifies the name of the generated Makefile. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nMAKEFILE_GENERATOR\n\nSpecifies the name of the Makefile generator to use when generating a Makefile. The value of this variable is typically handled internally by qmake and rarely needs to be modified.\n\nMSVCPROJ_*\n\nThese variables are handled internally by qmake and should not be modified or utilized.\n\nMOC_DIR\n\nSpecifies the directory where all intermediate moc files should be placed.\n\nFor example:\n\nunix:MOC_DIR = ../myproject/tmp win32:MOC_DIR = c:/myproject/tmp\n\nOBJECTIVE_HEADERS\n\nDefines the Objective-C++ header files for the project.\n\nqmake automatically detects whether moc is required by the classes in the headers, and adds the appropriate dependencies and files to the project for generating and linking the moc files.\n\nThis is similar to the HEADERS variable, but will let the generated moc files be compiled with the Objective-C++ compiler.\n\nSee also OBJECTIVE_SOURCES.\n\nOBJECTIVE_SOURCES\n\nSpecifies the names of all Objective-C/C++ source files in the project.\n\nThis variable is now obsolete, Objective-C/C++ files (.m and .mm) can be added to the SOURCES variable.\n\nSee also OBJECTIVE_HEADERS.\n\nOBJECTS\n\nThis variable is automatically populated from the SOURCES variable. The extension of each source file is replaced by .o (Unix) or .obj (Win32). You can add objects to the list.\n\nOBJECTS_DIR\n\nSpecifies the directory where all intermediate objects should be placed.\n\nFor example:\n\nunix:OBJECTS_DIR = ../myproject/tmp win32:OBJECTS_DIR = c:/myproject/tmp\n\nPOST_TARGETDEPS\n\nLists the libraries that the target depends on. Some backends, such as the generators for Visual Studio and Xcode project files, do not support this variable. Generally, this variable is supported internally by these build tools, and it is useful for explicitly listing dependent static libraries.\n\nThis list is placed after all builtin (and $$PRE_TARGETDEPS) dependencies.\n\nPRE_TARGETDEPS\n\nLists libraries that the target depends on. Some backends, such as the generators for Visual Studio and Xcode project files, do not support this variable. Generally, this variable is supported internally by these build tools, and it is useful for explicitly listing dependent static libraries.\n\nThis list is placed before all builtin dependencies.\n\nPRECOMPILED_HEADER\n\nIndicates the header file for creating a precompiled header file, to increase the compilation speed of a project. Precompiled headers are currently only supported on some platforms (Windows - all MSVC project types, Apple - Xcode, Makefile, Unix - gcc 3.3 and up).\n\nPWD\n\nSpecifies the full path leading to the directory containing the current file being parsed. This can be useful to refer to files within the source tree when writing project files to support shadow builds.\n\nSee also _PRO_FILE_PWD_.\n\nOUT_PWD\n\nSpecifies the full path leading to the directory where qmake places the generated Makefile.\n\nQM_FILES_RESOURCE_PREFIX\n\nSpecifies the directory in the resource system where .qm files will be made available by CONFIG += embed_translations.\n\nThe default is :/i18n/.\n\nQM_FILES_INSTALL_PATH\n\nSpecifies the target directory .qm files generated by CONFIG += lrelease will be installed to. Does not have any effect if CONFIG += embed_translations is set.\n\nQML_IMPORT_PATH\n\nThis variable is only used by Qt Creator. If you have an extra module that is kept outside of your Qt installation, you can specify its path here.\n\nSee Qt Creator: Using QML Modules with Plugins for details.\n\nQMLPATHS\n\nExpects a list of import paths that point to root directories of trees of QML modules. For example, if you have a custom location for your QML modules, you can specify it here.\n\nQMAKE\n\nSpecifies the name of the qmake program itself and is placed in generated Makefiles. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKESPEC\n\nA system variable that contains the full path of the qmake configuration that is used when generating Makefiles. The value of this variable is automatically computed.\n\nQMAKE_AR_CMD\n\nSpecifies the command to execute when creating a shared library. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_BUNDLE_DATA\n\nSpecifies the data that will be installed with a library bundle, and is often used to specify a collection of header files.\n\nFor example, the following lines add path/to/header_one.h and path/to/header_two.h to a group containing information about the headers supplied with the framework:\n\nFRAMEWORK_HEADERS.version = Versions FRAMEWORK_HEADERS.files = path/to/header_one.h path/to/header_two.h FRAMEWORK_HEADERS.path = Headers QMAKE_BUNDLE_DATA += FRAMEWORK_HEADERS\n\nThe last line adds the information about the headers to the collection of resources that will be installed with the library bundle.\n\nLibrary bundles are created when the lib_bundle option is added to the CONFIG variable.\n\nSee Platform Notes for more information about creating library bundles.\n\nA project can also use this variable to bundle application translation files. The exact syntax depends on whether the project is using Xcode's legacy build system or its new build system.\n\nFor example when the following project snippet is built using the legacy build system:\n\ntranslations_en.files = $$PWD/en.lproj/InfoPlist.strings translations_en.path = en.lproj QMAKE_BUNDLE_DATA += translations_en\n\nXcode will ignore the original location of InfoPlist.strings and the file will placed into the bundle Resources directory under the provided translations_en.path path, so Resources/en.lproj/InfoPlist.strings\n\nWith the new build system, the relative location of the file is preserved, which means the file will incorrectly be placed under Resources/en.lproj/en.lproj/InfoPlist.strings\n\nTo ensure correct file placement, the project can either move the original file not to be in a sub-directory or it can choose not to specify the translations_en.path variable.\n\n# Approach 1 translations_en.files = $$PWD/InfoPlist.strings translations_en.path = en.lproj # Approach 2 translations_de.files = $$PWD/de.lproj/InfoPlist.strings QMAKE_BUNDLE_DATA += translations_en translations_de\n\nSee QTBUG-98417 for more details on how the Xcode build system changed its behavior in bundling translation files.\n\nQMAKE_BUNDLE_EXTENSION\n\nSpecifies the extension to be used for library bundles. This allows frameworks to be created with custom extensions instead of the standard .framework directory name extension.\n\nFor example, the following definition will result in a framework with the .myframework extension:\n\nQMAKE_BUNDLE_EXTENSION = .myframework\n\nQMAKE_CC\n\nSpecifies the C compiler that will be used when building projects containing C source code. Only the file name of the compiler executable needs to be specified as long as it is on a path contained in the PATH variable when the Makefile is processed.\n\nQMAKE_CFLAGS\n\nSpecifies the C compiler flags for building a project. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified. The flags specific to debug and release modes can be adjusted by modifying the QMAKE_CFLAGS_DEBUG and QMAKE_CFLAGS_RELEASE variables, respectively.\n\nQMAKE_CFLAGS_DEBUG\n\nSpecifies the C compiler flags for debug builds. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CFLAGS_RELEASE\n\nSpecifies the C compiler flags for release builds. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CFLAGS_RELEASE_WITH_DEBUGINFO\n\nSpecifies the C compiler flags for release builds where force_debug_info is set in CONFIG. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CFLAGS_SHLIB\n\nSpecifies the compiler flags for creating a shared library. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CFLAGS_THREAD\n\nSpecifies the compiler flags for creating a multi-threaded application. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CFLAGS_WARN_OFF\n\nThis variable is used only when the warn_off CONFIG option is set. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CFLAGS_WARN_ON\n\nThis variable is used only when the warn_on CONFIG option is set. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CLEAN\n\nSpecifies a list of generated files (by moc and uic, for example) and object files to be removed by make clean.\n\nQMAKE_CXX\n\nSpecifies the C++ compiler that will be used when building projects containing C++ source code. Only the file name of the compiler executable needs to be specified as long as it is on a path contained in the PATH variable when the Makefile is processed.\n\nQMAKE_CXXFLAGS\n\nSpecifies the C++ compiler flags for building a project. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified. The flags specific to debug and release modes can be adjusted by modifying the QMAKE_CXXFLAGS_DEBUG and QMAKE_CXXFLAGS_RELEASE variables, respectively.\n\nQMAKE_CXXFLAGS_DEBUG\n\nSpecifies the C++ compiler flags for debug builds. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CXXFLAGS_RELEASE\n\nSpecifies the C++ compiler flags for release builds. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CXXFLAGS_RELEASE_WITH_DEBUGINFO\n\nSpecifies the C++ compiler flags for release builds where force_debug_info is set in CONFIG. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CXXFLAGS_SHLIB\n\nSpecifies the C++ compiler flags for creating a shared library. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CXXFLAGS_THREAD\n\nSpecifies the C++ compiler flags for creating a multi-threaded application. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CXXFLAGS_WARN_OFF\n\nSpecifies the C++ compiler flags for suppressing compiler warnings. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_CXXFLAGS_WARN_ON\n\nSpecifies C++ compiler flags for generating compiler warnings. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_DEVELOPMENT_TEAM\n\nThe identifier of a development team to use for signing certificates and provisioning profiles.\n\nQMAKE_DISTCLEAN\n\nSpecifies a list of files to be removed by make distclean.\n\nQMAKE_EXTENSION_SHLIB\n\nContains the extension for shared libraries. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_EXTENSION_STATICLIB\n\nContains the extension for shared static libraries. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_EXT_MOC\n\nContains the extension used on included moc files.\n\nSee also File Extensions.\n\nQMAKE_EXT_UI\n\nContains the extension used on Qt Designer UI files.\n\nSee also File Extensions.\n\nQMAKE_EXT_PRL\n\nContains the extension used on created PRL files.\n\nSee also File Extensions, Library Dependencies.\n\nQMAKE_EXT_LEX\n\nContains the extension used on files given to Lex.\n\nSee also File Extensions, LEXSOURCES.\n\nQMAKE_EXT_YACC\n\nContains the extension used on files given to Yacc.\n\nSee also File Extensions, YACCSOURCES.\n\nQMAKE_EXT_OBJ\n\nContains the extension used on generated object files.\n\nSee also File Extensions.\n\nQMAKE_EXT_CPP\n\nContains suffixes for files that should be interpreted as C++ source code.\n\nSee also File Extensions.\n\nQMAKE_EXT_H\n\nContains suffixes for files which should be interpreted as C header files.\n\nSee also File Extensions.\n\nQMAKE_EXTRA_COMPILERS\n\nSpecifies a list of additional compilers or preprocessors.\n\nSee also Adding Compilers.\n\nQMAKE_EXTRA_TARGETS\n\nSpecifies a list of additional qmake targets.\n\nSee also Adding Custom Targets.\n\nQMAKE_FAILED_REQUIREMENTS\n\nContains the list of failed requirements. The value of this variable is set by qmake and cannot be modified.\n\nSee also requires() and REQUIRES.\n\nQMAKE_FRAMEWORK_BUNDLE_NAME\n\nIn a framework project, this variable contains the name to be used for the framework that is built.\n\nBy default, this variable contains the same value as the TARGET variable.\n\nSee Creating Frameworks for more information about creating frameworks and library bundles.\n\nQMAKE_FRAMEWORK_VERSION\n\nFor projects where the build target is a macOS, iOS, tvOS, or watchOS framework, this variable is used to specify the version number that will be applied to the framework that is built.\n\nBy default, this variable contains the same value as the VERSION variable.\n\nSee Creating Frameworks for more information about creating frameworks.\n\nQMAKE_HOST\n\nProvides information about the host machine running qmake. For example, you can retrieve the host machine architecture from QMAKE_HOST.arch.\n\nwin32-g++:contains(QMAKE_HOST.arch, x86_64):{ message(\"Host is 64bit\") ... }\n\nQMAKE_INCDIR\n\nSpecifies the list of system header paths that are appended to INCLUDEPATH. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_INCDIR_EGL\n\nSpecifies the location of EGL header files to be added to INCLUDEPATH when building a target with OpenGL/ES or OpenVG support. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_INCDIR_OPENGL\n\nSpecifies the location of OpenGL header files to be added to INCLUDEPATH when building a target with OpenGL support. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenGL implementation uses EGL (most OpenGL/ES systems), then QMAKE_INCDIR_EGL may also need to be set.\n\nQMAKE_INCDIR_OPENGL_ES2\n\nThis variable specifies the location of OpenGL header files to be added to INCLUDEPATH when building a target with OpenGL ES 2 support.\n\nThe value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenGL implementation uses EGL (most OpenGL/ES systems), then QMAKE_INCDIR_EGL may also need to be set.\n\nQMAKE_INCDIR_OPENVG\n\nSpecifies the location of OpenVG header files to be added to INCLUDEPATH when building a target with OpenVG support. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenVG implementation uses EGL then QMAKE_INCDIR_EGL may also need to be set.\n\nQMAKE_INCDIR_X11\n\nSpecifies the location of X11 header file paths to be added to INCLUDEPATH when building an X11 target. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_INFO_PLIST\n\nSpecifies the name of the property list file, .plist, you would like to include in your macOS, iOS, tvOS, and watchOS application bundle.\n\nIn the .plist file, you can define some variables which qmake will replace with the relevant values:\n\nIf building for iOS, and the .plist file contains the key NSPhotoLibraryUsageDescription, qmake will include an additional plugin to the build that adds photo access support (to, e.g., QFile/QFileDialog). See Info.plist documentation from Apple for more information regarding this key.\n\nQMAKE_IOS_DEPLOYMENT_TARGET\n\nSpecifies the hard minimum version of iOS that the application supports.\n\nFor more information, see Expressing Supported iOS Versions.\n\nQMAKE_IOS_LAUNCH_SCREEN\n\nSpecifies the launch screen that is used by the application. If this is not set then a default launch screen is used.\n\nQMAKE_LFLAGS\n\nSpecifies a general set of flags that are passed to the linker. If you need to change the flags used for a particular platform or type of project, use one of the specialized variables for that purpose instead of this variable.\n\nQMAKE_LFLAGS_CONSOLE\n\nSpecifies the linker flags for building console programs. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_DEBUG\n\nSpecifies the linker flags for debug builds. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_PLUGIN\n\nSpecifies the linker flags for building plugins. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_RPATH\n\nSpecifies the linker flags needed to use the values from QMAKE_RPATHDIR.\n\nThe value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_REL_RPATH\n\nSpecifies the linker flags needed to enable relative paths in QMAKE_RPATHDIR.\n\nThe value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_REL_RPATH_BASE\n\nSpecifies the string the dynamic linker understands to be the location of the referring executable or library.\n\nThe value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_RPATHLINK\n\nSpecifies the linker flags needed to use the values from QMAKE_RPATHLINKDIR.\n\nThe value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_RELEASE\n\nSpecifies the linker flags for release builds. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_RELEASE_WITH_DEBUGINFO\n\nSpecifies the linker flags for release builds where force_debug_info is set in CONFIG. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_APP\n\nSpecifies the linker flags for building applications. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_SHLIB\n\nSpecifies the linker flags used for building shared libraries. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_SONAME\n\nSpecifies the linker flags for setting the name of shared objects, such as .so or .dll. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_THREAD\n\nSpecifies the linker flags for building multi-threaded projects. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LFLAGS_WINDOWS\n\nSpecifies the linker flags for building Windows GUI projects (that is, non-console applications). The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIBDIR\n\nSpecifies a list of library search paths for all projects. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nTo specify additional search paths in project files, use LIBS like that, instead:\n\nLIBS += -L/path/to/libraries\n\nQMAKE_LIBDIR_POST\n\nSpecifies a list of system library search paths for all projects. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIBDIR_FLAGS\n\nSpecifies the location of all library directories with -L prefixed. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIBDIR_EGL\n\nSpecifies the location of the EGL library directory, when EGL is used with OpenGL/ES or OpenVG. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIBDIR_OPENGL\n\nSpecifies the location of the OpenGL library directory. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenGL implementation uses EGL (most OpenGL/ES systems), then QMAKE_LIBDIR_EGL may also need to be set.\n\nQMAKE_LIBDIR_OPENVG\n\nSpecifies the location of the OpenVG library directory. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenVG implementation uses EGL, then QMAKE_LIBDIR_EGL may also need to be set.\n\nQMAKE_LIBDIR_X11\n\nSpecifies the location of the X11 library directory. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIBS\n\nSpecifies additional libraries each project needs to link against. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nTo specify libraries in a project file, use LIBS instead.\n\nQMAKE_LIBS_PRIVATE\n\nSpecifies additional private libraries each project needs to link against. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nTo specify private libraries in a library project file, use LIBS_PRIVATE instead.\n\nQMAKE_LIBS_EGL\n\nSpecifies all EGL libraries when building Qt with OpenGL/ES or OpenVG. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified. The usual value is -lEGL.\n\nQMAKE_LIBS_OPENGL\n\nSpecifies all OpenGL libraries. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenGL implementation uses EGL (most OpenGL/ES systems), then QMAKE_LIBS_EGL may also need to be set.\n\nQMAKE_LIBS_OPENGL_ES1, QMAKE_LIBS_OPENGL_ES2\n\nThese variables specify all the OpenGL libraries for OpenGL ES 1 and OpenGL ES 2.\n\nThe value of these variables is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nIf the OpenGL implementation uses EGL (most OpenGL/ES systems), then QMAKE_LIBS_EGL may also need to be set.\n\nQMAKE_LIBS_OPENVG\n\nSpecifies all OpenVG libraries. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified. The usual value is -lOpenVG.\n\nSome OpenVG engines are implemented on top of OpenGL. This will be detected at configure time and QMAKE_LIBS_OPENGL will be implicitly added to QMAKE_LIBS_OPENVG wherever the OpenVG libraries are linked.\n\nIf the OpenVG implementation uses EGL, then QMAKE_LIBS_EGL may also need to be set.\n\nQMAKE_LIBS_THREAD\n\nSpecifies all libraries that need to be linked against when building a multi-threaded target. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIBS_X11\n\nSpecifies all X11 libraries. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LIB_FLAG\n\nThis variable is not empty if the lib template is specified. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LINK\n\nSpecifies the linker that will be used when building application based projects. Only the file name of the linker executable needs to be specified as long as it is on a path contained in the PATH variable when the Makefile is processed. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LINK_SHLIB_CMD\n\nSpecifies the command to execute when creating a shared library. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LN_SHLIB\n\nSpecifies the command to execute when creating a link to a shared library. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_LRELEASE_FLAGS\n\nList of additional options passed to lrelease when enabled through CONFIG += lrelease.\n\nQMAKE_OBJECTIVE_CFLAGS\n\nSpecifies the Objective C/C++ compiler flags for building a project. These flags are used in addition to QMAKE_CFLAGS and QMAKE_CXXFLAGS.\n\nQMAKE_POST_LINK\n\nSpecifies the command to execute after linking the TARGET together. This variable is normally empty and therefore nothing is executed.\n\nQMAKE_PRE_LINK\n\nSpecifies the command to execute before linking the TARGET together. This variable is normally empty and therefore nothing is executed.\n\nQMAKE_PROJECT_NAME\n\nDetermines the name of the project when generating project files for IDEs. The default value is the target name. The value of this variable is typically handled by qmake and rarely needs to be modified.\n\nQMAKE_PROVISIONING_PROFILE\n\nThe UUID of a valid provisioning profile. Use in conjunction with QMAKE_DEVELOPMENT_TEAM to specify the provisioning profile.\n\nQMAKE_MAC_SDK\n\nThis variable is used on macOS when building universal binaries.\n\nQMAKE_MACOSX_DEPLOYMENT_TARGET\n\nSpecifies the hard minimum version of macOS that the application supports.\n\nFor more information, see macOS Supported Versions.\n\nQMAKE_MAKEFILE\n\nSpecifies the name of the Makefile to create. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_QMAKE\n\nContains the absolute path of the qmake executable.\n\nQMAKE_RESOURCE_FLAGS\n\nThis variable is used to customize the list of options passed to the Resource Compiler in each of the build rules where it is used. For example, the following line ensures that the -threshold and -compress options are used with particular values each time that rcc is invoked:\n\nQMAKE_RESOURCE_FLAGS += -threshold 0 -compress 9\n\nQMAKE_RPATHDIR\n\nSpecifies a list of library paths that are added to the executable at link time so that the paths will be preferentially searched at runtime.\n\nWhen relative paths are specified, qmake will mangle them into a form understood by the dynamic linker to be relative to the location of the referring executable or library. This is supported only by some platforms (currently Linux and Darwin-based ones) and is detectable by checking whether QMAKE_REL_RPATH_BASE is set.\n\nQMAKE_RPATHLINKDIR\n\nSpecifies a list of library paths for the static linker to search for implicit dependencies of shared libraries. For more information, see the manual page for ld(1).\n\nQMAKE_RUN_CC\n\nSpecifies the individual rule needed to build an object. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_RUN_CC_IMP\n\nSpecifies the individual rule needed to build an object. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_RUN_CXX\n\nSpecifies the individual rule needed to build an object. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_RUN_CXX_IMP\n\nSpecifies the individual rule needed to build an object. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_SONAME_PREFIX\n\nIf defined, the value of this variable is used as a path to be prepended to the built shared library's SONAME identifier. The SONAME is the identifier that the dynamic linker will later use to reference the library. In general, this reference may be a library name or full library path. On macOS, iOS, tvOS, and watchOS, the path may be specified relatively using the following placeholders:\n\nIn most cases, using @rpath is sufficient and recommended:\n\n# <project root>/project.pro QMAKE_SONAME_PREFIX = @rpath\n\nHowever, the prefix may be also specified using different placeholders, or an absolute path, such as one of the following:\n\n# <project root>/project.pro QMAKE_SONAME_PREFIX = @executable_path/../Frameworks QMAKE_SONAME_PREFIX = @loader_path/Frameworks QMAKE_SONAME_PREFIX = /Library/Frameworks\n\nFor more information, see dyld documentation on dynamic library install names.\n\nQMAKE_TARGET\n\nSpecifies the name of the project target. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nQMAKE_TARGET_COMPANY\n\nWindows only. Specifies the company for the project target; this is used where applicable for putting the company name in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_TARGET_DESCRIPTION\n\nWindows only. Specifies the description for the project target; this is used where applicable for putting the description in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_TARGET_COPYRIGHT\n\nWindows only. Specifies the copyright information for the project target; this is used where applicable for putting the copyright information in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_TARGET_PRODUCT\n\nWindows only. Specifies the product for the project target; this is used where applicable for putting the product in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_TARGET_ORIGINAL_FILENAME\n\nWindows only. Specifies the original file name for the project target; this is used where applicable for putting the original file name in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_TARGET_INTERNALNAME\n\nWindows only. Specifies the internal name for the project target; this is used where applicable for putting the internal name in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nWindows only. Specifies the comments for the project target; this is used where applicable for putting the comments in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_TARGET_TRADEMARKS\n\nWindows only. Specifies the trademark information for the project target; this is used where applicable for putting the trademark information in the application's properties. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nQMAKE_MANIFEST\n\nWindows only. Specifies the manifest file for the project target. This is only utilized if the RC_FILE and RES_FILE variables are not set. Don't forget to remove embed_manifest_exe and embed_manifest_dll from the CONFIG variable, otherwise it will conflict with the compiler generated one.\n\nQMAKE_TVOS_DEPLOYMENT_TARGET\n\nSpecifies the hard minimum version of tvOS that the application supports.\n\nFor more information, see Expressing Supported iOS Versions.\n\nQMAKE_UIC_FLAGS\n\nThis variable is used to customize the list of options passed to the User Interface Compiler in each of the build rules where it is used.\n\nQMAKE_WATCHOS_DEPLOYMENT_TARGET\n\nSpecifies the hard minimum version of watchOS that the application supports.\n\nFor more information, see Expressing Supported iOS Versions.\n\nQML_IMPORT_MAJOR_VERSION\n\nSpecifies the major version to be used for automatically generated QML type registrations. For more information, see Defining QML Types from C++.\n\nQML_IMPORT_MINOR_VERSION\n\nWhen automatically registering QML types defined in C++, register an additional version of the module using this minor version. Generally, minor versions to be registered are inferred from the meta objects.\n\nYou can use this variable if the meta objects have not changed and you still want to import a QML module with a newer minor version number. For example, MyModule metaobjects are at 1.1 level, but you want to import the module as 1.3.\n\nQML_IMPORT_VERSION\n\nSpecifies QML_IMPORT_MAJOR_VERSION and QML_IMPORT_MINOR_VERSION as a <major>.<minor> version string.\n\nQML_IMPORT_NAME\n\nSpecifies the module name to be used for automatically generated QML type registrations. For more information, see Defining QML Types from C++.\n\nQML_FOREIGN_METATYPES\n\nSpecifies further JSON files with metatypes to be considered when generating qmltypes files. Use this when external libraries provide types that are exposed to QML, either directly or as base types or properties of other types. Qt types will automatically be considered and don't have to be added here.\n\nQT\n\nSpecifies the Qt modules that are used by your project. For the value to add for each module, see the module documentation.\n\nAt the C++ implementation level, using a Qt module makes its headers available for inclusion and causes it to be linked to the binary.\n\nBy default, QT contains core and gui, ensuring that standard GUI applications can be built without further configuration.\n\nIf you want to build a project without the Qt GUI module, you need to exclude the gui value with the \"-=\" operator. The following line will result in a minimal Qt project being built:\n\nQT -= gui # Only the core module is used.\n\nIf your project is a Qt Designer plugin, use the value uiplugin to specify that the project is to be built as a library, but with specific plugin support for Qt Designer. For more information, see Building and Installing the Plugin.\n\nQTPLUGIN\n\nSpecifies a list of names of static Qt plugins that are to be linked with an application so that they are available as built-in resources.\n\nqmake automatically adds the plugins that are typically needed by the used Qt modules (see QT). The defaults are tuned towards an optimal out-of-the-box experience. See Static Plugins for a list of available plugins, and ways to override the automatic linking.\n\nThis variable currently has no effect when linking against a shared/dynamic build of Qt, or when linking libraries. It may be used for deployment of dynamic plugins at a later time.\n\nQT_VERSION\n\nContains the current version of Qt.\n\nQT_MAJOR_VERSION\n\nContains the current major version of Qt.\n\nQT_MINOR_VERSION\n\nContains the current minor version of Qt.\n\nQT_PATCH_VERSION\n\nContains the current patch version of Qt.\n\nRC_FILE\n\nWindows only. Specifies the name of the Windows resource file (.rc) for the target. See Adding Windows Resource Files.\n\nRC_CODEPAGE\n\nWindows only. Specifies the codepage that should be specified in a generated .rc file. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nRC_DEFINES\n\nWindows only. qmake adds the values of this variable as RC preprocessor macros (/d option). If this variable is not set, the DEFINES variable is used instead.\n\nRC_DEFINES += USE_MY_STUFF\n\nRC_ICONS\n\nWindows only. Specifies the icons that should be included into a generated .rc file. This is only utilized if the RC_FILE and RES_FILE variable are not set. More details about the generation of .rc files can be found in the Platform Notes.\n\nRC_LANG\n\nWindows only. Specifies the language that should be specified in a generated .rc file. This is only utilized if the VERSION or RC_ICONS variable is set and the RC_FILE and RES_FILE variables are not set.\n\nRC_INCLUDEPATH\n\nSpecifies include paths that are passed to the Windows Resource Compiler.\n\nRCC_DIR\n\nSpecifies the directory for Qt Resource Compiler output files.\n\nFor example:\n\nunix:RCC_DIR = ../myproject/resources win32:RCC_DIR = c:/myproject/resources\n\nREQUIRES\n\nSpecifies a list of values that are evaluated as conditions. If any of the conditions is false, qmake skips this project (and its SUBDIRS) when building.\n\nRESOURCES\n\nSpecifies the name of the resource collection files (qrc) for the target. For more information about the resource collection file, see The Qt Resource System.\n\nRES_FILE\n\nWindows only. Specifies the name of the Windows resource compiler's output file for this target. See RC_FILE and Adding Windows Resource Files.\n\nThe value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nSOURCES\n\nSpecifies the names of all source files in the project.\n\nFor example:\n\nSOURCES = myclass.cpp \\ login.cpp \\ mainwindow.cpp\n\nSee also HEADERS.\n\nSUBDIRS\n\nThis variable, when used with the subdirs template specifies the names of all subdirectories or project files that contain parts of the project that need to be built. Each subdirectory specified using this variable must contain its own project file.\n\nIt is recommended that the project file in each subdirectory has the same base name as the subdirectory itself, because that makes it possible to omit the file name. For example, if the subdirectory is called myapp, the project file in that directory should be called myapp.pro.\n\nAlternatively, you can specify a relative path to a .pro file in any directory. It is strongly recommended that you specify only paths in the current project's parent directory or its subdirectories.\n\nFor example:\n\nSUBDIRS = kernel \\ tools \\ myapp\n\nIf you need to ensure that the subdirectories are built in a particular order, use the .depends modifier on the relevant SUBDIRS elements.\n\nFor example:\n\nSUBDIRS += my_executable my_library tests doc my_executable.depends = my_library tests.depends = my_executable\n\nThe configuration above ensures that my_library is built before my_executable and that my_executable is built before tests. However, doc can be built in parallel with the other subdirectories, thus speeding up the build process.\n\nBeside defining the build order, it is possible to modify the default behavior of SUBDIRS by giving additional modifiers to SUBDIRS elements. Supported modifiers are:\n\nFor example, define two subdirectories, both of which reside in a different directory than the SUBDIRS value, and one of the subdirectories must be built before the other:\n\nSUBDIRS += my_executable my_library my_executable.subdir = app my_executable.depends = my_library my_library.subdir = lib\n\nTARGET\n\nSpecifies the name of the target file. Contains the base name of the project file by default.\n\nFor example:\n\nTEMPLATE = app TARGET = myapp SOURCES = main.cpp\n\nThe project file above would produce an executable named myapp on unix and myapp.exe on Windows.\n\nTARGET_EXT\n\nSpecifies the extension of TARGET. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nTARGET_x\n\nSpecifies the extension of TARGET with a major version number. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nTARGET_x.y.z\n\nSpecifies the extension of TARGET with a version number. The value of this variable is typically handled by qmake or qmake.conf and rarely needs to be modified.\n\nTEMPLATE\n\nSpecifies the name of the template to use when generating the project. The allowed values are:\n\nFor example:\n\nTEMPLATE = lib SOURCES = main.cpp TARGET = mylib\n\nThe template can be overridden by specifying a new template type with the -t command line option. This overrides the template type after the .pro file has been processed. With .pro files that use the template type to determine how the project is built, it is necessary to declare TEMPLATE on the command line rather than use the -t option.\n\nTRANSLATIONS\n\nSpecifies a list of translation (.ts) files that contain translations of the user interface text into non-native languages.\n\nTranslation files in TRANSLATIONS will be processed by both lrelease and Using lupdate tools. Use EXTRA_TRANSLATIONS if you want only lrelease to process a file.\n\nYou can use CONFIG += lrelease to automatically compile the files during the build, and CONFIG += lrelease embed_translations to make them available in The Qt Resource System.\n\nSee the Qt Linguist Manual for more information about internationalization (i18n) and localization (l10n) with Qt.\n\nUI_DIR\n\nSpecifies the directory where all intermediate files from uic should be placed.\n\nFor example:\n\nunix:UI_DIR = ../myproject/ui win32:UI_DIR = c:/myproject/ui\n\nVERSION\n\nSpecifies the version number of the application if the app template is specified or the version number of the library if the lib template is specified.\n\nOn Windows, triggers auto-generation of an .rc file if the RC_FILE and RES_FILE variables are not set. The generated .rc file will have the FILEVERSION and PRODUCTVERSION entries filled with major, minor, patch level, and build number. Each number must be in the range from 0 to 65535. More details about the generation of .rc files can be found in the Platform Notes.\n\nFor example:\n\nwin32:VERSION = 1.2.3.4 # major.minor.patch.build else:VERSION = 1.2.3 # major.minor.patch\n\nVERSION_PE_HEADER\n\nWindows only. Specifies the version number, that the Windows linker puts into the header of the .exe or .dll file via the /VERSION option. Only a major and minor version may be specified. If VERSION_PE_HEADER is not set, it falls back to the major and minor version from VERSION (if set).\n\nVERSION_PE_HEADER = 1.2\n\nVER_MAJ\n\nSpecifies the major version number of the library if the lib template is specified.\n\nVER_MIN\n\nSpecifies the minor version number of the library if the lib template is specified.\n\nVER_PAT\n\nSpecifies the patch version number of the library if the lib template is specified.\n\nVPATH\n\nTells qmake where to search for files it cannot open. For example, if qmake looks for SOURCES and finds an entry that it cannot open, it looks through the entire VPATH list to see if it can find the file on its own.\n\nSee also DEPENDPATH.\n\nWINDOWS_TARGET_PLATFORM_VERSION\n\nSpecifies the targeted Windows version; this corresponds to the tag WindowsTargetPlatformVersion in vcxproj files.\n\nOn desktop Windows, the default value is the value of the environment variable WindowsSDKVersion.\n\nWINDOWS_TARGET_PLATFORM_MIN_VERSION\n\nSpecifies the minimum version of the Windows target platform; this corresponds to the tag WindowsTargetPlatformMinVersion in vcxproj files.\n\nDefaults to WINDOWS_TARGET_PLATFORM_VERSION.\n\nYACCSOURCES\n\nSpecifies a list of Yacc source files to be included in the project. All dependencies, headers and source files will automatically be included in the project.\n\nFor example:\n\nYACCSOURCES = moc.y\n\n_PRO_FILE_\n\nContains the path to the project file in use.\n\nFor example, the following line causes the location of the project file to be written to the console:\n\nmessage($$_PRO_FILE_)\n\n_PRO_FILE_PWD_\n\nContains the path to the directory containing the project file in use.\n\nFor example, the following line causes the location of the directory containing the project file to be written to the console:\n\nmessage($$_PRO_FILE_PWD_)"
    }
}