{
    "id": "dbpedia_5009_3",
    "rank": 0,
    "data": {
        "url": "https://doc.qt.io/qt-6/resources.html",
        "read_more_link": "",
        "language": "en",
        "title": "The Qt Resource System",
        "top_image": "https://d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon-32x32.png",
        "meta_img": "https://d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon-32x32.png",
        "images": [
            "https://doc.qt.io/style/qt-logo-documentation.svg",
            "https://doc.qt.io/images/qtgroup.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "A platform-independent mechanism for shipping resource files in an application.",
        "meta_lang": "en",
        "meta_favicon": "//d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon.ico.gzip",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "The Qt resource system is a platform-independent mechanism for shipping resource files in an application. Use it if your application always needs a certain set of files (like icons, translation files, images), and you don't want to use system-specific means to package and locate these resources.\n\nMost commonly, the resource files are embedded into your application executable, or in libraries and plugins that are loaded by the application executable. Alternatively, the resource files can also be stored in an external resource file.\n\nThe resource system is based on tight cooperation between Qt's rcc resource compiler, the build system, and the Qt runtime API.\n\nThe Qt Resource Compiler (rcc)\n\nThe Resource Compiler (rcc) command line tool reads resource files and generates either a C++ or Python source file, or an .rcc file.\n\nThe list of files and related metadata is passed to rcc in the form of a Qt Resource Collection File.\n\nBy default, rcc will generate C++ source code that is then compiled as part of an executable or library. The -g python option generates Python source code instead. The -binary option generates a binary archive that is by convention saved in an .rcc file and can be loaded at runtime.\n\nQt Resource Collection File (.qrc)\n\nA .qrc file is an XML document that enumerates local files to be included as runtime resources. It serves as input to rcc.\n\nHere's an example .qrc file:\n\n<RCC> <qresource prefix=\"/\"> <file>images/copy.png</file> <file>images/cut.png</file> <file>images/new.png</file> <file>images/open.png</file> <file>images/paste.png</file> <file>images/save.png</file> </qresource> </RCC>\n\nEach <file> element in the XML identifies a file in the application's source tree. The path is resolved relative to the directory containing the .qrc file.\n\nThe path is also used by default to identify the file's content at runtime. That is, the file titlebarLeft.png will be available in the resource system as :/res/titlebarLeft.png or qrc:/res/titlebarLeft.png. To override this default run-time name, see Prefixes and Aliases.\n\nQt Creator, Qt Design Studio, Qt Designer, and Qt Visual Studio Tools allow you to create, inspect and edit .qrc files through a convenient user interface. Except for Qt Designer, they also provide wizards for projects using the Qt resource system.\n\nBuild System Integration\n\nThe processing of resource files with rcc is typically done at the time the application is built. Several build tools have dedicated support for this, including CMake and qmake.\n\nCMake\n\nIf CMAKE_AUTORCC is enabled, you can just add .qrc files as sources to your executable or library. The referenced resource files will then be embedded into the binary:\n\nset(CMAKE_AUTORCC ON) qt_add_executable(my_app application.qrc main.cpp )\n\nSee CMake's AUTORCC documentation for more details about AUTORCC.\n\nAn alternative to AUTORCC is using Qt6Core's CMake function qt_add_resources, which gives more control over the creation of resources. For example, it allows you to specify the content of the resource directly in the project file without writing a .qrc file first:\n\nqt_add_resources(my_app \"app_images\" PREFIX \"/\" FILES images/copy.png images/cut.png images/new.png images/open.png images/paste.png images/save.png )\n\nFinally, qt_add_qml_module allows you to embed Qt Quick resources into the resource system of your application. The function is defined in the Qml component of the Qt6 CMake package.\n\nqmake\n\nqmake supports handing resources with the RESOURCES variable. If you add a .qrc file path to the variable, the listed resource files will be embedded into the generated library or executable:\n\nRESOURCES = application.qrc\n\nThis creates a resource of several .png files, that are addressable like this: \":/res/titlebarLeft.png\".\n\nIf the directory layout of the files you want to embed into the resource doesn't match the expectations of the application, you can specify resources.base. base is a path prefix that denotes the root point of the file's alias. In the example above, if resources.base is set to \"res\", then titlebarLeft.png is addressable as \":/titlebarLeft.png\".\n\nRuntime API\n\nQt API that deals with iterating and reading files has built-in support for the Qt Resource System. You can pass a resource path instead of a local file path to QFile and QDir, but also for instance to the QIcon, QImage, and QPixmap constructors:\n\nThe : prefix makes it explicit that \"/images/cut.png\" should be loaded from the Qt Resource System.\n\nYou can also reference the Qt resource system through a QUrl. Use the qrc scheme in this case:\n\nAdvanced Topics\n\nPrefixes\n\nA .qrc file can set a prefix to be added to each local file name, given in a <file> element, to get the name by which the file shall be known within the resource system.\n\nPrefixes allow you to structure the resources, avoiding clashes between resource files added through different .qrc files in different libraries or plugins.\n\nAliases\n\nSometimes it is convenient to make a resource file available under a different path at runtime. .qrc files allow this by setting an alias attribute:\n\nThe file is from the application then only accessible as :/cut-img.png or qrc:/cut-img.png.\n\nDiscarding the file contents\n\nSometimes you want to add a file node to the resource file system but don't actually want to add the file contents. .qrc files allow this by setting the empty attribute to true.\n\nThe resulting file is then still accessible from the application, but its contents are empty.\n\nThis is useful to strip QML source code from an application binary.\n\nLanguage Selectors\n\nSome resources need to change based on the user's locale, such as translation files or icons. Resource Collection Files support this through a lang attribute to the qresource tag, specifying a suitable locale string. For example:\n\nIf the user's locale is French (i.e., QLocale::system().language() is French), :/cut.jpg or qrc:/cut.jpg becomes a reference to the cut_fr.jpg image. For other locales, cut.jpg is used.\n\nSee the QLocale documentation for a description of the format to use for locale strings.\n\nSee QFileSelector for an additional mechanism to select locale-specific resources.\n\nEmbedding Large Files\n\nBy default, rcc embeds the resource files into executables in the form of C++ arrays. This can be problematic especially for large resources.\n\nIf the compiler takes too long, or even fails because of memory overflow, you can opt into a special mode where the resources are embedded as part of a two-step process. The C++ compiler only reserves enough space in the target executable or library for the resources. The actual embedding of the resource file's content and metadata is then done after the compilation and linking phase, through another rcc call.\n\nFor CMake, you need to use the qt_add_big_resources function.\n\nExternal Resource Files\n\nAn alternative to embedding the resource files into the binary is to store them in a separate .rcc file. rcc allows this with the -binary option. Such a .rcc file must then be loaded at runtime with QResource.\n\nFor example, a set of resource data specified in a .qrc file can be compiled in the following way:\n\nIn the application, this resource would be registered with code like this:\n\nIf you use CMake, you can use the qt_add_binary_resources function to schedule the rcc call above:\n\nqt_add_binary_resources(resources application.qrc DESTINATION application.rcc) add_dependencies(my_app resources)\n\nResources in a Qt for Python application\n\nThe resource collection file is converted to a Python module by using the resource compiler rcc:\n\nThe module can then be imported in the application:\n\nCompression\n\nrcc attempts to compress the content to optimize disk space usage in the final binaries. By default, it will perform a heuristic check to determine whether compressing is worth it and will store the content uncompressed if it fails to sufficiently compress. To control the threshold, you can use the -threshold option, which tells rcc the percentage of the original file size that must be gained for it to store the file in compressed form.\n\nThe default value is \"70\", indicating that the compressed file must be 70% smaller than the original (no more than 30% of the original file size).\n\nIt is possible to turn off compression if desired. This can be useful if your resources already contain a compressed format, such as .png files, and you do not want to incur the CPU cost at build time to confirm that it can't be compressed. Another reason is if disk usage is not a problem and the application would prefer to keep the content as clean memory pages at runtime. You do this by giving the -no-compress command line argument.\n\nrcc also gives you some control over the compression level and compression algorithm, for example:\n\nIt is also possible to use threshold, compress, and compress-algo as attributes in a .qrc file tag.\n\nThe above will select the zstd algorithm with compression level 1.\n\nrcc supports the following compression algorithms and compression levels:\n\nbest: use the best algorithm among the ones below, at its highest compression level, to achieve the most compression at the expense of using a lot of CPU time during compilation. This value is useful in the XML file to indicate a file should be most compressed, regardless of which algorithms rcc supports.\n\nzstd: use the Zstandard library to compress contents. Valid compression levels range from 1 to 19, 1 is least compression (least CPU time) and 19 is the most compression (most CPU time). The default level is 14. A special value of 0 tells the zstd library to choose an implementation-defined default.\n\nzlib: use the zlib library to compress contents. Valid compression levels range from 1 to 9, with 1 applying the least compression (least CPU time) and 9 the most compression (most CPU time). The special value 0 means \"no compression\" and should not be used. The default is implementation-defined, but usually is level 6.\n\nnone: no compression. This is the same as the -no-compress option.\n\nSupport for both Zstandard and zlib are optional. If a given library was not detected at compile time, attempting to pass -compress-algo for that library will result in an error. The default compression algorithm is zstd if it is enabled, zlib if not.\n\nExplicit Loading and Unloading of Embedded Resources\n\nResources embedded in C++ executable or library code are automatically registered to the Qt resource system in a constructor of an internal global variable. Since the global variables are initialized before main() runs, the resources are available when the program starts to run.\n\nWhen embedding resources in static libraries, the C++ linker might remove the static variables that register the resources. If you embed resources in a static library, you therefore need to explicitly register your resources by calling Q_INIT_RESOURCE() with the base name of the .qrc file. For example:\n\nYou can also explicitly remove registered resources from the application, for instance when unloading a plugin. Use Q_CLEANUP_RESOURCE() for this."
    }
}