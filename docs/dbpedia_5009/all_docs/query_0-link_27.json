{
    "id": "dbpedia_5009_0",
    "rank": 27,
    "data": {
        "url": "https://amirkoblog.wordpress.com/2018/08/14/creating-c17-enabled-qt-projects/",
        "read_more_link": "",
        "language": "en",
        "title": "Creating C++17 enabled Qt projects",
        "top_image": "https://amirkoblog.wordpress.com/wp-content/uploads/2018/08/cpp17_win64_qt11_kit.jpg",
        "meta_img": "https://amirkoblog.wordpress.com/wp-content/uploads/2018/08/cpp17_win64_qt11_kit.jpg",
        "images": [
            "https://amirkoblog.wordpress.com/wp-content/uploads/2018/08/cpp17_win64_qt11_kit.jpg?w=809",
            "https://amirkoblog.wordpress.com/wp-content/uploads/2017/05/1981240.png?w=50",
            "https://amirkoblog.wordpress.com/wp-content/uploads/2017/05/1981240.png?w=50",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2018-08-14T00:00:00",
        "summary": "",
        "meta_description": "While using qmake as a build process for Qt projects, we can define several project configuration and compiler options using CONFIG . To enable C++11 or C++14, we can use: However, C++17 is not yet recognized for Qt 5.11. So, instead we can use the following: This post demonstrates a simple Qt Console application that…",
        "meta_lang": "en",
        "meta_favicon": "https://amirkoblog.wordpress.com/wp-content/uploads/2017/05/1981240.png?w=32",
        "meta_site_name": "AmirShrestha's Blog",
        "canonical_link": "https://amirkoblog.wordpress.com/2018/08/14/creating-c17-enabled-qt-projects/",
        "text": "While using qmake as a build process for Qt projects, we can define several project configuration and compiler options using CONFIG . To enable C++11 or C++14, we can use:\n\nCONFIG += C++11 or CONFIG += C++14\n\nHowever, C++17 is not yet recognized for Qt 5.11. So, instead we can use the following:\n\nQMAKE_CXXFLAGS += /std:c++17\n\nThis post demonstrates a simple Qt Console application that has all of these compiler configurations so that it is easy to test C++17 features quickly using Qt project file (.pro) in QtCreator IDE.\n\nTo begin with, we need to have Qt 5.11 already installed. Next, we need to have the latest compiler which supports C++17. For this post, I have used Microsoft Visual C++ compiler (Microsoft Visual Studio 17 Community Edition).\n\nIn Qt Creator, add Kit with the following configurations:\n\nName: win64-vc15-qt11\n\nCompiler: Microsoft Visual C++ Compiler (x86_amd64)\n\nQt Version: Qt 5.11.0 (msvc2017_64)\n\nThis is illustrated in the figure below:\n\nOnce the right Kit is configured, we can create a simple Qt Console application named “Cpp17Test”. This will create the following files:\n\nCpp17Test.pro\n\nmain.cpp\n\nThe file Cpp17Test.pro looks as shown below:\n\nQT -= gui CONFIG += c++14 console CONFIG -= app_bundle QMAKE_CXXFLAGS += /std:c++17 # The following define makes your compiler emit warnings if you use # any feature of Qt which as been marked deprecated (the exact warnings # depend on your compiler). Please consult the documentation of the # deprecated API in order to know how to port your code away from it. DEFINES += QT_DEPRECATED_WARNINGS # You can also make your code fail to compile if you use deprecated APIs. # In order to do so, uncomment the following line. # You can also select to disable deprecated APIs only up to a certain version of Qt. #DEFINES += QT_DISABLE_DEPRECATED_BEFORE=0x060000 # disables all the APIs deprecated before Qt 6.0.0 SOURCES += main.cpp\n\nIn main.cpp file, we can include several headers that are supported in C++17. Also, we can test C++17 features. For this post, I have used examples from cppreference\n\nThe main.cpp, where I’ve combined all examples, looks as shown below:\n\nnamespace StructuredBindings { int run() { std::cout << \"Structured Bindings Demo\\n\"; std::set myset; if (auto [iter, success] = myset.insert(\"Hello\"); success) std::cout << \"insert is successful. The value is \" << std::quoted(*iter) << '\\n'; else std::cout << \"The value \" << std::quoted(*iter) << \" already exists in the set\\n\"; std::cout << \"\\n\"; return 0; } }\n\nnamespace Optional { // optional can be used as the return type of a factory that may fail std::optional create(bool b) { if (b) return \"Godzilla\"; return {}; } // std::nullopt can be used to create any (empty) std::optional auto create2(bool b) { return b ? std::optional{\"Godzilla\"} : std::nullopt; } // std::reference_wrapper may be used to return a reference auto create_ref(bool b) { static std::string value = \"Godzilla\"; return b ? std::optional<std::reference_wrapper>{value} : std::nullopt; } int run() { std::cout << \"Optional Demo\\n\"; std::cout << \"create(false) returned \" << create(false).value_or(\"empty\") << '\\n'; // optional-returning factory functions are usable as conditions of while and if if (auto str = create2(true)) { std::cout << \"create2(true) returned \" << *str << '\\n'; } if (auto str = create_ref(true)) { // using get() to access the reference_wrapper's value std::cout << \"create_ref(true) returned \" <get() <get() = \"Mothra\"; std::cout << \"modifying it changed it to \" <get() << '\\n'; } std::cout << \"\\n\"; return 0; } } // end namespace\n\nnamespace RandomNumbers { //Select five numbers from 1 to 69 for the white balls; then select one number from 1 to 26 for the red Powerball. int run() { std::cout << \"Random numbers demo\\n\"; std::random_device rd {}; auto mtgen = std::mt19937 {rd()}; auto ud = std::uniform_int_distribution{1,69}; // select five numbers for white balls std::cout << \"Five numbers for white ball: \"; for(auto i = 0; i < 5; ++i) { auto number = ud(mtgen); std::cout << number << \" \"; } std::cout << \"\\n\"; std::cout << \"Powerball number: \" << ud(mtgen) << \"\\n\"; return 0; } } // end namespace\n\nnamespace StringView { int run() { std::cout << \"StringView Demo\\n\"; std::string_view str_view(\"abcd\"); auto begin = str_view.begin(); auto cbegin = str_view.cbegin(); std::cout << *begin << '\\n'; std::cout << *cbegin << '\\n'; std::cout << std::boolalpha << (begin == cbegin) << '\\n'; std::cout << std::boolalpha << (*begin == *cbegin) << '\\n'; std::cout << \"\\n\"; return 0; } } // end namespace\n\nnamespace Variant { using namespace std::literals; int run() { std::cout << \"Variant Demo\\n\"; std::variant v, w; v = 12; // v contains int int i = std::get(v); w = std::get(v); w = std::get(v); // same effect as the previous line w = v; // same effect as the previous line // std::get(v); // error: no double in [int, float] // std::get(v); // error: valid index values are 0 and 1 try { std::get(w); // w contains int, not float: will throw } catch (const std::bad_variant_access&) {} std::variant x(\"abc\"); // converting constructors work when unambiguous x = \"def\"; // converting assignment also works when unambiguous std::variant y(\"abc\"); // casts to bool when passed a char const * assert(std::holds_alternative(y)); // succeeds y = \"xyz\"s; assert(std::holds_alternative(y)); //succeeds std::cout << \"\\n\"; return 0; } } // end namespace\n\nint main(int argc, char *argv[]) { QCoreApplication a(argc, argv); qDebug() << \"C++17 Features Test\\n\"; StructuredBindings::run(); Optional::run(); Any::run(); Variant::run(); MonoState::run(); FileSystems::run(); StringView::run(); qDebug() << \"End of C++17 Features Test\\n\"; return a.exec(); }\n\nWe can add several small examples in main.cpp file to quickly test whether new C++17 features are supported by the compiler that is configured."
    }
}