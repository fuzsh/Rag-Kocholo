{
    "id": "dbpedia_5009_2",
    "rank": 67,
    "data": {
        "url": "https://docs.innerzaurus.com/en/latest/legacy/qml/chapter-04-s01.html",
        "read_more_link": "",
        "language": "en",
        "title": "Basic — Qt Programming Course 1.0 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.innerzaurus.com/en/latest/_images/01_project_windows.png",
            "https://docs.innerzaurus.com/en/latest/_images/02_project_files.png",
            "https://docs.innerzaurus.com/en/latest/_images/03_code_sample.png",
            "https://docs.innerzaurus.com/en/latest/_images/04_code_labels.png",
            "https://docs.innerzaurus.com/en/latest/_images/05_code_columns.png",
            "https://docs.innerzaurus.com/en/latest/_images/06_code_end.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "QML App - BasicÂ¶\n\nQML languageÂ¶\n\nQML is a language that is based on JavaScript and is used to create the user interface of an application. It allows you to use both traditional components (buttons, lists, etc.) and graphic elements to which logic is added. An example of the first case is the Ubuntu Touch user interface. For the second case there are several examples on the QT Web. QML handles the visualization but not the logic that implements the application.\n\nThis logic can be written in several languages, depending on the needs we have. If the application is a game and needs computing power, the language chosen would be C/C++. On the other hand, if the performance of the app is not critical, you can use JavaScript. At the moment the applications of the course will use JavaScript and later will be written in C/C++.\n\nThe configuration of the project must be the following:\n\nProject type: QML App with Simple UI (qmake).\n\nKits: select all installed kits.\n\nProject structureÂ¶\n\nThe project will be created with the chosen template and will open by default, the user interface (QML) file.\n\nProject Window\n\nThe structure of the project varies slightly comparing it to the one that had the Web App.\n\nProject Structure\n\nFiles that can be modified are displayed in bold type. The remaining files are for internal use of the IDE and should not be modified.\n\nCalculator.pro: main project file.\n\nCalculator\n\nCalculator.pro: information for the compiler.\n\nQML\n\nTests / unit: The files in this folder are used to make validations of the application.\n\nMain.qml: file containing the user interface of a screen.\n\nOther files\n\nTests / autopilot: The files in this folder are used to run the application.\n\nCalculator.apparmor: application permissions\n\nCalculator.desktop: application information for the application launcher.\n\nCalculator.png: application icon.\n\nOther files\n\nManifest.json.in: information for the Ubuntu store with application data.\n\nThe IDE has a tab that with the text âDesignâ. This tab analyzes the generated QML code and converts it into the user interface. The tool does not work well and gives errors even if the QML code is valid.\n\nYou can see this on the project screenshot on the words that are marked in red on lines 23, 24 and 25. For this reason, user interface tests will be performed by running the application on the computer.\n\nFile structureÂ¶\n\nAll QML files have a common structure that you will see below. QML allows you to use a number of components that are already defined. This information is passed to the project with the import statement. It is possible to use different versions of the components although it would be normal to choose the latest available version.\n\nimport QtQuick 2.4 import Ubuntu.Components 1.3\n\nMainViewÂ¶\n\nMainView is the root element of the user interface. It automatically adapts to the rotation of the device.\n\nMainView {\n\nThis block of code doesnât need to be modified. It is used internally.\n\n// objectName for functional testing purposes (autopilot-qt5) objectName: \"mainView\" // Note! applicationName needs to match the \"name\" field of the click manifest applicationName: \"calculadora.innerzaurus\"\n\nGrid UnitÂ¶\n\nThe next two statements are responsible for defining the initial size of the screen. An important detail is that the dimensions are not defined in pixels but in some units called gridUnits (gu). The reason to invent new units and not using pixels that already exists is that gridUnits is universal to the different screen sizes and translates. An example will make this clear.\n\nSuppose that we have a device with a resolution of 600 x 800 pixels. If a rectangle is defined with the dimensions 300x800 pixels, will occupy the middle of the screen. Now if you use a device that has a screen resolution of 1080x1920 pixels, the rectangle will not reach the middle of the screen. To avoid this problem, define the dimensions in gu (gridUnit). If the dimensions are defined in gu, internally, the system will calculate those dimensions with the characteristics of the screen. The final result will be that the rectangle always has the same size regardless of the screen resolution.\n\nwidth: units.gu(100) height: units.gu(75)\n\nPage ElementÂ¶\n\nThe Page element defines a view. It is recommended that it be included within a MainView element (our specific case) or an AdaptivePageLayout element. It contains a header with an identifier, title and style that applies to the elements of the header. The style is defined within the StyleHints element.\n\nPage { header: PageHeader { id: pageHeader title: i18n.tr(\"Calculator\") StyleHints { foregroundColor: UbuntuColors.orange backgroundColor: UbuntuColors.porcelain dividerColor: UbuntuColors.slate } }\n\nTo see the user interface that is created it is necessary to click on the Play button. Although you can also try on a physical device I recommend that you work with the desktop. The test process is faster and at first you will use it a lot.\n\nTemplate\n\nIn the default QML file there are several components. To make it easier to learn it will be created from scratch with a more detailed explanation. You have to delete the lines from 28 to 53.\n\nBelow you will see an initial design of the calculator with labels. It will help to introduce the way components works and will get a minimum base to continue with QML.\n\nLabelÂ¶\n\nA label is a component that displays text. Its minimum structure is:\n\nLabel { text: \"Hello World\" }\n\nAdd the following code from line 28. Then run the application on the desktop.\n\nLabel { text: \"Hello World. Look at me, I'm programming in QML\" } Label { text: \"I am another label\" }\n\nNow comment the lines in the header and run the application.\n\nLabel Overlay\n\nThe labels are shown, but the two are overlayed. In one hand there is the definition of the component and on the other hand, its organization. If the header is displayed, the tags do not show and if the header is removed the tags overlap.\n\nExercisesÂ¶\n\nIn the previous chapters you finished the exercises too quickly. In this chapter this will not be the case. The exercises are:\n\nExercise 01. Create three columns one after the other and show the numeric keypad numbers (1, 4, 7, 2, 5, 8, 3, 6, 9; 0).\n\nExercise 02. Distribute keypad numbers as a table by combining columns and rows. The element to create the rows is Row and is used similarly to the element Column. You may use the documentation included in the SDK but you may not search the solution on the Internet. To view the SDK documentation, press the F1 key with a QML component selected."
    }
}