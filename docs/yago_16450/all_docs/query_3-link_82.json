{
    "id": "yago_16450_3",
    "rank": 82,
    "data": {
        "url": "https://laravel.com/docs/11.x/database",
        "read_more_link": "",
        "language": "en",
        "title": "Database: Getting Started",
        "top_image": "https://laravel.com/img/og-image.jpg",
        "meta_img": "https://laravel.com/img/og-image.jpg",
        "images": [
            "https://laravel.com/img/logomark.min.svg",
            "https://laravel.com/img/logotype.min.svg",
            "https://laravel.com/img/logomark.min.svg",
            "https://laravel.com/img/logotype.min.svg",
            "https://laravel.com/img/icons/drop_arrow.min.svg",
            "https://laravel.com/img/icons/drop_arrow.dark.min.svg",
            "https://laravel.com/img/logomark.min.svg",
            "https://laravel.com/img/social/x.dark.min.svg",
            "https://laravel.com/img/social/x.min.svg",
            "https://laravel.com/img/social/github.dark.min.svg",
            "https://laravel.com/img/social/github.min.svg",
            "https://laravel.com/img/social/discord.dark.min.svg",
            "https://laravel.com/img/social/discord.min.svg",
            "https://laravel.com/img/social/youtube.dark.min.svg",
            "https://laravel.com/img/social/youtube.min.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Laravel is a PHP web application framework with expressive, elegant syntax. We’ve already laid the foundation — freeing you to create without sweating the small things.",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon/apple-touch-icon.png",
        "meta_site_name": "",
        "canonical_link": "https://laravel.com/docs/11.x/database",
        "text": "Introduction\n\nConfiguration\n\nRead and Write Connections\n\nRunning SQL Queries\n\nUsing Multiple Database Connections\n\nListening for Query Events\n\nMonitoring Cumulative Query Time\n\nDatabase Transactions\n\nConnecting to the Database CLI\n\nInspecting Your Databases\n\nMonitoring Your Databases\n\nIntroduction\n\nAlmost every modern web application interacts with a database. Laravel makes interacting with databases extremely simple across a variety of supported databases using raw SQL, a fluent query builder, and the Eloquent ORM. Currently, Laravel provides first-party support for five databases:\n\nConfiguration\n\nThe configuration for Laravel's database services is located in your application's config/database.php configuration file. In this file, you may define all of your database connections, as well as specify which connection should be used by default. Most of the configuration options within this file are driven by the values of your application's environment variables. Examples for most of Laravel's supported database systems are provided in this file.\n\nBy default, Laravel's sample environment configuration is ready to use with Laravel Sail, which is a Docker configuration for developing Laravel applications on your local machine. However, you are free to modify your database configuration as needed for your local database.\n\nSQLite Configuration\n\nSQLite databases are contained within a single file on your filesystem. You can create a new SQLite database using the touch command in your terminal: touch database/database.sqlite. After the database has been created, you may easily configure your environment variables to point to this database by placing the absolute path to the database in the DB_DATABASE environment variable:\n\nBy default, foreign key constraints are enabled for SQLite connections. If you would like to disable them, you should set the DB_FOREIGN_KEYS environment variable to false:\n\nMicrosoft SQL Server Configuration\n\nTo use a Microsoft SQL Server database, you should ensure that you have the sqlsrv and pdo_sqlsrv PHP extensions installed as well as any dependencies they may require such as the Microsoft SQL ODBC driver.\n\nConfiguration Using URLs\n\nTypically, database connections are configured using multiple configuration values such as host, database, username, password, etc. Each of these configuration values has its own corresponding environment variable. This means that when configuring your database connection information on a production server, you need to manage several environment variables.\n\nSome managed database providers such as AWS and Heroku provide a single database \"URL\" that contains all of the connection information for the database in a single string. An example database URL may look something like the following:\n\nThese URLs typically follow a standard schema convention:\n\nFor convenience, Laravel supports these URLs as an alternative to configuring your database with multiple configuration options. If the url (or corresponding DB_URL environment variable) configuration option is present, it will be used to extract the database connection and credential information.\n\nRead and Write Connections\n\nSometimes you may wish to use one database connection for SELECT statements, and another for INSERT, UPDATE, and DELETE statements. Laravel makes this a breeze, and the proper connections will always be used whether you are using raw queries, the query builder, or the Eloquent ORM.\n\nTo see how read / write connections should be configured, let's look at this example:\n\n'mysql'=> [\n\n'read'=> [\n\n'host'=> [\n\n'192.168.1.1',\n\n'196.168.1.2',\n\n],\n\n],\n\n'write'=> [\n\n'host'=> [\n\n'196.168.1.3',\n\n],\n\n],\n\n'sticky'=>true,\n\n'database'=>env('DB_DATABASE','laravel'),\n\n'username'=>env('DB_USERNAME','root'),\n\n'password'=>env('DB_PASSWORD',''),\n\n'unix_socket'=>env('DB_SOCKET',''),\n\n'charset'=>env('DB_CHARSET','utf8mb4'),\n\n'collation'=>env('DB_COLLATION','utf8mb4_unicode_ci'),\n\n'prefix'=>'',\n\n'prefix_indexes'=>true,\n\n'strict'=>true,\n\n'engine'=>null,\n\n'options'=>extension_loaded('pdo_mysql') ?array_filter([\n\nPDO::MYSQL_ATTR_SSL_CA => env('MYSQL_ATTR_SSL_CA'),\n\n]) : [],\n\n],\n\nNote that three keys have been added to the configuration array: read, write and sticky. The read and write keys have array values containing a single key: host. The rest of the database options for the read and write connections will be merged from the main mysql configuration array.\n\nYou only need to place items in the read and write arrays if you wish to override the values from the main mysql array. So, in this case, 192.168.1.1 will be used as the host for the \"read\" connection, while 192.168.1.3 will be used for the \"write\" connection. The database credentials, prefix, character set, and all other options in the main mysql array will be shared across both connections. When multiple values exist in the host configuration array, a database host will be randomly chosen for each request.\n\nThe sticky Option\n\nThe sticky option is an optional value that can be used to allow the immediate reading of records that have been written to the database during the current request cycle. If the sticky option is enabled and a \"write\" operation has been performed against the database during the current request cycle, any further \"read\" operations will use the \"write\" connection. This ensures that any data written during the request cycle can be immediately read back from the database during that same request. It is up to you to decide if this is the desired behavior for your application.\n\nRunning SQL Queries\n\nOnce you have configured your database connection, you may run queries using the DB facade. The DB facade provides methods for each type of query: select, update, insert, delete, and statement.\n\nRunning a Select Query\n\nTo run a basic SELECT query, you may use the select method on the DB facade:\n\n<?php\n\nnamespace App\\Http\\Controllers;\n\nuse App\\Http\\Controllers\\Controller;\n\nuse Illuminate\\Support\\Facades\\DB;\n\nuse Illuminate\\View\\View;\n\nclassUserControllerextendsController\n\n{\n\n/**\n\n* Show a list of all of the application's users.\n\n*/\n\npublicfunctionindex():View\n\n{\n\n$users=DB::select('select * from users where active = ?', [1]);\n\nreturnview('user.index',['users'=>$users]);\n\n}\n\n}\n\nThe first argument passed to the select method is the SQL query, while the second argument is any parameter bindings that need to be bound to the query. Typically, these are the values of the where clause constraints. Parameter binding provides protection against SQL injection.\n\nThe select method will always return an array of results. Each result within the array will be a PHP stdClass object representing a record from the database:\n\nuse Illuminate\\Support\\Facades\\DB;\n\n$users=DB::select('select * from users');\n\nforeach ($usersas$user) {\n\necho$user->name;\n\n}\n\nSelecting Scalar Values\n\nSometimes your database query may result in a single, scalar value. Instead of being required to retrieve the query's scalar result from a record object, Laravel allows you to retrieve this value directly using the scalar method:\n\n$burgers=DB::scalar(\n\n\"select count(case when food = 'burger' then 1 end) as burgers from menu\"\n\n);\n\nSelecting Multiple Result Sets\n\nIf your application calls stored procedures that return multiple result sets, you may use the selectResultSets method to retrieve all of the result sets returned by the stored procedure:\n\n[$options, $notifications] =DB::selectResultSets(\n\n\"CALL get_user_options_and_notifications(?)\", $request->user()->id\n\n);\n\nUsing Named Bindings\n\nInstead of using ? to represent your parameter bindings, you may execute a query using named bindings:\n\n$results=DB::select('select * from users where id = :id', ['id'=>1]);\n\nRunning an Insert Statement\n\nTo execute an insert statement, you may use the insert method on the DB facade. Like select, this method accepts the SQL query as its first argument and bindings as its second argument:\n\nuse Illuminate\\Support\\Facades\\DB;\n\nDB::insert('insert into users (id, name) values (?, ?)', [1, 'Marc']);\n\nRunning an Update Statement\n\nThe update method should be used to update existing records in the database. The number of rows affected by the statement is returned by the method:\n\nuse Illuminate\\Support\\Facades\\DB;\n\n$affected=DB::update(\n\n'update users set votes = 100 where name = ?',\n\n['Anita']\n\n);\n\nRunning a Delete Statement\n\nThe delete method should be used to delete records from the database. Like update, the number of rows affected will be returned by the method:\n\nuse Illuminate\\Support\\Facades\\DB;\n\n$deleted=DB::delete('delete from users');\n\nRunning a General Statement\n\nSome database statements do not return any value. For these types of operations, you may use the statement method on the DB facade:\n\nDB::statement('drop table users');\n\nRunning an Unprepared Statement\n\nSometimes you may want to execute an SQL statement without binding any values. You may use the DB facade's unprepared method to accomplish this:\n\nDB::unprepared('update users set votes = 100 where name = \"Dries\"');\n\nImplicit Commits\n\nWhen using the DB facade's statement and unprepared methods within transactions you must be careful to avoid statements that cause implicit commits. These statements will cause the database engine to indirectly commit the entire transaction, leaving Laravel unaware of the database's transaction level. An example of such a statement is creating a database table:\n\nDB::unprepared('create table a (col varchar(1) null)');\n\nPlease refer to the MySQL manual for a list of all statements that trigger implicit commits.\n\nUsing Multiple Database Connections\n\nIf your application defines multiple connections in your config/database.php configuration file, you may access each connection via the connection method provided by the DB facade. The connection name passed to the connection method should correspond to one of the connections listed in your config/database.php configuration file or configured at runtime using the config helper:\n\nuse Illuminate\\Support\\Facades\\DB;\n\n$users=DB::connection('sqlite')->select(/* ... */);\n\nYou may access the raw, underlying PDO instance of a connection using the getPdo method on a connection instance:\n\n$pdo=DB::connection()->getPdo();\n\nListening for Query Events\n\nIf you would like to specify a closure that is invoked for each SQL query executed by your application, you may use the DB facade's listen method. This method can be useful for logging queries or debugging. You may register your query listener closure in the boot method of a service provider:\n\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Database\\Events\\QueryExecuted;\n\nuse Illuminate\\Support\\Facades\\DB;\n\nuse Illuminate\\Support\\ServiceProvider;\n\nclassAppServiceProviderextendsServiceProvider\n\n{\n\n/**\n\n* Register any application services.\n\n*/\n\npublicfunctionregister():void\n\n{\n\n// ...\n\n}\n\n/**\n\n* Bootstrap any application services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\nDB::listen(function(QueryExecuted$query) {\n\n// $query->sql;\n\n// $query->bindings;\n\n// $query->time;\n\n// $query->toRawSql();\n\n});\n\n}\n\n}\n\nMonitoring Cumulative Query Time\n\nA common performance bottleneck of modern web applications is the amount of time they spend querying databases. Thankfully, Laravel can invoke a closure or callback of your choice when it spends too much time querying the database during a single request. To get started, provide a query time threshold (in milliseconds) and closure to the whenQueryingForLongerThan method. You may invoke this method in the boot method of a service provider:\n\n<?php\n\nnamespace App\\Providers;\n\nuse Illuminate\\Database\\Connection;\n\nuse Illuminate\\Support\\Facades\\DB;\n\nuse Illuminate\\Support\\ServiceProvider;\n\nuse Illuminate\\Database\\Events\\QueryExecuted;\n\nclassAppServiceProviderextendsServiceProvider\n\n{\n\n/**\n\n* Register any application services.\n\n*/\n\npublicfunctionregister():void\n\n{\n\n// ...\n\n}\n\n/**\n\n* Bootstrap any application services.\n\n*/\n\npublicfunctionboot():void\n\n{\n\nDB::whenQueryingForLongerThan(500, function(Connection$connection, QueryExecuted$event) {\n\n// Notify development team...\n\n});\n\n}\n\n}\n\nDatabase Transactions\n\nYou may use the transaction method provided by the DB facade to run a set of operations within a database transaction. If an exception is thrown within the transaction closure, the transaction will automatically be rolled back and the exception is re-thrown. If the closure executes successfully, the transaction will automatically be committed. You don't need to worry about manually rolling back or committing while using the transaction method:\n\nuse Illuminate\\Support\\Facades\\DB;\n\nDB::transaction(function() {\n\nDB::update('update users set votes = 1');\n\nDB::delete('delete from posts');\n\n});\n\nHandling Deadlocks\n\nThe transaction method accepts an optional second argument which defines the number of times a transaction should be retried when a deadlock occurs. Once these attempts have been exhausted, an exception will be thrown:\n\nuse Illuminate\\Support\\Facades\\DB;\n\nDB::transaction(function() {\n\nDB::update('update users set votes = 1');\n\nDB::delete('delete from posts');\n\n}, 5);\n\nManually Using Transactions\n\nIf you would like to begin a transaction manually and have complete control over rollbacks and commits, you may use the beginTransaction method provided by the DB facade:\n\nuse Illuminate\\Support\\Facades\\DB;\n\nDB::beginTransaction();\n\nYou can rollback the transaction via the rollBack method:\n\nDB::rollBack();\n\nLastly, you can commit a transaction via the commit method:\n\nDB::commit();\n\nConnecting to the Database CLI\n\nIf you would like to connect to your database's CLI, you may use the db Artisan command:\n\nIf needed, you may specify a database connection name to connect to a database connection that is not the default connection:\n\nInspecting Your Databases\n\nUsing the db:show and db:table Artisan commands, you can get valuable insight into your database and its associated tables. To see an overview of your database, including its size, type, number of open connections, and a summary of its tables, you may use the db:show command:\n\nYou may specify which database connection should be inspected by providing the database connection name to the command via the --database option:\n\nIf you would like to include table row counts and database view details within the output of the command, you may provide the --counts and --views options, respectively. On large databases, retrieving row counts and view details can be slow:\n\nIn addition, you may use the following Schema methods to inspect your database:\n\nuse Illuminate\\Support\\Facades\\Schema;\n\n$tables=Schema::getTables();\n\n$views=Schema::getViews();\n\n$columns=Schema::getColumns('users');\n\n$indexes=Schema::getIndexes('users');\n\n$foreignKeys=Schema::getForeignKeys('users');\n\nIf you would like to inspect a database connection that is not your application's default connection, you may use the connection method:\n\n$columns=Schema::connection('sqlite')->getColumns('users');\n\nTable Overview\n\nIf you would like to get an overview of an individual table within your database, you may execute the db:table Artisan command. This command provides a general overview of a database table, including its columns, types, attributes, keys, and indexes:\n\nMonitoring Your Databases\n\nUsing the db:monitor Artisan command, you can instruct Laravel to dispatch an Illuminate\\Database\\Events\\DatabaseBusy event if your database is managing more than a specified number of open connections.\n\nTo get started, you should schedule the db:monitor command to run every minute. The command accepts the names of the database connection configurations that you wish to monitor as well as the maximum number of open connections that should be tolerated before dispatching an event:"
    }
}