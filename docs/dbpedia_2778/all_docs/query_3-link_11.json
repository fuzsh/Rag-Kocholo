{
    "id": "dbpedia_2778_3",
    "rank": 11,
    "data": {
        "url": "https://seaborn.pydata.org/generated/seaborn.kdeplot.html",
        "read_more_link": "",
        "language": "en",
        "title": "seaborn.kdeplot — seaborn 0.13.2 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://seaborn.pydata.org/_static/logo-wide-lightbg.svg",
            "https://seaborn.pydata.org/_static/logo-wide-lightbg.svg",
            "https://seaborn.pydata.org/_images/kdeplot_1_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_3_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_5_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_7_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_9_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_11_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_13_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_15_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_17_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_19_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_21_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_23_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_25_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_27_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_29_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_31_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_33_0.png",
            "https://seaborn.pydata.org/_images/kdeplot_35_0.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../_static/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Plot univariate or bivariate distributions using kernel density estimation.\n\nA kernel density estimate (KDE) plot is a method for visualizing the distribution of observations in a dataset, analogous to a histogram. KDE represents the data using a continuous probability density curve in one or more dimensions.\n\nThe approach is explained further in the user guide.\n\nRelative to a histogram, KDE can produce a plot that is less cluttered and more interpretable, especially when drawing multiple distributions. But it has the potential to introduce distortions if the underlying distribution is bounded or not smooth. Like a histogram, the quality of the representation also depends on the selection of good smoothing parameters.\n\nParameters:\n\ndatapandas.DataFrame, numpy.ndarray, mapping, or sequence\n\nInput data structure. Either a long-form collection of vectors that can be assigned to named variables or a wide-form dataset that will be internally reshaped.\n\nx, yvectors or keys in data\n\nVariables that specify positions on the x and y axes.\n\nhuevector or key in data\n\nSemantic variable that is mapped to determine the color of plot elements.\n\nweightsvector or key in data\n\nIf provided, weight the kernel density estimation using these values.\n\npalettestring, list, dict, or matplotlib.colors.Colormap\n\nMethod for choosing the colors to use when mapping the hue semantic. String values are passed to color_palette(). List or dict values imply categorical mapping, while a colormap object implies numeric mapping.\n\nhue_ordervector of strings\n\nSpecify the order of processing and plotting for categorical levels of the hue semantic.\n\nhue_normtuple or matplotlib.colors.Normalize\n\nEither a pair of values that set the normalization range in data units or an object that will map from data units into a [0, 1] interval. Usage implies numeric mapping.\n\ncolormatplotlib color\n\nSingle color specification for when hue mapping is not used. Otherwise, the plot will try to hook into the matplotlib property cycle.\n\nfillbool or None\n\nIf True, fill in the area under univariate density curves or between bivariate contours. If None, the default depends on multiple.\n\nmultiple{{“layer”, “stack”, “fill”}}\n\nMethod for drawing multiple elements when semantic mapping creates subsets. Only relevant with univariate data.\n\ncommon_normbool\n\nIf True, scale each conditional density by the number of observations such that the total area under all densities sums to 1. Otherwise, normalize each density independently.\n\ncommon_gridbool\n\nIf True, use the same evaluation grid for each kernel density estimate. Only relevant with univariate data.\n\ncumulativebool, optional\n\nIf True, estimate a cumulative distribution function. Requires scipy.\n\nbw_methodstring, scalar, or callable, optional\n\nMethod for determining the smoothing bandwidth to use; passed to scipy.stats.gaussian_kde.\n\nbw_adjustnumber, optional\n\nFactor that multiplicatively scales the value chosen using bw_method. Increasing will make the curve smoother. See Notes.\n\nwarn_singularbool\n\nIf True, issue a warning when trying to estimate the density of data with zero variance.\n\nlog_scalebool or number, or pair of bools or numbers\n\nSet axis scale(s) to log. A single value sets the data axis for any numeric axes in the plot. A pair of values sets each axis independently. Numeric values are interpreted as the desired base (default 10). When None or False, seaborn defers to the existing Axes scale.\n\nlevelsint or vector\n\nNumber of contour levels or values to draw contours at. A vector argument must have increasing values in [0, 1]. Levels correspond to iso-proportions of the density: e.g., 20% of the probability mass will lie below the contour drawn for 0.2. Only relevant with bivariate data.\n\nthreshnumber in [0, 1]\n\nLowest iso-proportion level at which to draw a contour line. Ignored when levels is a vector. Only relevant with bivariate data.\n\ngridsizeint\n\nNumber of points on each dimension of the evaluation grid.\n\ncutnumber, optional\n\nFactor, multiplied by the smoothing bandwidth, that determines how far the evaluation grid extends past the extreme datapoints. When set to 0, truncate the curve at the data limits.\n\nclippair of numbers or None, or a pair of such pairs\n\nDo not evaluate the density outside of these limits.\n\nlegendbool\n\nIf False, suppress the legend for semantic variables.\n\ncbarbool\n\nIf True, add a colorbar to annotate the color mapping in a bivariate plot. Note: Does not currently support plots with a hue variable well.\n\ncbar_axmatplotlib.axes.Axes\n\nPre-existing axes for the colorbar.\n\ncbar_kwsdict\n\nAdditional parameters passed to matplotlib.figure.Figure.colorbar().\n\naxmatplotlib.axes.Axes\n\nPre-existing axes for the plot. Otherwise, call matplotlib.pyplot.gca() internally.\n\nkwargs\n\nOther keyword arguments are passed to one of the following matplotlib functions:\n\nmatplotlib.axes.Axes.plot() (univariate, fill=False),\n\nmatplotlib.axes.Axes.fill_between() (univariate, fill=True),\n\nmatplotlib.axes.Axes.contour() (bivariate, fill=False),\n\nmatplotlib.axes.contourf() (bivariate, fill=True).\n\nReturns:\n\nmatplotlib.axes.Axes\n\nThe matplotlib axes containing the plot.\n\nNotes\n\nThe bandwidth, or standard deviation of the smoothing kernel, is an important parameter. Misspecification of the bandwidth can produce a distorted representation of the data. Much like the choice of bin width in a histogram, an over-smoothed curve can erase true features of a distribution, while an under-smoothed curve can create false features out of random variability. The rule-of-thumb that sets the default bandwidth works best when the true distribution is smooth, unimodal, and roughly bell-shaped. It is always a good idea to check the default behavior by using bw_adjust to increase or decrease the amount of smoothing.\n\nBecause the smoothing algorithm uses a Gaussian kernel, the estimated density curve can extend to values that do not make sense for a particular dataset. For example, the curve may be drawn over negative values when smoothing data that are naturally positive. The cut and clip parameters can be used to control the extent of the curve, but datasets that have many observations close to a natural boundary may be better served by a different visualization method.\n\nSimilar considerations apply when a dataset is naturally discrete or “spiky” (containing many repeated observations of the same value). Kernel density estimation will always produce a smooth curve, which would be misleading in these situations.\n\nThe units on the density axis are a common source of confusion. While kernel density estimation produces a probability distribution, the height of the curve at each point gives a density, not a probability. A probability can be obtained only by integrating the density across a range. The curve is normalized so that the integral over all possible values is 1, meaning that the scale of the density axis depends on the data values.\n\nExamples\n\nPlot a univariate distribution along the x axis:\n\nFlip the plot by assigning the data variable to the y axis:\n\nPlot distributions for each column of a wide-form dataset:\n\nUse less smoothing:\n\nUse more smoothing, but don’t smooth past the extreme data points:\n\nPlot conditional distributions with hue mapping of a second variable:\n\n“Stack” the conditional distributions:\n\nNormalize the stacked distribution at each value in the grid:\n\nEstimate the cumulative distribution function(s), normalizing each subset:\n\nEstimate distribution from aggregated data, using weights:\n\nMap the data variable with log scaling:\n\nUse numeric hue mapping:\n\nModify the appearance of the plot:\n\nPlot a bivariate distribution:\n\nMap a third variable with a hue semantic to show conditional distributions:\n\nShow filled contours:\n\nShow fewer contour levels, covering less of the distribution:\n\nFill the axes extent with a smooth distribution, using a different colormap:"
    }
}