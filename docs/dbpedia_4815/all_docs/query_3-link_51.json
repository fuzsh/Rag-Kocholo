{
    "id": "dbpedia_4815_3",
    "rank": 51,
    "data": {
        "url": "https://dl.acm.org/doi/fullHtml/10.1145/3402942.3402979",
        "read_more_link": "",
        "language": "en",
        "title": "A Diagnostic Taxonomy of Failure in Videogames",
        "top_image": "https://dl.acm.org/cms/attachment/68bee59b-722e-4d57-967e-29016e4713f7/fdg20-37-fig1.jpg",
        "meta_img": "",
        "images": [
            "https://dl.acm.org/cms/attachment/68bee59b-722e-4d57-967e-29016e4713f7/fdg20-37-fig1.jpg",
            "https://dl.acm.org/cms/attachment/086a2eaa-9255-4890-b343-f7987e442ef1/fdg20-37-fig2.jpg",
            "https://dl.acm.org/cms/attachment/498f6ab6-792e-4f3b-b0c1-3e4e9b86accf/fdg20-37-fig3.jpg",
            "https://dl.acm.org/cms/attachment/46de1354-09bf-47dc-b073-dc8e52c128b2/fdg20-37-fig4.jpg",
            "https://dl.acm.org/cms/attachment/08b07605-2bb6-49b7-a583-39c97c24b4b1/fdg20-37-fig5.jpg",
            "https://dl.acm.org/cms/attachment/caac5e0d-d763-49f0-8e41-c52e98098d52/fdg20-37-fig6.jpg",
            "https://dl.acm.org/cms/attachment/c08ef9bd-fb5e-4ccc-a639-059153c14d99/fdg20-37-fig7.jpg",
            "https://dl.acm.org/cms/attachment/cda2d838-b6c6-4f00-9a6e-a37f8dd35f44/fdg20-37-fig8.jpg",
            "https://dl.acm.org/cms/attachment/fef029a4-4778-4b97-bdd3-babed5e88007/fdg20-37-fig9.jpg",
            "https://dl.acm.org/cms/attachment/940b9b1c-ace2-4352-ab1d-03bb0999491b/fdg20-37-fig10.jpg",
            "https://dl.acm.org/cms/attachment/532e2e74-2cc6-44f5-a7aa-728c3aa8279f/fdg20-37-fig11.jpg",
            "https://dl.acm.org/cms/attachment/7c29b59b-85e8-4d98-85ed-3daf32cd70ae/fdg20-37-fig12.jpg",
            "https://dl.acm.org/doi/fullHtml/10.1145/images/cc-by.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Batu Aytemiz",
            "baytemiz@ucsc.edu",
            "Adam M. Smith",
            "United States",
            "amsmith@ucsc.edu",
            "Keywords: Failure",
            "Game Design",
            "Game Development"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "1 INTRODUCTION\n\nFailure in videogames is not desirable. A cursory look at several beloved videogames is enough to challenge the previous blanket statement. From popular cult classics such as the Dark Souls [12] franchise to the intentionally difficult and frustrating games such as QWOP [21] and Getting Over It [22], many videogames are known to explicitly invite failure. These games are enjoyed, even cherished, by many who play them [2, 8]. When players fail in these challenging games, the failures are seen not as a problem [52], but rather as a part of the game loop [50]. However, not every failure is met with such enthusiasm, nor is every type of failure healthy [4, 48]. If a player is failing because the on-screen text is too small for them to read, or because they do not know the controls then there is a problem—no one is excited to face these types of challenges. So, if some failures are welcome, whereas some are unwanted, and if some failures are opportunities to grow, whereas others make players feel helpless, how do we know, articulate, and communicate these differences? In this paper, we contribute a diagnostic taxonomy (visualized in Fig. 1) to aid in answering these questions.\n\nPlayers can fail in a variety of different ways while playing games. Failure can be part of a game and might even be expected to occur naturally in the span of a gameplay session. Failure might also be undesirable and necessitate a response from either the game itself, in the form of a helping action, or from the game designer, in the form of a design change. For example, in an analytical game such as chess, we expect most of the exciting challenge of the game to revolve around the failure to form effective plans (and counter plans or counter-counter plans). If a player is failing because they made an ineffectual plan, this is par for the course and does not require a response from neither the game system itself nor from the game designer. However, if the players are constantly failing because the chess pieces are hard to grasp and keep slipping from their hands then this asks for a better-designed chess set, as moving the chess pieces around should not be where the challenge of chess lies. In the former failure case, the player failed because they didn't plan their moves correctly, which matches the presumed design intent of chess. However, if the player fails at handling the chess pieces this requires an intervention as this type of failure (dropping the pieces) does not match the presumed design intent of chess.\n\nLet us look at another example: Jenga [49]. Jenga is a game of physical skill in which players take turns removing one block at a time from a tower constructed of 54 wooden blocks. Each block removed is then placed on top of the tower, creating a progressively taller and more unstable structure. In a game of Jenga, in addition to your strategy of deciding which blocks to move, your ability to physically manipulate the blocks also matters—maybe even more so! Contrary to chess, dropping a game piece while performing an action is acceptable because the failure in removing the block by dropping it - after having decided which block to move - matches what we imagine to be the design intent of Jenga.\n\nIn chess, after having made a plan (deciding which piece to move), the act of executing that plan should be seamless and should not pose any chance of failure, as it would detract from the play experience. Whereas in Jenga, after having made a plan (deciding which piece to remove), you can still fail at the act of executing that plan, and that failure would not be jarring to the overall experience at all, as it is part of the expected gameloop.\n\nIn our Jenga and chess examples, we outlined two similar types of failures (failures that occur when physically handling a game piece) and described how the consequences of those failures on the play experiences can be wildly different. This is why we need to have terms to clearly differentiate the types of failures we want from the types of failures we would rather avoid. In this paper, we designate the failures that support the design intent of a game as in-loop failures (referring to the ideas of a game loop). The existence of in-loop failures is not detrimental to the enjoyment of the game, and in many cases, this type of failure is the main component that makes the game challenging and engaging. On the other hand, out-of-loop failures represents the unintentional (from the designer's side) failures that detract from the vision of the game and should therefore be minimized. To use our earlier example, dropping the chess piece would be an out-of-loop failure whereas dropping the Jenga block (and the tower with it!) would be an in-loop failure, even though they are both execution failures. In Jenga, physical manipulation is a part of the intended challenge, whereas in chess physical manipulation of the pieces is definitely not a part of the intended challenge.\n\nIn the context of videogames and this paper, we use the term “failure“ to describe the inability to make progress towards the objective (or goal) suggested by the game. It is important to note that just because the game is suggesting an objective, it does not mean the players are going to play the game to accomplish that goal. However, having this terminology will still help designers hone in on what the game is trying to accomplish and if appropriate (such as when discussing creative sand-box games or transgressive play [5]) can be extended to include player-set goals.\n\nCurrently, the videogame industry lacks any specific vocabulary to describe the differences pertaining to failures that occur in videogames. This gap makes it difficult to communicate which types of failures are desirable and which should be avoided, especially because communication is one of the problems game development teams often face [45]. Our paper proposes a taxonomy of failures to facilitate this differentiation and increase specificity in communication. If we have a vocabulary that allows us to describe how we, as game designers, are making our players fail, we can investigate whether these failure instances match our design intent. We propose this Taxonomy of Failure as a tool to help designers, critics, analysts, educators, and scholars be more precise in their discussions of failures in videogames.\n\nWe envision this taxonomy being used to:\n\ndescribe what categories of failures are in-loop and which are out-of-loop in the games we design, and\n\nclassify different instances of failures to better understand which are problematic and should be reduced, and which are essential and should be fostered.\n\n2 RELATED WORK\n\nFailure is an inherent component of games. In many cases, it is tailored to be a big part of the whole experience — to the extent that McGonigal [40] claims players spend a significant amount of their time failing. As such, the importance of failure has been a part of the discourse surrounding games from several different angles. Juul [33] investigates whether the presence of failure affects the enjoyment derived from playing videogames and concludes that players create elaborate theories of failure as a source of enjoyment. Further, in The Art of Failure, Juul [34] discusses the aesthetics of failure and argues that it is a crucial aspect of what makes a game a game. Building on this foundation by Juul, Roche describes the notion of “valid” failure[47], investigating the cases where the game recognizes, either from a gameplay or a narrative perspective, that the player has failed.\n\nAnother concept tightly related to failure is challenge. Adams, in Fundamentals of Game Design provides two broad categories of challenges: cognitive and physical [6]. Thinking about what the challenge facing the player should be is another way to conceptualize and differentiate in-loop from out-of-loop failures. However, it is important to note that these gameplay categorizations of challenge still struggles with measuring difficulty [7] and does not cover all the different ways a player can fail. Shifting our attention from challenge to failure allows us to engage our users on the users’ terms, by exploring how the challenges we design are received by our players.\n\nIn Uncertainty in Games, Costikyan [16] discusses another aspect crucial to failure: uncertainty. This discussion provides another perspective to describe in-loop and out-of-loop failures. If the player expects high uncertainty in their actions, blunders resulting from those specific moves are in-loop failures because the player acknowledges the likelihood of failing. Out-of-loop failures are those in which the player does not expect uncertainty. They do not foresee a potential of failure, and they are jarred if failure does occur. This lens can be another way to reason about how in-loop and out-of-loop failures affect the play experience.\n\nAnother angle to investigate failure is the aspect of learning and mastery. Gee [25] describes good videogames as learning machines and explains that failing and trying again makes failure central to learning and a part of the fun. Similarly, in The Art of Computer Game Design [17] Crawford, and in A Theory of Fun for Game Design [38], Koster, argues that fun, learning, and failing are intricately connected. In their work exploring failures and breakthroughs [31] Iacovides et al. discuss relationships between learning and in game involvement. Learning and failure have been connected to one another in other domains as well. Kapur introduces the concept of productive failures [36] and shows the effectiveness and how to design for them [37]. Productive failures are the notion of allowing people to fail while attempting to solve complex problems. This kind of failure facilitates the understanding of the problem at hand. It is easy to see the similarities between the good game design argued by Gee and Koster, and the notion of productive failures introduced by Kapur. Anderson digs into this connection by investigating how failure in games promotes learning [10], and Kllevig investigates whether the game can play a role in changing a person's relationship to failure [35]. Desirable difficulty [14] is another theory that puts emphasis on understanding how people fail and —through the failure and difficulty— learn. Desirable difficulty is concerned with matching the learner with the correct difficulty and challenge. In all these cases having a more precise language to specify and identify different types of failures would help the clarity and communication of the ideas.\n\nWhile the idea of learning is deemed to be important when it comes to enjoying games, the tutorial levels meant to teach players how to play usually leave some things to be desired—even though they have a significant effect on the rest of the game [9]. It is common for players to complain about the overprotective and cautious nature of some in-game tutorials, especially complaining about how the tutorial robs the player of a sense of discovery [46, 59] There has been some work in creating context-aware tutorials [11] and adjusting the game difficulty to fit the player [29] but there is still room for improvement. A taxonomy of failure can allow designers to decide when to provide tutorials and where to let the player explore, which is essential in allowing games to keep the sense of discovery and learning.\n\nAnother important benefit of being able to specify different types of failure is related to accessibility in games. There have been improvements when it comes to game accessibility [24] and there are many resources that educate game designers on how to make games more accessible such as the extensive Game Accessibility Guidelines [4]. There are still, however, many open research questions in this area. Being able to classify failures will surface cases where the players are failing due to accessibility issues. Classifying failures can also contribute to making games more accessible. Another use for the taxonomy is Universal Design [53], a design approach that prioritizes removing barriers to engagement with experiences. A taxonomy of failure can allow the designers to be more precise in deciding which failures act as barriers to enjoyment (and so should be removed) and which failures are essential for the game experiences (and so should be preserved).\n\n3 TAXONOMY OF FAILURE\n\nIn order to classify where people can fail while playing videogames we propose a specific model of how people play videogames (shown in Fig. 2). Our model is inspired by and builds upon Swink's feedback loops [55], Sellers interactive loop [51] and Don Norman's conceptual models [44], and is adjusted to make delineating failure classes more straightforward.\n\nBuilding upon the aforementioned work, we claim that players have a model of the game even before interacting with the game, created by their cultural knowledge, previous game experiences, and the aesthetic and representational aspects that the game is presenting [30]. The model consists of players understanding of the mechanics of the game (what they can do in the game) and the goals communicated by the game (what they should do in the game). Players then use this model to form a plan that can be arbitrarily short or long, in an attempt to achieve the goals they have set for themselves. Finally, the players attempt to execute this plan. Regardless of whether the plan is successful or not, the feedback from the game allows the player to update their mental model of the game and form a new plan.\n\nHowever, in order to even engage in this model–plan–execute–update loop, the players need to be able to encode their inputs to the system and decode the outputs that are coming out of the game. Encoding input refers to the ability of the player to engage with the game on the most elementary level, whether it is through pressing the correct buttons, knowing which gestures to make on a touch screen, or being able to voice the correct verbal commands, etc. Decoding output in this context refers to the ability of the player to parse and understand the feedback of the game, whether it be visual, aural, tactile or otherwise.\n\nThe steps described in our model of how a player engages with a videogame also represent the different classes of failures—points in our model where a failure can occur.\n\n3.1 Encoding Input → What physical action will allow me to act in the game?\n\nBefore one can truly start playing a game they need to be able to interact with the game system itself. This class refers to the players’ knowledge of the control scheme and the physical capability of using it. Is the player aware of the correct buttons to press, the right gestures to make, or in general, the valid set of actions they can take to interact with the system? More importantly, is the player physically capable of taking those actions?\n\nIn-loop encoding input failure can arise in puzzle boxes or escape rooms, where the challenge lies in actually figuring out the specific actions to get a response from the system or the correct physical components to push and pull.\n\nIt is much more common, however, for failures in the encoding input class to be out-of-loop. A simple example would be the player not knowing which buttons actually are to the game. A more serious encoding input failure is when a player can not use a functionality due to a physical limitation. A recent example is when a player with a physical disability loses the ability to play Civilization due to a change in the user interface [3].\n\n3.2 Decoding Output → Can I parse the feedback of the game?\n\nIn addition to the ability of saying thins to the game one must also understand what the game is saying in return. Decoding output refers to the player's ability to understand the information presented by the game, whether it be visual, aural, tactile or through any other medium that the game is using.\n\nGames that use decoding output as an in-loop class would be spot-the-difference or hidden object games where the challenge lies in parsing a generally complicated scene, a game where the player is trying to find differences between two images/sounds or games where part of the challenge lies in overcoming the chaotic visuals[15]. Any game where the challenge lies purely in perception can be considered to have decoding output as an in-loop class.\n\nMany out-of-loop examples in the decoding output class fall under accessibility issues: If the player can not differentiate enemies from allies due to their colorblindness [26] and the game's color scheme this is a decoding output failure. Further examples would include not being able to read text on screen because of it being too small [23], or not being able to understand the natural language that conveys crucial information about the game.\n\nEncoding Input and Decoding Output groups cover the fundamental requirements for any player to give input to the system and receive clear feedback as an output. Only after a baseline proficiency in these two classes are established can the player start engaging with the game productively. It is important to note that many failures in these two classes stem from accessibility issues and it is crucial for game designers to be aware of these cases.\n\n3.3 Discovering Mechanics → Do I know what I can do in the game?\n\nThis class of failure refers to the player's understanding of the game's mechanics and the set of available verbs offered to the player. In other words, does the player know the capabilities of the tools that they are given?\n\nIf the game is about figuring out how different mechanics relate to one another and finding creative ways of solving problems through emergent methods , that game is using discovering mechanics as an in-loop-failure class. The joy in playing the game comes from learning what the tools are, making the discovery of what the mechanics are is part of the fun.\n\nOn the other hand if the players progression is halted because they could not figure out how a specific lock-and-key style mechanic functions—whether it be not realizing that bombs can blow open cracked walls, or the specifics of how levers and pressure plates work in many adventure games (and the challenge lies in figuring out where you should place the bombs and the order of pulling the levers, instead of figuring out whether you can do those things)—then it is an out-of-loop failure in the discovering mechanics class. Another example would be the player repeatedly getting defeated by a specific type of enemy because they didn't realize that a specific tool in their toolkit deals more damage to that type of target. If the joy in the game is purely about mastery over the mechanics, and not in uncovering what the mechanics are, then discovering mechanics is an out-of-loop failure.\n\nTo be more concrete, in rhythm based games such as Guitar Hero [27] or Tap Tap Revenge [56], the available set of verbs is simple and should be well communicated, and the joy in the game emerges from getting better at those verbs, not figuring out what the verbs are. Whereas in Legend of Zelda, Breath of the Wild [43] understanding how different systems of weather, conductivity, and temperature relate to another would make discovering mechanics an in-loop class for that game.\n\nThis topic also comes up in design discussions that happen in the game industry. In the Noclip Podcast the game director of Doom Eternal[32], Hugo Martin, describes why deciding whether to make game mechanics easy to discover or not is important[1]:\n\n[Doom Eternal gets really] heavy-handed on the player education stuff, because we do not want to make learning [mechanics] part of the experience. As you know in Sekiro, a lot of the [mechanics] are there to be discovered and that's a huge part of the experience. For us, I want to make it clear as day. The fun of the game is not figuring [mechanics] out, the fun of the game is mastering it.\n\n3.4 Setting Goals → Do I know what I should accomplish in the game?\n\nAny moment a confused player asks “What am I trying to do here?” is a failure instance belonging to the setting goals class. The setting the goal class refers to the moments when the player does not know what to do to make effective progress in the game, or what progress even means. In other words, as long as the player is clear on what their goal is, the failure is not a setting goal failure.\n\nIn many open world games figuring out where to go next and who to talk to in order to move the story further is a part of the challenge and enjoyment. In these cases it is acceptable for the player to not know exactly what the proper next step is. The challenge and fun comes from discovering what comes next as well as exploring the space of possible goals. In other games, there are several ways to achieve victory, from conquering the world by force to becoming a diplomatic mastermind. In these games deciding which objective to pursue, and sometimes prioritizing, is fun and, as such, setting goals is an in-loop failure class as well.\n\nIn many games however the designers want their players to always know what their next objective is. If at any point the player is questioning what they should do next and if this questioning is not a part of the game's design, then failures stemming from this confusion are out-of-loop setting goal failures. This is a prominent issue with confusing quest texts and cases where a non-player character shares what the player should do next without recording that information anywhere permanent.\n\nWhen the player does not know where to go and what to do next in open world survival games, such as Subnautica [58], it is not a problem, since the design of the game affords wandering around and setting goals through the experience of spending time in the space. Whereas if a player does not know thatf the goal of Super Meat Boy [57], an action-packed platformer, is to reach the end of the level, then this is an out-of-loop failure! In Super Meat Boy the goal should be abundantly clear and the challenge should not come from the player understanding what the goal of the level is, but rather, the process to reach that goal.\n\nThe Discovering Mechanics and Setting Goals classes together represent a large portion of the mental model that the player uses to play the game. Players create this model before even playing the game, and through the experience of playing the game, this model is constantly updated. The player continually learns and improves their understanding of what is possible in the game and what they should do next, by forming plans, attempting to execute those plans, and updating their model based on the result of their actions.\n\n3.5 Planning → What steps should I take to accomplish my goals?\n\nPlanning is the player using their mental model of the game to decide what they will do next, given the goals they have and their awareness of the game's mechanics. A plan might span just the next few actions if the game is a twitchy reflex game, or a plan might be an elaborate battle strategy in a complex turn-based grand strategy game. Failures that fall into this class include the failures that arise from making an ineffectual plan and the failures at simply making a plan.\n\nIn many slow-paced turn-based games most of the fun arises in the plans the player generates: Which piece to play in chess, which position to move a soldier next in a turn-based tactics games or which route to take to the next level in a strategy game. Any failure that arises from making the wrong plan would be an in-loop planning failure.\n\nIf a game is designed to be purely about fast reaction times, or repeated executions and the player finds themselves making longer term plans (and failing at them) this would be an example of an out-of-loop failure. To be more concrete, imagine a game where the designer's intent is to have levels that can be progressed with any loadout that the player chooses. If there exists a scenario that a player is left unable to progress due to picking the wrong loadout (a long term plan they made at the start of the level) then this does not match the outlined design intent of the game. This hypothetical scenario is an example of how the Taxonomy of Failure could be used to validate and maintain the design intentions of a game while designing its experience.\n\n3.6 Execution → Was I successful in taking the steps in my plan?\n\nExecution is the ability to implement the plan formed by the player. There is a failure in this class whenever a player flops and does not succeed in something they had planned to do.\n\nAny game where dexterity is intended to play a role most likely has execution as an in-loop failure class. Whenever the player misses the next platform by a pixel because they jumped one moment too late, or they could not play the correct notes to the beat, or they parry one moment to soon and lose their last life, they are experiencing and in-loop execution failure.\n\nIf the game is not testing the players ability to execute those plans and instead tests the formation of plans, any failure in execution would be an out-of-loop failure. If a player miss-clicks and sends their armies to the wrong tile on a hex-based strategy game, if a player clicks on the wrong verb in an interactive narrative or if a player is forced to play a chess piece touched by accident due to the touch-move rule and as a result loses the game, they suffered an out-of-loop execution failure.\n\nIt is important to discuss the difference between failures in execution versus failures in encoding input as they might seem similar. The encoding input class refers to the players knowledge about the means in which they can act in the game. Does the player know what actions to take to act in the game and are they generally physically capable of taking those actions? Whereas Execution refers to their moment to moment success in taking those actions in the correct time and order. The ability to press a button does not directly correlate to one's accuracy of pressing it at the right time - an example of execution failure. However if you have a physical limitation that prohibits you from comfortably pressing the button at all then that is an encoding input failure.\n\nIn this section we have described the six categories of failure that exist in the Taxonomy of Failure:\n\nEncoding Input: What physical action will allow me to act in the game?\n\nDecoding Output: Can I parse the feedback of the game?\n\nDiscovering Mechanics: Do I know what I can do in the game?\n\nSetting Goals: Do I know what I should accomplish in the game?\n\nPlanning: What steps should I take to accomplish my goals?\n\nExecution: Was I successful in taking the steps in my plan?\n\n4 CLASSIFYING GAMES\n\nWhy is this classification useful? One way we can use the Taxonomy of Failure is to classify games by designating which of the classes of failures are in-loop and which classes of failures are out-of-loop. This classification allows us to look at games we are interested in through another perspective, complementing other ways of understanding games.\n\nIf we are in the process of designing a videogame then we can use the taxonomy to act as a map in describing where we want the challenge to exist. This description can be helpful in evaluating the design decisions we come across as the development process continues by ensuring failures happen in the in-loop classes, and failures in the out-of-loop classes are minimized.\n\nAdditionally, the Taxonomy of Failure might prove useful is when we are trying to understand games that already exist. After classifying the games that interest us, we can look at how these games actually guide their players away from out-of-loop failures and towards in-loop failures.\n\nAltough we believe the taxonomy to be useful, it is important to be aware of the limitations. An overemphasis on using the taxonomy during the initial phases of design might pigeon hole the game into a certain idea, and might cause interesting insights to slip by. It is important to be flexible and try to truly understand what makes the game fun! If you observe that your players are enjoying failing in categories you designated as out-of-loop failures then it might be valuable to reevaluate your initial classifications.\n\n4.1 Super Mario Bros\n\nLet us look at this process through a few examples. We start with Super Mario Bros [42] (referred to as SMB from here on out). We claim SMB is a game about mastering how to move in a world filled with spikes, piranha plants and hazardous landscapes. Given this observation, the in-loop classes are planning and execution and any failure outside of those two classes are out-of-loop failures.\n\nWe can start by digging into the in-loop failure classes of SMB. What is the main challenge in SMB? First, the player needs to decide which path to take through the obstacles. Is the player going to jump on the goombas, or will they try to dodge them by running on the platforms above? There are many paths in the game that are viable, but there are also many which lead to certain doom. If the player takes a leap of faith and, after falling into the pit, realizes that jumping is not possible, it is not a big problem. They will just take the other route the next time. They conducted a plan to make the jump and executed the plan but the plan was flawed. Thus the player failed, but this sequence was not problematic because planning in SMB is an in-loop failure class. (shown in Fig. 3)\n\nAfter making a plan in SMB, the player actually has to be able to implement that plan. It is one thing to think, “I am going to jump over the goomba, dodge the fireball, and vault over the piranha plant” and another to actually be able to do it! Either way though, if the player is not successful in their execution, they can always try again and no player is expected to successfully execute their plans on their first try, or with have a 100% success rate. When Mario dies there is a relatively short respawn time, and this supports our analysis that players are indeed expected to die several times in each gameplay session. These factors make execution also an in-loop failure class.\n\nNow, we can also look at the out-of-loop classes and see how games attempt to steer the players from failing at those classes. Let us start by investigating the encoding input class. When we actually look at the hardware design, we see that the Nintendo Entertainment System controller (Fig. 4) has very few buttons, so just by looking at the controller the player can gauge how to give input to the system. Consider playing SMB on an emulator on a modern computer. If the player does not know which of the myriad keyboard buttons actually map to the initial NES controller buttons, then they can spend several minutes trying to figure out what hardware buttons to press, that would be a good example of an encoding input class of failure.\n\nWhen it comes to decoding output, most Mario levels are not about trying to figure out where the obstacles are; rather, they are about avoiding them. Whether it be because of the color palette limitations of the day, or by intentional design (and realistically, a combination of both factors), obstacles in Mario are mostly easily discernable, and in many cases deaths, are not caused because the player does not see the enemies coming. Even if that ends up being the case, the non-random nature of levels indicates that the designers were comfortable with the players knowing where the hazards were before trying to navigate through them.\n\nIn updating the player's mental model, the first level of Mario (Fig 5) does a lot of heavy lifting. The way Mario is positioned when the game initially starts, and how the camera moves in relation to Mario all support the idea that Mario should go towards the right. Furthermore, the first few minutes of the game, with the goomba appearing (and not letting the player continue onwards until they demonstrate they can jump), the specific placement of the question mark tiles with power-ups, and the varying height pipes, teach most if not all the mechanics the player has to know to be effective at the game. If needed, a more detailed breakdown of Mario 1-1 can be found elsewhere [19]. Just within minutes the player knows what they can do and what they should do in the game respectively ensuring that no one is failing in discovering mechanics or setting goals. Miyamoto himself says, “So even within that one section we knew that the player would understand the general concept of what Mario is supposed to be and what the game is about” [18]. This gradual learning curve that starts at Mario 1-1 and continues throughout the game because Mario is not a game about the player exploring how complicated and varied systems interact with each other or figuring out where to go; rather it is about making a plan and executing it.\n\nOne might argue that when a speedrunner is trying to finish Mario in under five minutes, they are effectively exploring the ways of going faster and, as such, uncovering the hidden (and in this case potentially unintentional) mechanics becomes a part of the fun, making discovering mechanics an in-loop failure class. This argument goes to show that these types of generalizations using the framework run the risk of assuming the entire game audience engages with the game in an identical way. When using the taxonomy, care must be given to understanding different styles of games that any game can support, which might create several different in-loop and out-of-loop failure classes for each play style and player segment.\n\n4.2 Sid Meier's Civilization\n\nAnother game we can look at is Sid Meier's Civilization (shown in Fig 6) series [20]. Similar to SMB both encoding input and decoding output are out-of-loop failure classes. In Civilization figuring out which buttons to press and visually identifying what is going on the screen should not be challenging.\n\nWhen it comes to discovering mechanics, most Civilization-like games, we claim, expect you to learn the rules of the system and then try to be successful within those bounds. The joy does not come from exploring whether hammers help you build armies faster, or whether apples allow you to grow your cities— these are elementary building blocks of the game that the player is expected to utilize. If the player has difficulty grasping these concepts there is a problem and the game has aggressive in game advisors to ensure that this rarely happens. Thus discovering mechanics for Civilization is an out-of-loop failure class.\n\nThe main bulk of the challenge comes from the player making both long and short term plans to decide how to move their units, what buildings to construct, how to conduct diplomacy and what policies to enact. If the player loses the game, it is expected that this is due to making a series of bad decision, which means that this style of loss is within the gameloop. Thus planning is an in-loop failure class for the Civilization series.\n\nFollowing from this is the execution class. Unlike SMB, after having completed the plan, there should be no difficulty in actually implementing that plan. If the player has decided to build a granary, pressing the buttons to do so should be simple. Similarly if the player has decided to invade the neighboring city giving the order should be trivial. If the player fails to finish the granary because the city falls to enemy hands, or the invading army is defeated by the city's defenders, these are not execution failures—the orders were given and executed properly. Rather, they were planning failures, since the plans were not formed effectively which, as discussed above is not problematic. Therefore, this goes to show that in Civilization execution is definitely an out-of-loop failure class.\n\nDifferent from SMB however, is the setting goals class. In SMB, the goal is to reach the right side of the screen and that is closely attached to victory. However in Civilization there are several ways of achieving victory You can conquer all the capital cities of your enemies, you can talk your way into becoming a world leader or you can win the space race. Deciding on the victory conditions of the player's goal is a part of the fun. If the player fails at a given playthrough because they did not alight their goal with the strengths of their nation this is not a problem, because they can learn from their mistakes and try again. As such, setting goals is an in-loop failure class for Civilization, and not an in-loop class for Super Mario where the only is to go right (ignoring transgressive methods of engaging with the game).\n\n4.3 Legend of Zelda: Breath of the Wild\n\nSimilar to our earlier examples encoding input and decoding output are out-of-loop failure classes in Legend of Zelda: Breath of The Wild [43] (referred to BoTW from here on out). This game is not about figuring out which buttons to press or parsing the screen; rather, it is about, deciding what to do in an open-world, discovering how the game systems interact with one another and fighting different types of enemy characters.\n\nUnlike the previously mentioned games however, a big portion of the fun when it comes to playing BoTW comes from gradually learning how the different systems of the game interact with one another. Initially, the player can figure out that wooden weapons catch on fire when held close to a firepit, which can lead to the realization that the shrubbery too is flammable. This understanding culminates in the player figuring out that the fire creates an air current they can hijack to gain some altitude using their paraglider (shown in Fig. 9). Sequences like these in which the player discovers how primitive pieces interact and create emergent experiences contribute to what makes playing BoTW engaging. If the player fails because they perished in the forest fire they just created—showing that they failed because they didn't understand the mechanic previously– this is not a (design) problem. Nor it is a problem if the player has their progress halted while they play around discovering what tools they have to solve the puzzle they just encountered. Thus discovering mechanics is an in-loop class for BotW.\n\nWhen it comes to setting goals, most open world games have an in-loop class and BoTW is no exception. The player is given the overarching victory condition of defeating Ganon in his castle. The player can set his sights on that goal directly, or the player can decide to have their goal be becoming more powerful by recruiting other characters or finishing different storylines—all these goals are supported by the base game. If the player fails to defeat the boss because they set their sights on defeating him too early before accomplishing other goals this is not game breaking failure. The player is allowed to change and readjust their goals and try again later.\n\nPlanning and execution are also in-loop failures as with many other action games. When the player is in combat or climbing a rocky mountain, they first need to plot the actions they want to take and then successfully execute those actions. If they fail because they made the wrong plan—miscalculating how much stamina they would need to climb the hill and slipping down—or because they didn't execute their plan correctly—missing their bow shot and failing to take down the enemy from afar, thereby becoming overwhelmed—the play experience is not hampered and the player can respawn and try again, updating their model with their newfound experience.\n\n4.4 Where's Waldo?\n\nWe would like to conclude this section with an unorthodox game, Where's Waldo? The Fantastic Journey [39]. Altough, we argued that in most cases encoding input and decoding output is an out-of-loop failure class, this does not always have to be the case. The only manner in which a player should fail while playing Where's Waldo should be in finding Waldo, and as such decoding output is an in-loop failure class in this case. The player should know what their goals are, what they could do and which buttons they should press. After spotting Waldo, the rest should pose no difficulty, and as such, all other classes for this game are out-of-loop failure classes.\n\n5 CLASSIFYING INSTANCES OF FAILURES\n\nSo far, we have been classifying games, but another use case of the Taxonomy of Failure is to classify instances of failure. We defined failure as “inability to make progress towards the objective suggested by the game” earlier in the paper. For many games this might be an explicit “Game Over“ screen with a call for the player to try again, but for others it might take the form of a temporary setback. What exactly is going to be classified as an “instance of failure” will once again depend on the specifics of the game and the context in which the taxonomy is being used.\n\nWe would go through the trouble of classifying how our players are failing if this process would help us identify whether a design change is necessary or not. If we keep observing that the players are failing in a specific out-of-loop failure category, we can use this to inform our decisions as to what changes to make.\n\nAnother capability that is of interest to both industry [13] and researchers is player modeling [60]. In most approaches to player modeling the player failures are not differentiated, if represented at all [28]. Given that player response to different types of failures vary, we expect discriminating different types of failure to be useful for downstream applications.\n\nBut is the granularity of the Taxonomy of Failure enough to be a useful tool in the design process? One might argue that there can be cases where two failures of the same class might have opposing impacts on the player; even though they are in the same class, one failure might be in-loop and another might be out-of-loop.\n\nA simple example of this is repeated failures. The first time the player misses a difficult jump is fine. Perhaps the first five times it is fine, maybe the first fifty. But for many games there becomes a point in which even an in-loop failure can become frustrating and detrimental to the intended play experience. In those cases, the first few failures of the execution class are possibly in-loop, and the latter cases are out-of-loop.\n\nAnother example of this comes in the form of specific mechanical interactions. We argued that in many cases failures in decoding input are out-of-loop failures related to accessibility. However, consider the flashbangs in many first-person shooters or the screen obscuring attacks in Super Smash Bros [41] and other party games. Suddenly, if a player fails as they could not decode the screen because it was visually washed out, it is once again acceptable.\n\nTo account for these type of particular cases, in practice, it is valuable to extend the Taxonomy of Failure by considering instances of failures specific to the game one is working on. Going back to our earlier example, in Super Smash Bros. decoding output might be deemed an out-of-loop failure class, but underneath the decoding output class, the specific instance of “failure due to screen obstruction mechanic” would be designated as an in-loop failure instance. The provided Taxonomy of Failure does not come with this level of specific instances by default— we believe that for most games, many of the provided instances would be invalid, and it is better to construct this layer for each game individually. As such, we suggest expanding the taxonomy for the game one is interested in more deeply exploring, by describing the concrete ways how a player can fail in that game. This exercise allows the designers to be more specific when needed, and we also believe that the sole act of outlining the possible failure cases in a game one is designing to be a fruitful activity. Examples of specific failure instances can be seen in Fig. 12.\n\nWhen it comes to using the Taxonomy of Failure in practice, one cannot simply halt the playtest and ask why the player failed after a loss of health points. While it is possible for the designer of the game to guess what is happening, that would still be a guess. A possible way to alleviate this problem is to record the play session and if time permits, go over the failures with the player and work with them to annotate the failures.\n\n6 CONCLUSION\n\nIn this paper we described why it is important to delineate between different types of failures and we offered the Taxonomy of Failure with the six classes of failures to facilitate doing so:\n\nEncoding Input: What physical action will allow me to act in the game?\n\nDecoding Output: Can I parse the feedback of the game?\n\nDiscovering Mechanics: Do I know what I can do in the game?\n\nSetting Goals: Do I know what I should accomplish in the game?\n\nPlanning: What steps should I take to accomplish my goals?\n\nExecution: Was I successful in taking the steps in my plan?\n\nFurther, we discussed how classifying a game using this terminology can be useful for both developing and analyzing games: How, for each given game, each class can be described as in-loop or out-of-loop. That is to say whether the described class of failure is expected in the game loop or is to be avoided.\n\nWe also described how analyzing a game using the Taxonomy of Failure can offer insights into the analysis and critique of the given game and also offer another metric in deciding which design changes are appropriate given the expected players and the state of the game.\n\nOur hope is that after reading this paper the reader's relationship with failure in their favorite games has changed ever so slightly. In our future work we are looking forward to validating the Taxonomy of Failure both as a teaching and a design tool."
    }
}