{
    "id": "dbpedia_1585_2",
    "rank": 68,
    "data": {
        "url": "https://www.e-zest.com/agile_software_development",
        "read_more_link": "",
        "language": "en",
        "title": "Agile Software Development Process Models",
        "top_image": "https://www.e-zest.com/hubfs/Banners/Social/04%20Digital%20Engineering%20web.png",
        "meta_img": "https://www.e-zest.com/hubfs/Banners/Social/04%20Digital%20Engineering%20web.png",
        "images": [
            "https://www.e-zest.com/hubfs/images/Logos%20with%20Tagline/Corporate/SVG/e-Zest%20logo_An%20accion%20lab%20company_Colour.svg",
            "https://www.e-zest.com/hubfs/Elevating%20Product%20Engineering%20with%20AI%20and%20ML.jpg",
            "https://www.e-zest.com/hubfs/e-Zest%20%E2%80%93%20An%20Accion%20Labs%20Company%20-%20Gets%20Recognition%20as%20a%20Contender%20in%20the%20ISG%20Provider%20LensTM%20Study%20on%20Digital%20Engineering%20Services%202024.jpg",
            "https://www.e-zest.com/hubfs/blog-files/Digital%20Literacy%20Bus%20e-Zest.png",
            "https://www.e-zest.com/hubfs/icons/linkedin_icon_white.svg",
            "https://www.e-zest.com/hubfs/twitter-logo-silhouette%20(5).svg",
            "https://www.e-zest.com/hubfs/facebook-app-logo%20(4).svg",
            "https://www.e-zest.com/hubfs/instagram-logo%20(4).svg",
            "https://www.e-zest.com/hubfs/icons/youtube_icon_white.svg",
            "https://www.e-zest.com/hubfs/AA%20Assets/top%20button.svg",
            "https://no-cache.hubspot.com/cta/default/744339/1c80e2a3-3331-4fa1-8a3e-b06bc506baa0.png",
            "https://www.e-zest.com/hs-fs/hubfs/Banners/Building%20scalable%20enterprise%20digital%20tile.jpg?width=480&height=426&name=Building%20scalable%20enterprise%20digital%20tile.jpg",
            "https://www.e-zest.com/hs-fs/hubfs/Banners/IoT%20solution%20for%20modular%20tile.jpg?width=480&height=426&name=IoT%20solution%20for%20modular%20tile.jpg",
            "https://www.e-zest.com/hs-fs/hubfs/Banners/Enabling%20unified%20experience%20with%20tile.jpg?width=480&height=426&name=Enabling%20unified%20experience%20with%20tile.jpg",
            "https://dc.ads.linkedin.com/collect/?pid=322361&fmt=gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "e-Zest Solutions Inc"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Agile software development process models practiced at e-Zest Solutions. Agile processes can deliver successful systems quickly.",
        "meta_lang": "hi",
        "meta_favicon": "https://www.e-zest.com/hubfs/images/sitefavicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://www.e-zest.com/agile_software_development",
        "text": "Agile software engineering represents a reasonable compromise between to conventional software engineering for certain classes of software and certain types of software projects. Agile processes can deliver successful systems quickly. It stresses on continuous communication and collaboration among developers and customers.\n\ne-Zest practices agile software development process models for succesful execution of offshore software development projects having attributes like lesser time to market and changing business needs. Iterative development with frequent delivery to the customer is a core practice in agile software development, and one that directly addresses one of the major challenges of offshore development—decreased visibility into project status.\n\nAgile software engineering embraces a philosophy that encourages customer satisfaction, incremental software delivery, small project teams (composed of software engineers and stakeholders), informal methods, and minimal software engineering work products. Agile software engineering guidelines stress on-time delivery of an operational software increment over analysis and design\n\nAn agile team is able to respond to changes during project development\n\nAgile development recognizes that project plans must be flexible\n\nAgility encourages team structures and attitudes that make communication among developers and customers more facile\n\nAgility eliminates the separation between customers and developers\n\nAgility emphasizes the importance of rapid delivery of operational software and de-emphasizes importance of intermediate work products\n\nAgility can be applied to any software process as long as the project team is allowed to streamline tasks and conduct planning in way that eliminate non-essential work products\n\nAgile Processes\n\nAre based on three key assumptions\n\nIt is difficult to predict in advance which requirements or customer priorities will change and which will not\n\nFor many types of software design and construction activities are interleaved (construction is used to prove the design)\n\nAnalysis, design, and testing are not as predictable from a planning perspective as one might like them to be\n\nAgile processes must be adapted incrementally to manage unpredictability\n\nIncremental adaptation requires customer feedback based on evaluation of delivered software increments (executable prototypes) over short time periods\n\nAgility Principles\n\nHighest priority is to satisfy customer through early and continuous delivery of valuable software\n\nWelcome changing requirements even late in development, accommodating change is viewed as increasing the customer’s competitive advantage\n\nDelivering working software frequently with a preference for shorter delivery schedules (e.g., every 2 or 3 weeks)\n\nBusiness people and developers must work together daily during the project\n\nBuild projects around motivated individuals, given them the environment and support they need, trust them to get the job done\n\nFace-to-face communication is the most effective method of conveying information within the development team\n\nWorking software is the primary measure of progress\n\nAgile processes support sustainable development, developers and customers should be able to continue development indefinitely\n\nContinuous attention to technical excellence and good design enhances agility\n\nSimplicity (defined as maximizing the work not done) is essential\n\nThe best architectures, requirements, and design emerge from self-organizing teams\n\nAt regular intervals teams reflects how to become more effective and adjusts its behavior accordingly\n\nHuman Factors\n\nTraits that need to exist in members of agile development teams:\n\nCompetence\n\nCommon focus\n\nCollaboration\n\nDecision-making ability\n\nFuzzy-problem solving ability\n\nMutual trust and respect\n\nSelf-organization\n\nAgile Process Models\n\nExtreme Programming (XP)\n\nAdaptive Software Development (ASD)\n\nDynamic Systems Development Method (DSDM)\n\nScrum\n\nCrystal\n\nFeature Driven Development (FDD)\n\nAgile Modeling (AM)\n\nExtreme Programming\n\nRelies on object-oriented approach\n\nKey activities\n\nPlanning (user stories created and ordered by customer value)\n\nDesign (simple designs preferred, CRC cards and design prototypes are only work products, encourages use of refactoring)\n\nCoding (focuses on unit tests to exercise stories, emphasizes use of pairs programming to create story code, continuous integration and smoke testing is utilized)\n\nTesting (unit tests created before coding are implemented using an automated testing framework to encourage use of regression testing, integration and validation testing done on daily basis, acceptance tests focus on system features and functions viewable by the customer)\n\nAdaptive Software Development\n\nSelf-organization arises when independent agents cooperate to create a solution to a problem that is beyond the capability of any individual agent\n\nEmphasizes self-organizing teams, interpersonal collaboration, and both individual and team learning\n\nAdaptive cycle characteristics\n\nPhases\n\nMission-driven\n\nComponent-based\n\nIterative\n\nTime-boxed\n\nRisk driven and change-tolerant\n\nSpeculation (project initiated and adaptive cycle planning takes place)\n\nCollaboration (requires teamwork from a jelled team, joint application development is preferred requirements gathering approach, minispecs created)\n\nLearning (components implemented and testes, focus groups provide feedback, formal technical reviews, postmortems)\n\nDynamic Systems Development Method\n\nProvides a framework for building and maintaining systems which meet tight time constraints using incremental prototyping in a controlled environment\n\nUses Pareto principle (80% of project can be delivered in 20% required to deliver the entire project)\n\nEach increment only delivers enough functionality to move to the next increment\n\nUses time boxes to fix time and resources to determine how much functionality will be delivered in each increment\n\nGuiding principles\n\nActive user involvement\n\nTeams empowered to make decisions\n\nFitness foe business purpose is criterion for deliverable acceptance\n\nIterative and incremental develop needed to converge on accurate business solution\n\nAll changes made during development are reversible\n\nRequirements are baselined at a high level\n\nTesting integrates throughout life-cycle\n\nCollaborative and cooperative approach between stakeholders\n\nLife cycle activities\n\nFeasibility study (establishes requirements and constraints)\n\nBusiness study (establishes functional and information requirements needed to provide business value)\n\nFunctional model iteration (produces set of incremental prototypes to demonstrate functionality to customer)\n\nDesign and build iteration (revisits prototypes to ensure they provide business value for end users, may occur concurrently with functional model iteration)\n\nImplementation (latest iteration placed in operational environment)\n\nScrum\n\nScrum principles\n\nSmall working teamed used to maximize communication, minimize overhead, and maximize sharing of informal knowledge\n\nProcess must be adaptable to both technical and business challenges to ensure bets product produced\n\nProcess yields frequent increments that can be inspected, adjusted, tested, documented and built on\n\nDevelopment work and people performing it are partitioned into clean, low coupling partitions\n\nTesting and documentation is performed as the product is built\n\nProvides the ability to declare the product done whenever required\n\nProcess patterns defining development activities\n\nBacklog (prioritized list of requirements or features the provide business value to customer, items can be added at any time)\n\nSprints (work units required to achieve one of the backlog items, must fir into a predefined time-box, affected backlog items frozen)\n\nScrum meetings (15 minute daily meetings) addressing these questions: What was done since last meeting? What obstacles were encountered? What will be done by the next meeting?\n\nDemos (deliver software increment to customer for evaluation)\n\nCrystal\n\nDevelopment approach that puts a premium on maneuverability during a resource-limited game of invention and communication with the primary goal of delivering useful software and a secondary goal of setting up for the next game\n\nCrystal principles\n\nIts always cheaper and faster to communicate face-to-face\n\nAs methodologies become more formal teams become weighed down and have trouble adapting to project work vagaries\n\nAs projects grow in size, teams become larger and methodologies become heavier\n\nAs projects grow in criticality some degree of formality will need to be introduced in parts of the methodology\n\nAs feedback and communication become more efficient the need for intermediate work products is reduced\n\nDiscipline, skills, and understanding counter process, formality, and documentation\n\nTeam members not on the critical project path can spend their excess time improving the product or helping people who are on the critical path\n\nIncremental development strategy used with 1 to 3 month time lines\n\nReflection workshops conducted before project begins, during increment development activity, and after increment is delivered\n\nCrystal methodologies\n\nClear (small, low criticality projects)\n\nOrange (larger, moderately critical projects)\n\nOrange Web (typical e-business applications)\n\nFeature Driven Development\n\nPractical process model for object-oriented software engineering\n\nFeature is a client-valued function, can be implemented in two weeks or less\n\nFDD Philosophy\n\nEmphasizes collaboration among team members\n\nManages problem and project complexity using feature-based decomposition followed integration of software increments\n\nTechnical communication using verbal, graphical, and textual means\n\nSoftware quality encouraged by using incremental development, design and code inspections, SQA audits, metric collection, and use of patterns (analysis, design, construction)\n\nFramework activities\n\nDevelop overall model (contains set of classes depicting business model of application to be built)\n\nBuild features list (features extracted from domain model, features are categorized and prioritized, work is broken up into two week chunks)\n\nPlan by feature (features assessed based on priority, effort, technical issues, schedule dependencies)\n\nDesign by feature (classes relevant to feature are chosen, class and method prologs are written, preliminary design detail developed, owner assigned to each class, owner responsible for maintaining design document for his or her own work packages)\n\nBuild by feature (class owner translates design into source code and performs unit testing, integration performed by chief programmer)\n\nAgile Modeling"
    }
}