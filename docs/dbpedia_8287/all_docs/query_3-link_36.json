{
    "id": "dbpedia_8287_3",
    "rank": 36,
    "data": {
        "url": "https://code.tutsplus.com/objective-c-succinctly-protocols--mobile-22019t",
        "read_more_link": "",
        "language": "en",
        "title": "Objective-C Succinctly: Protocols",
        "top_image": "https://cdn.tutsplus.com/mobile/uploads/2014/03/0e5ds8-preview-image@2x.png",
        "meta_img": "https://cdn.tutsplus.com/mobile/uploads/2014/03/0e5ds8-preview-image@2x.png",
        "images": [
            "https://static.tutsplus.com/packs/static/images/envato-tutsplus-dark-da1bf6c5a7fd83433e94.png",
            "https://static.tutsplus.com/packs/static/images/envato-tutsplus-dark-da1bf6c5a7fd83433e94.png",
            "https://static.tutsplus.com/packs/static/images/envato-tutsplus-dark-da1bf6c5a7fd83433e94.png",
            "https://static.tutsplus.com/packs/static/images/home-67b42eb75817c9594bed.svg",
            "https://www.gravatar.com/avatar/34b12fe249cd57f0989d7445a240e8d9?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG",
            "https://cdn.tutsplus.com/mobile/uploads/2014/01/objective-c_succinctly_image029.jpg",
            "https://cdn.tutsplus.com/mobile/uploads/2014/01/objective-c_succinctly_image030.jpg",
            "https://cdn.tutsplus.com/cdn-cgi/image/width=467/mobile/uploads/2014/01/objective-c_succinctly_image031.jpg",
            "https://cdn.tutsplus.com/cdn-cgi/image/width=467/mobile/uploads/2014/01/objective-c_succinctly_image031.jpg",
            "https://cdn.tutsplus.com/cdn-cgi/image/width=360/mobile/uploads/2014/01/objective-c_succinctly_image031.jpg",
            "https://cdn.tutsplus.com/cdn-cgi/image/width=534/mobile/uploads/2014/01/objective-c_succinctly_image032.png",
            "https://cdn.tutsplus.com/cdn-cgi/image/width=534/mobile/uploads/2014/01/objective-c_succinctly_image032.png",
            "https://cdn.tutsplus.com/cdn-cgi/image/width=360/mobile/uploads/2014/01/objective-c_succinctly_image032.png",
            "https://cdn.tutsplus.com/mobile/uploads/2014/01/objective-c_succinctly_image033.jpg",
            "https://www.gravatar.com/avatar/34b12fe249cd57f0989d7445a240e8d9?s=200&d=https%3A%2F%2Fassets.tutsplus.com%2Fimages%2Fhub%2Favatar_default.png&r=PG",
            "https://static.tutsplus.com/packs/static/images/thumbs-up-e80969147d3487ef9dc5.svg",
            "https://static.tutsplus.com/packs/static/images/thumbs-up-highlight-13174f0b8cbe2b523c3b.svg",
            "https://static.tutsplus.com/packs/static/images/thumbs-down-401ae0d4ead12668516b.svg",
            "https://static.tutsplus.com/packs/static/images/thumbs-down-highlight-1022d39c6062c9267b1d.svg",
            "https://static.tutsplus.com/packs/static/images/market/code/wordpressplugin-ff7db8af535919c26f94.png",
            "https://static.tutsplus.com/packs/static/images/market/code/php_script-5bf7d147ae985669a293.png",
            "https://static.tutsplus.com/packs/static/images/market/code/javascript-523cd3104150162085a3.png",
            "https://static.tutsplus.com/packs/static/images/market/code/mobile-ba7205b80c0a3d32fab1.png",
            "https://static.tutsplus.com/packs/static/images/ecosystem/Elements-9c6156923682e0ca754a.png",
            "https://static.tutsplus.com/packs/static/images/ecosystem/Market-b1c3dbb6b2a34956edf4.png",
            "https://static.tutsplus.com/packs/static/images/ecosystem/Placeit-2bfac81aff196db3c276.png",
            "https://static.tutsplus.com/packs/static/images/ecosystem/Community-4973bc700aa03754d91c.png",
            "https://static.tutsplus.com/packs/static/images/tuts_logo-73b941f1418b55c886ac.svg",
            "https://static.tutsplus.com/packs/static/images/bcorp-bfc565be3a93741fc88c.svg",
            "https://static.tutsplus.com/packs/static/images/social_youtube-2fdd89edede4b116d099.svg",
            "https://static.tutsplus.com/packs/static/images/social_instagram-f01c9d7dc71f1ea86182.svg",
            "https://static.tutsplus.com/packs/static/images/social_tiktok-57b06ff17a284d8a1744.svg",
            "https://static.tutsplus.com/packs/static/images/social_facebook-f35494f677e855ad50dd.svg",
            "https://static.tutsplus.com/packs/static/images/social_twitter-98772a5169f3f29dd437.svg",
            "https://static.tutsplus.com/packs/static/images/social_pinterest-c768bee1968ceb51ae43.svg",
            "https://www.facebook.com/tr?id=912712196247539&ev=PageView&noscript=1",
            "https://googleads.g.doubleclick.net/pagead/viewthroughconversion/943617023/?value=0&guid=ON&script=0"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Ryan Hodson"
        ],
        "publish_date": "2013-12-01T12:37:27+00:00",
        "summary": "",
        "meta_description": "In Objective-C, a protocol is a group of methods that can be implemented by any class. Protocols are essentially the same as interfaces in C#, and they both have similar goals. They can be used as...",
        "meta_lang": "en",
        "meta_favicon": "https://static.tutsplus.com/packs/static/images/favicon-f8d459d2fa865233f59c.ico",
        "meta_site_name": "Code Envato Tuts+",
        "canonical_link": "https://code.tutsplus.com/objective-c-succinctly-protocols--mobile-22019t",
        "text": "In Objective-C, a protocol is a group of methods that can be implemented by any class. Protocols are essentially the same as interfaces in C#, and they both have similar goals. They can be used as a pseudo-data type, which is useful for making sure that a dynamically-typed object can respond to a certain set of messages. And, because any class can \"adopt\" a protocol, they can be used to represent a shared API between completely unrelated classes.\n\nThe official documentation discusses both an informal and a formal method for declaring protocols, but informal protocols are really just a unique use of categories and don't provide nearly as many benefits as formal protocols. With this in mind, this chapter focuses solely on formal protocols.\n\nCreating a Protocol\n\nFirst, let's take a look at how to declare a formal protocol. Create a new file in Xcode and select the Objective-C protocol icon under Mac OS X > Cocoa:\n\nAs usual, this will prompt you for a name. Our protocol will contain methods for calculating the coordinates of an object, so let's call it CoordinateSupport:\n\nClick Next and choose the default location for the file. This will create an empty protocol that looks almost exactly like an interface:\n\nOf course, instead of the @interface directive, it uses @protocol, followed by the protocol name. The <NSObject> syntax lets us incorporate another protocol into CoordinateSupport. In this case, we're saying that CoordinateSupport also includes all of the methods declared in the NSObject protocol (not to be confused with the NSObject class).\n\nNext, let's add a few methods and properties to the protocol. This works the same way as declaring methods and properties in an interface:\n\nAdopting a Protocol\n\nAny class that adopts this protocol is guaranteed to synthesize the x, y, and z properties and implement the arrayFromPosition and magnitude methods. While this doesn't say how they will be implemented, it does give you the opportunity to define a shared API for an arbitrary set of classes.\n\nFor example, if we want both Ship and Person to be able to respond to these properties and methods, we can tell them to adopt the protocol by placing it in angled brackets after the superclass declaration. Also note that, just like using another class, you need to import the protocol file before using it:\n\nNow, in addition to the properties and methods defined in this interface, the Person class is guaranteed to respond to the API defined by CoordinateSupport. Xcode will warn you that the Person implementation is incomplete until you synthesize x, y, and z, and implement arrayFromPosition and magnitude:\n\nLikewise, a category can adopt a protocol by adding it after the category. For example, to tell the Person class to adopt the CoordinateSupport protocol in the Relations category, you would use the following line:\n\nAnd, if your class needs to adopt more than one protocol, you can separate them with commas:\n\nAdvantages of Protocols\n\nWithout protocols, we would have two options to ensure both Ship and Person implemented this shared API:\n\nRe-declare the exact same properties and methods in both interfaces.\n\nDefine the API in an abstract superclass and define Ship and Person as subclasses.\n\nNeither of these options are particularly appealing: the first is redundant and prone to human error, and the second is severely limiting, especially if they already inherit from different parent classes. It should be clear that protocols are much more flexible and reusable, as they shield the API from being dependent on any particular class.\n\nThe fact that any class can easily adopt a protocol makes it possible to define horizontal relationships on top of an existing class hierarchy:\n\nDue to the flexible nature of protocols, the various iOS frameworks make good use of them. For example, user interface controls are often configured using the delegation design pattern, wherein a delegate object is responsible for reacting to user actions. Instead of encapsulating a delegate's responsibilities in an abstract class and forcing delegates to subclass it, iOS defines the necessary API for the delegate in a protocol. This way, it's incredibly easy for any object to act as the delegate object. We'll explore this in much more detail in the second half of this series, iOS Succinctly.\n\nProtocols as Pseudo-Types\n\nProtocols can be used as psuedo-data types. Instead of making sure a variable is an instance of a class, using a protocol as a type checking tool ensures that the variable always conforms to an arbitrary API. For example, the following person variable is guaranteed to implement the CoordinateSupport API.\n\nStill, enforcing protocol adoption is often more useful when used with the id data type. This lets you assume certain methods and properties while completely disregarding the object's class.\n\nAnd of course, the same syntax can be used with a method parameter. The following snippet adds a new getDistanceFromObject: method to the API whose parameter is required to conform to CoordinateSupport protocol:\n\nNote that it's entirely possible to use a protocol in the same file as it is defined.\n\nDynamic Conformance Checking\n\nIn addition to the static type checking discussed in the last section, you can also use the conformsToProtocol: method defined by the NSObject protocol to dynamically check whether an object conforms to a protocol or not. This is useful for preventing errors when working with dynamic objects (objects typed as id).\n\nThe following example assumes the Person class adopts the CoordinateSupport protocol, while the Ship class does not. It uses a dynamically typed object called mysteryObject to store an instance of Person,and then uses conformsToProtocol: to check if it has coordinate support. If it does, it's safe to use the x, y, and z properties, as well as the other methods declared in the CoordinateSupport protocol:\n\nIf you uncomment the line that reassigns the mysteryObject to a Ship instance, the conformsToProtocol: method will return NO, and you won't be able to safely use the API defined by CoordinateSupport. If you're not sure what kind of object a variable will hold, this kind of dynamic protocol checking is important to prevent your program from crashing when you try to call a method that doesn't exist.\n\nAlso notice the new @protocol() directive. This works much like @selector(), except instead of a method name, it takes a protocol name. It returns a Protocol object, which can be passed to conformsToProtocol:, among other built-in methods. The protocol header file does not need to be imported for @protocol() to work.\n\nForward-Declaring Protocols\n\nIf you end up working with a lot of protocols, you'll eventually run into a situation where two protocols rely on one another. This circular relationship poses a problem for the compiler, since it cannot successfully import either of them without the other. For example, let's say we were trying to abstract out some GPS functionality into a GPSSupport protocol, but want to be able to convert between the \"normal\" coordinates of our existing CoordinateSupport and the coordinates used by GPSSupport. The GPSSupport protocol is pretty simple:\n\nThis doesn't pose any problems, that is, until we need to reference the GPSSupport protocol from CoordinateSupport.h:\n\nNow, the CoordinateSupport.h file requires the GPSSupport.h file to compile correctly, and vice versa. It's a chicken-or-the-egg kind of problem, and the compiler will not like it very much:\n\nResolving the recursive relationship is simple. All you need to do is forward-declare one of the protocols instead of trying to import it directly:\n\nAll @protocol CoordinateSupport; says is that CoordinateSupport is indeed a protocol and the compiler can assume it exists without importing it. Note the semicolon at the end of the statement. This could be done in either of the two protocols; the point is to remove the circular reference. The compiler doesn't care how you do it.\n\nSummary\n\nProtocols are an incredibly powerful feature of Objective-C. They let you capture relationships between arbitrary classes when it's not feasible to connect them with a common parent class. We'll utilize several built-in protocols in iOS Succinctly, as many of the core functions of an iPhone or iPad app are defined as protocols.\n\nThe next chapter introduces exceptions and errors, two very important tools for managing the problems that inevitably arise while writing Objective-C programs."
    }
}