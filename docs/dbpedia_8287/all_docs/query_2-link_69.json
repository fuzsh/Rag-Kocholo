{
    "id": "dbpedia_8287_2",
    "rank": 69,
    "data": {
        "url": "https://codilime.com/blog/fpga-programming/",
        "read_more_link": "",
        "language": "en",
        "title": "FPGA Programming — Introduction Guide to HDL",
        "top_image": "https://codilime.com/static/02d8458cea25c6a58b521daeb0e19c0e/fpga-programming-featured-image.jpg",
        "meta_img": "https://codilime.com/static/02d8458cea25c6a58b521daeb0e19c0e/fpga-programming-featured-image.jpg",
        "images": [
            "https://codilime.com/static/103fda11d6631faad690d1212047ef7a/fpga-programming-header.png",
            "https://codilime.com/static/b90c6efc3b4ab85f20bd0c679c69518c/e07e1/cl_img_0321.jpg",
            "https://codilime.com/static/b90c6efc3b4ab85f20bd0c679c69518c/e07e1/cl_img_0321.jpg",
            "https://codilime.com/static/94d9ef6374fdd8a7387fa007895b7ec9/signal-values.svg",
            "https://codilime.com/static/e41a0d21b7f98487a6a83685267719d8/netlist.svg",
            "https://codilime.com/static/b90c6efc3b4ab85f20bd0c679c69518c/e07e1/cl_img_0321.jpg",
            "https://codilime.com/static/b90c6efc3b4ab85f20bd0c679c69518c/e07e1/cl_img_0321.jpg",
            "https://codilime.com/static/374cc533eee54c1edd7c9e541406e801/8f342/369_blogpost_from_algorithms_to_fpga_hardware_thumbnail.jpg",
            "https://codilime.com/static/374cc533eee54c1edd7c9e541406e801/8f342/369_blogpost_from_algorithms_to_fpga_hardware_thumbnail.jpg",
            "https://codilime.com/static/8f14fce7bc94e448a6230ab0758d8afd/8f342/310_the_next_evolution_in_storage_thumbnail.jpg",
            "https://codilime.com/static/8f14fce7bc94e448a6230ab0758d8afd/8f342/310_the_next_evolution_in_storage_thumbnail.jpg",
            "https://codilime.com/static/equinix-logo2-a051d98ff8ec6fff4bb9853700b9029a.svg",
            "https://codilime.com/static/63357885f25ffefb81eedde8d5cfe0a9/1c026/figure.png",
            "https://codilime.com/static/63357885f25ffefb81eedde8d5cfe0a9/1c026/figure.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Maciej Trochimiuk"
        ],
        "publish_date": "2022-08-03T12:39:11.549000+00:00",
        "summary": "",
        "meta_description": "FPGA programming consists of creating a logic circuit performing an algorithm and describe it with hardware description language. Read on to learn more.",
        "meta_lang": "",
        "meta_favicon": "/favicon-32x32.png?v=a43d9e30fe23c958c0e02daaebd0f65b",
        "meta_site_name": "CodiLime",
        "canonical_link": "https://codilime.com/blog/fpga-programming/",
        "text": "The notion of “FPGA programming” may be a little misleading. Actually, unlike a CPU, there is no program to run on an FPGA. FPGA programming consists of creating a logic circuit that will perform a requested algorithm and describe it using a hardware description language. Consequently, the building blocks of this algorithm are not variables, conditions and a set of operations to be performed, but rather logic gates, adders, registers and multiplexers. The described circuit will eventually be compiled into logic modules - the building blocks of FPGAs.\n\nBuilding blocks of a logic circuit\n\nAll computers are electronic machines that perform operations using boolean logic. In boolean logic, there are only two values a variable can be assigned: true and false. FPGA logic modules are designed to perform arbitrary boolean operations with a specific number of inputs and outputs.\n\nCombinational logic implements arbitrary truth tables and basic operations on multi-bit boolean variables. Multiplexers select one of the input paths depending on a condition. Ripple-carry adders implement fast additions and subtractions on arbitrary-length variables without engaging combinational logic. Finally, registers are utilized to store boolean values.\n\nLanguages used in FPGA programming\n\nHardware description language is used to assemble these FPGA building blocks into a circuit that will perform a specific task, making the programming different compared to typical high-level languages. The two most popular hardware description languages are VHDL and Verilog. VHDL’s syntax is similar to Pascal. Verilog, however, is similar to C.\n\nWriting a counter with VHDL\n\nIn order to demonstrate how to use hardware description language, we will write a simple but omnipresent hardware module - a counter. Our language of choice will be VHDL. Despite being a complex and somewhat archaic language with certain pitfalls, simple hardware designs in VHDL are self-explanatory.\n\nThe VHDL file begins with the keywords library and use. First, we define the libraries we’re about to use in the code below. Its counterpart in C language is the include section.\n\nLibrary std_logic_1164 contains definitions of std_logic and std_logic_vector. These two types of model logic states relate to single and multi-bit signals, respectively. Apart from zeros and ones, these types also contain special values to match with logical uncertainty and uninitialised values, which are used in hardware design simulation. Library numeric_std contains signed and unsigned data types and conversion functions from and to std_logic types. In our example, apart from std_logic and std_logic_vector, the type unsigned will be used.\n\nThe second part of the code is an entity declaration. We declare universal_counter as a design element with generics and ports. Generics in VHDL enable us to synthesize the same element in different variants. In this case, multiple counters may have different widths and, when no generic is passed, the compiler assumes a default value of 8. Ports in VHDL define the inputs and outputs of the entity. In the case of universal_counter, we have five input ports and one output. Ports include: clock clk, reset rst, load which assigns new values from the input to the counter, enable which makes the count work, and eventually output with the value of the counter.\n\nThe circuit design of an entity is specified in the architecture section. A single circuit may have multiple architectures in VHDL. This stems from the fact that different targets require different design approaches. For example, the architecture of an FPGA entity must exploit all features of the target FPGA device, such as logic modules, memories and DSP blocks (if available). On the other hand, architecture of ASIC circuits must be self-contained and must avoid resource-heavy components such as memories and multipliers.\n\nIn our case, we’re specifying register transfer level architecture. Register transfer level means utilizing both sequential elements (such as registers) and combinational elements (such as logic) to map the circuit. This architecture contains two signals of unsigned type. Signals are hardware components to which a value can be assigned within the architecture. In our example, signals are used to implement a flip-flop. Signal value_r stores the current value of the output, and signal value_next stores the next value, which is derived using combinational logic.\n\nAll statements defined inside the architecture are run in parallel. The architecture definition starts with the keyword begin.\n\nProcess is a special, event-driven statement in VHDL. Instructions inside a process statement are run sequentially every time a value on the sensitivity list (in our case clk and rst) is altered. Furthermore, VHDL processes may define their own variables to be used inside the process. In our case, we assign zero to signal value_r if reset is triggered and assign a derived value each clock cycle otherwise.\n\nThe assignment is used to derive value_next from known logical values inside the architecture. Since signals are of the unsigned type, input must be converted before being used, but don’t worry, this and many other cases will be resolved by the compiler and will be implemented using combinational logic: multiplexers and adders.\n\nThe last statement assigns the value from the flip-flop to the output. VHDL architecture is finalized with the keyword end.\n\nSimulating a counter with VHDL\n\nTo simulate a counter we must define a stimulus. A stimulus is a virtual entity that generates input signals to a design. More complex stimuli will not only generate input signals but also compare output from the hardware design with the output generated by the reference model to ensure that the design works as expected.\n\nAs with the universal_counter entity, the stimulus source file begins with library and entity declarations.\n\nBecause we’re not expecting to either provide or receive any data, the entity section can be empty. For the same reason, the architecture section of the file is more complex than the previous one.\n\nThe architecture definition consists of a component declaration that resembles the entity of universal_counter. Actually, it will resolve it and use a previously defined entity. Furthermore, we need signals to communicate with the component. In the next section we will implement a 4-bit counter. Thus, both s_input and s_output signals have a width of 4 bits.\n\nThe map section connects the wires of the component with signals defined in the architecture section. Since we used only one generic, to specify that the counter is 4-bit, we don’t need to specify the name of the generic. On the contrary, when mapping ports, each port must be manually connected to the matching signal. The DUT name specified at the beginning of the component map is the name of the component. It allows us to access that specific component in the simulation.\n\nTo generate the clock, we need to exploit the event-driven nature of the process statement. In process CLK_GEN, at the beginning of the simulation, each signal is set as uninitialized (value U in std_logic). Hence, an event on s_clk is generated that triggers the process that first sets the signal, and then negates it after a half of the clock cycle (we assume 10 nanoseconds).\n\nWhen the process statement is used without a sensitivity list, the instructions are run sequentially once. First, we set the reset signal to initialize the component. Furthermore, we explicitly set all values of input signals. In the next clock cycle, we disable the reset signal and load the input value of the counter, which was previously set to its maximum value. Lastly, we set the enable signal. Using the HDL simulation tool, we can observe the behavior of our entity. The plotted signal values have been depicted below.\n\nSynthesizing a counter\n\nSynthesis is a process that maps the described hardware into the logic modules described in the first chapter. To perform a synthesis of the presented counter we just need to specify the target device and desired pinout if we’re about to use specific boards. No other entities are required.\n\nNetlist - a scheme that shows how the FPGA compiler understood the circuit in hardware description language is depicted below. As we see, the design requires a multi-bit adder, two multiplexers and a registry.\n\nThe technology map viewer enables us to see how the netlist was eventually mapped onto the specific hardware components of a target device. Nevertheless, the technology map for even very simple circuits such as a multi-bit counter can be very complicated. Thus, it won’t be depicted.\n\nSummary\n\nIn this article, the building blocks of an FPGA device, a simple circuit design, and its stimulus were explained.\n\nFinally, the code of the counter looks as follows:\n\nThe code of the stimulus is presented below."
    }
}