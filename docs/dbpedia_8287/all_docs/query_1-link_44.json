{
    "id": "dbpedia_8287_1",
    "rank": 44,
    "data": {
        "url": "https://stackoverflow.com/questions/376090/nsdictionary-with-ordered-keys",
        "read_more_link": "",
        "language": "en",
        "title": "NSDictionary with ordered keys",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://cdn.sstatic.net/Img/teams/teams-promo.svg?v=e507948b81bf",
            "https://www.gravatar.com/avatar/e8891617e36b8d1254eb3ce1a5662da4?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/184c01c79e3685f1ea2fb9dfd0220c0f?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/VWGUO.jpg?s=64",
            "https://www.gravatar.com/avatar/c4913f524d506d57377e6aa2aee46e42?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/63bd3df4d0958b941d33ff380daf59ac?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5827c5d4787b233457149431a7f9a76d?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/196eaa9a65c4360dc9758a27ad1b69ee?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/4X65U.jpg?s=64",
            "https://www.gravatar.com/avatar/580af74dcdb23b29e1d37a65dffb707e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e8891617e36b8d1254eb3ce1a5662da4?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/accc35bdc86ca7a6045eaab14afc53e9?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/94fcbe7f19c0c5fe42e2b9e08f5ade88?s=64&d=identicon&r=PG",
            "https://stackoverflow.com/posts/376090/ivc/0d79?prg=67bd78b7-b720-4309-80d7-42d18c5d586a"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2008-12-17T21:27:37",
        "summary": "",
        "meta_description": "I have an NSDictionary (stored in a plist) that I'm basically using as an associative array (strings as keys and values).  I want to use the array of keys as part of my application, but I'd like th...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/376090/nsdictionary-with-ordered-keys",
        "text": "I have an NSDictionary (stored in a plist) that I'm basically using as an associative array (strings as keys and values). I want to use the array of keys as part of my application, but I'd like them to be in a specific order (not really an order that I can write an algorithm to sort them into). I could always store a separate array of the keys, but that seems kind of kludgey because I'd always have to update the keys of the dictionary as well as the values of the array, and make sure they always correspond. Currently I just use [myDictionary allKeys], but obviously this returns them in an arbitrary, non-guaranteed order. Is there a data structure in Objective-C that I'm missing? Does anyone have any suggestions on how to more elegantly do this?\n\nThere is no such inbuilt method from which you can acquire this. But a simple logic work for you. You can simply add few numeric text in front of each key while you prepare the dictionary. Like\n\nNSDictionary *dict = [[NSDictionary alloc] initWithObjectsAndKeys: @\"01.Created\",@\"cre\", @\"02.Being Assigned\",@\"bea\", @\"03.Rejected\",@\"rej\", @\"04.Assigned\",@\"ass\", @\"05.Scheduled\",@\"sch\", @\"06.En Route\",@\"inr\", @\"07.On Job Site\",@\"ojs\", @\"08.In Progress\",@\"inp\", @\"09.On Hold\",@\"onh\", @\"10.Completed\",@\"com\", @\"11.Closed\",@\"clo\", @\"12.Cancelled\", @\"can\", nil];\n\nNow if you can use sortingArrayUsingSelector while getting all keys in the same order as you place.\n\nNSArray *arr = [[dict allKeys] sortedArrayUsingSelector:@selector(localizedStandardCompare:)];\n\nAt the place where you want to display keys in UIView, just chop off the front 3 character.\n\nanswered Feb 22, 2013 at 9:14\n\nRajan TwanabashuRajan Twanabashu\n\n4,70655 gold badges4545 silver badges5555 bronze badges\n\nIf you're going to subclass NSDictionary you need to implement these methods as a minimum:\n\nNSDictionary\n\n-count\n\n-objectForKey:\n\n-keyEnumerator\n\nNSMutableDictionary\n\n-removeObjectForKey:\n\n-setObject:forKey:\n\nNSCopying/NSMutableCopying\n\n-copyWithZone:\n\n-mutableCopyWithZone:\n\nNSCoding\n\n-encodeWithCoder:\n\n-initWithCoder:\n\nNSFastEnumeration (for Leopard)\n\n-countByEnumeratingWithState:objects:count:\n\nThe easiest way to do what you want is to make a subclass of NSMutableDictionary that contains its' own NSMutableDictionary that it manipulates and an NSMutableArray to store an ordered set of keys.\n\nIf you're never going to encode your objects you could conceivable skip implementing -encodeWithCoder: and -initWithCoder:\n\nAll of your method implementations in the 10 methods above would then either go directly through your hosted dictionary or your ordered key array.\n\nanswered Dec 18, 2008 at 4:40\n\nAshley ClarkAshley Clark\n\n8,82333 gold badges3636 silver badges3535 bronze badges\n\nMinimal implementation of an ordered subclass of NSDictionary (based on https://github.com/nicklockwood/OrderedDictionary). Feel free to extend for your needs:\n\nSwift 3 and 4\n\nclass MutableOrderedDictionary: NSDictionary { let _values: NSMutableArray = [] let _keys: NSMutableOrderedSet = [] override var count: Int { return _keys.count } override func keyEnumerator() -> NSEnumerator { return _keys.objectEnumerator() } override func object(forKey aKey: Any) -> Any? { let index = _keys.index(of: aKey) if index != NSNotFound { return _values[index] } return nil } func setObject(_ anObject: Any, forKey aKey: String) { let index = _keys.index(of: aKey) if index != NSNotFound { _values[index] = anObject } else { _keys.add(aKey) _values.add(anObject) } } }\n\nusage\n\nlet normalDic = [\"hello\": \"world\", \"foo\": \"bar\"] // initializing empty ordered dictionary let orderedDic = MutableOrderedDictionary() // copying normalDic in orderedDic after a sort normalDic.sorted { $0.0.compare($1.0) == .orderedAscending } .forEach { orderedDic.setObject($0.value, forKey: $0.key) } // from now, looping on orderedDic will be done in the alphabetical order of the keys orderedDic.forEach { print($0) }\n\nObjective-C\n\n@interface MutableOrderedDictionary<__covariant KeyType, __covariant ObjectType> : NSDictionary<KeyType, ObjectType> @end @implementation MutableOrderedDictionary { @protected NSMutableArray *_values; NSMutableOrderedSet *_keys; } - (instancetype)init { if ((self = [super init])) { _values = NSMutableArray.new; _keys = NSMutableOrderedSet.new; } return self; } - (NSUInteger)count { return _keys.count; } - (NSEnumerator *)keyEnumerator { return _keys.objectEnumerator; } - (id)objectForKey:(id)key { NSUInteger index = [_keys indexOfObject:key]; if (index != NSNotFound) { return _values[index]; } return nil; } - (void)setObject:(id)object forKey:(id)key { NSUInteger index = [_keys indexOfObject:key]; if (index != NSNotFound) { _values[index] = object; } else { [_keys addObject:key]; [_values addObject:object]; } } @end\n\nusage\n\nNSDictionary *normalDic = @{@\"hello\": @\"world\", @\"foo\": @\"bar\"}; // initializing empty ordered dictionary MutableOrderedDictionary *orderedDic = MutableOrderedDictionary.new; // copying normalDic in orderedDic after a sort for (id key in [normalDic.allKeys sortedArrayUsingSelector:@selector(compare:)]) { [orderedDic setObject:normalDic[key] forKey:key]; } // from now, looping on orderedDic will be done in the alphabetical order of the keys for (id key in orderedDic) { NSLog(@\"%@:%@\", key, orderedDic[key]); }\n\nanswered Sep 6, 2017 at 14:15\n\nCœurCœur\n\n38.3k2626 gold badges201201 silver badges274274 bronze badges\n\nI don’t like C++ very much, but one solution that I see myself using more and more is to use Objective-C++ and std::map from the Standard Template Library. It is a dictionary whose keys are automatically sorted on insertion. It works surprisingly well with either scalar types or Objective-C objects both as keys and as values.\n\nIf you need to include an array as a value, just use std::vector instead of NSArray.\n\nOne caveat is that you might want to provide your own insert_or_assign function, unless you can use C++17 (see this answer). Also, you need to typedef your types to prevent certain build errors. Once you figure out how to use std::map, iterators etc., it is pretty straightforward and fast.\n\nanswered Aug 25, 2017 at 13:45\n\nMartin WinterMartin Winter\n\n1,38099 silver badges1010 bronze badges"
    }
}