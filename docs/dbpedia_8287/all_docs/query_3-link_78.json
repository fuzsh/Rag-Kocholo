{
    "id": "dbpedia_8287_3",
    "rank": 78,
    "data": {
        "url": "https://www.typescriptlang.org/docs/handbook/2/conditional-types.html",
        "read_more_link": "",
        "language": "en",
        "title": "TypeScript: Documentation",
        "top_image": "https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae",
        "meta_img": "https://www.typescriptlang.org/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae",
        "images": [
            "https://avatars.githubusercontent.com/u/49038?s=100&u=0b9ac5bf42a8ea2543a05191e150e0213456744e&v=4",
            "https://gravatar.com/avatar/67a495c379471d65003c17c34cbf0a04?s=32&&d=blank",
            "https://gravatar.com/avatar/364a571118695dfc26b1a069a81801ad?s=32&&d=blank",
            "https://gravatar.com/avatar/5467412635d8b794d2f3ea5f428222e1?s=32&&d=blank",
            "https://gravatar.com/avatar/808a426610e875611d0e1f5e2e23c7f8?s=32&&d=blank"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Create types which act like if statements in the type system.",
        "meta_lang": "en",
        "meta_favicon": "/favicon-32x32.png?v=8944a05a8b601855de116c8a56d3b3ae",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "At the heart of most useful programs, we have to make decisions based on input. JavaScript programs are no different, but given the fact that values can be easily introspected, those decisions are also based on the types of the inputs. Conditional types help describe the relation between the types of inputs and outputs.\n\nts\n\ninterfaceAnimal {\n\nlive(): void;\n\n}\n\ninterfaceDogextendsAnimal {\n\nwoof(): void;\n\n}\n\ntypeExample1 = DogextendsAnimal ? number : string;\n\ntype Example1 = number\n\ntypeExample2 = RegExpextendsAnimal ? number : string;\n\ntype Example2 = string\n\nTry\n\nConditional types take a form that looks a little like conditional expressions (condition ? trueExpression : falseExpression) in JavaScript:\n\nts\n\nSomeTypeextendsOtherType ? TrueType : FalseType;\n\nTry\n\nWhen the type on the left of the extends is assignable to the one on the right, then you’ll get the type in the first branch (the “true” branch); otherwise you’ll get the type in the latter branch (the “false” branch).\n\nFrom the examples above, conditional types might not immediately seem useful - we can tell ourselves whether or not Dog extends Animal and pick number or string! But the power of conditional types comes from using them with generics.\n\nFor example, let’s take the following createLabel function:\n\nts\n\ninterfaceIdLabel {\n\nid: number/* some fields */;\n\n}\n\ninterfaceNameLabel {\n\nname: string/* other fields */;\n\n}\n\nfunctioncreateLabel(id: number): IdLabel;\n\nfunctioncreateLabel(name: string): NameLabel;\n\nfunctioncreateLabel(nameOrId: string | number): IdLabel | NameLabel;\n\nfunctioncreateLabel(nameOrId: string | number): IdLabel | NameLabel {\n\nthrow\"unimplemented\";\n\n}\n\nTry\n\nThese overloads for createLabel describe a single JavaScript function that makes a choice based on the types of its inputs. Note a few things:\n\nIf a library has to make the same sort of choice over and over throughout its API, this becomes cumbersome.\n\nWe have to create three overloads: one for each case when we’re sure of the type (one for string and one for number), and one for the most general case (taking a string | number). For every new type createLabel can handle, the number of overloads grows exponentially.\n\nInstead, we can encode that logic in a conditional type:\n\nts\n\ntypeNameOrId<Textendsnumber | string> = Textendsnumber\n\n? IdLabel\n\n: NameLabel;\n\nTry\n\nWe can then use that conditional type to simplify our overloads down to a single function with no overloads.\n\nts\n\nfunctioncreateLabel<Textendsnumber | string>(idOrName: T): NameOrId<T> {\n\nthrow\"unimplemented\";\n\n}\n\nleta = createLabel(\"typescript\");\n\nlet a: NameLabel\n\nletb = createLabel(2.8);\n\nlet b: IdLabel\n\nletc = createLabel(Math.random() ? \"hello\" : 42);\n\nlet c: NameLabel | IdLabel\n\nTry\n\nConditional Type Constraints\n\nOften, the checks in a conditional type will provide us with some new information. Just like narrowing with type guards can give us a more specific type, the true branch of a conditional type will further constrain generics by the type we check against.\n\nFor example, let’s take the following:\n\nts\n\ntypeMessageOf<T> = T[\"message\"];\n\nType '\"message\"' cannot be used to index type 'T'.2536Type '\"message\"' cannot be used to index type 'T'.Try\n\nIn this example, TypeScript errors because T isn’t known to have a property called message. We could constrain T, and TypeScript would no longer complain:\n\nts\n\ntypeMessageOf<Textends { message: unknown }> = T[\"message\"];\n\ninterfaceEmail {\n\nmessage: string;\n\n}\n\ntypeEmailMessageContents = MessageOf<Email>;\n\ntype EmailMessageContents = string\n\nTry\n\nHowever, what if we wanted MessageOf to take any type, and default to something like never if a message property isn’t available? We can do this by moving the constraint out and introducing a conditional type:\n\nts\n\ntypeMessageOf<T> = Textends { message: unknown } ? T[\"message\"] : never;\n\ninterfaceEmail {\n\nmessage: string;\n\n}\n\ninterfaceDog {\n\nbark(): void;\n\n}\n\ntypeEmailMessageContents = MessageOf<Email>;\n\ntype EmailMessageContents = string\n\ntypeDogMessageContents = MessageOf<Dog>;\n\ntype DogMessageContents = never\n\nTry\n\nWithin the true branch, TypeScript knows that T will have a message property.\n\nAs another example, we could also write a type called Flatten that flattens array types to their element types, but leaves them alone otherwise:\n\nts\n\ntypeFlatten<T> = Textendsany[] ? T[number] : T;\n\n// Extracts out the element type.\n\ntypeStr = Flatten<string[]>;\n\ntype Str = string\n\n// Leaves the type alone.\n\ntypeNum = Flatten<number>;\n\ntype Num = number\n\nTry\n\nWhen Flatten is given an array type, it uses an indexed access with number to fetch out string[]’s element type. Otherwise, it just returns the type it was given.\n\nInferring Within Conditional Types\n\nWe just found ourselves using conditional types to apply constraints and then extract out types. This ends up being such a common operation that conditional types make it easier.\n\nConditional types provide us with a way to infer from types we compare against in the true branch using the infer keyword. For example, we could have inferred the element type in Flatten instead of fetching it out “manually” with an indexed access type:\n\nts\n\ntypeFlatten<Type> = TypeextendsArray<inferItem> ? Item : Type;\n\nTry\n\nHere, we used the infer keyword to declaratively introduce a new generic type variable named Item instead of specifying how to retrieve the element type of Type within the true branch. This frees us from having to think about how to dig through and probing apart the structure of the types we’re interested in.\n\nWe can write some useful helper type aliases using the infer keyword. For example, for simple cases, we can extract the return type out from function types:\n\nts\n\ntypeGetReturnType<Type> = Typeextends (...args: never[]) =>inferReturn\n\n? Return\n\n: never;\n\ntypeNum = GetReturnType<() =>number>;\n\ntype Num = number\n\ntypeStr = GetReturnType<(x: string) =>string>;\n\ntype Str = string\n\ntypeBools = GetReturnType<(a: boolean, b: boolean) =>boolean[]>;\n\ntype Bools = boolean[]\n\nTry\n\nWhen inferring from a type with multiple call signatures (such as the type of an overloaded function), inferences are made from the last signature (which, presumably, is the most permissive catch-all case). It is not possible to perform overload resolution based on a list of argument types.\n\nts\n\ndeclarefunctionstringOrNum(x: string): number;\n\ndeclarefunctionstringOrNum(x: number): string;\n\ndeclarefunctionstringOrNum(x: string | number): string | number;\n\ntypeT1 = ReturnType<typeofstringOrNum>;\n\ntype T1 = string | number\n\nTry\n\nDistributive Conditional Types\n\nWhen conditional types act on a generic type, they become distributive when given a union type. For example, take the following:\n\nts\n\ntypeToArray<Type> = Typeextendsany ? Type[] : never;\n\nTry\n\nIf we plug a union type into ToArray, then the conditional type will be applied to each member of that union.\n\nts\n\ntypeToArray<Type> = Typeextendsany ? Type[] : never;\n\ntypeStrArrOrNumArr = ToArray<string | number>;\n\ntype StrArrOrNumArr = string[] | number[]\n\nTry\n\nWhat happens here is that ToArray distributes on:\n\nts\n\nstring | number;\n\nTry\n\nand maps over each member type of the union, to what is effectively:\n\nts\n\nToArray<string> | ToArray<number>;\n\nTry\n\nwhich leaves us with:\n\nts\n\nstring[] | number[];\n\nTry\n\nTypically, distributivity is the desired behavior. To avoid that behavior, you can surround each side of the extends keyword with square brackets."
    }
}