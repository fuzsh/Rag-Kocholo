{
    "id": "dbpedia_8287_3",
    "rank": 72,
    "data": {
        "url": "https://www.hackingwithswift.com/books/ios-swiftui/working-with-identifiable-items-in-swiftui",
        "read_more_link": "",
        "language": "en",
        "title": "Working with Identifiable items in SwiftUI",
        "top_image": "https://www.hackingwithswift.com/favicon.svg",
        "meta_img": "https://www.hackingwithswift.com/favicon.svg",
        "images": [
            "https://www.hackingwithswift.com/img/logo-curves-ua.svg",
            "https://www.hackingwithswift.com/img/sponsors/superwall-light.svg",
            "https://www.hackingwithswift.com/img/hws-plus-footer-desktop.png",
            "https://www.hackingwithswift.com/img/covers-flat/pro-swift.png",
            "https://www.hackingwithswift.com/img/covers-flat/pro-swiftui.png",
            "https://www.hackingwithswift.com/img/covers-flat/patterns.png",
            "https://www.hackingwithswift.com/img/covers-flat/testing.png",
            "https://www.hackingwithswift.com/img/covers-flat/hws.png",
            "https://www.hackingwithswift.com/img/covers-flat/swiftcc.png",
            "https://www.hackingwithswift.com/img/covers-flat/sundays-1.png",
            "https://www.hackingwithswift.com/img/covers-flat/vapor.png",
            "https://www.hackingwithswift.com/img/covers-flat/advanced-ios-1.png",
            "https://www.hackingwithswift.com/img/covers-flat/advanced-ios-2.png",
            "https://www.hackingwithswift.com/img/covers-flat/advanced-ios-3.png",
            "https://www.hackingwithswift.com/img/covers-flat/watchos.png",
            "https://www.hackingwithswift.com/img/covers-flat/tvos.png",
            "https://www.hackingwithswift.com/img/covers-flat/macos.png",
            "https://www.hackingwithswift.com/img/covers-flat/spritekit.png",
            "https://www.hackingwithswift.com/img/covers-flat/sixty.png",
            "https://www.hackingwithswift.com/img/covers-flat/objc.png",
            "https://www.hackingwithswift.com/img/covers-flat/beyond-code.png",
            "https://www.hackingwithswift.com/img/unknown_user.png"
        ],
        "movies": [
            "https://www.youtube-nocookie.com/embed/naK7cXsVxD0?rel=0"
        ],
        "keywords": [],
        "meta_keywords": [
            "hacking with swift",
            "swift 5",
            "swift",
            "swiftui",
            "swift ui",
            "tutorial",
            "ios",
            "ios 17",
            "ios 16",
            "ios 15",
            "wwdc",
            "apple",
            "ipad",
            "iphone",
            "free",
            "tutorial",
            "guide",
            "objective c",
            "watchos",
            "tvos",
            "macOS",
            "uikit",
            "visionos",
            "watchkit"
        ],
        "tags": null,
        "authors": [
            "Paul Hudson",
            "Paul Hudson @twostraws"
        ],
        "publish_date": "2024-04-11T00:00:00",
        "summary": "",
        "meta_description": "Learn Swift coding for iOS with these free tutorials",
        "meta_lang": "en",
        "meta_favicon": "/favicon.svg",
        "meta_site_name": "Hacking with Swift",
        "canonical_link": "https://www.hackingwithswift.com/books/ios-swiftui/working-with-identifiable-items-in-swiftui",
        "text": "Paul Hudson @twostraws April 11th 2024\n\nWhen we create static views in SwiftUI – when we hard-code a VStack, then a TextField, then a Button, and so on – SwiftUI can see exactly which views we have, and is able to control them, animate them, and more. But when we use List or ForEach to make dynamic views, SwiftUI needs to know how it can identify each item uniquely otherwise it will struggle to compare view hierarchies to figure out what has changed.\n\nIn our current code, we have this:\n\nForEach(expenses.items, id: \\.name) { item in Text(item.name) } .onDelete(perform: removeItems)\n\nIn English, that means “create a new row for every item in the expense items, identified uniquely by its name, showing that name in the row, and calling the removeItems() method to delete it.”\n\nThen, later, we have this code:\n\nButton(\"Add Expense\", systemImage: \"plus\") { let expense = ExpenseItem(name: \"Test\", type: \"Personal\", amount: 5) expenses.items.append(expense) }\n\nEvery time that button is pressed, it adds a test expense to our list, so we can make sure adding and deleting works.\n\nCan you see the problem?\n\nEvery time we create an example expense item we’re using the name “Test”, but we’ve also told SwiftUI that it can use the expense name as a unique identifier. So, when our code runs and we delete an item, SwiftUI looks at the array beforehand – “Test”, “Test”, “Test”, “Test” – then looks at the array afterwards – “Test”, “Test”, “Test” – and can’t easily tell what changed. Something has changed, because one item has disappeared, but SwiftUI can’t be sure which.\n\nIn this situation we’re lucky, because List knows exactly which row we were swiping on, but in many other places that extra information won’t be available and our app will start to behave strangely.\n\nThis is a logic error on our behalf: our code is fine, and it doesn’t crash at runtime, but we’ve applied the wrong logic to get to that end result – we’ve told SwiftUI that something will be a unique identifier, when it isn’t unique at all.\n\nTo fix this we need to think more about our ExpenseItem struct. Right now it has three properties: name, type, and amount. The name by itself might be unique in practice, but it’s also likely not to be – as soon as the user enters “Lunch” twice we’ll start hitting problems. We could perhaps try to combine the name, type and amount into a new computed property, but even then we’re just delaying the inevitable; it’s still not really unique.\n\nThe smart solution here is to add something to ExpenseItem that is unique, such as an ID number that we assign by hand. That would work, but it does mean tracking the last number we assigned so we don’t use duplicates there either.\n\nThere is in fact an easier solution, and it’s called UUID – short for “universally unique identifier”, and if that doesn’t sound unique I’m not sure what does.\n\nUUIDs are long hexadecimal strings such as this one: 08B15DB4-2F02-4AB8-A965-67A9C90D8A44. So, that’s eight digits, four digits, four digits, four digits, then twelve digits, of which the only requirement is that there’s a 4 in the first number of the third block. If we subtract the fixed 4, we end up with 31 digits, each of which can be one of 16 values – if we generated 1 UUID every second for a billion years, we might begin to have the slightest chance of generating a duplicate.\n\nNow, we could update ExpenseItem to have a UUID property like this:\n\nstruct ExpenseItem { let id: UUID let name: String let type: String let amount: Double }\n\nAnd that would work. However, it would also mean we need to generate a UUID by hand, then load and save the UUID along with our other data. So, in this instance we’re going to ask Swift to generate a UUID automatically for us like this:\n\nstruct ExpenseItem { let id = UUID() let name: String let type: String let amount: Double }\n\nNow we don’t need to worry about the id value of our expense items – Swift will make sure they are always unique.\n\nWith that in place we can now fix our ForEach, like this:\n\nForEach(expenses.items, id: \\.id) { item in Text(item.name) }\n\nIf you run the app now you’ll see our problem is fixed: SwiftUI can now see exactly which expense item got deleted, and will animate everything correctly.\n\nWe’re not done with this step quite yet, though. Instead, I’d like you to modify the ExpenseItem to make it conform to a new protocol called Identifiable, like this:\n\nstruct ExpenseItem: Identifiable { let id = UUID() let name: String let type: String let amount: Double }\n\nAll we’ve done is add Identifiable to the list of protocol conformances, nothing more. This is one of the protocols built into Swift, and means “this type can be identified uniquely.” It has only one requirement, which is that there must be a property called id that contains a unique identifier. We just added that, so we don’t need to do any extra work – our type conforms to Identifiable just fine.\n\nNow, you might wonder why we added that, because our code was working fine before. Well, because our expense items are now guaranteed to be identifiable uniquely, we no longer need to tell ForEach which property to use for the identifier – it knows there will be an id property and that it will be unique, because that’s the point of the Identifiable protocol.\n\nSo, as a result of this change we can modify the ForEach again, to this:\n\nForEach(expenses.items) { item in Text(item.name) }\n\nMuch better!"
    }
}