{
    "id": "dbpedia_8287_3",
    "rank": 90,
    "data": {
        "url": "https://docs.pydantic.dev/latest/concepts/models/",
        "read_more_link": "",
        "language": "en",
        "title": "Pydantic",
        "top_image": "https://docs.pydantic.dev/latest/favicon.png",
        "meta_img": "https://docs.pydantic.dev/latest/favicon.png",
        "images": [
            "https://docs.pydantic.dev/latest/logo-white.svg",
            "https://docs.pydantic.dev/latest/logo-white.svg",
            "https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.0.3/assets/svg/274c.svg",
            "https://cdn.jsdelivr.net/gh/jdecked/twemoji@15.0.3/assets/svg/2705.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Data validation using Python type hints",
        "meta_lang": "en",
        "meta_favicon": "../../favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://docs.pydantic.dev/latest/concepts/models/",
        "text": "Models\n\nAPI Documentation\n\npydantic.main.BaseModel\n\nOne of the primary ways of defining schema in Pydantic is via models. Models are simply classes which inherit from pydantic.BaseModel and define fields as annotated attributes.\n\nYou can think of models as similar to structs in languages like C, or as the requirements of a single endpoint in an API.\n\nModels share many similarities with Python's dataclasses, but have been designed with some subtle-yet-important differences that streamline certain workflows related to validation, serialization, and JSON schema generation. You can find more discussion of this in the Dataclasses section of the docs.\n\nUntrusted data can be passed to a model and, after parsing and validation, Pydantic guarantees that the fields of the resultant model instance will conform to the field types defined on the model.\n\nBasic model usage¶\n\nIn this example, User is a model with two fields:\n\nid, which is an integer and is required\n\nname, which is a string and is not required (it has a default value).\n\nIn this example, user is an instance of User. Initialization of the object will perform all parsing and validation. If no ValidationError is raised, you know the resulting model instance is valid.\n\nMore details on pydantic's coercion logic can be found in Data Conversion. Fields of a model can be accessed as normal attributes of the user object. The string '123' has been converted into an int as per the field type.\n\nname wasn't set when user was initialized, so it has the default value.\n\nThe fields which were supplied when user was initialized.\n\nEither .model_dump() or dict(user) will provide a dict of fields, but .model_dump() can take numerous other arguments. (Note that dict(user) will not recursively convert nested models into dicts, but .model_dump() will.)\n\nBy default, models are mutable and field values can be changed through attribute assignment.\n\nModel methods and properties¶\n\nThe example above only shows the tip of the iceberg of what models can do. Models possess the following methods and attributes:\n\nmodel_computed_fields: a dictionary of the computed fields of this model instance.\n\nmodel_construct(): a class method for creating models without running validation. See Creating models without validation.\n\nmodel_copy(): returns a copy (by default, shallow copy) of the model. See Serialization.\n\nmodel_dump(): returns a dictionary of the model's fields and values. See Serialization.\n\nmodel_dump_json(): returns a JSON string representation of model_dump(). See Serialization.\n\nmodel_extra: get extra fields set during validation.\n\nmodel_fields_set: set of fields which were set when the model instance was initialized.\n\nmodel_json_schema(): returns a jsonable dictionary representing the model as JSON Schema. See JSON Schema.\n\nmodel_parametrized_name(): compute the class name for parametrizations of generic classes.\n\nmodel_post_init(): perform additional initialization after the model is initialized.\n\nmodel_rebuild(): rebuild the model schema, which also supports building recursive generic models. See Rebuild model schema.\n\nmodel_validate(): a utility for loading any object into a model. See Helper functions.\n\nmodel_validate_json(): a utility for validating the given JSON data against the Pydantic model. See Helper functions.\n\nNested models¶\n\nMore complex hierarchical data structures can be defined using models themselves as types in annotations.\n\nFor self-referencing models, see postponed annotations.\n\nRebuild model schema¶\n\nThe model schema can be rebuilt using model_rebuild(). This is useful for building recursive generic models.\n\nPydantic tries to determine when this is necessary automatically and error if it wasn't done, but you may want to call model_rebuild() proactively when dealing with recursive models or generics.\n\nIn V2, model_rebuild() replaced update_forward_refs() from V1. There are some slight differences with the new behavior. The biggest change is that when calling model_rebuild() on the outermost model, it builds a core schema used for validation of the whole model (nested models and all), so all types at all levels need to be ready before model_rebuild() is called.\n\nArbitrary class instances¶\n\n(Formerly known as \"ORM Mode\"/from_orm.)\n\nPydantic models can also be created from arbitrary class instances by reading the instance attributes corresponding to the model field names. One common application of this functionality is integration with object-relational mappings (ORMs).\n\nTo do this, set the config attribute model_config['from_attributes'] = True. See Model Config and ConfigDict for more information.\n\nThe example here uses SQLAlchemy, but the same approach should work for any ORM.\n\nReserved names¶\n\nYou may want to name a Column after a reserved SQLAlchemy field. In that case, Field aliases will be convenient:\n\nNote\n\nThe example above works because aliases have priority over field names for field population. Accessing SQLModel's metadata attribute would lead to a ValidationError.\n\nNested attributes¶\n\nWhen using attributes to parse models, model instances will be created from both top-level attributes and deeper-nested attributes as appropriate.\n\nHere is an example demonstrating the principle:\n\nError handling¶\n\nPydantic will raise ValidationError whenever it finds an error in the data it's validating.\n\nA single exception of type ValidationError will be raised regardless of the number of errors found, and that ValidationError will contain information about all of the errors and how they happened.\n\nSee Error Handling for details on standard and custom errors.\n\nAs a demonstration:\n\nHelper functions¶\n\nPydantic provides three classmethod helper functions on models for parsing data:\n\nmodel_validate(): this is very similar to the __init__ method of the model, except it takes a dict or an object rather than keyword arguments. If the object passed cannot be validated, or if it's not a dictionary or instance of the model in question, a ValidationError will be raised.\n\nmodel_validate_json(): this takes a str or bytes and parses it as json, then passes the result to model_validate().\n\nmodel_validate_strings(): this takes a dict (can be nested) with string keys and values and validates the data in json mode so that said strings can be coerced into the correct types.\n\nIf you want to validate serialized data in a format other than JSON, you should load the data into a dict yourself and then pass it to model_validate.\n\nNote\n\nLearn more about JSON parsing in the JSON section of the docs.\n\nCreating models without validation¶\n\nPydantic also provides the model_construct() method, which allows models to be created without validation. This can be useful in at least a few cases:\n\nwhen working with complex data that is already known to be valid (for performance reasons)\n\nwhen one or more of the validator functions are non-idempotent, or\n\nwhen one or more of the validator functions have side effects that you don't want to be triggered.\n\nThe _fields_set keyword argument to model_construct() is optional, but allows you to be more precise about which fields were originally set and which weren't. If it's omitted model_fields_set will just be the keys of the data provided.\n\nFor example, in the example above, if _fields_set was not provided, new_user.model_fields_set would be {'id', 'age', 'name'}.\n\nNote that for subclasses of RootModel, the root value can be passed to model_construct() positionally, instead of using a keyword argument.\n\nHere are some additional notes on the behavior of model_construct():\n\nWhen we say \"no validation is performed\" — this includes converting dicts to model instances. So if you have a field with a Model type, you will need to convert the inner dict to a model yourself before passing it to model_construct().\n\nIn particular, the model_construct() method does not support recursively constructing models from dicts.\n\nIf you do not pass keyword arguments for fields with defaults, the default values will still be used.\n\nFor models with private attributes, the __pydantic_private__ dict will be initialized the same as it would be when calling __init__.\n\nWhen constructing an instance using model_construct(), no __init__ method from the model or any of its parent classes will be called, even when a custom __init__ method is defined.\n\nGeneric models¶\n\nPydantic supports the creation of generic models to make it easier to reuse a common model structure.\n\nIn order to declare a generic model, you perform the following steps:\n\nDeclare one or more typing.TypeVar instances to use to parameterize your model.\n\nDeclare a pydantic model that inherits from pydantic.BaseModel and typing.Generic, where you pass the TypeVar instances as parameters to typing.Generic.\n\nUse the TypeVar instances as annotations where you will want to replace them with other types or pydantic models.\n\nHere is an example using a generic BaseModel subclass to create an easily-reused HTTP response payload wrapper:\n\nIf you set the model_config or make use of @field_validator or other Pydantic decorators in your generic model definition, they will be applied to parametrized subclasses in the same way as when inheriting from a BaseModel subclass. Any methods defined on your generic class will also be inherited.\n\nPydantic's generics also integrate properly with type checkers, so you get all the type checking you would expect if you were to declare a distinct type for each parametrization.\n\nNote\n\nInternally, Pydantic creates subclasses of BaseModel at runtime when generic models are parametrized. These classes are cached, so there should be minimal overhead introduced by the use of generics models.\n\nTo inherit from a generic model and preserve the fact that it is generic, the subclass must also inherit from typing.Generic:\n\nYou can also create a generic subclass of a BaseModel that partially or fully replaces the type parameters in the superclass:\n\nIf the name of the concrete subclasses is important, you can also override the default name generation:\n\nYou can use parametrized generic models as types in other models:\n\nTip\n\nWhen using a parametrized generic model as a type in another model (like product: ResponseModel[Product]), make sure to parametrize said generic model when you initialize the model instance (like response = ResponseModel[Product](content=product)). If you don't, a ValidationError will be raised, as Pydantic doesn't infer the type of the generic model based on the data passed to it.\n\nUsing the same TypeVar in nested models allows you to enforce typing relationships at different points in your model:\n\nWhen using bound type parameters, and when leaving type parameters unspecified, Pydantic treats generic models similarly to how it treats built-in generic types like List and Dict:\n\nIf you don't specify parameters before instantiating the generic model, they are validated as the bound of the TypeVar.\n\nIf the TypeVars involved have no bounds, they are treated as Any.\n\nAlso, like List and Dict, any parameters specified using a TypeVar can later be substituted with concrete types:\n\nWarning\n\nWhile it may not raise an error, we strongly advise against using parametrized generics in isinstance checks.\n\nFor example, you should not do isinstance(my_model, MyGenericModel[int]). However, it is fine to do isinstance(my_model, MyGenericModel). (Note that, for standard generics, it would raise an error to do a subclass check with a parameterized generic.)\n\nIf you need to perform isinstance checks against parametrized generics, you can do this by subclassing the parametrized generic class. This looks like class MyIntModel(MyGenericModel[int]): ... and isinstance(my_model, MyIntModel).\n\nIf a Pydantic model is used in a TypeVar bound and the generic type is never parametrized then Pydantic will use the bound for validation but treat the value as Any in terms of serialization:\n\nHere's another example of the above behavior, enumerating all permutations regarding bound specification and generic type parametrization:\n\nIf you use a default=... (available in Python >= 3.13 or via typing-extensions) or constraints (TypeVar('T', str, int); note that you rarely want to use this form of a TypeVar) then the default value or constraints will be used for both validation and serialization if the type variable is not parametrized. You can override this behavior using pydantic.SerializeAsAny:\n\nNote\n\nNote, you may run into a bit of trouble if you don't parametrize a generic when the case of validating against the generic's bound could cause data loss. See the example below:\n\nWhen the generic isn't parametrized, the input data is validated against the generic bound. Given that ItemBase has no fields, the item field information is lost.\n\nIn this case, the runtime type information is provided explicitly via the generic parametrization, so the input data is validated against the IntItem class and the serialization output matches what's expected.\n\nDynamic model creation¶\n\nAPI Documentation\n\npydantic.main.create_model\n\nThere are some occasions where it is desirable to create a model using runtime information to specify the fields. For this Pydantic provides the create_model function to allow models to be created on the fly:\n\nHere StaticFoobarModel and DynamicFoobarModel are identical.\n\nFields are defined by one of the following tuple forms:\n\n(<type>, <default value>)\n\n(<type>, Field(...))\n\ntyping.Annotated[<type>, Field(...)]\n\nUsing a Field(...) call as the second argument in the tuple (the default value) allows for more advanced field configuration. Thus, the following are analogous:\n\nThe special keyword arguments __config__ and __base__ can be used to customize the new model. This includes extending a base model with extra fields.\n\nYou can also add validators by passing a dict to the __validators__ argument.\n\nRootModel and custom root types¶\n\nAPI Documentation\n\npydantic.root_model.RootModel\n\nPydantic models can be defined with a \"custom root type\" by subclassing pydantic.RootModel.\n\nThe root type can be any type supported by Pydantic, and is specified by the generic parameter to RootModel. The root value can be passed to the model __init__ or model_validate via the first and only argument.\n\nHere's an example of how this works:\n\nIf you want to access items in the root field directly or to iterate over the items, you can implement custom __iter__ and __getitem__ functions, as shown in the following example.\n\nYou can also create subclasses of the parametrized root model directly:\n\nFaux immutability¶\n\nModels can be configured to be immutable via model_config['frozen'] = True. When this is set, attempting to change the values of instance attributes will raise errors. See the API reference for more details.\n\nNote\n\nThis behavior was achieved in Pydantic V1 via the config setting allow_mutation = False. This config flag is deprecated in Pydantic V2, and has been replaced with frozen.\n\nWarning\n\nIn Python, immutability is not enforced. Developers have the ability to modify objects that are conventionally considered \"immutable\" if they choose to do so.\n\nTrying to change a caused an error, and a remains unchanged. However, the dict b is mutable, and the immutability of foobar doesn't stop b from being changed.\n\nAbstract base classes¶\n\nPydantic models can be used alongside Python's Abstract Base Classes (ABCs).\n\nField ordering¶\n\nField order affects models in the following ways:\n\nfield order is preserved in the model schema\n\nfield order is preserved in validation errors\n\nfield order is preserved by .model_dump() and .model_dump_json() etc.\n\nRequired fields¶\n\nTo declare a field as required, you may declare it using an annotation, or an annotation in combination with a Field specification. You may also use Ellipsis/... to emphasize that a field is required, especially when using the Field constructor.\n\nThe Field function is primarily used to configure settings like alias or description for an attribute. The constructor supports Ellipsis/... as the sole positional argument. This is used as a way to indicate that said field is mandatory, though it's the type hint that enforces this requirement.\n\nHere a, b and c are all required. However, this use of b: int = ... does not work properly with mypy, and as of v1.0 should be avoided in most cases.\n\nNote\n\nIn Pydantic V1, fields annotated with Optional or Any would be given an implicit default of None even if no default was explicitly specified. This behavior has changed in Pydantic V2, and there are no longer any type annotations that will result in a field having an implicit default value.\n\nSee the migration guide for more details on changes to required and nullable fields.\n\nFields with non-hashable default values¶\n\nA common source of bugs in python is to use a mutable object as a default value for a function or method argument, as the same instance ends up being reused in each call.\n\nThe dataclasses module actually raises an error in this case, indicating that you should use the default_factory argument to dataclasses.field.\n\nPydantic also supports the use of a default_factory for non-hashable default values, but it is not required. In the event that the default value is not hashable, Pydantic will deepcopy the default value when creating each instance of the model:\n\nFields with dynamic default values¶\n\nWhen declaring a field with a default value, you may want it to be dynamic (i.e. different for each model). To do this, you may want to use a default_factory.\n\nHere is an example:\n\nYou can find more information in the documentation of the Field function.\n\nAutomatically excluded attributes¶\n\nClass vars¶\n\nAttributes annotated with typing.ClassVar are properly treated by Pydantic as class variables, and will not become fields on model instances:\n\nPrivate model attributes¶\n\nAPI Documentation\n\npydantic.fields.PrivateAttr\n\nAttributes whose name has a leading underscore are not treated as fields by Pydantic, and are not included in the model schema. Instead, these are converted into a \"private attribute\" which is not validated or even set during calls to __init__, model_validate, etc.\n\nHere is an example of usage:\n\nPrivate attribute names must start with underscore to prevent conflicts with model fields. However, dunder names (such as __attr__) are not supported.\n\nData conversion¶\n\nPydantic may cast input data to force it to conform to model field types, and in some cases this may result in a loss of information. For example:\n\nThis is a deliberate decision of Pydantic, and is frequently the most useful approach. See here for a longer discussion on the subject.\n\nNevertheless, strict type checking is also supported.\n\nModel signature¶\n\nAll Pydantic models will have their signature generated based on their fields:\n\nAn accurate signature is useful for introspection purposes and libraries like FastAPI or hypothesis.\n\nThe generated signature will also respect custom __init__ functions:\n\nTo be included in the signature, a field's alias or name must be a valid Python identifier. Pydantic will prioritize a field's alias over its name when generating the signature, but may use the field name if the alias is not a valid Python identifier.\n\nIf a field's alias and name are both not valid identifiers (which may be possible through exotic use of create_model), a **data argument will be added. In addition, the **data argument will always be present in the signature if model_config['extra'] == 'allow'.\n\nStructural pattern matching¶\n\nPydantic supports structural pattern matching for models, as introduced by PEP 636 in Python 3.10.\n\nNote\n\nA match-case statement may seem as if it creates a new model, but don't be fooled; it is just syntactic sugar for getting an attribute and either comparing it or declaring and initializing it.\n\nAttribute copies¶\n\nIn many cases, arguments passed to the constructor will be copied in order to perform validation and, where necessary, coercion.\n\nIn this example, note that the ID of the list changes after the class is constructed because it has been copied during validation:\n\nExtra fields¶\n\nBy default, Pydantic models won't error when you provide data for unrecognized fields, they will just be ignored:\n\nIf you want this to raise an error, you can achieve this via model_config:\n\nTo instead preserve any extra data provided, you can set extra='allow'. The extra fields will then be stored in BaseModel.__pydantic_extra__:\n\nBy default, no validation will be applied to these extra items, but you can set a type for the values by overriding the type annotation for __pydantic_extra__:\n\nThe = Field(init=False) does not have any effect at runtime, but prevents the __pydantic_extra__ field from being treated as an argument to the model's __init__ method by type-checkers.\n\nThe same configurations apply to TypedDict and dataclass' except the config is controlled by setting the __pydantic_config__ attribute of the class to a valid ConfigDict."
    }
}