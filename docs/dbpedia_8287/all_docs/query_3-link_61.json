{
    "id": "dbpedia_8287_3",
    "rank": 61,
    "data": {
        "url": "https://scikit-learn.org/stable/modules/generated/sklearn.linear_model.LogisticRegression.html",
        "read_more_link": "",
        "language": "en",
        "title": "LogisticRegression",
        "top_image": "https://scikit-learn/stable/_images/sphx_glr_plot_release_highlights_1_5_0_thumb.png",
        "meta_img": "https://scikit-learn/stable/_images/sphx_glr_plot_release_highlights_1_5_0_thumb.png",
        "images": [
            "https://scikit-learn.org/stable/_static/scikit-learn-logo-small.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_1_5_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_1_3_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_1_1_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_1_0_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_0_24_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_0_23_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_release_highlights_0_22_0_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_calibration_curve_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_classification_probability_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_feature_transformation_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_voting_probas_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_select_from_model_diabetes_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_rfe_digits_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_rfe_with_cross_validation_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_sgd_comparison_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_l1_l2_sparsity_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_iris_logistic_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_sparse_logistic_regression_mnist_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_sparse_logistic_regression_20newsgroups_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_multinomial_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_logistic_path_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_pipeline_display_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_estimator_representation_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_set_output_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_display_object_visualization_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_likelihood_ratios_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_roc_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_tuned_decision_threshold_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_cost_sensitive_learning_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_classifier_chain_yeast_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_rbm_logistic_classification_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_column_transformer_mixed_types_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_digits_pipe_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_discretization_classification_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_digits_classification_exercise_thumb.png",
            "https://scikit-learn.org/stable/_images/sphx_glr_plot_document_classification_20newsgroups_thumb.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Gallery examples: Release Highlights for scikit-learn 1.5 Release Highlights for scikit-learn 1.3 Release Highlights for scikit-learn 1.1 Release Highlights for scikit-learn 1.0 Release Highlights ...",
        "meta_lang": "en",
        "meta_favicon": "../../_static/favicon.ico",
        "meta_site_name": "scikit-learn",
        "canonical_link": "https://scikit-learn/stable/modules/generated/sklearn.linear_model.LogisticRegression.html",
        "text": "classsklearn.linear_model.LogisticRegression(penalty='l2', *, dual=False, tol=0.0001, C=1.0, fit_intercept=True, intercept_scaling=1, class_weight=None, random_state=None, solver='lbfgs', max_iter=100, multi_class='deprecated', verbose=0, warm_start=False, n_jobs=None, l1_ratio=None)[source]#\n\nLogistic Regression (aka logit, MaxEnt) classifier.\n\nIn the multiclass case, the training algorithm uses the one-vs-rest (OvR) scheme if the ‘multi_class’ option is set to ‘ovr’, and uses the cross-entropy loss if the ‘multi_class’ option is set to ‘multinomial’. (Currently the ‘multinomial’ option is supported only by the ‘lbfgs’, ‘sag’, ‘saga’ and ‘newton-cg’ solvers.)\n\nThis class implements regularized logistic regression using the ‘liblinear’ library, ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ solvers. Note that regularization is applied by default. It can handle both dense and sparse input. Use C-ordered arrays or CSR matrices containing 64-bit floats for optimal performance; any other input format will be converted (and copied).\n\nThe ‘newton-cg’, ‘sag’, and ‘lbfgs’ solvers support only L2 regularization with primal formulation, or no regularization. The ‘liblinear’ solver supports both L1 and L2 regularization, with a dual formulation only for the L2 penalty. The Elastic-Net regularization is only supported by the ‘saga’ solver.\n\nRead more in the User Guide.\n\nParameters:\n\npenalty{‘l1’, ‘l2’, ‘elasticnet’, None}, default=’l2’\n\nSpecify the norm of the penalty:\n\nNone: no penalty is added;\n\n'l2': add a L2 penalty term and it is the default choice;\n\n'l1': add a L1 penalty term;\n\n'elasticnet': both L1 and L2 penalty terms are added.\n\nWarning\n\nSome penalties may not work with some solvers. See the parameter solver below, to know the compatibility between the penalty and solver.\n\nAdded in version 0.19: l1 penalty with SAGA solver (allowing ‘multinomial’ + L1)\n\ndualbool, default=False\n\nDual (constrained) or primal (regularized, see also this equation) formulation. Dual formulation is only implemented for l2 penalty with liblinear solver. Prefer dual=False when n_samples > n_features.\n\ntolfloat, default=1e-4\n\nTolerance for stopping criteria.\n\nCfloat, default=1.0\n\nInverse of regularization strength; must be a positive float. Like in support vector machines, smaller values specify stronger regularization.\n\nfit_interceptbool, default=True\n\nSpecifies if a constant (a.k.a. bias or intercept) should be added to the decision function.\n\nintercept_scalingfloat, default=1\n\nUseful only when the solver ‘liblinear’ is used and self.fit_intercept is set to True. In this case, x becomes [x, self.intercept_scaling], i.e. a “synthetic” feature with constant value equal to intercept_scaling is appended to the instance vector. The intercept becomes intercept_scaling * synthetic_feature_weight.\n\nNote! the synthetic feature weight is subject to l1/l2 regularization as all other features. To lessen the effect of regularization on synthetic feature weight (and therefore on the intercept) intercept_scaling has to be increased.\n\nclass_weightdict or ‘balanced’, default=None\n\nWeights associated with classes in the form {class_label: weight}. If not given, all classes are supposed to have weight one.\n\nThe “balanced” mode uses the values of y to automatically adjust weights inversely proportional to class frequencies in the input data as n_samples / (n_classes * np.bincount(y)).\n\nNote that these weights will be multiplied with sample_weight (passed through the fit method) if sample_weight is specified.\n\nAdded in version 0.17: class_weight=’balanced’\n\nrandom_stateint, RandomState instance, default=None\n\nUsed when solver == ‘sag’, ‘saga’ or ‘liblinear’ to shuffle the data. See Glossary for details.\n\nsolver{‘lbfgs’, ‘liblinear’, ‘newton-cg’, ‘newton-cholesky’, ‘sag’, ‘saga’}, default=’lbfgs’\n\nAlgorithm to use in the optimization problem. Default is ‘lbfgs’. To choose a solver, you might want to consider the following aspects:\n\nFor small datasets, ‘liblinear’ is a good choice, whereas ‘sag’ and ‘saga’ are faster for large ones;\n\nFor multiclass problems, only ‘newton-cg’, ‘sag’, ‘saga’ and ‘lbfgs’ handle multinomial loss;\n\n‘liblinear’ and ‘newton-cholesky’ can only handle binary classification by default. To apply a one-versus-rest scheme for the multiclass setting one can wrapt it with the OneVsRestClassifier.\n\n‘newton-cholesky’ is a good choice for n_samples >> n_features, especially with one-hot encoded categorical features with rare categories. Be aware that the memory usage of this solver has a quadratic dependency on n_features because it explicitly computes the Hessian matrix.\n\nWarning\n\nThe choice of the algorithm depends on the penalty chosen and on (multinomial) multiclass support:\n\nsolver\n\npenalty\n\nmultinomial multiclass\n\n‘lbfgs’\n\n‘l2’, None\n\nyes\n\n‘liblinear’\n\n‘l1’, ‘l2’\n\nno\n\n‘newton-cg’\n\n‘l2’, None\n\nyes\n\n‘newton-cholesky’\n\n‘l2’, None\n\nno\n\n‘sag’\n\n‘l2’, None\n\nyes\n\n‘saga’\n\n‘elasticnet’, ‘l1’, ‘l2’, None\n\nyes\n\nNote\n\n‘sag’ and ‘saga’ fast convergence is only guaranteed on features with approximately the same scale. You can preprocess the data with a scaler from sklearn.preprocessing.\n\nSee also\n\nRefer to the User Guide for more information regarding LogisticRegression and more specifically the Table summarizing solver/penalty supports.\n\nAdded in version 0.17: Stochastic Average Gradient descent solver.\n\nAdded in version 0.19: SAGA solver.\n\nChanged in version 0.22: The default solver changed from ‘liblinear’ to ‘lbfgs’ in 0.22.\n\nAdded in version 1.2: newton-cholesky solver.\n\nmax_iterint, default=100\n\nMaximum number of iterations taken for the solvers to converge.\n\nmulti_class{‘auto’, ‘ovr’, ‘multinomial’}, default=’auto’\n\nIf the option chosen is ‘ovr’, then a binary problem is fit for each label. For ‘multinomial’ the loss minimised is the multinomial loss fit across the entire probability distribution, even when the data is binary. ‘multinomial’ is unavailable when solver=’liblinear’. ‘auto’ selects ‘ovr’ if the data is binary, or if solver=’liblinear’, and otherwise selects ‘multinomial’.\n\nAdded in version 0.18: Stochastic Average Gradient descent solver for ‘multinomial’ case.\n\nChanged in version 0.22: Default changed from ‘ovr’ to ‘auto’ in 0.22.\n\nDeprecated since version 1.5: multi_class was deprecated in version 1.5 and will be removed in 1.7. From then on, the recommended ‘multinomial’ will always be used for n_classes >= 3. Solvers that do not support ‘multinomial’ will raise an error. Use sklearn.multiclass.OneVsRestClassifier(LogisticRegression()) if you still want to use OvR.\n\nverboseint, default=0\n\nFor the liblinear and lbfgs solvers set verbose to any positive number for verbosity.\n\nwarm_startbool, default=False\n\nWhen set to True, reuse the solution of the previous call to fit as initialization, otherwise, just erase the previous solution. Useless for liblinear solver. See the Glossary.\n\nAdded in version 0.17: warm_start to support lbfgs, newton-cg, sag, saga solvers.\n\nn_jobsint, default=None\n\nNumber of CPU cores used when parallelizing over classes if multi_class=’ovr’”. This parameter is ignored when the solver is set to ‘liblinear’ regardless of whether ‘multi_class’ is specified or not. None means 1 unless in a joblib.parallel_backend context. -1 means using all processors. See Glossary for more details.\n\nl1_ratiofloat, default=None\n\nThe Elastic-Net mixing parameter, with 0 <= l1_ratio <= 1. Only used if penalty='elasticnet'. Setting l1_ratio=0 is equivalent to using penalty='l2', while setting l1_ratio=1 is equivalent to using penalty='l1'. For 0 < l1_ratio <1, the penalty is a combination of L1 and L2.\n\nAttributes:\n\nclasses_ndarray of shape (n_classes, )\n\nA list of class labels known to the classifier.\n\ncoef_ndarray of shape (1, n_features) or (n_classes, n_features)\n\nCoefficient of the features in the decision function.\n\ncoef_ is of shape (1, n_features) when the given problem is binary. In particular, when multi_class='multinomial', coef_ corresponds to outcome 1 (True) and -coef_ corresponds to outcome 0 (False).\n\nintercept_ndarray of shape (1,) or (n_classes,)\n\nIntercept (a.k.a. bias) added to the decision function.\n\nIf fit_intercept is set to False, the intercept is set to zero. intercept_ is of shape (1,) when the given problem is binary. In particular, when multi_class='multinomial', intercept_ corresponds to outcome 1 (True) and -intercept_ corresponds to outcome 0 (False).\n\nn_features_in_int\n\nNumber of features seen during fit.\n\nAdded in version 0.24.\n\nfeature_names_in_ndarray of shape (n_features_in_,)\n\nNames of features seen during fit. Defined only when X has feature names that are all strings.\n\nAdded in version 1.0.\n\nn_iter_ndarray of shape (n_classes,) or (1, )\n\nActual number of iterations for all classes. If binary or multinomial, it returns only 1 element. For liblinear solver, only the maximum number of iteration across all classes is given.\n\nChanged in version 0.20: In SciPy <= 1.0.0 the number of lbfgs iterations may exceed max_iter. n_iter_ will now report at most max_iter.\n\nSee also\n\nSGDClassifier\n\nIncrementally trained logistic regression (when given the parameter loss=\"log_loss\").\n\nLogisticRegressionCV\n\nLogistic regression with built-in cross validation.\n\nNotes\n\nThe underlying C implementation uses a random number generator to select features when fitting the model. It is thus not uncommon, to have slightly different results for the same input data. If that happens, try with a smaller tol parameter.\n\nPredict output may not match that of standalone liblinear in certain cases. See differences from liblinear in the narrative documentation.\n\nReferences\n\nL-BFGS-B – Software for Large-scale Bound-constrained Optimization\n\nCiyou Zhu, Richard Byrd, Jorge Nocedal and Jose Luis Morales. http://users.iems.northwestern.edu/~nocedal/lbfgsb.html\n\nLIBLINEAR – A Library for Large Linear Classification\n\nhttps://www.csie.ntu.edu.tw/~cjlin/liblinear/\n\nSAG – Mark Schmidt, Nicolas Le Roux, and Francis Bach\n\nMinimizing Finite Sums with the Stochastic Average Gradient https://hal.inria.fr/hal-00860051/document\n\nSAGA – Defazio, A., Bach F. & Lacoste-Julien S. (2014).\n\n“SAGA: A Fast Incremental Gradient Method With Support for Non-Strongly Convex Composite Objectives”\n\nHsiang-Fu Yu, Fang-Lan Huang, Chih-Jen Lin (2011). Dual coordinate descent\n\nmethods for logistic regression and maximum entropy models. Machine Learning 85(1-2):41-75. https://www.csie.ntu.edu.tw/~cjlin/papers/maxent_dual.pdf\n\nExamples\n\n>>> from sklearn.datasets import load_iris >>> from sklearn.linear_model import LogisticRegression >>> X, y = load_iris(return_X_y=True) >>> clf = LogisticRegression(random_state=0).fit(X, y) >>> clf.predict(X[:2, :]) array([0, 0]) >>> clf.predict_proba(X[:2, :]) array([[9.8...e-01, 1.8...e-02, 1.4...e-08], [9.7...e-01, 2.8...e-02, ...e-08]]) >>> clf.score(X, y) 0.97...\n\ndecision_function(X)[source]#\n\nPredict confidence scores for samples.\n\nThe confidence score for a sample is proportional to the signed distance of that sample to the hyperplane.\n\nParameters:\n\nX{array-like, sparse matrix} of shape (n_samples, n_features)\n\nThe data matrix for which we want to get the confidence scores.\n\nReturns:\n\nscoresndarray of shape (n_samples,) or (n_samples, n_classes)\n\nConfidence scores per (n_samples, n_classes) combination. In the binary case, confidence score for self.classes_[1] where >0 means this class would be predicted.\n\ndensify()[source]#\n\nConvert coefficient matrix to dense array format.\n\nConverts the coef_ member (back) to a numpy.ndarray. This is the default format of coef_ and is required for fitting, so calling this method is only required on models that have previously been sparsified; otherwise, it is a no-op.\n\nReturns:\n\nself\n\nFitted estimator.\n\nfit(X, y, sample_weight=None)[source]#\n\nFit the model according to the given training data.\n\nParameters:\n\nX{array-like, sparse matrix} of shape (n_samples, n_features)\n\nTraining vector, where n_samples is the number of samples and n_features is the number of features.\n\nyarray-like of shape (n_samples,)\n\nTarget vector relative to X.\n\nsample_weightarray-like of shape (n_samples,) default=None\n\nArray of weights that are assigned to individual samples. If not provided, then each sample is given unit weight.\n\nAdded in version 0.17: sample_weight support to LogisticRegression.\n\nReturns:\n\nself\n\nFitted estimator.\n\nNotes\n\nThe SAGA solver supports both float64 and float32 bit arrays.\n\nget_metadata_routing()[source]#\n\nGet metadata routing of this object.\n\nPlease check User Guide on how the routing mechanism works.\n\nReturns:\n\nroutingMetadataRequest\n\nA MetadataRequest encapsulating routing information.\n\nget_params(deep=True)[source]#\n\nGet parameters for this estimator.\n\nParameters:\n\ndeepbool, default=True\n\nIf True, will return the parameters for this estimator and contained subobjects that are estimators.\n\nReturns:\n\nparamsdict\n\nParameter names mapped to their values.\n\npredict(X)[source]#\n\nPredict class labels for samples in X.\n\nParameters:\n\nX{array-like, sparse matrix} of shape (n_samples, n_features)\n\nThe data matrix for which we want to get the predictions.\n\nReturns:\n\ny_predndarray of shape (n_samples,)\n\nVector containing the class labels for each sample.\n\npredict_log_proba(X)[source]#\n\nPredict logarithm of probability estimates.\n\nThe returned estimates for all classes are ordered by the label of classes.\n\nParameters:\n\nXarray-like of shape (n_samples, n_features)\n\nVector to be scored, where n_samples is the number of samples and n_features is the number of features.\n\nReturns:\n\nTarray-like of shape (n_samples, n_classes)\n\nReturns the log-probability of the sample for each class in the model, where classes are ordered as they are in self.classes_.\n\npredict_proba(X)[source]#\n\nProbability estimates.\n\nThe returned estimates for all classes are ordered by the label of classes.\n\nFor a multi_class problem, if multi_class is set to be “multinomial” the softmax function is used to find the predicted probability of each class. Else use a one-vs-rest approach, i.e. calculate the probability of each class assuming it to be positive using the logistic function and normalize these values across all the classes.\n\nParameters:\n\nXarray-like of shape (n_samples, n_features)\n\nVector to be scored, where n_samples is the number of samples and n_features is the number of features.\n\nReturns:\n\nTarray-like of shape (n_samples, n_classes)\n\nReturns the probability of the sample for each class in the model, where classes are ordered as they are in self.classes_.\n\nset_params(**params)[source]#\n\nSet the parameters of this estimator.\n\nThe method works on simple estimators as well as on nested objects (such as Pipeline). The latter have parameters of the form <component>__<parameter> so that it’s possible to update each component of a nested object.\n\nParameters:\n\n**paramsdict\n\nEstimator parameters.\n\nReturns:\n\nselfestimator instance\n\nEstimator instance.\n\nset_score_request(*, sample_weight:bool|None|str='$UNCHANGED$') → LogisticRegression[source]#\n\nRequest metadata passed to the score method.\n\nNote that this method is only relevant if enable_metadata_routing=True (see sklearn.set_config). Please see User Guide on how the routing mechanism works.\n\nThe options for each parameter are:\n\nTrue: metadata is requested, and passed to score if provided. The request is ignored if metadata is not provided.\n\nFalse: metadata is not requested and the meta-estimator will not pass it to score.\n\nNone: metadata is not requested, and the meta-estimator will raise an error if the user provides it.\n\nstr: metadata should be passed to the meta-estimator with this given alias instead of the original name.\n\nThe default (sklearn.utils.metadata_routing.UNCHANGED) retains the existing request. This allows you to change the request for some parameters and not others.\n\nAdded in version 1.3.\n\nNote\n\nThis method is only relevant if this estimator is used as a sub-estimator of a meta-estimator, e.g. used inside a Pipeline. Otherwise it has no effect.\n\nParameters:\n\nsample_weightstr, True, False, or None, default=sklearn.utils.metadata_routing.UNCHANGED\n\nMetadata routing for sample_weight parameter in score.\n\nReturns:\n\nselfobject\n\nThe updated object.\n\nsparsify()[source]#\n\nConvert coefficient matrix to sparse format.\n\nConverts the coef_ member to a scipy.sparse matrix, which for L1-regularized models can be much more memory- and storage-efficient than the usual numpy.ndarray representation.\n\nThe intercept_ member is not converted.\n\nReturns:\n\nself\n\nFitted estimator.\n\nNotes\n\nFor non-sparse models, i.e. when there are not many zeros in coef_, this may actually increase memory usage, so use this method with care. A rule of thumb is that the number of zero elements, which can be computed with (coef_ == 0).sum(), must be more than 50% for this to provide significant benefits.\n\nAfter calling this method, further fitting with the partial_fit method (if any) will not work until you call densify.\n\nGallery examples#\n\nRelease Highlights for scikit-learn 1.5\n\nRelease Highlights for scikit-learn 1.5\n\nRelease Highlights for scikit-learn 1.3\n\nRelease Highlights for scikit-learn 1.3\n\nRelease Highlights for scikit-learn 1.1\n\nRelease Highlights for scikit-learn 1.1\n\nRelease Highlights for scikit-learn 1.0\n\nRelease Highlights for scikit-learn 1.0\n\nRelease Highlights for scikit-learn 0.24\n\nRelease Highlights for scikit-learn 0.24\n\nRelease Highlights for scikit-learn 0.23\n\nRelease Highlights for scikit-learn 0.23\n\nRelease Highlights for scikit-learn 0.22\n\nRelease Highlights for scikit-learn 0.22\n\nProbability Calibration curves\n\nProbability Calibration curves\n\nPlot classification probability\n\nPlot classification probability\n\nFeature transformations with ensembles of trees\n\nFeature transformations with ensembles of trees\n\nPlot class probabilities calculated by the VotingClassifier\n\nPlot class probabilities calculated by the VotingClassifier\n\nModel-based and sequential feature selection\n\nModel-based and sequential feature selection\n\nRecursive feature elimination\n\nRecursive feature elimination\n\nRecursive feature elimination with cross-validation\n\nRecursive feature elimination with cross-validation\n\nComparing various online solvers\n\nComparing various online solvers\n\nL1 Penalty and Sparsity in Logistic Regression\n\nL1 Penalty and Sparsity in Logistic Regression\n\nLogistic Regression 3-class Classifier\n\nLogistic Regression 3-class Classifier\n\nLogistic function\n\nLogistic function\n\nMNIST classification using multinomial logistic + L1\n\nMNIST classification using multinomial logistic + L1\n\nMulticlass sparse logistic regression on 20newgroups\n\nMulticlass sparse logistic regression on 20newgroups\n\nPlot multinomial and One-vs-Rest Logistic Regression\n\nPlot multinomial and One-vs-Rest Logistic Regression\n\nRegularization path of L1- Logistic Regression\n\nRegularization path of L1- Logistic Regression\n\nDisplaying Pipelines\n\nDisplaying Pipelines\n\nDisplaying estimators and complex pipelines\n\nDisplaying estimators and complex pipelines\n\nIntroducing the set_output API\n\nIntroducing the set_output API\n\nVisualizations with Display Objects\n\nVisualizations with Display Objects\n\nClass Likelihood Ratios to measure classification performance\n\nClass Likelihood Ratios to measure classification performance\n\nMulticlass Receiver Operating Characteristic (ROC)\n\nMulticlass Receiver Operating Characteristic (ROC)\n\nPost-hoc tuning the cut-off point of decision function\n\nPost-hoc tuning the cut-off point of decision function\n\nPost-tuning the decision threshold for cost-sensitive learning\n\nPost-tuning the decision threshold for cost-sensitive learning\n\nMultilabel classification using a classifier chain\n\nMultilabel classification using a classifier chain\n\nRestricted Boltzmann Machine features for digit classification\n\nRestricted Boltzmann Machine features for digit classification\n\nColumn Transformer with Mixed Types\n\nColumn Transformer with Mixed Types\n\nPipelining: chaining a PCA and a logistic regression\n\nPipelining: chaining a PCA and a logistic regression\n\nFeature discretization\n\nFeature discretization\n\nDigits Classification Exercise\n\nDigits Classification Exercise\n\nClassification of text documents using sparse features\n\nClassification of text documents using sparse features"
    }
}