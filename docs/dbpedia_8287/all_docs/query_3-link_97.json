{
    "id": "dbpedia_8287_3",
    "rank": 97,
    "data": {
        "url": "https://www.hackingwithswift.com/books/ios-swiftui/introducing-mvvm-into-your-swiftui-project",
        "read_more_link": "",
        "language": "en",
        "title": "Introducing MVVM into your SwiftUI project",
        "top_image": "https://www.hackingwithswift.com/favicon.svg",
        "meta_img": "https://www.hackingwithswift.com/favicon.svg",
        "images": [
            "https://www.hackingwithswift.com/img/logo-curves-ua.svg",
            "https://www.hackingwithswift.com/img/sponsors/superwall-light.svg",
            "https://www.hackingwithswift.com/img/hws-plus-footer-desktop.png",
            "https://www.hackingwithswift.com/img/covers-flat/pro-swift.png",
            "https://www.hackingwithswift.com/img/covers-flat/pro-swiftui.png",
            "https://www.hackingwithswift.com/img/covers-flat/patterns.png",
            "https://www.hackingwithswift.com/img/covers-flat/testing.png",
            "https://www.hackingwithswift.com/img/covers-flat/hws.png",
            "https://www.hackingwithswift.com/img/covers-flat/swiftcc.png",
            "https://www.hackingwithswift.com/img/covers-flat/sundays-1.png",
            "https://www.hackingwithswift.com/img/covers-flat/vapor.png",
            "https://www.hackingwithswift.com/img/covers-flat/advanced-ios-1.png",
            "https://www.hackingwithswift.com/img/covers-flat/advanced-ios-2.png",
            "https://www.hackingwithswift.com/img/covers-flat/advanced-ios-3.png",
            "https://www.hackingwithswift.com/img/covers-flat/watchos.png",
            "https://www.hackingwithswift.com/img/covers-flat/tvos.png",
            "https://www.hackingwithswift.com/img/covers-flat/macos.png",
            "https://www.hackingwithswift.com/img/covers-flat/spritekit.png",
            "https://www.hackingwithswift.com/img/covers-flat/sixty.png",
            "https://www.hackingwithswift.com/img/covers-flat/objc.png",
            "https://www.hackingwithswift.com/img/covers-flat/beyond-code.png",
            "https://www.hackingwithswift.com/img/unknown_user.png"
        ],
        "movies": [
            "https://www.youtube-nocookie.com/embed/7S6iEmHICkQ?rel=0"
        ],
        "keywords": [],
        "meta_keywords": [
            "hacking with swift",
            "swift 5",
            "swift",
            "swiftui",
            "swift ui",
            "tutorial",
            "ios",
            "ios 17",
            "ios 16",
            "ios 15",
            "wwdc",
            "apple",
            "ipad",
            "iphone",
            "free",
            "tutorial",
            "guide",
            "objective c",
            "watchos",
            "tvos",
            "macOS",
            "uikit",
            "visionos",
            "watchkit"
        ],
        "tags": null,
        "authors": [
            "Paul Hudson",
            "Paul Hudson @twostraws"
        ],
        "publish_date": "2024-04-11T00:00:00",
        "summary": "",
        "meta_description": "Learn Swift coding for iOS with these free tutorials",
        "meta_lang": "en",
        "meta_favicon": "/favicon.svg",
        "meta_site_name": "Hacking with Swift",
        "canonical_link": "https://www.hackingwithswift.com/books/ios-swiftui/introducing-mvvm-into-your-swiftui-project",
        "text": "Paul Hudson @twostraws April 11th 2024\n\nSo far I’ve introduced you to a range of concepts across Swift and SwiftUI, and I’ve also dropped a few tips on ways to organize your code better. Well, here I want to explore that latter part a bit further: we’re going to look at what is commonly called a software architecture, or the more grandiose name an architectural design pattern – really it’s just a particular way of structuring your code.\n\nThe pattern we’re going to look at is called MVVM, which is an acronym standing for Model View View-Model. This is a terrifically bad name, and thoroughly confuses people, but I’m afraid we’re rather stuck with it at this point. There is no single definition of what is MVVM, and you’ll find all sorts of people arguing about it online, but that’s okay – here we’re going to keep it simple, and use MVVM as a way of getting some of our program state and logic out of our view structs. We are, in effect, separating logic from layout.\n\nWe’ll explore that definition as we go, but for now let’s start with the big stuff: make a new Swift file called ContentView-ViewModel.swift, then give it an extra import for MapKit. We’re going to use this to create a new class that manages our data, and manipulates it on behalf of the ContentView struct so that our view doesn’t really care how the underlying data system works.\n\nWe’re going to start with two trivial things, then build our way up from there. First, create a new class that uses the Observable macro, so we’re able to report changes back to any SwiftUI view that’s watching:\n\n@Observable class ViewModel { }\n\nSecond, I want you to place that new class inside an extension on ContentView, like this:\n\nextension ContentView { @Observable class ViewModel { } }\n\nNow we’re saying this isn’t just any view model, it’s the view model for ContentView. Later on it will be your job to add a second view model to handle EditView, so you can try seeing how the concepts map elsewhere.\n\nTip: I get lots of questions about why I place my view models into view extensions, so I'd like to take a moment to explain why. This is a small app, but think about how this would look when you have 10 views, or 50 views, or even 500 views. If you use extensions like this, the view model for your current view is always just called ViewModel, and not EditMapLocationViewModel or similar – it's much shorter, and avoids cluttering up your code with lots of different class names!\n\nNow that we have our class in place, we get to choose which pieces of state from our view should be moved into the view model. Some people will tell you to move all of it, others will be more selective, and that’s okay – again, there is no single definition of what MVVM looks like, so I’m going to provide you with the tools and knowledge to experiment yourself.\n\nLet’s start with the easy stuff: move both @State properties in ContentView over to its view model, removing the @State private parts because they aren't needed any more:\n\nextension ContentView { @Observable class ViewModel { var locations = [Location]() var selectedPlace: Location? } }\n\nAnd now we can replace all those properties in ContentView with a single one:\n\n@State private var viewModel = ViewModel()\n\nTip: This is a good example of why placing view models inside extensions is helpful – we just say ViewModel and we automatically get the correct view model type for the current view.\n\nThat will of course break a lot of code, but the fixes are easy – just add viewModel in various places. So, locations becomes $viewModel.locations, and selectedPlace becomes $viewModel.selectedPlace.\n\nOnce you’ve added that everywhere your code will compile again, but you might wonder how this has helped – haven’t we just moved our code from one place to another? Well, yes, but there is an important distinction that will become clearer as your skills grow: having all this functionality in a separate class makes it much easier to write tests for your code.\n\nViews work best when they handle presentation of data, meaning that manipulation of data is a great candidate for code to move into a view model. With that in mind, if you have a look through your ContentView code you might notice two places our view does more work than it ought to: adding a new location and updating an existing location, both of which root around inside the internal data of our view model.\n\nReading data from a view model’s properties is usually fine, but writing it isn’t because the whole point of this exercise is to separate logic from layout. You can find these two places immediately if we clamp down on writing view model data – modify the locations property in your view model to this:\n\nprivate(set) var locations = [Location]()\n\nNow we’ve said that reading locations is fine, but only the class itself can write locations. Immediately Xcode will point out the two places where we need to get code out of the view: adding a new location, and updating an existing one.\n\nSo, we can start by adding a new method to the view model to handle adding a new location. First, add an import for CoreLocation to the top, then add this method to the class:\n\nfunc addLocation(at point: CLLocationCoordinate2D) { let newLocation = Location(id: UUID(), name: \"New location\", description: \"\", latitude: point.latitude, longitude: point.longitude) locations.append(newLocation) }\n\nThat can then be used from the tap gesture in ContentView:\n\n.onTapGesture { position in if let coordinate = proxy.convert(position, from: .local) { viewModel.addLocation(at: coordinate) } }\n\nThe second problematic place is updating a location, so I want you to cut that whole if let index check to your clipboard, then paste it into a new method in the view model, adding in a check that we have a selected place to work with:\n\nfunc update(location: Location) { guard let selectedPlace else { return } if let index = locations.firstIndex(of: selectedPlace) { locations[index] = location } }\n\nYou'll need to adjust the code just a little, including making sure to remove the two viewModel references from there – they aren’t needed any more.\n\nNow the EditView sheet in ContentView can just pass its data onto the view model:\n\nEditView(location: place) { viewModel.update(location: $0) }\n\nAt this point the view model has taken over all aspects of ContentView, which is great: the view is there to present data, and the view model is there to manage data. The split isn’t always quite as clean as that, despite what you might hear elsewhere online, and again that’s okay – once you move into more advanced projects you’ll find that “one size fits all” approaches usually fit nobody, so we just do our best with what we have.\n\nAnyway, in this case now that we have our view model all set up, we can upgrade it to support loading and saving of data. This will look in the documents directory for a particular file, then use either JSONEncoder or JSONDecoder to convert it ready for use.\n\nPreviously I showed you how to locate your app's documents directory and create filenames inside there, but I don’t want to do that when both loading and saving files because it means if we ever change our save location we need to remember to update both places.\n\nSo, a better idea is to add a new property to our view model to store the location we’re saving to:\n\nlet savePath = URL.documentsDirectory.appending(path: \"SavedPlaces\")\n\nAnd with that in place we can create a new initializer and a new save() method that makes sure our data is saved automatically. Start by adding this to the view model:\n\ninit() { do { let data = try Data(contentsOf: savePath) locations = try JSONDecoder().decode([Location].self, from: data) } catch { locations = [] } }\n\nAs for saving, previously I showed you how to write a string to disk, but the Data version is even better because it lets us do something quite amazing in just one line of code: we can ask iOS to ensure the file is written with encryption so that it can only be read once the user has unlocked their device. This is in addition to requesting atomic writes – iOS does almost all the work for us.\n\nAdd this method to the view model now:\n\nfunc save() { do { let data = try JSONEncoder().encode(locations) try data.write(to: savePath, options: [.atomic, .completeFileProtection]) } catch { print(\"Unable to save data.\") } }\n\nYes, all it takes to ensure that the file is stored with strong encryption is to add .completeFileProtection to the data writing options.\n\nUsing this approach we can write any amount of data in any number of files – it’s much more flexible than UserDefaults, and also allows us to load and save data as needed rather than immediately when the app launches as with UserDefaults.\n\nBefore we’re done with this step, we need to make a handful of small changes to our view model so that uses the code we just wrote.\n\nFirst, the locations array no longer needs to be initialized to an empty array, because that’s handled by the initializer. Change it to this:\n\nprivate(set) var locations: [Location]\n\nAnd second, we need to call the save() method after adding a new location or after updating an existing one, so add save() to the end of both those methods.\n\nGo ahead and run the app now, and you should find that you can add items freely, then relaunch the app to see them restored just as they were.\n\nThat took quite a bit of code in total, but the end result is that we have loading and saving done really well:\n\nAll the logic is handled outside the view, so later on when you learn to write tests you’ll find the view model is much easier to work with.\n\nWhen we write data we’re making iOS encrypt it so the file can’t be read or written until the user unlocks their device.\n\nThe load and save process is almost transparent – our view has no idea it's even happening.\n\nSometimes people ask me why I didn't introduce MVVM earlier in the course, and there are two primary answers:\n\nIt works really badly with SwiftData, at least right now. This might improve in the future, but right now using SwiftData is basically impossible with MVVM.\n\nThere are lots of ways of structuring projects, with MVVM being just one of many. Spend some time experimenting rather than locking yourself into the first idea that comes along.\n\nOf course, our app isn’t truly secure yet: we’ve ensured our data file is saved out using encryption so that it can only be read once the device has been unlocked, but there’s nothing stopping someone else from reading the data afterwards."
    }
}