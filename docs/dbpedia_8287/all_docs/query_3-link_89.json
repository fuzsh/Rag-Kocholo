{
    "id": "dbpedia_8287_3",
    "rank": 89,
    "data": {
        "url": "https://www.home-assistant.io/docs/configuration/templating/",
        "read_more_link": "",
        "language": "en",
        "title": "Templating",
        "top_image": "https://www.home-assistant.io/images/default-social.png",
        "meta_img": "https://www.home-assistant.io/images/default-social.png",
        "images": [
            "https://www.home-assistant.io/images/footer-logo-text.svg",
            "https://www.home-assistant.io/images/frontpage/netlify.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Home Assistant"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Instructions on how to use the templating feature of Home Assistant.",
        "meta_lang": "en",
        "meta_favicon": "/images/favicon.ico",
        "meta_site_name": "Home Assistant",
        "canonical_link": "https://www.home-assistant.io/docs/configuration/templating/",
        "text": "This is an advanced feature of Home Assistant. You’ll need a basic understanding of:\n\nHome Assistant architecture, especially states.\n\nThe State object.\n\nTemplating is a powerful feature that allows you to control information going into and out of the system. It is used for:\n\nFormatting outgoing messages in, for example, the notify platforms and Alexa integration.\n\nProcess incoming data from sources that provide raw data, like MQTT, rest sensor or the command_line sensor.\n\nAutomation Templating.\n\nBuilding templates\n\nTemplating in Home Assistant is powered by the Jinja2 templating engine. This means that we are using their syntax and make some custom Home Assistant variables available to templates during rendering. Jinja2 supports a wide variety of operations:\n\nMathematical operation\n\nComparisons\n\nLogic\n\nWe will not go over the basics of the syntax, as Jinja2 does a great job of this in their templates documentation.\n\nThe frontend has a template editor tool to help develop and debug templates. Navigate to Developer Tools > Template, create your template in the Template editor and check the results on the right.\n\nTemplates can get big pretty fast. To keep a clear overview, consider using YAML multiline strings to define your templates:\n\nscript: msg_who_is_home: sequence: - action: notify.notify data: message: > {% if is_state('device_tracker.paulus', 'home') %} Ha, Paulus is home! {% else %} Paulus is at {{ states('device_tracker.paulus') }}. {% endif %}\n\nImportant template rules\n\nThere are a few very important rules to remember when adding templates to YAML:\n\nYou must surround single-line templates with double quotes (\") or single quotes (').\n\nIt is advised that you prepare for undefined variables by using if ... is not none or the default filter, or both.\n\nIt is advised that when comparing numbers, you convert the number(s) to a float or an int by using the respective filter.\n\nWhile the float and int filters do allow a default fallback value if the conversion is unsuccessful, they do not provide the ability to catch undefined variables.\n\nRemembering these simple rules will help save you from many headaches and endless hours of frustration when using automation templates.\n\nEnabled Jinja extensions\n\nJinja supports a set of language extensions that add new functionality to the language. To improve the experience of writing Jinja templates, we have enabled the following extensions:\n\nLoop Controls (break and continue)\n\nReusing templates\n\nYou can write reusable Jinja templates by adding them to a custom_templates folder under your configuration directory. All template files must have the .jinja extension and be less than 5MiB. Templates in this folder will be loaded at startup. To reload the templates without restarting Home Assistant, invoke the homeassistant.reload_custom_templates action.\n\nOnce the templates are loaded, Jinja includes and imports will work using config/custom_templates as the base directory.\n\nFor example, you might define a macro in a template in config/custom_templates/formatter.jinja:\n\n{% macro format_entity(entity_id) %} {{ state_attr(entity_id, 'friendly_name') }} - {{ states(entity_id) }} {% endmacro %}\n\nIn your automations, you could then reuse this macro by importing it:\n\n{% from 'formatter.jinja' import format_entity %} {{ format_entity('sensor.temperature') }}\n\nHome Assistant template extensions\n\nExtensions allow templates to access all of the Home Assistant specific states and adds other convenience functions and filters.\n\nLimited templates\n\nTemplates for some triggers as well as trigger_variables only support a subset of the Home Assistant template extensions. This subset is referred to as “Limited Templates”.\n\nStates\n\nNot supported in limited templates.\n\nIterating states will yield each state object.\n\nIterating states.domain will yield each state object of that domain.\n\nstates.sensor.temperature returns the state object for sensor.temperature (avoid when possible, see note below).\n\nstates can also be used as a function, states(entity_id, rounded=False, with_unit=False), which returns the state string (not the state object) of the given entity, unknown if it doesn’t exist, and unavailable if the object exists but is not available.\n\nThe optional arguments rounded and with_unit control the formatting of sensor state strings, please see the examples below.\n\nstates.sensor.temperature.state_with_unit formats the state string in the same way as if calling states('sensor.temperature', rounded=True, with_unit=True).\n\nis_state compares an entity’s state with a specified state or list of states and returns True or False. is_state('device_tracker.paulus', 'home') will test if the given entity is the specified state. is_state('device_tracker.paulus', ['home', 'work']) will test if the given entity is any of the states in the list.\n\nstate_attr('device_tracker.paulus', 'battery') will return the value of the attribute or None if it doesn’t exist.\n\nis_state_attr('device_tracker.paulus', 'battery', 40) will test if the given entity attribute is the specified state (in this case, a numeric value). Note that the attribute can be None and you want to check if it is None, you need to use state_attr('sensor.my_sensor', 'attr') is none or state_attr('sensor.my_sensor', 'attr') == None (note the difference in the capitalization of none in both versions).\n\nhas_value('sensor.my_sensor') will test if the given entity is not unknown or unavailable. Can be used as a filter or a test.\n\nWarning\n\nAvoid using states.sensor.temperature.state, instead use states('sensor.temperature'). It is strongly advised to use the states(), is_state(), state_attr() and is_state_attr() as much as possible, to avoid errors and error message when the entity isn’t ready yet (e.g., during Home Assistant startup).\n\nStates examples\n\nThe next two statements result in the same value if the state exists. The second one will result in an error if the state does not exist.\n\n{{ states('device_tracker.paulus') }} {{ states.device_tracker.paulus.state }}\n\nPrint out a list of all the sensor states:\n\n{% for state in states.sensor %} {{ state.entity_id }}={{ state.state }}, {% endfor %}\n\nPrint out a list of all the sensor states sorted by entity_id:\n\n{% for state in states.sensor | sort(attribute='entity_id') %} {{ state.entity_id }}={{ state.state }}, {% endfor %}\n\nEntities that are on:\n\n{{ ['light.kitchen', 'light.dining_room'] | select('is_state', 'on') | list }}\n\nOther state examples:\n\n{% if is_state('device_tracker.paulus', 'home') %} Ha, Paulus is home! {% else %} Paulus is at {{ states('device_tracker.paulus') }}. {% endif %} #check sensor.train_departure_time state {% if states('sensor.train_departure_time') in (\"unavailable\", \"unknown\") %} {{ ... }} {% if has_value('sensor.train_departure_time') %} {{ ... }} {% set state = states('sensor.temperature') %}{{ state | float + 1 if is_number(state) else \"invalid temperature\" }} {% set state = states('sensor.temperature') %}{{ (state | float * 10) | round(2) if is_number(state)}} {% set state = states('sensor.temperature') %} {% if is_number(state) and state | float > 20 %} It is warm! {% endif %} {{ as_timestamp(states.binary_sensor.garage_door.last_changed) }} {{ as_local(states.binary_sensor.garage_door.last_changed) }} {{ as_timestamp(now()) - as_timestamp(states.binary_sensor.garage_door.last_changed) }} {{ as_local(states.sensor.time.last_changed) }} {{ states('sensor.expires') | as_datetime }} # Make a list of states {{ ['light.kitchen', 'light.dining_room'] | map('states') | list }}\n\nFormatting sensor states\n\nThe examples below show the output of a temperature sensor with state 20.001, unit °C and user configured presentation rounding set to 1 decimal.\n\nThe following example results in the number 20.001:\n\n{{ states('sensor.temperature') }}\n\nThe following example results in the string \"20.0 °C\":\n\n{{ states('sensor.temperature', with_unit=True) }}\n\nThe following example result in the string \"20.001 °C\":\n\n{{ states('sensor.temperature', with_unit=True, rounded=False) }}\n\nThe following example results in the number 20.0:\n\n{{ states('sensor.temperature', rounded=True) }}\n\nThe following example results in the number 20.001:\n\n{{ states.sensor.temperature.state }}\n\nThe following example results in the string \"20.0 °C\":\n\n{{ states.sensor.temperature.state_with_unit }}\n\nAttributes\n\nNot supported in limited templates.\n\nYou can print an attribute with state_attr if state is defined.\n\nAttributes examples\n\n{% if states.device_tracker.paulus %} {{ state_attr('device_tracker.paulus', 'battery') }} {% else %} ?? {% endif %}\n\nWith strings:\n\n{% set tracker_name = \"paulus\"%} {% if states(\"device_tracker.\" + tracker_name) != \"unknown\" %} {{ state_attr(\"device_tracker.\" + tracker_name, \"battery\")}} {% else %} ?? {% endif %}\n\nList of friendly names:\n\n{{ ['binary_sensor.garage_door', 'binary_sensor.front_door'] | map('state_attr', 'friendly_name') | list }}\n\nList of lights that are on with a brightness of 255:\n\n{{ ['light.kitchen', 'light.dinig_room'] | select('is_state', 'on') | select('is_state_attr', 'brightness', 255) | list }}\n\nState translated\n\nNot supported in limited templates.\n\nThe state_translated function returns a translated state of an entity using a language that is currently configured in the general settings.\n\nState translated examples\n\n{{ states(\"sun.sun\") }} # below_horizon {{ state_translated(\"sun.sun\") }} # Below horizon {{ \"sun.sun\" | state_translated }} # Below horizon\n\n{{ states(\"binary_sensor.movement_backyard\") }} # on {{ state_translated(\"binary_sensor.movement_backyard\") }} # Detected {{ \"binary_sensor.movement_backyard\" | state_translated }} # Detected\n\nWorking with groups\n\nNot supported in limited templates.\n\nThe expand function and filter can be used to sort entities and expand groups. It outputs a sorted array of entities with no duplicates.\n\nExpand examples\n\n{% for tracker in expand('device_tracker.paulus', 'group.child_trackers') %} {{ state_attr(tracker.entity_id, 'battery') }} {%- if not loop.last %}, {% endif -%} {% endfor %}\n\nThe same thing can also be expressed as a filter:\n\n{{ expand(['device_tracker.paulus', 'group.child_trackers']) | selectattr(\"attributes.battery\", 'defined') | join(', ', attribute=\"attributes.battery\") }}\n\n{% for energy in expand('group.energy_sensors') if is_number(energy.state) %} {{ energy.state }} {%- if not loop.last %}, {% endif -%} {% endfor %}\n\nThe same thing can also be expressed as a test:\n\n{{ expand('group.energy_sensors') | selectattr(\"state\", 'is_number') | join(', ') }}\n\nEntities\n\nis_hidden_entity(entity_id) returns whether an entity has been hidden. Can also be used as a test.\n\nEntities examples\n\n{{ area_entities('kitchen') | reject('is_hidden_entity') }} # Gets a list of visible entities in the kitchen area\n\nDevices\n\ndevice_entities(device_id) returns a list of entities that are associated with a given device ID. Can also be used as a filter.\n\ndevice_attr(device_or_entity_id, attr_name) returns the value of attr_name for the given device or entity ID. Can also be used as a filter. Not supported in limited templates.\n\nis_device_attr(device_or_entity_id, attr_name, attr_value) returns whether the value of attr_name for the given device or entity ID matches attr_value. Can also be used as a test. Not supported in limited templates.\n\ndevice_id(entity_id) returns the device ID for a given entity ID or device name. Can also be used as a filter.\n\nDevices examples\n\n{{ device_attr('deadbeefdeadbeefdeadbeefdeadbeef', 'manufacturer') }} # Sony\n\n{{ is_device_attr('deadbeefdeadbeefdeadbeefdeadbeef', 'manufacturer', 'Sony') }} # true\n\n{{ device_id('sensor.sony') }} # deadbeefdeadbeefdeadbeefdeadbeef\n\nConfig entries\n\nconfig_entry_id(entity_id) returns the config entry ID for a given entity ID. Can also be used as a filter.\n\nconfig_entry_attr(config_entry_id, attr) returns the value of attr for the config entry of the given entity ID. Can also be used as a filter. The following attributes are allowed: domain, title, state, source, disabled_by. Not supported in limited templates.\n\nConfig entries examples\n\n{{ config_entry_id('sensor.sony') }} # deadbeefdeadbeefdeadbeefdeadbeef\n\n{{ config_entry_attr(config_entry_id('sensor.sony'), 'title') }} # Sony Bravia TV\n\nFloors\n\nfloors() returns the full list of floor IDs.\n\nfloor_id(lookup_value) returns the floor ID for a given device ID, entity ID, area ID, or area name. Can also be used as a filter.\n\nfloor_name(lookup_value) returns the floor name for a given device ID, entity ID, area ID, or floor ID. Can also be used as a filter.\n\nfloor_areas(floor_name_or_id) returns the list of area IDs tied to a given floor ID or name. Can also be used as a filter.\n\nFloors examples\n\n{{ floors() }} # ['floor_id']\n\n{{ floor_id('First floor') }} # 'first_floor'\n\n{{ floor_id('my_device_id') }} # 'second_floor'\n\n{{ floor_id('sensor.sony') }} # 'first_floor'\n\n{{ floor_name('first_floor') }} # 'First floor'\n\n{{ floor_name('my_device_id') }} # 'Second floor'\n\n{{ floor_name('sensor.sony') }} # 'First floor'\n\n{{ floor_areas('first_floor') }} # ['living_room', 'kitchen']\n\nAreas\n\nareas() returns the full list of area IDs\n\narea_id(lookup_value) returns the area ID for a given device ID, entity ID, or area name. Can also be used as a filter.\n\narea_name(lookup_value) returns the area name for a given device ID, entity ID, or area ID. Can also be used as a filter.\n\narea_entities(area_name_or_id) returns the list of entity IDs tied to a given area ID or name. Can also be used as a filter.\n\narea_devices(area_name_or_id) returns the list of device IDs tied to a given area ID or name. Can also be used as a filter.\n\nAreas examples\n\n{{ areas() }} # ['area_id']\n\n{{ area_id('Living Room') }} # 'deadbeefdeadbeefdeadbeefdeadbeef'\n\n{{ area_id('my_device_id') }} # 'deadbeefdeadbeefdeadbeefdeadbeef'\n\n{{ area_id('sensor.sony') }} # 'deadbeefdeadbeefdeadbeefdeadbeef'\n\n{{ area_name('deadbeefdeadbeefdeadbeefdeadbeef') }} # 'Living Room'\n\n{{ area_name('my_device_id') }} # 'Living Room'\n\n{{ area_name('sensor.sony') }} # 'Living Room'\n\n{{ area_entities('deadbeefdeadbeefdeadbeefdeadbeef') }} # ['sensor.sony']\n\n{{ area_devices('Living Room') }} # ['my_device_id']\n\nEntities for an integration\n\nintegration_entities(integration) returns a list of entities that are associated with a given integration, such as hue or zwave_js.\n\nintegration_entities(config_entry_title) if you have multiple entries set-up for an integration, you can also use the title you’ve set for the integration in case you only want to target a specific entry.\n\nIf there is more than one entry with the same title, the entities for all the matching entries will be returned, even if the entries are for different integrations. It’s not possible to search for entities of an untitled integration.\n\nIntegrations examples\n\n{{ integration_entities('hue') }} # ['light.hue_light_upstairs', 'light.hue_light_downstairs']\n\n{{ integration_entities('Hue bridge downstairs') }} # ['light.hue_light_downstairs']\n\nLabels\n\nlabels() returns the full list of label IDs, or those for a given area ID, device ID, or entity ID.\n\nlabel_id(lookup_value) returns the label ID for a given label name.\n\nlabel_name(lookup_value) returns the label name for a given label ID.\n\nlabel_areas(label_name_or_id) returns the list of area IDs tied to a given label ID or name.\n\nlabel_devices(label_name_or_id) returns the list of device IDs tied to a given label ID or name.\n\nlabel_entities(label_name_or_id) returns the list of entity IDs tied to a given label ID or name.\n\nEach of the label template functions can also be used as a filter.\n\nLabels examples\n\n{{ labels() }} # ['christmas_decorations', 'energy_saver', 'security']\n\n{{ labels(\"living_room\") }} # ['christmas_decorations', 'energy_saver']\n\n{{ labels(\"my_device_id\") }} # ['security']\n\n{{ labels(\"light.christmas_tree\") }} # ['christmas_decorations']\n\n{{ label_id('Energy saver') }} # 'energy_saver'\n\n{{ label_name('energy_saver') }} # 'Energy saver'\n\n{{ label_areas('security') }} # ['driveway', 'garden', 'porch']\n\n{{ label_devices('energy_saver') }} # ['deadbeefdeadbeefdeadbeefdeadbeef']\n\n{{ label_entities('security') }} # ['camera.driveway', 'binary_sensor.motion_garden', 'camera.porch']\n\nIssues\n\nissues() returns all open issues as a mapping of (domain, issue_id) tuples to the issue object.\n\nissue(domain, issue_id) returns a specific issue for the provided domain and issue_id.\n\nIssues examples\n\n{{ issues() }} # { (\"homeassistant\", \"deprecated_yaml_ping\"): {...}, (\"cloud\", \"legacy_subscription\"): {...} }\n\n{{ issue('homeassistant', 'python_version') }} # {\"breaks_in_ha_version\": \"2024.4\", \"domain\": \"homeassistant\", \"issue_id\": \"python_version\", \"is_persistent\": False, ...}\n\nImmediate if (iif)\n\nA common case is to conditionally return a value based on another value. For example, return a “Yes” or “No” when the light is on or off.\n\nThis can be written as:\n\n{% if is_state('light.kitchen', 'on') %} Yes {% else %} No {% endif %}\n\nOr using a shorter syntax:\n\n{{ 'Yes' if is_state('light.kitchen', 'on') else 'No' }}\n\nAdditionally, to the above, you can use the iif function/filter, which is an immediate if.\n\nSyntax: iif(condition, if_true, if_false, if_none)\n\niif returns the value of if_true if the condition is truthy, the value of if_false if it’s falsy and the value of if_none if it’s None. An empty string, an empty mapping or an an empty list, are all falsy, refer to the Python documentation for an in depth explanation.\n\nif_true is optional, if it’s omitted True is returned if the condition is truthy. if_false is optional, if it’s omitted False is returned if the condition is falsy. if_none is optional, if it’s omitted the value of if_false is returned if the condition is None.\n\nExamples using iif:\n\n{{ iif(is_state('light.kitchen', 'on'), 'Yes', 'No') }} {{ is_state('light.kitchen', 'on') | iif('Yes', 'No') }} {{ (states('light.kitchen') == 'on') | iif('Yes', 'No') }}\n\nWarning\n\nThe immediate if filter does not short-circuit like you might expect with a typical conditional statement. The if_true, if_false and if_none expressions will all be evaluated and the filter will simply return one of the resulting values. This means you cannot use this filter to prevent executing an expression which would result in an error.\n\nFor example, if you wanted to select a field from trigger in an automation based on the platform you might go to make this template: trigger.platform == 'event' | iif(trigger.event.data.message, trigger.to_state.state). This won’t work because both expressions will be evaluated and one will fail since the field doesn’t exist. Instead you have to do this trigger.event.data.message if trigger.platform == 'event' else trigger.to_state.state. This form of the expression short-circuits so if the platform is event the expression trigger.to_state.state will never be evaluated and won’t cause an error.\n\nTime\n\nnow(), relative_time(), today_at(), and utcnow() are not supported in limited templates.\n\nnow() returns a datetime object that represents the current time in your time zone.\n\nYou can also use: now().second, now().minute, now().hour, now().day, now().month, now().year, now().weekday() and now().isoweekday() and other datetime attributes and functions.\n\nUsing now() will cause templates to be refreshed at the start of every new minute.\n\nutcnow() returns a datetime object of the current time in the UTC timezone.\n\nFor specific values: utcnow().second, utcnow().minute, utcnow().hour, utcnow().day, utcnow().month, utcnow().year, utcnow().weekday() and utcnow().isoweekday().\n\nUsing utcnow() will cause templates to be refreshed at the start of every new minute.\n\ntoday_at(value) converts a string containing a military time format to a datetime object with today’s date in your time zone.\n\nUsing today_at() will cause templates to be refreshed at the start of every new minute.\n\n# Is the current time past 10:15? {{ now() > today_at(\"10:15\") }}\n\nas_datetime(value, default) converts a string containing a timestamp, or valid UNIX timestamp, to a datetime object. If that fails, it returns the default value or, if omitted, raises an error. When the input is already a datetime object it will be returned as is. in case the input is a datetime.date object, midnight will be added as time. This function can also be used as a filter.\n\nas_timestamp(value, default) converts datetime object or string to UNIX timestamp. If that fails, returns the default value, or if omitted raises an error. This function can also be used as a filter.\n\nas_local() converts datetime object to local time. This function can also be used as a filter.\n\nstrptime(string, format, default) parses a string based on a format and returns a datetime object. If that fails, it returns the default value or, if omitted, raises an error.\n\ntime_since(datetime, precision) converts a datetime object into its human-readable time string. The time string can be in seconds, minutes, hours, days, months, and years. precision takes an integer (full number) and indicates the number of units returned. The last unit is rounded. For example: precision = 1 could return “2 years” while precision = 2 could return “1 year 11 months”. This function can also be used as a filter. If the datetime is in the future, returns 0 seconds. A precision of 0 returns all available units, default is 1.\n\ntime_until(datetime, precision) converts a datetime object into a human-readable time string. The time string can be in seconds, minutes, hours, days, months, and years. precision takes an integer (full number) and indicates the number of units returned. The last unit is rounded. For example: precision = 1 could return “2 years” while precision = 2 could return “1 year 11 months”. This function can also be used as a filter. If the datetime is in the past, returns 0 seconds. A precision of 0 returns all available units, default is 1.\n\ntimedelta returns a timedelta object and accepts the same arguments as the Python datetime.timedelta function – days, seconds, microseconds, milliseconds, minutes, hours, weeks.\n\n# 77 minutes before current time. {{ now() - timedelta( hours = 1, minutes = 17 ) }}\n\nas_timedelta(string) converts a string to a timedelta object. Expects data in the format DD HH:MM:SS.uuuuuu, DD HH:MM:SS,uuuuuu, or as specified by ISO 8601 (e.g. P4DT1H15M20S which is equivalent to 4 1:15:20) or PostgreSQL’s day-time interval format (e.g. 3 days 04:05:06) This function can also be used as a filter.\n\n# Renders to \"00:10:00\" {{ as_timedelta(\"PT10M\") }}\n\nFilter timestamp_local(default) converts a UNIX timestamp to the ISO format string representation as date/time in your local timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead.\n\nFilter timestamp_utc(default) converts a UNIX timestamp to the ISO format string representation representation as date/time in UTC timezone. If that fails, returns the default value, or if omitted raises an error. If a custom string format is needed in the string, use timestamp_custom instead.\n\nFilter timestamp_custom(format_string, local=True, default) converts an UNIX timestamp to its string representation based on a custom format, the use of a local timezone is the default. If that fails, returns the default value, or if omitted raises an error. Supports the standard Python time formatting options.\n\nTip\n\nUNIX timestamp is the number of seconds that have elapsed since 00:00:00 UTC on 1 January 1970. Therefore, if used as a function’s argument, it can be substituted with a numeric value (int or float).\n\nImportant\n\nIf your template is returning a timestamp that should be displayed in the frontend (e.g., as a sensor entity with device_class: timestamp), you have to ensure that it is the ISO 8601 format (meaning it has the “T” separator between the date and time portion). Otherwise, frontend rendering on macOS and iOS devices will show an error. The following value template would result in such an error:\n\n{{ states.sun.sun.last_changed }} => 2023-07-30 20:03:49.253717+00:00 (missing “T” separator)\n\nTo fix it, enforce the ISO conversion via isoformat():\n\n{{ states.sun.sun.last_changed.isoformat() }} => 2023-07-30T20:03:49.253717+00:00 (contains “T” separator)\n\n{{ 120 | timestamp_local }}\n\nTo/From JSON\n\nThe to_json filter serializes an object to a JSON string. In some cases, it may be necessary to format a JSON string for use with a webhook, as a parameter for command-line utilities or any number of other applications. This can be complicated in a template, especially when dealing with escaping special characters. Using the to_json filter, this is handled automatically.\n\nto_json also accepts boolean arguments for pretty_print, which will pretty print the JSON with a 2-space indent to make it more human-readable, and sort_keys, which will sort the keys of the JSON object, ensuring that the resulting string is consistent for the same input.\n\nIf you need to generate JSON that will be used by a parser that lacks support for Unicode characters, you can add ensure_ascii=True to have to_json generate Unicode escape sequences in strings.\n\nThe from_json filter operates similarly, but in the other direction, de-serializing a JSON string back into an object.\n\nTo/From JSON examples\n\nTemplate\n\n{% set temp = {'temperature': 25, 'unit': '°C'} %} stringified object: {{ temp }} object|to_json: {{ temp|to_json(sort_keys=True) }}\n\nOutput\n\nstringified object: {'temperature': 25, 'unit': '°C'} object|to_json: {\"temperature\": 25, \"unit\": \"°C\"}\n\nConversely, from_json can be used to de-serialize a JSON string back into an object to make it possible to easily extract usable data.\n\nTemplate\n\n{% set temp = '{\"temperature\": 25, \"unit\": \"°C\"}'|from_json %} The temperature is {{ temp.temperature }}{{ temp.unit }}\n\nOutput\n\nThe temperature is 25°C\n\nIs defined\n\nSometimes a template should only return if a value or object is defined, if not, the supplied default value should be returned. This can be useful to validate a JSON payload. The is_defined filter allows to throw an error if a value or object is not defined.\n\nExample using is_defined to parse a JSON payload:\n\n{{ value_json.val | is_defined }}\n\nThis will throw an error UndefinedError: 'value_json' is undefined if the JSON payload has no val attribute.\n\nVersion\n\nversion() Returns a AwesomeVersion object for the value given inside the brackets.\n\nThis is also available as a filter (| version).\n\nExamples:\n\n{{ version(\"2099.9.9\") > \"2000.0.0\" }} Will return True\n\n{{ version(\"2099.9.9\") < \"2099.10\" }} Will return True\n\n{{ \"2099.9.9\" | version < \"2099.10\" }} Will return True\n\n{{ (version(\"2099.9.9\") - \"2100.9.10\").major }} Will return True\n\n{{ (version(\"2099.9.9\") - \"2099.10.9\").minor }} Will return True\n\n{{ (version(\"2099.9.9\") - \"2099.9.10\").patch }} Will return True\n\nDistance\n\nNot supported in limited templates.\n\ndistance() measures the distance between home, an entity, or coordinates. The unit of measurement (kilometers or miles) depends on the system’s configuration settings.\n\nclosest() will find the closest entity.\n\nDistance examples\n\nIf only one location is passed in, Home Assistant will measure the distance from home.\n\nUsing Lat Lng coordinates: {{ distance(123.45, 123.45) }} Using State: {{ distance(states.device_tracker.paulus) }} These can also be combined in any combination: {{ distance(123.45, 123.45, 'device_tracker.paulus') }} {{ distance('device_tracker.anne_therese', 'device_tracker.paulus') }}\n\nClosest examples\n\nThe closest function and filter will find the closest entity to the Home Assistant location:\n\nQuery all entities: {{ closest(states) }} Query all entities of a specific domain: {{ closest(states.device_tracker) }} Query all entities in group.children: {{ closest('group.children') }} Query all entities in group.children: {{ closest(states.group.children) }}\n\nFind entities closest to a coordinate or another entity. All previous arguments still apply for second argument.\n\nClosest to a coordinate: {{ closest(23.456, 23.456, 'group.children') }} Closest to an entity: {{ closest('zone.school', 'group.children') }} Closest to an entity: {{ closest(states.zone.school, 'group.children') }}\n\nSince closest returns a state, we can combine it with distance too.\n\n{{ closest(states).name }} is {{ distance(closest(states)) }} kilometers away.\n\nThe last argument of the closest function has an implicit expand, and can take any iterable sequence of states or entity IDs, and will expand groups:\n\nClosest out of given entities: {{ closest(['group.children', states.device_tracker]) }} Closest to a coordinate: {{ closest(23.456, 23.456, ['group.children', states.device_tracker]) }} Closest to some entity: {{ closest(states.zone.school, ['group.children', states.device_tracker]) }}\n\nIt will also work as a filter over an iterable group of entities or groups:\n\nClosest out of given entities: {{ ['group.children', states.device_tracker] | closest }} Closest to a coordinate: {{ ['group.children', states.device_tracker] | closest(23.456, 23.456) }} Closest to some entity: {{ ['group.children', states.device_tracker] | closest(states.zone.school) }}\n\nContains\n\nJinja provides by default a in operator how return True when one element is in a provided list. The contains test and filter allow you to do the exact opposite and test for a list containing an element. This is particularly useful in select or selectattr filter, as well as to check if a device has a specific attribute, a supported_color_modes, a specific light effect.\n\nSome examples:\n\n{{ state_attr('light.dining_room', 'effect_list') | contains('rainbow') }} will return true if the light has a rainbow effect.\n\n{{ expand('light.office') | selectattr(\"attributes.supported_color_modes\", 'contains', 'color_temp') | list }} will return all light that support color_temp in the office group.\n\n{% set current_month = now().month %} {% set extra_ambiance = [ {'name':'Halloween', 'month': [10,11]}, {'name':'Noel', 'month': [1,11,12]} ]%} {% set to_add = extra_ambiance | selectattr('month', 'contains', current_month ) | map(attribute='name') | list %} {% set to_remove = extra_ambiance | map(attribute='name') | reject('in', to_add) | list %} {{ (state_attr('input_select.light_theme', 'options') + to_add ) | unique | reject('in', to_remove) | list }}\n\nThis more complex example uses the contains filter to match the current month with a list. In this case, it’s used to generate a list of light theme to give to the Input select: Set options action.\n\nNumeric functions and filters\n\nSome of these functions can also be used in a filter. This means they can act as a normal function like this sqrt(2), or as part of a filter like this 2|sqrt.\n\nNote\n\nThe numeric functions and filters raise an error if the input is not a valid number, optionally a default value can be specified which will be returned instead. The is_number function and filter can be used to check if a value is a valid number. Errors can be caught by the default filter.\n\n{{ float(\"not_a_number\") }} - the template will fail to render\n\n{{ \"not_a_number\" | sin }} - the template will fail to render\n\n{{ float(\"not_a_number\", default=\"Invalid number!\") }} - renders as \"Invalid number!\"\n\n{{ \"not_a_number\" | sin(default=\"Invalid number!\") }} - renders as \"Invalid number!\"\n\nfloat(value, default) function will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error.\n\nfloat(default) filter will attempt to convert the input to a float. If that fails, returns the default value, or if omitted raises an error.\n\nis_number will return True if the input can be parsed by Python’s float function and the parsed input is not inf or nan, in all other cases returns False. Note that a Python bool will return True but the strings \"True\" and \"False\" will both return False. Can be used as a filter.\n\nint(value, default) function is similar to float, but converts to an int instead. Like float, it has a filter form, and an error is raised if the default value is omitted. Fractional part is discarded: int(\"1.5\") is 1.\n\nbool(value, default) function converts the value to either true or false. The following values are considered to be true: boolean true, non-zero ints and floats, and the strings \"true\", \"yes\", \"on\", \"enable\", and \"1\" (case-insensitive). false is returned for the opposite values: boolean false, integer or floating-point 0, and the strings \"false\", \"no\", \"off\", \"disable\", and \"0\" (also case-insensitive). If the value is not listed here, the function returns the default value, or if omitted raises an error. This function is intended to be used on states of binary sensors, switches, or similar entities, so its behavior is different from Python’s built-in bool conversion, which would consider e.g. \"on\", \"off\", and \"unknown\" all to be true, but \"\" to be false; if that is desired, use not not value or a similar construct instead. Like float and int, bool has a filter form. Using none as the default value is particularly useful in combination with the immediate if filter: it can handle all three possible cases in a single line.\n\nlog(value, base, default) will take the logarithm of the input. When the base is omitted, it defaults to e - the natural logarithm. If value or base can’t be converted to a float, returns the default value, or if omitted raises an error. Can also be used as a filter.\n\nsin(value, default) will return the sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\ncos(value, default) will return the cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\ntan(value, default) will return the tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\nasin(value, default) will return the arcus sine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\nacos(value, default) will return the arcus cosine of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\natan(value, default) will return the arcus tangent of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\natan2(y, x, default) will return the four quadrant arcus tangent of y / x. If y or x can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\nsqrt(value, default) will return the square root of the input. If value can’t be converted to a float, returns the default value, or if omitted raises an error. Can be used as a filter.\n\nmax([x, y, ...]) will obtain the largest item in a sequence. Uses the same parameters as the built-in max filter.\n\nmin([x, y, ...]) will obtain the smallest item in a sequence. Uses the same parameters as the built-in min filter.\n\naverage([x, y, ...], default) will return the average value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter.\n\nmedian([x, y, ...], default) will return the median value of the sequence. If list is empty or contains non-numeric value, returns the default value, or if omitted raises an error. Can be used as a filter.\n\nstatistical_mode([x, y, ...], default) will return the statistical mode value (most frequent occurrence) of the sequence. If the list is empty, it returns the default value, or if omitted raises an error. It can be used as a filter.\n\ne mathematical constant, approximately 2.71828.\n\npi mathematical constant, approximately 3.14159.\n\ntau mathematical constant, approximately 6.28318.\n\nFilter round(precision, method, default) will convert the input to a number and round it to precision decimals. Round has four modes and the default mode (with no mode specified) will round-to-even. If the input value can’t be converted to a float, returns the default value, or if omitted raises an error.\n\nround(precision, \"floor\", default) will always round down to precision decimals\n\nround(precision, \"ceil\", default) will always round up to precision decimals\n\nround(1, \"half\", default) will always round to the nearest .5 value. precision should be 1 for this mode\n\nFilter value_one|bitwise_and(value_two) perform a bitwise and(&) operation with two values.\n\nFilter value_one|bitwise_or(value_two) perform a bitwise or(|) operation with two values.\n\nFilter value_one|bitwise_xor(value_two) perform a bitwise xor(^) operation with two values.\n\nFilter ord will return for a string of length one an integer representing the Unicode code point of the character when the argument is a Unicode object, or the value of the byte when the argument is an 8-bit string.\n\nFilter multiply(arg) will convert the input to a number and multiply it by arg. Useful in list operations in conjunction with map.\n\nFilter add(arg) will convert the input to a number and add it to arg. Useful in list operations in conjunction with map.\n\nComplex type checking\n\nIn addition to strings and numbers, Python (and Jinja) supports lists, sets, and dictionaries. To help you with testing these types, you can use the following tests:\n\nx is list will return whether x is a list or not (e.g. [1, 2] is list will return True).\n\nx is set will return whether x is a set or not (e.g. {1, 2} is set will return True).\n\nx is tuple will return whether x is a tuple or not (e.g. (1, 2) is tuple will return True).\n\nx is datetime will return whether x is a datetime or not (e.g. datetime(2020, 1, 1, 0, 0, 0) is datetime will return True).\n\nx is string_like will return whether x is a string, bytes, or bytearray object.\n\nNote that, in Home Assistant, Jinja has built-in tests for boolean (True/False), callable (any function), float (a number with a decimal), integer (a number without a decimal), iterable (a value that can be iterated over such as a list, set, string, or generator), mapping (mainly dict but also supports other dictionary like types), number (float or int), sequence (a value that can be iterated over and indexed such as list and string), and string.\n\nType conversions\n\nWhile Jinja natively supports the conversion of an iterable to a list, it does not support conversion to a tuple or set. To help you with using these types, you can use the following functions:\n\nset(x) will convert any iterable x to a set (e.g. set([1, 2]) == {1, 2})\n\ntuple(x) will convert any iterable x to a tuple (e.g. tuple(\"abc\") == (\"a\", \"b\", \"c\"))\n\nNote that, in Home Assistant, to convert a value to a list, a string, an int, or a float, Jinja has built-in functions with names that correspond to each type.\n\nFunctions and filters to process raw data\n\nThese functions are used to process raw value’s in a bytes format to values in a native Python type or vice-versa. The pack and unpack functions can also be used as a filter. They make use of the Python 3 struct library. See: Python struct library documentation\n\nFilter value | pack(format_string) will convert a native type to a bytes type object. This will call function struct.pack(format_string, value). Returns None if an error occurs or when format_string is invalid.\n\nFunction pack(value, format_string) will convert a native type to a bytes type object. This will call function struct.pack(format_string, value). Returns None if an error occurs or when format_string is invalid.\n\nFilter value | unpack(format_string, offset=0) will try to convert a bytes object into a native Python object. The offset parameter defines the offset position in bytes from the start of the input bytes based buffer. This will call function struct.unpack_from(format_string, value, offset=offset). Returns None if an error occurs or when format_string is invalid. Note that the filter unpack will only return the first bytes object, despite the function struct.unpack_from supporting to return multiple objects (e.g. with format_string being \">hh\".\n\nFunction unpack(value, format_string, offset=0) will try to convert a bytes object into a native Python object. The offset parameter defines the offset position in bytes from the start of the input bytes based buffer. This will call function struct.unpack_from(format_string, value, offset=offset). Returns None if an error occurs or when format_string is invalid. Note that the function unpack will only return the first bytes object, despite the function struct.unpack_from supporting to return multiple objects (e.g. with format_string being \">hh\".\n\nNote\n\nSome examples:\n\n{{ 0xDEADBEEF | pack(\">I\") }} - renders as b\"\\xde\\xad\\xbe\\xef\"\n\n{{ pack(0xDEADBEEF, \">I\") }} - renders as b\"\\xde\\xad\\xbe\\xef\"\n\n{{ \"0x%X\" % 0xDEADBEEF | pack(\">I\") | unpack(\">I\") }} - renders as 0xDEADBEEF\n\n{{ \"0x%X\" % 0xDEADBEEF | pack(\">I\") | unpack(\">H\", offset=2) }} - renders as 0xBEEF\n\nString filters\n\nFilter urlencode will convert an object to a percent-encoded ASCII text string (e.g., for HTTP requests using application/x-www-form-urlencoded).\n\nFilter slugify(separator=\"_\") will convert a given string into a “slug”.\n\nFilter ordinal will convert an integer into a number defining a position in a series (e.g., 1st, 2nd, 3rd, 4th, etc).\n\nFilter value | base64_decode Decodes a base 64 string to a string, by default utf-8 encoding is used.\n\nFilter value | base64_decode(\"ascii\") Decodes a base 64 string to a string, using ascii encoding.\n\nFilter value | base64_decode(None) Decodes a base 64 string to raw bytes.\n\nSome examples:\n\n{{ \"aG9tZWFzc2lzdGFudA==\" | base64_decode }} - renders as homeassistant\n\n{{ \"aG9tZWFzc2lzdGFudA==\" | base64_decode(None) }} - renders as b'homeassistant'\n\nRegular expressions\n\nFor more information on regular expressions See: Python regular expression operations\n\nTest string is match(find, ignorecase=False) will match the find expression at the beginning of the string using regex.\n\nTest string is search(find, ignorecase=False) will match the find expression anywhere in the string using regex.\n\nFilter string|regex_replace(find='', replace='', ignorecase=False) will replace the find expression with the replace string using regex.\n\nFilter value | regex_findall(find='', ignorecase=False) will find all regex matches of the find expression in value and return the array of matches.\n\nFilter value | regex_findall_index(find='', index=0, ignorecase=False) will do the same as regex_findall and return the match at index.\n\nProcessing incoming data\n\nThe other part of templating is processing incoming data. It allows you to modify incoming data and extract only the data you care about. This will only work for platforms and integrations that mention support for this in their documentation.\n\nIt depends per integration or platform, but it is common to be able to define a template using the value_template configuration key. When a new value arrives, your template will be rendered while having access to the following values on top of the usual Home Assistant extensions:\n\nVariable Description value The incoming value. value_json The incoming value parsed as JSON.\n\nThis means that if the incoming values looks like the sample below:\n\n{\"on\":\"true\",\"temp\":21}\n\nThe template for on would be:\n\n\"{{value_json.on}}\"\n\nNested JSON in a response is supported as well:\n\n{\"sensor\":{\"type\":\"air\",\"id\":\"12345\"},\"values\":{\"temp\":26.09,\"hum\":56.73}}\n\nJust use the “Square bracket notation” to get the value.\n\n\"{{value_json['values']['temp']}}\"\n\nThe following overview contains a couple of options to get the needed values:\n\n# Incoming value: {\"primes\": [2, 3, 5, 7, 11, 13]} # Extract first prime number {{ value_json.primes[0] }} # Format output {{ \"%+.1f\" | value_json }} # Math {{ value_json | float * 1024 if is_number(value_json) }} {{ float(value_json) * (2**10) if is_number(value_json) }} {{ value_json | log if is_number(value_json) }} {{ log(1000, 10) }} {{ sin(pi / 2) }} {{ cos(tau) }} {{ tan(pi) }} {{ sqrt(e) }} # Timestamps {{ value_json.tst | timestamp_local }} {{ value_json.tst | timestamp_utc }} {{ value_json.tst | timestamp_custom('%Y', True) }}\n\nTo evaluate a response, go to Developer Tools > Template, create your output in “Template editor”, and check the result.\n\n{% set value_json= {\"name\":\"Outside\", \"device\":\"weather-ha\", \"data\": {\"temp\":\"24C\", \"hum\":\"35%\" } }%} {{value_json.data.hum[:-1]}}\n\nUsing templates with the MQTT integration\n\nThe MQTT integration relies heavily on templates. Templates are used to transform incoming payloads (value templates) to status updates or incoming actions (command templates) to payloads that configure the MQTT device.\n\nUsing value templates with MQTT\n\nFor incoming data a value template translates incoming JSON or raw data to a valid payload. Incoming payloads are rendered with possible JSON values, so when rendering the value_json can be used access the attributes in a JSON based payload.\n\nNote\n\nExample value template:\n\nWith given payload:\n\n{\"state\":\"ON\",\"temperature\":21.902}\n\nTemplate {{ value_json.temperature | round(1) }} renders to 21.9.\n\nAdditional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item.\n\nUsing command templates with MQTT\n\nFor actions, command templates are defined to format the outgoing MQTT payload to the device. When an action is executed, value can be used to generate the correct payload to the device.\n\nNote\n\nExample command template:\n\nWith given value 21.9 template {\"temperature\": {{ value }} } renders to:\n\n{\"temperature\":21.9}\n\nAdditional the MQTT entity attributes entity_id, name and this can be used as variables in the template. The this attribute refers to the entity state of the MQTT item.\n\nSome more things to keep in mind\n\nentity_id that begins with a number\n\nIf your template uses an entity_id that begins with a number (example: states.device_tracker.2008_gmc) you must use a bracket syntax to avoid errors caused by rendering the entity_id improperly. In the example given, the correct syntax for the device tracker would be: states.device_tracker['2008_gmc']\n\nPriority of operators\n\nThe default priority of operators is that the filter (|) has priority over everything except brackets. This means that:\n\n{{ states('sensor.temperature') | float / 10 | round(2) }}\n\nWould round 10 to 2 decimal places, then divide states('sensor.temperature') by 10 (rounded to 2 decimal places so 10.00). This behavior is maybe not the one expected, but priority rules imply that.\n\nHelp us improve our documentation\n\nSuggest an edit to this page, or provide/view feedback for this page."
    }
}