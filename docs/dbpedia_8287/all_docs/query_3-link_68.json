{
    "id": "dbpedia_8287_3",
    "rank": 68,
    "data": {
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval",
        "read_more_link": "",
        "language": "en",
        "title": "eval() - JavaScript",
        "top_image": "https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png",
        "meta_img": "https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png",
        "images": [],
        "movies": [
            "https://interactive-examples.mdn.mozilla.net/pages/js/globalprops-eval.html"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-07-30T04:48:57+00:00",
        "summary": "",
        "meta_description": "The eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.",
        "meta_lang": "en",
        "meta_favicon": "/favicon-48x48.cbbd161b.png",
        "meta_site_name": "MDN Web Docs",
        "canonical_link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/eval",
        "text": "eval()\n\nWarning: Executing JavaScript from a string is an enormous security risk. It is far too easy for a bad actor to run arbitrary code when you use eval(). See Never use direct eval()!, below.\n\nThe eval() function evaluates JavaScript code represented as a string and returns its completion value. The source is parsed as a script.\n\nTry it\n\nSyntax\n\njs\n\neval(script)\n\nParameters\n\nscript\n\nA string representing a JavaScript expression, statement, or sequence of statements. The expression can include variables and properties of existing objects. It will be parsed as a script, so import declarations (which can only exist in modules) are not allowed.\n\nReturn value\n\nThe completion value of evaluating the given code. If the completion value is empty, undefined is returned. If script is not a string primitive, eval() returns the argument unchanged.\n\nExceptions\n\nThrows any exception that occurs during evaluation of the code, including SyntaxError if script fails to be parsed as a script.\n\nDescription\n\neval() is a function property of the global object.\n\nThe argument of the eval() function is a string. It will evaluate the source string as a script body, which means both statements and expressions are allowed. It returns the completion value of the code. For expressions, it's the value the expression evaluates to. Many statements and declarations have completion values as well, but the result may be surprising (for example, the completion value of an assignment is the assigned value, but the completion value of let is undefined), so it's recommended to not rely on statements' completion values.\n\nIn strict mode, declaring a variable named eval or re-assigning eval is a SyntaxError.\n\njs\n\n\"use strict\"; const eval = 1;\n\nIf the argument of eval() is not a string, eval() returns the argument unchanged. In the following example, passing a String object instead of a primitive causes eval() to return the String object rather than evaluating the string.\n\njs\n\neval(new String(\"2 + 2\")); eval(\"2 + 2\");\n\nTo work around the issue in a generic fashion, you can coerce the argument to a string yourself before passing it to eval().\n\njs\n\nconst expression = new String(\"2 + 2\"); eval(String(expression));\n\nDirect and indirect eval\n\nThere are two modes of eval() calls: direct eval and indirect eval. Direct eval, as the name implies, refers to directly calling the global eval function with eval(...). Everything else, including invoking it via an aliased variable, via a member access or other expression, or through the optional chaining ?. operator, is indirect.\n\njs\n\neval(\"x + y\"); (0, eval)(\"x + y\"); eval?.(\"x + y\"); const geval = eval; geval(\"x + y\"); const obj = { eval }; obj.eval(\"x + y\");\n\nIndirect eval can be seen as if the code is evaluated within a separate <script> tag. This means:\n\nIndirect eval works in the global scope rather than the local scope, and the code being evaluated doesn't have access to local variables within the scope where it's being called.\n\njs\n\nfunction test() { const x = 2; const y = 4; console.log(eval(\"x + y\")); console.log(eval?.(\"x + y\")); }\n\nIndirect eval does not inherit the strictness of the surrounding context, and is only in strict mode if the source string itself has a \"use strict\" directive.\n\njs\n\nfunction nonStrictContext() { eval?.(`with (Math) console.log(PI);`); } function strictContext() { \"use strict\"; eval?.(`with (Math) console.log(PI);`); } function strictContextStrictEval() { \"use strict\"; eval?.(`\"use strict\"; with (Math) console.log(PI);`); } nonStrictContext(); strictContext(); strictContextStrictEval();\n\nOn the other hand, direct eval inherits the strictness of the invoking context.\n\njs\n\nfunction nonStrictContext() { eval(`with (Math) console.log(PI);`); } function strictContext() { \"use strict\"; eval(`with (Math) console.log(PI);`); } function strictContextStrictEval() { \"use strict\"; eval(`\"use strict\"; with (Math) console.log(PI);`); } nonStrictContext(); strictContext(); strictContextStrictEval();\n\nvar-declared variables and function declarations would go into the surrounding scope if the source string is not interpreted in strict mode â for indirect eval, they become global variables. If it's a direct eval in a strict mode context, or if the eval source string itself is in strict mode, then var and function declarations do not \"leak\" into the surrounding scope.\n\njs\n\neval(\"var a = 1;\"); console.log(a); eval(\"'use strict'; var b = 1;\"); console.log(b); function strictContext() { \"use strict\"; eval?.(\"var c = 1;\"); eval(\"var d = 1;\"); } strictContext(); console.log(c); console.log(d);\n\nlet and const declarations within the evaluated string are always scoped to that script.\n\nDirect eval may have access to additional contextual expressions. For example, in a function's body, one can use new.target:\n\njs\n\nfunction Ctor() { eval(\"console.log(new.target)\"); } new Ctor();\n\nNever use direct eval()!\n\nUsing direct eval() suffers from multiple problems:\n\neval() executes the code it's passed with the privileges of the caller. If you run eval() with a string that could be affected by a malicious party, you may end up running malicious code on the user's machine with the permissions of your webpage / extension. More importantly, allowing third-party code to access the scope in which eval() was invoked (if it's a direct eval) can lead to possible attacks that reads or changes local variables.\n\neval() is slower than the alternatives, since it has to invoke the JavaScript interpreter, while many other constructs are optimized by modern JS engines.\n\nModern JavaScript interpreters convert JavaScript to machine code. This means that any concept of variable naming gets obliterated. Thus, any use of eval() will force the browser to do long expensive variable name lookups to figure out where the variable exists in the machine code and set its value. Additionally, new things can be introduced to that variable through eval(), such as changing the type of that variable, forcing the browser to re-evaluate all of the generated machine code to compensate.\n\nMinifiers give up on any minification if the scope is transitively depended on by eval(), because otherwise eval() cannot read the correct variable at runtime.\n\nThere are many cases where the use of eval() or related methods can be optimized or avoided altogether.\n\nUsing indirect eval()\n\nConsider this code:\n\njs\n\nfunction looseJsonParse(obj) { return eval(`(${obj})`); } console.log(looseJsonParse(\"{ a: 4 - 1, b: function () {}, c: new Date() }\"));\n\nSimply using indirect eval and forcing strict mode can make the code much better:\n\njs\n\nfunction looseJsonParse(obj) { return eval?.(`\"use strict\";(${obj})`); } console.log(looseJsonParse(\"{ a: 4 - 1, b: function () {}, c: new Date() }\"));\n\nThe two code snippets above may seem to work the same way, but they do not; the first one using direct eval suffers from multiple problems.\n\nIt is a great deal slower, due to more scope inspections. Notice c: new Date() in the evaluated string. In the indirect eval version, the object is being evaluated in the global scope, so it is safe for the interpreter to assume that Date refers to the global Date() constructor instead of a local variable called Date. However, in the code using direct eval, the interpreter cannot assume this. For example, in the following code, Date in the evaluated string doesn't refer to window.Date().\n\njs\n\nfunction looseJsonParse(obj) { function Date() {} return eval(`(${obj})`); } console.log(looseJsonParse(`{ a: 4 - 1, b: function () {}, c: new Date() }`));\n\nThus, in the eval() version of the code, the browser is forced to make the expensive lookup call to check to see if there are any local variables called Date().\n\nIf not using strict mode, var declarations within the eval() source becomes variables in the surrounding scope. This leads to hard-to-debug issues if the string is acquired from external input, especially if there's an existing variable with the same name.\n\nDirect eval can read and mutate bindings in the surrounding scope, which may lead to external input corrupting local data.\n\nWhen using direct eval, especially when the eval source cannot be proven to be in strict mode, the engine â and build tools â have to disable all optimizations related to inlining, because the eval() source can depend on any variable name in its surrounding scope.\n\nHowever, using indirect eval() does not allow passing extra bindings other than existing global variables for the evaluated source to read. If you need to specify additional variables that the evaluated source should have access to, consider using the Function() constructor.\n\nUsing the Function() constructor\n\nThe Function() constructor is very similar to the indirect eval example above: it also evaluates the JavaScript source passed to it in the global scope without reading or mutating any local bindings, and therefore allows engines to do more optimizations than direct eval().\n\nThe difference between eval() and Function() is that the source string passed to Function() is parsed as a function body, not as a script. There are a few nuances â for example, you can use return statements at the top level of a function body, but not in a script.\n\nThe Function() constructor is useful if you wish to create local bindings within your eval source, by passing the variables as parameter bindings.\n\njs\n\nfunction Date(n) { return [ \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\", \"Sunday\", ][n % 7 || 0]; } function runCodeWithDateFunction(obj) { return Function(\"Date\", `\"use strict\";return (${obj});`)(Date); } console.log(runCodeWithDateFunction(\"Date(5)\"));\n\nBoth eval() and Function() implicitly evaluate arbitrary code, and are forbidden in strict CSP settings. There are also additional safer (and faster!) alternatives to eval() or Function() for common use-cases.\n\nUsing bracket accessors\n\nYou should not use eval() to access properties dynamically. Consider the following example where the property of the object to be accessed is not known until the code is executed. This can be done with eval():\n\njs\n\nconst obj = { a: 20, b: 30 }; const propName = getPropName(); const result = eval(`obj.${propName}`);\n\nHowever, eval() is not necessary here â in fact, it's more error-prone, because if propName is not a valid identifier, it leads to a syntax error. Moreover, if getPropName is not a function you control, this may lead to execution of arbitrary code. Instead, use the property accessors, which are much faster and safer:\n\njs\n\nconst obj = { a: 20, b: 30 }; const propName = getPropName(); const result = obj[propName];\n\nYou can even use this method to access descendant properties. Using eval(), this would look like:\n\njs\n\nconst obj = { a: { b: { c: 0 } } }; const propPath = getPropPath(); const result = eval(`obj.${propPath}`);\n\nAvoiding eval() here could be done by splitting the property path and looping through the different properties:\n\njs\n\nfunction getDescendantProp(obj, desc) { const arr = desc.split(\".\"); while (arr.length) { obj = obj[arr.shift()]; } return obj; } const obj = { a: { b: { c: 0 } } }; const propPath = getPropPath(); const result = getDescendantProp(obj, propPath);\n\nSetting a property that way works similarly:\n\njs\n\nfunction setDescendantProp(obj, desc, value) { const arr = desc.split(\".\"); while (arr.length > 1) { obj = obj[arr.shift()]; } return (obj[arr[0]] = value); } const obj = { a: { b: { c: 0 } } }; const propPath = getPropPath(); const result = setDescendantProp(obj, propPath, 1);\n\nHowever, beware that using bracket accessors with unconstrained input is not safe either â it may lead to object injection attacks.\n\nUsing callbacks\n\nJavaScript has first-class functions, which means you can pass functions as arguments to other APIs, store them in variables and objects' properties, and so on. Many DOM APIs are designed with this in mind, so you can (and should) write:\n\njs\n\nsetTimeout(() => { }, 1000); elt.addEventListener(\"click\", () => { });\n\nClosures are also helpful as a way to create parameterized functions without concatenating strings.\n\nUsing JSON\n\nIf the string you're calling eval() on contains data (for example, an array: \"[1, 2, 3]\"), as opposed to code, you should consider switching to JSON, which allows the string to use a subset of JavaScript syntax to represent data.\n\nNote that since JSON syntax is limited compared to JavaScript syntax, many valid JavaScript literals will not parse as JSON. For example, trailing commas are not allowed in JSON, and property names (keys) in object literals must be enclosed in quotes. Be sure to use a JSON serializer to generate strings that will be later parsed as JSON.\n\nPassing carefully constrained data instead of arbitrary code is a good idea in general. For example, an extension designed to scrape contents of web-pages could have the scraping rules defined in XPath instead of JavaScript code.\n\nExamples\n\nUsing eval()\n\nIn the following code, both of the statements containing eval() return 42. The first evaluates the string \"x + y + 1\"; the second evaluates the string \"42\".\n\njs\n\nconst x = 2; const y = 39; const z = \"42\"; eval(\"x + y + 1\"); eval(z);\n\neval() returns the completion value of statements\n\neval() returns the completion value of statements. For if, it would be the last expression or statement evaluated.\n\njs\n\nconst str = \"if (a) { 1 + 1 } else { 1 + 2 }\"; let a = true; let b = eval(str); console.log(`b is: ${b}`); a = false; b = eval(str); console.log(`b is: ${b}`);\n\nThe following example uses eval() to evaluate the string str. This string consists of JavaScript statements that assign z a value of 42 if x is five, and assign 0 to z otherwise. When the second statement is executed, eval() will cause these statements to be performed, and it will also evaluate the set of statements and return the value that is assigned to z, because the completion value of an assignment is the assigned value.\n\njs\n\nconst x = 5; const str = `if (x === 5) { console.log(\"z is 42\"); z = 42; } else { z = 0; }`; console.log(\"z is \", eval(str));\n\nIf you assign multiple values then the last value is returned.\n\njs\n\nlet x = 5; const str = `if (x === 5) { console.log(\"z is 42\"); z = 42; x = 420; } else { z = 0; }`; console.log(\"x is\", eval(str));\n\neval() as a string defining function requires \"(\" and \")\" as prefix and suffix\n\njs\n\nconst fctStr1 = \"function a() {}\"; const fctStr2 = \"(function b() {})\"; const fct1 = eval(fctStr1); const fct2 = eval(fctStr2);\n\nSpecifications\n\nSpecificationECMAScript Language Specification\n\n# sec-eval-x\n\nBrowser compatibility\n\nBCD tables only load in the browser\n\nSee also"
    }
}