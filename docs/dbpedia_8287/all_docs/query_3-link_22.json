{
    "id": "dbpedia_8287_3",
    "rank": 22,
    "data": {
        "url": "https://softwareengineering.stackexchange.com/questions/218011/how-accurate-is-business-logic-should-be-in-a-service-not-in-a-model",
        "read_more_link": "",
        "language": "en",
        "title": "How accurate is \"Business logic should be in a service, not in a model\"?",
        "top_image": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "meta_img": "https://cdn.sstatic.net/Sites/softwareengineering/Img/apple-touch-icon@2.png?v=1ef7363febba",
        "images": [
            "https://cdn.sstatic.net/Sites/softwareengineering/Img/logo.svg?v=e86f7d5306ae",
            "https://www.gravatar.com/avatar/5203b24e171961e916d054b73d8b5b59?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/ww6TF.jpg?s=64",
            "https://www.gravatar.com/avatar/b724ebca1ce4dc031f4db1215b70825e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/1e011d13433f12be7dc754180cb38ca8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/d1Y57.gif",
            "https://www.gravatar.com/avatar/d6db99aa846a8217f7e2aba6fa198e7c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/5c6d020feb65179965c761aa6538ff09?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/0bce4ecc3649443edeb6eba28f9a6c04?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8d4204ec8dc313dfa78b41569c625058?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/LnVvr.png?s=64",
            "https://www.gravatar.com/avatar/b345d2bbf3fe705cee330e56316364f6?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e0da8d701ff66baeed50abf356a0033a?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/9902735366cd9dfe6b27eadfba31cef9?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/d6db99aa846a8217f7e2aba6fa198e7c?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3939be96e6fc473a50a6e0926e23c9c3?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/TBWZB.jpg?s=64",
            "https://www.gravatar.com/avatar/c926671d6565f7a1070a2a25edc09881?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/780572ac3c178eabe2be5a41f05a5c48?s=64&d=identicon&r=PG",
            "https://softwareengineering.stackexchange.com/posts/218011/ivc/0c39?prg=bd74b2bf-4751-48b1-90ab-6dd9f4039f01"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2013-11-09T21:54:23",
        "summary": "",
        "meta_description": "Situation\n\nEarlier this evening I gave an answer to a question on StackOverflow. \n\nThe question:\r\n  Editing of an existing object should be done in repository layer or in service? \n  \n  For example...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/softwareengineering/Img/favicon.ico?v=c4f35a1e3900",
        "meta_site_name": "Software Engineering Stack Exchange",
        "canonical_link": "https://softwareengineering.stackexchange.com/questions/218011/how-accurate-is-business-logic-should-be-in-a-service-not-in-a-model",
        "text": "Situation\n\nEarlier this evening I gave an answer to a question on StackOverflow.\n\nThe question:\n\nEditing of an existing object should be done in repository layer or in service?\n\nFor example if I have a User that has debt. I want to change his debt. Should I do it in UserRepository or in service for example BuyingService by getting an object, editing it and saving it ?\n\nMy answer:\n\nYou should leave the responsibility of mutating an object to that same object and use the repository to retrieve this object.\n\nExample situation:\n\nclass User { private int debt; // debt in cents private string name; // getters public void makePayment(int cents){ debt -= cents; } } class UserRepository { public User GetUserByName(string name){ // Get appropriate user from database } }\n\nA comment I received:\n\nBusiness logic should really be in a service. Not in a model.\n\nWhat does the internet say?\n\nSo, this got me searching since I've never really (consciously) used a service layer. I started reading up on the Service Layer pattern and the Unit Of Work pattern but so far I can't say I'm convinced a service layer has to be used.\n\nTake for example this article by Martin Fowler on the anti-pattern of an Anemic Domain Model:\n\nThere are objects, many named after the nouns in the domain space, and these objects are connected with the rich relationships and structure that true domain models have. The catch comes when you look at the behavior, and you realize that there is hardly any behavior on these objects, making them little more than bags of getters and setters. Indeed often these models come with design rules that say that you are not to put any domain logic in the the domain objects. Instead there are a set of service objects which capture all the domain logic. These services live on top of the domain model and use the domain model for data.\n\n(...) The logic that should be in a domain object is domain logic - validations, calculations, business rules - whatever you like to call it.\n\nTo me, this seemed exactly what the situation was about: I advocated the manipulation of an object's data by introducing methods inside that class that do just that. However I realize that this should be a given either way, and it probably has more to do with how these methods are invoked (using a repository).\n\nI also had the feeling that in that article (see below), a Service Layer is more considered as a façade that delegates work to the underlying model, than an actual work-intensive layer.\n\nApplication Layer [his name for Service Layer]: Defines the jobs the software is supposed to do and directs the expressive domain objects to work out problems. The tasks this layer is responsible for are meaningful to the business or necessary for interaction with the application layers of other systems. This layer is kept thin. It does not contain business rules or knowledge, but only coordinates tasks and delegates work to collaborations of domain objects in the next layer down. It does not have state reflecting the business situation, but it can have state that reflects the progress of a task for the user or the program.\n\nWhich is reinforced here:\n\nService interfaces. Services expose a service interface to which all inbound messages are sent. You can think of a service interface as a façade that exposes the business logic implemented in the application (typically, logic in the business layer) to potential consumers.\n\nAnd here:\n\nThe service layer should be devoid of any application or business logic and should focus primarily on a few concerns. It should wrap Business Layer calls, translate your Domain in a common language that your clients can understand, and handle the communication medium between server and requesting client.\n\nThis is a serious contrast to other resources that talk about the Service Layer:\n\nThe service layer should consist of classes with methods that are units of work with actions that belong in the same transaction.\n\nOr the second answer to a question I've already linked:\n\nAt some point, your application will want some business logic. Also, you might want to validate the input to make sure that there isn't something evil or nonperforming being requested. This logic belongs in your service layer.\n\n\"Solution\"?\n\nFollowing the guidelines in this answer, I came up with the following approach that uses a Service Layer:\n\nclass UserController : Controller { private UserService _userService; public UserController(UserService userService){ _userService = userService; } public ActionResult MakeHimPay(string username, int amount) { _userService.MakeHimPay(username, amount); return RedirectToAction(\"ShowUserOverview\"); } public ActionResult ShowUserOverview() { return View(); } } class UserService { private IUserRepository _userRepository; public UserService(IUserRepository userRepository) { _userRepository = userRepository; } public void MakeHimPay(username, amount) { _userRepository.GetUserByName(username).makePayment(amount); } } class UserRepository { public User GetUserByName(string name){ // Get appropriate user from database } } class User { private int debt; // debt in cents private string name; // getters public void makePayment(int cents){ debt -= cents; } }\n\nConclusion\n\nAll together not much has changed here: code from the controller has moved to the service layer (which is a good thing, so there is an upside to this approach). However this doesn't look like it had anything to do with my original answer.\n\nI realize design patterns are guidelines, not rules set in stone to be implemented whenever possible. Yet I have not found a definitive explanation of the service layer and how it should be regarded.\n\nIs it a means to simply extract logic from the controller and put it inside a service instead?\n\nIs it supposed to form a contract between the controller and the domain?\n\nShould there be a layer between the domain and the service layer?\n\nAnd, last but not least: following the original comment\n\nBusiness logic should really be in a service. Not in a model.\n\nIs this correct?\n\nHow would I introduce my business logic in a service instead of the model?\n\nThe tl;dr version:\n\nMy experiences and opinions say that any objects which have business logic should be part of the domain model. The data model should likely not have any logic whatsoever. Services should likely tie the two together, and deal with cross-cutting concerns (databases, logging, etc.). However, the accepted answer is the most practical one.\n\nThe longer version, which has kind of been alluded to by others, is that there is an equivocation on the word \"model\". The post switches between data model and domain model as if they're the same, which is a very common mistake. There may also be a slight equivocation on the word \"service\".\n\nIn practical terms, you should not have a service which makes changes to any domain objects; the reason for this is that your service will likely have some method for every property on your object in order to change the value of that property. This is a problem because then, if you have an interface for your object (or even if not), the service is no longer following the Open-Closed Principle; instead, whenever you add more data to your model (regardless of domain vs data), you end up having to add more functions to your service. There are certain ways around it, but this is the most common reason I've seen \"enterprise\" applications fail, especially when those organizations think that \"enterprise\" means \"have an interface for every object in the system\". Can you imagine adding new methods to an interface, then to two or three different implementations (the in-app one, the mock implementation, and debug one, the in-memory one?), just for a single property on your model? Sounds like a terrible idea to me.\n\nThere's a longer problem here that I won't go into, but the gist is this: Hardcore object-oriented programming says that no one outside of the relevant object should be able to change the value of a property within the object, nor even \"see\" the value of the property within the object. This can be alleviated by making the data read-only. You can still run into issues like when a lot of people make use of the data even as read-only and you have to change the type of that data. It's possible that all the consumers will have to change to accommodate that. This is why, when you make APIs to be consumed by anyone and everyone, you're advised not to have public or even protected properties/data; it's the very reason OOP was invented, ultimately.\n\nI think the majority of the answers here, aside from the one marked accepted, are all clouding the issue. The one marked accepted is good, but I still felt the need to reply and agree that bullet 4 is the way to go, in general.\n\nIn DDD, services are meant specifically for the situation when you have an operation that doesn't properly belong to any aggregate root. You have to be careful here, because often the need for a service can imply that you didn't use the correct roots. But assuming you did, a service is used to coordinate operations across multiple roots, or sometimes to handle concerns that don't involve the domain model at all...\n\nanswered Nov 15, 2013 at 19:52\n\nWolfgangSenffWolfgangSenff\n\n26111 silver badge44 bronze badges"
    }
}