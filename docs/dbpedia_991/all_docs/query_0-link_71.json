{
    "id": "dbpedia_991_0",
    "rank": 71,
    "data": {
        "url": "https://expressjs.com/en/guide/using-middleware.html",
        "read_more_link": "",
        "language": "en",
        "title": "Using Express middleware",
        "top_image": "https://expressjs.com/images/express-facebook-share.png",
        "meta_img": "https://expressjs.com/images/express-facebook-share.png",
        "images": [
            "https://expressjs.com/images/arrow.png",
            "https://raw.githubusercontent.com/openjs-foundation/artwork/main/openjs_foundation/openjs_foundation-logo-horizontal-color.svg",
            "https://www.netlify.com/v3/img/components/netlify-color-accent.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/images/favicon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Using middleware\n\nExpress is a routing and middleware web framework that has minimal functionality of its own: An Express application is essentially a series of middleware function calls.\n\nMiddleware functions are functions that have access to the request object (req), the response object (res), and the next middleware function in the application’s request-response cycle. The next middleware function is commonly denoted by a variable named next.\n\nMiddleware functions can perform the following tasks:\n\nExecute any code.\n\nMake changes to the request and the response objects.\n\nEnd the request-response cycle.\n\nCall the next middleware function in the stack.\n\nIf the current middleware function does not end the request-response cycle, it must call next() to pass control to the next middleware function. Otherwise, the request will be left hanging.\n\nAn Express application can use the following types of middleware:\n\nApplication-level middleware\n\nRouter-level middleware\n\nError-handling middleware\n\nBuilt-in middleware\n\nThird-party middleware\n\nYou can load application-level and router-level middleware with an optional mount path. You can also load a series of middleware functions together, which creates a sub-stack of the middleware system at a mount point.\n\nApplication-level middleware\n\nBind application-level middleware to an instance of the app object by using the app.use() and app.METHOD() functions, where METHOD is the HTTP method of the request that the middleware function handles (such as GET, PUT, or POST) in lowercase.\n\nThis example shows a middleware function with no mount path. The function is executed every time the app receives a request.\n\nconst express = require('express') const app = express() app.use((req, res, next) => { console.log('Time:', Date.now()) next() })\n\nThis example shows a middleware function mounted on the /user/:id path. The function is executed for any type of HTTP request on the /user/:id path.\n\napp.use('/user/:id', (req, res, next) => { console.log('Request Type:', req.method) next() })\n\nThis example shows a route and its handler function (middleware system). The function handles GET requests to the /user/:id path.\n\napp.get('/user/:id', (req, res, next) => { res.send('USER') })\n\nHere is an example of loading a series of middleware functions at a mount point, with a mount path. It illustrates a middleware sub-stack that prints request info for any type of HTTP request to the /user/:id path.\n\napp.use('/user/:id', (req, res, next) => { console.log('Request URL:', req.originalUrl) next() }, (req, res, next) => { console.log('Request Type:', req.method) next() })\n\nRoute handlers enable you to define multiple routes for a path. The example below defines two routes for GET requests to the /user/:id path. The second route will not cause any problems, but it will never get called because the first route ends the request-response cycle.\n\nThis example shows a middleware sub-stack that handles GET requests to the /user/:id path.\n\napp.get('/user/:id', (req, res, next) => { console.log('ID:', req.params.id) next() }, (req, res, next) => { res.send('User Info') }) // handler for the /user/:id path, which prints the user ID app.get('/user/:id', (req, res, next) => { res.send(req.params.id) })\n\nTo skip the rest of the middleware functions from a router middleware stack, call next('route') to pass control to the next route. NOTE: next('route') will work only in middleware functions that were loaded by using the app.METHOD() or router.METHOD() functions.\n\nThis example shows a middleware sub-stack that handles GET requests to the /user/:id path.\n\napp.get('/user/:id', (req, res, next) => { // if the user ID is 0, skip to the next route if (req.params.id === '0') next('route') // otherwise pass the control to the next middleware function in this stack else next() }, (req, res, next) => { // send a regular response res.send('regular') }) // handler for the /user/:id path, which sends a special response app.get('/user/:id', (req, res, next) => { res.send('special') })\n\nMiddleware can also be declared in an array for reusability.\n\nThis example shows an array with a middleware sub-stack that handles GET requests to the /user/:id path\n\nfunction logOriginalUrl (req, res, next) { console.log('Request URL:', req.originalUrl) next() } function logMethod (req, res, next) { console.log('Request Type:', req.method) next() } const logStuff = [logOriginalUrl, logMethod] app.get('/user/:id', logStuff, (req, res, next) => { res.send('User Info') })\n\nRouter-level middleware\n\nRouter-level middleware works in the same way as application-level middleware, except it is bound to an instance of express.Router().\n\nconst router = express.Router()\n\nLoad router-level middleware by using the router.use() and router.METHOD() functions.\n\nThe following example code replicates the middleware system that is shown above for application-level middleware, by using router-level middleware:\n\nconst express = require('express') const app = express() const router = express.Router() // a middleware function with no mount path. This code is executed for every request to the router router.use((req, res, next) => { console.log('Time:', Date.now()) next() }) // a middleware sub-stack shows request info for any type of HTTP request to the /user/:id path router.use('/user/:id', (req, res, next) => { console.log('Request URL:', req.originalUrl) next() }, (req, res, next) => { console.log('Request Type:', req.method) next() }) // a middleware sub-stack that handles GET requests to the /user/:id path router.get('/user/:id', (req, res, next) => { // if the user ID is 0, skip to the next router if (req.params.id === '0') next('route') // otherwise pass control to the next middleware function in this stack else next() }, (req, res, next) => { // render a regular page res.render('regular') }) // handler for the /user/:id path, which renders a special page router.get('/user/:id', (req, res, next) => { console.log(req.params.id) res.render('special') }) // mount the router on the app app.use('/', router)\n\nTo skip the rest of the router’s middleware functions, call next('router') to pass control back out of the router instance.\n\nThis example shows a middleware sub-stack that handles GET requests to the /user/:id path.\n\nconst express = require('express') const app = express() const router = express.Router() // predicate the router with a check and bail out when needed router.use((req, res, next) => { if (!req.headers['x-auth']) return next('router') next() }) router.get('/user/:id', (req, res) => { res.send('hello, user!') }) // use the router and 401 anything falling through app.use('/admin', router, (req, res) => { res.sendStatus(401) })\n\nError-handling middleware\n\nDefine error-handling middleware functions in the same way as other middleware functions, except with four arguments instead of three, specifically with the signature (err, req, res, next):\n\napp.use((err, req, res, next) => { console.error(err.stack) res.status(500).send('Something broke!') })\n\nFor details about error-handling middleware, see: Error handling.\n\nBuilt-in middleware\n\nStarting with version 4.x, Express no longer depends on Connect. The middleware functions that were previously included with Express are now in separate modules; see the list of middleware functions.\n\nExpress has the following built-in middleware functions:\n\nexpress.static serves static assets such as HTML files, images, and so on.\n\nexpress.json parses incoming requests with JSON payloads. NOTE: Available with Express 4.16.0+\n\nexpress.urlencoded parses incoming requests with URL-encoded payloads. NOTE: Available with Express 4.16.0+\n\nThird-party middleware\n\nUse third-party middleware to add functionality to Express apps.\n\nInstall the Node.js module for the required functionality, then load it in your app at the application level or at the router level.\n\nThe following example illustrates installing and loading the cookie-parsing middleware function cookie-parser.\n\n$ npm install cookie-parser\n\nconst express = require('express') const app = express() const cookieParser = require('cookie-parser') // load the cookie-parsing middleware app.use(cookieParser())"
    }
}