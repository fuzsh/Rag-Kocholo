{
    "id": "dbpedia_3136_0",
    "rank": 53,
    "data": {
        "url": "https://crypto.stackexchange.com/questions/95438/the-better-algorithm-for-modular-exponentiation-on-secp256k1-r1",
        "read_more_link": "",
        "language": "en",
        "title": "The better algorithm for Modular Exponentiation on secp256k1/r1",
        "top_image": "https://cdn.sstatic.net/Sites/crypto/Img/apple-touch-icon@2.png?v=fff48bebc5fd",
        "meta_img": "https://cdn.sstatic.net/Sites/crypto/Img/apple-touch-icon@2.png?v=fff48bebc5fd",
        "images": [
            "https://cdn.sstatic.net/Sites/crypto/Img/logo.svg?v=87c028c5e448",
            "https://lh4.googleusercontent.com/-NZb6uZzo4Gg/AAAAAAAAAAI/AAAAAAAAAo0/xTr6RvgMTRw/photo.jpg?sz=64",
            "https://lh3.googleusercontent.com/-VPxJqtXCBTY/AAAAAAAAAAI/AAAAAAAAAAA/ACHi3rerriZUzgbImkD6YydaD1PmO_wriA/mo/photo.jpg?sz=64",
            "https://i.sstatic.net/sDSh5.png?s=64",
            "https://crypto.stackexchange.com/posts/95438/ivc/cd88?prg=a7ce6537-2a6a-4715-99b3-d95545011e29"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-10-06T03:38:57",
        "summary": "",
        "meta_description": "I know Modular Exponentiation ($r = b^e \\bmod m$) is important for RSA, and I can find some algorithm that if e is expressed in binary form (for exp: )--in such way for a n-bit long e, one can expe...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/crypto/Img/favicon.ico?v=e5444c0e7c0b",
        "meta_site_name": "Cryptography Stack Exchange",
        "canonical_link": "https://crypto.stackexchange.com/questions/95438/the-better-algorithm-for-modular-exponentiation-on-secp256k1-r1",
        "text": "There is no substitute for modular multiplication in the question's cryptosystems. Some languages like Python make that easy for educational purposes, only.\n\nIn RSA and DSA, and to a lesser degree ECC crypto on secp256k1 or secp256r1, one needs to compute $b^e\\bmod m$ for large $e$. The fastest algorithms (e.g. sliding window exponentiation) perform about $\\log_2 e$ modular squaring and like $\\approx0.2\\,\\log_2 e$ modular multiplications. However there are other algorithms only marginally more costly (e.g. Montgomery's ladder) that may be better from the standpoint of security against side channels.\n\nEach modular multiplication or squaring modulo $m$, for the above or (in ECC) point addition or multiplication by a scalar, has computational cost growing at most like $(\\log m)^2$ when using the algorithms learned in primary school adapted to computer words instead of digits. That can be lowered to $(\\log m)^{\\approx1.6}$ with Karatsuba or $(\\log m)^{\\approx1.5}$ with Toom-3, but in ECC the modulus $m$ is not large enough that it pays much ($m$ is a 'only' some hundreds bit in ECC, rather than some thousands in RSA/DSA).\n\nWhen developing signature or encryption using secp256k1 or secp256r1 from scratch for educational purposes, there typically are phases:\n\nGetting something that works, by building point addition and doubling in Cartesian coordinates on top of modular multiplication, then point multiplication, then signature or/and encryption.\n\nGetting it to work much faster by using a better representation of point, e.g. projective coordinates (which allows to deffer the costly modular inversion until the end of point multiplication)\n\nGetting it to work securely, which is very hard and typically requires rewriting a lot of things from the grounds up.\n\nPerformance optimizations. These can be attempted at any stage, but ponder the saying \"premature optimization is the root of all evil\".\n\nSome online references on modular multiplication and exponentiation (not ECC):"
    }
}