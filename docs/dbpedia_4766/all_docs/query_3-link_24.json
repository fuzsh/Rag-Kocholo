{
    "id": "dbpedia_4766_3",
    "rank": 24,
    "data": {
        "url": "https://www.cockroachlabs.com/blog/what-is-a-uuid/",
        "read_more_link": "",
        "language": "en",
        "title": "What is a UUID, and what is it used for?",
        "top_image": "https://images.ctfassets.net/00voh0j35590/5XQ8fkY0dm8owUiskj22XO/0fca069f3b79fec614b8159f08bd9b57/what-is-a-uuid.jpg",
        "meta_img": "https://images.ctfassets.net/00voh0j35590/5XQ8fkY0dm8owUiskj22XO/0fca069f3b79fec614b8159f08bd9b57/what-is-a-uuid.jpg",
        "images": [
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F4L99WneFfQZfEiTbAz7FBY%2Fcde51d5ab34e96fe246fbc8fe4dea72c%2Fcockroachlabs-logo-170.png&w=384&q=75 1x, /_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F4L99WneFfQZfEiTbAz7FBY%2Fcde51d5ab34e96fe246fbc8fe4dea72c%2Fcockroachlabs-logo-170.png&w=750&q=75 2x",
            "https://www.cockroachlabs.com/_next/image/?url=%2Fimages%2Fblog-default-wing.png&w=2048&q=75 1x, /_next/image/?url=%2Fimages%2Fblog-default-wing.png&w=3840&q=75 2x",
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F71mGCY0sVPoiluZ799OI5J%2F7c07c07ad8aa021210dee5ccd891e37c%2Fcharlie.jpeg&w=640&q=75 1x, /_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F71mGCY0sVPoiluZ799OI5J%2F7c07c07ad8aa021210dee5ccd891e37c%2Fcharlie.jpeg&w=828&q=75 2x",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://images.ctfassets.net/00voh0j35590/5s8uD8wa7cptUjYwTvcJZ/0b224c8812561d349d621caf689b425d/what-is-a-uuid-static.jpg",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://www.cockroachlabs.com/images/icons/copy-icon.svg",
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F7c0pfVlmpe0RE0K5iGEuWE%2F2c5384c591a32f361de807dd786b132f%2Fblog-header-serverless-architecture.jpg&w=3840&q=75 1x",
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F4WXZKfCL7duogeycVnOI0d%2F653951af5214f9300c288724037132a5%2Fforeign-key-1.jpg&w=1200&q=75 1x, /_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F4WXZKfCL7duogeycVnOI0d%2F653951af5214f9300c288724037132a5%2Fforeign-key-1.jpg&w=3840&q=75 2x",
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F10w1zHZ1xHRZDrZAZ8dpZD%2F8372059b5de76fbb1a9e5f0804b6894c%2FNellis_Auction_Cockroach_Labs_1080.png&w=1920&q=75 1x, /_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F10w1zHZ1xHRZDrZAZ8dpZD%2F8372059b5de76fbb1a9e5f0804b6894c%2FNellis_Auction_Cockroach_Labs_1080.png&w=3840&q=75 2x",
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F5cea9ECyWdL7dyAFKg8WPN%2F92d0a6fb996b5abff4948a5fa38c7dde%2FUDF-SP-blog-v2.png&w=1920&q=75 1x, /_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2F5cea9ECyWdL7dyAFKg8WPN%2F92d0a6fb996b5abff4948a5fa38c7dde%2FUDF-SP-blog-v2.png&w=3840&q=75 2x",
            "https://www.cockroachlabs.com/_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2FN32a7K67oaZ9QXjsabscI%2F8e704e2efc4c1ad583d3198f6682d6b0%2FPwC_UK_Cockroach_Labs_1920_TWO.png&w=1920&q=75 1x, /_next/image/?url=https%3A%2F%2Fimages.ctfassets.net%2F00voh0j35590%2FN32a7K67oaZ9QXjsabscI%2F8e704e2efc4c1ad583d3198f6682d6b0%2FPwC_UK_Cockroach_Labs_1920_TWO.png&w=3840&q=75 2x",
            "https://www.cockroachlabs.com/_next/static/media/youtube.4ba947d4.svg",
            "https://www.cockroachlabs.com/_next/static/media/twitter.bbc35ec1.svg",
            "https://www.cockroachlabs.com/_next/static/media/linkedin.af9eaeac.svg",
            "https://www.cockroachlabs.com/_next/static/media/instagram.fb391cad.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "You need to identify your database rows somehow. Calling them row 1, row 2, etc. comes with some hidden hazards. There's a better way: UUIDs.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://www.cockroachlabs.com/blog/what-is-a-uuid/",
        "text": "When working with a database, it’s common practice to use some kind of id field to provide a unique identifier for each row in a table.\n\nImagine, for example, a customers table. We wouldn’t want to use fields such as name or address as unique identifiers because it’s possible more than one customer could have the same name, or share the same address, or in some cases even both!\n\nInstead, it’s a good idea to assign each row some kind of truly unique identifier. One option we have is to use a UUID.\n\nWhat is a UUID?\n\nWhat does UUID stand for? A UUID – that’s short for Universally Unique Identifier – is a 36-character alphanumeric string that can be used to identify information. They are often used, for example, to identify rows of data within a database table, with each row assigned a specific UUID.\n\nHere is one example of a UUID: acde070d-8c4c-4f0d-9d8a-162843c10333\n\nUUIDs are widely used in part because they are highly likely to be unique globally, meaning that not only is our row’s UUID unique in our database table, it’s probably the only row with that UUID in any system anywhere.\n\n(Technically, it’s not impossible that the same UUID we generate could be used somewhere else, but with 340,282,366,920,938,463,463,374,607,431,768,211,456 different possible UUIDs out there, the chances are very slim).\n\nWhat are UUIDs used for?\n\nTo answer this question, let’s imagine we’re operating an ecommerce bookshop. As orders come in, we want to assign them an id number and store them in our orders table using that number.\n\nWe could set up sequential IDs such that the first order to come in is 1, the second is 2, and so on, like so:\n\nAnd this approach might work well, at least for a while, if our scale is small. However, it has some major downsides:\n\nFirst, it can easily create confusion when we’re doing things like joining tables or importing new data, because the id values above aren’t unique. This can create problems even internally if we use the same ID system for multiple tables, and it really gets messy when we start working with any kind of outside data.\n\nImagine, for example, that our little bookshop grows, and we acquire another online bookshop. When we go to integrate our order tables, we find that they’ve used the same system. Now we’ve got two order 1s, two order 2s, etc., and to resolve the issue, we’ll have to update every single ID in at least one of the two databases we’re integrating. Even in a best case scenario, that’s going to be a tremendous hassle.\n\nSecond, the sequential approach often doesn’t work well in distributed systems, because using sequential IDs means that INSERT commands must be executed one by one. This restriction can cause major performance issues, as your database nodes have to wait around as one node at a time writes data, rather than having all nodes be able to write simultaneously. Even if your application requires strict ID ordering, using a feature such as CockroachDB’s Change Data Capture may allow you to meet those requirements while still using UUIDs and not taking the performance hit that comes with sequentially-ordered IDs.\n\nOther traditional approaches to unique IDs, such as generating random IDs with SERIAL, can also lead to hotspots in distributed systems, because values generated around the same time have will often be similar and thus may be located close to each other in the table’s storage. In CockroachDB, for example, this can lead to hotspots where one node gets overworked because it’s handling most or all of the writes while other nodes sit idle.\n\nUUIDs solve all of these problems because:\n\nThey’re globally unique, so the chances of encountering a duplicate ID even in external data are very, very small.\n\nThey can be generated without the need to check against a central node, so in a distributed system, each node can generate UUIDs autonomously without fear of duplication or consistency issues.\n\nReason #1 alone is a good argument for using UUIDs in almost any database system. As a business that aspires to operate at scale, reason #2 is also very relevant to our bookshop, because distributed databases offer the best scalability and resilience.\n\nDisadvantages of UUIDs\n\nThe only significant disadvantage of UUIDs is that they take up 128 bits in memory (and often a bit more when we include metadata). If minimizing storage space is absolutely mission-critical, clearly storing a sequential ID (which will probably range somewhere between 1-10 numeric characters) is going to be more\n\nHowever, in most cases the disadvantages of using something like a sequential identifier significantly outweigh the minimal increase in storage costs that comes from using UUIDs.\n\nWhat is UUID used for? UUIDs are extremely popular and widely used for a variety of different identification purposes. We’ve focused on database examples in this article because we make a pretty awesome database, but UUIDs are also used in analytics systems, web and mobile applications, etc.\n\nHow to find UUID can be simple in most databases. For example, in CockroachDB, you can retrieve the UUID of a specific row by querying the relevant table.\n\nExamples of UUIDs\n\nThere are several different types of UUIDs:\n\nVersion 1 and version 2. Sometimes called time-based UUIDs, these IDs are generated using a combination of datetime values (reflecting the time the UUID is being generated), a random value, and a part of the MAC address of the device generating the UUID.\n\nHere’s how it breaks down visually:\n\nGenerating UUIDs in this way makes having identical UUIDs almost impossible – they would have to be generated by the same device at the exact same time and have generated the exact same random 16-bit sequence.\n\nBecause they contain a part of the generating device’s MAC address, UUID v1 and UUID v2 IDs can be used to identify (for example) which database node generated the ID. This is generally not a problem, and in distributed systems, it can be an advantage.\n\n(The difference between v1 and v2 UUIDs is that UUID v2s also contain a segment of a local domain number. For a number of reasons, this makes them less optimal for most applications, so UUID v2s are not widely used.)\n\nVersion 3 and version 5. These two versions of UUIDs are generated by hashing a namespace identifier and name. They’re similar to time-based UUIDs in that they are generated using existing data rather than being entirely random, but rather than using datetime data and the device MAC address, they use namespace data and name data.\n\nThe namespace data is itself a UUID, and the name data could really be any arbitrary string, although in practice it typically relates to how the UUID will be used – it might be an account name, for example, or a product ID. But whatever the two values used are, they’re hashed to generate a 36-character alphanumeric string that is the final UUID.\n\nUUIDs versions 3 and 5 differ primarily in that they use different hashing algorithms. UUID v3 uses MD5, and UUID v5 uses SHA-1.\n\nVersion 4. These UUIDs are mostly randomly-generated 36-character strings. Technically, a few characters from each string are generated from datetime values, but most of them are random or pseudo-random. See this paper for specific details.\n\nBecause the generation is entirely random, they are extremely likely to be unique. They also contain no identifying information like datetime, MAC address, or name data (which may be an advantage or a disadvantage, depending on the specific use case).\n\nVersions 6, 7, and 8. As of this writing, none of these versions exist, but they have been proposed and may be added to UUID standards in the coming years. You can read more about these proposed new UUIDs here.\n\nHow to generate a UUID\n\nUUIDs may look complicated, but in the context of modern application development generating them is actually pretty straightforward. Most popular programming languages will have libraries that make generating UUIDs as simple as calling a function. These libraries often include a UUID generator function that streamlines the process, utilizing a random generator to ensure uniqueness.”\n\nFor example, in JavaScript, you would simply import the uuid package and then call uuid.v1(), for example, to generate a UUID v1. Python is very similar: you import uuid and call uuid.uuid1() to generate a UUID v1.\n\nDatabases, and particularly distributed databases, may also have built-in UUID generation. In CockroachDB, for example, we recommend using UUIDs as row identifiers, and doing that is as easy as using the gen_random_uuid() function.\n\nSo, for example, when we create a table using SQL we can ensure it auto-generates a UUID v4 for each row like so:\n\nAny time a row is inserted into this table, the id value will be an auto-generated UUID.\n\nLong-story short: generating and using UUIDs is generally quite simple. The specific details of implementation may vary slightly based on the specific database technology and/or programming language we’re working with, but in most cases, it boils down to little more than calling some kind of generate_uuid() function.\n\nTry Serverless\n\nSpin up a serverless cluster in seconds.\n\nUUIDs in a distributed database\n\nDistributed SQL databases offer a powerful combination: the elastic scale and resilience of NoSQL databases combined with the transactional consistency and familiarity of SQL databases.\n\nHowever, working with distributed systems does mean some things need to be approached differently. As we mentioned earlier, traditional approaches to generating row ids, such as generating sequential IDs by adding 1 to an integer so that rows are identified as 2, 3, 4, etc., do not work well in distributed systems. These approaches lead to “hotspot” nodes and create performance bottlenecks.\n\nUUIDs offer a superior alternative for many distributed workloads, because each node in the database can generate completely unique UUIDs autonomously, without having to check against the other nodes.\n\nThis doesn’t mean that UUIDs are always the best choice, though. In CockroachDB, using UUIDs often works well, but using a multi-column primary key can offer superior performance in some circumstances (although it’s also more complex to set up and test).\n\nGo hands-on"
    }
}