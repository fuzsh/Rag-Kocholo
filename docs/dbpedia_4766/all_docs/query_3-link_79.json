{
    "id": "dbpedia_4766_3",
    "rank": 79,
    "data": {
        "url": "https://www.opengroup.org/onlinepubs/9629399/apdxa.htm",
        "read_more_link": "",
        "language": "en",
        "title": "DCE 1.1: Remote Procedure Call",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Previous section. CDE 1.1: Remote Procedure Call\n\nCopyright Â© 1997 The Open Group\n\nUniversal Unique Identifier\n\nThis appendix specifies the syntax and semantics of the DCE variant of Universal Unique Identifiers (UUIDs).\n\nA UUID is an identifier that is unique across both space and time1, with respect to the space of all UUIDs. A UUID can be used for multiple purposes, from tagging objects with an extremely short lifetime, to reliably identifying very persistent objects across a network.\n\nThe generation of UUIDs does not require a registration authority for each single identifier. Instead, it requires a unique value over space for each UUID generator. This spatially unique value is specified as an IEEE 802 address, which is usually already applied to network-connected systems. This 48-bit address can be assigned based on an address block obtained through the IEEE registration authority. This UUID specification assumes the availability of an IEEE 802 address.\n\nFormat\n\nUUID Format shows the format of a UUID.\n\nField NDR Data Type Octet # Note time_low unsigned long 0-3 The low field of the timestamp. time_mid unsigned short 4-5 The middle field of the timestamp. time_hi_and_version unsigned short 6-7 The high field of the timestamp multiplexed with the version number. clock_seq_hi_and_reserved unsigned small 8 The high field of the clock sequence multiplexed with the variant. clock_seq_low unsigned small 9 The low field of the clock sequence. node character 10-15 The spatially unique node identifier.\n\nTable: UUID Format\n\nThe UUID consists of a record of 16 octets and must not contain padding between fields. The total size is 128 bits.\n\nTo minimise confusion about bit assignments within octets, the UUID record definition is defined only in terms of fields that are integral numbers of octets. The version number is multiplexed with the time stamp (time_high), and the variant field is multiplexed with the clock sequence (clock_seq_high).\n\nThe timestamp is a 60 bit value. For UUID version 1, this is represented by Coordinated Universal Time (UTC) as a count of 100-nanosecond intervals since 00:00:00.00, 15 October 1582 (the date of Gregorian reform to the Christian calendar).\n\nThe version number is multiplexed in the 4 most significant bits of the time_hi_and_version field. UUID version Field lists currently defined versions of the UUID.\n\nmsb1 msb2 msb3 msb4 Version Description 0 0 0 1 1 DCE version, as specified herein. 0 0 1 0 2 DCE Security version, with embedded POSIX UIDs.\n\nTable: UUID version Field\n\nThe variant field determines the layout of the UUID. The structure of DCE UUIDs is fixed across different versions. Other UUID variants may not interoperate with DCE UUIDs. Interoperability of UUIDs is defined as the applicability of operations such as string conversion, comparison, and lexical ordering across different systems. The variant field consists of a variable number of the msbs of the clock_seq_hi_and_reserved field. UUID variant Field lists the contents of the DCE variant field.\n\nmsb1 msb2 msb3 Description 0 - - Reserved, NCS backward compatibility. 1 0 - DCE variant. 1 1 0 Reserved, Microsoft Corporation GUID. 1 1 1 Reserved for future definition.\n\nTable: UUID variant Field\n\nThe clock sequence is required to detect potential losses of monotonicity of the clock. Thus, this value marks discontinuities and prevents duplicates. An algorithm for generating this value is outlined in Clock Sequence . The clock sequence is encoded in the 6 least significant bits of the clock_seq_hi_and_reserved field and in the clock_seq_low field.\n\nThe node field consists of the IEEE address, usually the host address. For systems with multiple IEEE 802 nodes, any available node address can be used. The lowest addressed octet (octet number 10) contains the global/local bit and the unicast/multicast bit, and is the first octet of the address transmitted on an 802.3 LAN.\n\nDepending on the network data representation, the multi-octet unsigned integer fields are subject to byte swapping when communicated between different endian machines.\n\nThe nil UUID is special form of UUID that is specified to have all 128 bits set to 0 (zero).\n\nAlgorithms for Creating a UUID\n\nVarious aspects of the algorithm for creating a UUID are discussed in the following sections. UUID generation requires a guarantee of uniqueness within the node ID for a given variant and version. Interoperability is provided by complying with the specified data structure. To prevent possible UUID collisions, which could be caused by different implementations on the same node, compliance with the algorithms specified here is required.\n\nClock Sequence\n\nThe clock sequence value must be changed whenever:\n\nThe UUID generator detects that the local value of UTC has gone backward; this may be due to normal functioning of the DCE Time Service.\n\nThe UUID generator has lost its state of the last value of UTC used, indicating that time may have gone backward; this is typically the case on reboot.\n\nWhile a node is operational, the UUID service always saves the last UTC used to create a UUID. Each time a new UUID is created, the current UTC is compared to the saved value and if either the current value is less (the non-monotonic clock case) or the saved value was lost, then the clock sequence is incremented modulo 16,384, thus avoiding production of duplicate UUIDs.\n\nThe clock sequence must be initialised to a random number to minimise the correlation across systems. This provides maximum protection against node identifiers that may move or switch from system to system rapidly. The initial value shall not be correlated to the node identifier.\n\nThe rule of initialising the clock sequence to a random value is waived if, and only if all of the following are true:\n\nThe clock sequence value is stored in a form of non-volatile storage.\n\nThe system is manufactured such that the IEEE address ROM is designed to be inseparable from the system by either the user or field service, so that it cannot be moved to another system.\n\nThe manufacturing process guarantees that only new IEEE address ROMs are used.\n\nAny field service, remanufacturing or rebuilding process that could change the value of the clock sequence must reinitialise it to a random value.\n\nIn other words, the system constraints prevent duplicates caused by possible migration of the IEEE address, while the operational system itself can protect against non-monotonic clocks, except in the case of field service intervention. At manufacturing time, such a system may initialise the clock sequence to any convenient value.\n\nSystem Reboot\n\nThere are two possibilities when rebooting a system:\n\nThe UUID generator state-the last UTC, adjustment, and clock sequence-of the UUID service has been restored from non-volatile store.\n\nThe state of the last UTC or adjustment has been lost.\n\nIf the state variables have been restored, the UUID generator just continues as normal. Alternatively, if the state variables cannot be restored, they are reinitialised, and the clock sequence is changed. If the clock sequence is stored in non-volatile store, it is incremented; otherwise, it is reinitialised to a new random value.\n\nClock Adjustment\n\nUUIDs may be created at a rate greater than the system clock resolution. Therefore, the system must also maintain an adjustment value to be added to the lower-order bits of the time. Logically, each time the system clock ticks, the adjustment value is cleared. Every time a UUID is generated, the current adjustment value is read and incremented atomically, then added to the UTC time field of the UUID.\n\nClock Overrun\n\nThe 100 nanosecond granularity of time should prove sufficient even for bursts of UUID creation in the next generation of high-performance multiprocessors. If a system overruns the clock adjustment by requesting too many UUIDs within a single system clock tick, the UUID service may raise an exception, handled in a system or process-dependent manner either by:\n\nterminating the requester\n\nreissuing the request until it succeeds\n\nstalling the UUID generator until the system clock catches up.\n\nIf the processors overrun the UUID generation frequently, additional node identifiers and clocks may need to be added.\n\nUUID Generation\n\nUUIDs are generated according to the following algorithm:\n\nDetermine the values for the UTC-based timestamp and clock sequence to be used in the UUID. Format and Clock Sequence define how to determine these values. For the purposes of this algorithm, consider the timestamp to be a 60-bit unsigned integer and the clock sequence to be a 14-bit unsigned integer. Sequentially number the bits in a field, starting from 0 (zero) for the least significant bit.\n\nSet the time_low field equal to the least significant 32-bits (bits numbered 0 to 31 inclusive) of the time stamp in the same order of significance. If a DCE Security version UUID is being created, then replace the time_low field with the local user security attribute as defined by the DCE: Security Services specification.\n\nSet the time_mid field equal to the bits numbered 32 to 47 inclusive of the time stamp in the same order of significance.\n\nSet the 12 least significant bits (bits numbered 0 to 11 inclusive) of the time_hi_and_version field equal to the bits numbered 48 to 59 inclusive of the time stamp in the same order of significance.\n\nSet the 4 most significant bits (bits numbered 12 to 15 inclusive) of the time_hi_and_version field to the 4-bit version number corresponding to the UUID version being created, as shown in UUID version Field .\n\nSet the clock_seq_low field to the 8 least significant bits (bits numbered 0 to 7 inclusive) of the clock sequence in the same order of significance.\n\nSet the 6 least significant bits (bits numbered 0 to 5 inclusive) of the clock_seq_hi_and_reserved field to the 6 most significant bits (bits numbered 8 to 13 inclusive) of the clock sequence in the same order of significance.\n\nSet the 2 most significant bits (bits numbered 6 and 7) of the clock_seq_hi_and_reserved field as shown in The 2 msb of clock_seq_hi_and_reserved .\n\nBit 7 Bit 6 1 0\n\nTable: The 2 msb of clock_seq_hi_and_reserved\n\nSet the node field to the 48-bit IEEE address in the same order of significance as the address.\n\nString Representation of UUIDs\n\nFor use in human readable text, a UUID string representation is specified as a sequence of fields, some of which are separated by single dashes.\n\nEach field is treated as an integer and has its value printed as a zero-filled hexadecimal digit string with the most significant digit first. The hexadecimal values a to f inclusive are output as lower case characters, and are case insensitive on input. The sequence is the same as the UUID constructed type.\n\nThe formal definition of the UUID string representation is provided by the following extended BNF:\n\nUUID = <time_low> <hyphen> <time_mid> <hyphen> <time_high_and_version> <hyphen> <clock_seq_and_reserved> <clock_seq_low> <hyphen> <node> time_low = <hexOctet> <hexOctet> <hexOctet> <hexOctet> time_mid = <hexOctet> <hexOctet> time_high_and_version = <hexOctet> <hexOctet> clock_seq_and_reserved = <hexOctet> clock_seq_low = <hexOctet> node = <hexOctet><hexOctet><hexOctet> <hexOctet><hexOctet><hexOctet> hexOctet = <hexDigit> <hexDigit> hexDigit = <digit> | <a> | <b> | <c> | <d> | <e> | <f> digit = \"0\" | \"1\" | \"2\" | \"3\" | \"4\" | \"5\" | \"6\" | \"7\" | \"8\" | \"9\" hyphen = \"-\" a = \"a\" | \"A\" b = \"b\" | \"B\" c = \"c\" | \"C\" d = \"d\" | \"D\" e = \"e\" | \"E\" f = \"f\" | \"F\"\n\nThe following is an example of the string representation of a UUID:\n\n2fac1234-31f8-11b4-a222-08002b34c003\n\nComparing UUIDs\n\nField Order and Type lists the UUID fields in order of significance, from most significant to least significant, for purposes of UUID comparison. The table also shows the data types applicable to the fields.\n\nField Type time_low Unsigned 32-bit integer time_mid Unsigned 16-bit integer time_hi_and_version Unsigned 16-bit integer clock_seq_hi_and_reserved Unsigned 8-bit integer clock_seq_low Unsigned 8-bit integer node Unsigned 48-bit integer\n\nTable: Field Order and Type\n\nConsider each field to be an unsigned integer as shown in Field Order and Type . To compare a pair of UUIDs, arithmetically compare the corresponding fields from each UUID in order of significance and according to their data type. Two UUIDs are equal if and only if all the corresponding fields are equal. The first of two UUIDs follows the second if the most significant field in which the UUIDs differ is greater for the first UUID. The first of a pair of UUIDs precedes the second if the most significant field in which the UUIDs differ is greater for the second UUID.\n\nFootnotes\n\nTo be precise, the UUID consists of a finite bit space. Thus the time value used for constructing a UUID is limited and will roll over in the future (approximately at A.D. 3400, based on the specified algorithm).\n\nPlease note that the html version of this specification may contain formatting aberrations. The definitive version is available as an electronic publication on CD-ROM from The Open Group."
    }
}