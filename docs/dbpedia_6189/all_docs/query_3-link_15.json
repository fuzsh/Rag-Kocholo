{
    "id": "dbpedia_6189_3",
    "rank": 15,
    "data": {
        "url": "https://medium.com/%40softprops/configuration-envy-a09584386705",
        "read_more_link": "",
        "language": "en",
        "title": "Configuration envy",
        "top_image": "https://miro.medium.com/v2/resize:fit:784/1*5UBXdZEfSw8aa5FK5rpCzA.png",
        "meta_img": "https://miro.medium.com/v2/resize:fit:784/1*5UBXdZEfSw8aa5FK5rpCzA.png",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*ctc2KfEVTp825vtqi9fMkw.jpeg",
            "https://miro.medium.com/v2/resize:fill:144:144/1*ctc2KfEVTp825vtqi9fMkw.jpeg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Doug Tangren",
            "medium.com"
        ],
        "publish_date": "2018-10-16T04:17:18.209000+00:00",
        "summary": "",
        "meta_description": "How software is configured has always been a fascinating topic of interest to me. Not because configuration itself is interesting, but the observation of heavily crafted engineering solutions to a‚Ä¶",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@softprops/configuration-envy-a09584386705",
        "text": "üë©‚Äçüé® Some applications have a strong desire for artisanally crafted configurations . Looking back in history, whole markup languages were invented just to satisfy these configuration desires. In some limited cases this is warranted but in many in other cases, not so much. Like any technical problem, these off the conventional path approaches come with tradeoffs. Configuration is a user interface. Users of your software must learn and understand your configuration interface to effectively use your software. Inventing new configuration models and frameworks can be an interesting exercise for library developers but users of your software more often then not benefit more when they are able to reuse their existing knowledge of existing configuration tools and languages. That‚Äôs not to say configuration languages are bad per-say, but please consider users the next time you decide to invent a new configuration language üôÖ‚Äç‚ôÄÔ∏è.\n\nMy view on configuration\n\nConfiguration has a purpose. Understanding purpose is important when attempting to understand why something exists. The purpose of configuration is to change the behavior of software based on a dynamic set of inputs.\n\nThis is interesting to me because the way I look at layers of software has a strong influence on how I view configuration.\n\nGiven any abstract programming language, here‚Äôs a how I see a function.\n\nfn foo(args) { impl.. }\n\nHere‚Äôs how I see a larger abstraction.\n\nclass EnclosingType(args) { impl.. }\n\nHere‚Äôs how I see a programs execution\n\nshell program(args) { impl... }\n\nDo you see the pattern? Each level of abstraction is configurable via parameterization, including the program process. One way to describe this is currying. You can think of a program‚Äôs execution path as a currying of parameterized arguments that back track all the way to the shell that executes your program. There‚Äôs probably a lisp pun in there somewhere about all programs just being lists of parameterized functions surrounded by parenthesis, but in the abstract this is my mental model for configuration: parameterization of inputs at the program process level.\n\nIn the 1990‚Äôs there was a popular term that sold many books called ‚Äúdependency injection‚Äù which described the ability to change the behavior of software based on the wiring of its components. At some point the wiring became sole focus of interest and people all but forgot the underlying purpose of the wiring. I can‚Äôt recall the original source or wording for a little bit of wisdom I picked up on over the years, but paraphrased, I‚Äôve also heard dependency injection described as this.\n\nDependency injection is a fancy phrase for ‚Äúpassing arguments ‚Äú ‚Äî unknown\n\nAn external observer might ask, ‚ÄúSooo, the reason why software engineers invent new configuration management protocols to pass configuration along to their programs is because one does not already exist right?‚Äù Well, no. One does exist. It‚Äôs called the env. I like it. Here‚Äôs why.\n\nIt‚Äôs universally available to all programs on all platforms on all OS‚Äôs through a mostly uniform interface and a mostly uniform protocol. This means it doesn‚Äôt matter how what kind of application you write, where you run it, what language you write it in or what language you‚Äôre reading its usage in. You will always have access to the env and be able to understand its semantics. That‚Äôs a pretty amazing property in software and that dates all the way back to 1979! It‚Äôs interface is simple and easy to understand. You have named keys and, given a key, you can ask the env for a value. For many usage cases that‚Äôs all you actually need.\n\nSo then the external observer may ask, ‚ÄúSooo, why would anyone invent a new language and protocol just for program configuration if one already exists, and exists everywhere?‚Äù\n\nSoftware engineers‚Ä¶ like to engineer things. Despite the liberating qualities of the program env, some can feel constrained by its limited feature set.\n\nOne question often asked about when using the env for configuration is how you store it (for later use) and how you can utilize that source consistently. Since env variables exist in the realm of the software that runs your program, you have to find a way to ensure those variables actually get set prior to process execution. Some engineers like using configuration files to solve just this problem. Here‚Äôs one of my favorite env configuration management tricks.\n\n$ cat .env\n\nFOO=bar\n\nBAZ=123\n\n$ env $(cat .env | xargs) program\n\nWhat just happened? I‚Äôve captured a collection of env variables in a file called .env so I can pack it up and take it on my next camping trip. I then ran env(1) to set up my program‚Äôs execution env by calling cat(1) to get the lines of that file and xargs(1) to evaluate each pair, then ran my program with the env configured. Feel free to use this trick and take your next env camping too. No framework required! Interestingly, there is actually whole software ecosystem that‚Äôs emerged around reading in configuration of this format. So feel free to pack a framework if you‚Äôd like as well :)\n\nAnother complaint that usually comes along with using env for configuration is that the env knows nothing of the types programs expect their values to be in. The limitation often comes at the expense of runtime failure at the point the env variables are parsed which may be much exist deep within the application. This is often a form of justification for creating a configuration system that describes types as part of the configuration. And truth be told, some configuration values is very difficult to describe with simple types, thus new configuration languages are born üë∂. Another approach may be to reconsider flattening configuration structures to fit a more standard approach. Place the burden on the library author, not the user.\n\nFreedom of expression is important to software engineers, but it comes with tradeoffs. Consider this: when a program speaks it‚Äôs own unique configuration language, it‚Äôs harder to integrate that program into a larger system of coordinated programs. Speaking a common existing configuration language really helps with inter orchestration politics.\n\nIdeally every program could play together and compromise on at least a few universal configuration languages.\n\nBest of both worlds\n\nRust, like many other programing languages, provides an std library interface for interacting with the program env.\n\nRust is a programming language that doesn‚Äôt need a optometrist‚Äôs prescription to tell types apart which introduces some disheartenment when working with raw env variables for configuration. Ideally a program‚Äôs configuration could just be represented as any other typed input, like as struct. Structs have fields, which can hold other statically typed data. This also has the nice property of enabling more unit testability of your application as you then have complete control over providing that type as an input your tests.\n\nLuke: Use the ecosystem\n\nRust has an amazing library ecosystem. In particular a library for taking some arbitrary input and deserializing ( or serializing if you care to ) type safe outputs exists and has been well adopted in the community. It‚Äôs called serde. If you are doing anything remotely related to serialization in Rust, trust me, you need this. Want to store your application‚Äôs configuration in a json file, you‚Äôre covered. Yaml? We got you. Toml? Yep. There‚Äôs probably half a dozen other data formats you could store your configuration in and you‚Äôd be set with the Rust‚Äôs existing serde ecosystem.\n\nHowever, for many of my use cases for running Rust applications, storing configuration in file format is less attractive as I‚Äôm typically running Rust inside docker containers and container orchestrators typically encourage the use of standard interfaces like the env for configuration. So I pondered ü§î, ‚ÄúWhat if I could treat my program‚Äôs env parameterization with the same level of typing I treat my functions and enclosing types with while getting everything one get‚Äôs from using serde for free?‚Äù That would be the bee‚Äôs knees üêù .\n\nEnter: envy. Here‚Äôs what it looks like\n\nNote a few things. Config is not a special type. It‚Äôs your type. Call it whatever you like. It just needs to derive serde‚Äôs familiar Deserialize type which serde makes embarrassingly easy. You‚Äôre process brings the env‚Ä¶ and that‚Äôs it. That‚Äôs kind of neat! No awkward and error prone string parsing. No awkward intermediary types. Idiomatic error handling.\n\nEnvy is just an env deserializer for serde. Envy assumes the snake_cased names of your struct map to SCREAMING_SNAKE_CASE env variable names provided by your process env. That‚Äôs it. Serde is my configuration framework on top of the OS provided program env. I haven‚Äôt really needed anything more. Since this program uses only the program‚Äôs env for configuration it can be easily configured on any platform basically everywhere. Since my configuration is represented as a simple struct, it‚Äôs pretty straight forward to reason about and encodes expectation my application has able its env so that I may fail the application as early as possible when those expectations are not met.\n\nUsing the env for configuration will not likely cover all of your use cases but it‚Äôs covered many of mine. As mentioned above all solutions come with tradeoffs this one gives you strong typed configuration by limits what you can express. You can currently only express simple types, optionals, and simply vectors. I‚Äôve found you can get very far with these by thinking creatively and giving yourself limits. Try giving yourself some constraints. You may realize that you‚Äôve packed much more that you need in your camper without realizing it."
    }
}