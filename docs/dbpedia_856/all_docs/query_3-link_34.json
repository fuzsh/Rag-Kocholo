{
    "id": "dbpedia_856_3",
    "rank": 34,
    "data": {
        "url": "https://patents.google.com/patent/US20220284996A1",
        "read_more_link": "",
        "language": "en",
        "title": "US20220284996A1 - Combining domain-specific ontologies for language processing - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/4d/e6/50/bd5142814c2a85/US20220284996A1-20220908-D00000.png",
            "https://patentimages.storage.googleapis.com/b1/83/c4/8d01714a055641/US20220284996A1-20220908-D00001.png",
            "https://patentimages.storage.googleapis.com/c3/a1/d0/2c8f92a87bcd70/US20220284996A1-20220908-D00002.png",
            "https://patentimages.storage.googleapis.com/36/14/cd/91a3f6fc0f922e/US20220284996A1-20220908-D00003.png",
            "https://patentimages.storage.googleapis.com/8a/5d/77/4af0f354af7753/US20220284996A1-20220908-D00004.png",
            "https://patentimages.storage.googleapis.com/a5/30/4a/105d154bd4ee63/US20220284996A1-20220908-D00005.png",
            "https://patentimages.storage.googleapis.com/a8/71/19/9862fb1c088f17/US20220284996A1-20220908-D00006.png",
            "https://patentimages.storage.googleapis.com/a4/fe/12/43d5941098013f/US20220284996A1-20220908-D00007.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/c3/0e/29/d88b4fe694cc2c/US20220284996A1-20220908-P00002.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/34/b1/84/ede2ff4eaeac6f/US20220284996A1-20220908-P00003.png",
            "https://patentimages.storage.googleapis.com/c3/0e/29/d88b4fe694cc2c/US20220284996A1-20220908-P00002.png",
            "https://patentimages.storage.googleapis.com/c6/ea/de/71496b3f771ca3/US20220284996A1-20220908-P00004.png",
            "https://patentimages.storage.googleapis.com/a8/5c/e7/860185033a9491/US20220284996A1-20220908-P00005.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/c3/0e/29/d88b4fe694cc2c/US20220284996A1-20220908-P00002.png",
            "https://patentimages.storage.googleapis.com/c3/0e/29/d88b4fe694cc2c/US20220284996A1-20220908-P00002.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/c3/0e/29/d88b4fe694cc2c/US20220284996A1-20220908-P00002.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/34/b1/84/ede2ff4eaeac6f/US20220284996A1-20220908-P00003.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/c6/ea/de/71496b3f771ca3/US20220284996A1-20220908-P00004.png",
            "https://patentimages.storage.googleapis.com/a8/5c/e7/860185033a9491/US20220284996A1-20220908-P00005.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/8d/21/1c/34633897fc35b1/US20220284996A1-20220908-P00001.png",
            "https://patentimages.storage.googleapis.com/a4/50/79/70f10c27d6bbd3/US20220284996A1-20220908-P00006.png",
            "https://patentimages.storage.googleapis.com/74/04/01/e3f19864edd3f3/US20220284996A1-20220908-P00007.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-03-01T00:00:00",
        "summary": "",
        "meta_description": "Methods and systems for performing a natural language processing task include identifying hypernym/hyponym relations in a depth-wise ontology and identifying synonymy relations in a breadth-wise ontology. The depth-wise ontology and the breadth-wise ontology are combined into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations. Enhanced hypernym/hyponym relations are embedded using the combined ontology. A natural language processing task is performed using the enhanced hypernym/hyponym relations and the combined ontology.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US20220284996A1/en",
        "text": "Combining domain-specific ontologies for language processing Download PDF\n\nInfo\n\nPublication number\n\nUS20220284996A1\n\nUS20220284996A1 US17/188,310 US202117188310A US2022284996A1 US 20220284996 A1 US20220284996 A1 US 20220284996A1 US 202117188310 A US202117188310 A US 202117188310A US 2022284996 A1 US2022284996 A1 US 2022284996A1\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\nontology\n\nwise\n\nhypernym\n\nrelations\n\nhyponym\n\nPrior art date\n\n2021-03-01\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nPending\n\nApplication number\n\nUS17/188,310\n\nInventor\n\nKenneth Lee Clarkson\n\nSanjana Sahayaraj\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nInternational Business Machines Corp\n\nOriginal Assignee\n\nInternational Business Machines Corp\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n2021-03-01\n\nFiling date\n\n2021-03-01\n\nPublication date\n\n2022-09-08\n\n2021-03-01 Application filed by International Business Machines Corp filed Critical International Business Machines Corp\n\n2021-03-01 Priority to US17/188,310 priority Critical patent/US20220284996A1/en\n\n2021-03-01 Assigned to INTERNATIONAL BUSINESS MACHINES CORPORATION reassignment INTERNATIONAL BUSINESS MACHINES CORPORATION ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: CLARKSON, KENNETH LEE, SAHAYARAJ, SANJANA\n\n2022-09-08 Publication of US20220284996A1 publication Critical patent/US20220284996A1/en\n\nStatus Pending legal-status Critical Current\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\n238000012545 processing Methods 0.000 title description 25\n\n238000003058 natural language processing Methods 0.000 claims abstract description 27\n\n238000000034 method Methods 0.000 claims abstract description 26\n\n230000006870 function Effects 0.000 claims description 27\n\n238000003860 storage Methods 0.000 claims description 25\n\n230000015654 memory Effects 0.000 claims description 17\n\n239000013598 vector Substances 0.000 claims description 15\n\n238000004590 computer program Methods 0.000 claims description 7\n\n230000036541 health Effects 0.000 claims description 7\n\n230000036961 partial effect Effects 0.000 claims description 7\n\n238000010586 diagram Methods 0.000 description 17\n\n201000010099 disease Diseases 0.000 description 6\n\n208000037265 diseases, disorders, signs and symptoms Diseases 0.000 description 6\n\n241001465754 Metazoa Species 0.000 description 5\n\n238000007726 management method Methods 0.000 description 5\n\n238000003491 array Methods 0.000 description 4\n\n230000005540 biological transmission Effects 0.000 description 4\n\n210000003625 skull Anatomy 0.000 description 4\n\n241000282326 Felis catus Species 0.000 description 3\n\n230000000694 effects Effects 0.000 description 3\n\n238000013507 mapping Methods 0.000 description 3\n\n230000008520 organization Effects 0.000 description 3\n\n230000008569 process Effects 0.000 description 3\n\n238000010200 validation analysis Methods 0.000 description 3\n\n238000013459 approach Methods 0.000 description 2\n\n230000003993 interaction Effects 0.000 description 2\n\n230000006855 networking Effects 0.000 description 2\n\n230000003287 optical effect Effects 0.000 description 2\n\n230000001902 propagating effect Effects 0.000 description 2\n\n238000012384 transportation and delivery Methods 0.000 description 2\n\n238000012935 Averaging Methods 0.000 description 1\n\nRYGMFSIKBFXOCR-UHFFFAOYSA-N Copper Chemical compound [Cu] RYGMFSIKBFXOCR-UHFFFAOYSA-N 0.000 description 1\n\n230000003466 anti-cipated effect Effects 0.000 description 1\n\n230000008901 benefit Effects 0.000 description 1\n\n230000009172 bursting Effects 0.000 description 1\n\n230000001413 cellular effect Effects 0.000 description 1\n\n238000004140 cleaning Methods 0.000 description 1\n\n238000010276 construction Methods 0.000 description 1\n\n229910052802 copper Inorganic materials 0.000 description 1\n\n239000010949 copper Substances 0.000 description 1\n\n230000008878 coupling Effects 0.000 description 1\n\n238000010168 coupling process Methods 0.000 description 1\n\n238000005859 coupling reaction Methods 0.000 description 1\n\n238000012517 data analytics Methods 0.000 description 1\n\n230000001419 dependent effect Effects 0.000 description 1\n\n238000005516 engineering process Methods 0.000 description 1\n\n239000000284 extract Substances 0.000 description 1\n\n239000000835 fiber Substances 0.000 description 1\n\n230000006872 improvement Effects 0.000 description 1\n\n230000010354 integration Effects 0.000 description 1\n\n230000000670 limiting effect Effects 0.000 description 1\n\n238000004519 manufacturing process Methods 0.000 description 1\n\n230000007246 mechanism Effects 0.000 description 1\n\n239000000203 mixture Substances 0.000 description 1\n\n238000012986 modification Methods 0.000 description 1\n\n230000004048 modification Effects 0.000 description 1\n\n238000013439 planning Methods 0.000 description 1\n\n229920000747 poly(lactic acid) Polymers 0.000 description 1\n\n229920001690 polydopamine Polymers 0.000 description 1\n\n238000011176 pooling Methods 0.000 description 1\n\n230000002829 reductive effect Effects 0.000 description 1\n\n238000013468 resource allocation Methods 0.000 description 1\n\n230000002441 reversible effect Effects 0.000 description 1\n\n238000012552 review Methods 0.000 description 1\n\n239000004065 semiconductor Substances 0.000 description 1\n\n230000003068 static effect Effects 0.000 description 1\n\n238000012360 testing method Methods 0.000 description 1\n\n238000012795 verification Methods 0.000 description 1\n\nImages\n\nClassifications\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F40/00—Handling natural language data\n\nG06F40/30—Semantic analysis\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F40/00—Handling natural language data\n\nG06F40/20—Natural language analysis\n\nG06F40/279—Recognition of textual entities\n\nG06F40/284—Lexical analysis, e.g. tokenisation or collocates\n\nG—PHYSICS\n\nG16—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR SPECIFIC APPLICATION FIELDS\n\nG16H—HEALTHCARE INFORMATICS, i.e. INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR THE HANDLING OR PROCESSING OF MEDICAL OR HEALTHCARE DATA\n\nG16H10/00—ICT specially adapted for the handling or processing of patient-related medical or healthcare data\n\nG16H10/60—ICT specially adapted for the handling or processing of patient-related medical or healthcare data for patient-specific data, e.g. for electronic patient records\n\nG—PHYSICS\n\nG16—INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR SPECIFIC APPLICATION FIELDS\n\nG16H—HEALTHCARE INFORMATICS, i.e. INFORMATION AND COMMUNICATION TECHNOLOGY [ICT] SPECIALLY ADAPTED FOR THE HANDLING OR PROCESSING OF MEDICAL OR HEALTHCARE DATA\n\nG16H40/00—ICT specially adapted for the management or administration of healthcare resources or facilities; ICT specially adapted for the management or operation of medical equipment or devices\n\nG16H40/60—ICT specially adapted for the management or administration of healthcare resources or facilities; ICT specially adapted for the management or operation of medical equipment or devices for the operation of medical equipment or devices\n\nG16H40/67—ICT specially adapted for the management or administration of healthcare resources or facilities; ICT specially adapted for the management or operation of medical equipment or devices for the operation of medical equipment or devices for remote operation\n\nDefinitions\n\nthe present invention generally relates to natural language processing, and, more particularly, to combinations of domain-specific ontologies that may be used to enhance natural language processing.\n\nOne challenge in natural language processing is to impart meaning to embedded natural language features, beyond the use of contextual information.\n\nthe medical field is an area where embedded feature representations are potentially interpretable.\n\nDomain-specific information may be organized into ontologies, and may be derived from multiple different sources. Different ontologies may have overlapping, but non-identical, subject matter that pertains to a particular subject.\n\na method for performing a natural language processing task include identifying hypernym/hyponym relations in a depth-wise ontology and identifying synonymy relations in a breadth-wise ontology.\n\nthe depth-wise ontology and the breadth-wise ontology are combined into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations.\n\nEnhanced hypernym/hyponym relations are embedded using the combined ontology.\n\na natural language processing task is performed using the enhanced hypernym/hyponym relations and the combined ontology.\n\na system for performing a natural language processing task includes a hardware processor and a memory.\n\nthe memory is configured to store computer program code that, when executed by the hardware processor, implements a relation embedder, an ontology combiner, and a natural language processing task.\n\nthe relation embedder identifies hypernym/hyponym relations in a depth-wise ontology and synonymy relations in a breadth-wise ontology.\n\nthe ontology combiner combines the depth-wise ontology and the breadth-wise ontology into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations.\n\nthe relation embedder further embeds enhanced hypernym/hyponym relations using the combined ontology.\n\na natural language processing task uses the enhanced hypernym/hyponym relations and the combined ontology.\n\nFIG. 1 is a block/flow diagram of a method of combining ontologies and embedding ontological relations for use in a natural language processing task, in accordance with an embodiment of the present invention\n\nFIG. 2 is a block/flow diagram of a method of cleaning and improving a combined ontology, in accordance with an embodiment of the present invention\n\nFIG. 3 is a block/flow diagram of a method of forming a combined ontology based on a depth-wise ontology and a breadth-wise ontology, in accordance with an embodiment of the present invention\n\nFIG. 4 is a block diagram of a language processing system that uses combined ontologies, in accordance with an embodiment of the present invention\n\nFIG. 5 is a block diagram showing an illustrative cloud computing environment having one or more cloud computing nodes with which local computing devices used by cloud consumers communicate in accordance with an embodiment of the present invention\n\nFIG. 6 is a block diagram showing a set of functional abstraction layers provided by a cloud computing environment in accordance with an embodiment of the present invention.\n\nFIG. 7 is a diagram illustrating a text summarization natural language processing task, in accordance with an embodiment of the present invention.\n\nKnowledge-rich feature representations may be created using ontologies.\n\nthe knowledge and order information that is encoded in the ontologies may be extracted and then used for embedding. During subsequent natural language processing, this information can be leveraged to improve outcomes.\n\nICD International Classification of Diseases\n\ncodes include rich information, including hierarchical classifications, that can be incorporated in embeddings to process electronic health record data.\n\nTextual information from electronic health records can be used to predict, for example, unplanned hospital re-admissions and in-hospital mortality prediction.\n\nTextual information may be represented as sequences of vectors corresponding to the sequence of words in the physician's notes. The more accurately the semantics of the words are represented by the vectors, the more accurate the predictions are likely to be. By capturing the relationships between different elements in an ontology, the quality of the embedded vectors is improved, resulting in an improvement in any language processing task that uses the vectors.\n\nthe most effective embedding may not represent synonymy, but rather other relations between words.\n\nOther relations such as lexical entailment, relationships between captions and images, âpart-ofâ and âcauseâ relations, hypernym/hyponym, and other relations, may be captured in an ontology and may provide significant information regarding the underlying meaning of terms.\n\nHypernymy relationships are used to identify correspondences between the distinct ontologies.\n\nblock 102 considers each distinct ontology and represents the ordering relationships between terms.\n\nan approximate embedding may be determined, for terms with a partial order relation.\n\nan upper set of x may be constructed as â x â â y\n\nthe characteristic vector vec(x) y â of the upper set of x may be defined as:\n\na sketch vector sk(vec(x)) â d for a target dimension d, may be built so that, for x,y â , the dot product sk(vec(x)) â sk(vec(y)) â vec(x) â vec(y).\n\nthe upper sets â x â represent the partial order via the subset relation, such that x y â x â y â\n\n. Since the characteristic vectors have the property that vec(x) â vec(y)\n\nvec(x) gives a direct representation of ( , ) via the dot products.\n\nthe vectors are in dimensions, which may be too large to be useful.\n\nthe sketching operation maps the vec(x) to lower-dimensional vectors, while approximately preserving the dot products.\n\nAn embedding may be defined as, given x â , the vector:\n\nthe bit-flip hash function h 2 helps to reduce the effect of collisions, by averaging out their effects. However, with enough sparsity, h 2 may be omitted.\n\nThis embedding may be used to identify, for example, hypernym relations.\n\nThis relation exists between specific word meanings, and identifies a âkind ofâ relation, for example where first concept is a âkind ofâ a second concept.\n\nOne example is that the word âcatâ represents a kind of âanimal.â\n\nthe term âcatâ is a hyponym of âanimal,â and âanimalâ is a hypernym of âcat.â\n\nthe upper sets â x â for each word meaning may be the set of all meanings that are direct or indirect hypernyms of it.\n\nEach group of meanings may be represented as the union of their respective upper sets.\n\nthese meanings may be represented as âsynsetsâ in an ontology, referring to a set of one or more synonyms that are interchangeable in some context.\n\nunion of synsets may be represented a union of the respective upper sets, which may be represented as âlemmasâ in the ontology.\n\nR x , y def o â s â k â ( x ) â osk â ( y ) o â s â k â ( y ) â osk â ( y )\n\nR x,y can be expected to be close to 1. If x and y are not related, then the ratio R x,y â 0. Embedded representations can thus be tested using R x,y , where the positive case may include all synsets y and all unions of synsets x that have one meaning (synset) that is a hyponym of y. When testing the accuracy of the representation, a proxy for the negative, unrelated case, may be found in choosing, for each synset y, a number of unions x at random. Classifications may be determined by comparison of R x,y to a threshold value.\n\nan ontology's elements may be organized as synsets and lemmas.\n\nmultiple domain-specific ontologies may be combined, composing related elements across the multiple ontologies. For example, using synonymous concepts of a first ontology as the lemmas of a synset, contextual and ordering information may be captured when matching concepts to another ontology.\n\nBlock 104 uses the embedded depth-wise ontology terms, which represent hypernym/hyponym relations, to combine two or more distinct ontologies, for example including a depth-wise ontology that tracks hypernym/hyponym relations and a breadth-wise ontology that tracks synonyms. Given a depth-wise ontology term, block 104 splits the term into a complex query with every word in the term. For example, in the specific context of a medical ontology, a given disease may be a term that is made up of multiple words, each contributing to the meaning of the term.\n\nBlock 104 queries a breadth-wise ontology to find a preferred label and synonyms for the main concept in the complex query, where the main concept may be defined in the ontology.\n\nan ontology may include terms (T) that have several synonyms (S) linked with them.\n\nT terms\n\nS synonyms\n\nT may be a relationship indicated between T and S.\n\nT may be a âmain concept.â\n\nBlock 104 may then use heuristics, for example based on hypernym/hyponym or meronym relationships, to correlate terms across the ontologies using heuristics.\n\nBlock 106 identifies hypernym/hyponym relations within the combined ontology.\n\nHypernymy relations may be established by identifying members that take part in some sort of partial order, such as hypernymy or meronymy.\n\nthe hypernymy relation can be identified heuristically.\n\na hypernym may be identified as a member having multiple synonyms, while the synonyms are not mutually synonymous.\n\nâanimalâ may be identified as being synonymous with âcat,â âdot,â and âbird,â these terms are not synonymous with one another, suggesting that the term âanimalâ is a hypernym to each. This heuristic may be applied, regardless of the type of partial order.\n\nBlock 108 scores the combined ontology and infers correlations.\n\na function R x,y estimates relation strength between two elements to identify whether a hypernymy relation exists between the two elements. For example, the function may output a value between 0 and 1, with values closer to 1 representing a hypernym/hyponym relation.\n\nhypernym relations may be found heuristically in a first ontology, they may also be established in this manner in a parallel ontology that does not have hypernymy explicitly encoded.\n\nsome embodiments may score synonymy and hypernymy correlations differently. Most parts of deep hypernymy chains may be scored to a value that is close to 1, and a concept that is related between the two ontologies should have a value that is not close to 1. A main concept and its heuristically identified hyponyms may have a score value that is close to 1, while a main concept and its synonyms should have a value that is not close to 1.\n\nscoring mappings across ontologies may be used to discriminate between synonymy and hypernymy relations.\n\na subset S of terms in a first ontology, and a subset M of terms in a second ontology may be determined such that every term a in S has a synonym aâ² in M, and such that every term aâ² in M has a synonym a in S.\n\nBlock 110 performs a natural language processing task using the combined ontologies and the ordered embeddings.\n\nsuch combined ontologies may be particularly useful where ordered domain knowledge can be used, such as in summarization tasks and concept identification tasks.\n\nthis information can be used to identify disease mentions in electronic medical records, for example determining whether a disease is mentioned in a given sentence or paragraph.\n\nan original text 702 may be analyzed and a summary 704 may be generated that lists the concepts described in the original text 702 .\n\nFIG. 2 a method for completing and correcting an ordered ontology is shown. Further processing can be performed on the combined ontology to improve its quality. For example, having verified and established a hypernym/hyponym relation or synonym relation between two entities in the combined ontology, a difference in properties between the two entities can be used to infer missing fields in members of the combined ontology.\n\nField values of a first member, A may be inferred from a provided field value of a second member, B, where A is a hyponym, hypernym, or synonym of B.\n\nthe inference may involve clarifying importance and validation of properties to be included in a member that did not have them previously.\n\nthe inference may include domain knowledge, or may be performed entirely automatically.\n\nerroneous links may be identified, for example those that cause loops, and these links may be removed.\n\nan additional step may be avoided, but the check may also be performed separately.\n\nblock 202 a heuristic is applied that determines that a synonym or hyponym A of an entity B should have an equal or greater number of properties as compared to B.\n\nblock 202 identifies entities in the combined ontology that are incomplete. This process may include, for example, identifying hypernymy relations from a first, depth-wise ontology, and establishing links with a second, breadth-wise ontology.\n\nBlock 204 acts to complete the missing components, for example by filling in missing areas in the ontology, respecting hypernymy and synonymy relations.\n\nthe hypernym/hyponym relations may be embedded, as described above.\n\nBlock 206 cleans the ontology by identifying erroneous links through fully connected components. This may include review by a human operator, to verify that the identified link is actually incorrect. Block 206 modifies the hypernym and hyponym set of the synset in question. This, in turn, modifies the strongly connected component and the ontology. With the corrected ontology in place, block 208 can complete the embedding of hypernym/hyponym relations.\n\nBlock 302 selects a first concept in the first ontology and block 304 executes a query on the second ontology that includes tokens of the concept.\n\nblock 306 further validates the results, such that there is an overlap of at least one topic between the concept from the first ontology and the prefLabel, and between the concept and at least one synonym. This ensures sufficient contextual match between the entries of the first ontology and the second ontology, and also between the prefLabel information and the synonyms.\n\na concept from the first ontology which may include phrase-like entries, may be, e.g., âEntire occipitomastoid suture of skull (body structure).â\n\nthe second ontology may include more descriptive labels than the phrase-like entries of the first ontology.\n\na query on this concept may produce synonyms such as, âcranium,â âskulls,â âcalvaria,â âcalvarium,â with the associated prefLabel âskull.â\n\nthe query may also produce synonyms, on a different token, such as, âsuture technique,â âtechnique, suture,â âtechnics, suture,â with the associated prefLabel âsuture techniques.â In this manner, every token of the concept may be considered.\n\nBlock 308 determines whether there are additional concepts in the first ontology that have not yet been considered. If so, processing returns to block 302 to select a next concept. If not, then block 310 determines the combined ontology on the basis of the validated query results. After having established the link between the first ontology and the second ontology through validation of query results, the data structures representing the ontology may be amended, to have it properly represent the combined ontology. For example, the synsets of a particular hypernym, which might have initially had only a few words, may increase to multiple synsets by borrowing corresponding synonymous/related concepts from the second ontology.\n\nOne effect of this combination is to help curate a relatively noisy ontology. For example, if the first ontology includes subject matter that is not related to the subject matter of the second ontology, those uninformative concepts will not be included, as there will be no related synonyms in the second ontology.\n\nthe present invention may be a system, a method, and/or a computer program product at any possible technical detail level of integration\n\nthe computer program product may include a computer readable storage medium (or media) having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention\n\nthe computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device.\n\nthe computer readable storage medium may be, for example, but is not limited to, an electronic storage device, a magnetic storage device, an optical storage device, an electromagnetic storage device, a semiconductor storage device, or any suitable combination of the foregoing.\n\na non-exhaustive list of more specific examples of the computer readable storage medium includes the following: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), a static random access memory (SRAM), a portable compact disc read-only memory (CD-ROM), a digital versatile disk (DVD), a memory stick, a floppy disk, a mechanically encoded device such as punch-cards or raised structures in a groove having instructions recorded thereon, and any suitable combination of the foregoing.\n\nRAM random access memory\n\nROM read-only memory\n\nEPROM or Flash memory erasable programmable read-only memory\n\nSRAM static random access memory\n\nCD-ROM compact disc read-only memory\n\nDVD digital versatile disk\n\nmemory stick a floppy disk\n\na mechanically encoded device such as punch-cards or raised structures in a groove having instructions recorded thereon\n\na computer readable storage medium is not to be construed as being transitory signals per se, such as radio waves or other freely propagating electromagnetic waves, electromagnetic waves propagating through a waveguide or other transmission media (e.g., light pulses passing through a fiber-optic cable), or electrical signals transmitted through a wire.\n\nComputer readable program instructions described herein can be downloaded to respective computing/processing devices from a computer readable storage medium or to an external computer or external storage device via a network, for example, the Internet, a local area network, a wide area network and/or a wireless network.\n\nthe network may comprise copper transmission cables, optical transmission fibers, wireless transmission, routers, firewalls, switches, gateway computers and/or edge servers.\n\na network adapter card or network interface in each computing/processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing/processing device.\n\nComputer readable program instructions for carrying out operations of the present invention may be assembler instructions, instruction-set-architecture (ISA) instructions, machine instructions, machine dependent instructions, microcode, firmware instructions, state-setting data, configuration data for integrated circuitry, or either source code or object code written in any combination of one or more programming languages, including an object oriented programming language such as Smalltalk, C++, or the like, and procedural programming languages, such as the âCâ programming language or similar programming languages.\n\nthe computer readable program instructions may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server.\n\nthe remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider).\n\nelectronic circuitry including, for example, programmable logic circuitry, field-programmable gate arrays (FPGA), or programmable logic arrays (PLA) may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry, in order to perform aspects of the present invention.\n\nThese computer readable program instructions may be provided to a processor of a computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks.\n\nThese computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer, a programmable data processing apparatus, and/or other devices to function in a particular manner, such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function/act specified in the flowchart and/or block diagram block or blocks.\n\nthe computer readable program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other device to cause a series of operational steps to be performed on the computer, other programmable apparatus or other device to produce a computer implemented process, such that the instructions which execute on the computer, other programmable apparatus, or other device implement the functions/acts specified in the flowchart and/or block diagram block or blocks.\n\nany of the following â/â, âand/orâ, and âat least one ofâ, for example, in the cases of âA/Bâ, âA and/or Bâ and âat least one of A and Bâ, is intended to encompass the selection of the first listed option (A) only, or the selection of the second listed option (B) only, or the selection of both options (A and B).\n\nsuch phrasing is intended to encompass the selection of the first listed option (A) only, or the selection of the second listed option (B) only, or the selection of the third listed option (C) only, or the selection of the first and the second listed options (A and B) only, or the selection of the first and third listed options (A and C) only, or the selection of the second and third listed options (B and C) only, or the selection of all three options (A and B and C).\n\nThis may be extended, as readily apparent by one of ordinary skill in this and related arts, for as many items listed.\n\neach block in the flowchart or block diagrams may represent a module, segment, or portion of instructions, which comprises one or more executable instructions for implementing the specified logical function(s).\n\nthe functions noted in the blocks may occur out of the order noted in the Figures.\n\ntwo blocks shown in succession may, in fact, be accomplished as one step, executed concurrently, substantially concurrently, in a partially or wholly temporally overlapping manner, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved.\n\nthe term âhardware processor subsystemâ or âhardware processorâ can refer to a processor, memory, software or combinations thereof that cooperate to perform one or more specific tasks.\n\nthe hardware processor subsystem can include one or more data processing elements (e.g., logic circuits, processing circuits, instruction execution devices, etc.).\n\nthe one or more data processing elements can be included in a central processing unit, a graphics processing unit, and/or a separate processor- or computing element-based controller (e.g., logic gates, etc.).\n\nthe hardware processor subsystem can include one or more on-board memories (e.g., caches, dedicated memory arrays, read only memory, etc.).\n\nthe hardware processor subsystem can include one or more memories that can be on or off board or that can be dedicated for use by the hardware processor subsystem (e.g., ROM, RAM, basic input/output system (BIOS), etc.).\n\nthe hardware processor subsystem can include and execute one or more software elements.\n\nthe one or more software elements can include an operating system and/or one or more applications and/or specific code to achieve a specified result.\n\nthe hardware processor subsystem can include dedicated, specialized circuitry that performs one or more electronic processing functions to achieve a specified result.\n\nSuch circuitry can include one or more application-specific integrated circuits (ASICs), FPGAs, and/or PLAs.\n\nthe system 400 includes a hardware processor 402 and a memory 404 .\n\nthe system 400 may include a variety of functional modules. Each such module may be implemented in any appropriate way. For example, such modules may be implemented as computer program code that is stored in the memory 404 and that is executed by the hardware processor to perform the described function.\n\nOne or more modules may alternatively be implemented as one or more discrete hardware components, for example in the form of application-specific integrated chips or field-programmable gate arrays.\n\nthe memory 404 stores a first ontology 406 and a second ontology 408 .\n\nThese ontologies may be directed to shared subject matter, such as domain-specific medical information, and may be organized differently.\n\nthe first ontology 406 may be organized in a depth-wise fashion, with hypernym/hyponym relations being encoded\n\nthe second ontology 408 may be organized in a breadth-wise fashion, with synonym relations being encoded.\n\na relation embedder 410 works in with an ontology combiner 412 to produce a combined ontology 414 that uses the information from both ontologies to form an enriched knowledge base, with improved information relating to the relations between terms, and to produce improved embeddings of the relations between terms.\n\nThis improved embedded information may be used by a natural language task 416 , providing superior results as compared to performance of the task using separate ontologies. For example, a summarization task that extracts the meaning of an electronic health record is improved by finding better representations for the relationships between terms, producing a more accurate summary of the content.\n\na medical concept identification task for example, the ability to recognize whether a particular disease is mentioned in a given record is improved by better representing the relationships between terms.\n\nthe task has an improved ability to recognize the mention of a particular disease that is described using non-standard terminology in medical records.\n\nCloud computing is a model of service delivery for enabling convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, network bandwidth, servers, processing, memory, storage, applications, virtual machines, and services) that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service.\n\nThis cloud model may include at least five characteristics, at least three service models, and at least four deployment models.\n\nOn-demand self-service a cloud consumer can unilaterally provision computing capabilities, such as server time and network storage, as needed automatically without requiring human interaction with the service's provider.\n\nResource pooling the provider's computing resources are pooled to serve multiple consumers using a multi-tenant model, with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter).\n\nRapid elasticity capabilities can be rapidly and elastically provisioned, in some cases automatically, to quickly scale out and rapidly released to quickly scale in. To the consumer, the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.\n\nMeasured service cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts). Resource usage can be monitored, controlled, and reported, providing transparency for both the provider and consumer of the utilized service.\n\nlevel of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts).\n\nSaaS Software as a Service: the capability provided to the consumer is to use the provider's applications running on a cloud infrastructure.\n\nthe applications are accessible from various client devices through a thin client interface such as a web browser (e.g., web-based e-mail).\n\na web browser e.g., web-based e-mail\n\nthe consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited user-specific application configuration settings.\n\nPaaS Platform as a Service\n\nthe consumer does not manage or control the underlying cloud infrastructure including networks, servers, operating systems, or storage, but has control over the deployed applications and possibly application hosting environment configurations.\n\nIaaS Infrastructure as a Service\n\nthe consumer does not manage or control the underlying cloud infrastructure but has control over operating systems, storage, deployed applications, and possibly limited control of select networking components (e.g., host firewalls).\n\nPrivate cloud the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on-premises or off-premises.\n\nPublic cloud the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.\n\nHybrid cloud the cloud infrastructure is a composition of two or more clouds (private, community, or public) that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability (e.g., cloud bursting for load-balancing between clouds).\n\na cloud computing environment is service oriented with a focus on statelessness, low coupling, modularity, and semantic interoperability.\n\nAn infrastructure that includes a network of interconnected nodes.\n\ncloud computing environment 150 includes one or more cloud computing nodes 110 with which local computing devices used by cloud consumers, such as, for example, personal digital assistant (PDA) or cellular telephone 154 A, desktop computer 154 B, laptop computer 154 C, and/or automobile computer system 154 N may communicate.\n\nNodes 110 may communicate with one another. They may be grouped (not shown) physically or virtually, in one or more networks, such as Private, Community, Public, or Hybrid clouds as described hereinabove, or a combination thereof. This allows cloud computing environment 150 to offer infrastructure, platforms and/or software as services for which a cloud consumer does not need to maintain resources on a local computing device.\n\ncomputing devices 154 A-N shown in FIG. 1 are intended to be illustrative only and that computing nodes 110 and cloud computing environment 150 can communicate with any type of computerized device over any type of network and/or network addressable connection (e.g., using a web browser).\n\nFIG. 6 a set of functional abstraction layers provided by cloud computing environment 50 ( FIG. 5 ) is shown. It should be understood in advance that the components, layers, and functions shown in FIG. 8 are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted, the following layers and corresponding functions are provided:\n\nHardware and software layer 60 includes hardware and software components.\n\nhardware components include: mainframes 61 ; RISC (Reduced Instruction Set Computer) architecture based servers 62 ; servers 63 ; blade servers 64 ; storage devices 65 ; and networks and networking components 66 .\n\nsoftware components include network application server software 67 and database software 68 .\n\nVirtualization layer 70 provides an abstraction layer from which the following examples of virtual entities may be provided: virtual servers 71 ; virtual storage 72 ; virtual networks 73 , including virtual private networks; virtual applications and operating systems 74 ; and virtual clients 75 .\n\nmanagement layer 80 may provide the functions described below.\n\nResource provisioning 81 provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment.\n\nMetering and Pricing 82 provide cost tracking as resources are utilized within the cloud computing environment, and billing or invoicing for consumption of these resources. In one example, these resources may include application software licenses.\n\nSecurity provides identity verification for cloud consumers and tasks, as well as protection for data and other resources.\n\nUser portal 83 provides access to the cloud computing environment for consumers and system administrators.\n\nService level management 84 provides cloud computing resource allocation and management such that required service levels are met.\n\nService Level Agreement (SLA) planning and fulfillment 85 provide pre-arrangement for, and procurement of, cloud computing resources for which a future requirement is anticipated in accordance with an SLA.\n\nSLA Service Level Agreement\n\nWorkloads layer 90 provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include: mapping and navigation 91 ; software development and lifecycle management 92 ; virtual classroom education delivery 93 ; data analytics processing 94 ; transaction processing 95 ; and natural language processing 96 .\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nTheoretical Computer Science (AREA)\n\nHealth & Medical Sciences (AREA)\n\nGeneral Health & Medical Sciences (AREA)\n\nGeneral Physics & Mathematics (AREA)\n\nComputational Linguistics (AREA)\n\nPhysics & Mathematics (AREA)\n\nGeneral Engineering & Computer Science (AREA)\n\nAudiology, Speech & Language Pathology (AREA)\n\nArtificial Intelligence (AREA)\n\nMedical Informatics (AREA)\n\nEpidemiology (AREA)\n\nPrimary Health Care (AREA)\n\nPublic Health (AREA)\n\nBiomedical Technology (AREA)\n\nBusiness, Economics & Management (AREA)\n\nGeneral Business, Economics & Management (AREA)\n\nMachine Translation (AREA)\n\nAbstract\n\nMethods and systems for performing a natural language processing task include identifying hypernym/hyponym relations in a depth-wise ontology and identifying synonymy relations in a breadth-wise ontology. The depth-wise ontology and the breadth-wise ontology are combined into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations. Enhanced hypernym/hyponym relations are embedded using the combined ontology. A natural language processing task is performed using the enhanced hypernym/hyponym relations and the combined ontology.\n\nDescription\n\nSTATEMENT REGARDING PRIOR DISCLOSURES BY THE INVENTOR OR A JOINT INVENTOR\n\nThe following disclosure(s) are submitted under 35 U.S.C. Â§ 102(b)(1)(A):\n\nDISCLOSURE(S): Order Embeddings from Merged Ontologies using Sketching, by Kenneth L. Clarkson and Sanjana Sahayaraj, on Jan. 6, 2021.\n\nBACKGROUND\n\nThe present invention generally relates to natural language processing, and, more particularly, to combinations of domain-specific ontologies that may be used to enhance natural language processing.\n\nOne challenge in natural language processing is to impart meaning to embedded natural language features, beyond the use of contextual information. For example, the medical field is an area where embedded feature representations are potentially interpretable.\n\nDomain-specific information may be organized into ontologies, and may be derived from multiple different sources. Different ontologies may have overlapping, but non-identical, subject matter that pertains to a particular subject.\n\nSUMMARY\n\nA method for performing a natural language processing task include identifying hypernym/hyponym relations in a depth-wise ontology and identifying synonymy relations in a breadth-wise ontology. The depth-wise ontology and the breadth-wise ontology are combined into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations. Enhanced hypernym/hyponym relations are embedded using the combined ontology. A natural language processing task is performed using the enhanced hypernym/hyponym relations and the combined ontology.\n\nA system for performing a natural language processing task includes a hardware processor and a memory. The memory is configured to store computer program code that, when executed by the hardware processor, implements a relation embedder, an ontology combiner, and a natural language processing task. The relation embedder identifies hypernym/hyponym relations in a depth-wise ontology and synonymy relations in a breadth-wise ontology. The ontology combiner combines the depth-wise ontology and the breadth-wise ontology into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations. The relation embedder further embeds enhanced hypernym/hyponym relations using the combined ontology. A natural language processing task uses the enhanced hypernym/hyponym relations and the combined ontology.\n\nThese and other features and advantages will become apparent from the following detailed description of illustrative embodiments thereof, which is to be read in connection with the accompanying drawings.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nThe following description will provide details of preferred embodiments with reference to the following figures wherein:\n\nFIG. 1 is a block/flow diagram of a method of combining ontologies and embedding ontological relations for use in a natural language processing task, in accordance with an embodiment of the present invention;\n\nFIG. 2 is a block/flow diagram of a method of cleaning and improving a combined ontology, in accordance with an embodiment of the present invention;\n\nFIG. 3 is a block/flow diagram of a method of forming a combined ontology based on a depth-wise ontology and a breadth-wise ontology, in accordance with an embodiment of the present invention;\n\nFIG. 4 is a block diagram of a language processing system that uses combined ontologies, in accordance with an embodiment of the present invention;\n\nFIG. 5 is a block diagram showing an illustrative cloud computing environment having one or more cloud computing nodes with which local computing devices used by cloud consumers communicate in accordance with an embodiment of the present invention;\n\nFIG. 6 is a block diagram showing a set of functional abstraction layers provided by a cloud computing environment in accordance with an embodiment of the present invention; and\n\nFIG. 7 is a diagram illustrating a text summarization natural language processing task, in accordance with an embodiment of the present invention.\n\nDETAILED DESCRIPTION\n\nKnowledge-rich feature representations may be created using ontologies. The knowledge and order information that is encoded in the ontologies may be extracted and then used for embedding. During subsequent natural language processing, this information can be leveraged to improve outcomes. For example, in medical fields, International Classification of Diseases (ICD) codes include rich information, including hierarchical classifications, that can be incorporated in embeddings to process electronic health record data.\n\nTextual information from electronic health records, such as physician's notes for a patient, can be used to predict, for example, unplanned hospital re-admissions and in-hospital mortality prediction. Textual information may be represented as sequences of vectors corresponding to the sequence of words in the physician's notes. The more accurately the semantics of the words are represented by the vectors, the more accurate the predictions are likely to be. By capturing the relationships between different elements in an ontology, the quality of the embedded vectors is improved, resulting in an improvement in any language processing task that uses the vectors.\n\nIn the context of ontologies, the most effective embedding may not represent synonymy, but rather other relations between words. Other relations, such as lexical entailment, relationships between captions and images, âpart-ofâ and âcauseâ relations, hypernym/hyponym, and other relations, may be captured in an ontology and may provide significant information regarding the underlying meaning of terms.\n\nIt is to be understood that although this disclosure includes a detailed description on cloud computing, implementation of the teachings recited herein are not limited to a cloud computing environment. Rather, embodiments of the present invention are capable of being implemented in conjunction with any other type of computing environment now known or later developed.\n\nReferring now to FIG. 1, a method for performing a natural language processing task using combined ontologies is shown. Hypernymy relationships, for example represented as embedded vectors, are used to identify correspondences between the distinct ontologies. In particular, block 102 considers each distinct ontology and represents the ordering relationships between terms. To capture this information, an approximate embedding may be determined, for terms with a partial order relation. For example, in the partially ordered set ( , ), for all xâ , an upper set of x may be constructed as â¬{x} {y|x y}. The characteristic vector vec(x)yâ of the upper set of x may be defined as:\n\nvec â¡ ( x ) y â { 0 , 1 } = def { 1 y â â { x } 0 otherwise\n\nA sketch vector sk(vec(x))â d, for a target dimension d, may be built so that, for x,yâ , the dot product sk(vec(x))Â·sk(vec(y))âvec(x)Â·vec(y). The upper sets â¬{x} represent the partial order via the subset relation, such that x yââ¬{x}ââ¬{y}â|â¬{x}â©â¬{y}|=|â¬{y}|. Since the characteristic vectors have the property that vec(x)Â·vec(y)=|â¬{x}â©â¬{y}|, then:\n\nx yâvec(x)Â·vec(y)=vec(y)Â·vec(y)\n\nThus, vec(x) gives a direct representation of ( , ) via the dot products. However, the vectors are in dimensions, which may be too large to be useful. Thus, the sketching operation maps the vec(x) to lower-dimensional vectors, while approximately preserving the dot products.\n\nIn particular, two hash functions may be defined:\n\nh 1: â[d]\n\nh 2: â{â1,+1}\n\nwhere [d] {1, 2, . . . , d}. In an ideal setting the hash functions are uniformly random over [d] and {â1, +1}, respectively, though in some embodiments, the second hash function may instead be implemented as the trivial h2: â{+1}. Given a vector vâ , the sketch in d may have coordinates:\n\ns â¢ k c ( v ) i = def â y : h 1 â¢ ( y ) = i v y â¢ h 2 ( y )\n\nThis may be expressed as the sum of the bit flips h2 (y), over the yâ , such that vy=1 and y hashes to i, using h1.\n\nAn embedding may be defined as, given xâ , the vector:\n\nos â¢ k â¡ ( x ) i = def â x â¤ y h 1 ( y ) = i h 2 ( y ) , for â¢ i â [ d ]\n\nAssuming that h1 and h2 are random, then skc(v)Â·skc(w) is an unbiased estimator of vÂ·w, for v, wâ : [skc(v)Â·skc(w)]=vÂ·w. Given sufficient randomness in the hash function outputs, any appropriate hash function may be used for h1 and h2. If v and w are very sparse, such that there are no collisions in their sketches, then skc(v)Â·skc(w)=vÂ·w. This sparsity may be defined as h1(y)â h1(yâ²) for any y, yâ², with vy=vyâ²=1 or wy=wyâ²=1. More generally, the sparser that v and w are, the more accurate the sketch-based estimate of the dot product will be. The bit-flip hash function h2 helps to reduce the effect of collisions, by averaging out their effects. However, with enough sparsity, h2 may be omitted.\n\nThis embedding may be used to identify, for example, hypernym relations. This relation exists between specific word meanings, and identifies a âkind ofâ relation, for example where first concept is a âkind ofâ a second concept. One example is that the word âcatâ represents a kind of âanimal.â In this example, the term âcatâ is a hyponym of âanimal,â and âanimalâ is a hypernym of âcat.â The upper sets â¬{x} for each word meaning may be the set of all meanings that are direct or indirect hypernyms of it. Each group of meanings may be represented as the union of their respective upper sets. In some embodiments, these meanings may be represented as âsynsetsâ in an ontology, referring to a set of one or more synonyms that are interchangeable in some context. Thus, union of synsets may be represented a union of the respective upper sets, which may be represented as âlemmasâ in the ontology.\n\nWhen a synset y is a hypernym of a union of synsets x, then |â¬{x}â©â¬{y}|=|â¬{y}| by construction. In this case, the ratio:\n\nR x , y = def o â¢ s â¢ k â¡ ( x ) Â· osk â¡ ( y ) o â¢ s â¢ k â¡ ( y ) Â· osk â¡ ( y )\n\ncan be expected to be close to 1. If x and y are not related, then the ratio Rx,yâ0. Embedded representations can thus be tested using Rx,y, where the positive case may include all synsets y and all unions of synsets x that have one meaning (synset) that is a hyponym of y. When testing the accuracy of the representation, a proxy for the negative, unrelated case, may be found in choosing, for each synset y, a number of unions x at random. Classifications may be determined by comparison of Rx,y to a threshold value.\n\nWhile this represents one specific manner of embedding the partial order of terms in an ontology, it should be understood that other approaches may be used, such as simhash and minhash, but these approaches may be more complex and computationally expensive.\n\nFor this embedding to be useful in a particular domain, an ontology's elements may be organized as synsets and lemmas. In some cases, multiple domain-specific ontologies may be combined, composing related elements across the multiple ontologies. For example, using synonymous concepts of a first ontology as the lemmas of a synset, contextual and ordering information may be captured when matching concepts to another ontology.\n\nBlock 104 uses the embedded depth-wise ontology terms, which represent hypernym/hyponym relations, to combine two or more distinct ontologies, for example including a depth-wise ontology that tracks hypernym/hyponym relations and a breadth-wise ontology that tracks synonyms. Given a depth-wise ontology term, block 104 splits the term into a complex query with every word in the term. For example, in the specific context of a medical ontology, a given disease may be a term that is made up of multiple words, each contributing to the meaning of the term.\n\nBlock 104 queries a breadth-wise ontology to find a preferred label and synonyms for the main concept in the complex query, where the main concept may be defined in the ontology. For example, an ontology may include terms (T) that have several synonyms (S) linked with them. Thus, there may be a relationship indicated between T and S. However, there may be no relationship between the synonyms S for a given term T. In such an example, the term T may be a âmain concept.â Block 104 may then use heuristics, for example based on hypernym/hyponym or meronym relationships, to correlate terms across the ontologies using heuristics.\n\nBlock 106 then identifies hypernym/hyponym relations within the combined ontology. Hypernymy relations may be established by identifying members that take part in some sort of partial order, such as hypernymy or meronymy. The hypernymy relation can be identified heuristically. For example, a hypernym may be identified as a member having multiple synonyms, while the synonyms are not mutually synonymous. Thus, while âanimalâ may be identified as being synonymous with âcat,â âdot,â and âbird,â these terms are not synonymous with one another, suggesting that the term âanimalâ is a hypernym to each. This heuristic may be applied, regardless of the type of partial order.\n\nBlock 108 scores the combined ontology and infers correlations. A function Rx,y estimates relation strength between two elements to identify whether a hypernymy relation exists between the two elements. For example, the function may output a value between 0 and 1, with values closer to 1 representing a hypernym/hyponym relation. Thus, whereas hypernym relations may be found heuristically in a first ontology, they may also be established in this manner in a parallel ontology that does not have hypernymy explicitly encoded.\n\nFollowing the example of combining two parallel medical ontologies, some embodiments may score synonymy and hypernymy correlations differently. Most parts of deep hypernymy chains may be scored to a value that is close to 1, and a concept that is related between the two ontologies should have a value that is not close to 1. A main concept and its heuristically identified hyponyms may have a score value that is close to 1, while a main concept and its synonyms should have a value that is not close to 1.\n\nIn some embodiments, scoring mappings across ontologies may be used to discriminate between synonymy and hypernymy relations. A subset S of terms in a first ontology, and a subset M of terms in a second ontology, may be determined such that every term a in S has a synonym aâ² in M, and such that every term aâ² in M has a synonym a in S. There is an order on S, and an order on M, so that some measure of the correlation between a<b and aâ²<bâ² for any elements a and b. These mappings may be established through a scoring and can then be used to merge members or to perform other operations on ontologies.\n\nBlock 110 performs a natural language processing task using the combined ontologies and the ordered embeddings. For example, such combined ontologies may be particularly useful where ordered domain knowledge can be used, such as in summarization tasks and concept identification tasks. In the context of medical ontologies, this information can be used to identify disease mentions in electronic medical records, for example determining whether a disease is mentioned in a given sentence or paragraph. For example, as shown in FIG. 7, an original text 702 may be analyzed and a summary 704 may be generated that lists the concepts described in the original text 702.\n\nReferring now to FIG. 2, a method for completing and correcting an ordered ontology is shown. Further processing can be performed on the combined ontology to improve its quality. For example, having verified and established a hypernym/hyponym relation or synonym relation between two entities in the combined ontology, a difference in properties between the two entities can be used to infer missing fields in members of the combined ontology. Field values of a first member, A, may be inferred from a provided field value of a second member, B, where A is a hyponym, hypernym, or synonym of B. The inference may involve clarifying importance and validation of properties to be included in a member that did not have them previously. The inference may include domain knowledge, or may be performed entirely automatically. Having established an order between two elements in an ontology, erroneous links may be identified, for example those that cause loops, and these links may be removed. By discovering these erroneous links while getting the embedded vectors, an additional step may be avoided, but the check may also be performed separately.\n\nIn block 202, a heuristic is applied that determines that a synonym or hyponym A of an entity B should have an equal or greater number of properties as compared to B. Thus, block 202 identifies entities in the combined ontology that are incomplete. This process may include, for example, identifying hypernymy relations from a first, depth-wise ontology, and establishing links with a second, breadth-wise ontology.\n\nThe synsets may be expanded using the breadth-wise ontology. Block 204 acts to complete the missing components, for example by filling in missing areas in the ontology, respecting hypernymy and synonymy relations. The hypernym/hyponym relations may be embedded, as described above.\n\nBlock 206 cleans the ontology by identifying erroneous links through fully connected components. This may include review by a human operator, to verify that the identified link is actually incorrect. Block 206 modifies the hypernym and hyponym set of the synset in question. This, in turn, modifies the strongly connected component and the ontology. With the corrected ontology in place, block 208 can complete the embedding of hypernym/hyponym relations.\n\nReferring now to FIG. 3, additional detail is shown for the combining of ontologies in block 104. Block 302 selects a first concept in the first ontology and block 304 executes a query on the second ontology that includes tokens of the concept. Out of the accepted return results from the second ontology, for example including prefLabel and synonym attributes, block 306 further validates the results, such that there is an overlap of at least one topic between the concept from the first ontology and the prefLabel, and between the concept and at least one synonym. This ensures sufficient contextual match between the entries of the first ontology and the second ontology, and also between the prefLabel information and the synonyms.\n\nIn one example, a concept from the first ontology, which may include phrase-like entries, may be, e.g., âEntire occipitomastoid suture of skull (body structure).â The second ontology may include more descriptive labels than the phrase-like entries of the first ontology. As a result, the results from the second ontology that pass the validation are likely to include information related to the concept and to exclude non-informative parts, like prepositions and determinants. Thus, a query on this concept may produce synonyms such as, âcranium,â âskulls,â âcalvaria,â âcalvarium,â with the associated prefLabel âskull.â The query may also produce synonyms, on a different token, such as, âsuture technique,â âtechnique, suture,â âtechnics, suture,â with the associated prefLabel âsuture techniques.â In this manner, every token of the concept may be considered.\n\nBlock 308 then determines whether there are additional concepts in the first ontology that have not yet been considered. If so, processing returns to block 302 to select a next concept. If not, then block 310 determines the combined ontology on the basis of the validated query results. After having established the link between the first ontology and the second ontology through validation of query results, the data structures representing the ontology may be amended, to have it properly represent the combined ontology. For example, the synsets of a particular hypernym, which might have initially had only a few words, may increase to multiple synsets by borrowing corresponding synonymous/related concepts from the second ontology.\n\nOne effect of this combination is to help curate a relatively noisy ontology. For example, if the first ontology includes subject matter that is not related to the subject matter of the second ontology, those uninformative concepts will not be included, as there will be no related synonyms in the second ontology.\n\nThe present invention may be a system, a method, and/or a computer program product at any possible technical detail level of integration. The computer program product may include a computer readable storage medium (or media) having computer readable program instructions thereon for causing a processor to carry out aspects of the present invention.\n\nThe computer readable storage medium can be a tangible device that can retain and store instructions for use by an instruction execution device. The computer readable storage medium may be, for example, but is not limited to, an electronic storage device, a magnetic storage device, an optical storage device, an electromagnetic storage device, a semiconductor storage device, or any suitable combination of the foregoing. A non-exhaustive list of more specific examples of the computer readable storage medium includes the following: a portable computer diskette, a hard disk, a random access memory (RAM), a read-only memory (ROM), an erasable programmable read-only memory (EPROM or Flash memory), a static random access memory (SRAM), a portable compact disc read-only memory (CD-ROM), a digital versatile disk (DVD), a memory stick, a floppy disk, a mechanically encoded device such as punch-cards or raised structures in a groove having instructions recorded thereon, and any suitable combination of the foregoing. A computer readable storage medium, as used herein, is not to be construed as being transitory signals per se, such as radio waves or other freely propagating electromagnetic waves, electromagnetic waves propagating through a waveguide or other transmission media (e.g., light pulses passing through a fiber-optic cable), or electrical signals transmitted through a wire.\n\nComputer readable program instructions described herein can be downloaded to respective computing/processing devices from a computer readable storage medium or to an external computer or external storage device via a network, for example, the Internet, a local area network, a wide area network and/or a wireless network. The network may comprise copper transmission cables, optical transmission fibers, wireless transmission, routers, firewalls, switches, gateway computers and/or edge servers. A network adapter card or network interface in each computing/processing device receives computer readable program instructions from the network and forwards the computer readable program instructions for storage in a computer readable storage medium within the respective computing/processing device.\n\nComputer readable program instructions for carrying out operations of the present invention may be assembler instructions, instruction-set-architecture (ISA) instructions, machine instructions, machine dependent instructions, microcode, firmware instructions, state-setting data, configuration data for integrated circuitry, or either source code or object code written in any combination of one or more programming languages, including an object oriented programming language such as Smalltalk, C++, or the like, and procedural programming languages, such as the âCâ programming language or similar programming languages. The computer readable program instructions may execute entirely on the user's computer, partly on the user's computer, as a stand-alone software package, partly on the user's computer and partly on a remote computer or entirely on the remote computer or server. In the latter scenario, the remote computer may be connected to the user's computer through any type of network, including a local area network (LAN) or a wide area network (WAN), or the connection may be made to an external computer (for example, through the Internet using an Internet Service Provider). In some embodiments, electronic circuitry including, for example, programmable logic circuitry, field-programmable gate arrays (FPGA), or programmable logic arrays (PLA) may execute the computer readable program instructions by utilizing state information of the computer readable program instructions to personalize the electronic circuitry, in order to perform aspects of the present invention.\n\nAspects of the present invention are described herein with reference to flowchart illustrations and/or block diagrams of methods, apparatus (systems), and computer program products according to embodiments of the invention. It will be understood that each block of the flowchart illustrations and/or block diagrams, and combinations of blocks in the flowchart illustrations and/or block diagrams, can be implemented by computer readable program instructions.\n\nThese computer readable program instructions may be provided to a processor of a computer, or other programmable data processing apparatus to produce a machine, such that the instructions, which execute via the processor of the computer or other programmable data processing apparatus, create means for implementing the functions/acts specified in the flowchart and/or block diagram block or blocks. These computer readable program instructions may also be stored in a computer readable storage medium that can direct a computer, a programmable data processing apparatus, and/or other devices to function in a particular manner, such that the computer readable storage medium having instructions stored therein comprises an article of manufacture including instructions which implement aspects of the function/act specified in the flowchart and/or block diagram block or blocks.\n\nThe computer readable program instructions may also be loaded onto a computer, other programmable data processing apparatus, or other device to cause a series of operational steps to be performed on the computer, other programmable apparatus or other device to produce a computer implemented process, such that the instructions which execute on the computer, other programmable apparatus, or other device implement the functions/acts specified in the flowchart and/or block diagram block or blocks.\n\nReference in the specification to âone embodimentâ or âan embodimentâ of the present invention, as well as other variations thereof, means that a particular feature, structure, characteristic, and so forth described in connection with the embodiment is included in at least one embodiment of the present invention. Thus, the appearances of the phrase âin one embodimentâ or âin an embodimentâ, as well any other variations, appearing in various places throughout the specification are not necessarily all referring to the same embodiment.\n\nIt is to be appreciated that the use of any of the following â/â, âand/orâ, and âat least one ofâ, for example, in the cases of âA/Bâ, âA and/or Bâ and âat least one of A and Bâ, is intended to encompass the selection of the first listed option (A) only, or the selection of the second listed option (B) only, or the selection of both options (A and B). As a further example, in the cases of âA, B, and/or Câ and âat least one of A, B, and Câ, such phrasing is intended to encompass the selection of the first listed option (A) only, or the selection of the second listed option (B) only, or the selection of the third listed option (C) only, or the selection of the first and the second listed options (A and B) only, or the selection of the first and third listed options (A and C) only, or the selection of the second and third listed options (B and C) only, or the selection of all three options (A and B and C). This may be extended, as readily apparent by one of ordinary skill in this and related arts, for as many items listed.\n\nThe flowchart and block diagrams in the Figures illustrate the architecture, functionality, and operation of possible implementations of systems, methods, and computer program products according to various embodiments of the present invention. In this regard, each block in the flowchart or block diagrams may represent a module, segment, or portion of instructions, which comprises one or more executable instructions for implementing the specified logical function(s). In some alternative implementations, the functions noted in the blocks may occur out of the order noted in the Figures. For example, two blocks shown in succession may, in fact, be accomplished as one step, executed concurrently, substantially concurrently, in a partially or wholly temporally overlapping manner, or the blocks may sometimes be executed in the reverse order, depending upon the functionality involved. It will also be noted that each block of the block diagrams and/or flowchart illustration, and combinations of blocks in the block diagrams and/or flowchart illustration, can be implemented by special purpose hardware-based systems that perform the specified functions or acts or carry out combinations of special purpose hardware and computer instructions.\n\nAs employed herein, the term âhardware processor subsystemâ or âhardware processorâ can refer to a processor, memory, software or combinations thereof that cooperate to perform one or more specific tasks. In useful embodiments, the hardware processor subsystem can include one or more data processing elements (e.g., logic circuits, processing circuits, instruction execution devices, etc.). The one or more data processing elements can be included in a central processing unit, a graphics processing unit, and/or a separate processor- or computing element-based controller (e.g., logic gates, etc.). The hardware processor subsystem can include one or more on-board memories (e.g., caches, dedicated memory arrays, read only memory, etc.). In some embodiments, the hardware processor subsystem can include one or more memories that can be on or off board or that can be dedicated for use by the hardware processor subsystem (e.g., ROM, RAM, basic input/output system (BIOS), etc.).\n\nIn some embodiments, the hardware processor subsystem can include and execute one or more software elements. The one or more software elements can include an operating system and/or one or more applications and/or specific code to achieve a specified result.\n\nIn other embodiments, the hardware processor subsystem can include dedicated, specialized circuitry that performs one or more electronic processing functions to achieve a specified result. Such circuitry can include one or more application-specific integrated circuits (ASICs), FPGAs, and/or PLAs.\n\nThese and other variations of a hardware processor subsystem are also contemplated in accordance with embodiments of the present invention.\n\nReferring now to FIG. 4, a combined-ontology language processing system 400 is shown. The system 400 includes a hardware processor 402 and a memory 404. The system 400 may include a variety of functional modules. Each such module may be implemented in any appropriate way. For example, such modules may be implemented as computer program code that is stored in the memory 404 and that is executed by the hardware processor to perform the described function. One or more modules may alternatively be implemented as one or more discrete hardware components, for example in the form of application-specific integrated chips or field-programmable gate arrays.\n\nThe memory 404 stores a first ontology 406 and a second ontology 408. These ontologies may be directed to shared subject matter, such as domain-specific medical information, and may be organized differently. For example, the first ontology 406 may be organized in a depth-wise fashion, with hypernym/hyponym relations being encoded, while the second ontology 408 may be organized in a breadth-wise fashion, with synonym relations being encoded. A relation embedder 410 works in with an ontology combiner 412 to produce a combined ontology 414 that uses the information from both ontologies to form an enriched knowledge base, with improved information relating to the relations between terms, and to produce improved embeddings of the relations between terms.\n\nThis improved embedded information may be used by a natural language task 416, providing superior results as compared to performance of the task using separate ontologies. For example, a summarization task that extracts the meaning of an electronic health record is improved by finding better representations for the relationships between terms, producing a more accurate summary of the content. In a medical concept identification task, for example, the ability to recognize whether a particular disease is mentioned in a given record is improved by better representing the relationships between terms. In one example, the task has an improved ability to recognize the mention of a particular disease that is described using non-standard terminology in medical records.\n\nCloud computing is a model of service delivery for enabling convenient, on-demand network access to a shared pool of configurable computing resources (e.g., networks, network bandwidth, servers, processing, memory, storage, applications, virtual machines, and services) that can be rapidly provisioned and released with minimal management effort or interaction with a provider of the service. This cloud model may include at least five characteristics, at least three service models, and at least four deployment models.\n\nCharacteristics are as follows:\n\nOn-demand self-service: a cloud consumer can unilaterally provision computing capabilities, such as server time and network storage, as needed automatically without requiring human interaction with the service's provider.\n\nBroad network access: capabilities are available over a network and accessed through standard mechanisms that promote use by heterogeneous thin or thick client platforms (e.g., mobile phones, laptops, and PDAs).\n\nResource pooling: the provider's computing resources are pooled to serve multiple consumers using a multi-tenant model, with different physical and virtual resources dynamically assigned and reassigned according to demand. There is a sense of location independence in that the consumer generally has no control or knowledge over the exact location of the provided resources but may be able to specify location at a higher level of abstraction (e.g., country, state, or datacenter).\n\nRapid elasticity: capabilities can be rapidly and elastically provisioned, in some cases automatically, to quickly scale out and rapidly released to quickly scale in. To the consumer, the capabilities available for provisioning often appear to be unlimited and can be purchased in any quantity at any time.\n\nMeasured service: cloud systems automatically control and optimize resource use by leveraging a metering capability at some level of abstraction appropriate to the type of service (e.g., storage, processing, bandwidth, and active user accounts). Resource usage can be monitored, controlled, and reported, providing transparency for both the provider and consumer of the utilized service.\n\nService Models are as follows:\n\nSoftware as a Service (SaaS): the capability provided to the consumer is to use the provider's applications running on a cloud infrastructure. The applications are accessible from various client devices through a thin client interface such as a web browser (e.g., web-based e-mail). The consumer does not manage or control the underlying cloud infrastructure including network, servers, operating systems, storage, or even individual application capabilities, with the possible exception of limited user-specific application configuration settings.\n\nPlatform as a Service (PaaS): the capability provided to the consumer is to deploy onto the cloud infrastructure consumer-created or acquired applications created using programming languages and tools supported by the provider. The consumer does not manage or control the underlying cloud infrastructure including networks, servers, operating systems, or storage, but has control over the deployed applications and possibly application hosting environment configurations.\n\nInfrastructure as a Service (IaaS): the capability provided to the consumer is to provision processing, storage, networks, and other fundamental computing resources where the consumer is able to deploy and run arbitrary software, which can include operating systems and applications. The consumer does not manage or control the underlying cloud infrastructure but has control over operating systems, storage, deployed applications, and possibly limited control of select networking components (e.g., host firewalls).\n\nDeployment Models are as follows:\n\nPrivate cloud: the cloud infrastructure is operated solely for an organization. It may be managed by the organization or a third party and may exist on-premises or off-premises.\n\nCommunity cloud: the cloud infrastructure is shared by several organizations and supports a specific community that has shared concerns (e.g., mission, security requirements, policy, and compliance considerations). It may be managed by the organizations or a third party and may exist on-premises or off-premises.\n\nPublic cloud: the cloud infrastructure is made available to the general public or a large industry group and is owned by an organization selling cloud services.\n\nHybrid cloud: the cloud infrastructure is a composition of two or more clouds (private, community, or public) that remain unique entities but are bound together by standardized or proprietary technology that enables data and application portability (e.g., cloud bursting for load-balancing between clouds).\n\nA cloud computing environment is service oriented with a focus on statelessness, low coupling, modularity, and semantic interoperability. At the heart of cloud computing is an infrastructure that includes a network of interconnected nodes.\n\nReferring now to FIG. 5, illustrative cloud computing environment 150 is depicted. As shown, cloud computing environment 150 includes one or more cloud computing nodes 110 with which local computing devices used by cloud consumers, such as, for example, personal digital assistant (PDA) or cellular telephone 154A, desktop computer 154B, laptop computer 154C, and/or automobile computer system 154N may communicate. Nodes 110 may communicate with one another. They may be grouped (not shown) physically or virtually, in one or more networks, such as Private, Community, Public, or Hybrid clouds as described hereinabove, or a combination thereof. This allows cloud computing environment 150 to offer infrastructure, platforms and/or software as services for which a cloud consumer does not need to maintain resources on a local computing device. It is understood that the types of computing devices 154A-N shown in FIG. 1 are intended to be illustrative only and that computing nodes 110 and cloud computing environment 150 can communicate with any type of computerized device over any type of network and/or network addressable connection (e.g., using a web browser).\n\nReferring now to FIG. 6, a set of functional abstraction layers provided by cloud computing environment 50 (FIG. 5) is shown. It should be understood in advance that the components, layers, and functions shown in FIG. 8 are intended to be illustrative only and embodiments of the invention are not limited thereto. As depicted, the following layers and corresponding functions are provided:\n\nHardware and software layer 60 includes hardware and software components. Examples of hardware components include: mainframes 61; RISC (Reduced Instruction Set Computer) architecture based servers 62; servers 63; blade servers 64; storage devices 65; and networks and networking components 66. In some embodiments, software components include network application server software 67 and database software 68.\n\nVirtualization layer 70 provides an abstraction layer from which the following examples of virtual entities may be provided: virtual servers 71; virtual storage 72; virtual networks 73, including virtual private networks; virtual applications and operating systems 74; and virtual clients 75.\n\nIn one example, management layer 80 may provide the functions described below. Resource provisioning 81 provides dynamic procurement of computing resources and other resources that are utilized to perform tasks within the cloud computing environment. Metering and Pricing 82 provide cost tracking as resources are utilized within the cloud computing environment, and billing or invoicing for consumption of these resources. In one example, these resources may include application software licenses. Security provides identity verification for cloud consumers and tasks, as well as protection for data and other resources. User portal 83 provides access to the cloud computing environment for consumers and system administrators. Service level management 84 provides cloud computing resource allocation and management such that required service levels are met. Service Level Agreement (SLA) planning and fulfillment 85 provide pre-arrangement for, and procurement of, cloud computing resources for which a future requirement is anticipated in accordance with an SLA.\n\nWorkloads layer 90 provides examples of functionality for which the cloud computing environment may be utilized. Examples of workloads and functions which may be provided from this layer include: mapping and navigation 91; software development and lifecycle management 92; virtual classroom education delivery 93; data analytics processing 94; transaction processing 95; and natural language processing 96.\n\nHaving described preferred embodiments of combining domain-specific ontologies for language processing (which are intended to be illustrative and not limiting), it is noted that modifications and variations can be made by persons skilled in the art in light of the above teachings. It is therefore to be understood that changes may be made in the particular embodiments disclosed which are within the scope of the invention as outlined by the appended claims. Having thus described aspects of the invention, with the details and particularity required by the patent laws, what is claimed and desired protected by Letters Patent is set forth in the appended claims.\n\nClaims (20)\n\n1. A computer-implemented method for performing a natural language processing task, comprising:\n\nidentifying hypernym/hyponym relations in a depth-wise ontology;\n\nidentifying synonymy relations in a breadth-wise ontology;\n\ncombining the depth-wise ontology and the breadth-wise ontology into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations;\n\nembedding enhanced hypernym/hyponym relations using the combined ontology; and\n\nperforming a natural language processing task using the enhanced hypernym/hyponym relations and the combined ontology.\n\n2. The method of claim 1, wherein identifying the hypernym/hyponym relations includes identifying a partial order between terms in the depth-wise ontology.\n\n3. The method of claim 2, wherein embedding the enhanced hypernym/hyponym relations includes a sketch function that uses a random hash function to generate a vector representation of a relationship between two terms.\n\n4. The method of claim 3, wherein performing the natural language processing task includes determining whether a first term and a second term are related according to a hypernym/hyponym relation.\n\n5. The method of claim 4, wherein determining whether a first term and a second term are related includes comparing a ratio to a threshold.\n\n6. The method of claim 5, wherein the ratio is characterized as:\n\nR x , y = o â¢ s â¢ k â¡ ( x ) Â· osk â¡ ( y ) o â¢ s â¢ k â¡ ( y ) Â· osk â¡ ( y )\n\nwhere y is a set of synonyms of the first term and x is a union of sets of synonyms of the second term and where osk(Â·) is the sketch function.\n\n7. The method of claim 1, further comprising identifying and removing loops in the combined ontology by identifying hypernym/hyponym loops within the combined ontology.\n\n8. The method of claim 1, wherein combining the depth-wise ontology and the breadth-wise ontology includes executing a query on the breadth-wise ontology using tokens from each concept in the depth-wise ontology.\n\n9. The method of claim 8, further comprising validating results of the query from each concept in the depth-wise ontology to ensure a contextual match between the entries of the depth-wise ontology and the breadth-wise ontology.\n\n10. The method of claim 1, wherein performing the natural language processing task includes a task selected from the group consisting of summarizing electronic health records and detecting concept mentions within electronic health records.\n\n11. A non-transitory computer readable storage medium comprising a computer readable program for performing a natural language processing task, wherein the computer readable program when executed on a computer causes the computer to perform:\n\nidentifying hypernym/hyponym relations in a depth-wise ontology;\n\nidentifying synonymy relations in a breadth-wise ontology;\n\ncombining the depth-wise ontology and the breadth-wise ontology into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations;\n\nembedding enhanced hypernym/hyponym relations using the combined ontology; and\n\nperforming a natural language processing task using the enhanced hypernym/hyponym relations and the combined ontology.\n\n12. A system for performing a natural language processing task, comprising:\n\na hardware processor; and\n\na memory, configured to store computer program code that, when executed by the hardware processor, implements:\n\na relation embedder that identifies hypernym/hyponym relations in a depth-wise ontology and synonymy relations in a breadth-wise ontology;\n\nan ontology combiner that combines the depth-wise ontology and the breadth-wise ontology into a combined ontology using the identified hypernym/hyponym relations and the identified synonymy relations, wherein the relation embedder further embeds enhanced hypernym/hyponym relations using the combined ontology; and\n\na natural language processing task that uses the enhanced hypernym/hyponym relations and the combined ontology.\n\n13. The system of claim 12, wherein the relation embedder identifies a partial order between terms in the depth-wise ontology.\n\n14. The system of claim 13, wherein the relation embedder uses a sketch function that uses a random hash function to generate a vector representation of a relationship between two terms.\n\n15. The system of claim 14, wherein the natural language processing task includes a determination of whether a first term and a second term are related according to a hypernym/hyponym relation.\n\n16. The system of claim 15, wherein the natural language processing task compares a ratio to a threshold, wherein the ratio is characterized as:\n\nR x , y = o â¢ s â¢ k â¡ ( x ) Â· osk â¡ ( y ) o â¢ s â¢ k â¡ ( y ) Â· osk â¡ ( y )\n\nwhere y is a set of synonyms of the first term and x is a union of sets of synonyms of the second term and where osk(Â·) is the sketch function.\n\n17. The system of claim 12, wherein the ontology combiner further identifies and removes loops in the combined ontology by identifying hypernym/hyponym loops within the combined ontology.\n\n18. The system of claim 12, wherein the ontology combiner executes a query on the breadth-wise ontology using tokens from each concept in the depth-wise ontology.\n\n19. The system of claim 18, wherein the ontology combiner further validates results of the query from each concept in the depth-wise ontology to ensure a contextual match between the entries of the depth-wise ontology and the breadth-wise ontology.\n\n20. The system of claim 12, wherein the natural language processing task includes a task selected from the group consisting of summarizing electronic health records and detecting concept mentions within electronic health records.\n\nUS17/188,310 2021-03-01 2021-03-01 Combining domain-specific ontologies for language processing Pending US20220284996A1 (en)\n\nPriority Applications (1)\n\nApplication Number Priority Date Filing Date Title US17/188,310 US20220284996A1 (en) 2021-03-01 2021-03-01 Combining domain-specific ontologies for language processing\n\nApplications Claiming Priority (1)\n\nApplication Number Priority Date Filing Date Title US17/188,310 US20220284996A1 (en) 2021-03-01 2021-03-01 Combining domain-specific ontologies for language processing\n\nPublications (1)\n\nPublication Number Publication Date US20220284996A1 true US20220284996A1 (en) 2022-09-08\n\nFamily\n\nID=83117397\n\nFamily Applications (1)\n\nApplication Number Title Priority Date Filing Date US17/188,310 Pending US20220284996A1 (en) 2021-03-01 2021-03-01 Combining domain-specific ontologies for language processing\n\nCountry Status (1)\n\nCountry Link US (1) US20220284996A1 (en)\n\nCitations (4)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20150347375A1 (en) * 2014-05-30 2015-12-03 Nuance Communications, Inc. Automated quality assurance checks for improving the construction of natural language understanding systems US20170177703A1 (en) * 2015-12-21 2017-06-22 Ebay Inc. Automatic taxonomy mapping using sequence semantic embedding US20210056168A1 (en) * 2019-08-20 2021-02-25 International Business Machines Corporation Natural language processing using an ontology-based concept embedding model US11100289B1 (en) * 2018-02-23 2021-08-24 Cerner Innovation, Inc. Systems and methods for enhancing natural language processing\n\n2021\n\n2021-03-01 US US17/188,310 patent/US20220284996A1/en active Pending\n\nPatent Citations (4)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US20150347375A1 (en) * 2014-05-30 2015-12-03 Nuance Communications, Inc. Automated quality assurance checks for improving the construction of natural language understanding systems US20170177703A1 (en) * 2015-12-21 2017-06-22 Ebay Inc. Automatic taxonomy mapping using sequence semantic embedding US11100289B1 (en) * 2018-02-23 2021-08-24 Cerner Innovation, Inc. Systems and methods for enhancing natural language processing US20210056168A1 (en) * 2019-08-20 2021-02-25 International Business Machines Corporation Natural language processing using an ontology-based concept embedding model\n\nNon-Patent Citations (10)\n\n* Cited by examiner, â Cited by third party Title \"Count sketch\", Wikipedia (Year: 2023) * Argerich et al., \"Hash2Vec: Feature Hashing for Word Embeddings\", 2016 (Year: 2016) * Brendan O'Connor, March 13 2012, \"Cosine similarity, Pearson correlation, and OLS coefficients\". (Year: 2012) * Charikar et al., \"Finding frequent items in data streams.\", 2004, Theoretical Computer Science, Volume 312 Issue 1, Pages 3-15 (Year: 2004) * Lambrix et al., \"A unified approach for debugging is-a structure and mappings in networked taxonomies\", 2013, J Biomed Semantics. https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3851282 (Year: 2013) * Liang et al. \"Inferring Missing Links in Conceptual Taxonomies\", 2017. IEEE. IEEE Transactions on Knowledge and Data Engineering, Volume 29 Issue 6, pgs 1281-1295 (Year: 2017) * Maree et al, \"Coupling semantic and statistical techniques for dynamically enriching web ontologies\", 2013. https://arxiv.org/pdf/2004.11081 (Year: 2013) * Maree et al, March 2011, \"On the Merging of Domain-Specific Heterogenous Ontologies Using WordNet and Web-Pattern-Based Queries World Scientific Publishing, J. Inf. Knowl. Manag. Volume 10(1), Pages 23-36 (Year: 2011) * Nguyen et al., \"Hierarchical Embeddings for Hypernymy Detection and Directionality\", 2017. https://arxiv.org/abs/1707.07273 (Year: 2017) * Shi et al, \"Higher-order Count Sketch: Dimensionality Reduction That Retains Efficient Tensor Operations\", 2019 (Year: 2019) *\n\nSimilar Documents\n\nPublication Publication Date Title US10789552B2 (en) 2020-09-29 Question answering system-based generation of distractors using machine learning US11455473B2 (en) 2022-09-27 Vector representation based on context US11720346B2 (en) 2023-08-08 Semantic code retrieval using graph matching JP7412060B2 (en) 2024-01-12 Augmenting training data for natural language classification US11321371B2 (en) 2022-05-03 Query expansion using a graph of question and answer vocabulary US9569503B2 (en) 2017-02-14 Type evaluation in a question-answering system US11188720B2 (en) 2021-11-30 Computing system including virtual agent bot providing semantic topic model-based response US11636376B2 (en) 2023-04-25 Active learning for concept disambiguation US20200125648A1 (en) 2020-04-23 Using machine learning to determine electronic document similarity US11030402B2 (en) 2021-06-08 Dictionary expansion using neural language models US20230095180A1 (en) 2023-03-30 Question answering information completion using machine reading comprehension-based process US10216719B2 (en) 2019-02-26 Relation extraction using QandA US20180089569A1 (en) 2018-03-29 Generating a temporal answer to a question WO2023103814A1 (en) 2023-06-15 Extracting query-related temporal information from unstructured text documents US20200302332A1 (en) 2020-09-24 Client-specific document quality model US20220284996A1 (en) 2022-09-08 Combining domain-specific ontologies for language processing US12014142B2 (en) 2024-06-18 Machine learning for training NLP agent US20220351089A1 (en) 2022-11-03 Segmenting unstructured text US20210406294A1 (en) 2021-12-30 Relevance approximation of passage evidence US11615245B2 (en) 2023-03-28 Article topic alignment JP2023002475A (en) 2023-01-10 Computer system, computer program and computer-implemented method (causal knowledge identification and extraction) US20220067051A1 (en) 2022-03-03 Word embedding quality assessment through asymmetry US20220067102A1 (en) 2022-03-03 Reasoning based natural language interpretation US11841867B2 (en) 2023-12-12 Query relaxation using external domain knowledge for query answering US11120060B2 (en) 2021-09-14 Efficient resolution of syntactic patterns in question and answer (QA) pairs in an n-ary focus cognitive QA system\n\nLegal Events\n\nDate Code Title Description"
    }
}