{
    "id": "dbpedia_5465_3",
    "rank": 22,
    "data": {
        "url": "https://www.php.net/manual/en/language.types.string.php",
        "read_more_link": "",
        "language": "en",
        "title": "PHP: Strings",
        "top_image": "https://www.php.net/images/meta-image.png",
        "meta_img": "https://www.php.net/images/meta-image.png",
        "images": [
            "https://www.php.net/images/logos/php-logo.svg",
            "https://www.php.net/images/php8/logo_php8_3.svg",
            "https://www.php.net/images/to-top@2x.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "PHP is a popular general-purpose scripting language that powers everything from your blog to the most popular websites in the world.",
        "meta_lang": "en",
        "meta_favicon": "https://www.php.net/favicon.svg?v=2",
        "meta_site_name": "",
        "canonical_link": "https://www.php.net/manual/en/language.types.string.php",
        "text": "Heredoc\n\nA third way to delimit strings is the heredoc syntax: <<<. After this operator, an identifier is provided, then a newline. The string itself follows, and then the same identifier again to close the quotation.\n\nThe closing identifier may be indented by space or tab, in which case the indentation will be stripped from all lines in the doc string. Prior to PHP 7.3.0, the closing identifier must begin in the first column of the line.\n\nAlso, the closing identifier must follow the same naming rules as any other label in PHP: it must contain only alphanumeric characters and underscores, and must start with a non-digit character or underscore.\n\nExample #1 Basic Heredoc example as of PHP 7.3.0\n\n<?php\n\n// no indentation\n\necho <<<END\n\na\n\nb\n\nc\n\n\\n\n\nEND;\n\n// 4 spaces of indentation\n\necho <<<END\n\na\n\nb\n\nc\n\nEND;\n\nOutput of the above example in PHP 7.3:\n\na b c a b c\n\nIf the closing identifier is indented further than any lines of the body, then a ParseError will be thrown:\n\nExample #2 Closing identifier must not be indented further than any lines of the body\n\n<?php\n\necho <<<END\n\na\n\nb\n\nc\n\nEND;\n\nOutput of the above example in PHP 7.3:\n\nPHP Parse error: Invalid body indentation level (expecting an indentation level of at least 3) in example.php on line 4\n\nIf the closing identifier is indented, tabs can be used as well, however, tabs and spaces must not be intermixed regarding the indentation of the closing identifier and the indentation of the body (up to the closing identifier). In any of these cases, a ParseError will be thrown. These whitespace constraints have been included because mixing tabs and spaces for indentation is harmful to legibility.\n\nExample #3 Different indentation for body (spaces) closing identifier\n\n<?php\n\n// All the following code do not work.\n\n// different indentation for body (spaces) ending marker (tabs)\n\n{\n\necho <<<END\n\na\n\nEND;\n\n}\n\n// mixing spaces and tabs in body\n\n{\n\necho <<<END\n\na\n\nEND;\n\n}\n\n// mixing spaces and tabs in ending marker\n\n{\n\necho <<<END\n\na\n\nEND;\n\n}\n\nOutput of the above example in PHP 7.3:\n\nPHP Parse error: Invalid indentation - tabs and spaces cannot be mixed in example.php line 8\n\nThe closing identifier for the body string is not required to be followed by a semicolon or newline. For example, the following code is allowed as of PHP 7.3.0:\n\nExample #4 Continuing an expression after a closing identifier\n\n<?php\n\n$values = [<<<END\n\na\n\nb\n\nc\n\nEND, 'd e f'];\n\nvar_dump($values);\n\nOutput of the above example in PHP 7.3:\n\narray(2) { [0] => string(11) \"a b c\" [1] => string(5) \"d e f\" }\n\nWarning\n\nIf the closing identifier was found at the start of a line, then regardless of whether it was a part of another word, it may be considered as the closing identifier and causes a ParseError.\n\nExample #5 Closing identifier in body of the string tends to cause ParseError\n\n<?php\n\n$values = [<<<END\n\na\n\nb\n\nEND ING\n\nEND, 'd e f'];\n\nOutput of the above example in PHP 7.3:\n\nPHP Parse error: syntax error, unexpected identifier \"ING\", expecting \"]\" in example.php on line 6\n\nTo avoid this problem, it is safe to follow the simple rule: do not choose as a closing identifier if it appears in the body of the text.\n\nWarning\n\nPrior to PHP 7.3.0, it is very important to note that the line with the closing identifier must contain no other characters, except a semicolon (;). That means especially that the identifier may not be indented, and there may not be any spaces or tabs before or after the semicolon. It's also important to realize that the first character before the closing identifier must be a newline as defined by the local operating system. This is \\n on UNIX systems, including macOS. The closing delimiter must also be followed by a newline.\n\nIf this rule is broken and the closing identifier is not \"clean\", it will not be considered a closing identifier, and PHP will continue looking for one. If a proper closing identifier is not found before the end of the current file, a parse error will result at the last line.\n\nExample #6 Invalid example, prior to PHP 7.3.0\n\n<?php\n\nclass foo {\n\npublic $bar = <<<EOT\n\nbar\n\nEOT;\n\n}\n\n// Identifier must not be indented\n\n?>\n\nExample #7 Valid example, even prior to PHP 7.3.0\n\n<?php\n\nclass foo {\n\npublic $bar = <<<EOT\n\nbar\n\nEOT;\n\n}\n\n?>\n\nHeredocs containing variables can not be used for initializing class properties.\n\nHeredoc text behaves just like a double-quoted string, without the double quotes. This means that quotes in a heredoc do not need to be escaped, but the escape codes listed above can still be used. Variables are expanded, but the same care must be taken when expressing complex variables inside a heredoc as with strings.\n\nExample #8 Heredoc string quoting example\n\n<?php\n\n$str = <<<EOD\n\nExample of string\n\nspanning multiple lines\n\nusing heredoc syntax.\n\nEOD;\n\n/* More complex example, with variables. */\n\nclass foo\n\n{\n\nvar $foo;\n\nvar $bar;\n\nfunction __construct()\n\n{\n\n$this->foo = 'Foo';\n\n$this->bar = array('Bar1', 'Bar2', 'Bar3');\n\n}\n\n}\n\n$foo = new foo();\n\n$name = 'MyName';\n\necho <<<EOT\n\nMy name is \"$name\". I am printing some $foo->foo.\n\nNow, I am printing some {$foo->bar[1]}.\n\nThis should print a capital 'A': \\x41\n\nEOT;\n\n?>\n\nThe above example will output:\n\nMy name is \"MyName\". I am printing some Foo. Now, I am printing some Bar2. This should print a capital 'A': A\n\nIt is also possible to use the Heredoc syntax to pass data to function arguments:\n\nExample #9 Heredoc in arguments example\n\n<?php\n\nvar_dump(array(<<<EOD\n\nfoobar!\n\nEOD\n\n));\n\n?>\n\nIt's possible to initialize static variables and class properties/constants using the Heredoc syntax:\n\nExample #10 Using Heredoc to initialize static values\n\n<?php\n\n// Static variables\n\nfunction foo()\n\n{\n\nstatic $bar = <<<LABEL\n\nNothing in here...\n\nLABEL;\n\n}\n\n// Class properties/constants\n\nclass foo\n\n{\n\nconst BAR = <<<FOOBAR\n\nConstant example\n\nFOOBAR;\n\npublic $baz = <<<FOOBAR\n\nProperty example\n\nFOOBAR;\n\n}\n\n?>\n\nThe opening Heredoc identifier may optionally be enclosed in double quotes:\n\nExample #11 Using double quotes in Heredoc\n\n<?php\n\necho <<<\"FOOBAR\"\n\nHello World!\n\nFOOBAR;\n\n?>\n\nVariable parsing\n\nWhen a string is specified in double quotes or with heredoc, variables are parsed within it.\n\nThere are two types of syntax: a simple one and a complex one. The simple syntax is the most common and convenient. It provides a way to embed a variable, an array value, or an object property in a string with a minimum of effort.\n\nThe complex syntax can be recognised by the curly braces surrounding the expression.\n\nSimple syntax\n\nIf a dollar sign ($) is encountered, the parser will greedily take as many tokens as possible to form a valid variable name. Enclose the variable name in curly braces to explicitly specify the end of the name.\n\n<?php\n\n$juice = \"apple\";\n\necho \"He drank some $juice juice.\" . PHP_EOL;\n\n// Unintended. \"s\" is a valid character for a variable name, so this refers to $juices, not $juice.\n\necho \"He drank some juice made of $juices.\" . PHP_EOL;\n\n// Explicitly specify the end of the variable name by enclosing the reference in braces.\n\necho \"He drank some juice made of {$juice}s.\";\n\n?>\n\nThe above example will output:\n\nHe drank some apple juice. He drank some juice made of . He drank some juice made of apples.\n\nSimilarly, an array index or an object property can be parsed. With array indices, the closing square bracket (]) marks the end of the index. The same rules apply to object properties as to simple variables.\n\nExample #15 Simple syntax example\n\n<?php\n\n$juices = array(\"apple\", \"orange\", \"koolaid1\" => \"purple\");\n\necho \"He drank some $juices[0] juice.\".PHP_EOL;\n\necho \"He drank some $juices[1] juice.\".PHP_EOL;\n\necho \"He drank some $juices[koolaid1] juice.\".PHP_EOL;\n\nclass people {\n\npublic $john = \"John Smith\";\n\npublic $jane = \"Jane Smith\";\n\npublic $robert = \"Robert Paulsen\";\n\npublic $smith = \"Smith\";\n\n}\n\n$people = new people();\n\necho \"$people->john drank some $juices[0] juice.\".PHP_EOL;\n\necho \"$people->john then said hello to $people->jane.\".PHP_EOL;\n\necho \"$people->john's wife greeted $people->robert.\".PHP_EOL;\n\necho \"$people->robert greeted the two $people->smiths.\"; // Won't work\n\n?>\n\nThe above example will output:\n\nHe drank some apple juice. He drank some orange juice. He drank some purple juice. John Smith drank some apple juice. John Smith then said hello to Jane Smith. John Smith's wife greeted Robert Paulsen. Robert Paulsen greeted the two .\n\nAs of PHP 7.1.0 also negative numeric indices are supported.\n\nExample #16 Negative numeric indices\n\n<?php\n\n$string = 'string';\n\necho \"The character at index -2 is $string[-2].\", PHP_EOL;\n\n$string[-3] = 'o';\n\necho \"Changing the character at index -3 to o gives $string.\", PHP_EOL;\n\n?>\n\nThe above example will output:\n\nThe character at index -2 is n. Changing the character at index -3 to o gives strong.\n\nFor anything more complex, you should use the complex syntax.\n\nComplex (curly) syntax\n\nThis isn't called complex because the syntax is complex, but because it allows for the use of complex expressions.\n\nAny scalar variable, array element or object property with a string representation can be included via this syntax. The expression is written the same way as it would appear outside the string, and then wrapped in { and }. Since { can not be escaped, this syntax will only be recognised when the $ immediately follows the {. Use {\\$ to get a literal {$. Some examples to make it clear:\n\n<?php\n\n// Show all errors\n\nerror_reporting(E_ALL);\n\n$great = 'fantastic';\n\n// Won't work, outputs: This is { fantastic}\n\necho \"This is { $great}\";\n\n// Works, outputs: This is fantastic\n\necho \"This is {$great}\";\n\n// Works\n\necho \"This square is {$square->width}00 centimeters broad.\";\n\n// Works, quoted keys only work using the curly brace syntax\n\necho \"This works: {$arr['key']}\";\n\n// Works\n\necho \"This works: {$arr[4][3]}\";\n\n// This is wrong for the same reason as $foo[bar] is wrong outside a string.\n\n// PHP first looks for a constant named foo, and throws an error if not found.\n\n// If the constant is found, its value (and not 'foo' itself) would be used\n\n// for the array index.\n\necho \"This is wrong: {$arr[foo][3]}\";\n\n// Works. When using multi-dimensional arrays, always use braces around arrays\n\n// when inside of strings\n\necho \"This works: {$arr['foo'][3]}\";\n\n// Works.\n\necho \"This works: \" . $arr['foo'][3];\n\necho \"This works too: {$obj->values[3]->name}\";\n\necho \"This is the value of the var named $name: {${$name}}\";\n\necho \"This is the value of the var named by the return value of getName(): {${getName()}}\";\n\necho \"This is the value of the var named by the return value of \\$object->getName(): {${$object->getName()}}\";\n\n// Won't work, outputs: This is the return value of getName(): {getName()}\n\necho \"This is the return value of getName(): {getName()}\";\n\n// Won't work, outputs: C:\\folder\\{fantastic}.txt\n\necho \"C:\\folder\\{$great}.txt\"\n\n// Works, outputs: C:\\folder\\fantastic.txt\n\necho \"C:\\\\folder\\\\{$great}.txt\"\n\n?>\n\nIt is also possible to access class properties using variables within strings using this syntax.\n\n<?php\n\nclass foo {\n\nvar $bar = 'I am bar.';\n\n}\n\n$foo = new foo();\n\n$bar = 'bar';\n\n$baz = array('foo', 'bar', 'baz', 'quux');\n\necho \"{$foo->$bar}\\n\";\n\necho \"{$foo->{$baz[1]}}\\n\";\n\n?>\n\nThe above example will output:\n\nI am bar. I am bar.\n\nNote:\n\nThe value accessed from functions, method calls, static class variables, and class constants inside {$} will be interpreted as the name of a variable in the scope in which the string is defined. Using single curly braces ({}) will not work for accessing the return values of functions or methods or the values of class constants or static class variables.\n\n<?php\n\n// Show all errors.\n\nerror_reporting(E_ALL);\n\nclass beers {\n\nconst softdrink = 'rootbeer';\n\npublic static $ale = 'ipa';\n\n}\n\n$rootbeer = 'A & W';\n\n$ipa = 'Alexander Keith\\'s';\n\n// This works; outputs: I'd like an A & W\n\necho \"I'd like an {${beers::softdrink}}\\n\";\n\n// This works too; outputs: I'd like an Alexander Keith's\n\necho \"I'd like an {${beers::$ale}}\\n\";\n\n?>"
    }
}