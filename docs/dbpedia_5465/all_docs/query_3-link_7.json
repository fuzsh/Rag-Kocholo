{
    "id": "dbpedia_5465_3",
    "rank": 7,
    "data": {
        "url": "https://click.palletsprojects.com/en/8.1.x/commands/",
        "read_more_link": "",
        "language": "en",
        "title": "Commands and Groups — Click Documentation (8.1.x)",
        "top_image": "https://click.palletsprojects.com/en/8.1.x/_static/click-icon.png",
        "meta_img": "https://click.palletsprojects.com/en/8.1.x/_static/click-icon.png",
        "images": [
            "https://click.palletsprojects.com/en/8.1.x/_static/click-logo-sidebar.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../_static/click-icon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Commands and Groups¶\n\nThe most important feature of Click is the concept of arbitrarily nesting command line utilities. This is implemented through the Command and Group (actually MultiCommand).\n\nCallback Invocation¶\n\nFor a regular command, the callback is executed whenever the command runs. If the script is the only command, it will always fire (unless a parameter callback prevents it. This for instance happens if someone passes --help to the script).\n\nFor groups and multi commands, the situation looks different. In this case, the callback fires whenever a subcommand fires (unless this behavior is changed). What this means in practice is that an outer command runs when an inner command runs:\n\n@click.group() @click.option('--debug/--no-debug', default=False) def cli(debug): click.echo(f\"Debug mode is {'on'ifdebugelse'off'}\") @cli.command() # @cli, not @click! def sync(): click.echo('Syncing')\n\nHere is what this looks like:\n\n$ tool.py Usage: tool.py [OPTIONS] COMMAND [ARGS]... Options: --debug / --no-debug --help Show this message and exit. Commands: sync $ tool.py --debug sync Debug mode is on Syncing\n\nPassing Parameters¶\n\nClick strictly separates parameters between commands and subcommands. What this means is that options and arguments for a specific command have to be specified after the command name itself, but before any other command names.\n\nThis behavior is already observable with the predefined --help option. Suppose we have a program called tool.py, containing a subcommand called sub.\n\ntool.py --help will return the help for the whole program (listing subcommands).\n\ntool.py sub --help will return the help for the sub subcommand.\n\nBut tool.py --help sub will treat --help as an argument for the main program. Click then invokes the callback for --help, which prints the help and aborts the program before click can process the subcommand.\n\nNested Handling and Contexts¶\n\nAs you can see from the earlier example, the basic command group accepts a debug argument which is passed to its callback, but not to the sync command itself. The sync command only accepts its own arguments.\n\nThis allows tools to act completely independent of each other, but how does one command talk to a nested one? The answer to this is the Context.\n\nEach time a command is invoked, a new context is created and linked with the parent context. Normally, you can’t see these contexts, but they are there. Contexts are passed to parameter callbacks together with the value automatically. Commands can also ask for the context to be passed by marking themselves with the pass_context() decorator. In that case, the context is passed as first argument.\n\nThe context can also carry a program specified object that can be used for the program’s purposes. What this means is that you can build a script like this:\n\n@click.group() @click.option('--debug/--no-debug', default=False) @click.pass_context def cli(ctx, debug): # ensure that ctx.obj exists and is a dict (in case `cli()` is called # by means other than the `if` block below) ctx.ensure_object(dict) ctx.obj['DEBUG'] = debug @cli.command() @click.pass_context def sync(ctx): click.echo(f\"Debug is {'on'ifctx.obj['DEBUG']else'off'}\") if __name__ == '__main__': cli(obj={})\n\nIf the object is provided, each context will pass the object onwards to its children, but at any level a context’s object can be overridden. To reach to a parent, context.parent can be used.\n\nIn addition to that, instead of passing an object down, nothing stops the application from modifying global state. For instance, you could just flip a global DEBUG variable and be done with it.\n\nDecorating Commands¶\n\nAs you have seen in the earlier example, a decorator can change how a command is invoked. What actually happens behind the scenes is that callbacks are always invoked through the Context.invoke() method which automatically invokes a command correctly (by either passing the context or not).\n\nThis is very useful when you want to write custom decorators. For instance, a common pattern would be to configure an object representing state and then storing it on the context and then to use a custom decorator to find the most recent object of this sort and pass it as first argument.\n\nFor instance, the pass_obj() decorator can be implemented like this:\n\nfrom functools import update_wrapper def pass_obj(f): @click.pass_context def new_func(ctx, *args, **kwargs): return ctx.invoke(f, ctx.obj, *args, **kwargs) return update_wrapper(new_func, f)\n\nThe Context.invoke() command will automatically invoke the function in the correct way, so the function will either be called with f(ctx, obj) or f(obj) depending on whether or not it itself is decorated with pass_context().\n\nThis is a very powerful concept that can be used to build very complex nested applications; see Complex Applications for more information.\n\nGroup Invocation Without Command¶\n\nBy default, a group or multi command is not invoked unless a subcommand is passed. In fact, not providing a command automatically passes --help by default. This behavior can be changed by passing invoke_without_command=True to a group. In that case, the callback is always invoked instead of showing the help page. The context object also includes information about whether or not the invocation would go to a subcommand.\n\nExample:\n\n@click.group(invoke_without_command=True) @click.pass_context def cli(ctx): if ctx.invoked_subcommand is None: click.echo('I was invoked without subcommand') else: click.echo(f\"I am about to invoke {ctx.invoked_subcommand}\") @cli.command() def sync(): click.echo('The subcommand')\n\nAnd how it works in practice:\n\n$ tool I was invoked without subcommand $ tool sync I am about to invoke sync The subcommand\n\nCustom Multi Commands¶\n\nIn addition to using click.group(), you can also build your own custom multi commands. This is useful when you want to support commands being loaded lazily from plugins.\n\nA custom multi command just needs to implement a list and load method:\n\nimport click import os plugin_folder = os.path.join(os.path.dirname(__file__), 'commands') class MyCLI(click.MultiCommand): def list_commands(self, ctx): rv = [] for filename in os.listdir(plugin_folder): if filename.endswith('.py') and filename != '__init__.py': rv.append(filename[:-3]) rv.sort() return rv def get_command(self, ctx, name): ns = {} fn = os.path.join(plugin_folder, name + '.py') with open(fn) as f: code = compile(f.read(), fn, 'exec') eval(code, ns, ns) return ns['cli'] cli = MyCLI(help='This tool\\'s subcommands are loaded from a ' 'plugin folder dynamically.') if __name__ == '__main__': cli()\n\nThese custom classes can also be used with decorators:\n\n@click.command(cls=MyCLI) def cli(): pass\n\nMerging Multi Commands¶\n\nIn addition to implementing custom multi commands, it can also be interesting to merge multiple together into one script. While this is generally not as recommended as it nests one below the other, the merging approach can be useful in some circumstances for a nicer shell experience.\n\nThe default implementation for such a merging system is the CommandCollection class. It accepts a list of other multi commands and makes the commands available on the same level.\n\nExample usage:\n\nimport click @click.group() def cli1(): pass @cli1.command() def cmd1(): \"\"\"Command on cli1\"\"\" @click.group() def cli2(): pass @cli2.command() def cmd2(): \"\"\"Command on cli2\"\"\" cli = click.CommandCollection(sources=[cli1, cli2]) if __name__ == '__main__': cli()\n\nAnd what it looks like:\n\n$ cli --help Usage: cli [OPTIONS] COMMAND [ARGS]... Options: --help Show this message and exit. Commands: cmd1 Command on cli1 cmd2 Command on cli2\n\nIn case a command exists in more than one source, the first source wins.\n\nMulti Command Chaining¶\n\nChangelog\n\nNew in version 3.0.\n\nSometimes it is useful to be allowed to invoke more than one subcommand in one go. For instance if you have installed a setuptools package before you might be familiar with the setup.py sdist bdist_wheel upload command chain which invokes sdist before bdist_wheel before upload. Starting with Click 3.0 this is very simple to implement. All you have to do is to pass chain=True to your multicommand:\n\n@click.group(chain=True) def cli(): pass @cli.command('sdist') def sdist(): click.echo('sdist called') @cli.command('bdist_wheel') def bdist_wheel(): click.echo('bdist_wheel called')\n\nNow you can invoke it like this:\n\n$ setup.py sdist bdist_wheel sdist called bdist_wheel called\n\nWhen using multi command chaining you can only have one command (the last) use nargs=-1 on an argument. It is also not possible to nest multi commands below chained multicommands. Other than that there are no restrictions on how they work. They can accept options and arguments as normal. The order between options and arguments is limited for chained commands. Currently only --options argument order is allowed.\n\nAnother note: the Context.invoked_subcommand attribute is a bit useless for multi commands as it will give '*' as value if more than one command is invoked. This is necessary because the handling of subcommands happens one after another so the exact subcommands that will be handled are not yet available when the callback fires.\n\nNote\n\nIt is currently not possible for chain commands to be nested. This will be fixed in future versions of Click.\n\nMulti Command Pipelines¶\n\nChangelog\n\nNew in version 3.0.\n\nA very common usecase of multi command chaining is to have one command process the result of the previous command. There are various ways in which this can be facilitated. The most obvious way is to store a value on the context object and process it from function to function. This works by decorating a function with pass_context() after which the context object is provided and a subcommand can store its data there.\n\nAnother way to accomplish this is to setup pipelines by returning processing functions. Think of it like this: when a subcommand gets invoked it processes all of its parameters and comes up with a plan of how to do its processing. At that point it then returns a processing function and returns.\n\nWhere do the returned functions go? The chained multicommand can register a callback with MultiCommand.result_callback() that goes over all these functions and then invoke them.\n\nTo make this a bit more concrete consider this example:\n\n@click.group(chain=True, invoke_without_command=True) @click.option('-i', '--input', type=click.File('r')) def cli(input): pass @cli.result_callback() def process_pipeline(processors, input): iterator = (x.rstrip('\\r\\n') for x in input) for processor in processors: iterator = processor(iterator) for item in iterator: click.echo(item) @cli.command('uppercase') def make_uppercase(): def processor(iterator): for line in iterator: yield line.upper() return processor @cli.command('lowercase') def make_lowercase(): def processor(iterator): for line in iterator: yield line.lower() return processor @cli.command('strip') def make_strip(): def processor(iterator): for line in iterator: yield line.strip() return processor\n\nThat’s a lot in one go, so let’s go through it step by step.\n\nThe first thing is to make a group() that is chainable. In addition to that we also instruct Click to invoke even if no subcommand is defined. If this would not be done, then invoking an empty pipeline would produce the help page instead of running the result callbacks.\n\nThe next thing we do is to register a result callback on our group. This callback will be invoked with an argument which is the list of all return values of all subcommands and then the same keyword parameters as our group itself. This means we can access the input file easily there without having to use the context object.\n\nIn this result callback we create an iterator of all the lines in the input file and then pass this iterator through all the returned callbacks from all subcommands and finally we print all lines to stdout.\n\nAfter that point we can register as many subcommands as we want and each subcommand can return a processor function to modify the stream of lines.\n\nOne important thing of note is that Click shuts down the context after each callback has been run. This means that for instance file types cannot be accessed in the processor functions as the files will already be closed there. This limitation is unlikely to change because it would make resource handling much more complicated. For such it’s recommended to not use the file type and manually open the file through open_file().\n\nFor a more complex example that also improves upon handling of the pipelines have a look at the imagepipe multi command chaining demo in the Click repository. It implements a pipeline based image editing tool that has a nice internal structure for the pipelines.\n\nOverriding Defaults¶\n\nBy default, the default value for a parameter is pulled from the default flag that is provided when it’s defined, but that’s not the only place defaults can be loaded from. The other place is the Context.default_map (a dictionary) on the context. This allows defaults to be loaded from a configuration file to override the regular defaults.\n\nThis is useful if you plug in some commands from another package but you’re not satisfied with the defaults.\n\nThe default map can be nested arbitrarily for each subcommand:\n\ndefault_map = { \"debug\": True, # default for a top level option \"runserver\": {\"port\": 5000} # default for a subcommand }\n\nThe default map can be provided when the script is invoked, or overridden at any point by commands. For instance, a top-level command could load the defaults from a configuration file.\n\nExample usage:\n\nimport click @click.group() def cli(): pass @cli.command() @click.option('--port', default=8000) def runserver(port): click.echo(f\"Serving on http://127.0.0.1:{port}/\") if __name__ == '__main__': cli(default_map={ 'runserver': { 'port': 5000 } })\n\nAnd in action:\n\n$ cli runserver Serving on http://127.0.0.1:5000/\n\nContext Defaults¶\n\nChangelog\n\nNew in version 2.0.\n\nStarting with Click 2.0 you can override defaults for contexts not just when calling your script, but also in the decorator that declares a command. For instance given the previous example which defines a custom default_map this can also be accomplished in the decorator now.\n\nThis example does the same as the previous example:\n\nimport click CONTEXT_SETTINGS = dict( default_map={'runserver': {'port': 5000}} ) @click.group(context_settings=CONTEXT_SETTINGS) def cli(): pass @cli.command() @click.option('--port', default=8000) def runserver(port): click.echo(f\"Serving on http://127.0.0.1:{port}/\") if __name__ == '__main__': cli()\n\nAnd again the example in action:\n\n$ cli runserver Serving on http://127.0.0.1:5000/\n\nCommand Return Values¶\n\nChangelog\n\nNew in version 3.0.\n\nOne of the new introductions in Click 3.0 is the full support for return values from command callbacks. This enables a whole range of features that were previously hard to implement.\n\nIn essence any command callback can now return a value. This return value is bubbled to certain receivers. One usecase for this has already been show in the example of Multi Command Chaining where it has been demonstrated that chained multi commands can have callbacks that process all return values.\n\nWhen working with command return values in Click, this is what you need to know:\n\nThe return value of a command callback is generally returned from the BaseCommand.invoke() method. The exception to this rule has to do with Groups:\n\nIn a group the return value is generally the return value of the subcommand invoked. The only exception to this rule is that the return value is the return value of the group callback if it’s invoked without arguments and invoke_without_command is enabled.\n\nIf a group is set up for chaining then the return value is a list of all subcommands’ results.\n\nReturn values of groups can be processed through a MultiCommand.result_callback. This is invoked with the list of all return values in chain mode, or the single return value in case of non chained commands.\n\nThe return value is bubbled through from the Context.invoke() and Context.forward() methods. This is useful in situations where you internally want to call into another command.\n\nClick does not have any hard requirements for the return values and does not use them itself. This allows return values to be used for custom decorators or workflows (like in the multi command chaining example).\n\nWhen a Click script is invoked as command line application (through BaseCommand.main()) the return value is ignored unless the standalone_mode is disabled in which case it’s bubbled through."
    }
}