{
    "id": "dbpedia_5465_3",
    "rank": 19,
    "data": {
        "url": "https://docs.python.org/3/library/sys.html",
        "read_more_link": "",
        "language": "en",
        "title": "sys â System-specific parameters and functions",
        "top_image": "https://docs.python.org/3/_static/og-image.png",
        "meta_img": "https://docs.python.org/3/_static/og-image.png",
        "images": [
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg",
            "https://docs.python.org/3/_static/py.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This module provides access to some variables used or maintained by the interpreter and to functions that interact strongly with the interpreter. It is always available. Citations C99, ISO/IEC 9899...",
        "meta_lang": "en",
        "meta_favicon": "../_static/py.svg",
        "meta_site_name": "Python documentation",
        "canonical_link": "https://docs.python.org/3/library/sys.html",
        "text": "Append the callable hook to the list of active auditing hooks for the current (sub)interpreter.\n\nWhen an auditing event is raised through the sys.audit() function, each hook will be called in the order it was added with the event name and the tuple of arguments. Native hooks added by PySys_AddAuditHook() are called first, followed by hooks added in the current (sub)interpreter. Hooks can then log the event, raise an exception to abort the operation, or terminate the process entirely.\n\nNote that audit hooks are primarily for collecting information about internal or otherwise unobservable actions, whether by Python or libraries written in Python. They are not suitable for implementing a âsandboxâ. In particular, malicious code can trivially disable or bypass hooks added using this function. At a minimum, any security-sensitive hooks must be added using the C API PySys_AddAuditHook() before initialising the runtime, and any modules allowing arbitrary memory modification (such as ctypes) should be completely removed or closely monitored.\n\nCalling sys.addaudithook() will itself raise an auditing event named sys.addaudithook with no arguments. If any existing hooks raise an exception derived from RuntimeError, the new hook will not be added and the exception suppressed. As a result, callers cannot assume that their hook has been added unless they control all existing hooks.\n\nSee the audit events table for all events raised by CPython, and PEP 578 for the original design discussion.\n\nAdded in version 3.8.\n\nChanged in version 3.8.1: Exceptions derived from Exception but not RuntimeError are no longer suppressed.\n\nCPython implementation detail: When tracing is enabled (see settrace()), Python hooks are only traced if the callable has a __cantrace__ member that is set to a true value. Otherwise, trace functions will skip the hook.\n\nRaise an auditing event and trigger any active auditing hooks. event is a string identifying the event, and args may contain optional arguments with more information about the event. The number and types of arguments for a given event are considered a public and stable API and should not be modified between releases.\n\nFor example, one auditing event is named os.chdir. This event has one argument called path that will contain the requested new working directory.\n\nsys.audit() will call the existing auditing hooks, passing the event name and arguments, and will re-raise the first exception from any hook. In general, if an exception is raised, it should not be handled and the process should be terminated as quickly as possible. This allows hook implementations to decide how to respond to particular events: they can merely log the event or abort the operation by raising an exception.\n\nHooks are added using the sys.addaudithook() or PySys_AddAuditHook() functions.\n\nThe native equivalent of this function is PySys_Audit(). Using the native function is preferred when possible.\n\nSee the audit events table for all events raised by CPython.\n\nAdded in version 3.8.\n\nThis hook function is called by built-in breakpoint(). By default, it drops you into the pdb debugger, but it can be set to any other function so that you can choose which debugger gets used.\n\nThe signature of this function is dependent on what it calls. For example, the default binding (e.g. pdb.set_trace()) expects no arguments, but you might bind it to a function that expects additional arguments (positional and/or keyword). The built-in breakpoint() function passes its *args and **kws straight through. Whatever breakpointhooks() returns is returned from breakpoint().\n\nThe default implementation first consults the environment variable PYTHONBREAKPOINT. If that is set to \"0\" then this function returns immediately; i.e. it is a no-op. If the environment variable is not set, or is set to the empty string, pdb.set_trace() is called. Otherwise this variable should name a function to run, using Pythonâs dotted-import nomenclature, e.g. package.subpackage.module.function. In this case, package.subpackage.module would be imported and the resulting module must have a callable named function(). This is run, passing in *args and **kws, and whatever function() returns, sys.breakpointhook() returns to the built-in breakpoint() function.\n\nNote that if anything goes wrong while importing the callable named by PYTHONBREAKPOINT, a RuntimeWarning is reported and the breakpoint is ignored.\n\nAlso note that if sys.breakpointhook() is overridden programmatically, PYTHONBREAKPOINT is not consulted.\n\nAdded in version 3.7.\n\nThis function prints out a given traceback and exception to sys.stderr.\n\nWhen an exception other than SystemExit is raised and uncaught, the interpreter calls sys.excepthook with three arguments, the exception class, exception instance, and a traceback object. In an interactive session this happens just before control is returned to the prompt; in a Python program this happens just before the program exits. The handling of such top-level exceptions can be customized by assigning another three-argument function to sys.excepthook.\n\nRaise an auditing event sys.excepthook with arguments hook, type, value, traceback when an uncaught exception occurs. If no hook has been set, hook may be None. If any hook raises an exception derived from RuntimeError the call to the hook will be suppressed. Otherwise, the audit hook exception will be reported as unraisable and sys.excepthook will be called.\n\nSee also\n\nThe sys.unraisablehook() function handles unraisable exceptions and the threading.excepthook() function handles exception raised by threading.Thread.run().\n\nRaise a SystemExit exception, signaling an intention to exit the interpreter.\n\nThe optional argument arg can be an integer giving the exit status (defaulting to zero), or another type of object. If it is an integer, zero is considered âsuccessful terminationâ and any nonzero value is considered âabnormal terminationâ by shells and the like. Most systems require it to be in the range 0â127, and produce undefined results otherwise. Some systems have a convention for assigning specific meanings to specific exit codes, but these are generally underdeveloped; Unix programs generally use 2 for command line syntax errors and 1 for all other kind of errors. If another type of object is passed, None is equivalent to passing zero, and any other object is printed to stderr and results in an exit code of 1. In particular, sys.exit(\"some error message\") is a quick way to exit a program when an error occurs.\n\nSince exit() ultimately âonlyâ raises an exception, it will only exit the process when called from the main thread, and the exception is not intercepted. Cleanup actions specified by finally clauses of try statements are honored, and it is possible to intercept the exit attempt at an outer level.\n\nChanged in version 3.6: If an error occurs in the cleanup after the Python interpreter has caught SystemExit (such as an error flushing buffered data in the standard streams), the exit status is changed to 120.\n\nReturn a named tuple describing the Windows version currently running. The named elements are major, minor, build, platform, service_pack, service_pack_minor, service_pack_major, suite_mask, product_type and platform_version. service_pack contains a string, platform_version a 3-tuple and all other values are integers. The components can also be accessed by name, so sys.getwindowsversion()[0] is equivalent to sys.getwindowsversion().major. For compatibility with prior versions, only the first 5 elements are retrievable by indexing.\n\nplatform will be 2 (VER_PLATFORM_WIN32_NT).\n\nproduct_type may be one of the following values:\n\nConstant\n\nMeaning\n\nThis function wraps the Win32 GetVersionEx() function; see the Microsoft documentation on OSVERSIONINFOEX() for more information about these fields.\n\nplatform_version returns the major version, minor version and build number of the current operating system, rather than the version that is being emulated for the process. It is intended for use in logging rather than for feature detection.\n\nNote\n\nplatform_version derives the version from kernel32.dll which can be of a different version than the OS version. Please use platform module for achieving accurate OS version.\n\nAvailability: Windows.\n\nChanged in version 3.2: Changed to a named tuple and added service_pack_minor, service_pack_major, suite_mask, and product_type.\n\nChanged in version 3.6: Added platform_version\n\nThis string contains a platform identifier that can be used to append platform-specific components to sys.path, for instance.\n\nFor Unix systems, except on Linux and AIX, this is the lowercased OS name as returned by uname -s with the first part of the version as returned by uname -r appended, e.g. 'sunos5' or 'freebsd8', at the time when Python was built. Unless you want to test for a specific system version, it is therefore recommended to use the following idiom:\n\nif sys.platform.startswith('freebsd'): # FreeBSD-specific code here... elif sys.platform.startswith('linux'): # Linux-specific code here... elif sys.platform.startswith('aix'): # AIX-specific code here...\n\nFor other systems, the values are:\n\nSystem\n\nplatform value\n\nAIX\n\n'aix'\n\nEmscripten\n\n'emscripten'\n\nLinux\n\n'linux'\n\nWASI\n\n'wasi'\n\nWindows\n\n'win32'\n\nWindows/Cygwin\n\n'cygwin'\n\nmacOS\n\n'darwin'\n\nChanged in version 3.3: On Linux, sys.platform doesnât contain the major version anymore. It is always 'linux', instead of 'linux2' or 'linux3'. Since older Python versions include the version number, it is recommended to always use the startswith idiom presented above.\n\nChanged in version 3.8: On AIX, sys.platform doesnât contain the major version anymore. It is always 'aix', instead of 'aix5' or 'aix7'. Since older Python versions include the version number, it is recommended to always use the startswith idiom presented above.\n\nSee also\n\nos.name has a coarser granularity. os.uname() gives system-dependent version information.\n\nThe platform module provides detailed checks for the systemâs identity.\n\nSet the systemâs profile function, which allows you to implement a Python source code profiler in Python. See chapter The Python Profilers for more information on the Python profiler. The systemâs profile function is called similarly to the systemâs trace function (see settrace()), but it is called with different events, for example it isnât called for each executed line of code (only on call and return, but the return event is reported even when an exception has been set). The function is thread-specific, but there is no way for the profiler to know about context switches between threads, so it does not make sense to use this in the presence of multiple threads. Also, its return value is not used, so it can simply return None. Error in the profile function will cause itself unset.\n\nNote\n\nThe same tracing mechanism is used for setprofile() as settrace(). To trace calls with setprofile() inside a tracing function (e.g. in a debugger breakpoint), see call_tracing().\n\nProfile functions should have three arguments: frame, event, and arg. frame is the current stack frame. event is a string: 'call', 'return', 'c_call', 'c_return', or 'c_exception'. arg depends on the event type.\n\nThe events have the following meaning:\n\n'call'\n\nA function is called (or some other code block entered). The profile function is called; arg is None.\n\n'return'\n\nA function (or other code block) is about to return. The profile function is called; arg is the value that will be returned, or None if the event is caused by an exception being raised.\n\n'c_call'\n\nA C function is about to be called. This may be an extension function or a built-in. arg is the C function object.\n\n'c_return'\n\nA C function has returned. arg is the C function object.\n\n'c_exception'\n\nA C function has raised an exception. arg is the C function object.\n\nRaises an auditing event sys.setprofile with no arguments.\n\nSet the systemâs trace function, which allows you to implement a Python source code debugger in Python. The function is thread-specific; for a debugger to support multiple threads, it must register a trace function using settrace() for each thread being debugged or use threading.settrace().\n\nTrace functions should have three arguments: frame, event, and arg. frame is the current stack frame. event is a string: 'call', 'line', 'return', 'exception' or 'opcode'. arg depends on the event type.\n\nThe trace function is invoked (with event set to 'call') whenever a new local scope is entered; it should return a reference to a local trace function to be used for the new scope, or None if the scope shouldnât be traced.\n\nThe local trace function should return a reference to itself, or to another function which would then be used as the local trace function for the scope.\n\nIf there is any error occurred in the trace function, it will be unset, just like settrace(None) is called.\n\nNote\n\nTracing is disabled while calling the trace function (e.g. a function set by settrace()). For recursive tracing see call_tracing().\n\nThe events have the following meaning:\n\n'call'\n\nA function is called (or some other code block entered). The global trace function is called; arg is None; the return value specifies the local trace function.\n\n'line'\n\nThe interpreter is about to execute a new line of code or re-execute the condition of a loop. The local trace function is called; arg is None; the return value specifies the new local trace function. See Objects/lnotab_notes.txt for a detailed explanation of how this works. Per-line events may be disabled for a frame by setting f_trace_lines to False on that frame.\n\n'return'\n\nA function (or other code block) is about to return. The local trace function is called; arg is the value that will be returned, or None if the event is caused by an exception being raised. The trace functionâs return value is ignored.\n\n'exception'\n\nAn exception has occurred. The local trace function is called; arg is a tuple (exception, value, traceback); the return value specifies the new local trace function.\n\n'opcode'\n\nThe interpreter is about to execute a new opcode (see dis for opcode details). The local trace function is called; arg is None; the return value specifies the new local trace function. Per-opcode events are not emitted by default: they must be explicitly requested by setting f_trace_opcodes to True on the frame.\n\nNote that as an exception is propagated down the chain of callers, an 'exception' event is generated at each level.\n\nFor more fine-grained usage, itâs possible to set a trace function by assigning frame.f_trace = tracefunc explicitly, rather than relying on it being set indirectly via the return value from an already installed trace function. This is also required for activating the trace function on the current frame, which settrace() doesnât do. Note that in order for this to work, a global tracing function must have been installed with settrace() in order to enable the runtime tracing machinery, but it doesnât need to be the same tracing function (e.g. it could be a low overhead tracing function that simply returns None to disable itself immediately on each frame).\n\nFor more information on code and frame objects, refer to The standard type hierarchy.\n\nRaises an auditing event sys.settrace with no arguments.\n\nCPython implementation detail: The settrace() function is intended only for implementing debuggers, profilers, coverage tools and the like. Its behavior is part of the implementation platform, rather than part of the language definition, and thus may not be available in all Python implementations.\n\nChanged in version 3.7: 'opcode' event type added; f_trace_lines and f_trace_opcodes attributes added to frames\n\nChanged in version 3.12: 'opcode' event will only be emitted if f_trace_opcodes of at least one frame has been set to True before settrace() is called. This behavior will be changed back in 3.13 to be consistent with previous versions.\n\nHandle an unraisable exception.\n\nCalled when an exception has occurred but there is no way for Python to handle it. For example, when a destructor raises an exception or during garbage collection (gc.collect()).\n\nThe unraisable argument has the following attributes:\n\nexc_type: Exception type.\n\nexc_value: Exception value, can be None.\n\nexc_traceback: Exception traceback, can be None.\n\nerr_msg: Error message, can be None.\n\nobject: Object causing the exception, can be None.\n\nThe default hook formats err_msg and object as: f'{err_msg}: {object!r}'; use âException ignored inâ error message if err_msg is None.\n\nsys.unraisablehook() can be overridden to control how unraisable exceptions are handled.\n\nSee also\n\nexcepthook() which handles uncaught exceptions.\n\nWarning\n\nStoring exc_value using a custom hook can create a reference cycle. It should be cleared explicitly to break the reference cycle when the exception is no longer needed.\n\nStoring object using a custom hook can resurrect it if it is set to an object which is being finalized. Avoid storing object after the custom hook completes to avoid resurrecting objects.\n\nRaise an auditing event sys.unraisablehook with arguments hook, unraisable when an exception that cannot be handled occurs. The unraisable object is the same as what will be passed to the hook. If no hook has been set, hook may be None.\n\nAdded in version 3.8."
    }
}