{
    "id": "dbpedia_5465_3",
    "rank": 5,
    "data": {
        "url": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this",
        "read_more_link": "",
        "language": "en",
        "title": "this - JavaScript",
        "top_image": "https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png",
        "meta_img": "https://developer.mozilla.org/mdn-social-share.cd6c4a5a.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-07-25T21:42:31+00:00",
        "summary": "",
        "meta_description": "The this keyword refers to the context where a piece of code, such as a function's body, is supposed to run. Most typically, it is used in object methods, where this refers to the object that the method is attached to, thus allowing the same method to be reused on different objects.",
        "meta_lang": "en",
        "meta_favicon": "/favicon-48x48.cbbd161b.png",
        "meta_site_name": "MDN Web Docs",
        "canonical_link": "https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/this",
        "text": "Inside a function, the value of this depends on how the function is called. Think about this as a hidden parameter of a function â just like the parameters declared in the function definition, this is a binding that the language creates for you when the function body is evaluated.\n\nFor a regular function (not an arrow function, bound function, etc.), the value of this is the object that the function is accessed on. In other words, if the function call is in the form obj.f(), then this refers to obj. For example:\n\nNote how the function is the same, but based on how it's invoked, the value of this is different. This is analogous to how function parameters work.\n\nThe value of this is not the object that has the function as an own property, but the object that is used to call the function. You can prove this by calling a method of an object up in the prototype chain.\n\nThe value of this always changes based on how a function is called, even when the function was defined on an object at creation:\n\nIf the value that the method is accessed on is a primitive, this will be a primitive value as well â but only if the function is in strict mode.\n\nIf the function is called without being accessed on anything, this will be undefined â but only if the function is in strict mode.\n\nIn non-strict mode, a special process called this substitution ensures that the value of this is always an object. This means:\n\nIf a function is called with this set to undefined or null, this gets substituted with globalThis.\n\nIf the function is called with this set to a primitive value, this gets substituted with the primitive value's wrapper object.\n\nIn typical function calls, this is implicitly passed like a parameter through the function's prefix (the part before the dot). You can also explicitly set the value of this using the Function.prototype.call(), Function.prototype.apply(), or Reflect.apply() methods. Using Function.prototype.bind(), you can create a new function with a specific value of this that doesn't change regardless of how the function is called. When using these methods, the this substitution rules above still apply if the function is non-strict.\n\nCallbacks\n\nWhen a function is passed as a callback, the value of this depends on how the callback is called, which is determined by the implementor of the API. Callbacks are typically called with a this value of undefined (calling it directly without attaching it to any object), which means if the function is nonâstrict, the value of this is the global object (globalThis). This is the case for iterative array methods, the Promise() constructor, etc.\n\nSome APIs allow you to set a this value for invocations of the callback. For example, all iterative array methods and related ones like Set.prototype.forEach() accept an optional thisArg parameter.\n\nOccasionally, a callback is called with a this value other than undefined. For example, the reviver parameter of JSON.parse() and the replacer parameter of JSON.stringify() are both called with this set to the object that the property being parsed/serialized belongs to.\n\nArrow functions\n\nIn arrow functions, this retains the value of the enclosing lexical context's this. In other words, when evaluating an arrow function's body, the language does not create a new this binding.\n\nFor example, in global code, this is always globalThis regardless of strictness, because of the global context binding:\n\nArrow functions create a closure over the this value of its surrounding scope, which means arrow functions behave as if they are \"auto-bound\" â no matter how it's invoked, this is bound to what it was when the function was created (in the example above, the global object). The same applies to arrow functions created inside other functions: their this remains that of the enclosing lexical context. See example below.\n\nFurthermore, when invoking arrow functions using call(), bind(), or apply(), the thisArg parameter is ignored. You can still pass other arguments using these methods, though.\n\nConstructors\n\nWhen a function is used as a constructor (with the new keyword), its this is bound to the new object being constructed, no matter which object the constructor function is accessed on. The value of this becomes the value of the new expression unless the constructor returns another nonâprimitive value.\n\nIn the second example (C2), because an object was returned during construction, the new object that this was bound to gets discarded. (This essentially makes the statement this.a = 37; dead code. It's not exactly dead because it gets executed, but it can be eliminated with no outside effects.)\n\nsuper"
    }
}