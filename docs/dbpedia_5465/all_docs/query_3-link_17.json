{
    "id": "dbpedia_5465_3",
    "rank": 17,
    "data": {
        "url": "https://rollupjs.org/configuration-options/",
        "read_more_link": "",
        "language": "en",
        "title": "Configuration Options",
        "top_image": "https://rollupjs.org/favicon.png",
        "meta_img": "https://rollupjs.org/favicon.png",
        "images": [
            "https://rollupjs.org/rollup-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "compile JS code",
        "meta_lang": "en",
        "meta_favicon": "/favicon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Core functionality ​\n\nexternal ​\n\nType:(string | RegExp)[]| RegExp| string| (id: string, parentId: string, isResolved: boolean) => booleanCLI:-e/--external <external-id,another-external-id,...>\n\nEither a function that takes an id and returns true (external) or false (not external), or an Array of module IDs, or regular expressions to match module IDs, that should remain external to the bundle. Can also be just a single ID or regular expression. The matched IDs should be either:\n\nthe name of an external dependency, exactly the way it is written in the import statement. I.e. to mark import \"dependency.js\" as external, use \"dependency.js\" while to mark import \"dependency\" as external, use \"dependency\".\n\na resolved ID (like an absolute path to a file).\n\nNote that if you want to filter out package imports, e.g. import {rollup} from 'rollup', via a /node_modules/ regular expression, you need something like @rollup/plugin-node-resolve to resolve the imports to node_modules first.\n\nWhen given as a command line argument, it should be a comma-separated list of IDs:\n\nWhen providing a function, it is called with three parameters (id, parent, isResolved) that can give you more fine-grained control:\n\nid is the id of the module in question\n\nparent is the id of the module doing the import\n\nisResolved signals whether the id has been resolved by e.g. plugins\n\nWhen creating an iife or umd bundle, you will need to provide global variable names to replace your external imports via the output.globals option.\n\nIf a relative import, i.e. starting with ./ or ../, is marked as \"external\", rollup will internally resolve the id to an absolute file system location so that different imports of the external module can be merged. When the resulting bundle is written, the import will again be converted to a relative import. Example:\n\nThe conversion back to a relative import is done as if output.file or output.dir were in the same location as the entry point or the common base directory of all entry points if there is more than one.\n\ninput ​\n\nType:string | string []| { [entryName: string]: string }CLI:-i/--input <filename>\n\nThe bundle's entry point(s) (e.g. your main.js or app.js or index.js). If you provide an array of entry points or an object mapping names to entry points, they will be bundled to separate output chunks. Unless the output.file option is used, generated chunk names will follow the output.entryFileNames option. When using the object form, the [name] portion of the file name will be the name of the object property while for the array form, it will be the file name of the entry point.\n\nNote that it is possible when using the object form to put entry points into different sub-folders by adding a / to the name. The following will generate at least two entry chunks with the names entry-a.js and entry-b/index.js, i.e. the file index.js is placed in the folder entry-b:\n\nIf you want to convert a set of files to another format while maintaining the file structure and export signatures, the recommended way—instead of using output.preserveModules that may tree-shake exports as well as emit virtual files created by plugins—is to turn every file into an entry point. You can do so dynamically e.g. via the glob package:\n\nThe option can be omitted if some plugin emits at least one chunk (using this.emitFile) by the end of the buildStart hook.\n\nWhen using the command line interface, multiple inputs can be provided by using the option multiple times. When provided as the first options, it is equivalent to not prefix them with --input:\n\nChunks can be named by adding an = to the provided value:\n\nFile names containing spaces can be specified by using quotes:\n\noutput.dir ​\n\nType:stringCLI:-d/--dir <dirname>\n\nThe directory in which all generated chunks are placed. This option is required if more than one chunk is generated. Otherwise, the file option can be used instead.\n\noutput.file ​\n\nType:stringCLI:-o/--file <filename>\n\nThe file to write to. Will also be used to generate sourcemaps, if applicable. Can only be used if not more than one chunk is generated.\n\noutput.format ​\n\nType:stringCLI:-f/--format <formatspecifier>Default:\"es\"\n\nSpecifies the format of the generated bundle. One of the following:\n\namd – Asynchronous Module Definition, used with module loaders like RequireJS\n\ncjs – CommonJS, suitable for Node and other bundlers (alias: commonjs)\n\nes – Keep the bundle as an ES module file, suitable for other bundlers and inclusion as a <script type=module> tag in modern browsers (alias: esm, module)\n\niife – A self-executing function, suitable for inclusion as a <script> tag. (If you want to create a bundle for your application, you probably want to use this.). \"iife\" stands for \"immediately-invoked Function Expression\"\n\numd – Universal Module Definition, works as amd, cjs and iife all in one\n\nsystem – Native format of the SystemJS loader (alias: systemjs)\n\noutput.globals ​\n\nType:{ [id: string]: string }| ((id: string) => string)CLI:-g/--globals <external-id:variableName,another-external-id:anotherVariableName,...>\n\nSpecifies id: variableName pairs necessary for external imports in umd/iife bundles. For example, in a case like this…\n\n…we want to tell Rollup that jquery is external and the jquery module ID equates to the global $ variable:\n\nAlternatively, supply a function that will turn an external module ID into a global variable name.\n\nWhen given as a command line argument, it should be a comma-separated list of id:variableName pairs:\n\nTo tell Rollup that a local file should be replaced by a global variable, use an absolute id:\n\noutput.name ​\n\nType:stringCLI:-n/--name <variableName>\n\nNecessary for iife/umd bundles that exports values in which case it is the global variable name representing your bundle. Other scripts on the same page can use this variable name to access the exports of your bundle.\n\nNamespaces are supported i.e. your name can contain dots. The resulting bundle will contain the setup necessary for the namespacing.\n\noutput.plugins ​\n\nType:MaybeArray<MaybePromise<OutputPlugin | void>>\n\nAdds a plugin just to this output. See Using output plugins for more information on how to use output-specific plugins and Plugins on how to write your own. For plugins imported from packages, remember to call the imported plugin function (i.e. commonjs(), not just commonjs). Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins. Nested plugins will be flattened. Async plugin will be awaited and resolved.\n\nNot every plugin can be used here. output.plugins is limited to plugins that only use hooks that run during bundle.generate() or bundle.write(), i.e. after Rollup's main analysis is complete. If you are a plugin author, see output generation hooks to find out which hooks can be used.\n\nThe following will add minification to one of the outputs:\n\nplugins ​\n\nType:MaybeArray<MaybePromise<Plugin | void>>\n\nSee Using plugins for more information on how to use plugins and Plugins on how to write your own (try it out, it's not as difficult as it may sound and very much extends what you can do with Rollup). For plugins imported from packages, remember to call the imported plugin function (i.e. commonjs(), not just commonjs). Falsy plugins will be ignored, which can be used to easily activate or deactivate plugins. Nested plugins will be flattened. Async plugins will be awaited and resolved.\n\n(This example also demonstrates how to use an async IIFE and dynamic imports to avoid unnecessary module loading, which can be surprisingly slow.)\n\nAdvanced functionality ​\n\ncache ​\n\nType:RollupCache | booleanDefault:true\n\nThe cache property of a previous bundle. Use it to speed up subsequent builds in watch mode — Rollup will only reanalyse the modules that have changed. Setting this option explicitly to false will prevent generating the cache property on the bundle and also deactivate caching for plugins.\n\nlogLevel ​\n\nType:LogLevel | \"silent\"CLI:--logLevel <level>Default:\"info\"\n\nDetermine which logs to process. See onLog for the available log levels. The default logLevel of \"info\" means that info and warnings logs will be processed while debug logs will be swallowed, which means that they are neither passed to plugin onLog hooks nor the onLog option or printed to the console.\n\nWhen using the CLI, errors will still be printed to the console as they are not processed via the logging system. See the --silent flag for how to suppress error logs.\n\nmakeAbsoluteExternalsRelative ​\n\nType:boolean| \"ifRelativeSource\"CLI:--makeAbsoluteExternalsRelative/--no-makeAbsoluteExternalsRelativeDefault:\"ifRelativeSource\"\n\nDetermines if absolute external paths should be converted to relative paths in the output. This does not only apply to paths that are absolute in the source but also to paths that are resolved to an absolute path by either a plugin or Rollup core.\n\nFor true, an external import like import \"/Users/Rollup/project/relative.js\" would be converted to a relative path. When converting an absolute path to a relative path, Rollup does not take the file or dir options into account, because those may not be present e.g. for builds using the JavaScript API. Instead, it assumes that the root of the generated bundle is located at the common shared parent directory of all modules that were included in the bundle. Assuming that the common parent directory of all modules is \"/Users/Rollup/project\", the import from above would likely be converted to import \"./relative.js\" in the output. If the output chunk is itself nested in a subdirectory by choosing e.g. chunkFileNames: \"chunks/[name].js\", the import would be \"../relative.js\".\n\nAs stated before, this would also apply to originally relative imports like import \"./relative.js\" that are resolved to an absolute path before they are marked as external by the external option.\n\nOne common problem is that this mechanism will also apply to imports like import \"/absolute.js'\", resulting in unexpected relative paths in the output.\n\nFor this case, \"ifRelativeSource\" checks if the original import was a relative import and only then convert it to a relative import in the output. Choosing false will keep all paths as absolute paths in the output.\n\nNote that when a relative path is directly marked as \"external\" using the external option, then it will be the same relative path in the output. When it is resolved first via a plugin or Rollup core and then marked as external, the above logic will apply.\n\nmaxParallelFileOps ​\n\nType:numberCLI:--maxParallelFileOps <number>Default:20\n\nLimits the number of files rollup will open in parallel when reading modules or writing chunks. Without a limit or with a high enough value, builds can fail with an \"EMFILE: too many open files\". This depends on how many open file handles the operating system allows.\n\nonLog ​\n\nType:(level: LogLevel, log: RollupLog, defaultHandler: LogOrStringHandler) => void;\n\nA function that intercepts log messages. If not supplied, logs are printed to the console, whereby Rollup CLI aggregates certain \"warn\" logs and prints consolidated warnings after the build to reduce noise. This handler is also triggered when using the --silent CLI option.\n\nThe function receives three arguments: the log level, the log object and the default handler. Log objects have, at a minimum, a code and a message property, allowing you to control how different kinds of logs are handled. Other properties are added depending on the type of log. See utils/logs.ts for a complete list of built-in errors and logs together with their codes and properties.\n\nIf the default handler is not invoked, the log will not be printed to the console. Moreover, you can change the log level by invoking the default handler with a different level. Using the additional level \"error\" will turn the log into a thrown error that has all properties of the log attached.\n\nThis handler will not be invoked if logs are filtered out by the logLevel option. I.e. by default, \"debug\" logs will be swallowed.\n\nSome logs also have a loc property and a frame allowing you to locate the source of the log:\n\nonwarn ​\n\nType:(warning: RollupLog, defaultHandler: (warning: string | RollupLog) => void) => void;\n\nA function that will intercept warning messages. It is very similar to onLog but only receives warnings. If the default handler is invoked, the log will be handled as a warning. If both an onLog and onwarn handler are provided, the onwarn handler will only be invoked if onLog calls its default handler with a level of warn.\n\nSee onLog for more information.\n\noutput.assetFileNames ​\n\nType:string| ((assetInfo: PreRenderedAsset) => string)CLI:--assetFileNames <pattern>Default:\"assets/[name]-[hash][extname]\"\n\nThe pattern to use for naming custom emitted assets to include in the build output, or a function that is called per asset to return such a pattern. Patterns support the following placeholders:\n\n[extname]: The file extension of the asset including a leading dot, e.g. .css.\n\n[ext]: The file extension without a leading dot, e.g. css.\n\n[hash]: A hash based on the content of the asset. You can also set a specific hash length via e.g. [hash:10]. By default, it will create a base-64 hash. If you need a reduced character sets, see output.hashCharacters\n\n[name]: The file name of the asset excluding any extension.\n\nForward slashes / can be used to place files in sub-directories. When using a function, PreRenderedAsset is a reduced version of the OutputAsset type in generateBundle without the fileName. See also output.chunkFileNames, output.entryFileNames.\n\nType:string | ((chunk: RenderedChunk) => string| Promise<string>)CLI:--banner/--footer <text>\n\nSee the renderChunk hook for the RenderedChunk type.\n\nA string to prepend/append to the bundle. You can also supply a function that returns a Promise that resolves to a string to generate it asynchronously (Note: banner and footer options will not break sourcemaps).\n\nIf you supply a function, chunk contains additional information about the chunk using a RenderedChunk type that is a reduced version of the OutputChunk type used in generateBundle hook with the following differences:\n\ncode and map are not set as the chunk has not been rendered yet.\n\nall referenced chunk file names that would contain hashes will contain hash placeholders instead. This includes fileName, imports, importedBindings, dynamicImports and implicitlyLoadedBefore. When you use such a placeholder file name or part of it in the code returned from this option, Rollup will replace the placeholder with the actual hash before generateBundle, making sure the hash reflects the actual content of the final generated chunk including all referenced file hashes.\n\nchunk is mutable and changes applied in this hook will propagate to other plugins and to the generated bundle. That means if you add or remove imports or exports in this hook, you should update imports, importedBindings and/or exports.\n\nSee also output.intro/output.outro.\n\noutput.chunkFileNames ​\n\nType:string | ((chunkInfo: PreRenderedChunk) => string)CLI:--chunkFileNames <pattern>Default:\"[name]-[hash].js\"\n\nThe pattern to use for naming shared chunks created when code-splitting, or a function that is called per chunk to return such a pattern. Patterns support the following placeholders:\n\n[format]: The rendering format defined in the output options, e.g. es or cjs.\n\n[hash]: A hash based only on the content of the final generated chunk, including transformations in renderChunk and any referenced file hashes. You can also set a specific hash length via e.g. [hash:10]. By default, it will create a base-64 hash. If you need a reduced character sets, see output.hashCharacters\n\n[name]: The name of the chunk. This can be explicitly set via the output.manualChunks option or when the chunk is created by a plugin via this.emitFile. Otherwise, it will be derived from the chunk contents.\n\nForward slashes / can be used to place files in sub-directories. When using a function, PreRenderedChunk is a reduced version of the OutputChunk type in generateBundle without properties that depend on file names and no information about the rendered modules as rendering only happens after file names have been generated. You can however access a list of included moduleIds. See also output.assetFileNames, output.entryFileNames.\n\noutput.compact ​\n\nType:booleanCLI:--compact/--no-compactDefault:false\n\nThis will minify the wrapper code generated by rollup. Note that this does not affect code written by the user. This option is useful when bundling pre-minified code.\n\noutput.dynamicImportInCjs ​\n\nType:booleanCLI:--dynamicImportInCjs/--no-dynamicImportInCjsDefault:true\n\nWhile CommonJS output originally supported only require(…) to import dependencies, recent Node versions also started to support import(…), which is the only way to import ES modules from CommonJS files. If this option is true, which is the default, Rollup will keep external dynamic imports as import(…) expressions in CommonJS output. Set this to false to rewrite dynamic imports using require(…) syntax.\n\noutput.entryFileNames ​\n\nType:string | ((chunkInfo: PreRenderedChunk) => string)CLI:--entryFileNames <pattern>Default:\"[name].js\"\n\nSee output.chunkFileNames for the PreRenderedChunk type.\n\nThe pattern to use for chunks created from entry points, or a function that is called per entry chunk to return such a pattern. Patterns support the following placeholders:\n\n[format]: The rendering format defined in the output options, e.g. es or cjs.\n\n[hash]: A hash based only on the content of the final generated entry chunk, including transformations in renderChunk and any referenced file hashes. You can also set a specific hash length via e.g. [hash:10]. By default, it will create a base-64 hash. If you need a reduced character sets, see output.hashCharacters\n\n[name]: The file name (without extension) of the entry point, unless the object form of input was used to define a different name.\n\nForward slashes / can be used to place files in sub-directories. When using a function, PreRenderedChunk is a reduced version of the OutputChunk type in generateBundle without properties that depend on file names and no information about the rendered modules as rendering only happens after file names have been generated. You can however access a list of included moduleIds. See also output.assetFileNames, output.chunkFileNames.\n\nThis pattern will also be used for every file when setting the output.preserveModules option. Note that in this case, [name] will include the relative path from the output root and possibly the original file extension if it was not one of .js, .jsx, .mjs, .cjs, .ts, .tsx, .mts, or .cts.\n\noutput.extend ​\n\nType:booleanCLI:--extend/--no-extendDefault:false\n\nWhether to extend the global variable defined by the name option in umd or iife formats. When true, the global variable will be defined as (global.name = global.name || {}). When false, the global defined by name will be overwritten like (global.name = {}).\n\noutput.externalImportAttributes ​\n\nType:booleanCLI:--externalImportAttributes/--no-externalImportAttributesDefault:true\n\nWhether to add import attributes to external imports in the output if the output format is es. By default, attributes are taken from the input files, but plugins can add or remove attributes later. E.g. import \"foo\" assert {type: \"json\"} will cause the same import to appear in the output unless the option is set to false. Note that all imports of a module need to have consistent attributes, otherwise a warning is emitted.\n\noutput.generatedCode ​\n\nType:\"es5\" | \"es2015\"| { arrowFunctions?: boolean, constBindings?: boolean, objectShorthand?: boolean, preset?: \"es5\"| \"es2015\", reservedNamesAsProps?: boolean, symbols?: boolean }CLI:--generatedCode <preset>Default:\"es5\"\n\nWhich language features Rollup can safely use in generated code. This will not transpile any user code but only change the code Rollup uses in wrappers and helpers. You may choose one of several presets:\n\n\"es5\": Do not use ES2015+ features like arrow functions, but do not quote reserved names used as props.\n\n\"es2015\": Use any JavaScript features up to ES2015.\n\noutput.generatedCode.arrowFunctions ​\n\nType:booleanCLI:--generatedCode.arrowFunctions/--no-generatedCode.arrowFunctionsDefault:false\n\nWhether to use arrow functions for auto-generated code snippets. Note that in certain places like module wrappers, Rollup will keep using regular functions wrapped in parentheses as in some JavaScript engines, these will provide noticeably better performance.\n\noutput.generatedCode.constBindings ​\n\nType:booleanCLI:--generatedCode.constBindings/--no-generatedCode.constBindingsDefault:false\n\nThis will use const instead of var in certain places and helper functions. This will allow Rollup to generate more efficient helpers due to block scoping.\n\noutput.generatedCode.objectShorthand ​\n\nType:booleanCLI:--generatedCode.objectShorthand/--no-generatedCode.objectShorthandDefault:false\n\nAllows the use of shorthand notation in objects when the property name matches the value.\n\noutput.generatedCode.preset ​\n\nType:\"es5\" | \"es2015\"CLI:--generatedCode <value>\n\nAllows choosing one of the presets listed above while overriding some options.\n\noutput.generatedCode.reservedNamesAsProps ​\n\nType:booleanCLI:--generatedCode.reservedNamesAsProps/--no-generatedCode.reservedNamesAsPropsDefault:true\n\nDetermine whether reserved words like \"default\" can be used as prop names without using quotes. This will make the syntax of the generated code ES3 compliant. Note however that for full ES3 compliance, you may also need to polyfill some builtin functions like Object.keys or Array.prototype.forEach.\n\noutput.generatedCode.symbols ​\n\nType:booleanCLI:--generatedCode.symbols/--no-generatedCode.symbolsDefault:false\n\nWhether to allow the use of Symbol in auto-generated code snippets. Currently, this only controls if namespaces will have the Symbol.toStringTag property set to the correct value of Module, which means that for a namespace, String(namespace) logs [object Module]. This again is used for feature detection in certain libraries and frameworks.\n\noutput.hashCharacters ​\n\nType:\"base64\" | \"base36\" | \"hex\"CLI:--hashCharacters <name>Default:\"base64\"\n\nThis determines the character set that Rollup is allowed to use in file hashes.\n\nthe default \"base64\" will use url-safe base-64 hashes with potential characters ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_.\n\n\"base36\" will only use lower-case letters and numbers abcdefghijklmnopqrstuvwxyz0123456789.\n\n\"hex\" will create hexadecimal hashes with characters abcdef0123456789.\n\noutput.hoistTransitiveImports ​\n\nType:booleanCLI:--hoistTransitiveImports/--no-hoistTransitiveImportsDefault:true\n\nBy default, when creating multiple chunks, transitive imports of entry chunks will be added as empty imports to the entry chunks. See \"Why do additional imports turn up in my entry chunks when code-splitting?\" for details and background. Setting this option to false will disable this behaviour. This option is ignored when using the output.preserveModules option as here, imports will never be hoisted.\n\noutput.importAttributesKey ​\n\nType:\"with\" | \"assert\"CLI:--importAttributesKey <name>Default:\"assert\"\n\nThis determines the keyword set that Rollup will use for import attributes.\n\noutput.inlineDynamicImports ​\n\nType:booleanCLI:--inlineDynamicImports/--no-inlineDynamicImportsDefault:false\n\nThis will inline dynamic imports instead of creating new chunks to create a single bundle. Only possible if a single input is provided. Note that this will change the execution order: A module that is only imported dynamically will be executed immediately if the dynamic import is inlined.\n\noutput.interop ​\n\nType:\"compat\" | \"auto\"| \"esModule\"| \"default\"| \"defaultOnly\"| ((id: string) => \"compat\"| \"auto\"| \"esModule\"| \"default\"| \"defaultOnly\")CLI:--interop <value>Default:\"default\"\n\nControls how Rollup handles default, namespace and dynamic imports from external dependencies in formats like CommonJS that do not natively support these concepts. Note that the default mode of \"default\" mimics NodeJS behavior and is different from TypeScript esModuleInterop. To get TypeScript's behavior, explicitly set the value to \"auto\". In the examples, we will be using the CommonJS format, but the choice of interop similarly applies to AMD, IIFE and UMD targets as well.\n\nTo understand the different values, assume we are bundling the following code for a cjs target:\n\nKeep in mind that for Rollup, import * as ext_namespace from 'external'; console.log(ext_namespace.bar); is completely equivalent to import {bar} from 'external'; console.log(bar); and will produce the same code. In the example above however, the namespace object itself is passed to a global function as well, which means we need it as a properly formed object.\n\n\"default\" assumes that the required value should be treated as the default export of the imported module, just like when importing CommonJS from an ES module context in NodeJS. Named imports are supported as well, which are treated as properties of the default import. To create the namespace object, Rollup injects these helpers:\n\njs\n\nvar\n\nexternal\n\n=\n\nrequire\n\n('external1'); function\n\n_interopNamespaceDefault\n\n(\n\ne\n\n) { var\n\nn\n\n=\n\nObject\n\n.\n\ncreate\n\n(null); if (\n\ne\n\n) {\n\nObject\n\n.\n\nkeys\n\n(\n\ne\n\n).\n\nforEach\n\n(function (\n\nk\n\n) { if (\n\nk\n\n!== 'default') { var\n\nd\n\n=\n\nObject\n\n.\n\ngetOwnPropertyDescriptor\n\n(\n\ne\n\n,\n\nk\n\n);\n\nObject\n\n.\n\ndefineProperty\n\n(\n\nn\n\n,\n\nk\n\n,\n\nd\n\n.\n\nget\n\n?\n\nd\n\n: {\n\nenumerable\n\n: true,\n\nget\n\n: function () { return\n\ne\n\n[\n\nk\n\n]; } } ); } }); }\n\nn\n\n.default=\n\ne\n\n; return\n\nObject\n\n.\n\nfreeze\n\n(\n\nn\n\n); } var\n\nexternal__namespace\n\n= /*#__PURE__*/\n\n_interopNamespaceDefault\n\n(\n\nexternal\n\n);\n\nconsole\n\n.\n\nlog\n\n(\n\nexternal\n\n,\n\nexternal__namespace\n\n.bar,\n\nexternal__namespace\n\n);\n\nPromise\n\n.\n\nresolve\n\n() .\n\nthen\n\n(function () { return /*#__PURE__*/\n\n_interopNamespaceDefault\n\n(\n\nrequire\n\n('external2')); }) .\n\nthen\n\n(\n\nconsole\n\n.\n\nlog\n\n);\n\n\"esModule\" assumes that required modules are transpiled ES modules where the required value corresponds to the module namespace, and the default export is the .default property of the exported object. This is the only interop type that will not inject any helper functions:\n\njs\n\nvar external = require('external1'); console.log(external.default, external.bar, external); Promise.resolve() .then(function () { return require('external2'); }) .then(console.log);\n\nWhen esModule is used, Rollup adds no additional interop helpers and also supports live-bindings for default exports.\n\n\"auto\" combines both \"esModule\" and \"default\" by injecting helpers that contain code that detects at runtime if the required value contains the __esModule property. Adding this property is a hack implemented by TypeScript esModuleInterop, Babel and other tools to signify that the required value is the namespace of a transpiled ES module.:\n\njs\n\nvar\n\nexternal\n\n=\n\nrequire\n\n('external1'); function\n\n_interopNamespace\n\n(\n\ne\n\n) { if (\n\ne\n\n&&\n\ne\n\n.__esModule) return\n\ne\n\n; var\n\nn\n\n=\n\nObject\n\n.\n\ncreate\n\n(null); if (\n\ne\n\n) {\n\nObject\n\n.\n\nkeys\n\n(\n\ne\n\n).\n\nforEach\n\n(function (\n\nk\n\n) { if (\n\nk\n\n!== 'default') { var\n\nd\n\n=\n\nObject\n\n.\n\ngetOwnPropertyDescriptor\n\n(\n\ne\n\n,\n\nk\n\n);\n\nObject\n\n.\n\ndefineProperty\n\n(\n\nn\n\n,\n\nk\n\n,\n\nd\n\n.\n\nget\n\n?\n\nd\n\n: {\n\nenumerable\n\n: true,\n\nget\n\n: function () { return\n\ne\n\n[\n\nk\n\n]; } } ); } }); }\n\nn\n\n.default=\n\ne\n\n; return\n\nObject\n\n.\n\nfreeze\n\n(\n\nn\n\n); } var\n\nexternal__namespace\n\n= /*#__PURE__*/\n\n_interopNamespace\n\n(\n\nexternal\n\n);\n\nconsole\n\n.\n\nlog\n\n(\n\nexternal__namespace\n\n.default,\n\nexternal__namespace\n\n.bar,\n\nexternal__namespace\n\n);\n\nPromise\n\n.\n\nresolve\n\n() .\n\nthen\n\n(function () { return /*#__PURE__*/\n\n_interopNamespace\n\n(\n\nrequire\n\n('external2')); }) .\n\nthen\n\n(\n\nconsole\n\n.\n\nlog\n\n);\n\nNote how Rollup is reusing the created namespace object to get the default export. If the namespace object is not needed, Rollup will use a simpler helper:\n\njs\n\n// input import ext_default from 'external'; console.log(ext_default); // output var ext_default = require('external'); function _interopDefault(e) { return e && e.__esModule ? e : { default: e }; } var ext_default__default = /*#__PURE__*/ _interopDefault(ext_default); console.log(ext_default__default.default);\n\ncompat is equivalent to \"auto\" except that it uses a slightly different helper for the default export that checks for the presence of a default property instead of the __esModule property. Except for the rare situation where a CommonJS module exports a property \"default\" that should not be the default export, this often helps to make interop \"just work\" as it does not rely on idiosyncratic hacks but instead uses duck-typing:\n\njs\n\nvar\n\nexternal\n\n=\n\nrequire\n\n('external1'); function\n\n_interopNamespaceCompat\n\n(\n\ne\n\n) { if (\n\ne\n\n&& typeof\n\ne\n\n=== 'object' && 'default' in\n\ne\n\n) return\n\ne\n\n; var\n\nn\n\n=\n\nObject\n\n.\n\ncreate\n\n(null); if (\n\ne\n\n) {\n\nObject\n\n.\n\nkeys\n\n(\n\ne\n\n).\n\nforEach\n\n(function (\n\nk\n\n) { if (\n\nk\n\n!== 'default') { var\n\nd\n\n=\n\nObject\n\n.\n\ngetOwnPropertyDescriptor\n\n(\n\ne\n\n,\n\nk\n\n);\n\nObject\n\n.\n\ndefineProperty\n\n(\n\nn\n\n,\n\nk\n\n,\n\nd\n\n.\n\nget\n\n?\n\nd\n\n: {\n\nenumerable\n\n: true,\n\nget\n\n: function () { return\n\ne\n\n[\n\nk\n\n]; } } ); } }); }\n\nn\n\n.default=\n\ne\n\n; return\n\nObject\n\n.\n\nfreeze\n\n(\n\nn\n\n); } var\n\nexternal__namespace\n\n= /*#__PURE__*/\n\n_interopNamespaceCompat\n\n(\n\nexternal\n\n);\n\nconsole\n\n.\n\nlog\n\n(\n\nexternal__namespace\n\n.default,\n\nexternal__namespace\n\n.bar,\n\nexternal__namespace\n\n);\n\nPromise\n\n.\n\nresolve\n\n() .\n\nthen\n\n(function () { return /*#__PURE__*/\n\n_interopNamespaceCompat\n\n(\n\nrequire\n\n('external2')); }) .\n\nthen\n\n(\n\nconsole\n\n.\n\nlog\n\n);\n\nSimilar to \"auto\", Rollup will use a simpler helper if the namespace is not needed:\n\njs\n\n// input import ext_default from 'external'; console.log(ext_default); // output var ext_default = require('external'); function _interopDefaultCompat(e) { return e && typeof e === 'object' && 'default' in e ? e : { default: e }; } var ext_default__default = /*#__PURE__*/ _interopDefaultCompat(ext_default); console.log(ext_default__default.default);\n\n\"defaultOnly\" is similar to \"default\" except for the following:\n\nNamed imports are forbidden. If such an import is encountered, Rollup throws an error even in es and system formats. That way it is ensures that the es version of the code is able to import non-builtin CommonJS modules in Node correctly.\n\nWhile namespace reexports export * from 'external'; are not prohibited, they are ignored and will cause Rollup to display a warning because they would not have an effect if there are no named exports.\n\nWhen a namespace object is generated, Rollup uses a much simpler helper.\n\nHere is what Rollup will create from the example code. Note that we removed external.bar from the code as otherwise, Rollup would have thrown an error because, as stated before, this is equivalent to a named import.\n\njs\n\nvar ext_default = require('external1'); function _interopNamespaceDefaultOnly(e) { return Object.freeze({ __proto__: null, default: e }); } var ext_default__namespace = /*#__PURE__*/ _interopNamespaceDefaultOnly(ext_default); console.log(ext_default, ext_default__namespace); Promise.resolve() .then(function () { return /*#__PURE__*/ _interopNamespaceDefaultOnly( require('external2') ); }) .then(console.log);\n\nWhen a function is supplied, Rollup will pass each external id to this function once to control the interop type per dependency.\n\nAs an example if all dependencies are CommonJs, the following config will ensure that named imports are only permitted from Node builtins:\n\njs\n\n// rollup.config.js import\n\nbuiltins\n\nfrom 'builtins'; const\n\nnodeBuiltins\n\n= new\n\nSet\n\n(\n\nbuiltins\n\n()); export default { // ...\n\noutput\n\n: { // ...\n\ninterop\n\n(\n\nid\n\n) { if (\n\nnodeBuiltins\n\n.\n\nhas\n\n(\n\nid\n\n)) { return 'default'; } return 'defaultOnly'; } } };\n\nThere are some additional options that have an effect on the generated interop code:\n\nSetting output.externalLiveBindings to false will generate simplified namespace helpers as well as simplified code for extracted default imports.\n\nSetting output.freeze to false will prevent generated interop namespace objects from being frozen.\n\noutput.intro/output.outro ​\n\nType:string | ((chunk: RenderedChunk) => string| Promise<string>)CLI:--intro/--outro <text>\n\nSimilar to output.banner/output.footer, except that the code goes inside any format-specific wrapper.\n\noutput.manualChunks ​\n\nType:{ [chunkAlias: string]: string[] } | ((id: string, {getModuleInfo, getModuleIds}) => string | void)\n\nAllows the creation of custom shared common chunks. When using the object form, each property represents a chunk that contains the listed modules and all their dependencies if they are part of the module graph unless they are already in another manual chunk. The name of the chunk will be determined by the property key.\n\nNote that it is not necessary for the listed modules themselves to be part of the module graph, which is useful if you are working with @rollup/plugin-node-resolve and use deep imports from packages. For instance\n\nwill put all lodash modules into a manual chunk even if you are only using imports of the form import get from 'lodash/get'.\n\nWhen using the function form, each resolved module id will be passed to the function. If a string is returned, the module and all its dependency will be added to the manual chunk with the given name. For instance this will create a vendor chunk containing all dependencies inside node_modules:\n\nBe aware that manual chunks can change the behaviour of the application if side effects are triggered before the corresponding modules are actually used.\n\nWhen using the function form, manualChunks will be passed an object as second parameter containing the functions getModuleInfo and getModuleIds that work the same way as this.getModuleInfo and this.getModuleIds on the plugin context.\n\nThis can be used to dynamically determine into which manual chunk a module should be placed depending on its position in the module graph. For instance consider a scenario where you have a set of components, each of which dynamically imports a set of translated strings, i.e.\n\nIf a lot of such components are used together, this will result in a lot of dynamic imports of very small chunks: Even though we know that all language files of the same language that are imported by the same chunk will always be used together, Rollup does not have this information.\n\nThe following code will merge all files of the same language that are only used by a single entry point:\n\noutput.minifyInternalExports ​\n\nType:booleanCLI:--minifyInternalExports/--no-minifyInternalExportsDefault:true for formats es and system or if output.compact is true, false otherwise\n\nBy default, for formats es and system or if output.compact is true, Rollup will try to export internal variables as single letter variables to allow for better minification.\n\nExample\n\nInput:\n\nOutput with output.minifyInternalExports: true:\n\nOutput with output.minifyInternalExports: false:\n\nEven though it appears that setting this option to true makes the output larger, it actually makes it smaller if a minifier is used. In this case, export { importantValue as i } can become e.g. export{a as i} or even export{i}, while otherwise it would produce export{ a as importantValue } because a minifier usually will not change export signatures.\n\noutput.paths ​\n\nType:{ [id: string]: string } | ((id: string) => string)\n\nMaps external module IDs to paths. External ids are ids that cannot be resolved or ids explicitly provided by the external option. Paths supplied by output.paths will be used in the generated bundle instead of the module ID, allowing you to, for example, load dependencies from a CDN:\n\noutput.preserveModules ​\n\nType:booleanCLI:--preserveModules/--no-preserveModulesDefault:false\n\nInstead of creating as few chunks as possible, this mode will create separate chunks for all modules using the original module names as file names. Requires the output.dir option. Tree-shaking will still be applied, suppressing files that are not used by the provided entry points or do not have side effects when executed and removing unused exports of files that are not entry points. On the other hand, if plugins (like @rollup/plugin-commonjs) emit additional \"virtual\" files to achieve certain results, those files will be emitted as actual files using a pattern _virtual/fileName.js.\n\nIt is therefore not recommended to blindly use this option to transform an entire file structure to another format if you directly want to import from those files as expected exports may be missing. In that case, you should rather designate all files explicitly as entry points by adding them to the input option object, see the example there for how to do that.\n\nNote that when transforming to cjs or amd format, each file will by default be treated as an entry point with output.exports set to auto. This means that e.g. for cjs, a file that only contains a default export will be rendered as\n\nassigning the value directly to module.exports. If someone imports this file, they will get access to the default export via\n\nAs with regular entry points, files that mix default and named exports will produce warnings. You can avoid the warnings by forcing all files to use named export mode via output.exports: \"named\". In that case, the default export needs to be accessed via the .default property of the export:\n\noutput.preserveModulesRoot ​\n\nType:stringCLI:--preserveModulesRoot <directory-name>\n\nA directory path to input modules that should be stripped away from output.dir path while output.preserveModules is true.\n\nFor example, given the following configuration:\n\nThe preserveModulesRoot setting ensures that the input modules will be output to the paths dist/module.js and dist/another/module.js.\n\nThis option is particularly useful while using plugins such as @rollup/plugin-node-resolve, which may cause changes in the output directory structure. This can happen when third-party modules are not marked external, or while developing in a monorepo of multiple packages that rely on one another and are not marked external.\n\noutput.sourcemap ​\n\nType:boolean | 'inline'| 'hidden'CLI:-m/--sourcemap/--no-sourcemapDefault:false\n\nIf true, a separate sourcemap file will be created. If \"inline\", the sourcemap will be appended to the resulting output file as a data URI. \"hidden\" works like true except that the corresponding sourcemap comments in the bundled files are suppressed.\n\noutput.sourcemapBaseUrl ​\n\nType:stringCLI:--sourcemapBaseUrl <url>\n\nBy default, sourcemap files generated by Rollup uses relative URLs to reference the files they describe. By providing an absolute base URL, e.g. https://example.com, sourcemaps will use absolute URLs instead.\n\noutput.sourcemapExcludeSources ​\n\nType:booleanCLI:--sourcemapExcludeSources/--no-sourcemapExcludeSourcesDefault:false\n\nIf true, the actual code of the sources will not be added to the sourcemaps, making them considerably smaller.\n\noutput.sourcemapFile ​\n\nType:stringCLI:--sourcemapFile <file-name-with-path>\n\nThe location of the generated bundle. If this is an absolute path, all the sources paths in the sourcemap will be relative to it. The map.file property is the basename of sourcemapFile, as the location of the sourcemap is assumed to be adjacent to the bundle.\n\nsourcemapFile is not required if output is specified, in which case an output filename will be inferred by adding \".map\" to the output filename for the bundle.\n\noutput.sourcemapFileNames ​\n\nType:string | ((chunkInfo: PreRenderedChunk) => string)CLI:--sourcemapFileNames <pattern>\n\nSee output.chunkFileNames for the PreRenderedChunk type.\n\nThe pattern to use for sourcemaps, or a function that is called per sourcemap to return such a pattern. Patterns support the following placeholders:\n\n[format]: The rendering format defined in the output options, e.g. es or cjs.\n\n[hash]: A hash based only on the content of the final generated sourcemap. You can also set a specific hash length via e.g. [hash:10]. By default, it will create a base-64 hash. If you need a reduced character sets, see output.hashCharacters\n\n[chunkhash]: The same hash as the one used for the corresponding generated chunk (if any).\n\n[name]: The file name (without extension) of the entry point, unless the object form of input was used to define a different name.\n\nForward slashes / can be used to place files in sub-directories. When using a function, chunkInfo is a reduced version of the one in generateBundle without properties that depend on file names and no information about the rendered modules as rendering only happens after file names have been generated. You can however access a list of included moduleIds. See also output.assetFileNames, output.chunkFileNames.\n\noutput.sourcemapIgnoreList ​\n\nType:boolean | (relativeSourcePath: string, sourcemapPath: string) => boolean\n\nA predicate to decide whether or not to ignore-list source files in a sourcemap, used to populate the x_google_ignoreList source map extension. relativeSourcePath is a relative path from the generated .map file to the corresponding source file while sourcemapPath is the fully resolved path of the generated sourcemap file.\n\nWhen you don't specify this option explicitly, by default it will put all files with node_modules in their path on the ignore list. You can specify false here to turn off the ignore-listing completely.\n\noutput.sourcemapPathTransform ​\n\nType:(relativeSourcePath: string, sourcemapPath: string) => string\n\nA transformation to apply to each path in a sourcemap. relativeSourcePath is a relative path from the generated .map file to the corresponding source file while sourcemapPath is the fully resolved path of the generated sourcemap file.\n\nType:booleanCLI:--validate/--no-validateDefault:false\n\nRe-parses each generated chunk to detect if the generated code is valid JavaScript. This can be useful to debug output generated by plugins that use the renderChunk hook to transform code.\n\nIf the code is invalid, a warning will be issued. Note that no error is thrown so that you can still inspect the generated output. To promote this warning to an error, you can watch for it in an onwarn handler.\n\npreserveEntrySignatures ​\n\nType:\"strict\" | \"allow-extension\" | \"exports-only\"| falseCLI:--preserveEntrySignatures <strict | allow-extension>/--no-preserveEntrySignaturesDefault:\"exports-only\"\n\nControls if Rollup tries to ensure that entry chunks have the same exports as the underlying entry module.\n\nIf set to \"strict\", Rollup will create exactly the same exports in the entry chunk as there are in the corresponding entry module. If this is not possible because additional internal exports need to be added to a chunk, Rollup will instead create a \"facade\" entry chunk that reexports just the necessary bindings from other chunks but contains no code otherwise. This is the recommended setting for libraries.\n\n\"allow-extension\" will create all exports of the entry module in the entry chunk but may also add additional exports if necessary, avoiding a \"facade\" entry chunk. This setting makes sense for libraries where a strict signature is not required.\n\n\"exports-only\" behaves like \"strict\" if the entry module has exports, otherwise it behaves like \"allow-extension\".\n\nfalse will not add any exports of an entry module to the corresponding chunk and does not even include the corresponding code unless those exports are used elsewhere in the bundle. Internal exports may be added to entry chunks, though. This is the recommended setting for web apps where the entry chunks are to be placed in script tags as it may reduce both the number of chunks and possibly the bundle size.\n\nExample\n\nInput:\n\nOutput for preserveEntrySignatures: \"strict\":\n\nOutput for preserveEntrySignatures: \"allow-extension\":\n\nOutput for preserveEntrySignatures: false:\n\nAt the moment, the only way to override this setting for individual entry chunks is to use the plugin API and emit those chunks via this.emitFile instead of using the input option.\n\nstrictDeprecations ​\n\nType:booleanCLI:--strictDeprecations/--no-strictDeprecationsDefault:false\n\nWhen this flag is enabled, Rollup will throw an error instead of showing a warning when a deprecated feature is used. Furthermore, features that are marked to receive a deprecation warning with the next major version will also throw an error when used.\n\nThis flag is intended to be used by e.g. plugin authors to be able to adjust their plugins for upcoming major releases as early as possible.\n\nDanger zone ​\n\nYou probably don't need to use these options unless you know what you are doing!\n\ncontext ​\n\nType:stringCLI:--context <contextVariable>Default:undefined\n\nBy default, the context of a module – i.e., the value of this at the top level – is undefined. In rare cases you might need to change this to something else, like 'window'.\n\nmoduleContext ​\n\nType:((id: string) => string) | { [id: string]: string }\n\nSame as context, but per-module – can either be an object of id: context pairs, or an id => context function.\n\noutput.amd ​\n\nType:{ id?: string, autoId?: boolean, basePath?: string, define?: string }\n\nNote id can only be used for single-file builds, and cannot be combined with autoId/basePath.\n\noutput.amd.id ​\n\nType:stringCLI:--amd.id <amdId>\n\nAn ID to use for AMD/UMD bundles:\n\noutput.amd.autoId ​\n\nType:booleanCLI:--amd.autoId\n\nSet the ID to the chunk ID (with the '.js' extension removed).\n\noutput.amd.basePath ​\n\nType:stringCLI:--amd.basePath\n\nThe path that will be prepended to the auto generated ID. This is useful if the build is going to be placed inside another AMD project, and is not at the root.\n\nOnly valid with output.amd.autoId.\n\noutput.amd.define ​\n\nType:stringCLI:--amd.define <defineFunctionName>\n\nA function name to use instead of define:\n\noutput.amd.forceJsExtensionForImports ​\n\nType:booleanCLI:--amd.forceJsExtensionForImportsDefault:false\n\nAdd .js extension for imports of generated chunks and local AMD modules:\n\noutput.esModule ​\n\nType:boolean | \"if-default-prop\"CLI:--esModule/--no-esModuleDefault:\"if-default-prop\"\n\nWhether to add a __esModule: true property when generating exports for non-ES formats. This property signifies that the exported value is the namespace of an ES module and that the default export of this module corresponds to the .default property of the exported object.\n\ntrue will always add the property when using named exports mode, which is similar to what other tools do.\n\n\"if-default-prop\" will only add the property when using named exports mode and there also is a default export. The subtle difference is that if there is no default export, consumers of the CommonJS version of your library will get all named exports as default export instead of an error or undefined. We chose to make this the default value as the __esModule property is not a standard followed by any JavaScript runtime and leads to many interop issues, so we want to limit its use to the cases where it is really needed.\n\nfalse on the other hand will never add the property even if the default export would become a property .default.\n\nSee also output.interop.\n\noutput.exports ​\n\nType:\"auto\" | \"default\"| \"named\"| \"none\"CLI:--exports <exportMode>Default:'auto'\n\nWhat export mode to use. Defaults to auto, which guesses your intentions based on what the input module exports:\n\ndefault – if you are only exporting one thing using export default ...; note that this can cause issues when generating CommonJS output that is meant to be interchangeable with ESM output, see below\n\nnamed – if you are using named exports\n\nnone – if you are not exporting anything (e.g. you are building an app, not a library)\n\nAs this is only an output transformation, you can only choose default if a default export is the only export for all entry chunks. Likewise, you can only choose none if there are no exports, otherwise Rollup will throw an error.\n\nThe difference between default and named affects how other people can consume your bundle. If you use default, a CommonJS user could do this, for example:\n\nWith named, a user would do this instead:\n\nThe wrinkle is that if you use named exports but also have a default export, a user would have to do something like this to use the default export:\n\nNote: There are some tools such as Babel, TypeScript, Webpack, and @rollup/plugin-commonjs that are capable of resolving a CommonJS require(...) call with an ES module. If you are generating CommonJS output that is meant to be interchangeable with ESM output for those tools, you should always use named export mode. The reason is that most of those tools will by default return the namespace of an ES module on require where the default export is the .default property.\n\nIn other words for those tools, you cannot create a package interface where const lib = require(\"your-lib\") yields the same as import lib from \"your-lib\". With named export mode however, const {lib} = require(\"your-lib\") will be equivalent to import {lib} from \"your-lib\".\n\noutput.externalLiveBindings ​\n\nType:booleanCLI:--externalLiveBindings/--no-externalLiveBindingsDefault:true\n\nWhen set to false, Rollup will not generate code to support live bindings for external imports but instead assume that exports do not change over time. This will enable Rollup to generate more optimized code. Note that this can cause issues when there are circular dependencies involving an external dependency.\n\nThis will avoid most cases where Rollup generates getters in the code and can therefore be used to make code IE8 compatible in many cases.\n\nExample:\n\noutput.freeze ​\n\nType:booleanCLI:--freeze/--no-freezeDefault:true\n\nWhether to Object.freeze() namespace import objects (i.e. import * as namespaceImportObject from...) that are accessed dynamically.\n\noutput.indent ​\n\nType:boolean | stringCLI:--indent/--no-indentDefault:true\n\nThe indent string to use, for formats that require code to be indented (amd, iife, umd, system). Can also be false (no indent), or true (the default – auto-indent)\n\noutput.noConflict ​\n\nType:booleanCLI:--noConflict/--no-noConflictDefault:false\n\nThis will generate an additional noConflict export to UMD bundles. When called in an IIFE scenario, this method will return the bundle exports while restoring the corresponding global variable to its previous value.\n\noutput.reexportProtoFromExternal ​\n\nType:booleanCLI:--reexportProtoFromExternal/--no-reexportProtoFromExternalDefault:true\n\nThis option is only effective when output.format is set to one of ['amd', 'cjs', 'iife', 'umd'] and output.externalLiveBindings is set to false.\n\nFor maximum compatibility, Rollup reexports __proto__ from an external module by default. However, for common use cases, it is strongly recommended to set this value to false as it effectively reduces the output size.\n\noutput.sanitizeFileName ​\n\nType:boolean | (string) => stringCLI:--sanitizeFileName/no-sanitizeFileNameDefault:true\n\nSet to false to disable all chunk name sanitizations (removal of \\0, ? and * characters).\n\nAlternatively set to a function to allow custom chunk name sanitization.\n\noutput.strict ​\n\nType:booleanCLI:--strict/--no-strictDefault:true\n\nWhether to include the 'use strict' pragma at the top of generated non-ES bundles. Strictly speaking, ES modules are always in strict mode, so you shouldn't disable this without good reason.\n\noutput.systemNullSetters ​\n\nType:booleanCLI:--systemNullSetters/--no-systemNullSettersDefault:true\n\nWhen outputting the system module format, by default, empty setter functions are replaced with null as an output simplification. This is incompatible with SystemJS before v6.3.3. Deactivate this option to output empty functions instead that older SystemJS versions support.\n\nType:booleanCLI:--preserveSymlinksDefault:false\n\nWhen set to false, symbolic links are followed when resolving a file. When set to true, instead of being followed, symbolic links are treated as if the file is where the link is. To illustrate, consider the following situation:\n\nIf preserveSymlinks is false, then the bundle created from /main.js will log \"next to original\" as it will use the location of the symbolically linked file to resolve its dependencies. If preserveSymlinks is true, however, it will log \"next to linked\" as the symbolic link will not be resolved.\n\nshimMissingExports ​\n\nType:booleanCLI:--shimMissingExports/--no-shimMissingExportsDefault:false\n\nIf this option is provided, bundling will not fail if bindings are imported from a file that does not define these bindings. Instead, new variables will be created for these bindings with the value undefined.\n\ntreeshake ​\n\nType:boolean | TreeshakingPreset | TreeshakingOptionsCLI:--treeshake/--no-treeshakeDefault:true\n\nWhether to apply tree-shaking and to fine-tune the tree-shaking process. Setting this option to false will produce bigger bundles but may improve build performance. You may also choose one of three presets that will automatically be updated if new options are added:\n\n\"smallest\" will choose option values for you to minimize output size as much as possible. This should work for most code bases as long as you do not rely on certain patterns, which are currently:\n\ngetters with side effects will only be retained if the return value is used (treeshake.propertyReadSideEffects: false)\n\ncode from imported modules will only be retained if at least one exported value is used (treeshake.moduleSideEffects: false)\n\nyou should not bundle polyfills that rely on detecting broken builtins (treeshake.tryCatchDeoptimization: false)\n\nsome semantic issues may be swallowed (treeshake.unknownGlobalSideEffects: false, treeshake.correctVarValueBeforeDeclaration: false)\n\n\"recommended\" should work well for most usage patterns. Some semantic issues may be swallowed, though (treeshake.unknownGlobalSideEffects: false, treeshake.correctVarValueBeforeDeclaration: false)\n\n\"safest\" tries to be as spec compliant as possible while still providing some basic tree-shaking capabilities.\n\ntrue is equivalent to not specifying the option and will always choose the default value (see below).\n\nIf you discover a bug caused by the tree-shaking algorithm, please file an issue! Setting this option to an object implies tree-shaking is enabled and grants the following additional options:\n\ntreeshake.annotations ​\n\nType:booleanCLI:--treeshake.annotations/--no-treeshake.annotationsDefault:true\n\nIf false, ignore hints from annotation in comments:\n\n@__PURE__ ​\n\nComments containing @__PURE__ or #__PURE__ mark a specific function call or constructor invocation as side effect free. That means that Rollup will tree-shake i.e. remove the call unless the return value is used in some code that is not tree-shaken. These annotations need to immediately precede the call invocation to take effect. The following code will be completely tree-shaken unless this option is set to false, in which case it will remain unchanged.\n\nSuch an annotation is considered valid if it directly precedes a function call or constructor invocation and is only separated from the callee by white-space or comments. The only exception are parentheses that wrap a call or invocation.\n\nInvalid annotations are removed and Rollup emits a warning. Valid annotations remain in the code unless their function call or constructor invocation is removed as well.\n\n@__NO_SIDE_EFFECTS__ ​\n\nComments containing @__NO_SIDE_EFFECTS__ or #__NO_SIDE_EFFECTS__ mark a function declaration itself as side effect free. When a function has been marked as having no side effects, all calls to that function will be considered to be side effect free. The following code will be completely tree-shaken unless this option is set to false, in which case it will remain unchanged.\n\nSuch an annotation is considered valid if it directly precedes a function declaration or a constant variable declaration where the first declared variable is a function and is only separated from the declaration by white-space or comments.\n\nInvalid annotations are removed and Rollup emits a warning. Valid annotations remain in the code unless their declaration is removed as well\n\ntreeshake.correctVarValueBeforeDeclaration ​\n\nType:booleanCLI:--treeshake.correctVarValueBeforeDeclaration/--no-treeshake.correctVarValueBeforeDeclarationDefault:false\n\nIn some edge cases if a variable is accessed before its declaration assignment and is not reassigned, then Rollup may incorrectly assume that variable is constant throughout the program, as in the example below. This is not true if the variable is declared with var, however, as those variables can be accessed before their declaration where they will evaluate to undefined. Choosing true will make sure Rollup does not make any assumptions about the value of variables declared with var. Note though that this can have a noticeable negative impact on tree-shaking results.\n\ntreeshake.manualPureFunctions ​\n\nType:string[]CLI:--treeshake.manualPureFunctions <names>\n\nAllows to manually define a list of function names that should always be considered \"pure\", i.e. they have no side effects like changing global state etc. when called. The check is performed solely by name.\n\nThis can not only help with dead code removal, but can also improve JavaScript chunk generation especially when using output.experimentalMinChunkSize.\n\nBesides any functions matching that name, any properties on a pure function and any functions returned from a pure functions will also be considered pure functions, and accessing any properties is not checked for side effects.\n\ntreeshake.moduleSideEffects ​\n\nType:boolean| \"no-external\"| string[]| (id: string, external: boolean) => booleanCLI:--treeshake.moduleSideEffects/--no-treeshake.moduleSideEffects/--treeshake.moduleSideEffects no-externalDefault:true\n\nIf false, assume modules and external dependencies from which nothing is imported do not have other side effects like mutating global variables or logging without checking. For external dependencies, this will suppress empty imports:\n\nFor non-external modules, false will not include any statements from a module unless at least one import from this module is included:\n\nYou can also supply a list of modules with side effects or a function to determine it for each module individually. The value \"no-external\" will only remove external imports if possible and is equivalent to the function (id, external) => !external;\n\nIf a module that has this flag set to false reexports a variable from another module and this variable is used, the question if the reexporting module is scanned for side effects depends on how the variable is reexported:\n\nNote that despite the name, this option does not \"add\" side effects to modules that do not have side effects. If it is important that e.g. an empty module is \"included\" in the bundle because you need this for dependency tracking, the plugin interface allows you to designate modules as being excluded from tree-shaking via the resolveId, load or transform hook.\n\ntreeshake.preset ​\n\nType:\"smallest\" | \"safest\"| \"recommended\"CLI:--treeshake <value>\n\nAllows choosing one of the presets listed above while overriding some options.\n\ntreeshake.propertyReadSideEffects ​\n\nType:boolean| 'always'CLI:--treeshake.propertyReadSideEffects/--no-treeshake.propertyReadSideEffectsDefault:true\n\nIf true, retain unused property reads that Rollup can determine to have side effects. This includes accessing properties of null or undefined or triggering explicit getters via property access. Note that this does not cover destructuring assignment or getters on objects passed as function parameters.\n\nIf false, assume reading a property of an object never has side effects. Depending on your code, disabling this option can significantly reduce bundle size but can potentially break functionality if you rely on getters or errors from illegal property access.\n\nIf 'always', assume all member property accesses, including destructuring, have side effects. This setting is recommended for code relying on getters with side effects. It typically results in larger bundle size, but smaller than disabling treeshake altogether.\n\ntreeshake.tryCatchDeoptimization ​\n\nType:booleanCLI:--treeshake.tryCatchDeoptimization/--no-treeshake.tryCatchDeoptimizationDefault:true\n\nBy default, Rollup assumes that many builtin globals of the runtime behave according to the latest specs when tree-shaking and do not throw unexpected errors. In order to support e.g. feature detection workflows that rely on those errors being thrown, Rollup will by default deactivate tree-shaking inside try-statements. If a function parameter is called from within a try-statement, this parameter will be deoptimized as well. Set treeshake.tryCatchDeoptimization to false if you do not need this feature and want to have tree-shaking inside try-statements.\n\ntreeshake.unknownGlobalSideEffects ​\n\nType:booleanCLI:--treeshake.unknownGlobalSideEffects/--no-treeshake.unknownGlobalSideEffectsDefault:true\n\nSince accessing a non-existing global variable will throw an error, Rollup does by default retain any accesses to non-builtin global variables. Set this option to false to avoid this check. This is probably safe for most code-bases.\n\nIn the example, the last line is always retained as accessing the element property could also throw an error if angular is e.g. null. To avoid this check, set treeshake.propertyReadSideEffects to false as well.\n\nExperimental options ​\n\nThese options reflect new features that have not yet been fully finalized. Availability, behaviour and usage may therefore be subject to change between minor versions.\n\nexperimentalCacheExpiry ​\n\nType:numberCLI:--experimentalCacheExpiry <numberOfRuns>Default:10\n\nDetermines after how many runs cached assets that are no longer used by plugins should be removed.\n\nexperimentalLogSideEffects ​\n\nType:booleanCLI:--experimentalLogSideEffects/--no-experimentalLogSideEffectsDefault:false\n\nWhen set to true, this will log the first side effect it finds in every file to the console. This can be very helpful to figure which files have side effects and what the actual side effects are. Removing side effects can improve tree-shaking and chunk generation and is crucial to make output.experimentalMinChunkSize work.\n\nThis option will only log top-level statements, though. Sometimes, e.g. in case of immediately-invoked-function-expressions, the actual side effect can be hidden inside a nested expression.\n\noutput.experimentalMinChunkSize ​\n\nType:numberCLI:--experimentalMinChunkSize <size>Default:1\n\nSet a minimal chunk size target in Byte for code-splitting setups. When this value is set to the default of 1, Rollup will try to merge chunks that do not contain code except imports and reexports into other chunks. A merge will only be performed if it does not change what side effects are executed when any entry is loaded. For the value of 1, only merges are permitted that do no increase the amount of code loaded for any entry.\n\nLarger values will try to merge any chunk below the limit into other chunks. In that case, it is accepted that entries may load some unnecessary code. The algorithm always tries to merge in a way that minimizes the amount of unnecessary code, though.\n\nUnfortunately, due to the way chunking works, chunk size is measured before any chunk rendering plugins like minifiers ran, which means you should use a high enough limit to take this into account. When calculating the size, it will take tree-shaking of top-level statements into account, though.\n\nperf ​\n\nType:booleanCLI:--perf/--no-perfDefault:false\n\nWhether to collect performance timings. When used from the command line or a configuration file, detailed measurements about the current bundling process will be displayed. When used from the JavaScript API, the returned bundle object will contain an additional getTimings() function that can be called at any time to retrieve all accumulated measurements.\n\ngetTimings() returns an object of the following form:\n\nFor each key, the first number represents the elapsed time while the second represents the change in memory consumption, and the third represents the total memory consumption after this step. The order of these steps is the order used by Object.keys. Top level keys start with # and contain the timings of nested steps, i.e. in the example above, the 698ms of the # BUILD step include the 538ms of the ## parse modules step.\n\nwatch ​\n\nType:WatcherOptions | falseDefault:{}\n\nSpecify options for watch mode or prevent this configuration from being watched. Specifying false is only really useful when an array of configurations is used. In that case, this configuration will not be built or rebuilt on change in watch mode, but it will be built when running Rollup regularly:\n\nThese options only take effect when running Rollup with the --watch flag, or using rollup.watch.\n\nwatch.buildDelay ​\n\nType:numberCLI:--watch.buildDelay <number>Default:0\n\nConfigures how long Rollup will wait for further changes until it triggers a rebuild in milliseconds. By default, Rollup does not wait but there is a small debounce timeout configured in the chokidar instance. Setting this to a value greater than 0 will mean that Rollup will only trigger a rebuild if there was no change for the configured number of milliseconds. If several configurations are watched, Rollup will use the largest configured build delay.\n\nwatch.chokidar ​\n\nType:ChokidarOptions\n\nAn optional object of watch options that will be passed to the bundled chokidar instance. See the chokidar documentation to find out what options are available.\n\nwatch.clearScreen ​\n\nType:booleanCLI:--watch.clearScreen/--no-watch.clearScreenDefault:true\n\nWhether to clear the screen when a rebuild is triggered.\n\nwatch.exclude ​\n\nType:string | RegExp| (string| RegExp)[]CLI:--watch.exclude <files>\n\nPrevent files from being watched:\n\nwatch.include ​\n\nType:string | RegExp| (string| RegExp)[]CLI:--watch.include <files>\n\nLimit the file-watching to certain files. Note that this only filters the module graph but does not allow adding additional watch files:\n\nwatch.skipWrite ​\n\nType:booleanCLI:--watch.skipWrite/--no-watch.skipWriteDefault:false\n\nWhether to skip the bundle.write() step when a rebuild is triggered.\n\nDeprecated options ​\n\n☢️ These options have been deprecated and may be removed in a future Rollup version.\n\noutput.externalImportAssertions ​\n\nUse the output.externalImportAttributes option instead.\n\nType:booleanCLI:--externalImportAssertions/--no-externalImportAssertionsDefault:true"
    }
}