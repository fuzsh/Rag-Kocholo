{
    "id": "dbpedia_5465_3",
    "rank": 23,
    "data": {
        "url": "https://docs.docker.com/reference/cli/docker/buildx/build/",
        "read_more_link": "",
        "language": "en",
        "title": "docker buildx build",
        "top_image": "https://docs.docker.com/assets/images/thumbnail.webp",
        "meta_img": "https://docs.docker.com/assets/images/thumbnail.webp",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-04-10T10:24:40+02:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://docs.docker.com/favicons/docs@2x.ico",
        "meta_site_name": "Docker Documentation",
        "canonical_link": "https://docs.docker.com/reference/cli/docker/buildx/build/",
        "text": "DescriptionStart a buildUsagedocker buildx build [OPTIONS] PATH | URL | -Aliases\n\nAn alias is a short or memorable alternative for a longer command.\n\ndocker build docker builder build docker image build docker buildx b\n\nDescription\n\nThe docker buildx build command starts a build using BuildKit.\n\nOptions\n\nOptionDefaultDescription--add-hostAdd a custom host-to-IP mapping (format: host:ip)--allowAllow extra privileged entitlement (e.g., network.host, security.insecure)\n\n--annotationAdd annotation to the image--attestAttestation parameters (format: type=sbom,generator=image)--build-argSet build-time variables--build-contextAdditional build contexts (e.g., name=path)--cache-fromExternal cache sources (e.g., user/app:cache, type=local,src=path/to/dir)\n\n--cache-toCache export destinations (e.g., user/app:cache, type=local,dest=path/to/dir)\n\n--callbuildSet method for evaluating build (check, outline, targets)--cgroup-parentSet the parent cgroup for the RUN instructions during build--checkShorthand for --call=check--detachexperimental (CLI) Detach buildx server (supported only on linux)-f, --fileName of the Dockerfile (default: PATH/Dockerfile)--iidfileWrite the image ID to a file--labelSet metadata for an image--loadShorthand for --output=type=docker--metadata-fileWrite build result metadata to a file--networkSet the networking mode for the RUN instructions during build--no-cacheDo not use cache when building the image--no-cache-filterDo not cache specified stages-o, --outputOutput destination (format: type=local,dest=path)--platformSet target platform for build--progressautoSet type of progress output (auto, plain, tty, rawjson). Use plain to show container output\n\n--provenanceShorthand for --attest=type=provenance--pullAlways attempt to pull all referenced images--pushShorthand for --output=type=registry-q, --quietSuppress the build output and print image ID on success--rootexperimental (CLI) Specify root directory of server to connect--sbomShorthand for --attest=type=sbom--secretSecret to expose to the build (format: id=mysecret[,src=/local/secret])\n\n--server-configexperimental (CLI) Specify buildx server config file (used only when launching new server)\n\n--shm-sizeShared memory size for build containers--sshSSH agent socket or keys to expose to the build (format: default|<id>[=<socket>|<key>[,<key>]])\n\n-t, --tagName and optionally a tag (format: name:tag)--targetSet the target build stage to build--ulimitUlimit options\n\nExamples\n\nAdd entries to container hosts file (--add-host)\n\nYou can add other hosts into a build container's /etc/hosts file by using one or more --add-host flags. This example adds static addresses for hosts named my-hostname and my_hostname_v6:\n\nIf you need your build to connect to services running on the host, you can use the special host-gateway value for --add-host. In the following example, build containers resolve host.docker.internal to the host's gateway IP.\n\nYou can wrap an IPv6 address in square brackets. = and : are both valid separators. Both formats in the following example are valid:\n\nCreate annotations (--annotation)\n\nAdd OCI annotations to the image index, manifest, or descriptor. The following example adds the foo=bar annotation to the image manifests:\n\nYou can optionally add a type prefix to specify the level of the annotation. By default, the image manifest is annotated. The following example adds the foo=bar annotation the image index instead of the manifests:\n\nYou can specify multiple types, separated by a comma (,) to add the annotation to multiple image components. The following example adds the foo=bar annotation to image index, descriptors, manifests:\n\nYou can also specify a platform qualifier in square brackets ([os/arch]) in the type prefix, to apply the annotation to a subset of manifests with the matching platform. The following example adds the foo=bar annotation only to the manifest with the linux/amd64 platform:\n\nWildcards are not supported in the platform qualifier; you can't specify a type prefix like manifest[linux/*] to add annotations only to manifests which has linux as the OS platform.\n\nFor more information about annotations, see Annotations.\n\nCreate attestations (--attest)\n\nCreate image attestations. BuildKit currently supports:\n\nsbom - Software Bill of Materials.\n\nUse --attest=type=sbom to generate an SBOM for an image at build-time. Alternatively, you can use the --sbom shorthand.\n\nFor more information, see here.\n\nprovenance - SLSA Provenance\n\nUse --attest=type=provenance to generate provenance for an image at build-time. Alternatively, you can use the --provenance shorthand.\n\nBy default, a minimal provenance attestation will be created for the build result, which will only be attached for images pushed to registries.\n\nFor more information, see here.\n\nAllow extra privileged entitlement (--allow)\n\nAllow extra privileged entitlement. List of entitlements:\n\nnetwork.host - Allows executions with host networking.\n\nsecurity.insecure - Allows executions without sandbox. See related Dockerfile extensions.\n\nFor entitlements to be enabled, the BuildKit daemon also needs to allow them with --allow-insecure-entitlement (see create --buildkitd-flags).\n\nSet build-time variables (--build-arg)\n\nYou can use ENV instructions in a Dockerfile to define variable values. These values persist in the built image. Often persistence isn't what you want. Users want to specify variables differently depending on which host they build an image on.\n\nA good example is http_proxy or source versions for pulling intermediate files. The ARG instruction lets Dockerfile authors define values that users can set at build-time using the --build-arg flag:\n\nThis flag allows you to pass the build-time variables that are accessed like regular environment variables in the RUN instruction of the Dockerfile. These values don't persist in the intermediate or final images like ENV values do. You must add --build-arg for each build argument.\n\nUsing this flag doesn't alter the output you see when the build process echoes theARG lines from the Dockerfile.\n\nFor detailed information on using ARG and ENV instructions, see the Dockerfile reference.\n\nYou can also use the --build-arg flag without a value, in which case the daemon propagates the value from the local environment into the Docker container it's building:\n\nThis example is similar to how docker run -e works. Refer to the docker run documentation for more information.\n\nThere are also useful built-in build arguments, such as:\n\nBUILDKIT_CONTEXT_KEEP_GIT_DIR=<bool>: trigger git context to keep the .git directory\n\nBUILDKIT_INLINE_CACHE=<bool>: inline cache metadata to image config or not\n\nBUILDKIT_MULTI_PLATFORM=<bool>: opt into deterministic output regardless of multi-platform output or not\n\nLearn more about the built-in build arguments in the Dockerfile reference docs.\n\nAdditional build contexts (--build-context)\n\nDefine additional build context with specified contents. In Dockerfile the context can be accessed when FROM name or --from=name is used. When Dockerfile defines a stage with the same name it is overwritten.\n\nThe value can be a local source directory, local OCI layout compliant directory, container image (with docker-image:// prefix), Git or HTTP URL.\n\nReplace alpine:latest with a pinned one:\n\nExpose a secondary local source directory:\n\nUse an OCI layout directory as build context\n\nSource an image from a local OCI layout compliant directory, either by tag, or by digest:\n\nThe OCI layout directory must be compliant with the OCI layout specification. You can reference an image in the layout using either tags, or the exact digest.\n\nOverride the configured builder instance (--builder)\n\nSame as buildx --builder.\n\nUse an external cache source for a build (--cache-from)\n\nUse an external cache source for a build. Supported types are registry, local, gha and s3.\n\nregistry source can import cache from a cache manifest or (special) image configuration on the registry.\n\nlocal source can import cache from local files previously exported with --cache-to.\n\ngha source can import cache from a previously exported cache with --cache-to in your GitHub repository\n\ns3 source can import cache from a previously exported cache with --cache-to in your S3 bucket\n\nIf no type is specified, registry exporter is used with a specified reference.\n\ndocker driver currently only supports importing build cache from the registry.\n\nMore info about cache exporters and available attributes: https://github.com/moby/buildkit#export-cache\n\nInvoke a frontend method (--call)\n\nBuildKit frontends can support alternative modes of executions for builds, using frontend methods. Frontend methods are a way to change or extend the behavior of a build invocation, which lets you, for example, inspect, validate, or generate alternative outputs from a build.\n\nThe --call flag for docker buildx build lets you specify the frontend method that you want to execute. If this flag is unspecified, it defaults to executing the build and evaluating build checks.\n\nFor Dockerfiles, the available methods are:\n\nCommandDescriptionbuild (default)Execute the build and evaluate build checks for the current build target.checkEvaluate build checks for the either the entire Dockerfile or the selected target, without executing a build.outlineShow the build arguments that you can set for a target, and their default values.targetsList all the build targets in the Dockerfile.subrequests.describeList all the frontend methods that the current frontend supports.\n\nNote that other frontends may implement these or other methods. To see the list of available methods for the frontend you're using, use --call=subrequests.describe.\n\nDescriptions\n\nThe --call=targets and --call=outline methods include descriptions for build targets and arguments, if available. Descriptions are generated from comments in the Dockerfile. A comment on the line before a FROM instruction becomes the description of a build target, and a comment before an ARG instruction the description of a build argument. The comment must lead with the name of the stage or argument, for example:\n\nWhen you run docker buildx build --call=outline, the output includes the descriptions, as follows:\n\nFor more examples on how to write Dockerfile docstrings, check out the Dockerfile for Docker docs.\n\nCall: check (--check)\n\nThe check method evaluates build checks without executing the build. The --check flag is a convenient shorthand for --call=check. Use the check method to validate the build configuration before starting the build.\n\nUsing --check without specifying a target evaluates the entire Dockerfile. If you want to evaluate a specific target, use the --target flag.\n\nCall: outline\n\nThe outline method prints the name of the specified target (or the default target, if --target isn't specified), and the build arguments that the target consumes, along with their default values, if set.\n\nThe following example shows the default target release and its build arguments:\n\nThis means that the release target is configurable using these build arguments:\n\nCall: targets\n\nThe targets method lists all the build targets in the Dockerfile. These are the stages that you can build using the --target flag. It also indicates the default target, which is the target that will be built when you don't specify a target.\n\nExport build cache to an external cache destination (--cache-to)\n\nExport build cache to an external cache destination. Supported types are registry, local, inline, gha and s3.\n\nregistry type exports build cache to a cache manifest in the registry.\n\nlocal type exports cache to a local directory on the client.\n\ninline type writes the cache metadata into the image configuration.\n\ngha type exports cache through the GitHub Actions Cache service API.\n\ns3 type exports cache to a S3 bucket.\n\nThe docker driver only supports cache exports using the inline and local cache backends.\n\nAttribute key:\n\nmode - Specifies how many layers are exported with the cache. min on only exports layers already in the final build stage, max exports layers for all stages. Metadata is always exported for the whole build.\n\nMore info about cache exporters and available attributes: https://github.com/moby/buildkit#export-cache\n\nUse a custom parent cgroup (--cgroup-parent)\n\nWhen you run docker buildx build with the --cgroup-parent option, the daemon runs the containers used in the build with the corresponding docker run flag.\n\nSpecify a Dockerfile (-f, --file)\n\nSpecifies the filepath of the Dockerfile to use. If unspecified, a file named Dockerfile at the root of the build context is used by default.\n\nTo read a Dockerfile from stdin, you can use - as the argument for --file.\n\nLoad the single-platform build result to docker images (--load)\n\nShorthand for --output=type=docker. Will automatically load the single-platform build result to docker images.\n\nWrite build result metadata to a file (--metadata-file)\n\nTo output build metadata such as the image digest, pass the --metadata-file flag. The metadata will be written as a JSON object to the specified file. The directory of the specified file must already exist and be writable.\n\nNote\n\nBuild record provenance (buildx.build.provenance) includes minimal provenance by default. Set the BUILDX_METADATA_PROVENANCE environment variable to customize this behavior:\n\nmin sets minimal provenance (default).\n\nmax sets full provenance.\n\ndisabled, false or 0 doesn't set any provenance.\n\nSet the networking mode for the RUN instructions during build (--network)\n\nAvailable options for the networking mode are:\n\ndefault (default): Run in the default network.\n\nnone: Run with no network access.\n\nhost: Run in the hostâs network environment.\n\nFind more details in the Dockerfile reference.\n\nNote\n\nBuild warnings (buildx.build.warnings) are not included by default. Set the BUILDX_METADATA_WARNINGS environment variable to 1 or true to include them.\n\nIgnore build cache for specific stages (--no-cache-filter)\n\nThe --no-cache-filter lets you specify one or more stages of a multi-stage Dockerfile for which build cache should be ignored. To specify multiple stages, use a comma-separated syntax:\n\nFor example, the following Dockerfile contains four stages:\n\nbase\n\ninstall\n\ntest\n\nrelease\n\nTo ignore the cache for the install stage:\n\nTo ignore the cache the install and release stages:\n\nThe arguments for the --no-cache-filter flag must be names of stages.\n\nSet the export action for the build result (-o, --output)\n\nSets the export action for the build result. The default output, when using the docker build driver, is a container image exported to the local image store. The --output flag makes this step configurable allows export of results directly to the client's filesystem, an OCI image tarball, a registry, and more.\n\nBuildx with docker driver only supports the local, tarball, and image exporters. The docker-container driver supports all exporters.\n\nIf you only specify a filepath as the argument to --output, Buildx uses the local exporter. If the value is -, Buildx uses the tar exporter and writes the output to stdout.\n\nYou can export multiple outputs by repeating the flag.\n\nSupported exported types are:\n\nlocal\n\ntar\n\noci\n\ndocker\n\nimage\n\nregistry\n\nlocal\n\nThe local export type writes all result files to a directory on the client. The new files will be owned by the current user. On multi-platform builds, all results will be put in subdirectories by their platform.\n\nAttribute key:\n\ndest - destination directory where files will be written\n\nFor more information, see Local and tar exporters.\n\ntar\n\nThe tar export type writes all result files as a single tarball on the client. On multi-platform builds all results will be put in subdirectories by their platform.\n\nAttribute key:\n\ndest - destination path where tarball will be written. â-â writes to stdout.\n\nFor more information, see Local and tar exporters.\n\noci\n\nThe oci export type writes the result image or manifest list as an OCI image layout tarball on the client.\n\nAttribute key:\n\ndest - destination path where tarball will be written. â-â writes to stdout.\n\nFor more information, see OCI and Docker exporters.\n\ndocker\n\nThe docker export type writes the single-platform result image as a Docker image specification tarball on the client. Tarballs created by this exporter are also OCI compatible.\n\nThe default image store in Docker Engine doesn't support loading multi-platform images. You can enable the containerd image store, or push multi-platform images is to directly push to a registry, see registry.\n\nAttribute keys:\n\ndest - destination path where tarball will be written. If not specified, the tar will be loaded automatically to the local image store.\n\ncontext - name for the Docker context where to import the result\n\nFor more information, see OCI and Docker exporters.\n\nimage\n\nThe image exporter writes the build result as an image or a manifest list. When using docker driver the image will appear in docker images. Optionally, image can be automatically pushed to a registry by specifying attributes.\n\nAttribute keys:\n\nname - name (references) for the new image.\n\npush - Boolean to automatically push the image.\n\nFor more information, see Image and registry exporters.\n\nregistry\n\nThe registry exporter is a shortcut for type=image,push=true.\n\nFor more information, see Image and registry exporters.\n\nSet the target platforms for the build (--platform)\n\nSet the target platform for the build. All FROM commands inside the Dockerfile without their own --platform flag will pull base images for this platform and this value will also be the platform of the resulting image.\n\nThe default value is the platform of the BuildKit daemon where the build runs. The value takes the form of os/arch or os/arch/variant. For example, linux/amd64 or linux/arm/v7. Additionally, the --platform flag also supports a special local value, which tells BuildKit to use the platform of the BuildKit client that invokes the build.\n\nWhen using docker-container driver with buildx, this flag can accept multiple values as an input separated by a comma. With multiple values the result will be built for all of the specified platforms and joined together into a single manifest list.\n\nIf the Dockerfile needs to invoke the RUN command, the builder needs runtime support for the specified platform. In a clean setup, you can only execute RUN commands for your system architecture. If your kernel supports binfmt_misc launchers for secondary architectures, buildx will pick them up automatically. Docker Desktop releases come with binfmt_misc automatically configured for arm64 and arm architectures. You can see what runtime platforms your current builder instance supports by running docker buildx inspect --bootstrap.\n\nInside a Dockerfile, you can access the current platform value through TARGETPLATFORM build argument. Refer to the Dockerfile reference for the full description of automatic platform argument variants .\n\nYou can find the formatting definition for the platform specifier in the containerd source code.\n\nSet type of progress output (--progress)\n\nSet type of progress output (auto, plain, tty, rawjson). Use plain to show container output (default auto).\n\nNote\n\nYou can also use the BUILDKIT_PROGRESS environment variable to set its value.\n\nThe following example uses plain output during the build:\n\nNote\n\nCheck also the BUILDKIT_COLORS environment variable for modifying the colors of the terminal output.\n\nThe rawjson output marshals the solve status events from BuildKit to JSON lines. This mode is designed to be read by an external program.\n\nCreate provenance attestations (--provenance)\n\nShorthand for --attest=type=provenance, used to configure provenance attestations for the build result. For example, --provenance=mode=max can be used as an abbreviation for --attest=type=provenance,mode=max.\n\nAdditionally, --provenance can be used with Boolean values to enable or disable provenance attestations. For example, --provenance=false disables all provenance attestations, while --provenance=true enables all provenance attestations.\n\nBy default, a minimal provenance attestation will be created for the build result. Note that the default image store in Docker Engine doesn't support attestations. Provenance attestations only persist for images pushed directly to a registry if you use the default image store. Alternatively, you can switch to using the containerd image store.\n\nFor more information about provenance attestations, see here.\n\nPush the build result to a registry (--push)\n\nShorthand for --output=type=registry. Will automatically push the build result to registry.\n\nCreate SBOM attestations (--sbom)\n\nShorthand for --attest=type=sbom, used to configure SBOM attestations for the build result. For example, --sbom=generator=<user>/<generator-image> can be used as an abbreviation for --attest=type=sbom,generator=<user>/<generator-image>.\n\nAdditionally, --sbom can be used with Boolean values to enable or disable SBOM attestations. For example, --sbom=false disables all SBOM attestations.\n\nNote that the default image store in Docker Engine doesn't support attestations. Provenance attestations only persist for images pushed directly to a registry if you use the default image store. Alternatively, you can switch to using the containerd image store.\n\nFor more information, see here.\n\nSecret to expose to the build (--secret)\n\nExposes secrets (authentication credentials, tokens) to the build. A secret can be mounted into the build using a RUN --mount=type=secret mount in the Dockerfile. For more information about how to use build secrets, see Build secrets.\n\nSupported types are:\n\nfile\n\nenv\n\nBuildx attempts to detect the type automatically if unset.\n\nfile\n\nAttribute keys:\n\nid - ID of the secret. Defaults to base name of the src path.\n\nsrc, source - Secret filename. id used if unset.\n\nenv\n\nAttribute keys:\n\nid - ID of the secret. Defaults to env name.\n\nenv - Secret environment variable. id used if unset, otherwise will look for src, source if id unset.\n\nShared memory size for build containers (--shm-size)\n\nSets the size of the shared memory allocated for build containers when using RUN instructions.\n\nThe format is <number><unit>. number must be greater than 0. Unit is optional and can be b (bytes), k (kilobytes), m (megabytes), or g (gigabytes). If you omit the unit, the system uses bytes.\n\nNote\n\nIn most cases, it is recommended to let the builder automatically determine the appropriate configurations. Manual adjustments should only be considered when specific performance tuning is required for complex build scenarios.\n\nSSH agent socket or keys to expose to the build (--ssh)\n\nThis can be useful when some commands in your Dockerfile need specific SSH authentication (e.g., cloning a private repository).\n\n--ssh exposes SSH agent socket or keys to the build and can be used with the RUN --mount=type=ssh mount.\n\nExample to access Gitlab using an SSH agent socket:\n\nTag an image (-t, --tag)\n\nThis examples builds in the same way as the previous example, but it then tags the resulting image. The repository name will be docker/apache and the tag 2.0.\n\nRead more about valid tags.\n\nYou can apply multiple tags to an image. For example, you can apply the latest tag to a newly built image and add another tag that references a specific version.\n\nFor example, to tag an image both as docker/fedora-jboss:latest and docker/fedora-jboss:v2.1, use the following:\n\nSpecifying target build stage (--target)\n\nWhen building a Dockerfile with multiple build stages, use the --target option to specify an intermediate build stage by name as a final stage for the resulting image. The builder skips commands after the target stage.\n\nSet ulimits (--ulimit)\n\n--ulimit overrides the default ulimits of build's containers when using RUN instructions and are specified with a soft and hard limit as such: <type>=<soft limit>[:<hard limit>], for example:\n\nNote\n\nIf you don't provide a hard limit, the soft limit is used for both values. If no ulimits are set, they're inherited from the default ulimits set on the daemon."
    }
}