{
    "id": "wrong_mix_domain_subsidiary_00061_3",
    "rank": 25,
    "data": {
        "url": "https://dev.to/mjoycemilburn/24-a-very-gentle-introduction-to-sveltekit-for-google-cloud-developers-5cfj",
        "read_more_link": "",
        "language": "en",
        "title": "2.4 A gentle introduction to SvelteKit for Google Cloud developers",
        "top_image": "https://media.dev.to/cdn-cgi/image/width=1000,height=500,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsnugmzox7m73yt2qvwjy.jpg",
        "meta_img": "https://media.dev.to/cdn-cgi/image/width=1000,height=500,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsnugmzox7m73yt2qvwjy.jpg",
        "images": [
            "https://media.dev.to/cdn-cgi/image/quality=100/https://dev-to-uploads.s3.amazonaws.com/uploads/logos/resized_logo_UQww2soKuUsjaOGNB38o.png",
            "https://dev.to/assets/heart-plus-active-9ea3b22f2bc311281db911d416166c5f430636e76b15cd5df6b3b841d830eefa.svg",
            "https://dev.to/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://dev.to/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://dev.to/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://dev.to/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://dev.to/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg",
            "https://media.dev.to/cdn-cgi/image/width=1000,height=420,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2Fsnugmzox7m73yt2qvwjy.jpg",
            "https://media.dev.to/cdn-cgi/image/width=50,height=50,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F609115%2F3547878e-28f8-4489-8bb6-df1b1f7d4d97.png",
            "https://media.dev.to/cdn-cgi/image/width=256,height=,fit=scale-down,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F8j7kvp660rqzt99zui8e.png",
            "https://media.dev.to/cdn-cgi/image/width=50,height=50,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F150821%2F75e6e1cd-7d12-4a70-9ece-de03f308349b.JPG",
            "https://media.dev.to/cdn-cgi/image/width=90,height=90,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F150821%2F75e6e1cd-7d12-4a70-9ece-de03f308349b.JPG",
            "https://media.dev.to/cdn-cgi/image/width=50,height=50,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F609115%2F3547878e-28f8-4489-8bb6-df1b1f7d4d97.png",
            "https://media.dev.to/cdn-cgi/image/width=90,height=90,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F609115%2F3547878e-28f8-4489-8bb6-df1b1f7d4d97.png",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F112350%2Fc04f543a-ec65-4027-acee-48794c9f4099.png",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F1502513%2Ff3eaf989-e7b9-4461-9d3e-998bd750ce0d.jpeg",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F1502513%2Ff3eaf989-e7b9-4461-9d3e-998bd750ce0d.jpeg",
            "https://media.dev.to/cdn-cgi/image/width=100,height=100,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F1502513%2Ff3eaf989-e7b9-4461-9d3e-998bd750ce0d.jpeg",
            "https://media.dev.to/cdn-cgi/image/width=90,height=90,fit=cover,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Fuser%2Fprofile_image%2F609115%2F3547878e-28f8-4489-8bb6-df1b1f7d4d97.png",
            "https://media.dev.to/cdn-cgi/image/width=190,height=,fit=scale-down,gravity=auto,format=auto/https%3A%2F%2Fdev-to-uploads.s3.amazonaws.com%2Fuploads%2Farticles%2F8j7kvp660rqzt99zui8e.png",
            "https://dev.to/assets/sparkle-heart-5f9bee3767e18deb1bb725290cb151c25234768a0e9a2bd39370c382d02920cf.svg",
            "https://dev.to/assets/multi-unicorn-b44d6f8c23cdd00964192bedc38af3e82463978aa611b4365bd33a0f1f4f3e97.svg",
            "https://dev.to/assets/exploding-head-daceb38d627e6ae9b730f36a1e390fca556a4289d5a41abb2c35068ad3e2c4b5.svg",
            "https://dev.to/assets/raised-hands-74b2099fd66a39f2d7eed9305ee0f4553df0eb7b4f11b01b6b1b499973048fe5.svg",
            "https://dev.to/assets/fire-f60e7a582391810302117f987b22a8ef04a2fe0df7e3258a5f49332df1cec71e.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "sveltekit",
            "javascript",
            "googlecloud",
            "beginners",
            "software",
            "coding",
            "development",
            "engineering",
            "inclusive",
            "community"
        ],
        "tags": null,
        "authors": [
            "MartinJ"
        ],
        "publish_date": "2024-07-16T10:23:16+00:00",
        "summary": "",
        "meta_description": "Introduction   An earlier post in this series (A very gentle introduction to React)... Tagged with sveltekit, javascript, googlecloud, beginners.",
        "meta_lang": "en",
        "meta_favicon": "https://res.cloudinary.com/practicaldev/image/fetch/s--E8ak4Hr1--/c_limit,f_auto,fl_progressive,q_auto,w_32/https://dev-to.s3.us-east-2.amazonaws.com/favicon.ico",
        "meta_site_name": "DEV Community",
        "canonical_link": "https://dev.to/mjoycemilburn/24-a-very-gentle-introduction-to-sveltekit-for-google-cloud-developers-5cfj",
        "text": "Introduction\n\nAn earlier post in this series (A very gentle introduction to React) introduced readers to the excellent React framework system for developing webapps. SvelteKit is an alternative framework. How does it differ from React and is it any better?\n\nFunctionally, I guess there's not that much difference. Most things you can do in React you can do in SvelteKit. And vice-versa. But when you get down to the details, many people feel that SvelteKit has the edge in terms of the ease with which you achieve your \"reactive\" goals. Svelte means \"elegant\" - and that's just what it is - a slender, highly adaptable and practical tool.\n\nPersonally, I was attracted to SvelteKit because it also tends to push you towards server-side design - ie code that runs on your webapp's Cloud servers rather than in your user's web browser. This is ironic because it was the ease with which you could write and debug client-side code that originally got me hooked on webapp development. But then I discovered how reluctant indexing spiders are to invest effort in \"hydrating\" client-side code and realised I would just have to put more effort in here (see 'Debugging in SvelteKit', below, to get a handle on how you debug server-side code). But there are other reasons why you might consider using server-side code too. Here are a couple:\n\nOnce you start using third-party services such as Postmark (email despatch) or Paypal (payment collection), you'll realise that it's not a good idea to include their security codes in client-side code. If you can use the \"inspector\" to view these, so can anyone else. Code that runs server-side is inaccessible.\n\nserver-side code lives closer to your data and runs faster here than on a client laptop.\n\nSvelteKit makes it easy to play tunes on specifying which bits of your webapp are to run locally and which are to run remotely.\n\nIn some cases, pages may be entirely server-side rendered - if they contain only static information, Sveltekit will enable you to \"pre-render\" them. Pre-rendered pages are constructed at build time and downloaded as slabs of pure HTML.\n\nAlternatively, they may be entirely client-side rendered.\n\nOr yet again, they may run on both. A SvelteKit webapp aiming to deliver optimal response times may initially display just a server-sourced \"placeholder\" screen to get something, anything, visible (you get great credit with Google's indexing bots here, apparently). This is then \"hydrated\" by client-side code with information specific to the user-instance.\n\nLet's get down to something a bit more concrete.\n\nRouting in Svelte\n\nExternally, a Sveltekit webapp will look exactly like any classic browser application - a hierarchy of \"pages\" such as mywebapp/dosomethingwithmyfiles. It's like this because client users expect, and rely on this type of arrangement. But below the surface, a SvelteKit webapp delivers this arrangement in a totally different way to a React webapp. In React these pages are actually all parts of one giant slab of code and requests are routed thither by re-directs operating at the web interface (if that sentence doesn't make any sense to you, have a look at Whats a 'Single-page' webapp?). SvelteKit achieves this by using your project structure to define your page structure. So, if you want to have a mywebapp/dosomethingwithmyfiles page, you need to have a folder named dosomethingwithmyfiles with a +page.svelte file inside it. Once this arrangement is in place, your deployed app delivers a separate physical page for each of its URLs.\n\nHere's a sample source folder structure for a SvelteKit project:\n\nmyproject\n\n├───src\n\n│ └───routes\n\n│ └───dosomethingwithmyfiles\n\nOnce you've installed SvelteKit (see Svelte for New Developers), this structure will be augmented by a mass of complicated config files and build folders etc. But, for the present, the focus is on the routes folder. This is where you store your page code - and here is where you might start to wonder whether SvelteKit is the right thing for you. Take a tight grip now because this is where things get a bit complicated.\n\nSvelteKit requires you to follow a very strict naming convention for the content of a page folder. Here's a list of the filenames that might see in a dosomethingwithmyfiles folder:\n\ndosomethingwithmyfiles/+page.svelte. This file would contain the source for the code that displays the page for URL myproject/dosomethingwithmyfileson the browser screen. Whoah - let that sink in for a moment. When you're working in your VSCode editor on a SvelteKit project with half a dozen different pages, your filebar may display half a dozen tabs all named +page.svelte. Confusing? Yes, I agree.\n\nAt first sight, you might feel that this is simply unacceptable. But note that each +page.svelte file is qualified on the editor bar by the name of its folder owner, dosomethingwithmyfiles, or whatever. It's not so difficult to discipline yourself to check for the owner of a +page.svelte before you dive in and start editing. And once you've developed a SvelteKit project or two you'll begin to appreciate the value of the convention in declaring the purpose of the arrangement (as you'll see in a moment there are quite a few variations)\n\nWhile you're absorbing this shock, let me give you a bit of encouragement. Within a +page.svelte file you might expect to find the same sort of code you'd see in an equivalent React file - a mixture of exotic useState calls to manipulate page state, and JSX to 'react' to this and generate HTML. While a +page.svelte file certainly does the same job, it manages to discard the \"exotic\" bit and uses plain javascript and pure, undiluted HTMl salted with a sprinkling of special keywords. You may find this refreshing.\n\nHere are a few more standard filenames you might find in a dosomethingwithmyfiles folder:\n\ndosomethingwithmyfiles/+page.js, This would contain the source for a file that delivers data to a +page.svelte file (ie, the equivalent of a React useEffect). Code here will run on the server when the page is initially loaded. Subsequently, if the page is re-referenced, the +page.js code runs in the browser with the advantages listed earlier. Interestingly, if you've suffered in the past from having to \"re-program\" your javascript brain whenever you switch between writing Web API code to run in the browser and Node.js style to run server-side in a Firebase function you'll be delighted to hear that, in Sveltekit, the Web API version is now perfectly happy to run server-side as well. Naturally, you'll want to know just how you organise things so that data read by a +page.js file ends up in the associated +page.svelte. Let me say that, for the present, this arrives by SvelteKit magic. The exact mechanism will only become clear once I've described SvelteKit's arrangements for defining \"reactive\" variables. Hang onto your hat for now.\n\ndosomethingwithmyfiles/+page.server.js. This is where you would place code that you want to run only on the server (typically for security or performance reasons). As mentioned earlier, you can request that this is pre-rendered and thus constructed at build-time. In this case, performance is simply startling.\n\ndosomethingwithmyfiles/+layout.svelte. This is where you would place code that sets up those bits of a page common to a whole set of other pages - toolbar headers, for example. A +layout.svelte file applies to every child route and any sibling +page.svelte. You can nest layouts to arbitrary depth. Again, the precise arrangement for inserting the common layout into the recipient pages will be left for later - more Svelte magic. If a +layout.svelte page needs some data, it can have an attendant +layout.server.js file\n\ndosomethingwithmyfiles/+server.js. This is where you would place code that you wanted to be available as an \"API endpoint\" via a parameterised URL such as myProject/dosomethingwithmyfiles?type=\"pdf\". I'll provide more details on this arrangement later.\n\n'Reactive variables' and 'Reactive HTML' in SvelteKit\n\nBy 'reactive variables' I mean data items that cause the browser page to re-render when they change. By 'reactive HTML' I mean HTML instrumented to make it respond to these changes.\n\nIn React, you'll recall, reactive variables are declared using a useState expression that defines the variables as properties of a state object. The declaration also specifies initial property values and a function to change them.\n\nHere's an example - a React webapp that displays a popup that disappears when you click it:\n\nIn Svelte (I'm now talking about the language as opposed to the framework in which it operates) you might achieve this effect in a src/routes/demo/+page.svelte file by simply declaring popupVisible as a javascript variable\n\nHere's a summary of the key differences:\n\nSvelte uses a standard Javascript let declaration to introduce state variables instead of the strange React useState expression\n\nSvelte uses a down to earth #if 'logical expression' keyword to replace the awkward JSX {'logical expression' &&syntax. This makes your code much more readable. Svelte also provides associated else and each keywords.\n\nSvelte uses plain CSS to define HTML classes rather than the perplexing JSX style objects (eg {{textAlign: \"center\"}}).\n\nNote also that the demo/+pagesvelte file defined above will run directly in the browser as /demo. To run the React version you would have to put some code into an associated src/main.jsx file to define the new route.\n\nInputs: Local Functions, Actions and API endpoints\n\nKeyboard input in React generally uses the following pattern:\n\nHere, an input labelled as \"myProperty\" fires a general-purpose handleChange function every time you press a key. In handleChange its value is extracted and applied to the page's state to trigger a re-render.\n\nSvelte thinks this is too complicated and introduces a \"bind\" keyword to its input syntax. This automatically transmits changes to an associated state variable. A Svelte version of the above thus looks like this:\n\nThe bind keyword is also used to enable you to create two-way communication between parent and child components. This is a powerful feature.\n\nAn interesting feature of Svelte is that it encourages you to use forms and server-side processing for input handling. Thus it's perfectly permissible in Svelte to launch a client-side function like this:\n\nSvelte docs correctly insist that interactions like this are better handled by forms and server-side processing in a +page.server.js file. Here the validation and submission of the user input can be safely protected from the sort of interference possible in client-based code. Here also, any subsequent processing can be performed with maximum efficiency.\n\nTo implement this view, Svelte provide a neat automatic link between a form reading data on a +page.svelte and a function handling the processing of that data in the associated +page.server.js file. Here's an example:\n\nNote that no Javascript has been used in the form - no \"on click\" or \"on submit\", for example. The linkage has been established entirely through \"Svelte magic\".\n\nIn practice, of course, a +page.svelte file is likely to want to be the source of multiple \"actions\". See Svelte Form Actions for details of how Svelte manages this. (Note that Svelte docs are organised under two URLs: kit.svelte.dev for framework topics like routing and svelte.dev for elements of the language itself)\n\nFinally, to conclude this section, suppose you wanted users to be able to call on the service of an action by referencing it directly through a javascript \"fetch\" (or, at its simplest by launching a parameterised url via the browser - eg https:// mySite/myPage?param1=3 etc). This is where you would use a +server.js file to create an API \"endpoint\" function. Firebase users might well use such an arrangement where they had previously used a Firebase function. Not the least advantage of this would be that testing and debugging could be done in the Sveltekit server rather than the Firebase emulator.\n\nComponents\n\n1-way bindings\n\nEach +page.svelte file defines a component, and you mark variables declared here as \"props\" - ie make them accessible to \"consumers\" of the component - by adding the export keyword to their declarations. So, if you're still wondering how a +page.svelte file gets its data from +page.server.js - this is how it's done. A +page.svelte file wanting to receive \"load\" data from its +page.server.js (or +page.js) file just needs to put something like the following in its <script> section:\n\nSvelte magic will then ensure that if the 'load' function exported by the +page.server.js file returns an object such as {name: \"Benny\", } then +page.svelte will find that data.name contains \"Benny\".\n\nBut suppose that the +page.svelte file wanted to reference its own child component. How would that child be configured and linked to its parent?\n\nLet's say that this child component needs parameters param1 and param2 to build its output. It's usually most convenient to store the component in a src/lib folder - say src/lib/MyComponent.svelte - and its content might then look something like:\n\nThe parent +page.svelte could then engage the component like this:\n\nThis arrangement will be perfectly familiar if you've previously used React. Also, as with React, once the child component has received a parameter passed in this way, it's free to modify it at will - the parent will be oblivious of the change. This arrangement is known as a one-way binding\n\nNote the \"$\" shortcut used in the child component import declaration. Svelte works out the actual route automatically, saving you working out all the conventional \"./\" and \"//\" designators.\n\n2-way bindings\n\nSuppose the child component creates a form designed to serve both Create and Edit parents. In this case, it needs to be able to receive parameters supplying initial values for form elements and return the user inputs. Data is thus required to pass both down and up the component hierarchy.\n\nIn React you might have used a Context here. Svelte provides several alternatives, each with different characteristics, but the simplest is a bind: keyword applied to the parameter references in the parent's component call.\n\nLet's say we've created the following shared input layout in a lib/MySharedInputPanel.svelte file:\n\nThis creates a default export for a MySharedInputPanel component that a routes/editrecord/+page.svelte file can import and use to build an edit 'form' for the named, exported inputs as follows:\n\nIf you try this out yourself, you'll see that the shared panel initially displays the input1 and input2 values specified in the edit record route and that the parent editrecord/+page.svelte view of these changes when new values are entered. This confirms that the route is automatically rerendering when changes occur.\n\nA routes/createrecord/+page.svelte could use the same form component to collect inputs and create a record.\n\nNote that, for brevity, I've used neither the <form> nor <label> elements that good practices would require. My code also assumes that the parents and child use the same variable names. See Svelte's \"component directive\" docs for a more general version of the bind: syntax.\n\nSvelte store\n\nSometimes you'll find that you need a global state object to serve components that are not hierarchically related. Svelte store is designed to meet this need - and much more besides. A store, particularly a writable store (several variants exist), is an object with a set() method that allows you to set new values for its content.\n\nWhy is this any different from good old Chrome localStorage? Potential readers of the store register their interest via a subscribe() method that sets a callback function that notifies them whenever the store value changes - Svelte store is reactive!\n\nI'll only describe the \"writable\" version of Svelte store here - the one that I, myself, have found most useful. In brief:\n\nA writable store is created using the following code pattern:\n\nNow, if a component (or, indeed, a regular JavaScript module) needs to know if anything changes in the store, it can register its interest by supplying a callback function with a subscribe command along the lines of the following:\n\nNote that, once you've created this arrangement, you never have to explicitly read your store, its current value remains available in your page's currentMyStoreFieldsValue for the duration of a browser session. A typical arrangement will be to use a stores.js file (usually positioned at the root of the src folder) to create a store object and then import this wherever it's needed. The javascript module system will ensure that the store is initialized the first time it is imported during the browser session.\n\nTo update the store's value you can use the set() method again, but it may often be more convenient to use Svelte store's update() method as this gives you access to the current value of the store. Check out Svelte's docs at Writable Stores if you'd like to see an example (and much else besides).\n\nDebugging techniques for SvelteKit webapps\n\nSo, you've blasted your code through the myriad of shrieks and groans displayed by VSCode and Vite when they find trivial errors like undeclared variables and missing files. Now you've got a webapp that runs - but all it does is sit and sulk. What now?\n\nThe first thing, of course, is to open the browser's Inspector and see what the Console tab offers - there's almost always something to get a handle on here. Oh dear - CORS or Permissions errors etc. What now?.\n\nDebugging a SvelteKit webapp tends to be a lot more complicated than, say, a React codebase because so much of your code is likely to be running \"server-side\".\n\nIf you've followed this series rigorously, you'll likely now be a world expert in debugging client-side code through the Browser's Inspector. This, above all else, has made my own coding life the purest pleasure and you'll find it continues to work just fine in client-side +page.svelte files.\n\nBut when you try to set breakpoints in a SvelteKit +page.server.js file, you'll find that the browser won't let you. Think about this for a moment. How can it? Code here runs either in the development server launched by npm run dev or in the live server where you've just deployed a package. This is just a black hole as far as the browser is concerned. So what do you do now?\n\nWhile you're still working on development code, VSCode offers you browser-like debugging facilities directly within your IDE. Personally. I've found these clunky. In practice, while I was still getting used to Svelte, I tended to rely simply on sprinkling console.log instructions over my code. Output for these appears in whatever terminal session you've used to launch your run npm dev.\n\nHowever, with persistence, this is what works for me in VSCode:\n\nStart your dev server with npm run dev\n\nOpen your +page.server.js file in VSCode and set breakpoints by clicking on the red dot at the beginning of lines.\n\nIn the VSCode command palette choose Debug: Attach to node process to get a list of Node.js processes running on your PC. Select the one that corresponds with your particular dev server session.\n\nRefresh whatever browser page depends upon your +page.server.js file and note that the tab for this continues to display an \"X\". This indicates that it is waiting for something to happen. Back in VSCode, you'll find that the editor page for +page.server.js has now become an active debugging session, This is halted on your first breakpoint and is awaiting your next move. \"Mouseover\" on fields in the code displays values, just as in the browser's Inspector, and VSCode debugging control keys can be used to advance through the code in the old, familiar way.\n\nBut what if you've got a problem that can only be investigated on the live host?\n\nHere, the code of your live Svelte webapp is largely invisible except through the use of specialised tools. Opening the Inspector and clicking on the Sources tab will list the various elements of your webapp's \"package\" in the \"Page\" hierarchy. But these are no help since they are now \"minified\" and abstracted into total obscurity. When you were working on the development server, these would have been turned back into meaningful files through the services of your source maps - but these are no longer available when you're working on a live package (unless you're prepared to override the default Vite config settings and expose your deployed live app to public scrutiny). And while the \"workspace\" hierarchy (which you might have used in the past to manipulate your source code) still duly lists your local code, you can't set breakpoints on any of it. So, back to seeding your code with logging messages and re-deploying the webapp.\n\nBut now there's a problem. Where would you go to look for log messages launched by a live webapp? The answer, for a Google Cloud webapp is the \"Google Cloud Logs Explorer\" console.\n\nThis, on first acquaintance, is also quite a clunky brute. But, with experience, you'll appreciate that (rather like the browser's Inspector) it's a fine piece of software engineering. It provides infinitely adaptable tools in one neat package. Embrace it!\n\nBuilding and Deploying a SvelteKit webapp to the Google Cloud\n\nIf your webapp had been using React, as a Firebase developer you'd know that the next step is to use npm run build to create a runtime version of your code, followed by a firebase deploy to upload this to Google Cloud's Firebase hosting servers.\n\nBut if you're using Svelte there's a problem. If your Sveltekit webapp uses server-side code to achieve its effects, you will need hosting for a Svelte server. Firebase hosting only serves webapp pages. You need a different type of hosting altogether - one that effectively lets you mimic the operation of the local Svelte server you've been running on your PC.\n\nOnce you start looking closely, you'll discover that the Google Cloud provides a bewildering variety of facilities in this area. Typically, you might be interested in Google's \"App Engine\" and \"Cloud Run\" services.\n\nSvelteKit docs at Building your App describe a build process that creates a \"yaml\" file that \"provides an optimized production build of your server code and your browser code\" serviced by an \"adapter\" to run on your specific environment (eg Google Cloud Run). But where would you find the necessary \"adapter\" and how would you choose the \"specific environment\"?\n\nAlthough Svelte provides official adapters for numerous environments (eg Netlify and Vercel) this list unfortunately doesn't include the Google Cloud. But \"community\" developers have stepped in and the one I've been using is called svelte-adapter-appengine, courtesy of Jonas Jongejan (HalfdanJ). This targets the Google Cloud App Engine environment (as described at svelte-adapter-appengine README) and so my requirement list is complete. Here's the procedure.\n\nInstall the package as a development dependency:\n\nnpm install --save-dev svelte-adapter-appengine\n\nUpdate your svelte.config.js to use the adapter:\n\nBuild your application:\n\nnpm run build\n\nDeploy your application to App Engine:\n\ngcloud app deploy --project <CLOUD_PROJECT_ID> build/app.yaml\n\nOutput from the deployment process will provide a url for your deployed webapp (eg https://myProject.nw.r.appspot.com). Feed that to the browser and be electrified by the shockingly fast response of your Sveltekit webapp.\n\nPostscript\n\nI hope you've enjoyed reading this post. Check out NgateSystems for an index to the whole series and a super-useful keyword search facility.\n\nI'm conscious that I've only scratched the surface of what Svelte has to offer. This post has covered the basics and should be enough to enable you to develop a functional database access/maintenance system, but there's lots more to learn. Make sure that you check out Svelte docs for more information. Good luck with your coding. I, for one, shall certainly be using Svelte in future!"
    }
}