{
    "id": "wrong_mix_domain_subsidiary_00061_2",
    "rank": 64,
    "data": {
        "url": "https://docs.mendix.com/developerportal/deploy/private-cloud-operator/",
        "read_more_link": "",
        "language": "en",
        "title": "Using Command Line to Deploy a Mendix App to a Private Cloud Cluster",
        "top_image": "https://www.mendix.com/favicon.ico",
        "meta_img": "https://www.mendix.com/favicon.ico",
        "images": [
            "https://docs.mendix.com/icons/notes-paper-edit-1.svg",
            "https://docs.mendix.com/icons/message-bubble-typing-1.svg",
            "https://docs.mendix.com/icons/print-1.svg",
            "https://docs.mendix.com/attachments/deployment/private-cloud/private-cloud-operator/environments-create-mda.png",
            "https://docs.mendix.com/attachments/deployment/private-cloud/private-cloud-operator/constant-name.png",
            "https://docs.mendix.com/attachments/deployment/private-cloud/private-cloud-operator/image1.png",
            "https://docs.mendix.com/attachments/deployment/private-cloud/private-cloud-operator/image2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-06-19T16:23:06+02:00",
        "summary": "",
        "meta_description": "Describes the processes for using the Mendix Operator directly to deploy a Mendix app in the Private Cloud",
        "meta_lang": "en",
        "meta_favicon": "https://www.mendix.com/favicon.ico",
        "meta_site_name": "Mendix Documentation",
        "canonical_link": "https://docs.mendix.com/developerportal/deploy/private-cloud-operator/",
        "text": "1 Introduction\n\nOnce you have the Mendix Operator installed in a namespace of your Red Hat OpenShift, or other Kubernetes cluster (see Creating a Private Cloud Cluster), you can use it to control the deployment of your Mendix app using Mendix Custom Resources (CRs). The Mendix operator then creates the app container and builds the app inside the namespace, together with all the resources the app needs.\n\nThis document explains how to provide the CRs through the console or command line for a standalone cluster. This enables you to automate your deployment processes and perform deployments from behind a firewall which would prevent access to the Mendix Portal.\n\nAlternatively, you can create a connected cluster and use the Mendix Portal to deploy the app, as described in Deploying a Mendix App to a Private Cloud Cluster.\n\n2 Prerequisites for Deploying a Mendix App\n\nAn OpenShift (version 3.11 or above), or Kubernetes platform â see Supported Cluster Types in Supported Providers for a full list\n\nPlatform administration account\n\nOpenShift CLI installation if you are deploying on OpenShift (see Getting started with the CLI on the Red Hat OpenShift website for more information)\n\nKubectl installation if you are deploying to another Kubernetes platform (see Install and Set Up kubectl on the Kubernetes webside for more information)\n\nA command line terminal. In Windows, this could be PowerShell or the Windows Command Prompt.\n\nThe deployment package of a Mendix app made with version 8.0.0 (build 56467) or above\n\n3 Deploying a Mendix App with an Operator\n\nYou can deploy multiple Mendix apps to run in the same Kubernetes or OpenShift namespace. Apps will have an Environment UUID added when they are deployed to ensure that they are unique in the project; the name is required to identify the app when creating, modifying, or deleting it.\n\nFollow the instructions below to deploy your app.\n\n3.1 Creating a Deployment Package\n\nCreate a deployment package (.mda) file from your app. It is this which is picked up by the CR configuration and deployed in a container to your namespace.\n\nYou can obtain the deployment package in a number of ways:\n\nwithin Studio Pro, by choosing the menu option Project > Create Deployment Packageâ¦ â see Create Deployment Package for more information\n\nfrom the Environments page of your app in Apps\n\nthrough a CI/CD process, such as Jenkins.\n\nThe deployment package must be available over the internet without requiring authorization credentials, as these cannot be provided in the CR.\n\n3.2 Editing the CR\n\nYou need to create a file containing yml code and then configure it to create the CR for your app. Below is an example which can be used a reference purpose to create a mendix CR yaml file. Adapt this example as required for your own application.\n\nYou need to make the following changes:\n\nname: â You can deploy multiple apps in one project/namespace â the app name in the CR doesn’t have to match the app name in the mda and will have an Environment UUID added when it is deployed to ensure that it is unique in the project â see Reserved Names for Mendix Apps, below, for restrictions on naming your app\n\ndatabase/storage â ensure that these have the correct Database Plan and Storage Plan â they have to have the same names that you registered in the namespace\n\nmendixRuntimeVersion â the full runtime version of the app. In Operator versions 2.15.0 and 2.15.1, this field is not read (but needs to be specified). From Operator version 2.16.0 onwards, this field does not need to be specified.\n\nsourceURL â an HTTP or HTTPS URL specifying the location of the deployment package (this must be accessible from your cluster without any authentication; use expiring URLs for security). Alternatively, to deploy an existing app image built by the Mendix Operator, specify it using an oci-image:// schema.\n\nappURL â the endpoint where you can connect to your running app â this is optional, and if it is supplied it must be a URL which is supported by your platform\n\ntls â the TLS configuration â this is optional, and if it is supplied it will override the default Mendix Operator network configuration\n\nenableTLS â allows you to enable or disable TLS for the Mendix app’s Ingress or OpenShift Route\n\nsecretName â optional name of a kubernetes.io/tls secret, which must exist, containing the TLS certificate â if left empty, the default TLS certificate from the Ingress Controller or OpenShift Router will be used â cannot be used together with certificate and key\n\ncertificate and key â provide the tls.crt and tls.key values directly (not recommended for production environments) â cannot be used together with secretName\n\nreplicas â by default one replica will be started when you deploy your app\n\nresources â change the minimum and maximum container resources your app requires\n\nserviceAnnotations â set custom annotations for network Services; these annotations are applied on top of default annotations from OperatorConfiguration\n\nendpointAnnotations â set custom annotations for Ingress (or OpenShift Route) objects; these annotations are applied on top of default annotations from OperatorConfiguration\n\ningressPath â specify a custom Ingress path; this overrides the default ingress path from OperatorConfiguration\n\ningressPathType â specify a custom Ingress class name; this overrides the default ingress pathType from OperatorConfiguration\n\ntopologySpreadConstraints â specify Kubernetes topology spread constraints for the app’s runtime pods; please specify only constraints that are supported by your cluster\n\nlogAutosubscribeLevel â change the default logging level for your app, the standard level is INFO â possibilities are: TRACE, DEBUG, INFO, WARNING, ERROR, and CRITICAL\n\nmxAdminPassword â here you can change the password for the MxAdmin user â if you leave this empty, the password will be the one set in the Mendix model\n\ndebuggerPassword â here you can provide the password for the debugger â this is optional. Setting an empty debuggerPassword will disable the debugging features. In order to connect to the debugger in Studio Pro, enter the debugger URL as <AppURL>/debugger/. You can find further information in Debugging Microflows Remotely\n\ndtapMode â for development of the app, for example acceptance testing, choose D, for production deployment, select P\n\nruntimeLicenseProduct - this setting is applicable to PCLM licenses. If the product type for the license is anything other than Standard, then the value of the Product type needs to be set here. For more information, see PCLM Runtime License Product\n\nYour app can only be deployed to a production environment if security in the app is set on.\n\nIf you have an offline Runtime license, for example for a standalone cluster, you can configure it by adding a runtimeLicense section within the runtime section and setting LicenseId and LicenseKey to the values received from Mendix Support:\n\nlogLevels â set custom logging levels for specific log nodes in your app; valid values are: TRACE, DEBUG, INFO, WARNING, ERROR, and CRITICAL\n\nlogFormatType â allows to specify the log format of Mendix apps; valid values are plain (default) and json; for more information, see the runtime log format documentation.\n\nmicroflowConstants â set values for microflow constants. Mendix Operator 2.14.0 (and earlier versions) need all app constants to be specified if dtapMode is set to P; Operator 2.15.0 (and newer versions) will fallback to default values for any constants that are not specified here.\n\nscheduledEventExecution â choose which scheduled events should be enabled; valid values are: ALL, NONE and SPECIFIED\n\nmyScheduledEvents â list scheduled events which should be enabled â can only be used when scheduledEventExecution is set to SPECIFIED\n\njettyOptions and customConfiguration â if you have any custom Mendix Runtime parameters, they need to be added to this section; options for the Mendix runtime have to be provided in JSON format; see the examples in the CR for the correct format and the information below for more information on setting app constants and configuring scheduled events\n\nenvironmentVariables â set the environment variables for the Mendix app container, and JVM arguments through the JAVA_TOOL_OPTIONS environment variable\n\nclientCertificates â specify client certificates to be used for TLS calls to Web Services and REST services\n\nruntimeMetricsConfiguration â specify how metrics should be collected; any non-empty values will override default values from OperatorConfiguration; see Monitoring Environments in Mendix for Private Cloud for details on how to monitor your environment\n\nruntimeLeaderSelection â specify how the leader replica should be selected - valid options are assigned (default mode: the master deployment will run one leader replica) and none (do not run any leader replicas, master deployment is scaled down to zero; this mode requires a specific infrastructure configuration, please consult with Mendix Expert Services before using this feature)\n\ncustomPodLabels - specify additional pod labels (please avoid using labels that start with the privatecloud.mendix.com/ prefix)\n\ngeneral - specify additional labels for all pods of the app\n\n3.2.1 Setting App Constants\n\nThe constant name is equal to {module-name}.{constant-name} where {module-name} is the name of the Mendix app module containing the constant, and {constant-name} is the name of the constant. The constant name will also be visible in the constant properties (UnitTesting.RemoteApiEnabled in this example):\n\nSet the constant values in the microflowConstants value in runtime. For example:\n\n3.2.2 Configuring Scheduled Events\n\nTo disable execution of all scheduled events, set the scheduledEventExecution value to NONE in runtime.\n\nTo enable execution of all scheduled events, set the scheduledEventExecution value to ALL in runtime.\n\nTo enable execution for specific scheduled events, set the scheduledEventExecution value to SPECIFIED in runtime. Specify which events should be enabled by listing their full names in the myScheduledEvents value in runtime.\n\nFor example, to enable the execution of event EventOne in module MyFirstModule and event EventTwo in MySecondModule, set the myScheduledEvents list to MyFirstModule.EventOne, MySecondModule.EventTwo:\n\nThe MyScheduledEvents value should be removed from customConfiguration if ScheduledEventExecution is set to ALL or NONE.\n\n3.3 Building and Deploying Your App\n\nYou now need to supply the CR you have just created to the platform so that the Mendix Operator can use it to build and deploy the app.\n\nYou can do this in one of two ways:\n\nvia the CLI\n\nfor OpenShift, you can use the OpenShift console\n\n3.3.1 Processing the CR in the CLI\n\nTo submit the CR via a CLI you will need a file containing the YML you created in Editing the CR, above.\n\n3.3.1.1 Kubectl in the CLI\n\nTo build and deploy your app using AWS-EKS or other Kubernetes platform execute the following command:\n\n3.3.1.2 OpenShift CLI\n\nTo build and deploy your app using the OpenShift CLI, do the following:\n\nPaste the OpenShift login command into your command line terminal as described in the first few steps of the Signing in to Open Shift section of Creating a Private Cloud Cluster.\n\nSwitch to the project where you’ve deployed the Mendix Operator using the commandoc project {my-project} where {my-project} is the name of the project where the Mendix Operator is deployed.\n\nPaste the following command into your command line terminal:\n\n3.3.2 Process the CR in the OpenShift Console\n\nTo build and deploy your app using the OpenShift Console, do the following:\n\nSign in to the OpenShift Console.\n\nGo to your project.\n\nClick the Add button, and select Import YAML.\n\nIn the Import YAML page, enter/paste the YML you prepared in [Editing the CR}(#edit-cr), above.\n\nClick the Create button.\n\nMendix Operator will now pick up the YAML and deploy your app.\n\n3.4 Monitoring the Build Process.\n\nThe YAML window will report the status of the app build. Note that it can take up to ten minutes for all the statuses to reach ready.\n\nThe following statuses will be reported:\n\nappState â The status of your app (Started or Stopped)\n\nThis will also return the appURL which you can use to reach your app\n\nbuildStatus â Ready\n\ndatabaseStatus â Ready\n\nmendixAppState â Ready\n\nnetworkStatus â Ready\n\nruntimeStatus â Ready\n\nstorageStatus â Ready\n\nserviceAccountStatus - attached\n\n3.5 Starting and Stopping Your App\n\nYou can start and stop your app through the CR you supplied to deploy your app. See section Edit the CR, above, for the full CR.\n\nTo stop your app when it is running, set the value of replicas to zero.\n\nTo start your app when it is stopped, set the value of replicas to be non-zero.\n\nThe value set in replicas will only be applied once the runtime status is Ready. If the runtime is waiting for another action to complete (for example, provisioning the database), then it will apply the replicas value once all other actions have been completed.\n\n4 Current Limitations\n\n4.1 Reserved Names for Mendix Apps\n\nNames beginning mendix- cannot be used for your own apps as they are reserved for use by the Mendix Operator.\n\nAll names beginning openshift- are reserved for use by OpenShift if you are deploying to an OpenShift cluster.\n\n4.2 ApplicationRootUrl Needs to be Set Manually\n\nIn some cases, your Mendix app will need to know its own URL â for example when using SSO or sending emails.\n\nFor this to work properly, you need to set the ApplicationRootUrl variable in customConfiguration to the app’s URL. For example:"
    }
}