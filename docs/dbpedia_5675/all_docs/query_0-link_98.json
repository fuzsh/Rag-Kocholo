{
    "id": "dbpedia_5675_0",
    "rank": 98,
    "data": {
        "url": "https://stackoverflow.com/questions/35260539/combine-full-text-with-other-index",
        "read_more_link": "",
        "language": "en",
        "title": "Combine full text with other index",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://www.gravatar.com/avatar/069558aeae416cb4a81cd65b90f987ec?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/h8FTg.png?s=64",
            "https://stackoverflow.com/posts/35260539/ivc/908e?prg=bc07e489-dea8-44f1-b7e8-5d3f86515fcf"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2016-02-07T23:32:52",
        "summary": "",
        "meta_description": "I have a full text index and an index on a created date.\n\nMy query on the date alone returns a nice, small 44 records very quickly (within a second):\n\n&gt; db.oneMillionDocumentsIndexed.count({crea...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/35260539/combine-full-text-with-other-index",
        "text": "The main case here is that a \"text\" search result is generally taking precedence over other filter conditions in the query, and as such it becomes necessary to \"first\" obtain results from the \"text\" component, and then basically \"scan\" for other conditions in the document.\n\nThis type of search can be difficult to optimise along with a \"range\" or any type of \"inequality\" match condition in conjuntion with the text search results, and is mostly due to how MongoDB handles this \"special\" index type.\n\nFor a short demonstration, consider the following basic setup:\n\ndb.texty.drop(); db.texty.insert([ { \"a\": \"a\", \"text\": \"something\" }, { \"a\": \"b\", \"text\": \"something\" }, { \"a\": \"b\", \"text\": \"nothing much\" }, { \"a\": \"c\", \"text\": \"something\" } ]) db.texty.createIndex({ \"text\": \"text\" }) db.texty.createIndex({ \"a\": 1 })\n\nSo if you wanted to look at this with a text search condition as well as a range consideration on the other field ( { \"$lt\": \"c\" } ), then you could handle as follows:\n\ndb.texty.find({ \"a\": { \"$lt\": \"c\" }, \"$text\": { \"$search\": \"something\" } }).explain()\n\nWith the explain output such as ( important part ):\n\n\"winningPlan\" : { \"stage\" : \"FETCH\", \"filter\" : { \"a\" : { \"$lt\" : \"c\" } }, \"inputStage\" : { \"stage\" : \"TEXT\", \"indexPrefix\" : { }, \"indexName\" : \"text_text\", \"parsedTextQuery\" : { \"terms\" : [ \"someth\" ], \"negatedTerms\" : [ ], \"phrases\" : [ ], \"negatedPhrases\" : [ ] }, \"inputStage\" : { \"stage\" : \"TEXT_MATCH\", \"inputStage\" : { \"stage\" : \"TEXT_OR\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"_fts\" : \"text\", \"_ftsx\" : 1 }, \"indexName\" : \"text_text\", \"isMultiKey\" : true, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 1, \"direction\" : \"backward\", \"indexBounds\" : { } } } } } },\n\nWhich is basically saying \"first get me the text results and then filter those results fetched by the other condition\". So clearly only the \"text\" index is being used here and then all the results it returns are subsequently being filtered by examining the content.\n\nThis is not optimal for two reasons, being that it may likely be that the data is best constrained by the \"range\" condition rather than the matches from the text search. Secondly, even though there is an index on the other data, it is not being used here for comparison. So rather the whole document is loaded for each result and the filter is tested.\n\nYou might then consider a \"compound\" index format here, and it would seem initially logical that if the \"range\" is more specific to selection, then include that as the prefixed order of the indexed keys:\n\ndb.texty.dropIndexes(); db.texty.createIndex({ \"a\": 1, \"text\": \"text\" })\n\nBut there is a catch here, since when you attempt to run the query again:\n\ndb.texty.find({ \"a\": { \"$lt\": \"c\" }, \"$text\": { \"$search\": \"something\" } })\n\nIt would result in an error:\n\nError: error: { \"waitedMS\" : NumberLong(0), \"ok\" : 0, \"errmsg\" : \"error processing query: ns=test.textyTree: $and\\n a $lt \\\"c\\\"\\n TEXT : query=something, language=english, caseSensitive=0, diacriticSensitive=0, tag=NULL\\nSort: {}\\nProj: {}\\n planner returned error: failed to use text index to satisfy $text query (if text index is compound, are equality predicates given for all prefix fields?)\", \"code\" : 2 }\n\nSo even though that may seem \"optimal\", the way MongoDB processes the query ( and really index selection ) for the special \"text\" index, it is just not possible for this \"exclusion\" outside of the range to be possible.\n\nYou can however perform an \"equality\" match on this in a very efficient way:\n\ndb.texty.find({ \"a\": \"b\", \"$text\": { \"$search\": \"something\" } }).explain()\n\nWith the explain output:\n\n\"winningPlan\" : { \"stage\" : \"TEXT\", \"indexPrefix\" : { \"a\" : \"b\" }, \"indexName\" : \"a_1_text_text\", \"parsedTextQuery\" : { \"terms\" : [ \"someth\" ], \"negatedTerms\" : [ ], \"phrases\" : [ ], \"negatedPhrases\" : [ ] }, \"inputStage\" : { \"stage\" : \"TEXT_MATCH\", \"inputStage\" : { \"stage\" : \"TEXT_OR\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"a\" : 1, \"_fts\" : \"text\", \"_ftsx\" : 1 }, \"indexName\" : \"a_1_text_text\", \"isMultiKey\" : true, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 1, \"direction\" : \"backward\", \"indexBounds\" : { } } } } },\n\nSo the index is used and it can be shown to \"pre-filter\" the content provided to the text matching by the output of the other condition.\n\nIf indeed you keep the \"prefix\" to the index as the \"text\" field(s) to search however:\n\ndb.texty.dropIndexes(); db.texty.createIndex({ \"text\": \"text\", \"a\": 1 })\n\nThen perform the search:\n\ndb.texty.find({ \"a\": { \"$lt\": \"c\" }, \"$text\": { \"$search\": \"something\" } }).explain()\n\nThen you see a similar result to the above \"equality\" match:\n\n\"winningPlan\" : { \"stage\" : \"TEXT\", \"indexPrefix\" : { }, \"indexName\" : \"text_text_a_1\", \"parsedTextQuery\" : { \"terms\" : [ \"someth\" ], \"negatedTerms\" : [ ], \"phrases\" : [ ], \"negatedPhrases\" : [ ] }, \"inputStage\" : { \"stage\" : \"TEXT_MATCH\", \"inputStage\" : { \"stage\" : \"TEXT_OR\", \"filter\" : { \"a\" : { \"$lt\" : \"c\" } }, \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"_fts\" : \"text\", \"_ftsx\" : 1, \"a\" : 1 }, \"indexName\" : \"text_text_a_1\", \"isMultiKey\" : true, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 1, \"direction\" : \"backward\", \"indexBounds\" : { } } } } },\n\nThe big differnce here from the first attempt being where filter is placed in the processing chain, indicating that whilst not a \"prefix\" match ( which is most optimal ), the content is indeed being scanned off of the index \"before\" being sent to the \"text\" stage.\n\nSo it is \"pre-filtered\" but not of course in the most optimal way, and this is due to the very nature of how the \"text\" index is used. So if you just considered the plain range on an index by itself:\n\ndb.texty.createIndex({ \"a\": 1 }) db.texty.find({ \"a\": { \"$lt\": \"c\" } }).explain()\n\nThen the explain output:\n\n\"winningPlan\" : { \"stage\" : \"FETCH\", \"inputStage\" : { \"stage\" : \"IXSCAN\", \"keyPattern\" : { \"a\" : 1 }, \"indexName\" : \"a_1\", \"isMultiKey\" : false, \"isUnique\" : false, \"isSparse\" : false, \"isPartial\" : false, \"indexVersion\" : 1, \"direction\" : \"forward\", \"indexBounds\" : { \"a\" : [ \"[\\\"\\\", \\\"c\\\")\" ] } } },\n\nThen that at least got the indexBounds to consider and only looked at that portion of the index that fell within those bounds.\n\nSo that's the differences here. Using a \"compound\" structure should save you some iteration cycles here by being able to narrow down the selection, but it still must scan all index entries to filter, and must of course not be the \"prefix\" element in the index unless you can use an equality match on it.\n\nWithout a compound structure in the index, you are always returning the text results \"first\", and then applying any other conditions to those results. Also it is not possible to \"combine/intersect\" the results from looking at a \"text\" index and a \"normal\" index due to the query engine handling. That is generally not going to be the optimal approach, so planning for considerations is important.\n\nIn short, ideally compound with an \"equality\" match \"prefix\", and if not then include in the index \"after\" the text definition."
    }
}