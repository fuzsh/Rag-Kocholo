{
    "id": "dbpedia_8432_3",
    "rank": 85,
    "data": {
        "url": "https://medium.com/criteo-engineering/turning-your-training-bike-into-a-speed-remake-bceb4ea3d114",
        "read_more_link": "",
        "language": "en",
        "title": "Turning your training bike into a Speed remake",
        "top_image": "https://miro.medium.com/v2/resize:fit:1200/1*35PpTEFM7LnDvvhjpWil3Q.jpeg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1200/1*35PpTEFM7LnDvvhjpWil3Q.jpeg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*uQa2E6LGdotlsEg6fCm1yw.jpeg",
            "https://miro.medium.com/v2/resize:fill:48:48/1*WGftjNnfLwlWCeBno0xQCg.png",
            "https://miro.medium.com/v2/resize:fill:144:144/1*uQa2E6LGdotlsEg6fCm1yw.jpeg",
            "https://miro.medium.com/v2/resize:fill:64:64/1*WGftjNnfLwlWCeBno0xQCg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Kevin Gosse",
            "kevingosse.medium.com"
        ],
        "publish_date": "2020-04-15T09:04:14.214000+00:00",
        "summary": "",
        "meta_description": "In those days of isolation, finding ways to get a regular physical activity is important, both for health and moral. It turns out that I own a training bike, so it was a good opportunity to take it…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/resize:fill:256:256/1*R3hbDef2Ziu8Qe1GzCy78A.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://techblog.criteo.com/turning-your-training-bike-into-a-speed-remake-bceb4ea3d114",
        "text": "In those days of isolation, finding ways to get a regular physical activity is important, both for health and moral. It turns out that I own a training bike, so it was a good opportunity to take it back from wherever it had been stored for years (yeah, like you kept using it).\n\nI tend to use the bike while watching series to make it less boring. But I noticed that, when getting to the climax of a good episode, one tends to forget about the bike and unconsciously slow down. So I thought of an amusing way to fix that.\n\nRemember the most famous part of the Speed movie? A bus is rigged with a bomb that explodes if it moves slower than 50 mph. What if we stole the concept?\n\nOf course, I do not wish my training bike to explode, mostly for practical reasons. Instead, I would like the video to automatically pause when I get below the threshold, providing an immediate incentive to pedal harder. And so I built just that.\n\nThe setup uses a Raspberry Pi to read the speed from the bike and send it to the computer. There, an application takes care of playing/pausing the video as needed.\n\nThe very first step was finding how to read the speed. The speed counter of my training bike is connected using a simple 2-pins connector.\n\nFortunately, those things are pretty standard, and you can use any breadboard cable to connect the pins. The immediate question is: Where to plug them?\n\nThe Raspberry Pi has a set of pins called GPIO (for general-purpose input/output) that you can use for all kinds of things. Not all pins are created equal, so you must make sure to pick the right one depending on what you’re trying to do:\n\nTo pick the right pins, we need to clarify what we’re doing. I’ve already seen bike speedometers in the past, and they worked by having a magnet attached to the wheel and a detector attached to the frame. As the wheel is turning, when the magnet gets close to the detector, it triggers a switch that closes the circuit. Then it’s just a matter of counting the time between each of those impulses and deducing the speed (by knowing the size of the wheel).\n\nI assumed that my training bike worked the same way. So I plugged one pin of the bike connector to the 3.3V of the Raspberry (pin 1), and the other to a GPIO pin (pin 7). My expectation was that, as the training bike internal wheel turned, it would close the circuit and I would be able to read the 3.3V impulses on the GPIO pin.\n\nThat’s great, but to read those impulses we need some software. I tried playing a little bit with Windows 10 IoT, but it doesn’t support the Raspberry Pi properly and I ended up using Raspbian. If like me you don’t feel like plugging a keyboard and a screen to the Raspberry, there are great tutorials out there explaining how to prepare an SD card with a Raspbian that automatically starts an SSH daemon.\n\nFor the code itself, I decided to use .NET Core, since it supports reading/writing from GPIO pins using the System.Device.Gpio NuGet package.\n\nTo control the pins, you first need to instantiate a GpioController:\n\nYou can then open a pin and start listening to any change:\n\nAt least, that’s what I thought. But after launching the program, I started receiving a continuous stream of Rising/Falling events even though I wasn’t touching the bike! After a bit of poking around, I noticed two things:\n\nThe events would be triggered at a very precise rate of 50 per second\n\nThe events were triggered only when the circuit was open. When I moved the pedals in position to close the circuit, the events would stop\n\nI have only a cursory understanding of this, but from what I read it seems that when setting the pin mode to Input, it’s connected to nothing. Therefore, when the circuit is open and we try to read the value, it picks up residual noise (I suspect the 50 Hz is due to interference caused by the AC input, but don’t quote me on this). Instead, we need to use InputPullDown, which will ground the pin and properly read nothing when the circuit is open. After those changes, the events were properly captured, so the next step was to compute the actual speed.\n\nOn a real bike, it would just be a matter of measuring the size of the wheel and deducing how much distance is covered for one rotation. But on a training bike, we don’t have a wheel we can measure, so we must figure out what value the internal counter is using.\n\nOne way could be to use the bike, try to pedal at a constant speed, and read the value on the internal counter. Then plug the Raspberry, pedal at the same speed, compute the frequency, and deduce everything we need. This could work but it would be very approximate. Instead, I decided to plug the Raspberry directly to the counter and use it to simulate the bike. This way, we can send impulses at the frequency we want and read the speed on the counter. To plug the Raspberry to the counter, I simply connected one pin of the counter on a GPIO pin, and the other to the ground. Then I wrote some code to send the impulses at the desired frequency by using GpioController.Write:\n\nAt one impulse per second, the counter shows a speed of 16 km/h. Therefore, to compute the speed in km/h in our own setup, we need to compute the frequency in Hz of the impulses and multiply it by 16. Great.\n\nBefore moving on, I couldn’t resist having a bit of fun.\n\nThe maximum value that the counter can display is, as we could expect, 999.9 km/h. If I further increase the frequency, it overflows at around 2000 km/h (maybe 2048, my setup is not precise enough) and counts back from 0.\n\nOk, moving back to the serious stuff. I decided to keep the Raspberry plugged to both the bike and the counter so that I could capture the current speed and keep displaying it on the counter. The final code to compute the speed looks like:\n\nThe next step was to send that data to the computer. I could simply return the current speed on a web page and poll it from my computer but hey, the year is 2020. To get about one value per second, we totally need some push technology, so I decided to use SignalR.\n\nI actually started by thinking that SignalR was overkill and tried using raw web sockets instead. It seemed to work at first, but I quickly discovered that stuff we take as granted, such as detection of disconnections, isn’t available out of the box. So yeah, use SignalR instead.\n\nFor the implementation, I wrote a IHostedService that computes the current speed, and push it to the SignalR hub. It worked fine but I later discovered a problem: since I was waiting for inputs on the GPIO to compute the speed, if I suddenly stopped pedaling then the speed would stop being updated and would remain at its latest value. It kinda defeated the whole purpose of the project. So I added a background thread that monitors the time since the last speed update and assumes a speed of 0 km/h after 3 seconds without any change.\n\nWhat about the client-side? The goal was to start playing a video when the speed got above a threshold and stop it when it got below. Most video players (including web ones) use the spacebar as a shortcut to pause/resume the video, so all I did was sending the spacebar input to the focused application when the speed got above or below the threshold.\n\nI also used LiveCharts.Wpf to display the speed on a nice chart.\n\nFor the finishing touches, I attached the Raspberry to the bike and configured it to launch the application at startup. The Raspberry takes a few seconds to start when powered on, so I looked for a way to get visual feedback when the application is loaded and ready to send the speed. The only way I could think of was to use the on-board LEDs, and fortunately, it turns out that they can be controlled programmatically. To turn on the green LED, just write 1 to the /sys/class/leds/led0/brightness file. To turn it off, write 0. To restore the default behavior (have the LED blink on disk access), write mmc0 to /sys/class/leds/led0/trigger."
    }
}