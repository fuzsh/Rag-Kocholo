{
    "id": "dbpedia_183_3",
    "rank": 62,
    "data": {
        "url": "https://medium.com/%40jm_bensalem/applying-various-algorithms-to-tackle-the-traveling-salesman-problem-in-algeria-a01acfea678f",
        "read_more_link": "",
        "language": "en",
        "title": "Applying Various Algorithms to Tackle the Traveling Salesman Problem in Algeria",
        "top_image": "https://miro.medium.com/v2/resize:fit:491/1*u0x0wFp_BuyutfLf9rPpXQ.png",
        "meta_img": "https://miro.medium.com/v2/resize:fit:491/1*u0x0wFp_BuyutfLf9rPpXQ.png",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/da:true/resize:fill:88:88/0*u9tXmIsyQsmW8CQg",
            "https://miro.medium.com/v2/da:true/resize:fill:144:144/0*u9tXmIsyQsmW8CQg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "BENSALEM Mohamed Abderrahmane",
            "medium.com"
        ],
        "publish_date": "2023-07-14T13:33:40.214000+00:00",
        "summary": "",
        "meta_description": "While at school, Icame across a problem known as the Traveling Sales Man Problem (TSP) a well known and heavily studied combinatorial optimization problem, I only saw a specific variation on the…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/1*m-R_BkNf1Qjr1YbyOIJY2w.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@jm_bensalem/applying-various-algorithms-to-tackle-the-traveling-salesman-problem-in-algeria-a01acfea678f",
        "text": "While at school, Icame across a problem known as the Traveling Sales Man Problem (TSP) a well known and heavily studied combinatorial optimization problem, I only saw a specific variation on the problem being applied on a complete graph of 10 nodes which we solved using the Christofides algorithm .\n\nA thought came to mind this summer as to how this problem could really be applied on a real country using real roads without flying around in straight lines and hopping over districts, meaning applying the traveling salesman problem on a symmetric incomplete real road distance weighted graph and of course being an Algerian meant that i should try to apply it on my home land Algeria which turned out to be much harder to solve than regular complete graph TSP .\n\nThe Traveling Salesman Problem\n\nAs it has become a sort of a tradition to take an overview on a problem before tackling it we take an overview on the TSP, So it is essentially about answering a specific question :\n\nGiven a list of cities and the distances between each pair of cities, what is the shortest possible route that visits each city exactly once and returns to the origin city?\n\nFrom the perspective of graph theory this questions transforms into the task of finding the Hamiltonian cycle ( a cycle passing by all nodes of a graph once and returning to the origin ) in a complete undirected weighted graph with the minimalist sum of weights, from the eyes of combinatorial optimization it could be viewed as the task of finding the combination of edges that both contains all cities once and minimizes the sum of their weights.\n\nThe thing about this problem is that we know how to solve it and we have a method that can guarantee the best and most optimal route every time but this method is basically trying all possible routes and choosing the most optimal one, Feeling satisfied and wanting to move on to another problem ?\n\njust wait a second! for a country like Algeria solving the TSP would require trying (58–1)! tours equaling 4.052692 * 10⁷⁶ to put into perspective how monstrous this number is the estimated number of atoms in the universe is roughly 10⁸⁰ ,so even though we can solve the problem , it is far too costly to do so ,this makes it an NP-Problem with a time complexity of O(n!) or O(n²*2^n) in case you use dynamic programming.\n\nTSP is an NP-hard problem. This implies that if there are a large number of cities, it is not feasible to evaluate every possible solution within a “reasonable” time (Hayes, 2019).\n\nSo since we cannot find the best solution for the problem in a reasonable time what do we do? we look for good answer rather than the best answer via methods that take polynomial time to provide a good enough answer .\n\nAlgeria as a symmetric incomplete weighted graph\n\nAlgeria is the 10th largest country in the world and the largest country in Africa. It used to be divided into 48 districts now 58 districts (Wilaya) differing in size , distances , geographical locations .\n\nThe process of creating the Algerian map is the following :\n\nFor each district, only the main city of that district is chosen to represent it.\n\nEach district is connected only the its geographical neighbors , this produces a total number of 144 connections.\n\nThe distance between each province is determined by the real world shortest road distance .\n\nThe data for the distances was gathered manually from GoogleMaps making it possible for small errors to occur.\n\nEven tho it is mentioned here that the real world values of the roads are taken , the majority of algorithms tend to perform poorly on incomplete graphs meaning that it will be inevitable that the distances are measured based direct distance.\n\nFor a complete graph of the Algerian map meaning each district is connected to the other 57 districts the sum of total of distances based on the geodisc distance would be 2080248.971434621 km.\n\nObviously it is unreasonable to have such a big number of connections while some of the provinces are not directly connected to each other. Now if we only count the geographically connected and use the same distance calculation method (geodisc) we get 24,358.29 km . and finally the sum of distances based on real world road distance would be 33,731.7 km based on the 144 connections.\n\nNow we take a look at the estimation of the shortest path length , using the following code :\n\nimport random\n\nimport networkx as nx\n\nimport pandas as pd\n\nimport numpy as np\n\nfrom geopy.distance import geodesic\n\ndef generate_random_tour(graph):\n\n# Start at a random node in the graph\n\ncurrent_node = random.choice(list(graph.nodes()))\n\ntour = [current_node]\n\n# Visit each remaining node in a random order\n\nremaining_nodes = set(graph.nodes()) - {current_node}\n\nwhile remaining_nodes:\n\nnext_node = random.choice(list(remaining_nodes))\n\ntour.append(next_node)\n\nremaining_nodes.remove(next_node)\n\ncurrent_node = next_node\n\n# Return the random tour\n\nreturn tour\n\ndf = pd.read_csv('AlgeriaCities.csv')\n\nprint(df.columns)\n\n# Extract city, distance, and road information\n\ncities = list(set([*df['City'],*df['Adjacent province']]))\n\nroads = [(x['City'],x['Adjacent province'],{\"weight\": x['Distance'],\"color\":\"blue\",\"label\":x['Route']}) for _, x in df.iterrows()]\n\nG = nx.Graph()\n\nG.add_nodes_from(cities)\n\nG.add_edges_from(roads)\n\nt=[]\n\ndf1 = pd.read_csv('Cities.csv')\n\nfor j in range(5000):\n\npath= generate_random_tour(G)\n\ncost=0\n\n#the cost is calculated based on the geometric distance between coordinants\n\nfor i in range(len(path) - 1):\n\ncurrent_city = path[i]\n\nnext_city = path[i + 1]\n\n# Find the row in the DataFrame with the current city and the adjacent city\n\ncord1=(df1[df1['City'] == current_city].Latitude.values[0],df1[df1['City'] == current_city].Longitude.values[0])\n\ncord2=(df1[df1['City'] == next_city].Latitude.values[0],df1[df1['City'] == next_city].Longitude.values[0])\n\ncost += geodesic(cord1, cord2).kilometers\n\nt.append(cost)\n\ndata_np = np.array(t)\n\n# Calculate the standard deviation using numpy\n\nstd_dev = np.std(data_np)\n\nprint(\"Standard Deviation:\", std_dev)\n\nafter generating 5000 random tours the standard deviation of the tours which represent the road length is around σ = 10546,1976 km , this method of course isn’t precise and usually over estimates the minimal length, yet it provides a good neighboring point for estimating that value.\n\nApplying different Heuristics for finding a good solution\n\nFor the following section, I will give an overview on the algorithm used as well as the details on the type of distance used. the full code could found on https://github.com/bensalem14/Traveling-Sales-Man-Problem-TSP-Algeria\n\nEven though it is possible to gather all real world distances between all districts , it is unbelievably costly to do so manually as it requires 58*57 connections , another note is that even when doing so the solution is not guaranteed to respect the real world constraints of geographical neighborhood .\n\nNetworkx default algorithm Christofides\n\nWe begin by the using the networkx default algorithm for solving the tsp , which is according to the official documentation of netwrokx christofides.\n\nthis algorithm guarantees that its solutions will be within a factor of 3/2 of the optimal solution length, the algorithm starts off by creating the minimal spanning tree of the graph , then forming a subgraph containing only the nodes with an odd number of connections from the MST , then reconstructing the whole graph while keeping only the minimal weighted connections and constructing an Eulerian tour(one passing by all edges once) while removing the repeated nodes.\n\nimport networkx as nx\n\nimport pandas as pd\n\nimport folium\n\nfrom geopy.distance import geodesic\n\ndef distance_between(df,city1, city2):\n\n\"\"\"distance between two cities\"\"\"\n\nrow1,row2 = df[df.City==city1].iloc[0],df[df.City==city2].iloc[0]\n\nlat1, lon1 = row1.Latitude, row1.Longitude\n\nlat2, lon2 = row2.Latitude, row2.Longitude\n\ndistance = geodesic((lat1,lon1), (lat2,lon2)).kilometers\n\nreturn distance\n\n# Read the CSV file\n\ndf = pd.read_csv('AlgeriaCities.csv')\n\ndf1 = pd.read_csv('Cities.csv')\n\n# Extract city, distance, and road information\n\ncities = list(set([*df['City'],*df['Adjacent province']]))\n\nroads = [(i,j,{\"weight\": distance_between(df1,i,j),\"color\":\"blue\"}) for i in cities for j in cities if i!=j]\n\nG = nx.Graph()\n\nG.add_nodes_from(cities)\n\nG.add_edges_from(roads)\n\n#uses the christofides algorithm\n\ntsp = nx.approximation.traveling_salesman_problem\n\npath = tsp(G, cycle=False)\n\nnow this solution provides the best :\n\nThe average solution cost based on 100 experiments is 8,859.7882 km which the best average cost out of the algorithms , one issue with this solution is that it does not respect the road constraints for example there is no direct connection between El Meniaa and Tiaret buyt in the graph there is .\n\nSample Path : In Salah-> Adrar-> Timimoun-> Beni Abbes-> Tindouf-> Bechar-> Naama-> El Bayedh-> Saida-> Mascara-> Mostaganem-> Tlemcen-> Ain Temouchent-> Sidi Bel Abbes-> Oran-> Relizane-> Chlef-> Ain Defla-> Tissemsilt-> Tiaret-> El Menia-> Ghardaia-> Laghouat-> Djelfa-> Tipaza-> Blida-> Medea-> Alger-> Boumerdes-> Bouira-> Tizi Ouzou-> Bordj Bou Arreridj-> Msila-> Setif-> Bejaia-> Jijel-> Mila-> Constantine-> Guelma-> Annaba-> El Taref-> Souk-Ahras-> Skikda-> Oum El Bouaghi-> Khenchela-> Tebessa-> Batna-> Biskra-> Ouled Djellal-> El Meghaier-> Touggourt-> El Oued-> Ouargla-> Illizi-> Djanet-> Tamanrasset-> Bordj Badji Mokhtar-> In Guezzam\n\nKruskal with DFS\n\nkruskal is a greedy algorithm to find the minimal spanning tree MST of the graph , the resulting graph is then subjected to a preorder traversal or DFS in order for it to be come a valid tour . for the implementation we have\n\nG = nx.Graph()\n\nG.add_nodes_from(cities)\n\nG.add_edges_from(roads)\n\n#we first extract the mst of the algerian graph then apply a preorder\n\n#traversal or dfs to make it connected\n\nmst = nx.minimum_spanning_tree(G)\n\ngraph = nx.Graph()\n\ngraph.add_edges_from([x for x in list(mst.edges)])\n\n# Perform a depth-first search (DFS) traversal to construct the tour\n\npath = list(nx.dfs_preorder_nodes(graph))\n\nNow for the construction of the minimal spanning tree we could have two approaches , either construct it from the fully connected graph of algeria or construct it using the predefined 144 connections .\n\nFor the first case using the fully connected graph of algeria we get\n\nWith an average tour distance of 10,963.12 km much worst compared to the christofides method and the estimated minimal tour length. for the second case we get\n\nWith an average tour length of 11,108.308 km which is even worst than the first method .\n\nSample Path : Laghouat-> Djelfa-> Msila-> Bordj Bou Arreridj-> Setif-> Bejaia-> Jijel-> Mila-> Constantine-> Oum El Bouaghi-> Khenchela-> Batna-> Biskra-> Ouled Djellal-> El Meghaier-> Touggourt-> Ouargla-> El Oued-> Tebessa-> Skikda-> Guelma-> Souk-Ahras-> Annaba-> El Taref-> Bouira-> Boumerdes-> Alger-> Blida-> Medea-> Tipaza-> Ain Defla-> Chlef-> Relizane-> Mascara-> Saida-> El Bayedh-> Naama-> Bechar-> Beni Abbes-> Tindouf-> Timimoun-> Adrar-> In Salah-> Tamanrasset-> In Guezzam-> Bordj Badji Mokhtar-> Djanet-> Illizi-> Tiaret-> Tissemsilt-> Mostaganem-> Oran-> Ain Temouchent-> Sidi Bel Abbes-> Tlemcen-> Tizi Ouzou-> Ghardaia-> El Menia\n\nNearest Neighbor\n\nThe simplest algorithm , it starts with a random city and passes by to the nearest city until all cities have been visited . it was implemented in python using this function\n\n#function to solve the tsp based on the nearest neighbor algorithm\n\ndef solve_tsp_nearest(distances):\n\nnum_cities = len(distances)\n\nvisited = [False] * num_cities\n\ntour = []\n\ntotal_distance = 0\n\n# Start at the first city\n\ncurrent_city = 0\n\ntour.append(current_city)\n\nvisited[current_city] = True\n\n# Repeat until all cities have been visited\n\nwhile len(tour) < num_cities:\n\nnearest_city = None\n\nnearest_distance = float('inf')\n\n# Find the nearest unvisited city\n\nfor city in range(num_cities):\n\nif not visited[city]:\n\ndistance = distances[current_city][city]\n\nif distance < nearest_distance:\n\nnearest_city = city\n\nnearest_distance = distance\n\n# Move to the nearest city\n\ncurrent_city = nearest_city\n\ntour.append(current_city)\n\nvisited[current_city] = True\n\ntotal_distance += nearest_distance\n\n# Complete the tour by returning to the starting city\n\ntour.append(0)\n\ntotal_distance += distances[current_city][0]\n\nreturn tour, total_distance\n\nThe inconveniance of this method is that it gives some existent paths but nonetheless the worst part is the pathological paths that it might produce looking at the map below\n\nthe connexions such as Djanet->Tebessa or El bayadth->tindouf completly illogical as they pass by multiple cities.\n\nfor the average tour length it gives a relatively good result of 9950.5 km.\n\nSample Path : El Bayedh-> Naama-> Saida-> Mascara-> Mostaganem-> Relizane-> Tiaret-> Tissemsilt-> Ain Defla-> Tipaza-> Blida-> Medea-> Alger-> Boumerdes-> Bouira-> Tizi Ouzou-> Bejaia-> Setif-> Bordj Bou Arreridj-> Msila-> Biskra-> Ouled Djellal-> El Meghaier-> Touggourt-> El Oued-> Ouargla-> Ghardaia-> Laghouat-> Djelfa-> Chlef-> Oran-> Sidi Bel Abbes-> Ain Temouchent-> Tlemcen-> Bechar-> Beni Abbes-> Timimoun-> Adrar-> In Salah-> El Menia-> Batna-> Khenchela-> Oum El Bouaghi-> Constantine-> Mila-> Jijel-> Skikda-> Guelma-> Annaba-> El Taref-> Souk-Ahras-> Tebessa-> Illizi-> Djanet-> Tamanrasset-> In Guezzam-> Bordj Badji Mokhtar-> Tindouf\n\nConcorde\n\nThe Concorde TSP Solver is a program for solving the TSP ,According to Mulder & Wunsch (2003), Concorde\n\nis widely regarded as the fastest TSP solver, for large instances, currently in existence.\n\nthis has been repeatedly used for global testing including the largest instance of the TSP with over 98500 cities . it uses a Lin-Kernighan heuristic to solve the tsp instances for 2D euclidean spaces instances .\n\nfrom __future__ import division, print_function\n\nimport pandas as pd\n\nimport folium\n\nfrom concorde.tsp import TSPSolver\n\n#get cities coordinantes\n\ncities = pd.read_csv(\n\n\"Cities.csv\"\n\n)\n\n# Instantiate solver who uses the concorde algorithm\n\nsolver = TSPSolver.from_data(cities.Latitude, cities.Longitude, norm=\"GEO\")\n\n# Find tour\n\ntour_data = solver.solve()\n\nassert tour_data.success\n\nsolution = cities.iloc[tour_data.tour]\n\nprint(\"Optimal tour:\")\n\nprint(\n\n\" -> \".join(\"{r.City}\".format(r=row) for _, row in solution.iterrows())\n\n)\n\npath=[\"{r.City}\".format(r=row) for _, row in solution.iterrows()]\n\nIt is by far the fastest algorithm for solving the tsp for algeria as it takes on average 0.1 seconds , as for the solution unlike the previous algorithms the concorde algorithm provides a single unchanging solution with a length of 9,111 km , another thing that makes this algorithm super useful is that it provides the most accurate edges choice meaning respecting the real world geographic constraints with only a few minor violation in the connection between El Oued and Laghouat and chlef and Laghouat(Tindouf -Bordj Badji Mokhtar will be ignored as it is far too costly to consider).\n\nSolution Path :\n\nOuargla -> Touggourt -> El Oued -> El Meghaier -> Ouled Djellal -> Laghouat -> Djelfa -> Msila -> Bordj Bou Arreridj -> Setif -> Batna -> Biskra -> Khenchela -> Oum El Bouaghi -> Tebessa -> Souk-Ahras -> El Taref -> Annaba -> Skikda -> Guelma -> Constantine -> Mila -> Jijel -> Bejaia -> Bouira -> Tizi Ouzou -> Boumerdes -> Alger -> Tipaza -> Blida -> Medea -> Ain Defla -> Tissemsilt -> Tiaret -> Chlef -> Relizane -> Mostaganem -> Oran -> Ain Temouchent -> Tlemcen -> Sidi Bel Abbes -> Mascara -> Saida -> El Bayedh -> Naama -> Bechar -> Beni Abbes -> Tindouf -> Bordj Badji Mokhtar -> In Guezzam -> Tamanrasset -> Djanet -> Illizi -> In Salah -> Adrar -> Timimoun -> El Menia -> Ghardaia\n\nConclusion\n\nThough no clear answer respecting both the geographical constraints and real world distances contraints , this opens the door for further study on the matter. the tsp concorde remains the best algorithm with the most concise and consistent results ."
    }
}