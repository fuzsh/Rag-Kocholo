{
    "id": "dbpedia_3158_0",
    "rank": 62,
    "data": {
        "url": "https://microsoft.fandom.com/wiki/Component_Object_Model",
        "read_more_link": "",
        "language": "en",
        "title": "Component Object Model",
        "top_image": "https://static.wikia.nocookie.net/windows/images/3/39/Site-community-image/revision/latest/scale-to-width-down/1200?cb=20221114225401",
        "meta_img": "https://static.wikia.nocookie.net/windows/images/3/39/Site-community-image/revision/latest/scale-to-width-down/1200?cb=20221114225401",
        "images": [
            "https://static.wikia.nocookie.net/windows/images/e/e6/Site-logo.png/revision/latest?cb=20231202023119",
            "https://static.wikia.nocookie.net/windows/images/9/99/Question_book-new.svg/revision/latest/scale-to-width-down/25?cb=20120828102640",
            "https://static.wikia.nocookie.net/6a181c72-e8bf-419b-b4db-18fd56a0eb60",
            "https://static.wikia.nocookie.net/6c42ce6a-b205-41f5-82c6-5011721932e7",
            "https://static.wikia.nocookie.net/464fc70a-5090-490b-b47e-0759e89c263f",
            "https://static.wikia.nocookie.net/f7bb9d33-4f9a-4faa-88fe-2a0bd8138668"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Microsoft Wiki"
        ],
        "publish_date": "2024-07-29T22:27:06+00:00",
        "summary": "",
        "meta_description": "Component Object Model (COM) is a binary-interface standard for software componentry introduced by Microsoft in 1993. It is used to enable interprocess communication and dynamic object creation in a large range of programming languages. The term COM is often used in the Microsoft software...",
        "meta_lang": "en",
        "meta_favicon": "https://static.wikia.nocookie.net/windows/images/4/4a/Site-favicon.ico/revision/latest?cb=20231202044816",
        "meta_site_name": "Microsoft Wiki",
        "canonical_link": "https://microsoft.fandom.com/wiki/Component_Object_Model",
        "text": "Component Object Model (COM) is a binary-interface standard for software componentry introduced by Microsoft in 1993. It is used to enable interprocess communication and dynamic object creation in a large range of programming languages. The term COM is often used in the Microsoft software development industry as an umbrella term that encompasses the OLE, OLE Automation, ActiveX, COM+ and DCOM technologies.\n\nOverview[]\n\nThe essence of COM is a language-neutral way of implementing objects that can be used in environments different from the one in which they were created, even across machine boundaries. For well-authored components, COM allows reuse of objects with no knowledge of their internal implementation, as it forces component implementers to provide well-defined interfaces that are separate from the implementation. The different allocation semantics of languages are accommodated by making objects responsible for their own creation and destruction through reference-counting. Casting between different interfaces of an object is achieved through the QueryInterface() function. The preferred method of inheritance within COM is the creation of sub-objects to which method calls are delegated.\n\nAlthough the interface standard has been implemented on several platforms[citation needed], COM is primarily used with Microsoft Windows. For some applications, COM has been replaced at least to some extent by the Microsoft .NET framework, and support for Web Services through the Windows Communication Foundation (WCF). However, COM objects can be used with all .NET languages through .NET COM Interop.\n\nNetworked DCOM uses binary proprietary formats, while WCF encourages the use of XML-based SOAP messaging. COM is very similar to other component software interface technologies, such as CORBA and Java Beans, although each has its own strengths and weaknesses. The characteristics of COM make it most suitable for the development and deployment of desktop applications[citation needed], for which it was originally designed.\n\nHistory[]\n\nOne of the first methods of interprocess communication in Windows was Dynamic Data Exchange (DDE), first introduced in 1987, that allowed sending and receiving messages in so-called \"conversations\" between applications.\n\nAntony Williams, one of the more notable thinkers involved in the creation of the COM architecture, later distributed two internal papers in Microsoft that embraced the concept of software components; Object Architecture: Dealing With the Unknown – or – Type Safety in a Dynamically Extensible Class Library in 1988 and On Inheritance: What It Means and How To Use It in 1990. These provided the foundation of many of the ideas behind COM.\n\nObject Linking and Embedding (OLE), Microsoft's first object-based framework, was built on top of DDE and designed specifically for compound documents. It was introduced with Word for Windows and Excel in 1991, and was later included with Windows, starting with version 3.1 in 1992.\n\nAn example of a compound document is a spreadsheet embedded in a Word for Windows document; as changes are made to the spreadsheet within Excel, they appear automatically inside the Word document.\n\nIn 1991, Microsoft introduced Visual Basic Extensions (VBX) with Visual Basic 1.0. A VBX is a packaged extension in the form of a dynamic-link library (DLL) that allowed the creation of objects to be graphically placed in a form and manipulated by properties and methods. These were later adapted for use by other languages such as Visual C++.\n\nIn 1993, when version 3.1 of Windows was released, Microsoft released OLE 2 with its underlying object model. The COM Application binary interface (ABI) was the same as the MAPI ABI, which was released in 1992. While OLE 1 was focused on compound documents, COM and OLE 2 were designed to address software components in general. Text conversations and Windows messages had proved not to be flexible enough to allow sharing application features in a robust and extensible way, so COM was created as a new foundation, and OLE changed to OLE2.\n\nIn 1994 OLE custom controls (OCXs) were introduced as the successor to VBX controls. At the same time, Microsoft stated that OLE 2 would just be known as \"OLE\", and that OLE was no longer an acronym, but a name for all of the company's component technologies.\n\nIn early 1996, Microsoft found a new use for OLE Custom Controls, expanding their Web browser's capability to present content, renamed some parts of OLE relating to the Internet ActiveX, and gradually renamed all OLE technologies to ActiveX, except the compound document technology that was used in Microsoft Office. Later that year, DCOM was introduced as an answer to CORBA.\n\nRelated technologies[]\n\nCOM was the major software development platform for Windows and, as such, influenced development of a number of supporting technologies.\n\n.NET[]\n\nMain article: .NET Framework\n\nThe COM platform has largely been superseded by the Microsoft .NET initiative, and Microsoft now focuses its marketing efforts on .NET. COM was often used to hook up complex, high performance code to front end code implemented in Visual Basic or ASP.\n\nTo some extent, COM is now deprecated in favor of .NET.[1] Since .NET provides rapid development tools similar to Visual Basic for both Windows Forms and Web Forms with just-in-time compilation, back-end code can be implemented in any .NET Language including C#, Visual Basic and C++/CLI.\n\nDespite this, COM remains a viable technology with an important software base. As of 2009, Microsoft has no plans for discontinuing either COM or support for COM. It is also ideal for script control of applications such as Office or Internet Explorer since it provides an interface for calling COM object methods from a script rather than requiring knowing the API at compile time. The GUID system used by COM has wide uses any time a unique ID is needed.\n\nSeveral of the services that COM+ provides have been largely replaced by recent releases of .NET. For example, the System.Transactions namespace in .NET provides the TransactionScope class, which provides transaction management without resorting to COM+. Similarly, queued components can be replaced by Windows Communication Foundation with an MSMQ transport.\n\nThere is limited support for backward compatibility. A COM object may be used in .NET by implementing a runtime callable wrapper (RCW).[2] .NET objects that conform to certain interface restrictions may be used in COM objects by calling a COM callable wrapper (CCW).[3] From both the COM and .NET sides, objects using the other technology appear as native objects. See COM Interop.\n\nWCF solves a number of COM's remote execution shortcomings, allowing objects to be transparently marshalled by value across process or machine boundaries.\n\nInternet security[]\n\nMicrosoft's idea of embedding active content on web pages as COM/ActiveX components (rather than e.g. Java applets) created a combination of problems in the Internet Explorer web browser that has led to an explosion of computer virus, trojan and spyware infections. These malware attacks mostly depend on ActiveX for their activation and propagation to other computers. Microsoft recognized the problem with ActiveX as far back as 1996 when Charles Fitzgerald, program manager of Microsoft's Java team said \"If you want security on the 'Net', unplug your computer. … We never made the claim up front that ActiveX is intrinsically secure.\" [1]\n\nAs COM and ActiveX components are run as native code on the user's machine, there are fewer restrictions on what the code can do. Many of these problems have been addressed by the introduction of \"Authenticode\" code signing (based on digital signatures), and later by the .NET platform also. Other security measures are that, before an ActiveX control is installed, the user is prompted whether to allow the installation or not, enabling the user to disallow the installation of controls from sites that the user does not trust. It is also possible to disable ActiveX controls altogether, or to only allow a selected few.\n\nTechnical details[]\n\nCOM programmers build their software using COM-aware components. Different component types are identified by class IDs (CLSIDs), which are Globally Unique Identifiers (GUIDs). Each COM component exposes its functionality through one or more interfaces. The different interfaces supported by a component are distinguished from each other using interface IDs (IIDs), which are GUIDs too.\n\nCOM interfaces have bindings in several languages, such as C, C++, Visual Basic, Delphi, and several of the scripting languages implemented on the Windows platform. All access to components is done through the methods of the interfaces. This allows techniques such as inter-process, or even inter-computer programming (the latter using the support of DCOM).\n\nInterfaces[]\n\nAll COM components must (at the very least) implement the standard IUnknown interface, and thus all COM interfaces are derived from IUnknown. The IUnknown interface consists of three methods: AddRef() and Release(), which implement reference counting and controls the lifetime of interfaces; and QueryInterface(), which by specifying an IID allows a caller to retrieve references to the different interfaces the component implements. The effect of QueryInterface() is similar to dynamic_cast<> in C++ or casts in Java and C#.\n\nA COM component's interfaces are required to exhibit the reflexive, symmetric, and transitive properties. The reflexive property refers to the ability for the QueryInterface() call on a given interface with the interface's ID to return the same instance of the interface. The symmetric property requires that when interface B is retrieved from interface A via QueryInterface(), interface A is retrievable from interface B as well. The transitive property requires that if interface B is obtainable from interface A and interface C is obtainable from interface B, then interface C should be retrievable from interface A.\n\nAn interface consists of a pointer to a virtual function table that contains a list of pointers to the functions that implement the functions declared in the interface, in the same order that they are declared in the interface. This technique of passing structures of function pointers is very similar to the one used by OLE 1.0 to communicate with its system libraries.\n\nCOM specifies many other standard interfaces used to allow inter-component communication. For example, one such interface is IStream, which is exposed by components that have data stream semantics (e.g. a FileStream component used to read or write files). It has the expected Read and Write methods to perform stream reads and writes. Another standard interface is IOleObject, which is exposed by components that expect to be linked or embedded into a container. IOleObject contains methods that allow callers to determine the size of the component's bounding rectangle, whether the component supports operations like 'Open', 'Save' and so on.\n\nClasses[]\n\nA class is COM's language-independent way of defining a class in the object-oriented sense.\n\nA class can be a group of similar objects or a class is simply a representation of a type of object; it should be thought of as a blueprint that describes the object.\n\nA coclass supplies concrete implementation(s) of one or more interfaces. In COM, such concrete implementations can be written in any programming language that supports COM component development, e.g. Delphi, C++, Visual Basic, etc.\n\nOne of COM's major contributions to the world of Windows development is the awareness of the concept of separation of interface from implementation. An extension of this fundamental concept is the notion of one interface, multiple implementations. This means that at runtime, an application can choose to instantiate an interface from one of many different concrete implementations.\n\nInterface Definition Language and type libraries[]\n\nType libraries contain metadata that represent COM types. However, these types must first be described using Microsoft Interface Definition Language.\n\nThis is the common practice in the development of a COM component, i.e. to start with the definition of types using IDL. An IDL file is what COM provides that allows developers to define object-oriented classes, interfaces, structures, enumerations and other user-defined types in a language independent manner. COM IDL is similar in appearance to C/C++ declarations with the addition of keywords such as \"interface\" and \"library\" for defining interfaces and collections of classes, respectively. IDL also requires the use of bracketed attributes before declarations to provide additional information, such as the GUIDs of interfaces and the relationships between pointer parameters and length fields.\n\nThe IDL file is compiled by the MIDL compiler into a pair of forms for consumption from various languages. For C/C++, the MIDL compiler generates a compiler-independent header file containing struct definitions to match the vtbls of the declared interfaces and a C file containing declarations of the interface GUIDs. C++ source code for a proxy module can also be generated by the MIDL compiler. This proxy contains method stubs for converting COM calls into Remote Procedure Calls, thus enabling DCOM.\n\nAn IDL file may also be compiled by the MIDL compiler into a type library (.TLB file). The binary metadata contained within the type library is meant to be processed by language compilers and runtime environments (e.g. VB, Delphi, the .NET CLR etc.). The end result of such TLB processing is that language-specific constructs are produced that represent the COM class defined in the .TLB (and ultimately that which was defined in the originating IDL file).\n\nCOM as an object framework[]\n\nThe fundamental principles of COM have their roots in Object-Oriented philosophies. It is a platform for the realization of Object-Oriented Development and Deployment.\n\nBecause COM is a runtime framework, types have to be individually identifiable and specifiable at runtime. To achieve this, globally unique identifiers (GUIDs) are used. Each COM type is designated its own GUID for identification at runtime (versus compile time).\n\nIn order for information on COM types to be accessible at both compile time and runtime, COM uses type libraries. It is through the effective use of type libraries that COM achieves its capabilities as a dynamic framework for the interaction of objects.\n\nConsider the following example coclass definition in an IDL :\n\ncoclass MyObject { [default] interface IMyObject; [default, source] dispinterface _IMyObjectEvents; };\n\nThe above code fragment declares a COM class named MyObject which must implement an interface named IMyObject and which supports (not implements) the event interface _IMyObjectEvents.\n\nIgnoring the event interface bit, this is conceptually equivalent to defining a C++ class like this:\n\nclass CSomeObject : public ISomeInterface { ... ... ... };\n\nwhere ISomeInterface is a C++ pure virtual class.\n\nReferring once again to the MyObject COM class: once a coclass definition for it has been formalized in an IDL, and a Type Library compiled from it, the onus is on the individual language compiler to read and appropriately interpret this Type Library and then produce whatever code (in the specific compiler's language) necessary for a developer to implement and ultimately produce the binary executable code which can be deemed by COM to be of coclass MyObject.\n\nOnce an implementation of a COM coclass is built and is available in the system, next comes the question of how to instantiate it. In languages like C++, we can use the CoCreateInstance() API in which we specify the CLSID (CLSID_MyObject) of the coclass as well as the interface (specified by the IID IID_IMyObject) from that coclass that we want to use to interact with that coclass. Calling CoCreateInstance() like this:\n\nCoCreateInstance(CLSID_MyObject, NULL, CLSCTX_INPROC_SERVER, IID_IMyObject, (void**)&m_pIMyObject);\n\nis conceptually equivalent to the following C++ code:\n\nISomeInterface* pISomeInterface = new CSomeObject();\n\nIn the first case, the COM sub-system is used to obtain a pointer to an object that implements the IMyObject interface and coclass CLSID_MyObject's particular implementation of this interface is required. In the second case, an instance of a C++ class CSomeObject that implements the interface ISomeInterface is created.\n\nA coclass, then, is an object-oriented class in the COM world. The main feature of the coclass is that it is (1) binary in nature and consequently (2) programming language-independent.\n\nRegistry[]\n\nMain article: Windows Registry\n\nIn Windows, COM classes, interfaces and type libraries are listed by GUIDs in the registry, under HKEY_CLASSES_ROOT\\CLSID for classes and HKEY_CLASSES_ROOT\\Interface for interfaces. The COM libraries use the registry to locate either the correct local libraries for each COM object or the network location for a remote service.\n\nUnder the key HKCR\\clsid, the following are specified:\n\n-> Inprocserver32 = object is to be loaded into a process + Path to file/object and readable name\n\nHKCR\\interface: example: ISTREAM, IRPCSTUB, IMESSAGEFILTER connects to a CLSID. You can specify NUMMETHODS and PROXYSTUB(if web-object) HKCR\\typelib One or more CLSID can be grouped into type library. it contains parameters for linking in COM.\n\nThe rest of the info in the COM parts of the REGISTRY, is to give an application/object a CLSID.\n\nReference counting[]\n\nThe most fundamental COM interface of all, IUnknown (from which all COM interfaces must be derived), supports two main concepts: feature exploration through the QueryInterface method, and object lifetime management by including AddRef() and Release(). Reference counts and feature exploration apply to objects (not to each interface on an object) and thus must have a centralized implementation.\n\nThe COM specifications require a technique called reference counting to ensure that individual objects remain alive as long as there are clients which have acquired access to one or more of its interfaces and, conversely, that the same object is properly disposed of when all code that used the object have finished with it and no longer require it. A COM object is responsible for freeing its own memory once its reference count drops to zero.\n\nFor its implementation, a COM Object usually maintains an integer value that is used for reference counting. When AddRef() is called via any of object's interfaces, this integer value is incremented. When Release() is called, this integer is decremented. AddRef() and Release() are the only means by which a client of a COM object is able to influence its lifetime. The internal integer value remains a private member of the COM object and will never be directly accessible.\n\nThe purpose of AddRef() is to indicate to the COM object that an additional reference to itself has been affected and hence it is necessary to remain alive as long as this reference is still valid. Conversely, the purpose of Release() is to indicate to the COM object that a client (or a part of the client's code) has no further need for it and hence if this reference count has dropped to zero, it may be time to destroy itself.\n\nCertain languages (e.g. Visual Basic) provide automatic reference counting so that COM object developers need not explicitly maintain any internal reference counter in their source codes. Using COM in C, explicit reference counting is needed. In C++, a coder may write the reference counting code or use a smart pointer that will manage all the reference counting.\n\nThe following is a general guideline calling AddRef() and Release() to facilitate proper reference counting in COM object:\n\nFunctions (whether object methods or global functions) that return interface references (via return value or via \"out\" parameter) should increment the reference count of the underlying object before returning. Hence internally within the function or method, AddRef() is called on the interface reference (to be returned). An example of this is the QueryInterface() method of the IUnknown interface. Hence it is imperative that developers be aware that the returned interface reference has already been reference count incremented and not call AddRef() on the returned interface reference yet another time.\n\nRelease() must be called on an interface reference before that interface's pointer is overwritten or goes out of scope.\n\nIf a copy is made on an interface reference pointer, AddRef() should be called on that pointer. After all, in this case, we are actually creating another reference on the underlying object.\n\nAddRef() and Release() must be called on the specific interface which is being referenced since an object may implement per-interface reference counts in order to allocate internal resources only for the interfaces which are being referenced.\n\nExtra calls to these functions are not sent out to remote objects over the wire; a proxy keeps only one reference on the remote object and maintains its own local reference count.\n\nTo facilitate and promote COM development, Microsoft introduced ATL (Active Template Library) for C++ developers. ATL provides for a higher-level COM development paradigm. It also shields COM client application developers from the need to directly maintain reference counting, by providing smart pointer objects.\n\nOther libraries and languages that are COM-aware include the Microsoft Foundation Classes, the Compiler COM Support, VBScript, Visual Basic, ECMAScript (JavaScript) and Borland Delphi.\n\nInstantiation[]\n\nCOM standardizes the instantiation (i.e. creation) process of COM objects by requiring the use of Class Factories. In order for a COM object to be created, two associated items must exist:\n\nA Class ID.\n\nA Class Factory.\n\nEach COM Class or CoClass must be associated with a unique Class ID (a GUID). It must also be associated with its own Class Factory (that is achieved by using a centralized registry). A Class Factory is itself a COM object. It is an object that must expose the IClassFactory or IClassFactory2 (the latter with licensing support) interface. The responsibility of such an object is to create other objects.\n\nA class factory object is usually contained within the same executable code (i.e. the server code) as the COM object itself. When a class factory is called upon to create a target object, this target object's class id must be provided. This is how the class factory knows which class of object to instantiate.\n\nA single class factory object may create objects of more than one class. That is, two objects of different class ids may be created by the same class factory object. However, this is transparent to the COM system.\n\nBy delegating the responsibility of object creation into a separate object, a greater level of abstraction is promoted, and the developer is given greater flexibility. For example, implementation of the Singleton and other creation patterns is facilitated. Also, the calling application is shielded from the COM object's memory allocation semantics by the factory object.\n\nIn order for client applications to be able to acquire class factory objects, COM servers must properly expose them. A class factory is exposed differently, depending on the nature of the server code. A server which is DLL-based must export a DllGetClassObject() global function. A server which is EXE-based registers the class factory at runtime via the CoRegisterClassObject() Windows API function.\n\nThe following is a general outline of the sequence of object creation via its class factory:\n\nThe object's class factory is obtained via the CoGetClassObject() API (a standard Windows API).\n\nAs part of the call to CoGetClassObject(), the Class ID of the object (to be created) must be supplied. The following C++ code demonstrates this:\n\nIClassFactory* pIClassFactory = NULL; CoGetClassObject(CLSID_SomeObject, CLSCTX_ALL, NULL, IID_IClassFactory, (LPVOID*)&pIClassFactory);\n\nThe above code indicates that the Class Factory object of a COM object, which is identified by the class id CLSID_SomeObject, is required. This class factory object is returned by way of its IClassFactory interface.\n\nThe returned class factory object is then requested to create an instance of the originally intended COM object. The following C++ code demonstrates this:\n\nISomeObject* pISomeObject = NULL; if (pIClassFactory) { pIClassFactory->CreateInstance (NULL, IID_ISomeObject, (LPVOID*)&pISomeObject); pIClassFactory->Release(); pIClassFactory = NULL; }\n\nThe above code indicates the use of the Class Factory object's CreateInstance() method to create an object which exposes an interface identified by the IID_ISomeObject GUID. A pointer to the ISomeObject interface of this object is returned. Also note that because the class factory object is itself a COM object, it needs to be released when it is no longer required (i.e. its Release() method must be called).\n\nThe above demonstrates, at the most basic level, the use of a class factory to instantiate an object. Higher level constructs are also available, some of which do not even involve direct use of the Windows APIs.\n\nFor example, the CoCreateInstance() API can be used by an application to directly create a COM object without acquiring the object's class factory. However, internally, the CoCreateInstance() API itself will invoke the CoGetClassObject() API to obtain the object's class factory and then use the class factory's CreateInstance() method to create the COM object.\n\nVBScript supplies the New keyword as well as the CreateObject() global function for object instantiation. These language constructs encapsulate the acquisition of the class factory object of the target object (via the CoGetClassObject() API) followed by the invocation of the IClassFactory::CreateInstance() method.\n\nOther languages, e.g. PowerBuilder's PowerScript may also provide their own high-level object creation constructs. However, CoGetClassObject() and the IClassFactory interface remain the most fundamental object creation technique.\n\nReflection[]\n\nSee also: reflection (computer science)\n\nAt the time of the inception of COM technologies, the only way for a client to find out what features an object would offer was to actually create one instance and call into its QueryInterface method (part of the required IUnknown interface). This way of exploration became awkward for many applications, including the selection of appropriate components for a certain task, and tools to help a developer understand how to use methods provided by an object.\n\nAs a result, COM Type Libraries were introduced, through which components can describe themselves. A type library contains information such as the CLSID of a component, the IIDs of the interfaces the component implements, and descriptions of each of the methods of those interfaces. Type libraries are typically used by Rapid Application Development (RAD) environments such as Visual Basic or Visual Studio to assist developers of client applications.\n\nProgramming[]\n\nCOM is a binary standard (also said to be language agnostic) and may be developed in any programming language capable of understanding and implementing its binary defined data types and interfaces.\n\nRuntime libraries (in extreme situations, the programmers) are responsible for entering and leaving the COM environment, instantiating and reference counting COM objects, querying objects for version information, coding to take advantage of advanced object versions, and coding graceful degradation of function when newer versions are not available.\n\nApplication and network transparency[]\n\nCOM objects may be instantiated and referenced from within a process, across process boundaries within a computer, and across a network, using the DCOM technology. Out-of-process and remote objects may use marshalling to send method calls and return values back and forth. The marshalling is invisible to the object and the code using the object.\n\nThreading in COM[]\n\nIn COM, threading issues are addressed by a concept known as \"apartment models\". Here the term \"apartment\" refers to an execution context wherein a single thread or a group of threads is associated with one or more COM objects.\n\nApartments stipulate the following general guidelines for participating threads and objects:\n\nEach COM object is associated with one and only one apartment. This is decided at the time the object is created at runtime. After this initial setup, the object remains in that apartment throughout its lifetime.\n\nA COM thread (i.e., a thread in which COM objects are created or COM method calls are made) is also associated with an apartment. Like COM objects, the apartment with which a thread is associated is also decided at initialization time. Each COM thread also remains in its designated apartment until it terminates.\n\nThreads and objects which belong to the same apartment are said to follow the same thread access rules. Method calls which are made inside the same apartment are performed directly without any assistance from COM.\n\nThreads and objects from different apartments are said to play by different thread access rules. Method calls made across apartments are achieved via marshalling. This requires the use of proxies and stubs.\n\nThere are three types of Apartment Models in the COM world: Single-Threaded Apartment (STA), Multi-Threaded Apartment (MTA), and Neutral Apartment. Each apartment represents one mechanism whereby an object's internal state may be synchronized across multiple threads.\n\nThe Single-Threaded Apartment (STA) model is a very commonly used model. Here, a COM object stands in a position similar to a desktop application's user interface. In an STA model, a single thread is dedicated to drive an object's methods, i.e. a single thread is always used to execute the methods of the object. In such an arrangement, method calls from threads outside of the apartment are marshalled and automatically queued by the system (via a standard Windows message queue). Thus, there is no worry about race conditions or lack of synchronicity because each method call of an object is always executed to completion before another is invoked.\n\nIf the COM object's methods perform their own synchronization, multiple threads dedicated to calling methods on the COM object are permitted. This is termed the Multiple Threaded Apartment (MTA). Calls to an MTA object from a thread in an STA are also marshaled. A process can consist of multiple COM objects, some of which may use STA and others of which may use MTA. The Thread Neutral Apartment allows different threads, none of which is necessarily dedicated to calling methods on the object, to make such calls. The only provision is that all methods on the object must be serially reentrant.\n\nCriticisms[]\n\nSince COM has a fairly complex implementation, programmers can be distracted by some of the \"plumbing\" issues.\n\nMessage pumping[]\n\nWhen an STA is initialized it creates a hidden window that is used for inter-apartment and inter-process message routing. This window must have its message queue regularly pumped. This construct is known as a message pump. On earlier versions of Windows, failure to do so could cause system-wide deadlocks. This problem is especially nasty because some Windows APIs initialize COM as part of their implementation, which causes a leak of implementation details.\n\nReference counting[]\n\nReference counting within COM may cause problems if two or more objects are circularly referenced. The design of an application must take this into account so that objects are not left orphaned.\n\nObjects may also be left with active reference counts if the COM \"event sink\" model is used. Since the object that fires the event needs a reference to the object reacting to the event, the object's reference count will never reach zero.\n\nReference cycles are typically broken using either out-of-band termination or split identities. In the out of band termination technique, an object exposes a method which, when called, forces it to drop its references to other objects, thereby breaking the cycle. In the split identity technique, a single implementation exposes two separate COM objects (also known as identities). This creates a weak reference between the COM objects, preventing a reference cycle.\n\nDLL hell[]\n\nMain article: DLL hell\n\nBecause the location of each component is stored in a system-wide location (the Windows registry), there can be only one version of a certain component installed. This limitation can seriously complicate the deployment of COM-based applications, due to the possibility that different programs, or even different versions of the same program, may be designed to work with different versions of the same COM component. This condition is known as DLL hell. While this condition has been known to occur with OS components, it is generally a condition created by application developers in the use of their own components. The problem can be reduced or eliminated completely by careful software versioning and regression testing.\n\nWindows XP introduced a new mode of COM object registration called \"Registration-free COM\". This facility makes it possible for applications that need to install COM objects to store all the required COM registry information in the application's directory, instead of in the global registry, so that, strictly speaking, only that application will ever see/use it. DLL hell can be substantially avoided using Registration-free COM, the only limitation being it requires at least Windows XP or later Windows versions and that it must not be used for EXE COM servers or system-wide components such as MDAC, MSXML, DirectX or Internet Explorer.\n\nRegFree COM[]\n\nRegFree COM (or Registration-Free COM) is a technology introduced with Windows XP that allows Component Object Model (COM) components to store activation metadata and CLSID (Class ID) for the component without using the registry. Instead, the metadata and CLSIDs of the classes implemented in the component are declared in an assembly manifest (described using XML), stored either as a resource in the executable or as a separate file installed with the component.[4] This allows multiple versions of the same component to be installed in different directories, described by their own manifests, as well as XCOPY deployment.[5]\n\nDuring application loading, the Windows loader searches for the manifest.[6] If it is present, the loader adds information from it to the activation context [5] When the COM class factory tries to instantiate a class, the activation context is first checked to see if an implementation for the CLSID can be found. Only if the lookup fails is the registry scanned.[5]\n\nSee also[]\n\nPortable object (computing) cross language cross platform Object Model definition\n\nDCOM Distributed COM, extension making COM able to work in networks\n\nCommon Language Infrastructure current .Net cross language cross platform Object Model\n\nCORBA Common Object Request Broker Architecture, open cross language cross platform object model\n\nFreedesktop.org D-Bus current open cross language cross platform Object Model\n\nGNOME Bonobo deprecated GNOME cross language Object Model\n\nKDE DCOP deprecated KDE interprocess and software componentry communication system\n\nKDE KPart deprecated KDE component framework\n\nXPCOM Mozilla applications cross Platform Component Object Model\n\nIBM System Object Model SOM, a component system from IBM used in OS/2\n\nJava Beans\n\nJava Remote Method Invocation\n\nInternet Communications Engine\n\nLanguage binding\n\nForeign function interface\n\nCalling convention\n\nName mangling\n\nApplication programming interface - API\n\nApplication Binary Interface - ABI\n\nComparison of application virtual machines\n\nSWIG opensource automatic interfaces bindings generator from many languages to many languages\n\nReferences[]\n\n\"COM: A Brief Introduction (powerpoint)\" .\n\nBox, Don (1998). Essential COM. Addison-Wesley. ISBN 0-201-63446-5.\n\nChappell, David (1996). Understanding ActiveX and OLE. Microsoft Press. ISBN 978-1572312166.\n\n\"Integration and Migration of COM+ services to WCF\" .\n\n[]\n\nMicrosoft COM Technologies\n\nInterview with Tony Williams, Co-Inventor of COM (Video Webcast, August 2006)\n\nA concise technical overview of COM from master's thesis\n\nInfo: Difference Between OLE Controls and ActiveX Controls from Microsoft\n\nTypeLib Data Format Specification (unofficial) with open source dumper utility.\n\nThe COM / DCOM Glossary"
    }
}