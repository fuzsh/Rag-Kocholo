{
    "id": "dbpedia_2184_0",
    "rank": 93,
    "data": {
        "url": "https://www.cs.usfca.edu/~sjengle/cs212/javadoc/mysql/innodb-storage-engine.html",
        "read_more_link": "",
        "language": "en",
        "title": "Chapter 14 The InnoDB Storage Engine",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "ignore_builtin_innodb\n\nDeprecated5.5.22Command-Line Format--ignore-builtin-innodbSystem Variable Nameignore_builtin_innodbVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypeboolean\n\nSee the description of --ignore-builtin-innodb under “InnoDB Command Options” earlier in this section.\n\ninnodb_adaptive_flushing\n\nCommand-Line Format--innodb_adaptive_flushing=#System Variable Nameinnodb_adaptive_flushingVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypebooleanDefaultON\n\nSpecifies whether to dynamically adjust the rate of flushing dirty pages in the InnoDB buffer pool based on the workload. Adjusting the flush rate dynamically is intended to avoid bursts of I/O activity. This setting is enabled by default. See Section 14.16.2.2, “Configuring the Rate of InnoDB Buffer Pool Flushing” for more information. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_adaptive_hash_index\n\nCommand-Line Format--innodb_adaptive_hash_index=#System Variable Nameinnodb_adaptive_hash_indexVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypebooleanDefaultON\n\nWhether the InnoDB adaptive hash index is enabled or disabled. It may be desirable, depending on your workload, to dynamically enable or disable adaptive hash indexing to improve query performance. Because the adaptive hash index may not be useful for all workloads, conduct benchmarks with it both enabled and disabled, using realistic workloads. See Section 14.5.13.5, “Adaptive Hash Indexes” for details.\n\nThis variable is enabled by default. As of MySQL 5.5, You can modify this parameter using the SET GLOBAL statement, without restarting the server. Changing the setting requires the SUPER privilege. You can also use --skip-innodb_adaptive_hash_index at server startup to disable it.\n\nDisabling the adaptive hash index empties the hash table immediately. Normal operations can continue while the hash table is emptied, and executing queries that were using the hash table access the index B-trees directly instead. When the adaptive hash index is re-enabled, the hash table is populated again during normal operation.\n\ninnodb_additional_mem_pool_size\n\nCommand-Line Format--innodb_additional_mem_pool_size=#System Variable Nameinnodb_additional_mem_pool_sizeVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault8388608Min Value2097152Max Value4294967295\n\nThe size in bytes of a memory pool InnoDB uses to store data dictionary information and other internal data structures. The more tables you have in your application, the more memory you need to allocate here. If InnoDB runs out of memory in this pool, it starts to allocate memory from the operating system and writes warning messages to the MySQL error log. The default value is 8MB.\n\nThis variable relates to the InnoDB internal memory allocator, which is unused if innodb_use_sys_malloc is enabled.\n\ninnodb_autoextend_increment\n\nCommand-Line Format--innodb_autoextend_increment=#System Variable Nameinnodb_autoextend_incrementVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault64Min Value1Max Value1000\n\nThe increment size (in MB) for extending the size of an auto-extending system tablespace file when it becomes full. The default value is 8. This variable does not affect the per-table tablespace files that are created if you use innodb_file_per_table=1. Those files are auto-extending regardless of the value of innodb_autoextend_increment. The initial extensions are by small amounts, after which extensions occur in increments of 4MB.\n\ninnodb_autoinc_lock_mode\n\nCommand-Line Format--innodb_autoinc_lock_mode=#System Variable Nameinnodb_autoinc_lock_modeVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault1Valid Values012\n\nThe lock mode to use for generating auto-increment values. The permissible values are 0, 1, or 2, for “traditional”, “consecutive”, or “interleaved” lock mode, respectively. Section 14.9.5, “AUTO_INCREMENT Handling in InnoDB”, describes the characteristics of these modes.\n\nThis variable has a default of 1 (“consecutive” lock mode).\n\ninnodb_buffer_pool_instances\n\nIntroduced5.5.4Command-Line Format--innodb_buffer_pool_instances=#System Variable Nameinnodb_buffer_pool_instancesVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault1Min Value1Max Value64\n\nThe number of regions that the InnoDB buffer pool is divided into. For systems with buffer pools in the multi-gigabyte range, dividing the buffer pool into separate instances can improve concurrency, by reducing contention as different threads read and write to cached pages. Each page that is stored in or read from the buffer pool is assigned to one of the buffer pool instances randomly, using a hashing function. Each buffer pool manages its own free lists, flush lists, LRUs, and all other data structures connected to a buffer pool, and is protected by its own buffer pool mutex.\n\nThis option takes effect only when you set the innodb_buffer_pool_size to a size of 1GB or more. The total size you specify is divided among all the buffer pools. For best efficiency, specify a combination of innodb_buffer_pool_instances and innodb_buffer_pool_size so that each buffer pool instance is at least 1GB.\n\ninnodb_buffer_pool_size\n\nCommand-Line Format--innodb_buffer_pool_size=#System Variable Nameinnodb_buffer_pool_sizeVariable ScopeGlobalDynamic VariableNoPermitted ValuesPlatform Bit Size32TypenumericDefault134217728Min Value5242880Max Value2**32-1Permitted ValuesPlatform Bit Size64TypenumericDefault134217728Min Value5242880Max Value2**64-1\n\nThe size in bytes of the buffer pool, the memory area where InnoDB caches table and index data. The default value is 128MB. The maximum value depends on the CPU architecture; the maximum is 4294967295 (232-1) on 32-bit systems and 18446744073709551615 (264-1) on 64-bit systems. On 32-bit systems, the CPU architecture and operating system may impose a lower practical maximum size than the stated maximum. When the size of the buffer pool is greater than 1GB, setting innodb_buffer_pool_instances to a value greater than 1 can improve the scalability on a busy server.\n\nThe larger you set this value, the less disk I/O is needed to access the same data in tables more than once. On a dedicated database server, you might set this to up to 80% of the machine physical memory size. Be prepared to scale back this value if these other issues occur:\n\nCompetition for physical memory might cause paging in the operating system.\n\nInnoDB reserves additional memory for buffers and control structures, so that the total allocated space is approximately 10% greater than the specified size.\n\nThe address space must be contiguous, which can be an issue on Windows systems with DLLs that load at specific addresses.\n\nThe time to initialize the buffer pool is roughly proportional to its size. On large installations, this initialization time might be significant. For example, on a modern Linux x86_64 server, initialization of a 10GB buffer pool takes approximately 6 seconds. See Section 8.9.1, “The InnoDB Buffer Pool”.\n\ninnodb_change_buffering\n\nCommand-Line Format--innodb_change_buffering=#System Variable Nameinnodb_change_bufferingVariable ScopeGlobalDynamic VariableYesPermitted Values (<= 5.5.3)TypeenumerationDefaultinsertsValid ValuesinsertsnonePermitted Values (>= 5.5.4)TypeenumerationDefaultallValid Valuesinsertsdeletespurgeschangesallnone\n\nWhether InnoDB performs change buffering, an optimization that delays write operations to secondary indexes so that the I/O operations can be performed sequentially. The permitted values are inserts (buffer insert operations), deletes (buffer delete operations; strictly speaking, the writes that mark index records for later deletion during a purge operation), changes (buffer insert and delete-marking operations), purges (buffer purge operations, the writes when deleted index entries are finally garbage-collected), all (buffer insert, delete-marking, and purge operations) and none (do not buffer any operations). The default is all. For details, see Section 14.16.5, “Configuring InnoDB Change Buffering”.\n\ninnodb_checksums\n\nCommand-Line Format--innodb_checksumsSystem Variable Nameinnodb_checksumsVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultON\n\nInnoDB can use checksum validation on all pages read from the disk to ensure extra fault tolerance against broken hardware or data files. This validation is enabled by default. However, under some rare circumstances (such as when running benchmarks) this extra safety feature is unneeded and can be disabled with --skip-innodb-checksums.\n\ninnodb_commit_concurrency\n\nCommand-Line Format--innodb_commit_concurrency=#System Variable Nameinnodb_commit_concurrencyVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault0Min Value0Max Value1000\n\nThe number of threads that can commit at the same time. A value of 0 (the default) permits any number of transactions to commit simultaneously.\n\nThe value of innodb_commit_concurrency cannot be changed at runtime from zero to nonzero or vice versa. The value can be changed from one nonzero value to another.\n\ninnodb_concurrency_tickets\n\nCommand-Line Format--innodb_concurrency_tickets=#System Variable Nameinnodb_concurrency_ticketsVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault500Min Value1Max Value4294967295\n\nDetermines the number of threads that can enter InnoDB concurrently. A thread is placed in a queue when it tries to enter InnoDB if the number of threads has already reached the concurrency limit. When a thread is permitted to enter InnoDB, it is given a number of “free tickets” equal to the value of innodb_concurrency_tickets, and the thread can enter and leave InnoDB freely until it has used up its tickets. After that point, the thread again becomes subject to the concurrency check (and possible queuing) the next time it tries to enter InnoDB. The default value is 500.\n\ninnodb_data_file_path\n\nCommand-Line Format--innodb_data_file_path=nameSystem Variable Nameinnodb_data_file_pathVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypestringDefaultibdata1:10M:autoextend\n\nThe paths to individual InnoDB data files and their sizes. The full directory path to each data file is formed by concatenating innodb_data_home_dir to each path specified here. The file sizes are specified KB, MB or GB (1024MB) by appending K, M or G to the size value. If specifying data file size in kilobytes (KB), do so in multiples of 1024. Otherwise, KB values are rounded off to nearest megabyte (MB) boundary. The sum of the sizes of the files must be at least slightly larger than 10MB. If you do not specify innodb_data_file_path, the default behavior is to create a single auto-extending data file, slightly larger than 10MB, named ibdata1. The size limit of individual files is determined by your operating system. You can set the file size to more than 4GB on those operating systems that support big files. You can also use raw disk partitions as data files. For detailed information on configuring InnoDB tablespace files, see Section 14.6, “InnoDB Configuration”.\n\ninnodb_data_home_dir\n\nCommand-Line Format--innodb_data_home_dir=pathSystem Variable Nameinnodb_data_home_dirVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypedirectory name\n\nThe common part of the directory path for all InnoDB data files in the system tablespace. This setting does not affect the location of file-per-table tablespaces when innodb_file_per_table is enabled. The default value is the MySQL data directory. If you specify the value as an empty string, you can use absolute file paths in innodb_data_file_path.\n\ninnodb_doublewrite\n\nCommand-Line Format--innodb-doublewriteSystem Variable Nameinnodb_doublewriteVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultON\n\nIf this variable is enabled (the default), InnoDB stores all data twice, first to the doublewrite buffer, and then to the actual data files. This variable can be turned off with --skip-innodb_doublewrite for benchmarks or cases when top performance is needed rather than concern for data integrity or possible failures.\n\ninnodb_fast_shutdown\n\nCommand-Line Format--innodb_fast_shutdown[=#]System Variable Nameinnodb_fast_shutdownVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault1Valid Values012\n\nThe InnoDB shutdown mode. If the value is 0, InnoDB does a slow shutdown, a full purge and an insert buffer merge before shutting down. If the value is 1 (the default), InnoDB skips these operations at shutdown, a process known as a fast shutdown. If the value is 2, InnoDB flushes its logs and shuts down cold, as if MySQL had crashed; no committed transactions are lost, but the crash recovery operation makes the next startup take longer.\n\nThe slow shutdown can take minutes, or even hours in extreme cases where substantial amounts of data are still buffered. Use the slow shutdown technique before upgrading or downgrading between MySQL major releases, so that all data files are fully prepared in case the upgrade process updates the file format.\n\nUse innodb_fast_shutdown=2 in emergency or troubleshooting situations, to get the absolute fastest shutdown if data is at risk of corruption.\n\ninnodb_file_format\n\nCommand-Line Format--innodb_file_format=#System Variable Nameinnodb_file_formatVariable ScopeGlobalDynamic VariableYesPermitted Values (<= 5.5.6)TypestringDefaultBarracudaValid ValuesAntelopeBarracudaPermitted Values (>= 5.5.7)TypestringDefaultAntelopeValid ValuesAntelopeBarracuda\n\nThe file format to use for new InnoDB tables. Currently, Antelope and Barracuda are supported. This applies only for tables that have their own tablespace, so for it to have an effect, innodb_file_per_table must be enabled. The Barracuda file format is required for certain InnoDB features such as table compression.\n\nBe aware that ALTER TABLE operations that recreate InnoDB tables (ALTER OFFLINE) will use the current innodb_file_format setting (the conditions outlined above still apply).\n\ninnodb_file_format_check\n\nCommand-Line Format--innodb_file_format_check=#System Variable Nameinnodb_file_format_checkVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypestringDefaultAntelopePermitted Values (>= 5.5.1)TypestringDefaultBarracudaPermitted Values (>= 5.5.5)TypebooleanDefaultON\n\nAs of MySQL 5.5.5, this variable can be set to 1 or 0 at server startup to enable or disable whether InnoDB checks the file format tag in the system tablespace (for example, Antelope or Barracuda). If the tag is checked and is higher than that supported by the current version of InnoDB, an error occurs and InnoDB does not start. If the tag is not higher, InnoDB sets the value of innodb_file_format_max to the file format tag.\n\nBefore MySQL 5.5.5, this variable can be set to 1 or 0 at server startup to enable or disable whether InnoDB checks the file format tag in the shared tablespace. If the tag is checked and is higher than that supported by the current version of InnoDB, an error occurs and InnoDB does not start. If the tag is not higher, InnoDB sets the value of innodb_file_format_check to the file format tag, which is the value seen at runtime.\n\nNote\n\nDespite the default value sometimes being displayed as ON or OFF, always use the numeric values 1 or 0 to turn this option on or off in your configuration file or command line.\n\ninnodb_file_format_max\n\nIntroduced5.5.5Command-Line Format--innodb_file_format_max=#System Variable Nameinnodb_file_format_maxVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypestringDefaultAntelopeValid ValuesAntelopeBarracuda\n\nAt server startup, InnoDB sets the value of this variable to the file format tag in the system tablespace (for example, Antelope or Barracuda). If the server creates or opens a table with a “higher” file format, it sets the value of innodb_file_format_max to that format.\n\nThis variable was added in MySQL 5.5.5.\n\ninnodb_file_per_table\n\nCommand-Line Format--innodb_file_per_tableSystem Variable Nameinnodb_file_per_tableVariable ScopeGlobalDynamic VariableYesPermitted Values (<= 5.5.6)TypebooleanDefaultONPermitted Values (>= 5.5.7)TypebooleanDefaultOFF\n\nWhen innodb_file_per_table is disabled, InnoDB stores the data for all tables and indexes in the ibdata files that make up the system tablespace. This setting reduces the performance overhead of filesystem operations for operations such as DROP TABLE or TRUNCATE TABLE. It is most appropriate for a server environment where entire storage devices are devoted to MySQL data. Because the system tablespace never shrinks, and is shared across all databases in an instance, avoid loading huge amounts of temporary data on a space-constrained system when innodb_file_per_table=OFF. Set up a separate instance in such cases, so that you can drop the entire instance to reclaim the space.\n\nWhen innodb_file_per_table is enabled, InnoDB stores data and indexes for each newly created table in a separate .ibd file, rather than in the system tablespace. The storage for these InnoDB tables is reclaimed when the tables are dropped or truncated. This setting enables several other InnoDB features, such as table compression. See Section 14.8.2, “InnoDB File-Per-Table Mode” for details about such features as well as advantages and disadvantages of using file-per-table tablespaces.\n\nBe aware that enabling innodb_file_per_table also means that an ALTER TABLE operation will move InnoDB table from the system tablespace to an individual .ibd file in cases where ALTER TABLE recreates the table (ALTER OFFLINE).\n\nIn MySQL 5.5 and higher, the configuration parameter innodb_file_per_table is dynamic, and can be set ON or OFF using SET GLOBAL. Previously, the only way to set this parameter was in the MySQL configuration file (my.cnf or my.ini), and changing it required shutting down and restarting the server.\n\nDynamically changing the value of this parameter requires the SUPER privilege and immediately affects the operation of all connections.\n\ninnodb_flush_log_at_trx_commit\n\nCommand-Line Format--innodb_flush_log_at_trx_commit[=#]System Variable Nameinnodb_flush_log_at_trx_commitVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypeenumerationDefault1Valid Values012\n\nControls the balance between strict ACID compliance for commit operations, and higher performance that is possible when commit-related I/O operations are rearranged and done in batches. You can achieve better performance by changing the default value, but then you can lose up to a second of transactions in a crash.\n\nThe default value of 1 is required for full ACID compliance. With this value, the contents of the InnoDB log buffer are written out to the log file at each transaction commit and the log file is flushed to disk.\n\nWith a value of 0, the contents of the InnoDB log buffer are written to the log file approximately once per second and the log file is flushed to disk. No writes from the log buffer to the log file are performed at transaction commit. Once-per-second flushing is not 100% guaranteed to happen every second, due to process scheduling issues. Because the flush to disk operation only occurs approximately once per second, you can lose up to a second of transactions with any mysqld process crash.\n\nWith a value of 2, the contents of the InnoDB log buffer are written to the log file after each transaction commit and the log file is flushed to disk approximately once per second. Once-per-second flushing is not 100% guaranteed to happen every second, due to process scheduling issues. Because the flush to disk operation only occurs approximately once per second, you can lose up to a second of transactions in an operating system crash or a power outage.\n\nInnoDB's crash recovery works regardless of the value. Transactions are either applied entirely or erased entirely.\n\nFor the greatest possible durability and consistency in a replication setup using InnoDB with transactions, use innodb_flush_log_at_trx_commit=1 and sync_binlog=1 in your master server my.cnf file.\n\nCaution\n\nMany operating systems and some disk hardware fool the flush-to-disk operation. They may tell mysqld that the flush has taken place, even though it has not. Then the durability of transactions is not guaranteed even with the setting 1, and in the worst case a power outage can even corrupt InnoDB data. Using a battery-backed disk cache in the SCSI disk controller or in the disk itself speeds up file flushes, and makes the operation safer. You can also try using the Unix command hdparm to disable the caching of disk writes in hardware caches, or use some other command specific to the hardware vendor.\n\ninnodb_flush_method\n\nCommand-Line Format--innodb_flush_method=nameSystem Variable Nameinnodb_flush_methodVariable ScopeGlobalDynamic VariableNoPermitted ValuesType (Windows)stringDefaultasync_unbufferedPermitted ValuesType (Unix)stringDefaultfsyncValid ValuesfsyncO_DSYNCO_DIRECT\n\nDefines the method used to flush data to the InnoDB data files and log files, which can affect I/O throughput. This variable is only configurable on Unix and Linux systems. On Windows systems, the flush method is always async_unbuffered and cannot be changed.\n\nThe innodb_flush_method options include:\n\nfsync: InnoDB uses the fsync() system call to flush both the data and log files. fsync is the default setting.\n\nO_DSYNC: InnoDB uses O_SYNC to open and flush the log files, and fsync() to flush the data files. InnoDB does not use O_DSYNC directly because there have been problems with it on many varieties of Unix.\n\nO_DIRECT: InnoDB uses O_DIRECT (or directio() on Solaris) to open the data files, and uses fsync() to flush both the data and log files. This option is available on some GNU/Linux versions, FreeBSD, and Solaris.\n\nHow each settings affects performance depends on hardware configuration and workload. Benchmark your particular configuration to decide which setting to use, or whether to keep the default setting. Examine the Innodb_data_fsyncs status variable to see the overall number of fsync() calls for each setting. The mix of read and write operations in your workload can affect how a setting performs. For example, on a system with a hardware RAID controller and battery-backed write cache, O_DIRECT can help to avoid double buffering between the InnoDB buffer pool and the operating system's file system cache. On some systems where InnoDB data and log files are located on a SAN, the default value or O_DSYNC might be faster for a read-heavy workload with mostly SELECT statements. Always test this parameter with hardware and workload that reflect your production environment. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\nPrior to MySQL 5.1.24, the default innodb_flush_method option was named fdatasync. When fdatasync was specified, InnoDB used the fsync() system call to flush both the data and log files. To avoid confusing the fdatasync option name with the fdatasync() system call, the option name was changed to fsync in MySQL 5.1.24.\n\ninnodb_force_load_corrupted\n\nIntroduced5.5.18Command-Line Format--innodb_force_load_corruptedSystem Variable Nameinnodb_force_load_corruptedVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultOFF\n\nLets InnoDB load tables at startup that are marked as corrupted. Use only during troubleshooting, to recover data that is otherwise inaccessible. When troubleshooting is complete, turn this setting back off and restart the server.\n\ninnodb_force_recovery\n\nCommand-Line Format--innodb_force_recovery=#System Variable Nameinnodb_force_recoveryVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault0Min Value0Max Value6\n\nThe crash recovery mode, typically only changed in serious troubleshooting situations. Possible values are from 0 to 6. For the meanings of these values and important information about innodb_force_recovery, see Section 14.21.2, “Forcing InnoDB Recovery”.\n\nWarning\n\nOnly set this variable to a value greater than 0 in an emergency situation, so that you can start InnoDB and dump your tables. As a safety measure, InnoDB prevents INSERT, UPDATE, or DELETE operations when innodb_force_recovery is greater than 0.\n\ninnodb_io_capacity\n\nCommand-Line Format--innodb_io_capacity=#System Variable Nameinnodb_io_capacityVariable ScopeGlobalDynamic VariableYesPermitted ValuesPlatform Bit Size32TypenumericDefault200Min Value100Max Value2**32-1Permitted ValuesPlatform Bit Size64TypenumericDefault200Min Value100Max Value2**64-1\n\nThe innodb_io_capacity parameter sets an upper limit on the I/O activity performed by the InnoDB background tasks, such as flushing pages from the buffer pool and merging data from the insert buffer. The default value is 200. For busy systems capable of higher I/O rates, you can set a higher value at server startup, to help the server handle the background maintenance work associated with a high rate of row changes. For systems with individual 5400 RPM or 7200 RPM drives, you might lower the value to the former default of 100.\n\nThe innodb_io_capacity limit is a total limit for all buffer pool instances. When dirty pages are flushed, the innodb_io_capacity limit is divided equally among buffer pool instances.\n\nThis parameter should be set to approximately the number of I/O operations that the system can perform per second. Ideally, keep this setting as low as practical, but not so low that these background activities fall behind. If the value is too high, data is removed from the buffer pool and insert buffer too quickly to provide significant benefit from the caching.\n\nThe value represents an estimated proportion of the I/O operations per second (IOPS) available to older-generation disk drives that could perform about 100 IOPS. The current default of 200 reflects that modern storage devices are capable of much higher I/O rates.\n\nIn general, you can increase the value as a function of the number of drives used for InnoDB I/O, particularly fast drives capable of high numbers of IOPS. For example, systems that use multiple disks or solid-state disks for InnoDB are likely to benefit from the ability to control this parameter.\n\nAlthough you can specify a very high number, in practice such large values have little if any benefit; for example, a value of one million would be considered very high.\n\nYou can set the innodb_io_capacity value to any number 100 or greater, and the default value is 200. You can set the value of this parameter in the MySQL option file (my.cnf or my.ini) or change it dynamically with the SET GLOBAL command, which requires the SUPER privilege.\n\nSee Section 14.16.9, “Configuring the InnoDB Master Thread I/O Rate” for more guidelines about this option. For general information about InnoDB I/O performance, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_large_prefix\n\nIntroduced5.5.14Command-Line Format--innodb_large_prefixSystem Variable Nameinnodb_large_prefixVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypebooleanDefaultOFF\n\nEnable this option to allow index key prefixes longer than 767 bytes (up to 3072 bytes), for InnoDB tables that use the DYNAMIC and COMPRESSED row formats. (Creating such tables also requires the option values innodb_file_format=barracuda and innodb_file_per_table=true.) See Section 14.9.7, “Limits on InnoDB Tables” for the relevant maximums associated with index key prefixes under various settings.\n\nFor tables using the REDUNDANT and COMPACT row formats, this option does not affect the allowed key prefix length. It does introduce a new error possibility. When this setting is enabled, attempting to create an index prefix with a key length greater than 3072 for a REDUNDANT or COMPACT table causes an ER_INDEX_COLUMN_TOO_LONG error.\n\ninnodb_lock_wait_timeout\n\nCommand-Line Format--innodb_lock_wait_timeout=#System Variable Nameinnodb_lock_wait_timeoutVariable ScopeGlobal, SessionDynamic VariableYesPermitted ValuesTypenumericDefault50Min Value1Max Value1073741824\n\nThe length of time in seconds an InnoDB transaction waits for a row lock before giving up. The default value is 50 seconds. A transaction that tries to access a row that is locked by another InnoDB transaction waits at most this many seconds for write access to the row before issuing the following error:\n\nERROR 1205 (HY000): Lock wait timeout exceeded; try restarting transaction\n\nWhen a lock wait timeout occurs, the current statement is rolled back (not the entire transaction). To have the entire transaction roll back, start the server with the --innodb_rollback_on_timeout option. See also Section 14.21.4, “InnoDB Error Handling”.\n\nYou might decrease this value for highly interactive applications or OLTP systems, to display user feedback quickly or put the update into a queue for processing later. You might increase this value for long-running back-end operations, such as a transform step in a data warehouse that waits for other large insert or update operations to finish.\n\ninnodb_lock_wait_timeout applies to InnoDB row locks only. A MySQL table lock does not happen inside InnoDB and this timeout does not apply to waits for table locks.\n\nThe lock wait timeout value does not apply to deadlocks, because InnoDB detects them immediately and rolls back one of the deadlocked transactions.\n\nAs of MySQL 5.5, innodb_lock_wait_timeout can be set at runtime with the SET GLOBAL or SET SESSION statement. Changing the GLOBAL setting requires the SUPER privilege and affects the operation of all clients that subsequently connect. Any client can change the SESSION setting for innodb_lock_wait_timeout, which affects only that client.\n\ninnodb_locks_unsafe_for_binlog\n\nCommand-Line Format--innodb_locks_unsafe_for_binlogSystem Variable Nameinnodb_locks_unsafe_for_binlogVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultOFF\n\nThis variable affects how InnoDB uses gap locking for searches and index scans. Normally, InnoDB uses an algorithm called next-key locking that combines index-row locking with gap locking. InnoDB performs row-level locking in such a way that when it searches or scans a table index, it sets shared or exclusive locks on the index records it encounters. Thus, the row-level locks are actually index-record locks. In addition, a next-key lock on an index record also affects the “gap” before that index record. That is, a next-key lock is an index-record lock plus a gap lock on the gap preceding the index record. If one session has a shared or exclusive lock on record R in an index, another session cannot insert a new index record in the gap immediately before R in the index order. See Section 14.5.6, “InnoDB Record, Gap, and Next-Key Locks”.\n\nBy default, the value of innodb_locks_unsafe_for_binlog is 0 (disabled), which means that gap locking is enabled: InnoDB uses next-key locks for searches and index scans. To enable the variable, set it to 1. This causes gap locking to be disabled: InnoDB uses only index-record locks for searches and index scans.\n\nEnabling innodb_locks_unsafe_for_binlog does not disable the use of gap locking for foreign-key constraint checking or duplicate-key checking.\n\nThe effect of enabling innodb_locks_unsafe_for_binlog is similar to but not identical to setting the transaction isolation level to READ COMMITTED:\n\nEnabling innodb_locks_unsafe_for_binlog is a global setting and affects all sessions, whereas the isolation level can be set globally for all sessions, or individually per session.\n\ninnodb_locks_unsafe_for_binlog can be set only at server startup, whereas the isolation level can be set at startup or changed at runtime.\n\nREAD COMMITTED therefore offers finer and more flexible control than innodb_locks_unsafe_for_binlog. For additional details about the effect of isolation level on gap locking, see Section 13.3.6, “SET TRANSACTION Syntax”.\n\nEnabling innodb_locks_unsafe_for_binlog may cause phantom problems because other sessions can insert new rows into the gaps when gap locking is disabled. Suppose that there is an index on the id column of the child table and that you want to read and lock all rows from the table having an identifier value larger than 100, with the intention of updating some column in the selected rows later:\n\nSELECT * FROM child WHERE id > 100 FOR UPDATE;\n\nThe query scans the index starting from the first record where id is greater than 100. If the locks set on the index records in that range do not lock out inserts made in the gaps, another session can insert a new row into the table. Consequently, if you were to execute the same SELECT again within the same transaction, you would see a new row in the result set returned by the query. This also means that if new items are added to the database, InnoDB does not guarantee serializability. Therefore, if innodb_locks_unsafe_for_binlog is enabled, InnoDB guarantees at most an isolation level of READ COMMITTED. (Conflict serializability is still guaranteed.) For additional information about phantoms, see Section 14.5.7, “Avoiding the Phantom Problem Using Next-Key Locking”.\n\nEnabling innodb_locks_unsafe_for_binlog has additional effects:\n\nFor UPDATE or DELETE statements, InnoDB holds locks only for rows that it updates or deletes. Record locks for nonmatching rows are released after MySQL has evaluated the WHERE condition. This greatly reduces the probability of deadlocks, but they can still happen.\n\nFor UPDATE statements, if a row is already locked, InnoDB performs a “semi-consistent” read, returning the latest committed version to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE. If the row matches (must be updated), MySQL reads the row again and this time InnoDB either locks it or waits for a lock on it.\n\nConsider the following example, beginning with this table:\n\nCREATE TABLE t (a INT NOT NULL, b INT) ENGINE = InnoDB; INSERT INTO t VALUES (1,2),(2,3),(3,2),(4,3),(5,2); COMMIT;\n\nIn this case, table has no indexes, so searches and index scans use the hidden clustered index for record locking (see Section 14.5.13.2, “Clustered and Secondary Indexes”).\n\nSuppose that one client performs an UPDATE using these statements:\n\nSET autocommit = 0; UPDATE t SET b = 5 WHERE b = 3;\n\nSuppose also that a second client performs an UPDATE by executing these statements following those of the first client:\n\nSET autocommit = 0; UPDATE t SET b = 4 WHERE b = 2;\n\nAs InnoDB executes each UPDATE, it first acquires an exclusive lock for each row, and then determines whether to modify it. If InnoDB does not modify the row and innodb_locks_unsafe_for_binlog is enabled, it releases the lock. Otherwise, InnoDB retains the lock until the end of the transaction. This affects transaction processing as follows.\n\nIf innodb_locks_unsafe_for_binlog is disabled, the first UPDATE acquires x-locks and does not release any of them:\n\nx-lock(1,2); retain x-lock x-lock(2,3); update(2,3) to (2,5); retain x-lock x-lock(3,2); retain x-lock x-lock(4,3); update(4,3) to (4,5); retain x-lock x-lock(5,2); retain x-lock\n\nThe second UPDATE blocks as soon as it tries to acquire any locks (because first update has retained locks on all rows), and does not proceed until the first UPDATE commits or rolls back:\n\nx-lock(1,2); block and wait for first UPDATE to commit or roll back\n\nIf innodb_locks_unsafe_for_binlog is enabled, the first UPDATE acquires x-locks and releases those for rows that it does not modify:\n\nx-lock(1,2); unlock(1,2) x-lock(2,3); update(2,3) to (2,5); retain x-lock x-lock(3,2); unlock(3,2) x-lock(4,3); update(4,3) to (4,5); retain x-lock x-lock(5,2); unlock(5,2)\n\nFor the second UPDATE, InnoDB does a “semi-consistent” read, returning the latest committed version of each row to MySQL so that MySQL can determine whether the row matches the WHERE condition of the UPDATE:\n\nx-lock(1,2); update(1,2) to (1,4); retain x-lock x-lock(2,3); unlock(2,3) x-lock(3,2); update(3,2) to (3,4); retain x-lock x-lock(4,3); unlock(4,3) x-lock(5,2); update(5,2) to (5,4); retain x-lock\n\ninnodb_log_buffer_size\n\nCommand-Line Format--innodb_log_buffer_size=#System Variable Nameinnodb_log_buffer_sizeVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault8388608Min Value262144Max Value4294967295\n\nThe size in bytes of the buffer that InnoDB uses to write to the log files on disk. The default value is 8MB. A large log buffer enables large transactions to run without a need to write the log to disk before the transactions commit. Thus, if you have transactions that update, insert, or delete many rows, making the log buffer larger saves disk I/O. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_log_file_size\n\nCommand-Line Format--innodb_log_file_size=#System Variable Nameinnodb_log_file_sizeVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault5242880Min Value1048576Max Value4GB / innodb_log_files_in_group\n\nThe size in bytes of each log file in a log group. The combined size of log files (innodb_log_file_size * innodb_log_files_in_group) cannot exceed a maximum value that is slightly less than 4GB. A pair of 2047 MB log files, for example, would allow you to approach the range limit but not exceed it. The default value is 5MB. Sensible values range from 1MB to 1/N-th of the size of the buffer pool, where N is the number of log files in the group. The larger the value, the less checkpoint flush activity is needed in the buffer pool, saving disk I/O. Larger log files also make crash recovery slower, although improvements to recovery performance in MySQL 5.5 and higher make the log file size less of a consideration. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_log_files_in_group\n\nCommand-Line Format--innodb_log_files_in_group=#System Variable Nameinnodb_log_files_in_groupVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault2Min Value2Max Value100\n\nThe number of log files in the log group. InnoDB writes to the files in a circular fashion. The default (and recommended) value is 2. The location of these files is specified by innodb_log_group_home_dir.\n\ninnodb_log_group_home_dir\n\nCommand-Line Format--innodb_log_group_home_dir=pathSystem Variable Nameinnodb_log_group_home_dirVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypedirectory name\n\nThe directory path to the InnoDB redo log files, whose number is specified by innodb_log_files_in_group. If you do not specify any InnoDB log variables, the default is to create two files named ib_logfile0 and ib_logfile1 in the MySQL data directory. Their size is given by the size of the innodb_log_file_size system variable.\n\ninnodb_max_dirty_pages_pct\n\nCommand-Line Format--innodb_max_dirty_pages_pct=#System Variable Nameinnodb_max_dirty_pages_pctVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault75Min Value0Max Value99\n\nInnoDB tries to flush data from the buffer pool so that the percentage of dirty pages does not exceed this value. Specify an integer in the range from 0 to 99. The default value is 75.\n\nFor additional information about this variable, see Section 14.16.2.2, “Configuring the Rate of InnoDB Buffer Pool Flushing”. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_max_purge_lag\n\nCommand-Line Format--innodb_max_purge_lag=#System Variable Nameinnodb_max_purge_lagVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault0Min Value0Max Value4294967295\n\nThis variable controls how to delay INSERT, UPDATE, and DELETE operations when purge operations are lagging (see Section 14.5.12, “InnoDB Multi-Versioning”). The default value is 0 (no delays).\n\nThe InnoDB transaction system maintains a list of transactions that have index records delete-marked by UPDATE or DELETE operations. The length of this list represents the purge_lag value. When purge_lag exceeds innodb_max_purge_lag, each INSERT, UPDATE, and DELETE operation is delayed by ((purge_lag/innodb_max_purge_lag)×10)–5 milliseconds. The delay is computed in the beginning of a purge batch, every ten seconds. The operations are not delayed if purge cannot run because of an old consistent read view that could see the rows to be purged.\n\nA typical setting for a problematic workload might be 1 million, assuming that transactions are small, only 100 bytes in size, and it is permissible to have 100MB of unpurged InnoDB table rows.\n\nThe lag value is displayed as the history list length in the TRANSACTIONS section of InnoDB Monitor output. For example, if the output includes the following lines, the lag value is 20:\n\n------------ TRANSACTIONS ------------ Trx id counter 0 290328385 Purge done for trx's n:o < 0 290315608 undo n:o < 0 17 History list length 20\n\nFor general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_mirrored_log_groups\n\nHas no effect.\n\ninnodb_old_blocks_pct\n\nCommand-Line Format--innodb_old_blocks_pct=#System Variable Nameinnodb_old_blocks_pctVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault37Min Value5Max Value95\n\nSpecifies the approximate percentage of the InnoDB buffer pool used for the old block sublist. The range of values is 5 to 95. The default value is 37 (that is, 3/8 of the pool). See Section 14.16.2.3, “Making the Buffer Pool Scan Resistant” for more information. See Section 8.9.1, “The InnoDB Buffer Pool” for information about buffer pool management, such as the LRU algorithm and eviction policies.\n\ninnodb_old_blocks_time\n\nCommand-Line Format--innodb_old_blocks_time=#System Variable Nameinnodb_old_blocks_timeVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault0Min Value0Max Value2**32-1\n\nNon-zero values protect against the buffer pool being filled up by data that is referenced only for a brief period, such as during a full table scan. Increasing this value offers more protection against full table scans interfering with data cached in the buffer pool.\n\nSpecifies how long in milliseconds (ms) a block inserted into the old sublist must stay there after its first access before it can be moved to the new sublist. If the value is 0, a block inserted into the old sublist moves immediately to the new sublist the first time it is accessed, no matter how soon after insertion the access occurs. If the value is greater than 0, blocks remain in the old sublist until an access occurs at least that many ms after the first access. For example, a value of 1000 causes blocks to stay in the old sublist for 1 second after the first access before they become eligible to move to the new sublist.\n\nThis variable is often used in combination with innodb_old_blocks_pct. See Section 14.16.2.3, “Making the Buffer Pool Scan Resistant” for more information. See Section 8.9.1, “The InnoDB Buffer Pool” for information about buffer pool management, such as the LRU algorithm and eviction policies.\n\ninnodb_open_files\n\nCommand-Line Format--innodb_open_files=#System Variable Nameinnodb_open_filesVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault300Min Value10Max Value4294967295\n\nThis variable is relevant only if you use multiple InnoDB tablespaces. It specifies the maximum number of .ibd files that MySQL can keep open at one time. The minimum value is 10. The default value is 300.\n\nThe file descriptors used for .ibd files are for InnoDB tables only. They are independent of those specified by the --open-files-limit server option, and do not affect the operation of the table cache.\n\ninnodb_print_all_deadlocks\n\nIntroduced5.5.30Command-Line Format--innodb_print_all_deadlocks=#System Variable Nameinnodb_print_all_deadlocksVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypebooleanDefaultOFF\n\nWhen this option is enabled, information about all deadlocks in InnoDB user transactions is recorded in the mysqld error log. Otherwise, you see information about only the last deadlock, using the SHOW ENGINE INNODB STATUS command. An occasional InnoDB deadlock is not necessarily an issue, because InnoDB detects the condition immediately, and rolls back one of the transactions automatically. You might use this option to troubleshoot why deadlocks are happening if an application does not have appropriate error-handling logic to detect the rollback and retry its operation. A large number of deadlocks might indicate the need to restructure transactions that issue DML or SELECT ... FOR UPDATE statements for multiple tables, so that each transaction accesses the tables in the same order, thus avoiding the deadlock condition.\n\ninnodb_purge_batch_size\n\nIntroduced5.5.4Command-Line Format--innodb_purge_batch_size=#System Variable Nameinnodb_purge_batch_sizeVariable ScopeGlobalDynamic VariableYesPermitted Values (>= 5.5.4)TypenumericDefault20Min Value1Max Value5000\n\nThe granularity of changes, expressed in units of redo log records, that trigger a purge operation, flushing the changed buffer pool blocks to disk. This option is intended for tuning performance in combination with the setting innodb_purge_threads=n, and typical users do not need to modify it.\n\ninnodb_purge_threads\n\nIntroduced5.5.4Command-Line Format--innodb_purge_threads=#System Variable Nameinnodb_purge_threadsVariable ScopeGlobalDynamic VariableNoPermitted Values (>= 5.5.4)TypenumericDefault0Min Value0Max Value1\n\nThe number of background threads devoted to the InnoDB purge operation. Currently, can only be 0 (the default) or 1. The default value of 0 signifies that the purge operation is performed as part of the master thread. Running the purge operation in its own thread can reduce internal contention within InnoDB, improving scalability. Currently, the performance gain might be minimal because the background thread might encounter different kinds of contention than before. This feature primarily lays the groundwork for future performance work.\n\ninnodb_random_read_ahead\n\nIntroduced5.5.16Command-Line Format--innodb_random_read_ahead=#System Variable Nameinnodb_random_read_aheadVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypebooleanDefaultOFF\n\nEnables the random read-ahead technique for optimizing InnoDB I/O. Random read-ahead functionality was removed from the InnoDB Plugin (version 1.0.4) and was therefore not included in MySQL 5.5.0 when InnoDB Plugin became the “built-in” version of InnoDB. Random read-ahead was reintroduced in MySQL 5.1.59 and 5.5.16 and higher along with the innodb_random_read_ahead configuration option, which is disabled by default.\n\nSee Section 14.16.2.1, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)” for details about the performance considerations for the different types of read-ahead requests. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_read_ahead_threshold\n\nCommand-Line Format--innodb_read_ahead_threshold=#System Variable Nameinnodb_read_ahead_thresholdVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault56Min Value0Max Value64\n\nControls the sensitivity of linear read-ahead that InnoDB uses to prefetch pages into the buffer pool. If InnoDB reads at least innodb_read_ahead_threshold pages sequentially from an extent (64 pages), it initiates an asynchronous read for the entire following extent. The permissible range of values is 0 to 64. The default is 56: InnoDB must read at least 56 pages sequentially from an extent to initiate an asynchronous read for the following extent.\n\nKnowing how many pages are read through this read-ahead mechanism, and how many of them are evicted from the buffer pool without ever being accessed, can be useful to help fine-tune the innodb_read_ahead_threshold parameter. As of MySQL 5.5, SHOW ENGINE INNODB STATUS output displays counter information from the Innodb_buffer_pool_read_ahead and Innodb_buffer_pool_read_ahead_evicted global status variables. These variables indicate the number of pages brought into the buffer pool by read-ahead requests, and the number of such pages evicted from the buffer pool without ever being accessed respectively. These counters provide global values since the last server restart.\n\nSHOW ENGINE INNODB STATUS also shows the rate at which the read-ahead pages are read in and the rate at which such pages are evicted without being accessed. The per-second averages are based on the statistics collected since the last invocation of SHOW ENGINE INNODB STATUS and are displayed in the BUFFER POOL AND MEMORY section of the output.\n\nSee Section 14.16.2.1, “Configuring InnoDB Buffer Pool Prefetching (Read-Ahead)” for more information. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\ninnodb_read_io_threads\n\nCommand-Line Format--innodb_read_io_threads=#System Variable Nameinnodb_read_io_threadsVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault4Min Value1Max Value64\n\nThe number of I/O threads for read operations in InnoDB. The default value is 4. Its counterpart for write threads is innodb_write_io_threads. See Section 14.16.7, “Configuring the Number of Background InnoDB I/O Threads” for more information. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\nNote\n\nOn Linux systems, running multiple MySQL servers (typically more than 12) with default settings for innodb_read_io_threads, innodb_write_io_threads, and the Linux aio-max-nr setting can exceed system limits. Ideally, increase the aio-max-nr setting; as a workaround, you might reduce the settings for one or both of the MySQL configuration options.\n\ninnodb_replication_delay\n\nCommand-Line Format--innodb_replication_delay=#System Variable Nameinnodb_replication_delayVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault0Min Value0Max Value4294967295\n\nThe replication thread delay (in ms) on a slave server if innodb_thread_concurrency is reached.\n\ninnodb_rollback_on_timeout\n\nCommand-Line Format--innodb_rollback_on_timeoutSystem Variable Nameinnodb_rollback_on_timeoutVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultOFF\n\nIn MySQL 5.5, InnoDB rolls back only the last statement on a transaction timeout by default. If --innodb_rollback_on_timeout is specified, a transaction timeout causes InnoDB to abort and roll back the entire transaction (the same behavior as in MySQL 4.1).\n\ninnodb_rollback_segments\n\nIntroduced5.5.11Command-Line Format--innodb_rollback_segments=#System Variable Nameinnodb_rollback_segmentsVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault128Min Value1Max Value128\n\nDefines how many of the rollback segments in the system tablespace that InnoDB uses within a transaction. You might reduce this value from its default of 128 if a smaller number of rollback segments performs better for your workload.\n\ninnodb_spin_wait_delay\n\nCommand-Line Format--innodb_spin_wait_delay=#System Variable Nameinnodb_spin_wait_delayVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault6Min Value0Max Value4294967295\n\nThe maximum delay between polls for a spin lock. The low-level implementation of this mechanism varies depending on the combination of hardware and operating system, so the delay does not correspond to a fixed time interval. The default value is 6. See Section 14.16.11, “Configuring Spin Lock Polling” for more information.\n\ninnodb_stats_method\n\nIntroduced5.5.10Command-Line Format--innodb_stats_method=nameSystem Variable Nameinnodb_stats_methodVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypeenumerationDefaultnulls_equalValid Valuesnulls_equalnulls_unequalnulls_ignored\n\nHow the server treats NULL values when collecting statistics about the distribution of index values for InnoDB tables. This variable has three possible values, nulls_equal, nulls_unequal, and nulls_ignored. For nulls_equal, all NULL index values are considered equal and form a single value group that has a size equal to the number of NULL values. For nulls_unequal, NULL values are considered unequal, and each NULL forms a distinct value group of size 1. For nulls_ignored, NULL values are ignored.\n\nThe method that is used for generating table statistics influences how the optimizer chooses indexes for query execution, as described in Section 8.3.7, “InnoDB and MyISAM Index Statistics Collection”.\n\ninnodb_stats_on_metadata\n\nIntroduced5.5.4Command-Line Format--innodb_stats_on_metadataSystem Variable Nameinnodb_stats_on_metadataVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypebooleanDefaultON\n\nWhen this variable is enabled (which is the default, as before the variable was created), InnoDB updates statistics when metadata statements such as SHOW TABLE STATUS or SHOW INDEX are run, or when accessing the INFORMATION_SCHEMA tables TABLES or STATISTICS. (These updates are similar to what happens for ANALYZE TABLE.) When disabled, InnoDB does not update statistics during these operations. Disabling this variable can improve access speed for schemas that have a large number of tables or indexes. It can also improve the stability of execution plans for queries that involve InnoDB tables.\n\nTo change the setting, issue the statement SET GLOBAL innodb_stats_on_metadata=mode, where mode is either ON or OFF (or 1 or 0). Changing this setting requires the SUPER privilege and immediately affects the operation of all connections.\n\ninnodb_stats_sample_pages\n\nCommand-Line Format--innodb_stats_sample_pages=#System Variable Nameinnodb_stats_sample_pagesVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault8Min Value1Max Value2**64-1\n\nThe number of index pages to sample for index distribution statistics such as are calculated by ANALYZE TABLE. The default value is 8. For additional information, see Section 14.16.15, “Configuring Optimizer Statistics Parameters”.\n\nSetting a high value for innodb_stats_sample_pages could result in lengthy ANALYZE TABLE execution time. To estimate the number of database pages accessed by ANALYZE TABLE, see Section 14.16.16, “Estimating ANALYZE TABLE Complexity for InnoDB Tables”.\n\ninnodb_strict_mode\n\nCommand-Line Format--innodb_strict_mode=#System Variable Nameinnodb_strict_modeVariable ScopeGlobal, SessionDynamic VariableYesPermitted ValuesTypebooleanDefaultOFF\n\nWhen innodb_strict_mode is ON, InnoDB returns errors rather than warnings for certain conditions. The default value is OFF.\n\nStrict mode helps guard against ignored typos and syntax errors in SQL, or other unintended consequences of various combinations of operational modes and SQL statements. When innodb_strict_mode is ON, InnoDB raises error conditions in certain cases, rather than issuing a warning and processing the specified statement (perhaps with unintended behavior). This is analogous to sql_mode in MySQL, which controls what SQL syntax MySQL accepts, and determines whether it silently ignores errors, or validates input syntax and data values.\n\nThe innodb_strict_mode setting affects the handling of syntax errors for CREATE TABLE, ALTER TABLE and CREATE INDEX statements. innodb_strict_mode also enables a record size check, so that an INSERT or UPDATE never fails due to the record being too large for the selected page size.\n\nOracle recommends enabling innodb_strict_mode when using ROW_FORMAT and KEY_BLOCK_SIZE clauses on CREATE TABLE, ALTER TABLE, and CREATE INDEX statements. When innodb_strict_mode is OFF, InnoDB ignores conflicting clauses and creates the table or index, with only a warning in the message log. The resulting table might have different behavior than you intended, such as having no compression when you tried to create a compressed table. When innodb_strict_mode is ON, such problems generate an immediate error and the table or index is not created, avoiding a troubleshooting session later.\n\nYou can turn innodb_strict_mode ON or OFF on the command line when you start mysqld, or in the configuration file my.cnf or my.ini. You can also enable or disable innodb_strict_mode at runtime with the statement SET [GLOBAL|SESSION] innodb_strict_mode=mode, where mode is either ON or OFF. Changing the GLOBAL setting requires the SUPER privilege and affects the operation of all clients that subsequently connect. Any client can change the SESSION setting for innodb_strict_mode, and the setting affects only that client.\n\ninnodb_support_xa\n\nCommand-Line Format--innodb_support_xaSystem Variable Nameinnodb_support_xaVariable ScopeGlobal, SessionDynamic VariableYesPermitted ValuesTypebooleanDefaultTRUE\n\nEnables InnoDB support for two-phase commit in XA transactions, causing an extra disk flush for transaction preparation. This setting is the default. The XA mechanism is used internally and is essential for any server that has its binary log turned on and is accepting changes to its data from more than one thread. If you turn it off, transactions can be written to the binary log in a different order from the one in which the live database is committing them. This can produce different data when the binary log is replayed in disaster recovery or on a replication slave. Do not turn it off on a replication master server unless you have an unusual setup where only one thread is able to change data.\n\nFor a server that is accepting data changes from only one thread, it is safe and recommended to turn off this option to improve performance for InnoDB tables. For example, you can turn it off on replication slaves where only the replication SQL thread is changing data.\n\nYou can also turn off this option if you do not need it for safe binary logging or replication, and you also do not use an external XA transaction manager.\n\ninnodb_sync_spin_loops\n\nCommand-Line Format--innodb_sync_spin_loops=#System Variable Nameinnodb_sync_spin_loopsVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault30Min Value0Max Value4294967295\n\nThe number of times a thread waits for an InnoDB mutex to be freed before the thread is suspended. The default value is 30.\n\ninnodb_table_locks\n\nCommand-Line Format--innodb_table_locksSystem Variable Nameinnodb_table_locksVariable ScopeGlobal, SessionDynamic VariableYesPermitted ValuesTypebooleanDefaultTRUE\n\nIf autocommit = 0, InnoDB honors LOCK TABLES; MySQL does not return from LOCK TABLES ... WRITE until all other threads have released all their locks to the table. The default value of innodb_table_locks is 1, which means that LOCK TABLES causes InnoDB to lock a table internally if autocommit = 0.\n\nAs of MySQL 5.5.3, innodb_table_locks = 0 has no effect for tables locked explicitly with LOCK TABLES ... WRITE. It still has an effect for tables locked for read or write by LOCK TABLES ... WRITE implicitly (for example, through triggers) or by LOCK TABLES ... READ.\n\ninnodb_thread_concurrency\n\nCommand-Line Format--innodb_thread_concurrency=#System Variable Nameinnodb_thread_concurrencyVariable ScopeGlobalDynamic VariableYesPermitted ValuesTypenumericDefault0Min Value0Max Value1000\n\nInnoDB tries to keep the number of operating system threads concurrently inside InnoDB less than or equal to the limit given by this variable. Once the number of threads reaches this limit, additional threads are placed into a wait state within a FIFO queue for execution. Threads waiting for locks are not counted in the number of concurrently executing threads.\n\nThe correct value for this variable is dependent on environment and workload. Try a range of different values to determine what value works for your applications. A recommended value is 2 times the number of CPUs plus the number of disks.\n\nThe range of this variable is 0 to 1000. A value of 0 (the default) is interpreted as infinite concurrency (no concurrency checking). Disabling thread concurrency checking enables InnoDB to create as many threads as it needs. A value of 0 also disables the queries inside InnoDB and queries in queue counters in the ROW OPERATIONS section of SHOW ENGINE INNODB STATUS output.\n\ninnodb_thread_sleep_delay\n\nCommand-Line Format--innodb_thread_sleep_delay=#System Variable Nameinnodb_thread_sleep_delayVariable ScopeGlobalDynamic VariableYesPermitted Values (<= 5.5.36)Platform Bit Size32TypenumericDefault10000Min Value0Max Value4294967295Permitted Values (<= 5.5.36)Platform Bit Size64TypenumericDefault10000Min Value0Max Value18446744073709551615Permitted Values (>= 5.5.37)TypenumericDefault10000Min Value0Max Value1000000\n\nHow long InnoDB threads sleep before joining the InnoDB queue, in microseconds. The default value is 10,000. A value of 0 disables sleep.\n\ninnodb_use_native_aio\n\nIntroduced5.5.4Command-Line Format--innodb_use_native_aio=#System Variable Nameinnodb_use_native_aioVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultON\n\nSpecifies whether to use the Linux asynchronous I/O subsystem. This variable applies to Linux systems only, and cannot be changed while the server is running. Normally, you do not need to touch this option, because it is enabled by default.\n\nAs of MySQL 5.5, the asynchronous I/O capability that InnoDB has on Windows systems is available on Linux systems. (Other Unix-like systems continue to use synchronous I/O calls.) This feature improves the scalability of heavily I/O-bound systems, which typically show many pending reads/writes in the output of the command SHOW ENGINE INNODB STATUS\\G.\n\nRunning with a large number of InnoDB I/O threads, and especially running multiple such instances on the same server machine, can exceed capacity limits on Linux systems. In this case, you may receive the following error:\n\nEAGAIN: The specified maxevents exceeds the user's limit of available events.\n\nYou can typically address this error by writing a higher limit to /proc/sys/fs/aio-max-nr.\n\nHowever, if a problem with the asynchronous I/O subsystem in the OS prevents InnoDB from starting, you can start the server with innodb_use_native_aio=0 disabled (use innodb_use_native_aio=0 in the option file). This option may also be turned off automatically during startup if InnoDB detects a potential problem such as a combination of tmpdir location, tmpfs filesystem, and Linux kernel that does not support AIO on tmpfs.\n\nThis variable was added in MySQL 5.5.4.\n\ninnodb_use_sys_malloc\n\nCommand-Line Format--innodb_use_sys_malloc=#System Variable Nameinnodb_use_sys_mallocVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypebooleanDefaultON\n\nWhether InnoDB uses the operating system memory allocator (ON) or its own (OFF). The default value is ON. See Section 14.16.4, “Configuring the Memory Allocator for InnoDB” for more information.\n\ninnodb_version\n\nThe InnoDB version number. Starting in 5.5.30, the separate numbering for InnoDB is discontinued and this value is the same as for the version variable.\n\ninnodb_write_io_threads\n\nCommand-Line Format--innodb_write_io_threads=#System Variable Nameinnodb_write_io_threadsVariable ScopeGlobalDynamic VariableNoPermitted ValuesTypenumericDefault4Min Value1Max Value64\n\nThe number of I/O threads for write operations in InnoDB. The default value is 4. Its counterpart for read threads is innodb_read_io_threads. See Section 14.16.7, “Configuring the Number of Background InnoDB I/O Threads” for more information. For general I/O tuning advice, see Section 8.5.7, “Optimizing InnoDB Disk I/O”.\n\nNote\n\nOn Linux systems, running multiple MySQL servers (typically more than 12) with default settings for innodb_read_io_threads, innodb_write_io_threads, and the Linux aio-max-nr setting can exceed system limits. Ideally, increase the aio-max-nr setting; as a workaround, you might reduce the settings for one or both of the MySQL configuration options."
    }
}