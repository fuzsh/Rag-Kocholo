{
    "id": "dbpedia_8293_3",
    "rank": 80,
    "data": {
        "url": "https://en.wikibooks.org/wiki/Perl_Programming/Print_version",
        "read_more_link": "",
        "language": "en",
        "title": "Perl Programming/Print version",
        "top_image": "https://en.wikibooks.org/static/favicon/wikibooks.ico",
        "meta_img": "https://en.wikibooks.org/static/favicon/wikibooks.ico",
        "images": [
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d6/Crystal_Clear_action_apply.png/20px-Crystal_Clear_action_apply.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/80/Wikipedia-logo-v2.svg/40px-Wikipedia-logo-v2.svg.png",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/d7c6df024ec652b400e706863101da838ca9a06b",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e8de4a5c101ba3f00d4e332ca8783aa2ba8a1f87",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/91/Book_important2.svg/40px-Book_important2.svg.png",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/d7c6df024ec652b400e706863101da838ca9a06b",
            "https://wikimedia.org/api/rest_v1/media/math/render/svg/e8de4a5c101ba3f00d4e332ca8783aa2ba8a1f87",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikibooks.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikibooks.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/favicon/wikibooks.ico",
        "meta_site_name": "",
        "canonical_link": "https://en.wikibooks.org/wiki/Perl_Programming/Print_version",
        "text": "This book assumes that you know absolutely nothing about programming at all and that Perl is your first language. However, basic operations such as making text files are outside of the realm of this tutorial.\n\nTo find out, if you already have Perl installed on your computer, go into the command line and type:\n\nThis will display which version of Perl you have installed on your computer, if it is installed.\n\nThere are at least two easy ways to install Perl on Windows: the ActiveState distribution, and the Strawberry Perl distribution. Both are downloadable as native Windows installers. ActivePerl has a prebuilt package repository and is supported by a corporation, while Strawberry Perl includes a compiler (gcc) so that perl modules can be installed \"on the fly\" and is community-supported.\n\nMost Unix-like operating systems will include Perl by default, and Linux Standard Base mandates that all compliant Linuxes ship with Perl installed. However, if for some reason you don't have perl, you can explore the options available to you at the main Perl download page, which will provide links to source and binaries.\n\nPerl is an interpreted language, which means you will always need the Perl interpreter which will compile and execute your program each time you run it. Instead of compiling your program into bytecode, like in C++ or Pascal, and then executing it, you can simply copy your program's source code to a different computer (that has the Perl interpreter) and run it.\n\nFor our first example, run your favorite text editor, and type something like this:\n\nIf you don't understand this yet, don't worry; This will be explained in more depth later.\n\nSave the file as myprog.pl and you have a Perl program ready to run.\n\nTo run a Perl program with a modern version of ActivePerl installed, you simply click on it. If the screen flashes and you can't see the output you might have to execute the file from within the windows shell (ie. cmd.exe or PowerShell). With Strawberry Perl, you'll have to execute a Perl program from the command line as shown below.\n\nFrom a Windows command-line interface, you can run the program thusly:\n\nC:\\> perl path\\to\\foo\\myprog.pl\n\nor, if perl.exe is not in your path:\n\nC:\\> c:\\perl\\bin\\perl.exe myprog.pl\n\nNote: You may have to specify the full path to your program unless you are running the command prompt in that directory.\n\nYou can run a Perl program by running perl itself, and telling the shell the name of the file:\n\nperl myprog.pl\n\nUsually, Perl programs are made executable on their own. This involves two changes to the sample program. First, edit it and put the following shebang line at the top of the file:\n\nThen, at a command prompt, make your program executable by using chmod.\n\nYour program is now executable and ready to run, just like any other file. To execute, type:\n\nBy convention, .pl identifies a Perl script, and .pm a Perl library. The .pl file extension isn't needed for either of these examples; it's just a useful way of identifying files. The only time the convention should be violated is if the program is to be installed outside of the current working directory, and there runs a chance you might want to some day rewrite them in a different language.\n\nHere's a simple program written in Perl to get us started:\n\nLet's take a look at this program line by line:\n\n#!/usr/bin/perl\n\nOn Unix systems this tells the Operating System to execute this file with the program located at /usr/bin/perl. This is the default Unix location for the perl interpreter, on Windows #!C:\\Perl\\bin\\perl.exe or #!C:\\strawberry\\perl\\bin\\perl.exe (depending on whether ActivePerl or Strawberry Perl was installed) should be used instead.\n\nShebang: A line at the start of a file, beginning with #!, that gives instructions to the operating system.\n\n# Outputs ...\n\nThis line is a comment - it is ignored by the perl interpreter, but is very useful. It helps you to debug and maintain your code, and explain it to other programmers.\n\nComment: A line of plain text ignored by the interpreter in a file of code.\n\nprint \"Hello World!\\n\";\n\nThe print instruction writes whatever follows it to the screen. The \\n at the end of the string puts a new line to the screen. The semicolon at the end of the line tells the perl interpreter that the instruction is finished; you must put a semicolon at the end of every instruction in Perl code.\n\nString: A sequence of characters used as data by a program.\n\nChange the program so it says hello to you.\n\nChange the program so that after greeting you, it asks how you are doing, on the next line. The output should look like this:\n\nHello your_name! How are you?\n\nExperiment with the \\n character, what happens when you take it away? What happens, if you put two in a row?\n\nRemember: If you add another print instruction you will need to put a semicolon after it.\n\nAny sequence of characters put together as one unit, is a string. So, the word the is a string. This sentence is a string. Even this entire paragraph is a string. In fact, you could consider the text of this entire book as one string.\n\nStrings can be of any length and can contain any characters, numbers, punctuation, special characters (like ! #, and %), and even characters in natural languages besides English. In addition, a string can contain special whitespace formatting characters like newline, tab, and the bell character. We will discuss special characters more later on. For now, we will begin our consideration of strings by considering how to insert literal strings into a Perl program.\n\nTo begin our discussion of strings in Perl, we will consider how to work with string literals in Perl. The word literal here refers to the fact that these are used when you want to type a string directly to Perl. This can be contrasted with storing a string in a variable.\n\nAny string literal can be used as an expression. We will find this useful when we want to store string literals in variables. However, for now, we will simply consider the different types of string literals that one can make in Perl. Later, we will learn how to assign these string literals to variables in the Scalar Variables section.\n\nString literals can be represented in primarily three ways in Perl. We have already used one type in the simple programming examples, using double quote marks. Using double or single quote marks in Perl each has a special meaning.\n\nSingle quotes can be thought of as literal strings. In the previous examples, you may have noticed that variable names were included inside the strings with double quotes. When the results were printed, the value of the variable was placed in the printed line, not the name of the variable. If single quote marks were used, the actual variable name would have been printed because nearly all special characters that might be interpreted differently are taken at face value when using single quotes.\n\nTo see what is meant by this, try this simple program:\n\nYou should see \"Hello Fred\" on the first line and \"Hello $name\\n\" on the second (without a newline after it). Putting the value of $name into the string in the first print statement is called \"interpolation.\" If you don't need interpolation, you should use single quotes, because it makes your intent clearer.\n\nThere are two characters in single quoted strings that do not always represent themselves. This is due to necessity, since single-quoted strings start and end with the ' character. We need a way to express inside a single-quoted string that we want the string to contain a ' character.\n\nThe solution to this problem is to preceded any ' characters we actually want to appear in the string itself with the backslash (\\ character). Thus we have strings like this:\n\nWe have in this example a string with seven characters exactly. Namely, this is the string: xxx'xxx. It can be difficult at first to become accustomed to the idea that two characters in the input to Perl actually produce only one character in the string itself. (C programmers are already probably used to this idea.) However, just keep in mind the rules and you will probably get used to them quickly.\n\nSince we have used the \\ character to do something special with the ' character, we must now worry about the special cases for the backslash character itself. When we see a \\ character in a single-quoted string, we must carefully consider what will happen.\n\nUnder most circumstances, when a \\ is in a single-quoted string, it is simply a backslash, representing itself, as most other characters do. However, the following exceptions apply:\n\nThe sequence \\' yields the character ' in the actual string. (This is the exception we already discussed above).\n\nThe sequence \\\\ yields the character \\ in the actual string. In other words, two backslashes right next to each other actually yield only one backslash.\n\nA backslash, by itself, cannot be placed at the end of a the single-quoted string. This cannot happen because Perl will think that you are using the \\ to escape the closing '.\n\nThe following examples exemplify the various exceptions, and use them properly:\n\nIn the last example, note that the resulting string is Three \\'s: \"\\\\\\\". If you can follow that example, you have definitely mastered how single-quoted strings work!\n\nInstead of unreadable backslash escapes, Perl offers other ways of quoting strings. The first example above could be written as:\n\nNote that there is no rule against having a single-quoted string span several lines. When you do this, the string has newline characters embedded in it.\n\nA newline character is a special ASCII character that indicates that a new line should be started. In a text editor, or when printing output to the screen, this usually indicates that the cursor should move from the end of the current line to the first position on the line following it.\n\nSince Perl permits the placement of these newline characters directly into single quoted strings, we are permitted to do the following:\n\nThis string has a total of twenty characters. The first seven are Time to. The next character following that is a newline. Then, the eleven characters, start anew. follow. Note again that this is one string, with a newline as its eighth character.\n\nFurther, note that we are not permitted to put a comment in the middle of the string, even though we are usually allowed to place a # anywhere on the line and have the rest of the line be a comment. We cannot do this here, since we have yet to terminate our single-quoted string with a ', and thus, any # character and comment following it would actually become part of the single-quoted string! Remember that single-quotes strings are delimited by ' at the beginning, and ' at the end, and everything in between is considered part of the string, included newlines, # characters and anything else.\n\nIn finishing our discussion of singled-quoted strings, consider these examples of strings that are not legal because they violate the exceptions we talked about above:\n\nSometimes, when you have invalid string literals such as in the example above, the error message that Perl gives is not particularly intuitive. However, when you see error messages such as:\n\n(Might be a runaway multi-line '' string starting on line X) Bareword found where operator expected Bareword \"foo\" not allowed while \"strict subs\" in use\n\nIt is often an indication that you have runaway or invalid strings. Keep an eye out for these problems. Chances are, you will forget and violate one of the rules for single-quoted strings eventually, and then need to determine why you are unable to run your Perl program.\n\nBefore we move on to our consideration of double-quoted strings, it is necessary to first consider a small digression. We know how to represent strings in Perl, but, as you may have noticed, the examples we have given thus far do not do anything interesting. If you try placing the statements that we listed as examples in Single Quoted Strings, into a full Perl program, like this:\n\n#!/usr/bin/perl\n\nuse strict; use warnings;\n\n'Three \\\\\\'s: \"\\\\\\\\\\\"'; # There are three \\ chars between \"\" 'xxx\\'xxx'; # xxx, a single-quote character, and then xxx 'Time to start anew.';\n\nyou probably noticed that nothing of interest happens. Perl gladly runs this program, but it produces no output.\n\nThus, to begin to work with strings in Perl beyond simple hypothetical considerations, we need a way to have Perl display our strings for us. The canonical way of accomplishing this in Perl is to use the print function.\n\nThe print function in Perl can be used in a variety of ways. The simplest form is to use the statement print STRING;, where STRING is any valid Perl string.\n\nSo, to reconsider our examples, instead of simply listing the strings, we could instead print each one out:\n\n#!/usr/bin/perl\n\nuse strict; use warnings;\n\nprint 'Three \\\\\\'s: \"\\\\\\\\\\\"'; # Print first string print 'xxx\\'xxx'; # Print the second print 'Time to start anew. '; # Print last string, with a newline at the end\n\nThis program will produce output. When run, the output goes to what is called the standard output. This is usually the terminal, console or window in which you run the Perl program. In the case of the program above, the output to the standard output is as follows:\n\nThree \\'s: \"\\\\\\\"xxx'xxxTime to start anew.\n\nNote that a newline is required to break up the lines. Thus, you need to put a newline at the end of every valid string if you want your string to be the last thing on that line in the output.\n\nNote that it is particularly important to put a newline on the end of the last string of your output. If you do not, often times, the command prompt for the command interpreter that you are using may run together with your last line of output, and this can be very disorienting. So, always remember to place a newline at the end of each line, particularly on your last line of output.\n\nFinally, you may have noticed that formatting your code with newlines in the middle of single-quoted strings hurts readability. Since you are inside a single-quoted string, you cannot change the format of the continued lines within the print statement, nor put comments at the ends of those lines because that would insert data into your single-quoted strings. To handle newlines more elegantly, you should use double-quoted strings, which are the topic of the next section.\n\nDouble-quoted strings are another way of representing scalar string literals in Perl. Like single-quoted strings, you place a group of ASCII characters between two delimiters (in this case, our delimiter is \"). However, something called interpolation happens when you use a double-quoted string.\n\nInterpolation is a special process whereby certain special strings written in ASCII are replaced by something different. In Single-quoted strings section, we noted that certain sequences in single-quoted strings (namely, \\\\ and \\') were treated differently - these are called backslash escape sequences. This is very similar to what happens with interpolation.\n\nFor example, in interpolated double-quoted strings, various sequences preceded by a \\ character act differently according to the chart below:\n\nString Interpolated As \\\\ an actual, single backslash character \\$ a single $ character \\@ a single @ character \\\" a single double-quote character \\t tab \\n newline \\r hard return \\f form feed \\b backspace \\a alarm (bell) \\e escape \\056 character represented by octal value, 056 (same as.) \\x2E character represented by hexadecimal value, 2E (same as .)\n\nAs you may have noticed in the previous chapter, you can put the name of a variable within a string with its leading dollar sign. This form of interpolation replaces the name of the variable in the string with the content of the variable.\n\nLet us consider an example that uses a few of these characters:\n\n#!/usr/bin/perl\n\nuse strict; use warnings;\n\nprint \"A backslash: \\\\\\n\"; print \"Tab follows:\\tover here\\n\"; print \"Ring! \\a\\n\"; print \"Please pay someone\\@example.org \\$20.\\n\";\n\nThis program, when run, produces the following output on the screen:\n\nA backslash: \\ Tab follows: over here Ring! Please pay someone@example.org $20.\n\nIn addition, when running, you should hear the computer beep. That is the output of the \\a character, which you cannot see on the screen. However, you should be able to hear it.\n\nNotice that the \\n character ends a line. \\n should always be used to end a line. Those students familiar with the C language will be used to using this sequence to mean newline. When writing Perl, the word newline and the \\n character are roughly synonymous.\n\nOperators manipulate two or more strings in some way.\n\nPerl uses the . operator to concatenate or connect two strings together, like this:\n\n\"Hello\" . \"World\" # This is the same as \"HelloWorld\"\n\nIf you want to make the string have a space between Hello and World you could write it like this:\n\n\"Hello\" . \", \" . \"World\" # This is the same as \"Hello, World\"\n\nOr like this:\n\n\"Hello\" . \", World\" # This is the same as \"Hello, World\"\n\nThis is called the string repetition operator and is used to repeat a string. All you have to do is put a string on the left side of the x and a number on the right side. Like this:\n\n\"Hello\" x 5 # This is the same as \"HelloHelloHelloHelloHello\"\n\nIf you wish to insert a line break after each output of the string, use:\n\n\"Hello\\n\" x 5\n\nWrite a program that uses the . operator to print \"Hello, Sir!\".\n\nWrite another program which uses the x operator to print \"HelloHelloHelloHello\". Put comments in this program that explain how it works\n\nRemember to take some time to play with single and double quoted strings, the more practice you get, the better you will be.\n\nNumbers in Perl do not have to be enclosed in any kind of punctuation; they can be written as straight numbers.\n\nHere are some acceptable floating point numbers:\n\n0.1, -3.14, 2.71828…\n\nIntegers are all whole numbers and their negatives (and 0): {… -3, -2, -1, 0, 1, 2, 3, …}.\n\nHere are a few examples of integers:\n\n12, -50, 20, 185, -6654, 6654\n\nThe following examples are not integers:\n\n15.5, -3.458, 3/2, 0.5\n\nI'll dwell on this topic for a little longer than the other types of numbers. In Perl you can specify not only decimal numbers, but also numbers in hex, octal, and binary. If you are not familiar with how these systems work, you can try these Wikipedia articles:\n\nHexadecimal\n\nOctal\n\nBinary\n\nIn Perl you have to specify when you are going to write a non-decimal number. Binary numbers start with an 0b, so here are some possible binary numbers:\n\n0b101011101\n\n0b10\n\nOctal numbers start with 0 (\"zero\"), so here are some possible octal numbers:\n\n015462\n\n062657\n\n012\n\nHexadecimal numbers start with 0x, so here are some possible hexadecimal numbers:\n\n0xF17A\n\n0xFFFF\n\nJust like strings, numbers have operators. These operators are quite obvious so I'll just give a quick example of each one.\n\nThese operators are pretty obvious, but here are some examples:\n\n100 + 1 # That's 101 100 - 1 # That's 99 100/2 # That's 50 100*2 # That's 200\n\nPerl also has the familiar increment, decrement, plus-equals, and minus-equals operators from C:\n\n$a++ # evaluate, then increment ++$a # increment, then evaluate $a-- # evaluate, then decrement --$a # decrement, then evaluate $a += 5 # plus-equals operator, adds 5 to $a. Equivalent to $a = $a + 5 $a -= 2 # minus-equals operator, subtracts 2 from $a. Equivalent to $a = $a-2\n\nNow let's look at one more operator that's a little less obvious.\n\nThe ** operator is simply the exponentiation operator. Here's another example:\n\n2**4 # That's 16, same as 24 4**3**2 # that's 4**(3**2), or 49, or 262144\n\nExtra!\n\nThe modulus operator (%) can be used to find the remainder when dividing two numbers.\n\nIf that doesn't make sense now, that's fine, it's not that important. (Note, this returns 0 when used on floating point numbers)\n\nRemember the x operator? Use a mathematical expression as the number of times to repeat the string, see what happens.\n\nWrite a program like our original hello world program except make it print a mathematical expression.\n\nIn Perl, there are five types of variables: $calars, @rrays, %hashes, &subroutines, and *typeglobs.\n\nVariables, called scalars, are identified with the $ character, and can contain nearly any type of data. For example:\n\nNote that the perl interpreter is case sensitive. This means that identifier names containing lowercase letters will be treated as being different and separate from those containing uppercase letters.\n\nArrays in Perl use the @ character to identify themselves.\n\nHowever, when you deal with just one element of the array (using square brackets so it's not confused), then that element of the array is considered a scalar which takes the $ sigil:\n\nAs in the C programming language, the number of the first element is 0 (although as with all things in Perl, it's possible to change this if you want). Array subscripts can also use variables:\n\nAssociative arrays, or \"hashes,\" use the % character to identify themselves.\n\nWhen using the => the left side is assumed to be quoted. For long lists, lining up keys and values aids readability.\n\nHowever, when you deal with just one element of the array (using braces), then that element of the array is considered a scalar and takes the $ identifier:\n\nAssociative arrays are useful when you want to refer to the items by their names.\n\nSubroutines are defined by the sub function, and used to be called using & (using & is now deprecated). Here's an example program that calculates the Fibonnaci sequence:\n\nThe if statement is the primary conditional structure in Perl. The syntax is as follows:\n\nIf the boolean expression evaluates to true, the statements between the two braces will be executed. The braces around statements are mandatory, even if there is only one statement (unlike C or Java).\n\nAn alternative syntax to the if statement may be used on a single statement. This involves putting the conditional at the end of the statement rather than before, and does not include braces:\n\nThe following statements are synonymous:\n\nYou should choose whichever one is clearer in a given situation. For example, the following is legal, but unclear:\n\nThis hides the last (which is like break, and ends the loop) over at the right. Instead, use a postfix if:\n\nThe boolean expression conditional can contain any one of the comparison operators covered in the next section.\n\nMultiple conditions can be checked together using the boolean expression operators:\n\n&& - logical and, C style; used for most conditionals\n\nand - logical and, but with a lower precedence; used for flow control\n\n|| - logical or, C style; used for most conditionals\n\nor - logical or, but with a lower precedence; used for flow control\n\n! - logical not, C style\n\nnot - logical not, but with a lower precedence\n\nConditional statements can also be extended with the elsif and else structures:\n\nNote that an if statement is followed by any number (including zero) of elsif statements, and finally an optional else statement. The statements of an elsif will be executed, if its boolean expression is true, and no preceding (els)if statement's boolean expression is true. The trailing else (if present) is executed, if none of the preceding statements' boolean expressions are true.\n\nIf you want to shorten the conditional into one line, you may use the shortcut syntax:\n\nPerl's set of operators borrows extensively from the C programming language. Perl expands on this by infusing new operators for string functions (.=, x, eq, ne, etc.). C by contrast delegates its subset of Perl functionality to a library strings.h, and ctype.h, and includes no such functionality by default compilation. Perl also includes a highly flexible Regex engine inspired by Sed with improvements to standard POSIX regexes, most notably the support of Unicode.\n\nMost arithmetic operators are binary operators; this means they take two arguments. Unary operators only take one argument. Arithmetic operators are very simple and often transparent.\n\nAll the basic arithmetic operators, addition (+), subtraction (-), multiplication (*), and division (/), and the modulus operator % exist. Modulus returns the remainder of a division (/) operation.\n\nThe exponentiation operator is **. It allows you to raise one value to the power of another. If you raise to a fraction you will get the root of the number. In this example the second result when raised to the power of 2 should return 2 ((2**(1/2))**2 = 2).\n\nThe function sqrt is provided for finding a square root. Other fractional powers (i.e., (1/5), (2/13), (7/5), and similar) are suitably found using the ** operator.\n\nThe auto-decrement (--), and auto-increment (++) operators are unary operators. They alter the scalar variable they operate on by one logical unit. On numbers, they add or subtract one. On letters and strings, only the auto-increment shift one up in the alphabet, with the added ability to roll-over. Operators that come in post- and pre- varieties can be used two ways. The first way returns the value of the variable before it was altered, and the second way returns the value of the variable after it was altered.\n\nThe basic assignment operator is = that sets the value on the left side to be equal to the value on the right side. It also returns the value. Thus you can do things like $a = 5 + ($b = 6), which will set $b to a value of 6 and $a to a value of 11 (5 + 6). Why you would want to do this is another question.\n\nThe assignment update operators from C, +=, -=, etc. work in perl. Perl expands on this basic idea to encompass most of the binary operators in perl.\n\noperator name += add assign, plus-equals -= subtract assign, minus-equals *= multiply assign /= divide assign %= modulo assign **= exponent assign .= concatenate assign x= repeat assign &&= logical AND assign ||= logical OR assign &= bitwise AND assign |= bitwise OR assign ^= bitwise XOR assign &.= bitwise string AND assign |.= bitwise string OR assign ^.= bitwise string XOR assign <<= left shift assign >>= right shift assign //= defined OR assign\n\nPerl uses different operators to compare numbers and strings. This is done, because in most cases, Perl will happily stringify numbers and numify strings. In most cases this helps, and is consistent with Perl's DWIM Do-What-I-Mean theme. Unfortunately, one place this often does not help, is comparison.\n\nname numeric string equal == eq not equal != ne less than < lt greater than > gt less or equal <= le greater or equal >= ge compare <=> cmp\n\nPerl has two sets of logical operators, just like the comparison operators, however not for the same reason.\n\nThe first set (sometimes referred to as the C-style logical operators, because they are borrowed from C) is &&, ||, and !. They mean logical AND, OR, and NOT respectively. The second set is and, or, and not.\n\nThe only difference between these two sets is the precedence they take (See Precedence). The symbolic operators take a much higher precedence than the textual.\n\nMost of the time, you will be using logical operators in conditionals.\n\nIn this case, you could safely substitute and for && and the conditional would still work as expected. However, this is not always the case.\n\nThis, however, is completely different.\n\nMost people prefer to use C-style logical operators and use brackets to enforce clarity rather than using a combination of textual and C-style operators (when possible), which can be very confusing at times.\n\nPartial evaluation (or \"short circuiting\") is the property of logical operators that the second expression is only evaluated, if it needs to be.\n\nThis also works with logical OR statements. If the first expression evaluates as true, the second is never evaluated, because the conditional is automatically true.\n\nThis becomes useful in a case like this:\n\nHere, if the foo() subroutine returns false, \"foo() failed\\n\" is printed. However, if it returns true, \"foo() failed\\n\" is not printed, because the second expression (print \"foo() failed\\n\") does not need to be evaluated.\n\nThese operators perform the same operation as the logical operators, but instead of being performed on the true/false value of the entire expressions, it is done on the individual respective bits of their values.\n\n& (bitwise AND)\n\n| (bitwise OR)\n\n^ (bitwise XOR)\n\n~ (bitwise NOT)\n\nThe left and right shift operators move the bits of the left operand (e.g. $a in the case of $a << $b) left or right a number of times equal to the right operand ($b). Each move to the right or left effectively halves or doubles the number, except where bits are shifted off the left or right sides. For example, $number << 3 returns $number multiplied by 8 (2**3).\n\n<< (left shift)\n\n>> (right shift)\n\nThe string concatenation operator is ., not + that some other languages use.\n\nThere is a repeat operator for strings (x) that repeats a string a given number of times.\n\nTo compare strings, use eq and ne instead of == or != respectively. You can also look for a substring with substr(), or pattern-match with regular expressions.\n\nSee Perl Programming/Function Reference#-X\n\nThe range operator (..) returns a list of items in the range between two items; the items can be characters or numbers. The type of character is determined by the first operand; the code:\n\nprint ('A'..'Z'); print ('a'..'z'); print ('A'..'z'); print (1..'a'); print (1..20); print ('&'..'!'); print (10..-10); print \"$_\\n\" foreach (1..10);\n\nOutputs (Newlines added for readability):\n\nABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz ABCDEFGHIJKLMNOPQRSTUVWXYZ\n\n1234567891011121314151617181920 &\n\n1 2 3 4 5 6 7 8 9 10\n\nNote that the case is defined by the first operand, and that the 1..'a' and (10..-10) operations return empty list.\n\nPrecedence is a concept that will be familiar to anyone who has studied algebra or coded in C/C++. Each operator has its place in a hierarchy of operators, and are executed in order. The precedence of perl operators is strict and should be overridden with parentheses, both when you are knowingly going against precedence and when you aren't sure of the order of precedence. For a complete listing of the order, check perlop.\n\nThe smart match operator ~~ is new in perl 5.10. To use it, you'll need to explicitly say that you're writing code for perl 5.10 or newer. Its opposite operator ǃ~ matches smartly an inequality:\n\nThe smart match operator is versatile and fast (often faster than the equivalent comparison without ǃ~ or ~~). See smart matching in detail for the comparisons it can do. ~~ is also used in the given/when switch statement new in 5.10, which will be covered elsewhere.\n\nA variable, previously referenced with the reference operator can be dereferenced by using a doubledollar symbol prefix:\n\nIf the left hand operand of the arrow operator is an array or hash reference, or a subroutine that produces one, the arrow operator produces a look up of the element or hash:\n\nPerl has four fundamental data types: scalars, lists, hashes, and typeglobs.\n\nscalar\n\nis a funny way of saying a single value; it may be a number, a string, or a reference.\n\nlist\n\nis an ordered collection of scalars. A variable that holds a list is called an array. Items in a list or array can be accessed by their position in the list; programs can retrieve the first, second, third, etc. item in a list.\n\nhash\n\nis like an array, in that a hash holds many values, but the values are identified by a unique \"key\", rather than an ordinal index position.\n\ntypeglob\n\nis a variable representing an entry within the internal symbol table. It is used to manipulate file handles, and to create references or aliases.\n\nAll variables are marked by a leading sigil, which identifies the data type. The same name may be used for variables of different types, without conflict.\n\nNow that you understand how to use strings and numbers in Perl, you need to start learning how to use variables. The best way to learn about scalar variables - Perl talk for a single variable, as against a group or list of values - is to look at an example.\n\nNow let's break this program down:\n\nThe first two lines you already know, #!/usr/bin/perl and use warnings;\n\nThe third line is more interesting, it contains a scalar variable. There are a few important things to point out:\n\nIn case you haven't figured this out, the scalar variable in this line is $my_scalar_variable\n\nNotice the $ before the name my_scalar_variable, in order to define a scalar variable, this sign must appear before the name.\n\nNow let's look at the last line. This is just the familiar print function being told to print the value of $my_scalar_variable.\n\nTry it!\n\nType in the program mentioned above and run it.\n\nIn the course of writing a program, you will most likely use a variable. What is a variable? A variable is something that stores data. A scalar variable holds a single value.\n\nAll scalar variables names must start with a $ symbol. You can remember this by thinking $scalar.\n\nVariable names can be comprised of alphanumeric characters and underscores.\n\nNumeric characters are allowed in names of variables, but not as the first character after the $.\n\nYou may recall that earlier in the book, I said that whether you use \" or ' in strings makes a big difference in the interaction of strings and variables. Well now I am going to explain what I meant.\n\nNow that you know what a variable is, what if you wanted to put a variable in a string? Here's the difference:\n\nWith a double quoted string, this program:\n\nWould return \"I saw 4 lions!\"\n\nWith a single quoted string, this program:\n\nWould return \"I saw $variable lions!\"\n\nTry it!\n\nType in the programs mentioned above and run them.\n\nThis effect is because of what I said before, single quoted strings are interpreted literally.\n\nMain article: Perl Programming/Operators\n\nThere are operators that are used for comparing numbers and strings. This can be very useful when you get to more advanced programming. Both numbers and strings have their own set of operators which test for a condition such as equal or not equal and return either true or false.\n\nHere is the list of numeric comparison operators:\n\n== - Equal to\n\n!= - Not equal to\n\n< - Less than\n\n> - Greater than\n\n<= - Less than or equal to\n\n>= - Greater than or equal to\n\n<=> - Numeric Comparison\n\nHere is the list of string comparison operators:\n\neq - Equal to\n\nne - Not equal to\n\nlt - Less than\n\ngt - Greater than\n\nle - Less than or equal to\n\nge - Greater than or equal to\n\ncmp - String Comparison\n\nNote\n\nThe two 'Comparison' operators <=> and cmp are slightly different from the rest. Rather than returning only true or false, these operators return 1 if the left argument is greater than the right argument, 0 if they are equal, and -1 if the right argument is greater than the left argument.\n\nTry writing a program like the Hello World program except elaborate it by storing \"Hello, world!\\n\" in a variable and then printing the variable.\n\nPlay around with all the things we have learned so far. Try to create a program that has an example of everything we have learned so far.\n\nPerl syntax includes both lists and arrays.\n\nA list in perl is an ordered set of scalar values. It is represented in your code as a comma-separated sequence of values, which may or may not be contained in scalar variables. Lists can be used to make multiple assignments at once, and can be passed as arguments to several built-in and user-defined functions:\n\nNote\n\nParentheses are not required in the construction of a list. They are used only for precedence.\n\nWhen creating a list of several strings that do not include spaces, Perl provides a shortcut to get around typing multiple quotes and commas. Instead of\n\nyou can use the qw// operator. This operator uses any non-alpha-numeric character as a delimiter (typically the / character), and encloses a space-separated sequence of barewords. A delimiter separates the command with the arguments. The above line is identical to the following:\n\nand both are equal to this:\n\nThe last example uses the open and close parenthesis as a different delimiter. If there is an open and close version of the delimiter you choose, you need to use them both. Otherwise just repeat the same symbol twice. For example, you cannot type qw<Paul Michael< you have to type qw<Paul Michael>.\n\nYou can also abuse the glob syntax, when the strings do not include shell metacharacters:\n\nNote\n\nThe resulting strings from the qw// operator are single-quoted, meaning no interpolation happens in the set. If you need to include a variable in your list, you cannot use this method.\n\nAs shown above, lists can be used to make several assignments at once. If the number of variables on the left is the same as the number of values on the right, all variables are assigned to their corresponding values, as expected.\n\nIf there are fewer variables on the left than values on the right, the 'extra' values are simply ignored:\n\nIf there are more variables on the left than values on the right, the 'extra' variables are assigned the default undef value:\n\nThe existence of list assignment creates the ability to 'swap' two variables' values without the need of an intermediary temporary variable:\n\nAn array in Perl is a variable that contains a list. An array can be modified, have elements added and removed, emptied, or reassigned to an entirely different list. Just as all scalar variables start with the $ character, all array variables start with the @ character.\n\nNote\n\nIt is a common and frequent mistake in Perl to use the terms 'list' and 'array' interchangeably. They do not have the same meaning.\n\nA decent analogy is that a list (such as qw/foo bar baz/) is to an array (such as @values) as a string (such as 'Paul') is to a scalar variable (such as $name).\n\nArrays are assigned lists of values. The list of values can be arbitrarily large or small (it can even contain 0 elements).\n\nThat last example exemplifies a feature of Perl known as 'array flattening'. When an array is used in a list, it is the array's elements that populate the list, not the array itself. As stated above, a list is a set of scalar values only. Therefore, the @all array contains 1000 elements, not 2.\n\nNote\n\nAlthough this implies you cannot create an 'array of arrays', or 'two-dimensional arrays', such things do exist in Perl. They are simulated by using references.\n\nWhen an array is used in scalar context - either by assigning a scalar variable to the array's value, or using it in an operation or function that expects a scalar - the array returns its size. That is, it returns the number of elements it currently contains\n\nNote\n\nA common misconception is that a list in scalar context will also return its size. This is untrue. In fact, there is no such thing as a list in scalar context: using the comma operator in a scalar context does not create a list, instead it evaluates each of its arguments, left to right, and returns the last one:\n\n$name=('Paul','Michael','Jessica','Megan'); print\"The last name in my list is $name\\n\";\n\nThere are two general ways of printing the values of an array. You can either print the list of items in the array directly, or you can interpolate the array in a double-quoted string.\n\nIn the first example, the print function is being given a list of 6 arguments: the string 'My names are: ', each of the four values in @names, and the string \".\\n\". Each argument is printed separated by the value of the $, variable (that defaults to the empty string), resulting in the values from the array being 'squished' together:\n\nMy names are: PaulMichaelJessicaMegan.\n\nIn the second example, the print function is being given exactly one argument: a string that contains an interpolated array. When Perl interpolates an array, the result is a string consisting of all values in the array separated by the value of the $\" variable (that defaults to a single space):\n\nMy names are: Paul Michael Jessica Megan.\n\nNote\n\nBoth the $, and $\" variables can be changed to any string you like. For example, to separate the array's items with a comma and a space instead of just a space:\n\n$\"=', '; print\"My names are: @names.\\n\";\n\nMy names are: Paul, Michael, Jessica, Megan.\n\nYou generally do not want to do that as this may cause problems in other parts of your program depending on the default values of those variables though! A safer way to print your arrays with custom separator will be explained later.\n\nThe elements of an array are accessed using a numerical reference within square brackets. Because each item within an array is a scalar value, you need to use $ when referencing a value. The first element of an array is number 0 and all the others count up from there.\n\nA negative number will count down from the right side of the array. This means that -1 references the last element of the array and -3 references the third to last element. Let's see some examples:\n\nWhat if you need to know the last index? $#array will return it for you:\n\nA common mistake is to do this:\n\nIn fact @array[0] is a slice (that is, a sub-array of an array) that contains one element, whereas $array[0] is a scalar that contains the value 1.\n\nAs you may wonder, Perl scripts support command line arguments. The entire list of parameters is stored in the array @ARGV, with the first entry containing the first command line argument. If no command line parameters were passed, @ARGV is an empty array.\n\nThe array functions and operators listed above can easily be used to detect the passed command line arguments and to detect the number of arguments provided.\n\nData Structures/Arrays\n\nList Functions\n\nArray Functions\n\nPerl Arrays\n\nA Perl hash is similar to an ordinary array, but instead of using integer indexes, a hash uses \"keys\" that can take on any scalar value. These are usually strings or numbers.\n\nSyntax: instead of the @ operator, associative arrays use the % symbol, and rather than square brackets [], as in $myarray[0], hash elements are referenced using curly brackets {}, as in $myhash{\"george\"}.\n\nHashes are one of the most powerful and commonly used features in Perl. A typical use would be to build a hash that contains a \"dictionary\", with each key being a word in the dictionary, and the corresponding values being the definitions of those words.\n\nA hash containing the sounds various household pets make is below\n\n'=>' and ',' are actually interchangeable, so the right side could look exactly like an array. This means that you can assign an array to a hash. In such an assignment, each element with an even index (starting from 0) in the array becomes a key in the hash. The following statements create the same hash as the previous one does\n\nBut the first style is more preferred because it makes the statement more readable.\n\nTo access a hash element, use the curly brackets:\n\nwill print the following to STDOUT\n\nThe cat goes meow.\n\nTo add a new sound item to a hash\n\nTo overwrite an existing element, just reassign it\n\nTo remove an item from a hash, use delete. Setting the value to undef does not delete the item; using exists on a key that has been set to undef will still return true.\n\nOriginally, a \"hash\" was called an \"associative array\", but this term is a bit outdated (people just got sick and tired of using seven syllables). Although it isn't intuitive for newcomers to programming, \"hash\" is now the preferred term. The name is derived from the computer science term, hashtable.\n\nIf you know PHP, you may have thought by now of some convenient way to print the contents of your array the way print_r does...\n\nTo get the size of the hash, simply find the size of the result of the keys function, by evaluating it in scalar context:\n\nYou can define multidimensional hash array variables. An example may look like this:\n\nThis code will produce:\n\n1 a A FIRST 1 b C SECOND 1 c B THIRD $VAR1 = { '1' => { 'c' => { 'B' => 'THIRD' }, 'a' => { 'A' => 'FIRST' }, 'b' => { 'C' => 'SECOND' } } };\n\nInput/output, or IO, is an all-encompassing term that describes the way your program interacts with the user. IO comes in two forms, or stream types: the program's stimuli are collectively referred to as input, while the medium that the program uses to communicate back, write logs, play sounds, etc. is known as output. Both types of streams can be redirected either at a lower level than Perl, as is the case when done through the operating system by the shell; or, in Perl itself, as is the case when you reopen the file handles associated with the stream.\n\nYou have already learned how to output with the print statement. A simple reference is provided:\n\nWhat this print statement is actually doing is printing to STDOUT, which stands for standard output. Standard output is the default destination for all output. If you wish to print anywhere else you must be explicit. We will revisit this later.\n\nAs you may have imagined, it's very hard to write a good program without any type of input; here is an example program to teach you these concepts:\n\nStandard input is usually the keyboard though this can be changed at a lower level than your program. For now we will assume it isn't changed. However, this might not be an assumption you wish to make in production code.\n\nWrite a program that prompts the user for a number and then returns the number multiplied by four (or any other number).\n\nIn many situations, especially for web programming, you will find that you want to put certain things, such as backslashes or quotes, in your text that aren't allowed in a traditional print statements. A statement such as\n\nprint \"I said \"I like mangos and bananas\". \";\n\nwill not work because the interpreter would think that the quotes mark the end of the string. As with all things in Perl, there are many solutions to this problem.\n\nThe quickest solution to this problem would be to use single quotes to surround the string, allowing the use of double quotes in the middle.\n\n# I said \"I like mangos and bananas\". print 'I said \"I like mangos and bananas\".';\n\nThis is obviously not the best solution, as it is conceivable that you are trying to print a string containing both kinds of quote:\n\n# I said \"They're the most delicious fruits\". print 'I said \"They're the most delicious fruits\".';\n\nFor situations like the above where only a short amount of text is being quoted, a common solution is to escape any quotes in the string. By preceding any quotes with a backslash they are treated as literal characters.\n\nUsing single quotes, the characters that require escaping are \\'.\n\nUsing double quotes, the characters that need escaping are the variable sigils, (i.e. $@%*) in addition to \\\"\n\nUsing \\ to escape reserved characters of course implies that you also need to escape any backslashes you want to use in your string. To print the second line literally using perl, you would need to write:\n\nLuckily, Perl provides us with another way of quoting strings that avoids this problem.\n\nPerl provides the operators q and qq that allows you to decide that characters are used to quote strings. Most punctuation characters can be used. Here are a few examples:\n\nThe only symbols I have found that cannot be used for these quotes are $ ` /\n\nAs can be seen, while the custom quotes option works for short strings, it can run into problems, if a lot of text containing a lot of punctuation is output. For this situation, a technique called Block quoting can be used.\n\nAny string of characters can be used instead of OUTPUT in the example above. Using this technique anything can be output no matter what characters it contains. The one caveat of this method is that the closing OUTPUT must be the first character on the line, there cannot be any space before it.\n\nIt is possible to output variables within strings when you use some of these methods:\n\nPerl will figure out where your variable ends, if the character after it is neither a letter, number nor an underscore. If that is not your case, put your variable inside curly braces:\n\nThe single quote ' q{ and double quote \" qq <<A operators, behave differently. Whereas when using double quotes, you can include variables and escape any characters, when you use single quotes you can only escape single quotes and you cannot include variables.\n\nThe basic control structures do not differ greatly from those used in the C programming language or Java programming language:\n\nThough syntactically the same, Perl does not use break and continue to change the flow of loops. Perl provides the following commands: (with C equivalents in comments)\n\nNote that the statements in a while (or until) loop are not executed, if the Boolean expression evaluates to false (or true, respectively) on the first pass, even when specified at the end of the code block. Therefore the following loops are functionally equivalent: (the same applies to: do {} until)\n\nThe do {} while and the do {} until loops are technically statement modifiers and not actual control structures. The statements will be executed at least once.\n\n$variable is an alias to each element of the @list, starting at the first element on the first pass through the loop. The loop is exited when all the elements in the list have been exhausted. Since $variable is an alias, changing the value will change the value of the element in the list. This should generally be avoided to enhance maintainability of the code.\n\nIf $variable is omitted, the default variable $_ will be used.\n\nNote that for and foreach are actually synonyms and can be used interchangeably.\n\nBlocks may have an optional continue section, which is executed at the end of each iteration.\n\nWhen inside a loop, there are three keywords that manipulate how the loop is handled.\n\nTo start the next iteration, next jumps to the end of the block. If there is a continue block, that part is executed, as is the conditional to resume the loop.\n\nTo restart an iteration, redo jumps to the beginning of the block. Neither continue nor the conditional are executed.\n\nTo break out of the loop, last jumps outside the end of the block. Neither continue nor the conditional are executed.\n\nUntil version 5.10.1, Perl did not have an equivalent of the switch statement in other programming languages. Starting in that version, it became an experimental feature.\n\nIn Perl 5, it first needs to be enabled with one of the following statements:\n\nBy default, the expressions in when is matched to what is found in given. In certain exceptional cases, the value may be used directly as a boolean.\n\nStatements with else blocks (these also work with unless instead of if)\n\nControl statements can also be written with the conditional following the statements (called \"postfix\"). This syntax functions (nearly) identically to the ones given above.\n\nstatement if Boolean expression; statement unless Boolean expression; statement while Boolean expression; statement until Boolean expression; statement foreach list;\n\nThis method will read the whole file into an array. It will split on the special variable $/\n\nThis method will read the file one line at a time. This will keep memory usage down, but the program will have to poll the input stream on each iteration.\n\nUsing IO::File, you can get a more modern object-oriented interface to a Perl file handle.\n\nIn addition to the basic control structures, Perl allows the use of statement modifiers. The statement modifier is placed at the end of the statement that it modifies. Note that the do {…} until (…) and do {…} while (…) loop constructs are actually statement modifiers. The complete list of modifiers is:\n\nstatement ⇗\n\n⇘ if ⇘\n\n⇗ expression while statement ⇗\n\n⇘ unless ⇘\n\n⇗ expression until statement ⇒ foreach ⇒ list\n\nUnlike BASIC-PLUS, statement modifiers in Perl cannot be stacked.\n\nRemoves the last characters from a string only if they're recognized as a record separator (e.g. a newline character)\n\n?\n\nchomp($String = $_);\n\nchomp; # removes the last character from $_ if it is a record separator chomp(); # (same) chomp($String); # removes the last character from $String if it is a record separator\n\nchop - To remove the last character from a string\n\nRemoves the last character from a string regardless\n\n?\n\nchop($String = $_);\n\nchop; # removes the last character from $_ chop(); # (same) chop($String); # removes the last character from $String\n\nchomp - To remove the last character from a string if it is a record seperator\n\nRemoves the last character from a string (e.g. removes the newline characters when reading from a file)\n\nprint chr(65); # Prints a capital A\n\nGets an ASCII character, given it's code\n\n# One-way hash function my $HashedWord = crypt($Word, $Salt);\n\n(See also MD5 )\n\nThe salt string needs only be two characters long, and provides a way of randomising the hash, such that the same word can produce several different hashes, if used with different values of $Salt;!\n\nprint hex(11); # Prints B\n\nConverts a number to hexadecimal\n\nOther way around - converts hex to number: print hex(11); # prints 17\n\nyou can use\n\nprint sprintf(\"%X\",11); # Prints B\n\nSearch for one string within another (see rindex to search from end-to-start).\n\n$Result = index($Haystack, $Needle); $Result = index($Haystack, $Needle, $StartPosition);\n\nindex(\"Some text\", \"bleh\"); # Returns -1 (not found) index(\"Some text\", \"Some\"); # Returns 0 (first character) index(\"Some text\", \"text\"); # Returns 5 (sixth character)\n\nThe special variable $[ always gets added to the return value, but $[ is normally 0, and the manual recommends leaving it at 0.\n\n$Lowercase = lc($String);\n\nConverts a string to lower-case\n\nConverts the first character of a string to lowercase\n\nprint \"String is \" . length($String) . \" characters long\\n\";\n\nReturns the length of a string\n\nprint oct(8); # Prints 10\n\nConverts a number to octal\n\nConverts a character to its number.\n\nprint ord(\"A\"); # prints 65\n\nTakes a list and converts it into a string using a supplied set of rules.\n\nmy $String = pack($Template, @ListOfNumbers); my $String = pack(\"CCCC\",65,66,67,68); # Result: \"ABCD\"\n\n$Template can be made up of:\n\na A string with arbitrary binary data, will be null padded. A An ascii string, will be space padded. Z A null terminated (asciz) string, will be null padded.\n\nb A bit string (ascending bit order inside each byte, like vec()). B A bit string (descending bit order inside each byte). h A hex string (low nybble first). H A hex string (high nybble first).\n\nc A signed char value. C An unsigned char value. Only does bytes. See U for Unicode.\n\ns A signed short value. S An unsigned short value. (Exactly 16 bits unless you use the ! suffix)\n\ni A signed integer value. I An unsigned integer value. (At least 32 bits wide, machine-dependent)\n\nl A signed long value. L An unsigned long value. (Exactly 32 bits unless you use the ! suffix)\n\nn An unsigned short in \"network\" (big-endian) order. N An unsigned long in \"network\" (big-endian) order. v An unsigned short in \"VAX\" (little-endian) order. V An unsigned long in \"VAX\" (little-endian) order. (Exactly 16 bits and 32 bits respectively)\n\nq A signed quad (64-bit) value. Q An unsigned quad value. (Only available if your system supports 64-bit integers and Perl has been compiled to support them)\n\nf A single-precision float in the native format. d A double-precision float in the native format.\n\np A pointer to a null-terminated string. P A pointer to a structure (fixed-length string).\n\nu A uuencoded string. U A Unicode character number. Encodes to UTF-8 internally.\n\nw A BER compressed integer. Its bytes represent an unsigned integer in base 128, most significant digit first, with as few digits as possible. Bit eight (the high bit) is set on each byte except the last.\n\nx A null byte. X Back up a byte. @ Null fill to absolute position.\n\nEach letter may optionally be followed by a number giving a repeat count.\n\nThe integer types s, S, l, and L may be immediately followed by a ! suffix to signify native shorts or longs\n\nReverses a string (in scalar context) or a list (in list context):\n\nmy @ReversedList = reverse(@List);\n\n# As commonly seen in Perl programs: foreach( reverse( sort( @List ))) { ... }\n\nmy $ReversedString = reverse($String);\n\nmy @List = (\"One \", \"two \", \"three...\"); my $ReversedListAsString = reverse(@List); # Prints \"...eerht owt enO\"\n\nSearch for one string within another, starting at the end of the string.\n\n$Result = rindex($Haystack, $Needle); $Result = rindex($Haystack, $Needle, $StartPosition);\n\nrindex(\"Some text\", \"bleh\"); # Returns -1 (not found) rindex(\"Some text\", \"Some\"); # Returns 0 (first character) rindex(\"abbbbb\", \"b\"); # Returns 5 (first \"b\" found, when starting at the end)\n\nPrints a formatted string:\n\nmy $Text = sprintf(\"%d/%d is %08.5f\", 1, 3, 1/3); # Result: \"10/3 is 003.33333\"\n\nsprintf(\"Character: %c\", 65); sprintf(\"String %s\", \"Hello\"); sprintf(\"Signed integer: %d\", 15); sprintf(\"Unsigned integer: %u\", 15); sprintf(\"Unsigned int (in octal): %o\", 15); sprintf(\"Unisgned int (in hex): %x\", 15); # Use %X to get upper-case output sprintf(\"Binary number: %b\", 15); sprintf(\"Scientific notation: %e\", 5000); # Use %E to get upper-case output sprintf(\"Floating point number: %f\", 1/3); # 0.3333333 sprintf(\"Floating point number: %g\", 1/3); # Decides between scientific and float. %G is uppercase sprintf(\"Pointer: %p\", $Variable);\n\nUse %% to get a percent-sign.\n\nUse %n to request the number of characters written so far, and put it into the next variable in the list. You may want to check that user-supplied formatting rules don't contain this code.\n\nsprintf(\"%02d\", $Minutes); # Forces leading zeros to make the string two characters long sprintf(\"%1.5f\", $Number); # Limits the number of decimal places\n\nReturn part of a string (a substring)\n\nFormat: substr string start-position length\n\nstart-position is zero-based.\n\nA negative number starts from the end of the string.\n\n$FirstLetter = substr($Text, 0, 1); # First letter $First3Letters = substr($Text, 0, 3); # First three letters $Last3Letters = substr($Text, -3); # Last three letters\n\nYou can use substr on the left side of an assignment statement to change part of a string. This can actually shorten or lengthen the string.\n\n$text = 'cat dog'; substr ($mystring, 3, 1) = ' and '; # $text now contains 'cat and dog'\n\n$Uppercase = uc($String);\n\nConverts a string to upper-case\n\nConverts the first character of a string to uppercase\n\nReturns the absolute (positive) value of a number\n\n$Number = abs(-100); # Returns 100;\n\n# Converts cartesian(x,y) coordinates into an angle $Number = atan2($Y, $X);\n\n# Returns the cosine of an angle (radians) $Number = cos($Angle); # Cosine = Adjacent/Hypotenuse\n\n# Raises e to a specified power $Number = exp(2); # Returns e^2\n\ne ≈ 2.71828183 more about e\n\n# Interprets a string as hexidecimal, and returns its value $Number = hex(\"10\"); # Returns 16 $Number = hex(\"0xFF\"); # Returns 255\n\nRounds a number towards zero, returning an integer\n\n$Number = int(-1.6); # Returns -1 $Number = int(0.9); # Returns 0 $Number = int(28.54); # Returns 28\n\n# Returns the natural logarithm of a number $Number = log(2.71828183); # Returns 1 $Number = exp(log($X)); # Returns $X $Number = log($X)/log(10); # Returns log10($X). Alternately, you can use the log10() function in the POSIX module $Number = log($X)/log(15); # Returns log to the base 15 of $X\n\n# Interprets a string as octal, and returns its value $Number = oct(\"10\"); # Returns 8 $Number = oct(\"21\"); # Returns 17\n\n# Gets a random number (may automatically call srand() if that's not been done) $Number = rand(); # Returns a random number from 0 to 1 $Number = int(rand(800)); # Returns a random integer from 0 to 799 $Number = 1 + int(rand(999)); # Returns a random integer from 1 to 999\n\n# Returns the sine of an angle (radians) $Number = sin($Angle); # Sine = Opposite/Hypotenuse\n\n# Returns the square-root of a number $Number = sqrt(4); # Returns 2 $Number = sqrt($X ** 2 + $Y ** 2); # Returns the diagonal distance across a $X x $Y rectangle\n\nSee the Math::Complex module, if you need to take roots of negative numbers.\n\n# Seeds (sets-up) the random-number generator srand();\n\nVersion-dependent, and older versions of Perl are not guaranteed to have a good seed value. See the Math::TrulyRandom module for more possibilities. The current version of Perl uses the urandom device if it's available.\n\n$LastElement = pop(@MyArray);\n\nTake the last element from an array.\n\npush(@MyArray, \"Last element\"); push(@MyArray, \"several\", \"more\", \"elements\");\n\nPush a list of elements onto the end of an array.\n\nshift(@MyArray); # Delete the first element $FirstElement = shift(@MyArray); # Delete the first element, load it into $FirstElement instead\n\nTake the first element out of an array.\n\n# Removes elements from an array, optionally replacing them with a new array splice(@Array); # Removes all elements from array splice(@Array, 10); # Removes from element 10 to the end of the array splice(@Array, -10); # Removes the last 10 elements of the array splice(@Array, 0, 10); # Removes the first 10 elements of the array @NewArray = splice(@Array, 0, 10); # Removes the first 10 elements of the array and returns those 10 items splice(@Array, 0, 10, @Array2); # Replaces the first 10 elements of the array with Array2\n\nunshift(@MyArray, \"New element\"); unshift(@MyArray, \"several\", \"more\", \"elements\");\n\nAdd a list of elements onto the beginning of an array.\n\n# Returns a list of elements for which an expression is true @TextFiles = grep(/\\.txt$/, @AllFiles); $NumberOfTextFiles = grep(/\\.txt$/, @AllFiles);\n\n# Can use a block of code instead of an expression @TextFiles = grep({return(substr($_, -3) eq \"txt\");}, @AllFiles);\n\n# Joins the items of a list into a single string $OneItemPerLine = join( \"\\n\", @List); $EverythingBunchedTogether = join( \"\", @List); $Filename = join( \"/\", ($Directory, $Subdirectory, $Filename));\n\n# Evaluates a block of code for each item in a list, and returns # a list of the results @UppercaseList = map(uc, @List); @Numbers = map {\"Number $_\"} 1..100;\n\n# Reverses the order of a list @ReversedList = reverse(@List); # In scalar context, concatenates the list and then reverses the string $ReversedString = reverse('foo','bar','baz'); # gives 'zabraboof'\n\n# Sorts the elements in a list @AsciiSort = sort(@RandomList); @AsciiSort = sort @RandomList; foreach $Item (sort @RandomList) {...}\n\n# Can specify a function to decide the sort order @CaseInsensitiveSort = sort {uc($a) cmp uc($b)} @RandomList; @NumericSort = sort {$a <=> $b} @RandomList; @CustomSort = sort custom_function_name @RandomList;\n\nUnpacks a string into a list - see the templates available for the pack() function for details\n\n# Remove an element from a hash %h = ('a'=>1, 'cow'=>'moo', 'b'=>2); delete $h{cow}; # %h now contains ('a'=>1, 'b'=>2)\n\n# Return the 'next' key/value pair (in a random order) while (($key, $value) = each (%hash)) { print \"$key => $value\\n\"; }\n\n# Tests whether or not a key exists in a hash (even if the value for that key is undef) if (exists $hash{$key}) { print \"\\%hash contains a value for key '$key'\\n\"; }\n\n# Returns a list of all keys from the hash, in same 'random' order as each foreach $key (keys %hash) { print \"$key => $hash{$key}\\n\"; }\n\n# Returns a list of all values from the hash, in same 'random' order as keys foreach $value (values %hash) { print \"\\%hash contains a value '$value'\\n\"; }\n\n# closes a filehandle when it is no longer needed close(STDERR); # hide debugging info from the user\n\n# Close a directory open by opendir closedir(DIRHANDLE);\n\nExits the program, printing to \"STDERR\" the first parameter and the current file and line. Used to trap errors.\n\nThis function returns true, if the next read on FILEHANDLE would return end-of-file, or if FILEHANDLE is not open. FILEHANDLE may be an expression whose value gives the real filehandle, or a reference to a filehandle object of some sort. An eof without an argument returns the end-of-file status for the last file read. An eof() with empty parentheses () tests the ARGV filehandle (most commonly seen as the null filehandle in <>). Therefore, inside a while (<>) loop, an eof() with parentheses will detect the end of only the last of a group of files. Use eof (without the parentheses) to test each file in a while (<>) loop. For example, the following code inserts dashes just before the last line of the last file:\n\nOn the other hand, this script resets line numbering on each input file:\n\nLike \"$\" in a sed program, eof tends to show up in line number ranges. Here's a script that prints lines from /pattern/ to end of each input file:\n\nHere, the flip-flop operator (..) evaluates the pattern match for each line. Until the pattern matches, the operator returns false. When it finally matches, the operator starts returning true, causing the lines to be printed. When the eof operator finally returns true (at the end of the file being examined), the flip-flop operator resets, and starts returning false again for the next file in @ARGV\n\nPrints the parameters given.\n\nDiscussed in the following sections:\n\nDigression on print in Strings section\n\nSee the entry for pack further up the page\n\n# Reads data from a file-handle read(FILEHANDLE, $StoreDataHere, $NumberBytes);\n\n# Returns the number of bytes read $NumberBytesRead = read(FILEHANDLE, $StoreDataHere, $NumberBytes);\n\n# Optional offset is applied when the data is stored (not when reading) read(FILEHANDLE, $StoreDataHere, $NumberBytes, Offset);\n\n# Runs a system command syscall( $Command, $Argument1, $Argument2, $Argument3);\n\n# (maximum 14 arguments) $ReturnValue = syscall($Command);\n\n# See the pack function for details (unpack does the opposite!) unpack($Template, $BinaryData);\n\nif (-r $FullFilename) // File is readable by effective uid/gid. if (-w $FullFilename) // File is writable by effective uid/gid. if (-x $FullFilename) // File is executable by effective uid/gid. if (-o $FullFilename) // File is owned by effective uid.\n\nif (-R $FullFilename) // File is readable by real uid/gid. if (-W $FullFilename) // File is writable by real uid/gid. if (-X $FullFilename) // File is executable by real uid/gid. if (-O $FullFilename) // File is owned by real uid.\n\nif (-e $FullFilename) // File exists. if (-z $FullFilename) // File has zero size. if (-s $FullFilename) // File has nonzero size (returns size).\n\nif (-f $FullFilename) // File is a plain file. if (-d $FullFilename) // File is a directory. if (-l $FullFilename) // File is a symbolic link. if (-p $FullFilename) // File is a named pipe (FIFO), or Filehandle is a pipe. if (-S $FullFilename) // File is a socket. if (-b $FullFilename) // File is a block special file. if (-c $FullFilename) // File is a character special file. if (-t $FullFilename) // Filehandle is opened to a tty.\n\nif (-u $FullFilename) // File has setuid bit set. if (-g $FullFilename) // File has setgid bit set. if (-k $FullFilename) // File has sticky bit set.\n\nif (-T $FullFilename) // File is an ASCII text file. if (-B $FullFilename) // File is a \"binary\" file (opposite of -T).\n\n$Age = -M $FullFilename; // Age of file in days when script started. $Age = -A $FullFilename; // Same for access time. $Age = -C $FullFilename; // Same for inode change time.\n\nchdir $Directory; chdir $Directory || die(\"Couldn't change directory\");\n\nchmod 0744 $File1; chmod 0666 $File1, $File2, $File3; # 0 for octal, at the beginning of a number\n\n| Owner | Group | Others | Execute | 4 | 4 | 4 | Write | 2 | 2 | 2 | Read | 1 | 1 | 1 | ======--+======-+======-+======--+ Total | | | |\n\n# Change the owner of a file chown($NewUserID, $NewGroupID, $Filename); chown($\n\nNewUserID $NewGroupID, $File1, $File2, $File3); NewUserID, $NewGroupID, $File1, $File2, $File3);\n\nchown($NewUserID, -1, $Filename); # Leave group unchanged chown(-1, $NewGroupID, $Filename); # Leave user unchanged\n\nchroot $NewRootDirectory;\n\nSets the root directory for the program, such that the \"/\" location refers to the specified directory.\n\nProgram must be running as root for this to succeed.\n\n# Expands filenames, in a shell-like way my @TextFiles = glob(\"*.txt\");\n\nSee also File::Glob.\n\n# Creates a link to a file link($ExistingFile, $LinkLocation); link($ExistingFile, $LinkLocation) || die(\"Couldn't create link\");\n\nIdentical to stat(), except that if given file is symbolic link, stat link not the target.\n\nmkdir $Filename || die(\"Couldn't create directory\"); mkdir $Filename, 0777; # Make directory with particular file-permissions\n\nopen(my $FileHandle, $Filename) || die(\"Couldn't open file\"); open(my $fp, \"<\", $Filename); # Read from file open(my $fp, \">\", $Filename); # Write to file open(my $fp, \">>\", $Filename); # Append to file\n\nopen(my $fp, \"<$Filename\"); # Read from file open(my $fp, \">$Filename\"); # Write to file open(my $fp, \">>$Filename\"); # Append to file\n\nopen(my $fp, \"<\", \"./ filename with whitespace \\0\"); open(my $fp, \"<\", \"./->filename with reserved characters\\0\");\n\nopen(my $fp, \"$Program |\"); # Read from the output of another program open(m myy $fp, \"| $Program\"); # Write to the input of another program\n\nopen(my $fp, \"<\", \"-\"); # Read from standard input open(my $fp, \">\", \"-\"); # Write to standard output\n\nopendir(my $DirHandle, $Directory) || die(\"Couldn't open directory\");\n\nwhile (my $Filename = readdir $DirHandle) { # Do something with $Filename in $Directory } closedir($DirHandle);\n\nopendir(DIR, $Directory) || die(\"Couldn't open directory\");\n\nforeach(readdir(DIR)) { # Do something with $_ in $Directory } closedir(DIR);\n\n# Finds the value of a symbolic link $LinkTarget = readlink($LinkPosition);\n\nrename $OldFile, $NewFile or die(\"Couldn't move file\");\n\nMay work differently on non-*nix operating systems, and possibly not at all when moving between different filesystems. See [[File::Copy]] for more complicated file operations.\n\nrmdir $Filename || die(\"Couldn't remove directory\");\n\nstat\n\n$DeviceNum = $FileStatistics[0]; # device number of filesystemcs[0]; # device number of filesystem $Inode = $FileStatistics[1]; # inode number $FileMode = $FileStatistics[2]; # (type and permissions) $NumHardLinks = $FileStatistics[3]; # number of (hard) links to the file $UserID = $FileStatistics[4]; # numeric user ID $GroupID = $FileStatistics[5]; # numeric group ID $DeviceIdent = $FileStatistics[6]; # Device identifier (special files only) $SizeBytes = $FileStatistics[7]; $AccessTime = $FileStatistics[8]; # seconds since the epoch $ModifyTime = $FileStatistics[9]; $ChangeTime = $FileStatistics[10]; $BlockSize = $FileStatistics[11]; $NumBlocks = $FileStatistics[12];\n\n# Creates a new filename symbolically linked to the old filename symlink($OldFilename, $NewFilename); symlink($OldFilename, $NewFilename) || die(\"Couldn't create symlink\"); eval(symlink($OldFilename, $NewFilename));\n\n# Sets or returns the umask for the process. my $UMask = umask(); umask(0000); # This process can create any type of files umask(0001); # This process can't create world-readable files umask(0444); # This process can't create executable files\n\n# Deletes a file unlink $Filename; unlink $Filename || die(\"Couldn't delete file\"); unlink $File1, $File2, $File3; (unlink($File1, $File2, $File3) == 3) || die(\"Couldn't delete files\");\n\n# Updates the modification times of a list of files my $AccessTime = time(); my $ModificationTime = time();\n\nutime($AccessTime, $ModificationTime, $Filename); my $NumFilesChanged = utime($AccessTime, $ModificationTime, $File1, $File2, $File3);\n\nReturns information about the current function call stack. In scalar context, returns only the name of the package from where the current subroutine was called. In list context, returns the package, filename, and line number. In list context with a numeric argument passed, returns several pieces of information (see below). The argument represents how many levels in the call stack to go back.\n\n# !/usr/bin/perl\n\nfoo(); sub foo { $package = caller; # returns 'main' ($package, $filename, $line) = caller; # returns 'main', the file name, and 3 # Line below returns all 10 pieces of info. (Descriptions self-explanatory from variable names) ($package, $filename, $line, $subroutine, $hasargs, $wantarray, $evaltext, $is_require, $hints, $bitmask) = caller(0); }\n\nThere is no actual 'import' function. Rather, it is a convention when writing a module to create a subroutine named 'import' that populates the current namespace with that module's needed variables or methods.\n\nThe standard 'Exporter' module provides an import method, if your class has it as a base class.\n\nDeclares all lines that follow (until EOF or the next package statement) to belong to the given package's namespace.\n\n# !/usr/bin/perl\n\n$x = 5; # sets $main::x\n\npackage Foo; $x = 5; # sets $Foo::x sub bar { # defines &Foo::bar print \"hello world\"; }\n\npackage Temp; $x = 5; # sets $Temp::x\n\nincludes the specified module's code into the current program. The module can be specified either with an absolute or relative path, or with a bareword. If a bareword is given, a '.pm' extention is added, and :: is replaced with the current operating system's path seperator:\n\nrequire Foo::Bar; # identical to: require 'Foo/Bar.pm';\n\nRequires and imports the given module or pragma, at compile time. The line\n\nuse Foo qw/bar baz/;\n\nis identical to\n\nBEGIN { require Foo; import Foo qw/bar baz/; }\n\n# returns true, if argument is not undef $x = 0; print \"X defined\\n\" if defined $x; # prints print \"Y defined\\n\" if defined $y; # does not print\n\neval('$a = 30; $b = 40;'); print $a, $b;\n\n# assigns temporary value to global variable for duration of lexical scope $x = 5; print \"x = $x\\n\"; # 5 { local $x = 10; print \"x = $x\\n\"; # 10 } print \"x = $x\\n\"; # 5\n\n# creates new lexical (ie, not global) variable $x = 5; # refers to $main::x { my $x = 10; print \"x = $x\\n\"; # the lexical - 10 print \"main's x = $main::x\\n\" # the global - 5 } print \"x = $x\\n\"; # the global, because no lexical in scope - 5\n\n# resets hash's internal pointer, to affect lists returned by each while ($k, $v = each %h) { print \"$k = $v\\n\"; last if ($i++ == 2); } # if another each done here, $k,$v will pick up where they left off. reset %h # now each will restart from the beginning.\n\n# forces scalar context on an array @sizes = (scalar @foo, scalar @bar); # creates a list of the sizes of @foo and @bar, rather than the elements in @foo and @bar\n\n# undefines an existing variable $x = 5; undef $x; print \"x = $x\\n\" if defined $x; # does not print\n\n# returns 'true', 'false', or undef if function that called it was called in list, scalar, or void context, respectively. sub fctn { my @vals = (5..10); if (wantarray) { return @vals; } elsif (defined wantarray) { return $vals[0]; } else { warn \"Warning! fctn() called in void context!\\n\"; } }\n\n# clones the current process, returning 0 if clone, and the process id of the clone if the parent my $pid = fork();\n\nif ($pid == 0) { print \"I am a copy of the original\\n\"; } elsif ($pid == -1) { print \"I can't create a clone for some reason!\\n\"; } else { print \"I am the original, my clone has a process id of $pid\\n\"; }\n\nSee also Perl Objects\n\nConverts a timestamp to GMT.\n\n@TimeParts = gmtime(); @TimeParts = gmtime($Time);\n\n$Seconds = $TimeParts[0]; # 0-59 $Minutes = $TimeParts[1]; # 0-59 $Hours = $TimeParts[2]; # 0-23 $DayOfMonth = $TimeParts[3]; # 1-31 $Month = $TimeParts[4]; # 0-11 $Year = $TimeParts[5]; # Years since 1900 $DayOfWeek = $TimeParts[6]; # 0:Sun 1:Mon 2:Tue 3:Wed 4:Thu 5:Fri 6:Sat $DayOfYear = $TimeParts[7]; # 1-366\n\nConverts a timestamp to local time.\n\n@TimeParts = localtime(); @TimeParts = localtime($Time);\n\n$Seconds = $TimeParts[0]; # 0-59 $Minutes = $TimeParts[1]; # 0-59 $Hours = $TimeParts[2]; # 0-23 $DayOfMonth = $TimeParts[3]; # 1-31 $Month = $TimeParts[4]; # 0-11 $Year = $TimeParts[5]; # Years since 1900 $DayOfWeek = $TimeParts[6]; # 0:Sun 1:Mon 2:Tue 3:Wed 4:Thu 5:Fri 6:Sat $DayOfYear = $TimeParts[7]; # 1-366\n\n$Time = time();\n\nReturns number of seconds since an epoch (that is system-dependent, but may be 1970-01-01).\n\nSee also Time::Hires\n\n@CPUTimes = times(); $UserTimeForProcess = $CPUTimes[0]; $SystemTimeForProcess = $CPUTimes[1]; $UserTimeForChildren = $CPUTimes[2]; $SystemTimeForChildren = $CPUTimes[3];\n\nSome functions in perl reverse or otherwise cancel the effect of each other, so running a string through both of them will produce the same output as the input, for example\n\nprint ord(chr(1));\n\nwill echo 1 to standard output,\n\nord() will convert a character to its number in the character set, while chr() will convert a number to its corresponding character, therefore\n\nin the same way that x 2 = x {\\displaystyle {\\sqrt {x^{2}}}=x} and x 2 = x {\\displaystyle {\\sqrt {x}}^{2}=x} in Mathematics (assuming x is non-negative), ord(chr(1)) = 1 and chr(ord(1)) = 1 in Perl.\n\nList of functions that reverse each other:\n\nlc() and uc()\n\nlcfirst() and ucfirst()\n\nord() and chr()\n\njoin() and split()\n\npush() and pop()\n\nunshift() and shift()\n\nThese are a set of eight exercises that can be used to test your ability to write Perl programs. In some cases, these exercises might include material not covered from the textbook; in those cases, you may have to consult your platform documentation to identify a necessary function or otherwise implement one yourself.\n\nExercise 1\n\nExercise 2\n\nExercise 3\n\nExercise 4\n\nExercise 5\n\nExercise 6\n\nExercise 7\n\nExercise 8\n\nperlstyle\n\nSo you've been plodding along with your perl scripts, fiddling with arrays and hashes and suddenly you realize that you would like to pass a function to another function depending on the data you encounter, or perhaps you would like to get back a hash when you look up an array index. References are the thing for you, allowing you to build and pass around ever more complex data structures.\n\nOutput should be I laugh in the face of clowns.\n\nThe curly brackets are optional, but generally recommended.\n\nhttp://perldoc.perl.org/perlref.html\n\nhttp://perldoc.perl.org/perlreftut.html\n\nRegular expressions are tools for complex searching of text, considered one of the most powerful aspects of the Perl language. A regular expression can be as simple as just the text you want to find, or it can include wildcards, logic, and even sub-programs.\n\nTo use regular expressions in perl, use the =~ operator to bind a variable containing your text to the regular expression:\n\nThis returns 1, if \"needle\" is contained within $HayStack, or 0 otherwise.\n\nRegular expression can also be used to modify strings. You can search and replace complex patterns by using the regex format s///\n\n($msg is now \"perl is awesome\")\n\nMetacharacter Description Example\n\nNote that all the if statements return a TRUE value . Matches an arbitrary character, but not a newline.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/...../) { print \"$string1 has length >= 5\\n\"; }\n\n( ) Groups a series of pattern elements to a single element. When you match a pattern within parentheses, you can use any of $1, $2, … $9 later to refer to the previously matched pattern.\n\nProgram:\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/(H..).(o..)/) { print \"We matched '$1' and '$2'\\n\"; }\n\nOutput:\n\nWe matched 'Hel' and 'o W';\n\n+ Matches the preceding pattern element one or more times.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/l+/) { print \"There are one or more consecutive l's in $string1\\n\"; }\n\n? Matches zero or one times.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/H.?e/) { print \"There is an 'H' and a 'e' separated by \"; print \"0-1 characters (Ex: He Hoe)\\n\"; }\n\n? Matches the *, +, or {M,N}'d regexp that comes before as few times as possible.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/(l+?o)/) { print \"The non-greedy match with one or more 'l' print \"followed by an 'o' is 'lo', not 'llo'.\\n\"; }\n\n* Matches zero or more times.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/el*o/) { print \"There is an 'e' followed by zero to many\"; print \"'l' followed by 'o' (eo, elo, ello, elllo)\\n\"; }\n\n{M,N} Denotes the minimum M and the maximum N match count.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/l{1,2}/) { print \"There exists a substring with at least one\"; print \"and at most two l's in $string1\\n\"; }\n\n[...] Denotes a set of possible matches.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/[aeiou]+/) { print \"$string1 contains a one or more\"; print \"vowels\\n\"; }\n\n[^...] Matches any character not in the square brackets.\n\n$string = \"Sky.\"; if (String =~ /[^aeiou]/) { print \"$string doesn't contain any vowels\"; }\n\n| Matches one of the left or right operand.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/(Hello|Hi)/) { print \"Hello or Hi is \"; print \"contained in $string1\"; }\n\n\\b Matches a word boundary.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/ello?\\b/) { print \"There is a word that ends with\"; print \" 'ello'\\n\"; } else { print \"There are no words that end with\"; print \"'ello'\\n\"; }\n\n\\w Matches alphanumeric, including \"_\".\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/\\w/) { print \"There is at least one alpha-\"; print \"numeric char in $string1 (A-Z, a-z, 0-9, _)\\n\"; }\n\n\\W Matches a non-alphanumeric character.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/\\W/) { print \"The space between Hello and \"; print \"World is not alphanumeric\\n\"; }\n\n\\s Matches a whitespace character (space, tab, newline, formfeed)\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/\\s.*\\s/) { print \"There are TWO whitespace \"; print \"characters separated by other characters in $string1\"; }\n\n\\S Matches anything but a whitespace.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/\\S.*\\S/) { print \"There are TWO non-whitespace \"; print \"characters separated by other characters in $string1\"; }\n\n\\d Matches a digit, same as [0-9].\n\n$string1 = \"99 bottles of beer on the wall.\"; if ($string1 =~ m/(\\d+)/) { print \"$1 is the first number in '$string1'\\n\"; } '''Output:''' 99 is the first number in '<tt>99 bottles of beer on the wall.</tt>'\n\n\\D Matches a non-digit.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/\\D/) { print \"There is at least one character in $string1\"; print \"that is not a digit.\\n\"; }\n\n^ Matches the beginning of a line or string.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/^He/) { print \"$string1 starts with the characters 'He'\\n\"; }\n\n$ Matches the end of a line or string.\n\n$string1 = \"Hello World\\n\"; if ($string1 =~ m/rld$/) { print \"$string1 is a line or string\"; print \"that ends with 'rld'\\n\"; }\n\nPerl modules (files that end with the pm extension) are files of Perl code that can be reused from program to program. There is an online repository of Perl modules called CPAN (Comprehensive Perl Archive Network) at http://cpan.org. Many of these modules come standard with Perl, but others must be installed as needed.\n\nThere are thousands of Perl modules that do everything from creating a temporary file to calling Amazon web services. These modules can make it easy to quickly write your application if you know how to find, install, and use the appropriate Perl modules. If you are thinking of writing your own Perl module, the best thing to do is to first search at http://Search.cpan.org to make sure you are not about to reinvent the wheel.\n\nThere are two major styles of Perl modules:\n\nFunctional\n\nObject-oriented\n\nSome perl modules use both approaches.\n\nA functional Perl module might get used like this:\n\nuse Foo qw/bar/; # Import the name of the subroutine you want to use. print bar();\n\nTo use an object-oriented Perl module, you would do something like this:\n\nuse Foo; my $foo = Foo->new(); print $foo->bar; #call Foo's bar method and print the output.\n\nFind the Perl module, you want at http://cpan.org, and download the gzipped file. Untar and unzip the file:\n\ntar -zxvf MyModule.tgz\n\nThen change into this the directory and follow the instructions in the README or INSTALL file.\n\nYou can also use a command-line program called cpan, if you have it installed:\n\nsudo cpan -imt Module::I::Want\n\nPerl modules differ from Perl scripts in two key and simple ways. Instead of starting the module with \"#!/path/to/perl\", you start the file with the following:\n\npackage My::Module::Name;\n\nYou need to end the module with a true value, so the common practice is to do this at the end of the file:\n\n1;\n\nThe following is a valid Perl module:\n\npackage My::Module::Name; 1;\n\nWe create a new file called ExampleModule.pm, and in it have the following code:\n\npackage ExampleModule; use strict; use base \"Exporter\"; our @EXPORT = qw/hello_world/; sub hello_world { print \"Hello, World!\\n\"; } 1;\n\nWe can test to see if the syntax is valid by running:\n\nperl -c ExampleModule.pm\n\nIt will print out \"ExampleModule.pm syntax OK\", if all is well. Otherwise, you can debug using the messages that are printed out.\n\nNow we can use it in a script to see if it works:\n\n#!/usr/bin/perl use ExampleModule; hello_world(); exit;\n\nVoilá! You have made a Perl module.\n\nCPAN-style modules have test suites and a way to build the module into the Perl library.\n\nDownload and install: Module::Starter from CPAN. Once this is installed, there will be a program called module-starter in your path. To create a new module, do the following from the command line:\n\nmodule-starter --module=My::Module::Name, My::Other::Module::Name, --author=\"My Name\" --email=\"myemail@gmail.com\"\n\nIt will then create a set of directories for you, including some shell module files with starter POD documentation. The Perl modules will be inside the lib directory inside the directory that is created. These are the files to edit. You can put your tests for the modules into the \"t\" directory. To install and build the module, you do the following:\n\n>perl Makefile.PL >make >make test >sudo make install\n\nWhen calling a function from a Perl module, the module name, function name and opening and closing parenthesis are used. If some parameters are to be passed, this is done in due order inside the parenthesis. The code inside the module gets the parameters the following way:\n\nAfter the first line, the function count can use the passed parameters $command_type and $rc. The main program calls the count() procedure as follows:\n\nWhen Perl was initially developed, there was no support at all for object-orientated (OO) programming. Since Perl 5, OO has been added using the concept of Perl packages (namespaces), an operator called bless, some magic variables (@ISA, AUTOLOAD, UNIVERSAL), the -> and some strong conventions for supporting inheritance and encapsulation.\n\nAn object is created using the package keyword. All subroutines declared in that package become object or class methods.\n\nA class instance is created by calling a constructor method that must be provided by the class, by convention this method is called new()\n\nLet's see this constructor.\n\nClient code can use this class something like this.\n\nThis code prints 10.\n\nLet's look at the new contructor in a little more detail:\n\nThe first thing is that when a subroutine is called using the -> notation a new argument is pre-pended to the argument list. It is a string with either the name of the package or a reference to the object (Object->new() or $o->setA. Until that makes sense you will find OO in Perl very confusing.\n\nTo use private variables in objects and have variables names check, you can use a little different approach to create objects.\n\nNow you have good encapsulation - you cannot access object variables directly via $o->{bar}, but only using set/get methods. It's also impossible to make mistakes in object variable names, because they are not a hash-keys but normal perl variables, needed to be declared.\n\nWe use them the same way like hash-blessed objects:\n\nprints 10\n\nperlobj - Perl object reference, perldoc.perl.org\n\nPerl OOP, perltutorial.org\n\nThere are several GUI widget sets available as additions to Perl, though the most common is probably Perl/Tk.\n\nGtk uses Gtk+, the Gimp Toolkit.\n\nGtk2 uses Gtk+ 2.x.\n\nGtk3 uses Gtk+ 3.x.\n\nPrima uses its own toolkit.\n\nPerl Tk (sometimes pTk or ptk) is a collection of modules and code that attempts to wed the simple Tk widget set to perl 5.\n\nTcl::Tk same as perlTk, but uses existing Tcl/Tk via Tcl, so allowing Tcl widgets\n\nTkx a different, lightweight, access to Tk via Tcl.\n\nQt uses the Qt toolkit.\n\nWx uses the platform independent wxWidgets toolkit.\n\nThe comp.lang.perl.tk FAQ\n\nA huge collection of freely usable Perl modules, ranging from advanced mathematics to database connectivity, networking and more, can be downloaded from a network of sites called CPAN. Most or all of the software on CPAN is also available under either the Artistic License, the GPL, or both. CPAN.pm is also the name of the Perl module that downloads and installs other Perl modules from one of the CPAN mirror sites; such installations can be done with interactive prompts, or can be fully automated.\n\nLook for modules on CPAN\n\nFrom a command-line, type the command\n\nppm\n\nThis will give you a \"Perl Package Manager\" prompt, which allows you to download and install modules from the internet. For example, to install the Time::HiRes module, type:\n\nsearch time::hires\n\nThat will give you a list of modules that match your search query. Once you know the module is available and what its exact name is, you can install the module with:\n\ninstall Time::HiRes\n\nIf you're using a normal version of Perl, the way to activate the package manager is this:\n\nperl -MCPAN -e shell;\n\nThis will load the CPAN module, and let you search for, download, install, and manage the modules on your computer the same as PPM.\n\nThe Perl module cpanm (CPAN Minus) is another alternative for installing modules from the CPAN library cpanminus.pm.\n\ncpanm can be installed and used like this on a UNIX-like system:\n\ncurl -L \"http://cpanmin.us\" >cpanm chmod +x cpanm ./cpanm LWP::Bundle\n\nOne must have root privileges in order to install module in the system-wide directories, however alternatives exist such as local::lib, which allows regular users to install and use Perl modules in their home folder lib.pm.\n\nStrawberry Perl also includes the CPAN module, so you can use the command above to activate the package manager.\n\nThe start menu, however, also includes a shortcut (with the name of \"CPAN Client\") so that you don't have to go to a command line to do so.\n\nA number of modules are already included in Strawberry Perl, beyond what comes with a normal version of Perl, or what comes with ActivePerl, so you may wish to check, if the module you want is already installed before you start the CPAN client.\n\nTo incorporate a module into your program, use the use keyword:\n\nuse Time::HiRes;\n\nYou can supply an optional list of the functions you want to use from this module, if you're worried that some of the function names in the module are too similar to functions you're already using:\n\nuse Time::Hires qw(time gmtime);\n\nWith that done, you can simply use the supplied functions as normal. Most modules have example programs within their documentation, and the best way to start using a module is to copy and adapt one of the example programs.\n\nThe documentation for each module is installed in your documentation directory when you get a new module, or you can browse documentation on search.cpan.org and perldoc.perl.org.\n\nOn Unix systems, the documentation is usually installed as man pages in section 3p so that the command below will work:\n\nman 3p Module::Name\n\nperldoc Module::Name will also work.\n\nIf you want documentation that is browseable in a web browser, you can install Perldoc::Server as noted below.\n\nModule documentation is installed as HTML files in ActivePerl. To find those files, try looking in some of the following directories:\n\nC:\\Perl\\html\\lib\n\nC:\\Perl\\html\\site\\lib\n\nIf you're having real trouble finding the HTML documentation for a module, you may be able to read the *.pm Perl file yourself for POD comments, or use the pod2html tool yourself to generate the HTML file.\n\nStrawberry Perl does not install module documentation as either manpages or html files. Instead, you can run the perldoc command to display module documentation.\n\nperldoc Module::Name\n\nYou can also use Perldoc::Server to display module documentation, as illustrated below.\n\nThe Perldoc::Server module (that can be installed via CPAN) will provide a local server that will display HTML files \"on the fly\" from Perl's documentation and the documentation for installed modules. Install it, and the command\n\nperldoc-server\n\nwill be in your path. Run it, and then browse to http://localhost:7375/ in your Web browser to see the documentation.\n\nNote that the perldoc-server command must be running to provide the documentation using this method.\n\nIn the event that a module you need isn't available on CPAN, the usual answer is to write the module yourself and add it to CPAN. That way, nobody else needs to waste time creating the same functionality that you're already written.\n\nSee How to contribute modules to CPAN\n\nAssuming you already have an Apache server (or compatible server that reads a shebang! line - more on this in a moment) and a Perl installation running, it is fairly simple to start running a Perl program on the Internet.\n\nFirst, you must have some way to access the program. Here we will deal with form data and submission, so we will assume that your form code in HTML has a property saying ACTION=\"programname.cgi\".\n\nCGI scripts begin like any other Perl program, with a \"shebang\", something like:\n\n(see Perl Programming/First Programs for details)\n\nNext load the CGI module:\n\nThe CGI module makes our work easy because it has pre-programmed functions in it for Internet use. Then we must create a handle to CGI - something that allows us to access the functions. We do this with:\n\nThis means that the variable $query is loading the CGI standard functions.\n\nNow that our program is setup using the CGI module, it should look something like this:\n\nSo we have a program, it just doesn't do anything yet, and will actually cause a server error because the server has no output or any idea of what kind of output to display even if it had some.\n\nBefore we tell the server what to do with our output, we need to retrieve our input. To do this, we use the $query variable we declared earlier. Say we have a text box in the form that is named \"Name\" and we want to find out what was typed there. To do this, we put the following line of code in our program:\n\nNow, this line of code introduces us to the param() function (for \"parameter\"). The param() function can do quite a few handy tricks for us, all of them nice ways to retrieve our variables. It processes all of the HTTP coding so all we get is a nice clean variable. Another note, you aren't required to use $Name as your variable. It's simply more convenient to only remember one name for the same variable. Still, use what's best for you.\n\nNow we must create our header information. CGI even makes THIS easy for us. Instead of memorizing a bunch of mime-type declarations (that you may do as well), all we must do is type:\n\nand it prints out our header information. A note about headers. Inside the parenthesis, we may specify parameters like cookies to send to the user's browser. This becomes very useful later. For now we will just stick to the headers.\n\nThe last thing you need to put (though the program will run, displaying a blank page without it) is some output. Let's simply have it display the user's name back to them. This would look like.\n\nSo we now have a complete program that processes a form, using only six lines of code. Isn't Perl great? The final code looks like this:\n\nWhen put into perspective, we can see that the $query variable is a very important connection to the CGI module as it tells perl that the function you are referencing belongs to CGI; Again, you may declare any variable name in the place of $query so long as you are consistent, though you will find many developers use $query or $q. Also note the use of the escapeHTML method to avoid any HTML injection problems.\n\nFinal note: Make sure you change /usr/bin/perl to the path of your perl installation (assuming that is not it) so perl will execute properly.\n\nThere are a number of CGI frameworks to help with common CGI programming tasks:\n\nCGI::Application\n\nCatalyst\n\nmod_perl is an optional module for Apache. It embeds a Perl interpreter into the Apache server, so that dynamic content produced by Perl scripts can be served in response to incoming requests, without the significant overhead of re-launching the Perl interpreter for each request. As Lincoln D. Stein defined mod_perl in his words:\n\nmod_perl is more than CGI scripting on steroids. It is a whole new way to create dynamic content by utilizing the full power of the Apache web server to create stateful sessions, customized user authentication systems, smart proxies and much more. Yet, magically, your old CGI scripts will continue to work and work very fast indeed. With mod_perl you give up nothing and gain so much!\n\nmod_perl can emulate a Common Gateway Interface (CGI) environment, so that existing Perl CGI scripts can benefit from the performance boost without having to be re-written.\n\nUnlike CGI (and most other web application environments), mod_perl provides complete access to the Apache API, allowing programmers to write handlers for all phases in the Apache request cycle, manipulate Apache's internal tables and state mechanisms, share data between Apache processes or threads, alter or extend the Apache configuration file parser, and add Perl code to the configuration file itself, among other things.\n\nMain website\n\nWhy mod_perl?\n\nThe magic of mod_perl\n\nWriting Apache Modules with Perl and C\n\nThe mod_perl Developer's Cookbook\n\nPractical mod_perl\n\nmod_perl2 User's Guide\n\nRaku will separate parsing and compilation and runtime, making the virtual machine more attractive to developers looking to port other languages to the architecture.\n\nParrot is the Raku runtime, and can be programmed at a low level in Parrot assembly language. Parrot exists in a limited form as of June, 2003, and a small number of languages (Jako, Cola, Basic, Forth and a subset of Raku) exist simply to be 'compiled' down to Parrot assembly language opcodes.\n\nWhile Raku is being developed, the best way to stay informed about what's happening is to keep an eye on Weekly Rakudo News. Go there to see glimpses of Raku.\n\nSome people claim Perl stands for 'Pathologically Eclectic Rubbish Lister' due to the high use of meaningful punctuation characters in the language syntax.\n\nIn common with C programming language, obfuscated code competitions are an interesting feature of the Perl culture. Similar to obfuscated code but with a different purpose, Perl Poetry is the practice of writing poems that can actually be compiled by perl. This practice is fairly unique to Perl, due to the large number of regular English words used in the language. New poems can regularly be seen in the Perl Poetry section of perlmonks.org.\n\nYour mission, should you choose to accept it, is to write a one-liner perl script which displays the phrase \"Just another Perl hacker,\" (including the comma, and capitalization as shown). If successful, you win the right to use it as an email signature identifying yourself as a Perl hacker. Entries will be judged on how smart-ass the code is. Around 100 of the first JAPHs and some funky obfu Perl can be seen on CPAN.\n\nThere's always a place in Perl for odd modules, and one such place is the Acme:: namespace. If you have a module which knows how long a piece of string is, or one which converts your perl script into an image of Che Guevara, post it here.\n\nPerl is a very compact language. So compact, that some have even create a game around perl's terseness called perlgolf. In perlgolf, you are given a problem to solve. You must solve it in the fewest number of characters possible. A scorecard is kept, and after 18 \"holes\", a winner is announced.\n\nThis script counts the number of occurences of each letter in a file:\n\nIf you executed this program on a file containing the sentence \"The quick, brown fox jumps over the lazy dog.\", you would see this as output:\n\na appeared once. b appeared once. c appeared once. d appeared once. e appeared 3 times. f appeared once"
    }
}