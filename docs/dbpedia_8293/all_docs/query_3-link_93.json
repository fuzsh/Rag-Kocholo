{
    "id": "dbpedia_8293_3",
    "rank": 93,
    "data": {
        "url": "https://www.tutorialspoint.com/perl/perl_quick_guide.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Quick Guide",
        "top_image": "https://www.tutorialspoint.com/images/tp_logo_436.png",
        "meta_img": "https://www.tutorialspoint.com/images/tp_logo_436.png",
        "images": [
            "https://www.tutorialspoint.com/perl/images/perl-mini-logo.jpg",
            "https://www.tutorialspoint.com/perl/images/decision_making.jpg",
            "https://www.tutorialspoint.com/perl/images/loop_architecture.jpg",
            "https://www.tutorialspoint.com/perl/images/perl_socket.jpg",
            "https://www.tutorialspoint.com/perl/images/dbiarch.gif",
            "https://www.tutorialspoint.com/perl/images/cgiarch.gif",
            "https://www.tutorialspoint.com/static/images/logo-footer.svg",
            "https://www.tutorialspoint.com/static/images/googleplay.svg",
            "https://www.tutorialspoint.com/static/images/appstore.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Perl - Quick Guide - Perl is a general-purpose programming language originally developed for text manipulation and now used for a wide range of tasks including system administration, web development, network programming, GUI development, and more.",
        "meta_lang": "en",
        "meta_favicon": "https://www.tutorialspoint.com/images/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://www.tutorialspoint.com/perl/perl_quick_guide.htm",
        "text": "Perl - Quick Guide\n\nPerl - Introduction\n\nPerl is a general-purpose programming language originally developed for text manipulation and now used for a wide range of tasks including system administration, web development, network programming, GUI development, and more.\n\nWhat is Perl?\n\nPerl is a stable, cross platform programming language.\n\nThough Perl is not officially an acronym but few people used it as Practical Extraction and Report Language.\n\nIt is used for mission critical projects in the public and private sectors.\n\nPerl is an Open Source software, licensed under its Artistic License, or the GNU General Public License (GPL).\n\nPerl was created by Larry Wall.\n\nPerl 1.0 was released to usenet's alt.comp.sources in 1987.\n\nAt the time of writing this tutorial, the latest version of perl was 5.16.2.\n\nPerl is listed in the Oxford English Dictionary.\n\nPC Magazine announced Perl as the finalist for its 1998 Technical Excellence Award in the Development Tool category.\n\nPerl Features\n\nPerl takes the best features from other languages, such as C, awk, sed, sh, and BASIC, among others.\n\nPerls database integration interface DBI supports third-party databases including Oracle, Sybase, Postgres, MySQL and others.\n\nPerl works with HTML, XML, and other mark-up languages.\n\nPerl supports Unicode.\n\nPerl is Y2K compliant.\n\nPerl supports both procedural and object-oriented programming.\n\nPerl interfaces with external C/C++ libraries through XS or SWIG.\n\nPerl is extensible. There are over 20,000 third party modules available from the Comprehensive Perl Archive Network (CPAN).\n\nThe Perl interpreter can be embedded into other systems.\n\nPerl and the Web\n\nPerl used to be the most popular web programming language due to its text manipulation capabilities and rapid development cycle.\n\nPerl is widely known as \"the duct-tape of the Internet\".\n\nPerl can handle encrypted Web data, including e-commerce transactions.\n\nPerl can be embedded into web servers to speed up processing by as much as 2000%.\n\nPerl's mod_perl allows the Apache web server to embed a Perl interpreter.\n\nPerl's DBI package makes web-database integration easy.\n\nPerl is Interpreted\n\nPerl is an interpreted language, which means that your code can be run as is, without a compilation stage that creates a non portable executable program.\n\nTraditional compilers convert programs into machine language. When you run a Perl program, it's first compiled into a byte code, which is then converted ( as the program runs) into machine instructions. So it is not quite the same as shells, or Tcl, which are strictly interpreted without an intermediate representation.\n\nIt is also not like most versions of C or C++, which are compiled directly into a machine dependent format. It is somewhere in between, along with Python and awk and Emacs .elc files.\n\nPerl - Environment\n\nBefore we start writing our Perl programs, let's understand how to setup our Perl environment. Perl is available on a wide variety of platforms −\n\nUnix (Solaris, Linux, FreeBSD, AIX, HP/UX, SunOS, IRIX etc.)\n\nWin 9x/NT/2000/\n\nWinCE\n\nMacintosh (PPC, 68K)\n\nSolaris (x86, SPARC)\n\nOpenVMS\n\nAlpha (7.2 and later)\n\nSymbian\n\nDebian GNU/kFreeBSD\n\nMirOS BSD\n\nAnd many more...\n\nThis is more likely that your system will have perl installed on it. Just try giving the following command at the $ prompt −\n\n$perl -v\n\nIf you have perl installed on your machine, then you will get a message something as follows −\n\nThis is perl 5, version 16, subversion 2 (v5.16.2) built for i686-linux Copyright 1987-2012, Larry Wall Perl may be copied only under the terms of either the Artistic License or the GNU General Public License, which may be found in the Perl 5 source kit. Complete documentation for Perl, including FAQ lists, should be found on this system using \"man perl\" or \"perldoc perl\". If you have access to the Internet, point your browser at http://www.perl.org/, the Perl Home Page.\n\nIf you do not have perl already installed, then proceed to the next section.\n\nGetting Perl Installation\n\nThe most up-to-date and current source code, binaries, documentation, news, etc. are available at the official website of Perl.\n\nPerl Official Website − https://www.perl.org/\n\nYou can download Perl documentation from the following site.\n\nPerl Documentation Website − https://perldoc.perl.org\n\nInstall Perl\n\nPerl distribution is available for a wide variety of platforms. You need to download only the binary code applicable for your platform and install Perl.\n\nIf the binary code for your platform is not available, you need a C compiler to compile the source code manually. Compiling the source code offers more flexibility in terms of choice of features that you require in your installation.\n\nHere is a quick overview of installing Perl on various platforms.\n\nUnix and Linux Installation\n\nHere are the simple steps to install Perl on Unix/Linux machine.\n\nOpen a Web browser and go to https://www.perl.org/get.html.\n\nFollow the link to download zipped source code available for Unix/Linux.\n\nDownload perl-5.x.y.tar.gz file and issue the following commands at $ prompt.\n\n$tar -xzf perl-5.x.y.tar.gz $cd perl-5.x.y $./Configure -de $make $make test $make install\n\nNOTE − Here $ is a Unix prompt where you type your command, so make sure you are not typing $ while typing the above mentioned commands.\n\nThis will install Perl in a standard location /usr/local/bin and its libraries are installed in /usr/local/lib/perlXX, where XX is the version of Perl that you are using.\n\nIt will take a while to compile the source code after issuing the make command. Once installation is done, you can issue perl -v command at $ prompt to check perl installation. If everything is fine, then it will display message like we have shown above.\n\nWindows Installation\n\nHere are the steps to install Perl on Windows machine.\n\nFollow the link for the Strawberry Perl installation on Windows http://strawberryperl.com\n\nDownload either 32bit or 64bit version of installation.\n\nRun the downloaded file by double-clicking it in Windows Explorer. This brings up the Perl install wizard, which is really easy to use. Just accept the default settings, wait until the installation is finished, and you're ready to roll!\n\nMacintosh Installation\n\nIn order to build your own version of Perl, you will need 'make', which is part of the Apples developer tools usually supplied with Mac OS install DVDs. You do not need the latest version of Xcode (which is now charged for) in order to install make.\n\nHere are the simple steps to install Perl on Mac OS X machine.\n\nOpen a Web browser and go to https://www.perl.org/get.html.\n\nFollow the link to download zipped source code available for Mac OS X.\n\nDownload perl-5.x.y.tar.gz file and issue the following commands at $ prompt.\n\n$tar -xzf perl-5.x.y.tar.gz $cd perl-5.x.y $./Configure -de $make $make test $make install\n\nThis will install Perl in a standard location /usr/local/bin and its libraries are installed in /usr/local/lib/perlXX, where XX is the version of Perl that you are using.\n\nRunning Perl\n\nThe following are the different ways to start Perl.\n\nInteractive Interpreter\n\nYou can enter perl and start coding right away in the interactive interpreter by starting it from the command line. You can do this from Unix, DOS, or any other system, which provides you a command-line interpreter or shell window.\n\n$perl -e <perl code> # Unix/Linux or C:>perl -e <perl code> # Windows/DOS\n\nHere is the list of all the available command line options −\n\nScript from the Command-line\n\nA Perl script is a text file, which keeps perl code in it and it can be executed at the command line by invoking the interpreter on your application, as in the following −\n\n$perl script.pl # Unix/Linux or C:>perl script.pl # Windows/DOS\n\nIntegrated Development Environment\n\nYou can run Perl from a graphical user interface (GUI) environment as well. All you need is a GUI application on your system that supports Perl. You can download Padre, the Perl IDE. You can also use Eclipse Plugin EPIC - Perl Editor and IDE for Eclipse if you are familiar with Eclipse.\n\nBefore proceeding to the next chapter, make sure your environment is properly setup and working perfectly fine. If you are not able to setup the environment properly then you can take help from your system admininstrator.\n\nAll the examples given in subsequent chapters have been executed with v5.16.2 version available on the CentOS flavor of Linux.\n\nPerl - Syntax Overview\n\nPerl borrows syntax and concepts from many languages: awk, sed, C, Bourne Shell, Smalltalk, Lisp and even English. However, there are some definite differences between the languages. This chapter is designd to quickly get you up to speed on the syntax that is expected in Perl.\n\nA Perl program consists of a sequence of declarations and statements, which run from the top to the bottom. Loops, subroutines, and other control structures allow you to jump around within the code. Every simple statement must end with a semicolon (;).\n\nPerl is a free-form language: you can format and indent it however you like. Whitespace serves mostly to separate tokens, unlike languages like Python where it is an important part of the syntax, or Fortran where it is immaterial.\n\nFirst Perl Program\n\nInteractive Mode Programming\n\nYou can use Perl interpreter with -e option at command line, which lets you execute Perl statements from the command line. Let's try something at $ prompt as follows −\n\n$perl -e 'print \"Hello World\\n\"'\n\nThis execution will produce the following result −\n\nHello, world\n\nScript Mode Programming\n\nAssuming you are already on $ prompt, let's open a text file hello.pl using vi or vim editor and put the following lines inside your file.\n\n#!/usr/bin/perl # This will print \"Hello, World\" print \"Hello, world\\n\";\n\nHere /usr/bin/perl is actual the perl interpreter binary. Before you execute your script, be sure to change the mode of the script file and give execution priviledge, generally a setting of 0755 works perfectly and finally you execute the above script as follows −\n\n$chmod 0755 hello.pl $./hello.pl\n\nThis execution will produce the following result −\n\nHello, world\n\nYou can use parentheses for functions arguments or omit them according to your personal taste. They are only required occasionally to clarify the issues of precedence. Following two statements produce the same result.\n\nprint(\"Hello, world\\n\"); print \"Hello, world\\n\";\n\nPerl File Extension\n\nA Perl script can be created inside of any normal simple-text editor program. There are several programs available for every type of platform. There are many programs designd for programmers available for download on the web.\n\nAs a Perl convention, a Perl file must be saved with a .pl or .PL file extension in order to be recognized as a functioning Perl script. File names can contain numbers, symbols, and letters but must not contain a space. Use an underscore (_) in places of spaces.\n\nComments in Perl\n\nComments in any programming language are friends of developers. Comments can be used to make program user friendly and they are simply skipped by the interpreter without impacting the code functionality. For example, in the above program, a line starting with hash # is a comment.\n\nSimply saying comments in Perl start with a hash symbol and run to the end of the line −\n\n# This is a comment in perl\n\nLines starting with = are interpreted as the start of a section of embedded documentation (pod), and all subsequent lines until the next =cut are ignored by the compiler. Following is the example −\n\n#!/usr/bin/perl # This is a single line comment print \"Hello, world\\n\"; =begin comment This is all part of multiline comment. You can use as many lines as you like These comments will be ignored by the compiler until the next =cut is encountered. =cut\n\nThis will produce the following result −\n\nHello, world\n\nWhitespaces in Perl\n\nA Perl program does not care about whitespaces. Following program works perfectly fine −\n\n#!/usr/bin/perl print \"Hello, world\\n\";\n\nBut if spaces are inside the quoted strings, then they would be printed as is. For example −\n\n#!/usr/bin/perl # This would print with a line break in the middle print \"Hello world\\n\";\n\nThis will produce the following result −\n\nHello world\n\nAll types of whitespace like spaces, tabs, newlines, etc. are equivalent for the interpreter when they are used outside of the quotes. A line containing only whitespace, possibly with a comment, is known as a blank line, and Perl totally ignores it.\n\nSingle and Double Quotes in Perl\n\nYou can use double quotes or single quotes around literal strings as follows −\n\n#!/usr/bin/perl print \"Hello, world\\n\"; print 'Hello, world\\n';\n\nThis will produce the following result −\n\nHello, world Hello, world\\n$\n\nThere is an important difference in single and double quotes. Only double quotes interpolate variables and special characters such as newlines \\n, whereas single quote does not interpolate any variable or special character. Check below example where we are using $a as a variable to store a value and later printing that value −\n\n#!/usr/bin/perl $a = 10; print \"Value of a = $a\\n\"; print 'Value of a = $a\\n';\n\nThis will produce the following result −\n\nValue of a = 10 Value of a = $a\\n$\n\n\"Here\" Documents\n\nYou can store or print multiline text with a great comfort. Even you can make use of variables inside the \"here\" document. Below is a simple syntax, check carefully there must be no space between the << and the identifier.\n\nAn identifier may be either a bare word or some quoted text like we used EOF below. If identifier is quoted, the type of quote you use determines the treatment of the text inside the here docoment, just as in regular quoting. An unquoted identifier works like double quotes.\n\n#!/usr/bin/perl $a = 10; $var = <<\"EOF\"; This is the syntax for here document and it will continue until it encounters a EOF in the first line. This is case of double quote so variable value will be interpolated. For example value of a = $a EOF print \"$var\\n\"; $var = <<'EOF'; This is case of single quote so variable value will be interpolated. For example value of a = $a EOF print \"$var\\n\";\n\nThis will produce the following result −\n\nThis is the syntax for here document and it will continue until it encounters a EOF in the first line. This is case of double quote so variable value will be interpolated. For example value of a = 10 This is case of single quote so variable value will be interpolated. For example value of a = $a\n\nEscaping Characters\n\nPerl uses the backslash (\\) character to escape any type of character that might interfere with our code. Let's take one example where we want to print double quote and $ sign −\n\n#!/usr/bin/perl $result = \"This is \\\"number\\\"\"; print \"$result\\n\"; print \"\\$result\\n\";\n\nThis will produce the following result −\n\nThis is \"number\" $result\n\nPerl Identifiers\n\nA Perl identifier is a name used to identify a variable, function, class, module, or other object. A Perl variable name starts with either $, &commat; or % followed by zero or more letters, underscores, and digits (0 to 9).\n\nPerl does not allow punctuation characters such as &commat;, $, and % within identifiers. Perl is a case sensitive programming language. Thus $Manpower and $manpower are two different identifiers in Perl.\n\nPerl - Data Types\n\nPerl is a loosely typed language and there is no need to specify a type for your data while using in your program. The Perl interpreter will choose the type based on the context of the data itself.\n\nPerl has three basic data types: scalars, arrays of scalars, and hashes of scalars, also known as associative arrays. Here is a little detail about these data types.\n\nNumeric Literals\n\nPerl stores all the numbers internally as either signed integers or double-precision floating-point values. Numeric literals are specified in any of the following floating-point or integer formats −\n\nString Literals\n\nStrings are sequences of characters. They are usually alphanumeric values delimited by either single (') or double (\") quotes. They work much like UNIX shell quotes where you can use single quoted strings and double quoted strings.\n\nDouble-quoted string literals allow variable interpolation, and single-quoted strings are not. There are certain characters when they are proceeded by a back slash, have special meaning and they are used to represent like newline (\\n) or tab (\\t).\n\nYou can embed newlines or any of the following Escape sequences directly in your double quoted strings −\n\nExample\n\nLet's see again how strings behave with single quotation and double quotation. Here we will use string escapes mentioned in the above table and will make use of the scalar variable to assign string values.\n\n#!/usr/bin/perl # This is case of interpolation. $str = \"Welcome to \\ntutorialspoint.com!\"; print \"$str\\n\"; # This is case of non-interpolation. $str = 'Welcome to \\ntutorialspoint.com!'; print \"$str\\n\"; # Only W will become upper case. $str = \"\\uwelcome to tutorialspoint.com!\"; print \"$str\\n\"; # Whole line will become capital. $str = \"\\UWelcome to tutorialspoint.com!\"; print \"$str\\n\"; # A portion of line will become capital. $str = \"Welcome to \\Ututorialspoint\\E.com!\"; print \"$str\\n\"; # Backsalash non alpha-numeric including spaces. $str = \"\\QWelcome to tutorialspoint's family\"; print \"$str\\n\";\n\nThis will produce the following result −\n\nWelcome to tutorialspoint.com! Welcome to \\ntutorialspoint.com! Welcome to tutorialspoint.com! WELCOME TO TUTORIALSPOINT.COM! Welcome to TUTORIALSPOINT.com! Welcome\\ to\\ tutorialspoint\\'s\\ family\n\nPerl - Variables\n\nVariables are the reserved memory locations to store values. This means that when you create a variable you reserve some space in memory.\n\nBased on the data type of a variable, the interpreter allocates memory and decides what can be stored in the reserved memory. Therefore, by assigning different data types to variables, you can store integers, decimals, or strings in these variables.\n\nWe have learnt that Perl has the following three basic data types −\n\nScalars\n\nArrays\n\nHashes\n\nAccordingly, we are going to use three types of variables in Perl. A scalar variable will precede by a dollar sign ($) and it can store either a number, a string, or a reference. An array variable will precede by sign &commat; and it will store ordered lists of scalars. Finaly, the Hash variable will precede by sign % and will be used to store sets of key/value pairs.\n\nPerl maintains every variable type in a separate namespace. So you can, without fear of conflict, use the same name for a scalar variable, an array, or a hash. This means that $foo and &commat;foo are two different variables.\n\nCreating Variables\n\nPerl variables do not have to be explicitly declared to reserve memory space. The declaration happens automatically when you assign a value to a variable. The equal sign (=) is used to assign values to variables.\n\nKeep a note that this is mandatory to declare a variable before we use it if we use use strict statement in our program.\n\nThe operand to the left of the = operator is the name of the variable, and the operand to the right of the = operator is the value stored in the variable. For example −\n\n$age = 25; # An integer assignment $name = \"John Paul\"; # A string $salary = 1445.50; # A floating point\n\nHere 25, \"John Paul\" and 1445.50 are the values assigned to $age, $name and $salary variables, respectively. Shortly we will see how we can assign values to arrays and hashes.\n\nScalar Variables\n\nA scalar is a single unit of data. That data might be an integer number, floating point, a character, a string, a paragraph, or an entire web page. Simply saying it could be anything, but only a single thing.\n\nHere is a simple example of using scalar variables −\n\n#!/usr/bin/perl $age = 25; # An integer assignment $name = \"John Paul\"; # A string $salary = 1445.50; # A floating point print \"Age = $age\\n\"; print \"Name = $name\\n\"; print \"Salary = $salary\\n\";\n\nThis will produce the following result −\n\nAge = 25 Name = John Paul Salary = 1445.5\n\nArray Variables\n\nAn array is a variable that stores an ordered list of scalar values. Array variables are preceded by an \"at\" (&commat;) sign. To refer to a single element of an array, you will use the dollar sign ($) with the variable name followed by the index of the element in square brackets.\n\nHere is a simple example of using array variables −\n\n#!/usr/bin/perl &commat;ages = (25, 30, 40); &commat;names = (\"John Paul\", \"Lisa\", \"Kumar\"); print \"\\$ages[0] = $ages[0]\\n\"; print \"\\$ages[1] = $ages[1]\\n\"; print \"\\$ages[2] = $ages[2]\\n\"; print \"\\$names[0] = $names[0]\\n\"; print \"\\$names[1] = $names[1]\\n\"; print \"\\$names[2] = $names[2]\\n\";\n\nHere we used escape sign (\\) before the $ sign just to print it. Other Perl will understand it as a variable and will print its value. When executed, this will produce the following result −\n\n$ages[0] = 25 $ages[1] = 30 $ages[2] = 40 $names[0] = John Paul $names[1] = Lisa $names[2] = Kumar\n\nHash Variables\n\nA hash is a set of key/value pairs. Hash variables are preceded by a percent (%) sign. To refer to a single element of a hash, you will use the hash variable name followed by the \"key\" associated with the value in curly brackets.\n\nHere is a simple example of using hash variables −\n\n#!/usr/bin/perl %data = ('John Paul', 45, 'Lisa', 30, 'Kumar', 40); print \"\\$data{'John Paul'} = $data{'John Paul'}\\n\"; print \"\\$data{'Lisa'} = $data{'Lisa'}\\n\"; print \"\\$data{'Kumar'} = $data{'Kumar'}\\n\";\n\nThis will produce the following result −\n\n$data{'John Paul'} = 45 $data{'Lisa'} = 30 $data{'Kumar'} = 40\n\nVariable Context\n\nPerl treats same variable differently based on Context, i.e., situation where a variable is being used. Let's check the following example −\n\n#!/usr/bin/perl &commat;names = ('John Paul', 'Lisa', 'Kumar'); &commat;copy = &commat;names; $size = &commat;names; print \"Given names are : &commat;copy\\n\"; print \"Number of names are : $size\\n\";\n\nThis will produce the following result −\n\nGiven names are : John Paul Lisa Kumar Number of names are : 3\n\nHere &commat;names is an array, which has been used in two different contexts. First we copied it into anyother array, i.e., list, so it returned all the elements assuming that context is list context. Next we used the same array and tried to store this array in a scalar, so in this case it returned just the number of elements in this array assuming that context is scalar context. Following table lists down the various contexts −\n\nPerl - Scalars\n\nA scalar is a single unit of data. That data might be an integer number, floating point, a character, a string, a paragraph, or an entire web page.\n\nHere is a simple example of using scalar variables −\n\n#!/usr/bin/perl $age = 25; # An integer assignment $name = \"John Paul\"; # A string $salary = 1445.50; # A floating point print \"Age = $age\\n\"; print \"Name = $name\\n\"; print \"Salary = $salary\\n\";\n\nThis will produce the following result −\n\nAge = 25 Name = John Paul Salary = 1445.5\n\nNumeric Scalars\n\nA scalar is most often either a number or a string. Following example demonstrates the usage of various types of numeric scalars −\n\n#!/usr/bin/perl $integer = 200; $negative = -300; $floating = 200.340; $bigfloat = -1.2E-23; # 377 octal, same as 255 decimal $octal = 0377; # FF hex, also 255 decimal $hexa = 0xff; print \"integer = $integer\\n\"; print \"negative = $negative\\n\"; print \"floating = $floating\\n\"; print \"bigfloat = $bigfloat\\n\"; print \"octal = $octal\\n\"; print \"hexa = $hexa\\n\";\n\nThis will produce the following result −\n\ninteger = 200 negative = -300 floating = 200.34 bigfloat = -1.2e-23 octal = 255 hexa = 255\n\nString Scalars\n\nFollowing example demonstrates the usage of various types of string scalars. Notice the difference between single quoted strings and double quoted strings −\n\n#!/usr/bin/perl $var = \"This is string scalar!\"; $quote = 'I m inside single quote - $var'; $double = \"This is inside single quote - $var\"; $escape = \"This example of escape -\\tHello, World!\"; print \"var = $var\\n\"; print \"quote = $quote\\n\"; print \"double = $double\\n\"; print \"escape = $escape\\n\";\n\nThis will produce the following result −\n\nvar = This is string scalar! quote = I m inside single quote - $var double = This is inside single quote - This is string scalar! escape = This example of escape - Hello, World\n\nScalar Operations\n\nYou will see a detail of various operators available in Perl in a separate chapter, but here we are going to list down few numeric and string operations.\n\n#!/usr/bin/perl $str = \"hello\" . \"world\"; # Concatenates strings. $num = 5 + 10; # adds two numbers. $mul = 4 * 5; # multiplies two numbers. $mix = $str . $num; # concatenates string and number. print \"str = $str\\n\"; print \"num = $num\\n\"; print \"mix = $mix\\n\";\n\nThis will produce the following result −\n\nstr = helloworld num = 15 mul = 20 mix = helloworld15\n\nMultiline Strings\n\nIf you want to introduce multiline strings into your programs, you can use the standard single quotes as below −\n\n#!/usr/bin/perl $string = 'This is a multiline string'; print \"$string\\n\";\n\nThis will produce the following result −\n\nThis is a multiline string\n\nYou can use \"here\" document syntax as well to store or print multilines as below −\n\n#!/usr/bin/perl print <<EOF; This is a multiline string EOF\n\nThis will also produce the same result −\n\nThis is a multiline string\n\nV-Strings\n\nA literal of the form v1.20.300.4000 is parsed as a string composed of characters with the specified ordinals. This form is known as v-strings.\n\nA v-string provides an alternative and more readable way to construct strings, rather than use the somewhat less readable interpolation form \"\\x{1}\\x{14}\\x{12c}\\x{fa0}\".\n\nThey are any literal that begins with a v and is followed by one or more dot-separated elements. For example −\n\n#!/usr/bin/perl $smile = v9786; $foo = v102.111.111; $martin = v77.97.114.116.105.110; print \"smile = $smile\\n\"; print \"foo = $foo\\n\"; print \"martin = $martin\\n\";\n\nThis will also produce the same result −\n\nsmile = ☺ foo = foo martin = Martin Wide character in print at main.pl line 7.\n\nSpecial Literals\n\nSo far you must have a feeling about string scalars and its concatenation and interpolation opration. So let me tell you about three special literals __FILE__, __LINE__, and __PACKAGE__ represent the current filename, line number, and package name at that point in your program.\n\nThey may be used only as separate tokens and will not be interpolated into strings. Check the below example −\n\n#!/usr/bin/perl print \"File name \". __FILE__ . \"\\n\"; print \"Line Number \" . __LINE__ .\"\\n\"; print \"Package \" . __PACKAGE__ .\"\\n\"; # they can not be interpolated print \"__FILE__ __LINE__ __PACKAGE__\\n\";\n\nThis will produce the following result −\n\nFile name hello.pl Line Number 4 Package main __FILE__ __LINE__ __PACKAGE__\n\nPerl - Arrays\n\nAn array is a variable that stores an ordered list of scalar values. Array variables are preceded by an \"at\" (&commat;) sign. To refer to a single element of an array, you will use the dollar sign ($) with the variable name followed by the index of the element in square brackets.\n\nHere is a simple example of using the array variables −\n\n#!/usr/bin/perl &commat;ages = (25, 30, 40); &commat;names = (\"John Paul\", \"Lisa\", \"Kumar\"); print \"\\$ages[0] = $ages[0]\\n\"; print \"\\$ages[1] = $ages[1]\\n\"; print \"\\$ages[2] = $ages[2]\\n\"; print \"\\$names[0] = $names[0]\\n\"; print \"\\$names[1] = $names[1]\\n\"; print \"\\$names[2] = $names[2]\\n\";\n\nHere we have used the escape sign (\\) before the $ sign just to print it. Other Perl will understand it as a variable and will print its value. When executed, this will produce the following result −\n\n$ages[0] = 25 $ages[1] = 30 $ages[2] = 40 $names[0] = John Paul $names[1] = Lisa $names[2] = Kumar\n\nIn Perl, List and Array terms are often used as if they're interchangeable. But the list is the data, and the array is the variable.\n\nArray Creation\n\nArray variables are prefixed with the &commat; sign and are populated using either parentheses or the qw operator. For example −\n\n&commat;array = (1, 2, 'Hello'); &commat;array = qw/This is an array/;\n\nThe second line uses the qw// operator, which returns a list of strings, separating the delimited string by white space. In this example, this leads to a four-element array; the first element is 'this' and last (fourth) is 'array'. This means that you can use different lines as follows −\n\n&commat;days = qw/Monday Tuesday ... Sunday/;\n\nYou can also populate an array by assigning each value individually as follows −\n\n$array[0] = 'Monday'; ... $array[6] = 'Sunday';\n\nAccessing Array Elements\n\nWhen accessing individual elements from an array, you must prefix the variable with a dollar sign ($) and then append the element index within the square brackets after the name of the variable. For example −\n\n#!/usr/bin/perl @days = qw/Mon Tue Wed Thu Fri Sat Sun/; print \"$days[0]\\n\"; print \"$days[1]\\n\"; print \"$days[2]\\n\"; print \"$days[6]\\n\"; print \"$days[-1]\\n\"; print \"$days[-7]\\n\";\n\nThis will produce the following result −\n\nMon Tue Wed Sun Sun Mon\n\nArray indices start from zero, so to access the first element you need to give 0 as indices. You can also give a negative index, in which case you select the element from the end, rather than the beginning, of the array. This means the following −\n\nprint $days[-1]; # outputs Sun print $days[-7]; # outputs Mon\n\nSequential Number Arrays\n\nPerl offers a shortcut for sequential numbers and letters. Rather than typing out each element when counting to 100 for example, we can do something like as follows −\n\n#!/usr/bin/perl @var_10 = (1..10); @var_20 = (10..20); @var_abc = (a..z); print \"@var_10\\n\"; # Prints number from 1 to 10 print \"@var_20\\n\"; # Prints number from 10 to 20 print \"@var_abc\\n\"; # Prints number from a to z\n\nHere double dot (..) is called range operator. This will produce the following result −\n\n1 2 3 4 5 6 7 8 9 10 10 11 12 13 14 15 16 17 18 19 20 a b c d e f g h i j k l m n o p q r s t u v w x y z\n\nArray Size\n\nThe size of an array can be determined using the scalar context on the array - the returned value will be the number of elements in the array −\n\n&commat;array = (1,2,3); print \"Size: \",scalar &commat;array,\"\\n\";\n\nThe value returned will always be the physical size of the array, not the number of valid elements. You can demonstrate this, and the difference between scalar &commat;array and $#array, using this fragment is as follows −\n\n#!/usr/bin/perl @array = (1,2,3); $array[50] = 4; $size = @array; $max_index = $#array; print \"Size: $size\\n\"; print \"Max Index: $max_index\\n\";\n\nThis will produce the following result −\n\nSize: 51 Max Index: 50\n\nThere are only four elements in the array that contains information, but the array is 51 elements long, with a highest index of 50.\n\nAdding and Removing Elements in Array\n\nPerl provides a number of useful functions to add and remove elements in an array. You may have a question what is a function? So far you have used print function to print various values. Similarly there are various other functions or sometime called sub-routines, which can be used for various other functionalities.\n\n#!/usr/bin/perl # create a simple array @coins = (\"Quarter\",\"Dime\",\"Nickel\"); print \"1. \\&commat;coins = &commat;coins\\n\"; # add one element at the end of the array push(&commat;coins, \"Penny\"); print \"2. \\&commat;coins = &commat;coins\\n\"; # add one element at the beginning of the array unshift(&commat;coins, \"Dollar\"); print \"3. \\&commat;coins = &commat;coins\\n\"; # remove one element from the last of the array. pop(&commat;coins); print \"4. \\&commat;coins = &commat;coins\\n\"; # remove one element from the beginning of the array. shift(&commat;coins); print \"5. \\&commat;coins = &commat;coins\\n\";\n\nThis will produce the following result −\n\n1. &commat;coins = Quarter Dime Nickel 2. &commat;coins = Quarter Dime Nickel Penny 3. &commat;coins = Dollar Quarter Dime Nickel Penny 4. &commat;coins = Dollar Quarter Dime Nickel 5. &commat;coins = Quarter Dime Nickel\n\nSlicing Array Elements\n\nYou can also extract a \"slice\" from an array - that is, you can select more than one item from an array in order to produce another array.\n\n#!/usr/bin/perl &commat;days = qw/Mon Tue Wed Thu Fri Sat Sun/; &commat;weekdays = &commat;days[3,4,5]; print \"&commat;weekdays\\n\";\n\nThis will produce the following result −\n\nThu Fri Sat\n\nThe specification for a slice must have a list of valid indices, either positive or negative, each separated by a comma. For speed, you can also use the .. range operator −\n\n#!/usr/bin/perl &commat;days = qw/Mon Tue Wed Thu Fri Sat Sun/; &commat;weekdays = &commat;days[3..5]; print \"&commat;weekdays\\n\";\n\nThis will produce the following result −\n\nThu Fri Sat\n\nReplacing Array Elements\n\nNow we are going to introduce one more function called splice(), which has the following syntax −\n\nsplice &commat;ARRAY, OFFSET [ , LENGTH [ , LIST ] ]\n\nThis function will remove the elements of @ARRAY designated by OFFSET and LENGTH, and replaces them with LIST, if specified. Finally, it returns the elements removed from the array. Following is the example −\n\n#!/usr/bin/perl &commat;nums = (1..20); print \"Before - &commat;nums\\n\"; splice(&commat;nums, 5, 5, 21..25); print \"After - &commat;nums\\n\";\n\nThis will produce the following result −\n\nBefore - 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 After - 1 2 3 4 5 21 22 23 24 25 11 12 13 14 15 16 17 18 19 20\n\nHere, the actual replacement begins with the 6th number after that five elements are then replaced from 6 to 10 with the numbers 21, 22, 23, 24 and 25.\n\nTransform Strings to Arrays\n\nLet's look into one more function called split(), which has the following syntax −\n\nsplit [ PATTERN [ , EXPR [ , LIMIT ] ] ]\n\nThis function splits a string into an array of strings, and returns it. If LIMIT is specified, splits into at most that number of fields. If PATTERN is omitted, splits on whitespace. Following is the example −\n\n#!/usr/bin/perl # define Strings $var_string = \"Rain-Drops-On-Roses-And-Whiskers-On-Kittens\"; $var_names = \"Larry,David,Roger,Ken,Michael,Tom\"; # transform above strings into arrays. @string = split('-', $var_string); @names = split(',', $var_names); print \"$string[3]\\n\"; # This will print Roses print \"$names[4]\\n\"; # This will print Michael\n\nThis will produce the following result −\n\nRoses Michael\n\nTransform Arrays to Strings\n\nWe can use the join() function to rejoin the array elements and form one long scalar string. This function has the following syntax −\n\njoin EXPR, LIST\n\nThis function joins the separate strings of LIST into a single string with fields separated by the value of EXPR, and returns the string. Following is the example −\n\n#!/usr/bin/perl # define Strings $var_string = \"Rain-Drops-On-Roses-And-Whiskers-On-Kittens\"; $var_names = \"Larry,David,Roger,Ken,Michael,Tom\"; # transform above strings into arrays. &commat;string = split('-', $var_string); &commat;names = split(',', $var_names); $string1 = join( '-', &commat;string ); $string2 = join( ',', &commat;names ); print \"$string1\\n\"; print \"$string2\\n\";\n\nThis will produce the following result −\n\nRain-Drops-On-Roses-And-Whiskers-On-Kittens Larry,David,Roger,Ken,Michael,Tom\n\nSorting Arrays\n\nThe sort() function sorts each element of an array according to the ASCII Numeric standards. This function has the following syntax −\n\nsort [ SUBROUTINE ] LIST\n\nThis function sorts the LIST and returns the sorted array value. If SUBROUTINE is specified then specified logic inside the SUBTROUTINE is applied while sorting the elements.\n\n#!/usr/bin/perl # define an array &commat;foods = qw(pizza steak chicken burgers); print \"Before: &commat;foods\\n\"; # sort this array @foods = sort(&commat;foods); print \"After: &commat;foods\\n\";\n\nThis will produce the following result −\n\nBefore: pizza steak chicken burgers After: burgers chicken pizza steak\n\nPlease note that sorting is performed based on ASCII Numeric value of the words. So the best option is to first transform every element of the array into lowercase letters and then perform the sort function.\n\nMerging Arrays\n\nBecause an array is just a comma-separated sequence of values, you can combine them together as shown below −\n\n#!/usr/bin/perl &commat;numbers = (1,3,(4,5,6)); print \"numbers = &commat;numbers\\n\";\n\nThis will produce the following result −\n\nnumbers = 1 3 4 5 6\n\nThe embedded arrays just become a part of the main array as shown below −\n\n#!/usr/bin/perl &commat;odd = (1,3,5); &commat;even = (2, 4, 6); &commat;numbers = (&commat;odd, &commat;even); print \"numbers = &commat;numbers\\n\";\n\nThis will produce the following result −\n\nnumbers = 1 3 5 2 4 6\n\nSelecting Elements from Lists\n\nThe list notation is identical to that for arrays. You can extract an element from an array by appending square brackets to the list and giving one or more indices −\n\n#!/usr/bin/perl $var = (5,4,3,2,1)[4]; print \"value of var = $var\\n\"\n\nThis will produce the following result −\n\nvalue of var = 1\n\nSimilarly, we can extract slices, although without the requirement for a leading &commat; character −\n\n#!/usr/bin/perl &commat;list = (5,4,3,2,1)[1..3]; print \"Value of list = &commat;list\\n\";\n\nThis will produce the following result −\n\nValue of list = 4 3 2\n\nPerl - Hashes\n\nA hash is a set of key/value pairs. Hash variables are preceded by a percent (%) sign. To refer to a single element of a hash, you will use the hash variable name preceded by a \"$\" sign and followed by the \"key\" associated with the value in curly brackets..\n\nHere is a simple example of using the hash variables −\n\n#!/usr/bin/perl %data = ('John Paul', 45, 'Lisa', 30, 'Kumar', 40); print \"\\$data{'John Paul'} = $data{'John Paul'}\\n\"; print \"\\$data{'Lisa'} = $data{'Lisa'}\\n\"; print \"\\$data{'Kumar'} = $data{'Kumar'}\\n\";\n\nThis will produce the following result −\n\n$data{'John Paul'} = 45 $data{'Lisa'} = 30 $data{'Kumar'} = 40\n\nCreating Hashes\n\nHashes are created in one of the two following ways. In the first method, you assign a value to a named key on a one-by-one basis −\n\n$data{'John Paul'} = 45; $data{'Lisa'} = 30; $data{'Kumar'} = 40;\n\nIn the second case, you use a list, which is converted by taking individual pairs from the list: the first element of the pair is used as the key, and the second, as the value. For example −\n\n%data = ('John Paul', 45, 'Lisa', 30, 'Kumar', 40);\n\nFor clarity, you can use => as an alias for , to indicate the key/value pairs as follows −\n\n%data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40);\n\nHere is one more variant of the above form, have a look at it, here all the keys have been preceded by hyphen (-) and no quotation is required around them −\n\n%data = (-JohnPaul => 45, -Lisa => 30, -Kumar => 40);\n\nBut it is important to note that there is a single word, i.e., without spaces keys have been used in this form of hash formation and if you build-up your hash this way then keys will be accessed using hyphen only as shown below.\n\n$val = %data{-JohnPaul} $val = %data{-Lisa}\n\nAccessing Hash Elements\n\nWhen accessing individual elements from a hash, you must prefix the variable with a dollar sign ($) and then append the element key within curly brackets after the name of the variable. For example −\n\n#!/usr/bin/perl %data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40); print \"$data{'John Paul'}\\n\"; print \"$data{'Lisa'}\\n\"; print \"$data{'Kumar'}\\n\";\n\nThis will produce the following result −\n\n45 30 40\n\nExtracting Slices\n\nYou can extract slices of a hash just as you can extract slices from an array. You will need to use &commat; prefix for the variable to store the returned value because they will be a list of values −\n\n#!/uer/bin/perl %data = (-JohnPaul => 45, -Lisa => 30, -Kumar => 40); &commat;array = &commat;data{-JohnPaul, -Lisa}; print \"Array : &commat;array\\n\";\n\nThis will produce the following result −\n\nArray : 45 30\n\nExtracting Keys and Values\n\nYou can get a list of all of the keys from a hash by using keys function, which has the following syntax −\n\nkeys %HASH\n\nThis function returns an array of all the keys of the named hash. Following is the example −\n\n#!/usr/bin/perl %data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40); &commat;names = keys %data; print \"$names[0]\\n\"; print \"$names[1]\\n\"; print \"$names[2]\\n\";\n\nThis will produce the following result −\n\nLisa John Paul Kumar\n\nSimilarly, you can use values function to get a list of all the values. This function has the following syntax −\n\nvalues %HASH\n\nThis function returns a normal array consisting of all the values of the named hash. Following is the example −\n\n#!/usr/bin/perl %data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40); &commat;ages = values %data; print \"$ages[0]\\n\"; print \"$ages[1]\\n\"; print \"$ages[2]\\n\";\n\nThis will produce the following result −\n\n30 45 40\n\nChecking for Existence\n\nIf you try to access a key/value pair from a hash that doesn't exist, you'll normally get the undefined value, and if you have warnings switched on, then you'll get a warning generated at run time. You can get around this by using the exists function, which returns true if the named key exists, irrespective of what its value might be −\n\n#!/usr/bin/perl %data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40); if( exists($data{'Lisa'} ) ) { print \"Lisa is $data{'Lisa'} years old\\n\"; } else { print \"I don't know age of Lisa\\n\"; }\n\nHere we have introduced the IF...ELSE statement, which we will study in a separate chapter. For now you just assume that if( condition ) part will be executed only when the given condition is true otherwise else part will be executed. So when we execute the above program, it produces the following result because here the given condition exists($data{'Lisa'} returns true −\n\nLisa is 30 years old\n\nGetting Hash Size\n\nYou can get the size - that is, the number of elements from a hash by using the scalar context on either keys or values. Simply saying first you have to get an array of either the keys or values and then you can get the size of array as follows −\n\n#!/usr/bin/perl %data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40); &commat;keys = keys %data; $size = &commat;keys; print \"1 - Hash size: is $size\\n\"; @values = values %data; $size = &commat;values; print \"2 - Hash size: is $size\\n\";\n\nThis will produce the following result −\n\n1 - Hash size: is 3 2 - Hash size: is 3\n\nAdd and Remove Elements in Hashes\n\nAdding a new key/value pair can be done with one line of code using simple assignment operator. But to remove an element from the hash you need to use delete function as shown below in the example −\n\n#!/usr/bin/perl %data = ('John Paul' => 45, 'Lisa' => 30, 'Kumar' => 40); &commat;keys = keys %data; $size = &commat;keys; print \"1 - Hash size: is $size\\n\"; # adding an element to the hash; $data{'Ali'} = 55; &commat;keys = keys %data; $size = &commat;keys; print \"2 - Hash size: is $size\\n\"; # delete the same element from the hash; delete $data{'Ali'}; &commat;keys = keys %data; $size = &commat;keys; print \"3 - Hash size: is $size\\n\";\n\nThis will produce the following result −\n\n1 - Hash size: is 3 2 - Hash size: is 4 3 - Hash size: is 3\n\nPerl Conditional Statements - IF...ELSE\n\nPerl conditional statements helps in the decision making, which require that the programmer specifies one or more conditions to be evaluated or tested by the program, along with a statement or statements to be executed if the condition is determined to be true, and optionally, other statements to be executed if the condition is determined to be false.\n\nFollowing is the general from of a typical decision making structure found in most of the programming languages −\n\nThe number 0, the strings '0' and \"\" , the empty list () , and undef are all false in a boolean context and all other values are true. Negation of a true value by ! or not returns a special false value.\n\nPerl programming language provides the following types of conditional statements.\n\nThe ? : Operator\n\nLet's check the conditional operator ? :which can be used to replace if...else statements. It has the following general form −\n\nExp1 ? Exp2 : Exp3;\n\nWhere Exp1, Exp2, and Exp3 are expressions. Notice the use and placement of the colon.\n\nThe value of a ? expression is determined like this: Exp1 is evaluated. If it is true, then Exp2 is evaluated and becomes the value of the entire ? expression. If Exp1 is false, then Exp3 is evaluated and its value becomes the value of the expression. Below is a simple example making use of this operator −\n\n#!/usr/local/bin/perl $name = \"Ali\"; $age = 10; $status = ($age > 60 )? \"A senior citizen\" : \"Not a senior citizen\"; print \"$name is - $status\\n\";\n\nThis will produce the following result −\n\nAli is - Not a senior citizen\n\nPerl - Loops\n\nThere may be a situation when you need to execute a block of code several number of times. In general, statements are executed sequentially: The first statement in a function is executed first, followed by the second, and so on.\n\nProgramming languages provide various control structures that allow for more complicated execution paths.\n\nA loop statement allows us to execute a statement or group of statements multiple times and following is the general form of a loop statement in most of the programming languages −\n\nPerl programming language provides the following types of loop to handle the looping requirements.\n\nLoop Control Statements\n\nLoop control statements change the execution from its normal sequence. When execution leaves a scope, all automatic objects that were created in that scope are destroyed.\n\nPerl supports the following control statements. Click the following links to check their detail.\n\nThe Infinite Loop\n\nA loop becomes infinite loop if a condition never becomes false. The for loop is traditionally used for this purpose. Since none of the three expressions that form the for loop are required, you can make an endless loop by leaving the conditional expression empty.\n\n#!/usr/local/bin/perl for( ; ; ) { printf \"This loop will run forever.\\n\"; }\n\nYou can terminate the above infinite loop by pressing the Ctrl + C keys.\n\nWhen the conditional expression is absent, it is assumed to be true. You may have an initialization and increment expression, but as a programmer more commonly use the for (;;) construct to signify an infinite loop.\n\nPerl - Operators\n\nWhat is an Operator?\n\nSimple answer can be given using the expression 4 + 5 is equal to 9. Here 4 and 5 are called operands and + is called operator. Perl language supports many operator types, but following is a list of important and most frequently used operators −\n\nArithmetic Operators\n\nEquality Operators\n\nLogical Operators\n\nAssignment Operators\n\nBitwise Operators\n\nLogical Operators\n\nQuote-like Operators\n\nMiscellaneous Operators\n\nLets have a look at all the operators one by one.\n\nPerl Arithmetic Operators\n\nAssume variable $a holds 10 and variable $b holds 20, then following are the Perl arithmatic operators −\n\nShow Example\n\nPerl Equality Operators\n\nThese are also called relational operators. Assume variable $a holds 10 and variable $b holds 20 then, lets check the following numeric equality operators −\n\nShow Example\n\nBelow is a list of equity operators. Assume variable $a holds \"abc\" and variable $b holds \"xyz\" then, lets check the following string equality operators −\n\nShow Example\n\nPerl Assignment Operators\n\nAssume variable $a holds 10 and variable $b holds 20, then below are the assignment operators available in Perl and their usage −\n\nShow Example\n\nPerl Bitwise Operators\n\nBitwise operator works on bits and perform bit by bit operation. Assume if $a = 60; and $b = 13; Now in binary format they will be as follows −\n\n$a = 0011 1100\n\n$b = 0000 1101\n\n-----------------\n\n$a&$b = 0000 1100\n\n$a|$b = 0011 1101\n\n$a^$b = 0011 0001\n\n~$a = 1100 0011\n\nThere are following Bitwise operators supported by Perl language, assume if $a = 60; and $b = 13\n\nShow Example\n\nPerl Logical Operators\n\nThere are following logical operators supported by Perl language. Assume variable $a holds true and variable $b holds false then −\n\nShow Example\n\nQuote-like Operators\n\nThere are following Quote-like operators supported by Perl language. In the following table, a {} represents any pair of delimiters you choose.\n\nShow Example\n\nMiscellaneous Operators\n\nThere are following miscellaneous operators supported by Perl language. Assume variable a holds 10 and variable b holds 20 then −\n\nShow Example\n\nPerl Operators Precedence\n\nThe following table lists all operators from highest precedence to lowest.\n\nShow Example\n\nleft terms and list operators (leftward) left -> nonassoc ++ -- right ** right ! ~ \\ and unary + and - left =~ !~ left * / % x left + - . left << >> nonassoc named unary operators nonassoc < > <= >= lt gt le ge nonassoc == != <=> eq ne cmp ~~ left & left | ^ left && left || // nonassoc .. ... right ?: right = += -= *= etc. left , => nonassoc list operators (rightward) right not left and left or xor\n\nPerl - Date and Time\n\nThis chapter will give you the basic understanding on how to process and manipulate dates and times in Perl.\n\nCurrent Date and Time\n\nLet's start with localtime() function, which returns values for the current date and time if given no arguments. Following is the 9-element list returned by the localtime function while using in list context −\n\nsec, # seconds of minutes from 0 to 61 min, # minutes of hour from 0 to 59 hour, # hours of day from 0 to 24 mday, # day of month from 1 to 31 mon, # month of year from 0 to 11 year, # year since 1900 wday, # days since sunday yday, # days since January 1st isdst # hours of daylight savings time\n\nTry the following example to print different elements returned by localtime() function −\n\n#!/usr/local/bin/perl @months = qw( Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec ); @days = qw(Sun Mon Tue Wed Thu Fri Sat Sun); ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(); print \"$mday $months[$mon] $days[$wday]\\n\";\n\nWhen the above code is executed, it produces the following result −\n\n16 Feb Sat\n\nIf you will use localtime() function in scalar context, then it will return date and time from the current time zone set in the system. Try the following example to print current date and time in full format −\n\n#!/usr/local/bin/perl $datestring = localtime(); print \"Local date and time $datestring\\n\";\n\nWhen the above code is executed, it produces the following result −\n\nLocal date and time Sat Feb 16 06:50:45 2013\n\nGMT Time\n\nThe function gmtime() works just like localtime() function but the returned values are localized for the standard Greenwich time zone. When called in list context, $isdst, the last value returned by gmtime, is always 0. There is no Daylight Saving Time in GMT.\n\nYou should make a note on the fact that localtime() will return the current local time on the machine that runs the script and gmtime() will return the universal Greenwich Mean Time, or GMT (or UTC).\n\nTry the following example to print the current date and time but on GMT scale −\n\n#!/usr/local/bin/perl $datestring = gmtime(); print \"GMT date and time $datestring\\n\";\n\nWhen the above code is executed, it produces the following result −\n\nGMT date and time Sat Feb 16 13:50:45 2013\n\nFormat Date and Time\n\nYou can use localtime() function to get a list of 9-elements and later you can use the printf() function to format date and time based on your requirements as follows −\n\n#!/usr/local/bin/perl ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) = localtime(); printf(\"Time Format - HH:MM:SS\\n\"); printf(\"%02d:%02d:%02d\", $hour, $min, $sec);\n\nWhen the above code is executed, it produces the following result −\n\nTime Format - HH:MM:SS 06:58:52\n\nEpoch time\n\nYou can use the time() function to get epoch time, i.e., the numbers of seconds that have elapsed since a given date, in Unix is January 1, 1970.\n\n#!/usr/local/bin/perl $epoc = time(); print \"Number of seconds since Jan 1, 1970 - $epoc\\n\";\n\nWhen the above code is executed, it produces the following result −\n\nNumber of seconds since Jan 1, 1970 - 1361022130\n\nYou can convert a given number of seconds into date and time string as follows −\n\n#!/usr/local/bin/perl $datestring = localtime(); print \"Current date and time $datestring\\n\"; $epoc = time(); $epoc = $epoc - 24 * 60 * 60; # one day before of current date. $datestring = localtime($epoc); print \"Yesterday's date and time $datestring\\n\";\n\nWhen the above code is executed, it produces the following result −\n\nCurrent date and time Tue Jun 5 05:54:43 2018 Yesterday's date and time Mon Jun 4 05:54:43 2018\n\nPOSIX Function strftime()\n\nYou can use the POSIX function strftime() to format date and time with the help of the following table. Please note that the specifiers marked with an asterisk (*) are locale-dependent.\n\nLet's check the following example to understand the usage −\n\n#!/usr/local/bin/perl use POSIX qw(strftime); $datestring = strftime \"%a %b %e %H:%M:%S %Y\", localtime; printf(\"date and time - $datestring\\n\"); # or for GMT formatted appropriately for your locale: $datestring = strftime \"%a %b %e %H:%M:%S %Y\", gmtime; printf(\"date and time - $datestring\\n\");\n\nWhen the above code is executed, it produces the following result −\n\ndate and time - Sat Feb 16 07:10:23 2013 date and time - Sat Feb 16 14:10:23 2013\n\nPerl - Subroutines\n\nA Perl subroutine or function is a group of statements that together performs a task. You can divide up your code into separate subroutines. How you divide up your code among different subroutines is up to you, but logically the division usually is so each function performs a specific task.\n\nPerl uses the terms subroutine, method and function interchangeably.\n\nDefine and Call a Subroutine\n\nThe general form of a subroutine definition in Perl programming language is as follows −\n\nsub subroutine_name { body of the subroutine }\n\nThe typical way of calling that Perl subroutine is as follows −\n\nsubroutine_name( list of arguments );\n\nIn versions of Perl before 5.0, the syntax for calling subroutines was slightly different as shown below. This still works in the newest versions of Perl, but it is not recommended since it bypasses the subroutine prototypes.\n\n&subroutine_name( list of arguments );\n\nLet's have a look into the following example, which defines a simple function and then call it. Because Perl compiles your program before executing it, it doesn't matter where you declare your subroutine.\n\n#!/usr/bin/perl # Function definition sub Hello { print \"Hello, World!\\n\"; } # Function call Hello();\n\nWhen above program is executed, it produces the following result −\n\nHello, World!\n\nPassing Arguments to a Subroutine\n\nYou can pass various arguments to a subroutine like you do in any other programming language and they can be acessed inside the function using the special array @_. Thus the first argument to the function is in $_[0], the second is in $_[1], and so on.\n\nYou can pass arrays and hashes as arguments like any scalar but passing more than one array or hash normally causes them to lose their separate identities. So we will use references ( explained in the next chapter ) to pass any array or hash.\n\nLet's try the following example, which takes a list of numbers and then prints their average −\n\n#!/usr/bin/perl # Function definition sub Average { # get total number of arguments passed. $n = scalar(@_); $sum = 0; foreach $item (@_) { $sum += $item; } $average = $sum / $n; print \"Average for the given numbers : $average\\n\"; } # Function call Average(10, 20, 30);\n\nWhen above program is executed, it produces the following result −\n\nAverage for the given numbers : 20\n\nPassing Lists to Subroutines\n\nBecause the @_ variable is an array, it can be used to supply lists to a subroutine. However, because of the way in which Perl accepts and parses lists and arrays, it can be difficult to extract the individual elements from @_. If you have to pass a list along with other scalar arguments, then make list as the last argument as shown below −\n\n#!/usr/bin/perl # Function definition sub PrintList { my @list = @_; print \"Given list is @list\\n\"; } $a = 10; @b = (1, 2, 3, 4); # Function call with list parameter PrintList($a, @b);\n\nWhen above program is executed, it produces the following result −\n\nGiven list is 10 1 2 3 4\n\nPassing Hashes to Subroutines\n\nWhen you supply a hash to a subroutine or operator that accepts a list, then hash is automatically translated into a list of key/value pairs. For example −\n\n#!/usr/bin/perl # Function definition sub PrintHash { my (%hash) = @_; foreach my $key ( keys %hash ) { my $value = $hash{$key}; print \"$key : $value\\n\"; } } %hash = ('name' => 'Tom', 'age' => 19); # Function call with hash parameter PrintHash(%hash);\n\nWhen above program is executed, it produces the following result −\n\nname : Tom age : 19\n\nReturning Value from a Subroutine\n\nYou can return a value from subroutine like you do in any other programming language. If you are not returning a value from a subroutine then whatever calculation is last performed in a subroutine is automatically also the return value.\n\nYou can return arrays and hashes from the subroutine like any scalar but returning more than one array or hash normally causes them to lose their separate identities. So we will use references ( explained in the next chapter ) to return any array or hash from a function.\n\nLet's try the following example, which takes a list of numbers and then returns their average −\n\n#!/usr/bin/perl # Function definition sub Average { # get total number of arguments passed. $n = scalar(@_); $sum = 0; foreach $item (@_) { $sum += $item; } $average = $sum / $n; return $average; } # Function call $num = Average(10, 20, 30); print \"Average for the given numbers : $num\\n\";\n\nWhen above program is executed, it produces the following result −\n\nAverage for the given numbers : 20\n\nPrivate Variables in a Subroutine\n\nBy default, all variables in Perl are global variables, which means they can be accessed from anywhere in the program. But you can create private variables called lexical variables at any time with the my operator.\n\nThe my operator confines a variable to a particular region of code in which it can be used and accessed. Outside that region, this variable cannot be used or accessed. This region is called its scope. A lexical scope is usually a block of code with a set of braces around it, such as those defining the body of the subroutine or those marking the code blocks of if, while, for, foreach, and eval statements.\n\nFollowing is an example showing you how to define a single or multiple private variables using my operator −\n\nsub somefunc { my $variable; # $variable is invisible outside somefunc() my ($another, @an_array, %a_hash); # declaring many variables at once }\n\nLet's check the following example to distinguish between global and private variables −\n\n#!/usr/bin/perl # Global variable $string = \"Hello, World!\"; # Function definition sub PrintHello { # Private variable for PrintHello function my $string; $string = \"Hello, Perl!\"; print \"Inside the function $string\\n\"; } # Function call PrintHello(); print \"Outside the function $string\\n\";\n\nWhen above program is executed, it produces the following result −\n\nInside the function Hello, Perl! Outside the function Hello, World!\n\nTemporary Values via local()\n\nThe local is mostly used when the current value of a variable must be visible to called subroutines. A local just gives temporary values to global (meaning package) variables. This is known as dynamic scoping. Lexical scoping is done with my, which works more like C's auto declarations.\n\nIf more than one variable or expression is given to local, they must be placed in parentheses. This operator works by saving the current values of those variables in its argument list on a hidden stack and restoring them upon exiting the block, subroutine, or eval.\n\nLet's check the following example to distinguish between global and local variables −\n\n#!/usr/bin/perl # Global variable $string = \"Hello, World!\"; sub PrintHello { # Private variable for PrintHello function local $string; $string = \"Hello, Perl!\"; PrintMe(); print \"Inside the function PrintHello $string\\n\"; } sub PrintMe { print \"Inside the function PrintMe $string\\n\"; } # Function call PrintHello(); print \"Outside the function $string\\n\";\n\nWhen above program is executed, it produces the following result −\n\nInside the function PrintMe Hello, Perl! Inside the function PrintHello Hello, Perl! Outside the function Hello, World!\n\nState Variables via state()\n\nThere are another type of lexical variables, which are similar to private variables but they maintain their state and they do not get reinitialized upon multiple calls of the subroutines. These variables are defined using the state operator and available starting from Perl 5.9.4.\n\nLet's check the following example to demonstrate the use of state variables −\n\n#!/usr/bin/perl use feature 'state'; sub PrintCount { state $count = 0; # initial value print \"Value of counter is $count\\n\"; $count++; } for (1..5) { PrintCount(); }\n\nWhen above program is executed, it produces the following result −\n\nValue of counter is 0 Value of counter is 1 Value of counter is 2 Value of counter is 3 Value of counter is 4\n\nPrior to Perl 5.10, you would have to write it like this −\n\n#!/usr/bin/perl { my $count = 0; # initial value sub PrintCount { print \"Value of counter is $count\\n\"; $count++; } } for (1..5) { PrintCount(); }\n\nSubroutine Call Context\n\nThe context of a subroutine or statement is defined as the type of return value that is expected. This allows you to use a single function that returns different values based on what the user is expecting to receive. For example, the following localtime() returns a string when it is called in scalar context, but it returns a list when it is called in list context.\n\nmy $datestring = localtime( time );\n\nIn this example, the value of $timestr is now a string made up of the current date and time, for example, Thu Nov 30 15:21:33 2000. Conversely −\n\n($sec,$min,$hour,$mday,$mon, $year,$wday,$yday,$isdst) = localtime(time);\n\nNow the individual variables contain the corresponding values returned by localtime() subroutine.\n\nPerl - References\n\nA Perl reference is a scalar data type that holds the location of another value which could be scalar, arrays, or hashes. Because of its scalar nature, a reference can be used anywhere, a scalar can be used.\n\nYou can construct lists containing references to other lists, which can contain references to hashes, and so on. This is how the nested data structures are built in Perl.\n\nCreate References\n\nIt is easy to create a reference for any variable, subroutine or value by prefixing it with a backslash as follows −\n\n$scalarref = \\$foo; $arrayref = \\@ARGV; $hashref = \\%ENV; $coderef = \\&handler; $globref = \\*foo;\n\nYou cannot create a reference on an I/O handle (filehandle or dirhandle) using the backslash operator but a reference to an anonymous array can be created using the square brackets as follows −\n\n$arrayref = [1, 2, ['a', 'b', 'c']];\n\nSimilar way you can create a reference to an anonymous hash using the curly brackets as follows −\n\n$hashref = { 'Adam' => 'Eve', 'Clyde' => 'Bonnie', };\n\nA reference to an anonymous subroutine can be created by using sub without a subname as follows −\n\n$coderef = sub { print \"Boink!\\n\" };\n\nDereferencing\n\nDereferencing returns the value from a reference point to the location. To dereference a reference simply use $, @ or % as prefix of the reference variable depending on whether the reference is pointing to a scalar, array, or hash. Following is the example to explain the concept −\n\n#!/usr/bin/perl $var = 10; # Now $r has reference to $var scalar. $r = \\$var; # Print value available at the location stored in $r. print \"Value of $var is : \", $$r, \"\\n\"; @var = (1, 2, 3); # Now $r has reference to @var array. $r = \\@var; # Print values available at the location stored in $r. print \"Value of @var is : \", @$r, \"\\n\"; %var = ('key1' => 10, 'key2' => 20); # Now $r has reference to %var hash. $r = \\%var; # Print values available at the location stored in $r. print \"Value of %var is : \", %$r, \"\\n\";\n\nWhen above program is executed, it produces the following result −\n\nValue of 10 is : 10 Value of 1 2 3 is : 123 Value of %var is : key220key110\n\nIf you are not sure about a variable type, then its easy to know its type using ref, which returns one of the following strings if its argument is a reference. Otherwise, it returns false −\n\nSCALAR ARRAY HASH CODE GLOB REF\n\nLet's try the following example −\n\n#!/usr/bin/perl $var = 10; $r = \\$var; print \"Reference type in r : \", ref($r), \"\\n\"; @var = (1, 2, 3); $r = \\@var; print \"Reference type in r : \", ref($r), \"\\n\"; %var = ('key1' => 10, 'key2' => 20); $r = \\%var; print \"Reference type in r : \", ref($r), \"\\n\";\n\nWhen above program is executed, it produces the following result −\n\nReference type in r : SCALAR Reference type in r : ARRAY Reference type in r : HASH\n\nCircular References\n\nA circular reference occurs when two references contain a reference to each other. You have to be careful while creating references otherwise a circular reference can lead to memory leaks. Following is an example −\n\n#!/usr/bin/perl my $foo = 100; $foo = \\$foo; print \"Value of foo is : \", $$foo, \"\\n\";\n\nWhen above program is executed, it produces the following result −\n\nValue of foo is : REF(0x9aae38)\n\nReferences to Functions\n\nThis might happen if you need to create a signal handler so you can produce a reference to a function by preceding that function name with \\& and to dereference that reference you simply need to prefix reference variable using ampersand &. Following is an example −\n\n#!/usr/bin/perl # Function definition sub PrintHash { my (%hash) = @_; foreach $item (%hash) { print \"Item : $item\\n\"; } } %hash = ('name' => 'Tom', 'age' => 19); # Create a reference to above function. $cref = \\&PrintHash; # Function call using reference. &$cref(%hash);\n\nWhen above program is executed, it produces the following result −\n\nItem : name Item : Tom Item : age Item : 19\n\nPerl - Formats\n\nPerl uses a writing template called a 'format' to output reports. To use the format feature of Perl, you have to define a format first and then you can use that format to write formatted data.\n\nDefine a Format\n\nFollowing is the syntax to define a Perl format −\n\nformat FormatName = fieldline value_one, value_two, value_three fieldline value_one, value_two .\n\nHere FormatName represents the name of the format. The fieldline is the specific way, the data should be formatted. The values lines represent the values that will be entered into the field line. You end the format with a single period.\n\nNext fieldline can contain any text or fieldholders. The fieldholders hold space for data that will be placed there at a later date. A fieldholder has the format −\n\n@<<<<\n\nThis fieldholder is left-justified, with a field space of 5. You must count the @ sign and the < signs to know the number of spaces in the field. Other field holders include −\n\n@>>>> right-justified @|||| centered @####.## numeric field holder @* multiline field holder\n\nAn example format would be −\n\nformat EMPLOYEE = =================================== @<<<<<<<<<<<<<<<<<<<<<< @<< $name $age @#####.## $salary =================================== .\n\nIn this example, $name would be written as left justify within 22 character spaces and after that age will be written in two spaces.\n\nUsing the Format\n\nIn order to invoke this format declaration, we would use the write keyword −\n\nwrite EMPLOYEE;\n\nThe problem is that the format name is usually the name of an open file handle, and the write statement will send the output to this file handle. As we want the data sent to the STDOUT, we must associate EMPLOYEE with the STDOUT filehandle. First, however, we must make sure that that STDOUT is our selected file handle, using the select() function.\n\nselect(STDOUT);\n\nWe would then associate EMPLOYEE with STDOUT by setting the new format name with STDOUT, using the special variable $~ or $FORMAT_NAME as follows −\n\n$~ = \"EMPLOYEE\";\n\nWhen we now do a write(), the data would be sent to STDOUT. Remember: if you are going to write your report in any other file handle instead of STDOUT then you can use select() function to select that file handle and rest of the logic will remain the same.\n\nLet's take the following example. Here we have hard coded values just for showing the usage. In actual usage you will read values from a file or database to generate actual reports and you may need to write final report again into a file.\n\n#!/usr/bin/perl format EMPLOYEE = =================================== @<<<<<<<<<<<<<<<<<<<<<< @<< $name $age @#####.## $salary =================================== . select(STDOUT); $~ = EMPLOYEE; @n = (\"Ali\", \"Raza\", \"Jaffer\"); @a = (20,30, 40); @s = (2000.00, 2500.00, 4000.000); $i = 0; foreach (@n) { $name = $_; $age = $a[$i]; $salary = $s[$i++]; write; }\n\nWhen executed, this will produce the following result −\n\n=================================== Ali 20 2000.00 =================================== =================================== Raza 30 2500.00 =================================== =================================== Jaffer 40 4000.00 ===================================\n\nDefine a Report Header\n\nEverything looks fine. But you would be interested in adding a header to your report. This header will be printed on top of each page. It is very simple to do this. Apart from defining a template you would have to define a header and assign it to $^ or $FORMAT_TOP_NAME variable −\n\n#!/usr/bin/perl format EMPLOYEE = =================================== @<<<<<<<<<<<<<<<<<<<<<< @<< $name $age @#####.## $salary =================================== . format EMPLOYEE_TOP = =================================== Name Age =================================== . select(STDOUT); $~ = EMPLOYEE; $^ = EMPLOYEE_TOP; @n = (\"Ali\", \"Raza\", \"Jaffer\"); @a = (20,30, 40); @s = (2000.00, 2500.00, 4000.000); $i = 0; foreach (@n) { $name = $_; $age = $a[$i]; $salary = $s[$i++]; write; }\n\nNow your report will look like −\n\n=================================== Name Age =================================== =================================== Ali 20 2000.00 =================================== =================================== Raza 30 2500.00 =================================== =================================== Jaffer 40 4000.00 ===================================\n\nDefine a Pagination\n\nWhat about if your report is taking more than one page? You have a solution for that, simply use $% or $FORMAT_PAGE_NUMBER vairable along with header as follows −\n\nformat EMPLOYEE_TOP = =================================== Name Age Page @< $% =================================== .\n\nNow your output will look like as follows −\n\n=================================== Name Age Page 1 =================================== =================================== Ali 20 2000.00 =================================== =================================== Raza 30 2500.00 =================================== =================================== Jaffer 40 4000.00 ===================================\n\nNumber of Lines on a Page\n\nYou can set the number of lines per page using special variable $= ( or $FORMAT_LINES_PER_PAGE ), By default $= will be 60.\n\nDefine a Report Footer\n\nWhile $^ or $FORMAT_TOP_NAME contains the name of the current header format, there is no corresponding mechanism to automatically do the same thing for a footer. If you have a fixed-size footer, you can get footers by checking variable $- or $FORMAT_LINES_LEFT before each write() and print the footer yourself if necessary using another format defined as follows −\n\nformat EMPLOYEE_BOTTOM = End of Page @< $% .\n\nFor a complete set of variables related to formating, please refer to the Perl Special Variables section.\n\nPerl - File I/O\n\nThe basics of handling files are simple: you associate a filehandle with an external entity (usually a file) and then use a variety of operators and functions within Perl to read and update the data stored within the data stream associated with the filehandle.\n\nA filehandle is a named internal Perl structure that associates a physical file with a name. All filehandles are capable of read/write access, so you can read from and update any file or device associated with a filehandle. However, when you associate a filehandle, you can specify the mode in which the filehandle is opened.\n\nThree basic file handles are - STDIN, STDOUT, and STDERR, which represent standard input, standard output and standard error devices respectively.\n\nOpening and Closing Files\n\nThere are following two functions with multiple forms, which can be used to open any new or existing file in Perl.\n\nopen FILEHANDLE, EXPR open FILEHANDLE sysopen FILEHANDLE, FILENAME, MODE, PERMS sysopen FILEHANDLE, FILENAME, MODE\n\nHere FILEHANDLE is the file handle returned by the open function and EXPR is the expression having file name and mode of opening the file.\n\nOpen Function\n\nFollowing is the syntax to open file.txt in read-only mode. Here less than < sign indicates that file has to be opend in read-only mode.\n\nopen(DATA, \"<file.txt\");\n\nHere DATA is the file handle, which will be used to read the file. Here is the example, which will open a file and will print its content over the screen.\n\n#!/usr/bin/perl open(DATA, \"<file.txt\") or die \"Couldn't open file file.txt, $!\"; while(<DATA>) { print \"$_\"; }\n\nFollowing is the syntax to open file.txt in writing mode. Here less than > sign indicates that file has to be opend in the writing mode.\n\nopen(DATA, \">file.txt\") or die \"Couldn't open file file.txt, $!\";\n\nThis example actually truncates (empties) the file before opening it for writing, which may not be the desired effect. If you want to open a file for reading and writing, you can put a plus sign before the > or < characters.\n\nFor example, to open a file for updating without truncating it −\n\nopen(DATA, \"+<file.txt\"); or die \"Couldn't open file file.txt, $!\";\n\nTo truncate the file first −\n\nopen DATA, \"+>file.txt\" or die \"Couldn't open file file.txt, $!\";\n\nYou can open a file in the append mode. In this mode, writing point will be set to the end of the file.\n\nopen(DATA,\">>file.txt\") || die \"Couldn't open file file.txt, $!\";\n\nA double >> opens the file for appending, placing the file pointer at the end, so that you can immediately start appending information. However, you can't read from it unless you also place a plus sign in front of it −\n\nopen(DATA,\"+>>file.txt\") || die \"Couldn't open file file.txt, $!\";\n\nFollowing is the table, which gives the possible values of different modes\n\nSysopen Function\n\nThe sysopen function is similar to the main open function, except that it uses the system open() function, using the parameters supplied to it as the parameters for the system function −\n\nFor example, to open a file for updating, emulating the +<filename format from open −\n\nsysopen(DATA, \"file.txt\", O_RDWR);\n\nOr to truncate the file before updating −\n\nsysopen(DATA, \"file.txt\", O_RDWR|O_TRUNC );\n\nYou can use O_CREAT to create a new file and O_WRONLY- to open file in write only mode and O_RDONLY - to open file in read only mode.\n\nThe PERMS argument specifies the file permissions for the file specified, if it has to be created. By default it takes 0x666.\n\nFollowing is the table, which gives the possible values of MODE.\n\nClose Function\n\nTo close a filehandle, and therefore disassociate the filehandle from the corresponding file, you use the close function. This flushes the filehandle's buffers and closes the system's file descriptor.\n\nclose FILEHANDLE close\n\nIf no FILEHANDLE is specified, then it closes the currently selected filehandle. It returns true only if it could successfully flush the buffers and close the file.\n\nclose(DATA) || die \"Couldn't close file properly\";\n\nReading and Writing Files\n\nOnce you have an open filehandle, you need to be able to read and write information. There are a number of different ways of reading and writing data into the file.\n\nThe <FILEHANDL> Operator\n\nThe main method of reading the information from an open filehandle is the <FILEHANDLE> operator. In a scalar context, it returns a single line from the filehandle. For example −\n\n#!/usr/bin/perl print \"What is your name?\\n\"; $name = <STDIN>; print \"Hello $name\\n\";\n\nWhen you use the <FILEHANDLE> operator in a list context, it returns a list of lines from the specified filehandle. For example, to import all the lines from a file into an array −\n\n#!/usr/bin/perl open(DATA,\"<import.txt\") or die \"Can't open data\"; @lines = <DATA>; close(DATA);\n\ngetc Function\n\nThe getc function returns a single character from the specified FILEHANDLE, or STDIN if none is specified −\n\ngetc FILEHANDLE getc\n\nIf there was an error, or the filehandle is at end of file, then undef is returned instead.\n\nread Function\n\nThe read function reads a block of information from the buffered filehandle: This function is used to read binary data from the file.\n\nread FILEHANDLE, SCALAR, LENGTH, OFFSET read FILEHANDLE, SCALAR, LENGTH\n\nThe length of the data read is defined by LENGTH, and the data is placed at the start of SCALAR if no OFFSET is specified. Otherwise data is placed after OFFSET bytes in SCALAR. The function returns the number of bytes read on success, zero at end of file, or undef if there was an error.\n\nprint Function\n\nFor all the different methods used for reading information from filehandles, the main function for writing information back is the print function.\n\nprint FILEHANDLE LIST print LIST print\n\nThe print function prints the evaluated value of LIST to FILEHANDLE, or to the current output filehandle (STDOUT by default). For example −\n\nprint \"Hello World!\\n\";\n\nCopying Files\n\nHere is the example, which opens an existing file file1.txt and read it line by line and generate another copy file file2.txt.\n\n#!/usr/bin/perl # Open file to read open(DATA1, \"<file1.txt\"); # Open new file to write open(DATA2, \">file2.txt\"); # Copy data from one file to another. while(<DATA1>) { print DATA2 $_; } close( DATA1 ); close( DATA2 );\n\nRenaming a file\n\nHere is an example, which shows how we can rename a file file1.txt to file2.txt. Assuming file is available in /usr/test directory.\n\n#!/usr/bin/perl rename (\"/usr/test/file1.txt\", \"/usr/test/file2.txt\" );\n\nThis function renames takes two arguments and it just renames the existing file.\n\nDeleting an Existing File\n\nHere is an example, which shows how to delete a file file1.txt using the unlink function.\n\n#!/usr/bin/perl unlink (\"/usr/test/file1.txt\");\n\nPositioning inside a File\n\nYou can use to tell function to know the current position of a file and seek function to point a particular position inside the file.\n\ntell Function\n\nThe first requirement is to find your position within a file, which you do using the tell function −\n\ntell FILEHANDLE tell\n\nThis returns the position of the file pointer, in bytes, within FILEHANDLE if specified, or the current default selected filehandle if none is specified.\n\nseek Function\n\nThe seek function positions the file pointer to the specified number of bytes within a file −\n\nseek FILEHANDLE, POSITION, WHENCE\n\nThe function uses the fseek system function, and you have the same ability to position relative to three different points: the start, the end, and the current position. You do this by specifying a value for WHENCE.\n\nZero sets the positioning relative to the start of the file. For example, the line sets the file pointer to the 256th byte in the file.\n\nseek DATA, 256, 0;\n\nFile Information\n\nYou can test certain features very quickly within Perl using a series of test operators known collectively as -X tests. For example, to perform a quick test of the various permissions on a file, you might use a script like this −\n\n#/usr/bin/perl my $file = \"/usr/test/file1.txt\"; my (@description, $size); if (-e $file) { push @description, 'binary' if (-B _); push @description, 'a socket' if (-S _); push @description, 'a text file' if (-T _); push @description, 'a block special file' if (-b _); push @description, 'a character special file' if (-c _); push @description, 'a directory' if (-d _); push @description, 'executable' if (-x _); push @description, (($size = -s _)) ? \"$size bytes\" : 'empty'; print \"$file is \", join(', ',@description),\"\\n\"; }\n\nHere is the list of features, which you can check for a file or directory −\n\nPerl - Directories\n\nFollowing are the standard functions used to play with directories.\n\nopendir DIRHANDLE, EXPR # To open a directory readdir DIRHANDLE # To read a directory rewinddir DIRHANDLE # Positioning pointer to the begining telldir DIRHANDLE # Returns current position of the dir seekdir DIRHANDLE, POS # Pointing pointer to POS inside dir closedir DIRHANDLE # Closing a directory.\n\nDisplay all the Files\n\nThere are various ways to list down all the files available in a particular directory. First let's use the simple way to get and list down all the files using the glob operator −\n\n#!/usr/bin/perl # Display all the files in /tmp directory. $dir = \"/tmp/*\"; my @files = glob( $dir ); foreach (@files ) { print $_ . \"\\n\"; } # Display all the C source files in /tmp directory. $dir = \"/tmp/*.c\"; @files = glob( $dir ); foreach (@files ) { print $_ . \"\\n\"; } # Display all the hidden files. $dir = \"/tmp/.*\"; @files = glob( $dir ); foreach (@files ) { print $_ . \"\\n\"; } # Display all the files from /tmp and /home directories. $dir = \"/tmp/* /home/*\"; @files = glob( $dir ); foreach (@files ) { print $_ . \"\\n\"; }\n\nHere is another example, which opens a directory and list out all the files available inside this directory.\n\n#!/usr/bin/perl opendir (DIR, '.') or die \"Couldn't open directory, $!\"; while ($file = readdir DIR) { print \"$file\\n\"; } closedir DIR;\n\nOne more example to print the list of C source files you might use is −\n\n#!/usr/bin/perl opendir(DIR, '.') or die \"Couldn't open directory, $!\"; foreach (sort grep(/^.*\\.c$/,readdir(DIR))) { print \"$_\\n\"; } closedir DIR;\n\nCreate new Directory\n\nYou can use mkdir function to create a new directory. You will need to have the required permission to create a directory.\n\n#!/usr/bin/perl $dir = \"/tmp/perl\"; # This creates perl directory in /tmp directory. mkdir( $dir ) or die \"Couldn't create $dir directory, $!\"; print \"Directory created successfully\\n\";\n\nRemove a directory\n\nYou can use rmdir function to remove a directory. You will need to have the required permission to remove a directory. Additionally this directory should be empty before you try to remove it.\n\n#!/usr/bin/perl $dir = \"/tmp/perl\"; # This removes perl directory from /tmp directory. rmdir( $dir ) or die \"Couldn't remove $dir directory, $!\"; print \"Directory removed successfully\\n\";\n\nChange a Directory\n\nYou can use chdir function to change a directory and go to a new location. You will need to have the required permission to change a directory and go inside the new directory.\n\n#!/usr/bin/perl $dir = \"/home\"; # This changes perl directory and moves you inside /home directory. chdir( $dir ) or die \"Couldn't go inside $dir directory, $!\"; print \"Your new location is $dir\\n\";\n\nPerl - Error Handling\n\nThe execution and the errors always go together. If you are opening a file which does not exist. then if you did not handle this situation properly then your program is considered to be of bad quality.\n\nThe program stops if an error occurs. So a proper error handling is used to handle various type of errors, which may occur during a program execution and take appropriate action instead of halting program completely.\n\nYou can identify and trap an error in a number of different ways. Its very easy to trap errors in Perl and then handling them properly. Here are few methods which can be used.\n\nThe if statement\n\nThe if statement is the obvious choice when you need to check the return value from a statement; for example −\n\nif(open(DATA, $file)) { ... } else { die \"Error: Couldn't open the file - $!\"; }\n\nHere variable $! returns the actual error message. Alternatively, we can reduce the statement to one line in situations where it makes sense to do so; for example −\n\nopen(DATA, $file) || die \"Error: Couldn't open the file $!\";\n\nThe unless Function\n\nThe unless function is the logical opposite to if: statements can completely bypass the success status and only be executed if the expression returns false. For example −\n\nunless(chdir(\"/etc\")) { die \"Error: Can't change directory - $!\"; }\n\nThe unless statement is best used when you want to raise an error or alternative only if the expression fails. The statement also makes sense when used in a single-line statement −\n\ndie \"Error: Can't change directory!: $!\" unless(chdir(\"/etc\"));\n\nHere we die only if the chdir operation fails, and it reads nicely.\n\nThe ternary Operator\n\nFor very short tests, you can use the conditional operator ?:\n\nprint(exists($hash{value}) ? 'There' : 'Missing',\"\\n\");\n\nIt's not quite so clear here what we are trying to achieve, but the effect is the same as using an if or unless statement. The conditional operator is best used when you want to quickly return one of the two values within an expression or statement.\n\nThe warn Function\n\nThe warn function just raises a warning, a message is printed to STDERR, but no further action is taken. So it is more useful if you just want to print a warning for the user and proceed with rest of the operation −\n\nchdir('/etc') or warn \"Can't change directory\";\n\nThe die Function\n\nThe die function works just like warn, except that it also calls exit. Within a normal script, this function has the effect of immediately terminating execution. You should use this function in case it is useless to proceed if there is an error in the program −\n\nchdir('/etc') or die \"Can't change directory\";\n\nErrors within Modules\n\nThere are two different situations we should be able to handle −\n\nReporting an error in a module that quotes the module's filename and line number - this is useful when debugging a module, or when you specifically want to raise a module-related, rather than script-related, error.\n\nReporting an error within a module that quotes the caller's information so that you can debug the line within the script that caused the error. Errors raised in this fashion are useful to the end-user, because they highlight the error in relation to the calling script's origination line.\n\nThe warn and die functions work slightly differently than you would expect when called from within a module. For example, the simple module −\n\npackage T; require Exporter; @ISA = qw/Exporter/; @EXPORT = qw/function/; use Carp; sub function { warn \"Error in module!\"; } 1;\n\nWhen called from a script like below −\n\nuse T; function();\n\nIt will produce the following result −\n\nError in module! at T.pm line 9.\n\nThis is more or less what you might expected, but not necessarily what you want. From a module programmer's perspective, the information is useful because it helps to point to a bug within the module itself. For an end-user, the information provided is fairly useless, and for all but the hardened programmer, it is completely pointless.\n\nThe solution for such problems is the Carp module, which provides a simplified method for reporting errors within modules that return information about the calling script. The Carp module provides four functions: carp, cluck, croak, and confess. These functions are discussed below.\n\nThe carp Function\n\nThe carp function is the basic equivalent of warn and prints the message to STDERR without actually exiting the script and printing the script name.\n\npackage T; require Exporter; @ISA = qw/Exporter/; @EXPORT = qw/function/; use Carp; sub function { carp \"Error in module!\"; } 1;\n\nWhen called from a script like below −\n\nuse T; function();\n\nIt will produce the following result −\n\nError in module! at test.pl line 4\n\nThe cluck Function\n\nThe cluck function is a sort of supercharged carp, it follows the same basic principle but also prints a stack trace of all the modules that led to the function being called, including the information on the original script.\n\npackage T; require Exporter; @ISA = qw/Exporter/; @EXPORT = qw/function/; use Carp qw(cluck); sub function { cluck \"Error in module!\"; } 1;\n\nWhen called from a script like below −\n\nuse T; function();\n\nIt will produce the following result −\n\nError in module! at T.pm line 9 T::function() called at test.pl line 4\n\nThe croak Function\n\nThe croak function is equivalent to die, except that it reports the caller one level up. Like die, this function also exits the script after reporting the error to STDERR −\n\npackage T; require Exporter; @ISA = qw/Exporter/; @EXPORT = qw/function/; use Carp; sub function { croak \"Error in module!\"; } 1;\n\nWhen called from a script like below −\n\nuse T; function();\n\nIt will produce the following result −\n\nError in module! at test.pl line 4\n\nAs with carp, the same basic rules apply regarding the including of line and file information according to the warn and die functions.\n\nThe confess Function\n\nThe confess function is like cluck; it calls die and then prints a stack trace all the way up to the origination script.\n\npackage T; require Exporter; @ISA = qw/Exporter/; @EXPORT = qw/function/; use Carp; sub function { confess \"Error in module!\"; } 1;\n\nWhen called from a script like below −\n\nuse T; function();\n\nIt will produce the following result −\n\nError in module! at T.pm line 9 T::function() called at test.pl line 4\n\nPerl - Special Variables\n\nThere are some variables which have a predefined and special meaning in Perl. They are the variables that use punctuation characters after the usual variable indicator ($, @, or %), such as $_ ( explained below ).\n\nMost of the special variables have an english like long name, e.g., Operating System Error variable $! can be written as $OS_ERROR. But if you are going to use english like names, then you would have to put one line use English; at the top of your program file. This guides the interpreter to pickup exact meaning of the variable.\n\nThe most commonly used special variable is $_, which contains the default input and pattern-searching string. For example, in the following lines −\n\n#!/usr/bin/perl foreach ('hickory','dickory','doc') { print $_; print \"\\n\"; }\n\nWhen executed, this will produce the following result −\n\nhickory dickory doc\n\nAgain, let's check the same example without using $_ variable explicitly −\n\n#!/usr/bin/perl foreach ('hickory','dickory','doc') { print; print \"\\n\"; }\n\nWhen executed, this will also produce the following result −\n\nhickory dickory doc\n\nThe first time the loop is executed, \"hickory\" is printed. The second time around, \"dickory\" is printed, and the third time, \"doc\" is printed. That's because in each iteration of the loop, the current string is placed in $_, and is used by default by print. Here are the places where Perl will assume $_ even if you don't specify it −\n\nVarious unary functions, including functions like ord and int, as well as the all file tests (-f, -d) except for -t, which defaults to STDIN.\n\nVarious list functions like print and unlink.\n\nThe pattern-matching operations m//, s///, and tr/// when used without an =~ operator.\n\nThe default iterator variable in a foreach loop if no other variable is supplied.\n\nThe implicit iterator variable in the grep and map functions.\n\nThe default place to put an input record when a line-input operation's result is tested by itself as the sole criterion of a while test (i.e., ). Note that outside of a while test, this will not happen.\n\nSpecial Variable Types\n\nBased on the usage and nature of special variables, we can categorize them in the following categories −\n\nGlobal Scalar Special Variables.\n\nGlobal Array Special Variables.\n\nGlobal Hash Special Variables.\n\nGlobal Special Filehandles.\n\nGlobal Special Constants.\n\nRegular Expression Special Variables.\n\nFilehandle Special Variables.\n\nGlobal Scalar Special Variables\n\nHere is the list of all the scalar special variables. We have listed corresponding english like names along with the symbolic names.\n\nGlobal Array Special Variables\n\nGlobal Hash Special Variables\n\nGlobal Special Filehandles\n\nGlobal Special Constants\n\nRegular Expression Special Variables\n\nFilehandle Special Variables\n\nPerl - Coding Standard\n\nEach programmer will, of course, have his or her own preferences in regards to formatting, but there are some general guidelines that will make your programs easier to read, understand, and maintain.\n\nThe most important thing is to run your programs under the -w flag at all times. You may turn it off explicitly for particular portions of code via the no warnings pragma or the $^W variable if you must. You should also always run under use strict or know the reason why not. The use sigtrap and even use diagnostics pragmas may also prove useful.\n\nRegarding aesthetics of code lay out, about the only thing Larry cares strongly about is that the closing curly bracket of a multi-line BLOCK should line up with the keyword that started the construct. Beyond that, he has other preferences that aren't so strong −\n\n4-column indent.\n\nOpening curly on same line as keyword, if possible, otherwise line up.\n\nSpace before the opening curly of a multi-line BLOCK.\n\nOne-line BLOCK may be put on one line, including curlies.\n\nNo space before the semicolon.\n\nSemicolon omitted in \"short\" one-line BLOCK.\n\nSpace around most operators.\n\nSpace around a \"complex\" subscript (inside brackets).\n\nBlank lines between chunks that do different things.\n\nUncuddled elses.\n\nNo space between function name and its opening parenthesis.\n\nSpace after each comma.\n\nLong lines broken after an operator (except and and or).\n\nSpace after last parenthesis matching on current line.\n\nLine up corresponding items vertically.\n\nOmit redundant punctuation as long as clarity doesn't suffer.\n\nHere are some other more substantive style issues to think about: Just because you CAN do something a particular way doesn't mean that you SHOULD do it that way. Perl is designed to give you several ways to do anything, so consider picking the most readable one. For instance −\n\nopen(FOO,$foo) || die \"Can't open $foo: $!\";\n\nIs better than −\n\ndie \"Can't open $foo: $!\" unless open(FOO,$foo);\n\nBecause the second way hides the main point of the statement in a modifier. On the other hand,\n\nprint \"Starting analysis\\n\" if $verbose;\n\nIs better than −\n\n$verbose && print \"Starting analysis\\n\";\n\nBecause the main point isn't whether the user typed -v or not.\n\nDon't go through silly contortions to exit a loop at the top or the bottom, when Perl provides the last operator so you can exit in the middle. Just \"outdent\" it a little to make it more visible −\n\nLINE: for (;;) { statements; last LINE if $foo; next LINE if /^#/; statements; }\n\nLet's see few more important points −\n\nDon't be afraid to use loop labels--they're there to enhance readability as well as to allow multilevel loop breaks. See the previous example.\n\nAvoid using grep() (or map()) or `backticks` in a void context, that is, when you just throw away their return values. Those functions all have return values, so use them. Otherwise use a foreach() loop or the system() function instead.\n\nFor portability, when using features that may not be implemented on every machine, test the construct in an eval to see if it fails. If you know what version or patchlevel a particular feature was implemented, you can test $] ($PERL_VERSION in English) to see if it will be there. The Config module will also let you interrogate values determined by the Configure program when Perl was installed.\n\nChoose mnemonic identifiers. If you can't remember what mnemonic means, you've got a problem.\n\nWhile short identifiers like $gotit are probably ok, use underscores to separate words in longer identifiers. It is generally easier to read $var_names_like_this than $VarNamesLikeThis, especially for non-native speakers of English. It's also a simple rule that works consistently with VAR_NAMES_LIKE_THIS.\n\nPackage names are sometimes an exception to this rule. Perl informally reserves lowercase module names for \"pragma\" modules like integer and strict. Other modules should begin with a capital letter and use mixed case, but probably without underscores due to limitations in primitive file systems' representations of module names as files that must fit into a few sparse bytes.\n\nIf you have a really hairy regular expression, use the /x modifier and put in some whitespace to make it look a little less like line noise. Don't use slash as a delimiter when your regexp has slashes or backslashes.\n\nAlways check the return codes of system calls. Good error messages should go to STDERR, include which program caused the problem, what the failed system call and arguments were, and (VERY IMPORTANT) should contain the standard system error message for what went wrong. Here's a simple but sufficient example −\n\nopendir(D, $dir) or die \"can't opendir $dir: $!\";\n\nThink about reusability. Why waste brainpower on a one-shot when you might want to do something like it again? Consider generalizing your code. Consider writing a module or object class. Consider making your code run cleanly with use strict and use warnings (or -w) in effect. Consider giving away your code. Consider changing your whole world view. Consider... oh, never mind.\n\nBe consistent.\n\nBe nice.\n\nPerl - Regular Expressions\n\nA regular expression is a string of characters that defines the pattern or patterns you are viewing. The syntax of regular expressions in Perl is very similar to what you will find within other regular expression.supporting programs, such as sed, grep, and awk.\n\nThe basic method for applying a regular expression is to use the pattern binding operators =~ and !~. The first operator is a test and assignment operator.\n\nThere are three regular expression operators within Perl.\n\nMatch Regular Expression - m//\n\nSubstitute Regular Expression - s///\n\nTransliterate Regular Expression - tr///\n\nThe forward slashes in each case act as delimiters for the regular expression (regex) that you are specifying. If you are comfortable with any other delimiter, then you can use in place of forward slash.\n\nThe Match Operator\n\nThe match operator, m//, is used to match a string or statement to a regular expression. For example, to match the character sequence \"foo\" against the scalar $bar, you might use a statement like this −\n\n#!/usr/bin/perl $bar = \"This is foo and again foo\"; if ($bar =~ /foo/) { print \"First time is matching\\n\"; } else { print \"First time is not matching\\n\"; } $bar = \"foo\"; if ($bar =~ /foo/) { print \"Second time is matching\\n\"; } else { print \"Second time is not matching\\n\"; }\n\nWhen above program is executed, it produces the following result −\n\nFirst time is matching Second time is matching\n\nThe m// actually works in the same fashion as the q// operator series.you can use any combination of naturally matching characters to act as delimiters for the expression. For example, m{}, m(), and m>< are all valid. So above example can be re-written as follows −\n\n#!/usr/bin/perl $bar = \"This is foo and again foo\"; if ($bar =~ m[foo]) { print \"First time is matching\\n\"; } else { print \"First time is not matching\\n\"; } $bar = \"foo\"; if ($bar =~ m{foo}) { print \"Second time is matching\\n\"; } else { print \"Second time is not matching\\n\"; }\n\nYou can omit m from m// if the delimiters are forward slashes, but for all other delimiters you must use the m prefix.\n\nNote that the entire match expression, that is the expression on the left of =~ or !~ and the match operator, returns true (in a scalar context) if the expression matches. Therefore the statement −\n\n$true = ($foo =~ m/foo/);\n\nwill set $true to 1 if $foo matches the regex, or 0 if the match fails. In a list context, the match returns the contents of any grouped expressions. For example, when extracting the hours, minutes, and seconds from a time string, we can use −\n\nmy ($hours, $minutes, $seconds) = ($time =~ m/(\\d+):(\\d+):(\\d+)/);\n\nMatch Operator Modifiers\n\nThe match operator supports its own set of modifiers. The /g modifier allows for global matching. The"
    }
}