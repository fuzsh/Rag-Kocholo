{
    "id": "dbpedia_8293_3",
    "rank": 20,
    "data": {
        "url": "https://leanpub.com/perl2python/read",
        "read_more_link": "",
        "language": "en",
        "title": "Read Move Seamlessly between PERL and Python",
        "top_image": "https://leanpub.com/assets/favicons/favicon-16x16-19545df363d1089bccdc59d17ee5b781.png",
        "meta_img": "https://leanpub.com/assets/favicons/favicon-16x16-19545df363d1089bccdc59d17ee5b781.png",
        "images": [
            "https://d2sofvawe08yqg.cloudfront.net/perl2python/s_shelf?1620493085",
            "https://leanpub.com/assets/logos/logo-white-96-67-2x-cbf54f68046da93161c6375a4d74259d.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://leanpub.com/assets/favicons/apple-touch-icon-57x57-3dc48b9be1873ac9bf6d580e7836e3e5.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "The Shared History of PERL and Python\n\nThe year 1969 was pivotal in the history of computing. Later that year Ken Thompson and Dennis Ritchie released the first version of the UNIX operating system. The eventual births of the scripting languages like PERL and Python two decades later were related to that event.\n\nUNIX was the first operating system written almost entirely in a high-level language (C). Previously, operating systems were developed in machine-dependent assembly languages and therefore could not be ported to different types of computers. In contrast, the C-version of UNIX, released in 1973, could be ported easily to all kinds of computing hardware, and that made UNIX the most popular operating system. As a side effect, C also became the primary language for computing.\n\nThe concept of scripting originated from the UNIX world. Scripts were short informal programs, which did not need to be compiled unlike the C programs. Often they were used to search rapidly for patterns in the text files. UNIX developers not only included software tools like AWK to facilitate scripting, but also built another immensely helpful feature for approximate pattern search - regular expressions (regex). Ken Thompson initially added this capability to the UNIX editor âedâ. However, regexes turned out to be so useful that they eventually got adopted into many popular UNIX tools.\n\nPERL language was created (1987) by Larry Wall to bring the capabilities of various UNIX-related scripting tools in one place and also give the scripts C-like syntax. Right when the internet boom needed a language for efficient parsing of web documents (1994), PERL was ready with a matured release including regular expressions. For almost identical reasons, PERL became popular among the bioinformaticians in the 1990s and early 2000s.\n\nWhile PERL was created to give C-like structure to the UNIX scripts, Python was developed by Guido van Rossum (late 1980s) to have a simplify C and make it ready for scripting. Therefore, two languages attempted to accomplish almost the same objectives coming from two ends. Python took longer than PERL to mature, but its simpler syntax made it a favorite among the bioinformaticians since the mid-2000s. This created inconveniences for some of the earlier researchers trained in PERL, because they increasingly need to use Python to access shared public repositories or share codes with others.\n\nHere is the good news. Although, from a cursory look, the codes written in those two languages appear as different as English and Chinese, they are actually way closer than English and French. In fact, the two languages are as comparable as British and American English. By knowing how to convert a few major differences, a PERL programmer can easily translate codes to Python.\n\nThis book will make your transition easy by showing what those major differences are in the next chapter.\n\nLearning through Examples\n\nIn the previous chapter, you learned about the shared history of PERL and Python. Here you will see how similar the codes written in two languages are based on three examples. You will learn how to move easily from PERL to Python by making three simple changes in the code structure.\n\nExample 1 - Hello World\n\nThe most basic âhello worldâ program in PERL looks like -\n\n# This is a simple program\n\nprint âHello from Homolog.us\\nâ;\n\nYou can run it by typing -\n\n> perl hello.perl\n\nA similar code in Python looks like -\n\n# This is a simple program\n\nprint âHello from Homolog.usâ\n\nYou run it with -\n\n> Python hello.py\n\nExample 2 - Multiplication Table\n\nIn this example, we print the multiplication table of 10.\n\nPERL\n\nfor($i=0; $i<10; $i++)\n\n{\n\nÂ Â Â Â Â Â Â print â10 times, $i, â isâ, 10*$i,â\\nâ;\n\n}\n\nPython\n\nfor i in range(10):\n\nÂ Â Â Â Â Â Â print â10 times, i,â isâ, 10*i\n\nExample 3 - Prime Number\n\nIn this example, we check whether an integer is prime.\n\nPERL\n\n$num=59;\n\n$true=1;\n\nfor($i=2; $i < $num/2; $i++)\n\n{\n\nÂ Â Â Â Â Â Â Â if($num % $i ==0)\n\nÂ Â Â Â Â Â Â Â {\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â $true=0;\n\nÂ Â Â Â Â Â Â Â }\n\n}\n\nif($true==1)\n\n{\n\nÂ Â Â Â Â Â Â Â print $num, â is prime\\nâ;\n\n}\n\nelse\n\n{\n\nÂ Â Â Â Â Â Â Â print $num, â is not prime\\nâ;\n\n}\n\nPython\n\nnum=59\n\ntrue=1\n\nfor i in range(2,num/2):\n\nÂ Â Â Â Â Â Â Â if num % i ==0:\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â true=0\n\nif true==1:\n\nÂ Â Â Â Â Â Â Â print num, â is primeâ\n\nelse:\n\nÂ Â Â Â Â Â Â Â print num, â is not primeâ\n\nLet us go over the differences between the PERL and Python scripts one by one.\n\nYou can see that the Python programs do not include semicolons at the end of the lines. By removing all semicolons from the ends of Python statements, you can make them look almost like Python.\n\nThis change has an important ramification however. PERL programmers can pack multiple statements in the same line, but that is not possible in Python. Rather than a drawback, this is seen by Python programmers as a big plus. The inability to pack multiple statements in one line keeps Python programs clean and readable.\n\nUnlike PERL, Python code does not use curly brackets. This change also has an important ramification. Python uses indentation to identify blocks inside âforâ or âwhileâ loops. Therefore, Python is picky about the size of the indentation, which needs to be identical for all statements within the block.\n\nUnlike PERL, Python variables do not have characters â$â, â%â or â@â before their names.\n\nPython âprintâ statement automatically adds a newline, whereas PERL statements need â\\nâ to be added to be added explicitly.\n\nA Quick View of Pythonland\n\nNow that you know the main steps to convert PERL programs into Python, let us look at Python from a new programmersâ angle.\n\nPython core contains 32 keywords. Those words are special and cannot be used in as the names of variables. Also, Python comes with a set of commonly used functions. Those functions are shown below.\n\nPython Keywords are Special Words\n\nKeyword Action print prints text on screen and logical âandâ or logical âorâ not logical ânotâ True logical True False logical False is tests equality in checks if an element is in a list or dictionary del deletes an element from a list or dictionary if, else, elif conditional statement while conditinal loop for loop continue skips current execution of loop break quits the loop prematurely def defines new function return returns value at the end of function from, import imports functions from file\n\nSpecial words cannot be used as the names of variables.\n\nWrong code -\n\nfor = 1\n\nin = 2\n\nprint for + in\n\nHere is the Full List of Keywords\n\nprint\n\nand, or, not\n\nif, else, elif\n\nwhile, for, continue, break, in\n\ndef, return\n\nimport, from, as\n\nwith, as (file)\n\nin (list)\n\ndel (delete dictionary item, list item)\n\nexec (shell command)\n\nglobal, with, assert, pass, yield\n\nexcept, class, raise, finally\n\nis, lambda, try\n\nThe Same Keywords Listed Alphabetically\n\nand del from not while\n\nas elif global or with\n\nassert else if pass yield\n\nbreak except import print\n\nclass exec in raise\n\ncontinue finally is return\n\ndef for lambda try\n\nBuilt-in Functions in Python\n\nFunction - range()\n\nThe function range creates a list of integers.\n\nprint range(3)\n\nprint range(1,5)\n\nprint range(1,5,2)\n\nFunction - len()\n\nThis function gives the length of a list.\n\nx=range(9,2,-2)\n\nprint len(x)\n\nIn the following code, the variable i goes from 0 to 3, because len(a)=4.\n\na=[0,1,2,3]\n\nprint âloop using list indicesâ\n\nfor i in range(len(a)):\n\nÂ Â Â Â Â Â Â Â print i,âa[i]+8=â,a[i]+8\n\nFunction - float()\n\nThe function float converts an integer to a floating point number.\n\nx=1\n\ny=float(x)\n\nprint x,y\n\nFunction - int()\n\nThe function int gives the integer part of a floating point number.\n\nx=1.7\n\ny=int(x)\n\nprint x,y\n\nFunction - str()\n\nThe function str convers a number into a string.\n\nx=723\n\ny=str(x)\n\nprint y[0]\n\nAll Built-in Functions\n\nPython language includes 68 built-in functions.\n\nName Action help() Invoke the built-in help system. Number-related Â abs() Return the absolute value of a number. pow() Return power raised to a number. round() Return the rounded floating point value. divmod() Return a pair of numbers consisting of quotient and remainder when using integer division. Creates Objects Â ascii() Return a string containing a printable representation of an object, but escape the non-ASCII characters. bytearray() Return a new array of bytes. bytes() Return a new âbytesâ object. chr() Return the string representing a character. complex() Create a complex number or convert a string or number to a complex number. dict() Create a new dictionary. enumerate() Return an enumerate object. frozenset() Return a new frozenset object. hash() Return the hash value of the object. id() Return the âidentityâ of an object. iter() Return an iterator object. list() Return a list. memoryview() Return a âmemory viewâ object created from the given argument. object() Return a new featureless object. repr() Return a string containing a printable representation of an object. str() Return a str version of object. set() Return a new set object. slice() Return a slice object. tuple() Return a tuple type() Return the type of an object. Converts Â bin() Convert an integer number to a binary string. bool() Convert a value to a Boolean. float() Convert a string or a number to floating point. format() Convert a value to a âformattedâ representation. hex() Convert an integer number to a hexadecimal string. int() Convert a number or string to an integer. oct() Convert an integer number to an octal string. ord() Return an integer representing the Unicode. List operations Â len() Return the length (the number of items) of an object. min() Return the smallest item in an iterable. max() Return the largest item in an iterable. sorted() Return a new sorted list. sum() Sums the items of an iterable from left to right and returns the total. ** Iterables ** Â all() Return True if all elements of the iterable are true (or if the iterable is empty). any() Return True if any element of the iterable is true. If the iterable is empty, return False. callable() Return True if the object argument appears callable, False if not. map() Return an iterator that applies function to every item of iterable, yielding the results. filter() Construct an iterator from elements of iterable for which function returns true. zip() Make an iterator that aggregates elements from each of the iterables. range() Return an iterable sequence. next() Retrieve the next item from the iterator. reversed() Return a reverse iterator. I/O-related Â dir() Return the list of names in the current local scope. open() Open file and return a corresponding file object. print() Print objects to the stream. input() Reads a line from input, converts it to a string (stripping a trailing newline), and returns that. Runs Code Â compile() Compile the source into a code or AST object. eval() The argument is parsed and evaluated as a Python expression. exec() Dynamic execution of Python code. Other functions Â classmethod() Return a class method for the function. getattr() Return the value of the named attribute of an object. setattr() Assigns the value to the attribute. delattr() Deletes the named attribute of an object. hasattr() Return True if the name is one of the objectâs attributes. globals() Return a dictionary representing the current global symbol table. locals() Update and return a dictionary representing the current local symbol table. isinstance() Return True if the object argument is an instance. issubclass() Return True if class is a subclass. property() Return a property attribute. staticmethod() Return a static method for function. super() Return a proxy object that delegates method calls to a parent or sibling class. vars() Return the _dict_ attribute for a module, class, instance, or any other object. _import_() This function is invoked by the import statement.\n\nReferences\n\nhttps://gist.github.com/mindful108/6412490\n\nhttp://www.programiz.com/python-programming/keyword-list\n\nhttps://learnpythonthehardway.org/book/ex37.html\n\nNumbers and Variables\n\nApart from â$â, â%â and â@â symbols in front of the names, PERL and Python variables are named in the same way. Here are two equivalent PERL and Python programs -\n\n$x=10;\n\n$y=2*$x;\n\nprint â$y\\nâ;\n\n$y=$y+1;\n\nprint â$y\\nâ;\n\nx=10\n\ny=2*x\n\nprint y\n\ny=y+1\n\nprint y\n\nApart from the steps listed in the previous chapter, there are no differences between the two programs.\n\nWe also note that the mathematical operators are identical in PERL and Python. They are shown in the following table.\n\nOperator Action + Addition - Subtraction * Multiplication / Division % Remainder ** Power\n\nFrom Array to List\n\nPERL arrays are called lists in Python.\n\nHere is a PERL program demonstrating various aspects of arrays.\n\n@A=(10, 20, 30, 40, 3);\n\nprint $A[2],â\\nâ;\n\n$N=@A;\n\nprint â$N\\nâ;\n\n@A=();\n\n$N=@A;\n\nprint â$N\\nâ;\n\nprint $A[2],â\\nâ;\n\nThe equivalent code in Python looks like -\n\nA=[10,20,30,40,3]\n\nprint A[2]\n\nprint len(A)\n\nA=[]\n\nprint len(A)\n\nprint A[2]\n\nApart from the differences mentioned in chapter 2, here are the additional changes.\n\nLength of list in Python is obtained by using the âlenâ function.\n\nPERL is more forgiving than Python if the command seeks out-of-range elements of arrays/lists.\n\nPython Shortcuts on Lists\n\nHere we discuss a number of useful shortcuts related to lists in Python.\n\nThe â+â symbol concatenates two lists.\n\na=[1,3,2,0]\n\nb=[2,3,1,7]\n\nprint a+b\n\nYou can use â:â to get sublist.\n\na=[1,3,4,9,6,2,0]\n\nb=a[3:7]\n\nprint b\n\nThe following command gives a sublist from 3 to 7, skip 2.\n\na=[1,3,4,9,6,2,0]\n\nb=a[3:7:2]\n\nprint b\n\nThe following command reverses the list.\n\na=[1,3,4,9,6,2,0]\n\nb=a[::-1]\n\nprint b\n\nKeywords âinâ and âdelâ\n\nKeyword Action in checks if an element is in a list or dictionary del deletes an element from a list or dictionary\n\nKeyword âinâ\n\nThe keyword âinâ can be used to iterate over the keys or values. It checks wherher a number is in the list or not.\n\na=[3,4,9,1]\n\nprint 3 in a\n\nprint 100 in a\n\nKeyword - del\n\nThe keyword del is used to remove a list element at a known index.\n\nx=['a','b','c','d']\n\ndel x[2]\n\nprint x\n\nTry -\n\na=[1,3,4,9,6,2,0]\n\nprint a\n\ndel a[2]\n\nprint a\n\nFrom Associative Array to Dictionary\n\nAssociative arrays in PERL are called dictionaries in Python.\n\nHere is a PERL program using an associative array.\n\n%A = (âjohnâ, 39, âmarkâ, 170);\n\nprint $A{âjohnâ},â\\nâ;\n\nprint %A,â\\nâ;\n\nIts equivalent Python code is shown below.\n\nA = {âjohnâ: 12, âmarkâ: 170}\n\nprint A['john']\n\nprint A\n\nIterating over keys and values\n\nKeyword Action in checks if an element is in a list or dictionary del deletes an element from a list or dictionary\n\nKeyword âinâ\n\nThe keyword âinâ can be used to iterate over the keys or values.\n\nage={}\n\nage['john']=12\n\nage['paul']=77\n\nprint 12 in age\n\nprint âjohnâ in age\n\nKeyword - del\n\nThe keyword del can be used to delete a member of a dictionary.\n\nage={}\n\nage['john']=12\n\nage['paul']=77\n\nprint age\n\ndel age['john']\n\nprint age\n\nLoops and Conditions\n\nâwhileâ loop\n\nLet us demonstrate the âwhileâ loop by writing the multiplication table for 9 in both PERL and Python.\n\nThe PERL code -\n\n$i=1;\n\nwhile($i<=10)\n\n{\n\nÂ Â Â Â Â Â Â print 9*$i, â\\nâ;\n\nÂ Â Â Â Â Â Â $i++;\n\n}\n\nÂ\n\nPython code -\n\ni=1\n\nwhile(i<=10):\n\nÂ Â Â Â Â Â Â print 9*i\n\nÂ Â Â Â Â Â Â i=i+1\n\nApart from the differences mentioned in chapter 2, two codes are identical.\n\nâif-elseâ\n\nPERL code -\n\n$i=15;\n\nif($i>10) {\n\nÂ Â Â Â Â Â Â print â$i greater than 10\\nâ;\n\n}\n\nelse {\n\nÂ Â Â Â Â Â Â print â$i less than 10\\nâ;\n\n}\n\nPython code -\n\ni=15\n\nif(i>10):\n\nÂ Â Â Â Â Â Â print â$i greater than 10\\nâ;\n\nelse:\n\nÂ Â Â Â Â Â Â print â$i less than 10\\nâ;\n\nâforâ Loops\n\nKeyword Action for loop continue skips over the remaining lines and repeats break quits the loop\n\nPERL code -\n\nfor($i=1; $i<11; $i++)\n\n{\n\nÂ Â Â Â print â5 timesâ, $i, âisâ, 5*$i, â\\nâ;\n\n}\n\nprint âcompleted for loopâ\n\nPython code -\n\nfor i in range(1,11):\n\nÂ Â Â Â Â Â print â5 timesâ, i, âisâ, 5*i\n\nprint âcompleted for loopâ\n\nUsing âforâ over a Dictionary\n\nage={}\n\nage['john']=12\n\nage['paul']=77\n\nfor key in age:\n\nÂ Â Â Â Â Â Â Â print key\n\nÂ Â Â Â Â Â Â Â print age[key]+7\n\nWhen âforâ is written on a dictionary, the loop variable takes the values of\n\nthe keys of the dictionary.\n\nKeywords âbreakâ and âcontinueâ\n\nâWhileâ loops become even more powerful, when they are customized using an\n\ninternal condition (âifâ). The keywords âbreakâ and âcontinueâ come handy in that situation.\n\ni=0\n\nwhile True:\n\nÂ Â Â Â i=i+1\n\nÂ Â Â Â if i==4:\n\nÂ Â Â Â Â Â Â Â break\n\nÂ Â Â Â print â5 timesâ, i, âisâ, 5*i\n\nIn the above code, the condition for âwhileâ is always True. Therefore, it is expected to run infinite times. That does not happen, because the loop is terminated using âbreakâ, when i reaches 4.\n\ni=0\n\nwhile i<10:\n\nÂ Â Â Â i=i+1\n\nÂ Â Â Â if i==4:\n\nÂ Â Â Â Â Â Â Â continue\n\nÂ Â Â Â print â5 timesâ, i, âisâ, 5*i\n\nThe keyword âcontinueâ skips over the remaining lines of the âwhileâ block and starts the following run of the âwhileâ loop.\n\nFrom Subroutines to Functions\n\nPERL subroutines are called functions in Python.\n\nHere is a PERL code to show a simple subroutine -\n\nsub name {\n\nÂ Â Â Â Â Â Â Â my($name)=@_;\n\nÂ Â Â Â Â Â Â Â print âMy name is $name\\nâ;\n\n}\n\nname(âAliceâ);\n\nname(âJohnâ);\n\nThe equivalent Python code is shown below -\n\ndef name(str):\n\nÂ Â Â Â Â print âMy name isâ, str\n\nÂ Â Â Â Â return\n\nname(âAliceâ)\n\nname(âJohnâ)\n\nDifferences -\n\nparameter passing\n\nreturn at the end\n\nKeyword Action def Defines new function return Returns value at the end of function from Gives name of an external file import Brings in functions from an external file\n\nYou have been using many Pythons functions, such as range(), sort(), etc., to improve your\n\ncode. Internally, a function is block of code with a given name. When you use\n\na function (e.g. range(4)) within your code, Python executes the corresponding\n\nblock of code and returns the result. That way your code stays small and readable.\n\nApart from the in-built functions Python provides you with, you can also create your\n\nown functions. Here is an example.\n\ndef square(x):\n\nÂ return x*x\n\nprint square(2)\n\nprint square(3)\n\nThe keyword âdefâ gives name to a function, and the variables within the\n\nparenthesis are its parameter. The block of indented code following def represents the\n\ncode of the function, and the âreturnâ statement gives its return value to be used\n\nby the main program.\n\nHere, you created a function named âsquareâ that takes only one parameter x. Internally, this\n\nfunction computes x*x and returns the result. Whenever you use square()\n\nin your main code, Python runs the block of code from its definition to get a result.\n\nCode Flow with Functions\n\nWe need to also make clear that your main code consists of all lines after excluding the def\n\nblocks. The standard linear flow of execution from top to bottom does not hold for the\n\nfunctions. Let us illustrate the point with two codes.\n\ni=2\n\nj=3\n\ndef square(x):\n\nÂ print âinsideâ,i,j\n\nÂ return x*x\n\nprint square(i)\n\nprint square(j)\n\ndef square(x):\n\nÂ print âinsideâ,i,j\n\nÂ return x*x\n\ni=2\n\nj=3\n\nprint square(i)\n\nprint square(j)\n\nYou will see that both produce the same output. You may find that odd, because i and j are not defined\n\nbefore the function in the second case. How does the function know their values?\n\nThey work identically in both cases, because Python isolates the def block and keeps it separately.\n\nThen it takes the remaining lines and executes the code from top to bottom. Hence, i and j\n\nare already defined by the time the function square is called.\n\nDefault Parameter\n\ndef square(x=1):\n\nÂ return x*x\n\nprint square()\n\nprint square(2)\n\nprint square(3)\n\nThe above code gives default value of 1 to the parameter x. When the function square() is\n\ncalled without any number, Python uses the default value to print 1*1.\n\nImporting Functions from a File\n\nYou learned in the previous section that Python separates out the function definitions,\n\nwhile executing the code. To keep the code readable, programmers often prefer to write the function\n\ndefinitions is a file separate from the main program. How does one run such multi-program code?\n\nWe will learn that here by creating two files - ânames.pyâ for functions and âcode.pyâ for the\n\nmain code. You cannot do this in the sandbox.\n\nIn file names.py, type -\n\ndef square(x=1):\n\nÂ Â Â Â Â Â Â Â return x*X\n\ndef cube(x=1):\n\nÂ return xxx\n\nIn code.py -\n\n#from names import square\n\nfrom names import *\n\nprint square(2)\n\nprint cube(2)\n\nprint cube(10)/square(10)\n\nBoth files need to be in the same directory. When you run code.py, it will automatically\n\nincorporate the functions âsquareâ and âcubeâ from names.py.\n\nStrings\n\nIn the followin PERL code, â$xâ is a string -\n\n$x=âMy name is Aliceâ;\n\nprint $x,â\\nâ;\n\nThe equivalent Python code is shown below -\n\nx=âMy name is Aliceâ\n\nprint x\n\nSubstring\n\nThe following program prints ânameâ.\n\n$x=âMy name is Aliceâ;\n\n$y=substr($x,3,4);\n\nprint $y,â\\nâ;\n\nThe equivalent Python code is shown below -\n\nx=âMy name is Aliceâ\n\ny=x[3:7]\n\nprint y\n\nString-related Function\n\nhttps://docs.python.org/2/library/string.html\n\nPython String is a List\n\nInternally, Python represents each string as an immutable list. Therefore, many list-related commands and functions can be used for strings. Here is an example.\n\nline=âWelcome to the classâ\n\nprint line[10]\n\nprint line[1:9]\n\nprint line[::-1]\n\nThe first print command prints a single character from the list âlineâ, the second\n\ncommand prints a substring, and the third one reverses the string.\n\nString-related functions\n\nFunctions - upper(), lower()\n\nline=âA to Zâ\n\nprint line.upper()\n\nprint line.lower()\n\nFunction - strip()\n\nline=f.readline()\n\nl=line.strip()\n\nprint line\n\nprint l\n\nFunction - find()\n\nmystring=âATGCAAATGCATâ\n\nprint mystring.find(âAAAâ)\n\nFunction - replace()\n\nmystring=âATGCAAATGCATâ\n\nnew=mystring.replace(âAâ,âTâ)\n\nprint new\n\nThe function replace() replaces a substring with a different string.\n\nYou can use it to replace or remove letters. For example, the following\n\ncode removes all commas from a line.\n\nmystring=âJohn, Jane, Jill, Juan, Jediâ\n\nnew = mystring.replace(â,â,ââ)\n\nprint new\n\nFunction - split()\n\nline=âA big fat henâ\n\nx=line.split()\n\nfor w in x:\n\nÂ Â Â print w\n\nFunction - join()\n\nx=[\"ATGC\", \"TGGG\", \"TAAA\"]\n\ny=âATGCTGGGTAAAâ\n\nz= ââ.join(x)\n\nif(z==y):\n\nÂ Â Â Â Â Â Â Â print âYESâ\n\nRegular Expressions\n\nRegular expressions in PERL -\n\n$line= âATGAAATGTGGTGGGâ\n\nif($line=/^ATG(\\S\\S\\S).*(\\S)G$/) { print \"match.group(1): $1\\n\"; print \"match.group(2): $2\\n\"; } ~~~\n\nRegular expressions in Python -\n\nimport re\n\nline = âATGAAATGTGGTGGGâ\n\nmatch = re.match( râ^ATG(SSS).*(S)G$â, line)\n\nif match:\n\nÂ Â Â print âmatch.group(1) : â, match.group(1)\n\nÂ Â Â print âmatch.group(2) : â, match.group(2)\n\nRegular expression is a special sublanguage to make searches through strings easy. Python has a special library (âreâ) to facilitate the use of regular expressions.\n\nSearch\n\nimport re\n\nS=re.search(â[a-z]a[a-z]â, âa fat cat satâ)\n\nif S:\n\nÂ Â print âyesâ\n\nelse:\n\nÂ Â print ânoâ\n\nThe above code searches for three letter patterns within the sentence, where\n\nthe first and third letter can be âa-zâ, but the middle letter is âaâ.\n\nimport re\n\nstr = âI am flying from Seatttle to San Franciscoâ\n\nmatch = re.search(râ[SF]â, str)\n\nif match:\n\nÂ Â Â print âfound S/Fâ, match.group()\n\nelse:\n\nÂ Â Â Â print âdid not find S/Fâ\n\nSearch and Replace\n\nimport re\n\nseq=âATTCGATCTâ\n\ns= re.sub(âAâ, ââ, seq)\n\ndiff=len(seq)-len(s)\n\nprint âcount of A =â, diff\n\nThe sub command replaces âSeattleâ with âLondonâ in the following example.\n\nimport re\n\nstr = âI am flying from Seattle to San Franciscoâ\n\nx = re.sub(râSeattleâ, âLondonâ, str)\n\nprint x\n\nReferences\n\nFor description of regular expression sublanguage, check here -\n\nhttps://regexr.com/\n\nhttps://regex101.com/\n\nhttps://developers.google.com/edu/python/regular-expressions?hl=en\n\nReading and Writing Files\n\nReading from a file\n\nIn PERL, files are read as -\n\nopen(IN,âfilenameâ);\n\n$=<IN>;\n\nwhile(<IN>)\n\n{\n\nÂ print $,â\\nâ;\n\n}\n\nclose(IN);\n\nAbove command first reads one line in the statement â$_=<IN>â. Then it continually reads sentences and prints\n\non the screen.\n\nThe equivalent command in Python is -\n\nf = open(âfilenameâ, ârâ)\n\nline = f.readline()\n\nfor line in f:\n\nÂ Â Â Â print line\n\nf.close()\n\nprint line\n\nReading the entire file in an array\n\nopen(IN,âfilenameâ);\n\n@array=<IN>;\n\nf = open(âfilenameâ, ârâ)\n\nlines = f.readlines()\n\nWriting a string into a file\n\nPERL\n\nopen(OUT,â>myfileâ);\n\nprint OUT âMy name is john\\nâ;\n\nclose(OUT);\n\nPython\n\nf = open(âmyfileâ, âwâ)\n\nf.write(âhi, my name is john\\nâ)\n\nFile read/write symbols in PERL and Python\n\nfile request PERL Python open for reading open(F,âmyfileâ); f = open(âmyfileâ, ârâ) open for writing open(F,â>myfileâ); f = open(âmyfileâ, âwâ) open for appending open(F,â>>myfileâ); f = open(âmyfileâ, âaâ) open for read/write Â f = open(âmyfileâ, âr+â)\n\nModules and Packages\n\nA module in PERL is a collection of functions. A package is much larger.\n\nIn Python, a package\n\nhttp://stackoverflow.com/questions/3733969/old-pl-modules-versus-new-pm-modules\n\nPERL modules look like -\n\nuse Useful;\n\nopen(IN,âgeneâ);\n\n$_=<IN>;\n\n$x=Useful::translate($_);\n\nprint $x,â\\nâ;\n\nPython modules look like -\n\nimport Useful\n\nSplitting Code into Multiple Files\n\nKeyword Action import Brings in code from an external file\n\nWe will separate our code into two files and see how they run.\n\nYou cannot do this in the sandbox.\n\nIn file other.py, type -\n\nprint âcode in other fileâ\n\nIn main.py -\n\nimport other\n\nprint âcode in main fileâ\n\nBoth files need to be in the same directory. When you run main.py, it will automatically\n\ninclude the code from âother.pyâ and run it.\n\nprint âcode in main fileâ\n\nimport other\n\nImport from external file happens only once.\n\nThe main purpose of import is to separate function definitions in a separate file.\n\nFrom CPAN to PyPI\n\nInstalling perl modules from CPAN (http://www.cpan.org/) -\n\n> cpan App::cpanminus\n\ncpanm Module::Name\n\nPython Package Index\n\nhttps://pypi.python.org/pypi\n\nOne step installation process -\n\ngit install pip\n\npip install package\n\nWhere do they go in the unix directory structure?\n\nPython command line\n\nNumpy\n\nJupyter Notebook\n\nInline -\n\nhttp://search.cpan.org/dist/Inline-Python/Python.pod\n\nClass, Iterator, etc.\n\nObject oriented programming.\n\nWe do not want you to create classes. Just understand them so that you can\n\nuse them from the available libraries.\n\nCode -\n\nclass complex_number:\n\ndef init(self, re, im):\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â self.re = re\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â self.im = im\n\nz=complex_number(2,5)\n\nprint z.re, z.im\n\nclass complex_number:\n\ndef init(self, re, im):\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â self.re = re\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â self.im = im\n\nÂ Â Â Â Â Â Â Â def absquare(self):\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â return self.reself.re + self.imself.im\n\nz=complex_number(2,5)\n\nprint z.re, z.im, z.absquare()\n\nExample - integer_list, dna_seq\n\nPurpose of class is to make sure data conforms to standard.\n\nIterables, Iterators, Generators\n\nVery powerful concepts.\n\nCollection.\n\nMap, lambda.\n\nhttp://nvie.com/posts/iterators-vs-generators/\n\nAll codes here.\n\na=iter(range(5))\n\nprint a.next()\n\nprint a.next()\n\nprint a.next()\n\nprint a.next()\n\nprint a.next()\n\nhttp://nvie.com/posts/iterators-vs-generators/\n\n>>> from itertools import cycle\n\n>>> colors = cycle(['red', 'white', 'blue'])\n\n>>> next(colors) âredâ\n\n>>> next(colors) âwhiteâ\n\n>>> next(colors) âblueâ\n\n>>> next(colors) âredâ\n\nProtocols -\n\nhttp://anandology.com/python-practice-book/iterators.html\n\nhttp://www.dabeaz.com/generators-uk/\n\nhttps://stackoverflow.com/questions/9884132/what-exactly-are-pythons-iterator-iterable-and-iteration-protocols\n\nhttps://stackoverflow.com/questions/32799980/what-exactly-does-iterable-mean-in-python\n\n** make sure example is changed **\n\nhttps://docs.python.org/2/tutorial/classes.html\n\nhttp://www.diveintopython3.net/iterators.html\n\nhttp://nvie.com/posts/iterators-vs-generators/\n\nThe following code is from online.\n\nclass Fib:\n\nÂ Â Â Â â'âiterator that yields numbers in the Fibonacci sequenceâââ\n\ndef init(self, max):\n\nÂ Â Â Â Â Â Â Â self.max = max\n\nÂ Â Â Â def iter(self):\n\nÂ Â Â Â Â Â Â Â self.a = 0\n\nÂ Â Â Â Â Â Â Â self.b = 1\n\nÂ Â Â Â Â Â Â Â return self\n\nÂ Â Â Â def next(self):\n\nÂ Â Â Â Â Â Â Â fib = self.a\n\nÂ Â Â Â Â Â Â Â if fib > self.max:\n\nÂ Â Â Â Â Â Â Â Â Â Â Â raise StopIteration\n\nÂ Â Â Â Â Â Â Â self.a, self.b = self.b, self.a + self.b\n\nÂ Â Â Â Â Â Â Â return fib\n\nx=Fib(10)\n\nprint x\n\nFrom BioPERL to Biopython\n\nBiopython is good for -\n\nQuick analysis of nucleotide and protein sequence. You can easily extract\n\na segment from a longer sequence, get reverse complement, do nucleotide\n\nto protein translation.\n\nParsing of all kinds of files, including simple FASTA files,\n\nBLAST output, MUSCLE output, PDB files, and so on.\n\nSubmitting requests to online databases and fetchin data from them. For example,\n\nyou can programmatically run BLAST at NCBI, instead of manually filling up the\n\nform.\n\nStatistical and bioinformatics analysis - clustering, motifs, phylogeny, etc.\n\nAnalyzing Nucleotide and Protein Sequences\n\nBiopython has many functions to perform routine analysis\n\nof nucleotide and protein sequences. The sequences themselves\n\nare saved in the Bio.Seq class.\n\nExtracting Subsequences\n\nfrom Bio.Seq import Seq\n\nread = Seq(âGATCGTAGATAGTGCGCGCGTAGAGGAGAGATAGAGAGAGGAGATAGAGATAâ)\n\nprint read[10:20]\n\nYou will see âAGTGCGCGCGâ being printed.\n\nHere read is a Bio.Seq object that can be used to store nucleotide\n\nand protein sequences. A\n\nsubsequence of Bio.Seq object can be obtained in the same\n\nway we get substrings. Its coordinate system starts from 0.\n\nReverse Complement\n\nfrom Bio.Seq import Seq\n\nread = Seq(âGATCGTAGATAGTGCGCGCGTAGAGGAGAGATAGAGAGAGGAGATAGAGATAâ)\n\nprint read.reverse_complement()\n\nThe function âreverse_complementâ is included in Bio.Seq class. You\n\nwill see the output âTATCTCTATCTCCTCTCTCTATCTCTCCTCTACGCGCGCACTATCTACGATCâ.\n\nTranslate into Proteins\n\nfrom Bio.Seq import Seq\n\nread = Seq(âGATCGTAGATAGTGCGCGCGTAGAGGAGAGATAGAGAGAGGAGATAGAGATAâ)\n\nprint read.translate()\n\n/usr/local/lib/python2.7/dist-packages/Bio/Seq.py:2095: BiopythonWarning: Partial codon, len(sequence) not a multiple of three. Explicitly trim the sequence or add trailing N before translation. This may become an error in future.\n\nÂ Â BiopythonWarning)\n\nDRR*CARRGEIERGDRD\n\nIf you trim the last nucleotide, the error will go away.\n\nCompute GC Content\n\nfrom Bio.SeqUtils import GC\n\nfrom Bio.Seq import Seq\n\nread = Seq(âGATCGTAGATAGTGCGCGCGTAGAGGAGAGATAGAGAGAGGAGATAGAGATAâ)\n\nprint GC(read)\n\nOutput - 48.0769230769\n\nYou can experiment by changing the sequence to\n\nall As or all Gs to see whether the GC function works correctly.\n\nParsing Biological Records\n\nParsing text files of different formats is a tedious task in\n\nbioinformatics. Biopython makes this process\n\nvery easy. It can load data stored in many different file formats.\n\nFunctions - âreadâ and âparseâ\n\nBiopython maintains uniform syntax for loading data from a file. Each\n\nof its class parsing text files has two functions - âreadâ and âparseâ.\n\nTypically, biological data files have multiple records of the\n\nsame type. For example, a FASTA file contains several different\n\nsequences. A BLAST output file contains search results\n\nfor several different input sequence. The function âreadâ loads only the first\n\nrecord from a large file, whereas the function âparseâ creates an iterator\n\nto go over all records. Examples for the functions are shown below.\n\nReading FASTA File\n\nThe function âreadâ fetches only the first record from a FASTA file.\n\nfrom Bio import SeqIO\n\nrecord=SeqIO.read(âseq.fastaâ, âfastaâ)\n\nprint record.id, record.seq\n\nThe function âparseâ creates an iterator to go over all records in\n\na FASTA file. You can either loop over the records, or use next()\n\nfunction to fetch one record at a time.\n\nfrom Bio import SeqIO\n\nrecords=SeqIO.parse(âseq.fastaâ, âfastaâ)\n\nfor record in records:\n\nÂ Â Â Â Â Â Â Â print record.id, record.seq\n\nor\n\nfrom Bio import SeqIO\n\nrecords=SeqIO.parse(âseq.fastaâ, âfastaâ)\n\nrecord = next(records)\n\nprint record.id\n\nprint record.seq\n\nprint len(record)\n\nrecord = next(records)\n\nprint record.id\n\nprint record.seq\n\nprint len(record)\n\nKEGG Example\n\nhttp://www.genome.jp/dbget-bin/www_bget?ec:5.1.1.1\n\nThe function âreadâ fetches only one record.\n\nfrom Bio.KEGG import Enzyme\n\nrecord = Enzyme.read(open(âec_5.1.1.1.txtâ))\n\nThe function âparseâ creates an iterator to go over all records.\n\nfrom Bio.KEGG import Enzyme\n\nrecords = Enzyme.parse(open(âec_5.1.1.1.txtâ))\n\nrecord=next(records)\n\nâ¦\n\nâ¦\n\nrecord=next(records)\n\nCommands for Different Types of Data\n\nSimilar âparseâ and âreadâ functions can be used to process many different\n\ntypes of data files. In the following table, we list only one of the\n\ntwo functions. The other one is also valid.\n\nData Type Biopython Library FASTA from Bio import SeqIO<br>records=SeqIO.parse(âseq.fastaâ, âfastaâ) Genbank from Bio import SeqIO<br>records = SeqIO.parse(âdat.gbkâ, âgenbankâ) BLAST from Bio.Blast import NCBIXML<br>records = NCBIXML.parse(open(âblast_out.xmlâ)) CLUSTAL from Bio import AlignIO<br>align = AlignIO.read(âalignment.alnâ, âclustalâ) MUSCLE from Bio import AlignIO<br>align = AlignIO.read(âalignment.faaâ, âfastaâ) Phylogeny from Bio import Phylo<br>tree = Phylo.read(âtree.dndâ, ânewickâ) Entrez from Bio import Entrez<br>records = Entrez.parse(open(âHomo_sapiens.xmlâ)) UniGene from Bio import UniGene<br>record = UniGene.read(open(âgene.dataâ)) GEO from Bio import Geo<br>records = Geo.parse(open(âGSE273.txtâ)) Medline from Bio import Medline<br>records=Medline.parse(open(âpubmed_file.txtâ)) Pubmed Â SwissProt Keywords from Bio.SwissProt import KeyWList<br>records = KeyWList.parse(open(âkeywlist.txtâ)) Prosite from Bio.ExPASy import Prosite<br>records = Prosite.parse(open(âprosite.datâ)) Prosite Doc from Bio.ExPASy import Prodoc<br>records = Prodoc.parse(open(âprosite.docâ)) EXPASy from Bio.ExPASy import Enzyme<br>records = Enzyme.parse(open(âenzyme.datâ)) PDB PDBParser from Bio.PDB.PDBParser import PDBParser PDB MMCIF2Dict from Bio.PDB.MMCIF2Dict import MMCIF2Dict PDB MMCIFParser from Bio.PDB.MMCIFParser import MMCIFParser PDB MMTFParser from Bio.PDB.mmtf import MMTFParser KEGG from Bio.KEGG import Enzyme<br>records = Enzyme.parse(open(âec_5.1.1.1.txtâ))\n\nAlthough âparseâ and âreadâ functions are used to parse different types\n\nof data files, the records created by them are not identical. SeqIO.parse produces âSeqIOâ type of records, whereas âMedline.parseâ produces âMedlineâ type of records. We\n\nwill see more details about those records in the following section.\n\nObjects to Store Different Types of Data\n\nIn the last section, we learned about âreadâ and âparseâ\n\nfunctions to read files in different formats. The output\n\nfrom those calls create different kinds of records, as\n\nappropriate for the situation. Let us see a few examples. Some\n\nof those fields themselves can be iterators.\n\nFASTA Record\n\nBio.SeqIO with fasta\n\nid â>\n\nseq â>\n\nBLAST Record\n\nBio.Blast.NCBIXML object\n\nfrom Bio.Blast import NCBIXML\n\nrecords = NCBIXML.parse(open(âblast_output.xmlâ))\n\nE_VALUE_THRESH = 0.00001\n\nfor record in records:\n\nÂ for alignment in record.alignments:\n\nÂ Â Â for hsp in alignment.hsps:\n\nÂ Â Â Â Â if hsp.expect < E_VALUE_THRESH:\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(âNext Alignmentâ)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(âseq:â, alignment.title)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(âL:â, alignment.length)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(âe value:â, hsp.expect)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(hsp.query[0:75] + ââ¦â)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(hsp.match[0:75] + ââ¦â)\n\nÂ Â Â Â Â Â Â Â Â Â Â Â Â print(hsp.sbjct[0:75] + ââ¦â)\n\nMore examples are shown in the Example section.\n\nAccessing Data from the Internet\n\nOne attractive feature of Biopython is that it can fetch different\n\nkinds of data from the internet. For example, in case of BLAST, it\n\ncan submit BLAST request to the NCBI, and then get back the output for you.\n\nBLAST\n\nfrom Bio.Blast import NCBIWWW\n\nfrom Bio import SeqIO\n\nrecord = SeqIO.read(âm_cold.fastaâ, format=âfastaâ)\n\nresult_handle = NCBIWWW.qblast(âblastnâ, ântâ, record.seq)\n\nsave_file = open(âmy_blast.xmlâ, âwâ)\n\nsave_file.write(result_handle.read())\n\nsave_file.close()\n\nresult_handle.close()\n\nKEGG\n\nhttp://www.genome.jp/dbget-bin/www_bget?ec:5.1.1.1\n\nfrom Bio.KEGG import REST\n\nfrom Bio.KEGG import Enzyme\n\nreq = REST.kegg_get(âec:5.1.1.1â)\n\nopen(âec_5.1.1.1.txtâ, âwâ).write(req.read())\n\nEntrez\n\nfrom Bio import Entrez\n\nEntrez.email = âA.N.Other@example.comâ # Always tell NCBI who you are\n\nhandle = Entrez.efetch(db=ânucleotideâ, id=â186972394â, rettype=âgbâ, retmode=âtextâ)\n\nprint handle.read()\n\nReferences\n\nhttps://coding4medicine.com/Materials/biopython/index.html\n\nhttp://biopython.org/DIST/docs/tutorial/Tutorial.html\n\nhttp://people.duke.edu/~ccc14/pcfb/biopython/BiopythonBasics.html\n\nhttps://www.coursera.org/learn/python-genomics/lecture/ahlsr/lecture-8-biopython-13-32\n\nhttps://www.gitbook.com/book/krother/biopython-tutorial/details\n\nPERL was known as the âduct tape that held the internetâ.\n\nWho killed PERL? We note that scripting languages go out of fashion not because they are bad, but they are successful in solving the problem at hand. That allows the rise of technologies solving the higher level of problems, and people working on new technology like to create their own tools to start out fresh.\n\nhttps://www.linuxjournal.com/article/3394\n\nhttps://www.fastcompany.com/3026446/the-fall-of-perl-the-webs-most-promising-language\n\nPERL6 than never came and Python3 that never got adopted\n\nPERL5 came out on October 17, 1994. That was the same year Netscape web browser was published and\n\ninternet was officially born.\n\nhttps://thenewstack.io/larry-walls-quest-100-year-programming-language/"
    }
}