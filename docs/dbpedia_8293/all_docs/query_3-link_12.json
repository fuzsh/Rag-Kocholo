{
    "id": "dbpedia_8293_3",
    "rank": 12,
    "data": {
        "url": "https://www.cio.com/article/274154/developer-you-used-perl-to-write-what.html",
        "read_more_link": "",
        "language": "en",
        "title": "You Used Perl to Write WHAT?!",
        "top_image": "https://www.cio.com/wp-content/uploads/2023/02/cropped-CIO-favicon-2023.png?w=32",
        "meta_img": "https://www.cio.com/wp-content/uploads/2023/02/cropped-CIO-favicon-2023.png?w=32",
        "images": [
            "https://www.cio.com/wp-content/uploads/2024/08/3487551-0-42783400-1723817103-iStock-1014150608.jpg?quality=50&strip=all&w=375",
            "https://www.cio.com/wp-content/uploads/2024/08/479905-0-01412000-1723831032-shutterstock_1471191233.jpg?quality=50&strip=all&w=375",
            "https://www.cio.com/wp-content/uploads/2024/08/3486667-0-19836900-1723802462-shutterstock_1801533685-100959195-orig.jpg?quality=50&strip=all&w=375",
            "https://www.cio.com/wp-content/uploads/2024/08/0-56849800-1723679335-andrew-title-16x9-1.jpg?quality=50&strip=all&w=444",
            "https://www.cio.com/wp-content/uploads/2024/08/0-87580900-1723160777-CIO-ALAN-SHARVIN-16x9-2.jpg?quality=50&strip=all&w=444",
            "https://www.cio.com/wp-content/uploads/2024/08/0-97832200-1723019746-CIOLL-India-thumb_Irshad-Saifi.jpg?quality=50&strip=all&w=444",
            "https://www.cio.com/wp-content/uploads/2024/08/3487265-0-24098800-1723754692-cw-thumb-ai-gold-rush-gustavo.jpg?quality=50&strip=all&w=320",
            "https://www.cio.com/wp-content/uploads/2024/08/3484318-0-17601400-1723752635-Screenshot-2024-08-15-155953.png?w=444",
            "https://www.cio.com/wp-content/uploads/2024/08/3486953-0-14478100-1723679508-andrew-title-16x9-1.jpg?quality=50&strip=all&w=444"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "James Turner"
        ],
        "publish_date": "2008-01-24T07:00:00-08:00",
        "summary": "",
        "meta_description": "Every programming language has its strengths...and its weaknesses. We identify five tasks for which perl is ideally suited, and four that...well, really, shouldn't you choose something else?",
        "meta_lang": "en",
        "meta_favicon": "https://www.cio.com/wp-content/themes/cio-b2b-child-theme/src/static/img/favicon.ico",
        "meta_site_name": "CIO",
        "canonical_link": "https://www.cio.com/article/274154/developer-you-used-perl-to-write-what.html",
        "text": "Pattern matching: Perl’s greatest claim to fame has always been the tight integration of regular expressions into the base language syntax. For most developers, perl was the first time they ever used a regular expression.\n\nAs a result, perl has always been the go-to language for any task that involves pattern-matching input. A typical use of this capability is to scan an input stream for name/value pairs and split them. Another is parsing log files with a fixed but variable length format. It’s not for nothing that a lot of the popular log file auditing packages are written in perl.\n\nIn-place editing: Combine regular expressions with the ability to edit files “in place” from the command line, and perl makes a dandy tool for performing a batch modification on a group of files. For example, suppose you have renamed the /home/george directory to /home/curious, and want to update a few hundred scripts in the /usr/lib/yellowhat directory to point at the correct new path. The following one-liner will do just that:\n\n# perl -i.bak -p -e \"s#/home/george#/home/curious#\" `find . -print`\n\nNow, this is a fairly simple example and could have easily been done using a tool such as sed, but the important thing is that you could have used any arbitrarily complex perl program as the filter, and done highly complex manipulations. Imagine an area code getting split and having to replace a single area code with one of two depending on the original exchange in hundreds of files. In perl, it would be a snap.\n\nA replacement for shell scripts: One of the worst things about shell scripting—whether in bash, sh or csh—is that the syntax of the scripts themselves is fairly hard to read. By using perl as a scripting language instead of a “traditional” shell, you can use much more C-like syntax without sacrificing functionality.\n\nAs a database manipulation tool: One of perl’s strengths has always been the strong database interoperability through the DBI and DBD libraries. If you need to create a quick database report, or convert between a database and some other form of data storage, you can very easily whip up a little utility using perl in very short time.\n\nAs a cross-platform language: Because perl is interpreted, perl scripts don’t need to be recompiled when moved from platform to platform. And because companies like ActiveState have produced strong ports of perl to platforms such as Windows, most perl programs will run without modification even if they do advanced things such as database connectivity, file system modification or network programming.\n\nReal-time or high-performance applications: Perl is an interpreted language. In general, interpreted languages are not known to be speed demons. In researching this article, the most glaring example I found of someone who took perl to a place it didn’t want to go was a gentleman who decided to implement a ray-tracing program for 3-D computer graphics in perl. Even he admits it was a perverse thing to do!\n\nWhen looking at a potential application, if it seems to be characterized by a lot of tight loops over intensive calculations, you should probably be looking elsewhere.\n\nSimilarly, if the application is dependent on real-time response (especially life-critical or mission-critical response), perl won’t give you those kind of performance assurances, at least out of the box.\n\nAs a replacement for shell scripts: “But wait!” you scream, “You just told me I should be using perl to replace shell scripts.” And you should—if you do it right. Consider these two sample scripts:\n\n@files = `ls .`; for $file (@files) { system(\"cp $file $file.bak\"); }\n\nversus:\n\nuse File::Copy; opendir(DIR, \".\"); @files = readdir(DIR); close(DIR); for $file (@files) { if ($file =~ /.doc$/) { copy($file, \"$file.bak\"); } }\n\nThere’s no question that the second version is longer. However, the first version will fork a subshell to do the ls, and then a subshell every time it moves a file. The second version never needs to fork a shell (which is memory- and performance-wasteful). I’ve seen perl scripts that are nothing but a series of system calls to shell commands.\n\nSometimes you can’t get around using a system or backtick command in a perl script, but whenever possible, use the native functionality that mimics the shell call you’d otherwise make. This has the additional benefit of making the script portable. The first version of our sample script won’t run on Windows, while the second one works on both Linux and Windows.\n\nAs a Web scripting language: One of the earliest usages of perl, as the Web evolved, was for CGI programming webpages. As a result, perl has some pretty strong packages for dealing with Web forms. There is also support for embedding perl into HTML in the same way the Java is embedded into JSP pages.\n\nHowever, I would argue that more modern Web scripting languages, such as PHP and Ruby on Rails, offer more out-of-the-box Web support and a cleaner integration into the webpage experience. You should especially avoid using perl for traditional CGI-style form processing; this code tends to be hard to read and maintain because the HTML ends up inlined inside the perl code.\n\nIn an obfuscated fashion: Larry Wall, creator of perl, famously stated, “Perl is designed to give you several ways to do anything.” As a result, some developers have adopted the style of writing their code as compact and “elegantly” as they can. The results can sometimes be programs that look more like dialup line noise than supportable code.\n\nRemember that the full version of Wall’s quote states, “Perl is designed to give you several ways to do anything, so consider picking the most readable one.” Break up long lines into several statements, store intermediate values rather than passing them down a long chain of functions and use comments and whitespace to make the code clear."
    }
}