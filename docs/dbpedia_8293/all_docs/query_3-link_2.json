{
    "id": "dbpedia_8293_3",
    "rank": 2,
    "data": {
        "url": "https://www.activestate.com/blog/top-10-perl-tools-and-utilities/",
        "read_more_link": "",
        "language": "en",
        "title": "Pearls of Perl: Top 10 Perl Tools & Utilities",
        "top_image": "https://cdn.activestate.com/wp-content/uploads/2020/09/PerlTools.jpg",
        "meta_img": "https://cdn.activestate.com/wp-content/uploads/2020/09/PerlTools.jpg",
        "images": [
            "https://cdn.activestate.com/wp-content/uploads/2023/10/ActiveState.png",
            "https://cdn.activestate.com/wp-content/uploads/2020/09/PerlTools-1024x599.jpg",
            "https://cdn.activestate.com//wp-content/uploads/2020/09/perlcritic.png",
            "https://cdn.activestate.com/wp-content/uploads/2024/08/FinServRisks.jpg",
            "https://cdn.activestate.com/wp-content/uploads/2024/08/CloudSecurity.jpg",
            "https://cdn.activestate.com/wp-content/uploads/2024/08/FoxHenhouse.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Dana Crane"
        ],
        "publish_date": "2020-09-11T00:11:43+00:00",
        "summary": "",
        "meta_description": "Discover the top tools for Perl developers, as well as tools written in Perl that are essential for any coder.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "ActiveState",
        "canonical_link": "https://www.activestate.com/blog/top-10-perl-tools-and-utilities/",
        "text": "Veteran Perl developers will be well acquainted with this list of tools, but if you’re new to Perl, adopting this list will make your coding life much easier. While Perl isn’t currently one of the top three “must learn” languages, there’s still vast repositories of Perl programs out there, and more being added every day. In fact, you might be surprised at the number of Perl developers that ActiveState still engages with more than 20 years after we first introduced our ActivePerl for Windows distribution.\n\nIt turns out that the more ubiquitous a programming language was in its heyday (COBOL anyone?), the longer its life, and Perl was the king of dynamic scripting languages back in the 90’s and early 2000’s. Even as Perl turns 32 years old, there are countless systems that still depend on it for at least some part of their functionality, mainly because it’s often too expensive and time consuming to rewrite applications, scripts and services when the languages in which they were programmed go out of vogue. In fact, even modern versions of the Windows operating system still require Perl routines in order to build.\n\nPerl is having something of resurgence nowadays, rising from the #19 spot on the Tiobe index in 2019 to #13 in August 2020. The rate of usage growth is still ~1%, so it’s not headed back to it’s #3 slot, which it attained in 2005. But when it comes to quickly creating scripts or tackling specific tasks (especially text manipulation), Perl is still the right tool for the job.\n\nSo if you’re reaching for Perl to help you out, make sure to put the following tools and utilities in your toolbox to make your programming life a little easier.\n\nPerltidy\n\nPerltidy is one of those tools you can’t live without (along with perlcritic) when it comes to keeping your code style consistent. While functionally all it does is indent and reformat your code, it makes Perl code actually much easier to read. If you’ve been tasked with maintaining a Perl code base in your organization, this tool may make it more legible for you.\n\nBy default, perltidy will format the code according to Perl Style Guide guidelines. But if the guidelines aren’t to your liking, you can easily override perltidy’s default settings right on the command line.\n\nHere’s a simple example of default reformatting (taken from the perltidy docs), starting with a file labeled test.pl:\n\nprint \"Help Desk -- What Editor do you use?\"; chomp($editor = <STDIN>); if ($editor =~ /emacs/i) { print \"Why aren't you using vi?\\n\"; } elsif ($editor =~ /vi/i) { print \"Why aren't you using emacs?\\n\"; } else { print \"I think that's the problem\\n\"; }\n\nRunning perltidy on test.pl will create a new file called test.pl.tdy that looks like:\n\nprint \"Help Desk -- What Editor do you use?\"; chomp( $editor = <STDIN> ); if ( $editor =~ /emacs/i ) { print \"Why aren't you using vi?\\n\"; } elsif ( $editor =~ /vi/i ) { print \"Why aren't you using emacs?\\n\"; } else { print \"I think that's the problem\\n\"; }\n\nPerlcritic\n\nAt base, perlcritic is just a static code analysis tool, but in practice it functions more as a mentor to help you improve your coding skills.\n\nPerl is famous for its motto of TIMTOWTDI, which stands for “there is more than one way to do it.” It’s incredibly easy to dash off code that gets the job done quickly, regardless of maintainability, quality, or other long-term standards. If you’re hoping to ensure your Perl code is safe, secure, and understandable, you’ll want to make sure it conforms to some kind of Perl coding standard.\n\nPerlcritic comes with a number of policies that enforce various standards, but you can also create your own policy if your company has specific guidelines.\n\nWant to give it a quick try? Just upload your source code to http://perlcritic.com and choose how strict or lenient you want it to be. Here’s the diagnosis for the test.pl file from our previous example when perlcritic is set to “harsh”:\n\nWhile 5 violations reported for 9 lines of code may seem rather brutal, these suggestions can help turn throwaway code into something you’re proud to keep running.\n\nDist-Zilla\n\nAt some point, you’re going to hit a wall and realize that despite that fact that CPAN has hundreds of thousands of modules to help you get your job done, there’s nothing that does exactly what you need to do. After you’ve finished coding your solution, consider bundling it up as a contribution to CPAN.\n\nThere’s lots of tools available on CPAN that will take your source and build a tarball for easy redistribution, but Dist-Zilla is the one you want. Like the plug on its metacpan page says, it “takes care of all kinds of boring and mindless tasks” so you don’t have to.\n\nWhen you initially create your first distribution with Dist-Zilla, there’s still a lot of manual effort required to create your code, tests, doc, README, and so on. But when you update your distribution, you just run dzil build to automatically pull in required files (like your license file and meta.yml), as well as add standard boilerplate to your files (like versions and copyright statements).\n\nAnd when you’re ready to release, just run dzil release and Dist-Zilla will run your tests, build a tarball on successfully passing them, and then optionally upload it to CPAN for you.\n\nFor more information, read the Dist-Zilla tutorial.\n\nCarton\n\nCarton solves common Perl deployment issues. If you’ve ever encountered an error while deploying a Perl application, it’s probably because you’re pulling the latest versions of all the dependencies for the application from CPAN, but one or more of those dependencies are incompatible.\n\nYou can always use a cpanfile to pin an application’s dependencies so conflicts won’t occur during installation of your application, but what if other applications deployed on that same system have conflicting requirements?\n\nThat’s where carton comes in. Carton installs dependencies in the directory of the application to prevent cross-application conflicts. Carton is a command line tool that:\n\nAnalyzes your dependency tree\n\nCollects the version information in a cpanfile.snapshot file\n\nRunning carton install will ensure that an application is installed with the exact versions of dependencies that work together. You can even specify custom distributions as targets to ensure the correct dependency version is used.\n\nAnd carton will automatically maintain and update the snapshot file for you, so you don’t have to manage it on your own. Read carton’s documentation to get a better understanding of how to use it.\n\nMojo-UserAgent\n\nHave a need to quickly stand up an http client? Mojo-UserAgent is a great option for doing simple requests without the overhead of a large framework, but provides many of the bells and whistles you would normally only find in something more complex, including:\n\nWebsockets support\n\nLong polling\n\nConnection pooling\n\nStreaming\n\nIt’s perfect for quickly testing out your API. The following is a simple script that performs a get call and handles errors:\n\nuse Mojo::UserAgent; # Request a resource and make sure there were no connection errors my $ua = Mojo::UserAgent->new; my $tx = $ua->get('https://docs.mojolicious.org/Mojo' => {Accept => 'text/plain'}); my $res = $tx->result; # Decide what to do with its representation if ($res->is_success) { say $res->body } elsif ($res->is_error) { say $res->message } elsif ($res->code == 301) { say $res->headers->location } else { say 'Whatever...' }\n\nIt also comes with built-in content generators, including JSON, form (great for handling logins) and multipart (if you intend to upload multiple files). You can even do web scraping with it since it supports all common CSS selectors.\n\nBut much of this is also available directly from its command line interface, which can often be quicker and easier to use than curl. For example, to make our get request:\n\n$ mojo get https://www.activestate.com\n\nOr to scrape a website for all headings:\n\n$ mojo get https://www.activestate.com 'h1, h2, h3' text\n\nGet started by reading the documentation.\n\nData-Alias\n\nWhen coding in Perl, you’ll often run into instances where you can either copy, reference or alias an object. While certain cases may require one or the other solution, in general the best method is almost always to use an alias. Aliases provide better code readability than a reference, and use less resources than creating a copy.\n\nData-Alias then, is simply a tool that provides you with a set of convenient aliasing capabilities, causing aliases to be created whenever Perl would normally make copies.\n\nThe best way to realize the value of aliasing is to use it whenever you need to repeatedly refer to a complex expression or verbose string. For example:\n\nsub middlesection ($) { alias my ($s) = @_; substr $s, length($s)/4, length($s)/2 }\n\nIn this case, an alias is used instead of copying the large string, speeding up processing.\n\nWhile Perl 5.22 and later versions have support for aliasing built into the core functionality, if you can’t rely on being able to work with newer versions of Perl, data-alias is still your best bet. Read more about data-alias and its capabilities.\n\nPath-Tiny\n\nAs the Swiss army knife of file path manipulation, Path-Tiny provides you with everything you need to work with Linux and Windows files and their file paths. And it typically does it in a faster, less verbose way than other tools.\n\nSo what can you do with Path-Tiny?\n\nWork with path files and directory paths to (for example) get the absolute or relative path to a file, or convert between them. Also handy when creating symlinks.\n\nIterate through a directory and return the path of all files found there. Now you know how to reference all your files.\n\nSlurp a file’s contents into memory (or read larger files in line by line) in order to manipulate the contents by (for example) encrypting the file.\n\nWrite to a file, or append data to the end of a file.\n\nGet the path of a child file relative to the parent, and much, much more.\n\nOnce you start working with path-tiny, you’ll wonder how you ever managed without it. For an exhaustive list of all of path-tiny’s capabilities, refer to its metacpan entry.\n\nCommon Development Tools\n\nThe following tools just happen to be written in Perl, but as a developer, they’re going to be useful to you no matter what language you prefer to code in.\n\nSquitch\n\nNeed to manage a database? You can usually rely on that database’s tools to get done what you need to do, but what if you work with multiple databases? You can learn multiple different tools, or you can learn just one: sqitch.\n\nSqitch is a change management tool for databases whose strongest feature may be the fact that it’s non-opinionated, so it’s not tied to any one database or (in a wider sense) any one Object Relational Mapping (ORM) system. This means that no matter which database(s) you work with, you can write generic scripts to accomplish common database tasks, and sqitch will translate them into native database scripts so you can take full advantage of that database’s features.\n\nWhen it comes to database changes, sqitch employs the same kind of hashing technique found in Git and Bitcoin to ensure that each commit is uniquely identified and tracked. In any situation where it looks like a conflict may arise, sqitch fails safe, which means it doesn’t make the commit, erring on the side of maintaining database integrity. And of course, you can always roll back a commit, if needed.\n\nWith an active community of both users and contributors, sqitch may be the heterogeneous database management tool you’ve been looking for. Learn more about it by reading the documentation.\n\nAck\n\nTired of writing overly verbose grep statements to find what you’re looking for? Ack is the quintessential tool “designed for developers, by developers.” It intimately understands the pains associated with traditional command line search tools, and replaces them with a universal tool for all your search needs.\n\nGrep has always been the workhorse when it comes to searching for text in source code, but ack takes off where grep stops. It uses Perl’s strength (regular expressions) to help you search through your source code faster, and ignores older versions/backups of files and non-coding files by default, so it doesn’t return as many false positives as grep.\n\nIt also allows you to write searches far more efficiently, since:\n\nAck searches recursively by default\n\nAck know about the source files of different languages\n\nAs a result, complex queries in grep become simple one liners with ack. For example, if you’ve standardized on a mono repo – a single repository for all your code, no matter the language – grep requires a verbose syntax to search a Perl file:\n\n$ grep pattern $(find . -name '*.pl' -or -name '*.pm' -or -name '*.pod' | grep -v .git)\n\nWith ack, this query becomes simply:\n\n$ ack --perl pattern\n\nAs long as you’ve got a version of Perl 5 installed on your system, you can use ack. You can learn more about ack on its homepage.\n\nFile-Rename\n\nIf you’ve come to Perl from Unix or Linux scripting, you’re probably still using unix commands like rm, cp and mv. That works fine on your current platform, but one of the reasons to use Perl is to get things done in a platform-independent way.\n\nA good example is the File-Rename tool, which allows you to rename multiple files. Perl comes built-in with a rename function for single file renaming:\n\nrename OLDNAME,NEWNAME\n\nFile-Rename extends this function to let you rename lists of files. New names can be defined using:\n\nA simple string\n\nA code function that can literally be anything from generating a UUID for each new filename to prompting the user for a name to reading names from a file, etc\n\nFor example:\n\nuse File::Rename; rename \\@ARGV, sub { s/\\.pl\\z/.pm/ }, 1;\n\nWhich will replace the .pl file name extension with .pm\n\nNext Steps\n\nTo get started with the tools on this list, create a free ActiveState Platform account and then download our “Pearls of Perl” build. The build contains a version of Perl 5.28 and most of the tools listed in this post so you can test them out for yourself.\n\nNOTE: the simplest way to install the environment is to first install the ActiveState Platform’s command line interface (CLI), the State Tool.\n\nIf you’re on Windows, you can use Powershell to install the State Tool:\n\nIEX(New-Object Net.WebClient).downloadString('https://platform.activestate.com/dl/cli/install.ps1')\n\nIf you’re on Linux , you can use curl to install the State Tool:\n\nsh <(curl -q https://platform.activestate.com/dl/cli/install.sh)\n\nOnce the State Tool is installed, just run the following command to download the build and automatically install it into a virtual environment:\n\nstate activate Pizza-Team/Pearls-of-Perl\n\nUPDATE: ActiveState introduced a new version of our Perl ecosystem with the release of Perl 5.32, which provides a new way to install, work with and even consume Perl from ActiveState. You can learn more and download your own version of ActiveState’s new Perl ecosystem for free from our Perl 5.32 page.\n\nRelated Blogs:\n\nActiveState’s New Perl Ecosystem"
    }
}