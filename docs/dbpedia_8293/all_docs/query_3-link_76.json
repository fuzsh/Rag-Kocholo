{
    "id": "dbpedia_8293_3",
    "rank": 76,
    "data": {
        "url": "https://docs.mojolicious.org/perlmodstyle",
        "read_more_link": "",
        "language": "en",
        "title": "Perl module style guide",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.mojolicious.org/mojo/logo-white.png",
            "https://docs.mojolicious.org/mojolicious/mojojs-white.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "/mojolicious/touch-icon.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "#NAME\n\nperlmodstyle - Perl module style guide\n\n#INTRODUCTION\n\nThis document attempts to describe the Perl Community's \"best practice\" for writing Perl modules. It extends the recommendations found in perlstyle , which should be considered required reading before reading this document.\n\nWhile this document is intended to be useful to all module authors, it is particularly aimed at authors who wish to publish their modules on CPAN.\n\nThe focus is on elements of style which are visible to the users of a module, rather than those parts which are only seen by the module's developers. However, many of the guidelines presented in this document can be extrapolated and applied successfully to a module's internals.\n\nThis document differs from perlnewmod in that it is a style guide rather than a tutorial on creating CPAN modules. It provides a checklist against which modules can be compared to determine whether they conform to best practice, without necessarily describing in detail how to achieve this.\n\nAll the advice contained in this document has been gleaned from extensive conversations with experienced CPAN authors and users. Every piece of advice given here is the result of previous mistakes. This information is here to help you avoid the same mistakes and the extra work that would inevitably be required to fix them.\n\nThe first section of this document provides an itemized checklist; subsequent sections provide a more detailed discussion of the items on the list. The final section, \"Common Pitfalls\", describes some of the most popular mistakes made by CPAN authors.\n\n#QUICK CHECKLIST\n\nFor more detail on each item in this checklist, see below.\n\n#Before you start\n\nDon't re-invent the wheel\n\nPatch, extend or subclass an existing module where possible\n\nDo one thing and do it well\n\nChoose an appropriate name\n\nGet feedback before publishing\n\n#The API\n\nAPI should be understandable by the average programmer\n\nSimple methods for simple tasks\n\nSeparate functionality from output\n\nConsistent naming of subroutines or methods\n\nUse named parameters (a hash or hashref) when there are more than two parameters\n\n#Stability\n\nEnsure your module works under use strict and -w\n\nStable modules should maintain backwards compatibility\n\n#Documentation\n\nWrite documentation in POD\n\nDocument purpose, scope and target applications\n\nDocument each publicly accessible method or subroutine, including params and return values\n\nGive examples of use in your documentation\n\nProvide a README file and perhaps also release notes, changelog, etc\n\nProvide links to further information (URL, email)\n\n#Release considerations\n\nSpecify pre-requisites in Makefile.PL or Build.PL\n\nSpecify Perl version requirements with use\n\nInclude tests with your module\n\nChoose a sensible and consistent version numbering scheme (X.YY is the common Perl module numbering scheme)\n\nIncrement the version number for every change, no matter how small\n\nPackage the module using \"make dist\"\n\nChoose an appropriate license (GPL/Artistic is a good default)\n\n#BEFORE YOU START WRITING A MODULE\n\nTry not to launch headlong into developing your module without spending some time thinking first. A little forethought may save you a vast amount of effort later on.\n\n#Has it been done before?\n\nYou may not even need to write the module. Check whether it's already been done in Perl, and avoid re-inventing the wheel unless you have a good reason.\n\nGood places to look for pre-existing modules include MetaCPAN and asking on module-authors@perl.org (https://lists.perl.org/list/module-authors.html).\n\nIf an existing module almost does what you want, consider writing a patch, writing a subclass, or otherwise extending the existing module rather than rewriting it.\n\n#Do one thing and do it well\n\nAt the risk of stating the obvious, modules are intended to be modular. A Perl developer should be able to use modules to put together the building blocks of their application. However, it's important that the blocks are the right shape, and that the developer shouldn't have to use a big block when all they need is a small one.\n\nYour module should have a clearly defined scope which is no longer than a single sentence. Can your module be broken down into a family of related modules?\n\nBad example:\n\n\"FooBar.pm provides an implementation of the FOO protocol and the related BAR standard.\"\n\nGood example:\n\n\"Foo.pm provides an implementation of the FOO protocol. Bar.pm implements the related BAR protocol.\"\n\nThis means that if a developer only needs a module for the BAR standard, they should not be forced to install libraries for FOO as well.\n\n#What's in a name?\n\nMake sure you choose an appropriate name for your module early on. This will help people find and remember your module, and make programming with your module more intuitive.\n\nWhen naming your module, consider the following:\n\nBe descriptive (i.e. accurately describes the purpose of the module).\n\nBe consistent with existing modules.\n\nReflect the functionality of the module, not the implementation.\n\nAvoid starting a new top-level hierarchy, especially if a suitable hierarchy already exists under which you could place your module.\n\n#Get feedback before publishing\n\nIf you have never uploaded a module to CPAN before (and even if you have), you are strongly encouraged to get feedback from people who are already familiar with the module's application domain and the CPAN naming system. Authors of similar modules, or modules with similar names, may be a good place to start, as are community sites like Perl Monks.\n\n#DESIGNING AND WRITING YOUR MODULE\n\nConsiderations for module design and coding:\n\n#To OO or not to OO?\n\nYour module may be object oriented (OO) or not, or it may have both kinds of interfaces available. There are pros and cons of each technique, which should be considered when you design your API.\n\nIn Perl Best Practices (copyright 2004, Published by O'Reilly Media, Inc.), Damian Conway provides a list of criteria to use when deciding if OO is the right fit for your problem:\n\nThe system being designed is large, or is likely to become large.\n\nThe data can be aggregated into obvious structures, especially if there's a large amount of data in each aggregate.\n\nThe various types of data aggregate form a natural hierarchy that facilitates the use of inheritance and polymorphism.\n\nYou have a piece of data on which many different operations are applied.\n\nYou need to perform the same general operations on related types of data, but with slight variations depending on the specific type of data the operations are applied to.\n\nIt's likely you'll have to add new data types later.\n\nThe typical interactions between pieces of data are best represented by operators.\n\nThe implementation of individual components of the system is likely to change over time.\n\nThe system design is already object-oriented.\n\nLarge numbers of other programmers will be using your code modules.\n\nThink carefully about whether OO is appropriate for your module. Gratuitous object orientation results in complex APIs which are difficult for the average module user to understand or use.\n\n#Designing your API\n\nYour interfaces should be understandable by an average Perl programmer. The following guidelines may help you judge whether your API is sufficiently straightforward:\n\nWrite simple routines to do simple things.\n\nIt's better to have numerous simple routines than a few monolithic ones. If your routine changes its behaviour significantly based on its arguments, it's a sign that you should have two (or more) separate routines.\n\nSeparate functionality from output.\n\nReturn your results in the most generic form possible and allow the user to choose how to use them. The most generic form possible is usually a Perl data structure which can then be used to generate a text report, HTML, XML, a database query, or whatever else your users require.\n\nIf your routine iterates through some kind of list (such as a list of files, or records in a database) you may consider providing a callback so that users can manipulate each element of the list in turn. File::Find provides an example of this with its find(\\&wanted, $dir) syntax.\n\nProvide sensible shortcuts and defaults.\n\nDon't require every module user to jump through the same hoops to achieve a simple result. You can always include optional parameters or routines for more complex or non-standard behaviour. If most of your users have to type a few almost identical lines of code when they start using your module, it's a sign that you should have made that behaviour a default. Another good indicator that you should use defaults is if most of your users call your routines with the same arguments.\n\nNaming conventions\n\nYour naming should be consistent. For instance, it's better to have:\n\ndisplay_day(); display_week(); display_year();\n\nthan\n\ndisplay_day(); week_display(); show_year();\n\nThis applies equally to method names, parameter names, and anything else which is visible to the user (and most things that aren't!)\n\nParameter passing\n\nUse named parameters. It's easier to use a hash like this:\n\n$obj->do_something( name => \"wibble\", type => \"text\", size => 1024, );\n\n... than to have a long list of unnamed parameters like this:\n\n$obj->do_something(\"wibble\", \"text\", 1024);\n\nWhile the list of arguments might work fine for one, two or even three arguments, any more arguments become hard for the module user to remember, and hard for the module author to manage. If you want to add a new parameter you will have to add it to the end of the list for backward compatibility, and this will probably make your list order unintuitive. Also, if many elements may be undefined you may see the following unattractive method calls:\n\n$obj->do_something(undef, undef, undef, undef, undef, 1024);\n\nProvide sensible defaults for parameters which have them. Don't make your users specify parameters which will almost always be the same.\n\nThe issue of whether to pass the arguments in a hash or a hashref is largely a matter of personal style.\n\nThe use of hash keys starting with a hyphen (-name) or entirely in upper case (NAME) is a relic of older versions of Perl in which ordinary lower case strings were not handled correctly by the => operator. While some modules retain uppercase or hyphenated argument keys for historical reasons or as a matter of personal style, most new modules should use simple lower case keys. Whatever you choose, be consistent!\n\n#Strictness and warnings\n\nYour module should run successfully under the strict pragma and should run without generating any warnings. Your module should also handle taint-checking where appropriate, though this can cause difficulties in many cases.\n\n#Backwards compatibility\n\nModules which are \"stable\" should not break backwards compatibility without at least a long transition phase and a major change in version number.\n\n#Error handling and messages\n\nWhen your module encounters an error it should do one or more of:\n\nReturn an undefined value.\n\nset $Module::errstr or similar (errstr is a common name used by DBI and other popular modules; if you choose something else, be sure to document it clearly).\n\nwarn() or carp() a message to STDERR.\n\ncroak() only when your module absolutely cannot figure out what to do. (croak() is a better version of die() for use within modules, which reports its errors from the perspective of the caller. See Carp for details of croak(), carp() and other useful routines.)\n\nAs an alternative to the above, you may prefer to throw exceptions using the Error module.\n\nConfigurable error handling can be very useful to your users. Consider offering a choice of levels for warning and debug messages, an option to send messages to a separate file, a way to specify an error-handling routine, or other such features. Be sure to default all these options to the commonest use.\n\n#DOCUMENTING YOUR MODULE\n\n#POD\n\nYour module should include documentation aimed at Perl developers. You should use Perl's \"plain old documentation\" (POD) for your general technical documentation, though you may wish to write additional documentation (white papers, tutorials, etc) in some other format. You need to cover the following subjects:\n\nA synopsis of the common uses of the module\n\nThe purpose, scope and target applications of your module\n\nUse of each publicly accessible method or subroutine, including parameters and return values\n\nExamples of use\n\nSources of further information\n\nA contact email address for the author/maintainer\n\nThe level of detail in Perl module documentation generally goes from less detailed to more detailed. Your SYNOPSIS section should contain a minimal example of use (perhaps as little as one line of code; skip the unusual use cases or anything not needed by most users); the DESCRIPTION should describe your module in broad terms, generally in just a few paragraphs; more detail of the module's routines or methods, lengthy code examples, or other in-depth material should be given in subsequent sections.\n\nIdeally, someone who's slightly familiar with your module should be able to refresh their memory without hitting \"page down\". As your reader continues through the document, they should receive a progressively greater amount of knowledge.\n\nThe recommended order of sections in Perl module documentation is:\n\nNAME\n\nSYNOPSIS\n\nDESCRIPTION\n\nOne or more sections or subsections giving greater detail of available methods and routines and any other relevant information.\n\nBUGS/CAVEATS/etc\n\nAUTHOR\n\nSEE ALSO\n\nCOPYRIGHT and LICENSE\n\nKeep your documentation near the code it documents (\"inline\" documentation). Include POD for a given method right above that method's subroutine. This makes it easier to keep the documentation up to date, and avoids having to document each piece of code twice (once in POD and once in comments).\n\n#README, INSTALL, release notes, changelogs\n\nYour module should also include a README file describing the module and giving pointers to further information (website, author email).\n\nAn INSTALL file should be included, and should contain simple installation instructions. When using ExtUtils::MakeMaker this will usually be:\n\nperl Makefile.PL\n\nmake\n\nmake test\n\nmake install\n\nWhen using Module::Build, this will usually be:\n\nperl Build.PL\n\nperl Build\n\nperl Build test\n\nperl Build install\n\nRelease notes or changelogs should be produced for each release of your software describing user-visible changes to your module, in terms relevant to the user.\n\nUnless you have good reasons for using some other format (for example, a format used within your company), the convention is to name your changelog file Changes, and to follow the simple format described in CPAN::Changes::Spec.\n\n#RELEASE CONSIDERATIONS\n\n#Version numbering\n\nVersion numbers should indicate at least major and minor releases, and possibly sub-minor releases. A major release is one in which most of the functionality has changed, or in which major new functionality is added. A minor release is one in which a small amount of functionality has been added or changed. Sub-minor version numbers are usually used for changes which do not affect functionality, such as documentation patches.\n\nThe most common CPAN version numbering scheme looks like this:\n\n1.00, 1.10, 1.11, 1.20, 1.30, 1.31, 1.32\n\nA correct CPAN version number is a floating point number with at least 2 digits after the decimal. You can test whether it conforms to CPAN by using\n\nperl -MExtUtils::MakeMaker -le 'print MM->parse_version(shift)' \\ 'Foo.pm'\n\nIf you want to release a 'beta' or 'alpha' version of a module but don't want CPAN.pm to list it as most recent use an '_' after the regular version number followed by at least 2 digits, eg. 1.20_01. If you do this, the following idiom is recommended:\n\nour $VERSION = \"1.12_01\"; # so CPAN distribution will have # right filename our $XS_VERSION = $VERSION; # only needed if you have XS code $VERSION = eval $VERSION; # so \"use Module 0.002\" won't warn on # underscore\n\nWith that trick MakeMaker will only read the first line and thus read the underscore, while the perl interpreter will evaluate the $VERSION and convert the string into a number. Later operations that treat $VERSION as a number will then be able to do so without provoking a warning about $VERSION not being a number.\n\nNever release anything (even a one-word documentation patch) without incrementing the number. Even a one-word documentation patch should result in a change in version at the sub-minor level.\n\nOnce picked, it is important to stick to your version scheme, without reducing the number of digits. This is because \"downstream\" packagers, such as the FreeBSD ports system, interpret the version numbers in various ways. If you change the number of digits in your version scheme, you can confuse these systems so they get the versions of your module out of order, which is obviously bad.\n\n#Pre-requisites\n\nModule authors should carefully consider whether to rely on other modules, and which modules to rely on.\n\nMost importantly, choose modules which are as stable as possible. In order of preference:\n\nCore Perl modules\n\nStable CPAN modules\n\nUnstable CPAN modules\n\nModules not available from CPAN\n\nSpecify version requirements for other Perl modules in the pre-requisites in your Makefile.PL or Build.PL.\n\nBe sure to specify Perl version requirements both in Makefile.PL or Build.PL and with require 5.6.1 or similar. See the documentation on use VERSION for details.\n\n#Testing\n\nAll modules should be tested before distribution (using \"make disttest\"), and the tests should also be available to people installing the modules (using \"make test\"). For Module::Build you would use the make test equivalent perl Build test.\n\nThe importance of these tests is proportional to the alleged stability of a module. A module which purports to be stable or which hopes to achieve wide use should adhere to as strict a testing regime as possible.\n\nUseful modules to help you write tests (with minimum impact on your development process or your time) include Test::Simple, Carp::Assert and Test::Inline. For more sophisticated test suites there are Test::More and Test::MockObject.\n\n#Packaging\n\nModules should be packaged using one of the standard packaging tools. Currently you have the choice between ExtUtils::MakeMaker and the more platform independent Module::Build, allowing modules to be installed in a consistent manner. When using ExtUtils::MakeMaker, you can use \"make dist\" to create your package. Tools exist to help you to build your module in a MakeMaker-friendly style. These include ExtUtils::ModuleMaker and h2xs. See also perlnewmod.\n\n#Licensing\n\nMake sure that your module has a license, and that the full text of it is included in the distribution (unless it's a common one and the terms of the license don't require you to include it).\n\nIf you don't know what license to use, dual licensing under the GPL and Artistic licenses (the same as Perl itself) is a good idea. See perlgpl and perlartistic.\n\n#COMMON PITFALLS\n\n#Reinventing the wheel\n\nThere are certain application spaces which are already very, very well served by CPAN. One example is templating systems, another is date and time modules, and there are many more. While it is a rite of passage to write your own version of these things, please consider carefully whether the Perl world really needs you to publish it.\n\n#Trying to do too much\n\nYour module will be part of a developer's toolkit. It will not, in itself, form the entire toolkit. It's tempting to add extra features until your code is a monolithic system rather than a set of modular building blocks.\n\n#Inappropriate documentation\n\nDon't fall into the trap of writing for the wrong audience. Your primary audience is a reasonably experienced developer with at least a moderate understanding of your module's application domain, who's just downloaded your module and wants to start using it as quickly as possible.\n\nTutorials, end-user documentation, research papers, FAQs etc are not appropriate in a module's main documentation. If you really want to write these, include them as sub-documents such as My::Module::Tutorial or My::Module::FAQ and provide a link in the SEE ALSO section of the main documentation.\n\n#SEE ALSO\n\nperlstyle\n\nGeneral Perl style guide\n\nperlnewmod\n\nHow to create a new module\n\nperlpod\n\nPOD documentation\n\npodchecker\n\nVerifies your POD's correctness\n\nExtUtils::MakeMaker, Module::Build\n\nTest::Simple, Test::Inline, Carp::Assert, Test::More, Test::MockObject\n\nhttps://pause.perl.org/\n\nPerl Authors Upload Server. Contains links to information for module authors.\n\nAny good book on software engineering\n\n#AUTHOR\n\nKirrily \"Skud\" Robert <skud@cpan.org>"
    }
}