{
    "id": "wrong_mix_property_subsidiary_00027_1",
    "rank": 72,
    "data": {
        "url": "https://patents.google.com/patent/US20100281450A1/en",
        "read_more_link": "",
        "language": "en",
        "title": "US20100281450A1 - Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/00/fd/9a/2e5df695a8dbfe/US20100281450A1-20101104-D00000.png",
            "https://patentimages.storage.googleapis.com/0d/29/8b/fc1909d542bda7/US20100281450A1-20101104-D00001.png",
            "https://patentimages.storage.googleapis.com/51/f4/60/ade3117b351810/US20100281450A1-20101104-D00002.png",
            "https://patentimages.storage.googleapis.com/1c/9d/79/c2cc06c53053b6/US20100281450A1-20101104-D00003.png",
            "https://patentimages.storage.googleapis.com/c4/74/be/c09603f685785b/US20100281450A1-20101104-D00004.png",
            "https://patentimages.storage.googleapis.com/fb/4e/24/e0c9bc13b35acc/US20100281450A1-20101104-D00005.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2007-01-03T00:00:00",
        "summary": "",
        "meta_description": "A method and system is described for mapping a system-level description of an integrated system directly to a technology-specific set of logic cells that are comprised primarily of large complex cells (bricks). The invention is based on applying aggressive Boolean operations that would be of impractical runtime complexity for a large library, but are applicable for the targeted brick libraries which typically contain a small number of complex cells, along with a much smaller number of simple cells. This invention is modular such that it can be applied in the context of incremental netlist optimization as well as optimization during physical synthesis.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US20100281450A1/en",
        "text": "Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells Download PDF\n\nInfo\n\nPublication number\n\nUS20100281450A1\n\nUS20100281450A1 US12/835,675 US83567510A US2010281450A1 US 20100281450 A1 US20100281450 A1 US 20100281450A1 US 83567510 A US83567510 A US 83567510A US 2010281450 A1 US2010281450 A1 US 2010281450A1\n\nAuthority\n\nUS\n\nUnited States\n\nPrior art keywords\n\nfunctions\n\nnetwork\n\nlogic\n\nboolean\n\nmapping\n\nPrior art date\n\n2007-01-03\n\nLegal status (The legal status is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the status listed.)\n\nGranted\n\nApplication number\n\nUS12/835,675\n\nOther versions\n\nUS8082529B2 (en\n\nInventor\n\nVeerbhan Kheterpal\n\nCurrent Assignee (The listed assignees may be inaccurate. Google has not performed a legal analysis and makes no representation or warranty as to the accuracy of the list.)\n\nPDF Acquisition Corp\n\nOriginal Assignee\n\nPDF Acquisition Corp\n\nPriority date (The priority date is an assumption and is not a legal conclusion. Google has not performed a legal analysis and makes no representation as to the accuracy of the date listed.)\n\n2007-01-03\n\nFiling date\n\n2010-07-13\n\nPublication date\n\n2010-11-04\n\n2007-01-03 Priority claimed from US11/619,587 external-priority patent/US7784013B2/en\n\n2010-07-13 Application filed by PDF Acquisition Corp filed Critical PDF Acquisition Corp\n\n2010-07-13 Priority to US12/835,675 priority Critical patent/US8082529B2/en\n\n2010-10-18 Assigned to PDF ACQUISITION CORP. reassignment PDF ACQUISITION CORP. MERGER (SEE DOCUMENT FOR DETAILS). Assignors: FABRIX, INC.\n\n2010-10-18 Assigned to FABRIX, INC. reassignment FABRIX, INC. ASSIGNMENT OF ASSIGNORS INTEREST (SEE DOCUMENT FOR DETAILS). Assignors: KHETERPAL, VEERBHAN, MOTIANI, DIPTI, PILEGGI, LAWRENCE T.\n\n2010-11-04 Publication of US20100281450A1 publication Critical patent/US20100281450A1/en\n\n2011-12-20 Application granted granted Critical\n\n2011-12-20 Publication of US8082529B2 publication Critical patent/US8082529B2/en\n\nStatus Active - Reinstated legal-status Critical Current\n\n2027-01-03 Anticipated expiration legal-status Critical\n\nLinks\n\nUSPTO\n\nUSPTO PatentCenter\n\nUSPTO Assignment\n\nEspacenet\n\nGlobal Dossier\n\nDiscuss\n\n238000013507 mapping Methods 0.000 title claims abstract description 40\n\n238000000034 method Methods 0.000 title abstract description 45\n\n230000006870 function Effects 0.000 claims description 96\n\n230000003542 behavioural effect Effects 0.000 claims description 7\n\n238000012360 testing method Methods 0.000 claims description 2\n\n239000011449 brick Substances 0.000 abstract description 57\n\n238000005516 engineering process Methods 0.000 abstract description 29\n\n230000015572 biosynthetic process Effects 0.000 abstract description 18\n\n238000003786 synthesis reaction Methods 0.000 abstract description 18\n\n238000005457 optimization Methods 0.000 abstract description 16\n\n238000000354 decomposition reaction Methods 0.000 description 40\n\n238000013461 design Methods 0.000 description 26\n\n230000008569 process Effects 0.000 description 10\n\n238000004519 manufacturing process Methods 0.000 description 3\n\n230000009466 transformation Effects 0.000 description 3\n\n230000008901 benefit Effects 0.000 description 2\n\n238000004364 calculation method Methods 0.000 description 2\n\n238000010586 diagram Methods 0.000 description 2\n\n238000000605 extraction Methods 0.000 description 2\n\n230000006872 improvement Effects 0.000 description 2\n\n238000012986 modification Methods 0.000 description 2\n\n230000004048 modification Effects 0.000 description 2\n\n238000013519 translation Methods 0.000 description 2\n\n238000003491 array Methods 0.000 description 1\n\n238000012512 characterization method Methods 0.000 description 1\n\n238000006243 chemical reaction Methods 0.000 description 1\n\n238000011960 computer-aided design Methods 0.000 description 1\n\n230000001419 dependent effect Effects 0.000 description 1\n\n238000011161 development Methods 0.000 description 1\n\n235000015114 espresso Nutrition 0.000 description 1\n\n238000007429 general method Methods 0.000 description 1\n\n238000003780 insertion Methods 0.000 description 1\n\n230000037431 insertion Effects 0.000 description 1\n\n230000003993 interaction Effects 0.000 description 1\n\n238000010606 normalization Methods 0.000 description 1\n\n230000008520 organization Effects 0.000 description 1\n\n229920000747 poly(lactic acid) Polymers 0.000 description 1\n\n238000012552 review Methods 0.000 description 1\n\n238000001308 synthesis method Methods 0.000 description 1\n\n238000012546 transfer Methods 0.000 description 1\n\n230000001131 transforming effect Effects 0.000 description 1\n\nImages\n\nClassifications\n\nG—PHYSICS\n\nG06—COMPUTING; CALCULATING OR COUNTING\n\nG06F—ELECTRIC DIGITAL DATA PROCESSING\n\nG06F30/00—Computer-aided design [CAD]\n\nG06F30/30—Circuit design\n\nG06F30/32—Circuit design at the digital level\n\nG06F30/327—Logic synthesis; Behaviour synthesis, e.g. mapping logic, HDL to netlist, high-level language to RTL or netlist\n\nDefinitions\n\nthe present invention is related to integrated circuit design, and, more particularly, a method and system for mapping a Boolean logic network to a limited set of application-domain specific logic cells.\n\nTypical integrated circuit design environments make use of libraries of pre-designed standard cells (a cell library) which usually consist of from 500 cells to more than 1,000 cells. These libraries are composed of a number of simple, generic and standard logic functions that have been implemented in a form suitable for manufacturing. Each standard cell is a representation, typically the mask level representation, of the circuit that performs the logic function for that cell.\n\nthe logic functions performed by the cells in a typical cell library are intentionally general purpose and basic and the majority of them represent common, low-level logic functions such as AND, OR, XOR, AND-OR-INVERT (AOI), Multiplexer, Adder, etc. These are functions are representative of patterns that are recognized by logic designers, and those that are used as the building blocks for manual logic design.\n\nFull custom logic design at the transistor level can sometimes include complex AOI functions that are identifiable from their logic description, such as:\n\nIC design In a typical integrated circuit (IC) design flow an IC design is translated to logic gates. In most cases this translation is performed by an automatic logic synthesis tool to derive a netlist based on a set of the aforementioned generic logic functions. This translation is often necessary as there are many different methods in common use for design specification. Those methods may include specification using a high-level programming language such as Verilog, VHDL or C or by manually entering schematics using a computer-aided design system.\n\na high-level programming language such as Verilog, VHDL or C\n\na gate level netlist As a high level language cannot be directly implemented into the physical layout of an integrated circuit, it is first converted to a gate level implementation. The result of the conversion is a representation of the design called a gate level netlist. This representation is usually in the form of simple logic functions such as NAND, NOR, etc. along with a representation of the connections between functions (the netlist).\n\nAutomatic logic synthesis tools are then generally used to bind a design to an implementation, based on a set of manufacturing technology specific logic cells from a cell library.\n\nthe synthesis tool selects cells from the library based on a set of implementation goals that may include any combination of metrics related to area, performance or power and possibly manufacturing yield, to obtain a cell-based netlist.\n\nLogic synthesis is generally the process of transformation of an RTL or a Boolean network such that its functionality is not altered into a form that is aligned for technology mapping.\n\na Boolean network can be represented by a directed acyclic graph where each node is a Boolean function of one of three types: a primary input, internal, output.\n\na Boolean network may not contain a directed cycle.\n\nEach internal node in a Boolean network represents a Boolean function of its fanins.\n\na Boolean network may contain internal nodes with arbitrarily large number of fanins.\n\nthe Boolean network is first decomposed into a subject graph (a graph which represents the design independent of a specific technology or library using simple logic primitives (most commonly AND and INV) to form the technology-independent netlist. Subsequently, the subject graph is then typically mapped to a cell library using structural/Boolean matching followed by binate covering against pre-stored patterns representing the cells in the library. As the cells in the library get more complex, the matching complexity increases exponentially. Moreover, this method suffers from a structure bias; i.e, the mapping quality is dependent on the subject graph structure which is often derived with little knowledge of the characteristics of the target cell library.\n\nthe present invention relates to mapping a Boolean logic network to a limited set of application-domain specific logic cells.\n\na method and system for mapping a system-level description of an integrated system directly to a technology-specific set of logic cells that are comprised primarily of large complex cells (bricks).\n\nthe invention is based on applying aggressive Boolean operations that would be of impractical runtime complexity for a large library, but are applicable for the targeted brick libraries which typically contain a small number of complex cells, along with a much smaller number of simple cells.\n\nThis invention is modular such that it can be applied in the context of incremental netlist optimization as well as optimization during physical synthesis.\n\na method of mapping a behavioral, RTL or unmapped Boolean network to a small library of logic components to represent the network as different ones of the logic components that are connected together includes obtaining the behavioral, RTL or unmapped Boolean network; identifying the small library of logic components, the small library of logic components including a set of complex functions and a set of simple functions, wherein the set of complex functions includes a plurality of non-standard complex Boolean logic functions and wherein substantially all of the plurality of non-standard complex Boolean logic functions each have at least three inputs, and wherein the set of simple logic functions, together with the set of complex functions, can together completely specify the network; and mapping the network to the small library of logic components using aggressive Boolean operations to obtain a mapped network, wherein the mapping includes directly mapping large functions from the network to different ones of the non-standard complex Boolean logic functions without the large functions from the network being decomposed, wherein most of the network is mapped to certain ones of\n\nFIG. 1 illustrates a typical commercial flow that is used in mapping a Boolean network to a set of technology-specific standard cell gates.\n\nFIG. 2 illustrates an overview of the present invention\n\nFIG. 3 illustrates a flowchart of the direct brick mapping according to the present invention.\n\nFIG. 4 illustrates a flow diagram for incremental netlist optimization according to the present invention.\n\nFIG. 5 illustrates decomposition of a node according to the present invention.\n\na method and system are described to map a behavioral level (a functional description level for which the mapping to the final state machine is not specified. There is no description of how the variables map to circuit memory elements), RTL or system-level logic netlist to a small library of logic components (no fewer than 5 and no more than 50 unique logic functions).\n\nOne intended application of this invention is to leverage the unique advantages offered by small libraries of application-domain specific logic bricks, such as described in U.S. application Ser. No. 11/619,587 filed Jan. 3, 2007 and entitled âMethod For The Definition Of A Library Of Application-Domain-Specific Logic Cells,â referred to previously.\n\nIC design with increased regularity for manufacturabilty can incur a penalty in terms of area and performance. It is important, therefore, to exploit this regularity with circuits and methodologies that can overcome some or all of these penalties. Exploiting the large logic functions that are grouped for macro-regularity to maximize the logic utilization on the chip can provide a significant improvement in both area and performance. Improvements in IC area and performance are of great commercial value and all IC application domains. The present invention addresses this.\n\nthis invention describes a logic synthesis method to map a behavioral, RTL or system-level logic netlist to a library that is primarily composed of bricks or large logic cells (typically having 6-12 inputs, with substantially all of the large logic cells having at least 3 inputs).\n\nOur method takes advantage of the property that the brick library has a small number of cells compared to typical commercial standard-cell libraries that can contain hundreds or thousands of cells, as described in the previously referenced application.\n\nthe present invention starts by directly mapping a Boolean network onto a target library without any need for decomposition into a subject graph.\n\nDecomposition is the process of simplifying nodes by identifying and adding new Boolean nodes (with smaller number of fanins) to the network.\n\nmost decomposition algorithms work by choosing a factor and re-expressing the network in terms of that new factor and iterating until no new factors are found. This is achieved by direct decomposition of Boolean nodes into cells/bricks.\n\nBoolean network can contain internal nodes with arbitrarily large number of fanins\n\nthe general method of decomposition attempts to simplify such nodes by identifying and adding new Boolean nodes (with smaller number of fanins) to the network.\n\nthe prior art for decomposition algorithms are based on choosing a factor and re-expressing the network in terms of that new factor and iterating until no new factors are found.\n\nThis general set of decomposition techniques for logic optimization and technology mapping (the process of transforming a circuit netlist into a network of interconnected components/cells of a given library.\n\ntechnology mapping the process of transforming a circuit netlist into a network of interconnected components/cells of a given library.\n\na design can be targeted to a design style such as standard cells, FPGAs or gate arrays\n\nthe complexity of the cells in a brick library (also referred to as library that includes a set of complex functions includes a plurality of non-standard complex Boolean logic functions that are each derived from the identified logic function patterns of the recurring Boolean logic chains in the utility application incorporated by reference above) is considerably higher than those of typical standard cells, and the number of cells in a brick library (typically 5-50) is less than in a typical standard cell library (typically 700-2000).\n\nefficiency with a small cell library is sometimes obtained by generating the library to be application specific, or application domain specific. Based on the outlined differences, existing methods used for binding a system level (e.g. RTL) description to a specific technology library are inefficient for brick libraries.\n\na target technology library is one have a collection of cells that perform primitive Boolean logic functions in a specific technology or a design style.\n\nlogic decomposition and multi-level optimization are separate steps from technology mapping with very little interaction. Since a brick library has limited functionality, it provides for an opportunity to tightly couple these steps while having a tractable complexity of the computation.\n\nmapping graph does not scale with the size-complexity of Boolean functions, thereby making it impractical for application to libraries of bricks or large cells.\n\nFIG. 2 illustrates an overview of the present invention, which takes as inputs the Boolean network to be technology mapped, the limited library of bricks (potentially derived for a specific application-domain) and a set of design constraints that describe the area as well as delay goals.\n\nthe input Boolean network might be one that is obtained from the register transfer level (RTL) description of a circuit after performing some technology independent optimization.\n\nRTL register transfer level\n\nThis Boolean network is then technology mapped via decomposition and recomposition to bricks, as described hereinafter, following the design constraints and specifications.\n\nOne aspect of the uniqueness of the present invention is that each cell and its precise characteristics are considered while performing logic synthesis. This is not possible during decomposition to standard cells due to the small cell sizes and the overwhelmingly complex number of possible decompositions due to the number of unique logic cells.\n\nbricks are by definition dominated by large complex cells (cells with at least 3 inputs and 3 levels of internal logic depth as defined in the utility patent application incorporated by reference herein), the present invention does not use tree or DAG (directed acyclic graph) matching. Instead, during logic decomposition, decompositions are chosen for which the logic functions match a cell or brick in the library, as shown in the flow diagram of FIG. 3 .\n\nDAG directed acyclic graph\n\nthe present invention continues iteratively by decomposing any un-decomposed logic, and backtracking as necessary until all logic is decomposed into large function bricks and a few selected logic brick primitives (where percentage of cells that are simple primitives is typically no more than 15% of the total number of cells/bricks).\n\nthe invention further considers that decomposition is coupled with re-composition moves.\n\nLogic recomposition is the opposite of decomposition, during which nodes in the multilevel network are collapsed into their respective fanout nodes.\n\nLogic recomposition/collapse is the process of eliminating factors from a network usually resulting in an increase in complexity of nodes in the network. This creates an opportunity for which more efficient decompositions can be discovered.\n\nrecomposition (termed as eliminate) is driven by a maximum increase in the number of (user specified) literals in the network.\n\nthe number of literals has been shown to roughly represent the complexity of a Boolean network.\n\nU.S. Pat. No. 6,958,545 the recomposition moves are chosen in order to minimize congestion during the physical synthesis (the process of implementing the mask for a circuit netlist including buffer insertion and minor logic changes to accommodate for design constraints).\n\nAn aspect of the present invention with respect to recomposition is that the following two types of sub-networks are considered for recomposition:\n\nFIG. 3 highlights the mapping flow according to the present invention, including the decomposition and recomposition.\n\ncost function for the logic decomposition and optimization are measured in part by:\n\nthe present invention has the following properties that contribute to its novelty:\n\na behavioral, RTL or an unmapped Boolean network is technology mapped to the small library of logic brick components (containing the set of complex functions and the set of simple functions, with the set of complex functions being the non-standard complex Boolean logic functions) using aggressive Boolean operations.\n\nUnmapped Boolean functions in the Boolean network are tested against each Brick in the Brick library for Boolean factoring.\n\nOne way to test for factors is via Boolean division.\n\nthe Boolean network is technology mapped by directly mapping Boolean factors of the nodes in the Boolean network to complex Bricks that correspond to complex, non-traditional logic functions.\n\nSuch aggressive Boolean operations would be of impractical runtime complexity for a large library.\n\nexisting methods e.g.\n\nSIS A System for Sequential Circuit Synthesis. Robert K. Brayton Alberto Sangiovanni-Vincentelli et. al, EECS, University of California, Berkeley) employ algebraic factoring or weak division during the technology independent stage prior to technology mapping to reduce the complexity of the Boolean network before mapping the network to a standard cell library.\n\neach unmapped node in the Boolean network is mapped to bricks until all the nodes in the network get mapped.\n\nF Boolean function\n\nIs support-reducing bound-sets\n\nthe cost function can be designed to achieve a certain area-timing and/or power tradeoff.\n\nthe brick, Bb, that minimizes the cost function is chosen to decompose F (See FIG. 5 ) into a network that has a Boolean function f being driven by the brick Bb.\n\nM(f) is the number of literals in the minimized SOP (sum-of-products) form of the composition function (f).\n\nthe composition function is a Boolean function which represents the decomposed node in terms of the decomposition functions (factors).\n\nthe minimization can be carried out by a literal based minimization tool such as Espresso (See SIS: A System for Sequential Circuit Synthesis. Robert K. Brayton Alberto Sangiovanni-Vincentelli et. al, EECS, University of California, Berkeley).\n\nthe area(Bb) is the area foot-print of the brick B.\n\nthe normalization factor ( â ) depends on the actual area foot-prints of cells in the target brick library.\n\nX 1 is the set of pins in the bound set.\n\nthe criticality of a pin is defined as the minimum slack that each input has with respect to some output.\n\nthe weighting factors â and â are adjusted for trading-off timing and area.\n\nthe cost function biases the algorithm towards the selection of bricks with bound set inputs that are not critical.\n\nLandscapes\n\nEngineering & Computer Science (AREA)\n\nComputer Hardware Design (AREA)\n\nPhysics & Mathematics (AREA)\n\nTheoretical Computer Science (AREA)\n\nEvolutionary Computation (AREA)\n\nGeometry (AREA)\n\nGeneral Engineering & Computer Science (AREA)\n\nGeneral Physics & Mathematics (AREA)\n\nDesign And Manufacture Of Integrated Circuits (AREA)\n\nAbstract\n\nA method and system is described for mapping a system-level description of an integrated system directly to a technology-specific set of logic cells that are comprised primarily of large complex cells (bricks). The invention is based on applying aggressive Boolean operations that would be of impractical runtime complexity for a large library, but are applicable for the targeted brick libraries which typically contain a small number of complex cells, along with a much smaller number of simple cells. This invention is modular such that it can be applied in the context of incremental netlist optimization as well as optimization during physical synthesis.\n\nDescription\n\nRELATED APPLICATIONS\n\nThis application is a continuation of U.S. patent application Ser. No. 11/627,930 filed Jan. 26, 2007 entitled âA Method And System For Mapping A Boolean Logic Network To A Limited Set Of Application-Domain Specific Logic Cellsâ, which is a continuation-in-part of U.S. patent application Ser. No. 11/619,587 filed Jan. 3, 2007 entitled âMethod For The Definition Of A Library Of Application-Domain-Specific Logic Cellsâ, and claims priority to U.S. Provisional Application No. 60/883,332 filed Jan. 3, 2007 entitled âA Method and System For Grouping Logic In An Integrated Circuit Design To Minimize Number Of Transistors And Number Of Unique Geometry Patterns,â all of which are expressly incorporated by reference herein.\n\nBACKGROUND OF THE INVENTION\n\n1. Field of the Invention\n\nThe present invention is related to integrated circuit design, and, more particularly, a method and system for mapping a Boolean logic network to a limited set of application-domain specific logic cells.\n\n2. Field of the Related Art\n\nTypical integrated circuit design environments make use of libraries of pre-designed standard cells (a cell library) which usually consist of from 500 cells to more than 1,000 cells. These libraries are composed of a number of simple, generic and standard logic functions that have been implemented in a form suitable for manufacturing. Each standard cell is a representation, typically the mask level representation, of the circuit that performs the logic function for that cell.\n\nThe logic functions performed by the cells in a typical cell library are intentionally general purpose and basic and the majority of them represent common, low-level logic functions such as AND, OR, XOR, AND-OR-INVERT (AOI), Multiplexer, Adder, etc. These are functions are representative of patterns that are recognized by logic designers, and those that are used as the building blocks for manual logic design. Full custom logic design at the transistor level can sometimes include complex AOI functions that are identifiable from their logic description, such as:\n\n(Ä+ b)(c+d)\n\nBut such functions are typically not included in standard cell libraries, and not representative of specific basic building blocks that are known to logic designers. Instead, they are more likely to be custom designed at the transistor level as an AOI gate.\n\nIn a typical integrated circuit (IC) design flow an IC design is translated to logic gates. In most cases this translation is performed by an automatic logic synthesis tool to derive a netlist based on a set of the aforementioned generic logic functions. This translation is often necessary as there are many different methods in common use for design specification. Those methods may include specification using a high-level programming language such as Verilog, VHDL or C or by manually entering schematics using a computer-aided design system.\n\nAs a high level language cannot be directly implemented into the physical layout of an integrated circuit, it is first converted to a gate level implementation. The result of the conversion is a representation of the design called a gate level netlist. This representation is usually in the form of simple logic functions such as NAND, NOR, etc. along with a representation of the connections between functions (the netlist).\n\nAutomatic logic synthesis tools are then generally used to bind a design to an implementation, based on a set of manufacturing technology specific logic cells from a cell library. The synthesis tool selects cells from the library based on a set of implementation goals that may include any combination of metrics related to area, performance or power and possibly manufacturing yield, to obtain a cell-based netlist. Logic synthesis, as is known, is generally the process of transformation of an RTL or a Boolean network such that its functionality is not altered into a form that is aligned for technology mapping.\n\nWithin the context of the conventional design flow as described above, techniques for optimization using regularity extraction have been proposed for designs dominated by datapaths, which are formed by a small number of repeating logic elements (or bit slices) that are interconnected in a very organized pattern, and other regular circuit structures including RAMs, PLAs, array multipliers etc. For such designs, identifying repeating regularity in circuits simplifies the effort required via synthesis, optimization and layout. However, such regularity extraction techniques rely on the assumption that the designs inherently have within them a high degree of regularity. For example, most of these techniques use information such as bus names and datapath features such as high-fanout control nets to identify repeating structures, such as bit slices. These techniques do not apply, therefore, to more general design flows and logic descriptions that are without such organization and repetition. Also, these techniques to identify repeating regularity do not modify the underlying structural or functional topology of the circuit, which further makes them ineffective for generalized logic and random logic applications.\n\nIn light of the above background, the typical commercial flow that is used in mapping a Boolean network to a set of technology-specific standard cell gates, is shown in FIG. 1. A Boolean network can be represented by a directed acyclic graph where each node is a Boolean function of one of three types: a primary input, internal, output. A Boolean network may not contain a directed cycle. Each internal node in a Boolean network represents a Boolean function of its fanins. A Boolean network may contain internal nodes with arbitrarily large number of fanins. The Boolean network is first decomposed into a subject graph (a graph which represents the design independent of a specific technology or library using simple logic primitives (most commonly AND and INV) to form the technology-independent netlist. Subsequently, the subject graph is then typically mapped to a cell library using structural/Boolean matching followed by binate covering against pre-stored patterns representing the cells in the library. As the cells in the library get more complex, the matching complexity increases exponentially. Moreover, this method suffers from a structure bias; i.e, the mapping quality is dependent on the subject graph structure which is often derived with little knowledge of the characteristics of the target cell library.\n\nSUMMARY OF THE INVENTION\n\nThe present invention relates to mapping a Boolean logic network to a limited set of application-domain specific logic cells.\n\nIn one aspect, a method and system is described for mapping a system-level description of an integrated system directly to a technology-specific set of logic cells that are comprised primarily of large complex cells (bricks). The invention is based on applying aggressive Boolean operations that would be of impractical runtime complexity for a large library, but are applicable for the targeted brick libraries which typically contain a small number of complex cells, along with a much smaller number of simple cells. This invention is modular such that it can be applied in the context of incremental netlist optimization as well as optimization during physical synthesis.\n\nIn a particular aspect, there is described a method of mapping a behavioral, RTL or unmapped Boolean network to a small library of logic components to represent the network as different ones of the logic components that are connected together. The method includes obtaining the behavioral, RTL or unmapped Boolean network; identifying the small library of logic components, the small library of logic components including a set of complex functions and a set of simple functions, wherein the set of complex functions includes a plurality of non-standard complex Boolean logic functions and wherein substantially all of the plurality of non-standard complex Boolean logic functions each have at least three inputs, and wherein the set of simple logic functions, together with the set of complex functions, can together completely specify the network; and mapping the network to the small library of logic components using aggressive Boolean operations to obtain a mapped network, wherein the mapping includes directly mapping large functions from the network to different ones of the non-standard complex Boolean logic functions without the large functions from the network being decomposed, wherein most of the network is mapped to certain ones of the plurality of non-standard complex Boolean logic functions.\n\nSUMMARY OF THE DRAWINGS\n\nThese and other aspects and features of the present invention will become apparent to those of ordinary skill in the art upon review of the following description of specific embodiments of the invention in conjunction with the accompanying figures, wherein:\n\nFIG. 1 illustrates a typical commercial flow that is used in mapping a Boolean network to a set of technology-specific standard cell gates.\n\nFIG. 2 illustrates an overview of the present invention;\n\nFIG. 3 illustrates a flowchart of the direct brick mapping according to the present invention.\n\nFIG. 4 illustrates a flow diagram for incremental netlist optimization according to the present invention.\n\nFIG. 5 illustrates decomposition of a node according to the present invention.\n\nDETAILED DESCRIPTION OF THE PREFERRED EMBODIMENTS\n\nA method and system are described to map a behavioral level (a functional description level for which the mapping to the final state machine is not specified. There is no description of how the variables map to circuit memory elements), RTL or system-level logic netlist to a small library of logic components (no fewer than 5 and no more than 50 unique logic functions). One intended application of this invention is to leverage the unique advantages offered by small libraries of application-domain specific logic bricks, such as described in U.S. application Ser. No. 11/619,587 filed Jan. 3, 2007 and entitled âMethod For The Definition Of A Library Of Application-Domain-Specific Logic Cells,â referred to previously.\n\nIC design with increased regularity for manufacturabilty can incur a penalty in terms of area and performance. It is important, therefore, to exploit this regularity with circuits and methodologies that can overcome some or all of these penalties. Exploiting the large logic functions that are grouped for macro-regularity to maximize the logic utilization on the chip can provide a significant improvement in both area and performance. Improvements in IC area and performance are of great commercial value and all IC application domains. The present invention addresses this.\n\nSpecifically, this invention describes a logic synthesis method to map a behavioral, RTL or system-level logic netlist to a library that is primarily composed of bricks or large logic cells (typically having 6-12 inputs, with substantially all of the large logic cells having at least 3 inputs). Our method takes advantage of the property that the brick library has a small number of cells compared to typical commercial standard-cell libraries that can contain hundreds or thousands of cells, as described in the previously referenced application.\n\nIn contrast to the conventional commercial flow that is used in mapping a Boolean network to a set of technology-specific standard cell gates, the present invention starts by directly mapping a Boolean network onto a target library without any need for decomposition into a subject graph. Decomposition is the process of simplifying nodes by identifying and adding new Boolean nodes (with smaller number of fanins) to the network. In general, most decomposition algorithms work by choosing a factor and re-expressing the network in terms of that new factor and iterating until no new factors are found. This is achieved by direct decomposition of Boolean nodes into cells/bricks. Since a Boolean network can contain internal nodes with arbitrarily large number of fanins, the general method of decomposition attempts to simplify such nodes by identifying and adding new Boolean nodes (with smaller number of fanins) to the network. In general, the prior art for decomposition algorithms are based on choosing a factor and re-expressing the network in terms of that new factor and iterating until no new factors are found.\n\nThis general set of decomposition techniques for logic optimization and technology mapping (the process of transforming a circuit netlist into a network of interconnected components/cells of a given library. By means of technology mapping, a design can be targeted to a design style such as standard cells, FPGAs or gate arrays) have evolved with the development of standard cell-based design methodology. As a result, they are very specific to optimization of standard cells, and do not work well for large cells or bricks. The complexity of the cells in a brick library (also referred to as library that includes a set of complex functions includes a plurality of non-standard complex Boolean logic functions that are each derived from the identified logic function patterns of the recurring Boolean logic chains in the utility application incorporated by reference above) is considerably higher than those of typical standard cells, and the number of cells in a brick library (typically 5-50) is less than in a typical standard cell library (typically 700-2000). As described in more detail in the utility application incorporated by reference, efficiency with a small cell library is sometimes obtained by generating the library to be application specific, or application domain specific. Based on the outlined differences, existing methods used for binding a system level (e.g. RTL) description to a specific technology library are inefficient for brick libraries.\n\nFor example, the complexity of typical matching algorithms used during the matching stages of technology mapping grows exponentially with the number of inputs of the cells in the target technology library. A target technology library is one have a collection of cells that perform primitive Boolean logic functions in a specific technology or a design style. Further, logic decomposition and multi-level optimization are separate steps from technology mapping with very little interaction. Since a brick library has limited functionality, it provides for an opportunity to tightly couple these steps while having a tractable complexity of the computation. Although, there is work (see E. Lehman et al, âLogic decomposition during technology mappingâ, IEEE Trans. CAD, 16(8), 1997, pp. 813-833) that proposes a technique that combines algebraic decomposition with technology mapping, it is based on tree-matching onto a mapping graph, and thus suffers from structure bias. Further, the mapping graph does not scale with the size-complexity of Boolean functions, thereby making it impractical for application to libraries of bricks or large cells.\n\nFIG. 2 illustrates an overview of the present invention, which takes as inputs the Boolean network to be technology mapped, the limited library of bricks (potentially derived for a specific application-domain) and a set of design constraints that describe the area as well as delay goals. The input Boolean network might be one that is obtained from the register transfer level (RTL) description of a circuit after performing some technology independent optimization. This Boolean network is then technology mapped via decomposition and recomposition to bricks, as described hereinafter, following the design constraints and specifications.\n\nOne aspect of the uniqueness of the present invention is that each cell and its precise characteristics are considered while performing logic synthesis. This is not possible during decomposition to standard cells due to the small cell sizes and the overwhelmingly complex number of possible decompositions due to the number of unique logic cells.\n\nSince bricks are by definition dominated by large complex cells (cells with at least 3 inputs and 3 levels of internal logic depth as defined in the utility patent application incorporated by reference herein), the present invention does not use tree or DAG (directed acyclic graph) matching. Instead, during logic decomposition, decompositions are chosen for which the logic functions match a cell or brick in the library, as shown in the flow diagram of FIG. 3.\n\nThe present invention continues iteratively by decomposing any un-decomposed logic, and backtracking as necessary until all logic is decomposed into large function bricks and a few selected logic brick primitives (where percentage of cells that are simple primitives is typically no more than 15% of the total number of cells/bricks). The invention further considers that decomposition is coupled with re-composition moves. Logic recomposition is the opposite of decomposition, during which nodes in the multilevel network are collapsed into their respective fanout nodes. Logic recomposition/collapse is the process of eliminating factors from a network usually resulting in an increase in complexity of nodes in the network. This creates an opportunity for which more efficient decompositions can be discovered. In the university software tool SIS, (See SIS: A System for Sequential Circuit Synthesis. Robert K. Brayton Alberto Sangiovanni-Vincentelli et. al, EECS, University of California, Berkeley), recomposition (termed as eliminate) is driven by a maximum increase in the number of (user specified) literals in the network. The number of literals has been shown to roughly represent the complexity of a Boolean network. For example in U.S. Pat. No. 6,958,545 the recomposition moves are chosen in order to minimize congestion during the physical synthesis (the process of implementing the mask for a circuit netlist including buffer insertion and minor logic changes to accommodate for design constraints). An aspect of the present invention with respect to recomposition is that the following two types of sub-networks are considered for recomposition:\n\n1. Sub-networks that match a cell or brick in the library, including the large complex bricks that are not found in standard cell libraries. This is achieved by structural or Boolean matching.\n\n2. Sub-networks that are heuristically estimated to be efficiently decomposable into cells/bricks after re-composition.\n\nFIG. 3 highlights the mapping flow according to the present invention, including the decomposition and recomposition.\n\nAn important aspect of this invention is that the cost function for the logic decomposition and optimization are measured in part by:\n\nPlacement information (if applied during physical synthesis)\n\nWireload estimates (when applied during frontend synthesis)âstatistical wireloads\n\nTiming, area and power characteristics of the bricks\n\nThe present invention has the following properties that contribute to its novelty:\n\n1. A method to directly transform an RTL/Unmapped Boolean network into a technology-specific design representation that is defined by a library of 5 to 50 cells (brick), with 85% or more of those cells corresponding to large complex logic functions of at least 3 inputs and at least 3 levels of logic. An unmapped Boolean network is a Boolean network where the implementation of nodes in a specific technology is not defined. The functionality of each node is defined abstractly. e.g. using the sum of products form.\n\n2. A method to directly transform an RTL/Unmapped Boolean network into a cell (brick) level Boolean network based on a target cell (brick) library using Boolean decomposition.\n\n3. The method in 2 for which the direct mapping further facilitates the optimization of specific attributes (e.g. Area, Delay, Power) during decomposition that would otherwise be impractical with a larger library.\n\n4. The RTL/Unmapped Boolean network described in 1 might have been obtained in any of the following ways\n\na. Human designed\n\nb. Logic collapsed/re-composed from a gate level implementation which might have undergone logic synthesis and/or physical synthesis\n\nc. Created via behavioral synthesis\n\n5. The target brick library in 1 contains characterization data for the bricks that provides metrics for the targeted design attributes in 1. This data can also be derived during the processes described in the present invention using the process for transistor-level optimization described in the provisional application incorporated be reference herein. The Boolean functions of the bricks are derived as described in the utility application incorporated by reference herein.\n\n6. The transformation in 1 is performed by iteratively using the following procedures, of which at least one takes the target brick library into account:\n\na. Decomposition of nodes in the Boolean network\n\nb. Re-composition of nodes in the Boolean network\n\n7. The decomposition in 6.a computes the cost function of various potential decomposition choices and performs the decomposition using the best choice. The cost function calculation uses the data in the target brick library using one of the following methods:\n\na. Heuristic (Area and/or delay and/or power) estimation of the composition and/or the decomposition function when it is fully or partially implemented by the cells in the target library. A decomposition function is a candidate Boolean function (factor) that may be added to the network during decomposition.\n\nb. Exact (Area and/or delay and/or power) computation by recursively implementing the composition and/or decomposition function using the method in 1.\n\nc. Exact (Area and/or delay and/or power) computation by matching the composition and/or decomposition function to a brick in the target Brick library.\n\nFurther, the decomposition can be of type disjoint or non-disjoint.\n\n8. The decomposition in 7 also considers the possibility of sharing the decomposition functions (Bricks from the target brick library) as factors among multiple Boolean nodes in the network.\n\n9. Re-composition in 6.b evaluates the re-composition choices at a node and performs re-composition using the best choice. The cost function calculation takes the target brick library into account by calculating the cost function of the resulting collapsed Boolean function in one of the following ways:\n\na. Heuristic (Area and/or delay and/or power) estimation of the collapsed function when it is fully or partially implemented by the cells in the target library.\n\nb. Exact (Area and/or delay and/or power) computation by recursively implementing the collapsed function using the method in 1.\n\nc. Exact (Area and/or delay and/or power) computation by matching the collapsed function to a Brick in the target Brick library.\n\n10. The transformation procedure in 1 can be applied in the context of incremental optimization of a netlist. This can be done by selectively highlighting a sub-network and then remapping it using the procedure in 1. A flow-chart of this process is shown in FIG. 4.\n\n11. The process in 9 can be applied to perform incremental optimization on the gate level netlist after some physical prototyping or full physical synthesis. In this case the cost function in 7 & 8 are evaluated using the information from the physical prototype/implementation, e.g. placement co-ordinates, wire loads, etc.\n\nThe following illustrates certain particular aspects of the mapping process that are unique in the context of the present invention.\n\nA behavioral, RTL or an unmapped Boolean network is technology mapped to the small library of logic brick components (containing the set of complex functions and the set of simple functions, with the set of complex functions being the non-standard complex Boolean logic functions) using aggressive Boolean operations. Unmapped Boolean functions in the Boolean network are tested against each Brick in the Brick library for Boolean factoring. One way to test for factors is via Boolean division. In this manner, the Boolean network is technology mapped by directly mapping Boolean factors of the nodes in the Boolean network to complex Bricks that correspond to complex, non-traditional logic functions. Such aggressive Boolean operations would be of impractical runtime complexity for a large library. In contrast, existing methods (e.g. SIS: A System for Sequential Circuit Synthesis. Robert K. Brayton Alberto Sangiovanni-Vincentelli et. al, EECS, University of California, Berkeley) employ algebraic factoring or weak division during the technology independent stage prior to technology mapping to reduce the complexity of the Boolean network before mapping the network to a standard cell library.\n\nReferring to FIG. 3, each unmapped node in the Boolean network is mapped to bricks until all the nodes in the network get mapped. For example, referring to FIG. 5, we can consider starting with a Boolean function F (of an unmapped node) being technology mapped and derive all the support-reducing bound-sets (Is) of F, where the cardinality of each bound-set is less than N (N is the maximum number of inputs for any cell in the target brick library). Next, each brick in the target library is evaluated using each bound-set in Is to evaluate a cost function.\n\nThe cost function can be designed to achieve a certain area-timing and/or power tradeoff. The brick, Bb, that minimizes the cost function is chosen to decompose F (See FIG. 5) into a network that has a Boolean function f being driven by the brick Bb. An example of a cost function that can be used to optimize the area of the mapped circuit:\n\nC=M(f)+Î±Ãarea(Bb)\n\nwhere, M(f) is the number of literals in the minimized SOP (sum-of-products) form of the composition function (f). The composition function is a Boolean function which represents the decomposed node in terms of the decomposition functions (factors). The minimization can be carried out by a literal based minimization tool such as Espresso (See SIS: A System for Sequential Circuit Synthesis. Robert K. Brayton Alberto Sangiovanni-Vincentelli et. al, EECS, University of California, Berkeley). The area(Bb) is the area foot-print of the brick B. The normalization factor (Î±) depends on the actual area foot-prints of cells in the target brick library.\n\nAnother example of a cost function which trades-off between area and delay is:\n\nC=M(f)+_Î±Ãarea(B)+Î²_ÃMax(Criticality(X1))\n\nhere, X1 is the set of pins in the bound set. The criticality of a pin is defined as the minimum slack that each input has with respect to some output. The weighting factors Î± and Î² are adjusted for trading-off timing and area. The cost function biases the algorithm towards the selection of bricks with bound set inputs that are not critical.\n\nIn order to further optimize for area, we perform logic sharing (factoring) of the decomposition functions (Bricks) as follows. While evaluating the cost function during the selection of a brick, Bb, during decomposition of node F, other nodes in the neighborhood of F area considered for decomposition using the same brick. The selection of bricks which can form factors, as opposed to decompositions, is biased by the cost function for area.\n\nThe foregoing detailed description of the invention has been presented for purposes of illustration and description. It is not intended to be exhaustive or to limit the invention to the precise form disclosed. Many modifications and variations are possible in light of the above teaching. The described embodiments were chosen in order to best explain the principles of the invention and its practical application to thereby enable others skilled in the art to best utilize the invention in various embodiments and with various modifications as are suited to the particular use contemplated.\n\nClaims (7)\n\n1. A network of interconnected logic components embodied in a tangible medium, said network created, at least in part, by mapping a behavioral, RTL or unmapped Boolean network to a cell-level netlist description of an integrated circuit, said cell-level netlist description comprising logic components selected from a small library of logic components having no more than 50 unique logic functions, said mapping further comprising the steps of:\n\nusing a computer system to select components from the small library of logic components having no more than 50 unique logic functions for inclusion in the cell-level netlist description of the integrated circuit;\n\nthe small library of logic components including a set of complex functions and a set of simple functions, wherein the set of complex functions includes a plurality of non-standard complex Boolean logic functions and wherein substantially all of the plurality of non-standard complex Boolean logic functions each have at least three inputs; and\n\ndirectly mapping large functions from the network to different ones of the non-standard complex Boolean logic functions, wherein said direct mapping includes testing said unmapped functions against each complex function in the library using at least one of Boolean factoring and Boolean division, and wherein most of the network is mapped to certain ones of the plurality of non-standard complex Boolean logic functions.\n\n2. The network of claim 1, wherein the step of mapping further includes the steps of:\n\ndecomposing other functions from the network;\n\nsubsequently recomposing other large functions using the decomposed other functions; and,\n\nfurther mapping at least some of the recomposed large functions directly to different ones of the non-standard complex Boolean logic functions.\n\n3. The network of claim 1, wherein the step of mapping maps functions from the network that do not correspond to the non-standard complex Boolean logic functions using the simple functions from the small library.\n\n4. The network of claim 1, wherein the mapping uses a cost function.\n\n5. The network of claim 4, wherein the cost function is affected by placement information.\n\n6. The network of claim 4, wherein the cost function is affected by wireload estimates.\n\n7. The network of claim 4, wherein the cost function is affected by at least one of timing, area and power characteristics of each of the non-standard complex Boolean logic functions.\n\nUS12/835,675 2007-01-03 2010-07-13 Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells Active - Reinstated US8082529B2 (en)\n\nPriority Applications (1)\n\nApplication Number Priority Date Filing Date Title US12/835,675 US8082529B2 (en) 2007-01-03 2010-07-13 Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells\n\nApplications Claiming Priority (4)\n\nApplication Number Priority Date Filing Date Title US88333207P 2007-01-03 2007-01-03 US11/619,587 US7784013B2 (en) 2007-01-03 2007-01-03 Method for the definition of a library of application-domain-specific logic cells US11/627,930 US7757187B2 (en) 2007-01-03 2007-01-26 Method for mapping a Boolean logic network to a limited set of application-domain specific logic cells US12/835,675 US8082529B2 (en) 2007-01-03 2010-07-13 Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells\n\nRelated Parent Applications (1)\n\nApplication Number Title Priority Date Filing Date US11/627,930 Continuation US7757187B2 (en) 2007-01-03 2007-01-26 Method for mapping a Boolean logic network to a limited set of application-domain specific logic cells\n\nPublications (2)\n\nPublication Number Publication Date US20100281450A1 true US20100281450A1 (en) 2010-11-04 US8082529B2 US8082529B2 (en) 2011-12-20\n\nFamily\n\nID=39585875\n\nFamily Applications (2)\n\nApplication Number Title Priority Date Filing Date US11/627,930 Expired - Fee Related US7757187B2 (en) 2007-01-03 2007-01-26 Method for mapping a Boolean logic network to a limited set of application-domain specific logic cells US12/835,675 Active - Reinstated US8082529B2 (en) 2007-01-03 2010-07-13 Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells\n\nFamily Applications Before (1)\n\nApplication Number Title Priority Date Filing Date US11/627,930 Expired - Fee Related US7757187B2 (en) 2007-01-03 2007-01-26 Method for mapping a Boolean logic network to a limited set of application-domain specific logic cells\n\nCountry Status (1)\n\nCountry Link US (2) US7757187B2 (en)\n\nCited By (1)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title WO2014120209A1 (en) * 2013-01-31 2014-08-07 Empire Technology Development, Llc Masking power usage of co-processors on field-programmable gate arrays\n\nFamilies Citing this family (7)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title JP4444732B2 (en) * 2004-05-25 2010-03-31 å¯å£«éãã¤ã¯ã­ã¨ã¬ã¯ãã­ãã¯ã¹æ ªå¼ä¼ç¤¾ Library generation method and library generation program US7840915B2 (en) * 2006-02-01 2010-11-23 The Trustees Of Columbia University In The City Of New York Methods and media for forming a bound network US7945868B2 (en) * 2007-10-01 2011-05-17 Carnegie Mellon University Tunable integrated circuit design for nano-scale technologies US8176449B1 (en) * 2010-03-11 2012-05-08 Xilinx, Inc. Inference of hardware components from logic patterns US9659123B2 (en) 2014-10-17 2017-05-23 21, Inc. Systems and methods for flexibly optimizing processing circuit efficiency US10409827B2 (en) 2014-10-31 2019-09-10 21, Inc. Digital currency mining circuitry having shared processing logic US9942046B2 (en) * 2015-05-06 2018-04-10 21, Inc. Digital currency mining circuitry with adaptable difficulty compare capabilities\n\nCitations (9)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US6295636B1 (en) * 1998-02-20 2001-09-25 Lsi Logic Corporation RTL analysis for improved logic synthesis US6470486B1 (en) * 1999-05-26 2002-10-22 Get2Chip Method for delay-optimizing technology mapping of digital logic US6519609B1 (en) * 1998-12-04 2003-02-11 Cadence Design Systems, Inc. Method and system for matching boolean signatures US20030145288A1 (en) * 2002-01-25 2003-07-31 Xinning Wang Method and apparatus for improving digital circuit design US20030233628A1 (en) * 2002-06-17 2003-12-18 Rana Amar Pal Singh Technology dependent transformations in CMOS and silicon-on-insulator during digital design synthesis US6836877B1 (en) * 1998-02-20 2004-12-28 Lsi Logic Corporation Automatic synthesis script generation for synopsys design compiler US6958545B2 (en) * 2004-01-12 2005-10-25 International Business Machines Corporation Method for reducing wiring congestion in a VLSI chip design US20070011643A1 (en) * 2003-09-19 2007-01-11 Cadence Design Systems, Inc. Optimized mapping of an integrated circuit design to multiple cell libraries during a single synthesis pass US20080127000A1 (en) * 2006-05-26 2008-05-29 Open-Silicon, Inc. Method of IC design optimization via creation of design-specific cells from post-layout patterns\n\n2007\n\n2007-01-26 US US11/627,930 patent/US7757187B2/en not_active Expired - Fee Related\n\n2010\n\n2010-07-13 US US12/835,675 patent/US8082529B2/en active Active - Reinstated\n\nPatent Citations (10)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title US6295636B1 (en) * 1998-02-20 2001-09-25 Lsi Logic Corporation RTL analysis for improved logic synthesis US6836877B1 (en) * 1998-02-20 2004-12-28 Lsi Logic Corporation Automatic synthesis script generation for synopsys design compiler US6519609B1 (en) * 1998-12-04 2003-02-11 Cadence Design Systems, Inc. Method and system for matching boolean signatures US6470486B1 (en) * 1999-05-26 2002-10-22 Get2Chip Method for delay-optimizing technology mapping of digital logic US20030145288A1 (en) * 2002-01-25 2003-07-31 Xinning Wang Method and apparatus for improving digital circuit design US20030233628A1 (en) * 2002-06-17 2003-12-18 Rana Amar Pal Singh Technology dependent transformations in CMOS and silicon-on-insulator during digital design synthesis US20060075375A1 (en) * 2002-06-17 2006-04-06 Rana Amar P S Technology dependent transformations for CMOS in digital design synthesis US20070011643A1 (en) * 2003-09-19 2007-01-11 Cadence Design Systems, Inc. Optimized mapping of an integrated circuit design to multiple cell libraries during a single synthesis pass US6958545B2 (en) * 2004-01-12 2005-10-25 International Business Machines Corporation Method for reducing wiring congestion in a VLSI chip design US20080127000A1 (en) * 2006-05-26 2008-05-29 Open-Silicon, Inc. Method of IC design optimization via creation of design-specific cells from post-layout patterns\n\nCited By (2)\n\n* Cited by examiner, â Cited by third party Publication number Priority date Publication date Assignee Title WO2014120209A1 (en) * 2013-01-31 2014-08-07 Empire Technology Development, Llc Masking power usage of co-processors on field-programmable gate arrays US9304790B2 (en) 2013-01-31 2016-04-05 Empire Technology Development Llc Masking power usage of co-processors on field-programmable gate arrays using negative feedback to adjust a voltage variation on an FPGA power distribution trace\n\nAlso Published As\n\nPublication number Publication date US8082529B2 (en) 2011-12-20 US7757187B2 (en) 2010-07-13 US20080163152A1 (en) 2008-07-03\n\nSimilar Documents\n\nPublication Publication Date Title US8082529B2 (en) 2011-12-20 Method and system for mapping a boolean logic network to a limited set of application-domain specific logic cells US8589833B2 (en) 2013-11-19 Method for the definition of a library of application-domain-specific logic cells US7360198B2 (en) 2008-04-15 Technology dependent transformations for CMOS in digital design synthesis US5426591A (en) 1995-06-20 Apparatus and method for improving the timing performance of a circuit US7003738B2 (en) 2006-02-21 Process for automated generation of design-specific complex functional blocks to improve quality of synthesized digital integrated circuits in CMOS using altering process US20030208730A1 (en) 2003-11-06 Method for verifying properties of a circuit model US20050268258A1 (en) 2005-12-01 Rule-based design consultant and method for integrated circuit design US10339243B2 (en) 2019-07-02 Method and apparatus for automatic hierarchical design partitioning US20060225022A1 (en) 2006-10-05 Method, apparatus and program for determining the relationship of correspondence between register transfer level description and behavioral description US20050268268A1 (en) 2005-12-01 Methods and systems for structured ASIC electronic design automation US7409658B2 (en) 2008-08-05 Methods and systems for mixed-mode physical synthesis in electronic design automation EP1145159A3 (en) 2002-07-10 Block based design methodology WO2000072185A2 (en) 2000-11-30 Behavioral-synthesis electronic design automation tool and business-to-business application service provider WO2000019528A1 (en) 2000-04-06 Dram cell system and method for producing same US8904318B1 (en) 2014-12-02 Method and apparatus for performing optimization using don&#39;t care states Baumgartner et al. 2005 Maximal input reduction of sequential netlists via synergistic reparameterization and localization strategies US7451427B2 (en) 2008-11-11 Bus representation for efficient physical synthesis of integrated circuit designs US7287235B1 (en) 2007-10-23 Method of simplifying a circuit for equivalence checking US6516453B1 (en) 2003-02-04 Method for timing analysis during automatic scheduling of operations in the high-level synthesis of digital systems Rashid et al. 2022 Modernizing hardware circuits through high-level synthesis Nijssen et al. 1998 GreyHound: A methodology for utilizing datapath regularity in standard design flows Um et al. 2003 Synthesis of arithmetic circuits considering layout effects US6988252B2 (en) 2006-01-17 Universal gates for ICs and transformation of netlists for their implementation Djunaidy 1992 GARUDA: An Automatic Multi-Level Logic Synthesis and Optimisation System Lin et al. 2004 An efficient approach for hierarchical submodule extraction\n\nLegal Events\n\nDate Code Title Description"
    }
}