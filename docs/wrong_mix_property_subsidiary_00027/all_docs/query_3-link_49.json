{
    "id": "wrong_mix_property_subsidiary_00027_3",
    "rank": 49,
    "data": {
        "url": "https://patents.google.com/patent/US5237514A/en",
        "read_more_link": "",
        "language": "en",
        "title": "US5237514A - Minimizing path delay in a machine by compensation of timing through selective placement and partitioning - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/0b/5e/8a/73dcfc0dc08fc4/US5237514-drawings-page-2.png",
            "https://patentimages.storage.googleapis.com/f3/4d/c8/ee36b49143ae2f/US5237514-drawings-page-3.png",
            "https://patentimages.storage.googleapis.com/1b/11/82/e1fbf73f888629/US5237514-drawings-page-4.png",
            "https://patentimages.storage.googleapis.com/c9/ac/8b/e049322fcde575/US5237514-drawings-page-5.png",
            "https://patentimages.storage.googleapis.com/91/c5/5a/9a9d7a69551b06/US5237514-drawings-page-6.png",
            "https://patentimages.storage.googleapis.com/05/23/7f/0918c522ca1282/US5237514-drawings-page-7.png",
            "https://patentimages.storage.googleapis.com/1f/05/0d/7e8346391a1bc7/US5237514-drawings-page-8.png",
            "https://patentimages.storage.googleapis.com/c7/ae/88/2a511578f7a4b4/US5237514-drawings-page-9.png",
            "https://patentimages.storage.googleapis.com/13/ec/3b/287d79cad59c0c/US5237514-drawings-page-10.png",
            "https://patentimages.storage.googleapis.com/05/d9/50/f13ed09517ba8e/US5237514-drawings-page-11.png",
            "https://patentimages.storage.googleapis.com/82/d8/37/cb5106ef80db07/US5237514-drawings-page-12.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "1990-12-21T00:00:00",
        "summary": "",
        "meta_description": "A method for minimizing cycle time to improve machine performance is described. The approach prioritizes placement and partitioning decisions based on the criticality of paths and their constituent net segments. It provides an initial coarse approximation to a final more optimum configuration by iteratively improving on it through the use of deterministic techniques. The method optimizes placement by means of heuristic algorithms that are based on a cost function that is dependent on net segment and path criticality.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US5237514A/en",
        "text": "FIELD OF THE INVENTION\n\nThis invention relates to minimizing the path delay between circuits by optimizing their placement in an integrated circuit package as a function of path delay criticality thereby improving the cycle time and the performance of a machine.\n\nBACKGROUND OF THE INVENTION\n\nThe speed of complex machines is commonly determined by the time delay of electrical signals through their electronic components. In the process of designing a machine of certain speed, particular attention is given to the critical paths, since they are the ones that determine the machine cycle and help define how fast a machine can run. Attempts to minimize a machine cycle by improving the performance of circuits does not by itself guarantee a faster machine. Other considerations (independent of the functional circuit delay) pertaining to layout, such as chip or floor planning, partitioning, placement and wire routing have played an ever increasing role in the design of machines. As a result, it is not uncommon to find a small number of data paths with excessive delay playing an important role in limiting the machine cycle of a computing machine. Considerable effort has been expended by design practitioners in optimizing data paths by minimizing length so as to reduce wire capacitance and resistance and the distance for a signal to travel.\n\nAn example of how a logic function comprised of a plurality of interconnected blocks may be decomposed into constituent paths, such as signal paths, machine paths, etc., and a determination of relative path delay value extremes for each path is described in U.S. Pat. No. 4,263,651 to W. E. Donath et al and of common assignee.\n\nIn another instance, such as U.S. Pat. No. 4,564,943 to J. C. Collins et al, and of common assignee, delay paths are stressed for their extremes to assist in the characterization of a design that is to be frozen. No attempt, though is made to optimize the overall timing.\n\nIn U.S. Pat. No. 4,698,760 to R. E. Lembach and of common assignee, optimization of the signal timing delay is arrived at by actually altering the circuit block through the selection of different logic book types. This method does not address timing optimization by placement and partitioning methods.\n\nHeuristic techniques which explore the permutation space of all possible block placements must conduct their trial and error search by using a guiding or goal oriented mechanism called `cost` or `objective` function. Several papers in various publications have been published, whereby attempts to minimize the `cost` function have been made:\n\n\"Optimization by Simulated Annealing\", by S. Kirkpatrick, C. D. Gelatt, and M. P. Vecchi, Science, Vol. 220, No. 4598, pp. 671-680. This highlights the connection that exists between statistical mechanics and combinatorial optimization. It discusses the strong analogy with annealing in solids, thus providing a framework for optimizing the properties of very large and complex systems. This approach does not formulate Constructive Placement algorithms for initial placement or address timing optimization of specific critical paths and geometric constraints of path segments. Moreover, it does not provide interactive guidance for defining the assumptions required for initial conditions--such as partitioning boundaries, modelling and optimization of a complete machine.\n\n\"ESP: Placement by Simulated Evolution\", by R. M. Kling and P. Banerjee, IEEE Transactions on Computer-Aided Design of Integrated Circuits & Systems, (1989), Vol 8, No. 3, pp. 245-256 discloses a method which is similar to the previous reference but uses a different heuristic algorithm that involves multiple block relocations as opposed to pair swapping. Even though it is a method of simulating an evolutionary process that effectively minimizes cell interconnection length, it contains the same limitations as the previous approach.\n\n\"Genetic Placement\", by J. P. Cohoon and W. D. Paris, 1986 IEEE Intl. Conference on Computer Aided Design, pp. 422-425, is similar to the two previous approaches and with the same limitations.\n\n\"A new Approach for Solving the Placement Problem using Force Models\", by K. J. Antreich, F. M. Johannes and F. H. Kirsch, IEEE International Symposium on Circuits and Systems, June 1982, pp. 481-486 discloses a Force Model using pair swapping just as in Simulated Annealing and iterates to a solution as in all previously mentioned cases. Its cost function is based on modelling of interconnection's affinities as a function of the forces of attraction and repulsion between blocks until equilibrium is reached. Again, the same limitations are found.\n\n\"Stochastic Evolution: A Fast Effective Heuristic for some Generic Layout Problems\" by Y. G. Saab & V. B. Rao, Proceedings of the 27th Design Automation Conference, 1990, pp. 26-31 is another heuristic technique that seeks faster solution results and better quality than that found in Simulated Annealing. It operates on the principle that states are deemed suitable for survival based on an evaluation by the cost function. Its algorithm includes backtracking of proposed block moves if changes are deemed unsuitable for survival. Once again, the same limitations as previously mentioned are found.\n\nMost importantly, all of the referenced publications collectively attempt to achieve a faster machine solution by minimizing total wiring or capacitance of the nets within a machine architecture. No systematic procedure exists for determining the priority of block placement based on how critical certain signal paths may be or the geometric constriction of their `net segments`. None of the previously described approaches offer an initial placement strategy or guidance to assist in the human decision process where judgement involving partitioning and I/O constraints force certain initial conditions that reside outside the purview of the method of placement. Thus, a faster machine cannot be guaranteed when the algorithms that carry out an optimization are based on total wire, total capacitance or some other summation parameter. One may arrive at a placement scenario which may have the least amount of total wire or capacitance but which results in a slower machine than some other placement with greater wire or capacitance. This can occur when the machine speed is limited by the longest path and not by the largest amount of wire or capacitance.\n\nMost heuristic placement algorithms presently operate with a variety of `cost` or `objective` functions as found in the above described Simulated Annealing and Genetic Placement methods. Some, such as `Min-Cut`, attempt to minimize wire congestion and channel competition by intelligent placement. Others, such as `Bounded Rectangle`, `Concentric Circle`, and `Position Oriented` seek to improve machine cycle and performance by minimizing total wire or total capacitance. These timing directed functions share a common factor in that they are all net oriented, handling all segments of a given net as one net entity.\n\nSUMMARY AND OBJECTS OF THE INVENTION\n\nThe present invention optimizes machine speed by specifically prioritizing a block placement that concurrently addresses the criticality of a path and the restricted degrees of freedom dictated by both the slack and the number of segments (i.e., block-to-block interconnections) in each path. It uses a deterministic process that prioritizes block placement and provides an initial block placement strategy and `hierarchical nesting` of circuit groups that are based on timing requirements. This `hierarchical nesting` can assist the human decision process needed for establishing partitioning boundaries within given I/O constraints.\n\nThe present invention, furthermore, introduces a novel `cost` function by treating each net segment member as a path-weighted entity, and makes a judgement that is based on the prioritized path effects of moving a block placement.\n\nIt is therefore a primary object of this invention to efficiently and economically locate functional blocks for an entire computing machine, preferably comprised of a large number of blocks, so as to achieve minimum cycle time, thus improving or exceeding machine MIPS objectives.\n\nAnother object is to provide a method for creating a `Constructive Initial Placement Seed` for optimizing path delay and minimizing cycle time within long path and short path constraint considerations.\n\nA further object is to provide a method for improving cycle time by optimizing the combined effect of `Functional Work` delay (e.g., logic block\n\n`Communication` delay (e.g., wire connections between blocks dictated by placement, wiring, etc.).\n\nStill another object of the invention is to generate a `cost` function which circumvents `Path Bundling` by executing net evaluation through composite critical path weighting in its quest for minimizing critical paths and machine cycle time.\n\nA more particular object is to provide an improved heuristic placement algorithm similar to the above described Simulated Annealing, Genetic Placement and Simulated Evolution to achieve optimum logic block placement.\n\nYet a further object is to foster a better human understanding and interactive participation in the design optimization process and, more particularly, in fostering intelligent decisions regarding initial conditions which reside outside the purview of the placement procedure.\n\nThese and other objects are achieved by use of the present invention which is: a method for minimizing path delay and optimizing machine cycle by identifying all the `net segments` comprising the machine and prioritizing them in accordance to their relative importance; achieving an initial coarse approximation to the final optimum configuration based on relative `net segment` criticality; improving this initial approximation to a final optimum configuration by assigning a cost function to those `net segments` based on the previously determined relative `net segment` criticality; and using the cost function to achieve an improved configuration by heuristic means.\n\nBRIEF DESCRIPTION OF THE DRAWINGS\n\nThe advantages of this invention will be apparent from the following and more particular description of the preferred embodiment as illustrated in the accompanying drawings, in which:\n\nFIG. 1 is a flow diagram of the process required for creating a `Constructive Initial Placement Seed` and generating a `Path Slack Dependent Cost` function in order to minimize path delay and optimize the cycle time of a machine;\n\nFIGS. 2A-2K are an illustrative example of the various steps starting from initialization of the path definition through the establishment of a `net segment` hierarchy (`ascendency` rule);\n\nFIGS. 3A and 3B show an example of `net coagulation` via the `solitaire` procedure;\n\nFIG. 4 is an example of a `net segment` hierarchy partitioned by growth order leading to nested levels, their representation including level subsets;\n\nFIGS. 5A-5D illustrate the `aggregation` and `accretion` sequences;\n\nFIGS. 6A-6D are an example of how partitioning can be factored into the calculation of the slack function, thus providing a more effective evaluation of a given design alternative; and\n\nFIGS. 7A-7C are an example how to measure `goodness` in the process of optimizing in the presence of `path bundling`.\n\nDESCRIPTION OF THE PREFERRED EMBODIMENT\n\nThe broad, overall concepts for minimizing path delay between circuits to improve cycle time and performance of a computing machine may be better understood by subdividing the proposed methodology in two major subdivisions: 1) an initial approximation to a path definition, and 2) optimizing the path defined.\n\nInitial Approximation\n\nA single data path of excessive delay can limit the cycle time of a machine. As a result, combinatorial optimization techniques that optimize solutions for aggregate `cost` or `objective` functions (e.g., `total wire` minimization) do not directly address the problem of minimizing cycle time. Even objectives such as `total path delay` may be improper because a path delay distribution with low `total` and low accumulated average (i.e., mean) but with uncharacteristic 2 and 3 sigma members, is less effective than a distribution with higher `total` and nominal value, but with smaller deviation and shorter `longest path`. Whereas it is generally true that minimizing `total wire` length and, consequently, `average path delay` may lead to a faster cycle time, it is also true that violations of this rule by intelligent fluctuation may produce an even faster cycle.\n\nAssuming no ability to change the logic block delay (i.e., designs for which the path `functional work` delay is given), the remaining area of design flexibility is the `net segment` delay (also referred to as `communication delay`) which is dictated by placement, routing, etc. Accordingly, the wire length flexibility can be expressed as:\n\nCycle Time-Functional Work Delay=Path Slack.\n\nThus, for a critical path,\n\nWire Delayâ§Path Slack,\n\nwhereas for a fast path,\n\nWire Delayâ§Race Time Requirement.\n\nAny `averaging` technique measures total or accumulated behavior of the ensemble of paths, and is only inferentially related to the problem. Aggregate path behavior does not dictate cycle speed, only the slowest paths do. Thus any of the combinatorial optimization techniques that are chosen, whether Simulated Annealing, Genetic Placement, Simulated Evolution, etc., will require a careful definition of the optimized `target parameter`.\n\nThe process flow of a prioritized placement of blocks leading to an optimized design is shown in FIG. 1. Block 100, `initialize path definition` contains an equation definition for each machine path, where the path delay is equal to the sum of all functional block member delays and all `net segment` delays (FIG. 2a). For each functional block member listed in the path definition, an appropriate block delay field is retrieved. For each `net segment` member, the corresponding source and destination names (also referred to as `come from` and `go to` blocks) are listed as variables.\n\nAn initial placement `seed` procedure does not require an exhaustive, complex or highly accurate approximation of the final optimum. Such algorithms are so time consuming and cost prohibitive that they are unrealizable in actual practice. An implementable `seed` solution will only succeed if a set of powerful simple rules can be devised that accomplish the desired net slack to block location tailoring required to meet the machine path delay target. Accordingly, rules must be discovered that are simple in terms of computation and sufficiently powerful that they appropriately reflect the complexity of path interaction requirements and net slack tailoring in the positioning and partitioning of the blocks.\n\nThe ultimate object is, therefore, to minimize the slowest path contribution and, in the process, to tighten up the slack distribution of the ensemble of paths by placement compensation. This is achieved by generating an equation for each path such that it expresses the path slack in terms of net slack contribution to the path. The set of path equations is then solved for the slack values of the `net segments` and the values are used to construct an initial placement seed position for Simulated Annealing, Simulated Evolution, Genetic Placement, etc, equation. The equation is solved while carefully monitoring the `target parameter`, namely, the one that emphasizes minimum slack on the critical paths. Thus, the path equation is as follows:\n\ny.sub.1 =kx.sub.1 +kx.sub.2 +kx.sub.3 +. . . +kx.sub.n\n\nwhere, y=path slack, x=`net segment slack`, and k=contribution or presence factor.\n\nAccordingly, a set of equations is generated representing all the paths: ##EQU1##\n\nEach `path slack` is now expressed as a function of its `net segment` member length:\n\nS.sub.1 =f (NS.sub.1 +NS.sub.3 +NS.sub.4 +NS.sub.8 +NS.sub.12),\n\nwhere:\n\nS1 is the path slack for path 1;\n\nNS1 the `net segment` 1, etc., to be followed by expressing each `net segment` in terms of its source and destination blocks:\n\nNS.sub.1 =A/B, NS.sub.2 =B/G, NS.sub.3 =G/F, NS.sub.4 =F/N, NS.sub.5 =N/R,\n\nsuch that S1=A/B+B/G+G/F+F/N+N/R.\n\nSolving this set of equations will give a per `net segment` delay or slack contribution which will adjust all path delays to approach their desired values. This per `net segment` delay factor can be translated into a block placement tag for Simulated Annealing placement algorithms. The matrix of simultaneous equations is large in that its x dimension is a set equal to the number of blocks in the machine, while its y dimension is equal to the number of paths in the machine--a generally much larger number.\n\nRent's Rule states that \"the circuits in a typical system can be connected with short-range interactions if they are imbedded in a space that exists between two or three dimensions\".\n\nIt is evident that, in view of Rent's Rule, the matrix is sparce with most `net segments` having their own individual degrees of freedom constrained solely by the path slack aggregate delay--the sum of `net segment's` delay in path'slack, and path interaction, whereby, pinning of some other path by the mutual sharing of one or more of the same segments occurs. If there is no pinning, the matrix degenerates into a listing of independent equations with no interactions. If all the paths share all `net segments`, the matrix becomes full and potentially solvable by overdetermined regression techniques which are readily known to one skilled in the art.\n\nThe matrix of equations usually fails to yield a unique or overdetermined approximate solution space, since so much `freedom of action` exists in the placement of `net segments` in spite of the partial pinning that links the paths. It is however, possible to generate a placement seed by `equipartition` and substitution techniques without having to manipulate any matrix steps by supercomputer algorithms.\n\nHaving deleted all the `functional work` delays leaving only the `net segment` delays, a `path slack` target is then defined (FIG. 1, block 101). As mentioned, the `path slack` is defined as the difference between cycle time and the sum of all path member block delays.\n\nIn the next step, an `equipartition` list (block 102) is created by determining the total count of the `net segments` contained in the Path Slack Definition for each path in the list and, preferably, dividing each path slack by this number. It is evident that other forms of division could have been advantageously used, such as dividing by N1/3 to reflect non-linear geometric constraints. A file is then created with fields for each `net segment` and equipartition value. It is also evident that multiple paths can pass through any given block-to-block `net segment`. If each path is analyzed independently during `equipartition` as it also is intended, different values will arise for the multi-path `net segments` based on the timing needs of each distinct path through that segment. A comparison is then made for multiple values of `net segments` with the same name by searching the list for multiple occurrences and by comparing values and accepting the lowest one.\n\nWith the `net segment` list created in this manner, each `net segment` name appears only once. The accepted value is placed in the field associated with the corresponding `net segment` name.\n\nThe next step `establish net segment length hierarchy` (block 103) essentially creates a `net segment` timing priority list by means of the `ascendency` procedure. Thereby, `net segments` are ordered in ascending order as a function of individual delay values and implicit length.\n\nDuring the execution of this procedure, particular care should be taken to avoid placing unrelated or loosely coupled pairs near one another. Moreover, placing all short delay `net segments` first, without regard to `associativity`, is too simplistic. It may eventually lead to consuming valuable real estate by juxtaposing short nets that have only `remote` interconnection closure with one another. Therefore, it has been found to be more advantageous to first establish a measure of `familial closeness` to help prioritize layout by establishing `centers-of-growth` and placement proliferation around those centers. No inherent intelligence or capability exists in a hierarchy based on `distance-between-blocks` to establish `familial closeness` for `centers-of-growth`. Moreover, the technique of hierarchical placement tends to imply a single proliferating point source for placement and wiring. It is unlikely that such an approach will provide an optimum solution for a single chip, and it is certain that such an approach will be inadequate for a multi-chip partitioned function. From this discussion, it becomes evident that what is needed is a placement seed which represents--not a single proliferating source point--but many source points that represent many chips or regions of growth in a chip. This `slack net hierarchy` can be used advantageously to generate such a seed.\n\nHaving properly prioritized the `net segment` timing, a list of multiple nested `net segments` is created by the next step, `solitaire` procedure, (block 104, FIG. 1) which modifies the placement `solitaire` procedure is based on net `coagulation`. Starting from the `shortest` nets in the `distance-between-blocks` hierarchy, groups are columnized in a manner similar to playing solitaire. Every net connection comprised of its two blocks (source and destination) is represented by a pair of letters or symbols (e.g., x,y). With each succeeding entry, the following questions are asked:\n\nDoes the first symbol appear in a list?\n\nDoes the second symbol appear in a list?\n\nIf the answer is (no, no), then this pair becomes the first entry in a new list.\n\nIf the answer is (yes,no) or viceversa, then this pair is added to the existing matched list;\n\nIf the answer is (yes,yes), then this pair is added to one of the matching lists, and the matching lists are merged.\n\nThis procedure tends to produce multiple lists which are independent of one another up to a net length arrived via the (yes,yes) decision of the `net segment` pair. For some applications, the lists may not be of equal length or adequate number. This is particularly true in cases that require multiple partitions of roughly equal size (e.g., chips). In such instances, a simple net coagulation is insufficient and further intelligence is required. Intelligent manipulation of the lists may be achieved by list merging rules as well as by block `rating` rules, all of which are readily known and available to one skilled in the art.\n\nSudden link up of `centers-of-growth` in the `solitaire` procedure is accommodated by the `ascendency` rule. As `centers-of-growth` accumulate circuit count, they can be visualized as ever-expanding regions of population, with ever-increasing radii. The sudden link-up of two such groups, by net connections somewhere within them, requires a new `net segment` whose length is somewhere between one unit and the sum of group's A radius and group's B radius, (asserting that no other links exist between them at this point). If nets were to be listed and processed randomly in terms of their length, a short `net segment` requirement between the two `centers-of-growth` might demand a very small net connection at a point where the two radii made this impossible. By using the `ascendency` rule, the net connection link-ups deliver longer connections in the same order in which they are geometrically required.\n\nAn Example\n\nTo further illustrate the methodology defined thus far, reference is made to FIGS. 2 through 6.\n\nShown in FIG. 2a is a simple logic arrangement consisting of 13 interconnected blocks having I1, I2 and I3 as inputs, and O1, O2 and O3 as outputs. Each total path delay is comprised of path member block delays and of `net segment` delays. The first step of the inventive methodology `initialize path definition` (block 100, FIG. 1) requires a listing of all the paths which complete some work function in a clock cycle. The inputs and outputs represent cycle initiation and termination points for the paths shown.\n\nReferring now to FIG. 2b, to the right of each path are the number of blocks in each path. Within a given cycle time, each path is graphically represented by a unit block delay of every block in the path, leaving the previously defined slack as the balance of the cycle time (FIG. 2c). The next step calls for `removing functional delays` (block 101, FIG. 1) leaving only the `net segment` delays, as graphically shown in FIG. 2d. Particular attention is drawn to each `net segment` which is expressed by its source and destination variables.\n\nIn order to better understand and appreciate the `equipartition` rule (block 102, FIG. 1), a matrix is formed comprised of as many rows as there are paths and as many columns as there are `net segments`. The pertinent elements of the matrix are given either `P`, for each `pinned net segment` or `X`, for each `free net segment` (FIG. 2e). Under the `equipartition rule`, each slack is divided by the corresponding number of `net segments` (FIG. 2f) and each `net segment` is then individually assigned the resulting `net segment` value.\n\nThe multiple `net segment` delay values derived from the `equipartition` rule are then set to the smallest calculated value for each `pinned` segment and appropriate substitution is made wherever that segment appears (FIG. 2g).\n\nListed in FIG. 2h are the slacks for each `net segment`.\n\n`Net segments` are prioritized next by means of the `ascendency` rule (block 103, FIG. 1), whereby the net slack sequence is ordered in ascending order (FIG. 2i). If the actual placement of blocks results in precisely the same `net segment` slack values, the path delays shown in FIG. 2j will then result.\n\nFrom the discussion on the `ascendency` rule it is evident to those skilled in the art that the key point is not the projected path delay values but rather understanding the `equipartition` rule whereby the smallest value for a `pinned` segment guarantees that the most crucial `net segments` (i.e., block placements) will be handled first through the `ascendency` rule for `net segment` listing. This, in turn, guarantees that a path will receive placement priority and attention proportional to their timing criticality. Thus, pivotal block placements affecting the most critical nets will be given highest priority.\n\nMore specifically, each `net segment` will have a delay factor attached to it that can be used to generate a `distance between blocks` hierarchy for generating a placement seed. This leads to a typical block representation, as shown in FIG. 2k, where the numbers shown represent units of length or units of delay.\n\nA seed placement may start by placing all short `net segments` delays required first. Thus, the blocks connected by these nets would be seeded locally first. Longer length segment member blocks would be placed next, etc. Conflicts arising between long and short requirements for a single block would be addressed by the Annealing algorithm to achieve minimum energy, which in this case is the difference between the desired net delay and the actual placement delay.\n\nFIG. 3a shows a new reduced list of `net segments` arranged in increasing order of `slack value` in accordance with the previously described `ascendency` rule. From it, the `solitaire` procedure is applied defining a natural partitioning that leads to the formation of a plurality of growth centers (FIG. 3b).\n\nUpon completion of the execution of the aforementioned procedures, a `prioritized placement` with a nested hierarchical structure will have been established.\n\nThis allows for reconstructing and analyzing the whole process of `accretion` and `aggregation` (FIG. 4) as the CPU logic mass develops. The nested hierarchy offers a guide to the development of natural boundary choices while, simultaneously, providing the necessary information about the I/O count and integration size of any given partition choice.\n\nThe dynamic sequence of growth center accretion and center-to-center aggregation may be captured and preserved in a coded structure. If growth centers are attributed and merging operations are catalogued in an indexed hierarchy, a road map or tree-structure of the developing logic mass will emerge.\n\nThe nested groupings (i.e., growth centers) within the `ascendency` hierarchy the evolution of the developing logic mass. It symbolizes dynamic partitioning due to the fact that specific groups are growing independently from one another until the first connection which merges that specific set of groupings is achieved. From that point on, the merged groups are treated as one larger group (FIG. 4).\n\nThe `ascendency` sequence listing provides the order in which groups are merged. Together, the nesting and list sequence provide a history of the evolution of `aggregation` and `accretion`.\n\nIndexing helps the `timing compensation placement` (TCP) process in two areas:\n\n1) Partitioning, whereby the tree-structured hierarchy of levels will allow I/O interconnect evaluations for different partition strategies and integration sizes. As partitions are modified, the I/O's will automatically change to reflect the moving boundaries. Interconnection counts among all partitioned entities are available to estimate signal I/O requirements as well as I/O interconnection delay requirements vs. chip partitioning and positioning.\n\n2) Placement, whereby group-to-group placement prioritization is provided by the `solitaire` and link-up procedures.\n\nThe `nested sequence` can best be understood by referring to FIG. 5, wherein an example of a `net segment` hierarchy partitioned by growth order is shown, (FIG. 5a), leading to the indexed growth history (FIG. 5b); from it, to a plurality of nested levels (FIG. 5c), and finally to a representation of plural levels and corresponding subsets of those levels (FIG. 5d).\n\nThe rectangular blocks, referred to as `growth centers`, contain a plurality of sets of logic block connections (i.e., `net segments`) based on path criticality timing requirements and associativity.\n\n`Aggregation` occurs when a `net segment` links logic blocks members which reside in two previously independent growth center's groups. With this new `net segment` the two groups are suddenly linked and merged in the nested hierarchy. As shown in FIG. 5, a new `net segment` has linked a block in group 1 to a block in group 4. As a result, group 4 is now merged with group 1. Finally, `accretion`, the method for adding additional `net segment` members to an existing growth center is symbolically and pictorially demonstrated in FIG. 4 by the widening of rectangles (growth center), blocks 6 and 8.\n\nAccordingly, it has been established how to initiate a suitable initial placement based on the steps thus far described in FIG. 1, block 106. As the process flow diagrams indicate, the prioritized placement procedure can be followed by a preliminary design assessment of the most appropriate partition boundary choices. These choices can be inserted into the model and a new prioritized placement hierarchy established.\n\nReferring now to block 105 in FIG. 1, the prioritized placement procedure is followed by a preliminary assessment of the most appropriate partitioning boundary choices. These choices can be taken into account by establishing a new placement hierarchy without resorting to any physical placement of blocks. This is true because the `ascendency/nesting hierarchy` allows first-pass deductions without regard to geometric placement decisions. These considerations allow modelling an idealized placement which lacks partitioned boundaries. This is particularly well suited as a starting point for an analysis of the design process. More particularly, it allows a designer to assess in approximate form, the impact of placement within the constraints of a two-dimensional (planar) space. The master grid placement of blocks within a predefined x,y coordinate system results in a delay factor for each segment connected to the blocks. These net segment delays lead to path delays. A designer may thusly obtain an approximate feeling for his path delay distribution to assess the `time-of-flight` penalties associated with planar distances thereby assessing the impact of various partition boundary choices on the path delays. In this manner, the effect of planar design can be segregated from those of partitioning. Upon completion of the placement procedure the `net segment` values can be retrieved from the Placement File and inserted in the path equation to predict the actual delay.\n\nReferring now to the feedback paths, blocks 109, 110 and 111 in FIG. 1, various alternatives can be exercised depending on the course of action set by the results of the placement evaluation (blocks 105 or 108). If partitioning is allowed, a certain slack reduction will result from:\n\n1) assigning a special partition output driver delay value to each set of blocks which are partition boundary choices, (Note: a block can represent a chip, module, card, etc. The delay characteristics are altered to account for a block chosen as a driver or receiver), and\n\n2) assigning a special value to the `net segments` that link partitions at the next level.\n\nIn the case of an unpartitioned path, the path slack was equally divided among the segment members to achieve a first-pass priority approximation for placement. This so-called `equipartition` approximation may require alteration for the partitioned path case. Although all `net segment` delays are a function of the distance between blocks, the difference between the distribution of `net segments` within a partition and the distribution of `net segments` between partitions is radically different.\n\nProvisions can be made so that partition choices can automatically change internal blocks to partition drivers, and their block delay to driver delay. Altered delay values of the selected driver blocks will permit new path slack calculations and new `net segment` `ascendency` hierarchies. The new `net segment` list sequence may then result in an altered `solitaire` procedure result and a new placement.\n\nFor the I/O `net segments`, a new delay value can be calculated based on the positions of the partitions and the resulting `come from/go to` master grid coordinates. This length, coupled to a module net delay multiplier, enables the construction of new path delay values based on the `net segment` delays and block delays of all members of each path.\n\nFIG. 6a illustrates an unpartitioned path whereby, for illustration purposes, the functional blocks are set equal to each other, leaving a path slack independent of any partition.\n\nThe same path is shown in FIG. 6b with the exception that slack path is reduced as a result of partitioning. Additional delay is added to the functional block that corresponds to a partition driver, which in turn reduces the path slack.\n\nThe mean (average) distance for the distribution of on-chip net segments is measured in cell pitches. The mean (average) distance for the distribution of chip-to-chip `net segments` is measured in chip pitches.\n\nBy way of illustration, FIG. 6c shows a distribution of the `net segments` alterations as a function of length (e.g., transit time). The curve shows two clusters, one centering around Mi that corresponds to the intra-chip distribution and the other centering around Me that corresponds to the inter-chip distribution.\n\nReferring now to FIG. 6d, in the unpartitioned case, the path slack is equally divided among all `net segments` (a result of applying the equipartition rule. Thus the total `net segment` slack is just the total slack divided by the number of `net segments`. In the partitioned case, (after reducing the total path slack by the amount corresponding to the delay associated with special circuits), the altered `equipartitioned` slack is modified where appropriate by the additional chip-to-chip considerations, thus providing a more realistic picture of the `net segment` topology. It is evident that in the instance of excessive chip-to-chip delay assigned by the partitioning to various `net segments`, an unacceptably small reduced slack may remain to be divided among the `net segments` left on the path, thus invalidating the design. This can prove to be a very effective tool for a designer in his quest for an optimized distribution.\n\nAt this point, the requirement for recalculating the net segment priority becomes necessary and is achieved by the `altered equipartition`.\n\nA means for accounting for the difference between internal and external `net segments` would be to generate an expression for the external `net segments` which approximates their length (time delay) in internal `net segment` equivalents. Thus, the partition boundary `net segments` are re-expressed as an equivalent number of internal `net segments`. This allows for executing the original `equipartition` procedure in a more realistic division of the path slack apportionments (FIG. 6D). Thus, a new `ascendency` hierarchy is established for prioritized placement. This prioritized placement is accomplished without physical placement of the blocks. When the physical placement is undertaken, the actual `net segment` delays may be calculated from equations which determine the length from the x,y coordinate information of the physical placement.\n\nReferring again to block 111, the x,y unpartitioned placement may contain most of the partitioning impact within it. The x,y placements and distances of the unpartitioned layout can correspond to the same distances that a partitoned external net would have. The alterations of the delay are primarily due to:\n\n1) the increased delay of the driver block that will decrease the available path slack, and\n\n2) the added distance of the chip border when the chips are not `brick-walled` on the module. These can be expressed as:\n\nBorder=chip pitch-chip size.\n\nIt is evident to those familiar with the art, that it is possible to model an idealized placement without partitioned boundaries. Although it may be unrealistic, nonetheless, it is an excellent starting point for analyzing the design process. It allows a designer to assess in approximate form, the impact of placement within the constraints of a two-dimensional (i.e., planar) space.\n\nThe `master grid` placement of blocks within a given x,y coordinate system results in a timing delay factor for each net segment connected to the blocks. These `net segment` delays, in turn, result in path delay. The designer should get an approximate feeling for this path delay distribution to assess the `time-of-flight` penalties associated with planar distance, and to assess the impact of various choices of partition boundaries on the path delays. In this manner, it becomes feasable to separate the effects of planar design from those of partitioning.\n\nOptimization: Path Slack Dependent `Cost` Function\n\nCompletion of the initial physical placement by means of the previously described steps (blocks 100 through 106) leads to the required optimization portion of the inventive methodology.\n\nCombinatorial optimization heuristic techniques have been developed with a variety of `cost` or `objective` functions to guide the exploration through the design space. A number of early iterative techniques made use of an evaluation criteria that accepted only rearrangements leading `downhill`, i.e., that improved the cost function. Such searches usually converged on a local optimum, but rarely on a global optimum. Succeeding refinements to the `cost` function allowed for the probabilistic acceptance of `uphill` as well as `downhill` moves, allowing the algorithmic procedure to avoid becoming stuck at a local minimum.\n\nPractitioners of this art have advantageously used the concept of `energy` in a Boltzmann's acceptance analog to statistical mechanics. Thus, the usual iterative improvement techniques that utilize combinatorial optimization and statistical mechanics apply the Bolzmann Temperature factor equally to all placements at a given `temperature`. This permits an equal `degree of freedom` for all block placements, which is gradually reduced as the `temperature` is reduced and the placement stabilizes.\n\nIt is the intention of this methodology to disproportionately restrict the freedom of the longest path, while at the same time maximizing the overall placement freedom by allowing the non-critical nets to maneuver within their wider design space. Thus, a modified criteria could be established in which Boltzmann compare would be net criticality dependent. Under such criteria, a placement that reduces the `energy` would be accepted, whereas if it would increase the `energy`, its acceptance would be based on the probability of a random number being less than the value of the Bolzmann's function of the form exp (-E/kS), whereby the new variable S is path dependent and a function of the slack of the path. As an example:\n\nS=TÃ(cycle time/slack),\n\nwhere T is the `temperature` variable.\n\nThus, placements that increase path delay for the more restricted nets, i.e., the longer `critical` nets, would most probably be rejected, whereas, placements that increase path delay for the less restricted nets would have a higher probability of being accepted. This is true because it is possible for them to increase their delay up to a point of accommodating physical placement requirements without impacting cycle time (set by the critical nets).\n\nThis `priority based on criticality` methodology attempts to minimize the longest path delay and not the average path delay (e.g., total wire or total capacitance). Since in general, long paths contain a large number of functional blocks, the path definition results in the smallest slack time divided over a large number of net segments. Consequently, these paths have highly restricted degrees of placement freedom because of their limited `net segment` length, and the number of `net segments` which must lie in proximity of one another. Moreover, since placement freedom is not symmetric, expansion will end with better probability of success than contraction. Thus, the longest paths with the shortest slack are given the highest priority in placement.\n\nThis technique can be considered global (also referred to as machine wide because the relative freedom of placement (or acceptance) is based on the criticality of all paths, `nets segments`, etc., of all the circuits that comprise the machine.\n\nOptimization in the presence of `Path Bundling`\n\nThe application of `cost` functions, which essentially treats a net as the entity to be examined, may create `path bundling`, whereby path `net segments` are grouped together and analyzed in aggregates. This transformation converts sets of distinct path-identified `net segments` into a pseudo-delay variable to be called `net`. A disadvantage of this approach is the conversion of specific path analysis capabilities into a technique for delay averaging.\n\nCritical path `net segment` requirements end up being analyzed in conjunction with the combined statistics of non-critical `net segment` members of the same `net`. Thus, the analysis is conducted at a more abstract level, whereby less total wire, less net capacitance, etc., are considered as being better.\n\nPreviously, the preferred placement introduced was path dependent, with the measure of acceptance or `goodness` based on a path slack value. To successfully achieve this goal, it is necessary that, in the process of optimizing a block placement, the analysis include changes in multiple paths. In the `constructive initial placement` procedure and block placement hierarchy this was not a problem, because the `ascendency` list--which dictates the order of placement criticality--was based on `net segments`. Thus, it was possible to separate path effects from one another during the process of placing blocks.\n\n`Placement optimization` procedures differ in that, prior to optimization, all tentative blocks and `net segment` connections must already be in place. Thus, any block placement change and evaluation involves all the `nets segments` connected to the block being moved (i.e., the entire net). As a result, a number of path delays will be simultaneously affected by that single block movement. It is, therefore, evident that some criterium must be established to analyze the composite `goodness` of positive and negative path delay impacts resulting from repositioning of blocks.\n\n`Goodness` can be measured by attempting to incorporate:\n\n1) a comparison criterium based on previous values, longest paths and cycle time, and\n\n2) prioritizing a path dependence based on `criticality`.\n\n`Goodness` can be quantified by the following sequence of steps:\n\n1) Defining net and block changes in term of `net segments` and paths;\n\n2) Assigning a `criticality` value to each path and `net segment` in the various lists based on path slack or `net segment` criticality assigned by the `ascendency` list priority order, i.e., position based on `ascendency`;\n\n3) Coding the `criticality` value previously defined by binary weight indexing (e.g., 20, 21, 22, . . . 2n etc.), with the most critical path assigned to the most significant digit. For example, the most critical net would have an indexed weight of 2n and the least critical net segment, an index weight of 20 ;\n\n4) Letting a symbol, such as a binary number, e.g., a `+` (defined as a 1) show improved `goodness` (i.e., shorter path, . . . and a `-` (defined as a 0) show deteriorated `goodness` (e.g., longer path, . . . );\n\n5) Coding the composite path results in ascending binary numbers, and basing acceptance on the composite weight of the binary number translation.\n\nThis technique can be viewed as local because the relative freedom of placement (or acceptance) depends on criticalities (path slack/`net segment` slack) which are based only on `net segments` participating in the net under consideration.\n\nBy way of example, a net comprised of three `net segments` is shown in FIG. 7a, whereby:\n\nNET1=NS(A)+NS(A)+NS(C)\n\nThree possible paths are shown in FIG. 7B with their respective slack, `criticality` and assigned indexes weight, and the ensuing `composite acceptance weight` for each of the paths and placement results (FIG. 7C).\n\nIn summary, a method has been described that provides timing compensation placement and partitioning, advantageously creating means for producing:\n\n1) An initial constructive placement seed for `heuristic` optimization techniques;\n\n2) Improved `Cost` Functions for minimized cycle times based on the timing criticality of `net segments`; and\n\n3) Means for intelligent involvement in the `fast machine` solution process by allowing interaction, intervention and decision making to machine partitioning, book placement, chip geometries, package configurations, etc.\n\nWhile the present invention has been particularly shown and described with reference to a preferred embodiment, it will be understood by those skilled in the art that the foregoing and other changes in form or detail, such as altering the `cost` function definitions in the Annealing and Genetic procedures, may be made herein without departing from the spirit or scope of the invention."
    }
}