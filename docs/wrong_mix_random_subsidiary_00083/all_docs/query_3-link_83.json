{
    "id": "wrong_mix_random_subsidiary_00083_3",
    "rank": 83,
    "data": {
        "url": "https://patents.google.com/patent/US11436296B2/en",
        "read_more_link": "",
        "language": "en",
        "title": "US11436296B2 - Method of and system for inferring user intent in search input in a conversational interaction system - Google Patents",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://patentimages.storage.googleapis.com/ef/25/b0/79c7709ea01cb0/US11436296-20220906-D00000.png",
            "https://patentimages.storage.googleapis.com/cb/12/8c/0e56c4db9188a9/US11436296-20220906-D00001.png",
            "https://patentimages.storage.googleapis.com/3f/e8/f1/4f5299ea9651ea/US11436296-20220906-D00002.png",
            "https://patentimages.storage.googleapis.com/a5/f8/2f/b08506d429dd6e/US11436296-20220906-D00003.png",
            "https://patentimages.storage.googleapis.com/c3/f0/93/354602d54379db/US11436296-20220906-D00004.png",
            "https://patentimages.storage.googleapis.com/02/b1/54/1963ef1f964241/US11436296-20220906-D00005.png",
            "https://patentimages.storage.googleapis.com/2c/aa/79/e4a87d28de698e/US11436296-20220906-D00006.png",
            "https://patentimages.storage.googleapis.com/56/29/2b/ac1407507d6082/US11436296-20220906-D00007.png",
            "https://patentimages.storage.googleapis.com/13/a9/7c/7341b0227c2845/US11436296-20220906-D00008.png",
            "https://patentimages.storage.googleapis.com/a8/a5/d7/c7728c380f6eeb/US11436296-20220906-D00009.png",
            "https://patentimages.storage.googleapis.com/b0/03/09/47f2bcda70ccbd/US11436296-20220906-D00010.png",
            "https://patentimages.storage.googleapis.com/bb/97/46/4e76ab1c0052de/US11436296-20220906-D00011.png",
            "https://patentimages.storage.googleapis.com/81/75/9c/455a7b16017b3e/US11436296-20220906-D00012.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2012-07-20T00:00:00",
        "summary": "",
        "meta_description": "A method of inferring user intent in search input in a conversational interaction system is disclosed. A method of inferring user intent in a search input includes providing a user preference signature that describes preferences of the user, receiving search input from the user intended by the user to identify at least one desired item, and determining that a portion of the search input contains an ambiguous identifier. The ambiguous identifier is intended by the user to identify, at least in part, a desired item. The method further includes inferring a meaning for the ambiguous identifier based on matching portions of the search input to the preferences of the user described by the user preference signature and selecting items from a set of content items based on comparing the search input and the inferred meaning of the ambiguous identifier with metadata associated with the content items.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://patents.google.com/patent/US11436296B2/en",
        "text": "CROSS-REFERENCE TO RELATED APPLICATIONS\n\nThis application is a continuation of U.S. patent application Ser. No. 15/228,847, filed Aug. 4, 2016 (allowed), which is a continuation of U.S. patent application Ser. No. 13/667,400, filed Nov. 2, 2012, now U.S. Pat. No. 9,424,233, which claims the benefit under 35 U.S.C. Â§ 119(e) to U.S. Provisional Patent Application No. 61/673,867 entitled A Conversational Interaction System for Large Corpus Information Retrieval, filed on Jul. 20, 2012, and U.S. Provisional Patent Application No. 61/712,721 entitled Method of and System for Content Search Based on Conceptual Language Clustering, filed on Oct. 11, 2012, the contents of each of which are incorporated by reference herein.\n\nBACKGROUND OF THE INVENTION Field of Invention\n\nThe invention generally relates to conversational interaction techniques, and, more specifically, to inferring user input intent based on resolving input ambiguities and/or inferring a change in conversational session has occurred.\n\nDescription of Related Art\n\nConversational systems are poised to become a preferred mode of navigating large information repositories across a range of devices: Smartphones, Tablets, TVs/STBs, multi-modal devices such as wearable computing devices such as âGogglesâ (Google's sunglasses), hybrid gesture recognition/speech recognition systems like Xbox/Kinect, automobile information systems, and generic home entertainment systems. The era of touch based interfaces being center stage, as the primary mode of interaction, is perhaps slowly coming to an end, where in many daily life use cases, user would rather speak his intent, and the system understands and executes on the intent. This has also been triggered by the significant hardware, software and algorithmic advances making text to speech significantly effective compared to a few years ago.\n\nWhile progress is being made towards pure conversation interfaces, existing simple request response style conversational systems suffice only to addresses specific task oriented or specific information retrieval problems in small sized information repositoriesâthese systems fail to perform well on large corpus information repositories.\n\nCurrent systems that are essentially request response systems at their core, attempt to offer a conversational style interface such as responding to users question, as follows:\n\nUser: What is my checking account balance?\n\nSystem: It is $2,459.34.\n\nUser: And savings?\n\nSystem: It is $6,209.012.\n\nUser: How about the money market?\n\nSystem: It is $14,599.33.\n\nThese are inherently goal oriented or task oriented request response systems providing a notion of continuity of conversation though each request response pair is independent of the other and the only context maintained is the simple context that it is user's bank account. Other examples of current conversational systems are ones that walk user through a sequence of well-defined and often predetermined decision tree paths, to complete user intent (such as making a dinner reservation, booking a flight etc.)\n\nApplicants have discovered that understanding user intent (even within a domain such as digital entertainment where user intent could span from pure information retrieval, to watching a show, or reserving a ticket for a show/movie), combined with understanding the semantics of the user utterance expressing the intent, so as to provide a clear and succinct response matching user intent is a hard problem that present systems in the conversation space fall short in addressing. Barring simple sentences with clear expression of intent, it is often hard to extract intent and the semantics of the sentence that expresses the intent, even in a single request/response exchange style interaction. Adding to this complexity, are intents that are task oriented without having well defined steps (such as the traversal of a predetermined decision tree). Also problematic are interactions that require a series of user requests and system responses to get to the completion of a task (e.g., like making a dinner reservation). Further still, rich information repositories can be especially challenging because user intent expression for an entity may take many valid and natural forms, and the same lexical tokens (words) may arise in relation to many different user intents.\n\nWhen the corpus is large, lexical conflict or multiple semantic interpretations add to the complexity of satisfying user intent without a dialog to clarify these conflicts and ambiguities. Sometimes it may not even be possible to understand user intent, or the semantics of the sentence that expresses the intentâsimilar to what happens in real life conversations between humans. The ability of the system to ask the minimal number of questions (from the point of view of comprehending the other person in the conversation) to understand user intent, just like a human would do (on average where the participants are both aware of the domain being discussed), would define the closeness of the system to human conversations.\n\nSystems that engage in a dialog or conversation, which go beyond the simple multi-step travel/dinner reservation making (e.g., where the steps in the dialog are well defined request/response subsequences with not much ambiguity resolution in each step), also encounter the complexity of having to maintain the state of the conversation in order to be effective. For example, such systems would need to infer implicit references to intents and entities (e.g., reference to people, objects or any noun) and attributes that qualify the intent in user's sentences (e.g., âshow me the latest movies of Tom Hanks and not the old ones; âshow me more action and less violence). Further still, applicants have discovered that it is beneficial to track not only references made by the user to entities, attributes, etc. in previous entries, but also to entities, attributes, etc. of multi-modal responses of the system to the user.\n\nFurther still, applicants have found that maintaining pronoun to object/subject associations during user/system exchanges enhances the user experience. For example, a speech analyzer (or natural language processor) that relates the pronoun âitâ to its object/subject âLed Zeppelin songâ in a complex user entry, such as, âThe Led Zeppelin song in the original sound track of the recent Daniel Craig movie . . . Who performed it?â assists the user by not requiring the user to always use a particular syntax. However, this simple pronoun to object/subject association is ineffective in processing the following exchange:\n\nQ1: Who acts as Obi-wan Kenobi in the new star wars?\n\nA: Ewan McGregor.\n\nQ2: How about his movies with Scarlet Johansson?\n\nHere the âhisâ in the second question refers to the person in the response, rather than from the user input. A more complicated example follows:\n\nQ1: Who played the lead roles in Kramer vs. Kramer?\n\nA1: Meryl Streep and Dustin Hoffman.\n\nQ2: How about more of his movies?\n\nA2: Here are some of Dustin Hoffman movies . . . [list of Dustin Hoffman movies].\n\nQ3: What about more of her movies?\n\nHere the âhisâ in Q2 and âherâ in Q3 refer back to the response A1. A natural language processor in isolation is ineffective in understanding user intent in these cases. In several of the embodiments described below, the language processor works in conjunction with a conversation state engine and domain specific information indicating male and female attributes of the entities that can help resolve these pronoun references to prior conversation exchanges.\n\nAnother challenge facing systems that engage a user in conversation is the determination of the user's intent change, even if it is within the same domain. For example, user may start off with the intent of finding an answer to a question, e.g., in the entertainment domain. While engaging in the conversation of exploring more about that question, decide to pursue a completely different intent path. Current systems expect user to offer a clear cue that a new conversation is being initiated. If the user fails to provide that important clue, the system responses would be still be constrained to the narrow scope of the exploration path user has gone down, and will constrain users input to that narrow context, typically resulting undesirable, if not absurd, responses. The consequence of getting the context wrong is even more glaring (to the extent that the system looks comically inept) when user chooses to switch domains in the middle of a conversation. For instance, user may, while exploring content in the entertainment space, say, âI am hungryâ. If the system does not realize this as a switch to a new domain (restaurant/food domain), it may respond thinking âI am hungryâ is a question posed in the entertainment space and offer responses in that domain, which in this case, would be a comically incorrect response.\n\nA human, on the other hand, naturally recognizes such a drastic domain switch by the very nature of the statement, and responds accordingly (e.g., âShall we order pizza?â). Even in the remote scenario where the transition to new domain is not so evident, a human participant may falter, but quickly recover, upon feedback from the first speaker (âOh no. I mean I am hungryâI would like to eat!â). These subtle, yet significant, elements of a conversation, that humans take for granted in conversations, are the ones that differentiate the richness of human-to-human conversations from that with automated systems.\n\nIn summary, embodiments of the techniques disclosed herein attempt to closely match user's intent and engage the user in a conversation not unlike human interactions. Certain embodiments exhibit any one or more of the following, non-exhaustive list of characteristics: a) resolve ambiguities in intent and/or description of the intent and, whenever applicable, leverage off of user's preferences (some implementations use computing elements and logic that are based on domain specific vertical information); b) maintain state of active intents and/or entities/attributes describing the intent across exchanges with the user, so as to implicitly infer references made by user indirectly to intents/entities/attributes mentioned earlier in a conversation; c) tailor responses to user, whenever applicable, to match user's preferences; d) implicitly determine conversation boundaries that start a new topic within and across domains and tailor a response accordingly; e) given a failure to understand user's intent (e.g., either because the intent cannot be found or the confidence score of its best guess is below a threshold), engage in a minimal dialog to understand user intent (in a manner similar to that done by humans in conversations to understand intent.) In some embodiments of the invention, the understanding of the intent may leverage off the display capacity of the device (e.g., like a tablet device) to graphically display intuitive renditions that user could interact with to offer clues on user intent.\n\nBRIEF SUMMARY OF THE INVENTION\n\nIn an aspect of the invention, a method of and system for inferring user intent in search input in a conversational interaction system is disclosed.\n\nIn another aspect of the invention, a method of inferring user intent in a search input based on resolving ambiguous portions of the search input includes providing access to a set of content items. Each of the content items is associated with metadata that describes the corresponding content item. The method also includes providing a user preference signature. The user preference signature describes preferences of the user for at least one of (i) particular content items and (ii) metadata associated with the content items. The method also includes receiving search input from the user. The search input is intended by the user to identify at least one desired content item. The method also includes determining that a portion of the search input contains an ambiguous identifier. The ambiguous identifier being intended by the user to identify, at least in part, the at least one desired content item. The method also includes inferring a meaning for the ambiguous identifier based on matching portions of the search input to the preferences of the user described by the user preference signature and selecting content items from the set of content items based on comparing the search input and the inferred meaning of the ambiguous identifier with metadata associated with the content items.\n\nIn a further aspect of the invention, the ambiguous identifier can be a pronoun, a syntactic expletive, an entertainment genre, and/or at least a portion of a name.\n\nIn still another aspect of the invention, the metadata associated with the content items includes a mapping of relationships between entities associated with the content items.\n\nIn yet a further aspect of the invention, the user preference signature is based on explicit preferences provided by the user and/or is based on analyzing content item selections by user conducted over a period of time. Optionally, the user preference signature describes preferences of the user for metadata associated with the content items, the metadata including entities preferred by the user.\n\nIn another aspect of the invention, a method of inferring user intent in a search input based on resolving ambiguous portions of the search input includes providing access to a set of content items. Each of the content items is associated with metadata that describes the corresponding content item. The method also includes receiving search input from the user. The search input is intended by the user to identify at least one desired content item. The method also includes determining whether or not a portion of the search input contains an ambiguous identifier. The ambiguous identifier being intended by the user to identify, at least in part, the at least one desired content item. Upon a condition in which a portion of the search input contains an ambiguous identifier, the method includes: inferring a meaning for the ambiguous identifier based on matching portions of the search input to preferences of the user described by a user preference signature, selecting content items from the set of content items based on comparing the search input and the inferred meaning of the ambiguous identifier with metadata associated with the content item, and, upon a condition in which the search input does not contain an ambiguous identifier, selecting content items from the set of content items based on comparing the search input with metadata associated with the content items.\n\nAny of the aspects listed above can be combined with any of the other aspects listed above and/or with the techniques disclosed herein.\n\nBRIEF DESCRIPTION OF THE SEVERAL VIEWS OF THE DRAWINGS\n\nFor a more complete understanding of various embodiments of the present invention, reference is now made to the following descriptions taken in connection with the accompanying drawings in which:\n\nFIG. 1 illustrates a user interface approach incorporated here for elucidative purposes.\n\nFIG. 2 illustrates a user interface approach incorporated here for elucidative purposes.\n\nFIG. 3 illustrates a user interface approach incorporated here for elucidative purposes.\n\nFIG. 4 illustrates a user interface approach incorporated here for elucidative purposes.\n\nFIG. 5 illustrates a user interface approach incorporated here for elucidative purposes.\n\nFIG. 6 illustrates an example of a graph that represents entities and relationships between entities.\n\nFIG. 7 illustrates an example of a graph that represents entities and relationships between entities.\n\nFIG. 8 illustrates an example of a graph that represents entities and relationships between entities.\n\nFIG. 9 illustrates an example of a graph that represents entities and relationships between entities.\n\nFIG. 10 illustrates an architecture that is an embodiment of the present invention.\n\nFIG. 11 illustrates a simplified flowchart of the operation of embodiments of the invention.\n\nFIG. 12 illustrates a control flow of the operation of embodiments of the invention.\n\nDETAILED DESCRIPTION\n\nPreferred embodiments of the invention include methods of and systems for inferring user's intent and satisfying that intent in a conversational exchange. Certain implementations are able to resolve ambiguities in user input, maintain state of intent, entities, and/or attributes associated with the conversational exchange, tailor responses to match user's preferences, infer conversational boundaries that start a new topic (i.e. infer a change of a conversational session), and/or engage in a minimal dialog to understand user intent. The concepts that follow are used to describe embodiments of the invention.\n\nInformation Repositories\n\nInformation repositories are associated with domains, which are groupings of similar types of information and/or certain types of content items. Certain types of information repositories include entities and relationships between the entities. Each entity/relationship has a type, respectively, from a set of types. Furthermore, associated with each entity/relationship are a set of attributes, which can be captured, in some embodiments, as a defined finite set of name-value fields. The entity/relationship mapping also serves as a set of metadata associated with the content items because the entity/relationship mapping provides information that describes the various content items. In other words, a particular entity will have relationships with other entities, and these âother entitiesâ serve as metadata to the âparticular entityâ. In addition, each entity in the mapping can have attributes assigned to it or to the relationships that connect the entity to other entities in the mapping. Collectively, this makes up the metadata associated with the entities/content items. In general, such information repositories are called structured information repositories. Examples of information repositories associated with domains follow below.\n\nA media entertainment domain includes entities, such as, movies, TV-shows, episodes, crew, roles/characters, actors/personalities, athletes, games, teams, leagues and tournaments, sports people, music artists and performers, composers, albums, songs, news personalities, and/or content distributors. These entities have relationships that are captured in the information repository. For example, a movie entity is related via an âacted inâ relationship to one or more actor/personality entities. Similarly, a movie entity may be related to an music album entity via an âoriginal sound trackâ relationship, which in turn may be related to a song entity via a âtrack in albumâ relationship. Meanwhile, names, descriptions, schedule information, reviews, ratings, costs, URLs to videos or audios, application or content store handles, scores, etc. may be deemed attribute fields.\n\nA personal electronic mail (email) domain includes entities, such as, emails, email-threads, contacts, senders, recipients, company names, departments/business units in the enterprise, email folders, office locations, and/or cities and countries corresponding to office locations. Illustrative examples of relationships include an email entity related to its sender entity (as well as the to, cc, bcc, receivers, and email thread entities.) Meanwhile, relationships between a contact and his or her company, department, office location can exist. In this repository, instances of attribute fields associated with entities include contacts' names, designations, email handles, other contact information, email sent/received timestamp, subject, body, attachments, priority levels, an office's location information, and/or a department's name and description.\n\nA travel-related/hotels and sightseeing domain includes entities, such as, cities, hotels, hotel brands, individual points of interest, categories of points of interest, consumer facing retail chains, car rental sites, and/or car rental companies. Relationships between such entities include location, membership in chains, and/or categories. Furthermore, names, descriptions, keywords, costs, types of service, ratings, reviews, etc. all amount of attribute fields.\n\nAn electronic commerce domain includes entities, such as, product items, product categories and subcategories, brands, stores, etc. Relationships between such entities can include compatibility information between product items, a product âsold byâ a store, etc. Attribute fields in include descriptions, keywords, reviews, ratings, costs, and/or availability information.\n\nAn address book domain includes entities and information such as contact names, electronic mail addresses, telephone numbers, physical addresses, and employer.\n\nThe entities, relationships, and attributes listed herein are illustrative only, and are not intended to be an exhaustive list.\n\nEmbodiments of the present invention may also use repositories that are not structured information repositories as described above. For example, the information repository corresponding to network-based documents (e.g., the Internet/World Wide Web) can be considered a relationship web of linked documents (entities). However, in general, no directly applicable type structure can meaningfully describe, in a nontrivial way, all the kinds of entities and relationships and attributes associated with elements of the Internet in the sense of the structured information repositories described above. However, elements such as domain names, internet media types, filenames, filename extension, etc. can be used as entities or attributes with such information.\n\nFor example, consider a corpus consisting of a set of unstructured text documents. In this case, no directly applicable type structure can enumerate a set of entities and relationships that meaningfully describe the document contents. However, application of semantic information extraction processing techniques as a pre-processing step may yield entities and relationships that can partially uncover structure from such a corpus.\n\nIllustrative Examples of Accessing Information Repositories Under Certain Embodiments of the Present Invention\n\nThe following description illustrates examples of information retrieval tasks in the context of structured and unstructured information repositories as described above.\n\nIn some cases, a user is interested in one or more entities of some type-generally called intent type hereinâwhich the user wishes to uncover by specifying only attribute field constraints that the entities must satisfy. Note that sometimes intent may be a (type, attribute) pair when the user wants some attribute of an entity of a certain type. For example, if the user wants the rating of a movie, the intent could be viewed as (type, attribute)=(movie, rating). Such query-constraints are generally called attribute-only constraints herein.\n\nWhenever the user names the entity or specifies enough information to directly match attributes of the desired intent type entity, it is an attribute-only constraint. For example, when the user identifies a movie by name and some additional attribute (e.g., âCape Fearâ made in the 60s), or when he specifies a subject match for the email he wants to uncover, or when he asks for hotels based on a price range, or when he specifies that he wants a 32 GB, black colored iPod touch.\n\nHowever, in some cases, a user is interested in one or more entities of the intent type by specifying not only attribute field constraints on the intent type entities but also by specifying attribute field constraints on or naming other entities to which the intent type entities are connected via relationships in some well defined way. Such query-constraints are generally called connection oriented constraints herein.\n\nAn example of a connection oriented constraint is when the user wants a movie (an intent type) based on specifying two or more actors of the movie or a movie based on an actor and an award the movie won. Another example, in the context of email, is if the user wants emails (intent type) received from certain senders from a particular company in the last seven days. Similarly, a further example is if the user wants to book a hotel room (intent type) to a train station as well as a Starbucks outlet. Yet another example is if the user wants a television set (intent type) made by Samsung that is also compatible with a Nintendo Wii. All of these are instances of connection oriented constraints queries.\n\nIn the above connection-oriented constraint examples, the user explicitly describes or specifies the other entities connected to the intent entities. Such constraints are generally called explicit connection oriented constraints and such entities as explicit entities herein.\n\nMeanwhile, other queries contain connection oriented constraints that include unspecified or implicit entities as part of the constraint specification. In such a situation, the user is attempting to identify a piece of information, entity, attribute, etc. that is not know through relationships between the unknown item and items the user does now. Such constraints are generally called implicit connection oriented constraints herein and the unspecified entities are generally called implicit entities of the constraint herein.\n\nFor example, the user may wish to identify a movie she is seeking via naming two characters in the movie. However, the user does not recall the name of one of the characters, but she does recall that a particular actor played the character. Thus, in her query, she states one character by name and identifies the unknown character by stating that the character was played by the particular actor.\n\nIn the context of email repository, an example includes a user wanting to get the last email (intent) from an unspecified gentleman from a specified company âIntelâ to whom he was introduced via email (an attribute specifier) last week. In this case, the implicit entity is a contact who can be discovered by examining contacts from âIntelâ, via an employee/company relationship, who was a first time common-email-recipient with the user last week.\n\nFurther examples of implicit connection oriented constraints are described in more detail below.\n\nIn the context of connection oriented constraints, it is useful to map entities and relationships of information repositories to nodes and edges of a graph. The motivation for specifically employing the graph model is the observation that relevance, proximity, and relatedness in natural language conversation can be modeled simply by notions such as link-distance and, in some cases, shortest paths and smallest weight trees. During conversation when a user dialog involves other entities related to the actually sought entities, a subroutine addressing information retrieval as a simple graph search problem effectively helps reduce dependence on deep unambiguous comprehension of sentence structure. Such an approach offers system implementation benefits. Even if the user intent calculation is ambiguous or inconclusive, so long as entities have been recognized in the user utterance, a graph-interpretation based treatment of the problem enables a system to respond in a much more intelligible manner than otherwise possible, as set forth in more detail below.\n\nAttribute-Only Constraints\n\nWhat follows are examples of information retrieval techniques that enable the user to specify attribute-only constraints. While some of these techniques are known in the art (where specified), the concepts are presented here to illustrate how these basic techniques can be used with the inventive techniques described herein to enhance the user experience and improve the quality of the search results that are returned in response to the user's input.\n\nExamples of Attributes-Only Constraints During Information Retrieval from a Movie/TV Search Interface\n\nFIG. 1 shows a search interface 100 for a search engine for movie and television content that is known in the art (i.e., the IMDb search interface). FIG. 1 includes a pull-down control 105 that allows the user to expressly select an entity type or attribute. For example, Title means intent entity type is Movie or TV Show, TV Episode means the intent type is Episode, Names means intent type is Personality, Companies means the intent type is Company (e.g., Production house or Studio etc.), Characters means the intent type is Role. Meanwhile, Keywords, Quotes, and Plots specify attribute fields associated with intent entities of type Movie or TV Show or Episode that are sought to be searched. Meanwhile, the pull-down control 110 allows the user to only specify attributes for entities of type Movie, Episode, or TV Show.\n\nFIG. 2 shows the Advanced Title Search graphical user interface of the IMDB search interface (known in the art) 200. Here, the Title Type choice 205 amounts to selection of intent entity type. Meanwhile, Release Date 210, User Rating 215, and Number of Votes 220 are all attributes of entities of type movies, TV Shows, episodes, etc. If the number of Genres 225 and Title Groups 230 shown here is deemed small enough, then those genres and title groups can be deemed descriptive attributes of entities. So the genre and title groups section here is also a way of specifying attribute constraints. The Title Data 235 section is specifying the constraint corresponding to the data source attribute.\n\nExamples of Attributes-Only Constraints During Information Retrieval from an Electronic-Commerce Search Interface\n\nFIG. 3 illustrates a graphical user interface 300 for an electronic-commerce website's search utility that is known in the art. In previous examples, the user interface allowed users to specify sets of attribute constraints before initiating any search in the information repository. Meanwhile, FIG. 3 shows the user interface after the user has first launched a text-only search query âcar stereoâ. Based on features and attributes associated with the specific results returned by the text search engine for the text search query 305, the post-search user interface is constructed by dynamically picking a subset of attributes for this set of search results, which allows the user to specify further attribute constraints for them. As a result, the user is forced to follow the specific flow of first doing a text search or category filtering and then specifying the constraints on further attributes.\n\nThis âhard-codedâ flowâof first search followed by post-search attribute filtersâresults from a fundamental limitation of this style of graphical user interface because it simply cannot display all of the meaningful attributes up-front without having any idea of the product the user has in mind. Such an approach is less efficient that the inventive techniques disclosed herein because the user may want to declare some of the attribute constraints he or she has in mind at the beginning of the search. This problem stems, in part, from the fact that even though the number of distinct attributes for each individual product in the database is a finite number, the collective set is typically large enough that a graphical user interface cannot display a sufficient number of the attributes, thereby leading to the hard coded flow.\n\nNote that the conversational interface embodiments disclosed herein do not suffer from physical spatial limitations. Thus, a user can easily specify any attribute constraint in the first user input.\n\nExplicit Connection Oriented Constraints\n\nWhat follows are examples of explicit connection oriented constraints employed in information retrieval systems. Graph model terminology of nodes and edges can also be used to describe connection oriented constraints as can the terminology of entities and relationships.\n\nWhen using an attribute-only constraints interface, the user only specifies the type and attribute constraints on intent entities. Meanwhile, when using an explicit connected node constraints interface, the user can additionally specify the type and attribute constraints on other nodes connected to the intent nodes via specified kinds of edge connections. One example of an interface known in the art that employs explicit connected node constraints during information retrieval is a Movie/TV information search engine 400 shown in FIG. 4.\n\nConsidering that the number of possible death and birth places 405 across all movie and TV personalities is a huge number, birth and death places are treated as nodes rather than attributes in the movie information repository graph. Thus, birth and death place specifications in the graphical user interface 400 are specifications for nodes connected to the intended personality node. The filmography filter 410 in the graphical user interface 400 allows a user to specify the name of a movie or TV show node, etc., which is again another node connected to the intended personality node. The other filters 500, shown in FIG. 5, of the graphical user interface are specifiers of the attributes of the intended node.\n\nIn the first part of the graphical user interface 400, a user may specify two movie or TV show nodes when his intent is to get the personalities who collaborated on both these nodes. In the second part of the graphical UI above, a user may specify two personality nodes when his intent is to get movie or TV show nodes corresponding to their collaborations. In both case, the user is specifying connected nodes other than his intended nodes, thereby making this an explicit connected node constraint. However, the interfaces known in the art do not support certain types of explicit connected node constraints (explicit connection oriented constraints), as described below.\n\nFIG. 6 illustrates a graph 600 of the nodes (entities) and edges (relationships) analyzed by the inventive techniques disclosed herein to arrive at the desired result when the user seeks a movie based on the fictional character Jack Ryan that stars Sean Connery. The user may provide the query, âWhat movie has Jack Ryan and stars Sean Connery?â The techniques herein interpret the query, in view of the structured information repositories as: Get the node of type Movie (intent) that is connected by an edge 605 to the explicit node of type Role named âJack Ryanâ 610 and also connected via an âActed Inâ edge 615 to the explicit node of type Personality named âSean Conneryâ 620. The techniques described herein return the movie âThe Hunt for the Red Octoberâ 625 as a result.\n\nReferring again to FIG. 6, assume the user asks, âWho are all of the actors that played the character of Jack Ryan?â The disclosed techniques would interpret the query as:\n\nGet nodes of type Personality (intent) connected by means of an âActed-asâ edge 630 to the explicit node of type Role named âJack Ryanâ 610. Embodiments of the inventive systems disclosed herein would return the actors âAlec Baldwinâ 635, âHarrison Fordâ 640, and âBen Affleckâ 645.\n\nA further example is a user asking for the name of the movie starring Tom Cruise based on a John Grisham book. Thus, the query becomes: Get the node of type Movie (intent) connected by an âActed Inâ edge to the explicit node of type Personality named Tom Cruise and connected by a âWriterâ edge to the explicit node of type Personality named âJohn Grishamâ. Embodiments of the inventive systems disclosed herein would return the movie âThe Firmâ.\n\nImplicit Connection Oriented Constraints\n\nThe following examples illustrate the implicit connection oriented constraints and implicit entities used for specific information retrieval goals. The first two examples used the terminology of entities and relationships.\n\nIn one example, the user wants the role (intent) played by a specified actor/personality (e.g., Michelle Pfeiffer) in an unspecified movie that is about a specified role (e.g., the character Tony Montana.) In this case, the user's constraint includes an unspecified or implicit entity. The implicit entity is the movie âScarfaceâ. FIG. 7 illustrates a graph 700 of the entities and relationships analyzed by the techniques disclosed herein to arrive at the desired result. The graph 700 is an illustrative visual representation of a structured information repository. Specifically, the implicit movie entity âScarfaceâ 705 is arrived at via a âActed Inâ relationship 710 between the movie entity âScarfaceâ 705 and the actor entity âMichelle Pfeifferâ 715 and a âCharacter Inâ relationship 720 between the character entity âTony Montanaâ 725 and the movie entity âScarfaceâ 705. The role entity âElvira Hancockâ 730 played by âMichelle Pfeifferâ is then discovered by the âActed byâ relationship 735 to âMichelle Pfeifferâ and the âCharacter Inâ relationship 740 to the movie entity âScarfaceâ 705.\n\nIn a further example, suppose that the user wants the movie (intent) starring the specified actor entity Scarlett Johansson and the unspecified actor entity who played the specified role of Obi-Wan Kenobi in a specified movie entity Star Wars. In this case, the implicit entity is the actor entity âEwan McGregorâ and the resulting entity is the movie âThe Islandâ starring âScarlett Johanssonâ and âEwan McGregorâ. FIG. 8 illustrates a graph 800 of the entities and relationships analyzed by the techniques disclosed herein to arrive at the desired result. Specifically, the implicit actor entity Ewan McGregor 805 is arrived at via an Acted In relationship 810 with at least one movie entity Star Wars 815 and via a Character relationship 820 to a character entity Obi-Wan Kenobi 825, which in turn is related via a Character relationship 830 to the movie entity Star Wars 815. Meanwhile, the result entity The Island 835 is arrived at via an Acted In relationship 840 between the actor/personality entity Scarlett Johansson 845 and the movie entity The Island 835 and an Acted In relationship 850 between the implicit actor entity Ewan McGregor 805 and the movie entity The Island.\n\nFIG. 9 illustrates a graph 900 of the entities and relationships analyzed by the techniques disclosed herein to arrive at a desired result. This example uses the terminology of nodes and edges. The user knows that there is a band that covered a Led Zeppelin song for a new movie starring Daniel Craig. The user recalls neither the name of the covered song nor the name of the movie, but he wants to explore the other music (i.e., songs) of the band that did that Led Zeppelin cover. Thus, by specifying the known entities of Led Zeppelin (as the song composer) and Daniel Craig (as an actor in the movie), the interposing implied nodes are discovered to find the user's desired result. Thus, embodiments of the inventive techniques herein compose the query constraint as follows: Return the nodes of type Song (intent) connected by a âComposerâ edge 905 to an implicit node of type Band 910 (Trent Reznor) such that this Band node has a âCover Performerâ edge 915 with an implicit node of type Song 920 (Immigrant Song) which in turn has a âComposerâ edge 925 with an explicit node of type Band named âLed Zeppelinâ 930 and also a âTrack in Albumâ edge 935 with an implicit node of type Album 940 (Girl with the Dragon Tattoo Original Sound Track) which has an âOriginal Sound Track (OST)â edge 945 with an implicit node of type Movie 950 (Girl with the Dragon Tattoo Original Sound Track) that has an âActed Inâ edge 955 with the explicit node of type Personality named âDaniel Craigâ. 960.\n\nAs mentioned above, known techniques and systems for information retrieval suffer from a variety of problems. Described herein are embodiments of an inventive conversational interaction interface. These embodiments enable a user to interact with an information retrieval system by posing a query and/or instruction by speaking to it and, optionally, selecting options by physical interaction (e.g., touching interface, keypad, keyboard, and/or mouse). Response to a user query may be performed by machine generated spoken text to speech and may be supplemented by information displayed on a user screen. Embodiments of the conversation interaction interface, in general, allow a user to pose his next information retrieval query or instruction in reaction to the information retrieval system's response to a previous query, so that an information retrieval session is a sequence of operations, each of which has the user first posing a query or instruction and the system the presenting a response to the user.\n\nEmbodiments of the present invention are a more powerful and expressive paradigm than graphical user interfaces for the query-constraints discussed herein. In many situations, especially when it comes to flexibly selecting from among a large number of possible attributes or the presence of explicit and implicit connected nodes, the graphical user interface approach does not work well or does not work at all. In such cases, embodiments of the conversational interaction interface of the present invention are a much more natural fit. Further, embodiments of the present invention are more scalable in terms of the number of distinct attributes a user may specify as well as the number of explicit connected node constraints and the number of implicit node constraints relative to graphical user interfaces.\n\nConversational System Architecture\n\nFIG. 10 represents the overall system architecture 1000 of an embodiment of the present invention. User 1001 speaks his or her question that is fed to a speech to text engine 1002. While the input could be speech, the embodiment does not preclude the input to be direct text input. The text form of the user input is fed to session dialog content module 1003. This module maintains state across a conversation session, a key use of which is to help in understanding user intent during a conversation, as described below.\n\nThe session dialog content module 1003, in conjunction with a Language Analyzer 1006, a Domain Specific Named Entity Recognizer 1007, a Domain Specific Context and Intent Analyzer 1008, a Personalization Based Intent Analyzer 1009, a Domain Specific Graph Engine 1010, and an Application Specific Attribute Search Engine 1011 (all described in more detail below) process the user input so as to return criteria to a Query Execution Engine 1004. The Query Execution Engine 1004 uses the criteria to perform a search of any available source of information and content to return a result set.\n\nA Response Transcoding Engine 1005, dispatches the result set to the user for consumption, e.g., in the device through which user is interacting. If the device is a tablet device with no display constraints, embodiments of the present invention may leverage off the display to show a graphical rendition of connection similar in spirit to FIGS. 7, 6, 9, and 8, with which the user can interact with to express intent. In a display-constrained device such as a smartphone, the Response Transcoding Engine 105 may respond with text and/or speech (using a standard text to speech engine).\n\nWhile FIG. 10 is a conversation architecture showing the modules for a specific domain, the present embodiment is a conversation interface that can take user input and engage in a dialog where user's intent can span domains. In an embodiment of the invention, this is accomplished by having multiple instances of the domain specific architecture shown in FIG. 10, and scoring the intent weights across domains to determine user intent. This scoring mechanism is also used to implicitly determine conversation topic switching (for example, during a entertainment information retrieval session, a user could just say âI am hungryâ).\n\nFIG. 11 illustrates a simplified flowchart of the operation of embodiments of the invention. First, the user's speech input is converted to text by a speech recognition engine 1101. The input is then broken down into intent, entities, and attributes 1102. This process is assisted by information from the prior conversation state 1103. The breakdown into intents, entities, and attributes, enables the system to generate a response to the user 1104. Also, the conversation state 1103 is updated to reflect the modifications of the current user input and any relevant returned response information.\n\nFIG. 12 illustrates the control flow in more detail. First, the user's speech is input to the process as text 1201. Upon receiving the user input as text, query execution coordination occurs 1202. The query execution coordination 1202 oversees the breakdown of the user input to understand user's input. The query execution coordination 1202 makes use of language analysis 1203 that parses the user input and generates a parse tree. The query execution coordination 1202 also makes use of the maintenance and updating of the dialog state 1208. The parse tree and any relevant dialog state values are passed to modules that perform intent analysis 1204, entity analysis 1205, and attribute analysis 1206. These analysis processes work concurrently, because sequential processing of these three analysis steps may not be possible. For instance, in some cases of user input, the recognition of entities may require the recognition of intents and vice versa. These mutual dependencies can only be resolved by multiple passes on the input by the relevant modules, until the input is completely analyzed. Once the breakdown and analysis is complete, a response to the user is generated 1207. The dialog state is also updated 1208 to reflect the modifications of the current input and return of relevant results. In other words, certain linguistic elements (e.g., spoken/recognized words and/or phrases) are associated with the present conversation session.\n\nReferring again to FIG. 10, in one illustrative embodiment, the Session Dialog Content Module 1003, in conjunction with a Language Analyzer 1006, and the other recognizer module, analyzer modules, and/or engines described in more detail below, perform the analysis steps mentioned in connection with FIG. 12 and break down the sentence into its constituent parts. The Language Analyzer 1006 creates a parse tree from the text generated from the user input, and the other recognizer module, analyzer modules, and/or engines operate on the parse tree to determine the constituent parts. Those parts can be broadly categorized as (1) intentsâthe actual intent of the user (such as âfind a movieâ, âplay a songâ, âtune to a channelâ, ârespond to an emailâ, etc.), (2) entitiesânoun or pronoun phrases describing or associated with the intent, and (3) attributesâqualifiers to entities such as the âlatestâ movie, âlessâ violence, etc. Other constituent part categories are within the scope of the invention.\n\nIn the context of the goal of providing an intelligent and meaningful conversation, the intent is among the most important of all three categories. Any good search engine can perform an information retrieval task fairly well just by extracting the entities from a sentenceâwithout understanding the grammar or the intent. For instance, the following user question, âCan my daughter watch pulp fiction with meââmost search engines would show a link for pulp fiction, which may suffice to find the rating that is most likely available from traversing that link. But in a conversational interface, the expectation is clearly higherâthe system must ideally understand the (movie, rating) intent corresponding to the expected response of the rating of the movie and the age group it is appropriate for. A conversational interface response degenerating to that of a search engine is tantamount to a failure of the system from a user perspective. Intent determination and, even more importantly, responding to user's question that appears closer to a human's response when the intent is not known or clearly discernible is an important aspect for a conversational interface that strives to be closer to human interaction than to a search engine.\n\nIn this example, although the user never used the word âratingâ, the system infers that user is looking for rating, from the words âcan . . . watchâ based on a set of rules and/or a naÃ¯ve Bayes classifier, described in more details below. Meanwhile, âmy daughterâ could be recognized as an attribute. In order for the daughter to watch a program, several criteria must be met: the show timing, the show availability, and âwatchabilityâ or rating. This condition may be triggered by other attributes too such as âsonâ, âgirlâ, âboyâ etc. These could be rules-based domain specific intents or naÃ¯ve Bayes classifier scoring based on domain specific training sets to look for ratings and show timings in this case. There could also be weightage factor for the satisfiabiltiy of these conditions that is driven by the entity that is being watched.\n\nIntent Analyzer 1008 is a domain specific module that analyzes and classifies intent for a domain and works in conjunction with other modulesâdomain specific entity recognizer 1007, personalization based intent analyzer 1009 that classifies intent based on user's personal preferences, and the domain specific graph engine 1010. The attribute specific search engine 1011 assists in recognizing attributes and their weights influence the entities they qualify.\n\nThe intent analyzer 1008, in an embodiment of the invention, is a rules driven intent recognizer and/or a naÃ¯ve Bayes classifier with supervised training. The rules and/or training set capture how various words and word sets relate to user intent. It takes as input a parse tree, entity recognizer output, and attribute specific search engine output (discussed above and below). In some implementations, user input may go through multiple entity recognition, the attribute recognition, and intent recognition steps, until the input is fully resolved. The intent recognizer deciphers the intent of a sentence, and also deciphers the differences in nuances of intent. For instance, given âI would like to see the movie Top Gunâ versus âI would like to see a movie like Top Gunâ, the parse trees would be different. This difference assists the intent recognizer to differentiate the meaning of âlikeâ. The rules based recognition, as the very name implies, recognizes sentences based on predefined rules. Predefined rules are specific to a domain space, for example, entertainment. The naÃ¯ve Bayes classifier component, however, just requires a training data set to recognize intent.\n\nThe entity recognizer 1007, using the inputs mentioned above, recognizes entities in user input. Examples of entities are âTom cruiseâ in âcan I watch a Tom Cruise movieâ, or âWhere Eagles Dareâ in âwhen was Where Eagles Dare releasedâ. In certain implementations, the entity recognizer 1007 can be rules driven and/or a Bayes classifer. For example, linguistic elements such as nouns and gerunds can be designated as entities in a set of rules, or that association can arise during a supervised training process for the Bayes classifer. Entity recognition can, optionally, involve error correction or compensation for errors in user input (such as errors in speech to text recognition). When an input matches two entities phonetically, e.g., newman, and neuman, both are picked as likely candidates. In some embodiments, the resolution between these two comes form the information gleaned from the rest of user input, where relationships between entities may weed out one of the possibilities. The classifying of a subset of user input as an entity is only a weighting. There could be scenarios in which an input could be scored as both an entity and as an attribute. These ambiguities are resolved in many cases as the sentence semantics become clearer with subsequent processing of the user input. In certain embodiments, a component used for resolution is the entity relationship graph. In certain implementations, an output of the entity recognizer 1007 is a probability score for subsets of input to be entities.\n\nThe application specific attribute search engine 1011 recognizes attributes such as âlatestâ, ârecentâ, âlikeâ etc. Here again, there could be conflicts with entities. For example âTomorrow Never Diesâ is an entity (a movie), and, when used in a sentence, there could be an ambiguity in interpreting âtomorrowâ as an attribute. The scoring of tomorrow as an attribute may be lower than the scoring of âtomorrowâ as part of âTomorrow Never Diesâ as determined by entity relationship graph (which may depend on other elements of the input, e.g., the words âmovieâ, âshowâ, âactorâ, etc.). The output of the attribute search engine 1011 is a probability score for input words similar to that of the output of entity recognizer 1007.\n\nThe language analyzer 1006 is a pluggable module in the architecture to enable to system to support multiple languages. While understanding the semantics of user input is not constrained to the language analyzer 1006 alone, the core modules of the architecture such as dialog context module 1003 or graph engine 1010 are language independent. As mentioned earlier, the language module alone cannot do much more than analysis of a sentence and performing tasks such a relating a pronoun to its subject/object etc. (âThe Led Zeppelin song in the OST of the recent Daniel Craig movie . . . Who performed it?â), it is ineffective in isolation to associate pronouns across exchanges. It is the interaction with the session dialog context module 1003, that enables resolution of pronouns across exchanges as in the following:\n\nQ1: Who acts as obi-wan Kenobi in the new star wars?\n\nA1: Ewan McGregor\n\nQ2: How about his movies with Scarlet Johansson\n\nWhile it may seem, at first glance, that dialog session context is a simple state maintenance of the last active entity or entities, the following examples show the lurking complexity in dialog session context:\n\nQ1: Who played the lead roles in Kramer vs. Kramer?\n\nA1: Meryl Streep and Dustin Hoffman\n\nQ2: How about more of his movies\n\nA2: Here are some of Dustin Hoffman movies . . . [list of Dustin Hoffman movies]\n\nQ3: What about more of her movies?\n\nA3: [list of movies if any]\n\nQ4: What about just his early movies?\n\nA4: [list of movies if any]\n\nQ5: What about her recent movies?\n\nA5: [list of movies if any]\n\nQ6: Have they both acted again in the recent past?\n\nA6: [list of movies if any]\n\nQ7: Have they both ever acted again at all?\n\nIn the example above, the entities Meryl Streep and Dustin Hoffman are indirectly referred to in six questions, sometimes together and sometimes separately. The above example also illustrates a distinction of embodiments of the present invention from simple request response systems that engage in an exploratory exchange around a central theme. While the present embodiments not only resolve ambiguities in an exchange, they simultaneously facilitate an exploratory exchange with implicit references to entities and/or intents mentioned much earlier in a conversationâsomething that is naturally done in rich human interactions. In certain embodiments, this is done through the recognition of linguistic linking elements, which are words and/or phrases that link the present user input to a previous user input and/or system response. Referring to the example provided above, the pronouns âhisâ, âhersâ, and âtheyâ are words that link the present user input to a previous user input and/or system response. Other pronouns, as well as syntactic expletives, can act as linguistic linking elements.\n\nWhether a particular word or phrase used by the user in a later question is a suitable or appropriate link to an entity mentioned in an earlier input (or some other part of the earlier input) is determined by examining the attributes of the earlier entity and the attributes of the potential linking element. For example, âhisâ is a suitable link to Dustin Hoffman in the example above because Dustin Hoffman is male, and âhisâ is a male gender pronoun. Moreover, âhisâ is a possessive pronoun, which is appropriate because the user is referring to movies in which Dustin Hoffman appears.\n\nThe following example illustrates user referring to an entity who is not even explicitly specified in a prior exchange (an implicit connection oriented constraint). In other words, the user never identifies the entity that is saved as part of the dialog state.\n\nQ1: Which show had that physically challenged scientist alluding to the possibility of non-carbon based life form?\n\nA1: That was Stephen Hawking's discovery channel program on aliens.\n\nQ2: Was he in another show that David Attenborough produced?\n\nIn another example of dialog state maintenance not being restricted to just entities and their attributes, the system can maintain state of intents across conversation exchanges, as show as follows:\n\nQ1: âCan my daughter watch pulp fiction with me?â\n\nA1: Pulp fiction by Quentin Tarantino is rated R for graphic violence and nudity.\n\nQ2: What about his other movies?\n\nA2: They are all rated RâReservoir Dogs, Jackie Brown, Kill Bill, Death Proof.\n\nIn this example in addition to maintain state of the entity âQuentin Tarantinoâ which enables the system to understand the pronoun reference to him (in the form of âhisâ) in Q2, the system also keeps track of user intent across the exchangesâthe user intent being the âratingâ. Again, the system's decision to maintain both âQuentin Taratinoâ and the âratingâ intent stems from the rules and/or Bayes classifier training sets. Thus, the techniques disclosed herein enable the preservation and use of multiple intents. In such an implementation, the set intents would be passed as a collection of intents with weights. Depending on the output of the rules and/or Bayes classifier, the system may elect to save all intents during a session (and/or entities, attributes, etc.), but may only use the one intent that is scored highest for a particular input. Thus, it is possible that an intent that accrued relatively earlier in the dialog exchange applies much later in the conversation. Maintaining the state in this way facilitates a succinct and directed response as in A2, almost matching a human interaction.\n\nThe directed responses illustrated above are possible with the intent analyzer 1008 and entity recognizer 1009 working in close concert with the personalization based intent analyzer 1009. These modules are all assisted by an application specific attribute search engine 1011 that assists in determining relevant attributes (e.g., latest, less of violence, more of action) and assigns weights to them. So a user input exchange would come from the speech to text engine 1002, would be processed by the modules, analyzers, and engines working in concert (with the query execution engine 1004 playing a coordinating role), and would yield one or more candidate interpretations of the user input. For instance the question, âDo you have the Kay Kay Menon movie about the Bombay bomb blasts?â, the system may have two alternative candidate representations wherein one has âBombayâ as an entity (there is a movie called Bombay) with âbomb blastâ being another and the other has âBombay bomb blastâ as a single entity in another. The system then attempts to resolve between these candidate representations by engaging in a dialog with the user, on the basis of the presence of the other recognized entity Kay Kay Menon who is an actor. In such a case, the question(s) to formulate depend on the ambiguity that arises. In this example, the actor entity is known, it is the associated movie entities that are ambiguous. Thus, the system would ask questions concerning the movie entities. The system has a set of forms that are used as a model to form questions to resolve the ambiguities.\n\nIn some instances, resolution of ambiguity can be done, without engaging in a dialog, by knowing user's preferences. For instance, the user may ask âIs there a sox game tonight?â While this question has an ambiguous portionâthe ambiguity of the team being the Boston Red Sox or the Chicago White Soxâif the system is aware that user's preference is Red Sox, then the response can be directed to displaying a Red Sox game schedule if there is one that night. In instances where there are multiple matches across domains, the domain match resulting in the higher overall confidence score will win. Personalization of results can also be done, when applicable, based on the nature of the query. For instance, if the user states âshow me movies of Tom Cruise tonightâ, this query should not apply personalization but just return latest movies of Tom Cruise. However if user states âshow me sports tonightâ, system should apply personalization and display sports and games that are known to be of interest to the user based on his explicit preferences or implicit actions captured from various sources of user activity information.\n\nA user preference signature can be provided by the system using known techniques for discovering and storing such user preference information. For example, the methods and systems set forth in U.S. Pat. No. 7,774,294, entitled Methods and Systems for Selecting and Presenting Content Based on Learned Periodicity of User Content Selections, issued Aug. 10, 2010, U.S. Pat. No. 7,835,998, entitled Methods and Systems for Selecting and Presenting Content on a First System Based on User Preferences Learned on a Second System, issued Nov. 16, 2010, U.S. Pat. No. 7,461,061, entitled User Interface Methods and Systems for Selecting and Presenting Content Based on User Navigation and Selection Actions Associated with the Content, issued Dec. 2, 2008, and U.S. Pat. No. 8,112,454, entitled Methods and Systems for Ordering Content Items According to Learned User Preferences, issued Feb. 7, 2012, each of which is incorporated by reference herein, can be used with the techniques disclosed herein. However, the use of user's preference signatures and/or information is not limited to the techniques set forth in the incorporated applications.\n\nThe relationship or connection engine 1010 is one of the modules that plays a role in comprehending user input to offer a directed response. The relationship engine could be implemented in many ways, a graph data structure being one instance so that we may call the relationship engine by the name graph engine. The graph engine evaluates the user input in the backdrop of known weighted connections between entities.\n\nOne embodiment showing the importance of the graph engine is illustrated by the following example in which user intent is clearly known. If the user simply queries âwhat is the role played by Michelle Pfeiffer in the Tony Montana movieâ, the system knows the user intent (the word role and its usage in the sentence may be used to deduce that the user wants to know the character that Michelle Pfeiffer has played somewhere) and has to grapple with the fact that the named entity Tony Montana could be the actor named Tony Montana or the name of the leading character of the movie Scarface. The graph engine in this instance is trivially able to disambiguate since a quick analysis of the path between the two Tony Montana entities respectively and the entity of Michelle Pfeiffer quickly reveals that the actor Tony Montana never collaborated with Michelle Pfeiffer, whereas the movie Scarface (about the character Tony Montana) starred Michelle Pfeiffer. Thus, the system will conclude that it can safely ignore the actor Tony Montana and that the user wants to know the name of the character played by Michelle Pfeiffer in the movie Scarface.\n\nIn another embodiment, the graph engine 1010 assists when the system is unable to determine the user intent despite the fact that the entity recognizer 1007 has computed the entities specified by the user. This is illustrated by the following examples in which the user intent cannot be inferred or when the confidence score of the user intent is below a threshold. In such a scenario, two illustrative strategies could be taken by a conversation system to get the user's specific intent. In some embodiments, the system determined the most important keywords from the user utterance and treats each result candidate as a document, calculates a relevance score of each document based on the each keyword's relevance, and presents the top few documents to the user for him to peruse. This approach is similar to the web search engines. In other embodiments, the system admits to the user that it cannot process the user request or that the information it gathered is insufficient, thereby prompting the user to provide more information or a subsequent query.\n\nHowever, neither approach is entirely satisfactory when one considers the response from the user's perspective. The first strategy, which does blind keyword matches, can often look completely mechanical. The second approach attempts to be human-like when it requests the user in a human-like manner to furnish more information to make up for the fact that it could not compute the specific user-intent. However, in the cases that the user clearly specifies one or more other entities related to the desired user intent, the system looks incapable if the system appear to not attempt an answer using the clearly specified entities in the user utterance.\n\nIn certain implementations, a third strategy is employed so long as entity recognition has succeeded (even when the specific user intent calculation has failed). Note that entity recognition computation is successful in a large number of cases, especially when the user names or gives very good clues as to the entities in his utterance, which is usually the case.\n\nThe strategy is as follows:\n\n1. Consider the entity relationship graph corresponding to the information repository in question. Entities are nodes and relationships are edges in this graph. This mapping involving entities/nodes and relationships/edges can involve one-to-one, one-to-many, and many-to-many mapping based on information and metadata associated with the entities being mapped.\n\n2. Entities/nodes have types from a finite and well-defined set of types.\n\n3. Since entity recognition is successful (e.g., from an earlier interaction), we consider the following cases:\n\na. Number of presently recognized entities is 0: In this case, the system gives one from a fixed set of responses based on response templates using the information from the user that is recognized. The template selections is based on rules and/or Bayes classifier determinations.\n\nb. Number of recognized entities is 1: Suppose that the entity identifier is A and the type of the entity is B and we know the finite set S of all the distinct edge/relationship types A can be involved in. In this case, a system employing the techniques set forth herein (âthe IR systemâ) speaks and/or displays a human-consumption multi-modal response template T(A,B,S) that follows from an applicable template response based on A, B and S. The template response is selected from a set of manually constructed template responses based on a priori knowledge of all possible node types and edge types, which form finite well-defined sets. The response and IR system is designed to allow the user to select, using a touch interface or even vocally, more information and entities related to A.\n\nc. Number of recognized edge types is 2: In this case, let the two entity nodes respectively have identifiers A, Aâ², types B, Bâ² and have edge-type sets S, Sâ².\n\nIf the edge distance between the two entity nodes is greater than some previously decided threshold k, then the IR system appropriately employs and delivers (via speech and/or display) the corresponding two independent human-consumption multi-modal response templates T(A, B, S) and T(Aâ², Bâ², Sâ²).\n\nIf the edge distance is no more than k, then the IR system selects a shortest edge length path between A and Aâ². If there are clues available in user utterance, the IR system may prefer some shortest paths to others. Let there be kâ² nodes in the selected shortest path denoted A=A1, A2, A3, . . . Akâ²=Aâ² where kâ²<k+1 and for each i, where i goes from 1 to kâ², the ith entity node of the path is represented by the 3-tuple Ai, Bi, Ei where Ai is the entity identifier, Bi is the entity type and Ei is a list of one or two elements corresponding to the one or two edges connected to A; that are present in the selected shortest path. In this case the IR system then delivers to the user an appropriate response based on an intelligent composition of the sequence of human-consumption multi-modal response templates T(Ai, Bi, Ei) where i goes from 1 to kâ².\n\nd. Number of recognized edge types is R>=3: In this case the IR system simply calculates K maximal components C1, C2, . . . Ck where each component Ci is such each entity node A in Ci is at a distance of no more than k edges away from at least one other node Aâ² of Ci. For each Ci, the IR System selects an appropriate representative sequence of human-consumption multi-modal response template sequences, similar to c. above and composes a response based on the response template sequences for each component.\n\nThis method to generate a response is suggested to be more human in that it has the ability to demonstrate to the user that, with the help of the entities recognized, it presented to the user a response which made it potentially easier compared to the two earlier strategies vis-Ã -vis his goal of retrieving information. FIGS. 7, 6, 9, and 8, illustrate examples implementations of the disclosed techniques.\n\nThe techniques set forth above are also used, in certain implementations, to reset all or part of the conversation state values. For example, assume a system has retained certain entities and/or attributes from user input and system responses. When the user provides subsequent input, the techniques disclosed herein enable the new input to be evaluated against the retained values. Speaking in terms of a graph model, if linguistic elements of the subsequent input are found in an entity/relationship graph to be too far removed from the retained information (also in the graph), it can be inferred that the user's subsequent intent has changed from the previous one. In such a case, the earlier retained information can be reset and/or disregarded when performing the subsequent search.\n\nFurther still, embodiments of the invention can recognize that a user has provided subsequent input that lacks entities, attributes, or relationship information, but the input is an appropriate response to an earlier system response. For example, a system implementing the techniques set forth herein may present a set of movies as a response to a first user input. The user may then respond that she is not interested in any of the movies presented. In such a case, the system would retain the various conversation state values and make a further attempt to satisfy the user's previous request (by, e.g., requesting additional information about the type of movie desired or requesting additional information to better focus the search, such as actor names, genre, etc.).\n\nIn the foregoing description, certain steps or processes can be performed on particular servers or as part of a particular engine. These descriptions are merely illustrative, as the specific steps can be performed on various hardware devices, including, but not limited to, server systems and/or mobile devices. Similarly, the division of where the particular steps are performed can vary, it being understood that no division or a different division is within the scope of the invention. Moreover, the use of âanalyzerâ, âmoduleâ, âengineâ, and/or other terms used to describe computer system processing is intended to be interchangeable and to represent logic or circuitry in which the functionality can be executed.\n\nThe techniques and systems disclosed herein may be implemented as a computer program product for use with a computer system or computerized electronic device. Such implementations may include a series of computer instructions, or logic, fixed either on a tangible medium, such as a computer readable medium (e.g., a diskette, CD-ROM, ROM, flash memory or other memory or fixed disk) or transmittable to a computer system or a device, via a modem or other interface device, such as a communications adapter connected to a network over a medium.\n\nThe medium may be either a tangible medium (e.g., optical or analog communications lines) or a medium implemented with wireless techniques (e.g., Wi-Fi, cellular, microwave, infrared or other transmission techniques). The series of computer instructions embodies at least part of the functionality described herein with respect to the system. Those skilled in the art should appreciate that such computer instructions can be written in a number of programming languages for use with many computer architectures or operating systems.\n\nFurthermore, such instructions may be stored in any tangible memory device, such as semiconductor, magnetic, optical or other memory devices, and may be transmitted using any communications technology, such as optical, infrared, microwave, or other transmission technologies.\n\nIt is expected that such a computer program product may be distributed as a removable medium with accompanying printed or electronic documentation (e.g., shrink wrapped software), preloaded with a computer system (e.g., on system ROM or fixed disk), or distributed from a server or electronic bulletin board over the network (e.g., the Internet or World Wide Web). Of course, some embodiments of the invention may be implemented as a combination of both software (e.g., a computer program product) and hardware. Still other embodiments of the invention are implemented as entirely hardware, or entirely software (e.g., a computer program product)."
    }
}