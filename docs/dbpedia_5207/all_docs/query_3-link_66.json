{
    "id": "dbpedia_5207_3",
    "rank": 66,
    "data": {
        "url": "http://www.movable-type.co.uk/scripts/latlong.html",
        "read_more_link": "",
        "language": "en",
        "title": "Longitude points using haversine formula in JavaScript",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.movable-type.co.uk/images/mtl.gif",
            "http://www.movable-type.co.uk/scripts/baghdad-to-osaka.jpg",
            "http://www.movable-type.co.uk/scripts/license-osi-mit.png",
            "https://www.paypal.com/en_GB/i/scr/pixel.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "latitude longitude distance bearing points earth haversine great circle rhumb"
        ],
        "tags": null,
        "authors": [
            "Chris Veness"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "This page presents a variety of calculations for lati­tude/longi­tude points, with the formulas and code fragments for implementing them.\n\nAll these formulas are for calculations on the basis of a spherical earth (ignoring ellipsoidal effects) â which is accurate enough* for most purposesâ¦ [In fact, the earth is very slightly ellipsoidal; using a spherical model gives errors typically up to 0.3%1 â see notes for further details].\n\nGreat-circle distance between two points\n\nEnter the co-ordinates into the text boxes to try out the calculations. A variety of formats are accepted, principally:\n\ndeg-min-sec suffixed with N/S/E/W (e.g. 40Â°44â²55â³N, 73 59 11W), or\n\nsigned decimal degrees without compass direction, where negative indicates west/south (e.g. 40.7486, -73.9864):\n\nPoint 1: , Point 2: ,\n\nDistance: km (to 4 SF*) Initial bearing: Final bearing: Midpoint:\n\nAnd you can see it on a map\n\n... hide map\n\nDistance\n\nThis uses the âhaversineâ formula to calculate the great-circle distance between two points â that is, the shortest distance over the earthâs surface â giving an âas-the-crow-fliesâ distance between the points (ignoring any hills they fly over, of course!).\n\nHaversine\n\nformula: a = sinÂ²(ÎÏ/2) + cos Ï1 â cos Ï2 â sinÂ²(ÎÎ»/2) c = 2 â atan2( √a, √(1âa) ) d = R â c where: Ï is latitude, Î» is longitude, R is earthâs radius (mean radius = 6,371km);\n\nnote that angles need to be in radians to pass to trig functions! JavaScript:\n\nconst R = 6371e3; // metres const Ï1 = lat1 * Math.PI/180; // Ï, Î» in radians const Ï2 = lat2 * Math.PI/180; const ÎÏ = (lat2-lat1) * Math.PI/180; const ÎÎ» = (lon2-lon1) * Math.PI/180; const a = Math.sin(ÎÏ/2) * Math.sin(ÎÏ/2) + Math.cos(Ï1) * Math.cos(Ï2) * Math.sin(ÎÎ»/2) * Math.sin(ÎÎ»/2); const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a)); const d = R * c; // in metres\n\nNote in these scripts, I generally use lat/lon for lati­tude/longi­tude in degrees, and Ï/Î» for lati­tude/longi­tude in radians â having found that mixing degrees & radians is often the easiest route to head-scratching bugs...\n\nThe haversine formula1 âremains particularly well-conditioned for numerical computa­tion even at small distancesâ â unlike calcula­tions based on the spherical law of cosines. The â(re)versed sineâ is 1âcosÎ¸, and the âhalf-versed-sineâ is (1âcosÎ¸)/2 or sinÂ²(Î¸/2) as used above. Once widely used by navigators, it was described by Roger Sinnott in Sky & Telescope magazine in 1984 (âVirtues of the Haversineâ): Sinnott explained that the angular separa­tion between Mizar and Alcor in Ursa Major â 0Â°11â²49.69â³ â could be accurately calculated in Basic on a TRS-80 using the haversine.\n\nFor the curious, c is the angular distance in radians, and a is the square of half the chord length between the points.\n\nIf atan2 is not available, c could be calculated from 2 â asin( min(1, √a) ) (including protec­tion against rounding errors).\n\nUsing Chrome on an aging Core i5 PC, a distance calcula­tion takes around 2 â 5 micro­seconds (hence around 200,000 â 500,000 per second). Little to no benefit is obtained by factoring out common terms; probably the JIT compiler optimises them out.\n\nSpherical Law of Cosines\n\nIn fact, JavaScript (and most modern computers & languages) use âIEEE 754â 64-bit floating-point numbers, which provide 15 significant figures of precision. By my estimate, with this precision, the simple spherical law of cosines formula (cos c = cos a cos b + sin a sin b cos C) gives well-condi­tioned results down to distances as small as a few metres on the earthâs surface. (Note that the geodetic form of the law of cosines is rearranged from the canonical one so that the latitude can be used directly, rather than the colatitude).\n\nThis makes the simpler law of cosines a reasonable 1-line alternative to the haversine formula for many geodesy purposes (if not for astronomy). The choice may be driven by programming language, processor, coding context, available trig func­tions (in different languages), etc â and, for very small distances an equirectangular approxima­tion may be more suitable.\n\nLaw of cosines: d = acos( sin Ï1 â sin Ï2 + cos Ï1 â cos Ï2 â cos ÎÎ» ) â R JavaScript:\n\nconst Ï1 = lat1 * Math.PI/180, Ï2 = lat2 * Math.PI/180, ÎÎ» = (lon2-lon1) * Math.PI/180, R = 6371e3; const d = Math.acos( Math.sin(Ï1)*Math.sin(Ï2) + Math.cos(Ï1)*Math.cos(Ï2) * Math.cos(ÎÎ») ) * R;\n\nExcel: =ACOS( SIN(lat1)*SIN(lat2) + COS(lat1)*COS(lat2)*COS(lon2-lon1) ) * 6371000 (or with lat/lon in degrees): =ACOS( SIN(lat1*PI()/180)*SIN(lat2*PI()/180) + COS(lat1*PI()/180)*COS(lat2*PI()/180)*COS(lon2*PI()/180-lon1*PI()/180) ) * 6371000\n\nWhile simpler, the law of cosines is slightly slower than the haversine, in my tests.\n\nEquirectangular approximation\n\nIf performance is an issue and accuracy less important, for small distances Pythagorasâ theorem can be used on an equi­rectangular projec­tion:*\n\nFormula x = ÎÎ» â cos Ïm y = ÎÏ d = R â √xÂ² + yÂ² JavaScript:\n\nconst x = (Î»2-Î»1) * Math.cos((Ï1+Ï2)/2); const y = (Ï2-Ï1); const d = Math.sqrt(x*x + y*y) * R;\n\nThis uses just one trig and one sqrt function â as against half-a-dozen trig func­tions for cos law, and 7 trigs + 2 sqrts for haversine. Accuracy is somewhat complex: along meridians there are no errors, otherwise they depend on distance, bearing, and latitude, but are small enough for many purposes* (and often trivial compared with the spherical approxima­tion itself).\n\nAlternatively, the polar coordinate flat-earth formula can be used: using the co-latitudes Î¸1 = Ï/2âÏ1 and Î¸2 = Ï/2âÏ2, then d = R â √Î¸1Â² + Î¸2Â² â 2 â Î¸1 â Î¸2 â cos ÎÎ». Iâve not compared accuracy.\n\nBearing\n\nIn general, your current heading will vary as you follow a great circle path (orthodrome); the final heading will differ from the initial heading by varying degrees according to distance and latitude (if you were to go from say 35Â°N,45Â°E (â Baghdad) to 35Â°N,135Â°E (â Osaka), you would start on a heading of 60Â° and end up on a heading of 120Â°!).\n\nThis formula is for the initial bearing (sometimes referred to as forward azimuth) which if followed in a straight line along a great-circle arc will take you from the start point to the end point:1\n\nFormula: Î¸ = atan2( sin ÎÎ» â cos Ï2 , cos Ï1 â sin Ï2 â sin Ï1 â cos Ï2 â cos ÎÎ» ) where: Ï1,Î»1 is the start point, Ï2,Î»2 the end point (ÎÎ» is the difference in longitude) JavaScript:\n\n(all angles\n\nin radians)\n\nconst y = Math.sin(Î»2-Î»1) * Math.cos(Ï2); const x = Math.cos(Ï1)*Math.sin(Ï2) - Math.sin(Ï1)*Math.cos(Ï2)*Math.cos(Î»2-Î»1); const Î¸ = Math.atan2(y, x); const brng = (Î¸*180/Math.PI + 360) % 360; // in degrees\n\nExcel:\n\n(all angles\n\nin radians)\n\n=ATAN2(COS(lat1)*SIN(lat2)-SIN(lat1)*COS(lat2)*COS(lon2-lon1),\n\nSIN(lon2-lon1)*COS(lat2))\n\n*note that Excel reverses the arguments to ATAN2 â see notes below\n\nSince atan2 returns values in the range -Ï ... +Ï (that is, -180Â° ... +180Â°), to normalise the result to a compass bearing (in the range 0Â° ... 360Â°, with âve values transformed into the range 180Â° ... 360Â°), convert to degrees and then use (Î¸+360) % 360, where % is (floating point) modulo.\n\nFor final bearing, simply take the initial bearing from the end point to the start point and reverse it (using Î¸ = (Î¸+180) % 360).\n\nMidpoint\n\nThis is the half-way point along a great circle path between the two points.1\n\nFormula: Bx = cos Ï2 â cos ÎÎ» By = cos Ï2 â sin ÎÎ» Ïm = atan2( sin Ï1 + sin Ï2, √(cos Ï1 + Bx)Â² + ByÂ² ) Î»m = Î»1 + atan2(By, cos(Ï1)+Bx) JavaScript:\n\n(all angles\n\nin radians)\n\nconst Bx = Math.cos(Ï2) * Math.cos(Î»2-Î»1); const By = Math.cos(Ï2) * Math.sin(Î»2-Î»1); const Ï3 = Math.atan2(Math.sin(Ï1) + Math.sin(Ï2), Math.sqrt( (Math.cos(Ï1)+Bx)*(Math.cos(Ï1)+Bx) + By*By ) ); const Î»3 = Î»1 + Math.atan2(By, Math.cos(Ï1) + Bx);\n\nThe longitude can be normalised to â180â¦+180 using (lon+540)%360-180\n\nJust as the initial bearing may vary from the final bearing, the midpoint may not be located half-way between latitudes/longitudes; the midpoint between 35Â°N,45Â°E and 35Â°N,135Â°E is around 45Â°N,90Â°E.\n\nIntermediate point\n\nAn intermediate point at any fraction along the great circle path between two points can also be calculated.1\n\nFormula: a = sin((1âf)â Î´) / sin Î´ b = sin(fâ Î´) / sin Î´ x = a â cos Ï1 â cos Î»1 + b â cos Ï2 â cos Î»2 y = a â cos Ï1 â sin Î»1 + b â cos Ï2 â sin Î»2 z = a â sin Ï1 + b â sin Ï2 Ïi = atan2(z, √xÂ² + yÂ²) Î»i = atan2(y, x) where: f is fraction along great circle route (f=0 is point 1, f=1 is point 2), Î´ is the angular distance d/R between the two points.\n\nDestination point given distance and bearing from start point\n\nGiven a start point, initial bearing, and distance, this will calculate the destina­tion point and final bearing travelling along a (shortest distance) great circle arc.\n\nDestination point along great-circle given distance and bearing from start point\n\nStart point: , Bearing: Distance: km\n\nDestination point: Final bearing:\n\nview map\n\nhide map\n\nFormula: Ï2 = asin( sin Ï1 â cos Î´ + cos Ï1 â sin Î´ â cos Î¸ ) Î»2 = Î»1 + atan2( sin Î¸ â sin Î´ â cos Ï1, cos Î´ â sin Ï1 â sin Ï2 ) where: Ï is latitude, Î» is longitude, Î¸ is the bearing (clockwise from north), Î´ is the angular distance d/R; d being the distance travelled, R the earthâs radius JavaScript:\n\n(all angles\n\nin radians)\n\nconst Ï2 = Math.asin( Math.sin(Ï1)*Math.cos(d/R) + Math.cos(Ï1)*Math.sin(d/R)*Math.cos(brng) ); const Î»2 = Î»1 + Math.atan2(Math.sin(brng)*Math.sin(d/R)*Math.cos(Ï1), Math.cos(d/R)-Math.sin(Ï1)*Math.sin(Ï2));\n\nThe longitude can be normalised to â180â¦+180 using (lon+540)%360-180 Excel:\n\n(all angles\n\nin radians)\n\nlat2: =ASIN(SIN(lat1)*COS(d/R) + COS(lat1)*SIN(d/R)*COS(brng))\n\nlon2: =lon1 + ATAN2(COS(d/R)-SIN(lat1)*SIN(lat2), SIN(brng)*SIN(d/R)*COS(lat1))\n\n* Remember that Excel reverses the arguments to ATAN2 â see notes below\n\nFor final bearing, simply take the initial bearing from the end point to the start point and reverse it with (brng+180)%360.\n\nIntersection of two paths given start points and bearings\n\nThis is a rather more complex calculation than most others on this page, but I've been asked for it a number of times. This comes from Ed Williamâs aviation formulary. See below for the JavaScript.\n\nIntersection of two great-circle paths\n\nPoint 1: , Brng 1: Point 2: , Brng 2:\n\nIntersection point:\n\nFormula: Î´12 = 2â asin( √(sinÂ²(ÎÏ/2) + cos Ï1 â cos Ï2 â sinÂ²(ÎÎ»/2)) ) angular dist. p1âp2 Î¸a = acos( ( sin Ï2 â sin Ï1 â cos Î´12 ) / ( sin Î´12 â cos Ï1 ) )\n\nÎ¸b = acos( ( sin Ï1 â sin Ï2 â cos Î´12 ) / ( sin Î´12 â cos Ï2 ) ) initial / final bearings\n\nbetween points 1 & 2 if sin(Î»2âÎ»1) > 0\n\nÎ¸12 = Î¸a\n\nÎ¸21 = 2Ï â Î¸b\n\nelse\n\nÎ¸12 = 2Ï â Î¸a\n\nÎ¸21 = Î¸b Î±1 = Î¸13 â Î¸12\n\nÎ±2 = Î¸21 â Î¸23 angle p2âp1âp3\n\nangle p1âp2âp3 Î±3 = acos( âcos Î±1 â cos Î±2 + sin Î±1 â sin Î±2 â cos Î´12 ) angle p1âp2âp3 Î´13 = atan2( sin Î´12 â sin Î±1 â sin Î±2 , cos Î±2 + cos Î±1 â cos Î±3 ) angular dist. p1âp3 Ï3 = asin( sin Ï1 â cos Î´13 + cos Ï1 â sin Î´13 â cos Î¸13 ) p3 lat ÎÎ»13 = atan2( sin Î¸13 â sin Î´13 â cos Ï1 , cos Î´13 â sin Ï1 â sin Ï3 ) long p1âp3 Î»3 = Î»1 + ÎÎ»13 p3 long where\n\nÏ1, Î»1, Î¸13 : 1st start point & (initial) bearing from 1st point towards intersection point\n\nÏ2, Î»2, Î¸23 : 2nd start point & (initial) bearing from 2nd point towards intersection point\n\nÏ3, Î»3 : intersection point\n\n% = (floating point) modulo\n\nnote â if sin Î±1 = 0 and sin Î±2 = 0: infinite solutions\n\nif sin Î±1 â sin Î±2 < 0: ambiguous solution\n\nthis formulation is not always well-conditioned for meridional or equatorial lines\n\nThis is a lot simpler using vectors rather than spherical trigonometry: see latlong-vectors.html.\n\nCross-track distance\n\nHereâs a new one: Iâve sometimes been asked about distance of a point from a great-circle path (sometimes called cross track error).\n\nFormula: dxt = asin( sin(Î´13) â sin(Î¸13âÎ¸12) ) â R where Î´13 is (angular) distance from start point to third point\n\nÎ¸13 is (initial) bearing from start point to third point\n\nÎ¸12 is (initial) bearing from start point to end point\n\nR is the earthâs radius\n\nJavaScript:\n\nconst Î´13 = d13 / R; const dXt = Math.asin(Math.sin(Î´13)*Math.sin(Î¸13-Î¸12)) * R;\n\nHere, the great-circle path is identified by a start point and an end point â depending on what initial data youâre working from, you can use the formulas above to obtain the relevant distance and bearings. The sign of dxt tells you which side of the path the third point is on.\n\nThe along-track distance, from the start point to the closest point on the path to the third point, is\n\nFormula: dat = acos( cos(Î´13) / cos(Î´xt) ) â R where Î´13 is (angular) distance from start point to third point\n\nÎ´xt is (angular) cross-track distance\n\nR is the earthâs radius\n\nJavaScript:\n\nconst Î´13 = d13 / R; const dAt = Math.acos(Math.cos(Î´13)/Math.cos(dXt/R)) * R;\n\nClosest point to the poles\n\nAnd: âClairautâs formulaâ will give you the maximum latitude of a great circle path, given a bearing Î¸ and latitude Ï on the great circle:\n\nFormula: Ïmax = acos( | sin Î¸ â cos Ï | ) JavaScript:\n\nconst ÏMax = Math.acos(Math.abs(Math.sin(Î¸)*Math.cos(Ï)));\n\nRhumb lines\n\nA ârhumb lineâ (or loxodrome) is a path of constant bearing, which crosses all meridians at the same angle.\n\nSailors used to (and sometimes still) navigate along rhumb lines since it is easier to follow a constant compass bearing than to be continually adjusting the bearing, as is needed to follow a great circle. Rhumb lines are straight lines on a Mercator Projec­tion map (also helpful for naviga­tion).\n\nRhumb lines are generally longer than great-circle (orthodrome) routes. For instance, London to New York is 4% longer along a rhumb line than along a great circle â important for avia­tion fuel, but not particularly to sailing vessels. New York to Beijing â close to the most extreme example possible (though not sailable!) â is 30% longer along a rhumb line.\n\nRhumb-line distance between two points\n\nPoint 1: , Point 2: ,\n\nDistance: km Bearing: Midpoint:\n\nview map\n\nhide map\n\nDestination point along rhumb line given distance and bearing from start point\n\nStart point: , Bearing: Distance: km\n\nDestination point:\n\nview map\n\nhide map\n\nKey to calculations of rhumb lines is the inverse Gudermannian func­tionÂ¹, which gives the âisometric latitudeâ (Ï), equivalent to the height on a Mercator projec­tion map of a given geodetic latitude â this can be expessed in various ways:\n\nÏ = ln( tan(Ï/4 + Ï/2) ) Ï = ln( tanÏ + secÏ ) [i.e. ln( tanÏ + 1/cosÏ )] Ï = asinh( tanÏ ) [â¡ atanh( sinÏ )]\n\nThe isometric latitude of course tends to infinity at the poles (in keeping with the Mercator projec­tion).\n\nFor obsessives, this is a simplification of the full ellipsoidal version:\n\nÏ = ln( tan(Ï/4+Ï/2) â [ (1âeâ sinÏ) / (1+eâ sinÏ) ]e/2) Ï = asinh(tanÏ) â eâ atanh(eâ sinÏ)\n\nwhere e is the eccentricity\n\nThe formulas to derive Mercator projection easting and northing coordinates from spherical latitude and longitude are then:\n\nE = R â Î» N = R â ln( tan(Ï/4 + Ï/2) )\n\nThe following formulas are from Ed Williamsâ aviation formularyÂ¹.\n\nDistance\n\nSince a rhumb line is a straight line on a Mercator projec­tion, the distance between two points along a rhumb line is the length of that line (by Pythagoras); but the distor­tion of the projec­tion needs to be compensated for.\n\nOn a constant latitude course (travelling east-west), this compensa­tion is simply cosÏ; in the general case, it is ÎÏ/ÎÏ where ÎÏ is the âisometricâ (projected) latitude difference.\n\nFormula: ÎÏ = ln( tan(Ï/4 + Ï2/2) / tan(Ï/4 + Ï1/2) ) q = ÎÏ / ÎÏ (or cosÏ for E-W line) d = √(ÎÏÂ² + qÂ²â ÎÎ»Â²) â R (Pythagoras) where: Ï is geodetic latitude, Ï is isometric latitude, Î» is longitude, ÎÎ» is taking shortest route (<180Â°), R is the earthâs radius, ln is natural log JavaScript:\n\n(all angles\n\nin radians)\n\nconst ÎÏ = Math.log(Math.tan(Math.PI/4+Ï2/2) / Math.tan(Math.PI/4+Ï1/2)); const q = Number.isFinite(ÎÏ/ÎÏ) ? ÎÏ/ÎÏ : Math.cos(Ï1); // E-W course becomes ill-conditioned with 0/0 // if dLon over 180Â° take shorter rhumb line across the anti-meridian: if (Math.abs(ÎÎ») > Math.PI) ÎÎ» = ÎÎ»>0 ? -(2*Math.PI-ÎÎ») : (2*Math.PI+ÎÎ»); const dist = Math.sqrt(ÎÏ*ÎÏ + q*q*ÎÎ»*ÎÎ») * R;\n\nBearing\n\nA rhumb line is a straight line on a Mercator projection, with an angle on the projec­tion equal to the compass bearing.\n\nFormula: ÎÏ = ln( tan(Ï/4 + Ï2/2) / tan(Ï/4 + Ï1/2) ) Î¸ = atan2(ÎÎ», ÎÏ) where: Ï is geodetic latitude, Ï is isometric latitude, Î» is longitude, ÎÎ» is taking shortest route (<180Â°), R is the earthâs radius, ln is natural log JavaScript:\n\n(all angles\n\nin radians)\n\nconst ÎÏ = Math.log(Math.tan(Math.PI/4+Ï2/2)/Math.tan(Math.PI/4+Ï1/2)); // if dLon over 180Â° take shorter rhumb line across the anti-meridian: if (Math.abs(ÎÎ») > Math.PI) ÎÎ» = ÎÎ»>0 ? -(2*Math.PI-ÎÎ») : (2*Math.PI+ÎÎ»); const brng = Math.atan2(ÎÎ», ÎÏ) * 180/Math.PI;\n\nDestination\n\nGiven a start point and a distance d along constant bearing Î¸, this will calculate the destina­tion point. If you maintain a constant bearing along a rhumb line, you will gradually spiral in towards one of the poles.\n\nFormula: Ï2 = Ï1 + Î´ â cos Î¸ ÎÏ = ln( tan(Ï/4 + Ï2/2) / tan(Ï/4 + Ï1/2) ) q = ÎÏ / ÎÏ (or cos Ï for E-W line) ÎÎ» = Î´ â sin Î¸ / q Î»2 = Î»1 + ÎÎ» where: Î´ is angular distance, Ï is geodetic latitude, Ï is isometric latitude, Î» is longitude, ÎÎ» is taking shortest route (<180Â°), ln is natural log, R is the earthâs radius JavaScript:\n\n(all angles\n\nin radians)\n\nconst Î´ = d/R; const ÎÏ = Î´ * Math.cos(Î¸); const Ï2 = Ï1 + ÎÏ; const ÎÏ = Math.log(Math.tan(Ï2/2+Math.PI/4)/Math.tan(Ï1/2+Math.PI/4)); const q = Math.abs(ÎÏ) > 10e-12 ? ÎÏ / ÎÏ : Math.cos(Ï1); // E-W course becomes ill-conditioned with 0/0 const ÎÎ» = Î´*Math.sin(Î¸)/q; const Î»2 = Î»1 + ÎÎ»; // check for some daft bugger going past the pole, normalise latitude if so if (Math.abs(Ï2) > Math.PI/2) Ï2 = Ï2>0 ? Math.PI-Ï2 : -Math.PI-Ï2;\n\nThe longitude can be normalised to â180â¦+180 using (lon+540)%360-180\n\nMid-point\n\nThis formula for calculating the âloxodromic midpointâ, the point half-way along a rhumb line between two points, is due to Robert Hill and Clive Tooth1 (thx Axel!).\n\nFormula: Ïm = (Ï1+Ï2) / 2 f1 = tan(Ï/4 + Ï1/2) f2 = tan(Ï/4 + Ï2/2) fm = tan(Ï/4+Ïm/2) Î»m = [ (Î»2âÎ»1) â ln(fm) + Î»1 â ln(f2) â Î»2 â ln(f1) ] / ln(f2/f1) where: Ï is latitude, Î» is longitude, ln is natural log JavaScript:\n\n(all angles\n\nin radians)\n\nif (Math.abs(Î»2-Î»1) > Math.PI) Î»1 += 2*Math.PI; // crossing anti-meridian const Ï3 = (Ï1+Ï2)/2; const f1 = Math.tan(Math.PI/4 + Ï1/2); const f2 = Math.tan(Math.PI/4 + Ï2/2); const f3 = Math.tan(Math.PI/4 + Ï3/2); const Î»3 = ( (Î»2-Î»1)*Math.log(f3) + Î»1*Math.log(f2) - Î»2*Math.log(f1) ) / Math.log(f2/f1); if (!isFinite(Î»3)) Î»3 = (Î»1+Î»2)/2; // parallel of latitude\n\nThe longitude can be normalised to â180â¦+180 using (lon+540)%360-180\n\nUsing the scripts in web pages\n\nUsing these scripts in web pages would be something like the following:\n\n<!doctype html> <html lang=\"en\"> <head> <title>Using the scripts in web pages</title> <meta charset=\"utf-8\"> <script type=\"module\"> import LatLon from 'https://cdn.jsdelivr.net/npm/geodesy@2/latlon-spherical.min.js'; document.addEventListener('DOMContentLoaded', function() { document.querySelector('#calc-dist').onclick = function() { calculateDistance(); } }); function calculateDistance() { const p1 = LatLon.parse(document.querySelector('#point1').value); const p2 = LatLon.parse(document.querySelector('#point2').value); const dist = parseFloat(p1.distanceTo(p2).toPrecision(4)); document.querySelector('#result-distance').textContent = dist + ' metres'; } </script> </head> <body> <form> Point 1: <input type=\"text\" name=\"point1\" id=\"point1\" placeholder=\"lat1,lon1\"> Point 2: <input type=\"text\" name=\"point2\" id=\"point2\" placeholder=\"lat2,lon2\"> <button type=\"button\" id=\"calc-dist\">Calculate distance</button> <output id=\"result-distance\"></output> </form> </body> </html>\n\nConvert between degrees-minutes-seconds & decimal degrees\n\nLatitude Longitude d 1Â° â 111 km (110.57 eqâl â 111.70 polar) dm 1â² â 1.85 km (= 1 nm) 0.01Â° â 1.11 km dms 1â³ â 30.9 m 0.0001Â° â 11.1 m\n\nDisplay calculation results as: degrees deg/min deg/min/sec\n\nNotes:\n\nAccuracy: since the earth is not quite a sphere, there are small errors in using spherical geometry; the earth is actually roughly ellipsoidal (or more precisely, oblate spheroidal) with a radius varying between about 6,378km (equatorial) and 6,357km (polar), and local radius of curvature varying from 6,336km (equatorial meridian) to 6,399km (polar). 6,371 km is the generally accepted value for the earthâs mean radius. This means that errors from assuming spherical geometry might be up to 0.55% crossing the equator, though generally below 0.3%, depending on latitude and direction of travel (whuber explores this in excellent detail on stackexchange). An accuracy of better than 3m in 1km is mostly good enough for me, but if you want greater accuracy, you could use the Vincenty formula for calculating geodesic distances on ellipsoids, which gives results accurate to within 1mm. (Out of sheer perversity â Iâve never needed such accuracy â I looked up this formula and discovered the JavaScript implementation was simpler than I expected).\n\nTrig functions take arguments in radians, so latitude, longitude, and bearings in degrees (either decimal or degrees/minutes/seconds) need to be converted to radians, rad = degâ Ï/180. When converting radians back to degrees (deg = radâ 180/Ï), West is negative if using signed decimal degrees. For bearings, values in the range -Ï to +Ï [-180Â° to +180Â°] need to be converted to 0 to +2Ï [0Â°â360Â°]; this can be done by (brng+360)%360 where % is the (floating point) modulo operator (note that different languages implement the modulo operation in different ways).\n\nAll bearings are with respect to true north, 0Â°=N, 90Â°=E, etc; if you are working from a compass, magnetic north varies from true north in a complex way around the earth, and the difference has to be compensated for by variances indicated on local maps.\n\nThe atan2() function widely used here takes two arguments, atan2(y, x), and computes the arc tangent of the ratio y/x. It is more flexible than atan(y/x), since it handles x=0, and it also returns values in all 4 quadrants -Ï to +Ï (the atan function returns values in the range -Ï/2 to +Ï/2).\n\nIf you implement any formula involving atan2 in a spreadsheet (Microsoft Excel, LibreOffice Calc, Google Sheets, Apple Numbers), you will need to reverse the arguments, as Excel etc have them the opposite way around from JavaScript â conventional order is atan2(y, x), but Excel uses atan2(x, y). To use atan2 in a (VBA) macro, you can use WorksheetFunction.Atan2().\n\nIf you are using Google Maps, several of these functions are now provided in the Google Maps API V3 âsphericalâ library (computeDistanceBetween(), computeHeading(), computeOffset(), interpolate(), etc; note they use a default Earth radius of 6,378,137 meters).\n\nIf you use UK Ordnance Survey Grid References, I have implemented a script for converting between Lat/Long & OS Grid References.\n\nIf you use UTM coordinates or MGRS grid references, I have implemented scripts for converting between Lat/Long, UTM, & MGRS.\n\nI learned a lot from the US Census Bureau GIS FAQ which is no longer available, so Iâve made a copy.\n\nThanks to Ed Williamsâ Aviation Formulary for many of the formulas.\n\nFor miles, divide km by 1.609344\n\nFor nautical miles, divide km by 1.852\n\nSee below for the JavaScript source code, also available on GitHub. Full documentation is available, as well as a test suite.\n\nNote I use Greek letters in variables representing maths symbols conventionally presented as Greek letters: I value the great benefit in legibility over the minor inconvenience in typing (if you encounter any problems, ensure your <head> includes <meta charset=\"utf-8\">), and use UTF-8 encoding when saving files).\n\nWith its untyped C-style syntax, JavaScript reads remarkably close to pseudo-code: exposing the algorithms with a minimum of syntactic distractions. These functions should be simple to translate into other languages if required, though can also be used as-is in browsers and Node.js.\n\nFor convenience & clarity, I have extended the base JavaScript Number object with toRadians() and toDegrees() methods: I donât see great likelihood of conflicts, as these are ubiquitous operations.\n\nI also have a page illustrating the use of the spherical law of cosines for selecting points from a database within a specified bounding circle â the example is based on MySQL+PDO, but should be extensible to other DBMS platforms.\n\nSeveral people have asked about example Excel spreadsheets, so I have implemented the distance & bearing and the destination point formulas as spreadsheets, in a form which breaks down the all stages involved to illustrate the operation.\n\nFebruary 2019: I have refactored the library to use ES modules, as well as extending it in scope; see the GitHub README and CHANGELOG for details.\n\nPerformance: as noted above, the haversine distance calculation takes around 2 â 5 micro­seconds (hence around 200,000 â 500,000 per second). I have yet to complete timing tests on other calculations.\n\nOther languages: I cannot support translations into other languages, but if you have ported the code to another language, I am happy to provide links here.\n\nBrian Lambert has made an Objective-C version.\n\nJean Brouwers has made a Python version.\n\nVahan Aghajanyan has made a C++ version.\n\nBahadÄ±r Arslan has made a Kotlin version and a Dart version.\n\nI offer these scripts for free use and adaptation to balance my debt to the open-source info-verse. You are welcome to re-use these scripts [under an MIT licence, without any warranty express or implied] provided solely that you retain my copyright notice and a link to this page.\n\nIf you need any advice or development work done, I am available for consultancy.\n\nIf you have any queries or find any problems, contact me at ku.oc.epyt-elbavom@oeg-stpircs."
    }
}