{
    "id": "dbpedia_3062_3",
    "rank": 74,
    "data": {
        "url": "https://www.run.ai/blog/serving-large-language-models",
        "read_more_link": "",
        "language": "en",
        "title": "What it means to serve an LLM and which serving technology to choose from",
        "top_image": "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/6661a68efc253be38b4ea6b1_LLMs-1.jpg",
        "meta_img": "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/6661a68efc253be38b4ea6b1_LLMs-1.jpg",
        "images": [
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/635a79ad72a1555286e378b9_RunAi_Logo_Digital_2C_BP.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/65e8dbe18012c733c79b5248_dev.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/65e8e16a4d53eccf2f744266_control%20plane.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/65e8dbe108e7b027121e9352_cluster-engine.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/6661e523bd5e016fc51fcde8_blog-header-llms.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659c952a29442d6bdce7f888_image5.png",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659c955429442d6bdce80b71_image3.png",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659c958b97db5b5334492c5e_image2.png",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659cbf9fe9578c07862d1358_A%20comparison%20of%20engine%20and%20server%20capabilities.jpg",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659cbff7f410febe78e76f98_image4.png",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659cc10aad91d851af1a258c_image1.png",
            "https://cdn.prod.website-files.com/61e95e54543a7c7d5467fffe/659d115fdc979fb08cd48609_Generation.gif",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/64526239b6cfe10e9606c4aa_Run-ai-logo-white.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/629b52048c5f7d5b564918a2_AICPA-Soc-2.webp",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/645268506aa1e79f1018b6ce_mdi_github.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/6452684fdcc6b88e55b186ad_ri_youtube-fill.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/6452684fbd06fd348d5c85b7_instagram.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/6452684ff5d46bf61219fb4d_mdi_linkedin.svg",
            "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/6452684f75706afdf43ef504_mdi_twitter.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Run:ai Team"
        ],
        "publish_date": "2024-07-24T00:00:00",
        "summary": "",
        "meta_description": "This benchmarking study assesses the performance of large language models (LLMs) through an exploration of model-serving frameworks, focusing on the critical aspect of throughput.",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.prod.website-files.com/61e95e54543a7c0a5967ffd1/621f9accba9df5780351deaf_Favicon_32x32%20(1).png",
        "meta_site_name": "",
        "canonical_link": "https://www.run.ai/blog/serving-large-language-models",
        "text": "The rapidly growing interest in leveraging large language models (LLMs) for a wide range of applications has led to extensive exploration within both the industry and the open-source community. As the demand for these models in production environments continues to rise, the need to understand the available tools and frameworks alongside with their offerings and differences, becomes increasingly significant.\n\nThis blogpost takes a deep dive into what model serving is, the relevant components, parameters and evaluation metrics to pay attention to and model-serving frameworks, with a specific focus on their offerings and differences.\n\nTogether with this blogpost, we also release a whitepaper where we share the performance analysis for each tool, measuring throughput for various input/output length, batch sizes and request rate per second. By evaluating inference engines such as TensorRT-LLM, vLLM and inference servers such as RayLLM with RayServe, TGI and TensorRT-LLM + Triton, our goal is to provide ML practitioners with some insights. We share our main learnings at the end of this blogpost as well. Please refer to the whitepaper for more information about the experimental setting and findings.\n\nText Generation Process with LLMs\n\nBefore jumping into serving LLMs, letâs refresh our memory about how they actually work. So, the generation process of LLMs has two main steps; tokenization and decoding. Before jumping into the explanation of both steps, here are some terms to clarify:\n\nInput sequence: The text that the user sends to the language model to be processed.\n\nOutput sequence: The text that the language model generates after receiving the input sequence from the users.\n\nInput length: The number of tokens that input sequence contains\n\nOutput length: The number of tokens that output sequence contains\n\nToken: The unit of text that model reads to generate the next token. This can be a whole word or a part of the word depending on how the tokenizer tokenizes the text (see Figure 1).\n\nNow we went through all needed terms, letâs start with an example: We have a chatbot that is powered by an LLM and we received an input sequence from one of the users. Can LLMs or any other machine learning model work with words for computing the weights and doing the matrix multiplication? Of course not. Since the machines, thus language models, canât work with string, the input sequence is turned into tokens and then each of those tokens are converted into embeddings (see Figure 2), which can be fed to LLM. Each token is represented by an embedding vector.\n\nIn the decoding part, LLM will generate the next token in an autoregressive manner. In the next iteration, the newly generated token will be appended to the input sequence and the generation process will keep going until LLM hits the stopping criteria (e.g. maximum number of tokens, generation of a special <end> token). For more information about the generation process, refer to this blog.\n\nMetrics for LLM Serving\n\nWhen it comes to serving these models, there are two important metrics that needs to be underlined: throughput and latency.\n\nThroughput\n\nThroughput tells us how many users our system can handle effectively. Throughput stands for the number of generated tokens per second by the inference server throughout the multiple requests by the users. The higher the throughput, the better our system can accommodate and respond to user requests.\n\nLatency\n\nLatency, on the other hand, reflects the time it takes for the server and model to generate the complete output in the output sequence. If we're streaming the generated output to the end user, latency specifically refers to the time taken by the inference server to generate the very first token. This initial token generation time is also known as the \"time to first token\" (TTFT). Essentially, latency gives us insights into how responsive and swift our system is in delivering results to the end user\n\nIn a nutshell, let's simplify these concepts: latency is what users feelâthe time it takes to receive an answer from the chatbot. Meanwhile, throughput is not only about how many users our system can effectively handle simultaneously but also impacts the user experience in stream modeâusers feel the speed at which new words are generated. These metrics collectively shape our understanding of the system's performance and user experience.\n\nWhat you need to serve an LLM\n\nâ\n\nWhen it comes to serving LLM based applications, there are 2 main components: engine and server. The engine handles everything about the models and batching the requests, while the server handles forwarding the user requests.\n\nEngines\n\nEngines are what run the models and everything that we covered so far about the generation process with different types of optimization techniques. In their core, these are Python libraries. They handle batching of the requests that are coming from users to our chatbot and generating the response for those requests.\n\nServers\n\nServers are responsible for orchestrating the HTTP/gRPC requests coming in from the users. In real world applications, we will have many users asking questions to our chatbot at different times of the day. Servers queue these requests and forward them to the engine for the generation of the response. Servers also bring the metrics such as throughput and latency, which are important to track for model serving.\n\nCapabilities\n\nEngines\n\nMemory optimization\n\nModel specific optimization\n\nBatching support\n\nServers\n\nHTTP/gRPC APIs\n\nRequest queuing\n\nMulti-model serving\n\nMulti-engine support\n\nâ\n\nSo far, we discussed a straightforward scenario where the model handles a single request. However, real-life applications demand the ability to serve hundreds, even thousands of users concurrently. Now, our focus shifts to optimizing costs and throughput, leading us to the next critical considerations: request batching and memory optimization with PagedAttention. These optimizations are pivotal for hosting the model efficiently, ensuring both cost-effectiveness and high throughput in the case of substantial user demand.\n\nRequest batching\n\nOne important aspect of LLM serving is batching the user requests. Rather than reloading parameters for each new request, an efficient approach involves loading parameters onto the GPU once and utilizing them to process as many input sequences as possible in one go. This method not only boosts server throughput and optimizes compute utilization but also significantly contributes to cost-effectiveness. However, adopting a naive approach, like waiting for a fixed number of user requests to accumulate before processing the batch, presents challenges. This means that each request generates the end of sequence token at different times within a batch. Consequently, your batch computation speed is limited by the longest generation time, resulting in undesirable waiting times (latency) for users. The variations in completion times among sequences lead to GPU underutilization, diminishing the efficiency gains expected from batching.\n\nBecause of all the challenges that we talked about, continuous batching has been presented to solve these problems.\n\nContinuous batching\n\nContinuous batching is a type of batch scheduling that is specifically designed for LLMs. In comparison to dynamic batching, where batch size is determined dynamically according to configured time threshold and maximum batch size, continuous batching lets new requests join to the current batch in the next decoder cycle, instead of waiting for the current batch to end. Due to the autoregressive generation process of LLMs, this method works easily for LLMs and highly increases the throughput of the model.\n\nContinuous batching is great for batching the requests dynamically. However, we also face another problem: memory boundedness. Consider our chatbot scenarioâone user might ask a question with a single sentence while another user sends a paragraph to our application - it is impossible to assume the length of input (and output) sequences. This uncertainty brings us to the critical problem of memory consumption. Without knowing the exact memory requirements of a sequence, one is compelled to adopt the worst-case scenario, reserving the highest possible memory for the entire batch. Here's the issue: GPUs have finite memory, needing space for both 1) model parameters and 2) user request computations (KV cache) 3) for whole batch computations. Without optimization, these take up a lot of room, forcing us to shrink the batch size and, unfortunately, decrease throughput. But we want high throughput. How do we optimize this? Memory is the key.\n\nLetâs have a deeper look into what is happening in the decoding process from a memory point of view. Generation process of the LLMs starts with processing the input sequence and generating the next token one by one in an autoregressive manner (see Figure 5). This generation process includes self-attention calculation which needs all key-value (KV) score calculations of each token that has been processed so far. To illustrate, for generation of the token t, we need the calculated key and values from the tokens t-1, t-2,....1.\n\nâ\n\nâ\n\nTo optimize the recurrent calculation, the concept of KV caching is introduced. This method aims to store previously computed K and V tensors of tokens in the decoder, subsequently reusing them in next iterations. However, this optimization strategy comes at the expense of increased memory space, which is very critical when the batch size is also high to increase the throughput. The challenge escalates due to the unpredictable sequence length, leading traditional attention mechanisms to result in a significant waste of memoryâranging from 60% to 80%âdue to fragmentation and over-allocation.\n\nPagedAttention: A Memory-Centric Solution\n\nTo overcome this challenge, PagedAttention is proposed. Drawing inspiration from the traditional operating systemâs (OS) strategies for managing memory fragmentation and sharing, PagedAttention uses a virtual memory approach with paging. It allows the key and value vectors to be stored in non-contiguous memory space. This allows key and value vectors to reside in non-contiguous memory spaces, organized into blocks. Each block accommodates attention keys and values for a fixed number of tokens. While performing the computation, the PagedAttention kernel identifies and fetches the blocks efficiently. For a deeper dive into KV caching and PagedAttention, please refer to this paper and this blog.\n\nPutting Knowledge into Action: Selecting Frameworks for LLM Serving\n\nNow that we've covered important metrics, trade-offs, and techniques to handle critical challenges in LLM serving, the big question is: How do we put these techniques into action? Which tools are the best fit for our needs, and what should we know about the frameworks before diving in?\n\nIn this section, we delve into all these details of the key frameworks, sharing the primary findings derived from our benchmarking experiments. We picked popular and widely-used frameworks in the industry. Each framework has a unique value in optimizing and enhancing the performance of Large Language Models (LLMs) during inference. We categorize these frameworks into two groups: servers and engines. By the end, you will have a clear picture of the available tools and their potential fit for your specific LLM serving requirements.\n\nEngines\n\nTensorRT-LLM\n\nAn open-source library designed to accelerate and optimize inference performance on the latest LLMs using NVIDIA Tensor Core GPUs [4].\n\nWraps TensorRTâs Deep Learning Compiler, optimized kernels from FasterTransformer, pre- and post-processing, and multi-GPU/multi-node communication in a simple, open-source Python API for defining, optimizing and executing LLMs in production\n\nUtilizing tensor parallelism, TensorRT-LLM allows for efficient inference at scale across multiple GPUs and servers without the need for extensive developer intervention.\n\nIncludes highly optimized, ready-to-run versions of popular LLMs, such as Meta Llama 2, OpenAI GPT-2 and GPT-3, Falcon, Mosaic MPT, and more.\n\nProvides a C++ runtime for executing LLM engines, offering features like token sampling and KV cache management, further enhancing the efficiency of inference.\n\nSupports in-flight batching, also known as continuous batching or iteration-level batching. This is a technique that aims at reducing wait times in queues, eliminating the need for padding requests, and making higher GPU utilization possible.\n\nAims to simplify the process of building and experimenting with new LLMs, providing peak performance and customization without requiring deep knowledge of C++ or NVIDIA CUDA.\n\nImportant notes:\n\nTensorRT-LLM is creating the engine specifically for the flags that are used when running the build.py function. Therefore, it is important to note that you should specify maximum input, output length and maximum batch size before building the engine. If you want to change any of the parameters, you will need to rebuild the engine. This will take a couple of minutes.\n\nTensorRT-LLM doesnât tokenize the input. The users will need to tokenize the input and send it to the TensorRT-LLM engine. The engine only accepts token IDs.\n\nManaging the allocation of the KV cache is not open sourced. Therefore, it is not very clear how it is exactly managed. However, we observed that TensorRT-LLM calculates the required memory depending on the batch size and input-output length and pre-allocates the KV cache memory accordingly. This memory is managed during runtime.\n\nvLLM\n\nA high-performance library tailored for LLM inference and serving, emphasizing state-of-the-art serving throughput and efficient management of attention [6].\n\nMemory efficiency and high throughput are at the core of vLLM, thanks to its innovative PagedAttention mechanism. This approach optimizes memory allocation and allows for non-contiguous KV cache, translating into higher batch sizes and cost-effective serving [2].\n\nIncludes support for continuous batching, GPU parallelism, streaming output, and OpenAI compatibility.\n\nProvides a Python API for conducting offline batched inference on datasets, establishing API servers for LLMs, and launching OpenAI-compatible API servers.\n\nImportant notes:\n\nWhen there is a high request rate with high batch sizes, the memory can create a bottleneck. In this case, vLLM starts to preempt already calculated paged attentions due to memory shortage. This leads to more compute need in the long term when there are upcoming sequences from the user for the same request.\n\nServers\n\nRayLLM with RayServe:\n\nBuilt on Ray Serve, RayLLM benefits from a distributed compute framework that provides specialized libraries for data streaming, training, fine-tuning, hyperparameter tuning, and serving, simplifying the development and deployment of large-scale AI models [8].\n\nSupports deployment of multi model endpoint.\n\nIt provides server capabilities while engine capabilities are provided by integrations such as continuous batching, paged attention, and other optimization techniques through TGI and vLLM integration.\n\nTriton with TensorRT-LLM (Triton backend for TensorRT-LLM)\n\nAn open-source inference serving software that provides the ability to deploy models at scale in production environments. It supports various machine learning frameworks and is designed for high throughput and low latency inference workloads.\n\nThe Triton backend for TensorRT-LLM provides a solution for optimizing, deploying, and running LLMs efficiently. This combination leverages techniques like in-flight batching and paged KV-caching to enhance performance, while leveraging the advantages of TensorRT-LLM for rapid inference execution [9].\n\nIt works as an ensemble of models - There are multiple pipelines. First one handles tokenizing, which is handled by the Tokenizers from HuggingFace library. The next one is TensorRT-LLM with engine capabilities.\n\nServer and Engine\n\nText Generation Inference (TGI)\n\nA Rust, Python, gRPC server, used at HuggingFace to power HuggingChat, the Inference API and Inference Endpoint.\n\nUtilizes tensor parallelism (Accelerate) for faster inference on multiple GPUs\n\nSupports continuous batching for increased throughput, quantization, Paged and FlashAttention, token streaming using Server-Sent Events (SSE) and many more\n\nLogits warper (different parameters such as temperature,repetition penalty, top-k, top-n, etc.)\n\nSupports optimized set of specific LLMs\n\nThe license for usage has been changed. It is not free of charge for commercial use.\n\nMain Findings\n\nWe assess the performance of these frameworks and their offerings in our whitepaper using different setups. Each frameworkâbe it engines like TensorRT-LLM and vLLM, or servers like RayLLM with RayServe, Triton with TensorRT-LLM, and Text Generation Inference (TGI)âbrings unique capabilities to the table, which are valuable for different use cases. Our benchmarking study uncovered nuanced findings, from memory allocation challenges to the strategic trade-offs of preemptions and the influence of sequence length on throughput. Here is a short overview what we have learned from the experiments:\n\nMemory is the key. Management of memory allocation is critical for optimizing LLM performance.\n\nPreemptions are a strategic trade-off for engines like vLLM since the generation operation is memory-bound while GPU is being underutilized.\n\nSequence length insight reveals vLLM's efficiency in handling concurrent requests, particularly with shorter outputs.\n\nModel size significantly affects throughput. However, beyond a certain point, additional GPU memory no longer contributes to higher throughput.\n\nServer selection plays a vital role, as demonstrated by TensorRT-LLM with Triton outperforming standalone TensorRT-LLM in the whitepaper.\n\nFor a more detailed overview of these findings, refer to our comprehensive benchmarking study white paper.\n\nFinal words\n\nUnderstanding the text generation with LLMs, we have walked through tokenization, decoding, the challenges in serving effectively, the current state-of-the-art techniques and tools that try to solve these challenges. Metrics like throughput and latency emerged as critical benchmarks, influencing both user handling and streaming experiences that the teams need to pay attention to.\n\nThe landscape of LLMs and serving LLMs is growing every day. This blogpost and our white paper reflects the current state at time, but the field is constantly evolving, introducing new tools and techniques. Stay informed, embrace change, and explore new technologies to stay at the forefront of this transformative domain.\n\nReferences\n\n[1]: MunichNLP x TUM.AI LLM workshop\n\n[2]: https://www.anyscale.com/blog/continuous-batching-llm-inference\n\n[3]: https://huggingface.co/docs/transformers/llm_tutorial\n\n[4]: https://developer.nvidia.com/blog/nvidia-tensorrt-llm-supercharges-large-language-model-inference-on-nvidia-h100-gpus/\n\n[5]: https://developer.nvidia.com/blog/optimizing-inference-on-llms-with-tensorrt-llm-now-publicly-available/\n\n[6]: https://github.com/vllm-project/vllm\n\n[7]: https://vllm.readthedocs.io/en/latest/getting_started/quickstart.html\n\n[8]: https://docs.ray.io/en/latest/ray-overview/use-cases.html\n\n[9]: https://github.com/triton-inference-server/tensorrtllm_backend"
    }
}