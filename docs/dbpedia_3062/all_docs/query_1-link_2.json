{
    "id": "dbpedia_3062_1",
    "rank": 2,
    "data": {
        "url": "https://www.geeksforgeeks.org/difference-between-compile-time-and-run-time-polymorphism-in-java/",
        "read_more_link": "",
        "language": "en",
        "title": "Difference between Compile",
        "top_image": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_200x200-min.png",
        "meta_img": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_200x200-min.png",
        "images": [
            "https://media.geeksforgeeks.org/gfg-gg-logo.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/Google-news.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/Google-news.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/new-premium-rbanner-us.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/gfgFooterLogo.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/googleplay.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/appstore.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/suggestChangeIcon.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/createImprovementIcon.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Data Structures",
            "Algorithms",
            "Python",
            "Java",
            "C",
            "C++",
            "JavaScript",
            "Android Development",
            "SQL",
            "Data Science",
            "Machine Learning",
            "PHP",
            "Web Development",
            "System Design",
            "Tutorial",
            "Technical Blogs",
            "Interview Experience",
            "Interview Preparation",
            "Programming",
            "Competitive Programming",
            "Jobs",
            "Coding Contests",
            "GATE CSE",
            "HTML",
            "CSS",
            "React",
            "NodeJS",
            "Placement",
            "Aptitude",
            "Quiz",
            "Computer Science",
            "Programming Examples",
            "GeeksforGeeks Courses",
            "Puzzles",
            "SSC",
            "Banking",
            "UPSC",
            "Commerce",
            "Finance",
            "CBSE",
            "School",
            "k12",
            "General Knowledge",
            "News",
            "Mathematics",
            "Exams"
        ],
        "tags": null,
        "authors": [
            "GeeksforGeeks"
        ],
        "publish_date": "2020-06-09T12:00:20",
        "summary": "",
        "meta_description": "A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.",
        "meta_lang": "en",
        "meta_favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "meta_site_name": "GeeksforGeeks",
        "canonical_link": "https://www.geeksforgeeks.org/difference-between-compile-time-and-run-time-polymorphism-in-java/",
        "text": "The word polymorphism means having many forms. In simple words, we can define polymorphism as the ability of a message to be displayed in more than one form. In this article, we will see the difference between two types of polymorphisms, compile time and run time.\n\nCompile Time Polymorphism: Whenever an object is bound with its functionality at the compile time, this is known as the compile-time polymorphism. At compile-time, java knows which method to call by checking the method signatures. So this is called compile-time polymorphism or static or early binding. Compile-time polymorphism is achieved through method overloading. Method Overloading says you can have more than one function with the same name in one class having a different prototype. Function overloading is one of the ways to achieve polymorphism but it depends on technology and which type of polymorphism we adopt. In java, we achieve function overloading at compile-Time. The following is an example where compile-time polymorphism can be observed.\n\nJava\n\n// Java program to demonstrate // compile-time polymorphism publicclass GFG{ // First addition function publicstaticintadd(inta,intb) { returna+b; } // Second addition function publicstaticdoubleadd( doublea,doubleb) { returna+b; } // Driver code publicstaticvoidmain(Stringargs[]) { // Here, the first addition // function is called System.out.println(add(2,3)); // Here, the second addition // function is called System.out.println(add(2.0,3.0)); } }\n\nOutput\n\n5 5.0\n\nRun-Time Polymorphism: Whenever an object is bound with the functionality at run time, this is known as runtime polymorphism. The runtime polymorphism can be achieved by method overriding. Java virtual machine determines the proper method to call at the runtime, not at the compile time. It is also called dynamic or late binding. Method overriding says the child class has the same method as declared in the parent class. It means if the child class provides the specific implementation of the method that has been provided by one of its parent classes then it is known as method overriding. The following is an example where runtime polymorphism can be observed.\n\nJava\n\n// Java program to demonstrate // runtime polymorphism // Implementing a class class Test{ // Implementing a method publicvoidmethod() { System.out.println(\"Method 1\"); } } // Defining a child class publicclass GFGextendsTest{ // Overriding the parent method publicvoidmethod() { System.out.println(\"Method 2\"); } // Driver code publicstaticvoidmain(Stringargs[]) { Testtest=newGFG(); test.method(); } }\n\nOutput\n\nMethod 2\n\nThe following table demonstrates the difference between runtime polymorphism and compile-time polymorphism:\n\nCompile Time PolymorphismRun time PolymorphismIn Compile time Polymorphism, the call is resolved by the compiler.In Run time Polymorphism, the call is not resolved by the compiler.It is also known as Static binding, Early binding and overloading as well.It is also known as Dynamic binding, Late binding and overriding as well.It is achieved by method overloadingIt is achieved by virtual functions and pointers.It provides fast execution because the method that needs to be executed is known early at the compile time.It provides slow execution as compare to early binding because the method that needs to be executed is known at the runtime.Compile time polymorphism is less flexible as all things execute at compile time.Run time polymorphism is more flexible as all things execute at run time.Inheritance is not involved. Inheritance is involved."
    }
}