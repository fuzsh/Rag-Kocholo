{
    "id": "dbpedia_465_0",
    "rank": 31,
    "data": {
        "url": "https://worthdoingbadly.com/xnuqemu2/",
        "read_more_link": "",
        "language": "en",
        "title": "Tutorial - emulate an iOS kernel in QEMU up to launchd and userspace",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://worthdoingbadly.com/assets/blog/mail.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Worth Doing Badly"
        ],
        "publish_date": "2018-07-22T00:00:00+00:00",
        "summary": "",
        "meta_description": "I got launchd and recoveryd to start on an emulated iPhone running iOS 12 beta 4’s kernel using a modified QEMU. Here’s what I learned, and how you can try this yourself.",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "Worth Doing Badly",
        "canonical_link": "https://worthdoingbadly.com/xnuqemu2/",
        "text": "I got launchd and recoveryd to start on an emulated iPhone running iOS 12 beta 4’s kernel using a modified QEMU. Here’s what I learned, and how you can try this yourself.\n\nIntroduction\n\nThis is Part 2 of a series on the iOS boot process. Part 1 is here. Sign up with your email to be the first to read new posts.\n\nskip to: tutorial, writeup\n\nFirst, let me repeat: this is completely useless unless you’re really interested in iOS internals. If you want to run iOS, you should ask @CorelliumHQ instead, or just buy an iPhone.\n\nI’ve been interested in how iOS starts, so I’ve been trying to boot the iOS kernel in QEMU.\n\nI was inspired by @cmwdotme’s Corellium, a service which can boot any iOS in a virtual machine. Since I don’t have 9 years to build a perfect simulation of an iPhone, I decided to go for a less lofty goal: getting enough of iOS emulated until launchd, the first program to run when iOS boots, is able to start.\n\nSince last week’s post, I got the iOS 12 beta 4 kernel to fully boot in QEMU, and even got it to run launchd and start recoveryd from the restore ramdisk. Here’s the output from the virtual serial port:\n\nIf you would like to examine iOS’s boot process yourself, here’s how you can try it out.\n\nBuilding QEMU\n\nThe emulation uses a patched copy of QEMU, which must be compiled from source.\n\nInstall dependencies\n\nTo compile QEMU, you first need to install some libraries.\n\nmacOS:\n\nAccording to the QEMU wiki and the Homebrew recipe, you need to install Xcode and Homebrew, then run\n\nbrew install pkg-config libtool jpeg glib pixman\n\nto install the required libraries to compile QEMU.\n\nUbuntu 18.04:\n\nAccording to the QEMU wiki, run\n\nsudo apt install libglib2.0-dev libfdt-dev libpixman-1-dev zlib1g-dev libsdl1.2-dev\n\nto install the required libraries to compile QEMU.\n\nWindows:\n\nQEMU can be built on Windows, but their instructions doesn’t seem to work for this modified QEMU. Please build on macOS or Linux instead. You can set up a virtual machine running Ubuntu 18.04 with Virtualbox or VMWare Player.\n\nDownload and build source\n\nOpen a terminal, and run\n\nPreparing iOS files for QEMU\n\nOnce QEMU is compiled, you need to obtain the required iOS kernelcache, device tree, and ramdisk.\n\nIf you don’t want to extract these files yourself, I packaged all the files you need from iOS 12 beta 4. You can download this archive if you sign up for my mailing list.\n\nIf you want to extract your own files directly from an iOS update, here’s how:\n\n1. Download the required files:\n\nDownload my XNUQEMUScripts repository:\n\nDownload the iOS 12 beta 4 for iPhone X.\n\nTo decompress the kernel, download newosxbook’s Joker tool.\n\n2. Extract the kernel using Joker:\n\nreplace joker.universal with joker.ELF64 if you are using Linux.\n\n3. extract the ramdisk:\n\n4. Modify the devicetree.dtb file:\n\nInstalling a debugger\n\nYou will also need lldb or gdb for arm64 installed.\n\nmacOS\n\nThe version of lldb included in Xcode 9.3 should work. (Later versions should also work.) You don’t need to install anything in this step.\n\nUbuntu 18.04\n\nI can’t find an LLDB compatible with ARM64: neither the LLDB from the Ubuntu repository nor the version from LLVM’s own repos support ARM64. (Someone please build one!)\n\nInstead, you can use GDB on Linux.\n\nTwo versions of GDB can be used: the version from devkitA64, or the Linaro GDB (recommended).\n\nEnter your xnuqemu directory (from the downloaded package or from the clone of the XNUQEMUScripts repo)\n\nRun\n\nto download the Linaro GDB.\n\nRunning QEMU\n\nPlace your qemu directory into the same directory as the scripts, kernel, devicetree, and ramdisk.\n\nYou should have these files:\n\n./runqemu.sh to start QEMU.\n\nin a different terminal, ./lldbit.sh to start lldb, or if you’re using Linux, ./gdbit.sh to start gdb.\n\nType c into lldb or gdb to start execution.\n\nIn the terminal running QEMU, you should see boot messages. Congratulations, you’ve just ran a tiny bit of iOS with a virtual iPhone! Or as UnthreadedJB would say, “#we r of #fakr!”\n\nWhat works\n\nBooting XNU all the way to running userspace programs\n\nConsole output from virtual serial port\n\nWhat doesn’t work\n\nWi-Fi\n\nBluetooth\n\nUSB\n\nScreen\n\nInternal storage\n\nEverything except the serial port\n\nYou tell me\n\nSeriously, though, this only runs a tiny bit of iOS, and is nowhere close to iOS emulation. To borrow a simile from the creator of Corellium, if Corellium is a DeLorean time machine, then this is half a wheel at most.\n\nThis experiment only finished the easy part of booting iOS, as it doesn’t emulate an iPhone at all, relying on only the parts common to all ARM devices. No drivers are loaded whatsoever, so there’s no emulation of the screen, the USB, the internal storage… You name it: it doesn’t work.\n\nFor full iOS emulation, the next step would be reverse engineering the iPhone’s SoC to find out how its peripherals work. Unfortunately, that’s a 9-year project, as shown by the development history of Corellium. I can’t do that on my own - that’s why I wrote this tutorial!\n\nIt’s my hope that this work inspires others to look into proper iOS emulation - from what I’ve seen, it’ll be a great learning experience.\n\nHow I did this\n\nLast week, I started modifying QEMU to load an iOS kernel and device tree: the previous writeup is here. Here’s how I got from crashing when loading kernel modules to fully booting the kernel.\n\nTweaking CPU emulation, part 3: Interrupting cow\n\nWhen we left off, the kernel crashed with a data abort when it tries to bzero a write only region of memory. Why?\n\nTo confirm that it’s indeed writing to read-only memory, I implemented a command to dump out the kernel memory mappings, and enabled QEMU’s verbose MMU logging to detect changes to the memory map.\n\nI tracked down the crashing code to OSKext::updateLoadedKextSummaries. After every kext load, this code resets the kext summaries region to writable with vm_map_protect, writes information for the new kext, then sets the region back to read-only. The logs show that the call to protect the region modifies the memory mappings, but the call to reset it to read-write doesn’t do anything. Why isn’t it setting the page to writable?\n\nAccording to comments in vm_map_protect, it turns out that readonly->readwrite calls actually don’t change the protection immediately, but only sets it on-demand when a program tries - and fails - to write to the page. This is to implement copy on write.\n\nSo, it seems the data abort exception is supposed to happen, but the panic is not.\n\nIn the data abort exception, the page should be set to writable in arm_fast_fault. The code in open-source XNU can only return KERN_FAILURE or KERN_SUCCESS, but with a breakpoint, I saw it was returning KERN_PROTECTION_FAILURE.\n\nI checked the disassembly: yes, there’s extra code (0xFFFFFFF0071F953C in iOS 12 beta 4) returning KERN_PROTECTION_FAILURE if the page address doesn’t match one of the new KTRR registers added on the A11 processor .\n\nI had been ignoring all writes to KTRR registers, so this code can’t read the value from the register (which the kernel stored at startup), and believes that all addresses are invalid. Thus, instead of setting the page to writable, the kernel panics instead.\n\nI fixed this by adding these registers to QEMU’s virtual CPU, allowing the kernel to read and write them.\n\nAfter this change, a few more kexts started up, but the kernel then hangs… like it’s waiting for something.\n\nConnecting the timer interrupt\n\nMy hunch for why the kernel hangs: one of the kexts tries to sleep for some time during initialization, but never wakes up because there are no timer interrupts, as shown by QEMU not logging any exceptions when it hangs.\n\nOn ARM, there are two ways for hardware to signal the CPU: IRQ, shared by many devices, or FIQ, dedicated to just one device.\n\nQEMU’s virt machine hooks up the processor’s timer to IRQ, like most real ARM platforms. FIQ is usually reserved for debuggers.\n\nApple, however, hooks up the timer directly to the FIQ. With virt’s timer hooked up to the wrong signal, the kernel would wait forever for an interrupt that would never come.\n\nAll I had to do to get the timer working was to hook it up to FIQ. This gets me… a nice panic in the Image4 parser.\n\nGetting the Image4 parser module working\n\nWhat does this mean? What’s error 0x60?\n\nI found the panic string, and looked for where the error message is generated.\n\nIt turns out that the Image4 parser queries the device tree for various nodes in “/chosen” or “/default”; if the value doesn’t exist, it returns error 0x60. If the value is the wrong size, it returns 0x54.\n\niOS’s device tree is missing two properties: chip-epoch and security-domain, which causes the module to panic with the 0x60 error.\n\nOddly, the device tree doesn’t reserve extra space for these properties. I had to delete two existing properties to make space for them.\n\nWith the modified device tree, the Image4 module initializes, but now I have a panic from a data abort in rorgn_lockdown.\n\nFailed attempt to get device drivers to not crash\n\nOf course the KTRR driver crashes when it tries to access the memory controller: there isn’t one! QEMU’s virt machine doesn’t have anything mapped at that address.\n\nSince I don’t have an emulation of the memory controller, I just added a block of empty memory to avoid the crash.\n\nThis strategy didn’t work for the next crash, though, from the AppleInterruptController driver. That driver reads and validates values from the device, so just placing a blank block of memory causes the driver to panic.\n\nSomething more drastic is needed if I don’t want to spend 9 years reverse engineering each driver.\n\nDriverless like we’re Waymo\n\nTo boot XNU, I don’t really need all those drivers, do I? Who needs interrupts or the screen or power management or storage, anyways? All XNU needs to boot into userspace is a serial port and a timer.\n\nI disabled every other driver in the kernel. Drivers are loaded if their IONameMatch property corresponds to a device’s “compatible”, “name”, or “device_type” fields. To disable all the drivers, I erased every “compatible” property in the device tree, along with a few “name” and “device_type” properties.\n\nNow, with no drivers, XNU seems to hang, but after I patiently waited for a minute…\n\nIt’s trying to mount the root filesystem!\n\nLoading a RAMDisk\n\nIf it’s looking for a root filesystm, let’s give it one. I don’t have any drivers for storage, but I can mount an iOS Recovery RAMDisk, which requires no drivers. All I had to do was:\n\nLoad the ramdisk at the end of the kernel, just before the device tree blob\n\nput its address and size in the device tree so XNU can find it\n\nset boot argument to rd=md0 to boot from ramdisk\n\nThe kernel mounts the root filesystem! … but then hangs again.\n\nUsing LLDB to patch out hanging functions\n\nBy putting breakpoints all over bsd_init, I found that the kernel was hanging in IOBSDSecureRoot, when it tries to call the platform function. The platform function looks for a device, but since I removed all the device drivers, it waits forever, in vain.\n\nTo fix this, I just skipped the problematic call. I used an LLDB breakpoint to jump over the call and simulate a true return instead.\n\nAnd, after three weeks, the virtual serial port finally printed out:\n\n“Houston, the kernel has booted.”\n\nWhat I learned\n\nquirks of iOS memory management\n\nhow iOS handles timer interrupts\n\nhow iOS loads ramdisks\n\nbuilding QEMU on different platforms\n\nmodifying QEMU to add new CPU configuration registers\n\ndifferences between GDB and LLDB’s command syntax\n\nhow to get people to subscribe to my mailing list. (muhahaha, one last signup link.)\n\nThanks\n\nThanks to everyone who shared or commented on my last article. To those who tried building and running it - sorry about taking so long to write up instructions!\n\nThanks to @matteyeux, @h3adsh0tzz, @_th0ex, and @enzolovesbacon for testing the build instructions."
    }
}