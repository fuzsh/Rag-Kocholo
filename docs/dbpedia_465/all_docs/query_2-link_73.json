{
    "id": "dbpedia_465_2",
    "rank": 73,
    "data": {
        "url": "https://www.educative.io/blog/operating-systems-crashcourse",
        "read_more_link": "",
        "language": "en",
        "title": "Operating systems crash course: From kernels to virtualization",
        "top_image": "https://www.educative.io/v2api/editorpage/6292006289539072/image/5581777484644352",
        "meta_img": "https://www.educative.io/v2api/editorpage/6292006289539072/image/5581777484644352",
        "images": [
            "https://www.educative.io/api/page/6292006289539072/image/download/5125552905125888",
            "https://www.educative.io/api/page/6292006289539072/image/download/4702281059532800",
            "https://www.educative.io/api/page/6292006289539072/image/download/6716280338907136",
            "https://www.educative.io/api/page/6292006289539072/image/download/6106174731583488",
            "https://www.educative.io/api/page/6292006289539072/image/download/4667250226233344",
            "https://www.educative.io/api/page/6292006289539072/image/download/5217774101069824",
            "https://www.educative.io/api/page/6292006289539072/image/download/5868120062296064",
            "https://www.educative.io/api/page/6292006289539072/image/download/4660160577404928",
            "https://www.educative.io/static/imgs/soc2.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "operating systems",
            "linux",
            "virtualization",
            "concurrency",
            "beginner"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "An operating system (OS) is the primary software that manages anything on a computer. OS are a foundational computer science skill. Today, we'll break down the OS basics from kernels to virtualization.",
        "meta_lang": "en",
        "meta_favicon": "/static/favicons/faviconV2.png",
        "meta_site_name": "Educative",
        "canonical_link": "https://www.educative.io/blog/operating-systems-crashcourse",
        "text": "Operating systems are the foundation of modern digital devices. These systems determine how you see and interact with your machines. Operating systems determine how we program an application, what software we can use, and how hardware should be designed. Understanding operating systems is essential for developers to ensure you’re designing programs that work to the strengths of a particular operating system.\n\nToday, we’ll break down the basics of operating system components and functions, starting with the most basic kernel and ending with the more advanced topic of virtualization. By the end of this article, you’ll have a solid foundation of operating systems and be ready to jump into intermediate practice.\n\nHere’s what we’ll cover today:\n\nWhat is an operating system?\n\nWhat is a kernel?\n\nWhat is a process?\n\nWhat is a service?\n\nTypes of operating system configurations\n\nAdvanced OS concepts\n\nReview questions\n\nWhat to learn next\n\nWhat is an operating system?\n\nAn operating system (OS) is the core software that contains a collection of services essential for the machine to run programs. Think of this as the manager of a computer’s memory and processes. An OS is how we can communicate with a computer without understanding the same language. Without an OS, a user would need to know dozens of command line statements to manually control each part of a computer.\n\nThe most important function of an OS is to standardize and mediate programs and the machine’s internal hardware. The OS is how a computer schedules sequential tasks, completes tasks concurrently, and delegates resources. In other words, the OS is to provide both the platform and resources needed for programs to run.\n\nBefore operating systems were commonplace, developers had to design their programs to work with individual pieces of hardware. However, it was impossible to know what hardware your customers would have, so widely distributed software was nearly impossible. Operating systems provide a standard medium that developers can program. If the system can run the OS, it can run your program.\n\nPopular operating systems for developers\n\nThere are many operating systems out there, many that you probably haven’t even heard of. They generally all provide the same base but have different functionalities such as support for hardware, security, intended user-base, or regular updates.\n\nToday, the three most popular operating systems used by developers are:\n\nWhat is a kernel?\n\nThe kernel is the central core of an operating system that allows programs to access hardware resources. A kernel is how a system starts up, translates input, and outputs requests to the central processing unit (GPU).\n\nEach OS must have a kernel to function. As a result, the kernel is stored in restricted memory space so it’s not accidentally overwritten. Developers working on kernels aim to make it as small as possible without altering functionality so that more memory is open to the user.\n\nKernels rarely change from version to version. In fact, the modern OS uses the same versions from over 20 years ago with only minor updates or modernizations.\n\nLinux uses the Linux kernel\n\nmacOS uses the XNU kernel\n\nWindows uses the Windows NT kernel\n\nResource management\n\nResource management is one of the most important services of a kernel. The kernel delegates computer resources like memory and CPU to each process being executed.\n\nBy regulating processes, the kernel prevents greedy programs from starving the system and slowing down other concurrent programs. This service ensures that all processes have enough resources to function and that each process makes use of all available resources.\n\nWhat is a service?\n\nThe kernel is our platform to run programs while services provide tools to the program to do its job. A service is a built-in set of functions that programs can use to implement common behaviors, like saving to files or sharing data. Without services, developers would have to write the code for these behaviors in each program that needs them.\n\nComputer scientists working on OS systems quickly realized that many programs would benefit from these behaviors and included them in the OS package. This makes programming for an OS more convenient, as the developer can avoid writing the most frequently needed behaviors from scratch each time.\n\nFor example, a cloud storage application doesn’t need to include instructions on how to write data to memory. Instead, the application simply calls the save behavior included in the file system manipulation service.\n\nSome services, like error detection, run at all times regardless of program calls.\n\nCommon services\n\nThe services included in an operating system vary based from OS to OS, but some have become standard:\n\nProgram execution: This service allows the computer to load, execute, and produce the output of a program.\n\nInput/Output (I/O) operations: This service provides the ability to communicate with standard devices like printers and keyboards. The device can use this to make requests of the kernel or visa versa. Software to handle specific devices is called a driver, that instructs the I/O operations service how to interface with the new device.\n\nFile System manipulation: This service includes a standardized method of navigating memory so we can create and place files within directories. Programs can then navigate these directories, alter properties, or access/create files. It also provides the interface for users to interact with files through requests like create/delete and move.\n\nCommunication: The communication service enables links between individual processes to share data or results. It also includes the framework for distributed systems of multiple machines working together.\n\nError Detection: Error detection allows computers to scan all processes for errors by monitoring progress and expected outcomes. This service can also correct minor errors without user interference.\n\nResource Allocation: This kernel service allows the computer to grant and free up resources dynamically as processes are added or completed. It also allows the computer to create process sequences using CPU schedulers.\n\nProtection: This service provides basic cybersecurity protection through controlling system access, limiting I/O access to unrelated resources, and password authentication.\n\nTypes of operating system configurations\n\nOperating systems are used on every digital system and come in different types. Linux, macOS and Windows are all just one type of OS, called a network operating system. While these work great for computers, other systems like email servers and air-traffic control systems have different needs.\n\nAdditional types of OS were invented to meet these needs. Each type has unique strengths and processing algorithms to optimize the system for certain tasks.\n\nCompanies need developers to make programs tailored to the adopted type of OS. It’s essential for you to know how each type of OS works and the unique challenges each poses to a developer.\n\nBelow, we’ll explore the 6 types of OS, what tasks they’re used for, and how you can optimize your programs for each.\n\nNetwork operating system\n\nNetwork Operating Systems run on a server and provide the server the ability to manage networking functions like data, users, groups, security, and software programs. These systems are designed to grant file sharing and printer access among multiple computers in a network, typically a local area network (LAN), a private network, or other networks like the internet.\n\nThis is the most commonly used type of OS, found on home computers, and on network management devices like routers and switches. Windows, macOS, and Linux are all network operating systems as they must frequently use the Internet.\n\nBatch operating system\n\nBatch operating systems are designed to speed up processing by “batching” groups of tasks to be run later.\n\nUsers do not interact with the computer directly in a batched operating system. Instead, tasks are drafted on separate offline devices and handed off to a computer controller.\n\nThe controller runs the batch once they receive it at a specific time, like the end of the workday, or when they get enough tasks to warrant execution. This speeds up processing as similar processes can be completed at the same time.\n\nBatch operating systems are often used in financial fields. Payroll and bank statement processing systems are the two most common systems to implement batch operating systems. These systems are of an older style, with many companies moving to convert them to time-sharing systems in recent years.\n\nWhen designing programs for a batch system, minimize processing time as any long process will slow down the work pipeline. However, your program can be very resource-intensive as the device only runs one process at a time.\n\nTime-sharing operating system\n\nTime-sharing operating systems allot a period of time, called a quantum, to work on each user’s tasks and rapidly switch between each process until all are complete. While CPUs can only work on one process at a time, the rapid switching simulates concurrent processing.\n\nTime-sharing systems prioritize response time as processes are completed at the same pace regardless of when they were issued. This avoids stacking response time where the first process in a sequence is completed swiftly while the final process is untouched until all others are complete.\n\nTime-sharing systems are not widely used but are used to convert old batch OS devices to be more responsive. Time-sharing is also used by Multics, an operating system that defined modern multitasking systems and Unix, the basis for macOS. This style of system is the backbone of multithreading techniques.\n\nDistributed operating system\n\nDistributed operating systems use multiple connected computers, called nodes, to handle user tasks. Each process is distributed to available devices for individual completion and all pieces are combined once all nodes are finished. The primary advantage of a distributed system is that it allows individual users to concurrently use the processing power of many devices, resulting in faster processing.\n\nWhen designing programs for distributed operating systems, split the program into smaller modular tasks to ensure the system can efficiently use its divide and conquer structure.\n\nCommon examples of distributed operating systems can be found in large scale, response-focused systems like email servers, cell phone networks, and electronic banking systems.\n\nReal-time operating system\n\nThis operating system gives each program a given period, with any program that would exceed that processing time being rejected. This maintains a strict schedule of processes to ensure certain high importance tasks can always be performed at a moment’s notice.\n\nReal-time systems differ from time-sharing systems in how many processes can be completed at once. Real-time operating systems complete only one process at a time within a certain period. The process is interrupted if the processing time exceeds its dedicated period. Time-sharing systems, on the other hand, switch focus between multiple processes and are allowed to take multiple quantums to complete.\n\nThese systems are widely used when responsiveness and strict schedules are essential, such as in equipment for scientific experiments, air traffic control systems, or defense systems.\n\nWhen writing programs for a real-time system, you must know how long each period is in your system and ensure your program is small enough to complete within that period.\n\nVirtualization\n\nVirtualization is the technique of making virtual objects that behave as hardware, such as the switching ability of time-sharing operating systems. The time-sharing OS can complete multiple processes simultaneously by switching between them rapidly.\n\nNormally, a computer would need two individual CPUs to complete processes concurrently. As a result, a time-sharing OS achieves virtualization by using rapid process switching to emulate an additional CPU.\n\nVirtualization can simulate entire OS instances with individually assigned sections of the host resources, data, and devices for each container. These containers are isolated from the host machine and all other hosted virtual machines (VMs). This larger scale of virtualization is called operating-system-virtualization or, more commonly, containerization.\n\nPrograms run on these containers as though they are a true operating system. They access resources allocated to the container and execute processes using a containerized scheduler.\n\nVirtualization, therefore, grants the ability to run multiple concurrent programs in separate containers while all being hosted on the same physical machine.\n\nThis gives developers a high level of control over OS container environments. By controlling container environments, developers can test programs on different kinds of operating systems or simulate hardware environments all on the same machine. Also, programs are more efficient when using concurrent programs across multiple VMs.\n\nWhat to learn next\n\nCongratulations on completing your crash course of operating systems! Having a solid foundation on OS is essential to your long-term success as a developer, especially if you want to work on app development. While this is a wide topic to tackle, you’re now ready to move on to intermediate concepts.\n\nThe OS concepts to learn next are:\n\nOS Paging\n\nAddress Translation\n\nComplete VM Systems\n\nConcurrency locks\n\nRedundant Disk Arrays\n\nData persistence\n\nTo help you explore these concepts, Educative has created Operating Systems: Virtualization, Concurrency & Persistence. It is the definitive guide for developers looking to learn about OS. This course contains 400+ interactive lessons designed to teach you intermediate OS topics. By the end, you’ll have learned how to virtualize different operating systems, implement concurrency through multithreading, and more.\n\nHappy learning!"
    }
}