{
    "id": "dbpedia_465_0",
    "rank": 62,
    "data": {
        "url": "https://archive.org/details/github.com-apple-darwin-xnu_-_2017-10-05_06-57-01",
        "read_more_link": "",
        "language": "en",
        "title": "01 : apple : Free Download, Borrow, and Streaming : Internet Archive",
        "top_image": "https://archive.org/services/img/github.com-apple-darwin-xnu_-_2017-10-05_06-57-01",
        "meta_img": "https://archive.org/services/img/github.com-apple-darwin-xnu_-_2017-10-05_06-57-01",
        "images": [
            "https://archive.org/services/img/etree",
            "https://archive.org/services/img/librivoxaudio",
            "https://archive.org/services/img/metropolitanmuseumofart-gallery",
            "https://archive.org/services/img/clevelandart",
            "https://archive.org/services/img/internetarcade",
            "https://archive.org/services/img/consolelivingroom",
            "https://archive.org/images/book-lend.png",
            "https://archive.org/images/widgetOL.png",
            "https://archive.org/services/img/tv",
            "https://archive.org/services/img/911",
            "https://archive.org/download/github.com-apple-darwin-xnu_-_2017-10-05_06-57-01/cover.jpg",
            "https://archive.org/services/img/github_narabot_mirror",
            "https://athena.archive.org/0.gif?kind=track_js&track_js_case=control&cache_bust=2011814178",
            "https://athena.archive.org/0.gif?kind=track_js&track_js_case=disabled&cache_bust=1218533228"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The Darwin Kernel (mirror) What is XNU?XNU kernel is part of the Darwin operating system for use in OS X and iOS operating systems. XNU is an acronym for XNU...",
        "meta_lang": "en",
        "meta_favicon": "https://archive.org/images/glogo.jpg",
        "meta_site_name": "Internet Archive",
        "canonical_link": "https://archive.org/details/github.com-apple-darwin-xnu_-_2017-10-05_06-57-01",
        "text": "The Darwin Kernel (mirror)\n\nWhat is XNU?\n\nXNU kernel is part of the Darwin operating system for use in OS X and iOS operating systems. XNU is an acronym for XNU is Not Unix.XNU is a hybrid kernel combining the Mach kernel developed at Carnegie Mellon University with components from FreeBSD and C++ API for writing drivers called IOKit.XNU runs on I386, X86_64 for both single processor and multi-processor configurations.\n\nXNU Source Tree\n\nconfig - configurations for exported apis for supported architecture and platform\n\nSETUP - Basic set of tools used for configuring the kernel, versioning and kextsymbol management.\n\nEXTERNAL_HEADERS - Headers sourced from other projects to avoid dependency cycles when building. These headers should be regularly synced when source is updated.\n\nlibkern - C++ IOKit library code for handling of drivers and kexts.\n\nlibsa - kernel bootstrap code for startup\n\nlibsyscall - syscall library interface for userspace programs\n\nlibkdd - source for user library for parsing kernel data like kernel chunked data.\n\nmakedefs - top level rules and defines for kernel build.\n\nosfmk - Mach kernel based subsystems\n\npexpert - Platform specific code like interrupt handling, atomics etc.\n\nsecurity - Mandatory Access Check policy interfaces and related implementation.\n\nbsd - BSD subsystems code\n\ntools - A set of utilities for testing, debugging and profiling kernel.\n\nHow to build XNU\n\nBuilding DEVELOPMENT kernel\n\nThe xnu make system can build kernel based on KERNEL_CONFIGS & ARCH_CONFIGS variables as arguments.Here is the syntax:\n\nmake SDKROOT= ARCH_CONFIGS= KERNEL_CONFIGS=\n\nWhere:\n\n\\: path to MacOS SDK on disk. (defaults to /)\n\n\\: can be debug, development, release, profile and configures compilation flags and asserts throughout kernel code.\n\n\\ : can be valid arch to build for. (E.g. i386 or X86_64)\n\nTo build a kernel for the same architecture as running OS, just type\n\n$ make$ make SDKROOT=macosx.internal\n\nAdditionally, there is support for configuring architectures through ARCH_CONFIGS and kernel configurations with KERNEL_CONFIGS.\n\n$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=DEVELOPMENT$ make SDKROOT=macosx.internal ARCH_CONFIGS=X86_64 KERNEL_CONFIGS=\"RELEASE DEVELOPMENT DEBUG\"\n\nNote: * By default, architecture is set to the build machine architecture, and the default kernel config is set to build for DEVELOPMENT.\n\nThis will also create a bootable image, kernel.[config], and a kernel binarywith symbols, kernel.[config].unstripped.\n\nTo build with RELEASE kernel configuration\n\nmake KERNEL_CONFIGS=RELEASE SDKROOT=/path/to/SDK\n\nBuilding FAT kernel binary\n\nDefine architectures in your environment or when running a make command.\n\n$ make ARCH_CONFIGS=\"I386 X86_64\" exporthdrs all\n\nOther makefile options\n\n$ make MAKEJOBS=-j8 # this will use 8 processes during the build. The default is 2x the number of active CPUS.\n\n$ make -j8 # the standard command-line option is also accepted\n\n$ make -w # trace recursive make invocations. Useful in combination with VERBOSE=YES\n\n$ make BUILD_LTO=0 # build without LLVM Link Time Optimization\n\n$ make REMOTEBUILD=user@remotehost # perform build on remote host\n\n$ make BUILDJSONCOMPILATION_DATABASE=1 # Build Clang JSON Compilation Database\n\nThe XNU build system can optionally output color-formatted build output. To enable this, you can eitherset the XNU_LOGCOLORS environment variable to y, or you can pass LOGCOLORS=y to the make command.\n\nDebug information formats\n\nBy default, a DWARF debug information repository is created during the install phase; this is a \"bundle\" named kernel.development.\\.dSYMTo select the older STABS debug information format (where debug information is embedded in the kernel.development.unstripped image), set the BUILD_STABS environment variable.\n\n$ export BUILD_STABS=1$ make\n\nBuilding KernelCaches\n\nTo test the xnu kernel, you need to build a kernelcache that links the kexts andkernel together into a single bootable image.To build a kernelcache you can use the following mechanisms:\n\nUsing automatic kernelcache generation with kextd.The kextd daemon keeps watching for changing in /System/Library/Extensions directory. So you can setup new kernel as\n\n$ cp BUILD/obj/DEVELOPMENT/X86_64/kernel.development /System/Library/Kernels/$ touch /System/Library/Extensions$ ps -e | grep kextd\n\nManually invoking kextcache to build new kernelcache.\n\n$ kextcache -q -z -a x86_64 -l -n -c /var/tmp/kernelcache.test -K /var/tmp/kernel.test /System/Library/Extensions\n\nRunning KernelCache on Target machine\n\nThe development kernel and iBoot supports configuring boot arguments so that we can safely boot into test kernel and, if things go wrong, safely fall back to previously used kernelcache.Following are the steps to get such a setup:\n\nCreate kernel cache using the kextcache command as /kernelcache.test\n\nCopy exiting boot configurations to alternate file\n\n$ cp /Library/Preferences/SystemConfiguration/com.apple.Boot.plist /next_boot.plist\n\nUpdate the kernelcache and boot-args for your setup\n\n$ plutil -insert \"Kernel Cache\" -string \"kernelcache.test\" /next_boot.plist $ plutil -replace \"Kernel Flags\" -string \"debug=0x144 -v kernelsuffix=test \" /next_boot.plist\n\nCopy the new config to /Library/Preferences/SystemConfiguration/\n\n$ cp /next_boot.plist /Library/Preferences/SystemConfiguration/boot.plist\n\nBless the volume with new configs.\n\n$ sudo -n bless --mount / --setBoot --nextonly --options \"config=boot\"\n\nThe --nextonly flag specifies that use the boot.plist configs only for one boot. So if the kernel panic's you can easily power reboot and recover back to original kernel.\n\nCreating tags and cscope\n\nSet up your build environment and from the top directory, run:\n\n$ make tags # this will build ctags and etags on a case-sensitive volume, only ctags on case-insensitive$ make TAGS # this will build etags$ make cscope # this will build cscope database\n\nCoding styles (Reindenting files)\n\nSource files can be reindented using clang-format setup in .clang-format.XNU follows a variant of WebKit style for source code formatting.Please refer to format styles at WebKit website. Further options about style options is available at clang docs\n\nNote: clang-format binary may not be part of base installation. It can be compiled from llvm clang sources and is reachable in $PATH.\n\nFrom the top directory, run:\n\n$ make reindent # reindent all source files using clang format.\n\nHow to install a new header file from XNU\n\nTo install IOKit headers, see additional comments in iokit/IOKit/Makefile.\n\nXNU installs header files at the following locations -\n\na. $(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headersb. $(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeadersc. $(DSTROOT)/usr/include/d. $(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders\n\nKernel.framework is used by kernel extensions.\\The System.framework and /usr/include are used by user level applications. \\The header files in framework's PrivateHeaders are only available for * Apple Internal Development *.\n\nThe directory containing the header file should have a Makefile thatcreates the list of files that should be installed at different locations.If you are adding first header file in a directory, you will need tocreate Makefile similar to xnu/bsd/sys/Makefile.\n\nAdd your header file to the correct file list depending on where you wantto install it. The default locations where the header files are installedfrom each file list are -\n\na. `DATAFILES` : To make header file available in user level - `$(DSTROOT)/usr/include`b. `PRIVATE_DATAFILES` : To make header file available to Apple internal in user level - `$(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders`c. `KERNELFILES` : To make header file available in kernel level - `$(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers` `$(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders`d. `PRIVATE_KERNELFILES` : To make header file available to Apple internal for kernel extensions - `$(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders`\n\nThe Makefile combines the file lists mentioned above into differentinstall lists which are used by build system to install the header files.\n\nIf the install list that you are interested does not exist, create itby adding the appropriate file lists. The default install lists, itsmember file lists and their default location are described below -\n\na. `INSTALL_MI_LIST` : Installs header file to a location that is available to everyone in user level. Locations - $(DSTROOT)/usr/include Definition - INSTALL_MI_LIST = ${DATAFILES}b. `INSTALL_MI_LCL_LIST` : Installs header file to a location that is available for Apple internal in user level. Locations - $(DSTROOT)/System/Library/Frameworks/System.framework/PrivateHeaders Definition - INSTALL_MI_LCL_LIST = ${PRIVATE_DATAFILES}c. `INSTALL_KF_MI_LIST` : Installs header file to location that is available to everyone for kernel extensions. Locations - $(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers Definition - INSTALL_KF_MI_LIST = ${KERNELFILES}d. `INSTALL_KF_MI_LCL_LIST` : Installs header file to location that is available for Apple internal for kernel extensions. Locations - $(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders Definition - INSTALL_KF_MI_LCL_LIST = ${KERNELFILES} ${PRIVATE_KERNELFILES}e. `EXPORT_MI_LIST` : Exports header file to all of xnu (bsd/, osfmk/, etc.) for compilation only. Does not install anything into the SDK. Definition - EXPORT_MI_LIST = ${KERNELFILES} ${PRIVATE_KERNELFILES}\n\nIf you want to install the header file in a sub-directory of the pathsdescribed in (1), specify the directory name using two variablesINSTALL_MI_DIR and EXPORT_MI_DIR as follows -\n\nINSTALL_MI_DIR = dirnameEXPORT_MI_DIR = dirname\n\nA single header file can exist at different locations using the stepsmentioned above. However it might not be desirable to make all the codein the header file available at all the locations. For example, youwant to export a function only to kernel level but not user level.\n\nYou can use C language's pre-processor directive (#ifdef, #endif, #ifndef) to control the text generated before a header file is installed. The kernel only includes the code if the conditional macro is TRUE and strips out code for FALSE conditions from the header file.\n\nSome pre-defined macros and their descriptions are -\n\na. `PRIVATE` : If true, code is available to all of the xnu kernel and is not available in kernel extensions and user level header files. The header files installed in all the paths described above in (1) will not have code enclosed within this macro.b. `KERNEL_PRIVATE` : If true, code is available to all of the xnu kernel and Apple internal kernel extensions.c. `BSD_KERNEL_PRIVATE` : If true, code is available to the xnu/bsd part of the kernel and is not available to rest of the kernel, kernel extensions and user level header files. The header files installed in all the paths described above in (1) will not have code enclosed within this macro.d. `KERNEL` : If true, code is available only in kernel and kernel extensions and is not available in user level header files. Only the header files installed in following paths will have the code - $(DSTROOT)/System/Library/Frameworks/Kernel.framework/Headers $(DSTROOT)/System/Library/Frameworks/Kernel.framework/PrivateHeaders you should check [Testing the kernel][] for details.\n\nHow to add a new syscall\n\nTesting the kernel\n\nXNU kernel has multiple mechanisms for testing.\n\nAssertions - The DEVELOPMENT and DEBUG kernel configs are compiled with assertions enabled. This allows developers to easilytest invariants and conditions.\n\nXNU Power On Self Tests (XNUPOST): The XNUPOST config allows for building the kernel with basic set of test functionsthat are run before first user space process is launched. Since XNU is hybrid between MACH and BSD, we have two locations wheretests can be added.\n\nxnu/osfmk/tests/ # For testing mach based kernel structures and apis.bsd/tests/ # For testing BSD interfaces.\n\nPlease follow the documentation at osfmk/tests/README.md\n\nUser level tests: The tools/tests/ directory holds all the tests that verify syscalls and other features of the xnu kernel.The make target xnu_tests can be used to build all the tests supported.\n\n$ make RC_ProjectName=xnu_tests SDKROOT=/path/to/SDK\n\nThese tests are individual programs that can be run from Terminal and report tests status by means of std posix exit codes (0 -> success) and/or stdout.Please read detailed documentation in tools/tests/unit_tests/README.md\n\nKernel data descriptors\n\nXNU uses different data formats for passing data in its api. The most standard way is using syscall arguments. But for complex datait often relies of sending memory saved by C structs. This packaged data transport mechanism is fragile and leads to broken interfacesbetween user space programs and kernel apis. libkdd directory holds user space library that can parse custom data provided by thesame version of kernel. The kernel chunked data format is described in detail at libkdd/README.md.\n\nDebugging the kernel\n\nThe xnu kernel supports debugging with a remote kernel debugging protocol (kdp). Please refer documentation at technical noteBy default the kernel is setup to reboot on a panic. To debug a live kernel, the kdp server is setup to listen for UDP connectionsover ethernet. For machines without ethernet port, this behavior can be altered with use of kernel boot-args. Following are somecommon options.\n\ndebug=0x144 - setups debug variables to start kdp debugserver on panic\n\n-v - print kernel logs on screen. By default XNU only shows grey screen with boot art.\n\nkdp_match_name=en1 - Override default port selection for kdp. Supported for ethernet, thunderbolt and serial debugging.\n\nTo debug a panic'ed kernel, use llvm debugger (lldb) along with unstripped symbol rich kernel binary.\n\nsh$ lldb kernel.development.unstripped\n\nAnd then you can connect to panic'ed machine with kdp_remote [ip addr] or gdb_remote [hostip : port] commands.\n\nEach kernel is packaged with kernel specific debug scripts as part of the build process. For security reasons these special commandsand scripts do not get loaded automatically when lldb is connected to machine. Please add the following setting to your ~/.lldbinitif you wish to always load these macros.\n\nsettings set target.load-script-from-symbol-file true\n\nThe tools/lldbmacros directory contains the source for each of these commands. Please follow the README.mdfor detailed explanation of commands and their usage.\n\nTo restore the repository download the bundle\n\nwget https://archive.org/download/github.com-apple-darwin-xnu_-_2017-10-05_06-57-01/apple-darwin-xnu_-_2017-10-05_06-57-01.bundle\n\nand run:\n\ngit clone apple-darwin-xnu_-_2017-10-05_06-57-01.bundle\n\nSource: https://github.com/apple/darwin-xnu\n\nUploader: apple\n\nUpload date: 2017-10-05"
    }
}