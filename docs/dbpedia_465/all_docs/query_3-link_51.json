{
    "id": "dbpedia_465_3",
    "rank": 51,
    "data": {
        "url": "https://faisalmemon.github.io/the-road-to-zero/KernelBugHunting/",
        "read_more_link": "",
        "language": "en",
        "title": "Kernel Bug Hunting",
        "top_image": "https://faisalmemon.github.io/the-road-to-zero/assets/images/favicon.png",
        "meta_img": "https://faisalmemon.github.io/the-road-to-zero/assets/images/favicon.png",
        "images": [
            "https://faisalmemon.github.io/the-road-to-zero/overallExample.png",
            "https://faisalmemon.github.io/the-road-to-zero/pickingASnippet.png",
            "https://faisalmemon.github.io/the-road-to-zero/rightClickRunQuery.png",
            "https://faisalmemon.github.io/the-road-to-zero/matchInSourceCode.png",
            "https://faisalmemon.github.io/the-road-to-zero/vscodeCodeQL.png",
            "https://faisalmemon.github.io/the-road-to-zero/importedDatabase.png",
            "https://faisalmemon.github.io/the-road-to-zero/qlFilesInStarterProject.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../assets/images/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://faisalmemon.github.io/the-road-to-zero/KernelBugHunting/",
        "text": "It is generally the case that the barriers to finding and exploiting are getting higher. But there is good news also. In this chapter we describe how to use an automated approach to finding vulnerabilities in the XNU kernel.\n\nBasic Concepts\n\nThe GitHub site provides a service which statically analyses code for known coding errors and bad practices, security being a subset of such analysis rules. The underlying tool chain, called CodeQL, provides the mechanism where a structured rule can be used to parse the syntax tree of a compiled program.\n\nIn this chapter we show how the XNU kernel and be compiled, and from this a database can be constructed. Then CodeQL queries can be run against it to automatically find bad practices and security sensitive issues.\n\nSample Visualization\n\nBefore we get into the details of what we are setting up, let's jump into what we can expect to end up with. We will go into the details of setup and configuration in a later section, but it makes more sense to first understand the approach and benefits we shall gain from using CodeQL.\n\nWe can either run a specific rule, to find code references that match the rule, or we can run a batch of queries given a set of rules.\n\nSpecific rule approach\n\nWe start with checking for code which has an if-clause but then has an empty block of C++ code that is invoked when the condition matches. For example:\n\nWhen looking for such data, our overall Visual Studio Code setup will look like:\n\nThe workflow is to select a snippet to query for. Here we picked one that looks for empty blocks:\n\nThen we right-click to get the context menu and select the \"Run Query\" option:\n\nLastly, we inspect the matched source code files:\n\nBatch Queries\n\nIf we update the workspace file vscode-codeql-starter.code-workspace to first have increased querying capability:\n\nthen we can Right Click on a directory level to run all the .ql files underneath. We can for example select the vscode-codeql-starter/ql/cpp/ql/src/Security/CWE directory and then run all the Security-related queries. This takes a few minutes on a powerful Mac. But it is still quicker than a manual inspection!\n\nUnfortunately, as of xnu-8792.61.2 there are no matches for any of the 64 rules underneath Security/CWE.\n\nThis is probably because Apple, or perhaps a third-party collaborator, has been running CodeQL as part of a Continuous Integration pipeline.\n\nNevertheless, as we have shown, an empty block in the code might allude to a missing error handling case. So the less interesting rules might turn up security vulnerabilities or give us ideas for how to write a new rule. These private rules would not be part of the CI test set that Apple run. So there is a real opportunity to find new weaknesses or helpful bugs.\n\nOutline of Approach\n\nIn this section we give a high level overview of how our toolchain is setup.\n\nHere we've made some assumptions and choices on configuration and setup which we hope can be adapted for your requirements and preferences.\n\nWe assume our bug hunting is done with:\n\nApple Silicon ARM architecture\n\nVisual Studio is our editor for querying for, and viewing, results\n\nXNU Kernel xnu-8792.61.2 is being studied\n\nThe top level steps are:\n\nSetup for Xcode on Mac on Apple Silicon.\n\nInstall the Kernel Debug Kit.\n\nObtain download and compilation scripts.\n\nSetup and install Visual Studio Code, and the QL plug-in.\n\nLoad the Starter Workspace for CodeQL.\n\nInstall CodeQL engine\n\nGenerate XNU CodeQL database.\n\nImport XNU CodeQL database.\n\nRun CodeQL queries to find weaknesses and vulnerabilities.\n\nSoftware Requirements\n\nWe need the following software:\n\nName Purpose Location Xcode Compiler Mac App Store Kernel Debug Kit (13.1 22C65) XNU Dependency for compilation Apple Download Site xnu-build Build Scripts for XNU pwn0rz/xnu-build Visual Studio Code Editor/Viewer Microsoft VS Code CodeQL plug-in Integration for CodeQL into VS Code From Extensions in VS Code; search for CodeQL CodeQL snippets Pre-made queries to run Starter Workspace CodeQL CLI CodeQL engine binaries Releases\n\nInstall the Apple Proprietary base software\n\nWe assume that as standard, you have installed Xcode on your Apple Silicon Mac.\n\nHere we use Xcode 14.1.\n\nIn order for the CodeQL engine to run, we also need Command Line Tools for Xcode and Rosetta 2.\n\nInstall Command Line Tools from Apple Download Site by searching for \"Command Line Tools\". Install the edition that matches our installed Xcode version, 14.1.\n\nRosetta 2 is installed upon demand the first time a tool (such as CodeQL) requires it. But it is possible to put it in place beforehand with the command\n\nThen resources needed in order to compile the XNU kernel are provided by the Kernel Debug Kit. The kernel evolves rapidly over time, and particularly after a new product release, a bulk update can often been seen in the XNU sources. There is a tight coupling between the version of the KDK and the XNU kernel that is compiled using it. Expect to have to do hacks and tweaks if this document is being read sometime after the versions we specify here.\n\nTo get the currently most recent KDK, visit the Apple Download Site and search for \"Kernel Debug Kit\". Specifically we use 13.1 build 22C65 in this tutorial.\n\nOnce the KDK is downloaded and installed, it will be present on your machine, and can be confirmed using:\n\nNote that in an earlier chapter, we used the KDK because we wanted to actually do Kernel Debugging. Here, we use KDK only to facilitate XNU kernel compilation.\n\nIt is worthwhile, whilst we are here, to look inside the KDK subdirectories because it is like Polyfilla (TM). It has many binary components that fill gaps in the open source XNU in order to make a complete system. This would either be to hide details of Apple-custom hardware, or avoid third party intellectual property issues preventing Apple from releasing the source code.\n\nBuild XNU kernel\n\nInstalling all the prerequisite software modules that the XNU kernel requires, as well as patching up small differences needed due to our compilation being done outside of Apple (and thus not using their internal SDK) is non-trivial. Fortunately the heavy-lifting has already been done by pwn0rz with repository pwn0rz/xnu-build. In this tutorial we are using it at commit 6b5c72cfb5a9a9ad8b5e9e245dbd00f331d37259.\n\nClone the repository pwn0rz/xnu-build.\n\nEnsure a modern Python is present on your system, e.g. Python 3.10.8\n\nRun the script that fetches and compiles the source code\n\ncd xnu-build ./x.py > x-py-output.txt2>x-py-err.txt\n\nIt is worthwhile trying to exactly match the software being used here to see it working in at least one configuration. Then on later versions of the XNU kernel, some idea of what \"normal\" looks like is already in mind, and iterative debugging can be done to get the kernel to compile. There is no single long term solution here since the XNU source code is kind of \"thrown over the wall\" to the community. It is not a project which comes associated with a governance and community leadership aspect from Apple. To be fair, we should be grateful that it even exists.\n\nIn our case, our case, out compile never completely succeeds. But it is not really a problem because the above configuration gets us what we require - a set of intermediate binary objects that then can be explored and inspected with CodeQL later along.\n\nOur output files can be cross-compared from The Road to Zero GitHub, in directory examples/compile_xnu.\n\nSetup Visual Studio Code\n\nWe assume you have setup Visual Studio Code, Microsoft VS Code When running this tool, with the \"Activity Bar\" on the left visible, or Shift+Command+X, the extensions panel can be raised. Search for extension \"CodeQL\" (the author is GitHub and should be the first match). Then install it.\n\nAt this point we have a CodeQL extension installed, but no actual CodeQL engine (called the CodeQL CLI) that it can call.\n\nFurthermore, CodeQL needs two more items to be effective. Firstly it needs rules (a ruleset) that it can execute to find code weaknesses and bugs. Secondly, it needs a database file that indexes the code base it should search within.\n\nIn order to get the ruleset, recursively clone the repository Starter Workspace\n\nIdentify the location of the checked out file, vscode-codeql-starter.code-workspace from the above repository. In Visual Studio Code, choose \"File -> Open Workspace From File...\" and select the above workspace file.\n\nInstall CodeQL CLI\n\nThe engine that runs CodeQL is called the CodeQL CLI. These are offered as binaries. In order for our configuration to work we require Xcode command-line developer tools and Rosetta 2 are installed. These were installed earlier.\n\nDownload the CodeQL CLI via the release binaries. Here we are using codeql-osx64.zip version 2.11.6. The latest version is at CodeQL Releases\n\nPlace the downloaded codeql into a place which is reachable by your shell PATH variable. E.g. for zsh users it would be:\n\nand check the installed command:\n\nCreate the XNU CodeQL Database\n\nAt this point we can go back to our xnu-build repository and run its second shell script.\n\nOur output files can be cross-compared from The Road to Zero GitHub, in directory examples/codeql_database_generation. Make a note of the newly created directory, xnu-codeql because this is referenced in a later step.\n\nImport the XNU CodeQL Database\n\nFrom the Left Hand panel of Visual Studio Code, click the Dots menu and select CodeQL to show it.\n\nFrom here we can \"Add a CodeQL Database from a folder\". We pick the xnu-codeql folder we generated in the previous section. (It will be a subdirectory of xnu-build.)\n\nWhen this is done we see that the CPP (C++) database xnu-codeql is seen with a tick mark in the Left Panel section marked \"DATABASES\".\n\nRun a Query\n\nWe now need to switch our view from the CodeQL plug-in view to the normal folders view.\n\nAs a consequence of the recursive clone made for the starter project earlier, we should have a folder called ql as seen in the above screenshot.\n\nWe need to drill down into ql/cpp/ql/src/Security/CWE/CWE-014 to find a directory showing some sample code, and a .ql file for finding such examples. Right Clicking on MemsetMayBeDeleted.ql and selecting \"Run Query\" will execute the query against our database, which is the XNU kernel.\n\nUnfortunately it will not result in any matches because the code does not have such a flaw.\n\nRun a Batch of Queries\n\nWe can select at a folder level and choose to run a batch of queries. The CodeQL tool will find all .ql files in the file hierarchy and run each in turn. For example Right Clicking on ql/cpp/ql/src/Likely Bugs/Memory Management will run memory management checks. Unfortunately again, there are no matched returned results because the source base does not have such flaws.\n\nAs we mentioned in our earlier section, there can be query limits we reach. These limits can be extended.\n\nWe need to update the workspace file vscode-codeql-starter.code-workspace to support for example 128 queries (instead of the default 64):\n\nNext Steps\n\nWe have shown a powerful tool that can be used to inspect the XNU kernel source, and shown how we can get the source code and compile it.\n\nWhat remains is to explore the CodeQL query language, and make novel queries.\n\nWe could draw inspiration from past bug fixes to see if other instances are present by crafting a query that would match the past bug fix.\n\nAlternatively we could run some of the \"noise\" queries, such as the empty block query we presented earlier in this chapter. This can lead to insights and further refinement to get a good query that could find a flaw."
    }
}