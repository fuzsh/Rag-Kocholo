{
    "id": "dbpedia_465_0",
    "rank": 65,
    "data": {
        "url": "https://alephsecurity.com/2019/06/17/xnu-qemu-arm64-1/",
        "read_more_link": "",
        "language": "en",
        "title": "Running iOS in QEMU to an interactive bash shell (1): tutorial",
        "top_image": "https://alephsecurity.com/assets/img/logo-black.png",
        "meta_img": "https://alephsecurity.com/assets/img/logo-black.png",
        "images": [
            "https://alephsecurity.com/assets/img/qemu-ios/bash-shell-demo.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/kernel-gdb-demo.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/hlt1.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/hlt2.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/hlt3.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/hlt4.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "alephsecurity.com"
        ],
        "publish_date": "2019-06-17T00:00:00",
        "summary": "",
        "meta_description": "Running iOS in QEMU to an interactive bash shell (1): tutorial",
        "meta_lang": "en",
        "meta_favicon": "/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://alephsecurity.com/2019/06/17/xnu-qemu-arm64-1/",
        "text": "Edit (July 2020): This project has greatly evolved since its first release. Now, the kernel is patched to bypass the Secure Monitor and the Core Trust mechanisms. We decided to leave this blog post unchanged for educational purposes. To see the current status of the project, please visit our GitHub repository.\n\nWhile wanting to do some iOS security research and inspired by the work done by zhuowei, I decided to try and get this emulation project further along the boot process. The goal was to get the system to boot without having to patch the kernel beforehand or during the boot process, have new modules that extend QEMU’s capabilities to execute arm64 XNU systems and, get an interactive bash shell. This post is the first post in a 2-post series, in which I will present instructions for executing iOS on QEMU and launching an interactive bash shell. In the second post, I will detail some of the research that was required in order to get there. For this project, the iOS version and device that were chosen are iOS 12.1 and iPhone 6s Plus, because this specific iOS 12 image comes with a lot of symbols exported in the kernel image compared to other iOS kernel images that are usually stripped of most symbols. This presented some more challenges, because it is a non-KTRR device that uses a secure monitor image, and that required changes in the stages of the solution already done by zhuowei. Another change is that I wanted this feature to be in external modules that could later be extended and used to create modules for other iOS devices and versions, instead of having the code inside the core QEMU code.\n\nCurrent Status\n\nThe project is now available at qemu-aleph-git with the required scripts at qemu-scripts-aleph-git. The current status allows booting to user mode with a read only mounted ram disk, to which new executables and launchd items can be added (before boot), and those can use the dyld cache from the main disk image copied to the ram disk and communicate with the user via the emulated UART channel. Here is a demonstration of running an interactive bash shell with this project:\n\nThis lets you execute whatever user mode process you want as root, with whatever entitlements you choose, and debug the process and/or the kernel with a kernel debugger:\n\nCurrent Limitations\n\nThere is a long suspension where nothing happens for a few seconds before mounting the ram disk.\n\nIt only works with a ram disk image which is mounted as read only, and is limited to 2GB in size.\n\nWe can only communicate with the guest iOS over UART, and no other communication channels are currently available.\n\nNo devices emulation: screen, touch, wifi, BT or anything else.\n\nOnly a single emulated CPU is currently supported.\n\nTutorial\n\nTo start the process we first need to prepare a kernel image, a device tree, a static trust cache, and ram disk images. To get the images we first need to get the update file from Apple: iOS 12.1 update file. This is actually a zip file which we can extract:\n\nNext, we need to clone the supporting scripts repository:\n\nAnd extract the ASN1 encoded kernel image:\n\nThis decoded image now includes the lzss compressed kernel. You can use this code to decompress it or use this translated code with python2.\n\nNow let’s prepare a device tree which we can boot with (more details about the device tree in the second post). First, extract it from the ASN1 encoded file:\n\nNow we have to set up the ram disk. First, ASN1 decode it:\n\nNext, resize it so it has room for the dynamic loader cache file (needed by bash and other executables), mount it, and force usage of file permissions on it:\n\nNow let’s mount the regular update disk image 048-31952-103.dmg:\n\nCreate a directory for the dynamic loader cache in the ram disk, copy the cache from the update image and chown it to root:\n\nGet precompiled user mode tools for iOS, including bash, from rootlessJB and/or iOSBinaries. Alternatively, compile your own iOS console binaries as described here.\n\nConfigure launchd to not execute any services:\n\nAnd now, configure it to launch the interactive bash shell by creating a new file under /Volumes/PeaceB16B92.arm64UpdateRamDisk/System/Library/LaunchDaemons/bash.plist with the following contents:\n\nAs a side note, you can always convert the binary plist files that you find natively in iOS images to text xml format and back to binary format with:\n\nFor launch daemon, iOS accepts both xml and binary plist files.\n\nSince the new binaries are signed, but not by Apple, they need to be trusted by the static trust cache that we will create. To do this, we need to get jtool (also available via Homebrew: brew cask install jtool). Once we have the tool, we have to run it on every binary we wish to be trusted, extract the first 40 characters of its CDHash, and put it in a new file named tchashes. A sample execution of jtool looks like this:\n\nIn the above case, we need to write down 7ad4d4c517938b6fdc0f5241cd300d17fbb52418 in tchashes. For convenience, the following command will extract the correct part of the hash from each of the binaries we put in the image:\n\nCreate the static trust cache blob:\n\nNow is a good time to unmount both volumes.\n\nWe now have all the images and files prepared. Let’s get the modified QEMU code (more detailed info on the work done in QEMU will be in the second post in the series):\n\nand compile it:\n\nAnd all there’s left to do is execute:\n\nAnd we have an interactive bash shell! :)\n\nNote that the last flag (-serial mon:stdio) will forward all shell combinations (such as Ctrl+C) to the shell. To shut down QEMU, close its (empty) window.\n\nTo get a kernel debugger, -S -s should be added to the QEMU command line, and then it’s possible to execute target remote :1234 in a gdb console which supports this architecture. More details on how to get this gdb and perform this can be found in here. You can also get the relevant gdb on OSX with mac ports, while adding the multiarch and python27 options to the gdb port.\n\nFuture Improvements\n\nMake this boot much faster, without a long suspension before mounting the ram disk.\n\nAdd support to emulate the iOS as a USB device and communicate over usbmuxd. This will enable us to connect over SSH and therefore copy files using scp, have a more robust terminal, conduct security research for network protocols, use gdbserver to debug user mode applications and more.\n\nAdd support for emulated physical storage to work with a r/w mounted disk, that won’t be a ram disk and will not be limited to 2GB.\n\nAdd support for devices such as screen, touch, wifi, BT, etc…\n\nAdd support for more iDevices and iOS versions.\n\nFun Feature\n\nUser applications get loaded at different addresses every boot because of ASLR, and can share virtual addresses with one another, so using a regular breakpoint on a static virtual address in gdb can be challenging, when debugging user mode applications. Therefore, I added another fun feature to help debug user mode applications in this kernel debugger. When QEMU encounters the HLT aarch64 instruction, it breaks in gdb just as if it was a gdb breakpoint, so all you have to do to debug user mode applications in the kernel debugger is to patch the application with an HLT instruction, using ghidra, for example:\n\nand then sign it using jtool with any required entitlements:\n\nAfter that, you need to add the new CDHash to the tchashes file, and recreate the static trust cache.\n\nFollowing that, gdb will break when it encounters the HLT instruction in the user mode application so we can debug the application in the kernel debugger:\n\nConclusion\n\nIf you have gotten this far, and are interested in learning about some of the research and some of the implementation details, then carry on and read the second blog post in the series, as well as the code, comments and commit messages. The second blog post in the series will be available soon, stay tuned.\n\nPlease let me know if you have any ideas, suggestions, or other comments below."
    }
}