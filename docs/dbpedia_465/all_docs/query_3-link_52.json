{
    "id": "dbpedia_465_3",
    "rank": 52,
    "data": {
        "url": "https://forums.macrumors.com/threads/start-programming-on-os-x-ppc.2290129/",
        "read_more_link": "",
        "language": "en",
        "title": "Start Programming on OS X PPC",
        "top_image": "https://images.macrumors.com/social/?t=2290129&v=6",
        "meta_img": "https://images.macrumors.com/social/?t=2290129&v=6",
        "images": [
            "https://images.macrumors.com/images-new/macrumors-simple-logo-light.svg",
            "https://images.macrumors.com/images-new/macrumors-simple-logo-dark.svg",
            "https://images.macrumors.com/images-new/macrumors-simple-logo-light.svg",
            "https://images.macrumors.com/images-new/macrumors-simple-logo-dark.svg",
            "https://secure.gravatar.com/avatar/d91dada7f075bc8885c4c113b61412df?s=96",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://secure.gravatar.com/avatar/d91dada7f075bc8885c4c113b61412df?s=96",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://forums.macrumors.com/data/avatars/m/1069/1069261.jpg?1508754594",
            "https://forums.macrumors.com/data/avatars/m/1207/1207497.jpg?1584554365",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://forums.macrumors.com/data/avatars/m/1207/1207497.jpg?1584554365",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://forums.macrumors.com/attachments/1617276060902-png.1752025/",
            "https://forums.macrumors.com/attachments/1617276170587-png.1752027/",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://forums.macrumors.com/data/avatars/m/1024/1024959.jpg?1462634003",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://forums.macrumors.com/proxy.php?image=https%3A%2F%2Fsourceforge.net%2Fprojects%2Fsears%2Ffiles%2Fsears%2F&hash=cc81c09cec9f4fbdbf7738e8e1373110&return_error=1",
            "https://forums.macrumors.com/data/avatars/m/1203/1203692.jpg?1578951020",
            "https://forums.macrumors.com/data/avatars/m/873/873727.jpg?1560109122",
            "https://secure.gravatar.com/avatar/d91dada7f075bc8885c4c113b61412df?s=96",
            "https://images.macrumors.com/images-new/macrumors-simple-logo-light.svg",
            "https://images.macrumors.com/images-new/macrumors-simple-logo-dark.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "sanfrancisofont1984"
        ],
        "publish_date": "2021-03-30T20:21:10+00:00",
        "summary": "",
        "meta_description": "Step 1, download and install Xcode that is latest for your OS version. I usually use https://xcodereleases.com/ It might require an Apple ID. Note that...",
        "meta_lang": "",
        "meta_favicon": "/data/assets/logo/mr-icon-192.png",
        "meta_site_name": "MacRumors Forums",
        "canonical_link": "https://forums.macrumors.com/threads/start-programming-on-os-x-ppc.2290129/",
        "text": "I do wish I'd started learning C earlier than I did—it's the language everything else today is based on—but I'm really glad I didn't have to worry about pointers and memory addresses when I was initially starting out!\n\nThen C# or Java should suffice. Based on the C syntax, though of course still rather removed from original core C, but without pointer shenanigans.\n\nOne day I'll write a blog post about it, but I would not encourage any beginner start with Python if programming is what they want to get into. If all they want is to use programming as a tool for quickly manipulating data for other uses like scientific or mathematical work, fine. But if their goal is to learn programming, I don't think Python is as good a starting point as many seem to suggest.\n\nBut I am also biased against Python and find it often results in abhorrent code if what you're doing requires more than 200-ish lines\n\nRemember we're in the PPC section though. Java is stuck on an old version, so you risk running into out-of-date documentation. And correct me if I'm wrong, but I don't think Mono is a thing on PPC?\n\nSure, valid points. Though Java has documentation available for each version; It doesn't kill older versions when a new set of docs come up. - So if the reader was cognisant of the version it wouldn't be an issue. And I believe Java 6 should be available at least. Java 8 would be nice with lambdas, but 6 should be perfectly good as a starting point I think.\n\nAs for Mono, no I haven't heard of a PPC version. When I wrote C# I didn't consider the PPC bit .\n\nI do like teaching Python to beginners in general (I taught at Girls Who Code before the pandemic, and I have aspirations to teach coding in an elementary or middle school), but that's less a love of Python and more a process of elimination. Python is a nice playground for learning what variables, loops, and functions are, without being distracted by OO constructions, code that can run out of order, or memory addresses. And unlike, say, Processing, Python is a \"real\" language which you can use to make useful things, even as a beginner, which is just plain more fun and exciting.\n\nRight. - I think I'd personally suggest Swift Playgrounds in that situation, though that is a fairly recent development. It does also come with a limitation of requiring either a Mac/iPad setup or setting up a Swift build environment on Linux and then you won't have access to UIKit and such, which might limit the appeal for younger learners somewhat.\n\nSo yeah, context is important, and Python has its place.\n\nIf you're new, you may also want to consider using something like Python. MacPorts has PPC compatible versions of Python 3 (the built-in version is Python 2), and if you ever want to share your work, you can use pyinstaller to create standalone binaries.\n\nI do wish I'd started learning C earlier than I did—it's the language everything else today is based on—but I'm really glad I didn't have to worry about pointers and memory addresses when I was initially starting out!\n\nThe latest Python 3.6.x releases still compile for even 10.3.9 Panther without patches using Xcode/10.4 SDK, and 3.6.x is still getting security updates till the end of this year. Using TigerPorts or\n\nLeopardPorts will get you to the latest version 3.9.\n\nAs for me, I’m all in on C. Nothing is more beautiful then having one .c text file (well various copies of it with different line endings) compile for literally anything and your toaster. So far I’ve gotten every C program I’ve ever written to work on Mac OS 9 except one (which may change soon, is there a byte swap function for OS 9 like in OS X?) since I target the ancient C89/ANSI-C standard. Some of my stuff is on GitHub. Here’s something that targets C89.\n\nAs for me, I’m all in on C. Nothing is more beautiful then having one .c text file (with different line endings) compile for literally anything and your toaster. So far I’ve gotten every C program I’ve ever written to work on Mac OS 9 except one (which may change soon) since I target the ancient C89/ANSI-C standard. Some of my stuff is on GitHub.\n\nI know you probably don't mean it that way, but I feel like this is a bit dangerously close to \"True programmers code in C\" which is a downwards slope to \"true programmers only code assembly\" or even machine code directly.\n\nAnd even if you try to code portable C89, you still need to be very careful when taking it to other platforms. Is stdlib.h even available on SmartFridgeOS2? Does their version of memcpy actually behave slightly differently to what it does on every other platform? - Compiling also isn't the same as functioning the same there may be platform specific bugs, or you may accidentally be relying on undefined behaviour.\n\nThat's not to say your code falls into any of these pitfalls. But for a thread which initial premise was showing beginners how to get started, I don't want newcomers to programming reading this thinking they have to write C89 (C999, Assembly, C++, or any specific language at all) to be a \"true programmer\" or anything.\n\nAgain, I'm sure that wasn't your intention either, just want to ensure a welcoming tone to newly interested folk reading, and don't want them to get scared away by\n\nCode:\n\ntypedef struct TreeNode { struct TreeNode* next; struct TreeNode* previous; int value; } TreeNode_t;\n\nor anything\n\nOr my personal favourite weird-looking C; The function pointer\n\nCode:\n\n((void (*)(void)) ((uint32_t)(ELFHDR->e_entry)))();\n\nThat's not to say your code falls into any of these pitfalls. But for a thread which initial premise was showing beginners how to get started, I don't want newcomers to programming reading this thinking they have to write C89 (C999, Assembly, C++, or any specific language at all) to be a \"true programmer\" or anything.\n\nAgain, I'm sure that wasn't your intention either, just want to ensure a welcoming tone to newly interested folk reading, and don't want them to get scared away by\n\nCode:\n\ntypedef struct TreeNode { struct TreeNode* next; struct TreeNode* previous; int value; } TreeNode_t;\n\nor anything\n\nOr my personal favourite weird-looking C; The function pointer\n\nCode:\n\n((void (*)(void)) ((uint32_t)(ELFHDR->e_entry)))();\n\nOf course, which is why I said “as for me”. Do what you like, what you want, and what you enjoy. If I’m writing a real command line program from scratch I’m using C89 unless I can’t, but that’s just what I’m used to and what I think is the most valuable use of my time for retro from scratch projects. Hello world is K&R C anyways, predating C89 by over a decade. C89 is a great stepping stone IMO.\n\nFor Panther/Tiger/Leopard you can usually get C17 stuff to work anyways with TigerPorts/LeopardPorts and GCC 7.4.\n\nI know you probably don't mean it that way, but I feel like this is a bit dangerously close to \"True programmers code in C\" which is a downwards slope to \"true programmers only code assembly\" or even machine code directly.\n\nLot of software is written in C and thus more or less portable. So we don't often go downwards. Python (CPython) is written in C. Linux and BSD kernels are written in C with a sprinkle of assembly (Darwin kernel might have some C++ in it as well?). Many Unix utilities are written in C.\n\nFor OS X PPC in particular knowing C also helps a lot with Objective-C.\n\nI don't mind people using Python to start instead but I'd mention that Python is bad at being \"self-sufficient\". The interpreter is written in C. Many performance-concerning Python libraries are calling into C, C++ or Fortran. For completeness, there is also PyPy written in RPython with a JIT (does it work on PPC?).\n\nBTW, C++ is also important especially for those interested in the likes of browsers and compilers ...\n\nLot of software is written in C and thus more or less portable. So we don't often go downwards. Python (CPython) is written in C. Linux and BSD kernels are written in C with a sprinkle of assembly (Darwin kernel might have some C++ in it as well?). Many Unix utilities are written in C.\n\nFor OS X PPC in particular knowing C also helps a lot with Objective-C.\n\nI don't mind people using Python to start instead but I'd mention that Python is bad at being \"self-sufficient\". The interpreter is written in C. Many performance-concerning Python libraries are calling into C, C++ or Fortran. For completeness, there is also PyPy written in RPython with a JIT (does it work on PPC?).\n\nBTW, C++ is also important especially for those interested in the likes of browsers and compilers ...\n\nSure; But what does all that really matter to someone learning? Or really to anyone trying to just achieve something. The reason Linux, XNU, Mach, BSD, NT, etc. are written in C is that you don't really have a choice there. - Or at least hadn't at the time of their inception; There's Zig now which could work as a systems programming language. C can work with no dependencies; No standard library or anything. Most other languages cannot really. But that doesn't necessarily mean every single part of these systems is written purely in C. - To also answer your question about Darwin, here's the scc output for Darwin/XNU\n\nAnd for completeness, here's the one for the Linux kernel project\n\nI should note that most of (perhaps even all) the C++ files are drivers.\n\nBut back to where I started; What does it matter? Unless you're writing an OS, which you likely aren't, any language and toolchain that gets the job done is perfectly fine. If you don't *need* to manipulate memory directly, it isn't even really an advantage that C lets you. It just makes it more likely you'll encounter really weird and hard to debug problems, when your program continues even after you've clobbered your stack.\n\nAnd most C code never winds up purely portable anyway. You often wind up relying on system provided libraries you can't expect to be everywhere. Or compiler specific behaviour for that matter.\n\nThe core of the Linux kernel may be C but there are so many dependencies at this point that you can only really build Linux on Linux.\n\nIf a tool gets the job done, it doesn't matter what the tool is. C is a multi-tool and heavy machinery. If your goal is to put up a painting, just use a hammer for the nail, not a bulldozer. It's just a matter of tradeoffs, and sometimes C doesn't give the best balance there. Otherwise Netflix wouldn't have a lot of their infrastructure written in Scala for example.\n\nGet me right, C's absolutely wonderful and I appreciate the legends of Bell Labs for it. But when machine code is executed and the computer does what you want it to do; It's more or less irrelevant if it's C, Go, Rust, Zig, Dart or whatever behind it\n\nLot of software is written in C and thus more or less portable. So we don't often go downwards. Python (CPython) is written in C. Linux and BSD kernels are written in C with a sprinkle of assembly (Darwin kernel might have some C++ in it as well?). Many Unix utilities are written in C.\n\nFor OS X PPC in particular knowing C also helps a lot with Objective-C.\n\nI don't mind people using Python to start instead but I'd mention that Python is bad at being \"self-sufficient\". The interpreter is written in C. Many performance-concerning Python libraries are calling into C, C++ or Fortran. For completeness, there is also PyPy written in RPython with a JIT (does it work on PPC?).\n\nBTW, C++ is also important especially for those interested in the likes of browsers and compilers ...\n\nI feel like with my last reply I completely missed the whole point about the downward slope; - It wasn't really about the practicality of things, but about the. culture of things. Opinions on \"I like language x and don't like language y\" are welcome discussions in my mind. But I don't want a culture where \"You're not a real programmer cause you code Java and not C\" is prevalent - It may not be as much of a threat on these forums, but try roaming Stack Exchange a bit and you'll get what I mean, haha\n\nBut back to where I started; What does it matter? Unless you're writing an OS, which you likely aren't, any language and toolchain that gets the job done is perfectly fine. If you don't *need* to manipulate memory directly, it isn't even really an advantage that C lets you. It just makes it more likely you'll encounter really weird and hard to debug problems, when your program continues even after you've clobbered your stack.\n\nC and C family (C++, Objective-C) are used far beyond just OS projects. It is a bit tedious to list then all interesting projects so let's just give 5 non-OS examples. Bash, ffmpeg, Firefox (mostly C++), Python, vim. Programming is about as much inspecting/modifying existing programs as wiring new ones from scratch. So we should not ignore what's out there.\n\nTo be fair, plain C is not necessarily a great programming language for \"application programming\" (as opposed to \"system programming\") due to reasons you mentioned. So C++ and Objective-C were invented as almost drop-in upgrades. Interestingly, apart from Qt (C++) side of things, bulk of Linux desktop (Xorg, mesa, desktop environments and window managers) is written in plain C with some C++, Python, JS, Vala, C#, D in between.\n\nNow what about all these new shiny languages. Well, I don't see any of them becoming as foundational as C in the ecosystem any time soon (Rust may be the only exception, it is showing up in some foundational project like librsvg). And in the PPC context, apart from ones that are interpreted and without a JIT (like Python), most of them probably would not work on PPC and anything written in them automatically becomes a portability problem for PPC. Sidenote, in the first few weeks/months after Apple M1 shipped, Java, Go and Rust are all missing so a large chunk of Homebrew would not work natively using ARM. One would be glad in that case if something they care is written only in C/C++.\n\nC and C family (C++, Objective-C) are used far beyond just OS projects. It is a bit tedious to list then all interesting projects so let's just give 5 non-OS examples. Bash, ffmpeg, Firefox (mostly C++), Python, vim. Programming is about as much inspecting/modifying existing programs as wiring new ones from scratch. So we should not ignore what's out there.\n\nI'm also not arguing that. By all means, learn C. I wouldn't recommend it as your first language, but if it's what you want to start with, go for that too. But what a beginner wants is usually to submit a pull request for Firefox or ffmpeg.\n\nThey might want to make their own, *simple* little UI based program after printing hello world and doing a few console things. And that's where, on PPC I'd say Java as a great starting point, and on newer Macs Swift would be great too. It's far, far easier to get started and draw a window with. And you can find plenty code written in any language, so \"let's not ignore what's out there\" could be applied to learning literally all of them.\n\nNow what about all these new shiny languages. Well, I don't see any of them becoming as foundational as C in the ecosystem any time soon (Rust may be the only exception, it is showing up in some foundational project like librsvg). And in the PPC context, apart from ones that are interpreted and without a JIT (like Python), most of them probably would not work on PPC and anything written in them automatically becomes a portability problem for PPC. Sidenote, in the first few weeks/months after Apple M1 shipped, Java, Go and Rust are all missing so a large chunk of Homebrew would not work natively using ARM. One would be glad in that case if something they care is written only in C/C++.\n\nI disagree with that last bit. If whatever you rely on lives on the Java Virtual Machine, it runs natively as soon as the JVM does. That's bound to happen. If it's written in C and is closed source or low level enough that it's not architecture agnostic, you're not getting a native version of that ever/without a lot of work from you.\n\nWhat if your favourite C project. There are quite a few, but here's one example of an ARM64 and x86_64 difference that might cause issues in your C code if you're not cognisant of it\n\nThe x86_64 and arm64 architectures have different calling conventions for variadic functions—functions with a variable number of parameters. On x86_64, the compiler treats fixed and variadic parameters the same, placing parameters in registers first and only using the stack when no more registers are available. On arm64, the compiler always places variadic parameters on the stack, regardless of whether registers are available. If you implement a function with fixed parameters, but redeclare it with variadic parameters, the mismatch causes unexpected behavior at runtime.\n\nThat's from Apple's docs on the matter.\n\nIf your codebase was Java on the other hand you would not have to change your code or even .jar file at all. An updated JVM would make it native.\n\nAgain; I like C. I write C in my current project. But everything comes with tradeoffs\n\nAnd that's where, on PPC I'd say Java as a great starting point, and on newer Macs Swift would be great too. It's far, far easier to get started and draw a window with. And you can find plenty code written in any language, so \"let's not ignore what's out there\" could be applied to learning literally all of them.\n\nCan you give some example Java projects that are interesting and can actually run on PPC? Even snippets found online these days might not compile on early Java compilers like 1.5.\n\nSwift might be a good language but on Mac one would need latest macOS to get latest Xcode to get latest Swift compiler (we are at Swift 5.x right now), not very early Intel friendly isn't it? The Linux release is x86-64 so that might be okay on early Intel.\n\nI disagree with that last bit. If whatever you rely on lives on the Java Virtual Machine, it runs natively as soon as the JVM does. That's bound to happen. If it's written in C and is closed source or low level enough that it's not architecture agnostic, you're not getting a native version of that ever/without a lot of work from you.\n\nWhat if your favourite C project. There are quite a few, but here's one example of an ARM64 and x86_64 difference that might cause issues in your C code if you're not cognisant of it\n\nThat's from Apple's docs on the matter.\n\nIf your codebase was Java on the other hand you would not have to change your code or even .jar file at all. An updated JVM would make it native.\n\nWho is going to maintain a updated JVM for a platform like Mac PPC? Also many jars in the wild contain native code not compiled for Mac PPC (or Solaris for that matter)...\n\nCan you give some example Java projects that are interesting and can actually run on PPC? Even snippets found online these days might not compile on early Java compilers like 1.5.\n\nSwift might be a good language but on Mac one would need latest macOS to get latest Xcode to get latest Swift compiler (we are at Swift 5.x right now), not very early Intel friendly isn't it? The Linux release is x86-64 so that might be okay on early Intel.\n\nSears - A caption editor, works with Java 1.6 I believe. 1.6 is the latest available for PPC if I'm not mistaken\n\nSears - Browse /sears at SourceForge.net\n\nA java graphical tool to easily modify, delay and resynch movie's subtitles. When your subtitles does not fit the movies/TV show you're looking at.…\n\nBut that's missing the point I was making, as is the Swift thing. - It's not important if it's the very latest version of the language with the latest language features or if there are many projects out there using the exact same language and version. If you're just getting started, any code you write that can do what you're trying to do is worthwhile. And making your own little thing in Java will give you a lot of the skills you need to get into the C codebases you mentioned as well, but you don't need to debug the more esoteric parts of C while you're learning. This is irregardless of PPC, Intel or other as well as OS of choice.\n\nWho is going to maintain a updated JVM for a platform like Mac PPC? Also many jars in the wild contain native code not compiled for Mac PPC (or Solaris for that matter)...\n\nWhat I was replying to, and what you're now replying to in turn, was about The M1 Macs and getting Homebrew software up and running. An updated JVM is definitely available there now.\n\nBut even if we look at the PPC bit; Sure someone might not maintain an updated JVM. But who will go and port esoteric C code that makes assumptions about the architecture to PPC if it's made for Intel? Or C code that uses libraries only available on Big Sur? It's the same issue just shifted to a different layer. Going by that logic you also don't need to update the JVM; You could also \"downgrade\" the code of the relevant program to Java 1.6.\n\nI''m also not married to Java, it was just an example of other options other than C existing and being valid"
    }
}