{
    "id": "dbpedia_465_0",
    "rank": 76,
    "data": {
        "url": "https://blog.siguza.net/cl0ver/",
        "read_more_link": "",
        "language": "en",
        "title": "cl0ver",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://blog.siguza.net/cl0ver/assets/img/heap1.svg",
            "https://blog.siguza.net/cl0ver/assets/img/heap2.svg",
            "https://blog.siguza.net/cl0ver/assets/img/heap3.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Siguza’s Blog",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "cl0ver",
        "canonical_link": "https://blog.siguza.net/cl0ver/",
        "text": "Siguza, 25. Dec 2016\n\ntfp0 powered by Pegasus\n\nMake Userland Great Again!\n\nIntroduction\n\nOn October 4th, @jndok did an amazing writeup on how to exploit the Pegasus vulnerabilities on OS X.\n\nShortly after that I started working on a tool to exploit them on iOS, in order to add the tfp0 kernel patch that has been missing from Pangu’s 9.0 and 9.2-9.3.3 jailbreaks. On December 4th, my tool had advanced enough for me to release a proof of concept video, it was still far from complete. I intended to bring it to full compatibility with as many devices and OS versions as possible, but shortly after my PoC, @qwertyoruiopz released a web-based reimplementation of the 9.2-9.3.3 jailbreak, which does have a tfp0 patch. Apparently I’ve also missed some ongoing efforts by Simone Ferrini/Benjamin Randazzo/@angelXwind to create a 32-bit jailbreak based on these vulnerabilities. And on December 15th Ian Beer killed it (once again) with his partial 10.1.1 jailbreak, which qwertyoruiopz is now turning into a full one, probably diverting everyone’s attention away from iOS 9 for good.\n\nOf course huge props to all of them, but that kind of abolishes the need for an iOS 9 tfp0 patch. In light of that, I’m going to release my tool in an unfinished state and instead focus on this writeup.\n\nSo, here’s my demonstration of how to use the Pegasus vulnerabilities to dump, exploit and patch an iOS kernel in a way that can be done from within the sandbox and with only publicly available knowledge (i.e. no kernel dumps required).\n\nI’m gonna leave it at applying the tfp0 patch here, but turning this into a full jailbreak should then be as “simple” as installing more patches to the kernel and other parts of the system, using tfp0 + the Mach APIs… it’s just gonna be a whole lot of work.\n\nNow, If you haven’t already, I heavily suggest reading jndok’s writeup before continuing here.\n\nThe following are assumed to be well known/understood, and are explained in detail in his writeup:\n\nthe OSSerializeBinary data format\n\nhow the kernel slide info leak works\n\nhow the UaF can be used to gain PC control\n\nNote: This project included a lot of “firsts” for me. I’ve never before: done ROP, played with IOKit, MIG or the kernel heap, etc, etc. As such it might be that this writeup contains some misconceptions or stuff that could be done a lot easier, faster or safer.\n\nIf you spot anything like that, please let me know (via GitHub issues, Mastodon, Email (*@*.net where * = siguza), or whatever).\n\nAlso please don’t hesitate to contact me if there’s something you don’t understand, of if you’d like more details on something.\n\nFor the record, I’ve worked this up on an iPhone SE (iPhone8,4/N69AP) on 9.3.3/13G34 and an iPod touch 5G (iPod5,1/N78AP) on 9.3.2/ with only information and tools that are publicly available (not as an exercise for myself, but because I didn’t have anything else, lol).\n\nExploitation overview\n\nLet’s first look at what jndok does on OS X:\n\nmmap() the kernel from /System/Library/Kernels/kernel\n\nLeak the kernel slide\n\nUse kernel + slide to build ROP chain\n\nUse UaF with fake vtable to execute ROP chain\n\nROP chain escalates privileges to root\n\nThat first step is gonna be a problem because on iOS <10, kernels are encrypted. There’s two ways around that:\n\nGet decrypted kernels and hardcode stuff\n\nDump the kernel at runtime\n\nHardcoding stuff is ugly and there are hardly any decryption keys available for 64-bit devices (although nice work on that iPhone6,1, @xerub), therefore the former doesn’t seem like such a viable option. Without finding another exploit that allows us to dump the kernel, and without any friends willing capable of providing us with dumped/decrypted kernels, what can we do?\n\nWell, we can corrupt a string. ;)\n\nLet’s assume for a moment that we can get the kernel to still treat our corrupted string as an instance of OSString - then we merely need to change its buffer pointer to wherever we choose, and we can read back arbitrary kernel memory by calling IORegistryEntryGetProperty on that property. We’re gonna be restricted by the maximum MIG message size so we’ll have to do it in chunks, but we can effectively dump the entire kernel this way!\n\nNow back to our assumption: How do we make the kernel treat our corrupted string still as an OSString? By setting the string’s vtable to the actual OSString vtable. In order to be able to do that, we’re gonna need to learn its address by some other means though.\n\nSo how do we gain knowledge of that address?\n\nNote that vtables are stored in the __DATA.__const section, so once we know our vtab’s offset from the kernel base as well as the kernel slide, we’re all set.\n\nUnfortunately, as far as I’m aware the vtable pointer cannot be obtained at runtime (through the Pegasus vulnerabilities and without prior knowledge, that is). But it’s only a single value, so hardcoding it is a lot more reasonable. Obtaining it once would be enough then.\n\nLet’s see what we can come up with:\n\nFor most (but not all) 32-bit devices (and specifically the 6,1 model of the iPhone 5s) there will likely be decryption keys available.\n\nFor all 64-bit devices except the iPhone 5s, there are no keys publicly available whatsoever, so we need an actual leak. For values that fit into a single register (such as a vtable address), panic logs can sometimes be abused for that. And it turns out that, if played well, this is one of those cases (exclusive to 64-bit though).\n\nFor the few remaining devices (iPad2,4, iPod5,1 and (for iOS >=9.3) iPad3,4-iPad3,6), neither of the above will work. The vtable leak doesn’t work on 32-bit, but we can panic-log some other stuff that, as it turns out, together with decrypted kernels for other devices yields enough information to guess the vtable address.\n\n(Note: My iPhone SE and iPod touch 5G fell into the latter two categories.)\n\nAt this point we’ve conceptually taken care of the first point on jndok’s list. So what else is there?\n\nWe want to install a kernel patch to allow for tfp0, so we obviously need to add that to the list. Installing a kernel patch through ROP sounds unnecessarily complicated to me though, so let’s use ROP to merely retrieve the kernel task first without any patch, and then use the Mach APIs on the kernel to put the actual patch in place. And since we’re doing that using only methods accessible from within the sandbox, we can skip privilege escalation entirely.\n\nNow, at last we have an idea what we want our process to look like:\n\nObtain the OSString vtable pointer once somehow, then hardcode it\n\nLeak the kernel slide\n\nUse UaF with valid vtable to read arbitrary memory/dump the kernel\n\nUse kernel + slide to build ROP chain\n\nUse UaF with fake vtable to execute ROP chain\n\nROP chain makes kernel_task available userland\n\nUse kernel_task to install kernel patches\n\nWith that laid out, let’s look at the details.\n\nPreparations\n\nBefore we can actually get to pwning, we need to set up a few things.\n\nSetting up the build environment\n\nThe Pegasus vulnerabilities are within IOKit, so linking against the IOKit framework is advisable. Apple’s iOS SDK doesn’t come with IOKit headers (anymore?), so we need to get them from elsewhere. We could copy them in from the IOKitUser source… or we could use those of OS X.\n\nFor that we create a local ./include directory that we later pass to the compiler with -I./include, and to where we simply symlink the IOKit header directory:\n\nWe also use some IOKit MIG functions, which are perfectly available on 32-bit (iokitmig.h) but private (non-exported) on 64-bit.\n\nWe could write a 32-bit binary able to exploit both a 32-bit and 64-bit kernel, but having the same data types and sizes as the kernel is just so much more convenient. And after all, generating the MIG routines yourself and statically linking against them turns out to be simple enough. I found very little info on this on the web though, so here’s the process in detail:\n\nThere’s a mig utility to create C source files from .defs, in the case of the IOKit MIG functions, xnu/osfmk/device/device.defs.\n\nWe run it as xcrun -sdk iphoneos mig to get the iOS environment and add -arch arm64 to set the correct target architecture (I’m not sure whether the generated C code differs at all between architectures, but at some point it might, so I’m trying to do this the correct way). Examining the file, we can also see that if the IOKIT macro is not defined, we get hardly anything, so we’re gonna add a -DIOKIT to our flags. Lastly, we need some other .defs files to be included but we can’t specify xnu/osfmk as an include directory because it contains some files that will #error when the architecture is neither i386 nor x86_64, so we symlink the following files (from xnu/osfmk) to our local ./include directory:\n\nFinally we can run:\n\nThis will generate three files:\n\nIncluding iokit.h and iokitUser.c in our program will provide us with the full set of IOKit MIG functions. iokitServer.c isn’t needed as such, but it can still serve as a good reference to understand how exactly the kernel passes our MIG calls to its is_io_* functions.\n\n(In my actual implementation I used /usr/include instead of xnu/osfmk because I can’t assert people to have the XNU source available in a predefined location, but that might stop working when XNU changes enough.)\n\nNow we’re fully equipped to play with IOKit on both armv7 and arm64! :D\n\nRecap: IOKit, data structures and the info leak\n\nWithout further ado, a quick recap/reference on some key points:\n\nConstants:\n\nenum { kOSSerializeDictionary = 0x01000000U, kOSSerializeArray = 0x02000000U, kOSSerializeSet = 0x03000000U, kOSSerializeNumber = 0x04000000U, kOSSerializeSymbol = 0x08000000U, kOSSerializeString = 0x09000000U, kOSSerializeData = 0x0a000000U, kOSSerializeBoolean = 0x0b000000U, kOSSerializeObject = 0x0c000000U, kOSSerializeTypeMask = 0x7F000000U, kOSSerializeDataMask = 0x00FFFFFFU, kOSSerializeEndCollection = 0x80000000U, kOSSerializeMagic = 0x000000d3U, // My creation, equivalent to \"\\323\\0\\0\" }; enum { kOSStringNoCopy = 0x00000001, // For OSString.flags };\n\nOSString in C terms:\n\ntypedef struct { void ** vtab; // C++, for virtual function calls int retainCount; // OSObject, for reference counting unsigned int flags; // OSString, for managed/unmanaged string buffer unsigned int length; // OSString, string buffer length const char * string; // OSString, string buffer address } OSString;\n\nConcrete memory layout:\n\ntypedef struct { uint32_t vtab; uint32_t retainCount; uint32_t flags; uint32_t length; uint32_t string; } OSString32; // sizeof(OSString32) == 20 typedef struct { uint32_t vtab_lo; uint32_t vtab_hi; uint32_t retainCount; uint32_t flags; uint32_t length; uint32_t padding; // <-- note uint32_t string_lo; uint32_t string_hi; } OSString64; // sizeof(OSString64) == 32\n\nWhich data structure goes to which kalloc zone:\n\nType 32-bit 64-bit OSData kalloc.32 kalloc.48 OSString kalloc.24 kalloc.32 OSSymbol kalloc.24 kalloc.48\n\nThe first method called on any kOSSerializeObject is retain(), which is the 5th entry in the vtable (i.e. vtab[4]).\n\nThe kernel slide info leak can be copied from jndok’s code with only minor changes. One can figure out which values are gonna be of use and what their unslid equivalents are like this:\n\nRead some 200 bytes off the kernel stack repeatedly and check for values that start with ffffff80 and don’t change between invocations (unless you reboot).\n\nWrite that value down somewhere, then cause a kernel panic (e.g. by trying to read 4096 bytes off the stack). Obtain the kernel slide from the panic log and subtract it from the value you wrote down. Done.\n\nOn x86_64 it was buf[7] that held a useful address, on armv7 it’s buf[9], on arm64 it’s buf[1].\n\nThe full implementation of this can be found in slide.c.\n\nFeeding XML/binary dicts to IOKit and reading values back works roughly like this (omitted error handling):\n\nvoid io_get_prop(char *serviceName, void *dict, size_t dictlen, char *key, void *buf, uint32_t *buflen) { mach_port_t master; io_service_t service; io_connect_t client; kern_return_t err; io_iterator_t it; host_get_io_master(mach_host_self(), &master); service = IOServiceGetMatchingService(master, IOServiceMatching(serviceName)); io_service_open_extended(service, mach_task_self(), 0, NDR_record, dict, dictlen, &err, &client); IORegistryEntryCreateIterator(service, \"IOService\", kIORegistryIterateRecursively, &it); IORegistryEntryGetProperty(IOIteratorNext(it), key, buf, buflen); IOServiceClose(client); }\n\nNote that the first element of the iterator isn’t necessarily the one you’re looking for (likeliness of this happening depends on serviceName - but you shouldn’t rely on it). So mark your dicts with something identifiable, e.g. your username as a key somewhere, and always iterate over all elements in the registry.\n\nThe full implementation of this can be found in io.c.\n\nAlso note that the choice of serviceName is critical - only a subset of all services allow access from within the sandbox, and only very few of those allow the retrieving of property bytes.\n\nI wrote a little tool that iterates over all possible service names I could find (strings - kernel | grep 'UserClient$') and prints whether:\n\nThe service is valid (IOServiceGetMatchingService returns success)\n\nThe service is accessible (io_service_open_extended returns success)\n\nProperty bytes can be read back on OSStrings and OSNumbers\n\nRunning it inside the sandbox in an unjailbroken environment (you’ll have to pack it into an App for that), we get:\n\niPhone8,4 on 9.3.3:\n\nService name Valid Spawn num str AGXShared --- --- 0 --- ASP --- --- 0 --- AppleARMIIC --- --- 0 --- AppleAVE --- --- 0 --- AppleAuthCP --- --- 0 --- AppleBCMWLAN --- --- 0 --- AppleBaseband yes --- 0 --- AppleBiometricServices yes --- 0 --- AppleCredentialManager yes --- 0 --- AppleD5500 yes --- 0 --- AppleEffaceableStorage yes --- 0 --- AppleEmbeddedPCIE yes --- 0 --- AppleH2CamIn --- --- 0 --- AppleH3CamIn --- --- 0 --- AppleH4CamIn --- --- 0 --- AppleH6CamIn yes --- 0 --- AppleHDQGasGaugeControl yes --- 0 --- AppleIPAppender yes --- 0 --- AppleJPEGDriver yes yes 6969696969696969 abc AppleKeyStore yes yes 6969696969696969 abc AppleMobileApNonce yes --- 0 --- AppleMobileFileIntegrity yes yes 6969696969696969 abc AppleMultitouchSPI yes --- 0 --- AppleNANDFTL --- --- 0 --- AppleNVMeSMART --- --- 0 --- AppleOscarCMA --- --- 0 --- AppleOscar --- --- 0 --- ApplePMGRTemp --- --- 0 --- AppleSEP --- --- 0 --- AppleSPUHIDDevice yes yes 6969696969696969 abc AppleSPUHIDDriver yes --- 0 --- AppleSPUProfileDriver --- --- 0 --- AppleSPU --- --- 0 --- AppleSRSDriver --- --- 0 --- AppleSSE yes --- 0 --- AppleSmartIO yes --- 0 --- AppleStockholmControl yes --- 0 --- AppleT700XTempSensor yes --- 0 --- AppleTempSensor --- --- 0 --- AppleUSBHostDevice --- --- 0 --- AppleUSBHostInterface --- --- 0 --- AppleUSBHost --- --- 0 --- AppleVXD375 --- --- 0 --- AppleVXD390 --- --- 0 --- AppleVXD393 --- --- 0 --- AppleVXE380 --- --- 0 --- CCDataPipe yes --- 0 --- CCLogPipe yes --- 0 --- CCPipe yes --- 0 --- CoreCapture --- --- 0 --- EffacingMediaFilter --- --- 0 --- EncryptedMediaFilter --- --- 0 --- H3H264VideoEncoderDriver --- --- 0 --- IOAESAccelerator yes --- 0 --- IOAVAudioInterface --- --- 0 --- IOAVCECControlInterface --- --- 0 --- IOAVController --- --- 0 --- IOAVDevice --- --- 0 --- IOAVInterface --- --- 0 --- IOAVService --- --- 0 --- IOAVVideoInterface --- --- 0 --- IOAccelMemoryInfo --- --- 0 --- IOAccelRestart --- --- 0 --- IOAccelShared --- --- 0 --- IOAccessoryEAInterface --- --- 0 --- IOAccessoryIDBus --- --- 0 --- IOAccessoryManager yes --- 0 --- IOAccessoryPort yes --- 0 --- IOAudio2Device yes --- 0 --- IOAudio2Transformer --- --- 0 --- IOAudioCodecs yes --- 0 --- IOCEC --- --- 0 --- IODPAudioInterface --- --- 0 --- IODPController --- --- 0 --- IODPDevice --- --- 0 --- IODPDisplayInterface --- --- 0 --- IODPService --- --- 0 --- IOHDIXController yes --- 0 --- IOHIDEventService yes --- 0 --- IOHIDLib --- --- 0 --- IOHIDResourceDevice --- --- 0 --- IOMikeyBusBulkPipe --- --- 0 --- IOMikeyBusDevice --- --- 0 --- IOMikeyBusFunctionGroup --- --- 0 --- IOMobileFramebuffer yes yes 0 --- IONetworkStack yes --- 0 --- IONetwork --- --- 0 --- IOPKEAccelerator --- --- 0 --- IOPRNGAccelerator --- --- 0 --- IOReport --- --- 0 --- IOSHA1Accelerator --- --- 0 --- IOStreamAudio --- --- 0 --- IOStream --- --- 0 --- IOSurfaceRoot yes yes 0 --- IOUSBDeviceInterface yes --- 0 --- IOUserEthernetResource yes --- 0 --- KDIDiskImageNub --- --- 0 --- LwVM --- --- 0 --- ProvInfoIOKit yes --- 0 --- RTBuddyLoader --- --- 0 --- RTBuddy yes --- 0 --- RootDomain --- --- 0 --- com_apple_audio_IOBorealisOwl yes --- 0 --- com_apple_driver_FairPlayIOKit yes --- 0 --- com_apple_driver_KeyDeliveryIOKit yes --- 0 --- mDNSOffload --- --- 0 --- wlDNSOffload --- --- 0 ---\n\niPod5,1 on 9.3.2:\n\nService name Valid Spawn num str AGXShared --- --- 0 --- ASP --- --- 0 --- AppleARMIIC --- --- 0 --- AppleAVE --- --- 0 --- AppleAuthCP --- --- 0 --- AppleBCMWLAN --- --- 0 --- AppleBaseband --- --- 0 --- AppleBiometricServices --- --- 0 --- AppleCredentialManager yes --- 0 --- AppleD5500 --- --- 0 --- AppleEffaceableStorage yes --- 0 --- AppleEmbeddedPCIE --- --- 0 --- AppleH2CamIn --- --- 0 --- AppleH3CamIn --- --- 0 --- AppleH4CamIn yes --- 0 --- AppleH6CamIn --- --- 0 --- AppleHDQGasGaugeControl --- --- 0 --- AppleIPAppender --- --- 0 --- AppleJPEGDriver yes yes 6969696969696969 abc AppleKeyStore yes yes 6969696969696969 abc AppleMobileApNonce yes --- 0 --- AppleMobileFileIntegrity yes yes 6969696969696969 abc AppleMultitouchSPI yes --- 0 --- AppleNANDFTL yes --- 0 --- AppleNVMeSMART --- --- 0 --- AppleOscarCMA --- --- 0 --- AppleOscar --- --- 0 --- ApplePMGRTemp --- --- 0 --- AppleSEP --- --- 0 --- AppleSPUHIDDevice --- --- 0 --- AppleSPUHIDDriver --- --- 0 --- AppleSPUProfileDriver --- --- 0 --- AppleSPU --- --- 0 --- AppleSRSDriver --- --- 0 --- AppleSSE --- --- 0 --- AppleSmartIO --- --- 0 --- AppleStockholmControl --- --- 0 --- AppleT700XTempSensor --- --- 0 --- AppleTempSensor --- --- 0 --- AppleUSBHostDevice --- --- 0 --- AppleUSBHostInterface --- --- 0 --- AppleUSBHost --- --- 0 --- AppleVXD375 --- --- 0 --- AppleVXD390 yes --- 0 --- AppleVXD393 --- --- 0 --- AppleVXE380 --- --- 0 --- CCDataPipe yes --- 0 --- CCLogPipe yes --- 0 --- CCPipe yes --- 0 --- CoreCapture --- --- 0 --- EffacingMediaFilter --- --- 0 --- EncryptedMediaFilter --- --- 0 --- H3H264VideoEncoderDriver --- --- 0 --- IOAESAccelerator yes --- 0 --- IOAVAudioInterface --- --- 0 --- IOAVCECControlInterface --- --- 0 --- IOAVController yes --- 0 --- IOAVDevice --- --- 0 --- IOAVInterface --- --- 0 --- IOAVService --- --- 0 --- IOAVVideoInterface --- --- 0 --- IOAccelMemoryInfo --- --- 0 --- IOAccelRestart --- --- 0 --- IOAccelShared --- --- 0 --- IOAccessoryEAInterface --- --- 0 --- IOAccessoryIDBus --- --- 0 --- IOAccessoryManager yes --- 0 --- IOAccessoryPort yes --- 0 --- IOAudio2Device yes --- 0 --- IOAudio2Transformer yes --- 0 --- IOAudioCodecs yes --- 0 --- IOCEC --- --- 0 --- IODPAudioInterface --- --- 0 --- IODPController yes --- 0 --- IODPDevice --- --- 0 --- IODPDisplayInterface --- --- 0 --- IODPService --- --- 0 --- IOHDIXController yes --- 0 --- IOHIDEventService yes --- 0 --- IOHIDLib --- --- 0 --- IOHIDResourceDevice --- --- 0 --- IOMikeyBusBulkPipe --- --- 0 --- IOMikeyBusDevice --- --- 0 --- IOMikeyBusFunctionGroup --- --- 0 --- IOMobileFramebuffer yes yes 0 --- IONetworkStack yes --- 0 --- IONetwork --- --- 0 --- IOPKEAccelerator yes --- 0 --- IOPRNGAccelerator --- --- 0 --- IOReport --- --- 0 --- IOSHA1Accelerator --- --- 0 --- IOStreamAudio yes --- 0 --- IOStream --- --- 0 --- IOSurfaceRoot yes yes 0 --- IOUSBDeviceInterface yes --- 0 --- IOUserEthernetResource yes --- 0 --- KDIDiskImageNub --- --- 0 --- LwVM --- --- 0 --- ProvInfoIOKit yes --- 0 --- RTBuddyLoader --- --- 0 --- RTBuddy --- --- 0 --- RootDomain --- --- 0 --- com_apple_audio_IOBorealisOwl --- --- 0 --- com_apple_driver_FairPlayIOKit yes --- 0 --- com_apple_driver_KeyDeliveryIOKit yes --- 0 --- mDNSOffload --- --- 0 --- wlDNSOffload --- --- 0 ---\n\nAs one can see, there are only three services matching our requirements: AppleJPEGDriver, AppleKeyStore and - behold - AppleMobileFileIntegrity. You might get more with entitlements, but we don’t even need that (note: you also get a lot more outside the sandbox).\n\nYou can choose freely from these, but… one of them is just more fun to abuse than the others. :P\n\nThe implementation of this (just CLI, no GUI) can be found outside the main source, in cl0ver/scan/scan.c.\n\nUpdate 10. Jan 2017:\n\nThe original path to yield a UaF was to use an OSString as dictionary key, which would free it even before the next object is parsed. It turns out that this method doesn’t work on all iOS versions from 9.0 through 9.3.4.\n\nThe ability to use strings as keys (as opposed to symbols) was introduced somewhere between xnu-2782.40.9 and xnu-3248.20.55… so somewhere between between iOS 8.0 beta 2 and 9.2 beta 3. What I know for sure is that 9.2 and above are vulnerable, and 9.0.2 and below are not. Trying to use a string as key in those versions will make the call to io_service_open_extended fail with an “invalid argument” error.\n\nBut fear not! There are other paths yielding a UaF!\n\nOne of them is using the same key multiple times, which leads to the value previously assigned to that key getting freed. (This was disabled somewhere between xnu-3248.20.55 and xnu-3248.60.10 (after 9.2 beta 1), but has been enabled again in xnu-3789.1.32).\n\nBasically all you have to do is, for versions not vulnerable to this:\n\nkOSSerializeString, // string that'll get freed // ... kOSSerializeData, // data that replaces the string // ... kOSSerializeSymbol, // ... kOSSerializeObject | 1, // reference to overwritten string\n\nYou do this:\n\nkOSSerializeSymbol, // some name // ... kOSSerializeString, // string that'll get freed // ... kOSSerializeObject | 1, // same name as above kOSSerializeBoolean, // just any value kOSSerializeObject | 1, // same name again kOSSerializeData, // data that replaces the string // ... kOSSerializeSymbol, // ... kOSSerializeObject | 2, // reference to overwritten string\n\nSo, game on! :D\n\nPart One: Obtaining the OSString vtable address\n\nAll of OSData, OSString and OSSymbol contain both a buffer pointer and length field, which we could abuse together with IORegistryEntryGetProperty to retrieve arbitrary kernel memory. So in theory, we could overwrite our freed OSString to mimic any of these. However:\n\nThe 64-bit panic leak works by far best with the OSString class.\n\nAn OSString is the best fit for reallocation over another freed OSString, the other two are larger.\n\nOSString\n\nSo the OSString vtable it the one of choice. Now let’s look at how to get it.\n\nThe good: decrypted kernels\n\nIf keys are available, we can just grab the kernelcache from our IPSW, run it through xpwntool(-lite) and lzssdec, and we’ve got the raw kernel binary.\n\nSince decrypted kernels are symbolicated, we merely have to search its symbol table for __ZTV8OSString (symbols starting with __ZTV are vtables):\n\nAs one can see with a hex viewer (I’m using radare2 here), however (first column is offsets, rest is data):\n\nThere are two machine words before the actual vtable, so the real address we’re looking for is at offset 2 * sizeof(void*) from the __ZTV... address.\n\nThe bad: panic logs\n\nI stumbled across this method by accident while trying to play with OSStrings while they were freed (which won’t work due to heap poisoning).\n\nAnyway, here are a few raw facts:\n\nThe first machine word of a C++ object is (interpreted as) a pointer to its vtable.\n\nThe first machine word of a node in the freelist is a pointer to the next node in the freelist.\n\nPages (i.e. chunks of contiguous memory) are allocated as a whole into a kalloc zone.\n\nretain() is the 5th element in the vtable.\n\n(arm64) The 5th element in an array of pointers is at an offset of 32 bytes.\n\n(arm64) OSStrings are 32 bytes wide.\n\nSee what I’m getting at? :P\n\nHere’s a visualization:\n\nNow what happens when retain() is called on an OSString that was freed, but not yet reallocated?\n\nIn other words, what happens when we combine the above?\n\nSo what used to be our object’s vtable pointer is now a pointer to the next node in the freelist. And what is treated as a pointer to retain() is the value just out of bounds of that next node.\n\nNow, is there any way of predicting what value that area of memory is gonna hold?\n\nIf our (freed) object occupies the last 32 bytes on a memory page, the adjacent memory could hold anything or be unmapped. We have no way of telling, which makes this case pretty useless to us. But since, on arm64, memory pages are 16 kB, the chance of that happening in the kalloc.32 zone are 1 in 512. In the other 511 cases we’re still within the same memory page, which means still in kalloc.32-managed memory, so the adjacent memory can only be a 32-byte chunk that is either allocated or free.\n\nIf it is free, then it’s only gonna hold a pointer to the next node in the freelist and some 0xdeadbeef. Again useless to us.\n\nIf it is allocated, it could in theory hold anything… but if it’s another OSString for example, then a call to retain() on our original freed object is going to load the first 8 bytes of this object, which happen to be the address of the OSString vtable, and it will try to branch to that address. And since that address lies within a non-executable segment, this is gonna lead to a “Kernel instruction fetch abort” panic, creating a panic log with the OSString vtable address in pc. At last, something that sounds useful.\n\nNow that we know what could be there, how can we make that happen? How can we arrange for our freed OSString to lie next to another OSString?\n\nBy making lots of strategical allocations and deallocations (hooray for Heap Feng Shui). And we can do that by passing dictionary with kOSSerializeStrings to io_service_open_extended for allocation, and the returned client handle to IOServiceClose for deallocation. So:\n\nWhen our program starts, there could be any number of nodes from any memory page in the kalloc.32 freelist. But once all nodes in the freelist are used up and a new page is mapped, all nodes in the freelist will be from that page. So the first thing we do is allocate a lot of strings. (I used 255 strings here.)\n\nNext we’re gonna allocate some more strings, always alternating between a bunch (I chose 64) and only one in the dictionary. And we’re gonna do that a couple of times too (I did 16 each).\n\nThen we’re gonna release all clients with a single string in their dictionary, thus “poking holes” into the heap, in a way that each hole is pretty likely to be surrounded by OSString objects.\n\nVisualized again:\n\n(The dictionaries to achieve this are straightforward and make no use of any bugs so far.)\n\nNow we’re gonna parse a rather simple dictionary:\n\nkOSSerializeString will cause an OSString to get allocated, hopefully in one of those lonely holes we’ve punched into the heap, and when it is freed again shortly after, we’re left with objsArray[1] holding a pointer to that chunk of memory that is surrounded by allocated OSStrings.\n\nkOSSerializeObject will then attempt to call retain() on that chunk of freed memory, thus unfolding the process explained above, ultimately causing a kernel panic and logging the vtable address in the panic log:\n\n0xffffff801c2ef1f0 - 0x0000000017e00000 = 0xffffff80044ef1f0, there we go.\n\nThe full implementation of this can be found in the uaf_panic_leak_vtab function in uaf_panic.c.\n\nThe ugly: semi-blind guessing\n\nDisclaimer: I can’t promise that this will work for every device and OS version, but it did on my iPod.\n\nOur target is iPod5,1/9.3.2, so let’s first look at 9.3.2 for some other devices:\n\nAs we can see, __DATA.__const has different offsets, depending on the device, and so does the OSString vtable.\n\nHowever, if we subtract the former from the latter: 0x803ece8c - 0x803e7000 = 0x803f4e8c - 0x803ef000 = 0x5e8c. It turns out that the vtable’s offset from __DATA.__const is the same for both. Could it be the same for the iPod5,1 as well?\n\nFirst we need to learn the base address of __DATA.__const. That address is stored in the kernel’s mach header at offset 0x244. Since the data segment is non-executable, branching to that location will cause a panic.\n\nThus we use the UaF to construct an OSString whose vtable pointer points to 4 machine words before offset 0x244, i.e. kernel_base + kernel_slide + 0x224, so that a call to retain() will give us:\n\nSubtracting the kernel slide from the value in pc yields the unslid address of __DATA.__const: 0x803E7000.\n\nThat happens to be the same as for the iPhone4,1, so we assume our vtable address to be 0x803ece8c.\n\nWe can verify whether that is actually the case in the next step.\n\nIf it is, then we’re done here.\n\nIf it isn’t, I suggest going a few machine words up and down, looking at the panic logs to see what’s at that address instead, and trying to figure out where that is in the decrypted kernels, which should give you a rough idea on how far you need to go, and in which direction.\n\nThe full implementation of this can be found in the uaf_panic_leak_DATA_const_base and uaf_panic_read functions in uaf_panic.c.\n\nPart Two: Dumping the kernel\n\nWith the OSString vtable and the kernel slide both known, we can construct valid(-ish) strings that point to wherever we choose.\n\nLet’s see how we can use that to read a fixed amount of memory from an arbitrary address:\n\nWe start with an OSString:\n\nObviously it’s gonna need its vtable and the address we want to read from:\n\nI’ll get back to the length later, for now we’re just gonna use the maximum MIG message size, i.e. 4096 bytes:\n\nNow there’s two fields left: retainCount and flags.\n\nThe retain count we set to something unrealistically high, so that a call to release() is never actually going to free anything. We want this because our OSString is actually the buffer of an OSData, which will be managed and freed as such, and interfering with that would only cause chaos and destruction.\n\nAs for flags, there is exactly one recognised by OSString: kOSStringNoCopy, indicating the string doesn’t own its buffer and will not free or modify it.\n\nI’m not sure it even makes a difference in this case, but we might as well set it:\n\nNow we have to build a payload for OSUnserializeBinary. Conceptually, it should suffice to have a dictionary containing:\n\nA kOSSerializeString as key, which will get freed.\n\nA kOSSerializeData right after it, whose buffer will replace it.\n\nA name by which we’re later gonna retrieve bytes from our address.\n\nA kOSSerializeObject pointing to the overwritten string.\n\nIf you test this in practice, however, you’ll always get a panic. This is because during deallocation, when release() gets called on the last of the above, the OSData before it will have been deallocated already, along with its buffer, which causes the underlying memory to get poisoned, so that a call to release() will end up trying to branch to some 0xdeadbeef.\n\nWe can work around that, however, by adding another kOSSerializeObject to the end of the dict, referencing the OSData, causing it to be retained until after release() has been called on the reference to the overwritten string.\n\nImplementing all of the above, we get:\n\nWith that figured out, back to the length that we put aside earlier: MIG let’s us pass at most 4096 bytes in or out of the kernel at once, so in order to dump arbitrary amounts of memory, we need to invoke the UaF in a loop (I don’t think this needs more explaining, it’s just math).\n\nI’ve implemented the concept up until here in the uaf_get_bytes and uaf_read_naive functions in uaf_read.c. They’re not used anymore, but I left them in for demo purposes.\n\nNow, with the above it is already possible do dump the kernel… provided you wait a sufficient amount of time between invocations. If you don’t, you’re likely to see your device panic. That is because ultimately, the UaF is a race condition.\n\nWhen our OSString is freed, it gets added to the top of its zone’s freelist, and we count on it being there when our OSData’s buffer is allocated. If that is not the case, then the subsequent call to retain() will almost certainly cause a panic.\n\nNow, I went through OSUnserializeBinary multiple times and I’m pretty confident that it doesn’t do any allocations or deallocations between our two key events… so from the perspective of a single thread, our assumption should hold. But in the multithreaded environment that is XNU, we’re very far from that.\n\nThere are a couple of things that can happen, for a couple of different reasons, and with a couple of different consequences:\n\nThe freed OSString is at the top of the freelist\n\nThis is what we want. It doesn’t matter whether the freelist remained untouched or not, so long as the top node is still our OSString.\n\nWinning this race once is no big deal in practice, but in order to dump the entire kernel without panicking, you have to win it thousands of times, without losing even once! I have found the race to be so easily winnable that even with these odds, I got my kernel dump with just four tries.\n\nThat’s nowhere near reliable though, so let’s see what we can do to improve stability.\n\nElements were added to the freelist\n\nAnother chunk of memory is sitting at the top of the freelist now, so when our OSData’s buffer gets allocated, our OSString stays freed and poisoned, causing a panic when retain() is called on it. This will manifest itself as some 0xdeadbeef showing up in the panic log.\n\nIn practice, I have found this to be by far the most likely outcome when spamming the kernel with this technique. However, stability increased by orders of magnitude when I waited for 1ms between invocations. I have heard claims that some IOKit memory cleanup is done asynchonously, which would be consistent with my findings, however I’ve been unable to find any hard evidence of this (does anyone have more info on this?).\n\nOf course this slows down dumping considerably, and I’ve explored two ideas to counteract this:\n\nMultiple dictionaries per client: Completely broke stability. Still not sure why exactly, but I never got past five invocations this way.\n\nSpawning multiple clients and releasing them together: This worked for me, as long as I didn’t go beyond 10 clients. It wasn’t as much as I had hoped for, but hey, I’ll take a speed improvement of 10x.\n\nAt this point I still hit a panic every now and then on some 0xdeadbeef, so the OSString was still prone to sinking down in the freelist.\n\nBut you can actually do something to reduce the likelihood of that causing a panic: Have multiple OSDatas with the same content!\n\nIf you’ve got just one OSData, then the freed OSString must be at the very top of the freelist. If you’ve got, say, three of them, then being anywhere among the top three nodes in the freelist will cause our OSString to get overwritten. And since this is a race that is easily winnable already, very few additional OSDatas should suffice. In practice, a total of three proved enough to never panic on any 0xdeadbeef again.\n\nWhen implementing this, one must take care though to not introduce anything else that gets allocated on the same kalloc zone as OSStrings. For example, when adding two OSDatas as values, both of which have an OSSymbol as key, that will cause no problems on 64-bit as OSString and OSSymbol go to different kalloc zones there, but on 32-bit they share the same zone. This could lead to an OSSymbol key getting allocated over the string, which would cause no panic, but yield an unwanted result. It’s pretty simple to avoid these problems altogether though, by simply putting them before the OSString in the dict, and referencing them with kOSSerializeObject.\n\nElements were removed from the freelist\n\nOur OSString has been reallocated and is gone. I haven’t figured out anything that could be done about this.\n\nFreeing additional strings as a “freelist buffer” won’t work, since that way, the time our referenced OSString spends at the top of the freelist (and is thus “vulnerable to allocation”) is actually increased.\n\nTrying to free and overwrite multiple strings (with a “one of them has to get overwritten” mindset) won’t work either, since we don’t need one string to be valid, but all of them, since just one invalid reference will trigger a panic.\n\nOddly enough I never ran into this case when running from the command line, but regularly when running from an app within the sandbox (always on a NULL pointer interpreted as vtable, and almost always either on the first try, or not at all). Feel free to hit me up if you know more about this.\n\nWith all of the above I managed to make dumping reasonably stable (never got a panic from the command line anymore, got about 20% panic from sandbox) and take less than a minute. At that point I gave up on trying to improve it further and instead added functionality to cache the required information (see offsets.c), so that once the kernel had been dumped, it would never have to be done again on that device.\n\nFeel free to fiddle around with it though, and hopefully create a pull request if you manage to make it faster or more reliable. :)\n\nWith arbitrary read now more or less stable, dumping the kernel is trivial. But for the sake of completeness:\n\nRead the Mach-O header from the kernel text base\n\nFigure out the file size and allocate a sufficiently large buffer\n\nIterate over all segments and dump them one by one\n\nRemove the symbol table from the header because it’s not mapped to memory\n\nWrite buffer to file\n\nThe full implementation of this can be found in the uaf_read and uaf_dump_kernel functions in uaf_read.c.\n\nPart Three: ROP\n\nNote: I haven’t done any of the following on 32-bit yet, and I’m not sure whether I will. For now this is 64-bit only.\n\nPivoting and restoring the stack\n\nIf you’ve read jndok’s writeup or have played with the Pegasus vulnerabilities yourself, then you know that our UaF gives us exactly one ROP gadget worth of execution. So we need to find a stack pivot.\n\nBut before we can go off and search for one, we first need to determine what requirements we have for it:\n\nIn order for things to go smooth, we need to be able to restore the stack frame at the end of our ROP chain. For that we need to save the stack pointer somehow. In normal program flow, the stack pointer is usually passed from sp to x29 when entering a function, and from x29 to RAM on any subsequent function call within that function, and exactly that path back again when returning from functions. Ideally we’d just move sp or x29 to another register or save it to a known address, but it turns out that such instructions tend to be either exceedingly rare, very far away from branches or returns, or both (so they don’t make usable ROP gadgets).\n\nOn top of all that, we also need for our gadget to load x29 and x30 from a controllable location, so that we actually get stack control. For that we need to find not only a gadget, but also a register that holds either a controllable, or otherwise useful value.\n\nA good point to start is to examine which registers hold which values. By examining the disassembly of OSUnserializeXML (and possible looking at panic logs), I made out the following:\n\nx0 and x28 hold a pointer to the current object, i.e. what is called o in OSUnserializeBinary.\n\nx8 is the address we just jumped to, i.e. the pointer to retain() in our fake vtable.\n\nx9 holds the type of the parsed object, in our case 0xc000000 for kOSSerializeObject.\n\nx21 = bufferPos\n\nx22 = bufferSize\n\nx27 = objsArray\n\nLet’s first sort out those we surely cannot use as a stack pivot loading address:\n\nx8 controllable, but must point to the stack pivoting gadget itself for our exploit to work, so it’s not suitable as a loading address.\n\nx21 and x22 can never be bigger than 0x1000, due to the maximum MIG message size. Pages are 0x4000 bytes on ARM, and, unlike on OS X, you cannot map at NULL at all on iOS (unmapping __PAGEZERO fails, and binaries missing it will be slaughtered on sight by the kernel). These values are therefore too small to hold valid memory addresses.\n\nx27 holds a pointer to an array of pointers to allocated objects. Loading such an address into x30 would cause a panic, so that’s not suitable as well.\n\nx0 or x28 would be perfect, as they point to a memory area whose contents are entirely controllable. However, I was unable to find a gadget that loads from x0 or x28.\n\nI had my fair share of trouble finding a usable stack pivot. I looked at some docs discussing stack pivots on x86 and 32-bit ARM, and I have to say it looks to me like on those architectures it’s a lot easier than on arm64!\n\nThe only thing that I found at all mentioning stack pivots on arm64 was @qwertyoruiopz, saying it’s amazingly easy to find them. Luca, should you happen to read this, care to elaborate? :)\n\nNow, I did eventually find a usable gadget:\n\nThe way we use this gadget is as follows:\n\nWe put our fake stack at the “address” x9 points to, 0xc000000. Yes, that would normally be within __PAGEZERO, but even though we cannot remove that mapping, we can still shrink it! To do so, we simply pass -Wl,-pagezero_size,0x4000 to our compiler (and preferably also -Wl,-image_base,0x100000000, to move the remaining segments back to their usual address), and we can happily map at 0xc000000!\n\nvm_address_t addr = kOSSerializeObject; vm_allocate(mach_task_self(), &addr, 0x4000, 0);\n\nNote: If we couldn’t shrink __PAGEZERO, we’d simply move to a 32-bit binary where it’s only 0x4000 bytes by default.\n\nAlso note that on the iPhone 7 with SMAP, we couldn’t just load from userland addresses in kernel mode, so we’d have to find some place in the kernel to put our data, of which we know the address (with arbitrary read we could simply search for it though). But for now this is iOS 9, so we’re most definitely not on an iPhone 7.\n\nWe put the address of that gadget not only into our fake vtable, but also on the top of our stack, as the first return address. This does not cause an infinite loop, since x9 is increased by 0x10 every time the gadget is run.\n\nWe repeat the gadget until sp point to the location in RAM where x29 of the previous stack frame is stored. This works because sp is never overwritten with an arbitrary value, but simply moved.\n\nAt that point we jump to a gadget that loads a value from the stack and stores it in any register that is convenient. And then we finally have both the address of the original stack frame, as well as a fake stack from which we’re running now. Of course, since the loaded value is x29 and not sp, we need to subtract the stack size of the calling function from it, which in the case of is_io_service_open_extended is 0x120, but that’s a trivial task now. It’s also a good idea to store that value to RAM somewhere, so that our ROP chain doesn’t corrupt it by accident.\n\nAfter saving a pointer to the last stack frame and pivoting the stack, we run whatever ROP we actually wanted to run in the first place. Let’s put that aside for a moment though, I’ll get to it in a bit.\n\nAt the end of our ROP chain we need to make use of that stack pointer we saved earlier, and (preferably) return to somewhere within OSUnserializeXML.\n\nThe easiest way to restore the saved stack frame, is quite simple: when we save it to RAM at the beginning of our chain, we don’t just write it anywhere, but to a location further down on our stack, more precisely the location where x29 will be loaded from when we load our return address into x30. That requires knowledge of the exact length of our ROP chain and some precise counting, but it’s easily doable.\n\nPaired with that we’re gonna need an address to return to, for simplicity most likely one within OSUnserializeXML. I chose 0xffffff80043f08c4 for now, which is at the end of OSUnserializeXML:\n\nThis basically means return 0;.\n\nThat is actually quite bad though, because it means that all memory allocated by the function will be leaked (i.e. all objects created while parsing, plus objsArray and stackArray), and because it will ultimately cause the call to return failure. If my tool was ever to go into production, that should definitely be fixed, but since it’s technically working, it was good enough for my demo.\n\nThe core of our chain\n\nThe goal of our ROP chain is simple: get the kernel task port!\n\nWe can make a plan of how to do that by walking through the code of task_for_pid (vm_unix.c, l. 632) and just pretend we were already past the pid == 0 check, and that p->task = kernel_task. Skipping all checks, it basically comes down to:\n\nLet’s simplify that.\n\nextmod_statistics_incr_task_for_pid can be dropped entirely, because it’s just statistics.\n\nipc_port_copyout_send is basically just ipc_port_make_send(task->itk_self) with checks, locks, and the consuming of a reference. If we replace it with that, we can also drop task_reference(p->task); entirely. This is a pretty unsafe thing to do, but at what point is kernel_task->itk_self really gonna be NULL, or change in a way significant to ipc_port_make_send?\n\nget_task_ipcspace is literally just:\n\nipc_space_t get_task_ipcspace(task_t t) { return(t->itk_space); }\n\nSo we can substitute get_task_ipcspace(current_task()) for current_task()->itk_space.\n\nAnd we can also replace that copyout with just an assignment: *task_addr = tret.\n\nAgain, on a device with SMAP (iPhone 7) we couldn’t do that, but for now… we can. :P\n\nSo given a userland address task_addr, this is what we want to run in kernel mode:\n\nNow, I’m not dumping the ROP chain generation code into this writeup. If you wanna have a look at it, you’re gonna need to see all of it, so go have a look at rop.c. It’s not pretty, but I’ve thoroughly annotated it, so hopefully you’ll be able to understand it.\n\nThe general concept of this “inner” ROP chain is:\n\nCall current_task().\n\nLoad [x0, 0x2a0] to x0 (->itk_space has an offset of 0x2a0).\n\nStore x0 somewhere, for later use.\n\nLoad kernel_task to x0 (kernel_task is at a fixed address, see nm kernel | grep kernel_task).\n\nLoad [x0, 0xe8] to x0 (->itk_self has an offset of 0xe8).\n\nCall ipc_port_make_send().\n\nRestore the x0 we saved before to x1, without corrupting x0.\n\nCall ipc_port_copyout_send().\n\nStore x0 at task_addr.\n\nIn practice it’s a bit more complicated than that. For example, calling a function is straightforward in a normal program, but in ROP that actually requires you to first run a gadget that loads values into some registers (commonly x19 and upwards), and then a gadget that does a blr to such a register.\n\nBut the above is sort of a high-level view. If you want details, go look at the source. It’s quite understandable, I promise! :P\n\nThe full implementation of this can be found in rop.c (building the chain) and uaf_rop.c (executing the chain).\n\nFinding offsets/addresses\n\nWhether we’re manually looking for addresses or want to write code that does it for us (after all, hardcoding is ugly), we need a plan on how to identify them.\n\n~Note: I planned for an offset finder to be implemented in find.c, but I haven’t gotten round to it. I’m just lining out how the addresses could be found.~\n\nUpdate 10. Jan 2017:\n\nFor arm64, this has been fully implemented in find.c now.\n\nNow, there’s two categories:\n\nROP gadgets\n\nThose are really straightforward: You have a fixed sequence of opcodes you need, so all you have to do is walk through __TEXT and __PRELINK_TEXT until you find a 1:1 match (on a 4-byte boundary, that is).\n\nThe rest\n\nData addresses, data structure offsets and most functions are more complicated; we need something that uniquely identifies them.\n\nThe usual approach to this is to start at the address of something that is uniquely identifiable (such as a string or a very rare sequence of opcodes) and then find reference to or from that address or adjacent locations. I’ll briefly discuss everything that is not a ROP gadget (in my code, everything that doesn’t have registers in its name):\n\ncurrent_task()\n\nThis is the entire function:\n\n0xffffff8004052e0c 88d038d5 mrs x8, tpidr_el1 0xffffff8004052e10 008941f9 ldr x0, [x8, 0x310] 0xffffff8004052e14 c0035fd6 ret\n\nSo even though it isn’t a ROP gadget, we can look for it as if it was.\n\n(The reason for this is that arm64 has a special system register, tpidr_el1, where XNU stores a pointer to the current mach thread struct, which has a pointer to the task it belongs to.)\n\nipc_port_copyout_send() and task_t->itk_space\n\nCalled from task_for_pid(), whose address is in the mach_trap_table, which is a unique data structure.\n\nLooking at syscall_sw.c, we can see that the mach_trap_table starts as follows:\n\n/* 0 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 1 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 2 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 3 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 4 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 5 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 6 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 7 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 8 */ MACH_TRAP(kern_invalid, 0, 0, NULL), /* 9 */ MACH_TRAP(kern_invalid, 0, 0, NULL),\n\nIn hex, that’s gonna look like this:\n\n0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000 0x0000000000000000 0xffffff801ec4cef8 0x0000000000000000 0x0000000000000000\n\nWhere 0xffffff801ec4cef8 will point to a function that simply returns KERN_INVALID_ARGUMENT (= 4):\n\n0xffffff801ec4cef8 e0031e32 orr w0, wzr, 4 0xffffff801ec4cefc c0035fd6 ret\n\nWith that we can find the mach_trap_table. Now task_for_pid() is mach trap 45, mach_trap_t is 4 pointers wide and mach_trap_t->mach_trap_function is the second pointer (index 1). That places a pointer to task_for_pid() at an offset of 181 * sizeof(void*) from the start of the table.\n\nAnd then, the task_for_pid() function itself contains a passage that, in symbolicated terms, reads:\n\n0xffffff80043c31ac d6bcf197 bl sym._convert_task_to_port 0xffffff80043c31b0 88d038d5 mrs x8, tpidr_el1 0xffffff80043c31b4 088941f9 ldr x8, [x8, 0x310] ; [0x310:4]=0x530018 0xffffff80043c31b8 015141f9 ldr x1, [x8, 0x2a0] ; [0x2a0:4]=0x41445f5f ; 0xffffff80043c31bc a372f197 bl sym._ipc_port_copyout_send\n\nIt is characterized by an access to tpidr_el1 and a subsequent load to x1 (from inlined calls to current_task() and get_task_ipcspace()).\n\nRight after that is a call to ipc_port_copyout_send(), which lets you calculate its address.\n\nThe load to x1 also tells you the offset of ->itk_space from the base of task_t.\n\nipc_port_make_send() and task_t->itk_self\n\nBoth called/referenced from convert_task_to_port(), which is called from task_for_pid() (see above). This is convert_task_to_port() in its entirety:\n\n0xffffff8004032504 f657bda9 stp x22, x21, [sp, -0x30]! ; '0' 0xffffff8004032508 f44f01a9 stp x20, x19, [sp, 0x10] 0xffffff800403250c fd7b02a9 stp x29, x30, [sp, 0x20] 0xffffff8004032510 fd830091 add x29, sp, 0x20 0xffffff8004032514 f30300aa mov x19, x0 0xffffff8004032518 74420391 add x20, x19, 0xd0 0xffffff800403251c e00314aa mov x0, x20 0xffffff8004032520 3a190394 bl sym._lck_mtx_lock 0xffffff8004032524 607640f9 ldr x0, [x19, 0xe8] ; [0xe8:4]=0x486980 0xffffff8004032528 800000b4 cbz x0, 0xffffff8004032538 0xffffff800403252c 9cb5ff97 bl sym._ipc_port_make_send 0xffffff8004032530 f50300aa mov x21, x0 0xffffff8004032534 02000014 b 0xffffff800403253c 0xffffff8004032538 150080d2 movz x21, 0 0xffffff800403253c e00314aa mov x0, x20 0xffffff8004032540 5d190394 bl sym._lck_mtx_unlock 0xffffff8004032544 e00313aa mov x0, x19 0xffffff8004032548 16730094 bl sym._task_deallocate 0xffffff800403254c e00315aa mov x0, x21 0xffffff8004032550 fd7b42a9 ldp x29, x30, [sp, 0x20] ; [0x20:4]=25 0xffffff8004032554 f44f41a9 ldp x20, x19, [sp, 0x10] ; [0x10:4]=13 0xffffff8004032558 f657c3a8 ldp x22, x21, [sp], 0x30 0xffffff800403255c c0035fd6 ret\n\nThe second bl in that function is a call to ipc_port_make_send().\n\nThe offset in the ldr before that is the offset of ->itk_self from task_t.\n\nkernel_task\n\nReferenced from multiple locations with the following characteristics, in that order:\n\nA reference to the string \"root\"\n\nAn access to tpidr_el1\n\nA reference to the string \"aapl,panic-info\"\n\nFor example:\n\n0xffffff800445139c 216a3110 adr x1, str.root 0xffffff80044513a0 1f2003d5 nop 0xffffff80044513a4 c11b0094 bl sym.IOUserClient::clientHasPrivilege 0xffffff80044513a8 df0a0071 cmp w22, 2 0xffffff80044513ac 0418407a ccmp w0, 0, 4, ne 0xffffff80044513b0 00010054 b.eq 0xffffff80044513d0 0xffffff80044513b4 00008052 movz w0, 0 0xffffff80044513b8 02000014 b 0xffffff80044513c0 0xffffff80044513bc 00008052 movz w0, 0 0xffffff80044513c0 fd7b42a9 ldp x29, x30, [sp, 0x20] ; [0x20:4]=25 0xffffff80044513c4 f44f41a9 ldp x20, x19, [sp, 0x10] ; [0x10:4]=13 0xffffff80044513c8 f657c3a8 ldp x22, x21, [sp], 0x30 0xffffff80044513cc c0035fd6 ret 0xffffff80044513d0 df0e0071 cmp w22, 3 0xffffff80044513d4 21010054 b.ne 0xffffff80044513f8 0xffffff80044513d8 88d038d5 mrs x8, tpidr_el1 0xffffff80044513dc 088941f9 ldr x8, [x8, 0x310] ; [0x310:4]=0x530018 0xffffff80044513e0 1f2003d5 nop 0xffffff80044513e4 69617258 ldr x9, sym._kernel_task 0xffffff80044513e8 1f0109eb cmp x8, x9 0xffffff80044513ec 60000054 b.eq 0xffffff80044513f8 0xffffff80044513f0 00008052 movz w0, 0 0xffffff80044513f4 f3ffff17 b 0xffffff80044513c0 0xffffff80044513f8 880240f9 ldr x8, [x20] 0xffffff80044513fc 085940f9 ldr x8, [x8, 0xb0] ; [0xb0:4]=0 0xffffff8004451400 21b53050 adr x1, str.aapl_panic_info\n\nAnd between the access to tpidr_el1 and the reference to \"aapl,panic-info\", there is one PC-relative reference, which is our precious kernel_task.\n\nrealhost.special\n\nReferenced from host_get_special_port(), which is referenced from _Xhost_get_special_port(), whose address is in the host_priv subsystem.\n\nLooking at the struct host_priv_subsystem in host_privServer.c (mig xnu/osfmk/mach/host_priv.defs), we can see start and end being 400 and 426. The resulting byte sequence, 90 01 00 00 AA 01 00 00, is already unique within the kernel.\n\nFrom there we use the pointer in routine[12] to get to _Xhost_get_special_port(), which calls host_get_special_port() in the last bl before the (first) ret:\n\n0xffffff8004069f3c 6c17ff97 bl sym._host_get_special_port 0xffffff8004069f40 60010034 cbz w0, 0xffffff8004069f6c 0xffffff8004069f44 602a00b9 str w0, [x19, 0x28] 0xffffff8004069f48 c82400f0 adrp x8, 0xffffff8004504000 0xffffff8004069f4c 082540f9 ldr x8, [x8, 0x48] ; [0x48:4]=0 ; 'H' 0xffffff8004069f50 681200f9 str x8, [x19, 0x20] 0xffffff8004069f54 fd7b44a9 ldp x29, x30, [sp, 0x40] ; [0x40:4]=0x4dc000 ; '@' 0xffffff8004069f58 f44f43a9 ldp x20, x19, [sp, 0x30] ; [0x30:4]=0 ; '0' 0xffffff8004069f5c f65742a9 ldp x22, x21, [sp, 0x20] ; [0x20:4]=25 0xffffff8004069f60 f85f41a9 ldp x24, x23, [sp, 0x10] ; [0x10:4]=13 0xffffff8004069f64 fa67c5a8 ldp x26, x25, [sp], 0x50 0xffffff8004069f68 c0035fd6 ret\n\nAnd host_get_special_port() loads from realhost.special right after the first bl:\n\n0xffffff800402fd20 3a230394 bl sym._lck_mtx_lock 0xffffff800402fd24 282b0090 adrp x8, 0xffffff8004593000 0xffffff800402fd28 08813a91 add x8, x8, 0xea0 0xffffff800402fd2c 08cd358b add x8, x8, w21, sxtw 3 0xffffff800402fd30 151144f9 ldr x21, [x8, 0x820] ; [0x820:4]=0\n\nWhere 0xffffff8004593ea0 is realhost, and 0xffffff8004593ea0 + 0x820 = 0xffffff80045946c0 subsequently realhost.special.\n\nis_io_service_open_extended stack size\n\nThe function contains the only reference within the kernel to the string \"IOUserClientCrossEndian\". Once we find the reference, we find the function and can derive the stack size from the code.\n\nOSUnserializeXML stack size and return address\n\nThe function contains the only reference within the kernel to \"/Library/Caches/com.apple.xbs/Sources/xnu/xnu-3248.60.9/libkern/c++/OSSerializeBinary.cpp\".\n\nStack size is trivial, the return address is from the ret instruction backwards until 0 is moved into the register that is subsequently moved to x0.\n\nPart Four: Patching the kernel\n\nThe patch we’re gonna apply is as follows:\n\nWith access to the kernel task port, applying that patch is a simple matter of using vm_read and vm_write (omitted error handling):\n\nThis isn’t technically true to the name “tfp0”, but it allows any binary running as root to retrieve the kernel task port via\n\nThe full implementation of this can be found in the patch_host_special_port_4 function in exploit.c\n\nConclusion\n\nHoly. Shit.\n\nThat was awesome!\n\nIt was also a whole lot of work, and this writeup is by far the longest thing I’ve ever written.\n\nGlad you stayed with me ‘till the end! :D\n\nAnd phew, I’ve learned an insane amount of things while doing this. I had doubts whether I was even gonna make it to the end, but it turns out I did, and I’m glad about that.\n\nIf you’re trying to get into exploitation like me, I can only recommend doing a project like this. Grab some publicly disclosed vulnerabilities that have been fixed in the latest iOS but to which your device is still vulnerable, start playing around with them, and see what you can get out of it. No amount of reading could replace such an experience. :)\n\nNow, I will definitely continue to poke around in iOS, and if you’re interested in reading about it, you can follow me on Twitter Mastodon.\n\nAnd as stated at the beginning, please feel free to reach out to me if you have any kind of comments or questions. :)\n\nAnything left to say?\n\nCode\n\nThe code I wrote for this project is open source and available on GitHub, licensed under MIT.\n\n(I simply named it after the leaf on my avatar, clover.)\n\nCredits & thanks\n\nFirst and foremost I would like to thank @jndok (as well as all the people he credits and thanks) for his amazing writeup and the accompanying PoC. My work here is entirely based on yours.\n\nAlso thanks to:"
    }
}