{
    "id": "dbpedia_465_0",
    "rank": 7,
    "data": {
        "url": "https://opensource.apple.com/source/xnu/xnu-3789.21.4/bsd/kern/kern_exec.c.auto.html",
        "read_more_link": "",
        "language": "en",
        "title": "exec.c",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "kern_exec.c [plain text]\n\n#include <machine/reg.h> #include <machine/cpu_capabilities.h> #include <sys/param.h> #include <sys/systm.h> #include <sys/filedesc.h> #include <sys/kernel.h> #include <sys/proc_internal.h> #include <sys/kauth.h> #include <sys/user.h> #include <sys/socketvar.h> #include <sys/malloc.h> #include <sys/namei.h> #include <sys/mount_internal.h> #include <sys/vnode_internal.h> #include <sys/file_internal.h> #include <sys/stat.h> #include <sys/uio_internal.h> #include <sys/acct.h> #include <sys/exec.h> #include <sys/kdebug.h> #include <sys/signal.h> #include <sys/aio_kern.h> #include <sys/sysproto.h> #include <sys/persona.h> #include <sys/reason.h> #if SYSV_SHM #include <sys/shm_internal.h> #endif #include <sys/ubc_internal.h> #include <sys/spawn.h> #include <sys/spawn_internal.h> #include <sys/process_policy.h> #include <sys/codesign.h> #include <sys/random.h> #include <crypto/sha1.h> #include <libkern/libkern.h> #include <security/audit/audit.h> #include <ipc/ipc_types.h> #include <mach/mach_types.h> #include <mach/port.h> #include <mach/task.h> #include <mach/task_access.h> #include <mach/thread_act.h> #include <mach/vm_map.h> #include <mach/mach_vm.h> #include <mach/vm_param.h> #include <kern/sched_prim.h> #include <kern/affinity.h> #include <kern/assert.h> #include <kern/task.h> #include <kern/coalition.h> #include <kern/policy_internal.h> #include <kern/kalloc.h> #if CONFIG_MACF #include <security/mac.h> #include <security/mac_mach_internal.h> #endif #include <vm/vm_map.h> #include <vm/vm_kern.h> #include <vm/vm_protos.h> #include <vm/vm_kern.h> #include <vm/vm_fault.h> #include <vm/vm_pageout.h> #include <kdp/kdp_dyld.h> #include <machine/pal_routines.h> #include <pexpert/pexpert.h> #if CONFIG_MEMORYSTATUS #include <sys/kern_memorystatus.h> #endif #if CONFIG_DTRACE extern void dtrace_proc_exec(proc_t); extern void (*dtrace_proc_waitfor_exec_ptr)(proc_t); static void (*dtrace_proc_waitfor_hook)(proc_t) = NULL; #include <sys/dtrace_ptss.h> #endif thread_t fork_create_child(task_t parent_task, coalition_t *parent_coalition, proc_t child_proc, int inherit_memory, int is64bit, int in_exec); void vfork_exit(proc_t p, int rv); extern void proc_apply_task_networkbg_internal(proc_t, thread_t); extern void task_set_did_exec_flag(task_t task); extern void task_clear_exec_copy_flag(task_t task); proc_t proc_exec_switch_task(proc_t p, task_t old_task, task_t new_task, thread_t new_thread); boolean_t task_is_active(task_t); boolean_t thread_is_active(thread_t thread); void thread_copy_resource_info(thread_t dst_thread, thread_t src_thread); void *ipc_importance_exec_switch_task(task_t old_task, task_t new_task); extern void ipc_importance_release(void *elem); void ipc_task_reset( task_t task); void ipc_thread_reset( thread_t thread); kern_return_t ipc_object_copyin( ipc_space_t space, mach_port_name_t name, mach_msg_type_name_t msgt_name, ipc_object_t *objectp); void ipc_port_release_send(ipc_port_t); #if DEVELOPMENT || DEBUG void task_importance_update_owner_info(task_t); #endif extern struct savearea *get_user_regs(thread_t); __attribute__((noinline)) int __EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__(mach_port_t task_access_port, int32_t new_pid); #include <kern/thread.h> #include <kern/task.h> #include <kern/ast.h> #include <kern/mach_loader.h> #include <kern/mach_fat.h> #include <mach-o/fat.h> #include <mach-o/loader.h> #include <machine/vmparam.h> #include <sys/imgact.h> #include <sys/sdt.h> #define EAI_ITERLIMIT 3 #define IS_WHITESPACE(ch) ((ch == ' ') || (ch == '\\t')) #define IS_EOL(ch) ((ch == '#') || (ch == '\\n')) extern vm_map_t bsd_pageable_map; extern const struct fileops vnops; #define USER_ADDR_ALIGN(addr, val) \\ ( ( (user_addr_t)(addr) + (val) - 1) \\ & ~((val) - 1) ) struct image_params; static int exec_activate_image(struct image_params *imgp); static int exec_copyout_strings(struct image_params *imgp, user_addr_t *stackp); static int load_return_to_errno(load_return_t lrtn); static int execargs_alloc(struct image_params *imgp); static int execargs_free(struct image_params *imgp); static int exec_check_permissions(struct image_params *imgp); static int exec_extract_strings(struct image_params *imgp); static int exec_add_apple_strings(struct image_params *imgp, const load_result_t *load_result); static int exec_handle_sugid(struct image_params *imgp); static int sugid_scripts = 0; SYSCTL_INT (_kern, OID_AUTO, sugid_scripts, CTLFLAG_RW | CTLFLAG_LOCKED, &sugid_scripts, 0, \"\"); static kern_return_t create_unix_stack(vm_map_t map, load_result_t* load_result, proc_t p); static int copyoutptr(user_addr_t ua, user_addr_t ptr, int ptr_size); static void exec_resettextvp(proc_t, struct image_params *); static int check_for_signature(proc_t, struct image_params *); static void exec_prefault_data(proc_t, struct image_params *, load_result_t *); static errno_t exec_handle_port_actions(struct image_params *imgp, boolean_t * portwatch_present, ipc_port_t * portwatch_ports); static errno_t exec_handle_spawnattr_policy(proc_t p, int psa_apptype, uint64_t psa_qos_clamp, uint64_t psa_darwin_role, ipc_port_t * portwatch_ports, int portwatch_count); static int exec_add_user_string(struct image_params *imgp, user_addr_t str, int seg, boolean_t is_ncargs) { int error = 0; do { size_t len = 0; int space; if (is_ncargs) space = imgp->ip_argspace; else space = imgp->ip_strspace; if (space <= 0) { error = E2BIG; break; } if (!UIO_SEG_IS_USER_SPACE(seg)) { char *kstr = CAST_DOWN(char *,str); error = copystr(kstr, imgp->ip_strendp, space, &len); } else { error = copyinstr(str, imgp->ip_strendp, space, &len); } imgp->ip_strendp += len; imgp->ip_strspace -= len; if (is_ncargs) imgp->ip_argspace -= len; } while (error == ENAMETOOLONG); return error; } #define EXECUTABLE_KEY \"executable_path=\" static int exec_save_path(struct image_params *imgp, user_addr_t path, int seg, const char **excpath) { int error; size_t len; char *kpath; memset(imgp->ip_strings, '\\0', strlen(EXECUTABLE_KEY) + MAXPATHLEN); len = MIN(MAXPATHLEN, imgp->ip_strspace); switch(seg) { case UIO_USERSPACE32: case UIO_USERSPACE64: error = copyinstr(path, imgp->ip_strings + strlen(EXECUTABLE_KEY), len, &len); break; case UIO_SYSSPACE: kpath = CAST_DOWN(char *,path); error = copystr(kpath, imgp->ip_strings + strlen(EXECUTABLE_KEY), len, &len); break; default: error = EFAULT; break; } if (!error) { bcopy(EXECUTABLE_KEY, imgp->ip_strings, strlen(EXECUTABLE_KEY)); len += strlen(EXECUTABLE_KEY); imgp->ip_strendp += len; imgp->ip_strspace -= len; if (excpath) { *excpath = imgp->ip_strings + strlen(EXECUTABLE_KEY); } } return(error); } static int exec_reset_save_path(struct image_params *imgp) { imgp->ip_strendp = imgp->ip_strings; imgp->ip_argspace = NCARGS; imgp->ip_strspace = ( NCARGS + PAGE_SIZE ); return (0); } static int exec_shell_imgact(struct image_params *imgp) { char *vdata = imgp->ip_vdata; char *ihp; char *line_startp, *line_endp; char *interp; proc_t p; struct fileproc *fp; int fd; int error; if (vdata[0] != '#' || vdata[1] != '!' || (imgp->ip_flags & IMGPF_INTERPRET) != 0) { return (-1); } if (imgp->ip_origcputype != 0) { return (-1); } imgp->ip_flags |= IMGPF_INTERPRET; imgp->ip_interp_sugid_fd = -1; imgp->ip_interp_buffer[0] = '\\0'; if (sugid_scripts == 0) { imgp->ip_origvattr->va_mode &= ~(VSUID | VSGID); } for( ihp = &vdata[2]; ihp < &vdata[IMG_SHSIZE]; ihp++ ) { if (IS_EOL(*ihp)) { return (ENOEXEC); } else if (IS_WHITESPACE(*ihp)) { } else { break; } } if (ihp == &vdata[IMG_SHSIZE]) { return (ENOEXEC); } line_startp = ihp; for ( ; ihp < &vdata[IMG_SHSIZE]; ihp++ ) { if (IS_EOL(*ihp)) { break; } else { } } if (ihp == &vdata[IMG_SHSIZE]) { return (ENOEXEC); } while (IS_EOL(*ihp) || IS_WHITESPACE(*ihp)) { ihp--; } line_endp = ihp + 1; interp = imgp->ip_interp_buffer; for ( ihp = line_startp; (ihp < line_endp) && !IS_WHITESPACE(*ihp); ihp++) *interp++ = *ihp; *interp = '\\0'; exec_reset_save_path(imgp); exec_save_path(imgp, CAST_USER_ADDR_T(imgp->ip_interp_buffer), UIO_SYSSPACE, NULL); interp = imgp->ip_interp_buffer; for ( ihp = line_startp; (ihp < line_endp); ihp++) *interp++ = *ihp; *interp = '\\0'; if (imgp->ip_origvattr->va_mode & (VSUID | VSGID)) { p = vfs_context_proc(imgp->ip_vfs_context); error = falloc(p, &fp, &fd, imgp->ip_vfs_context); if (error) return(error); fp->f_fglob->fg_flag = FREAD; fp->f_fglob->fg_ops = &vnops; fp->f_fglob->fg_data = (caddr_t)imgp->ip_vp; proc_fdlock(p); procfdtbl_releasefd(p, fd, NULL); fp_drop(p, fd, fp, 1); proc_fdunlock(p); vnode_ref(imgp->ip_vp); imgp->ip_interp_sugid_fd = fd; } return (-3); } static int exec_fat_imgact(struct image_params *imgp) { proc_t p = vfs_context_proc(imgp->ip_vfs_context); kauth_cred_t cred = kauth_cred_proc_ref(p); struct fat_header *fat_header = (struct fat_header *)imgp->ip_vdata; struct _posix_spawnattr *psa = NULL; struct fat_arch fat_arch; int resid, error; load_return_t lret; if (imgp->ip_origcputype != 0) { return (-1); } if (OSSwapBigToHostInt32(fat_header->magic) != FAT_MAGIC) { error = -1; goto bad; } lret = fatfile_validate_fatarches((vm_offset_t)fat_header, PAGE_SIZE); if (lret != LOAD_SUCCESS) { error = load_return_to_errno(lret); goto bad; } psa = (struct _posix_spawnattr *) imgp->ip_px_sa; if (psa != NULL && psa->psa_binprefs[0] != 0) { uint32_t pr = 0; for (pr = 0; pr < NBINPREFS; pr++) { cpu_type_t pref = psa->psa_binprefs[pr]; if (pref == 0) { error = EBADARCH; goto bad; } if (pref == CPU_TYPE_ANY) { goto regular_grading; } lret = fatfile_getbestarch_for_cputype(pref, (vm_offset_t)fat_header, PAGE_SIZE, &fat_arch); if (lret == LOAD_SUCCESS) { goto use_arch; } } error = EBADEXEC; goto bad; } regular_grading: lret = fatfile_getbestarch((vm_offset_t)fat_header, PAGE_SIZE, &fat_arch); if (lret != LOAD_SUCCESS) { error = load_return_to_errno(lret); goto bad; } use_arch: error = vn_rdwr(UIO_READ, imgp->ip_vp, imgp->ip_vdata, PAGE_SIZE, fat_arch.offset, UIO_SYSSPACE, (IO_UNIT|IO_NODELOCKED), cred, &resid, p); if (error) { goto bad; } if (resid) { memset(imgp->ip_vdata + (PAGE_SIZE - resid), 0x0, resid); } error = -2; imgp->ip_arch_offset = (user_size_t)fat_arch.offset; imgp->ip_arch_size = (user_size_t)fat_arch.size; imgp->ip_origcputype = fat_arch.cputype; imgp->ip_origcpusubtype = fat_arch.cpusubtype; bad: kauth_cred_unref(&cred); return (error); } static int activate_exec_state(task_t task, proc_t p, thread_t thread, load_result_t *result) { int ret; task_set_dyld_info(task, MACH_VM_MIN_ADDRESS, 0); if (result->is64bit) { task_set_64bit(task, TRUE); OSBitOrAtomic(P_LP64, &p->p_flag); } else { task_set_64bit(task, FALSE); OSBitAndAtomic(~((uint32_t)P_LP64), &p->p_flag); } ret = thread_state_initialize(thread); if (ret != KERN_SUCCESS) { return ret; } if (result->threadstate) { uint32_t *ts = result->threadstate; uint32_t total_size = result->threadstate_sz; while (total_size > 0) { uint32_t flavor = *ts++; uint32_t size = *ts++; ret = thread_setstatus(thread, flavor, (thread_state_t)ts, size); if (ret) { return ret; } ts += size; total_size -= (size + 2) * sizeof(uint32_t); } } thread_setentrypoint(thread, result->entry_point); return KERN_SUCCESS; } static void set_proc_name(struct image_params *imgp, proc_t p) { int p_name_len = sizeof(p->p_name) - 1; if (imgp->ip_ndp->ni_cnd.cn_namelen > p_name_len) { imgp->ip_ndp->ni_cnd.cn_namelen = p_name_len; } bcopy((caddr_t)imgp->ip_ndp->ni_cnd.cn_nameptr, (caddr_t)p->p_name, (unsigned)imgp->ip_ndp->ni_cnd.cn_namelen); p->p_name[imgp->ip_ndp->ni_cnd.cn_namelen] = '\\0'; if (imgp->ip_ndp->ni_cnd.cn_namelen > MAXCOMLEN) { imgp->ip_ndp->ni_cnd.cn_namelen = MAXCOMLEN; } bcopy((caddr_t)imgp->ip_ndp->ni_cnd.cn_nameptr, (caddr_t)p->p_comm, (unsigned)imgp->ip_ndp->ni_cnd.cn_namelen); p->p_comm[imgp->ip_ndp->ni_cnd.cn_namelen] = '\\0'; } static int exec_mach_imgact(struct image_params *imgp) { struct mach_header *mach_header = (struct mach_header *)imgp->ip_vdata; proc_t p = vfs_context_proc(imgp->ip_vfs_context); int error = 0; task_t task; task_t new_task = NULL; thread_t thread; struct uthread *uthread; vm_map_t old_map = VM_MAP_NULL; vm_map_t map = VM_MAP_NULL; load_return_t lret; load_result_t load_result; struct _posix_spawnattr *psa = NULL; int spawn = (imgp->ip_flags & IMGPF_SPAWN); int vfexec = (imgp->ip_flags & IMGPF_VFORK_EXEC); int exec = (imgp->ip_flags & IMGPF_EXEC); os_reason_t exec_failure_reason = OS_REASON_NULL; if ((mach_header->magic == MH_CIGAM) || (mach_header->magic == MH_CIGAM_64)) { error = EBADARCH; goto bad; } if ((mach_header->magic != MH_MAGIC) && (mach_header->magic != MH_MAGIC_64)) { error = -1; goto bad; } if (mach_header->filetype != MH_EXECUTE) { error = -1; goto bad; } if (imgp->ip_origcputype != 0) { if (imgp->ip_origcputype != mach_header->cputype || imgp->ip_origcpusubtype != mach_header->cpusubtype) { error = EBADARCH; goto bad; } } else { imgp->ip_origcputype = mach_header->cputype; imgp->ip_origcpusubtype = mach_header->cpusubtype; } task = current_task(); thread = current_thread(); uthread = get_bsdthread_info(thread); if ((mach_header->cputype & CPU_ARCH_ABI64) == CPU_ARCH_ABI64) imgp->ip_flags |= IMGPF_IS_64BIT; psa = (struct _posix_spawnattr *) imgp->ip_px_sa; if (psa != NULL && psa->psa_binprefs[0] != 0) { int pr = 0; for (pr = 0; pr < NBINPREFS; pr++) { cpu_type_t pref = psa->psa_binprefs[pr]; if (pref == 0) { error = EBADARCH; goto bad; } if (pref == CPU_TYPE_ANY) { goto grade; } if (pref == imgp->ip_origcputype) { goto grade; } } error = EBADARCH; goto bad; } grade: if (!grade_binary(imgp->ip_origcputype, imgp->ip_origcpusubtype & ~CPU_SUBTYPE_MASK)) { error = EBADARCH; goto bad; } error = exec_extract_strings(imgp); if (error) goto bad; AUDIT_ARG(argv, imgp->ip_startargv, imgp->ip_argc, imgp->ip_endargv - imgp->ip_startargv); AUDIT_ARG(envv, imgp->ip_endargv, imgp->ip_envc, imgp->ip_endenvv - imgp->ip_endargv); if (vfexec) { imgp->ip_new_thread = fork_create_child(task, NULL, p, FALSE, (imgp->ip_flags & IMGPF_IS_64BIT), FALSE); if (imgp->ip_new_thread == NULL) { error = ENOMEM; goto bad; } } thread = imgp->ip_new_thread; uthread = get_bsdthread_info(thread); task = new_task = get_threadtask(thread); lret = load_machfile(imgp, mach_header, thread, &map, &load_result); if (lret != LOAD_SUCCESS) { error = load_return_to_errno(lret); KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_BAD_MACHO, 0, 0); if (lret == LOAD_BADMACHO_UPX) { set_proc_name(imgp, p); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_UPX); exec_failure_reason->osr_flags |= OS_REASON_FLAG_GENERATE_CRASH_REPORT; exec_failure_reason->osr_flags |= OS_REASON_FLAG_CONSISTENT_FAILURE; } else { exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_BAD_MACHO); } goto badtoolate; } proc_lock(p); p->p_cputype = imgp->ip_origcputype; p->p_cpusubtype = imgp->ip_origcpusubtype; proc_unlock(p); vm_map_set_user_wire_limit(map, p->p_rlimit[RLIMIT_MEMLOCK].rlim_cur); if (load_result.csflags & CS_VALID) { imgp->ip_csflags |= load_result.csflags & (CS_VALID|CS_SIGNED|CS_DEV_CODE| CS_HARD|CS_KILL|CS_RESTRICT|CS_ENFORCEMENT|CS_REQUIRE_LV| CS_ENTITLEMENTS_VALIDATED|CS_DYLD_PLATFORM| CS_ENTITLEMENT_FLAGS| CS_EXEC_SET_HARD|CS_EXEC_SET_KILL|CS_EXEC_SET_ENFORCEMENT); } else { imgp->ip_csflags &= ~CS_VALID; } if (p->p_csflags & CS_EXEC_SET_HARD) imgp->ip_csflags |= CS_HARD; if (p->p_csflags & CS_EXEC_SET_KILL) imgp->ip_csflags |= CS_KILL; if (p->p_csflags & CS_EXEC_SET_ENFORCEMENT) imgp->ip_csflags |= CS_ENFORCEMENT; if (p->p_csflags & CS_EXEC_SET_INSTALLER) imgp->ip_csflags |= CS_INSTALLER; vm_map_exec(map, task, load_result.is64bit, (void *)p->p_fd->fd_rdir, cpu_type()); fdexec(p, psa != NULL ? psa->psa_flags : 0); error = exec_handle_sugid(imgp); if (error) { vm_map_deallocate(map); KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_SUGID_FAILURE, 0, 0); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_SUGID_FAILURE); goto badtoolate; } old_map = swap_task_map(task, thread, map, !spawn); vm_map_deallocate(old_map); lret = activate_exec_state(task, p, thread, &load_result); if (lret != KERN_SUCCESS) { KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_ACTV_THREADSTATE, 0, 0); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_ACTV_THREADSTATE); goto badtoolate; } if (imgp->ip_new_thread == NULL) thread_set_mach_voucher(current_thread(), IPC_VOUCHER_NULL); if (!vfexec && !spawn && (p->p_lflag & P_LTRACED)) psignal(p, SIGTRAP); if (load_result.unixproc && create_unix_stack(get_task_map(task), &load_result, p) != KERN_SUCCESS) { error = load_return_to_errno(LOAD_NOSPACE); KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_STACK_ALLOC, 0, 0); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_STACK_ALLOC); goto badtoolate; } error = exec_add_apple_strings(imgp, &load_result); if (error) { KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_APPLE_STRING_INIT, 0, 0); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_APPLE_STRING_INIT); goto badtoolate; } old_map = vm_map_switch(get_task_map(task)); if (load_result.unixproc) { user_addr_t ap; ap = p->user_stack; error = exec_copyout_strings(imgp, &ap); if (error) { vm_map_switch(old_map); KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_COPYOUT_STRINGS, 0, 0); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_COPYOUT_STRINGS); goto badtoolate; } thread_setuserstack(thread, ap); } if (load_result.dynlinker) { uint64_t ap; int new_ptr_size = (imgp->ip_flags & IMGPF_IS_64BIT) ? 8 : 4; ap = thread_adjuserstack(thread, -new_ptr_size); error = copyoutptr(load_result.mach_header, ap, new_ptr_size); if (error) { vm_map_switch(old_map); KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_COPYOUT_DYNLINKER, 0, 0); exec_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_COPYOUT_DYNLINKER); goto badtoolate; } task_set_dyld_info(task, load_result.all_image_info_addr, load_result.all_image_info_size); } exec_prefault_data(p, imgp, &load_result); vm_map_switch(old_map); stopprofclock(p); execsigs(p, thread); _aio_exec( p ); #if SYSV_SHM if (!vfexec && p->vm_shm) shmexec(p); #endif #if SYSV_SEM semexit(p); #endif p->p_acflag &= ~AFORK; set_proc_name(imgp, p); #if CONFIG_SECLUDED_MEMORY if (secluded_for_apps) { if (strncmp(p->p_name, \"Camera\", sizeof (p->p_name)) == 0 || #if 00 strncmp(p->p_name, \"camerad\", sizeof (p->p_name)) == 0 || #endif strncmp(p->p_name, \"testCamera\", sizeof (p->p_name)) == 0) { task_set_could_use_secluded_mem(task, TRUE); } else { task_set_could_use_secluded_mem(task, FALSE); } if (strncmp(p->p_name, \"mediaserverd\", sizeof (p->p_name)) == 0) { task_set_could_also_use_secluded_mem(task, TRUE); } } #endif pal_dbg_set_task_name( task ); #if DEVELOPMENT || DEBUG task_importance_update_owner_info(task); #endif memcpy(&p->p_uuid[0], &load_result.uuid[0], sizeof(p->p_uuid)); #if CONFIG_DTRACE dtrace_proc_exec(p); #endif if (kdebug_enable) { long dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4; kdbg_trace_string(p, &dbg_arg1, &dbg_arg2, &dbg_arg3, &dbg_arg4); KERNEL_DEBUG_CONSTANT1(TRACE_DATA_EXEC | DBG_FUNC_NONE, p->p_pid ,0,0,0, (uintptr_t)thread_tid(thread)); KERNEL_DEBUG_CONSTANT1(TRACE_STRING_EXEC | DBG_FUNC_NONE, dbg_arg1, dbg_arg2, dbg_arg3, dbg_arg4, (uintptr_t)thread_tid(thread)); } if (imgp->ip_px_sa != NULL) { psa = (struct _posix_spawnattr *) imgp->ip_px_sa; if (psa->psa_flags & POSIX_SPAWN_START_SUSPENDED) { proc_lock(p); p->p_stat = SSTOP; proc_unlock(p); (void) task_suspend_internal(task); } } OSBitOrAtomic(P_EXEC, &p->p_flag); proc_resetregister(p); if (p->p_pptr && (p->p_lflag & P_LPPWAIT)) { proc_lock(p); p->p_lflag &= ~P_LPPWAIT; proc_unlock(p); wakeup((caddr_t)p->p_pptr); } if (vfexec && (p->p_lflag & P_LTRACED)) { psignal_vfork(p, new_task, thread, SIGTRAP); } goto done; badtoolate: if (!spawn) { if (vfexec) { assert(exec_failure_reason != OS_REASON_NULL); psignal_vfork_with_reason(p, new_task, thread, SIGKILL, exec_failure_reason); exec_failure_reason = OS_REASON_NULL; } else { assert(exec_failure_reason != OS_REASON_NULL); psignal_with_reason(p, SIGKILL, exec_failure_reason); exec_failure_reason = OS_REASON_NULL; if (exec) { task_terminate_internal(task); } } error = 0; } else { os_reason_free(exec_failure_reason); exec_failure_reason = OS_REASON_NULL; } done: if (!spawn) { if ((p->p_lflag & P_LTERM_DECRYPTFAIL) == 0) proc_knote(p, NOTE_EXEC); } if (load_result.threadstate) { kfree(load_result.threadstate, load_result.threadstate_sz); load_result.threadstate = NULL; } bad: assert(exec_failure_reason == OS_REASON_NULL); return(error); } struct execsw { int (*ex_imgact)(struct image_params *); const char *ex_name; } execsw[] = { { exec_mach_imgact, \"Mach-o Binary\" }, { exec_fat_imgact, \"Fat Binary\" }, { exec_shell_imgact, \"Interpreter Script\" }, { NULL, NULL} }; static int exec_activate_image(struct image_params *imgp) { struct nameidata *ndp = NULL; const char *excpath; int error; int resid; int once = 1; int i; int itercount = 0; proc_t p = vfs_context_proc(imgp->ip_vfs_context); error = execargs_alloc(imgp); if (error) goto bad_notrans; error = exec_save_path(imgp, imgp->ip_user_fname, imgp->ip_seg, &excpath); if (error) { goto bad_notrans; } DTRACE_PROC1(exec, uintptr_t, excpath); MALLOC(ndp, struct nameidata *, sizeof(*ndp), M_TEMP, M_WAITOK | M_ZERO); if (ndp == NULL) { error = ENOMEM; goto bad_notrans; } NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF | AUDITVNPATH1, UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp->ip_vfs_context); again: error = namei(ndp); if (error) goto bad_notrans; imgp->ip_ndp = ndp; imgp->ip_vp = ndp->ni_vp; proc_lock(p); if (p->p_lflag & P_LEXIT) { error = EDEADLK; proc_unlock(p); goto bad_notrans; } error = proc_transstart(p, 1, 0); proc_unlock(p); if (error) goto bad_notrans; error = exec_check_permissions(imgp); if (error) goto bad; if (once) { once = 0; *imgp->ip_origvattr = *imgp->ip_vattr; } error = vn_rdwr(UIO_READ, imgp->ip_vp, imgp->ip_vdata, PAGE_SIZE, 0, UIO_SYSSPACE, IO_NODELOCKED, vfs_context_ucred(imgp->ip_vfs_context), &resid, vfs_context_proc(imgp->ip_vfs_context)); if (error) goto bad; if (resid) { memset(imgp->ip_vdata + (PAGE_SIZE - resid), 0x0, resid); } encapsulated_binary: if (++itercount > EAI_ITERLIMIT) { error = EBADEXEC; goto bad; } error = -1; for(i = 0; error == -1 && execsw[i].ex_imgact != NULL; i++) { error = (*execsw[i].ex_imgact)(imgp); switch (error) { case -2: goto encapsulated_binary; case -3: #if CONFIG_MACF if (imgp->ip_scriptlabelp) mac_vnode_label_free(imgp->ip_scriptlabelp); imgp->ip_scriptlabelp = mac_vnode_label_alloc(); if (imgp->ip_scriptlabelp == NULL) { error = ENOMEM; break; } mac_vnode_label_copy(imgp->ip_vp->v_label, imgp->ip_scriptlabelp); if (imgp->ip_scriptvp) vnode_put(imgp->ip_scriptvp); if (vnode_getwithref(imgp->ip_vp) == 0) imgp->ip_scriptvp = imgp->ip_vp; #endif nameidone(ndp); vnode_put(imgp->ip_vp); imgp->ip_vp = NULL; imgp->ip_ndp = NULL; NDINIT(ndp, LOOKUP, OP_LOOKUP, FOLLOW | LOCKLEAF, UIO_SYSSPACE, CAST_USER_ADDR_T(excpath), imgp->ip_vfs_context); proc_transend(p, 0); goto again; default: break; } } if (error == 0 && kauth_authorize_fileop_has_listeners()) { kauth_authorize_fileop(vfs_context_ucred(imgp->ip_vfs_context), KAUTH_FILEOP_EXEC, (uintptr_t)ndp->ni_vp, 0); } bad: proc_transend(p, 0); bad_notrans: if (imgp->ip_strings) execargs_free(imgp); if (imgp->ip_ndp) nameidone(imgp->ip_ndp); if (ndp) FREE(ndp, M_TEMP); return (error); } static errno_t exec_handle_spawnattr_policy(proc_t p, int psa_apptype, uint64_t psa_qos_clamp, uint64_t psa_darwin_role, ipc_port_t * portwatch_ports, int portwatch_count) { int apptype = TASK_APPTYPE_NONE; int qos_clamp = THREAD_QOS_UNSPECIFIED; int role = TASK_UNSPECIFIED; if ((psa_apptype & POSIX_SPAWN_PROC_TYPE_MASK) != 0) { int proctype = psa_apptype & POSIX_SPAWN_PROC_TYPE_MASK; switch(proctype) { case POSIX_SPAWN_PROC_TYPE_DAEMON_INTERACTIVE: apptype = TASK_APPTYPE_DAEMON_INTERACTIVE; break; case POSIX_SPAWN_PROC_TYPE_DAEMON_STANDARD: apptype = TASK_APPTYPE_DAEMON_STANDARD; break; case POSIX_SPAWN_PROC_TYPE_DAEMON_ADAPTIVE: apptype = TASK_APPTYPE_DAEMON_ADAPTIVE; break; case POSIX_SPAWN_PROC_TYPE_DAEMON_BACKGROUND: apptype = TASK_APPTYPE_DAEMON_BACKGROUND; break; case POSIX_SPAWN_PROC_TYPE_APP_DEFAULT: apptype = TASK_APPTYPE_APP_DEFAULT; break; case POSIX_SPAWN_PROC_TYPE_APP_TAL: apptype = TASK_APPTYPE_APP_TAL; break; default: apptype = TASK_APPTYPE_NONE; break; } } if (psa_qos_clamp != POSIX_SPAWN_PROC_CLAMP_NONE) { switch (psa_qos_clamp) { case POSIX_SPAWN_PROC_CLAMP_UTILITY: qos_clamp = THREAD_QOS_UTILITY; break; case POSIX_SPAWN_PROC_CLAMP_BACKGROUND: qos_clamp = THREAD_QOS_BACKGROUND; break; case POSIX_SPAWN_PROC_CLAMP_MAINTENANCE: qos_clamp = THREAD_QOS_MAINTENANCE; break; default: qos_clamp = THREAD_QOS_UNSPECIFIED; break; } } if (psa_darwin_role != PRIO_DARWIN_ROLE_DEFAULT) { proc_darwin_role_to_task_role(psa_darwin_role, &role); } if (apptype != TASK_APPTYPE_NONE || qos_clamp != THREAD_QOS_UNSPECIFIED || role != TASK_UNSPECIFIED) { proc_set_task_spawnpolicy(p->task, apptype, qos_clamp, role, portwatch_ports, portwatch_count); } return (0); } static errno_t exec_handle_port_actions(struct image_params *imgp, boolean_t * portwatch_present, ipc_port_t * portwatch_ports) { _posix_spawn_port_actions_t pacts = imgp->ip_px_spa; #if CONFIG_AUDIT proc_t p = vfs_context_proc(imgp->ip_vfs_context); #endif _ps_port_action_t *act = NULL; task_t task = get_threadtask(imgp->ip_new_thread); ipc_port_t port = NULL; errno_t ret = 0; int i; kern_return_t kr; *portwatch_present = FALSE; for (i = 0; i < pacts->pspa_count; i++) { act = &pacts->pspa_actions[i]; if (MACH_PORT_VALID(act->new_port)) { kr = ipc_object_copyin(get_task_ipcspace(current_task()), act->new_port, MACH_MSG_TYPE_COPY_SEND, (ipc_object_t *) &port); if (kr != KERN_SUCCESS) { ret = EINVAL; goto done; } } else { port = CAST_MACH_NAME_TO_PORT(act->new_port); } switch (act->port_type) { case PSPA_SPECIAL: kr = task_set_special_port(task, act->which, port); if (kr != KERN_SUCCESS) ret = EINVAL; break; case PSPA_EXCEPTION: kr = task_set_exception_ports(task, act->mask, port, act->behavior, act->flavor); if (kr != KERN_SUCCESS) ret = EINVAL; break; #if CONFIG_AUDIT case PSPA_AU_SESSION: ret = audit_session_spawnjoin(p, task, port); break; #endif case PSPA_IMP_WATCHPORTS: if (portwatch_ports != NULL && IPC_PORT_VALID(port)) { *portwatch_present = TRUE; portwatch_ports[i] = port; } else { ipc_port_release_send(port); } break; default: ret = EINVAL; break; } if (ret) { ipc_port_release_send(port); break; } } done: if (0 != ret) DTRACE_PROC1(spawn__port__failure, mach_port_name_t, act->new_port); return (ret); } static int exec_handle_file_actions(struct image_params *imgp, short psa_flags) { int error = 0; int action; proc_t p = vfs_context_proc(imgp->ip_vfs_context); _posix_spawn_file_actions_t px_sfap = imgp->ip_px_sfa; int ival[2]; for (action = 0; action < px_sfap->psfa_act_count; action++) { _psfa_action_t *psfa = &px_sfap->psfa_act_acts[ action]; switch(psfa->psfaa_type) { case PSFA_OPEN: { char *bufp = NULL; struct vnode_attr *vap; struct nameidata *ndp; int mode = psfa->psfaa_openargs.psfao_mode; struct dup2_args dup2a; struct close_nocancel_args ca; int origfd; MALLOC(bufp, char *, sizeof(*vap) + sizeof(*ndp), M_TEMP, M_WAITOK | M_ZERO); if (bufp == NULL) { error = ENOMEM; break; } vap = (struct vnode_attr *) bufp; ndp = (struct nameidata *) (bufp + sizeof(*vap)); VATTR_INIT(vap); mode = ((mode &~ p->p_fd->fd_cmask) & ALLPERMS) & ~S_ISTXT; VATTR_SET(vap, va_mode, mode & ACCESSPERMS); NDINIT(ndp, LOOKUP, OP_OPEN, FOLLOW | AUDITVNPATH1, UIO_SYSSPACE, CAST_USER_ADDR_T(psfa->psfaa_openargs.psfao_path), imgp->ip_vfs_context); error = open1(imgp->ip_vfs_context, ndp, psfa->psfaa_openargs.psfao_oflag, vap, fileproc_alloc_init, NULL, ival); FREE(bufp, M_TEMP); if (error || ival[0] == psfa->psfaa_filedes) break; origfd = ival[0]; dup2a.from = origfd; dup2a.to = psfa->psfaa_filedes; error = dup2(p, &dup2a, ival); if (error) break; ca.fd = origfd; error = close_nocancel(p, &ca, ival); } break; case PSFA_DUP2: { struct dup2_args dup2a; dup2a.from = psfa->psfaa_filedes; dup2a.to = psfa->psfaa_openargs.psfao_oflag; error = dup2(p, &dup2a, ival); } break; case PSFA_CLOSE: { struct close_nocancel_args ca; ca.fd = psfa->psfaa_filedes; error = close_nocancel(p, &ca, ival); } break; case PSFA_INHERIT: { struct fcntl_nocancel_args fcntla; fcntla.fd = psfa->psfaa_filedes; fcntla.cmd = F_GETFD; if ((error = fcntl_nocancel(p, &fcntla, ival)) != 0) break; if ((ival[0] & FD_CLOEXEC) == FD_CLOEXEC) { fcntla.fd = psfa->psfaa_filedes; fcntla.cmd = F_SETFD; fcntla.arg = ival[0] & ~FD_CLOEXEC; error = fcntl_nocancel(p, &fcntla, ival); } } break; default: error = EINVAL; break; } if (error) { if (PSFA_OPEN == psfa->psfaa_type) { DTRACE_PROC1(spawn__open__failure, uintptr_t, psfa->psfaa_openargs.psfao_path); } else { DTRACE_PROC1(spawn__fd__failure, int, psfa->psfaa_filedes); } break; } } if (error != 0 || (psa_flags & POSIX_SPAWN_CLOEXEC_DEFAULT) == 0) return (error); proc_fdlock(p); for (action = 0; action < px_sfap->psfa_act_count; action++) { _psfa_action_t *psfa = &px_sfap->psfa_act_acts[action]; int fd = psfa->psfaa_filedes; switch (psfa->psfaa_type) { case PSFA_DUP2: fd = psfa->psfaa_openargs.psfao_oflag; case PSFA_OPEN: case PSFA_INHERIT: *fdflags(p, fd) |= UF_INHERIT; break; case PSFA_CLOSE: break; } } proc_fdunlock(p); return (0); } #if CONFIG_MACF void * exec_spawnattr_getmacpolicyinfo(const void *macextensions, const char *policyname, size_t *lenp) { const struct _posix_spawn_mac_policy_extensions *psmx = macextensions; int i; if (psmx == NULL) return NULL; for (i = 0; i < psmx->psmx_count; i++) { const _ps_mac_policy_extension_t *extension = &psmx->psmx_extensions[i]; if (strncmp(extension->policyname, policyname, sizeof(extension->policyname)) == 0) { if (lenp != NULL) *lenp = extension->datalen; return extension->datap; } } if (lenp != NULL) *lenp = 0; return NULL; } static int spawn_copyin_macpolicyinfo(const struct user__posix_spawn_args_desc *px_args, _posix_spawn_mac_policy_extensions_t *psmxp) { _posix_spawn_mac_policy_extensions_t psmx = NULL; int error = 0; int copycnt = 0; int i = 0; *psmxp = NULL; if (px_args->mac_extensions_size < PS_MAC_EXTENSIONS_SIZE(1) || px_args->mac_extensions_size > PAGE_SIZE) { error = EINVAL; goto bad; } MALLOC(psmx, _posix_spawn_mac_policy_extensions_t, px_args->mac_extensions_size, M_TEMP, M_WAITOK); if ((error = copyin(px_args->mac_extensions, psmx, px_args->mac_extensions_size)) != 0) goto bad; if (PS_MAC_EXTENSIONS_SIZE(psmx->psmx_count) > px_args->mac_extensions_size) { error = EINVAL; goto bad; } for (i = 0; i < psmx->psmx_count; i++) { _ps_mac_policy_extension_t *extension = &psmx->psmx_extensions[i]; if (extension->datalen == 0 || extension->datalen > PAGE_SIZE) { error = EINVAL; goto bad; } } for (copycnt = 0; copycnt < psmx->psmx_count; copycnt++) { _ps_mac_policy_extension_t *extension = &psmx->psmx_extensions[copycnt]; void *data = NULL; MALLOC(data, void *, extension->datalen, M_TEMP, M_WAITOK); if ((error = copyin(extension->data, data, extension->datalen)) != 0) { FREE(data, M_TEMP); goto bad; } extension->datap = data; } *psmxp = psmx; return 0; bad: if (psmx != NULL) { for (i = 0; i < copycnt; i++) FREE(psmx->psmx_extensions[i].datap, M_TEMP); FREE(psmx, M_TEMP); } return error; } static void spawn_free_macpolicyinfo(_posix_spawn_mac_policy_extensions_t psmx) { int i; if (psmx == NULL) return; for (i = 0; i < psmx->psmx_count; i++) FREE(psmx->psmx_extensions[i].datap, M_TEMP); FREE(psmx, M_TEMP); } #endif #if CONFIG_COALITIONS static inline void spawn_coalitions_release_all(coalition_t coal[COALITION_NUM_TYPES]) { for (int c = 0; c < COALITION_NUM_TYPES; c++) { if (coal[c]) { coalition_remove_active(coal[c]); coalition_release(coal[c]); } } } #endif #if CONFIG_PERSONAS static int spawn_validate_persona(struct _posix_spawn_persona_info *px_persona) { int error = 0; struct persona *persona = NULL; int verify = px_persona->pspi_flags & POSIX_SPAWN_PERSONA_FLAGS_VERIFY; if (!kauth_cred_issuser(kauth_cred_get())) return EPERM; persona = persona_lookup(px_persona->pspi_id); if (!persona) { error = ESRCH; goto out; } if (verify) { if (px_persona->pspi_flags & POSIX_SPAWN_PERSONA_UID) { if (px_persona->pspi_uid != persona_get_uid(persona)) { error = EINVAL; goto out; } } if (px_persona->pspi_flags & POSIX_SPAWN_PERSONA_GID) { if (px_persona->pspi_gid != persona_get_gid(persona)) { error = EINVAL; goto out; } } if (px_persona->pspi_flags & POSIX_SPAWN_PERSONA_GROUPS) { int ngroups = 0; gid_t groups[NGROUPS_MAX]; if (persona_get_groups(persona, &ngroups, groups, px_persona->pspi_ngroups) != 0) { error = EINVAL; goto out; } if (ngroups != (int)px_persona->pspi_ngroups) { error = EINVAL; goto out; } while (ngroups--) { if (px_persona->pspi_groups[ngroups] != groups[ngroups]) { error = EINVAL; goto out; } } if (px_persona->pspi_gmuid != persona_get_gmuid(persona)) { error = EINVAL; goto out; } } } out: if (persona) persona_put(persona); return error; } static int spawn_persona_adopt(proc_t p, struct _posix_spawn_persona_info *px_persona) { int ret; kauth_cred_t cred; struct persona *persona = NULL; int override = !!(px_persona->pspi_flags & POSIX_SPAWN_PERSONA_FLAGS_OVERRIDE); if (!override) return persona_proc_adopt_id(p, px_persona->pspi_id, NULL); persona = persona_lookup(px_persona->pspi_id); if (!persona) return ESRCH; cred = persona_get_cred(persona); if (!cred) { ret = EINVAL; goto out; } if (px_persona->pspi_flags & POSIX_SPAWN_PERSONA_UID) { cred = kauth_cred_setresuid(cred, px_persona->pspi_uid, px_persona->pspi_uid, px_persona->pspi_uid, KAUTH_UID_NONE); } if (px_persona->pspi_flags & POSIX_SPAWN_PERSONA_GID) { cred = kauth_cred_setresgid(cred, px_persona->pspi_gid, px_persona->pspi_gid, px_persona->pspi_gid); } if (px_persona->pspi_flags & POSIX_SPAWN_PERSONA_GROUPS) { cred = kauth_cred_setgroups(cred, px_persona->pspi_groups, px_persona->pspi_ngroups, px_persona->pspi_gmuid); } ret = persona_proc_adopt(p, persona, cred); out: persona_put(persona); return ret; } #endif int posix_spawn(proc_t ap, struct posix_spawn_args *uap, int32_t *retval) { proc_t p = ap; user_addr_t pid = uap->pid; int ival[2]; char *bufp = NULL; struct image_params *imgp; struct vnode_attr *vap; struct vnode_attr *origvap; struct uthread *uthread = 0; int error, sig; int is_64 = IS_64BIT_PROCESS(p); struct vfs_context context; struct user__posix_spawn_args_desc px_args; struct _posix_spawnattr px_sa; _posix_spawn_file_actions_t px_sfap = NULL; _posix_spawn_port_actions_t px_spap = NULL; struct __kern_sigaction vec; boolean_t spawn_no_exec = FALSE; boolean_t proc_transit_set = TRUE; boolean_t exec_done = FALSE; int portwatch_count = 0; ipc_port_t * portwatch_ports = NULL; vm_size_t px_sa_offset = offsetof(struct _posix_spawnattr, psa_ports); task_t new_task = NULL; boolean_t should_release_proc_ref = FALSE; void *inherit = NULL; #if CONFIG_PERSONAS struct _posix_spawn_persona_info *px_persona = NULL; #endif MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO); imgp = (struct image_params *) bufp; if (bufp == NULL) { error = ENOMEM; goto bad; } vap = (struct vnode_attr *) (bufp + sizeof(*imgp)); origvap = (struct vnode_attr *) (bufp + sizeof(*imgp) + sizeof(*vap)); imgp->ip_user_fname = uap->path; imgp->ip_user_argv = uap->argv; imgp->ip_user_envv = uap->envp; imgp->ip_vattr = vap; imgp->ip_origvattr = origvap; imgp->ip_vfs_context = &context; imgp->ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE); imgp->ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32); imgp->ip_mac_return = 0; imgp->ip_px_persona = NULL; imgp->ip_cs_error = OS_REASON_NULL; if (uap->adesc != USER_ADDR_NULL) { if(is_64) { error = copyin(uap->adesc, &px_args, sizeof(px_args)); } else { struct user32__posix_spawn_args_desc px_args32; error = copyin(uap->adesc, &px_args32, sizeof(px_args32)); px_args.attr_size = px_args32.attr_size; px_args.attrp = CAST_USER_ADDR_T(px_args32.attrp); px_args.file_actions_size = px_args32.file_actions_size; px_args.file_actions = CAST_USER_ADDR_T(px_args32.file_actions); px_args.port_actions_size = px_args32.port_actions_size; px_args.port_actions = CAST_USER_ADDR_T(px_args32.port_actions); px_args.mac_extensions_size = px_args32.mac_extensions_size; px_args.mac_extensions = CAST_USER_ADDR_T(px_args32.mac_extensions); px_args.coal_info_size = px_args32.coal_info_size; px_args.coal_info = CAST_USER_ADDR_T(px_args32.coal_info); px_args.persona_info_size = px_args32.persona_info_size; px_args.persona_info = CAST_USER_ADDR_T(px_args32.persona_info); } if (error) goto bad; if (px_args.attr_size != 0) { if ((error = copyin(px_args.attrp, &px_sa, px_sa_offset) != 0)) goto bad; bzero( (void *)( (unsigned long) &px_sa + px_sa_offset), sizeof(px_sa) - px_sa_offset ); imgp->ip_px_sa = &px_sa; } if (px_args.file_actions_size != 0) { int maxfa = (p->p_limit ? p->p_rlimit[RLIMIT_NOFILE].rlim_cur : NOFILE); if (px_args.file_actions_size < PSF_ACTIONS_SIZE(1) || px_args.file_actions_size > PSF_ACTIONS_SIZE(maxfa)) { error = EINVAL; goto bad; } MALLOC(px_sfap, _posix_spawn_file_actions_t, px_args.file_actions_size, M_TEMP, M_WAITOK); if (px_sfap == NULL) { error = ENOMEM; goto bad; } imgp->ip_px_sfa = px_sfap; if ((error = copyin(px_args.file_actions, px_sfap, px_args.file_actions_size)) != 0) goto bad; if (PSF_ACTIONS_SIZE(px_sfap->psfa_act_count) != px_args.file_actions_size) { error = EINVAL; goto bad; } } if (px_args.port_actions_size != 0) { if (px_args.port_actions_size < PS_PORT_ACTIONS_SIZE(1) || px_args.port_actions_size > PAGE_SIZE) { error = EINVAL; goto bad; } MALLOC(px_spap, _posix_spawn_port_actions_t, px_args.port_actions_size, M_TEMP, M_WAITOK); if (px_spap == NULL) { error = ENOMEM; goto bad; } imgp->ip_px_spa = px_spap; if ((error = copyin(px_args.port_actions, px_spap, px_args.port_actions_size)) != 0) goto bad; if (PS_PORT_ACTIONS_SIZE(px_spap->pspa_count) != px_args.port_actions_size) { error = EINVAL; goto bad; } } #if CONFIG_PERSONAS if (px_args.persona_info_size != 0 && px_args.persona_info != 0) { if (px_args.persona_info_size != sizeof(*px_persona)) { error = ERANGE; goto bad; } MALLOC(px_persona, struct _posix_spawn_persona_info *, px_args.persona_info_size, M_TEMP, M_WAITOK|M_ZERO); if (px_persona == NULL) { error = ENOMEM; goto bad; } imgp->ip_px_persona = px_persona; if ((error = copyin(px_args.persona_info, px_persona, px_args.persona_info_size)) != 0) goto bad; if ((error = spawn_validate_persona(px_persona)) != 0) goto bad; } #endif #if CONFIG_MACF if (px_args.mac_extensions_size != 0) { if ((error = spawn_copyin_macpolicyinfo(&px_args, (_posix_spawn_mac_policy_extensions_t *)&imgp->ip_px_smpx)) != 0) goto bad; } #endif } uthread = get_bsdthread_info(current_thread()); if (uthread->uu_flag & UT_VFORK) { error = EINVAL; goto bad; } if (imgp->ip_px_sa == NULL || !(px_sa.psa_flags & POSIX_SPAWN_SETEXEC)){ coalition_t coal[COALITION_NUM_TYPES] = { COALITION_NULL }; #if CONFIG_COALITIONS int i, ncoals; kern_return_t kr = KERN_SUCCESS; struct _posix_spawn_coalition_info coal_info; int coal_role[COALITION_NUM_TYPES]; if (imgp->ip_px_sa == NULL || !px_args.coal_info) goto do_fork1; memset(&coal_info, 0, sizeof(coal_info)); if (px_args.coal_info_size > sizeof(coal_info)) px_args.coal_info_size = sizeof(coal_info); error = copyin(px_args.coal_info, &coal_info, px_args.coal_info_size); if (error != 0) goto bad; ncoals = 0; for (i = 0; i < COALITION_NUM_TYPES; i++) { uint64_t cid = coal_info.psci_info[i].psci_id; if (cid != 0) { if (!task_is_in_privileged_coalition(p->task, i)) { coal_dbg(\"ERROR: %d not in privilegd \" \"coalition of type %d\", p->p_pid, i); spawn_coalitions_release_all(coal); error = EPERM; goto bad; } coal_dbg(\"searching for coalition id:%llu\", cid); coal[i] = coalition_find_and_activate_by_id(cid); if (coal[i] == COALITION_NULL) { coal_dbg(\"could not find coalition id:%llu \" \"(perhaps it has been terminated or reaped)\", cid); spawn_coalitions_release_all(coal); error = ESRCH; goto bad; } if (coalition_type(coal[i]) != i) { coal_dbg(\"coalition with id:%lld is not of type:%d\" \" (it's type:%d)\", cid, i, coalition_type(coal[i])); error = ESRCH; goto bad; } coal_role[i] = coal_info.psci_info[i].psci_role; ncoals++; } } if (ncoals < COALITION_NUM_TYPES) { if (coal[COALITION_TYPE_RESOURCE] == COALITION_NULL) { spawn_coalitions_release_all(coal); error = EINVAL; goto bad; } } do_fork1: #endif error = fork1(p, &imgp->ip_new_thread, PROC_CREATE_SPAWN, coal); if (error == 0) { new_task = get_threadtask(imgp->ip_new_thread); } #if CONFIG_COALITIONS if (error == 0) { kr = coalitions_set_roles(coal, get_threadtask(imgp->ip_new_thread), coal_role); if (kr != KERN_SUCCESS) error = EINVAL; } spawn_coalitions_release_all(coal); #endif if (error != 0) { goto bad; } imgp->ip_flags |= IMGPF_SPAWN; spawn_no_exec = TRUE; #if CONFIG_PERSONAS #if 0 if (!proc_has_persona(p) && imgp->ip_px_persona == NULL) { MALLOC(px_persona, struct _posix_spawn_persona_info *, sizeof(*px_persona), M_TEMP, M_WAITOK|M_ZERO); if (px_persona == NULL) { error = ENOMEM; goto bad; } px_persona->pspi_id = persona_get_id(g_system_persona); imgp->ip_px_persona = px_persona; } #endif #endif } else { imgp->ip_new_thread = fork_create_child(current_task(), NULL, p, FALSE, p->p_flag & P_LP64, TRUE); if (imgp->ip_new_thread == NULL) { error = ENOMEM; goto bad; } new_task = get_threadtask(imgp->ip_new_thread); imgp->ip_flags |= IMGPF_EXEC; } if (spawn_no_exec) { p = (proc_t)get_bsdthreadtask_info(imgp->ip_new_thread); DTRACE_PROC1(create, proc_t, p); } assert(p != NULL); context.vc_thread = imgp->ip_new_thread; context.vc_ucred = p->p_ucred; if (imgp->ip_px_sfa != NULL) { if ((error = exec_handle_file_actions(imgp, imgp->ip_px_sa != NULL ? px_sa.psa_flags : 0)) != 0) goto bad; } if (imgp->ip_px_spa != NULL) { boolean_t is_adaptive = FALSE; boolean_t portwatch_present = FALSE; if (imgp->ip_px_sa != NULL && px_sa.psa_apptype == POSIX_SPAWN_PROC_TYPE_DAEMON_ADAPTIVE) is_adaptive = TRUE; if (px_spap->pspa_count != 0 && is_adaptive) { portwatch_count = px_spap->pspa_count; MALLOC(portwatch_ports, ipc_port_t *, (sizeof(ipc_port_t) * portwatch_count), M_TEMP, M_WAITOK | M_ZERO); } else { portwatch_ports = NULL; } if ((error = exec_handle_port_actions(imgp, &portwatch_present, portwatch_ports)) != 0) goto bad; if (portwatch_present == FALSE && portwatch_ports != NULL) { FREE(portwatch_ports, M_TEMP); portwatch_ports = NULL; portwatch_count = 0; } } if (imgp->ip_px_sa != NULL) { if (px_sa.psa_flags & POSIX_SPAWN_SETPGROUP) { struct setpgid_args spga; spga.pid = p->p_pid; spga.pgid = px_sa.psa_pgroup; if((error = setpgid(p, &spga, ival)) != 0) goto bad; } while (px_sa.psa_flags & POSIX_SPAWN_RESETIDS) { kauth_cred_t my_cred = kauth_cred_proc_ref(p); kauth_cred_t my_new_cred = kauth_cred_setuidgid(my_cred, kauth_cred_getruid(my_cred), kauth_cred_getrgid(my_cred)); if (my_cred == my_new_cred) { kauth_cred_unref(&my_cred); break; } proc_ucred_lock(p); if (p->p_ucred != my_cred) { proc_ucred_unlock(p); kauth_cred_unref(&my_new_cred); continue; } p->p_ucred = my_new_cred; PROC_UPDATE_CREDS_ONPROC(p); proc_ucred_unlock(p); kauth_cred_unref(&my_cred); } #if CONFIG_PERSONAS if (spawn_no_exec && imgp->ip_px_persona != NULL) { error = spawn_persona_adopt(p, imgp->ip_px_persona); if (error != 0) goto bad; } #endif #if !SECURE_KERNEL if (px_sa.psa_flags & _POSIX_SPAWN_DISABLE_ASLR) OSBitOrAtomic(P_DISABLE_ASLR, &p->p_flag); #endif if (px_sa.psa_flags & _POSIX_SPAWN_ALLOW_DATA_EXEC) imgp->ip_flags |= IMGPF_ALLOW_DATA_EXEC; } if (p->p_flag & P_DISABLE_ASLR) imgp->ip_flags |= IMGPF_DISABLE_ASLR; if (spawn_no_exec) { proc_transend(p, 0); proc_transit_set = 0; } #if MAC_SPAWN if (uap->mac_p != USER_ADDR_NULL) { error = mac_execve_enter(uap->mac_p, imgp); if (error) goto bad; } #endif error = exec_activate_image(imgp); if (error == 0 && !spawn_no_exec) { p = proc_exec_switch_task(p, current_task(), new_task, imgp->ip_new_thread); should_release_proc_ref = TRUE; } if (error == 0) { exec_done = TRUE; } else if (error == -1) { error = ENOEXEC; } if (!error && imgp->ip_px_sa != NULL) { thread_t child_thread = imgp->ip_new_thread; uthread_t child_uthread = get_bsdthread_info(child_thread); if (px_sa.psa_flags & POSIX_SPAWN_SETSIGMASK) child_uthread->uu_sigmask = (px_sa.psa_sigmask & ~sigcantmask); if (px_sa.psa_flags & POSIX_SPAWN_SETSIGDEF) { vec.sa_handler = SIG_DFL; vec.sa_tramp = 0; vec.sa_mask = 0; vec.sa_flags = 0; for (sig = 1; sig < NSIG; sig++) if (px_sa.psa_sigdefault & (1 << (sig-1))) { error = setsigvec(p, child_thread, sig, &vec, spawn_no_exec); } } if (px_sa.psa_cpumonitor_percent != 0) { error = proc_set_task_ruse_cpu(p->task, TASK_POLICY_RESOURCE_ATTRIBUTE_NOTIFY_EXC, px_sa.psa_cpumonitor_percent, px_sa.psa_cpumonitor_interval * NSEC_PER_SEC, 0, TRUE); } } bad: if (error == 0) { if ((p->p_flag & P_DELAYIDLESLEEP) == P_DELAYIDLESLEEP) OSBitAndAtomic(~((uint32_t)P_DELAYIDLESLEEP), &p->p_flag); if (imgp->ip_px_sa != NULL) { switch (px_sa.psa_pcontrol) { case POSIX_SPAWN_PCONTROL_THROTTLE: p->p_pcaction = P_PCTHROTTLE; break; case POSIX_SPAWN_PCONTROL_SUSPEND: p->p_pcaction = P_PCSUSP; break; case POSIX_SPAWN_PCONTROL_KILL: p->p_pcaction = P_PCKILL; break; case POSIX_SPAWN_PCONTROL_NONE: default: p->p_pcaction = 0; break; }; } exec_resettextvp(p, imgp); #if CONFIG_MEMORYSTATUS if (imgp->ip_px_sa != NULL && (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_SET)) { if (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND) { memorystatus_update(p, px_sa.psa_priority, 0, (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_USE_EFFECTIVE_PRIORITY), TRUE, -1, TRUE, px_sa.psa_memlimit_inactive, FALSE, (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND)); } else { memorystatus_update(p, px_sa.psa_priority, 0, (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_USE_EFFECTIVE_PRIORITY), TRUE, px_sa.psa_memlimit_active, (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_MEMLIMIT_ACTIVE_FATAL), px_sa.psa_memlimit_inactive, (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_MEMLIMIT_INACTIVE_FATAL), (px_sa.psa_jetsam_flags & POSIX_SPAWN_JETSAM_HIWATER_BACKGROUND)); } } #endif } if (spawn_no_exec) { if (proc_transit_set) proc_transend(p, 0); proc_signalend(p, 0); proc_knote(p->p_pptr, NOTE_FORK | p->p_pid); if ((p->p_lflag & P_LTERM_DECRYPTFAIL) == 0) proc_knote(p, NOTE_EXEC); } if (error == 0) { error = proc_transstart(p, 0, 0); if (error == 0) { task_bank_init(get_threadtask(imgp->ip_new_thread)); proc_transend(p, 0); } } if (error == 0 && imgp->ip_px_sa != NULL) { struct _posix_spawnattr *psa = (struct _posix_spawnattr *) imgp->ip_px_sa; exec_handle_spawnattr_policy(p, psa->psa_apptype, psa->psa_qos_clamp, psa->psa_darwin_role, portwatch_ports, portwatch_count); } if (error == 0 && task_did_exec(current_task())) { inherit = ipc_importance_exec_switch_task(current_task(), get_threadtask(imgp->ip_new_thread)); } if (error == 0) { thread_t main_thread = imgp->ip_new_thread; task_set_main_thread_qos(get_threadtask(imgp->ip_new_thread), main_thread); } if (portwatch_ports != NULL) { for (int i = 0; i < portwatch_count; i++) { ipc_port_t port = NULL; if ((port = portwatch_ports[i]) != NULL) { ipc_port_release_send(port); } } FREE(portwatch_ports, M_TEMP); portwatch_ports = NULL; portwatch_count = 0; } if (error == 0) { error = check_for_signature(p, imgp); if (imgp != NULL && spawn_no_exec && (p->p_lflag & P_LTRACED)) { psignal_vfork(p, p->task, imgp->ip_new_thread, SIGTRAP); } if (error == 0 && !spawn_no_exec) KDBG(BSDDBG_CODE(DBG_BSD_PROC,BSD_PROC_EXEC), p->p_pid); } if (imgp != NULL) { if (imgp->ip_vp) vnode_put(imgp->ip_vp); if (imgp->ip_scriptvp) vnode_put(imgp->ip_scriptvp); if (imgp->ip_strings) execargs_free(imgp); if (imgp->ip_px_sfa != NULL) FREE(imgp->ip_px_sfa, M_TEMP); if (imgp->ip_px_spa != NULL) FREE(imgp->ip_px_spa, M_TEMP); #if CONFIG_PERSONAS if (imgp->ip_px_persona != NULL) FREE(imgp->ip_px_persona, M_TEMP); #endif #if CONFIG_MACF if (imgp->ip_px_smpx != NULL) spawn_free_macpolicyinfo(imgp->ip_px_smpx); if (imgp->ip_execlabelp) mac_cred_label_free(imgp->ip_execlabelp); if (imgp->ip_scriptlabelp) mac_vnode_label_free(imgp->ip_scriptlabelp); if (imgp->ip_cs_error != OS_REASON_NULL) { os_reason_free(imgp->ip_cs_error); imgp->ip_cs_error = OS_REASON_NULL; } #endif } #if CONFIG_DTRACE if (spawn_no_exec) { if (error) { DTRACE_PROC1(spawn__failure, int, error); } else { DTRACE_PROC(spawn__success); dtrace_thread_didexec(imgp->ip_new_thread); } } else { if (error) { DTRACE_PROC1(exec__failure, int, error); } else { DTRACE_PROC(exec__success); } } if ((dtrace_proc_waitfor_hook = dtrace_proc_waitfor_exec_ptr) != NULL) { (*dtrace_proc_waitfor_hook)(p); } #endif if (task_did_exec(current_task())) { set_bsdtask_info(current_task(), NULL); } if (new_task != NULL && task_is_exec_copy(new_task)) { set_bsdtask_info(new_task, NULL); task_terminate_internal(new_task); } if (imgp != NULL && spawn_no_exec) { if (pid != USER_ADDR_NULL) (void)suword(pid, p->p_pid); retval[0] = error; if (error) { proc_list_lock(); p->p_listflag |= P_LIST_DEADPARENT; proc_list_unlock(); proc_lock(p); if (p->p_stat != SZOMB && p->exit_thread == NULL) { p->exit_thread = current_thread(); proc_unlock(p); exit1(p, 1, (int *)NULL); } else { proc_unlock(p); } } } if (task_did_exec(current_task())) { task_terminate_internal(current_task()); } if (imgp != NULL && imgp->ip_new_thread) { task_clear_return_wait(get_threadtask(imgp->ip_new_thread)); thread_deallocate(imgp->ip_new_thread); imgp->ip_new_thread = NULL; } if (new_task) { task_deallocate(new_task); new_task = NULL; } if (should_release_proc_ref) { proc_rele(p); } if (bufp != NULL) { FREE(bufp, M_TEMP); } if (inherit != NULL) { ipc_importance_release(inherit); } return(error); } proc_t proc_exec_switch_task(proc_t p, task_t old_task, task_t new_task, thread_t new_thread) { int error = 0; boolean_t task_active; boolean_t proc_active; boolean_t thread_active; thread_t old_thread = current_thread(); p = proc_refdrain_with_refwait(p, TRUE); assert(get_threadtask(new_thread) == new_task); task_active = task_is_active(new_task); proc_lock(p); proc_active = !(p->p_lflag & P_LEXIT); thread_active = thread_is_active(old_thread); if (proc_active && task_active && thread_active) { error = proc_transstart(p, 1, 0); if (error == 0) { uthread_t new_uthread = get_bsdthread_info(new_thread); uthread_t old_uthread = get_bsdthread_info(current_thread()); p->task = new_task; act_set_astbsd(new_thread); new_uthread->uu_siglist = old_uthread->uu_siglist; new_uthread->uu_sigwait = old_uthread->uu_sigwait; new_uthread->uu_sigmask = old_uthread->uu_sigmask; new_uthread->uu_oldmask = old_uthread->uu_oldmask; new_uthread->uu_vforkmask = old_uthread->uu_vforkmask; new_uthread->uu_exit_reason = old_uthread->uu_exit_reason; #if CONFIG_DTRACE new_uthread->t_dtrace_sig = old_uthread->t_dtrace_sig; new_uthread->t_dtrace_stop = old_uthread->t_dtrace_stop; new_uthread->t_dtrace_resumepid = old_uthread->t_dtrace_resumepid; assert(new_uthread->t_dtrace_scratch == NULL); new_uthread->t_dtrace_scratch = old_uthread->t_dtrace_scratch; old_uthread->t_dtrace_sig = 0; old_uthread->t_dtrace_stop = 0; old_uthread->t_dtrace_resumepid = 0; old_uthread->t_dtrace_scratch = NULL; #endif thread_copy_resource_info(new_thread, current_thread()); old_uthread->uu_exit_reason = NULL; old_uthread->uu_siglist = 0; TAILQ_INSERT_TAIL(&p->p_uthlist, new_uthread, uu_list); TAILQ_REMOVE(&p->p_uthlist, old_uthread, uu_list); task_set_did_exec_flag(old_task); task_clear_exec_copy_flag(new_task); proc_transend(p, 1); } } proc_unlock(p); proc_refwake(p); if (error != 0 || !task_active || !proc_active || !thread_active) { task_terminate_internal(new_task); } return p; } int execve(proc_t p, struct execve_args *uap, int32_t *retval) { struct __mac_execve_args muap; int err; memoryshot(VM_EXECVE, DBG_FUNC_NONE); muap.fname = uap->fname; muap.argp = uap->argp; muap.envp = uap->envp; muap.mac_p = USER_ADDR_NULL; err = __mac_execve(p, &muap, retval); return(err); } int __mac_execve(proc_t p, struct __mac_execve_args *uap, int32_t *retval) { char *bufp = NULL; struct image_params *imgp; struct vnode_attr *vap; struct vnode_attr *origvap; int error; int is_64 = IS_64BIT_PROCESS(p); struct vfs_context context; struct uthread *uthread; task_t new_task = NULL; boolean_t should_release_proc_ref = FALSE; boolean_t exec_done = FALSE; boolean_t in_vfexec = FALSE; void *inherit = NULL; context.vc_thread = current_thread(); context.vc_ucred = kauth_cred_proc_ref(p); MALLOC(bufp, char *, (sizeof(*imgp) + sizeof(*vap) + sizeof(*origvap)), M_TEMP, M_WAITOK | M_ZERO); imgp = (struct image_params *) bufp; if (bufp == NULL) { error = ENOMEM; goto exit_with_error; } vap = (struct vnode_attr *) (bufp + sizeof(*imgp)); origvap = (struct vnode_attr *) (bufp + sizeof(*imgp) + sizeof(*vap)); imgp->ip_user_fname = uap->fname; imgp->ip_user_argv = uap->argp; imgp->ip_user_envv = uap->envp; imgp->ip_vattr = vap; imgp->ip_origvattr = origvap; imgp->ip_vfs_context = &context; imgp->ip_flags = (is_64 ? IMGPF_WAS_64BIT : IMGPF_NONE) | ((p->p_flag & P_DISABLE_ASLR) ? IMGPF_DISABLE_ASLR : IMGPF_NONE); imgp->ip_seg = (is_64 ? UIO_USERSPACE64 : UIO_USERSPACE32); imgp->ip_mac_return = 0; imgp->ip_cs_error = OS_REASON_NULL; uthread = get_bsdthread_info(current_thread()); if (uthread->uu_flag & UT_VFORK) { imgp->ip_flags |= IMGPF_VFORK_EXEC; in_vfexec = TRUE; } else { imgp->ip_flags |= IMGPF_EXEC; imgp->ip_new_thread = fork_create_child(current_task(), NULL, p, FALSE, p->p_flag & P_LP64, TRUE); if (imgp->ip_new_thread == NULL) { error = ENOMEM; goto exit_with_error; } new_task = get_threadtask(imgp->ip_new_thread); context.vc_thread = imgp->ip_new_thread; } #if CONFIG_MACF if (uap->mac_p != USER_ADDR_NULL) { error = mac_execve_enter(uap->mac_p, imgp); if (error) { kauth_cred_unref(&context.vc_ucred); goto exit_with_error; } } #endif error = exec_activate_image(imgp); if (imgp->ip_new_thread != NULL) { new_task = get_threadtask(imgp->ip_new_thread); } if (!error && !in_vfexec) { p = proc_exec_switch_task(p, current_task(), new_task, imgp->ip_new_thread); should_release_proc_ref = TRUE; } kauth_cred_unref(&context.vc_ucred); if (error == -1) error = ENOEXEC; if (!error) { exec_done = TRUE; assert(imgp->ip_new_thread != NULL); exec_resettextvp(p, imgp); error = check_for_signature(p, imgp); } if (imgp->ip_vp != NULLVP) vnode_put(imgp->ip_vp); if (imgp->ip_scriptvp != NULLVP) vnode_put(imgp->ip_scriptvp); if (imgp->ip_strings) execargs_free(imgp); #if CONFIG_MACF if (imgp->ip_execlabelp) mac_cred_label_free(imgp->ip_execlabelp); if (imgp->ip_scriptlabelp) mac_vnode_label_free(imgp->ip_scriptlabelp); #endif if (imgp->ip_cs_error != OS_REASON_NULL) { os_reason_free(imgp->ip_cs_error); imgp->ip_cs_error = OS_REASON_NULL; } if (!error) { error = proc_transstart(p, 0, 0); } if (!error) { task_bank_init(get_threadtask(imgp->ip_new_thread)); proc_transend(p, 0); thread_affinity_exec(current_thread()); thread_t main_thread = imgp->ip_new_thread; task_set_main_thread_qos(new_task, main_thread); DTRACE_PROC(exec__success); #if CONFIG_DTRACE if ((dtrace_proc_waitfor_hook = dtrace_proc_waitfor_exec_ptr) != NULL) (*dtrace_proc_waitfor_hook)(p); #endif if (in_vfexec) { vfork_return(p, retval, p->p_pid); } } else { DTRACE_PROC1(exec__failure, int, error); } exit_with_error: if (task_did_exec(current_task())) { set_bsdtask_info(current_task(), NULL); } if (new_task != NULL && task_is_exec_copy(new_task)) { set_bsdtask_info(new_task, NULL); task_terminate_internal(new_task); } if (error == 0 && task_did_exec(current_task())) { inherit = ipc_importance_exec_switch_task(current_task(), get_threadtask(imgp->ip_new_thread)); } if (imgp != NULL) { if (task_did_exec(current_task())) { task_terminate_internal(current_task()); } if (imgp->ip_new_thread) { task_clear_return_wait(get_threadtask(imgp->ip_new_thread)); thread_deallocate(imgp->ip_new_thread); imgp->ip_new_thread = NULL; } } if (new_task) { task_deallocate(new_task); new_task = NULL; } if (should_release_proc_ref) { proc_rele(p); } if (bufp != NULL) { FREE(bufp, M_TEMP); } if (inherit != NULL) { ipc_importance_release(inherit); } return(error); } static int copyinptr(user_addr_t froma, user_addr_t *toptr, int ptr_size) { int error; if (ptr_size == 4) { unsigned int i; error = copyin(froma, &i, 4); *toptr = CAST_USER_ADDR_T(i); } else { error = copyin(froma, toptr, 8); } return (error); } static int copyoutptr(user_addr_t ua, user_addr_t ptr, int ptr_size) { int error; if (ptr_size == 4) { unsigned int i = CAST_DOWN_EXPLICIT(unsigned int,ua); error = copyout(&i, ptr, 4); } else { error = copyout(&ua, ptr, 8); } return (error); } static int exec_copyout_strings(struct image_params *imgp, user_addr_t *stackp) { proc_t p = vfs_context_proc(imgp->ip_vfs_context); int ptr_size = (imgp->ip_flags & IMGPF_IS_64BIT) ? 8 : 4; int ptr_area_size; void *ptr_buffer_start, *ptr_buffer; int string_size; user_addr_t string_area; user_addr_t ptr_area; user_addr_t argc_area; user_addr_t stack; int error; unsigned i; struct copyout_desc { char *start_string; int count; #if CONFIG_DTRACE user_addr_t *dtrace_cookie; #endif boolean_t null_term; } descriptors[] = { { .start_string = imgp->ip_startargv, .count = imgp->ip_argc, #if CONFIG_DTRACE .dtrace_cookie = &p->p_dtrace_argv, #endif .null_term = TRUE }, { .start_string = imgp->ip_endargv, .count = imgp->ip_envc, #if CONFIG_DTRACE .dtrace_cookie = &p->p_dtrace_envp, #endif .null_term = TRUE }, { .start_string = imgp->ip_strings, .count = 1, #if CONFIG_DTRACE .dtrace_cookie = NULL, #endif .null_term = FALSE }, { .start_string = imgp->ip_endenvv, .count = imgp->ip_applec - 1, #if CONFIG_DTRACE .dtrace_cookie = NULL, #endif .null_term = TRUE } }; stack = *stackp; if (imgp->ip_strspace % ptr_size != 0) { error = EINVAL; goto bad; } string_size = imgp->ip_strendp - imgp->ip_strings; stack -= string_size; string_area = stack; ptr_area_size = (imgp->ip_argc + imgp->ip_envc + imgp->ip_applec + 3) * ptr_size; stack -= ptr_area_size; ptr_area = stack; ptr_buffer_start = ptr_buffer = (void *)imgp->ip_strendp; stack -= ptr_size; argc_area = stack; proc_lock(p); p->p_argc = imgp->ip_argc; p->p_argslen = (int)(*stackp - string_area); proc_unlock(p); *stackp = stack; error = copyout(imgp->ip_strings, string_area, string_size); if (error) goto bad; for (i = 0; i < sizeof(descriptors)/sizeof(descriptors[0]); i++) { char *cur_string = descriptors[i].start_string; int j; #if CONFIG_DTRACE if (descriptors[i].dtrace_cookie) { proc_lock(p); *descriptors[i].dtrace_cookie = ptr_area + ((uintptr_t)ptr_buffer - (uintptr_t)ptr_buffer_start); proc_unlock(p); } #endif for (j = 0; j < descriptors[i].count; j++) { user_addr_t cur_address = string_area + (cur_string - imgp->ip_strings); if (ptr_size == 8) { *(uint64_t *)ptr_buffer = (uint64_t)cur_address; } else { *(uint32_t *)ptr_buffer = (uint32_t)cur_address; } ptr_buffer = (void *)((uintptr_t)ptr_buffer + ptr_size); cur_string += strlen(cur_string) + 1; } if (descriptors[i].null_term) { if (ptr_size == 8) { *(uint64_t *)ptr_buffer = 0ULL; } else { *(uint32_t *)ptr_buffer = 0; } ptr_buffer = (void *)((uintptr_t)ptr_buffer + ptr_size); } } error = copyout(ptr_buffer_start, ptr_area, ptr_area_size); if (error) goto bad; error = copyoutptr((user_addr_t)imgp->ip_argc, argc_area, ptr_size); if (error) goto bad; bad: return(error); } static int exec_extract_strings(struct image_params *imgp) { int error = 0; int ptr_size = (imgp->ip_flags & IMGPF_WAS_64BIT) ? 8 : 4; int new_ptr_size = (imgp->ip_flags & IMGPF_IS_64BIT) ? 8 : 4; user_addr_t argv = imgp->ip_user_argv; user_addr_t envv = imgp->ip_user_envv; while (imgp->ip_strspace % new_ptr_size != 0) { *imgp->ip_strendp++ = '\\0'; imgp->ip_strspace--; } imgp->ip_startargv = imgp->ip_strendp; imgp->ip_argc = 0; if((imgp->ip_flags & IMGPF_INTERPRET) != 0) { user_addr_t arg; char *argstart, *ch; argstart = imgp->ip_interp_buffer; while (argstart) { ch = argstart; while (*ch && !IS_WHITESPACE(*ch)) { ch++; } if (*ch == '\\0') { error = exec_add_user_string(imgp, CAST_USER_ADDR_T(argstart), UIO_SYSSPACE, TRUE); argstart = NULL; } else { *ch = '\\0'; error = exec_add_user_string(imgp, CAST_USER_ADDR_T(argstart), UIO_SYSSPACE, TRUE); argstart = ch + 1; while (IS_WHITESPACE(*argstart)) { argstart++; } } if (error) goto bad; if (imgp->ip_argspace < new_ptr_size) { error = E2BIG; goto bad; } imgp->ip_argspace -= new_ptr_size; imgp->ip_argc++; } if (argv != 0LL) { error = copyinptr(argv, &arg, ptr_size); if (error) goto bad; if (arg != 0LL) { argv += ptr_size; } } if (imgp->ip_interp_sugid_fd != -1) { char temp[19]; snprintf(temp, sizeof(temp), \"/dev/fd/%d\", imgp->ip_interp_sugid_fd); error = exec_add_user_string(imgp, CAST_USER_ADDR_T(temp), UIO_SYSSPACE, TRUE); } else { error = exec_add_user_string(imgp, imgp->ip_user_fname, imgp->ip_seg, TRUE); } if (error) goto bad; if (imgp->ip_argspace < new_ptr_size) { error = E2BIG; goto bad; } imgp->ip_argspace -= new_ptr_size; imgp->ip_argc++; } while (argv != 0LL) { user_addr_t arg; error = copyinptr(argv, &arg, ptr_size); if (error) goto bad; if (arg == 0LL) { break; } argv += ptr_size; error = exec_add_user_string(imgp, arg, imgp->ip_seg, TRUE); if (error) goto bad; if (imgp->ip_argspace < new_ptr_size) { error = E2BIG; goto bad; } imgp->ip_argspace -= new_ptr_size; imgp->ip_argc++; } if (imgp->ip_argspace < new_ptr_size) { error = E2BIG; goto bad; } imgp->ip_argspace -= new_ptr_size; imgp->ip_endargv = imgp->ip_strendp; imgp->ip_envc = 0; while (envv != 0LL) { user_addr_t env; error = copyinptr(envv, &env, ptr_size); if (error) goto bad; envv += ptr_size; if (env == 0LL) { break; } error = exec_add_user_string(imgp, env, imgp->ip_seg, TRUE); if (error) goto bad; if (imgp->ip_argspace < new_ptr_size) { error = E2BIG; goto bad; } imgp->ip_argspace -= new_ptr_size; imgp->ip_envc++; } if (imgp->ip_argspace < new_ptr_size) { error = E2BIG; goto bad; } imgp->ip_argspace -= new_ptr_size; while (imgp->ip_strspace % new_ptr_size != 0) { if (imgp->ip_argspace < 1) { error = E2BIG; goto bad; } *imgp->ip_strendp++ = '\\0'; imgp->ip_strspace--; imgp->ip_argspace--; } imgp->ip_endenvv = imgp->ip_strendp; bad: return error; } #define GUARD_VALUES 1 #define GUARD_KEY \"stack_guard=\" #define ENTROPY_VALUES 2 #define ENTROPY_KEY \"malloc_entropy=\" #define NANO_ENGAGE_KEY \"MallocNanoZone=1\" #define PFZ_KEY \"pfz=\" extern user32_addr_t commpage_text32_location; extern user64_addr_t commpage_text64_location; #define MAIN_STACK_VALUES 4 #define MAIN_STACK_KEY \"main_stack=\" #define HEX_STR_LEN 18 // 64-bit hex value \"0x0123456701234567\" static int exec_add_entropy_key(struct image_params *imgp, const char *key, int values, boolean_t embedNUL) { const int limit = 8; uint64_t entropy[limit]; char str[strlen(key) + (HEX_STR_LEN + 1) * limit + 1]; if (values > limit) { values = limit; } read_random(entropy, sizeof(entropy[0]) * values); if (embedNUL) { entropy[0] &= ~(0xffull << 8); } int len = snprintf(str, sizeof(str), \"%s0x%llx\", key, entropy[0]); int remaining = sizeof(str) - len; for (int i = 1; i < values && remaining > 0; ++i) { int start = sizeof(str) - remaining; len = snprintf(&str[start], remaining, \",0x%llx\", entropy[i]); remaining -= len; } return exec_add_user_string(imgp, CAST_USER_ADDR_T(str), UIO_SYSSPACE, FALSE); } static int exec_add_apple_strings(struct image_params *imgp, const load_result_t *load_result) { int error; int img_ptr_size = (imgp->ip_flags & IMGPF_IS_64BIT) ? 8 : 4; imgp->ip_applec = 1; { char pfz_string[strlen(PFZ_KEY) + HEX_STR_LEN + 1]; if (img_ptr_size == 8) { snprintf(pfz_string, sizeof(pfz_string), PFZ_KEY \"0x%llx\", commpage_text64_location); } else { snprintf(pfz_string, sizeof(pfz_string), PFZ_KEY \"0x%x\", commpage_text32_location); } error = exec_add_user_string(imgp, CAST_USER_ADDR_T(pfz_string), UIO_SYSSPACE, FALSE); if (error) { goto bad; } imgp->ip_applec++; } if (imgp->ip_px_sa) { int proc_flags = (((struct _posix_spawnattr *) imgp->ip_px_sa)->psa_flags); if ((proc_flags & _POSIX_SPAWN_NANO_ALLOCATOR) == _POSIX_SPAWN_NANO_ALLOCATOR) { const char *nano_string = NANO_ENGAGE_KEY; error = exec_add_user_string(imgp, CAST_USER_ADDR_T(nano_string), UIO_SYSSPACE, FALSE); if (error){ goto bad; } imgp->ip_applec++; } } error = exec_add_entropy_key(imgp, GUARD_KEY, GUARD_VALUES, TRUE); if (error) { goto bad; } imgp->ip_applec++; error = exec_add_entropy_key(imgp, ENTROPY_KEY, ENTROPY_VALUES, FALSE); if (error) { goto bad; } imgp->ip_applec++; if (load_result->unixproc) { char stack_string[strlen(MAIN_STACK_KEY) + (HEX_STR_LEN + 1) * MAIN_STACK_VALUES + 1]; snprintf(stack_string, sizeof(stack_string), MAIN_STACK_KEY \"0x%llx,0x%llx,0x%llx,0x%llx\", (uint64_t)load_result->user_stack, (uint64_t)load_result->user_stack_size, (uint64_t)load_result->user_stack_alloc, (uint64_t)load_result->user_stack_alloc_size); error = exec_add_user_string(imgp, CAST_USER_ADDR_T(stack_string), UIO_SYSSPACE, FALSE); if (error) { goto bad; } imgp->ip_applec++; } while (imgp->ip_strspace % img_ptr_size != 0) { *imgp->ip_strendp++ = '\\0'; imgp->ip_strspace--; } bad: return error; } #define unix_stack_size(p) (p->p_rlimit[RLIMIT_STACK].rlim_cur) static int exec_check_permissions(struct image_params *imgp) { struct vnode *vp = imgp->ip_vp; struct vnode_attr *vap = imgp->ip_vattr; proc_t p = vfs_context_proc(imgp->ip_vfs_context); int error; kauth_action_t action; if (!vnode_isreg(vp)) return (EACCES); VATTR_INIT(vap); VATTR_WANTED(vap, va_uid); VATTR_WANTED(vap, va_gid); VATTR_WANTED(vap, va_mode); VATTR_WANTED(vap, va_fsid); VATTR_WANTED(vap, va_fileid); VATTR_WANTED(vap, va_data_size); if ((error = vnode_getattr(vp, vap, imgp->ip_vfs_context)) != 0) return (error); if (!vfs_authopaque(vnode_mount(vp)) && ((vap->va_mode & (S_IXUSR | S_IXGRP | S_IXOTH)) == 0)) return (EACCES); if (vap->va_data_size == 0) return (ENOEXEC); imgp->ip_arch_offset = (user_size_t)0; imgp->ip_arch_size = vap->va_data_size; if ((vp->v_mount->mnt_flag & MNT_NOSUID) || (p->p_lflag & P_LTRACED)) vap->va_mode &= ~(VSUID | VSGID); if (vap->va_mode & (VSUID | VSGID)) imgp->ip_flags &= ~(IMGPF_ALLOW_DATA_EXEC | IMGPF_DISABLE_ASLR); #if CONFIG_MACF error = mac_vnode_check_exec(imgp->ip_vfs_context, vp, imgp); if (error) return (error); #endif action = KAUTH_VNODE_EXECUTE; if (p->p_lflag & P_LTRACED) action |= KAUTH_VNODE_READ_DATA; if ((error = vnode_authorize(vp, NULL, action, imgp->ip_vfs_context)) != 0) return (error); #if 0 vnode_lock(vp); if (vp->v_writecount) { panic(\"going to return ETXTBSY %x\", vp); vnode_unlock(vp); return (ETXTBSY); } vnode_unlock(vp); #endif return (error); } static int exec_handle_sugid(struct image_params *imgp) { proc_t p = vfs_context_proc(imgp->ip_vfs_context); kauth_cred_t cred = vfs_context_ucred(imgp->ip_vfs_context); kauth_cred_t my_cred, my_new_cred; int i; int leave_sugid_clear = 0; int mac_reset_ipc = 0; int error = 0; task_t task = NULL; #if CONFIG_MACF int mac_transition, disjoint_cred = 0; int label_update_return = 0; mac_transition = mac_cred_check_label_update_execve( imgp->ip_vfs_context, imgp->ip_vp, imgp->ip_arch_offset, imgp->ip_scriptvp, imgp->ip_scriptlabelp, imgp->ip_execlabelp, p, imgp->ip_px_smpx); #endif OSBitAndAtomic(~((uint32_t)P_SUGID), &p->p_flag); if (((imgp->ip_origvattr->va_mode & VSUID) != 0 && kauth_cred_getuid(cred) != imgp->ip_origvattr->va_uid) || ((imgp->ip_origvattr->va_mode & VSGID) != 0 && ((kauth_cred_ismember_gid(cred, imgp->ip_origvattr->va_gid, &leave_sugid_clear) || !leave_sugid_clear) || (kauth_cred_getgid(cred) != imgp->ip_origvattr->va_gid)))) { #if CONFIG_MACF handle_mac_transition: #endif while (imgp->ip_origvattr->va_mode & VSUID) { my_cred = kauth_cred_proc_ref(p); my_new_cred = kauth_cred_setresuid(my_cred, KAUTH_UID_NONE, imgp->ip_origvattr->va_uid, imgp->ip_origvattr->va_uid, KAUTH_UID_NONE); if (my_new_cred == my_cred) { kauth_cred_unref(&my_cred); break; } proc_ucred_lock(p); if (p->p_ucred != my_cred) { proc_ucred_unlock(p); kauth_cred_unref(&my_new_cred); continue; } p->p_ucred = my_new_cred; PROC_UPDATE_CREDS_ONPROC(p); proc_ucred_unlock(p); kauth_cred_unref(&my_cred); break; } while (imgp->ip_origvattr->va_mode & VSGID) { my_cred = kauth_cred_proc_ref(p); my_new_cred = kauth_cred_setresgid(my_cred, KAUTH_GID_NONE, imgp->ip_origvattr->va_gid, imgp->ip_origvattr->va_gid); if (my_new_cred == my_cred) { kauth_cred_unref(&my_cred); break; } proc_ucred_lock(p); if (p->p_ucred != my_cred) { proc_ucred_unlock(p); kauth_cred_unref(&my_new_cred); continue; } p->p_ucred = my_new_cred; PROC_UPDATE_CREDS_ONPROC(p); proc_ucred_unlock(p); kauth_cred_unref(&my_cred); break; } #if CONFIG_MACF if (mac_transition) { thread_t thread = current_thread(); thread_enable_send_importance(thread, TRUE); kauth_proc_label_update_execve(p, imgp->ip_vfs_context, imgp->ip_vp, imgp->ip_arch_offset, imgp->ip_scriptvp, imgp->ip_scriptlabelp, imgp->ip_execlabelp, &imgp->ip_csflags, imgp->ip_px_smpx, &disjoint_cred, &label_update_return); thread_enable_send_importance(thread, FALSE); if (disjoint_cred) { leave_sugid_clear = 0; } imgp->ip_mac_return = label_update_return; } mac_reset_ipc = mac_proc_check_inherit_ipc_ports(p, p->p_textvp, p->p_textoff, imgp->ip_vp, imgp->ip_arch_offset, imgp->ip_scriptvp); #endif if (mac_reset_ipc || !leave_sugid_clear) { ipc_task_reset((imgp->ip_new_thread != NULL) ? get_threadtask(imgp->ip_new_thread) : p->task); ipc_thread_reset((imgp->ip_new_thread != NULL) ? imgp->ip_new_thread : current_thread()); } if (!leave_sugid_clear) { OSBitOrAtomic(P_SUGID, &p->p_flag); for (i = 0; i < 3; i++) { if (p->p_fd->fd_ofiles[i] != NULL) continue; struct fileproc *fp; int indx; int flag; struct nameidata *ndp = NULL; if (i == 0) flag = FREAD; else flag = FWRITE; if ((error = falloc(p, &fp, &indx, imgp->ip_vfs_context)) != 0) continue; MALLOC(ndp, struct nameidata *, sizeof(*ndp), M_TEMP, M_WAITOK | M_ZERO); if (ndp == NULL) { fp_free(p, indx, fp); error = ENOMEM; break; } NDINIT(ndp, LOOKUP, OP_OPEN, FOLLOW, UIO_SYSSPACE, CAST_USER_ADDR_T(\"/dev/null\"), imgp->ip_vfs_context); if ((error = vn_open(ndp, flag, 0)) != 0) { fp_free(p, indx, fp); FREE(ndp, M_TEMP); break; } struct fileglob *fg = fp->f_fglob; fg->fg_flag = flag; fg->fg_ops = &vnops; fg->fg_data = ndp->ni_vp; vnode_put(ndp->ni_vp); proc_fdlock(p); procfdtbl_releasefd(p, indx, NULL); fp_drop(p, indx, fp, 1); proc_fdunlock(p); FREE(ndp, M_TEMP); } } } #if CONFIG_MACF else { if (mac_transition) { leave_sugid_clear = 1; goto handle_mac_transition; } } #endif for (;;) { my_cred = kauth_cred_proc_ref(p); my_new_cred = kauth_cred_setsvuidgid(my_cred, kauth_cred_getuid(my_cred), kauth_cred_getgid(my_cred)); if (my_new_cred == my_cred) { kauth_cred_unref(&my_cred); break; } proc_ucred_lock(p); if (p->p_ucred != my_cred) { proc_ucred_unlock(p); kauth_cred_unref(&my_new_cred); continue; } p->p_ucred = my_new_cred; PROC_UPDATE_CREDS_ONPROC(p); proc_ucred_unlock(p); kauth_cred_unref(&my_cred); break; } p->p_idversion++; if (imgp->ip_new_thread != NULL) { task = get_threadtask(imgp->ip_new_thread); } else { task = p->task; } set_security_token_task_internal(p, task); return(error); } static kern_return_t create_unix_stack(vm_map_t map, load_result_t* load_result, proc_t p) { mach_vm_size_t size, prot_size; mach_vm_offset_t addr, prot_addr; kern_return_t kr; mach_vm_address_t user_stack = load_result->user_stack; proc_lock(p); p->user_stack = user_stack; proc_unlock(p); if (load_result->user_stack_alloc_size > 0) { if (mach_vm_round_page_overflow(load_result->user_stack_alloc_size, &size)) { return KERN_INVALID_ARGUMENT; } addr = mach_vm_trunc_page(load_result->user_stack - size); kr = mach_vm_allocate(map, &addr, size, VM_MAKE_TAG(VM_MEMORY_STACK) | VM_FLAGS_FIXED); if (kr != KERN_SUCCESS) { addr = 0; kr = mach_vm_allocate(map, &addr, size, VM_MAKE_TAG(VM_MEMORY_STACK) | VM_FLAGS_ANYWHERE); if (kr != KERN_SUCCESS) { return kr; } user_stack = addr + size; load_result->user_stack = user_stack; proc_lock(p); p->user_stack = user_stack; proc_unlock(p); } load_result->user_stack_alloc = addr; if (load_result->user_stack_size == 0) { load_result->user_stack_size = unix_stack_size(p); prot_size = mach_vm_trunc_page(size - load_result->user_stack_size); } else { prot_size = PAGE_SIZE; } prot_addr = addr; kr = mach_vm_protect(map, prot_addr, prot_size, FALSE, VM_PROT_NONE); if (kr != KERN_SUCCESS) { (void)mach_vm_deallocate(map, addr, size); return kr; } } return KERN_SUCCESS; } #include <sys/reboot.h> static int load_init_program_at_path(proc_t p, user_addr_t scratch_addr, const char* path) { int retval[2]; int error; struct execve_args init_exec_args; user_addr_t argv0 = USER_ADDR_NULL, argv1 = USER_ADDR_NULL; assert(p); assert(scratch_addr); assert(path); size_t path_length = strlen(path) + 1; argv0 = scratch_addr; error = copyout(path, argv0, path_length); if (error) return error; scratch_addr = USER_ADDR_ALIGN(scratch_addr + path_length, sizeof(user_addr_t)); if (boothowto & RB_SINGLE) { const char *init_args = \"-s\"; size_t init_args_length = strlen(init_args)+1; argv1 = scratch_addr; error = copyout(init_args, argv1, init_args_length); if (error) return error; scratch_addr = USER_ADDR_ALIGN(scratch_addr + init_args_length, sizeof(user_addr_t)); } if (proc_is64bit(p)) { user64_addr_t argv64bit[3]; argv64bit[0] = argv0; argv64bit[1] = argv1; argv64bit[2] = USER_ADDR_NULL; error = copyout(argv64bit, scratch_addr, sizeof(argv64bit)); if (error) return error; } else { user32_addr_t argv32bit[3]; argv32bit[0] = (user32_addr_t)argv0; argv32bit[1] = (user32_addr_t)argv1; argv32bit[2] = USER_ADDR_NULL; error = copyout(argv32bit, scratch_addr, sizeof(argv32bit)); if (error) return error; } init_exec_args.fname = argv0; init_exec_args.argp = scratch_addr; init_exec_args.envp = USER_ADDR_NULL; set_security_token(p); return execve(p, &init_exec_args, retval); } static const char * init_programs[] = { #if DEBUG \"/usr/local/sbin/launchd.debug\", #endif #if DEVELOPMENT || DEBUG \"/usr/local/sbin/launchd.development\", #endif \"/sbin/launchd\", }; void load_init_program(proc_t p) { uint32_t i; int error; vm_map_t map = current_map(); mach_vm_offset_t scratch_addr = 0; mach_vm_size_t map_page_size = vm_map_page_size(map); (void) mach_vm_allocate(map, &scratch_addr, map_page_size, VM_FLAGS_ANYWHERE); #if CONFIG_MEMORYSTATUS && CONFIG_JETSAM (void) memorystatus_init_at_boot_snapshot(); #endif #if DEBUG || DEVELOPMENT char launchd_suffix[64]; if (PE_parse_boot_argn(\"launchdsuffix\", launchd_suffix, sizeof(launchd_suffix))) { char launchd_path[128]; boolean_t is_release_suffix = ((launchd_suffix[0] == 0) || (strcmp(launchd_suffix, \"release\") == 0)); if (is_release_suffix) { error = load_init_program_at_path(p, (user_addr_t)scratch_addr, \"/sbin/launchd\"); if (!error) return; panic(\"Process 1 exec of launchd.release failed, errno %d\", error); } else { strlcpy(launchd_path, \"/usr/local/sbin/launchd.\", sizeof(launchd_path)); strlcat(launchd_path, launchd_suffix, sizeof(launchd_path)); if (!load_init_program_at_path(p, (user_addr_t)scratch_addr, launchd_path)) { return; } } } #endif error = ENOENT; for (i = 0; i < sizeof(init_programs)/sizeof(init_programs[0]); i++) { error = load_init_program_at_path(p, (user_addr_t)scratch_addr, init_programs[i]); if (!error) return; } panic(\"Process 1 exec of %s failed, errno %d\", ((i == 0) ? \"<null>\" : init_programs[i-1]), error); } static int load_return_to_errno(load_return_t lrtn) { switch (lrtn) { case LOAD_SUCCESS: return 0; case LOAD_BADARCH: return EBADARCH; case LOAD_BADMACHO: case LOAD_BADMACHO_UPX: return EBADMACHO; case LOAD_SHLIB: return ESHLIBVERS; case LOAD_NOSPACE: case LOAD_RESOURCE: return ENOMEM; case LOAD_PROTECT: return EACCES; case LOAD_ENOENT: return ENOENT; case LOAD_IOERROR: return EIO; case LOAD_FAILURE: case LOAD_DECRYPTFAIL: default: return EBADEXEC; } } #include <mach/mach_types.h> #include <mach/vm_prot.h> #include <mach/semaphore.h> #include <mach/sync_policy.h> #include <kern/clock.h> #include <mach/kern_return.h> static int execargs_waiters = 0; lck_mtx_t *execargs_cache_lock; static void execargs_lock_lock(void) { lck_mtx_lock_spin(execargs_cache_lock); } static void execargs_lock_unlock(void) { lck_mtx_unlock(execargs_cache_lock); } static wait_result_t execargs_lock_sleep(void) { return(lck_mtx_sleep(execargs_cache_lock, LCK_SLEEP_DEFAULT, &execargs_free_count, THREAD_INTERRUPTIBLE)); } static kern_return_t execargs_purgeable_allocate(char **execarg_address) { kern_return_t kr = vm_allocate(bsd_pageable_map, (vm_offset_t *)execarg_address, BSD_PAGEABLE_SIZE_PER_EXEC, VM_FLAGS_ANYWHERE | VM_FLAGS_PURGABLE); assert(kr == KERN_SUCCESS); return kr; } static kern_return_t execargs_purgeable_reference(void *execarg_address) { int state = VM_PURGABLE_NONVOLATILE; kern_return_t kr = vm_purgable_control(bsd_pageable_map, (vm_offset_t) execarg_address, VM_PURGABLE_SET_STATE, &state); assert(kr == KERN_SUCCESS); return kr; } static kern_return_t execargs_purgeable_volatilize(void *execarg_address) { int state = VM_PURGABLE_VOLATILE | VM_PURGABLE_ORDERING_OBSOLETE; kern_return_t kr; kr = vm_purgable_control(bsd_pageable_map, (vm_offset_t) execarg_address, VM_PURGABLE_SET_STATE, &state); assert(kr == KERN_SUCCESS); return kr; } static void execargs_wakeup_waiters(void) { thread_wakeup(&execargs_free_count); } static int execargs_alloc(struct image_params *imgp) { kern_return_t kret; wait_result_t res; int i, cache_index = -1; execargs_lock_lock(); while (execargs_free_count == 0) { execargs_waiters++; res = execargs_lock_sleep(); execargs_waiters--; if (res != THREAD_AWAKENED) { execargs_lock_unlock(); return (EINTR); } } execargs_free_count--; for (i = 0; i < execargs_cache_size; i++) { vm_offset_t element = execargs_cache[i]; if (element) { cache_index = i; imgp->ip_strings = (char *)(execargs_cache[i]); execargs_cache[i] = 0; break; } } assert(execargs_free_count >= 0); execargs_lock_unlock(); if (cache_index == -1) { kret = execargs_purgeable_allocate(&imgp->ip_strings); } else kret = execargs_purgeable_reference(imgp->ip_strings); assert(kret == KERN_SUCCESS); if (kret != KERN_SUCCESS) { return (ENOMEM); } imgp->ip_vdata = imgp->ip_strings + ( NCARGS + PAGE_SIZE ); imgp->ip_strendp = imgp->ip_strings; imgp->ip_argspace = NCARGS; imgp->ip_strspace = ( NCARGS + PAGE_SIZE ); return (0); } static int execargs_free(struct image_params *imgp) { kern_return_t kret; int i; boolean_t needs_wakeup = FALSE; kret = execargs_purgeable_volatilize(imgp->ip_strings); execargs_lock_lock(); execargs_free_count++; for (i = 0; i < execargs_cache_size; i++) { vm_offset_t element = execargs_cache[i]; if (element == 0) { execargs_cache[i] = (vm_offset_t) imgp->ip_strings; imgp->ip_strings = NULL; break; } } assert(imgp->ip_strings == NULL); if (execargs_waiters > 0) needs_wakeup = TRUE; execargs_lock_unlock(); if (needs_wakeup == TRUE) execargs_wakeup_waiters(); return ((kret == KERN_SUCCESS ? 0 : EINVAL)); } static void exec_resettextvp(proc_t p, struct image_params *imgp) { vnode_t vp; off_t offset; vnode_t tvp = p->p_textvp; int ret; vp = imgp->ip_vp; offset = imgp->ip_arch_offset; if (vp == NULLVP) panic(\"exec_resettextvp: expected valid vp\"); ret = vnode_ref(vp); proc_lock(p); if (ret == 0) { p->p_textvp = vp; p->p_textoff = offset; } else { p->p_textvp = NULLVP; p->p_textoff = 0; } proc_unlock(p); if ( tvp != NULLVP) { if (vnode_getwithref(tvp) == 0) { vnode_rele(tvp); vnode_put(tvp); } } } static boolean_t taskgated_required(proc_t p, boolean_t *require_success) { size_t length; void *blob; int error; if (cs_debug > 2) csvnode_print_debug(p->p_textvp); const int can_skip_taskgated = csproc_get_platform_binary(p) && !csproc_get_platform_path(p); if (can_skip_taskgated) { if (cs_debug) printf(\"taskgated not required for: %s\\n\", p->p_name); *require_success = FALSE; return FALSE; } if ((p->p_csflags & CS_VALID) == 0) { *require_success = FALSE; return TRUE; } error = cs_entitlements_blob_get(p, &blob, &length); if (error == 0 && blob != NULL) { if ((boothowto & RB_SINGLE) == 0) *require_success = TRUE; if (p == initproc) { *require_success = FALSE; return FALSE; } if (cs_debug) printf(\"taskgated required for: %s\\n\", p->p_name); return TRUE; } *require_success = FALSE; return FALSE; } __attribute__((noinline)) int __EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__(mach_port_t task_access_port, int32_t new_pid) { return find_code_signature(task_access_port, new_pid); } static int check_for_signature(proc_t p, struct image_params *imgp) { mach_port_t port = NULL; kern_return_t kr = KERN_FAILURE; int error = EACCES; boolean_t unexpected_failure = FALSE; unsigned char hash[SHA1_RESULTLEN]; boolean_t require_success = FALSE; int spawn = (imgp->ip_flags & IMGPF_SPAWN); int vfexec = (imgp->ip_flags & IMGPF_VFORK_EXEC); os_reason_t signature_failure_reason = OS_REASON_NULL; proc_lock(p); p->p_csflags = imgp->ip_csflags; proc_unlock(p); if(p->p_csflags & (CS_HARD|CS_KILL)) { vm_map_switch_protect(get_task_map(p->task), TRUE); } if (imgp->ip_mac_return != 0) { KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_SECURITY_POLICY, 0, 0); signature_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_SECURITY_POLICY); error = imgp->ip_mac_return; unexpected_failure = TRUE; goto done; } if (imgp->ip_cs_error != OS_REASON_NULL) { signature_failure_reason = imgp->ip_cs_error; imgp->ip_cs_error = OS_REASON_NULL; error = EACCES; goto done; } if (!taskgated_required(p, &require_success)) { error = 0; goto done; } kr = task_get_task_access_port(p->task, &port); if (KERN_SUCCESS != kr || !IPC_PORT_VALID(port)) { error = 0; if (require_success) { KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_CODESIGNING, CODESIGNING_EXIT_REASON_TASK_ACCESS_PORT, 0, 0); signature_failure_reason = os_reason_create(OS_REASON_CODESIGNING, CODESIGNING_EXIT_REASON_TASK_ACCESS_PORT); error = EACCES; } goto done; } kr = __EXEC_WAITING_ON_TASKGATED_CODE_SIGNATURE_UPCALL__(port, p->p_pid); switch (kr) { case KERN_SUCCESS: error = 0; break; case KERN_FAILURE: error = EACCES; KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_CODESIGNING, CODESIGNING_EXIT_REASON_TASKGATED_INVALID_SIG, 0, 0); signature_failure_reason = os_reason_create(OS_REASON_CODESIGNING, CODESIGNING_EXIT_REASON_TASKGATED_INVALID_SIG); goto done; default: error = EACCES; KERNEL_DEBUG_CONSTANT(BSDDBG_CODE(DBG_BSD_PROC, BSD_PROC_EXITREASON_CREATE) | DBG_FUNC_NONE, p->p_pid, OS_REASON_EXEC, EXEC_EXIT_REASON_TASKGATED_OTHER, 0, 0); signature_failure_reason = os_reason_create(OS_REASON_EXEC, EXEC_EXIT_REASON_TASKGATED_OTHER); unexpected_failure = TRUE; goto done; } if (p->p_textvp != NULLVP) { if (0 == ubc_cs_getcdhash(p->p_textvp, p->p_textoff, hash)) { proc_lock(p); p->p_csflags |= CS_VALID; proc_unlock(p); } } done: if (0 != error) { if (!unexpected_failure) p->p_csflags |= CS_KILLED; if (vfexec || spawn) { assert(signature_failure_reason != OS_REASON_NULL); psignal_vfork_with_reason(p, p->task, imgp->ip_new_thread, SIGKILL, signature_failure_reason); signature_failure_reason = OS_REASON_NULL; error = 0; } else { assert(signature_failure_reason != OS_REASON_NULL); psignal_with_reason(p, SIGKILL, signature_failure_reason); signature_failure_reason = OS_REASON_NULL; } } assert(signature_failure_reason == OS_REASON_NULL); return error; } static void exec_prefault_data(proc_t p __unused, struct image_params *imgp, load_result_t *load_result) { int ret; size_t expected_all_image_infos_size; vm_fault(current_map(), vm_map_trunc_page(load_result->entry_point, vm_map_page_mask(current_map())), VM_PROT_READ | VM_PROT_EXECUTE, FALSE, THREAD_UNINT, NULL, 0); if (imgp->ip_flags & IMGPF_IS_64BIT) { expected_all_image_infos_size = sizeof(struct user64_dyld_all_image_infos); } else { expected_all_image_infos_size = sizeof(struct user32_dyld_all_image_infos); } if (load_result->dynlinker && load_result->all_image_info_addr && load_result->all_image_info_size >= expected_all_image_infos_size) { union { struct user64_dyld_all_image_infos infos64; struct user32_dyld_all_image_infos infos32; } all_image_infos; vm_fault(current_map(), vm_map_trunc_page(load_result->all_image_info_addr, vm_map_page_mask(current_map())), VM_PROT_READ | VM_PROT_WRITE, FALSE, THREAD_UNINT, NULL, 0); if ((load_result->all_image_info_addr & PAGE_MASK) + expected_all_image_infos_size > PAGE_SIZE) { vm_fault(current_map(), vm_map_trunc_page(load_result->all_image_info_addr + expected_all_image_infos_size - 1, vm_map_page_mask(current_map())), VM_PROT_READ | VM_PROT_WRITE, FALSE, THREAD_UNINT, NULL, 0); } ret = copyin(load_result->all_image_info_addr, &all_image_infos, expected_all_image_infos_size); if (ret == 0 && all_image_infos.infos32.version >= 9) { user_addr_t notification_address; user_addr_t dyld_image_address; user_addr_t dyld_version_address; user_addr_t dyld_all_image_infos_address; user_addr_t dyld_slide_amount; if (imgp->ip_flags & IMGPF_IS_64BIT) { notification_address = all_image_infos.infos64.notification; dyld_image_address = all_image_infos.infos64.dyldImageLoadAddress; dyld_version_address = all_image_infos.infos64.dyldVersion; dyld_all_image_infos_address = all_image_infos.infos64.dyldAllImageInfosAddress; } else { notification_address = all_image_infos.infos32.notification; dyld_image_address = all_image_infos.infos32.dyldImageLoadAddress; dyld_version_address = all_image_infos.infos32.dyldVersion; dyld_all_image_infos_address = all_image_infos.infos32.dyldAllImageInfosAddress; } dyld_slide_amount = load_result->all_image_info_addr - dyld_all_image_infos_address; #if 0 kprintf(\"exec_prefault: 0x%016llx 0x%08x 0x%016llx 0x%016llx 0x%016llx 0x%016llx\\n\", (uint64_t)load_result->all_image_info_addr, all_image_infos.infos32.version, (uint64_t)notification_address, (uint64_t)dyld_image_address, (uint64_t)dyld_version_address, (uint64_t)dyld_all_image_infos_address); #endif vm_fault(current_map(), vm_map_trunc_page(notification_address + dyld_slide_amount, vm_map_page_mask(current_map())), VM_PROT_READ | VM_PROT_EXECUTE, FALSE, THREAD_UNINT, NULL, 0); vm_fault(current_map(), vm_map_trunc_page(dyld_image_address + dyld_slide_amount, vm_map_page_mask(current_map())), VM_PROT_READ | VM_PROT_EXECUTE, FALSE, THREAD_UNINT, NULL, 0); vm_fault(current_map(), vm_map_trunc_page(dyld_version_address + dyld_slide_amount, vm_map_page_mask(current_map())), VM_PROT_READ, FALSE, THREAD_UNINT, NULL, 0); vm_fault(current_map(), vm_map_trunc_page(dyld_all_image_infos_address + dyld_slide_amount, vm_map_page_mask(current_map())), VM_PROT_READ | VM_PROT_WRITE, FALSE, THREAD_UNINT, NULL, 0); } } }"
    }
}