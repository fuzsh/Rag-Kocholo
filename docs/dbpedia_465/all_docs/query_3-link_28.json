{
    "id": "dbpedia_465_3",
    "rank": 28,
    "data": {
        "url": "https://tweag.io/blog/2022-07-14-taming-unix-with-nix/",
        "read_more_link": "",
        "language": "en",
        "title": "Nix – taming Unix with functional programming",
        "top_image": "https://tweag.io/logo.png",
        "meta_img": "https://tweag.io/logo.png",
        "images": [
            "https://tweag.io/26d911ec4ffeff4a35bac3b52601b7f0/memory-analogy.svg",
            "https://tweag.io/2ffefe1d82e7cf3919bf811cd27aa936/dataflow-analogy.svg",
            "https://tweag.io/c14fd81c08d90238cd8afaf0ea43c0da/derivation.svg",
            "https://tweag.io/18d63a6c0a19d2c965a67f68ac7cc4a3/functional-mapping.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-07-14T00:00:00",
        "summary": "",
        "meta_description": "Nix is all about applying functional programming to files and processes.",
        "meta_lang": "en",
        "meta_favicon": "/favicon-32x32.png?v=24f8ea31818259c4506bd1dd71f09cf3",
        "meta_site_name": "",
        "canonical_link": "https://tweag.io/blog/2022-07-14-taming-unix-with-nix/",
        "text": "You may be aware of Nix or NixOS. Users love them for being superior tools for building, deploying, and managing software. Yet, Nix is generally perceived as notoriously hard to learn.\n\nThe core Nix ecosystem consists of several distinct components:\n\nNix is a build system and package manager that comes with a configuration language to declare software components, the Nix language.\n\nSoftware made available through Nix is centrally maintained in a massive package collection called Nixpkgs.\n\nThere also exists a Linux distribution called NixOS, which is based on Nix and Nixpkgs.\n\nIn an attempt to provide an alternative learning approach, this article discusses the Nix and its underlying principles in the context of the history of computing. The condensed findings presented here reflect only some of our ongoing community effort , started this year to improve documentation and make the benefits of Nix more accessible to software developers, and eventually computer users in general.\n\nEverything is a… what?\n\nNix is not new. It has been under active development since 2003.\n\nWhile touted as the purely functional package manager, one cannot say that Nix introduces a fundamentally new paradigm. Functional programming goes back to John McCarthy’s Lisp (1962), rooted in Alonzo Church’s lambda calculus (1936), where everything is a function.\n\nIt is not even a new idea for Nix to propose parting ways with one of the most pervasive skeuomorphisms in computing, the file system, which naturally followed from an era where everything was a piece of paper.\n\nKen Thompson and Dennis Ritchie inherited the novelty of a hierarchical file system from one of its predecessors Multics and firmly assumed it as a given by 1974:\n\nThe most important job of UNIX is to provide a file system.\n\n— The UNIX Time-Sharing System (1974)\n\nAlthough arguably it is a severely limiting abstraction , it remains largely unquestioned as a cornerstone of software development practice . The rise of object oriented-programming brought about a number of experimental systems where everything is an object – an idea attributed to Alan Kay’s Smalltalk (1972) – but none of them saw mass adoption.\n\nPart of the Unix philosophy later even turned into the malapropism everything is a file. Linus Torvalds clarified in various public emails that it was really about small, composable tools operating on uniform interfaces, not the specific mapping of names to contents:\n\nThe whole point with “everything is a file” is not that you have some random filename (indeed, sockets and pipes show that “file” and “filename” have nothing to do with each other), but the fact that you can use common tools to operate on different things.\n\n— Linus Torvalds (2002)\n\nThe UNIX philosophy is often quoted as “everything is a file”, but that really means “everything is a stream of bytes”.\n\n— Linus Torvalds (2007)\n\nRob Pike and Ken Thompson have further pursued the design of an entire system around a hierarchy of named files with Plan 9 since the 1980s, culminating in what Torvalds phrased as “everything is a namespace”:\n\nIt may be unnatural to the Plan-9 way of “everything is a namespace”, but that was never the UNIX way. The UNIX way is “everything is a file descriptor or a process”, but that was never about namespaces.\n\n— Linus Torvalds (2002)\n\nToday’s most widely used operating systems (Linux, XNU, and Windows NT) all have file systems at their core. However, Nix is special not so much because it radically puts that into question with the purely functional approach, but for rather pragmatically offering an intriguing shift in perspective:\n\nWhat if we could continue developing and using all our software (mostly) as it is, and (mostly) stop bothering with file names, paths, and directories when building and deploying it?\n\nAn intriguing shift in perspective\n\nThe key insight behind Nix is that the problem of software deployment can be seen through the lens of programming language theory. The idea was first put forward by Eelco Dolstra et al. in Imposing a Memory Management Discipline on Software Deployment (2004). In his PhD thesis The Purely Functional Software Deployment Model (2005), Dolstra proposed that we can treat the file system in an operating system like memory in a running program, and equate package management to memory management. With Nix, he showed how to apply proven solutions, such as garbage collection or disallowing arbitrary manipulation of pointers (also known as pointer discipline), to the perennial struggle of making software work reliably.\n\nThe following figure illustrates the analogy of memory structures in programs and operating systems down to single objects.\n\nAs an example of this equivalence, take the following shell script:\n\nIt contains a reference to /usr/bin/sh. That file path is just like a mutable pointer to a mutable variable:\n\nThe path itself can be changed to reference a different file or one that does not even exist.\n\nThe contents of /usr/bin/sh can be changed or the file deleted entirely.\n\nThis makes it hard to reason about the overall system state – the same problem as for program state in an imperative programming language.\n\nMore details are elaborated in the table below (based on Figure 3.1 in The Purely Functional Software Deployment Model, p. 55).\n\nProgramming Language Domain Deployment Domain memory disk value, object file address path name pointer dereference file access pointer arithmetic string operations dangling pointer path to absent file object graph dependency graph calling constructed object with reference to other object runtime dependency calling constructor with reference to other object, not stored build-time dependency calling constructor with reference to other object, stored retained dependency languages without pointer discipline (e.g. assembler) typical Unix-style deployment languages with enough pointer discipline to\n\nsupport conservative garbage collection (e.g. C, C++) Nix languages with full pointer discipline (e.g. Java, Haskell) as-yet unknown deployment style not enabled\n\nby contemporary operating systems\n\nThis notion was further refined by Andrey Mokhov et al. in Build Systems à la Carte (2018), from a slightly different angle: distilling the essential features of build systems shows that building software can also be seen through the lens of programming language theory. It is really about applying functions to arbitrary values, which happen to be files in a file system; some of these files end up being run as processes. Again, proven solutions like memoization and self-adjusting computation offer themselves, this time, for tackling the perennial problem of long compilation times.\n\nBoth building and deploying software components as if they were values in a program’s call graph clearly shows the benefits and power of purely functional programming: ensuring correctness while allowing flexible composition and automatic optimizations.\n\nIn case of Nix, this enables reproducible builds and deployments, comfortable construction of packages and their variants from reusable building blocks, and features such as transparent binary caching.\n\nThe following table shows equivalence in terminology between build systems and programming language theory:\n\nNix Bazel Build Systems à la Carte programming language store object artifact value value builder (depends on action type) function function derivation action Task thunk derivation graph action graph, build graph Tasks call graph build build application of Build evaluation store action cache Store heap\n\nWhat Nix has been doing successfully since 2004 is encoding the place-oriented paradigm of files and processes in terms of a dataflow-oriented programming language, and hooking its evaluation results back into the operating system.\n\nMaybe surprisingly, that programming language is not the Nix language. Rather, Nix uses what we may call the derivation language, for lack of a better term.\n\nThe derivation language is a key mechanism in Nix, but users are rarely exposed to it. The Nix language itself is merely syntactic sugar that helps us encode objects and their relations (i.e., values and functions) as expressions in the derivation language.\n\nPrograms written in the derivation language transform build inputs into build results. These programs use part of the file system as memory, and their memory objects are files. Nix calls this part of the filesystem the Nix store. To run programs written in the derivation language, we evaluate them with the build scheduler.\n\nThe following example is a most basic Nix language expression:\n\nIt declares what Nix calls a derivation: a precise description of how contents of existing files are used to derive new files.\n\nThe build instructions encoded in this derivation create a file with contents hello. This does the same thing as capturing the output of the shell script example above.\n\nThe main difference is that, with Nix, repeated executions of these build instructions will always produce the same result, regardless of what happens to the original input files. In addition, changing any of the parameters of a derivation will produce a distinctly different result that cannot be mistaken for the original one. Nix achieves this by copying all input files to the Nix store, where they cannot change, and always working with these immutable copies that are identified by their content hash. The build result itself also gets a unique name, which is based on the hashes of all the build inputs and parameters.\n\nA side effect of evaluating the above expression with nix-instantiate is the creation of the the following build task:\n\nNix calls this structure a store derivation: a build task with unambiguously specified dependencies, persisted in the Nix store.\n\nNote how the builder is not /bin/sh any more, but a file in /nix/store, uniquely identified by the hash of its contents. The file system path outputs.out.path will be populated when the derivation is built, and would be different if we changed any parameter to derivation – or the contents of /bin/sh – before evaluatinng the Nix expression.\n\nThe unwieldy syntax and the specifics of wiring up the build execution with env and args are rather arbitrary and have historical reasons. What matters here is that this construction has properties of a dataflow programming language:\n\nDataflow oriented: Build tasks can be composed.\n\nThe build result of one can be used as build input for another. The order of operations is determined by data dependencies, and otherwise irrelevant.\n\nPure: The builder will always produce the same result for the same inputs.\n\nAssuming the builder process is sufficiently isolated from its host system, the transformation it performs on its arguments acts like a pure function.\n\nFollowing the analogy of build systems and programming languages, this diagram illustrates the derivation as pure data transformation:\n\nEvaluating Nix language expressions only produces build tasks. Evaluating the build tasks produces build results. The Nix package manager’s command line tools in turn allow exposing build results to the Unix environment.\n\nNixOS pushes this idea to the limit by capturing as much operating system state as possible into the realm of declarative programming.\n\nThe following diagram shows a drastic simplification of how Nix interacts with the operating system: It uses files as function inputs, and outputs are files again. On the operating system, files can be run as processes, which, in turn, operate on files. A build function also amounts to an operating system process (not depicted).\n\nWhat next?\n\nSince its inception, Nix development has been primarily occupied with imposing the abstraction of functional programming onto the messy, real world of our Unix lineage: encoding and correctly dealing with object references in the file system, ensuring purity of function application, and working around built-in assumptions behind the mechanisms of different language ecosystems and build procedures – all while keeping performance acceptable.\n\nDespite numerous rough edges remaining due to the enormous scope of the undertaking, Nix, Nixpkgs, and NixOS have been working products for many years. Currently there is much work in progress to improve the user experience by presenting a more consistent command line interface and better error messages.\n\nHowever, something much more interesting lives in the long-term. Which other results from programming language theory and mathematics will we be able to leverage to make software build quickly, work reliably, and further tame Unix?\n\nFor example, what if the derivation language was not only pure, but also functional, to use derivations as build inputs? What if it also had types, to describe constraints to composing packages and configurations?\n\nNix is begging the question: what if everything on our computers was, in fact, a computer program?\n\nEdited 2022-11-09: Explained more precisely the effects of changing inputs and parameters of derivations.\n\nEdited 2022-08-29: Expanded on the derivation language, added examples and explanations. Originally it was only briefly mentioned as a key mechanism underlying Nix.\n\nThanks to Ian Henry (@ianthehenry) for detailed feedback and specifically for pointing out that gap."
    }
}