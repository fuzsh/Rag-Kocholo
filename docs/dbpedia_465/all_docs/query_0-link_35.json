{
    "id": "dbpedia_465_0",
    "rank": 35,
    "data": {
        "url": "https://alephsecurity.com/2019/06/25/xnu-qemu-arm64-2/",
        "read_more_link": "",
        "language": "en",
        "title": "Running iOS in QEMU to an interactive bash shell (2): research",
        "top_image": "https://alephsecurity.com/assets/img/logo-black.png",
        "meta_img": "https://alephsecurity.com/assets/img/logo-black.png",
        "images": [
            "https://alephsecurity.com/assets/img/qemu-ios/xnu-iosecurebsdroot-code.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/xnu-iosecurebsdroot-ghidra.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/callPlatformFunction-ghidra.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/secureroot-ghidra.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/ghidra-securemonitor-pasrse-kernel-mach-o.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/top-level-hash.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/lookup-static-trust-cache.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/parse-trust-cache.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/read-devtree-trust-cache.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/lookup-static-trust-cache.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/hlt2.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/shared_region_map_and_slide_np.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/uart-input-decide.jpg",
            "https://alephsecurity.com/assets/img/qemu-ios/serial-boot-arg.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "alephsecurity.com"
        ],
        "publish_date": "2019-06-25T00:00:00",
        "summary": "",
        "meta_description": "Running iOS in QEMU to an interactive bash shell (2): research",
        "meta_lang": "en",
        "meta_favicon": "/favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://alephsecurity.com/2019/06/25/xnu-qemu-arm64-2/",
        "text": "Edit (July 2020): This project has greatly evolved since its first release. Now, the kernel is patched to bypass the Secure Monitor and the Core Trust mechanisms. We decided to leave this blog post unchanged for educational purposes. To see the current status of the project, please visit our GitHub repository.\n\nThis is the second post in a 2-post series about the work I did to boot a non-patched iOS 12.1 kernel on QEMU emulating iPhone 6s plus and getting an interactive bash shell on the emulated iPhone. To see the code and the explanation on how to use it, please refer to the first post. In this post, I will present some of the research that was done in order to make this happen. This research was based on the work done by zhuowei as a starting point. Based on the work done by zhuowei, I already had a way to boot an iOS kernel of a slightly different version on a different iPhone without a secure monitor, while patching the kernel at runtime to make it boot, running the launchd services that preexisted on the ramdisk image and without interactive I/O. In this post I will present:\n\nHow the code was inserted in the QEMU project as a new machine type.\n\nHow the kernel was booted without patching the kernel either at runtime or beforehand.\n\nHow the secure monitor image was loaded and executed in EL3.\n\nHow a new static trust cache was added so self signed executables could be executed.\n\nHow a new launchd item was added for executing an interactive shell instead of the existing services on the ramdisk.\n\nHow full serial I/O was established.\n\nThe project is now available at qemu-aleph-git with the required scripts at qemu-scripts-aleph-git.\n\nQEMU code\n\nIn order to be able to later rebase the code on more recent versions of QEMU and to add support for other iDevices and iOS versions, I moved all the QEMU code changes into new modules. I now have the module hw/arm/n66_iphone6splus.c that is the main module for the iPhone 6s plus (n66ap) iDevice in QEMU that is responsible for:\n\nDefine a new machine type.\n\nDefine the memory layout of the UART memory mapped I/O, the loaded kernel, secure monitor, boot args, device tree, trust cache in different exception levels’ memory.\n\nDefine the iDevice’s proprietary registers (currently do nothing and just operate as general purpose registers).\n\nDefine the machine’s capabilities and properties like having EL3 support and start execution in it at the secure monitor entry point.\n\nConnect the builtin timer interrupt to FIQ.\n\nGet command-line parameters for defining the files for: kernel image, secure monitor image, device tree, ramdisk, static trust cache, kernel boot args.\n\nThe other main module is hw/arm/xnu.c and it is responsible for:\n\nLoading the device tree into memory and adding the ramdisk and the static trust cache addresses to the device tree where they are actually loaded.\n\nLoading the ramdisk into memory.\n\nLoading the static trust cache into memory.\n\nLoading the kernel image into memory.\n\nLoading the secure monitor image into memory.\n\nLoading and setting the kernel and secure monitor boot args.\n\nBooting the kernel with no patches\n\nBasing the work on zhuowei, I already had the ability to boot to user mode with a different iOS version and for a different iPhone while patching the kernel at runtime using the kernel debugger. The need to patch comes from the fact that after changing the device tree and booting from a ramdisk we encounter a non-returning function waiting for an event that never comes. By placing breakpoints all over and single stepping in the kernel debugger I found that the non-returning function is IOSecureBSDRoot() which can be found in the XNU code published by Apple in version xnu-4903.221.2:\n\nand at runtime, when debugging the kernel itself:\n\nThis function doesn’t return, because the call to pe->callPlatformFunction() doesn’t return. For this function I don’t have any reference code, so the kernel is disassembled:\n\nBy examining the function, we can see that the non-returning function deals a lot with specific members of the object in x19, and the flow changes depending on these members. I tried a few approaches to understand what these members mean, and where their values are set, but with no luck. These members do seem to be at special offsets, so after a while I tried my luck and used Ghidra to search the whole kernel for functions that use objects and their members at offsets 0x10a, 0x10c and 0x110 - and I got lucky! I found this function, that deals with the exact same object and these members:\n\nIn this function, it is easy to see that when the prop secure-root-prefix is not in the device tree, the member at offset 0x110 is kept untouched with the value 0, and then the original function I looked at (pe->callPlatformFunction()) just returns, and voila - there no need to patch the kernel.\n\nLoading the secure monitor image\n\nWhere we left off with the work done by zhuowei, I was able to boot an iPhone X image to user mode. This image boots straight into EL1 and has no secure monitor. I decided to work with another image for iPhone 6s plus, as Apple left off a lot of symbols in there and I thought it would make the research simpler. It turns out that KPP (Kernel Patch Protection) based devices with no KTRR (Kernel Text Readonly Region) have a secure monitor image that needs to be loaded with its own boot args, and executed in EL3. This part of the project was about finding the secure monitor image embedded in the kernel file, loading it, understanding the boot args structure, and loading the image and configuring QEMU to start executing the entry point in EL3. After completing these steps, things still didn’t work. The reason seemed to be that the secure monitor image tries to parse the kernel mach-o header at the kernel base (read from the kernel boot args), and I didn’t have a kernel image at that base address, so it failed with a data-abort. This all happens in this function:\n\nI believe this function is responsible for the KPP functionality because it keeps a map of kernel sections based on the permissions they should have, but this assumption still needs to be verified.\n\nAs can be seen in the code from zhuowei, the virt_base arg was pointing to the lowest segment of the loaded kernel:\n\nThis segment, in our case, was mapped below the address of the loaded mach-o header. This means that the virt_base does not point to the kernel mach-o header, and therefore doesn’t work with the secure monitor code as presented above. One way I tried solving this was by setting the virt_base to the address of the mach-o header, but this made some kernel drivers code load below virt_base, which messed up a lot of stuff, like the following function:\n\nAnother approach I tried was to skip the execution of the secure monitor, and start straight from the kernel entry point in EL1. This worked until I hit the first SMC instruction. It might have been possible to solve this by patching the kernel at points where SMC is used, but I didn’t want to go this way, as I opted for no patches at all (if possible), and you never know where not having some secure monitor functionality might hit you again. What eventually worked was setting the virt_base to a lower address below the lowest loaded segment, and just have another copy of the whole raw kernelcache file at this place (in addition to the copy loaded segment by segment where the code is actually executed from). This solution satisfied all the conditions of having the virt_base below all the virtual addresses actually used in the kernel, having it point to the kernel mach-o header, and having the kernel loaded at its preferred address segment by segment, where it is actually executed from.\n\nTrust Cache\n\nIn this section, I will present the work that was done to load non-Apple, self-signed executables. iOS systems normally will only execute trusted executables that are either in a trust cache, or signed by Apple or an installed profile. More background on the subject can be found here, as well as other writeups on the web and in books. In general, there are 3 types of trust caches:\n\nA trust cache hardcoded in the kernelcache.\n\nA trust cache that can be loaded at runtime from a file.\n\nA trust cache in memory pointed to from the device tree.\n\nI decided to go after the 3rd one. The following function contains the top level logic for checking whether an executable has a code signature that is approved for execution, based on trust cahces or otherwise:\n\nIf we drill down deeper, we finally get to this function, that checks the static trust cache:\n\nFrom there, we can see, using XREFs, that the values are set here:\n\nThe function above parses the raw trust cache format. It is left as an exercise to the reader to follow the code and the error messages, to conclude that the trust cache format is:\n\nAnd it seems that even though the structure supports multiple trust caches in the buffer, the code actually limits the size to 1.\n\nFollowing XREFS from this function leads us to the following code:\n\nThis data is, therefore, read from the device tree.\n\nNow, all that’s left to do is load the trust cache into memory, and point to it from the device tree. I have to decide where to place it in memory. There is a kernel boot arg top of kernel data which points to the address after the kernel, ramdisk, device tree and the boot args. The first location I tried was near this top of kernel data address (before and after it). This didn’t go so well because of the following code which is the code ~matching the above assembly:\n\nHere we can see that when we have a static trust cache, segEXTRADATA is set to the trust cache buffer, instead of segLOWESTTEXT.\n\nIn the following 2 functions we can see that if the data between gVirtBase and segEXTRADATA holds anything meaningful, terrible things happen:\n\nAlright, so now, based on the above observation, I decided to place the trust cache buffer right after the raw kernel file I placed at virt_base. This, of course, still didn’t work. Following the code that sets the page table, I found where this memory location gets unloaded from the table, and finally understood that a few pages after the end of the raw kernel file get unloaded from memory at some point. Therefore, I placed it a few MBs above that address, and it finally worked (partially).\n\nLooking at the code at:\n\nIt is left to the reader to read the function and see that a binary search is implemented there. After sorting the hashes in the buffer, it finally worked properly.\n\nBash launchd item\n\nAt this point, I have the ability to execute our own self-signed, non-Apple executables, so I wanted launchd to execute bash instead of the services that exist on the ramdisk. To do so, I deleted all the files in /System/Library/LaunchDaemons/ and added a new file com.apple.bash.plist, with the following content:\n\nThis made launchd try and execute bash, but still no go. It seems that the ramdisk comes without the dynamic loader cache on it. To solve this, I copied the dyld cache from the full disk image to the ramdisk (after resizing the ramdisk so it would have enough space for it). Alas, it still didn’t work and it seemed the problem was still the same missing libraries, even with the dyld cache in place. To debug this, I needed to better understand where the failure happens. I found out that loading the cache happens inside dyld in:\n\nBy using the fun feature from the previous post, which lets us debug user mode apps in the gdb kernel debugger, I was able to debug, by stepping through this function, and seeing what fails. To do this, I patched dyld with an HLT instruction, which our modified QEMU treats as a breakpoint. I then re-signed the executable with jtool, and added the new signature to the static trust cache:\n\nThis showed me that actually the failure is in:\n\nGood thing I am running a kernel debugger, so I can step right into the kernel system call and see where it fails. And another good thing is that I have some version of the code:\n\nBy stepping through the code in the debugger, I found that the call to _shared_region_map_and_slide() is what actually fails:\n\nAnd by stepping through this function in the kernel debugger, I found that the failure is in this part:\n\nAnd the problem is that the cache file isn’t owned by root, so I found a way to mount the ramdisk on OSX with file permissions enabled, and chowned the file. This made bash work! Now we only have stdout, but no input support.\n\nUART interactive I/O\n\nNow, all that’s left is enabling UART input. After going over and reversing some of the serial I/O handling code I found this place, which decides whether to enable the UART input (which is off by default):\n\nThis code reads a global value, and checks bit #1. If it is on, UART input is enabled. By examining this global, we can see that it is set here:\n\nThe value is taken from the serial boot arg. So finally, by setting the serial boot arg to 2 (bit #1 on) I got an interactive bash shell!\n\nConclusion\n\nThis project was a lot of fun and the team plans to keep working on it and expand the features mentioned in the previous post. This post shows some of the details of some of the interesting parts of the work, but as I worked very sparsely on this project for the past few months, and documentation during the research lacked some details, not all the details are here. With that in mind, all the functionality is in the code which does include comments in non-trivial places. I got into iOS internals only through this project, so some parts can possibly be improved, and I already received some improvement suggestions. If you have any comments/ideas/suggestions for this project, please comment and/or contact me."
    }
}