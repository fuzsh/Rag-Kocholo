{
    "id": "dbpedia_465_1",
    "rank": 42,
    "data": {
        "url": "https://pwning.systems/posts/easy-apple-kernel-bug/",
        "read_more_link": "",
        "language": "en",
        "title": "A tale of a simple Apple kernel bug",
        "top_image": "https://pwning.systems/",
        "meta_img": "https://pwning.systems/",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "apple",
            "kernel",
            "vulnerability"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-10-31T19:30:12+02:00",
        "summary": "",
        "meta_description": "Earlier this year, I discovered a flaw in XNU, which is the kernel that Apple uses on both macOS and iOS. While it&rsquo;s not a particularly complicated flaw, I wanted to explain how I discovered it and how it works, both so that I can motivate others and so that they can learn from my discovery.\nWithin the memdev.c file (the ramdisk device driver), I found the source of the vulnerability, which was a write/read operation that exceeded the allowed range.",
        "meta_lang": "en",
        "meta_favicon": "https://pwning.systems/img/apple-touch-icon-192x192.png",
        "meta_site_name": "pwning.systems",
        "canonical_link": "https://pwning.systems/posts/easy-apple-kernel-bug/",
        "text": "Earlier this year, I discovered a flaw in XNU, which is the kernel that Apple uses on both macOS and iOS. While it’s not a particularly complicated flaw, I wanted to explain how I discovered it and how it works, both so that I can motivate others and so that they can learn from my discovery.\n\nWithin the memdev.c file (the ramdisk device driver), I found the source of the vulnerability, which was a write/read operation that exceeded the allowed range. Why are ramdisks such an intriguing target to look at? If you identify a bug in the driver, it may give you the ability to execute code in the kernel. Additionally, on some systems, you may be able to construct ramdisks with particular settings such that it is mapped to physical memory, which may give you the ability to read and write data to physical memory.\n\nIn order for us to understand the bug, we will first have to figure out what uimove is.\n\nData can be moved between user space and kernel space with the help of the uiomove() function. To a large extent, it is comparable to an I/O vector.\n\nThe uimove() function requires three parameters: the location of the destination buffer, the size of the buffer, and a pointer to the uio structure.\n\nThe uio structure looks like this:\n\nOnce you know how this function works, you can probably foresee the potential problems that could arise. For example what happens when you put a size argument that’s bigger than the destination buffer. This is what I started searching for.\n\nWhen we take a look at the uio struct, we notice that it contains two fields that relevant to our interest: uio_resid and uio_offset. Where uio_resid refers to the number of bytes that still need to be copied and uio_offset specifies the position inside the buffer that will be used as the destination.\n\nTherefore, the first thing that I would try would be to search for locations where uio_resid is used in the size parameter. And this is when Weggli entered the picture!\n\nI started exploring with a simple weggli query like this:\n\nweggli -u -R func=uiomove '$func(_,_,_);' ./\n\nThis would search for all calls to functions that contain the word uiomove anywhere in the name of the function. This gave a bunch of results, but I was too lazy to go through them manually.\n\nAfter that, I attempted to make the query a little more specific by checking to see if the word resid was included in the size argument anywhere. Unfortunately, this did not provide any results; however, after a little bit of fiddling around, I discovered that it produces results if the resid variable is included in a sub-expression of the size argument like seen here:\n\nweggli -u -R func=uiomove -R 'resid=resid' '$func(_,_($resid),_);' ./\n\nThis gave two results, one of them containing min() so I didn’t bother looking at that. The other one however seemed promising:\n\nSo the mdevrw function appears to use something with resid in the size argument. However it’s not using uio->uio_resid, apparently uio_resid() is just a macro that returns uio->uio_resid. So that works as well :')\n\nSo I took a look at the memdev driver’s mdevrw function.\n\nWhen we examine this function, we can plainly see that there is no size check, which indicates that we are dealing with a read and a write of an arbitrary size to and from the kernel (This is because the user decides wether they want to read or write, based on the syscall they use).\n\nNext to that there’s one other thing that sparked my interest, did you see this line?\n\nmdata = ((addr64_t)mdev[devid].mdBase << 12) + uio->uio_offset;\n\nYes, that’s right. It doesn’t perform any size checks, but it still uses the user-provided offset to figure out where the destination is.\n\nAt this point, it appears that we are dealing with an issue that involves reading and writing data on an arbitrary offset of an arbitrary size. Looks like a textbook bug!\n\nSimply opening the device, reading from it, or writing to it will cause this problem to be triggered. The only catch is that you need to have unsandboxed code execution and be logged in as root in order to be able to exploit this problem. Therefore, it’s not a severe issue, but it might be beneficial nonetheless in a full-chain\n\nAfter I reported this problem to Apple, I happened to come across a proof-of-concept tweet for the bug on Twitter because someone was diffing the patches which was fun.\n\nThe vulnerability, which is now known as CVE-2022-26743, has now been patched and rewarded."
    }
}