{
    "id": "dbpedia_465_0",
    "rank": 72,
    "data": {
        "url": "https://gitea.com/matteyeux/darwin-xnu/src/branch/master/osfmk/tests",
        "read_more_link": "",
        "language": "en",
        "title": "darwin-xnu",
        "top_image": "https://seccdn.libravatar.org/avatar/48534de4521fb2913ebdf8e3038c4e30?d=identicon",
        "meta_img": "https://seccdn.libravatar.org/avatar/48534de4521fb2913ebdf8e3038c4e30?d=identicon",
        "images": [
            "https://gitea.com/assets/img/logo.svg",
            "https://seccdn.libravatar.org/avatar/a8b3e32920be504488d62ed9a07c3f69?d=identicon&s=48"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "go",
            "git",
            "self-hosted",
            "gitea"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "darwin-xnu",
        "meta_lang": "en",
        "meta_favicon": "/assets/img/favicon.svg",
        "meta_site_name": "Gitea: Git with a cup of tea",
        "canonical_link": "https://gitea.com/matteyeux/darwin-xnu",
        "text": "Kernel Power On Self Tests (POST)\n\nThe tests directories osfmk/tests and bsd/tests include set of tests that run in kernel at boot-time. The primary objective for these tests is to verify functionality of various subsystems like memory allocators, scheduling, VM, IPC ports etc. Following are some tips and guidelines to creating and running tests.\n\nFeatures:\n\nCompiled out of RELEASE kernels.\n\nenabled with boot-arg kernPOST [ 0x1 : for on desk testing, 0x3 for BATs testing]\n\nAutomatically skips tests that are designed to panic kernel for on-desk testing, but run in BATs environment.\n\nDoes not require complete install on device to run. Just kernelcache is enough.\n\nAbility to check for assertions and panic path as well.\n\nHow to run kernel POST\n\nStart usbterm and setup your target machine/device in iBoot.\n\nset boot-args to include \"kernPOST=0x1\"\" to enable kernel testing on boot.\n\nload kernelcache using \"usb get /patch/to/kc\"\n\nboot the image \"bootx\"\n\nwatch for nanokdp serial output with tags like \"[KTEST] <test> logs\"\n\nHow do I configure to run just test #8?\n\nKernel POST supports configuring test through boot-args. For example if you want to run your test #8 (say you are tweaking it to do more testing). Just set \"kernPOST_config=8\" and only your test will be run. The configuration also takes ranges as follows\n\n-> kernPOST_config=1_3,5_9999 # skip test#4. Will run tests 1,2,3 and 5,6 and onwards. -> kernPOST_config=1_3,4_9999 # will not skip anything. lower_upper are both inclusive.\n\nHow do I add a new test?\n\nAdding a new kernel POST test is very simple. Here are a few steps and guidelines for adding tests.\n\nThere are two locations osfmk/tests/ and bsd/tests where you can add tests based on your area of testing.\n\nIf you wish to add a new .c file for your tests then, use #include <xnupost.h> to include required functions and macros for testing. Remember to add file_name.c in osfmk/conf/files or bsd/conf/files as\n\nosfmk/tests/my_tests.c optional config_xnupost\n\nTo add a test function just declare a function with prototype as\n\nkern_return_t my_sample_tests(void);\n\nAnd add to struct xnupost_test array in osfmk/tests/kernel_tests.c or bsd/tests/bsd_tests.c as\n\nstruct xnupost_test kernel_post_tests[] = { XNUPOST_TEST_CONFIG_BASIC(my_sample_tests), // simple test XNUPOST_TEST_CONFIG_TEST_PANIC(panic_test) // test that is expected to panic };\n\nAnd you are set. Use KERN_SUCCESS to report successful run and any other error for failure. Here is an example with some available macros.\n\nkern_return_t my_sample_tests() { uint64_t test_begin_timestamp = 0; uint64_t cur_timestamp = 0, tmp; T_SETUPBEGIN; test_begin_timestamp = mach_absolute_time(); T_ASSERT_NOTNULL(test_begin_timestamp, \"mach_absolute_time returned 0.\"); T_SETUPEND; T_LOG(\"Testing mach_absolute_time for 100 iterations\"); for (int i = 0; i < 100; i++) { tmp = mach_absolute_time(); T_EXPECT_TRUE((cur_timestamp <= tmp ), \"Time went backwards\"); cur_timestamp = tmp; } T_LOG(\"Completed mach_absolute_time tests.\"); return KERN_SUCCESS; }\n\nThere are many ** T_* ** macros available for your convenience.\n\nNote: Please make sure your test does a proper cleanup of state. The kernel is expected to continue to boot after testing. If you are unable to cleanup and require a reboot then use XNUPOST_TEST_CONFIG_TEST_PANIC type and panic at the end of the function. This will make sure the test controller reboots and runs the next test in automation.\n\nWhat is the difference between T_EXPECT and T_ASSERT macros?\n\nT_ASSERT macros will check for condition and upon failure return with KERN_FAILURE. This way it ensures that no further execution of test code is done.\n\nT_EXPECT will just report failure of that test case, but will continue to run further test code.\n\nHow do I run my tests in BATs?\n\nBats has a new test type kernel_POST that runs Lean test environment tests. You can run the following command to get POST testing.\n\n~osdev/tat/dev/bin/bats build -b <build> -t darwinLTE -p xnu:<branch> -r <radarnum>\n\nHow do I test for panic/assertions?\n\nThe xnupost subsystem provides mechanism for setting up a panic widget. This widget can check for some conditions and report test case SUCCESS/FAILURE. See xnupost.h for XT_RET* style return values. There are convenience macros for registering for generic panic and for assertion handling. For example if you wish to check for api foo(int arg) { assert(arg > 0); ... } then a test case could be like\n\nkern_return_t test_foo_arg_assertion(void) { void * assert_retval = NULL; kern_return_t kr = T_REGISTER_ASSERT_CHECK(\"arg > 0\", &assert_retval); T_ASSERT(kr == KERN_SUCCESS, \"register assertion handler\"); foo(-1); /* this will cause assert to fire */ T_ASSERT(assert_retval == (void *)XT_RET_W_SUCCESS, \"verify assertion was hit\"); }\n\nHow do XNUPOST panic widgets work?\n\nOn debug/development kernels, the panic() code is modified to call out to XNUPOST system xnupost_process_panic(). This callout can then determine if testing was enabled and has a widget registered for checking panics. If yes, then the corresponding widget function is called and the return value determines what action is taken. For example a widget could return either of the following values\n\nXT_PANIC_UNRELATED /* not related. continue panic / XT_RET_W_FAIL / report FAILURE and return from panic / XT_RET_W_SUCCESS / report SUCCESS and return from panic / XT_PANIC_W_FAIL / report FAILURE and continue to panic / XT_PANIC_W_SUCCESS / report SUCCESS and continue to panic */\n\nThe panic widget data is saved in internal data array where each is of type: struct xnupost_panic_widget { void * xtp_context_p; /* a context pointer for callbacks to track / void ** xtp_outval_p; / an out param for function to return some value to running test / const char * xtp_func_name; / widget name for tracking in serial output */ xt_panic_widget_func xtp_func; };"
    }
}