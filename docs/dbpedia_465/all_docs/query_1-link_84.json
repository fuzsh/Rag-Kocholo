{
    "id": "dbpedia_465_1",
    "rank": 84,
    "data": {
        "url": "https://bellis1000.medium.com/exploring-the-ios-screen-frame-buffer-a-kernel-reversing-experiment-6cbf9847365",
        "read_more_link": "",
        "language": "en",
        "title": "Exploring the iOS screen framebuffer– a kernel reversing experiment",
        "top_image": "https://miro.medium.com/v2/resize:fit:1200/1*g_X7-f8w33-urqCdM2FXVA.jpeg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1200/1*g_X7-f8w33-urqCdM2FXVA.jpeg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*0FEDOacmN4qkN7ZTn2ZvBQ@2x.jpeg",
            "https://miro.medium.com/v2/resize:fill:144:144/1*0FEDOacmN4qkN7ZTn2ZvBQ@2x.jpeg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Billy Ellis"
        ],
        "publish_date": "2020-01-18T20:41:53.845000+00:00",
        "summary": "",
        "meta_description": "It’s been over two years since I last published a blog, so I thought I’d give this another go in 2020 and kick it off by writing about an iOS-related project I’ve been working on over the last couple…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/1*m-R_BkNf1Qjr1YbyOIJY2w.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://bellis1000.medium.com/exploring-the-ios-screen-frame-buffer-a-kernel-reversing-experiment-6cbf9847365",
        "text": "It’s been over two years since I last published a blog, so I thought I’d give this another go in 2020 and kick it off by writing about an iOS-related project I’ve been working on over the last couple weeks – a reverse engineering task involving the iOS screen frame-buffer.\n\nFirst of all, my inspiration to start looking at this came shortly after the release of the checkra1n jailbreak for the iPhone 5S – iPhone X. If you haven’t yet played with checkra1n, check it out here – https://checkra.in/.\n\nOne of the things checkra1n does during the jailbreaking process is display a series of debug messages on the phone’s screen to let the user know about the progress of the jailbreak, and allow them to see what went wrong in the event of the jailbreak failing.\n\nThese debug messages are written to the display over the top of the standard boot screen. I was intrigued by this and started to wonder how the checkra1n team had implemented it. I heard some phrases thrown around online mentioning the use of a “framebuffer” and that the jailbreak tool was somehow “writing” to it.\n\nSo I set myself the challenge of figuring out how this worked and how I could replicate this in order render some characters on the screen by directly manipulating the pixels.\n\nLocating the iOS frame-buffer in kernel memory\n\nThe first step towards reaching my goal of writing custom characters to the screen was to find where in memory the screen pixel data was stored.\n\nThe checkra1n tool manipulates pixels in the framebuffer during the iBoot stage of the boot process, which is why we see the debug messages printed over the Apple boot-logo. I decided to take a different approach and focus on an already-booted iPhone.\n\nThe only difference meant dealing with kernel memory as opposed to iBoot memory, and dealing with the kernel memory seemed like the simpler approach as I could get started right away without having to construct a fully patched boot-chain etc.\n\nI started digging around to find where the iOS kernel holds the screen pixel data in memory. Knowing this memory location would allow me to write to it (assuming I’m using a jailbroken device with a TFP0 patch) resulting in the colour of the pixels changing.\n\nMy first thought was to see if there was some kind of framebuffer symbol within the iOS kernel.\n\nI opened a decrypted kernelcache file (for this, I’m using an iPhone3,1 iOS 7.1.2 kernel) in Hopper disassembler and searched for “framebuffer” but no luck :(\n\nDespite not finding any symbols, Hopper did find a string containing “framebuffer”:\n\nThis string appeared to be some kind of debug message coming from the function initialize_screen. I went to the XNU source code to confirm this function actually existed and found it in the file https://github.com/apple/darwin-xnu/blob/a449c6a3b8014d9406c2ddbdc81795da24aa7443/osfmk/console/video_console.c.\n\nLooking at the first few lines of code in this function it is clear that this function is responsible for setting up the device’s screen and assigning values for the width, height, colour depth etc.\n\nThe first argument to this function is a pointer to a PE_Video structure. I went to where this struct was defined (in https://github.com/apple/darwin-xnu/blob/master/pexpert/pexpert/pexpert.h) and found that it holds some information about the host’s screen, including the width, height, colour depth and a base address of where in memory the pixel data actually lies.\n\nstruct PE_Video {\n\nunsigned long v_baseAddr; /* Base address of video memory */\n\nunsigned long v_rowBytes; /* Number of bytes per pixel row */\n\nunsigned long v_width; /* Width */\n\nunsigned long v_height; /* Height */\n\nunsigned long v_depth; /* Pixel Depth */\n\nunsigned long v_display; /* Text or Graphics */\n\nchar v_pixelFormat[64];\n\nunsigned long v_offset; /* offset into video memory to start at */\n\nunsigned long v_length; /* length of video memory (0 for v_rowBytes * v_height) */\n\nunsigned char v_rotate; /* Rotation: 0:normal, 1:right 90, 2:left 180, 3:left 90 */\n\nunsigned char v_scale; /* Scale Factor for both X & Y */\n\nchar reserved1[2];\n\n#ifdef __LP64__\n\nlong reserved2;\n\n#else\n\nlong v_baseAddrHigh;\n\n#endif\n\n};\n\nIf I could find this structure sitting in the kernel memory I’d be able to follow the v_baseAddr pointer and find the raw pixel data.\n\nI followed the first XREF from the debug string I had found in the iOS kernelcache and landed in the following code:\n\nIf this code was part of initialize_screen then I’d have a chance at finding the address of this PE_Video structure in here.\n\nThere was no symbol for initialize_screen in the binary so I couldn’t tell for sure if the code I had found myself in was actually initialize_screen but a couple of observations between the disassembly and the source code left me pretty confident that it probably was.\n\nI did a bit of digging and found out that the PE_Video structure is only used when setting up the screen initially, and that the screen information was actually held somewhere else after the kernel had properly started.\n\nThe values passed in through the PE_Video structure are copied over to a global vc_info structure named vinfo further down in the code.\n\nLooking at the definition for vc_info we can see that it is similar to the PE_Video structure in terms of the information it holds about the screen:\n\nstruct vc_info{\n\nunsigned int v_height; /* pixels */\n\nunsigned int v_width; /* pixels */\n\nunsigned int v_depth;\n\nunsigned int v_rowbytes;\n\nunsigned long v_baseaddr;\n\nunsigned int v_type;\n\nchar v_name[32];\n\nuint64_t v_physaddr;\n\nunsigned int v_rows; /* characters */\n\nunsigned int v_columns; /* characters */\n\nunsigned int v_rowscanbytes; /* Actualy number of bytes used for display per row*/\n\nunsigned int v_scale;\n\nunsigned int v_rotate;\n\nunsigned int v_reserved[3];\n\n};\n\nThe vinfo structure is assigned its values between calls to simple_lock and simple_unlock in initialize_screen.\n\nif (vc_progress) {\n\nsimple_lock(&vc_progress_lock);\n\nvinfo = new_vinfo;\n\nsimple_unlock(&vc_progress_lock);\n\n}\n\nLocating this code in the disassembly was relatively easy as we had some pretty clear ‘markers’ to look out for — the lock and unlock functions.\n\nHere is the disassembly of the above code in the iOS kernel (note: in the kernel version I was using for this, the lock and unlock functions used were actually _lck_spin_lock and _lck_spin_unlock instead of simple_lock and simple_unlock):\n\n8011c688 blx _lck_spin_lock\n\n8011c68c ldr r0, [sp, #-0x8 + 56]\n\n8011c68e add.w r1, fp, #0x8\n\n8011c692 str.w r0, [fp]\n\n8011c696 ldr r0, [sp, #-0x8 + 20]\n\n8011c698 str.w r0, [fp, #0x4]\n\n8011c69c ldr r0, [sp, #-0x8 + 52]\n\n8011c69e stm.w r1, {r0, r8, sl}\n\n8011c6a2 ldr r0, [sp, #-0x8 + 24]\n\n8011c6a4 str.w r0, [fp, #0x14]\n\n8011c6a8 movs r0, #0x0\n\n8011c6aa strb.w r0, [fp, #0x18]\n\n8011c6ae ldr r0, [sp, #-0x8 + 28]\n\n8011c6b0 vld1.8 {d16, d17}, [r0]\n\n8011c6b4 add r0, sp, #0x54\n\n8011c6b6 vld1.32 {d18, d19}, [r0]\n\n8011c6ba ldr r0, [sp, #-0x8 + 36]\n\n8011c6bc vst1.8 {d16, d17}, [r0]\n\n8011c6c0 ldr r0, [sp, #-0x8 + 40]\n\n8011c6c2 vst1.8 {d18, d19}, [r0]\n\n8011c6c6 ldr r0, [sp, #-0x8 + 60]\n\n8011c6c8 str.w r0, [fp, #0x3c]\n\n8011c6cc str.w r5, [fp, #0x38]\n\n8011c6d0 ldr r0, [sp, #-0x8 + 88]\n\n8011c6d2 vldr d16, [sp, #-0x8 + 80]\n\n8011c6d6 str.w r0, [fp, #0x48]\n\n8011c6da ldr r0, [sp, #-0x8 + 32]\n\n8011c6dc vstr d16, [fp, #0x40]\n\n8011c6e0 str.w r0, [fp, #0x4c]\n\n8011c6e4 add r0, sp, #0x38\n\n8011c6e6 vld1.32 {d16, d17}, [r0]\n\n8011c6ea ldr r0, [sp, #-0x8 + 44]\n\n8011c6ec vst1.64 {d16, d17}, [r0, #0x80]\n\n8011c6f0 mov r0, r6\n\n8011c6f2 blx _lck_spin_unlock\n\nThe series of STR and LDR instructions in the above assembly code are copying each of the values out of the PE_Video struct over to the new vc_info struct.\n\nI decided to go to the same code in Ghidra, in pseudo code view, as it helped display the memory addresses that were being written to a little clearer.\n\n_lck_spin_lock(&DAT_8037d714);\n\nDAT_8037f260 = uStack104;\n\nDAT_8037f268 = uStack108;\n\nuRam8037f278 = 0;\n\nuRam8037f29c = uStack100;\n\nuRam8037f2b0 = CONCAT44(uStack96,uStack96);\n\nuRam8037f2b8 = CONCAT44(uStack92,uStack92);\n\nDAT_8037f264 = uVar12;\n\nDAT_8037f26c = uVar14;\n\nDAT_8037f270 = iVar15;\n\nuRam8037f274 = uVar11;\n\nuRam8037f298 = uVar7;\n\n_DAT_8037f2a0 = uVar4;\n\nDAT_8037f2a8 = iVar5;\n\nuRam8037f2ac = uVar10;\n\n_lck_spin_unlock(&DAT_8037d714);\n\nThe address 0x8037f260 is written to first, on the line DAT_8037f260 = uStack104;. This is actually the base address of the vc_info structure in memory. All other addresses written to in the above code are relative to this address.\n\nTaking this address, adding the KASLR slide and reading some bytes from it produced the following output:\n\nBillys-N90AP:/var/mobile root# ./kernread 0x9B17F260 0x50\n\n0x9b17f260: 000003c0 00000280 00000020 00000a00 | � �\n\n0x9b17f270: 92e31000 00000000 00000000 ffff0000 | �� ��\n\nNice! This definitely looks like it is the vc_info structure.\n\nWe can confirm that this is the case by comparing the values against the struct definition — the 3c0 and 280 (in hex) should represent the screen height and width in pixels. This checks out as I’m using an iPhone with a 3.5 inch display, so the decimal conversions of these values (960 and 640) are accurate.\n\nThe 5th value in the memory dump is what I was looking for — the v_baseaddr pointer to the start of the raw pixel data. Reading from this memory, we see a bunch of ffffffff values.\n\nBillys-N90AP:/var/mobile root# ./kernread 0x92e31000 0x100\n\n0x92e31000: ffffffff ffffffff ffffffff ffffffff | ���� ���� ����\n\n0x92e31010: ffffffff ffffffff ffffffff ffffffff | ���� ���� ����\n\n0x92e31020: ffffffff ffffffff ffffffff ffffffff | ���� ���� ����\n\n0x92e31030: ffffffff ffffffff ffffffff ffffffff | ���� ���� ����\n\n0x92e31040: ffffffff ffffffff ffffffff ffffffff | ���� ���� ����\n\nThis is because at the time of reading the memory, I had an app open on the iPhone’s screen with a white background, so these ffffffff values are representing those white pixels.\n\nHowever, when I read from the same memory when on the home screen, we get a different result:\n\nBillys-N90AP:/var/mobile root# ./kernread 0x92e31000 0x100\n\n0x92e31000: ff162341 ff162342 ff172442 ff152241 | �#A �#B �$B �\"A\n\n0x92e31010: ff152342 ff162342 ff162341 ff162241 | �#B �#B �#A �\"A\n\n0x92e31020: ff172341 ff162241 ff172341 ff162241 | �#A �\"A �#A �\"A\n\n0x92e31030: ff172240 ff172341 ff172241 ff172140 | �\"@ �#A �\"A �!@\n\n0x92e31040: ff172141 ff172341 ff16203e ff152041 | �!A �#A � > � A\n\nThese values are representing the blues and greens found on the default iOS 7 wallpaper on the SpringBoard.\n\nManipulating the pixels\n\nNow that we know exactly where the screen pixel values are held in kernel memory, we can move on to actually manipulating them.\n\nI started by writing a small program that writes some black and white pixels to the screen, just to test that any changes I made to the memory actually affected what was being displayed on the screen.\n\nThe result looked something like this:\n\nSo now I had confirmed that this was indeed the framebuffer and changes to the memory resulted in changes to what we see on the device’s screen almost immediately.\n\nCool! Now we can look at actually rendering something potentially useful.\n\nRendering characters\n\nThe next step was to figure out how to actually render alpha-numeric characters so we can print our own text strings over the display.\n\nI did some more digging around the XNU source and found some functions that appeared to be responsible for rendering characters on the screen. One of these functions was vc_render_char.\n\nThis function follows an algorithm that renders a specific character on the screen. The font used here is the iso_font which is the same font that is used during the verbose boot mode on iOS and macOS. It is defined as a 256*16 byte array in the file https://github.com/apple/darwin-xnu/blob/master/osfmk/console/iso_font.c.\n\nThe algorithm to render the characters works by taking a desired character — say ‘A’ — and using its ASCII code (65) multiplied by the desired character height in pixels and using it as an index into the iso_font array.\n\nA series of bit-shifts and bitwise ANDs are then performed on the values to produce an output value. Depending on this output value, either a black or white pixel is written to the framebuffer.\n\nI wrote some code to test if I could generate a character based on this algorithm, using the iso_font. The output was as follows:\n\n~/Documents/dev ./print_char\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 0 0 0 0 0 1 1\n\n0 0 1 1 1 0 0 1\n\n0 0 1 1 1 0 0 1\n\n0 0 1 1 1 0 0 1\n\n0 0 0 0 0 0 0 1\n\n0 0 1 1 1 0 0 1\n\n0 0 1 1 1 0 0 1\n\n0 0 1 1 1 0 0 1\n\n0 0 1 1 1 0 0 1\n\n0 0 1 1 1 0 0 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n1 1 1 1 1 1 1 1\n\n~/Documents/dev\n\nLooking closely at the above output, you can see that the 0 characters create the shape of a capital A and the 1 characters act as a background.\n\nTo translate this to screen pixel data all we have to do is render a white pixel when the value returned is a 0 and a black pixel when the value returned is a 1.\n\nFinal outcome\n\nAs a result of the above research, I managed write a program that allows me to render arbitrary text strings to the iPhone’s screen by directly modifying the framebuffer pixels!\n\nI guess this research doesn’t have any real practical use, but it was a fun project to work on and the end result looks pretty cool ;)\n\nIf you want to try running this code on your own jailbroken device, you can find the code for my fb_write tool here https://github.com/Billy-Ellis/framebuffer_write.\n\nRight now the offsets are hard-coded for the iPhone3,1 running iOS 7.1.2, but you can add your own for other devices you want to try this on.\n\nHopefully you enjoyed this post and got something out of it! Feedback is welcome — you can contact me @bellis1000 on Twitter or billy@zygosec.com via e-mail.\n\nThanks for reading!"
    }
}