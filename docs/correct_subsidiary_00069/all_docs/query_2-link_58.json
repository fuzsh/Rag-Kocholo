{
    "id": "correct_subsidiary_00069_2",
    "rank": 58,
    "data": {
        "url": "https://www.eficode.com/blog/migrate-from-synergy-to-git",
        "read_more_link": "",
        "language": "en",
        "title": "How to migrate from IBM Rational Synergy to Git",
        "top_image": "https://www.eficode.com/hubfs/images/blogs/670x670/migration-to-git.jpg",
        "meta_img": "https://www.eficode.com/hubfs/images/blogs/670x670/migration-to-git.jpg",
        "images": [
            "https://www.eficode.com/hubfs/images/logos/eficode_logo_black_70.svg",
            "https://mb.cision.com/Public/18902/3988509/aa9b3d7390e787da_200x200ar.png",
            "https://www.eficode.com/hs-fs/hubfs/images/blogs/670x670/migration-to-git.jpg?width=640&height=480&name=migration-to-git.jpg",
            "https://hubspot-no-cache-eu1-prod.s3.amazonaws.com/cta/default/2714969/ad0f7e42-b37a-4011-990f-ef8b757a92dd.png",
            "https://www.eficode.com/hs-fs/hubfs/images/blogs/670x670/migration-to-git-graph1%20(1).png?width=662&name=migration-to-git-graph1%20(1).png",
            "https://www.eficode.com/hs-fs/hubfs/images/blogs/670x670/migration-to-git-graph2.png?width=662&name=migration-to-git-graph2.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/People/claus-schneider-2.png?width=150&name=claus-schneider-2.png",
            "https://www.eficode.com/hubfs/images/icons-and-illustrations/f_logo_RGB-White_58.png",
            "https://www.eficode.com/hubfs/images/icons-and-illustrations/linkedin-white.svg",
            "https://www.eficode.com/hubfs/Eficode%202020%20Theme/Logos/x-logo-svg.svg",
            "https://www.eficode.com/hs-fs/hubfs/the-future-of-software/banners/The%20future%20of%20software%20-%20blue%20announcement.png?width=500&name=The%20future%20of%20software%20-%20blue%20announcement.png",
            "https://www.eficode.com/hs-fs/hubfs/the-future-of-software/banners/The%20future%20of%20software%20-%20blue%20announcement.png?width=500&name=The%20future%20of%20software%20-%20blue%20announcement.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/Blog%20images/cv-blogs/Git.png?width=500&name=Git.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/Blog%20images/cv-blogs/Git.png?width=500&name=Git.png",
            "https://www.eficode.com/hs-fs/hubfs/CITCON.png?width=500&name=CITCON.png",
            "https://www.eficode.com/hs-fs/hubfs/CITCON.png?width=500&name=CITCON.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/Hero%20images/continuous%20delivery.png?width=400&name=continuous%20delivery.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/Training%20and%20Academy/Training%20themed%20illustration%20-%20Git.png?width=400&name=Training%20themed%20illustration%20-%20Git.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/devops-for-executives-CTA.png?width=200&name=devops-for-executives-CTA.png",
            "https://www.eficode.com/hs-fs/hubfs/Eficode%202020%20site%20images/devops-for-executives-CTA.png?width=200&name=devops-for-executives-CTA.png",
            "https://hubspot-no-cache-eu1-prod.s3.amazonaws.com/cta/default/2714969/4bdc9e76-cbbf-4ebe-a619-66e278ad6f4c.png",
            "https://www.eficode.com/hubfs/Eficode%202020%20Theme/icons/eficode-icon-white.svg",
            "https://www.eficode.com/hubfs/Eficode%202020%20Theme/Logos/x-logo-svg.svg",
            "https://www.eficode.com/hubfs/Eficode%202020%20Theme/Logos/x-logo-svg.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Claus Schneider"
        ],
        "publish_date": "2020-08-20T08:46:12+00:00",
        "summary": "",
        "meta_description": "No one stays in IBM Rational Synergy voluntarily, but migrating is a scary task. We have some experiences that can help you plan your migration.",
        "meta_lang": "en",
        "meta_favicon": "https://www.eficode.com/hubfs/Images/Icons%20and%20illustrations/eficode-favicon.png",
        "meta_site_name": "Eficode.com",
        "canonical_link": "https://www.eficode.com/blog/migrate-from-synergy-to-git",
        "text": "The history of IBM Rational Synergy\n\nIBM Rational Synergy is a client-server based version control system that has evolved from a single file version control system in the 90’s to a task management system topped with a change management system called Change. It has been branded under different names (Continuus, CM/Synergy and most recently Rational® Synergy) over the years and under different companies ending at IBM® under the Rational® brand.\n\nIn the 2000’s it had a few strengths which gave it traction in the market. Firstly, it is a task-based configuration management system which is a step up from systems like CVS. In Synergy, you can assign tasks to developers that change and add file revisions and finally complete the task for a particular release.\n\nSecondly, it has the concept of repositories which are great for larger organizations - many teams delivering components to product lines.\n\nThirdly, it could be extended with Rational Change to implement software change management processes, customized hierarchies, properties and life-cycles.\n\nIBM Rational Synergy is close to its end of life\n\nThe tool is maintained, but has had no feature updates for many years, so it is close to its end-of-life. Due to this singularly critical reason it should be on the IT agenda to migrate quickly to a new system like Git.\n\nBeyond that, as a system, it is very slow to use, requires a lot of manual work to do trivial merges, is designed for long-living release branches and is complex to understand. All of this can kill development teams’ efficiency.\n\nMy experience is that teams and organizations develop a mindset of “don’t touch it”. This means they do not even develop or optimize their use of Synergy to meet the needs of the teams. They all live with it and work around it. This alone indicates that it is time to move on.\n\nThe big question is: can it be done? The short answer is “in all likelihood”. It really depends on the way Synergy has been used over the years.\n\nPlanning the migration\n\nMatching Synergy and Git data models\n\nSynergy has a very loose model for how software changes build up a revision. This presents challenges in migrating from Synergy to Git. The data models are completely different. These are the major differences.\n\nMapping concepts overview\n\nBased on the migration experiences, we have developed a migration strategy summarized in the table below with a quick verdict followed by detailed reasoning.\n\nSynergy\n\nGit\n\nFiles and history\n\nNot directly\n\nTasks\n\nNot directly\n\nBaselines\n\nNot directly\n\nReleases\n\nNo\n\nProjects and revisions\n\nRepository, commits and tags\n\nSubprojects\n\nSubmodules\n\nCustom attributes\n\nNo\n\nFiles and their history - not migrated directly\n\nFiles in Synergy have their own history of revisions and they could be interesting to migrate, but file revisions does not exist in Git as a revision itself.\n\nSynergy File objects have types and based on those the file can have different newlines, viewer and merge behaviors. To a large extent this can be implemented in .gitattributes. One thing which remains to be handled explicitly is execute bits as they are not automatically set in Git.\n\nBe aware of existing .gitignores and .gitattributes of imported source code as they can cause unintended behaviour when present during migration.\n\nMerges are carried out on a file object level.\n\nTasks - not migrated directly\n\nTasks would be the ideal object to migrate as it is a single change similar to a patch file in Git. This means that it does not have a parent relation. They will not be migrated, but they will be listed in commit messages and annotated tags.\n\nBaselines - not migrated directly\n\nBaselines, also called baseline objects, cannot be migrated as such, because it is just a meta-data container and a link to project revisions, tasks and Change Objects. The closest we get in Git is annotated tags and the baseline information is added as the annotation. Baselines are a relatively new concept and only became mandatory in version 7.x, so it is not a reliable source for migration.\n\nReleases - not migrated\n\nReleases are somewhat the same as branches, but they are usually used as long living release branches.They will only appear in the naming of the annotated tag.\n\nProjects and Project revisions - migrated\n\nProjects and Project revisions in a static state is the closest we get to a commit in Git. The static states of projects revisions are: integrate, test, sqa and released. This is a reproducible revision which is based on a previous revision, called a project baseline. The project revisions are the best migration object as it contains the revision of the source code and has the history relationship.\n\nA Synergy project should by default be mapped to a Git repository.\n\nThe revision name is usually the same as the release, build number or an ID the software organization can identify again later. Revision names or IDs are mapped to Git tags. After the migration, you will be able to find the equivalent software revision in Git with the same naming as you would in Synergy.\n\nProject names and revisions have far less restrictions than Git naming of repositories and tags. It means that you likely must replace spaces and odd characters with dashes or underscores and likely also need to unify project names to lowercase.\n\nIn Synergy, multiple projects can have the same name, handled by the instance attribute. How we migrate these should be guided by the reason why duplicated project names exist. It could be that there is a different project in the repository manager or the history of all instances has the same target Git repository.\n\nThere is no concept of merges on a project revision level as a project revision can only have one parent.\n\nIn case the project revisions does not represent the revisions, builds or releases or they don't exist at all – does this disqualify a migration?\n\nNo, not necessarily. Usually, software organizations have release notes or bill-of-materials. They state baseline revision, subproject revisions and task lists. In this case it is possible to replay the revision and migrate it to Git.\n\nSubprojects - migrated\n\nThey can be directly mapped to submodules in Git, as the data model is the same. A project can have another project added as a subproject in specific revision. It results in a directory in the workspace. It is the same in Git.\n\nCustom attributes - not migrated\n\nThey can be created on any object in the Synergy database. It gives special meaning to the development process which can be hard to redo in Git. It is not so much related to the migration itself, but how the development process adapted to working in Git.\n\nThe above should show that while you may lack a one to one mapping from Synergy to Git, you can make reasonable choices that allow us to migrate.\n\nHow to migrate\n\nSince projects and their revisions are the unit for migration, let us dig a bit deeper into how to do the migration.\n\nProjects\n\nFirstly, you need to figure out which projects from which databases you would like to migrate. You might already have a sense of what to migrate, but I recommend querying the databases for projects in order to avoid missing some.\n\nThe databases might have been around for longer than the people working in the teams currently. You need to assess the projects to determine if they are targeted for migration or can be skipped. Some projects have subprojects and you must determine how to migrate those. It should either be preserved as a submodule or it should be a subdirectory.\n\nFile revisions impact\n\nWorking in a client-server SCM has usually given patterns of storing artifacts, dependencies and tools in the source. It does not fit well with a distributed source control system like Git as you carry, by default, the whole history of commits and files with you.\n\nThe size of the repository itself, but also the increase in size per revision, gives the first indication if the repository is sustainable in the long run. Actions to remediate this can vary from removing files, adding to artifact manager, adding to Git Large Files System (LFS) or submodules. It is hard to say up front which solution is best for each file or area. That evaluation and actions should be decided within the organization.\n\nMetadata – Files, tasks and baselines\n\nAs mentioned above, the files, tasks and baselines cannot be migrated to Git as such, but they contain a lot of relevant information. The baseline object contains this information and it can be added to an annotated tag along with the commit message, which is great, as these are searchable via Git, but also parsable by Git repository managers. It will give you a traceability bridge from Synergy to Git.\n\nYou can migrate the Synergy tasks and Rational Change problems to your task management tool. The tasks can include information about the assignee, the release, a description and file lists.\n\nUsually, repository managers and task management systems have integrations, so you can reference tasks in commit messages. It is then possible to use this method to link together the project revisions migrated and tasks in the task management system. It will give great traceability to the historic revisions. I’ve done a migration targeting BitBucket and Jira in the past. Synergy tasks were migrated to Jira as stories along with FixVersions and components.\n\nIterations and verification\n\nExperience over the years tells me that you will have to tune the migration machinery a few times to get it right. It is an iterative process. There are decisions that need to be made, which is related to processes and structure. In all likelihood you are changing the engine of the car while you are driving, so you should expect to rehearse the migration several times.\n\nThe migration should be verified both from technical and process perspectives\n\nTechnically, you can compare the files and structures between a revision taken out of Synergy and a tag taken out of Git. Can we build and verify the software? Can you generate documentation, produce artifacts and releases?\n\nIn terms of process, you need to go through a full development and delivery lifecycle in Git to see that you are able to work from the Git base.\n\nExecuting the migration\n\nIn the previous sections, I highlighted challenges and potential solutions as a result of the different data models. Many of these elements are implemented in our open-source 2git tool which has been used for ClearCase and Synergy migrations.\n\nThe migration has two major parts. The first part is to get the source code out of Synergy and into Git without modifications and optimizations. The second part is to optimize the Git repository and add the dependencies.\n\nSynergy to Git:\n\nRun 2git with ccm2git driver. The result is Git history which is not optimized and without submodules\n\nFile and structure compare between the same revision taken from Synergy and Git\n\nBuild software from Git\n\nEvaluate the result\n\nDo repository analysis to find files to remove and LFS configuration for phase 2.\n\nOne option could be use the git-repo-analyser to files with biggest impact to Git repository\n\nRepeat these steps until you are satisfied with the migration.\n\nGit optimization:\n\nUpdate .gitignore and .gitattributes from repository analysis in phase 1\n\nAdd dependencies to an artifact management system\n\nRun 2git with git2git-with-ccm-flavour. The result is a Git history which is optimized with submodules.\n\nFile and structure compare between the same revision taken from Synergy and Git\n\nAdd dependencies and tools that are not present in Git\n\nBased on your decisions. Update the 2git tool to get dependencies and tools\n\nBuild software from Git\n\nEvaluate the result\n\nRepeat the above steps until you are satisfied\n\nGoing live\n\nDelta and partial migrations\n\nFor larger organizations, it can be problematic to get team members trained in Git and new processes. In this case, it can be beneficial to do partial migrations. This can either be on project level or it can be based on Synergy releases.\n\n2git can handle delta migrations and only migrate the missing project revisions to Git which makes it flexible and less of a ‘big bang’. I’d advise that you start with top level projects. Firstly, because the top level project does not have any other Synergy projects depending on them and secondly you can verify earlier that you can produce product releases based on the new tool stack, which lowers the risk in the software projects. The subsystems can still release in Synergy and the Git tag/commit becomes available for integration after another run of 2git\n\nDefine branching strategy\n\nSynergy and Git are different regarding releases and branches as mentioned. In both setups, a developer delivers changes to a release or branch respectively, but in Synergy there is not such a thing as a default branch or the concept of trunk based development. You might have handled it yourself in Synergy which is great and you can take advantage of the Git way of doing things immediately, by announcing the default branch as the same.\n\nThere are many approaches to Git branch management and it’s hard to advise on which route to take without a deep knowledge about your current way of working and constraints.\n\nI suggest that you investigate the migrated history in Git to get a good understanding of how your software assets have evolved over time. You can see very visually how the project revisions and their baselines have developed over time and where there are splits in the history.\n\nEach split indicates a branch, but you are only interested in the potential active branches that will have commits in the immediate future. You can always create more as needed.\n\nFollowing up\n\nYou have now transferred to Git and are reaping the benefits, but it can be hard to change habits.\n\nAs an example, organizations tend to continue to do development on release branches. But with Git you could do features on the master branch instead and only create release branches when and if they are needed for maturing. You need to work actively to shift from early to late branching, so you can benefit from a less divergent code base.\n\nMerging is expensive in Synergy and as a consequence you rarely merge the release branches back to the mainline. You might even not merge the changes at all: instead developers are asked to reimplement the same changes on several branches.\n\nYou can now create a branching strategy that enables this in an automated manner. Git is both fast and reliable at doing merges. It can even be implemented in your continuous integration platform. I prefer the Git Phlow as it is designed so you can implement changes only once and automation propagates the change to the mainline via trivial merges.\n\nConclusion\n\nA Synergy migration is usually scary because of the scale and the legacy tooling around it, but it is very much possible with the right knowledge and skills. Experience also helps. We have helped large global organizations through this."
    }
}