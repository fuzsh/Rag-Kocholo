{
    "id": "dbpedia_4811_1",
    "rank": 6,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Web_server",
        "read_more_link": "",
        "language": "en",
        "title": "Web server",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/1/1e/Web_server_serving_static_content.png",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/1/1e/Web_server_serving_static_content.png",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/99/Question_book-new.svg/50px-Question_book-new.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Web_server_serving_static_content.png/221px-Web_server_serving_static_content.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/38/Inside_and_Rear_of_Webserver.jpg/300px-Inside_and_Rear_of_Webserver.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/6/69/Wikimedia_Foundation_Servers-8055_35.jpg/300px-Wikimedia_Foundation_Servers-8055_35.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/98/Wikimedia_Servers-0051_10.jpg/320px-Wikimedia_Servers-0051_10.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/34/Acorplan120m.jpg/160px-Acorplan120m.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8d/Ginevra%2C_centro_visitatori_del_cern%2C_primo_server_della_storia_%281989%29%2C_02.JPG/120px-Ginevra%2C_centro_visitatori_del_cern%2C_primo_server_della_storia_%281989%29%2C_02.JPG",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d1/First_Web_Server.jpg/220px-First_Web_Server.jpg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/1/1d/Information_icon4.svg/40px-Information_icon4.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/1/1d/Information_icon4.svg/40px-Information_icon4.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/6/6d/Cobalt_Qube_3_Front.jpg/220px-Cobalt_Qube_3_Front.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/c/c9/Client-server-model.svg/250px-Client-server-model.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/5/53/Ambox_current_red_Americas.svg/42px-Ambox_current_red_Americas.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1e/Web_server_serving_static_content.png/221px-Web_server_serving_static_content.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/94/Web_server_serving_static_and_dynamic_content.png/221px-Web_server_serving_static_and_dynamic_content.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/3e/Web_server_directory_list.png/271px-Web_server_directory_list.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/12/Usage_share_of_web_servers_%28Source_Netcraft%29.svg/300px-Usage_share_of_web_servers_%28Source_Netcraft%29.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/0/09/Usage_share_of_web_servers_%28Source_Netcraft%29_1995-2005.svg/300px-Usage_share_of_web_servers_%28Source_Netcraft%29_1995-2005.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2001-08-10T16:16:25+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Web_server",
        "text": "Computer software that distributes web pages\n\nA web server is computer software and underlying hardware that accepts requests via HTTP (the network protocol created to distribute web content) or its secure variant HTTPS. A user agent, commonly a web browser or web crawler, initiates communication by making a request for a web page or other resource using HTTP, and the server responds with the content of that resource or an error message. A web server can also accept and store resources sent from the user agent if configured to do so.[1][2]\n\nThe hardware used to run a web server can vary according to the volume of requests that it needs to handle. At the low end of the range are embedded systems, such as a router that runs a small web server as its configuration interface. A high-traffic Internet website might handle requests with hundreds of servers that run on racks of high-speed computers.\n\nA resource sent from a web server can be a pre-existing file (static content) available to the web server, or it can be generated at the time of the request (dynamic content) by another program that communicates with the server software. The former usually can be served faster and can be more easily cached for repeated requests, while the latter supports a broader range of applications.\n\nTechnologies such as REST and SOAP, which use HTTP as a basis for general computer-to-computer communication, as well as support for WebDAV extensions, have extended the application of web servers well beyond their original purpose of serving human-readable pages.\n\nHistory\n\n[edit]\n\nThis is a very brief history of web server programs, so some information necessarily overlaps with the histories of the web browsers, the World Wide Web and the Internet; therefore, for the sake of clarity and understandability, some key historical information below reported may be similar to that found also in one or more of the above-mentioned history articles.\n\nInitial WWW project (1989–1991)\n\n[edit]\n\nIn March 1989, Sir Tim Berners-Lee proposed a new project to his employer CERN, with the goal of easing the exchange of information between scientists by using a hypertext system. The proposal titled \"HyperText and CERN\", asked for comments and it was read by several people. In October 1990 the proposal was reformulated and enriched (having as co-author Robert Cailliau), and finally, it was approved.[3][4][5]\n\nBetween late 1990 and early 1991 the project resulted in Berners-Lee and his developers writing and testing several software libraries along with three programs, which initially ran on NeXTSTEP OS installed on NeXT workstations: [6] [7] [5]\n\na graphical web browser, called WorldWideWeb;\n\na portable line mode web browser;\n\na web server, later known as CERN httpd.\n\nThose early browsers retrieved web pages written in a simple early form of HTML, from web server(s) using a new basic communication protocol that was named HTTP 0.9.\n\nIn August 1991 Tim Berners-Lee announced the birth of WWW technology and encouraged scientists to adopt and develop it.[8] Soon after, those programs, along with their source code, were made available to people interested in their usage.[6] Although the source code was not formally licensed or placed in the public domain, CERN informally allowed users and developers to experiment and further develop on top of them. Berners-Lee started promoting the adoption and the usage of those programs along with their porting to other operating systems.[5]\n\nFast and wild development (1991–1995)\n\n[edit]\n\nIn December 1991, the first web server outside Europe was installed at SLAC (U.S.A.).[7] This was a very important event because it started trans-continental web communications between web browsers and web servers.\n\nIn 1991–1993, CERN web server program continued to be actively developed by the www group, meanwhile, thanks to the availability of its source code and the public specifications of the HTTP protocol, many other implementations of web servers started to be developed.\n\nIn April 1993, CERN issued a public official statement stating that the three components of Web software (the basic line-mode client, the web server and the library of common code), along with their source code, were put in the public domain.[11] This statement freed web server developers from any possible legal issue about the development of derivative work based on that source code (a threat that in practice never existed).\n\nAt the beginning of 1994, the most notable among new web servers was NCSA httpd which ran on a variety of Unix-based OSs and could serve dynamically generated content by implementing the POST HTTP method and the CGI to communicate with external programs. These capabilities, along with the multimedia features of NCSA's Mosaic browser (also able to manage HTML FORMs in order to send data to a web server) highlighted the potential of web technology for publishing and distributed computing applications.\n\nIn the second half of 1994, the development of NCSA httpd stalled to the point that a group of external software developers, webmasters and other professional figures interested in that server, started to write and collect patches thanks to the NCSA httpd source code being available to the public domain. At the beginning of 1995 those patches were all applied to the last release of NCSA source code and, after several tests, the Apache HTTP server project was started.[12][13]\n\nAt the end of 1994, a new commercial web server, named Netsite, was released with specific features. It was the first one of many other similar products that were developed first by Netscape, then also by Sun Microsystems, and finally by Oracle Corporation.\n\nIn mid-1995, the first version of IIS was released, for Windows NT OS, by Microsoft. This marked the entry, in the field of World Wide Web technologies, of a very important commercial developer and vendor that has played and still is playing a key role on both sides (client and server) of the web.\n\nIn the second half of 1995, CERN and NCSA web servers started to decline (in global percentage usage) because of the widespread adoption of new web servers which had a much faster development cycle along with more features, more fixes applied, and more performances than the previous ones.\n\nExplosive growth and competition (1996–2014)\n\n[edit]\n\nAt the end of 1996, there were already over fifty known (different) web server software programs that were available to everybody who wanted to own an Internet domain name and/or to host websites.[15] Many of them lived only shortly and were replaced by other web servers.\n\nThe publication of RFCs about protocol versions HTTP/1.0 (1996) and HTTP/1.1 (1997, 1999), forced most web servers to comply (not always completely) with those standards. The use of TCP/IP persistent connections (HTTP/1.1) required web servers both to increase the maximum number of concurrent connections allowed and to improve their level of scalability.\n\nBetween 1996 and 1999, Netscape Enterprise Server and Microsoft's IIS emerged among the leading commercial options whereas among the freely available and open-source programs Apache HTTP Server held the lead as the preferred server (because of its reliability and its many features).\n\nIn those years there was also another commercial, highly innovative and thus notable web server called Zeus (now discontinued) that was known as one of the fastest and most scalable web servers available on market, at least till the first decade of 2000s, despite its low percentage of usage.\n\nApache resulted in the most used web server from mid-1996 to the end of 2015 when, after a few years of decline, it was surpassed initially by IIS and then by Nginx. Afterward IIS dropped to much lower percentages of usage than Apache (see also market share).\n\nFrom 2005–2006, Apache started to improve its speed and its scalability level by introducing new performance features (e.g. event MPM and new content cache).[16][17] As those new performance improvements initially were marked as experimental, they were not enabled by its users for a long time and so Apache suffered, even more, the competition of commercial servers and, above all, of other open-source servers which meanwhile had already achieved far superior performances (mostly when serving static content) since the beginning of their development and at the time of the Apache decline were able to offer also a long enough list of well tested advanced features.\n\nIn fact, a few years after 2000 started, not only other commercial and highly competitive web servers, e.g. LiteSpeed, but also many other open-source programs, often of excellent quality and very high performances, among which should be noted Hiawatha, Cherokee HTTP server, Lighttpd, Nginx and other derived/related products also available with commercial support, emerged.\n\nAround 2007–2008, most popular web browsers increased their previous default limit of 2 persistent connections per host-domain (a limit recommended by RFC-2616)[18] to 4, 6 or 8 persistent connections per host-domain, in order to speed up the retrieval of heavy web pages with lots of images, and to mitigate the problem of the shortage of persistent connections dedicated to dynamic objects used for bi-directional notifications of events in web pages.[19] Within a year, these changes, on average, nearly tripled the maximum number of persistent connections that web servers had to manage. This trend (of increasing the number of persistent connections) definitely gave a strong impetus to the adoption of reverse proxies in front of slower web servers and it gave also one more chance to the emerging new web servers that could show all their speed and their capability to handle very high numbers of concurrent connections without requiring too many hardware resources (expensive computers with lots of CPUs, RAM and fast disks).[20]\n\nNew challenges (2015 and later years)\n\n[edit]\n\nIn 2015, RFCs published new protocol version [HTTP/2], and as the implementation of new specifications was not trivial at all, a dilemma arose among developers of less popular web servers (e.g. with a percentage of usage lower than 1% .. 2%), about adding or not adding support for that new protocol version.[21][22]\n\nIn fact supporting HTTP/2 often required radical changes to their internal implementation due to many factors (practically always required encrypted connections, capability to distinguish between HTTP/1.x and HTTP/2 connections on the same TCP port, binary representation of HTTP messages, message priority, compression of HTTP headers, use of streams also known as TCP/IP sub-connections and related flow-control, etc.) and so a few developers of those web servers opted for not supporting new HTTP/2 version (at least in the near future) also because of these main reasons:[21][22]\n\nprotocols HTTP/1.x would have been supported anyway by browsers for a very long time (maybe forever) so that there would be no incompatibility between clients and servers in next future;\n\nimplementing HTTP/2 was considered a task of overwhelming complexity that could open the door to a whole new class of bugs that till 2015 did not exist and so it would have required notable investments in developing and testing the implementation of the new protocol;\n\nadding HTTP/2 support could always be done in future in case the efforts would be justified.\n\nInstead, developers of most popular web servers, rushed to offer the availability of new protocol, not only because they had the work force and the time to do so, but also because usually their previous implementation of SPDY protocol could be reused as a starting point and because most used web browsers implemented it very quickly for the same reason. Another reason that prompted those developers to act quickly was that webmasters felt the pressure of the ever increasing web traffic and they really wanted to install and to try – as soon as possible – something that could drastically lower the number of TCP/IP connections and speedup accesses to hosted websites.[23]\n\nIn 2020–2021 the HTTP/2 dynamics about its implementation (by top web servers and popular web browsers) were partly replicated after the publication of advanced drafts of future RFC about HTTP/3 protocol.\n\nTechnical overview\n\n[edit]\n\nThe following technical overview should be considered only as an attempt to give a few very limited examples about some features that may be implemented in a web server and some of the tasks that it may perform in order to have a sufficiently wide scenario about the topic.\n\nA web server program plays the role of a server in a client–server model by implementing one or more versions of HTTP protocol, often including the HTTPS secure variant and other features and extensions that are considered useful for its planned usage.\n\nThe complexity and the efficiency of a web server program may vary a lot depending on (e.g.):[1]\n\ncommon features implemented;\n\ncommon tasks performed;\n\nperformances and scalability level aimed as a goal;\n\nsoftware model and techniques adopted to achieve wished performance and scalability level;\n\ntarget hardware and category of usage, e.g. embedded system, low-medium traffic web server, high traffic Internet web server.\n\nCommon features\n\n[edit]\n\nAlthough web server programs differ in how they are implemented, most of them offer the following common features.\n\nThese are basic features that most web servers usually have.\n\nStatic content serving: to be able to serve static content (web files) to clients via HTTP protocol.\n\nHTTP: support for one or more versions of HTTP protocol in order to send versions of HTTP responses compatible with versions of client HTTP requests, e.g. HTTP/1.0, HTTP/1.1 (eventually also with encrypted connections HTTPS), plus, if available, HTTP/2, HTTP/3.\n\nLogging: usually web servers have also the capability of logging some information, about client requests and server responses, to log files for security and statistical purposes.\n\nA few other more advanced and popular features (only a very short selection) are the following ones.\n\nDynamic content serving: to be able to serve dynamic content (generated on the fly) to clients via HTTP protocol.\n\nVirtual hosting: to be able to serve many websites (domain names) using only one IP address.\n\nAuthorization: to be able to allow, to forbid or to authorize access to portions of website paths (web resources).\n\nContent cache: to be able to cache static and/or dynamic content in order to speed up server responses;\n\nLarge file support: to be able to serve files whose size is greater than 2 GB on 32 bit OS.\n\nBandwidth throttling: to limit the speed of content responses in order to not saturate the network and to be able to serve more clients;\n\nRewrite engine: to map parts of clean URLs (found in client requests) to their real names.\n\nCustom error pages: support for customized HTTP error messages.\n\nCommon tasks\n\n[edit]\n\nA web server program, when it is running, usually performs several general tasks, (e.g.):[1]\n\nstarts, optionally reads and applies settings found in its configuration file(s) or elsewhere, optionally opens log file, starts listening to client connections / requests;\n\noptionally tries to adapt its general behavior according to its settings and its current operating conditions;\n\nmanages client connection(s) (accepting new ones or closing the existing ones as required);\n\nreceives client requests (by reading HTTP messages):\n\nreads and verify each HTTP request message;\n\nusually performs URL normalization;\n\nusually performs URL mapping (which may default to URL path translation);\n\nusually performs URL path translation along with various security checks;\n\nexecutes or refuses requested HTTP method:\n\noptionally manages URL authorizations;\n\noptionally manages URL redirections;\n\noptionally manages requests for static resources (file contents):\n\noptionally manages directory index files;\n\noptionally manages regular files;\n\noptionally manages requests for dynamic resources:\n\noptionally manages directory listings;\n\noptionally manages program or module processing, checking the availability, the start and eventually the stop of the execution of external programs used to generate dynamic content;\n\noptionally manages the communications with external programs / internal modules used to generate dynamic content;\n\nreplies to client requests sending proper HTTP responses (e.g. requested resources or error messages) eventually verifying or adding HTTP headers to those sent by dynamic programs / modules;\n\noptionally logs (partially or totally) client requests and/or its responses to an external user log file or to a system log file by syslog, usually using common log format;\n\noptionally logs process messages about detected anomalies or other notable events (e.g. in client requests or in its internal functioning) using syslog or some other system facilities; these log messages usually have a debug, warning, error, alert level which can be filtered (not logged) depending on some settings, see also severity level;\n\noptionally generates statistics about web traffic managed and/or its performances;\n\nother custom tasks.\n\nRead request message\n\n[edit]\n\nWeb server programs are able:[24] [25] [26]\n\nto read an HTTP request message;\n\nto interpret it;\n\nto verify its syntax;\n\nto identify known HTTP headers and to extract their values from them.\n\nOnce an HTTP request message has been decoded and verified, its values can be used to determine whether that request can be satisfied or not. This requires many other steps, including security checks.\n\nURL normalization\n\n[edit]\n\nMain article: URL normalization\n\nWeb server programs usually perform some type of URL normalization (URL found in most HTTP request messages) in order to:\n\nmake resource path always a clean uniform path from root directory of website;\n\nlower security risks (e.g. by intercepting more easily attempts to access static resources outside the root directory of the website or to access to portions of path below website root directory that are forbidden or which require authorization);\n\nmake path of web resources more recognizable by human beings and web log analysis programs (also known as log analyzers / statistical applications).\n\nThe term URL normalization refers to the process of modifying and standardizing a URL in a consistent manner. There are several types of normalization that may be performed, including the conversion of the scheme and host to lowercase. Among the most important normalizations are the removal of \".\" and \"..\" path segments and adding trailing slashes to a non-empty path component.\n\nURL mapping\n\n[edit]\n\nMain article: URL mapping\n\n\"URL mapping is the process by which a URL is analyzed to figure out what resource it is referring to, so that that resource can be returned to the requesting client. This process is performed with every request that is made to a web server, with some of the requests being served with a file, such as an HTML document, or a gif image, others with the results of running a CGI program, and others by some other process, such as a built-in module handler, a PHP document, or a Java servlet.\"[27][needs update]\n\nIn practice, web server programs that implement advanced features, beyond the simple static content serving (e.g. URL rewrite engine, dynamic content serving), usually have to figure out how that URL has to be handled, e.g. as a:\n\nURL redirection, a redirection to another URL;\n\nstatic request of file content;\n\ndynamic request of:\n\ndirectory listing of files or other sub-directories contained in that directory;\n\nother types of dynamic request in order to identify the program / module processor able to handle that kind of URL path and to pass to it other URL parts, i.e. usually path-info and query string variables.\n\nOne or more configuration files of web server may specify the mapping of parts of URL path (e.g. initial parts of file path, filename extension and other path components) to a specific URL handler (file, directory, external program or internal module).[28]\n\nWhen a web server implements one or more of the above-mentioned advanced features then the path part of a valid URL may not always match an existing file system path under website directory tree (a file or a directory in file system) because it can refer to a virtual name of an internal or external module processor for dynamic requests.\n\nURL path translation to file system\n\n[edit]\n\nWeb server programs are able to translate an URL path (all or part of it), that refers to a physical file system path, to an absolute path under the target website's root directory.[28]\n\nWebsite's root directory may be specified by a configuration file or by some internal rule of the web server by using the name of the website which is the host part of the URL found in HTTP client request.[28]\n\nPath translation to file system is done for the following types of web resources:\n\na local, usually non-executable, file (static request for file content);\n\na local directory (dynamic request: directory listing generated on the fly);\n\na program name (dynamic requests that is executed using CGI or SCGI interface and whose output is read by web server and resent to client who made the HTTP request).\n\nThe web server appends the path found in requested URL (HTTP request message) and appends it to the path of the (Host) website root directory. On an Apache server, this is commonly /home/www/website (on Unix machines, usually it is: /var/www/website). See the following examples of how it may result.\n\nURL path translation for a static file request\n\nExample of a static request of an existing file specified by the following URL:\n\nhttp://www.example.com/path/file.html\n\nThe client's user agent connects to www.example.com and then sends the following HTTP/1.1 request:\n\nGET /path/file.html HTTP/1.1 Host: www.example.com Connection: keep-alive\n\nThe result is the local file system resource:\n\n/home/www/www.example.com/path/file.html\n\nThe web server then reads the file, if it exists, and sends a response to the client's web browser. The response will describe the content of the file and contain the file itself or an error message will return saying that the file does not exist or its access is forbidden.\n\nURL path translation for a directory request (without a static index file)\n\nExample of an implicit dynamic request of an existing directory specified by the following URL:\n\nhttp://www.example.com/directory1/directory2/\n\nThe client's user agent connects to www.example.com and then sends the following HTTP/1.1 request:\n\nGET /directory1/directory2 HTTP/1.1 Host: www.example.com Connection: keep-alive\n\nThe result is the local directory path:\n\n/home/www/www.example.com/directory1/directory2/\n\nThe web server then verifies the existence of the directory and if it exists and it can be accessed then tries to find out an index file (which in this case does not exist) and so it passes the request to an internal module or a program dedicated to directory listings and finally reads data output and sends a response to the client's web browser. The response will describe the content of the directory (list of contained subdirectories and files) or an error message will return saying that the directory does not exist or its access is forbidden.\n\nURL path translation for a dynamic program request\n\nFor a dynamic request the URL path specified by the client should refer to an existing external program (usually an executable file with a CGI) used by the web server to generate dynamic content.[29]\n\nExample of a dynamic request using a program file to generate output:\n\nhttp://www.example.com/cgi-bin/forum.php?action=view&orderby=thread&date=2021-10-15\n\nThe client's user agent connects to www.example.com and then sends the following HTTP/1.1 request:\n\nGET /cgi-bin/forum.php?action=view&ordeby=thread&date=2021-10-15 HTTP/1.1 Host: www.example.com Connection: keep-alive\n\nThe result is the local file path of the program (in this example, a PHP program):\n\n/home/www/www.example.com/cgi-bin/forum.php\n\nThe web server executes that program, passing in the path-info and the query string action=view&orderby=thread&date=2021-10-15 so that the program has the info it needs to run. (In this case, it will return an HTML document containing a view of forum entries ordered by thread from October 15, 2021). In addition to this, the web server reads data sent from the external program and resends that data to the client that made the request.\n\nManage request message\n\n[edit]\n\nOnce a request has been read, interpreted, and verified, it has to be managed depending on its method, its URL, and its parameters, which may include values of HTTP headers.\n\nIn practice, the web server has to handle the request by using one of these response paths:[28]\n\nif something in request was not acceptable (in status line or message headers), web server already sent an error response;\n\nif request has a method (e.g. OPTIONS) that can be satisfied by general code of web server then a successful response is sent;\n\nif URL requires authorization then an authorization error message is sent;\n\nif URL maps to a redirection then a redirect message is sent;\n\nif URL maps to a dynamic resource (a virtual path or a directory listing) then its handler (an internal module or an external program) is called and request parameters (query string and path info) are passed to it in order to allow it to reply to that request;\n\nif URL maps to a static resource (usually a file on file system) then the internal static handler is called to send that file;\n\nif request method is not known or if there is some other unacceptable condition (e.g. resource not found, internal server error, etc.) then an error response is sent.\n\nServe static content\n\n[edit]\n\nIf a web server program is capable of serving static content and it has been configured to do so, then it is able to send file content whenever a request message has a valid URL path matching (after URL mapping, URL translation and URL redirection) that of an existing file under the root directory of a website and file has attributes which match those required by internal rules of web server program.[28]\n\nThat kind of content is called static because usually it is not changed by the web server when it is sent to clients and because it remains the same until it is modified (file modification) by some program.\n\nNOTE: when serving static content only, a web server program usually does not change file contents of served websites (as they are only read and never written) and so it suffices to support only these HTTP methods:\n\nOPTIONS\n\nHEAD\n\nGET\n\nResponse of static file content can be sped up by a file cache.\n\nDirectory index files\n\n[edit]\n\nMain article: Web server directory index\n\nIf a web server program receives a client request message with an URL whose path matches one of an existing directory and that directory is accessible and serving directory index file(s) is enabled then a web server program may try to serve the first of known (or configured) static index file names (a regular file) found in that directory; if no index file is found or other conditions are not met then an error message is returned.\n\nMost used names for static index files are: index.html, index.htm and Default.htm.\n\nRegular files\n\n[edit]\n\nIf a web server program receives a client request message with an URL whose path matches the file name of an existing file and that file is accessible by web server program and its attributes match internal rules of web server program, then web server program can send that file to client.\n\nUsually, for security reasons, most web server programs are pre-configured to serve only regular files or to avoid to use special file types like device files, along with symbolic links or hard links to them. The aim is to avoid undesirable side effects when serving static web resources.[30]\n\nServe dynamic content\n\n[edit]\n\nIf a web server program is capable of serving dynamic content and it has been configured to do so, then it is able to communicate with the proper internal module or external program (associated with the requested URL path) in order to pass to it the parameters of the client request. After that, the web server program reads from it its data response (that it has generated, often on the fly) and then it resends it to the client program who made the request.[citation needed]\n\nNOTE: when serving static and dynamic content, a web server program usually has to support also the following HTTP method in order to be able to safely receive data from client(s) and so to be able to host also websites with interactive form(s) that may send large data sets (e.g. lots of data entry or file uploads) to web server / external programs / modules:\n\nPOST\n\nIn order to be able to communicate with its internal modules and/or external programs, a web server program must have implemented one or more of the many available gateway interface(s) (see also Web Server Gateway Interfaces used for dynamic content).\n\nThe three standard and historical gateway interfaces are the following ones.\n\nCGI\n\nAn external CGI program is run by web server program for each dynamic request, then web server program reads from it the generated data response and then resends it to client.\n\nSCGI\n\nAn external SCGI program (it usually is a process) is started once by web server program or by some other program / process and then it waits for network connections; every time there is a new request for it, web server program makes a new network connection to it in order to send request parameters and to read its data response, then network connection is closed.\n\nFastCGI\n\nAn external FastCGI program (it usually is a process) is started once by web server program or by some other program / process and then it waits for a network connection which is established permanently by web server; through that connection are sent the request parameters and read data responses.\n\nDirectory listings\n\n[edit]\n\nMain article: Web server directory index\n\nA web server program may be capable to manage the dynamic generation (on the fly) of a directory index list of files and sub-directories.[31]\n\nIf a web server program is configured to do so and a requested URL path matches an existing directory and its access is allowed and no static index file is found under that directory then a web page (usually in HTML format), containing the list of files and/or subdirectories of above mentioned directory, is dynamically generated (on the fly). If it cannot be generated an error is returned.\n\nSome web server programs allow the customization of directory listings by allowing the usage of a web page template (an HTML document containing placeholders, e.g. $(FILE_NAME), $(FILE_SIZE), etc., that are replaced with the field values of each file entry found in directory by web server), e.g. index.tpl or the usage of HTML and embedded source code that is interpreted and executed on the fly, e.g. index.asp, and / or by supporting the usage of dynamic index programs such as CGIs, SCGIs, FCGIs, e.g. index.cgi, index.php, index.fcgi.\n\nUsage of dynamically generated directory listings is usually avoided or limited to a few selected directories of a website because that generation takes much more OS resources than sending a static index page.\n\nThe main usage of directory listings is to allow the download of files (usually when their names, sizes, modification date-times or file attributes may change randomly / frequently) as they are, without requiring to provide further information to requesting user.[32]\n\nProgram or module processing\n\n[edit]\n\nAn external program or an internal module (processing unit) can execute some sort of application function that may be used to get data from or to store data to one or more data repositories, e.g.:[citation needed]\n\nfiles (file system);\n\ndatabases (DBs);\n\nother sources located in local computer or in other computers.\n\nA processing unit can return any kind of web content, also by using data retrieved from a data repository, e.g.:[citation needed]\n\na document (e.g. HTML, XML, etc.);\n\nan image;\n\na video;\n\nstructured data, e.g. that may be used to update one or more values displayed by a dynamic page (DHTML) of a web interface and that maybe was requested by an XMLHttpRequest API (see also: dynamic page).\n\nIn practice whenever there is content that may vary, depending on one or more parameters contained in client request or in configuration settings, then, usually, it is generated dynamically.\n\nSend response message\n\n[edit]\n\nWeb server programs are able to send response messages as replies to client request messages.[24]\n\nAn error response message may be sent because a request message could not be successfully read or decoded or analyzed or executed.[25]\n\nNOTE: the following sections are reported only as examples to help to understand what a web server, more or less, does; these sections are by any means neither exhaustive nor complete.\n\nError message\n\n[edit]\n\nA web server program may reply to a client request message with many kinds of error messages, anyway these errors are divided mainly in two categories:\n\nHTTP client errors, due to the type of request message or to the availability of requested web resource;[33]\n\nHTTP server errors, due to internal server errors.[34]\n\nWhen an error response / message is received by a client browser, then if it is related to the main user request (e.g. an URL of a web resource such as a web page) then usually that error message is shown in some browser window / message.\n\nURL authorization\n\n[edit]\n\nA web server program may be able to verify whether the requested URL path:[35]\n\ncan be freely accessed by everybody;\n\nrequires a user authentication (request of user credentials, e.g. such as user name and password);\n\naccess is forbidden to some or all kind of users.\n\nIf the authorization / access rights feature has been implemented and enabled and access to web resource is not granted, then, depending on the required access rights, a web server program:\n\ncan deny access by sending a specific error message (e.g. access forbidden);\n\nmay deny access by sending a specific error message (e.g. access unauthorized) that usually forces the client browser to ask human user to provide required user credentials; if authentication credentials are provided then web server program verifies and accepts or rejects them.\n\nURL redirection\n\n[edit]\n\nMain article: URL redirection\n\nA web server program may have the capability of doing URL redirections to new URLs (new locations) which consists in replying to a client request message with a response message containing a new URL suited to access a valid or an existing web resource (client should redo the request with the new URL).[36]\n\nURL redirection of location is used:[36]\n\nto fix a directory name by adding a final slash '/';[31]\n\nto give a new URL for a no more existing URL path to a new path where that kind of web resource can be found.\n\nto give a new URL to another domain when current domain has too much load.\n\nExample 1: a URL path points to a directory name but it does not have a final slash '/' so web server sends a redirect to client in order to instruct it to redo the request with the fixed path name.[31]\n\nFrom:\n\n/directory1/directory2\n\nTo:\n\n/directory1/directory2/\n\nExample 2: a whole set of documents has been moved inside website in order to reorganize their file system paths.\n\nFrom:\n\n/directory1/directory2/2021-10-08/\n\nTo:\n\n/directory1/directory2/2021/10/08/\n\nExample 3: a whole set of documents has been moved to a new website and now it is mandatory to use secure HTTPS connections to access them.\n\nFrom:\n\nhttp://www.example.com/directory1/directory2/2021-10-08/\n\nTo:\n\nhttps://docs.example.com/directory1/2021-10-08/\n\nAbove examples are only a few of the possible kind of redirections.\n\nSuccessful message\n\n[edit]\n\nA web server program is able to reply to a valid client request message with a successful message, optionally containing requested web resource data.[37]\n\nIf web resource data is sent back to client, then it can be static content or dynamic content depending on how it has been retrieved (from a file or from the output of some program / module).\n\nContent cache\n\n[edit]\n\nIn order to speed up web server responses by lowering average HTTP response times and hardware resources used, many popular web servers implement one or more content caches, each one specialized in a content category.[38] [39]\n\nContent is usually cached by its origin, e.g.:\n\nstatic content:\n\nfile cache;\n\ndynamic content:\n\ndynamic cache (module / program output).\n\nFile cache\n\n[edit]\n\nHistorically, static contents found in files which had to be accessed frequently, randomly and quickly, have been stored mostly on electro-mechanical disks since mid-late 1960s / 1970s; regrettably reads from and writes to those kind of devices have always been considered very slow operations when compared to RAM speed and so, since early OSs, first disk caches and then also OS file cache sub-systems were developed to speed up I/O operations of frequently accessed data / files.\n\nEven with the aid of an OS file cache, the relative / occasional slowness of I/O operations involving directories and files stored on disks became soon a bottleneck in the increase of performances expected from top level web servers, specially since mid-late 1990s, when web Internet traffic started to grow exponentially along with the constant increase of speed of Internet / network lines.\n\nThe problem about how to further efficiently speed-up the serving of static files, thus increasing the maximum number of requests/responses per second (RPS), started to be studied / researched since mid 1990s, with the aim to propose useful cache models that could be implemented in web server programs.[40]\n\nIn practice, nowadays, many popular / high performance web server programs include their own userland file cache, tailored for a web server usage and using their specific implementation and parameters.[41] [42] [43]\n\nThe wide spread adoption of RAID and/or fast solid-state drives (storage hardware with very high I/O speed) has slightly reduced but of course not eliminated the advantage of having a file cache incorporated in a web server.\n\nDynamic cache\n\n[edit]\n\nDynamic content, output by an internal module or an external program, may not always change very frequently (given a unique URL with keys / parameters) and so, maybe for a while (e.g. from 1 second to several hours or more), the resulting output can be cached in RAM or even on a fast disk.[44]\n\nThe typical usage of a dynamic cache is when a website has dynamic web pages about news, weather, images, maps, etc. that do not change frequently (e.g. every n minutes) and that are accessed by a huge number of clients per minute / hour; in those cases it is useful to return cached content too (without calling the internal module or the external program) because clients often do not have an updated copy of the requested content in their browser caches.[45]\n\nAnyway, in most cases those kind of caches are implemented by external servers (e.g. reverse proxy) or by storing dynamic data output in separate computers, managed by specific applications (e.g. memcached), in order to not compete for hardware resources (CPU, RAM, disks) with web server(s).[46] [47]\n\nKernel-mode and user-mode web servers\n\n[edit]\n\nA web server software can be either incorporated into the OS and executed in kernel space, or it can be executed in user space (like other regular applications).\n\nWeb servers that run in kernel mode (usually called kernel space web servers) can have direct access to kernel resources and so they can be, in theory, faster than those running in user mode; anyway there are disadvantages in running a web server in kernel mode, e.g.: difficulties in developing (debugging) software whereas run-time critical errors may lead to serious problems in OS kernel.\n\nWeb servers that run in user-mode have to ask the system for permission to use more memory or more CPU resources. Not only do these requests to the kernel take time, but they might not always be satisfied because the system reserves resources for its own usage and has the responsibility to share hardware resources with all the other running applications. Executing in user mode can also mean using more buffer/data copies (between user-space and kernel-space) which can lead to a decrease in the performance of a user-mode web server.\n\nNowadays almost all web server software is executed in user mode (because many of the aforementioned small disadvantages have been overcome by faster hardware, new OS versions, much faster OS system calls and new optimized web server software). See also comparison of web server software to discover which of them run in kernel mode or in user mode (also referred as kernel space or user space).\n\nPerformances\n\n[edit]\n\nTo improve the user experience (on client / browser side), a web server should reply quickly (as soon as possible) to client requests; unless content response is throttled (by configuration) for some type of files (e.g. big or huge files), also returned data content should be sent as fast as possible (high transfer speed).\n\nIn other words, a web server should always be very responsive, even under high load of web traffic, in order to keep total user's wait (sum of browser time + network time + web server response time) for a response as low as possible.\n\nPerformance metrics\n\n[edit]\n\nFor web server software, main key performance metrics (measured under vary operating conditions) usually are at least the following ones (i.e.):[48]\n\nnumber of requests per second (RPS, similar to QPS, depending on HTTP version and configuration, type of HTTP requests and other operating conditions);\n\nnumber of connections per second (CPS), is the number of connections per second accepted by web server (useful when using HTTP/1.0 or HTTP/1.1 with a very low limit of requests / responses per connection, i.e. 1 .. 20);\n\nnetwork latency + response time for each new client request; usually benchmark tool shows how many requests have been satisfied within a scale of time laps (e.g. within 1ms, 3ms, 5ms, 10ms, 20ms, 30ms, 40ms) and / or the shortest, the average and the longest response time;\n\nthroughput of responses, in bytes per second.\n\nAmong the operating conditions, the number (1 .. n) of concurrent client connections used during a test is an important parameter because it allows to correlate the concurrency level supported by web server with results of the tested performance metrics.\n\nSoftware efficiency\n\n[edit]\n\nThe specific web server software design and model adopted (e.g.):\n\nsingle process or multi-process;\n\nsingle thread (no thread) or multi-thread for each process;\n\nusage of coroutines or not;\n\n... and other programming techniques, such as (e.g.):\n\nminimization of possible CPU cache misses;\n\nminimization of possible CPU branch mispredictions in critical paths for speed;\n\nminimization of the number of system calls used to perform a certain function / task;\n\nother tricks;\n\n... used to implement a web server program, can bias a lot the performances and in particular the scalability level that can be achieved under heavy load or when using high end hardware (many CPUs, disks and lots of RAM).\n\nIn practice some web server software models may require more OS resources (specially more CPUs and more RAM) than others to be able to work well and so to achieve target performances.\n\nOperating conditions\n\n[edit]\n\nThere are many operating conditions that can affect the performances of a web server; performance values may vary depending on (i.e.):\n\nthe settings of web server (including the fact that log file is or is not enabled, etc.);\n\nthe HTTP version used by client requests;\n\nthe average HTTP request type (method, length of HTTP headers and optional body);\n\nwhether the requested content is static or dynamic;\n\nwhether the content is cached or not cached (by server and/or by client);\n\nwhether the content is compressed on the fly (when transferred), pre-compressed (i.e. when a file resource is stored on disk already compressed so that web server can send that file directly to the network with the only indication that its content is compressed) or not compressed at all;\n\nwhether the connections are or are not encrypted;\n\nthe average network speed between web server and its clients;\n\nthe number of active TCP connections;\n\nthe number of active processes managed by web server (including external CGI, SCGI, FCGI programs);\n\nthe hardware and software limitations or settings of the OS of the computer(s) on which the web server runs;\n\nother minor conditions.\n\nBenchmarking\n\n[edit]\n\nMain article: Web server benchmarking\n\nPerformances of a web server are typically benchmarked by using one or more of the available automated load testing tools.\n\nLoad limits\n\n[edit]\n\nA web server (program installation) usually has pre-defined load limits for each combination of operating conditions, also because it is limited by OS resources and because it can handle only a limited number of concurrent client connections (usually between 2 and several tens of thousands for each active web server process, see also the C10k problem and the C10M problem).\n\nWhen a web server is near to or over its load limits, it gets overloaded and so it may become unresponsive.\n\nCauses of overload\n\n[edit]\n\nAt any time web servers can be overloaded due to one or more of the following causes (e.g.).\n\nExcess legitimate web traffic. Thousands or even millions of clients connecting to the website in a short amount of time, e.g., Slashdot effect.\n\nDistributed Denial of Service attacks. A denial-of-service attack (DoS attack) or distributed denial-of-service attack (DDoS attack) is an attempt to make a computer or network resource unavailable to its intended users.\n\nComputer worms that sometimes cause abnormal traffic because of millions of infected computers (not coordinated among them).\n\nXSS worms can cause high traffic because of millions of infected browsers or web servers.\n\nInternet bots Traffic not filtered/limited on large websites with very few network resources (e.g. bandwidth) and/or hardware resources (CPUs, RAM, disks).\n\nInternet (network) slowdowns (e.g. due to packet losses) so that client requests are served more slowly and the number of connections increases so much that server limits are reached.\n\nWeb servers, serving dynamic content, waiting for slow responses coming from back-end computer(s) (e.g. databases), maybe because of too many queries mixed with too many inserts or updates of DB data; in these cases web servers have to wait for back-end data responses before replying to HTTP clients but during these waits too many new client connections / requests arrive and so they become overloaded.\n\nWeb servers (computers) partial unavailability. This can happen because of required or urgent maintenance or upgrade, hardware or software failures such as back-end (e.g. database) failures; in these cases the remaining web servers may get too much traffic and become overloaded.\n\nSymptoms of overload\n\n[edit]\n\nThe symptoms of an overloaded web server are usually the following ones (e.g.).\n\nRequests are served with (possibly long) delays (from 1 second to a few hundred seconds).\n\nThe web server returns an HTTP error code, such as 500, 502,[49][50] 503,[51] 504,[52] 408, or even an intermittent 404.\n\nThe web server refuses or resets (interrupts) TCP connections before it returns any content.\n\nIn very rare cases, the web server returns only a part of the requested content. This behavior can be considered a bug, even if it usually arises as a symptom of overload.\n\nAnti-overload techniques\n\n[edit]\n\nTo partially overcome above average load limits and to prevent overload, most popular websites use common techniques like the following ones (e.g.).\n\nTuning OS parameters for hardware capabilities and usage.\n\nTuning web server(s) parameters to improve their security and performances.\n\nDeploying web cache techniques (not only for static contents but, whenever possible, for dynamic contents too).\n\nManaging network traffic, by using:\n\nFirewalls to block unwanted traffic coming from bad IP sources or having bad patterns;\n\nHTTP traffic managers to drop, redirect or rewrite requests having bad HTTP patterns;\n\nBandwidth management and traffic shaping, in order to smooth down peaks in network usage.\n\nUsing different domain names, IP addresses and computers to serve different kinds (static and dynamic) of content; the aim is to separate big or huge files (download.*) (that domain might be replaced also by a CDN) from small and medium-sized files (static.*) and from main dynamic site (maybe where some contents are stored in a backend database) (www.*); the idea is to be able to efficiently serve big or huge (over 10 – 1000 MB) files (maybe throttling downloads) and to fully cache small and medium-sized files, without affecting performances of dynamic site under heavy load, by using different settings for each (group) of web server computers, e.g.:\n\nhttps://download.example.com\n\nhttps://static.example.com\n\nhttps://www.example.com\n\nUsing many web servers (computers) that are grouped together behind a load balancer so that they act or are seen as one big web server.\n\nAdding more hardware resources (i.e. RAM, fast disks) to each computer.\n\nUsing more efficient computer programs for web servers (see also: software efficiency).\n\nUsing the most efficient Web Server Gateway Interface to process dynamic requests (spawning one or more external programs every time a dynamic page is retrieved, kills performances).\n\nUsing other programming techniques and workarounds, especially if dynamic content is involved, to speed up the HTTP responses (i.e. by avoiding dynamic calls to retrieve objects, such as style sheets, images and scripts), that never change or change very rarely, by copying that content to static files once and then keeping them synchronized with dynamic content).\n\nUsing latest efficient versions of HTTP (e.g. beyond using common HTTP/1.1 also by enabling HTTP/2 and maybe HTTP/3 too, whenever available web server software has reliable support for the latter two protocols) in order to reduce a lot the number of TCP/IP connections started by each client and the size of data exchanged (because of more compact HTTP headers representation and maybe data compression).\n\nCaveats about using HTTP/2 and HTTP/3 protocols\n\nEven if newer HTTP (2 and 3) protocols usually generate less network traffic for each request / response data, they may require more OS resources (i.e. RAM and CPU) used by web server software (because of encrypted data, lots of stream buffers and other implementation details); besides this, HTTP/2 and maybe HTTP/3 too, depending also on settings of web server and client program, may not be the best options for data upload of big or huge files at very high speed because their data streams are optimized for concurrency of requests and so, in many cases, using HTTP/1.1 TCP/IP connections may lead to better results / higher upload speeds (your mileage may vary).[53][54]\n\nMarket share\n\n[edit]\n\nFurther information on HTTP server programs: Category:Web server software\n\nBelow are the latest statistics of the market share of all sites of the top web servers on the Internet by Netcraft.\n\nWeb server: Market share of all sites Date nginx (Nginx, Inc.) Apache (ASF) OpenResty (OpenResty Software Foundation) Cloudflare Server (Cloudflare, Inc.) IIS (Microsoft) GWS (Google) Others October 2021[55] 34.95% 24.63% 6.45% 4.87% 4.00% (*) 4.00% (*) Less than 22% February 2021[56] 34.54% 26.32% 6.36% 5.0% 6.5% 3.90% Less than 18% February 2020[57] 36.48% 24.5% 4.00% 3.0% 14.21% 3.18% Less than 15% February 2019[58] 25.34% 26.16% N/A N/A 28.42% 1.66% Less than 19% February 2018[59] 24.32% 27.45% N/A N/A 34.50% 1.20% Less than 13% February 2017[60] 19.42% 20.89% N/A N/A 43.16% 1.03% Less than 15% February 2016[61] 16.61% 32.80% N/A N/A 29.83% 2.21% Less than 19%\n\nNOTE: (*) percentage rounded to integer number, because its decimal values are not publicly reported by source page (only its rounded value is reported in graph).\n\nSee also\n\n[edit]\n\nServer (computing)\n\nApplication server\n\nComparison of web server software\n\nHTTP server (core part of a web server program that serves HTTP requests)\n\nHTTP compression\n\nWeb application\n\nOpen source web application\n\nList of AMP packages\n\nVariant object\n\nVirtual hosting\n\nWeb hosting service\n\nWeb container\n\nWeb proxy\n\nWeb service\n\nStandard Web Server Gateway Interfaces used for dynamic contents:\n\nCGI Common Gateway Interface\n\nSCGI Simple Common Gateway Interface\n\nFastCGI Fast Common Gateway Interface\n\nA few other Web Server Interfaces (server or programming language specific) used for dynamic contents:\n\nSSI Server Side Includes, rarely used, static HTML documents containing SSI directives are interpreted by server software to include small dynamic data on the fly when pages are served, e.g. date and time, other static file contents, etc.\n\nSAPI Server Application Programming Interface:\n\nISAPI Internet Server Application Programming Interface\n\nNSAPI Netscape Server Application Programming Interface\n\nPSGI Perl Web Server Gateway Interface\n\nWSGI Python Web Server Gateway Interface\n\nRack Rack Web Server Gateway Interface\n\nJSGI JavaScript Web Server Gateway Interface\n\nJava Servlet, JavaServer Pages\n\nActive Server Pages, ASP.NET\n\nReferences\n\n[edit]"
    }
}