{
    "id": "yago_3735_1",
    "rank": 52,
    "data": {
        "url": "http://lambda-the-ultimate.org/node/5548",
        "read_more_link": "",
        "language": "en",
        "title": "Lambda the Ultimate",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://lambda-the-ultimate.org/node/themes/chameleon/ltu/tagline.png",
            "http://lambda-the-ultimate.org/misc/xml.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "History of Lisp (The history of LISP according to McCarthy's memory in 1978, presented at the ACM SIGPLAN History of Programming Languages Conference.)\n\nThis is such a fun paper which I couldn't find on LtU. It's about the very early history of programming (1950s and '60s), back when things we take for granted today didn't exist yet.\n\nOn taking apart complex data structures with functions like CAR and CDR:\n\nIt was immediately apparent that arbitrary subexpressions of symbolic expressions could be obtained by composing the functions that extract immediate subexpressions, and this seemed reason enough to go to an algebraic language.\n\nOn creating new data, i.e. CONS:\n\nAt some point a cons(a,d,p,t) was defined, but it was regarded as a subroutine and not as a function with a value. ... Gelernter and Gerberich noticed that cons should be a function, not just a subroutine, and that its value should be the location of the word that had been taken from the free storage list. This permitted new expressions to be constructed out of subsubexpressions by composing occurrences of cons\n\nOn inventing IF:\n\nThis led to the invention of the true conditional expression which evaluates only one of N1 and N2 according to whether M is true or false and to a desire for a programming language that would allow its use.\n\nOn how supreme laziness led to the invention of garbage collection:\n\nOnce we decided on garbage collection, its actual implementation could be postponed, because only toy examples were being done.\n\nYou might have heard this before:\n\nS.R. Russell noticed that eval could serve as an interpreter for LISP, promptly hand coded it, and we now had a programming language with an interpreter.\n\nAnd the rest is history..."
    }
}