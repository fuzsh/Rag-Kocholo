{
    "id": "yago_3735_1",
    "rank": 89,
    "data": {
        "url": "https://beautifulracket.com/appendix/why-racket-why-lisp.html",
        "read_more_link": "",
        "language": "en",
        "title": "Beautiful Racket: Why Racket? Why Lisp?",
        "top_image": "https://beautifulracket.com/img/og-image.jpg?1715634897",
        "meta_img": "https://beautifulracket.com/img/og-image.jpg?1715634897",
        "images": [
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/appendix/racetrack.jpg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg",
            "https://beautifulracket.com/fonts/feather-v1.1/svg/download.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Beautiful Racket",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://beautifulracket.com",
        "text": "BeauÂ­tiful Racket / appendix\n\nî\n\nWhy Racket? Why Lisp?\n\nî\n\nBeauÂ­tiful Racket and PracÂ­tical TypogÂ­raphy were made possible by a publishing system called Pollen. I created Pollen with the Racket programÂ­ming language. Racket is a descenÂ­dant of Scheme, which in turn is a descenÂ­dant of Lisp.\n\nî\n\nSo while Racket is not Lisp (in the specific Common Lisp sense), it is a Lisp (in the familial sense). Its core ideasâand core virtuesâare shared with Lisp. So talking about Racket means talking about Lisp.\n\nî\n\nIn pracÂ­tical programÂ­ming projects, Lisps are rare. Racket espeÂ­cially so. Thus, before I origÂ­iÂ­nally embarked on my Lisp advenÂ­ture, I wanted to underÂ­stand the costs & beneÂ­fits of using a Lisp. Why do Lisps have such a great repuÂ­taÂ­tion, yet few users? Was I seeing someÂ­thing everyone else missed? Or did they know someÂ­thing I didnât? To find out, I read whatÂ­ever I could find about Lisps, including Paul Grahamâs Hackers & Painters and Peter Seibelâs PracÂ­tical Common Lisp. (OK, parts. Itâs a big book.)\n\nî\n\nWhat I found was plenty of Lisp flatÂ­tery from expert Lisp programÂ­mers. (Also plenty of Lisp kvetchery from its detracÂ­tors.) What I didnât find were simple, persuaÂ­sive arguÂ­ments in its favor. So hereâs why Racket was the right tool for me, and what I see as the pracÂ­tical virtues of Lisps in general.\n\nî\n\nI didnât study computer science in college (though I was a math major for two years, before switching to design). Iâve never held an offiÂ­cial job as a programmer. Rather, programÂ­ming has been a secondary skill Iâve used in my work as a web designer, type designer, and writer.\n\nî\n\nBut in the last few years, Iâve spent an increasing amount of my time programÂ­ming. This programÂ­ming generÂ­ates income. So by the simplest defiÂ­nÂ­iÂ­tionâdoes the skill make you money?âI suppose I qualify as a profesÂ­sional programmer. And since most of my programÂ­ming efforts are in Racket, I qualify as a profesÂ­sional Racket programmer.\n\nî\n\nMind you, Iâm not claiming that Iâm an expert programmer. Among the Racket commuÂ­nity, which is laden with computer-science PhDs & profesÂ­sors, I (have no choice but to) embrace my relaÂ­tive inexÂ­peÂ­riÂ­ence. Hence the title of my talk at RackÂ­etCon 2014: Like a Blind Squirrel in a Ferrari.\n\nî\n\nYet despite my limiÂ­taÂ­tions as a programmer, with Racket Iâve been able to render bigger ideas into programs more quickly, and with fewer bugs, than any language Iâve used before (and there have been manyâBASIC, C, C++, Perl, Java, JavaScript, Python, and others). Since I havenât gotten a brain transÂ­plant recently, there must be someÂ­thing special about Racket as a language.\n\nî\n\nLisp is a language most programÂ­mers have heard of, for two reasons. First, itâs one of the oldest computer languages, in use since 1958. Second, itâs accrued a repuÂ­taÂ­tion as a language for brainiacs. OrigÂ­iÂ­nally this repuÂ­taÂ­tion arose from its assoÂ­ciÂ­aÂ­tion with the field of artiÂ­fiÂ­cial intelÂ­liÂ­gence. Since then, this repuÂ­taÂ­tion has been mainÂ­tained by periÂ­odic endorseÂ­ments from respected programÂ­mers (latterly, Eric Raymond and Paul Graham) and the enduring fame of the textÂ­book used in introÂ­ducÂ­tory computer-science courses at MIT, StrucÂ­ture and InterÂ­preÂ­taÂ­tion of Computer Programs (which uses Scheme, and that one I did read start to finish).\n\nî\n\nBut as mainÂ­stream programÂ­ming tools, Lisp and its descenÂ­dants have been largely ignored. PopuÂ­larity of programÂ­ming languages is tricky to measure, but hereâs a simple proxyâletâs count the number of projects currently hosted on GitHub. One could quibble about the accuÂ­racy of this method, except that the results arenât even close:\n\nî\n\nî\n\nLanguageGitHub projectsJavaScript7,488,087Java6,570,575Python4,017,958PHP2,123,489Ruby1,699,590Clojure64,239Lisp17,989Scheme12,412Racket11,725\n\nî\n\nThe last four languages are Lisps, and together account for only 106,365 projects. Racket itself only accounts for a small fracÂ­tion of this small fracÂ­tion.\n\nî\n\nPopular programÂ­ming languages arenât necesÂ­sarily goodâlook whatâs at the top of that list. Â +Â [JavaScript] has a lot of stupid in it â¦ The good parts of [JavaScript] go back to Scheme and Self.\n\nâBrendan Eich, here and here But unpopÂ­ular languages often have fatal flaws that prevent wider adopÂ­tion. As I was considÂ­ering languages, Racket had a lot to recomÂ­mend it. But was there a fatal flaw I was overÂ­looking? And by commitÂ­ting to a Lisp, would I be painting myself into a corner? I wanted to underÂ­stand the risks and beneÂ­fits.\n\nî\n\nI said above that Lisp flatÂ­tery is easy to find. The problem with Lisp flatÂ­tery is that it makes sense only to expeÂ­riÂ­enced Lisp programÂ­mers. To othersâespeÂ­cially those who are trying to decide whether to learn and use a Lispâit just comes across as unsubÂ­stanÂ­tiÂ­ated hoodoo.\n\nî\n\nFor example, in his essay How to Become a Hacker, Eric Raymond says âLisp is worth learning for â¦ the profound enlightÂ­enÂ­ment expeÂ­riÂ­ence you will have when you finally get it. That expeÂ­riÂ­ence will make you a better programmer for the rest of your days, even if you never actuÂ­ally use Lisp itself a lot.â UnforÂ­tuÂ­nately Raymond doesnât follow up this claim by describing the âenlightÂ­enÂ­ment expeÂ­riÂ­enceâ, nor why itâs âprofoundâ, nor how it will improve your programÂ­ming skills generÂ­ally.\n\nî\n\nTo be fair, Raymondâs essay is not focused on Lisp. But compare Beating the AverÂ­ages, by Paul Graham, which is. Graham starts off by citing Raymondâs compliÂ­ment to Lisp and seems ready to make the claim concrete.\n\nî\n\nInstead, he breaks it into smaller chunks of flatÂ­tery. âWe knew Lisp was a really good language for writing softÂ­ware quickly.â Because of what charÂ­acÂ­terÂ­isÂ­tics? He doesnât say, but then describes Lisp as his âsecret weaponâ. OK, so whatâs the secret? He says âprogramÂ­ming languages vary in powerâ. Fine, but what exactly makes Lisp more powerful?\n\nî\n\nGraham offers one concrete example: Lispâs macro facility, which he describes as its ability to make âprograms that write programsâ. After four years using a Lisp language, Iâd agree with Graham that macros are great when you need them. But for someone new to Lisp languages, theyâre not necesÂ­sarily a bread-and-butter benefit.\n\nî\n\nI was hopeful when I opened Peter Seibelâs PracÂ­tical Common Lisp and saw that the introÂ­ducÂ­tion was subtiÂ­tled âWhy Lisp?â Yes, tell me! Seibel echoes Grahamâs claim: âYouâll get more done, faster, using [Lisp] than you would using pretty much any other language.â OK, but how? Seibel wonders whether âI like Lisp because of some quirk in the way my brain is wired. It could even be genetic, since my dad has it too.â Thatâs not encourÂ­aging to those of us outside your family. UltiÂ­mately, he sums up the appeal of Lisp by describing it as âthe programÂ­mable programÂ­ming languageâ. But Iâve neverÂ used a programÂ­mable programÂ­ming language. Why should I start?\n\nî\n\nThis is the fundaÂ­mental quesÂ­tion that Lisp advoÂ­cates have to answer for new users. But more often, itâs sideÂ­stepped. Iâm not picking on Raymond or Graham or Seibel. Theyâre excelÂ­lent writers. As programÂ­mers, theyâre way out of my league. As I learn more about Lisps, I return to these artiÂ­cles and they make more sense.\n\nî\n\nBut these artiÂ­cles are also emblemÂ­atic of a general weakÂ­ness of messaging about Lisp. I say that not as a ranking member of the Lisp commuÂ­nity, but rather as someone who spent a lot of time seeking an answer to that fundaÂ­mental quesÂ­tion. I never got it.\n\nî\n\nSeibel is passing the buck when he says that to underÂ­stand the beneÂ­fits of Lisp, âyouâre going to have to learn some Lisp and see for yourÂ­selfâ. Sure, this method worksâusing Racket for a few months finally made the beneÂ­fits of Lisp clear to me. But it also required an investÂ­ment of about 100â200 hours.Â Â +Â For more on the perils of taxing reader patience, see why does typogÂ­raphy matter in PracÂ­tical TypogÂ­raphy.\n\nî\n\nThatâs asking too much. If Lisp languages are so great, then it should be possible to summaÂ­rize their beneÂ­fits in concise, pracÂ­tical terms. It should be possible to demonÂ­strate the power of Lisp in one hour, not 100. If Lisp advoÂ­cates refuse to do this, then we shouldnât be surprised when these languages remain stuck near the bottom of the charts.\n\nî\n\nIn a word, expresÂ­siveÂ­ness: the measure of how easy it is to put your ideas into code. For instance, an expresÂ­sive language like Racket lets you write the âHello worldâ program like this:\n\nî\n\n\"Hello world\"\n\n1\n\n\"Hello world\"\n\nî\n\nWhereas a less expresÂ­sive languageâI wonât name namesârequires this:\n\nî\n\npublic class HelloWorld {\n\nÂ Â Â Â public static void main(String[] args) {\n\nÂ Â Â Â Â Â Â Â System.out.println(\"Hello world\");\n\nÂ Â Â Â }\n\n}\n\nî\n\nConciÂ­sion is valuÂ­able, but expresÂ­siveÂ­ness also embodies other qualÂ­iÂ­ties: preciÂ­sion, readÂ­ability, flexÂ­iÂ­bility, potenÂ­tial for generÂ­alÂ­izaÂ­tion.\n\nî\n\nî\n\nCompared to other languages, Lisps are tremenÂ­dously expresÂ­sive. Like the overÂ­powÂ­ered Japanese motorÂ­cycle I once owned, they go where you want, very quickly, with a minimum of input. If youâve ridden a motorÂ­cycle, then you know what I mean. If you havenât, good newsâLisps are cheaper and safer.\n\nî\n\nHereâs my ranking of the language features that offered the most immeÂ­diate value to me, when I was a programmer new to the Lisp world. For each, Iâve noted whether itâs a feature of Racket specifÂ­iÂ­cally, or Lisps generÂ­ally.\n\nî\n\nEveryÂ­thing is an expresÂ­sion. [Lisps] Most programÂ­ming languages are a combiÂ­naÂ­tion of two distinct ingreÂ­diÂ­ents: expresÂ­sions (things that are evalÂ­uÂ­ated to produce a value) and stateÂ­ments (things that denote an action). For instance, in Python, x = 42 is a stateÂ­ment, and x + 42 is an expresÂ­sion.\n\nî\n\nStateÂ­ments and expresÂ­sions are distinct because while expresÂ­sions can be natuÂ­rally nested with each other, stateÂ­ments and expresÂ­sions cannot. For instance, in Python, this is a valid expresÂ­sion:\n\nî\n\n42 + 101\n\n1\n\n42 + 101\n\nî\n\nAnd so is this, substiÂ­tuting another expresÂ­sion for the right-hand value:\n\nî\n\n42 + (100 + 100)\n\n1\n\n42 + (100 + 100)\n\nî\n\nBut this is not valid:\n\nî\n\n42 + if 1 < 0:\n\nÂ Â Â Â Â Â Â Â Â 100\n\nÂ Â Â Â Â else:\n\nÂ Â Â Â Â Â Â Â Â 200\n\nî\n\nWhy? Because in Python, a stanÂ­dard if condiÂ­tional is a stateÂ­ment, and can only be used in certain posiÂ­tions.\n\nî\n\nBy making everyÂ­thing an expresÂ­sion, however, Lisps remove this limiÂ­taÂ­tion. Since expresÂ­sions are nestable, anything in the language can be combined with nearly anything else. For instance, because an if condiÂ­tional is an expresÂ­sion, you can use it in place of a value:\n\nî\n\n(+ 42 (if (< 1 0) 100 200))\n\nî\n\nâBut wait! Python has a ternary condiÂ­tional expresÂ­sion!â It doesnât change the essenÂ­tial point, but OKâyou can indeed write this:\n\nî\n\n42 + (100 if 1 < 0 else 200)\n\nî\n\nBut now suppose we want to use a condiÂ­tional in place of the operÂ­ator, not the right-hand value. In a Lisp, because everyÂ­thing is an expresÂ­sionâincluding the operÂ­ator itselfâthis is easy:\n\nî\n\n((if (< 1 0) + *) 42 100)\n\nî\n\nBut if you try the same thing in Python, it will raise a syntax error:\n\nî\n\n42 (+ if 1 < 0 else *) 100\n\nî\n\nWhy? Because Python operÂ­aÂ­tors are not expresÂ­sions.\n\nî\n\nThis is a synthetic example. The point is not that youâd necesÂ­sarily want to do this, but that Lisps permit it. You donât run into the syntactic guardrails that are lurking in other languages. As a programmer, this simpliÂ­fies your work, because everyÂ­thing snaps together easily. It also expands your possiÂ­bilÂ­iÂ­ties, because you can combine parts of the language in unusual ways if you feel like it.\n\nî\n\nItâs similar to the basic idea behind Legos. Other building sets offer specialÂ­ized pieces that can only fit together certain ways. But by sharing uniform measureÂ­ments, Lego bricks offer maximum possiÂ­bilÂ­iÂ­ties for combiÂ­naÂ­tions. This ends up being more flexÂ­ible & more fun.\n\nî\n\nSo it is with an expresÂ­sion-based language. If you find this idea exciting, congratÂ­uÂ­laÂ­tionsâyou might be a Lisp programmer. (If you find this idea weird and scary, this is a good moment to bail out.)\n\nî\n\nEvery expresÂ­sion is either a single value or a list. [Lisps] Single values are things like numbers and strings and hash tables. (In Lisps, theyâre someÂ­times called atoms.) That part is no big deal.\n\nî\n\nThe list part, however, is a big deal. In a language like Python, the list is one data type within the language. But in Lisps, the list is more like an orgaÂ­nizing prinÂ­ciple for everyÂ­thing that happens. Â +Â The name âLispâ is an abbreÂ­viÂ­aÂ­tion for âlist processingâ. So yes, you can use the list as a data type. But a funcÂ­tion call is also a list. In fact, the source code for the funcÂ­tion is a list. ActuÂ­ally, the rest of the program is too. Lists are everyÂ­where.Â Â +Â The fancy CS term for this propÂ­erty is homoiconicity.\n\nî\n\nThe beneÂ­fits of lists are similar to that of expresÂ­sions. By bringing more of the language into a consisÂ­tent form, more possiÂ­bilÂ­iÂ­ties arise for how pieces can be combined and manipÂ­uÂ­lated.\n\nî\n\nSeibel describes Lisp as a tool for getting âmore done, fasterâ. Here, you can start to see why this is so. Lisp languages are immensely flexÂ­ible and permisÂ­sive in how their pieces can be connected. This means that the way you think about a programÂ­ming problem can be quite close to the way you actuÂ­ally program it. (This is also why Lisps have tradiÂ­tionÂ­ally excelled for protoÂ­types and exploratory work.)\n\nî\n\nTo be fair, getting the most out of a Lisp means learning to think more in the Lisp idiom of lists and expresÂ­sions. For that reason, I agree with Seibelâtrying it yourÂ­self is the best way to be convinced of the beneÂ­fits. As you get a feel for lists and expresÂ­sions, it does pay increasing diviÂ­dends throughout the language. You see how tiny lines of code can produce epic amounts of work. You also start to appreÂ­ciate that even in a well-designed language like Python, youâre spending a lot of time shaping your ideas to fit its limiÂ­taÂ­tions, like shaving an invisÂ­ible yak.\n\nî\n\nFuncÂ­tional programÂ­ming. [Lisps] Yes, I know that other languages offer funcÂ­tional-programÂ­ming features, and that Lisps arenât considÂ­ered pure funcÂ­tional languages. But many programÂ­mers havenât been exposed to this idiom, and thus tend to underÂ­rate its beneÂ­fits. I know I was in that cateÂ­gory.\n\nî\n\nFuncÂ­tional programÂ­ming doesnât mean programÂ­ming with funcÂ­tions. EveryÂ­body does that. FuncÂ­tional programÂ­ming refers to a stricter style where funcÂ­tions receive certain data as input, process only that data, and return a result. In funcÂ­tional programÂ­ming, funcÂ­tions avoid two habits common in other languages: mutaÂ­tion (= changing data in-place rather than returning a value) and relying on state (= extra context thatâs not provided as input, for instance global variÂ­ables).\n\nî\n\nâWaitâI love state and mutaÂ­tion. Why would you take them away?â Because theyâre false friends. They contraÂ­dict the essenÂ­tial concept of a funcÂ­tion, which is to encapÂ­suÂ­late data and algoÂ­rithms. When a funcÂ­tion relies on state or mutaÂ­tion, itâs operÂ­ating outside those boundÂ­aries. ThereÂ­fore, you either take on an increasing houseÂ­keeping burden to keep track of how funcÂ­tions affect each other, or watch your program sink into a swamp of mysteÂ­rious, compliÂ­cated bugs.\n\nî\n\nProgramÂ­ming in a funcÂ­tional style takes more effort at the outset. But it encourÂ­ages you to strucÂ­ture the program in a clean, compartÂ­menÂ­talÂ­ized way. This pays off immeÂ­diÂ­ately in programs that are easier to test and debug. Itâs also more likely to lead to reusable compoÂ­nents, since funcÂ­tions are truly indeÂ­penÂ­dent.\n\nî\n\nThis bite-the-bullet aspect of funcÂ­tional programÂ­ming is another reason why you can get âmore done, fasterâ with a Lisp. The differÂ­ence between protoÂ­type and producÂ­tion code often ends up being small, because you donât take as many shortÂ­cuts at the start. The program grows and evolves more smoothly because itâs easy to change one part without causing ripple effects elseÂ­where.\n\nî\n\nMacros. [Racket] Some RackÂ­eÂ­teers quibble with this term, preferÂ­ring syntax transÂ­formers, because a Racket macro can be more sophisÂ­tiÂ­cated than the usual Common Lisp macro.\n\nî\n\nA macro in Common Lisp is a funcÂ­tion that runs at compile time, accepting symbols as input and injecting them into a template to produce new code.\n\nî\n\nMacros in Racket, on the other hand, rely on the concept of hygiene. They can handle Common Lisp-style macros, but also more elabÂ­oÂ­rate syntax rearrangeÂ­ments.\n\nî\n\nBut forget thatâwhatâs in it for you? As a programmer, you end up getting two bites at the apple every time you run a file: Racket runs the macros (which alter the source code), and then the source code itself.\n\nî\n\nUnlike someÂ­thing like the C preprocessor, which is basiÂ­cally a sepaÂ­rate mini-language, Racket macros are themÂ­selves Racket funcÂ­tions that give you access to everyÂ­thing in Racket. Like lists and expresÂ­sions, macros add another layer of expresÂ­sive possiÂ­bilÂ­iÂ­ties.\n\nî\n\nCreate new programÂ­ming languages. [Racket] When I first read that Racket could be used to create new languages, I had two thoughtsâare they serious? and would I really want to do that? The answers were yes and ohÂ hellÂ yes.\n\nî\n\nBetween expresÂ­sions, lists, and macros, Racket gives you a huge amount of semantic flexÂ­iÂ­bility. But on top of that, it also adds syntactic flexÂ­iÂ­bility, in that you can define a reader that converts surface syntax into stanÂ­dard Racket S-expresÂ­sions, andÂ an expander that deterÂ­mines the meaning of these S-expresÂ­sions. Â +Â Paul Grahamâs programÂ­ming language Arc, a dialect of Lisp, was built on top of Racket.\n\nî\n\nYou can use this facility to make specialÂ­ized dialects of Racket. Or impleÂ­ment earlier languages. Or create entirely new languages with their own rules. You can use any of these languages within DrRacket to code new projects. (These special languages are someÂ­times called domain-specific languages, or DSLs.) Scribble is a DSL based on Racket; Pollen is a set of DSLs based on Scribble.\n\nî\n\nIf youâre like most programÂ­mers, youâve never had a tool for making a new language, so youâve not considÂ­ered it a realÂ­istic approach to a problem. And you wonât need it all the time. But when you do, it is awesome, in both the new and old senses of that word.\n\nî\n\n(The sequel to this pieceâWhy language-oriented programÂ­ming? Why Racket?âis devoted to this topic.)\n\nî\n\nLibraries & docuÂ­menÂ­taÂ­tion. [Racket] This might not look like a competÂ­iÂ­tive differÂ­enÂ­tiatorâdoesnât every programÂ­ming language have libraries & docuÂ­menÂ­taÂ­tion?\n\nî\n\nYes, but probÂ­ably not like this. As a conseÂ­quence of being used in research settings for many yearsâRacketâs core develÂ­opÂ­ment team is made of computer-science profesÂ­sorsâRacketâs libraries & docs are more like a transÂ­misÂ­sion from a highly evolved alien intelÂ­liÂ­gence.\n\nî\n\nYou get the essenÂ­tials, of course:Â web server, JSON, XML, drawing, foreign-funcÂ­tion interÂ­face, and so on. Then you notice packÂ­ages you maybe didnât expect:Â GUI appliÂ­caÂ­tion frameÂ­work, math plotÂ­ting, package-distriÂ­buÂ­tion system, unit tester. Beyond that, your face starts to melt a little bit: semanÂ­tics engiÂ­neering? Futures visuÂ­alÂ­izer?\n\nî\n\nI wonât pretend to know what all this shit does. A lot of it is over my head. But I like that. Each week I use Racket, I end up exploring a new part of the library, and learning someÂ­thing new. As opposed to other languages that seem to kill brain cells on contact (= pretty much anything named *Script, I find).Â\n\nî\n\nThis learning is only possible because of Racketâs truly outstanding docuÂ­menÂ­taÂ­tion. Itâs vast, thorÂ­ough, precise, and approachÂ­able. See for yourÂ­self. Â +Â If you donât like the typogÂ­raphy and layout of the docs, blame me.\n\nî\n\nDrRacket. [Racket] Yes, I know how to use a command line. But Racket includes a cross-platÂ­form graphÂ­ical IDE called DrRacket thatâs pretty great. DrRacket lets you edit, run, and debug Racket source files (or any other language based on Racketâsee item #9 on this list.)\n\nî\n\nNo, it doesnât have the Ginsu-level search-and-replace facilÂ­iÂ­ties of someÂ­thing like Sublime Text. But it does have helpful editing features optiÂ­mized for Racket code (for instance, you can right-click on a symbol name and rename it throughout the file, or jump from a funcÂ­tion to its docuÂ­menÂ­taÂ­tion).\n\nî\n\nMoreÂ­over, the command line within DrRacket doesnât just show plain textâit can show stacked fracÂ­tions, drawÂ­ings, math plots, and other unexÂ­pected guests. If your command line does all that, by all means keep using it.\n\nî\n\nX-expresÂ­sions. [Racket] This choice is someÂ­what biased by my work with Racket, which mostly involves docuÂ­ment processing and typeÂ­setÂ­ting. But related topics arise in most web programÂ­ming. An X-expresÂ­sion is a special native data strucÂ­ture that Lisps use to repreÂ­sent HTML and other XML-ish data.\n\nî\n\nWell, not âspecialâ in a Lispy senseâkeeping with the usual policy, an X-expresÂ­sion is just another listâbut special in the sense that other programÂ­ming languages donât have it. Usually your choice is to repreÂ­sent HTML either as a string or as a full XML tree. A string is wrong because it doesnât capture the strucÂ­ture of the HTML, as defined by its tags and attribÂ­utes. An XML tree shows this strucÂ­ture, but conceals the sequenÂ­tial nature of the data elements, and is unwieldy to work with.\n\nî\n\nAn X-expresÂ­sion ends up being an ideal hybrid between a string and a tree. MoreÂ­over, because itâs just another list-based expresÂ­sion in the language, you have a lot of options for processing it. TransÂ­lating an X-expresÂ­sion to or from a text repreÂ­senÂ­taÂ­tion using angle brackets is trivial and fast. (Details.)\n\nî\n\nGiven the close kinship between XML-ish data strucÂ­tures and Lisp languages, I have no explaÂ­naÂ­tion why, during the Internet era, theyâve not been paired more often. Theyâre like peanut butter and jelly.\n\nî\n\nScribble. [Racket] Pollen wouldnât have been possible without Scribble, so for me, this has been the stone-cold killer feature of Racket. But that wonât be true for everyone, so Iâm moving it down the list.Â Â +Â Scribble was origÂ­iÂ­nally created to serve as Racketâs docuÂ­menÂ­taÂ­tion language (a job it does well).\n\nî\n\nScribble is a dialect of Racket that inverts the ordiÂ­nary relaÂ­tionÂ­ship of plain text and code: rather than embedÂ­ding text strings within source, a Scribble docuÂ­ment consists of code expresÂ­sions embedded within plain text.\n\nî\n\nâSo itâs like an HTML template language.â Yes, in the sense that a template language allows code to be embedded in text. But also no, because a template language is usually a pidgin version of a real programÂ­ming language. Scribble, by contrast, lets you invoke any Racket code simply by adding a command charÂ­acter to the front. In keeping with the theme already estabÂ­lished, this approach is both simpler (because thereâs almost nothing new to learn) and more powerful (because you can invoke anything in Racket).\n\nî\n\nIn its combiÂ­naÂ­tion of text and code, Scribble has more kinship with LaTeX. While it doesnât have the typeÂ­setÂ­ting facilÂ­iÂ­ties of LaTeX, the programÂ­ming facilÂ­iÂ­ties are much better.\n\nî\n\nOpporÂ­tuÂ­niÂ­ties to particÂ­iÂ­pate. [Racket] In theory, open-source softÂ­ware projects create the opporÂ­tuÂ­nity for groups of develÂ­opers to join together and make better things in collabÂ­oÂ­raÂ­tion than they could sepaÂ­rately.\n\nî\n\nIn pracÂ­tice, Iâve found that they sort into a bimodal distriÂ­buÂ­tion: over here, the underÂ­docÂ­uÂ­mented solo projects that sputter along fitfully (if at all); over there, the mature, popular projects that can be intimÂ­iÂ­dating for new contribÂ­uÂ­tors.\n\nî\n\nAs an open-source project, Racket is posiÂ­tioned at a happy medium. The core develÂ­opÂ­ment team has been working together for years, and the commits remain fast & furious. But theyâre friendly scienÂ­tists, not Shire-dwelling egotists, and remain recepÂ­tive to improveÂ­ments across the whole system. If you have a better idea, theyâll listen; if you code it up to their stanÂ­dards and make a pull request, theyâll take it.\n\nî\n\n[2021 update: I no longer contribute to Racket due to abuse & bullying by the project leadÂ­erÂ­ship. Everyone in the broader Racket commuÂ­nity, however, has always been helpful and kind.]\n\nî\n\nThe point of this list has been to tell you about the posiÂ­tives. That doesnât mean there arenât negaÂ­tives. The small pool of Racket programÂ­mers means that when you hit a pothole, itâs possible no oneâs ever seen your problem (= the inverse of Linusâs Law). If I wanted to hire a Racket programmer, the options would be few.\n\nî\n\nStill, why shouldnât I be enthuÂ­siÂ­astic? What Iâve been able to accomÂ­plish so far with Racket has been tremenÂ­dously useful, educaÂ­tional, and funâthe most fun Iâve had in 25+ years of programÂ­ming.\n\nî\n\nIf you think I sound like a fanboy or cult member, I can live with that. But those are people whose enthuÂ­siasm is disproÂ­porÂ­tionate to reality. Here, Iâve tried to stay out of the clouds (and the weeds) and explain the concrete, pracÂ­tical features that have made Racket such a pleaÂ­sure in my own work.\n\nî\n\nAs always, your mileage may vary. But if I persuade a few people to downÂ­load Racket and try it, Iâll be happy. In fact, if you try it and donât like it, I invite you to contact me, because Iâm always curious to hear dissenting opinÂ­ions.\n\nî\n\nI will end by taking on the big kahunaâ\n\nî\n\nI wonât claim Iâve reached the top of the mounÂ­tain. But I can tell you what the view looks like so far.\n\nî\n\nThereâs a sense in which Lisp and its descenÂ­dants are more than programÂ­ming languages. Theyâre tools in the broader intelÂ­lecÂ­tual inquiry into the theory of compuÂ­taÂ­tion. Lispâs inventor, John McCarthy, origÂ­iÂ­nally considÂ­ered Lisp a âway of describing computable funcÂ­tions much neater than the Turing machinesâ, adapting the notaÂ­tion of lambda calculus to do so. Racket, likeÂ­wise, has grown out of scienÂ­tific research and exploÂ­ration.\n\nî\n\nThe theory of compuÂ­taÂ­tion is just one of many great scienÂ­tific discovÂ­eries in the last 100 years. But I donât get to use quantum mechanics or relaÂ­tivity or DNA sequencing in my daily work. When Iâm programÂ­ming, however, Iâm using compuÂ­taÂ­tion.\n\nî\n\nRacket, as a Lisp dialect, has many pracÂ­tical beneÂ­fits. But it also opens a window onto a vast theoÂ­retÂ­ical world that underÂ­lies everyÂ­thing we can do with programs. Iâm not a brainiac computer scienÂ­tist. But some days, through that window, I can start to see a bit of what they seeâsome math, some science, a lot of truth, and more than a little beautyÂ and mystery.\n\nî\n\nPaul Graham calls Lisp a âsecret weaponâ. I would clarify: Lisp itself isnât the secret weapon. Rather, you areâbecause a Lisp language offers you the chance to discover your potenÂ­tial as a programmer and a thinker, and thereby raise your expecÂ­taÂ­tions for what you can accomÂ­plish.\n\nî\n\nIf thatâs not a step toward enlightÂ­enÂ­ment, I donât know what is.\n\nî\n\nFurther reading"
    }
}