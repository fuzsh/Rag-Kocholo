{
    "id": "yago_3735_0",
    "rank": 35,
    "data": {
        "url": "https://ericnormand.me/article/idea-of-lisp",
        "read_more_link": "",
        "language": "en",
        "title": "The Idea of Lisp",
        "top_image": "https://ericnormand.me/favicon.ico",
        "meta_img": "https://ericnormand.me/favicon.ico",
        "images": [
            "https://ericnormand.me/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FSean-Allen.bad45596.png&w=32&q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FSean-Allen.bad45596.png&w=64&q=75 2x",
            "https://ericnormand.me/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FNicolas-Hery.8456f4a0.jpeg&w=32&q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FNicolas-Hery.8456f4a0.jpeg&w=64&q=75 2x",
            "https://ericnormand.me/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FMathieu-Gagnon.b67b6bfb.jpeg&w=32&q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FMathieu-Gagnon.b67b6bfb.jpeg&w=64&q=75 2x",
            "https://cdn.slashgear.com/wp-content/uploads/2011/10/mccarthy.png",
            "https://ericnormand.me/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FSean-Allen.bad45596.png&w=32&q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FSean-Allen.bad45596.png&w=64&q=75 2x",
            "https://ericnormand.me/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FNicolas-Hery.8456f4a0.jpeg&w=32&q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FNicolas-Hery.8456f4a0.jpeg&w=64&q=75 2x",
            "https://ericnormand.me/_next/image?url=%2F_next%2Fstatic%2Fmedia%2FMathieu-Gagnon.b67b6bfb.jpeg&w=32&q=75 1x, /_next/image?url=%2F_next%2Fstatic%2Fmedia%2FMathieu-Gagnon.b67b6bfb.jpeg&w=64&q=75 2x"
        ],
        "movies": [
            "https://ericnormand.substack.com/embed"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "How a programming language can be an idea.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://ericnormand.me/article/idea-of-lisp",
        "text": "Summary: How a programming language can be an idea.\n\nLISP. It conjures up visions of a bygone age of computers the size of refrigerators, ALL CAPS CODE, and parentheses. Oh! so many parentheses! So why is Object-Oriented Programming's creator so enamored with the idea of Lisp? And what can he mean by a programming language being an idea anyway? Should I blame my Computer Science education for not teaching it to me?\n\nLisp was first introduced to the world in a paper called Recursive Functions of Symbolic Expressions and Their Interpretation by Machines, Part I, written by John McCarthy. In it, McCarthy introduces many new ideas to programming. Among them are conditional expressions (that's right, if/then/else) and using more than one letter---sometimes even words and phrases---for variables (like they still do in math). Your favorite programming language owes those two features to John McCarthy. But there is an even deeper idea lurking in the definition of Lisp itself.\n\nJohn McCarthy\n\nHe defines 5 primitive operations (atom, eq, cons, car, and cdr) along with a conditional expression. It also assumes the ability to define functions. And then he uses those to define an entire programming language, defined in itself. Let me say that again: John McCarthy wrote 6 easy things in machine code, then combined them to make a programming language. Before that, the only higher-level programming language was Fortran, which took 18 man-years to develop. Fortran was a big achievement, but Lisp was a big idea.\n\nLet's unpack this tremendous idea a bit:\n\nThe bootstrapping material was very small.\n\nThese 6 things give you lists of symbols which can be interpreted. They define a very small \"kernel\" which can be easily ported to other systems. It is a small \"fixed point\" of agreement. All other meaning can be defined in terms of them.\n\nThe language was defined in terms of itself as an interpreter.\n\nThis is a proof by construction that the language is universal. The idea of Turing Completeness actually has two parts. The first is that you can compute anything computable. That one is satisfied by just about all programming languages (Lisp included since it has recursive functions). However, the second part is much more special. Turing Machines can be seen as universal when they can interpret any other Turing Machine. Well, Lisp is defined as an interpreter in terms of itself from the get-go, just like a Universal Turing Machine. Lisp is a universal language because it can interpret its own code. While you can certainly write a JavaScript interpreter in JavaScript, none of the work is done for you.\n\nThe meaning of expressions in the language is defined by the interpreter.\n\nYou could write your own interpreter that assigned different meanings to the expressions. This is Alan Kay's notion of \"late binding\". Since we don't know much about how to program well, it would be a mistake to build in too many assumptions into the base of the language. So we want a system that will allow us to swap out the assumptions as we learn more without having to throw it all away.\n\nThe expressions are written in data structures usable in the language.\n\nThe expressions are written as recursive linked lists. The 5 primitives are all you need to walk these data structures and interpret them.\n\nLispers have enjoyed working with this highly flexible \"kernel\", though most Lisp systems make practical compromises, like compiling the expressions to machine code instead of interpreting it each time. Here are some of the features of Lisp that follow directly from the Idea of Lisp.\n\nMacros\n\nMacros are functions that take code and return code. They are code transformers. They extend the expressiveness of the language and allow you to do computation at compile time.\n\nData-Driven Programming\n\nLispers often write their own interpreters in Lisp for new languages they create. They re-enact the bootstrapping of Lisp for their own languages. These can be seen as Domain-Specific Languages.\n\nProgramming language experimentation\n\nBecause it was made to write its own interpreter, Lisp is great for experimenting with alternative semantics for languages.\n\nWe're all too forgetful of the history of our field. The most significant languages in our industry are changed every so often. The new hot language will be gone in 15 years. But Lisp, the idea, endures. Its most promising incarnation at the moment is Clojure, which runs on the JVM and in JavaScript.\n\nHowever, the ideas of Lisp actually live on in your favorite language:\n\nThe REPL\n\nREPL stands for Read-Eval-Print-Loop, which are the names of the four Lisp constructs that defined it. If your language has an interactive prompt where you can type in code and see it run, that comes from Lisp.\n\nRecursive functions\n\nComputer Scientists in 1960 knew that recursive functions were possible, but they thought they would be too expensive. Fortran, the other major language at the time, did not have recursive functions back then. Now recursive functions are table stakes.\n\nGarbage collection\n\nLisp was the first language with garbage collection, mainly because the language created a lot of temporary objects and it ran for a long time.\n\nConditional expressions\n\nYes, John McCarthy invented the conditional expression. He lobbied the Algol committee to add them to Algol, from which most languages got them today.\n\nMulti-character variable names\n\nI mentioned this before, but it bears repeating: programmers were following math's lead and using one-letter variable names before McCarthy came along.\n\nLiteral data structures\n\nCan you write arrays and maps direc tly with syntax in your language? Well, Lisp did that first using parens ().\n\nHere's the full quote from Alan Kay:\n\nMost people who graduate with CS degrees don't understand the significance of Lisp. Lisp is the most important idea in computer science.\n\nI didn't graduate with that significance. It took a lot of reading and exploration after university to feel like I had a proper education in Computer Science. I try to share what I'm learning in my newsletter. The more I read and learn, the more fascinated I am by the depth and breadth of what was done over forty years ago."
    }
}