{
    "id": "yago_3735_1",
    "rank": 15,
    "data": {
        "url": "https://medium.com/%40nitinpatel_20236/the-early-history-of-lisp-1956-1959-485cd27e3b25",
        "read_more_link": "",
        "language": "en",
        "title": "The Early History of LISP (1956–1959)",
        "top_image": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_img": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*6rWWd5Gi1W7eebzE0t6PJA.png",
            "https://miro.medium.com/v2/resize:fill:144:144/1*6rWWd5Gi1W7eebzE0t6PJA.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Nitin Patel",
            "medium.com"
        ],
        "publish_date": "2019-01-14T01:32:23.677000+00:00",
        "summary": "",
        "meta_description": "The origins of LISP is quite fascinating because many of the programming concepts we take for granted came from the development of this language. The rest of the blog post is the summary of research…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@nitinpatel_20236/the-early-history-of-lisp-1956-1959-485cd27e3b25",
        "text": "The origins of LISP is quite fascinating because many of the programming concepts we take for granted came from the development of this language.\n\nThe rest of the blog post is the summary of research found in this paper Early LISP History (1956–1959) by Herbert Stoyan University of Erlangen-N”urnberg, Germany.\n\nIn the 1950s, almost no one thought of programming as mathematical functions. Programming was associated more with stepwise execution of algorithms.\n\nBut it was John McCarthy who was first to truly develop the idea of using “functions” or subroutines as a partial step to a program. This approach slowly evolved into a full-fledged programming paradigm which we today call functional programming.\n\nOrigins of LISP\n\nJohn McCarthy had this idea of creating a programming language during his research on Artificial Intelligence for the Dartmouth Summer Research Project around the year 1955.\n\nHe presented a proposal for research to study the relation of language to intelligence. The conclusion was that there should be attempts to create an artificial language which can be used by computers on problems and self-reference.\n\nThe Dartmouth Summer Research project was also visited by A. Newell, H. Simon and a bunch of other computer scientists who had already created a programming language and demonstrated a running program. The language was called IPL.\n\nMcCarthy was not impressed by this new language because it was too low level. But he was inspired by the idea of list processing which IPL introduced to him and would become one of the foundations of LISP.\n\nFunctional Programming With FORTRAN\n\nFrom the years 1955 to 1957, McCarthy worked on developing and refining the idea of functional programming. During this time, he was also involved in creating a program to prove theorems of geometry along with H. Gelernter.\n\nIBM was developing Formula Translator or FORTRAN which looked promising to McCarthy, who was fascinated by the idea of writing programs as algebraic or mathematical expressions.\n\nMcCarthy submitted suggestions of including functions for list processing in FORTRAN which were accepted. These functions could be nested to create elaborate programs of subroutines with a single statement. His ideas were used to implement a program to prove theorems of geometry.\n\nMany of the functions he submitted later became an important part of LISP.\n\nProposals to The Committee for Programming Languages\n\nIn 1957, he joined the ACM ad-hoc-committee for programming languages. McCarthy, along with fellow members of the committee, laid out several of his important ideas in the proposal titled — “Proposal for a Programming Language”.\n\nMuch of his proposals were rejected at the time.\n\nIn 1958, McCarthy gave a lecture in M. Minsky’s course at the department of mathematics in which he talked about “An algebraic coding system”. One graduate student described McCarthy’s thoughts in the lecture as:\n\n“FORTRAN plus variable functions, composite functions (Church lambda), multiple functions, several valued functions of several variables, direct sum of functions, label portion of program with facility to make symbolic substitutions therein…”\n\nThis was one of the first references to Lambda Calculus made in the context of programming languages.\n\nThe Second Proposal\n\nIn an attempt to clarify some of his points, McCarthy wrote another paper titled “Proposals for the Volume 2 (V2) language”\n\nIn this paper, he stressed the benefits of composite expression and his proposed prefix notation, along with a bunch of other suggestions including:\n\n“1. Addition, substraction, multiplication and division for numerical valued functions. In general we shall want any operations which were appropriate on the range of a set of functions.\n\n2. Composition … is appropriate whenever the domain of a (function) f and the range of (another function) g coincide.\n\n3. Abstraction from forms. … I have chosen to propose that we use the Church Lambda notation … This implies that we must also admit forms into our system and an appropriate collection of operations on them ….\n\n4. Operations on functions such as differentiation, other differential operators, and integration … 5. … direct sum operation (of multiplet valued functions) …”\n\nAlong with these, he considered there be a way to describe logical relations between variables (the idea later developed into logic-oriented programming). This idea, however, could not be realized in 1958 due to the lacking state of the art in computing.\n\nIn the more detailed version of the paper, “The construction of the advice taker”, he describes representing programs as list structures.\n\nLeaving FORTRAN Behind\n\nAll those interesting things, however, could not be added into FORTRAN at the time. It was this time when McCarthy set out to develop his own programming language.\n\nTo help the process, McCarthy also found a financial basis for his project. The MIT Artificial Intelligence Project which was founded on September 1958 decided to back McCarthy in developing a programming language for AI.\n\nThe “New” Programming Language\n\nFor the next few months, he worked with MIT to create a new programming language which he described in a memo titled: “An Algebraic Language for the Manipulation of Symbolic Expression”\n\nThe language worked with integers, word, boolean, and quantities to functions and locations. The concept of “quantities” taken from ALGOL.\n\nThe language routine worked by reading lists into the machine. A list could contain numbers (floating points as well as integers), text, symbols and lists themselves (nested lists).\n\nIt had GO statements, compound statements, statements for iteration, declaration of variables and functions, and a bunch of other functions.\n\nThis language also was the first to use what we today call map function or maplist function. It took three arguments, first is the list to be mapped, second is the variable which has various list elements and third is the function body.\n\nIt was later changed to accept just two arguments, the first being the list and second being the function. McCarthy introduced the lambda notation in the second version after which it became something like this:\n\nmaplist(L,f)=(L=0->0,1-> consls(f(L),maplist(cdr(L),f)))\n\nOnce the language was specified, they began working on an implementation of the language. While McCarthy and team were excited to start using their new language to build AI programs, nobody in the group was expert in writing a compiler.\n\nTo gain some experience, they started by translating some of the functions into SAP assembly language.\n\nThis is when they fixed the convention for calling functions, managing the storage and working with pushdown lists in the memory.\n\nThe final definitions were fixed in the fourth Memo. The language used linear sequences of machine registers for implementing lists. It used a central stack or “public push-down list”.\n\nThis memo was also the first written document where the name “LISP” was used. Much of the memo contains the SAP code for various functions of this programming language such as cons, copy, maplist, diff and some others.\n\nTuring Completeness and Development of Interpreter\n\nBy the end of 1958, McCarthy wanted to prove that his new language was “Turing complete”, meaning, not only it can describe computable functions, but it can describe the same kinds of functions as a Turing Machine.\n\nTo do that, McCarthy chose the problem of developing a universal LISP function, (akin to a universal Turing-Machine), and demonstrate that it is much more understandable that the universal Turing-Machine.\n\nThe first known interpreter for LISP was released on 15th of May, 1959. This version did not feature a garbage collector as it was developed a few months later.\n\nThe idea of garbage collection was also first described by John McCarthy. He envisioned a system in which user to the program does not have to return the registers to free storage list. Rather, it takes place automatically.\n\nThe idea was bought to life on June/July of 1959 by Dan Edwards. He was one of the first users of LISP-system.\n\nConclusion"
    }
}