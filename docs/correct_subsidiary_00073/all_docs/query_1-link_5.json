{
    "id": "correct_subsidiary_00073_1",
    "rank": 5,
    "data": {
        "url": "https://en.wikipedia.org/wiki/SPARC",
        "read_more_link": "",
        "language": "en",
        "title": "Wikipedia",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Sparc-logo.svg/1200px-Sparc-logo.svg.png",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Sparc-logo.svg/1200px-Sparc-logo.svg.png",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/db/Sparc-logo.svg/220px-Sparc-logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1c/Sun_UltraSPARCII.jpg/220px-Sun_UltraSPARCII.jpg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/4/4a/Commons-logo.svg/30px-Commons-logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/8/8b/Sun-Logo.svg/110px-Sun-Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2002-01-31T05:56:15+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/SPARC",
        "text": "RISC instruction set architecture\n\nFor other uses, see SPARC (disambiguation).\n\nSPARCDesignerSun Microsystems (acquired by Oracle Corporation)[1][2]Bits64-bit (32 → 64)Introduced1986; 38 years ago ( ) (production)\n\n1987; 37 years ago ( ) (shipments)VersionV9 (1993) / OSA2017DesignRISCTypeLoad–storeEncodingFixedBranchingCondition codeEndiannessBi (Big → Bi)Page size8 KB (4 KB → 8 KB)ExtensionsVIS 1.0, 2.0, 3.0, 4.0OpenYes, and royalty freeRegistersGeneral-purpose31 (G0 = 0; non-global registers use register windows)Floating point32 (usable as 32 single-precision, 32 double-precision, or 16 quad-precision)\n\nSPARC (Scalable Processor ARChitecture) is a reduced instruction set computer (RISC) instruction set architecture originally developed by Sun Microsystems.[1][2] Its design was strongly influenced by the experimental Berkeley RISC system developed in the early 1980s. First developed in 1986 and released in 1987,[3][2] SPARC was one of the most successful early commercial RISC systems, and its success led to the introduction of similar RISC designs from many vendors through the 1980s and 1990s.\n\nThe first implementation of the original 32-bit architecture (SPARC V7) was used in Sun's Sun-4 computer workstation and server systems, replacing their earlier Sun-3 systems based on the Motorola 68000 series of processors. SPARC V8 added a number of improvements that were part of the SuperSPARC series of processors released in 1992. SPARC V9, released in 1993, introduced a 64-bit architecture and was first released in Sun's UltraSPARC processors in 1995. Later, SPARC processors were used in symmetric multiprocessing (SMP) and non-uniform memory access (CC-NUMA) servers produced by Sun, Solbourne, and Fujitsu, among others.\n\nThe design was turned over to the SPARC International trade group in 1989, and since then its architecture has been developed by its members. SPARC International is also responsible for licensing and promoting the SPARC architecture, managing SPARC trademarks (including SPARC, which it owns), and providing conformance testing. SPARC International was intended to grow the SPARC architecture to create a larger ecosystem; SPARC has been licensed to several manufacturers, including Atmel, Bipolar Integrated Technology, Cypress Semiconductor, Fujitsu, Matsushita and Texas Instruments. Due to SPARC International, SPARC is fully open, non-proprietary and royalty-free.\n\nAs of 2024, the latest commercial high-end SPARC processors are Fujitsu's SPARC64 XII (introduced in September 2017 for its SPARC M12 server) and Oracle's SPARC M8 introduced in September 2017 for its high-end servers.\n\nOn September 1, 2017, after a round of layoffs that started in Oracle Labs in November 2016, Oracle terminated SPARC design after completing the M8. Much of the processor core development group in Austin, Texas, was dismissed, as were the teams in Santa Clara, California, and Burlington, Massachusetts.[4][5]\n\nFujitsu will also discontinue their SPARC production (has already shifted to producing their own ARM-based CPUs), after two \"enhanced\" versions of Fujitsu's older SPARC M12 server in 2020–22 (formerly planned for 2021) and again in 2026–27, end-of-sale in 2029, of UNIX servers and a year later for their mainframe and end-of-support in 2034 \"to promote customer modernization\".[6]\n\nThe SPARC architecture was heavily influenced by the earlier RISC designs, including the RISC I and II from the University of California, Berkeley and the IBM 801. These original RISC designs were minimalist, including as few features or op-codes as possible and aiming to execute instructions at a rate of almost one instruction per clock cycle. This made them similar to the MIPS architecture in many ways, including the lack of instructions such as multiply or divide. Another feature of SPARC influenced by this early RISC movement is the branch delay slot.\n\nThe SPARC processor usually contains as many as 160 general-purpose registers. According to the \"Oracle SPARC Architecture 2015\" specification an \"implementation may contain from 72 to 640 general-purpose 64-bit\" registers.[7] At any point, only 32 of them are immediately visible to software — 8 are a set of global registers (one of which, g0, is hard-wired to zero, so only seven of them are usable as registers) and the other 24 are from the stack of registers. These 24 registers form what is called a register window, and at function call/return, this window is moved up and down the register stack. Each window has eight local registers and shares eight registers with each of the adjacent windows. The shared registers are used for passing function parameters and returning values, and the local registers are used for retaining local values across function calls.\n\nThe \"scalable\" in SPARC comes from the fact that the SPARC specification allows implementations to scale from embedded processors up through large server processors, all sharing the same core (non-privileged) instruction set. One of the architectural parameters that can scale is the number of implemented register windows; the specification allows from three to 32 windows to be implemented, so the implementation can choose to implement all 32 to provide maximum call stack efficiency, or to implement only three to reduce cost and complexity of the design, or to implement some number between them. Other architectures that include similar register file features include Intel i960, IA-64, and AMD 29000.\n\nThe architecture has gone through several revisions. It gained hardware multiply and divide functionality in version 8.[8][9] 64-bit (addressing and data) were added to the version 9 SPARC specification published in 1994.[10]\n\nIn SPARC version 8, the floating-point register file has 16 double-precision registers. Each of them can be used as two single-precision registers, providing a total of 32 single-precision registers. An odd–even number pair of double-precision registers can be used as a quad-precision register, thus allowing 8 quad-precision registers. SPARC Version 9 added 16 more double-precision registers (which can also be accessed as 8 quad-precision registers), but these additional registers can not be accessed as single-precision registers. No SPARC CPU implements quad-precision operations in hardware as of 2024.[11]\n\nTagged add and subtract instructions perform adds and subtracts on values checking that the bottom two bits of both operands are 0 and reporting overflow if they are not. This can be useful in the implementation of the run time for ML, Lisp, and similar languages that might use a tagged integer format.\n\nThe endianness of the 32-bit SPARC V8 architecture is purely big-endian. The 64-bit SPARC V9 architecture uses big-endian instructions, but can access data in either big-endian or little-endian byte order, chosen either at the application instruction (load–store) level or at the memory page level (via an MMU setting). The latter is often used for accessing data from inherently little-endian devices, such as those on PCI buses.\n\nThere have been three major revisions of the architecture. The first published version was the 32-bit SPARC version 7 (V7) in 1986. SPARC version 8 (V8), an enhanced SPARC architecture definition, was released in 1990. The main differences between V7 and V8 were the addition of integer multiply and divide instructions, and an upgrade from 80-bit \"extended-precision\" floating-point arithmetic to 128-bit \"quad-precision\" arithmetic. SPARC V8 served as the basis for IEEE Standard 1754-1994, an IEEE standard for a 32-bit microprocessor architecture.\n\nSPARC version 9, the 64-bit SPARC architecture, was released by SPARC International in 1993. It was developed by the SPARC Architecture Committee consisting of Amdahl Corporation, Fujitsu, ICL, LSI Logic, Matsushita, Philips, Ross Technology, Sun Microsystems, and Texas Instruments. Newer specifications always remain compliant with the full SPARC V9 Level 1 specification.\n\nIn 2002, the SPARC Joint Programming Specification 1 (JPS1) was released by Fujitsu and Sun, describing processor functions which were identically implemented in the CPUs of both companies (\"Commonality\"). The first CPUs conforming to JPS1 were the UltraSPARC III by Sun and the SPARC64 V by Fujitsu. Functionalities which are not covered by JPS1 are documented for each processor in \"Implementation Supplements\".\n\nAt the end of 2003, JPS2 was released to support multicore CPUs. The first CPUs conforming to JPS2 were the UltraSPARC IV by Sun and the SPARC64 VI by Fujitsu.\n\nIn early 2006, Sun released an extended architecture specification, UltraSPARC Architecture 2005. This includes not only the non-privileged and most of the privileged portions of SPARC V9, but also all the architectural extensions developed through the processor generations of UltraSPARC III, IV IV+ as well as CMT extensions starting with the UltraSPARC T1 implementation:\n\nthe VIS 1 and VIS 2 instruction set extensions and the associated GSR register\n\nmultiple levels of global registers, controlled by the GL register\n\nSun's 64-bit MMU architecture\n\nprivileged instructions ALLCLEAN, OTHERW, NORMALW, and INVALW\n\naccess to the VER register is now hyperprivileged\n\nthe SIR instruction is now hyperprivileged\n\nIn 2007, Sun released an updated specification, UltraSPARC Architecture 2007, to which the UltraSPARC T2 implementation complied.\n\nIn August 2012, Oracle Corporation made available a new specification, Oracle SPARC Architecture 2011, which besides the overall update of the reference, adds the VIS 3 instruction set extensions and hyperprivileged mode to the 2007 specification.[12]\n\nIn October 2015, Oracle released SPARC M7, the first processor based on the new Oracle SPARC Architecture 2015 specification.[7][13] This revision includes VIS 4 instruction set extensions and hardware-assisted encryption and silicon secured memory (SSM).[14]\n\nSPARC architecture has provided continuous application binary compatibility from the first SPARC V7 implementation in 1987 through the Sun UltraSPARC Architecture implementations.\n\nAmong various implementations of SPARC, Sun's SuperSPARC and UltraSPARC-I were very popular, and were used as reference systems for SPEC CPU95 and CPU2000 benchmarks. The 296 MHz UltraSPARC-II is the reference system for the SPEC CPU2006 benchmark.\n\nSPARC is a load–store architecture (also known as a register–register architecture); except for the load/store instructions used to access memory, all instructions operate on the registers, in accordance with the RISC design principles.\n\nA SPARC processor includes an integer unit (IU) that performs integer load, store, and arithmetic operations.[15]: 9 [10]: 15–16 It may include a floating-point unit (FPU) that performs floating-point operations[15]: 9 [10]: 15–16 and, for SPARC V8, may include a co-processor (CP) that performs co-processor-specific operations; the architecture does not specify what functions a co-processor would perform, other than load and store operations.[15]: 9\n\nThe SPARC architecture has an overlapping register window scheme. At any instant, 32 general-purpose registers are visible. A Current Window Pointer (CWP) variable in the hardware points to the current set. The total size of the register file is not part of the architecture, allowing more registers to be added as the technology improves, up to a maximum of 32 windows in SPARC V7 and V8 as CWP is 5 bits and is part of the PSR register.\n\nIn SPARC V7 and V8 CWP will usually be decremented by the SAVE instruction (used by the SAVE instruction during the procedure call to open a new stack frame and switch the register window), or incremented by the RESTORE instruction (switching back to the call before returning from the procedure). Trap events (interrupts, exceptions or TRAP instructions) and RETT instructions (returning from traps) also change the CWP. For SPARC V9, CWP register is decremented during a RESTORE instruction, and incremented during a SAVE instruction. This is the opposite of PSR.CWP's behavior in SPARC V8. This change has no effect on nonprivileged instructions.\n\nWindow Addressing Register group Mnemonic Register address Availability global G0...G7 R[00]...R[07] always the same ones, G0 being zero always out O0...O7 R[08]...R[15] to be handed over to, and returned from, the called subroutine, as its \"in\" local L0...L7 R[16]...R[23] truly local to the current subroutine in I0...I7 R[24]...R[31] handed over from the caller, and returned to the caller, as its \"out\"\n\nSPARC registers are shown in the figure above.\n\nThere is also a non-windowed Y register, used by the multiply-step, integer multiply, and integer divide instructions.[15]: 32\n\nA SPARC V8 processor with an FPU includes 32 32-bit floating-point registers, each of which can hold one single-precision IEEE 754 floating-point number. An even–odd pair of floating-point registers can hold one double-precision IEEE 754 floating-point number, and a quad-aligned group of four floating-point registers can hold one quad-precision IEEE 754 floating-point number.[15]: 10\n\nA SPARC V9 processor with an FPU includes:[10]: 36–40\n\n32 32-bit floating-point registers, each of which can hold one single-precision IEEE 754 floating-point number;\n\n32 64-bit floating-point registers, each of which can hold one double-precision IEEE 754 floating-point number;\n\n16 128-bit floating-point registers, each of which can hold one quad-precision IEEE 754 floating-point number.\n\nThe registers are organized as a set of 64 32-bit registers, with the first 32 being used as the 32-bit floating-point registers, even–odd pairs of all 64 registers being used as the 64-bit floating-point registers, and quad-aligned groups of four floating-point registers being used as the 128-bit floating-point registers.\n\nFloating-point registers are not windowed; they are all global registers.[10]: 36–40\n\nAll SPARC instructions occupy a full 32-bit word and start on a word boundary. Four formats are used, distinguished by the first two bits. All arithmetic and logical instructions have 2 source operands and 1 destination operand.[16] RD is the \"destination register\", where the output of the operation is deposited. The majority of SPARC instructions have at least this register, so it is placed near the \"front\" of the instruction format. RS1 and RS2 are the \"source registers\", which may or may not be present, or replaced by a constant.\n\nSPARC instruction formats Type Bit 31 30 29 28 27 26 25 24 23 22 21 20 19 18 17 16 15 14 13 12 11 10 9 8 7 6 5 4 3 2 1 0 SETHI format 00 RD 100 Immediate constant 22 bits I Branch format 00 A icc 010 Displacement constant 22 bits F Branch format 00 A fcc 110 Displacement constant 22 bits C Branch format 00 A ccc 111 Displacement constant 22 bits CALL disp 01 PC-relative displacement Arithmetic register 10 RD opcode RS1 0 0 RS2 Arithmetic immediate 10 RD opcode RS1 1 Immediate constant 13 bits FPU operation 10 FD 110100/110101 FS1 opf FS2 CP operation 10 RD 110110/110111 RS1 opc RS2 JMPL register 10 RD 111000 RS1 0 0 RS2 JMPL immediate 10 RD 111000 RS1 1 Immediate constant 13 bits LD/ST register 11 RD opcode RS1 0 0 RS2 LD/ST immediate 11 RD opcode RS1 1 Immediate constant 13 bits\n\nLoad and store instructions have a three-operand format, in that they have two operands representing values for the address and one operand for the register to read or write to. The address is created by adding the two address operands to produce an address. The second address operand may be a constant or a register. Loads take the value at the address and place it in the register specified by the third operand, whereas stores take the value in the register specified by the first operand and place it at the address. To make this more obvious, the assembler language indicates address operands using square brackets with a plus sign separating the operands, instead of using a comma-separated list. Examples:[16]\n\nld [%L1+%L2],%L3 !load the 32-bit value at address %L1+%L2 and put the value into %L3 ld [%L1+8],%L2 !load the value at %L1+8 into %L2 ld [%L1],%L2 !as above, but no offset, which is the same as +%G0 st %L1,[%I2] !store the value in %L1 into the location stored in %I2 st %G0,[%I1+8] !clear the memory at %I1+8\n\nDue to the widespread use of non-32-bit data, such as 16-bit or 8-bit integral data or 8-bit bytes in strings, there are instructions that load and store 16-bit half-words and 8-bit bytes, as well as instructions that load 32-bit words. During a load, those instructions will read only the byte or half-word at the indicated location and then either fill the rest of the target register with zeros (unsigned load or with the value of the uppermost bit of the byte or half-word (signed load). During a store, those instructions discard the upper bits in the register and store only the lower bits. There are also instructions for loading double-precision values used for floating-point arithmetic, reading or writing eight bytes from the indicated register and the \"next\" one, so if the destination of a load is L1, L1 and L2 will be set. The complete list of load and store instructions for the general-purpose registers in 32-bit SPARC is LD, ST, LDUB (unsigned byte), LDSB (signed byte), LDUH (unsigned half-word), LDSH (signed half-word), LDD (load double), STB (store byte), STH (store half-word), STD (store double).[16]\n\nIn SPARC V9, registers are 64-bit, and the LD instruction, renamed LDUW, clears the upper 32 bits in the register and loads the 32-bit value into the lower 32 bits, and the ST instruction, renamed STW, discards the upper 32 bits of the register and stores only the lower 32 bits. The new LDSW instruction sets the upper bits in the register to the value of the uppermost bit of the word and loads the 32-bit value into the lower bits. The new LDX instruction loads a 64-bit value into the register, and the STX instruction stores all 64 bits of the register.\n\nThe LDF, LDDF, and LDQF instructions load a single-precision, double-precision, or quad-precision value from memory into a floating-point register; the STF, STDF, and STQF instructions store a single-precision, double-precision, or quad-precision floating-point register into memory.\n\nThe memory barrier instruction, MEMBAR, serves two interrelated purposes: it articulates order constraints among memory references and facilitates explicit control over the completion of memory references. For example, all effects of the stores that appear prior to the MEMBAR instruction must be made visible to all processors before any loads following the MEMBAR can be executed.[17]\n\nArithmetic and logical instructions also use a three-operand format, with the first two being the operands and the last being the location to store the result. The middle operand can be a register or a 13-bit signed integer constant; the other operands are registers. Any of the register operands may point to G0; pointing the result to G0 discards the results, which can be used for tests. Examples include:[16]\n\nadd %L1,%L2,%L3 !add the values in %L1 and %L2 and put the result in %L3 add %L1,1,%L1 !increment %L1 add %G0,%G0,%L4 !clear any value in %L4\n\nThe list of mathematical instructions is ADD, SUB, AND, OR, XOR, and negated versions ANDN, ORN, and XNOR. One quirk of the SPARC design is that most arithmetic instructions come in pairs, with one version setting the NZVC condition code bits in the status register, and the other not setting them, with the default being not to set the codes. This is so that the compiler has a way to move instructions around when trying to fill delay slots. If one wants the condition codes to be set, this is indicated by adding cc to the instruction:[16]\n\nsubcc %L1,10,%G0 !compare %L1 to 10 and ignore the result, but set the flags\n\nadd and sub also have another modifier, X, which indicates whether the operation should set the carry bit:\n\naddx %L1,100,%L1 !add 100 to the value in %L1 and track carry\n\nSPARC V7 does not have multiplication or division instructions, but it does have MULSCC, which does one step of a multiplication testing one bit and conditionally adding the multiplicand to the product. This was because MULSCC can complete over one clock cycle in keeping with the RISC philosophy. SPARC V8 added UMUL (unsigned multiply), SMUL (signed multiply), UDIV (unsigned divide), and SDIV (signed divide) instructions, with both versions that do not update the condition codes and versions that do. MULSCC and the multiply instructions use the Y register to hold the upper 32 bits of the product; the divide instructions use it to hold the upper 32 bits of the dividend. The RDY instruction reads the value of the Y register into a general-purpose register; the WRY instruction writes the value of a general-purpose register to the Y register.[15]: 32 SPARC V9 added MULX, which multiplies two 64-bit values and produces a 64-bit result, SDIVX, which divides a 64-bit signed dividend by a 64-bit signed divisor and produces a 64-bit signed quotient, and UDIVX, which divides a 64-bit unsigned dividend by a 64-bit unsigned divisor and produces a 64-bit signed quotient; none of those instructions use the Y register.[10]: 199\n\nConditional branches test condition codes in a status register, as seen in many instruction sets such the IBM System/360 architecture and successors and the x86 architecture. This means that a test and branch is normally performed with two instructions; the first is an ALU instruction that sets the condition codes, followed by a branch instruction that examines one of those flags. The SPARC does not have specialized test instructions; tests are performed using normal ALU instructions with the destination set to %G0. For instance, to test if a register holds the value 10 and then branch to code that handles it, one would:\n\nsubcc %L1,10,%G0 !subtract 10 from %L1, setting the zero flag if %L1 is 10 be WASEQUAL !if the zero flag is set, branch to the address marked WASEQUAL\n\nIn a conditional branch instruction, the icc or fcc field specifies the condition being tested. The 22-bit displacement field is the address, relative to the current PC, of the target, in words, so that conditional branches can go forward or backward up to 8 megabytes. The ANNUL (A) bit is used to get rid of some delay slots. If it is 0 in a conditional branch, the delay slot is executed as usual. If it is 1, the delay slot is only executed if the branch is taken. If it is not taken, the instruction following the conditional branch is skipped.\n\nThere are a wide variety of conditional branches: BA (branch always, essentially a jmp), BN (branch never), BE (equals), BNE (not equals), BL (less than), BLE (less or equal), BLEU (less or equal, unsigned), BG (greater), BGE (greater or equal), BGU (greater unsigned), BPOS (positive), BNEG (negative), BCC (carry clear), BCS (carry set), BVC (overflow clear), BVS (overflow set).[15]: 119–120\n\nThe FPU and CP have sets of condition codes separate from the integer condition codes and from each other; two additional sets of branch instructions were defined to test those condition codes. Adding an F to the front of the branch instruction in the list above performs the test against the FPU's condition codes,[15]: 121–122 while, in SPARC V8, adding a C tests the flags in the otherwise undefined CP.[15]: 123–124\n\nThe CALL (jump to subroutine) instruction uses a 30-bit program counter-relative word offset. As the target address is specifying the start of a word, not a byte, 30-bits is all that is needed to reach any address in the 4 gigabyte address space.[16] The CALL instruction deposits the return address in register R15, also known as output register O7.\n\nThe JMPL (jump and link) instruction is a three-operand instruction, with two operands representing values for the target address and one operand for a register in which to deposit the return address. The address is created by adding the two address operands to produce a 32-bit address. The second address operand may be a constant or a register.\n\nAs the instruction opcode takes up some bits of the 32-bit instruction word, there is no way to load a 32-bit constant using a single instruction. This is significant because addresses are manipulated through registers and they are 32-bits. To ease this, the special-purpose SETHI instruction copies its 22-bit immediate operand into the high-order 22 bits of any specified register, and sets each of the low-order 10 bits to 0. In general use, SETHI is followed by an or instruction with only the lower 10 bits of the value set. To ease this, the assembler includes the %hi(X) and %lo(X) macros. For example:[16]\n\nsethi %hi(0x89ABCDEF),%L1 !sets the upper 22 bits of L1 or %L1,%lo(0x89ABCDEF),%L1 !sets the lower 10 bits of L1 by ORing\n\nThe hi and lo macros are performed at assembly time, not runtime, so it has no performance hit yet makes it clearer that L1 is set to a single value, not two unrelated ones. To make this even easier, the assembler also includes a \"synthetic instruction\", set, that performs these two operations in a single line:\n\nset 0x89ABCDEF,% L1\n\nThis outputs the two instructions above if the value is larger than 13 bits, otherwise it will emit a single ld with the value.[16]\n\nAs noted earlier, the SPARC assembler uses \"synthetic instructions\" to ease common coding tasks. Additional examples include (among others):[16]\n\nSPARC synthetic instructions mnemonic actual output purpose nop sethi0,%g0 do nothing clr%reg or%g0,%g0,%reg set a register to zero clr[address] st%g0,[address] set a memory address to zero clrh[address] sth%g0,[address] set the half-word at memory address to zero clrb[address] stb%g0,[address] set the byte at memory address to zero cmp%reg1,%reg2 subcc%reg1,%reg2,%g0 compare two registers, set codes, discard results cmp%reg,const subcc%reg,const,%g0 compare register with constant mov%reg1,%reg2 or%g0,%reg1,%reg2 copy value from one register to another movconst,%reg or%g0,const,%reg copy constant value into a register inc%reg add%reg,1,%reg increment a register inccc%reg addcc%reg,1,%reg increment a register, set conditions dec%reg sub%reg,1,%reg decrement a register deccc%reg subcc%reg,1,%reg decrement a register, set conditions not%reg xnor%reg,%g0,%reg flip the bits in a register neg%reg sub%g0,%reg,%reg two's complement a register tst%reg orcc%reg,%g0,%g0 test whether the value in a register is > 0, 0, or < 0\n\nThe following organizations have licensed the SPARC architecture:\n\nName (codename) Model Frequency (MHz) Arch. version Year Total threads[note 1] Process (nm) Transistors (millions) Die size (mm2) IO pins Power (W) Voltage (V) L1 Dcache (KB) L1 Icache (KB) L2 cache (KB) L3 cache (KB) SPARC MB86900 Fujitsu[1][3][2] 14.28–33 V7 1986 1×1=1 1300 0.11 — 256 — — 0–128 (unified) none none SPARC Various[note 2] 14.28–40 V7 1989–1992 1×1=1 800–1300 ~0.1–1.8 — 160–256 — — 0–128 (unified) none none MN10501 (KAP) Solbourne Computer,\n\nMatsushita[18]\n\n33–36 V8 1990–1991 1x1=1 — 1.0[19] — — — — 8 8 0–256 none microSPARC I (Tsunami) TI TMS390S10 40–50 V8 1992 1×1=1 800 0.8 225? 288 2.5 5 2 4 none none SuperSPARC I (Viking) TI TMX390Z50 / Sun STP1020 33–60 V8 1992 1×1=1 800 3.1 — 293 14.3 5 16 20 0–2048 none SPARClite Fujitsu MB8683x 66–108 V8E 1992 1×1=1 — — — 144, 176 — 2.5/3.3–5.0 V, 2.5–3.3 V 1, 2, 8, 16 1, 2, 8, 16 none none hyperSPARC (Colorado 1) Ross RT620A 40–90 V8 1993 1×1=1 500 1.5 — — — 5? 0 8 128–256 none microSPARC II (Swift) Fujitsu MB86904 / Sun STP1012 60–125 V8 1994 1×1=1 500 2.3 233 321 5 3.3 8 16 none none hyperSPARC (Colorado 2) Ross RT620B 90–125 V8 1994 1×1=1 400 1.5 — — — 3.3 0 8 128–256 none SuperSPARC II (Voyager) Sun STP1021 75–90 V8 1994 1×1=1 800 3.1 299 — 16 — 16 20 1024–2048 none hyperSPARC (Colorado 3) Ross RT620C 125–166 V8 1995 1×1=1 350 1.5 — — — 3.3 0 8 512–1024 none TurboSPARC Fujitsu MB86907 160–180 V8 1996 1×1=1 350 3.0 132 416 7 3.5 16 16 512 none UltraSPARC (Spitfire) Sun STP1030 143–167 V9 1995 1×1=1 470 3.8 315 521 30[note 3] 3.3 16 16 512–1024 none UltraSPARC (Hornet) Sun STP1030 200 V9 1995 1×1=1 420 5.2 265 521 — 3.3 16 16 512–1024 none hyperSPARC (Colorado 4) Ross RT620D 180–200 V8 1996 1×1=1 350 1.7 — — — 3.3 16 16 512 none SPARC64 Fujitsu (HAL) 101–118 V9 1995 1×1=1 400 — Multichip 286 50 3.8 128 128 — — SPARC64 II Fujitsu (HAL) 141–161 V9 1996 1×1=1 350 — Multichip 286 64 3.3 128 128 — — SPARC64 III Fujitsu (HAL) MBCS70301 250–330 V9 1998 1×1=1 240 17.6 240 — — 2.5 64 64 8192 — UltraSPARC IIs (Blackbird) Sun STP1031 250–400 V9 1997 1×1=1 350 5.4 149 521 25[note 4] 2.5 16 16 1024 or 4096 none UltraSPARC IIs (Sapphire-Black) Sun STP1032 / STP1034 360–480 V9 1999 1×1=1 250 5.4 126 521 21[note 5] 1.9 16 16 1024–8192 none UltraSPARC IIi (Sabre) Sun SME1040 270–360 V9 1997 1×1=1 350 5.4 156 587 21 1.9 16 16 256–2048 none UltraSPARC IIi (Sapphire-Red) Sun SME1430 333–480 V9 1998 1×1=1 250 5.4 — 587 21[note 6] 1.9 16 16 2048 none UltraSPARC IIe (Hummingbird) Sun SME1701 400–500 V9 1999 1×1=1 180 Al — — 370 13[note 7] 1.5–1.7 16 16 256 none UltraSPARC IIi (IIe+) (Phantom) Sun SME1532 550–650 V9 2000 1×1=1 180 Cu — — 370 17.6 1.7 16 16 512 none SPARC64 GP Fujitsu SFCB81147 400–563 V9 2000 1×1=1 180 30.2 217 — — 1.8 128 128 8192 — SPARC64 GP -- 600–810 V9 — 1×1=1 150 30.2 — — — 1.5 128 128 8192 — SPARC64 IV Fujitsu MBCS80523 450–810 V9 2000 1×1=1 130 — — — — — 128 128 2048 — UltraSPARC III (Cheetah) Sun SME1050 600 JPS1 2001 1×1=1 180 Al 29 330 1368 53 1.6 64 32 8192 none UltraSPARC III (Cheetah) Sun SME1052 750–900 JPS1 2001 1×1=1 130 Al 29 — 1368 — 1.6 64 32 8192 none UltraSPARC III Cu (Cheetah+) Sun SME1056 900–1200 JPS1 2001 1×1=1 130 Cu 29 232 1368 50[note 8] 1.6 64 32 8192 none UltraSPARC IIIi (Jalapeño) Sun SME1603 1064–1593 JPS1 2003 1×1=1 130 87.5 206 959 52 1.3 64 32 1024 none SPARC64 V (Zeus) Fujitsu 1100–1350 JPS1 2003 1×1=1 130 190 289 269 40 1.2 128 128 2048 — SPARC64 V+ (Olympus-B) Fujitsu 1650–2160 JPS1 2004 1×1=1 90 400 297 279 65 1 128 128 4096 — UltraSPARC IV (Jaguar) Sun SME1167 1050–1350 JPS2 2004 1×2=2 130 66 356 1368 108 1.35 64 32 16384 none UltraSPARC IV+ (Panther) Sun SME1167A 1500–2100 JPS2 2005 1×2=2 90 295 336 1368 90 1.1 64 64 2048 32768 UltraSPARC T1 (Niagara) Sun SME1905 1000–1400 UA2005 2005 4×8=32 90 300 340 1933 72 1.3 8 16 3072 none SPARC64 VI (Olympus-C) Fujitsu 2150–2400 JPS2 2007 2×2=4 90 540 422 — 120–150 1.1 128×2 128×2 4096–6144 none UltraSPARC T2 (Niagara 2) Sun SME1908A 1000–1600 UA2007 2007 8×8=64 65 503 342 1831 95 1.1–1.5 8 16 4096 none UltraSPARC T2 Plus (Victoria Falls) Sun SME1910A 1200–1600 UA2007 2008 8×8=64 65 503 342 1831 — — 8 16 4096 none SPARC64 VII (Jupiter)[20] Fujitsu 2400–2880 JPS2 2008 2×4=8 65 600 445 — 150 — 64×4 64×4 6144 none UltraSPARC \"RK\" (Rock)[21] Sun SME1832 2300 ???? canceled[22] 2×16=32 65 ? 396 2326 ? ? 32 32 2048 ? SPARC64 VIIIfx (Venus)[23][24] Fujitsu 2000 JPS2 / HPC-ACE 2009 1×8=8 45 760 513 1271 58 ? 32×8 32×8 6144 none LEON2FT Atmel AT697F 100 V8 2009 1×1=1 180 — — 196 1 1.8/3.3 16 32 — —|none SPARC T3 (Rainbow Falls) Oracle/Sun 1650 UA2007 2010 8×16=128 40[25] ???? 371 ? 139 ? 8 16 6144 none Galaxy FT-1500 NUDT (China) 1800 UA2007? 201? 8×16=128 40 ???? ??? ? 65 ? 16×16 16×16 512×16 4096 SPARC64 VII+ (Jupiter-E or M3)[26][27] Fujitsu 2667–3000 JPS2 2010 2×4=8 65 — — — 160 — 64×4 64×4 12288 none LEON3FT Cobham Gaisler GR712RC 100 V8E 2011 1×2=2 180 — — — 1.5[note 9] 1.8/3.3 4x4Kb 4x4Kb none none R1000 MCST (Russia) 1000 JPS2 2011 1×4=4 90 180 128 — 15 1, 1.8, 2.5 32 16 2048 none SPARC T4 (Yosemite Falls)[28] Oracle 2850–3000 OSA2011 2011 8×8=64 40 855 403 ? 240 ? 16×8 16×8 128×8 4096 SPARC64 IXfx[29][30][31] Fujitsu 1850 JPS2 / HPC-ACE 2012 1x16=16 40 1870 484 1442 110 ? 32×16 32×16 12288 none SPARC64 X (Athena)[32] Fujitsu 2800 OSA2011 / HPC-ACE 2012 2×16=32 28 2950 587.5 1500 270 ? 64×16 64×16 24576 none SPARC T5 Oracle 3600 OSA2011 2013 8×16=128 28 1500 478 ? ? ? 16×16 16×16 128×16 8192 SPARC M5[33] Oracle 3600 OSA2011 2013 8×6=48 28 3900 511 ? ? ? 16×6 16×6 128×6 49152 SPARC M6[34] Oracle 3600 OSA2011 2013 8×12=96 28 4270 643 ? ? ? 16×12 16×12 128×12 49152 SPARC64 X+ (Athena+)[35] Fujitsu 3200–3700 OSA2011 / HPC-ACE 2014 2×16=32 28 2990 600 1500 392 ? 64×16 64×16 24M none SPARC64 XIfx[36] Fujitsu 2200 JPS2 / HPC-ACE2 2014 1×(32+2)=34 20 3750 ? 1001 ? ? 64×34 64×34 12M×2 none SPARC M7[37][38] Oracle 4133 OSA2015 2015 8×32=256 20 >10,000 ? ? ? ? 16×32 16×32 256×24 65536 SPARC S7[39][40] Oracle 4270 OSA2015 2016 8×8=64 20 ???? ? ? ? ? 16×8 16×8 256×2+256×4 16384 SPARC64 XII[41] Fujitsu 4250 OSA201? / HPC-ACE 2017 8×12=96 20 5500 795 1860 ? ? 64×12 64×12 512×12 32768 SPARC M8[42][43] Oracle 5000 OSA2017 2017 8×32=256 20 ? ? ? ? ? 32×32 16×32 128×32+256×8 65536 LEON4 Cobham Gaisler GR740 250[note 10] V8E 2017 1×4=4 32 — — — — 1.2/2.5/3.3 4x4 4x4 2048 none R2000 MCST (Russia) 2000 ? 2018 1×8=8 28 500 ? — ? ? ? ? ? none LEON5 Cobham Gaisler — V8E 2019 ? ? — — — — — ? ? 16–8192 none Name (codename) Model Frequency (MHz) Arch. version Year Total threads[note 1] Process (nm) Transistors (millions) Die size (mm2) IO pins Power (W) Voltage (V) L1 Dcache (KB) L1 Icache (KB) L2 cache (KB) L3 cache (KB)\n\nNotes:\n\nSPARC machines have generally used Sun's SunOS, Solaris, JavaOS, or OpenSolaris including derivatives illumos and OpenIndiana, but other operating systems have also been used, such as NeXTSTEP, RTEMS, FreeBSD, OpenBSD, NetBSD, and Linux.\n\nIn 1993, Intergraph announced a port of Windows NT to the SPARC architecture,[44] but it was later cancelled.\n\nIn October 2015, Oracle announced a \"Linux for SPARC reference platform\".[45]\n\nSeveral fully open source implementations of the SPARC architecture exist:\n\nLEON, a 32-bit radiation-tolerant, SPARC V8 implementation, designed especially for space use. Source code is written in VHDL, and licensed under the GPL.\n\nOpenSPARC T1, released in 2006, a 64-bit, 32-thread implementation conforming to the UltraSPARC Architecture 2005 and to SPARC Version 9 (Level 1). Source code is written in Verilog, and licensed under many licenses. Most OpenSPARC T1 source code is licensed under the GPL. Source based on existent open source projects will continue to be licensed under their current licenses. Binary programs are licensed under a binary software license agreement.\n\nS1, a 64-bit Wishbone compliant CPU core based on the OpenSPARC T1 design. It is a single UltraSPARC V9 core capable of 4-way SMT. Like the T1, the source code is licensed under the GPL.\n\nOpenSPARC T2, released in 2008, a 64-bit, 64-thread implementation conforming to the UltraSPARC Architecture 2007 and to SPARC Version 9 (Level 1). Source code is written in Verilog, and licensed under many licenses. Most OpenSPARC T2 source code is licensed under the GPL. Source based on existing open source projects will continue to be licensed under their current licenses. Binary programs are licensed under a binary Software License Agreement.\n\nA fully open source simulator for the SPARC architecture also exists:\n\nRAMP Gold, a 32-bit, 64-thread SPARC Version 8 implementation, designed for FPGA-based architecture simulation. RAMP Gold is written in ~36,000 lines of SystemVerilog, and licensed under the BSD licenses.\n\nFor HPC loads Fujitsu builds specialized SPARC64 fx processors with a new instruction extensions set, called HPC-ACE (High Performance Computing – Arithmetic Computational Extensions).\n\nFujitsu's K computer ranked No. 1 in the TOP500 June 2011 and November 2011 lists. It combines 88,128 SPARC64 VIIIfx CPUs, each with eight cores, for a total of 705,024 cores—almost twice as many as any other system in the TOP500 at that time. The K Computer was more powerful than the next five systems on the list combined, and had the highest performance-to-power ratio of any supercomputer system.[46] It also ranked No. 6 in the Green500 June 2011 list, with a score of 824.56 MFLOPS/W.[47] In the November 2012 release of TOP500, the K computer ranked No. 3, using by far the most power of the top three.[48] It ranked No. 85 on the corresponding Green500 release.[49] Newer HPC processors, IXfx and XIfx, were included in recent PRIMEHPC FX10 and FX100 supercomputers.\n\nTianhe-2 (TOP500 No. 1 as of November 2014[50]) has a number of nodes with Galaxy FT-1500 OpenSPARC-based processors developed in China. However, those processors did not contribute to the LINPACK score.[51][52]\n\nERC32 — based on SPARC V7 specification\n\nRoss Technology, Inc. — a SPARC microprocessor developer during the 1980s and 1990s\n\nSparcle — a modified SPARC with multiprocessing support used by the MIT Alewife project\n\nLEON — a space rated SPARC V8 processor.\n\nR1000 — a Russian quad-core microprocessor based on SPARC V9 specification\n\nGalaxy FT-1500 — a Chinese 16-core OpenSPARC-based processor"
    }
}