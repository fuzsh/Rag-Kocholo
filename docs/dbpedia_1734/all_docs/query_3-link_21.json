{
    "id": "dbpedia_1734_3",
    "rank": 21,
    "data": {
        "url": "https://dhirajpatra.medium.com/kafka-and-ai-b36eb4340526",
        "read_more_link": "",
        "language": "en",
        "title": "Kafka and AI",
        "top_image": "https://miro.medium.com/v2/resize:fit:1200/1*R394DaA7U8ZfPGojTQZ46w.jpeg",
        "meta_img": "https://miro.medium.com/v2/resize:fit:1200/1*R394DaA7U8ZfPGojTQZ46w.jpeg",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/1*ueg1h7g0vZWnJTCku_wZsg.png",
            "https://miro.medium.com/v2/resize:fill:144:144/1*ueg1h7g0vZWnJTCku_wZsg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Think Different - Dhiraj Patra",
            "dhirajpatra.medium.com"
        ],
        "publish_date": "2023-06-27T03:52:33.341000+00:00",
        "summary": "",
        "meta_description": "Apache Kafka® is a hot technology amongst application developers and architects looking to build the latest generation of real-time and web-scale applications. According the official Apache Kafka®…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://dhirajpatra.medium.com/kafka-and-ai-b36eb4340526",
        "text": "Overview\n\nApache Kafka® is a hot technology amongst application developers and architects looking to build the latest generation of real-time and web-scale applications. According the official Apache Kafka® website “Kafka is used for building real-time data pipelines and streaming apps. It is horizontally scalable, fault-tolerant, wicked fast, and runs in production in thousands of companies.”\n\nWhy Use a Queuing or Streaming Engine?\n\nKafka is part of general family of technologies known as queuing, messaging, or streaming engines. Other examples in this broad technology family include traditional message queue technology such RabbitMQ, IBM MQ, and Microsoft Message Queue. It can be said that Kafka is to traditional queuing technologies as NoSQL technology is to traditional relational databases. These newer technologies break through scalability and performance limitations of the traditional solutions while meeting similar needs, Apache Kafka can also be compared to proprietary solutions offered by the big cloud providers such as AWS Kinesis, Google Cloud Dataflow, and Azure Stream Analytics.\n\nTo smooth and increase reliability in the face of temporary spikes in workload. That is to deal gracefully with temporary incoming message rates greater than the processing app can deal with by quickly and safely storing the message until the processing system catches up and can clear the backlog.\n\nTo increase flexibility in your application architecture by completely decoupling applications that produce events from the applications that consume them. This is particularly important to successfully implementing a microservices architecture, the current state of the art in application architectures. By using a queuing system, applications that are producing events simply publish them to a named queue and applications that are interested in the events consume them off the queue. The publisher and then consumer don’t need to know anything about each other except for the name of the queue and the message schema. There can be one or many producers publishing the same kind of message to the queue and one or many consumers reading the message and neither side will care.\n\nadd an new API application that accepts customer registrations from a new partner and posts them to the queue; or\n\nadd a new consumer application that registers the customer in a CRM system.\n\nWhy Use Kafka?\n\nThe objectives we’ve mentioned above can be achieved with a range of technologies. So why would you use Kafka rather than one of those other technologies for your use case?\n\nIt’s highly scalable\n\nIt’s highly reliable due to built in replication, supporting true always-on operations\n\nIt’s Apache Foundation open source with a strong community\n\nIt has built-in optimizations such as compression and message batching\n\nIt has a strong reputation for being used by leading organizations. For example: LinkedIn (orginator), Pinterest, AirBnB, Datadog, Rabobank, Twitter, Netflix (see https://kafka.apache.org/powered-by for more)\n\nIt has a rich ecosystem around it including many connectors\n\nA distributed log store in a Kappa architecture\n\nA stream processing engine\n\nLooking Under the Hood\n\nLet’s take a look at how Kafka achieves all this: We’ll start with PRODUCERS. Producers are the applications that generate events and publish them to Kafka. Of course, they don’t randomly generate events — they create the events based on interactions with people, things, or systems. For example a mobile app could generate an event when someone clicks on a button, an IoT device could generate an event when a reading occurs, or an API application could generate an event when called by another application (in fact, it is likely an API application would sit between a mobile app or IoT device and Kafka). These producer applications use a Kafka producer library (similar in concept to a database driver) to send events to Kafka with libraries available for Java, C/ C++, Python, Go, and .NET.\n\nThe next component to understand is the CONSUMERS. Consumers are applications that read the event from Kafka and perform some processing on them. Like producers, they can be written in various languages using the Kafka client libraries.\n\nThe core of the system is the Kafka BROKERS. When people talk about a Kafka cluster they are typically talking about the cluster of brokers. The brokers receive events from the producer and reliably store them so they can be read by consumers.\n\nThe brokers are configured with TOPICS. Topics are a bit like tables in a database, separating different types of data. Each topic is split into PARTITIONS. When an event is received, a record is appended to the log file for the topic and partition that the event belongs to (as determined by the metadata provided by the producer). Each of the partitions that make up a topic are allocated to the brokers in the cluster. This allows each broker to share the processing of a topic. When a topic is created, it can be configured to be replicated multiple times across the cluster so that the data is still available for even if a server fails. For each partition, there is a single leader broker at any point in time that serves all reads and writes. The leader is responsible for synchronizing with the replicas. If the leader fails, Kafka will automatically transfer leader responsibility for its partitions to one of the replicas.\n\nIn some instances, guaranteed ordering of message delivery is important so that events are consumed in the same order they are produced. Kafka can support this guarantee at the topic level. To facilitate this, consumer applications are placed in consumer groups and within a CONSUMER GROUP a partition is associated with only a single consumer instance per consumer group.\n\nThe following diagram illustrates all these Kafka concepts and their relationships:\n\nA Kafka cluster is a complex distributed system with many configuration properties and possible interactions between components in the system. Operated well, Kafka can operate at the highest levels of reliability even in relatively unreliable infrastructure environments such as the cloud.\n\nSimple way we can use for an AI/ML application where we are using video streaming for smart camera system. AI application detect the person and object for further analysis.\n\nHere are the simple steps on how Kafka can be used for AI/ML application where video streaming is required to detect from image:\n\nInstall Kafka. Kafka is an open-source distributed streaming platform. You can install it on your local machine or on a cloud platform.\n\nConfigure Kafka. You need to configure Kafka to create a producer and a consumer. The producer will be responsible for sending the video streaming data to Kafka, and the consumer will be responsible for receiving the data and processing it.\n\nCreate a producer. The producer will be responsible for sending the video streaming data to Kafka. You can use the Kafka producer API to send the data.\n\nCreate a consumer. The consumer will be responsible for receiving the video streaming data from Kafka and processing it. You can use the Kafka consumer API to receive the data.\n\nProcess the data. The consumer will need to process the video streaming data and detect objects or events of interest. You can use a machine learning model to do this.\n\nHere is a diagram of the steps involved:\n\nVideo Streaming Data\n\nProducer → Kafka → Consumer → Machine Learning Model\n\nIn details a step-by-step guide on how Kafka can be used for an AI/ML application that involves video streaming and image detection:\n\n1. Set up a Kafka cluster: Install and configure Apache Kafka on your infrastructure. A Kafka cluster typically consists of multiple brokers (servers) that handle message storage and distribution.\n\n2. Define Kafka topics: Create Kafka topics to represent different stages of your AI/ML pipeline. For example, you might have topics like “raw_video_frames” to receive video frames and “processed_images” to store the results of image detection.\n\n3. Video ingestion: Develop a video ingestion component that reads video streams or video files and extracts individual frames. This component should publish each frame as a message to the “raw_video_frames” topic in Kafka.\n\n4. Implement image detection: Build an image detection module that takes each frame from the “raw_video_frames” topic, processes it using AI/ML algorithms, and generates a detection result. This component should consume messages from the “raw_video_frames” topic, perform image analysis, and produce the detected results.\n\n5. Publish results: Once the image detection is complete, the results can be published to the “processed_images” topic in Kafka. Each message published to this topic would contain the corresponding image frame and its associated detection results.\n\n6. Subscribers or consumers: Create subscriber applications that consume messages from the “processed_images” topic. These subscribers can be used for various purposes such as real-time visualization, storage, or triggering downstream actions based on the detection results.\n\n7. Scalability and parallel processing: Kafka’s partitioning feature allows you to process video frames and image detection results in parallel. You can have multiple instances of the image detection module running in parallel, each consuming frames from a specific partition of the “raw_video_frames” topic. Similarly, subscribers of the “processed_images” topic can scale horizontally to handle the processing load efficiently.\n\n8. Monitoring and management: Implement monitoring and management mechanisms to track the progress of your video processing pipeline. Kafka provides various tools and metrics to monitor the throughput, lag, and health of your Kafka cluster.\n\nBy following these steps, you can leverage Kafka’s distributed messaging system to build a scalable and efficient AI/ML application that can handle video streaming and image detection.\n\nYou can find out more on https://kafka.apache.org/ Most of the information used here were collected from Apache Kafka site and its documents.\n\nYou can find many examples in internet including this one https://www.researchgate.net/figure/Overview-of-Kafka-ML-architecture_fig3_353707721\n\nThank you."
    }
}