{
    "id": "dbpedia_6067_0",
    "rank": 57,
    "data": {
        "url": "https://quri-parts.qunasys.com/docs/tutorials/basics/real_devices/qiskit/",
        "read_more_link": "",
        "language": "en",
        "title": "Sampling on Qiskit's real quantum computers",
        "top_image": "https://quri-parts.qunasys.com/img/qunasys-logo.png",
        "meta_img": "https://quri-parts.qunasys.com/img/qunasys-logo.png",
        "images": [
            "https://quri-parts.qunasys.com/img/logo.png",
            "https://quri-parts.qunasys.com/img/logo-dark.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Here we introduce the Qiskit backends. For IBM devices, we provide 2 sampling backends:",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://quri-parts.qunasys.com/docs/tutorials/basics/real_devices/qiskit/",
        "text": "Here we introduce the Qiskit backends. For IBM devices, we provide 2 sampling backends:\n\nQiskitSamplingBackend : For the IBMQ backends\n\nQiskitRuntimeSamplingBackend: For the devices provided by the QiskitRuntimeService\n\nwhich we provide further details on how to use them.\n\nThis section requires topics described in the previous sections (Sampler, Sampling estimation and Sampling Backend), so you need to read them before this section.\n\nQURI Parts modules used in this tutorial: quri-parts-circuit, quri-parts-core and quri-parts-qiskit. You can install them as follows:\n\nFor using an IBMQ backend real device, you would need to activate your account first, then you may pick a device you prefer listed by the all_device variable defined below:\n\nThen, a QiskitSamplingBackend may be created by passing in the device\n\nWith the sampling backend we just created, we can run the exact codes as in the Sampling Backend and Sampler section of the Sampling Backend tutorial.\n\nQiskit Runtime is a new service provided by IBM to perform experiments on real devices. In this section, we demonstrate how to submit jobs to Qiskit Runtime via QURI Parts. We first prepare some circuit\n\nFor using the Qiskit Runtime service, you can create a QiskitRuntimeSamplingBackend by passing in a qiskit.providers.backend and a qiskit_ibm_runtime.QiskitRuntimeService object. To see the list of all the devices supported by the Qiskit Runtime Service, you may run:\n\nWe are now ready to create a qiskit runtime sampling backend\n\nA sampler can be created as usual\n\nIn Qiskit Runtime Service, they provide Session objects that allows us to group jobs together. In the above example, a Session is created every time the sampler is called. In QURI Parts, we can group jobs into a single Session with the QiskitRuntimeSamplingBackend as well.\n\nWhen executing jobs on real devices, it can be useful to keep track of the cost by tracking the billable time. In the QiskitRuntimeSamplingBackend, we provide the total_time_limit option that allows you to track the total billable time. If the total billable time exceeds the time limit, the backend will reject new job submissions and cancel all unfinished jobs. Let’s create a backend with run time limit of 100 seconds:\n\nWhen the total time limit is set, a Tracker object is created along with the sampling backend. You may access it by the .tracker attribute.\n\nThe total billable run time of jobs submitted by the backend is not tracked automatically. Instead, it is computed whenever any of the total_run_time, running_jobs, finished_jobs properties is accessed. As we have not submitted any jobs with the backend we just created, it should be 0 at the moment.\n\n0.0\n\nWhen we submit jobs with the backend, the jobs will be registered to the tracker for tracking. For example let’s submit 3 sampling jobs:\n\nThese jobs will be stored inside the tracker and can be accessed by the .running_jobs property if they are still being executed by the real device. If any of the job is finished, you may access them with the .finished_jobs property.\n\nAs we might want to perform different analysis using the same data generated by real devices, having a way to save and retrieve past experiment data can be useful. In this section, we explain how to save and replay past experiment data generated by Qiskit devices.\n\nThe data saving feature can be activated by setting the save_data_while_sampling to True. Both QiskitSamplingBackend and QiskitRuntimeSamplingBackend support this feature. Let’s use the local Aer simulator as an example.\n\nAfter performing sampling job like the above, we may save the sampling data into a json file:"
    }
}