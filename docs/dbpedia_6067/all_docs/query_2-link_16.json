{
    "id": "dbpedia_6067_2",
    "rank": 16,
    "data": {
        "url": "https://stackoverflow.com/questions/418914/why-is-c-so-fast-and-why-arent-other-languages-as-fast-or-faster",
        "read_more_link": "",
        "language": "en",
        "title": "Why is C so fast, and why aren't other languages as fast or faster?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://lh4.googleusercontent.com/-W_1DgAFW1cw/AAAAAAAAAAI/AAAAAAAAY0k/7nLe8v9rz6M/photo.jpg?sz=64",
            "https://graph.facebook.com/496260983880990/picture?type=large",
            "https://www.gravatar.com/avatar/1de7574c70db36492ea962c22e2252a8?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/7FnYg.jpg?s=64",
            "https://www.gravatar.com/avatar/a007be5a61f6aa8f3e85ae2fc18dd66e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/JP7C7.png?s=64",
            "https://www.gravatar.com/avatar/04ba362109d3862660d4b1b0b3f2d923?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/bc46fdb623a9c91672c68be6dc3e80d8?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f79a7909dfca0088f4fdc01f109f497e?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/7dd45a27a5616b8a5608b84007e4e08f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/f609c97aa34e4c9b3b5ec8232f3a44db?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/iQcva.jpg?s=64",
            "https://www.gravatar.com/avatar/c906eb019c67f76f8bcdc9897847eda4?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/748e3f66b86e1f84dddfd4151e219be0?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/53ee9941b3fefef67175daf212e62d41?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/704e34cccf484f4ee708d00657093674?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/FtcvL.png?s=64",
            "https://www.gravatar.com/avatar/13d0dfe5c8b53a2e617af0725fb83d0b?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/06969baf813bc19566b382484068a211?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/d796ba58a4582831881d9fc896de2427?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/X2g3z.png?s=64",
            "https://www.gravatar.com/avatar/c3ae6a1b8d708b79b6b85ecc365266a4?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/H4G5i.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/66c3eb9f37055da583d65f4fcbe04b08?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/b6ece6d41e5bc5a5e35f7c3f8b67420d?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2faf0c72f6a7f65431e7df489878be24?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/d92b64b0bbc0f2b7297924e76c4a4a84?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/8e25c72c9528fd7a7610a15f4cad6382?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/NeuGc.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/c23ef823ae0ba03daf7675991deb3083?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/679417fdfb152a19e639912e33692a6e?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/9cd57855e7bff23fbca35abc8ddc0073?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/e6Xo3.png?s=64",
            "https://stackoverflow.com/posts/418914/ivc/5faf?prg=3c0839cd-af17-4c23-a75e-b000af62f97c"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-01-07T01:59:06",
        "summary": "",
        "meta_description": "In listening to the Stack Overflow podcast, the jab keeps coming up that &quot;real programmers&quot; write in C, and that C is so much faster because it's &quot;close to the machine.&quot; Leaving...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/418914/why-is-c-so-fast-and-why-arent-other-languages-as-fast-or-faster",
        "text": "There is a trade-off the C designers have made. That's to say, they made the decision to put speed above safety. C won't\n\nCheck array index bounds\n\nCheck for uninitialized variable values\n\nCheck for memory leaks\n\nCheck for null pointer dereference\n\nWhen you index into an array, in Java it takes some method call in the virtual machine, bound checking and other sanity checks. That is valid and absolutely fine, because it adds safety where it's due. But in C, even pretty trivial things are not put in safety. For example, C doesn't require memcpy to check whether the regions to copy overlap. It's not designed as a language to program a big business application.\n\nBut these design decisions are not bugs in the C language. They are by design, as it allows compilers and library writers to get every bit of performance out of the computer. Here is the spirit of C how the C Rationale document explains it:\n\nC code can be non-portable. Although it strove to give programmers the opportunity to write truly portable programs, the Committee did not want to force programmers into writing portably, to preclude the use of C as a ``high-level assembler'': the ability to write machine-specific code is one of the strengths of C.\n\nKeep the spirit of C. The Committee kept as a major goal to preserve the traditional spirit of C. There are many facets of the spirit of C, but the essence is a community sentiment of the underlying principles upon which the C language is based. Some of the facets of the spirit of C can be summarized in phrases like\n\nTrust the programmer.\n\nDon't prevent the programmer from doing what needs to be done.\n\nKeep the language small and simple.\n\nProvide only one way to do an operation.\n\nMake it fast, even if it is not guaranteed to be portable.\n\nThe last proverb needs a little explanation. The potential for efficient code generation is one of the most important strengths of C. To help ensure that no code explosion occurs for what appears to be a very simple operation, many operations are defined to be how the target machine's hardware does it rather than by a general abstract rule. An example of this willingness to live with what the machine does can be seen in the rules that govern the widening of char objects for use in expressions: whether the values of char objects widen to signed or unsigned quantities typically depends on which byte operation is more efficient on the target machine.\n\nIf you spend a month to build something in C that runs in 0.05 seconds, and I spend a day writing the same thing in Java, and it runs in 0.10 seconds, then is C really faster?\n\nBut to answer your question, well-written C code will generally run faster than well-written code in other languages because part of writing C code \"well\" includes doing manual optimizations at a near-machine level.\n\nAlthough compilers are very clever indeed, they are not yet able to creatively come up with code that competes with hand-massaged algorithms (assuming the \"hands\" belong to a good C programmer).\n\nEdit:\n\nA lot of comments are along the lines of \"I write in C and I don't think about optimizations.\"\n\nBut to take a specific example from this post:\n\nIn Delphi I could write this:\n\nfunction RemoveAllAFromB(a, b: string): string; var before, after :string; begin Result := b; if 0 < Pos(a,b) then begin before := Copy(b,1,Pos(a,b)-Length(a)); after := Copy(b,Pos(a,b)+Length(a),Length(b)); Result := before + after; Result := RemoveAllAFromB(a,Result); //recursive end; end;\n\nand in C I write this:\n\nchar *s1, *s2, *result; /* original strings and the result string */ int len1, len2; /* lengths of the strings */ for (i = 0; i < len1; i++) { for (j = 0; j < len2; j++) { if (s1[i] == s2[j]) { break; } } if (j == len2) { /* s1[i] is not found in s2 */ *result = s1[i]; result++; /* assuming your result array is long enough */ } }\n\nBut how many optimizations are there in the C version? We make lots of decisions about implementation that I don't think about in the Delphi version. How is a string implemented? In Delphi I don't see it. In C, I've decided it will be a pointer to an array of ASCII integers, which we call chars. In C, we test for character existence one at a time. In Delphi, I use Pos.\n\nAnd this is just a small example. In a large program, a C programmer has to make these kinds of low-level decisions with every few lines of code. It adds up to a hand-crafted, hand-optimized executable.\n\nI didn't see it already, so I'll say it: C tends to be faster because almost everything else is written in C.\n\nJava is built on C, Python is built on C (or Java, or .NET, etc.), Perl is, etc. The OS is written in C, the virtual machines are written in C, the compilers are written in C, the interpreters are written in C. Some things are still written in Assembly language, which tends to be even faster. More and more things are being written in something else, which is itself written in C.\n\nEach statement that you write in other languages (not Assembly) is typically implemented underneath as several statements in C, which are compiled down to native machine code. Since those other languages tend to exist in order to obtain a higher level of abstraction than C, those extra statements required in C tend to be focused on adding safety, adding complexity, and providing error handling. Those are often good things, but they have a cost, and its names are speed and size.\n\nPersonally, I have written in literally dozens of languages spanning most of the available spectrum, and I personally have sought the magic that you hint at:\n\nHow can I have my cake and eat it, too? How can I play with high-level abstractions in my favorite language, then drop down to the nitty gritty of C for speed?\n\nAfter a couple of years of research, my answer is Python (on C). You might want to give it a look. By the way, you can also drop down to Assembly from Python, too (with some minor help from a special library).\n\nOn the other hand, bad code can be written in any language. Therefore, C (or Assembly) code is not automatically faster. Likewise, some optimization tricks can bring portions of higher-level language code close to the performance level of raw C. But, for most applications, your program spends most of its time waiting on people or hardware, so the difference really does not matter.\n\nEnjoy.\n\nC is not always faster.\n\nC is slower than, for example, Modern Fortran.\n\nC is often slower than Java for some things (especially after the JIT compiler has had a go at your code).\n\nC lets pointer aliasing happen, which means some good optimizations are not possible. Particularly when you have multiple execution units, this causes data fetch stalls. Ow.\n\nThe assumption that pointer arithmetic works really causes slow bloated performance on some CPU families (PIC particularly!) It used to suck the big one on segmented x86.\n\nBasically, when you get a vector unit, or a parallelizing compiler, C stinks and modern Fortran runs faster.\n\nC programmer tricks, like thunking (modifying the executable on the fly), cause CPU prefetch stalls.\n\nDo you get the drift?\n\nAnd our good friend, the x86, executes an instruction set that these days bears little relationship to the actual CPU architecture. Shadow registers, load-store optimizers, all in the CPU. So C is then close to the virtual metal. The real metal, Intel don't let you see. (Historically VLIW CPU's were a bit of a bust so, maybe that's no so bad.)\n\nIf you program in C on a high-performance DSP (maybe a TI DSP?), the compiler has to do some tricky stuff to unroll the C across the multiple parallel execution units. So in that case, C isn't close to the metal, but it is close to the compiler, which will do whole program optimization. Weird.\n\nAnd finally, some CPUs (like JOP project7) run Java bytecodes in hardware, well on a gate-array.\n\nI guess you forgot that Assembly language is also a language :)\n\nBut seriously, C programs are faster only when the programmer knows what he's doing. You can easily write a C program that runs slower than programs written in other languages that do the same job.\n\nThe reason why C is faster is because it is designed in this way. It lets you do a lot of \"lower level\" stuff that helps the compiler to optimize the code. Or, shall we say, you the programmer are responsible for optimizing the code. But it's often quite tricky and error prone.\n\nOther languages, like others already mentioned, focus more on productivity of the programmer. It is commonly believed that programmer time is much more expensive than machine time (even in the old days). So it makes a lot of sense to minimize the time programmers spend on writing and debugging programs instead of the running time of the programs. To do that, you will sacrifice a bit on what you can do to make the program faster because a lot of things are automated.\n\nMany of these answers give valid reasons for why C is, or is not, faster (either in general or in specific scenarios). It's undeniable that:\n\nMany other languages provide automatic features that we take for granted. Bounds checking, run-time type checking, and automatic memory management, for example, don't come for free. There is at least some cost associated with these features, which we may not think about—or even realize—while writing code that uses these features.\n\nThe step from source to machine is often not as direct in other languages as it is in C.\n\nOTOH, to say that compiled C code executes faster than other code written in other languages is a generalization that isn't always true. Counter-examples are easy to find (or contrive).\n\nAll of this notwithstanding, there is something else I have noticed that, I think, affects the comparative performance of C vs. many other languages more greatly than any other factor. To wit:\n\nOther languages often make it easier to write code that executes more slowly. Often, it's even encouraged by the design philosophies of the language. Corollary: a C programmer is more likely to write code that doesn't perform unnecessary operations.\n\nAs an example, consider a simple Windows program in which a single main window is created. A C version would populate a WNDCLASS[EX] structure which would be passed to RegisterClass[Ex], then call CreateWindow[Ex] and enter a message loop. Highly simplified and abbreviated code follows:\n\nWNDCLASS wc; MSG msg; wc.style = 0; wc.lpfnWndProc = &WndProc; wc.cbClsExtra = 0; wc.cbWndExtra = 0; wc.hInstance = hInstance; wc.hIcon = NULL; wc.hCursor = LoadCursor(NULL, IDC_ARROW); wc.hbrBackground = (HBRUSH)(COLOR_BTNFACE + 1); wc.lpszMenuName = NULL; wc.lpszClassName = \"MainWndCls\"; RegisterClass(&wc); CreateWindow(\"MainWndCls\", \"\", WS_OVERLAPPEDWINDOW | WS_VISIBLE, CW_USEDEFAULT, 0, CW_USEDEFAULT, 0, NULL, NULL, hInstance, NULL); while(GetMessage(&msg, NULL, 0, 0)){ TranslateMessage(&msg); DispatchMessage(&msg); }\n\nAn equivalent program in C# could be just one line of code:\n\nApplication.Run(new Form());\n\nThis one line of code provides all of the functionality that nearly 20 lines of C code did, and adds some things we left out, such as error checking. The richer, fuller library (compared to those used in a typical C project) did a lot of work for us, freeing our time to write many more snippets of code that look short to us but involve many steps behind the scenes.\n\nBut a rich library enabling easy and quick code bloat isn't really my point. My point is more apparent when you start examining what actually happens when our little one-liner actually executes. For fun sometime, enable .NET source access in Visual Studio 2008 or higher, and step into the simple one-linef above. One of the fun little gems you'll come across is this comment in the getter for Control.CreateParams:\n\n// In a typical control this is accessed ten times to create and show a control. // It is a net memory savings, then, to maintain a copy on control. // if (createParams == null) { createParams = new CreateParams(); }\n\nTen times. The information roughly equivalent to the sum of what's stored in a WNDCLASSEX structure and what's passed to CreateWindowEx is retrieved from the Control class ten times before it's stored in a WNDCLASSEX structure and passed on to RegisterClassEx and CreateWindowEx.\n\nAll in all, the number of instructions executed to perform this very basic task is 2–3 orders of magnitude more in C# than in C. Part of this is due to the use of a feature-rich library, which is necessarily generalized, versus our simple C code which does exactly what we need and nothing more. But part of it is due to the fact that the modularized, object-oriented nature of .NET framework, lends itself to a lot of repetition of execution that often is avoided by a procedural approach.\n\nI'm not trying to pick on C# or the .NET framework. Nor am I saying that modularization, generalization, library/language features, OOP, etc. are bad things. I used to do most of my development in C, later in C++, and most lately in C#. Similarly, before C, I used mostly assembly. And with each step \"higher\" my language goes, I write better, more maintainable, more robust programs in less time. They do, however, tend to execute a little more slowly.\n\nI don't think anyone has mentioned the fact that much more effort has been put into C compilers than any other compiler, with perhaps the exception of Java.\n\nC is extremely optimizable for many of the reasons already stated - more than almost any other language. So if the same amount of effort is put into other language compilers, C will probably still come out on top.\n\nI think there is at least one candidate language that, with effort, could be optimized better than C and thus we could see implementations that produce faster binaries. I'm thinking of Digital Mars' D, because the creator took care to build a language that could potentially be better optimized than C. There may be other languages that have this possibility. However, I cannot imagine that any language will have compilers more than just a few percent faster than the best C compilers. I would love to be wrong.\n\nI think the real \"low hanging fruit\" will be in languages that are designed to be easy for humans to optimize. A skilled programmer can make any language go faster, but sometimes you have to do ridiculous things or use unnatural constructs to make this happen. Although it will always take effort, a good language should produce relatively fast code without having to obsess over exactly how the program is written.\n\nIt's also important (at least to me) that the worst case code tends to be fast. There are numerous \"proofs\" on the web that Java is as fast or faster than C, but that is based on cherry picking examples.\n\nI'm not big fan of C, but I know that anything I write in C is going to run well. With Java, it will \"probably\" run within 15% of the speed, usually within 25%, but in some cases it can be far worse. Any cases where it's just as fast or within a couple of percent are usually due to most of the time being spent in the library code which is heavily optimized C code anyway.\n\nThis is actually a bit of a perpetuated falsehood. While it is true that C programs are frequently faster, this is not always the case, especially if the C programmer isn't very good at it.\n\nOne big glaring hole that people tend to forget about is when the program has to block for some sort of I/O, such as user input in any GUI program. In these cases, it doesn't really matter what language you use since you are limited by the rate at which data can come in rather than how fast you can process it. In this case, it doesn't matter much if you are using C, Java, C# or even Perl; you just cannot go any faster than the data can come in.\n\nThe other major thing is that using garbage collection (GC) and not using proper pointers allows the virtual machine to make a number of optimizations not available in other languages. For instance, the JVM is capable of moving objects around on the heap to defragment it. This makes future allocations much faster since the next index can simply be used rather than looking it up in a table. Modern JVMs also don't have to actually deallocate memory; instead, they just move the live objects around when they GC and the spent memory from the dead objects is recovered essentially for free.\n\nThis also brings up an interesting point about C and even more so in C++. There is something of a design philosophy of \"If you don't need it, you don't pay for it.\" The problem is that if you do want it, you end up paying through the nose for it. For instance, the vtable implementation in Java tends to be a lot better than C++ implementations, so virtual function calls are a lot faster. On the other hand, you have no choice but to use virtual functions in Java and they still cost something, but in programs that use a lot of virtual functions, the reduced cost adds up.\n\nDon't take someone’s word for it; look at the disassembly for both C and your language-of-choice in any performance critical part of your code. I think you can just look in the disassembly window at runtime in Visual Studio to see disassembled .NET code. It should be possible, if tricky, for Java using WinDbg, though if you do it with .NET, many of the issues would be the same.\n\nI don't like to write in C if I don't need to, but I think many of the claims made in these answers that tout the speed of languages other than C can be put aside by simply disassembling the same routine in C and in your higher level language of choice, especially if lots of data is involved as is common in performance critical applications. Fortran may be an exception in its area of expertise; I don't know. Is it higher level than C?\n\nThe first time I did compare JITed code with native code resolved any and all questions whether .NET code could run comparably to C code. The extra level of abstraction and all the safety checks come with a significant cost. The same costs would probably apply to Java, but don't take my word for it; try it on something where performance is critical. (Does anyone know enough about JITed Java to locate a compiled procedure in memory? It should certainly be possible.)\n\nSetting aside advanced optimization techniques such as hot-spot optimization, pre-compiled meta-algorithms, and various forms of parallelism, the fundamental speed of a language correlates strongly with the implicit behind-the-scenes complexity required to support the operations that would commonly be specified within inner loops.\n\nPerhaps the most obvious is validity checking on indirect memory references—such as checking pointers for null and checking indexes against array boundaries. Most high-level languages perform these checks implicitly, but C does not. However, this is not necessarily a fundamental limitation of these other languages—a sufficiently clever compiler may be capable of removing these checks from the inner loops of an algorithm through some form of loop-invariant code motion.\n\nThe more fundamental advantage of C (and to a similar extent the closely related C++) is a heavy reliance on stack-based memory allocation, which is inherently fast for allocation, deallocation, and access. In C (and C++) the primary call stack can be used for allocation of primitives, arrays, and aggregates (struct/class).\n\nWhile C does offer the capability to dynamically allocate memory of arbitrary size and lifetime (using the so called 'heap'), doing so is avoided by default (the stack is used instead).\n\nTantalizingly, it is sometimes possible to replicate the C memory allocation strategy within the runtime environments of other programming languages. This has been demonstrated by asm.js, which allows code written in C or C++ to be translated into a subset of JavaScript and run safely in a web browser environment—with near-native speed.\n\nAs somewhat of an aside, another area where C and C++ outshine most other languages for speed is the ability to seamlessly integrate with native machine instruction sets. A notable example of this is the (compiler and platform dependent) availability of SIMD intrinsics which support the construction of custom algorithms that take advantage of the now nearly ubiquitous parallel processing hardware—while still utilizing the data allocation abstractions provided by the language (lower-level register allocation is managed by the compiler).\n\nBack in the good ole days, there were just two types of languages: compiled and interpreted.\n\nCompiled languages utilized a \"compiler\" to read the language syntax and convert it into identical assembly language code, which could than just directly on the CPU. Interpreted languages used a couple of different schemes, but essentially the language syntax was converted into an intermediate form, and then run in a \"interpreter\", an environment for executing the code.\n\nThus, in a sense, there was another \"layer\" -- the interpreter -- between the code and the machine. And, as always the case in a computer, more means more resources get used. Interpreters were slower, because they had to perform more operations.\n\nMore recently, we've seen more hybrid languages like Java, that employ both a compiler and an interpreter to make them work. It's complicated, but a JVM is faster, more sophisticated and way more optimized than the old interpreters, so it stands a much better change of performing (over time) closer to just straight compiled code. Of course, the newer compilers also have more fancy optimizing tricks so they tend to generate way better code than they used to as well. But most optimizations, most often (although not always) make some type of trade-off such that they are not always faster in all circumstances. Like everything else, nothing comes for free, so the optimizers must get their boast from somewhere (although often times it using compile-time CPU to save runtime CPU).\n\nGetting back to C, it is a simple language, that can be compiled into fairly optimized assembly and then run directly on the target machine. In C, if you increment an integer, it's more than likely that it is only one assembler step in the CPU, in Java however, it could end up being a lot more than that (and could include a bit of garbage collection as well :-) C offers you an abstraction that is way closer to the machine (assembler is the closest), but you end up having to do way more work to get it going and it is not as protected, easy to use or error friendly. Most other languages give you a higher abstraction and take care of more of the underlying details for you, but in exchange for their advanced functionality they require more resources to run. As you generalize some solutions, you have to handle a broader range of computing, which often requires more resources.\n\nWith modern optimizing compilers, it's highly unlikely that a pure C program is going to be all that much faster than compiled .NET code, if at all. With the productivity enhancement that frameworks like .NET provide the developer, you can do things in a day that used to take weeks or months in regular C. Coupled with the cheap cost of hardware compared to a developer's salary, it's just way cheaper to write the stuff in a high-level language and throw hardware at any slowness.\n\nThe reason Jeff and Joel talk about C being the \"real programmer\" language is because there isn't any hand-holding in C. You must allocate your own memory, deallocate that memory, do your own bounds-checking, etc. There isn't any such thing as new object(); There isn't any garbage collection, classes, OOP, entity frameworks, LINQ, properties, attributes, fields, or anything like that.\n\nYou have to know things like pointer arithmetic and how to dereference a pointer. And, for that matter, know and understand what a pointer is. You have to know what a stack frame is and what the instruction pointer is. You have to know the memory model of the CPU architecture you're working on. There is a lot of implicit understanding of the architecture of a microcomputer (usually the microcomputer you're working on) when programming in C that simply is not present nor necessary when programming in something like C# or Java. All of that information has been off-loaded to the compiler (or VM) programmer.\n\nIt's the difference between automatic and manual. Higher-level languages are abstractions, thus automated. C/C++ are manually controlled and handled; even error checking code is sometimes a manual labor.\n\nC and C++ are also compiled languages which means none of that run-everywhere business. These languages have to be fine-tuned for the hardware you work with, thus adding an extra layer of gotcha. Though this is slightly phasing out now as C/C++ compilers are becoming more common across all platforms. You can do cross compilations between platforms. It's still not a run everywhere situation, and you’re basically instructing compiler A to compile against compiler B the same code on a different architecture.\n\nBottom line, C languages are not meant to be easy to understand or reason. This is also why they’re referred to as systems languages. They came out before all this high-level abstraction nonsense. This is also why they are not used for front end web programming. They’re just not suited to the task; they’re meant to solve complex problems that can't be resolved with conventional language tooling.\n\nThis is why you get crazy stuff, like micro-architectures, drivers, quantum physics, AAA games, and operating systems. There are things C and C++ are just well suited for. Speed and number crunching being the chief areas."
    }
}