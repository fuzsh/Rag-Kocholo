{
    "id": "dbpedia_6067_2",
    "rank": 81,
    "data": {
        "url": "https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-paradigm-in-programmin",
        "read_more_link": "",
        "language": "en",
        "title": "What is the difference between declarative and imperative paradigm in programming?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://lh3.googleusercontent.com/a-/AAuE7mDZopUyzXjIHDwhKQdskFzNbIW99yO73OPQqgPqyg=k-s64",
            "https://www.gravatar.com/avatar/f3d41ab51c67c43a826caf36f9eb9062?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/87b3a4c585e6fd2ad5308e15e12bdc36?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/rTmRA.jpg?s=64",
            "https://www.gravatar.com/avatar/2399133df2eee6cc4d77c6662d50e5db?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/2d0efd3335d52ea01310d4cac797f80f?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/e43e620f96a26bf6ee7fa70750c0302a?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/21o5X.jpg?s=64",
            "https://www.gravatar.com/avatar/96b236f5075479289b5ccd05dc56f76a?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/OK1Pm.jpg?s=64",
            "https://i.sstatic.net/KzenF.png?s=64",
            "https://www.gravatar.com/avatar/3ceca551f9fca86508e37cf9ec436570?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/ac85ed46c6bbf694d62968bfc3ffd3be?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/08bc2edb5f1342c0c1e4805f4d4585bf?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/335c623228d1b4cb43f7fc5ed3f177a4?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/cd721c97d499ac8a084c0210f2bd16ac?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/gerXo.png?s=64",
            "https://i.sstatic.net/7aLLR.png",
            "https://i.sstatic.net/nT7ET.jpg?s=64",
            "https://i.sstatic.net/UHx7w.jpg?s=64",
            "https://i.sstatic.net/ij6dO.png?s=64",
            "https://i.sstatic.net/R7Q27.png?s=64",
            "https://graph.facebook.com/1415608815418639/picture?type=large",
            "https://www.gravatar.com/avatar/f483473f29484c14482db8c5eae13dcd?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/MmWIF.jpg?s=64",
            "https://www.gravatar.com/avatar/df9b1cab1c92b5a3ca9707a26333f53b?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/Iebdt.jpg?s=64",
            "https://graph.facebook.com/1096330634/picture?type=large",
            "https://www.gravatar.com/avatar/eda258d9b32e88dfac9d35b65a2b16e4?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://stackoverflow.com/posts/1784664/ivc/5faf?prg=3946f30c-c032-42a0-9461-7ed1111ee544"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-11-23T17:24:41",
        "summary": "",
        "meta_description": "I have been searching the web looking for a definition for declarative and imperative programming that would shed some light for me. However, the language used at some of the resources that I have ...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/1784664/what-is-the-difference-between-declarative-and-imperative-paradigm-in-programmin",
        "text": "Declarative programming is when you say what you want, and imperative language is when you say how to get what you want.\n\nA simple example in Python:\n\n# Declarative small_nums = [x for x in range(20) if x < 5] # Imperative small_nums = [] for i in range(20): if i < 5: small_nums.append(i)\n\nThe first example is declarative because we do not specify any \"implementation details\" of building the list.\n\nTo tie in a C# example, generally, using LINQ results in a declarative style, because you aren't saying how to obtain what you want; you are only saying what you want. You could say the same about SQL.\n\nOne benefit of declarative programming is that it allows the compiler to make decisions that might result in better code than what you might make by hand. Running with the SQL example, if you had a query like\n\nSELECT score FROM games WHERE id < 100;\n\nthe SQL \"compiler\" can \"optimize\" this query because it knows that id is an indexed field -- or maybe it isn't indexed, in which case it will have to iterate over the entire data set anyway. Or maybe the SQL engine knows that this is the perfect time to utilize all 8 cores for a speedy parallel search. You, as a programmer, aren't concerned with any of those conditions, and you don't have to write your code to handle any special case in that way.\n\nDeclarative vs. Imperative\n\nA programming paradigm is a fundamental style of computer programming. There are four main paradigms: imperative, declarative, functional (which is considered a subset of the declarative paradigm) and object-oriented.\n\nDeclarative programming : is a programming paradigm that expresses the logic of a computation(What do) without describing its control flow(How do). Some well-known examples of declarative domain specific languages (DSLs) include CSS, regular expressions, and a subset of SQL (SELECT queries, for example) Many markup languages such as HTML, MXML, XAML, XSLT... are often declarative. The declarative programming try to blur the distinction between a program as a set of instructions and a program as an assertion about the desired answer.\n\nImperative programming : is a programming paradigm that describes computation in terms of statements that change a program state. The imperative programs can be dually viewed as programming commands or mathematical assertions.\n\nFunctional programming : is a programming paradigm that treats computation as the evaluation of mathematical functions and avoids state and mutable data. It emphasizes the application of functions, in contrast to the imperative programming style, which emphasizes changes in state. In a pure functional language, such as Haskell, all functions are without side effects, and state changes are only represented as functions that transform the state.\n\nThe following example of imperative programming in MSDN, loops through the numbers 1 through 10, and finds the even numbers.\n\nvar numbersOneThroughTen = new List<int> { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 }; //With imperative programming, we'd step through this, and decide what we want: var evenNumbers = new List<int>(); foreach (var number in numbersOneThroughTen) { if (number % 2 == 0) { evenNumbers.Add(number); } } //The following code uses declarative programming to accomplish the same thing. // Here, we're saying \"Give us everything where it's even\" var evenNumbers = numbersOneThroughTen.Where(number => number % 2 == 0);\n\nBoth examples yield the same result, and one is neither better nor worse than the other. The first example requires more code, but the code is testable, and the imperative approach gives you full control over the implementation details. In the second example, the code is arguably more readable; however, LINQ does not give you control over what happens behind the scenes. You must trust that LINQ will provide the requested result.\n\nAnswers here and in other online posts mention the following:\n\nWith declarative programming, you write code that describes what you want, but not necessarily how to get it\n\nYou should prefer declarative programming over the imperative programming\n\nWhat they have not told us is how to achieve it. For part of the program to be more declarative, other parts must provide the abstraction to hide the implementation details (which is the imperative code).\n\nE.g., LINQ is more declarative than loops (for, while, etc.), e.g., you can use list.Where() to get a new filtered list. For this to work, Microsoft has done all the heavy lifting behind the LINQ abstraction.\n\nIn fact, one of the reason functional programming and functional libraries are more declarative is because they have abstracted away loops and list creations, hiding all the implementation details (most likely imperative code with loops) behind the scene.\n\nIn any program, you will always have both imperative and declarative code, and you should aim to hide all imperative code behind the domain-specific abstractions, so that other parts of the program can use them declaratively.\n\nFinally, although functional programming and LINQ can make your program more declarative, you can always make it even more declarative by providing more abstractions. For example:\n\n// JavaScript example // Least declarative const bestProducts = []; for(let i = 0; i < products.length; i++) { let product = products[i]; if (product.rating >= 5 && product.price < 100) { bestProducts.push(product); } } // More declarative const bestProducts = products.filter(function(product) { return product.rating >= 5 && product.price < 100; }); // Most declarative, implementation details are hidden in a function const bestProducts = getBestProducts();\n\nP.S. the extreme of declarative programming is to invent new domain specific languages (DSL):\n\nString Search: Regular Expression instead of custom imperative code\n\nReact.js: JSX instead of direct DOM manipulation\n\nAWS CloudFormation: YAML instead of CLI\n\nRelational Database: SQL instead of older readâ€“write APIs such as ISAM or VSAM.\n\nI'll add another example that rarely pops up in declarative/imperative programming discussion: the User Interface!\n\nIn C#, you can build an UI using various technologies.\n\nOn the imperative end, you could use DirectX or OpenGL to very imperatively draw your buttons, checkboxes, etc... line-by-line (or really, triangle by triangle). It is up to you to say how to draw the user interface.\n\nAt the declarative end, you have WPF. You basically write some XML (yeah, yeah, \"XAML\" technically) and the framework does the work for you. You say what the user interface looks like. It is up to the system to figure out how to do it.\n\nAnyway, just another thing to think about. Just because one language is declarative or imperative does not mean that it doesn't have certain features of the other.\n\nAlso, one benefit of declarative programming is that purpose is usually more easily understood from reading the code whereas imperative gives you finer control over execution.\n\nThe gist of it all:\n\nDeclarative -> what you want done\n\nImperative -> how you want it done\n\nJust a practical example, of why CSS being declarative and JavaScript being imperative.\n\nImagine we have this navbar, and the user is currently looking at \"Explore\" option so it is marked as currently selected.\n\n<ul> <li class=\"selected\"> <p>Explore</p> </li> <li> <p>Suggestions</p> </li> </ul>\n\nWe want the title of the currently selected option to be blue, how do we achieve this with CSS and JavaScript?\n\nCSS\n\nli.selected > p { color: blue; }\n\nHere li.selected > p declares the pattern of element to which we want the property color: blue; to be applied. The result is \"Explore\" is highlighted in blue but \"Suggestions\" is not. Notice, our code describes what we want to happen and not how. How does CSS selector engine find \"Explore\"? We don't know and usually don't care.\n\nJavaScript\n\nlet liElements = document.getElementsByTagName(\"li\") for (let i = 0; i < liElements.length; i++) { if (liElements[i].className === \"selected\") { let children = liElements[i].childNodes for (let j = 0; j < children. length; j++) { let child = children[j] if (child.nodeType === Node.ELEMENT_NODE && child.tagName === \"P\") { child.setAttribute(\"style\", \"color: blue\") } } } }\n\nThis code is much longer and harder to understand. Other than that, it applies blue color to a selected option but never unapply it when selected class is removed. The blue colors are only reset when the page is reloaded. Notice, that with this code we specify exactly what needs to be done and how, step by step.\n\nConclusion\n\nEach programming paradigm brings its advantages to the table.\n\nCSS (declarative)\n\nconcise\n\nwe, as programmers, don't control how the CSS core does what we need. This gives the CSS core developers an opportunity to change the CSS selector implementation at any time. Why would the CSS core need to be changed? Perhaps, the CSS developers found a faster way to apply properties.\n\nJavaScript (imperative)\n\ncustomization. We control all aspects of how our code accomplishes the goal.\n\ngood for solving wide variety of problems\n\nI found it easier to distinguish between declarative and imperative based upon idempotent and commutative. Use the references to know about them.\n\nCheckout this simplified version to know about idempotent.\n\nThen I bring in the definition of \"WHAT\" & \"HOW\" to understand what \"WHAT\" & \"HOW\" actually mean. In declarative, you connect one data with another by defining a relationship between them. You don't mention how that relationship should be achieved rather \"WHAT\" that relationship is. Through a relationship you describe \"WHAT\" your output data looks like rather than \"HOW\" to achieve this output data.\n\nStart drawing some diagrams in our head, draw some dots (data) and connect them with lines (relationship). Draw in all possible ways one to many, many to one & one to one. Give arrows to these lines, like this <-----------. All arrows should be facing left because all datas that a particular data is based upon must be calculated first and then move left to calculate that particular data.\n\nIf data a is based upon data b, data c and data d which in turn might be based upon on some other datas. Then b, c and d should be calculated first and only then a will be calculated. So a is on the left side of line and all others on the right. There will be 3 lines reaching a one from each of b, c and d.\n\nThis diagram has some properties:\n\nNO data will violate the relationship it has with all other data\n\ncontrol flow or the order doesn't matter, of course b, c and d should be calculated before a but there is no preference between b, c and d i.e. it doesn't matter which one of these 3 is calculated first (commutative)\n\na is only based upon b, c and d and no one else. Hence, it doesn't matter how many times the relationship operation that calculates a using b, c and d is executed, same a should be achieved (idempotent). a is the end result of the relationship operation here. Basically, everyone who is affecting a should have a line pointing to a.\n\nThese relationships (lines) are like functions (functions of Mathematics and NOT programming). No doubt functional programming is famous among people of academia. Pure functions (of our programming, therefore not in bold) are like functions (of Maths, therefore in bold).\n\nBy now declarative might have started to sound like PURE and IMMUTABLE (which are generally used in Functional Programming) to you, if yes GOOD and if no GREAT. Because that's not the aim here, that's something that automatically emerged out of this pattern.\n\nIf your piece of code can be converted into this diagram then it's completely declarative otherwise, it lies somewhere else on the scale.\n\nDeclarative is close to Maths.\n\nNow let's zoom in into these relationships (lines), to see what's going on inside the computer during program execution.\n\nImperative comes in. Here's where that ground-level work is done. In imperative, you mention step by step \"HOW\" it needs to be done and you know that this sequence of steps will create the requested relationship between one data (inputs b c d) and another data (output a). Here you create variables, mutate them, loop through array and all other things.\n\nImperative is close to Programming.\n\nInstead of saying a program to be declarative or imperative, I prefer to see it on a scale where on the leftmost side I have completely declarative and on the rightmost side it's completely imperative. Remember, declarative is built on top of imperative, hence any declarative thing you see is actually imperative underneath. Generally, programs are a mixture of declarative and imperative.\n\nNow, let's take these 2 examples:\n\nSecond example can be converted to the diagram like this:\n\nreduce_r map_r filter_r\n\na <--------- b <--------- c <--------- d\n\nfilter_r (relationship): c is only even numbers of d\n\nmap_r (relationship): b is all numbers multiplied by 10 of c\n\nreduce_r (relationship): a is all numbers added of b\n\nthis should look like compound function of maths: reduce_r( map_r( filter_r( d ) ) )\n\nIn declarative, the job of developer is to break the ultimate goal (a) into subgoals (b, c) which will help to reach the ultimate goal.\n\nof course under the hood of procedures map, reduce and filter is imperative code running.\n\nFood for thought: if you are required to make an assumption on map function to go from left to right to make your code work as expected, you are actually doing imperative in the name of declarative.\n\nReferences: purpleidea (James), www.dataops.live, wiki.c2.com\n\nFrom my understanding, both terms have roots in philosophy, there are declarative and imperative kinds of knowledge. Declarative knowledge are assertions of truth, statements of fact like math axioms. It tells you something. Imperative, or procedural knowledge, tells you step by step how to arrive at something. That's what the definition of an algorithm essentially is. If you would, compare a computer programming language with the English language. Declarative sentences state something. A boring example, but here's a declarative way of displaying whether two numbers are equal to each other, in Java:\n\npublic static void main(String[] args) { System.out.print(\"4 = 4.\"); }\n\nImperative sentences in English, on the other hand, give a command or make some sort of request. Imperative programming, then, is just a list of commands (do this, do that). Here's an imperative way of displaying whether two numbers are equal to each other or not while accepting user input, in Java:\n\nprivate static Scanner input; public static void main(String[] args) { input = new Scanner(System.in); System.out.println(); System.out.print(\"Enter an integer value for x: \"); int x = input.nextInt(); System.out.print(\"Enter an integer value for y: \"); int y = input.nextInt(); System.out.println(); System.out.printf(\"%d == %d? %s\\n\", x, y, x == y); }\n\nEssentially, declarative knowledge skips over certain elements to form a layer of abstraction over those elements. Declarative programming does the same.\n\ndeclarative program is just a data for its some more-or-less \"universal\" imperative implementation/vm.\n\npluses: specifying just a data, in some hardcoded (and checked) format, is simpler and less error-prone than specifying variant of some imperative algorithm directly. some complex specifications just cant be written directly, only in some DSL form. best and freq used in DSLs data structures is sets and tables. because you not have dependencies between elements/rows. and when you havent dependencies you have freedom to modify and ease of support. (compare for example modules with classes - with modules you happy and with classes you have fragile base class problem) all goods of declarativeness and DSL follows immediately from benefits of that data structures (tables and sets). another plus - you can change implementation of declarative language vm, if DSL is more-or-less abstract (well designed). make parallel implementation, for example. or port it to other os etc. all good specifed modular isolating interfaces or protocols gives you such freedom and easyness of support.\n\nminuses: you guess right. generic (and parameterized by DSL) imperative algorithm/vm implementation may be slower and/or memory hungry than specific one. in some cases. if that cases is rare - just forget about it, let it be slow. if it's frequient - you always can extend your DSL/vm for that case. somewhere slowing down all other cases, sure...\n\nP.S. Frameworks is half-way between DSL and imperative. and as all halfway solutions ... they combines deficiences, not benefits. they not so safe AND not so fast :) look at jack-of-all-trades haskell - it's halfway between strong simple ML and flexible metaprog Prolog and... what a monster it is. you can look at Prolog as a Haskell with boolean-only functions/predicates. and how simple its flexibility is against Haskell...\n\nThe Simplest and Most Reliable Definition\n\nDeclarative is when declarations are complete, and additional external control is unnecessary.\n\nconst message = \"Hello World.\"; // Complete declaration\n\n<h1>Hello World</h1> <!-- Complete declaration -->\n\nImperative is code that commands additional behavior from outside of declarations (see the general definition of imperative).\n\nlet message = 'Hello'; // Incomplete declaration // ... message += ' World.'; // Defining more of `message` outside of its declaration\n\n<h1 id=\"message\">Hello</h1> <!-- Incomplete declaration -->\n\ndocument.querySelector('#message').innerHTML += ' World.'; // Defining more of `#message` outside of its declaration\n\nWhat vs how sort of gets at it, but it seems like a confusing and incomplete distinction to me. You can abstract imperative code into a single high-level command, and it's still imperative (examples below). Declarative code can also include lots of details that show \"how\" something is structured, but it's still declarative. Imagine a long, detailed block of JSX markup, containing no commands at all.\n\nExamples from Other Answers\n\nhttps://stackoverflow.com/a/1784702/4906280\n\nList<int> collection = new List<int> { 1, 2, 3, 4, 5 };\n\nWith imperative programming, we'd step through this, and decide what we want:\n\nList<int> results = new List<int>(); foreach(var num in collection) { if (num % 2 != 0) results.Add(num); }\n\nNotice that the declarative example is just a single declaration. Yes, the 2nd example involves stepping through stuff, but it also has an incomplete declaration and a command to Add to that declaration. The imperative statement is what makes the code imperative.\n\nyou write code that describes what you want, but not necessarily how to get it (declare your desired results, but not the step-by-step)\n\nEven if you abstracted the step-by-step code away, you would still be left with an incomplete declaration and an imperative modification of it:\n\nList<int> results = new List<int>(); AddCollectionToList(collection, results);\n\nThis is still imperative, even though it includes no step-by-step code.\n\nhttps://stackoverflow.com/a/1784687/4906280\n\n# Declarative small_nums = [x for x in range(20) if x < 5] # Imperative small_nums = [] for i in range(20): if i < 5: small_nums.append(i)\n\nAgain, the declarative example is just a single, complete declaration, and the imperative example has an incomplete declaration small_nums = [] and an imperative statement/command modifying it small_nums.append(i). And the imperative modification can be abstracted again, and it's still imperative:\n\nsmall_nums = [] add_small_nums(small_nums)\n\nAgain, this is still imperative, despite having almost no \"implementation details\".\n\nhttps://stackoverflow.com/a/17403998/4906280\n\nThis is my favorite answer, but still could be simplified.\n\nDeclarative programming is a programming paradigm that expresses the logic of a computation(What do) without describing its control flow(How do).\n\nThe key word here is control. Since the computer must obey the code, commanding and controlling are the same thing. The \"flow\" part doesn't matter. Any code that controls something away from its declaration is imperative, whether it's in a sequence of such other commands or not.\n\nImperative programming : is a programming paradigm that describes computation in terms of statements that change a program state. The imperative programs can be dually viewed as programming commands or mathematical assertions.\n\nAlso very good.\n\nthe imperative approach gives you full control over the implementation details.\n\nAgain, it doesn't have to be this way, and I don't believe there is any reason you couldn't have full control within a single, complete declaration, given the language allows it.\n\nhttps://stackoverflow.com/a/39561818/4906280\n\nFor part of the program to be more declarative, other parts must provide the abstraction to hide the implementation details\n\nIs this a necessary fact of every possible programming language?\n\n// JavaScript example // Least declarative const bestProducts = []; for(let i = 0; i < products.length; i++) { let product = products[i]; if (product.rating >= 5 && product.price < 100) { bestProducts.push(product); } } // More declarative const bestProducts = products.filter(function(product) { return product.rating >= 5 && product.price < 100; }); // Most declarative, implementation details are hidden in a function const bestProducts = getBestProducts();\n\nThe first example is imperative. The 2nd and 3rd examples are equally declarative, because they are each complete declarations. One is just more abstracted than the other. Declarative does not mean abstract.\n\nP.S. the extreme of declarative programming is to invent new domain specific languages (DSL)\n\nA DSL does not guarantee declarative code. You can use a DLS to express imperative relationships between code. He mentions SQL as an example of this, and in another answer you'll find someone correctly saying that it's the SELECT statements specifically that are declarative. UPDATE statements, for example, are modifying data without a central declaration. UPDATE is literally a command (= imperative; again, see the definition of imperative).\n\nYou've asked for an example in C#, which is a highly \"imperative\" language. Imperative and declarative fall on two ends of a spectrum of \"what\" vs. \"how\", and they are often blended. On the declarative end, consider pure HTML or CSS (without scripts). An HTML doc like <body><p>Hello World</p></body> contains no imperative commands at all; in this case it really does just declare \"what\" the result should be. On the imperative end, consider a C statement like void main(){ printf(\"Hello World\\n\");}. This is purely \"imperative,\" formed as a list of commands telling the computer \"how\" to do the job.\n\nConsider an SQL statement like SELECT * FROM customers WHERE balance > 0;. This falls somewhere in the middle. It has a declarative aspect in the FROM and WHERE clauses, describing \"what\" the result should be. But it is clearly structured as an imperative statement starting off with a SELECT command.\n\nIf you ask the question in the context of a highly imperative programming language you're usually going to get an example of \"functional\" programming, where some basic imperative operations are wrapped up so they can be used in a more declarative style. The usual example is a \"for-loop\" function used to perform common operations on an array or object. You get something like let evenNums = myNums.where(number => number % 2 == 0); This is essentially an imperative statement instructing the computer to create a variable and assign a value to it, but it invokes a \"where\" function that gives it a declarative feel. It does include a truncated function call, but the mechanics of the for-loop are swapped out for the \"where.\" It has to be placed closer to the imperative end of the scale than the SQL example, but in the context of an imperative language it's still relatively declarative. This is why it's hard to get a clear-cut answer.\n\nNote that the \"where\" function and all the other built-in \"functional\" methods for handling arrays and objects are basically wrappers around a for-loop. They just have more declarative-style names and signatures that result in clearer code (usually). Whenever you write a function, and you're encapsulating a bunch of imperative statements, give your functions declarative-style names that describe \"what\" they return--you can be a declarative-programming god too.\n\nI think this concept is often over-complicated.\n\nDeclarative Programming = calling a function\n\nImperative Programming = defining a function\n\nReally, that's what it is. In short and simple terms, declarative programming is calling some abstracted pre-defined function that someone else programmed.\n\nTake a look at the top-rated answer:\n\n// Declarative: You call Where() var results = collection.Where(num => num % 2 != 0); // Imperative: You implement Where() List<int> results = new List<int>(); foreach(var num in collection) { if (num % 2 != 0) results.Add(num); }\n\nOr another one:\n\nvar numbers = [1,2,3,4,5] var doubled = [] // Imperative: You implement map() for(var i = 0; i < numbers.length; i++) { var newNumber = numbers[i] * 2 doubled.push(newNumber) } console.log(doubled) //=> [2,4,6,8,10]\n\nvar numbers = [1,2,3,4,5] // Declarative: You call map() var doubled = numbers.map(function(n) { return n * 2 }) console.log(doubled) //=> [2,4,6,8,10]\n\nvar numbers = [1,2,3,4,5] var total = 0 // Imperative: You implement reduce() for(var i = 0; i < numbers.length; i++) { total += numbers[i] } console.log(total) //=> 15\n\nvar numbers = [1,2,3,4,5] // Declarative: You call reduce() var total = numbers.reduce(function(sum, n) { return sum + n }); console.log(total) //=> 15\n\nIf you want to get more deep, there is a spectrum:\n\nThe more pre-defined functions you use, the more \"declarative\" it is.\n\nThe less functions you use, the more \"imperative\" it is.\n\nTake another example that was given:\n\n// Least declarative: Mostly implemented const bestProducts = []; for(let i = 0; i < products.length; i++) { let product = products[i]; if (product.rating >= 5 && product.price < 100) { bestProducts.push(product); } } // More declarative: Function called, less implementation const bestProducts = products.filter(function(product) { return product.rating >= 5 && product.price < 100; }); // Most declarative: Function called, no implementation const bestProducts = getBestProducts();"
    }
}