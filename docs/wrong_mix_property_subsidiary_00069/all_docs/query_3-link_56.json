{
    "id": "wrong_mix_property_subsidiary_00069_3",
    "rank": 56,
    "data": {
        "url": "http://www.mbsetraining.com/2020/08/ibm-rational-rhapsody-tip-82-modelling.html",
        "read_more_link": "",
        "language": "en",
        "title": "IBM Rhapsody UML/SysML training and automation helper consultancy: IBM Rational Rhapsody Tip #82",
        "top_image": "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_vKf4PXO4suKNUAq_E7XBD0FQCKwESUi1unf5pZrYkY_3GyPmWjlKIH5Rz4-kZY1PMdRdqNZdLQL-s4aNsApvIKJzpiXGlRV6fb5V3ywYtrgRop=w1200-h630-n-k-no-nu",
        "meta_img": "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_vKf4PXO4suKNUAq_E7XBD0FQCKwESUi1unf5pZrYkY_3GyPmWjlKIH5Rz4-kZY1PMdRdqNZdLQL-s4aNsApvIKJzpiXGlRV6fb5V3ywYtrgRop=w1200-h630-n-k-no-nu",
        "images": [
            "https://resources.blogblog.com/img/icon18_edit_allbkg.gif",
            "https://blogger.googleusercontent.com/img/a/AVvXsEjcMWfKTAlgvIXAJ_1wdcXDp54L9MhLqyExBanWu24G1MMs__yCDW0unHwpTsNUIru5urnJRD9MqL6kGyHpVa-lqWMUSYjgFByehll1AvWkfij78hMakkG2mFuFkyqiNTDTR72j4ylemvnPtf-8LzeL0DuZO8CJRGpvuSMFClRDEw4SW0kVTeC03sEx=s265",
            "http://3.bp.blogspot.com/-3fDW4C7HP50/VpASRWx7kkI/AAAAAAAAHm8/cRjwraNhUJk/s1600-r/OMG-SysML-USE.png",
            "https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEjek5JAWX28ymz1GL60X_VTEULhPtl9KypyXkvEt_08Oib-JQr_n8FMZRy0XPUZW6Hml-NdElefgFRmqMdEjNYSCXay9Tq-NUz0VdIZ-ejznib-eeADc4WGZho53p7f2qdP-uhMbhGtKP4/w72-h72-p-k-no-nu/image1.png",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_uPY8lgbgCqdpaCGOGo9FIXRdZVRWQM8oJBtp76Q3uX7FC-El55tsVhIr3OOUxMyBdF9KUY8I-M1-94T552SBNudJhfDyVf27DjLA=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_sfjI72F1x8UL6cpbEarHa912EYr_1lhQ_zG7W68qqRL_zYsm4y46VkfAomcevKTQl2-v0Yaw4Is5VOMLoCBKsc8PNQJXD9gpMv3Q=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_tLe-EPhayNI7iCrA8I_JYCSnd9BGxfe4fIMu3rfKrbrrm7ZO4j7A4a8coAr8lcrTrnZvF-QRRCVi6vb188SW0qw5VBsb8HU-H8ANs=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_ti-ulxNLyO-KuYi4-T6GMRdTBzDDy4Aw1ojluIHDqPXtNMBQo4CCsvTZSZI4CO7z3eK0N2DW1cJC-zjj6R2HpqGEv5QThDkqVzKw=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_sCpLWESYpWGJGv4ZmIhkCdyvtbsriCnUfGmBaB4xe1O-4HbwGPvEMfHIb4MMaXuQUpy6nzxyCksC7QoCB43RzlvQsBoRrgLEl7r5Q=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_uP6OVM2g-qtEmJsZWMDoDxiYU3fLO49shyqEQyL0aDF2_sgk42g55UNtMnldnzitFaHvY47XY2d3ldsuQnWZBcBKlmp-uNRi6lEA0=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_s4k20O1Kfh5rGSeiCIsjYc-j4N1yevhs1Mt7ospa9dPp9WoDTeYIR_OMJ_gAskHwPIbyB8iebIRhgP9FAjLHJsAfel5k-TmKp3Rw=w72-h72-n-k-no-nu",
            "https://lh3.googleusercontent.com/blogger_img_proxy/AEn0k_tKHBpnb3BcuQdEE2eOf76kVQBXH_lZcdgInkqIl0tpYCW4U2vPcy-ZHJql8tIiNzraAZ_xG0A_ggHYnuq45YOGaa8MAuPuczH6Gtw=w72-h72-n-k-no-nu"
        ],
        "movies": [
            "https://www.youtube.com/embed/YrI0bL0bWwY"
        ],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "This is one of my more involved and narrated videos. It covers the topic of domain specific profiling with IBM Rational Rhapsody. In it, I g...",
        "meta_lang": "en",
        "meta_favicon": "http://www.mbsetraining.com/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "http://www.mbsetraining.com/2020/08/ibm-rational-rhapsody-tip-82-modelling.html",
        "text": "This is one of my more involved and narrated videos. It covers the topic of domain specific profiling with IBM Rational Rhapsody. In it, I give a glimpse of an example profile for automotive model-based systems engineering, showing how it's possible to add new term element types and diagrams to make SysML/UML more easily consumable when following a chosen method. Domain specific profiling in Rhapsody is controlled via properties on stereotypes. At the end I also show one of the more advanced techniques I've moved to is to build and maintain such a profile using model-based techniques, i.e., drawing a class model of the domain specific meta-model that represents the element types (also known as meta-modeling! ;-).\n\nHere's the transcipt:\n\nIn this video I thought I’d give a short insight into what a domain specific profile is. Some of the benefits… and how I go about this in Rhapsody now, based on my experience.\n\nFirstly, a profile is type of package that extends the UML language. Profiles contain stereotypes to represent new concepts and meanings. Profiles can also add tags and, in the case of Rhapsody can convey properties that change the user interface.\n\nSysML, for example, is a profile that extends UML, and it contains a stereotype called a Block. Whilst a block in SysML is a general-purpose element for architectural specification, within any given model there likely to be different types of blocks. We could further classify or replace the idea of a Block using stereotypes of our own.\n\nFor example, here I have the prototype for a profile I’m dubbing as my 'Autobahn Profile' as it’s designed to speed up the journey into productive model-based systems engineering, and builds on my automotive sector experience. In this profile some Blocks may represent systems while others may represent subsystems or functionality performed by subsystems.\n\nHaving created these stereotypes I can use them in the browser. Let’s create a logical system package with a logical system element inside it. Here the browser is representing these new term stereotyped elements as part of the tools’ modeling language, including given them their own categories and icons in the browser.\n\nStereotypes are a bit like fancy dress. We can stereotype base UML elements to give them new meaning.\n\nWith Rhapsody, unlike some of its competitors such as Cameo, the extension mechanism for writing a domain specific profile does not require you to write any code. It is based instead on static values set in profile and stereotype properties. The use of New terms like this Logical System stereotype I’ve added here, can be conveyed by the profile in such a way that they change the Rhapsody menus.\n\nNew term stereotypes can also be applied to diagrams. Here’s a stereotype I’ve used to create my own Architecture Definition Diagram type. The drawing toolbar for the diagram has be customised using properties on the stereotype. This enables me to add new classifications of element types to the drawing toolbar, but also subset default element types so that users are not burdened with unnecessary choices.\n\nLet me quickly change this diagram back to the standard Object Model Diagram type. Here you can see if has options such as Objects, Classes, Associations, and Links. By applying the new term stereotype, I can specialise and simplify the available palette of tools. I’ve essentially created my own domain specific Block Definition Diagram type, albeit that I’ve further classifiers such as logical systems, logical subsystems and subsystem functions.\n\nThis makes it clearer and simpler for a non-SysML expert to draw a necessary structure, as they can work closely with more familiar terms.\n\nA system comprises of subsystems, and subsystems own subsystem functions. By using this domain specific profile, I’ve made a choice about how to adapt the generic SysML language up front rather than leaving it to end users. This reduces the burden placed on end users to choose how to represent their concepts.\n\nUsing properties on the elements, I have also applied some more direct constraints. For example, subsystem functions can be used by subsystems and by not systems.\n\nThis makes it possible to achieve a more consistent outcome with less training. Such customisation's become valuable at scale when you start to deploy MBSE in a mass- user environment where black belt SysML experts are not 10 to a penny, rather everyone has a job to do and a limited time to do it.\n\nIn building a number of these profiles for different clients, one of techniques I’ve centred on is the use of different package types to simplify menus to role-based work. Here, for example, you can see that there are a number of different package types I’ve made available on the right-click menu for the project.\n\nFor example, I quite like the idea of a use case package, where the right-click menus are simplified for just elements needed for use case analysis. As I want use case analysis to be by a domain specialist, I’ve removed SysML types they don’t need like Blocks, Parts, and Ports. In this instance I haven’t actually added any new concepts. I’ve just simplified the menu so that the users working on these packages can focus on the job at hand.\n\nI quite like this idea of sub-setting packages in this way. I also like the flatter, ordered structure that new term package types can give, so users do not have to drill too deep to find the area of the model they’re working on.\n\nThat’s just a very short introduction into what domain specific profiling is and some of the benefits such as easing adoption by domain specialists, improving the consistency of models, and simplifying training by removing the need for all end users to learn the full breadth of the UML and SysML languages.\n\nI wanted to finish off by just giving you a glimpse of how I now approach building profiles like these for customers. As you can see here, the profile is specified using properties which formulate how the menu should be structured and what the context menu of an element should allow.\n\nFor small profiles these can be doctored by hand. What I found through experience is that manually keeping all these properties in synch becomes exponentially harder as you progressively add new terms, especially as names of things often change during the forging of a profile.\n\nTo solve this issue, I’ve created a meta-modeling profile and plugin to apply a model-based approach to building up the profile properties. This enables me to draw the relationships I want between meta-types and get the code to automatically update the corresponding property values. This makes it much more fun. For example adding a composition relation will allow a nesting in the browser and using an aggregation relation will add the element type to the drawing toolbar.\n\nTo illustrate this, let’s look at an example. Firstly, I’m going to add some new icons to the profile’s Rhapsody project. These will be used to represent a new type of package called an Actor Package. Actor Packages will perform the role of housing Actors shared by other packages, and will have their own icons to distinguish them in the browser.\n\nI’ll now add a stereotype to represent the Actor Package type. I’ll make this a New Term stereotype applicable to the base UML Package type. Checking the New Term box tells Rhapsody that it needs add Actor Packages as a category in the browser, and also means that some properties applied to the stereotype will come into play.\n\nLet’s use these properties to specify a new icon for Actor Package elements in the browser. I’ll also set this separate property that specifies which icon to use when displaying a category grouping elements of this type.\n\nIn general it’s better for stereotypes to not have spaces in their name as it makes managing the properties for them easier, so I’ve not used spaces in the browser, and will give the Actor Package a human readable name via its property instead.\n\nI’ll also give it a category name for use in the Rhapsody browser. Using a number here is a trick that I use particular for new term packages, as it acts to order to the package types in the root of the Rhapsody browser, making them easy to find. This will become more obvious in a minute.\n\nI’m now going to switch to the metamodel that I’m using to maintain the menu related properties. This is declared separate from the profile, using a class model, hence doesn’t need to be deployed to end users. As I mentioned, this metamodeling-based approach enables me to build the menu structures graphically. As I can’t draw class relationships between stereotypes I will use a stereotyped class in the model to represent the stereotype instead.\n\nTo begin with I need to add a class to represent the Actor Package. I’m using a stereotype in my metamodel profile to represent that this is a new term. I’ve draw a dependency to bind this class to the stereotype I want the properties to be updated for.\n\nA number of classes are already specified in the metamodel for this profile. I want Actor Packages to be available on the right-click menu for the project, so I’m going to use a Composition relation to specify this. I’ll drag on the class representing the AutoMBSEProfile and draw the composition. I also want actor packages to be in the right-click menu for elements typed as use cases packages, so I’ll drag that concept in from the browser and draw another composition relationship.\n\nFinally, I’m going to use a stereotype to say Actor Packages it should be placed in the AutoMBSE Element submenu. At this point I can run the plugin code that sets or updates the properties based on the metamodel I’ve specified here.\n\nThis can take a minute or so but is a lot quicker than trying to find all the necessary properties and update them by hand, especially when the number of terms becomes large, or you want to tweak or change their names. As you can see here, the meta-model plugin displays the aggregates properties for the new term element types in a simple table.\n\nThis allows me to spot mistakes. For example, my new actor package is missing some element types. I forgot to say that I want Actor Packages to contain actors, for example. To do this, I’ll drag in the UML Actor type from the base metamodel package. I can then draw a composition relationship to say that Actor packages can contain them.\n\nThere are also a number of types that I want all Packages to have such as Comments, Tags, Dependencies and Hyperlinks. Rather than draw these individually I’m going to specify these base relationships using a Generalisation relationship to a base Package type. My plugin code will look at the relations of the inherited metatype when forming the property values.\n\nIf things start to get complicated I can get Rhapsody to re-lay out this metamodel diagram with a hierarchical style.\n\nOnce I’m happy the desired relations are in place, I can then rerun the plugin to set the necessary properties on the stereotypes. This will include the property that determines the right-click menu structure. Again, this can take a while but is a lot easier to do with the profile doing the work for me.\n\nNow we can see Actor Packages are on the right-click menu. By controlling the menus in this way, it’s easier to direct a team to produce more consistent output. Consistency about how projects or parts of projects are developed can also be valuable when chaining methods together, for example, taking the outcome of use case analysis and consuming them in further downstream analysis such as building an interaction model with executable state machines.\n\nWe can think of the team developing the model as a system, where different parts of the system work on different packages and hand off or consume artefacts of others.\n\nPackages are also the default granularity for configuration management of Rhapsody models, and can be shared by reference between different projects.\n\nThis concludes the demo for now. The profile I’ve shown here is a prototype of my Autobaun profile, so if you’re interested to know more then let me know and I can maybe show you a few more details.\n\nThat’s it for now.\n\nMy name is Fraser Chadburn and I’m a specialist in model-based engineering with Rhapsody. As well as developing and delivering tool-based training for Rhapsody and IBM products, I specialise in providing consulting for clients to achieve higher value by extracting the best from their tools. If you do have any questions then feel free to drop us an email."
    }
}