{
    "id": "wrong_mix_property_foundationPlace_00064_1",
    "rank": 21,
    "data": {
        "url": "https://github.com/JetBrains/jdk-sa-jdwp/blob/master/core/src/main/java/com/jetbrains/sa/jdwp/JDWP.java",
        "read_more_link": "",
        "language": "en",
        "title": "jdk-sa-jdwp/core/src/main/java/com/jetbrains/sa/jdwp/JDWP.java at master · JetBrains/jdk-sa-jdwp",
        "top_image": "https://opengraph.githubassets.com/cc01605fd0e15f3ebe0649aa92c1814276f72c9eae7f8f6e3fc0c1cae03dec5d/JetBrains/jdk-sa-jdwp",
        "meta_img": "https://opengraph.githubassets.com/cc01605fd0e15f3ebe0649aa92c1814276f72c9eae7f8f6e3fc0c1cae03dec5d/JetBrains/jdk-sa-jdwp",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Java serviceability agent to jdwp adapter. Contribute to JetBrains/jdk-sa-jdwp development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/JetBrains/jdk-sa-jdwp/blob/master/core/src/main/java/com/jetbrains/sa/jdwp/JDWP.java",
        "text": "/*\n\n* Copyright (C) 2018 JetBrains s.r.o.\n\n*\n\n* This program is free software; you can redistribute and/or modify it under\n\n* the terms of the GNU General Public License v2 with Classpath Exception.\n\n* The text of the license is available in the file LICENSE.TXT.\n\n*\n\n* This program is distributed in the hope that it will be useful, but WITHOUT\n\n* ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n\n* FITNESS FOR A PARTICULAR PURPOSE. See LICENSE.TXT for more details.\n\n*\n\n* You may contact JetBrains s.r.o. at Na Hřebenech II 1718/10, 140 00 Prague,\n\n* Czech Republic or at legal@jetbrains.com.\n\n*/\n\npackage com.jetbrains.sa.jdwp;\n\nimport com.jetbrains.sa.jdi.*;\n\nimport com.sun.jdi.AbsentInformationException;\n\nimport com.sun.jdi.ClassNotLoadedException;\n\nimport com.sun.jdi.IncompatibleThreadStateException;\n\nimport com.sun.jdi.VMDisconnectedException;\n\nimport java.util.ArrayList;\n\nimport java.util.Collections;\n\nimport java.util.List;\n\n/**\n\n* Java(tm) Debug Wire Protocol\n\n*/\n\n@SuppressWarnings({\"unused\", \"DanglingJavadoc\"})\n\npublic class JDWP {\n\nstatic class VirtualMachine {\n\nstatic final int COMMAND_SET = 1;\n\nprivate VirtualMachine() {} // hide constructor\n\n/**\n\n* Returns the JDWP version implemented by the target VM.\n\n* The version string format is implementation dependent.\n\n*/\n\nstatic class Version implements Command {\n\nstatic final int COMMAND = 1;\n\n/**\n\n* Text information on the VM version\n\n*/\n\n//final String description;\n\n/**\n\n* Major JDWP Version number\n\n*/\n\n//final int jdwpMajor;\n\n/**\n\n* Minor JDWP Version number\n\n*/\n\n//final int jdwpMinor;\n\n/**\n\n* Target VM JRE version, as in the java.version property\n\n*/\n\n//final String vmVersion;\n\n/**\n\n* Target VM name, as in the java.vm.name property\n\n*/\n\n//final String vmName;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n//description = answer.readString();\n\nanswer.writeString(vm.vm.description());\n\n//jdwpMajor = answer.readInt();\n\nanswer.writeInt(vm.vm.jdwpMajor());\n\n//jdwpMinor = answer.readInt();\n\nanswer.writeInt(vm.vm.jdwpMinor());\n\n//vmVersion = answer.readString();\n\nanswer.writeString(vm.vm.version());\n\n//vmName = answer.readString();\n\nanswer.writeString(vm.vm.name());\n\n}\n\n}\n\n/**\n\n* Returns reference types for all the classes loaded by the target VM\n\n* which match the given signature.\n\n* Multple reference types will be returned if two or more class\n\n* loaders have loaded a class of the same name.\n\n* The search is confined to loaded classes only; no attempt is made\n\n* to load a class of the given signature.\n\n*/\n\nstatic class ClassesBySignature implements Command {\n\nstatic final int COMMAND = 2;\n\nstatic class ClassInfo {\n\n/**\n\n* <a href=\"#JDWP_TypeTag\">Kind</a>\n\n* of following reference type.\n\n*/\n\n//final byte refTypeTag;\n\n/**\n\n* Matching loaded reference type\n\n*/\n\n//final long typeID;\n\n/**\n\n* The current class\n\n* <a href=\"#JDWP_ClassStatus\">status.</a>\n\n*/\n\n//final int status;\n\npublic static void write(ReferenceTypeImpl referenceType, VirtualMachineImpl vm, PacketStream answer) {\n\n//refTypeTag = answer.readByte();\n\nanswer.writeByte(referenceType.tag());\n\n//typeID = answer.readClassRef();\n\nanswer.writeClassRef(referenceType.uniqueID());\n\n//status = answer.readInt();\n\nanswer.writeInt(referenceType.ref().getClassStatus());\n\n}\n\n}\n\n/**\n\n* Number of reference types that follow.\n\n*/\n\n//final ClassInfo[] classes;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nString signature = command.readString();\n\nList<ReferenceTypeImpl> referenceTypes = vm.vm.findReferenceTypes(signature);\n\nanswer.writeInt(referenceTypes.size());\n\nfor (ReferenceTypeImpl referenceType : referenceTypes) {\n\nClassInfo.write(referenceType, vm, answer);\n\n}\n\n// //int classesCount = answer.readInt();\n\n//classes = new ClassInfo[classesCount];\n\n//for (int i = 0; i < classesCount; i++) {;\n\n//classes[i] = new ClassInfo(vm, ps);\n\n//}\n\n}\n\n}\n\n/**\n\n* Returns reference types for all classes currently loaded by the\n\n* target VM.\n\n*/\n\nstatic class AllClasses implements Command {\n\nstatic final int COMMAND = 3;\n\nstatic class ClassInfo {\n\n/**\n\n* <a href=\"#JDWP_TypeTag\">Kind</a>\n\n* of following reference type.\n\n*/\n\n//final byte refTypeTag;\n\n/**\n\n* Loaded reference type\n\n*/\n\n//final long typeID;\n\n/**\n\n* The JNI signature of the loaded reference type\n\n*/\n\n//final String signature;\n\n/**\n\n* The current class\n\n* <a href=\"#JDWP_ClassStatus\">status.</a>\n\n*/\n\n//final int status;\n\npublic static void write(ReferenceTypeImpl referenceType, VirtualMachineImpl vm, PacketStream answer) {\n\n//refTypeTag = answer.readByte();\n\nanswer.writeByte(referenceType.tag());\n\n//typeID = answer.readClassRef();\n\nanswer.writeClassRef(referenceType.uniqueID());\n\n//signature = answer.readString();\n\nanswer.writeString(referenceType.signature());\n\n//status = answer.readInt();\n\nanswer.writeInt(referenceType.ref().getClassStatus());\n\n}\n\n}\n\n/**\n\n* Number of reference types that follow.\n\n*/\n\n//final ClassInfo[] classes;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nList<ReferenceTypeImpl> referenceTypes = vm.vm.allClasses();\n\nanswer.writeInt(referenceTypes.size());\n\nfor (ReferenceTypeImpl referenceType : referenceTypes) {\n\nClassInfo.write(referenceType, vm, answer);\n\n}\n\n// //int classesCount = answer.readInt();\n\n//classes = new ClassInfo[classesCount];\n\n//for (int i = 0; i < classesCount; i++) {;\n\n//classes[i] = new ClassInfo(vm, ps);\n\n//}\n\n}\n\n}\n\n/**\n\n* Returns all threads currently running in the target VM .\n\n* The returned list contains threads created through\n\n* java.lang.Thread, all native threads attached to\n\n* the target VM through JNI, and system threads created\n\n* by the target VM. Threads that have not yet been started\n\n* and threads that have completed their execution are not\n\n* included in the returned list.\n\n*/\n\nstatic class AllThreads implements Command {\n\nstatic final int COMMAND = 4;\n\n/**\n\n* Number of threads that follow.\n\n*/\n\n//final ThreadReferenceImpl[] threads;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nList<ThreadReferenceImpl> allThreads = vm.vm.allThreads();\n\n// //int threadsCount = answer.readInt();\n\nanswer.writeInt(allThreads.size());\n\nfor (ThreadReferenceImpl thread : allThreads) {\n\nanswer.writeObjectRef(thread.uniqueID());\n\n}\n\n//threads = new ThreadReferenceImpl[threadsCount];\n\n//for (int i = 0; i < threadsCount; i++) {;\n\n//threads[i] = answer.readThreadReference();\n\n//}\n\n}\n\n}\n\n/**\n\n* Returns all thread groups that do not have a parent. This command\n\n* may be used as the first step in building a tree (or trees) of the\n\n* existing thread grouanswer.\n\n*/\n\nstatic class TopLevelThreadGroups implements Command {\n\nstatic final int COMMAND = 5;\n\n/**\n\n* Number of thread groups that follow.\n\n*/\n\n//final ThreadGroupReferenceImpl[] groups;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nList<ThreadGroupReferenceImpl> list = vm.vm.topLevelThreadGroups();\n\n// //int groupsCount = answer.readInt();\n\nanswer.writeInt(list.size());\n\nfor (ThreadGroupReferenceImpl group : list) {\n\nanswer.writeObjectRef(group.uniqueID());\n\n}\n\n//groups = new ThreadGroupReferenceImpl[groupsCount];\n\n//for (int i = 0; i < groupsCount; i++) {;\n\n//groups[i] = answer.readThreadGroupReference();\n\n//}\n\n}\n\n}\n\n/**\n\n* Invalidates this virtual machine mirror.\n\n* The communication channel to the target VM is closed, and\n\n* the target VM prepares to accept another subsequent connection\n\n* from this debugger or another debugger, including the\n\n* following tasks:\n\n* <ul>\n\n* <li>All event requests are cancelled.\n\n* <li>All threads suspended by the thread-level\n\n* <a href=\"#JDWP_ThreadReference_Resume\">resume</a> command\n\n* or the VM-level\n\n* <a href=\"#JDWP_VirtualMachine_Resume\">resume</a> command\n\n* are resumed as many times as necessary for them to run.\n\n* <li>Garbage collection is re-enabled in all cases where it was\n\n* <a href=\"#JDWP_ObjectReference_DisableCollection\">disabled</a>\n\n* </ul>\n\n* Any current method invocations executing in the target VM\n\n* are continued after the disconnection. Upon completion of any such\n\n* method invocation, the invoking thread continues from the\n\n* location where it was originally stopped.\n\n* <p>\n\n* Resources originating in\n\n* this VirtualMachine (ObjectReferences, ReferenceTypes, etc.)\n\n* will become invalid.\n\n*/\n\nstatic class Dispose implements Command {\n\nstatic final int COMMAND = 6;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nthrow new VMDisconnectedException();\n\n}\n\n}\n\n/**\n\n* Returns the sizes of variably-sized data types in the target VM.\n\n* The returned values indicate the number of bytes used by the\n\n* identifiers in command and reply packets.\n\n*/\n\nstatic class IDSizes implements Command {\n\nstatic final int COMMAND = 7;\n\n/**\n\n* fieldID size in bytes\n\n*/\n\n//final int fieldIDSize;\n\n/**\n\n* methodID size in bytes\n\n*/\n\n//final int methodIDSize;\n\n/**\n\n* objectID size in bytes\n\n*/\n\n//final int objectIDSize;\n\n/**\n\n* referenceTypeID size in bytes\n\n*/\n\n//final int referenceTypeIDSize;\n\n/**\n\n* frameID size in bytes\n\n*/\n\n//final int frameIDSize;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n//fieldIDSize = answer.readInt();\n\nanswer.writeInt(vm.sizeofFieldRef);\n\n//methodIDSize = answer.readInt();\n\nanswer.writeInt(vm.sizeofMethodRef);\n\n//objectIDSize = answer.readInt();\n\nanswer.writeInt(vm.sizeofObjectRef);\n\n//referenceTypeIDSize = answer.readInt();\n\nanswer.writeInt(vm.sizeofClassRef);\n\n//frameIDSize = answer.readInt();\n\nanswer.writeInt(vm.sizeofFrameRef);\n\n}\n\n}\n\n/**\n\n* Suspends the execution of the application running in the target\n\n* VM. All Java threads currently running will be suspended.\n\n* <p>\n\n* Unlike java.lang.Thread.suspend,\n\n* suspends of both the virtual machine and individual threads are\n\n* counted. Before a thread will run again, it must be resumed through\n\n* the <a href=\"#JDWP_VirtualMachine_Resume\">VM-level resume</a> command\n\n* or the <a href=\"#JDWP_ThreadReference_Resume\">thread-level resume</a> command\n\n* the same number of times it has been suspended.\n\n*/\n\nstatic class Suspend implements Command {\n\nstatic final int COMMAND = 8;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n}\n\n}\n\n/**\n\n* Resumes execution of the application after the suspend\n\n* command or an event has stopped it.\n\n* Suspensions of the Virtual Machine and individual threads are\n\n* counted. If a particular thread is suspended n times, it must\n\n* resumed n times before it will continue.\n\n*/\n\nstatic class Resume implements Command {\n\nstatic final int COMMAND = 9;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n}\n\n}\n\n/**\n\n* Terminates the target VM with the given exit code.\n\n* On some platforms, the exit code might be truncated, for\n\n* example, to the low order 8 bits.\n\n* All ids previously returned from the target VM become invalid.\n\n* Threads running in the VM are abruptly terminated.\n\n* A thread death exception is not thrown and\n\n* finally blocks are not run.\n\n*/\n\nstatic class Exit implements Command {\n\nstatic final int COMMAND = 10;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n}\n\n}\n\n/**\n\n* Creates a new string object in the target VM and returns\n\n* its id.\n\n*/\n\nstatic class CreateString implements Command {\n\nstatic final int COMMAND = 11;\n\n/**\n\n* Created string (instance of java.lang.String)\n\n*/\n\n//final StringReferenceImpl stringObject;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n//stringObject = answer.readStringReference();\n\n}\n\n}\n\n/**\n\n* Retrieve this VM's capabilities. The capabilities are returned\n\n* as booleans, each indicating the presence or absence of a\n\n* capability. The commands associated with each capability will\n\n* return the NOT_IMPLEMENTED error if the cabability is not\n\n* available.\n\n*/\n\nstatic class Capabilities implements Command {\n\nstatic final int COMMAND = 12;\n\n/**\n\n* Can the VM watch field modification, and therefore\n\n* can it send the Modification Watchpoint Event?\n\n*/\n\n//final boolean canWatchFieldModification;\n\n/**\n\n* Can the VM watch field access, and therefore\n\n* can it send the Access Watchpoint Event?\n\n*/\n\n//final boolean canWatchFieldAccess;\n\n/**\n\n* Can the VM get the bytecodes of a given method?\n\n*/\n\n//final boolean canGetBytecodes;\n\n/**\n\n* Can the VM determine whether a field or method is\n\n* synthetic? (that is, can the VM determine if the\n\n* method or the field was invented by the compiler?)\n\n*/\n\n//final boolean canGetSyntheticAttribute;\n\n/**\n\n* Can the VM get the owned monitors infornation for\n\n* a thread?\n\n*/\n\n//final boolean canGetOwnedMonitorInfo;\n\n/**\n\n* Can the VM get the current contended monitor of a thread?\n\n*/\n\n//final boolean canGetCurrentContendedMonitor;\n\n/**\n\n* Can the VM get the monitor information for a given object?\n\n*/\n\n//final boolean canGetMonitorInfo;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n//canWatchFieldModification = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canWatchFieldModification());\n\n//canWatchFieldAccess = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canWatchFieldAccess());\n\n//canGetBytecodes = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetBytecodes());\n\n//canGetSyntheticAttribute = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetSyntheticAttribute());\n\n//canGetOwnedMonitorInfo = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetOwnedMonitorInfo());\n\n//canGetCurrentContendedMonitor = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetCurrentContendedMonitor());\n\n//canGetMonitorInfo = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetMonitorInfo());\n\n}\n\n}\n\n/**\n\n* Retrieve the classpath and bootclasspath of the target VM.\n\n* If the classpath is not defined, returns an empty list. If the\n\n* bootclasspath is not defined returns an empty list.\n\n*/\n\nstatic class ClassPaths implements Command {\n\nstatic final int COMMAND = 13;\n\n/**\n\n* Base directory used to resolve relative\n\n* paths in either of the following lists.\n\n*/\n\n//final String baseDir;\n\n/**\n\n* Number of paths in classpath.\n\n*/\n\n//final String[] classpaths;\n\n/**\n\n* Number of paths in bootclasspath.\n\n*/\n\n//final String[] bootclasspaths;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n//baseDir = answer.readString();\n\nanswer.writeString(vm.vm.baseDirectory());\n\nList<String> classPath = vm.vm.classPath();\n\n// //int classpathsCount = answer.readInt();\n\nanswer.writeInt(classPath.size());\n\nfor (String s : classPath) {\n\nanswer.writeString(s);\n\n}\n\n//classpaths = new String[classpathsCount];\n\n//for (int i = 0; i < classpathsCount; i++) {;\n\n//classpaths[i] = answer.readString();\n\n//}\n\n// //int bootclasspathsCount = answer.readInt();\n\nList<String> bootClassPath = vm.vm.bootClassPath();\n\nanswer.writeInt(bootClassPath.size());\n\nfor (String s : bootClassPath) {\n\nanswer.writeString(s);\n\n}\n\n//bootclasspaths = new String[bootclasspathsCount];\n\n//for (int i = 0; i < bootclasspathsCount; i++) {;\n\n//bootclasspaths[i] = answer.readString();\n\n//}\n\n}\n\n}\n\n/**\n\n* Releases a list of object IDs. For each object in the list, the\n\n* following applies.\n\n* The count of references held by the back-end (the reference\n\n* count) will be decremented by refCnt.\n\n* If thereafter the reference count is less than\n\n* or equal to zero, the ID is freed.\n\n* Any back-end resources associated with the freed ID may\n\n* be freed, and if garbage collection was\n\n* disabled for the object, it will be re-enabled.\n\n* The sender of this command\n\n* promises that no further commands will be sent\n\n* referencing a freed ID.\n\n* <p>\n\n* Use of this command is not required. If it is not sent,\n\n* resources associated with each ID will be freed by the back-end\n\n* at some time after the corresponding object is garbage collected.\n\n* It is most useful to use this command to reduce the load on the\n\n* back-end if a very large number of\n\n* objects has been retrieved from the back-end (a large array,\n\n* for example) but may not be garbage collected any time soon.\n\n* <p>\n\n* IDs may be re-used by the back-end after they\n\n* have been freed with this command.\n\n* This description assumes reference counting,\n\n* a back-end may use any implementation which operates\n\n* equivalently.\n\n*/\n\nstatic class DisposeObjects implements Command {\n\nstatic final int COMMAND = 14;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n}\n\n}\n\n/**\n\n* Tells the target VM to stop sending events. Events are not discarded;\n\n* they are held until a subsequent ReleaseEvents command is sent.\n\n* This command is useful to control the number of events sent\n\n* to the debugger VM in situations where very large numbers of events\n\n* are generated.\n\n* While events are held by the debugger back-end, application\n\n* execution may be frozen by the debugger back-end to prevent\n\n* buffer overflows on the back end.\n\n* Responses to commands are never held and are not affected by this\n\n* command. If events are already being held, this command is\n\n* ignored.\n\n*/\n\nstatic class HoldEvents implements Command {\n\nstatic final int COMMAND = 15;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n}\n\n}\n\n/**\n\n* Tells the target VM to continue sending events. This command is\n\n* used to restore normal activity after a HoldEvents command. If\n\n* there is no current HoldEvents command in effect, this command is\n\n* ignored.\n\n*/\n\nstatic class ReleaseEvents implements Command {\n\nstatic final int COMMAND = 16;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n}\n\n}\n\n/**\n\n* Retrieve all of this VM's capabilities. The capabilities are returned\n\n* as booleans, each indicating the presence or absence of a\n\n* capability. The commands associated with each capability will\n\n* return the NOT_IMPLEMENTED error if the cabability is not\n\n* available.\n\n* Since JDWP version 1.4.\n\n*/\n\nstatic class CapabilitiesNew implements Command {\n\nstatic final int COMMAND = 17;\n\n/**\n\n* Can the VM watch field modification, and therefore\n\n* can it send the Modification Watchpoint Event?\n\n*/\n\n//final boolean canWatchFieldModification;\n\n/**\n\n* Can the VM watch field access, and therefore\n\n* can it send the Access Watchpoint Event?\n\n*/\n\n//final boolean canWatchFieldAccess;\n\n/**\n\n* Can the VM get the bytecodes of a given method?\n\n*/\n\n//final boolean canGetBytecodes;\n\n/**\n\n* Can the VM determine whether a field or method is\n\n* synthetic? (that is, can the VM determine if the\n\n* method or the field was invented by the compiler?)\n\n*/\n\n//final boolean canGetSyntheticAttribute;\n\n/**\n\n* Can the VM get the owned monitors infornation for\n\n* a thread?\n\n*/\n\n//final boolean canGetOwnedMonitorInfo;\n\n/**\n\n* Can the VM get the current contended monitor of a thread?\n\n*/\n\n//final boolean canGetCurrentContendedMonitor;\n\n/**\n\n* Can the VM get the monitor information for a given object?\n\n*/\n\n//final boolean canGetMonitorInfo;\n\n/**\n\n* Can the VM redefine classes?\n\n*/\n\n//final boolean canRedefineClasses;\n\n/**\n\n* Can the VM add methods when redefining\n\n* classes?\n\n*/\n\n//final boolean canAddMethod;\n\n/**\n\n* Can the VM redefine classes\n\n* in arbitrary ways?\n\n*/\n\n//final boolean canUnrestrictedlyRedefineClasses;\n\n/**\n\n* Can the VM pop stack frames?\n\n*/\n\n//final boolean canPopFrames;\n\n/**\n\n* Can the VM filter events by specific object?\n\n*/\n\n//final boolean canUseInstanceFilters;\n\n/**\n\n* Can the VM get the source debug extension?\n\n*/\n\n//final boolean canGetSourceDebugExtension;\n\n/**\n\n* Can the VM request VM death events?\n\n*/\n\n//final boolean canRequestVMDeathEvent;\n\n/**\n\n* Can the VM set a default stratum?\n\n*/\n\n//final boolean canSetDefaultStratum;\n\n/**\n\n* Can the VM return instances, counts of instances of classes\n\n* and referring objects?\n\n*/\n\n//final boolean canGetInstanceInfo;\n\n/**\n\n* Can the VM request monitor events?\n\n*/\n\n//final boolean canRequestMonitorEvents;\n\n/**\n\n* Can the VM get monitors with frame depth info?\n\n*/\n\n//final boolean canGetMonitorFrameInfo;\n\n/**\n\n* Can the VM filter class prepare events by source name?\n\n*/\n\n//final boolean canUseSourceNameFilters;\n\n/**\n\n* Can the VM return the constant pool information?\n\n*/\n\n//final boolean canGetConstantPool;\n\n/**\n\n* Can the VM force early return from a method?\n\n*/\n\n//final boolean canForceEarlyReturn;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved22;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved23;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved24;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved25;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved26;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved27;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved28;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved29;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved30;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved31;\n\n/**\n\n* Reserved for future capability\n\n*/\n\n//final boolean reserved32;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\n//canWatchFieldModification = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canWatchFieldModification());\n\n//canWatchFieldAccess = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canWatchFieldAccess());\n\n//canGetBytecodes = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetBytecodes());\n\n//canGetSyntheticAttribute = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetSyntheticAttribute());\n\n//canGetOwnedMonitorInfo = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetOwnedMonitorInfo());\n\n//canGetCurrentContendedMonitor = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetCurrentContendedMonitor());\n\n//canGetMonitorInfo = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetMonitorInfo());\n\n//canRedefineClasses = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canRedefineClasses());\n\n//canAddMethod = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canAddMethod());\n\n//canUnrestrictedlyRedefineClasses = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canUnrestrictedlyRedefineClasses());\n\n//canPopFrames = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canPopFrames());\n\n//canUseInstanceFilters = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canUseInstanceFilters());\n\n//canGetSourceDebugExtension = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetSourceDebugExtension());\n\n//canRequestVMDeathEvent = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canRequestVMDeathEvent());\n\n//canSetDefaultStratum = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//canGetInstanceInfo = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetInstanceInfo());\n\n//canRequestMonitorEvents = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canRequestMonitorEvents());\n\n//canGetMonitorFrameInfo = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetMonitorFrameInfo());\n\n//canUseSourceNameFilters = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canUseSourceNameFilters());\n\n//canGetConstantPool = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canGetConstantPool());\n\n//canForceEarlyReturn = answer.readBoolean();\n\nanswer.writeBoolean(vm.vm.canForceEarlyReturn());\n\n//reserved22 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved23 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved24 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved25 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved26 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved27 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved28 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved29 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved30 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved31 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n//reserved32 = answer.readBoolean();\n\nanswer.writeBoolean(false);\n\n}\n\n}\n\n/**\n\n* Installs new class definitions.\n\n* If there are active stack frames in methods of the redefined classes in the\n\n* target VM then those active frames continue to run the bytecodes of the\n\n* original method. These methods are considered obsolete - see\n\n* <a href=\"#JDWP_Method_IsObsolete\">IsObsolete</a>. The methods in the\n\n* redefined classes will be used for new invokes in the target VM.\n\n* The original method ID refers to the redefined method.\n\n* All breakpoints in the redefined classes are cleared.\n\n* If resetting of stack frames is desired, the\n\n* <a href=\"#JDWP_StackFrame_PopFrames\">PopFrames</a> command can be used\n\n* to pop frames with obsolete methods.\n\n* <p>\n\n* Requires canRedefineClasses capability - see\n\n* <a href=\"#JDWP_VirtualMachine_CapabilitiesNew\">CapabilitiesNew</a>.\n\n* In addition to the canRedefineClasses capability, the target VM must\n\n* have the canAddMethod capability to add methods when redefining classes,\n\n* or the canUnrestrictedlyRedefineClasses to redefine classes in arbitrary\n\n* ways.\n\n*/\n\nstatic class RedefineClasses implements Command {\n\nstatic final int COMMAND = 18;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nnotImplemented(answer);\n\n}\n\n}\n\n/**\n\n* Set the default stratum. Requires canSetDefaultStratum capability - see\n\n* <a href=\"#JDWP_VirtualMachine_CapabilitiesNew\">CapabilitiesNew</a>.\n\n*/\n\nstatic class SetDefaultStratum implements Command {\n\nstatic final int COMMAND = 19;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nnotImplemented(answer);\n\n}\n\n}\n\n/**\n\n* Returns reference types for all classes currently loaded by the\n\n* target VM.\n\n* Both the JNI signature and the generic signature are\n\n* returned for each class.\n\n* Generic signatures are described in the signature attribute\n\n* section in\n\n* <cite>The Java&trade; Virtual Machine Specification</cite>.\n\n* Since JDWP version 1.5.\n\n*/\n\nstatic class AllClassesWithGeneric implements Command {\n\nstatic final int COMMAND = 20;\n\nstatic class ClassInfo {\n\n/**\n\n* <a href=\"#JDWP_TypeTag\">Kind</a>\n\n* of following reference type.\n\n*/\n\n//final byte refTypeTag;\n\n/**\n\n* Loaded reference type\n\n*/\n\n//final long typeID;\n\n/**\n\n* The JNI signature of the loaded reference type.\n\n*/\n\n//final String signature;\n\n/**\n\n* The generic signature of the loaded reference type\n\n* or an empty string if there is none.\n\n*/\n\n//final String genericSignature;\n\n/**\n\n* The current class\n\n* <a href=\"#JDWP_ClassStatus\">status.</a>\n\n*/\n\n//final int status;\n\npublic static void write(ReferenceTypeImpl cls, VirtualMachineImpl vm, PacketStream answer) {\n\n//refTypeTag = answer.readByte();\n\nanswer.writeByte(cls.tag());\n\n//typeID = answer.readClassRef();\n\nanswer.writeClassRef(cls.uniqueID());\n\n//signature = answer.readString();\n\nanswer.writeString(cls.signature());\n\n//genericSignature = answer.readString();\n\nanswer.writeStringOrEmpty(cls.genericSignature());\n\n//status = answer.readInt();\n\nanswer.writeInt(cls.ref().getClassStatus());\n\n}\n\n}\n\n/**\n\n* Number of reference types that follow.\n\n*/\n\n//final ClassInfo[] classes;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nList<ReferenceTypeImpl> allClasses = vm.vm.allClasses();\n\n// //int classesCount = answer.readInt();\n\nanswer.writeInt(allClasses.size());\n\n//classes = new ClassInfo[classesCount];\n\nfor (ReferenceTypeImpl cls : allClasses) {\n\nClassInfo.write(cls, vm, answer);\n\n}\n\n//for (int i = 0; i < classesCount; i++) {;\n\n//classes[i] = new ClassInfo(vm, ps);\n\n//}\n\n}\n\n}\n\n/**\n\n* Returns the number of instances of each reference type in the input list.\n\n* Only instances that are reachable for the purposes of\n\n* garbage collection are counted. If a reference type is invalid,\n\n* eg. it has been unloaded, zero is returned for its instance count.\n\n* <p>Since JDWP version 1.6. Requires canGetInstanceInfo capability - see\n\n* <a href=\"#JDWP_VirtualMachine_CapabilitiesNew\">CapabilitiesNew</a>.\n\n*/\n\nstatic class InstanceCounts implements Command {\n\nstatic final int COMMAND = 21;\n\n/**\n\n* The number of counts that follow.\n\n*/\n\n//final long[] counts;\n\npublic void reply(VirtualMachineImpl vm, PacketStream answer, PacketStream command) {\n\nint count = command.readInt();\n\nList<ReferenceTypeImpl> refs = new ArrayList<ReferenceTypeImpl>(count);"
    }
}