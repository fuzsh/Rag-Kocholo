{
    "id": "wrong_mix_property_foundationPlace_00064_3",
    "rank": 44,
    "data": {
        "url": "https://www.industriallogic.com/blog/appcode-is-dead/",
        "read_more_link": "",
        "language": "en",
        "title": "Suddenly, AppCode Is Dead. Now What?",
        "top_image": "https://www.industriallogic.com/img/socialcard/blog/2023-01-17-appcode-is-dead.jpg",
        "meta_img": "https://www.industriallogic.com/img/socialcard/blog/2023-01-17-appcode-is-dead.jpg",
        "images": [
            "https://www.industriallogic.com/img/misc/il_inline_color.svg",
            "https://www.industriallogic.com/img/blog/2023-appcode-is-dead/headstone.png",
            "https://www.industriallogic.com/img/team/jon_reid_headshot_2021.png",
            "https://www.industriallogic.com/img/illustration/trw_albums.png",
            "https://www.industriallogic.com/img/illustration/homepage_training_small.jpg",
            "https://www.industriallogic.com/img/pages/read_a_blog.jpg",
            "https://www.industriallogic.com/img/team/jon_reid_headshot_2021.png",
            "https://www.industriallogic.com/img/workshops/APSW_copy.jpg",
            "https://www.industriallogic.com/img/misc/il_inline_color.svg",
            "https://px.ads.linkedin.com/collect/?pid=3229850&fmt=gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "jon"
        ],
        "publish_date": "2023-01-17T00:00:00+00:00",
        "summary": "",
        "meta_description": "Long liveâ¦ what, exactly?",
        "meta_lang": "",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "Industrial Logic - Better Software Sooner",
        "canonical_link": "https://www.industriallogic.com/blog/appcode-is-dead/",
        "text": "AppCode is dead. Long liveâ¦ what, exactly?\n\nIf youâve seen any of my live coding, you know that AppCode is my preferred IDE for Swift. There are very few tasks (such as changing project settings) for which I prefer Xcode. But for coding, thereâs no contest. And with the addition of Inline refactorings, my Swift coding accelerated even more.\n\nBut as JetBrains announced their latest release of AppCode, they dropped a bomb: this is also their final release. They will provide bare-bones updates for compatibility and security through the end of 2023. And then, the end.\n\nIâm gutted.\n\nWhy Did AppCode Die?\n\nSwift alone nearly killed AppCode. But I think SwiftUI struck the final blow.\n\nRemember pre-Swift days? Objective-C was the tool for working with almost everything in the Apple ecosystem. Remember, Objective-C dates back to the early 1980s. A big shift to Objective-C 2.0 happened in 2007. You can still build old Objective-C projects today, with no changes.\n\nThough AppCode users were a small minority, some of my coworkers used it at least occasionally. Thatâs because compared to Xcode, its support for automated refactoring was overpowering.\n\nThen came Swift.\n\nThis new programming language was type-strict, with a lot more syntax. JetBrains, the makers of AppCode, was suddenly left with an IDE that didnât work for modern Apple development. So they had to catch up, adding basic Swift support. But Swift is a performance hog. AppCodeâs usability suffered, and my coworkers who had been using AppCodeâ¦ well, they stopped.\n\nAnd this wasnât just support for a single language. We also needed cross-language support: Swift calling Objective-C, and Objective-C calling Swift. AppCode features suffered when they crossed this language boundary, because a good IDE answers these basic questions:\n\nWhere is this thing defined?\n\nWhere is this thing used?\n\nIs this thing unused?\n\nAcross the language boundary, the answers were sometimes incomplete â and thus wrong. From a coderâs perspective, trusted Objective-C features became worse. So this was another problem that JetBrains had to solve. Even as they did, Apple kept issuing changes to improve the syntax with special transformation rules, which AppCode had to add (after the fact).\n\nBut over several releases, AppCode improved in both performance and reliability. It became possible to use for real projects again. I told my coworkers, âYou can come back now, it handles Swift just fine.â But they didnât come back.\n\nThen Swift became open-source.\n\nNew language features (with new syntax) started flying in. AppCodeâs support for refactoring Swift was bare-bones to start with, but they were in a race adding language changes, and couldnât afford to add refactoring features. In a race to keep up, you are always going to be behind. So when a new language feature came, AppCode users often had to wait. Of course, this lost even more users.\n\nStill, JetBrains eventually added more code manipulation. Change Signature was a game-changer for me.\n\nThen along came SwiftUI.\n\nSwiftUI did two things. First, it accelerated changes to Swift, adding features and syntax that SwiftUI needs. But also, Xcodeâs built-in Preview (live rendering the UI) made Xcode itself more compelling for SwiftUI.\n\nJetBrains published an article showing how to use InjectionIII to see your SwiftUI layouts without Xcode. But InjectionIII is a third-party library â more friction to keep developers from adopting AppCode.\n\nFor JetBrains, the expenses of developing AppCode kept increasing, while their revenue kept decreasing. Game over.\n\nSwift Refactorings Weâll Never See in AppCode\n\nWith the end of AppCode development, there are refactorings we have for Objective-C that weâll never see for Swift. These include: Introduce parameter (moving variable definition into the signature)\n\nExtract superclass\n\nExtract subclass\n\nPull members up (properties or methods)\n\nPush members down\n\nMove members to another type (existing or new). This checks which referenced members should also move.\n\nRemove unused imports\n\nI wrote above, âCompared to Xcode, its support for automated refactoring was overpowering.â Long before the end of AppCode, this was finally true for Swift. But the Swift refactoring was still a thin sliver of what it could do with Objective-C.\n\nAnd you know what? The powerful Objective-C refactoring itself was a thin sliver of what you can do in their other IDEs, especially IntelliJ.\n\nI grieve for what could have been.\n\nWhatâs the Future of Refactoring and Code Generation in Swift?\n\nSo now what? I would guess that most developers in the Apple ecosystem have only ever worked in Xcode. Thereâs no clamor for better tools. Will Apple developers remain ignorant of automated refactoring or point-of-call code generation?\n\nI sure hope not. There are two ways this could go. One way is Apple putting in the hard work to improve refactoring in their tools. This would mean:\n\nImproving current refactorings which are barely adequate (if they work at all)\n\nAdding new refactorings\n\nProviding these in a keyboard-triggered pop-up instead of slow mouse access\n\nBut given Appleâs antipathy to good coding practices (and their lack of exposure to ideas outside their ecosystem), the odds are slim. And what few changes they will provide come only once a year.\n\nBut theyâre not the only players. Remember how Swift went open-source?\n\nWe have an opportunity for the open-source community to respond. Thereâs already an official Swift plug-in for the VSCode IDE. Still in its early days, itâs worth keeping an eye on.\n\nWhat if the community came together to create:\n\nA way to convert Swift source code into an Abstract Syntax Tree (AST)\n\nA way to convert an AST back into Swift source code\n\nBehavior-preserving transformations of the AST\n\nMaybe itâs time for developers to reclaim tool-making in the Apple ecosystem, and let Apple catch up.\n\nDo you know of tools to refactor Swift source code, or generate new code from a call site? Please share any in the comments below."
    }
}