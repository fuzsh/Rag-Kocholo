{
    "id": "wrong_mix_property_foundationPlace_00064_3",
    "rank": 30,
    "data": {
        "url": "https://www.baeldung.com/jetbrains-contract-annotation",
        "read_more_link": "",
        "language": "en",
        "title": "JetBrains @Contract Annotation",
        "top_image": "https://www.baeldung.com/wp-content/uploads/2021/09/Java-8-Featured.png",
        "meta_img": "https://www.baeldung.com/wp-content/uploads/2021/09/Java-8-Featured.png",
        "images": [
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://secure.gravatar.com/avatar/1d1d48084f8f3bfc8dc92e1829c12f61?s=50&r=g",
            "https://www.baeldung.com/wp-content/uploads/custom_avatars/david-martinez-150x150.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2023/03/inspect_code_intellij.png 151w, https://www.baeldung.com/wp-content/uploads/2023/03/inspect_code_intellij-100x130.png 100w",
            "https://www.baeldung.com/wp-content/uploads/2023/03/violated-contract-clause-300x101.png 300w, https://www.baeldung.com/wp-content/uploads/2023/03/violated-contract-clause-100x34.png 100w, https://www.baeldung.com/wp-content/uploads/2023/03/violated-contract-clause.png 541w",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-main-1.2.0.jpg",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-icn-1.0.0.png",
            "https://www.baeldung.com/wp-content/uploads/2024/01/book-cover-mockito-guide-lg-1.png",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-security-widget-main-1.2.0-300x235.jpg",
            "https://www.baeldung.com/wp-content/uploads/2022/11/BookCover-Persistence_with_Spring.png",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/whiteleaf.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Thibault Faure"
        ],
        "publish_date": "2023-03-20T05:48:51+02:00",
        "summary": "",
        "meta_description": "Learn how to use the JetBrains @Contract annotation.",
        "meta_lang": "en",
        "meta_favicon": "https://www.baeldung.com/wp-content/themes/baeldung/favicon/apple-touch-icon-57x57.png",
        "meta_site_name": "Baeldung",
        "canonical_link": "https://www.baeldung.com/jetbrains-contract-annotation",
        "text": "1. Overview\n\nIn this article, we’ll explain how to use the @Contract annotation. Thanks to this annotation, we can define a contract that our methods must match. JetBrains, the brand behind IntelliJ IDEA, introduced the annotation. It allows the text editor to directly troubleshoot potential problems with the calling methods in our code.\n\n2. Setup Maven Dependency\n\nThe latest version of the annotations library can be found in the Maven Central Repository. Let’s add the dependency in our pom.xml:\n\n<dependency> <groupId>org.jetbrains</groupId <artifactId>annotations</artifactId> <version>24.0.1</version> </dependency>\n\n3. The Value Attribute\n\nThe @Contract annotation has two attributes: value and pure. The value attribute contains clauses describing the relationship between the methods’ inputs and output. It’s the primary functionality of the annotation and was first introduced in IntelliJ 14.\n\n3.1. Contract Grammar\n\nA contract is a set of causality clauses of the form: “A -> B”. This means that providing A to the method will always give B as a result. For instance, “_ -> null” means that the method returns null for any input value.\n\nThe possible constraints on the input are the following:\n\n_: any value\n\nnull: a null value\n\n!null: a non-null value\n\ntrue: a true boolean value\n\nfalse: a false boolean value\n\nThe return value supports the same constraints as long as the following ones:\n\nfail: the method throws an Exception\n\nnew: the method returns a new Object. This Object must be non-null and different from any other Object already present in the heap\n\nthis: the method returns its qualifier value. It can’t be applied to static methods\n\nparam1, param2, ..: the method returns the value of its first (respectively second…) parameter\n\nThe new, this, and param1 keywords have only been supported since IntelliJ 2018.2.\n\nAdditionally, let’s point out that various constraints can be accumulated as long as they don’t collide.\n\n3.2. Writing Our First Contracts\n\nLet’s now showcase a first example: we’ll create a Person class with a lone name attribute. We’ll add a builder method that will set the name of the Person and return the Person instance:\n\npublic class Person { String name; @Contract(\"_ -> this\") Person withName(String name) { this.name = name; return this; } }\n\nAs we can see, whatever the input is, the object itself is returned, so we annotated this method with the valid @Contract(“_ -> this”) annotation.\n\nLet’s now write a method with a more complex signature. This method concatenates two Strings only if the second one is not null and returns null otherwise. Thus, we can give it a contract that states that:\n\nif the second argument is null, the result is null and doesn’t depend on the value of the first argument\n\nif the first argument is null, the result is the value of the second argument\n\nif the second argument isn’t null, then the result isn’t null\n\nIn a nutshell, we can annotate our method with the following contract:\n\n@Contract(\"_, null -> null; null, _ -> param2; _, !null -> !null\") String concatenateOnlyIfSecondArgumentIsNotNull(String head, String tail) { if (tail == null) { return null; } if (head == null) { return tail; } return head + tail; }\n\n3.3. Code Inspection\n\nWriting a contract can result in two types of errors:\n\nthe contract isn’t written correctly\n\na calling method has some unreachable code\n\nIntelliJ can run code analysis and highlight both kinds of errors. To run the code inspection, we can open the Code menu and then choose Inspect Code:\n\nFor instance, let’s write a method that doesn’t do anything. We’ll add a wrong contract that states that it should always fail:\n\n@Contract(\" -> fail\") void doNothingWithWrongContract() {}\n\nThe Problems tab opens, and the editor warns us about a probable bug in the code:\n\nThose hints that concern contract correctness are useful, but the inspection tool really shines when it helps to remove dead or redundant code. For example, let’s write a piece of code that will call the concatenateOnlyIfSecondArgumentIsNotNull method for two non-null Strings. Then, we’ll want to print the result if it’s not null. Naively, we could write:\n\nString concatenation = concatenateOnlyIfSecondArgumentIsNotNull(\"1234\", \"5678\"); if (concatenation != null) { System.out.println(concatenation); }\n\nLet’s run the code inspection tool. The following message appears:\n\nCondition 'concatenation != null' is always 'true'\n\nOur non-null check is indeed redundant because calling concatenateOnlyIfSecondArgumentIsNotNull on two non-null arguments will always return a non-null result. And IntelliJ was able to spot that thanks to the @Contract annotation!\n\nLast but not least, let’s mention that IntelliJ is also able to carefully look at our libraries’ bytecode and infer contract annotations. For instance, IntelliJ automatically annotates the isEmpty() method with @Contract(“null->true”).\n\n4. The Pure Attribute\n\nThe pure attribute specifies that the method has no visible side effects. Thus, if the return value of a pure method isn’t used, we’ll be able to safely remove the call without changing the overall result of our code. Printing to the standard output isn’t considered a visible side effect. On the other hand, methods that don’t seem to have a side effect but could allow changes happening in other threads to be visible in their thread after their execution can’t be marked as pure.\n\nFor instance, replacing some characters in a String is a pure operation:\n\n@Contract(pure = true) String replace(String string, char oldChar, char newChar) { return string.replace(oldChar, newChar); }\n\nFurthermore, it is possible to use the pure attribute alongside the value attribute. For instance, we can write a not method that returns the opposite of its boolean parameter with the following contract:\n\n@Contract(value = \"true -> false; false -> true\", pure = true) boolean not(boolean input) { return !input; }\n\nAs of version 2023.1, IntelliJ doesn’t run any relevant code inspection based on the pure attribute. The default value for the pure attribute is false.\n\n6. Conclusion\n\nIn this tutorial, we’ve seen how to use the @Contract annotation. Adding this annotation to our toolbox can significantly impact our code quality. In particular, we can easily spot dead code thanks to the value attributes. However, we need to point out that the annotation is just here for description purposes and doesn’t have any consequence on the compiled code."
    }
}