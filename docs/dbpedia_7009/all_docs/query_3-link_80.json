{
    "id": "dbpedia_7009_3",
    "rank": 80,
    "data": {
        "url": "https://discourse.julialang.org/t/syntax-surprises/92369",
        "read_more_link": "",
        "language": "en",
        "title": "Syntax Surprises",
        "top_image": "https://global.discourse-cdn.com/julialang/original/3X/4/d/4d76a1d8062ed9397f2f00f22abdd69926b51785.png",
        "meta_img": "https://global.discourse-cdn.com/julialang/original/3X/4/d/4d76a1d8062ed9397f2f00f22abdd69926b51785.png",
        "images": [
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/miguelraz/48/631_2.png",
            "https://emoji.discourse-cdn.com/twitter/wave.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=12",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/niclasmattsson/48/21988_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://emoji.discourse-cdn.com/twitter/eyes.png?v=12",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=12",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://emoji.discourse-cdn.com/twitter/sweat_smile.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/wink.png?v=12",
            "https://avatars.discourse-cdn.com/v4/letter/j/c0e974/48.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/uniment/48/24532_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/uniment/48/24532_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/uniment/48/24532_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/stevengj/48/71_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/forcebru/48/21389_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/stevengj/48/71_2.png",
            "https://sea2.discourse-cdn.com/julialang/user_avatar/discourse.julialang.org/stevengj/48/71_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "syntax",
            "discussion",
            "fun",
            "gotchas"
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-12-31T20:00:02+00:00",
        "summary": "",
        "meta_description": "A fun one for the new year :wink: \nOne of the things I really like about Julia is being able to write code how I like (and the surprisingly large number of language decisions I find myself loving). The syntax is natural,&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/julialang/optimized/3X/5/2/52e282d46eadd4022c458057bb740061d8efad72_2_32x32.png",
        "meta_site_name": "Julia Programming Language",
        "canonical_link": "https://discourse.julialang.org/t/syntax-surprises/92369",
        "text": "A fun one for the new year\n\nOne of the things I really like about Julia is being able to write code how I like (and the surprisingly large number of language decisions I find myself loving). The syntax is natural, I can add or subtract lines and indent however I feel is most appropriate in the moment—whether for brevity or for verbosity—I don’t need a bunch of extra parentheses and braces, matrix building is amazing, tuple destructuring, macros and generated functions are awesome, string and expression interpolation, builtin big numbers, regular expressions, complex numbers, let’s not forget the type system!.. I can go on for days. It’s amazing how much expressivity Julia’s creators were able to pack into a single language, and a high performance one at that!\n\nBut that superpower also comes with some [all things considered, a surprisingly small number of] gotchas that can be unexpected sometimes, and you might spend some time debugging before you figure out what happened. The parsing rules are amazing, in that remarkably concise syntax gets you what you want most of the time and that makes up for the times when you didn’t get what you expected; but it means you have to be careful sometimes.\n\nI’ll list some things I’ve bumped into:\n\n1. Sometimes Subtraction\n\njulia> @show 1-2+3 (1 - 2) + 3 = 2 2 julia> @show 1 -2+3 1 = 1 -2 + 3 = 1 1 julia> @show 1 -2 +3 1 = 1 -2 = -2 3 = 3 3 julia> @show 1- 2+ 3 (1 - 2) + 3 = 2 2\n\n2. Curry Me Maybe\n\njulia> [<(5) cos] 1×2 Matrix{Function}: Fix2{typeof(<), Int64}(<, 5) cos julia> [cos <(5)] ERROR: MethodError: no method matching isless(::typeof(cos), ::Int64)\n\n3. Symbol Swap\n\njulia> s = 2 > 1 ? :Hello : :World :Hello julia> if 2 > 1 s=:Hello else s=:World end :Hello julia> s = if 2 > 1 :Hello else :World end ERROR: UndefVarError: Hello not defined\n\n4. Tuple Trouble\n\njulia> f() = (local a, b = 1, 2; a+b) f (generic function with 1 method) julia> f() = (a, b = 1, 2; a+b) ERROR: syntax: unexpected semicolon in tuple around REPL[2]:1\n\n5. Parenthetically Speaking\n\njulia> for x=1:3 print(\"$x \") end 1 2 3 julia> for x=(1,2,3) print(\"$x \") end 1 2 3 julia> for x=1:3 (print(\"$x \")) end 1 2 3 julia> for x=(1,2,3) (print(\"$x \")) end ERROR: syntax: space before \"(\" not allowed in \"(1, 2, 3) (\" at REPL[4]:1\n\n6. Called It\n\njulia> (4)(4) 16 julia> (4)(2*2) 16 julia> (2*2)(4) ERROR: MethodError: objects of type Int64 are not callable\n\n7. Poly vs Bi\n\njulia> +(1, 2, 3) 6 julia> -(1, 2, 3) ERROR: MethodError: no method matching -(::Int64, ::Int64, ::Int64)\n\n8. Enter the Matrix\n\njulia> if 1 > 2 A=[1 2; 3 4] else A=[4 3; 2 1] end 2×2 Matrix{Int64}: 4 3 2 1 julia> A = if 1 > 2 [1 2; 3 4] else [4 3; 2 1] end ERROR: syntax: space before \"[\" not allowed in \"2 [\" at REPL[2]:1\n\nThankfully parsing surprises are better than runtime surprises, and many of these are avoided with a strategic semicolon.\n\nAre there any syntax surprises and gotchas that should be added to the list? Post them below!\n\nHow does this affect the existence of the -(::Int64, ::Int64, ::Int64) method?\n\nSince + is associative, (a+b)+c == a+(b+c) and (a+(b+c))+d == a+((b+c)+d) and so on, so I could drop parentheses and simply write a+b+c+d == +(a,b,c,d). Makes sense.\n\nSince - is not associative (a-b)-c != a-(b-c), it’s not possible to unambiguously write a-b-c without parentheses. Thus, -(a,b,c) could mean (a-b)-c or a-(b-c). Makes sense as well.\n\nHowever, a-b-c-d always means ((a-b)-c)-d since - is left-associative. Why not make -(a,b,c,d) evaluate to a-b-c-d?\n\nFor +, @code_llvm (1+2+3+4) and @code_llvm (+(1,2,3,4)) produce:\n\n; %0, %1, %2 and %3 are the four input numbers %4 = add i64 %1, %0 %5 = add i64 %4, %2 %6 = add i64 %5, %3 ret i64 %6\n\nOrder of addition is swapped for floats\n\nNote that the first instruction is %4 = add i64 %1, %0, so we add like %1 + %0, as opposed to %0 + %1, which would seem more natural?\n\nIf I use floats instead of integers (@code_llvm (1. + 2. + 3. + 4.)), the order in the first instruction will be swapped:\n\n; The integer version had add i64 %1, %0 %4 = fadd double %0, %1 ; %0 + %1 %5 = fadd double %4, %2 %6 = fadd double %5, %3 ret double %6\n\nIs this more efficient? More resistant to floating-point shenanigans? Seems inconsistent to me. Julia 1.9.0-beta2, commit 7daffeecb8c (2022-12-29 07:45 UTC).\n\nWhy not have @code_llvm (-(1,2,3,4)) produce almost the same thing, but with subtraction instead of addition:\n\n; %0, %1, %2 and %3 are the four input numbers ; NOTE: swapped %0 and %1 compared to addition above %4 = sub i64 %0, %1 ; %4 = 1 - 2 = -1 %5 = sub i64 %4, %2 ; %5 = -1 - 3 = -4 %6 = sub i64 %5, %3 ; %6 = -4 - 4 = -8 ret i64 %6; -8\n\nJust a clarification for newcomers that may believe that issue 1 indicates that Julia has a fundamental problem with operator precedence, associativity or commutativity. That is of course not the case. This is a question of how to invoke macros and separate arguments in the call. When a macro is called without parentheses, its arguments are whitespace separated (see documentation).\n\nIn a nutshell, @show 1 -2+3 is equivalent to @show(1, -2+3). Adding parentheses resolves the ambiguity in all four examples of issue 1:\n\njulia> @show(1-2+3) (1 - 2) + 3 = 2 2 julia> @show(1 -2+3) (1 - 2) + 3 = 2 2 julia> @show(1 -2 +3) (1 - 2) + 3 = 2 2 julia> @show(1- 2+ 3) (1 - 2) + 3 = 2 2\n\nAnd to be extra clear, evaluating the four expressions without a macro call always produces the expected result:\n\njulia> 1-2+3 === 1 -2+3 === 1 -2 +3 === 1- 2+ 3 === 2 true\n\nIt’s also a question of how to build matrices, and how to separate the elements of a row within a matrix. To demonstrate using row vectors:\n\njulia> ([1-2+3], [1 -2+3], [1 -2 +3], [1- 2+ 3]) ([2], [1 1], [1 -2 3], [2])\n\nAdd a comma and it throws an error:\n\njulia> [1 -2 +3,] ERROR: syntax: unexpected comma in array expression\n\nsimilarly,\n\njulia> [1 -2, +3] ERROR: syntax: missing separator in array expression\n\nThis is because commas are used only for building one-dimensional arrays, i.e. column Vectors, and that’s incompatible with matrices and other multidimensional arrays.\n\nTo do arithmetic on elements of the vector, spaces around the operator must be symmetric:\n\njulia> [1-2, +3] 2-element Vector{Int64}: -1 3 julia> [1 - 2, +3] 2-element Vector{Int64}: -1 3\n\n(more precisely, if there’s space on the left-side of the operator, then if there is no space on the right-side of the operator it will not be treated as a binary operator but instead as a unary operator.)\n\nTo build a higher-dimensional array such as a matrix, use semicolons or newlines:\n\njulia> [1 -2 +3; -4 +5 -6] 2×3 Matrix{Int64}: 1 -2 3 -4 5 -6\n\nIn this expression, it becomes perfectly clear why these parsing rules work this way.\n\nYou can also build a column vector using semicolons or newlines instead of commas, because column vectors are just the tiniest subset of multi-dimensional arrays:\n\njulia> [1; 2; 3] 3-element Vector{Int64}: 1 2 3\n\nlet’s do some arithmetic:\n\njulia> [1+1; 2+2; 3+3] 3-element Vector{Int64}: 2 4 6\n\nBut add funny spaces around elements, and you can get an error:\n\njulia> [1+1; 2 +2; 3+3] ERROR: ArgumentError: argument count does not match specified shape (expected 3, got 4)\n\nJulia’s parser is very clever for this specific reason—within the bounds of [], it’s assumed that expressions will be space-delimited for matrix-building, and so parsing rules needed to be made to handle this. And then, similar parsing rules are applied when we call macros without parentheses because we’re using spaces again as a separater between arguments.\n\nIt’s just something to be mindful of; you’ll run into it sooner or later anyway, either when building arrays or when calling macros, so it’s best to just adopt habits of symmetrical whitespace around operators. Symmetrical whitespace is a good habit anyway for code legibility.\n\nNote that these considerations only apply to plus and minus, which are the only operators which can either be binary or unary; other operators don’t act like this:\n\njulia> ([1/2*3], [1 /2*3], [1 /2 *3], [1/ 2* 3]) ([1.5], [1.5], [1.5], [1.5])\n\nBest to adopt good whitespace habits anyway.\n\nEdit:\n\nNote that it could have been decided, instead of having whitespace-dependent rules for when + and - would become unary operators, to simply wrap expressions in parentheses within matrices:\n\njulia> [1 (-2) (+3)] 1×3 Matrix{Int64}: 1 -2 3\n\nThen there would be no room for confusion surrounding this topic, neither within arrays nor in macro calls.\n\nHowever, building large matrices would become a pain. Julia’s creators, being math-centric folks who love matrices, chose to prioritize succinctness in matrix building even though it calls for some context-dependent whitespace-dependent parsing rules.\n\nI’m partial to math myself (after all, math is the closest thing we have to a universal language), so I can’t fault them for that. But it does demonstrate quite nicely how decisions in a language design will necessarily revolve around the priorities of its authors.\n\nNot just matrices, but anything wrapped in brackets or parentheses:\n\njulia> if true Any[] end Any[] julia> if true [x for x=1:3] end ERROR: syntax: space before \"[\" not allowed in \"true [\" at REPL[2]:1 julia> if isodd(1) (1,2,3) end ERROR: syntax: space before \"(\" not allowed in \"isodd(1) (\" at REPL[3]:1\n\nThere’s a good chance this is a bug, but I don’t think #3 in the OP is; I suspect I might simply adopt a habit of adding a semicolon after the condition for one-liner ifs, fors, and whiles to avoid it altogether. I’ve already had to adopt a similar habit for one-liner let, do, and try...catch statements anyway.\n\nThis behavior I actually don’t find egregious. It’s enough of an edge case (who makes multidimensional arrays of functions anyway? ), and can be disambiguated with [cos (<(5))] or [cos;;<(5)]. Although of course I would prefer, instead of <(5), to use underscore partial application syntax _ < 5.\n\nIf you did want to make a multidimensional array of disparate functions though (why??), you’d probably want to roll a new type that maintains type stability by storing them in a Tuple.\n\nI guess this is just highlighting how inconsistent mathematical notation is\n\nIn math we can write (a+b)(c+d) and it will mean implicitly (a+b)\\times(c+d), yet we can also write (f * g)(t) and it does *not* mean (f * g)\\times (t) (where * refers to convolution). The fact that the parsing rules of math depend on context and the type of object—which we use naming conventions and natural language descriptions to disambiguate—makes it impossible to architect a perfectly consistent programming language around it.\n\nYet we try, and for good enough reason: if the goal is consistency at all costs, using the language becomes difficult not for ambiguity, but for lack of resemblance with anything meaningful to a human (and everything is wrapped fifteen layers deep in parentheses). The extra verbosity to eliminate ambiguity in all edge cases reduces the SNR of the base cases, which then increases error rate. After all, isn’t resemblance to math, at least in part, what brings us to Julia?\n\nConsistency is very valuable, but is not the sole measure of quality. The question then becomes not about how to achieve perfect consistency, but about what set of trade-offs is optimal. As we know about most real-life optimization problems (i.e., high-dimensional, nonlinear, and poorly observable; it has been said that life itself is a POMDP), there’s no knowably optimal answer; we descend gradients, we reason, we experiment, we develop heuristics, and of course we opine, but the ultimate referee is Father Time.\n\nLanguages like mathematics and English have spent hundreds of years being refined, even if imperfectly, to balance these demands—to maximize information transfer rate whilst minimizing error rate and maintaining sufficient brevity for experiments and derivations. By Lindy’s Law, these languages should serve as a decent starting point for programming language design; indeed, many successful languages have incorporated some blend of their features, Julia especially so.\n\nVarious features can be debated here and there, but 4(4) is pretty unambiguous as multiplication instead of function call so I don’t really see how it should raise too much controversy. For any weirdos who want to call their integers, I think it’s fairly agreeable that they should be forced to write x=4; x(4).\n\n2e + 1, on the other hand, kinda scares me. Same for this:\n\nf2=101 2(f2) #-> 202 2f2 #-> 200.0f0\n\nNot sure why it took so long; on my system it’s immediate.\n\nTo answer this requires a greater mind than mine\n\nCompletely agree. This is exactly what I was just about to reply to @uniment.\n\nI wonder whether programmers really find the ability to premultiply by a numeric literal like 4a + 5b or like (5)(5) useful enough. Does it really improve coding speed that much? Does it help understand code better than the usual notation 4 * a + 5 * b?\n\nPerhaps, but what’s the cost of such resemblance to math? If it’s confusing syntax like in OP or complicated and error-prone context-sensitive parsing, then I’d rather write 4 * a instead of 4(a).\n\nIMO, it’s pretty unambiguous as a function call, because basically all widely used languages treat <thing>(<thing>) as a function call:\n\nR, the language of statisticians, doesn’t let you call your numbers.\n\nPython, the language of data scientists, doesn’t let you call numbers either.\n\nThe Wolfram language, arguably the language of mathematicians, does support this syntax:\n\nIn[1]:= 4(6) Out[1]= 24\n\nHowever, Wolfram uses square brackets [] instead of parentheses () for function calls, so 4(6) can’t be interpreted as a function call and is thus unambiguously multiplication. A function call looks like Length[{2,3,4}] == 3.\n\nC and Rust, systems programming languages, definitely don’t allow this. Rust’s error message clearly says “call expression requires function” about code like 4(5).\n\n…which is yet another confusing consequence of the same design choice to allow multiplication by calling numbers or prepending numeric literals to identifiers.\n\nThe ultimate questions are: do Julia programmers find this syntax useful enough? How many of us prefer it to the usual 4 * a? What are its advantages compared to the usual syntax, except being at most 3 characters shorter? What are its disadvantages? Do the advantages outweigh the disadvantages?\n\nPetition to make syntax like 4a, 4(a) and (4)(a) an error in Julia 2.0."
    }
}