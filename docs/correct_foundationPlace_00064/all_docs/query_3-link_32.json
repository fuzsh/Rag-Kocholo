{
    "id": "correct_foundationPlace_00064_3",
    "rank": 32,
    "data": {
        "url": "https://in.relation.to/2024/04/01/jakarta-data-1/",
        "read_more_link": "",
        "language": "en",
        "title": "In Relation To",
        "top_image": "https://www.gravatar.com/avatar/77987db6d7dd75abd4a14651641b3d46?s=240",
        "meta_img": "https://www.gravatar.com/avatar/77987db6d7dd75abd4a14651641b3d46?s=240",
        "images": [
            "https://in.relation.to/images/hibernate-logo.svg",
            "https://in.relation.to/images/hibernate-logo.svg",
            "https://www.gravatar.com/avatar/77987db6d7dd75abd4a14651641b3d46?s=65",
            "https://in.relation.to/images/gavin/apt-error-1.png",
            "https://in.relation.to/images/gavin/intellij-error-1.png",
            "https://in.relation.to/images/gavin/apt-error-2.png",
            "https://in.relation.to/images/gavin/intellij-error-2.png",
            "https://in.relation.to/images/sponsored-by-redhat.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Gavin King"
        ],
        "publish_date": "2024-04-01T00:00:00",
        "summary": "",
        "meta_description": "Cross-posted from Substack.\n\n\n\nJakarta Data is a new specification for persistence in Java, scheduled for release as part of the EE 11 platform. Whereas Jakarta Persistence provides a mature and extremely feature-rich foundation for object/relational mapping solutions like Hibernate, Jakarta Data aims to offer a somewhat simplified programming model, but one which is also suitable for use with non-relational databases.",
        "meta_lang": "en",
        "meta_favicon": "https://static.jboss.org/hibernate/images/favicon.ico",
        "meta_site_name": "In Relation To",
        "canonical_link": "https://in.relation.to/2024/04/01/jakarta-data-1/",
        "text": "Jakarta Data is a programming model for repositories. Early versions of the specification featured what I’ve taken to calling “DAO-style” repositories, along the lines of established solutions like Spring Data. In this approach, each entity has its own repository interface offering persistence operations dedicated to that particular entity. So for Book, there’s a BookRepository, for Author, there’s an AuthorRepository, and so on.\n\nFolks who follow me on Twitter know I’ve long been a skeptic of this approach. I don’t want to revisit all the arguments here, but let me quickly touch on the following points, since they helped motivate the (new) design of Jakarta Data:\n\nFor relational data the division of operations by entity is unnatural. Most interesting queries operate across multiple entities, and very often across entities which—just like my favorite Book/Author example—participate in many-to-many associations. It’s unnatural to assign such operations to one entity. Please note that this point is specific to relational data. For a document database, DAO-style repositories are completely natural. I really don’t want to go too far down this rabbit hole here, but let me just bait you with the thought that this is an under-appreciated aspect of the O/R mapping problem, and an aspect which one particular section of the community has completely missed.\n\nIn a typical mature system, there are many more queries than entities, and this leads to a DAO filling up with many operations with extremely low cohesion.\n\nOlder frameworks offered little-to-no additional type safety, only extremely modest reductions in code (at best), and interposed a whole extra layer of framework code between the application program and the database, while making it more difficult to get access to advanced and performance-related features of Hibernate.\n\nOlder implementations based on JPA offered a CRUD-style API which was a completely inappropriate abstraction of JPA’s stateful persistence context. In a stateful persistence context, updates are implicit, so an update() method makes no sense.\n\nIn light of all this, Jakarta Data provides repositories which are not tied to one particular entity. Instead, persistence operations may be categorized according whatever classification you as a software designer dream up. Instead of BookRepository and AuthorRepository you might have Bookstore and Library. Indeed, the idea is that you could have many fine-grained repository interfaces, with operations classified by client or by topic, each with much improved cohesion, each operating over multiple entities.\n\nBut this isn’t what changed my mind about repositories, and it’s not really enough reason for you to start using them instead of just calling EntityManager. What made all the difference for me was realizing the potential for much greater type safety, a potential that older frameworks have simply failed to properly exploit. This realization grew out of work I began as part of Hibernate 6.3, but it reaches its apotheosis in the Jakarta Data specification. But now we’re getting ahead of ourselves.\n\nEnough with the handwaving. If you want to try out Jakarta Data today, you’ll need the M4 release, and you’ll need a snapshot build of Hibernate 6.6:\n\nhere’s a Gradle build you could use, or\n\nif you want to try it out in Quarkus, check out this Maven POM.\n\nNotice that it’s essential to enable HibernateProcessor, the annotation processor in the now inappropriately-named hibernate-jpamodelgen module. The annotation processor contains Hibernate’s implementation of Jakarta Data.\n\nIf you’re wondering why we implemented Jakarta Data using an annotation processor, instead of using reflection, or bytecode generation, or some other such runtime technique, the answer is type safety. HibernateProcessor is able to detect an incredible array of different kinds of error at compile time, and reports such problems with easily-understandable messages, as we’ll see later. This compile-time error reporting is the main reason to use Jakarta Data with Hibernate.\n\nOf course, we’ll need some JPA entity classes:\n\n@Entity public class Book { @Id String isbn; @Basic(optional = false) String title; LocalDate publicationDate; @Basic(optional = false) String text; @Enumerated(STRING) @Basic(optional = false) Type type = Type.Book; @ManyToOne(optional = false, fetch = LAZY) Publisher publisher; @ManyToMany(mappedBy = Author_.BOOKS) Set<Author> authors; ... } @Entity public class Author { @Id String ssn; @Basic(optional = false) String name; Address address; @ManyToMany Set<Book> books; }\n\nJakarta Data also works with entities defined using Jakarta NoSQL annotations, but here we’re using Hibernate ORM, so these annotations are the ones you already know from jakarta.persistence. There’s nothing new here.\n\nNext, let’s create our first repository, calling it Library, just for fun:\n\n@Repository public interface Library {}\n\nThe @Repository annotation tells HibernateProcessor to generate an implementation of this interface. When we compile our code, we obtain the following generated class:\n\n@RequestScoped @Generated(\"org.hibernate.processor.HibernateProcessor\") public class Library_ implements Library { protected @Nonnull StatelessSession session; public Library_(@Nonnull StatelessSession session) { this.session = session; } public @Nonnull StatelessSession session() { return session; } @PersistenceUnit private EntityManagerFactory sessionFactory; @PostConstruct private void openSession() { session = sessionFactory.unwrap(SessionFactory.class).openStatelessSession(); } @PreDestroy private void closeSession() { session.close(); } @Inject Library_() { } }\n\nAs you can see, this is an injectable CDI bean, which makes use of a Hibernate StatelessSession to interact with the database. You may obtain an instance from CDI using:\n\n@Inject Library library;\n\nOn the other hand, if you don’t have CDI available in your environment, no problem, HibernateProcessor will generate simpler code without any dependence on CDI. And you always have the option to instantiate the repository using new:\n\nLibrary library = new Library_(sessionFactory.openStatelessSession());\n\nIf we need to get direct access to the StatelessSession underling Library, we can just add a method like this:\n\n@Repository public interface Library { StatelessSession session(); }\n\nThis method is especially useful when our repository interface has default methods we’re going to implement by hand.\n\nI should mention that Library_ wasn’t the only class generated when we compiled our code. We also obtained:\n\nJakarta Persistence static metamodel classes Author_ and Book_, along with\n\nJakarta Data static metamodel classes _Author and _Book.\n\nLet’s hope the Jakarta platform never needs to introduce a third persistence API, because we’ve just run out of locations we can put an underscore.\n\nSo far, our repository doesn’t have any useful operations.\n\nA lifecycle method is indicated by an annotation. In Jakarta Data 1.0, there are four lifecycle annotations, and the first three have names matching the operations of StatelessSession:\n\n@Repository public interface Library { @Insert void addToCollection(Book book); @Delete void removeFromCollection(Book book); @Insert void newAuthor(Author author); @Update void updateAuthor(Author author); }\n\nCompiling this code produces implementations in Library_, including the following method:\n\n@Override public void addToCollection(Book book) { if (book == null) throw new IllegalArgumentException(\"Null book\"); try { session.insert(book); } catch (EntityExistsException exception) { throw new jakarta.data.ex.EntityExistsException(exception); } catch (PersistenceException exception) { throw new DataException(exception); } }\n\nI think you’ll agree that this code is easy to understand and debug.\n\nI said there were four lifecycle annotations in Jakarta Data 1.0, but I’ve only shown you three of them. Here’s the fourth:\n\n@Save void addOrUpdate(Book book);\n\nNow, “save” here has absolutely nothing to do with a legacy (and deprecated) method with a similar name on Hibernate’s Session interface. It actually results in a SQL merge statement. Here’s the generated implementation.\n\n@Override public void addOrUpdate(Book book) { if (book == null) throw new IllegalArgumentException(\"Null book\"); try { session.upsert(book); } catch (OptimisticLockException exception) { throw new OptimisticLockingFailureException(exception); } catch (PersistenceException exception) { throw new DataException(exception); } }\n\nThat’s right, @Save maps to upsert(). Nice, huh?\n\nWell, now it’s time to break the bad news, at least if you’re a fan of JPA-style stateful persistence contexts. You might already be yelling at the screen wanting to know why there’s no @Persist, @Merge, @Refresh, @Lock, and @Remove annotations mapping to the standard operations of a JPA EntityManager. The answer is simply that they’re not in Jakarta Data 1.0, but they’re almost certainly coming later. Repositories in Jakarta Data are stateless, at least for now.\n\nAn astute observer will have already noticed that Jakarta Data lifecycle methods offer no advantage compared to just calling the equivalent methods of StatelessSession directly. But that’s because lifecycle methods are boring. What we really care about are queries.\n\nAn automatic query method is the simplest method ever devised to express a query for an entity. The parameters of the method express the query conditions. Let’s consider the simplest possible example:\n\n@Find Book book(String isbn);\n\nThat’s it, that’s the query.\n\nThis query retrieves the Book with the given isbn. Jakarta Data uses the name of the method parameter to identify the field we’re using to restrict the query results.\n\nAt this point, you’re sure I’m lying to you, and that there’s no way this ridiculous “query” is type safe. But you’re wrong:\n\nThis is better than whatever DAO-style repository framework you’re using today, and it’s not even close. Quite soon, IntelliJ itself will report these errors as you’re typing, without even needing to call the annotation processor.\n\nAutomatic queries can get quite a lot more interesting. This one is sort of medium-level interesting:\n\n@Find List<Book> booksByTitle(@Pattern String title, Type type, Order<Book> order, Limit limit);\n\nWe’re not going any further down this path today, because I have something even better to tell you about. I should, however, show you the generated code for the methods we’ve just seen.\n\nFor our first example, HibernateProcessor recognized that isbn is the primary key of Book, and generated this code:\n\n@Override public Book book(String isbn) { if (isbn == null) throw new IllegalArgumentException(\"Null isbn\"); try { return session.get(Book.class, isbn); } catch (NoResultException exception) { throw new EmptyResultException(exception); } catch (NonUniqueResultException exception) { throw new jakarta.data.ex.NonUniqueResultException(exception); } catch (PersistenceException exception) { throw new DataException(exception); } }\n\nFor the second “medium interesting” example, we obtain:\n\n@Override public List<Book> booksByTitle(String title, Type type, Order<Book> order, Limit limit) { if (type == null) throw new IllegalArgumentException(\"Null type\"); var _builder = session.getFactory().getCriteriaBuilder(); var _query = _builder.createQuery(Book.class); var _entity = _query.from(Book.class); _query.where( title==null ? _entity.get(Book_.title).isNull() : _builder.like(_entity.get(Book_.title), title), _builder.equal(_entity.get(Book_.type), type) ); var _orders = new ArrayList<Order<? super Book>>(); for (var _sort : order.sorts()) { _orders.add(by(Book.class, _sort.property(), _sort.isAscending() ? ASCENDING : DESCENDING, _sort.ignoreCase())); } try { return session.createSelectionQuery(_query) .setFirstResult((int) limit.startAt() - 1) .setMaxResults(limit.maxResults()) .setOrder(_orders) .getResultList(); } catch (PersistenceException exception) { throw new DataException(exception); } }\n\nThis might appear a little scary at first glance, but if you know the JPA CriteriaQuery API, you’ll quickly make sense of it. Notice that even the generated implementation of this method is completely statically type safe.\n\nAn annotated query method is one where the query is expressed in a language like Jakarta Data Query Language (JDQL), Jakarta Persistence Query Language (JPQL), or native SQL. JDQL is a strict subset of JPQL, and so Hibernate supports all three of these options.\n\nThe @Query annotation lets us specify a query written in JDQL or JPQL:\n\n@Query(\"select b \" + \"from Book b join b.authors a \" + \"where a.name = :authorName \" + \"order by a.ssn, b.isbn\") List<Book> booksBy(String authorName);\n\nAlright, so this time you’ve got me for sure. There’s no way that horrible string is type safe! Everyone here knows how queries embedded in Java strings work.\n\nWrong again:\n\nYes, that’s right: HibernateProcessor not only syntax-checks your query at compile time, it also type-checks the whole query! Some pretty sophisticated machinery underlies this, machinery it’s taken us years to build.\n\nBut the folks at JetBrains also have some pretty sweet machinery, and IntelliJ will also be able to do it very soon:\n\nTo achieve greater type safety, people sometimes advocate the use of convoluted, barely-readable internal DSLs like CriteriaQuery (which I had a hand in designing, so please don’t take offense at those adjectives), or JOOQ, or whatever. I now consider this approach obsolete. JPQL is far more readable than criteria queries.\n\nNow, sure, an internal DSL is still nice when we really need to build a query dynamically. (Future versions of Jakarta Data will have a nice way to partially address that problem too!) So CriteriaQuery ain’t dead quite yet.\n\nOh, right, before I forget: the generated code. By now you can probably guess it:\n\n@Override public List<Book> booksBy(String authorName) { try { return session.createSelectionQuery(BOOKS_BY_String, Book.class) .setParameter(\"authorName\", authorName) .getResultList(); } catch (PersistenceException exception) { throw new DataException(exception); } }\n\nOf course, there’s much more I could say about JDQL and about query methods in general. A particularly interesting topic—which I’ll leave for a future post—is offset-based and key-based (or “keyset”) pagination."
    }
}