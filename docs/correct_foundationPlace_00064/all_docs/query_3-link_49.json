{
    "id": "correct_foundationPlace_00064_3",
    "rank": 49,
    "data": {
        "url": "https://docs.pact.io/implementation_guides/jvm/consumer",
        "read_more_link": "",
        "language": "en",
        "title": "Pact consumer",
        "top_image": "https://docs.pact.io/img/docusaurus.png",
        "meta_img": "https://docs.pact.io/img/docusaurus.png",
        "images": [
            "https://docs.pact.io/img/favicon.ico",
            "https://docs.pact.io/img/favicon.ico",
            "https://docs.pact.io/img/favicon.ico"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2023-03-23T16:46:54+00:00",
        "summary": "",
        "meta_description": "Pact Consumer is used by projects that are consumers of an API.",
        "meta_lang": "en",
        "meta_favicon": "/img/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://docs.pact.io/implementation_guides/jvm/consumer",
        "text": "Pact Consumer is used by projects that are consumers of an API.\n\nMost projects will want to use pact-consumer via one of the test framework specific projects. If your favourite framework is not implemented, this module should give you all the hooks you need.\n\nProvides a DSL for use with Java to build consumer pacts.\n\nThe library is available on maven central using:\n\ngroup-id = au.com.dius.pact\n\nartifact-id = consumer\n\nversion-id = 4.4.x\n\nExample in a JUnit test:\n\nThe DSL has the following pattern:\n\nYou can define as many interactions as required. Each interaction starts with uponReceiving followed by willRespondWith. The test state setup with given is a mechanism to describe what the state of the provider should be in before the provider is verified. It is only recorded in the consumer tests and used by the provider verification tasks.\n\nThe body method of the ConsumerPactBuilder can accept a PactDslJsonBody, which can construct a JSON body as well as define regex and type matchers.\n\nFor example:\n\nThe following matching methods are provided with the DSL. In most cases, they take an optional value parameter which will be used to generate example values (i.e. when returning a mock response). If no example value is given, a random one will be generated.\n\nmethoddescriptionstring, stringValueMatch a string value (using string equality)number, numberValueMatch a number value (using Number.equals) *booleanValueMatch a boolean value (using equality)stringTypeWill match all StringsnumberTypeWill match all numbers *integerTypeWill match all numbers that are integers (both ints and longs) *decimalTypeWill match all real numbers (floating point and decimal) *booleanTypeWill match all boolean values (true and false)stringMatcherWill match strings using the provided regular expressiontimestampWill match string containing timestamps. If a timestamp format is not given, will match an ISO timestamp formatdateWill match string containing dates. If a date format is not given, will match an ISO date formattimeWill match string containing times. If a time format is not given, will match an ISO time formatipAddressWill match string containing IP4 formatted address.idWill match all numbers by typehexValueWill match all hexadecimal encoded stringsuuidWill match strings containing UUIDsincludesStrWill match strings containing the provided stringequalsToWill match using equalsmatchUrlDefines a matcher for URLs, given the base URL path and a sequence of path fragments. The path fragments could be strings or regular expression matchersnullValueMatches the JSON Null value\n\n* Note: JSON only supports double precision floating point values. Depending on the language implementation, they may be parsed as integer, floating point or decimal numbers.\n\nLots of the time you might not know the number of items that will be in a list, but you want to ensure that the list has a minimum or maximum size and that each item in the list matches a given example. You can do this with the arrayLike, minArrayLike and maxArrayLike functions.\n\nfunctiondescriptioneachLikeEnsure that each item in the list matches the provided examplemaxArrayLikeEnsure that each item in the list matches the provided example and the list is no bigger than the provided maxminArrayLikeEnsure that each item in the list matches the provided example and the list is no smaller than the provided min\n\nFor example:\n\nThis will ensure that the users list is never empty and that each user has an identifier that is a number and a name that is a string.\n\nIf the order of the list items is not known, you can use the unorderedArray matcher functions. These will match the actual list against the expected one, except will match the items in any order.\n\nfunctiondescriptionunorderedArrayEnsure that the list matches the provided example, ignoring the orderunorderedMinArrayEnsure that the list matches the provided example and the list is not smaller than the provided minunorderedMaxArrayEnsure that the list matches the provided example and the list is no bigger than the provided maxunorderedMinMaxArrayEnsure that the list matches the provided example and the list is constrained to the provided min and max\n\nThe array contains matcher functions allow you to match the actual list against a list of required variants. These work by matching each item against the variants, and the matching succeeds if each variant matches at least one item. Order of items in the list is not important.\n\nThe variants can have a totally different structure, and can have their own matching rules to apply. For an example of how these can be used to match a hypermedia format like Siren, see Example Pact + Siren project.\n\nfunctiondescriptionarrayContainingMatches the items in an array against a number of variants. Matching is successful if each variant occurs once in the array. Variants may be objects containing matching rules.\n\nFor cases where you are expecting basic JSON values (strings, numbers, booleans and null) at the root level of the body and need to use matchers, you can use the PactDslJsonRootValue class. It has all the DSL matching methods for basic values that you can use.\n\nFor example:\n\nIf the root of the body is an array, you can create PactDslJsonArray classes with the following methods:\n\nfunctiondescriptionarrayEachLikeEnsure that each item in the list matches the provided examplearrayMaxLikeEnsure that each item in the list matches the provided example and the list is no bigger than the provided maxarrayMinLikeEnsure that each item in the list matches the provided example and the list is no smaller than the provided min\n\nFor example:\n\nThis will then match a body like:\n\nFor the case where you have arrays of arrays (GeoJSON is an example), the following methods have been provided:\n\nfunctiondescriptioneachArrayLikeEnsure that each item in the array is an array that matches the provided exampleeachArrayWithMaxLikeEnsure that each item in the array is an array that matches the provided example and the array is no bigger than the provided maxeachArrayWithMinLikeEnsure that each item in the array is an array that matches the provided example and the array is no smaller than the provided min\n\nFor example (with GeoJSON structure):\n\nThis generated the following JSON:\n\nand will be able to match all coordinates regardless of the number of coordinates.\n\nThe DSL has been extended for cases where the keys in a map are IDs. For an example of this, see #313. In this case you can use the eachKeyLike method, which takes an example key as a parameter.\n\nFor example:\n\nFor an example, have a look at ArticlesTest.\n\nYou can use regular expressions to match incoming requests. The DSL has a matchPath method for this. You can provide a real path as a second value to use when generating requests, and if you leave it out it will generate a random one from the regular expression.\n\nFor example:\n\nYou can use regular expressions to match request and response headers. The DSL has a matchHeader method for this. You can provide an example header value to use when generating requests and responses, and if you leave it out it will generate a random one from the regular expression.\n\nFor example:\n\nYou can use regular expressions to match request query parameters. The DSL has a matchQuery method for this. You can provide an example value to use when generating requests, and if you leave it out it will generate a random one from the regular expression.\n\nFor example:\n\nForcing pact files to be overwritten\n\nBy default, when the pact file is written, it will be merged with any existing pact file. To force the file to be overwritten, set the Java system property pact.writer.overwrite to true.\n\nHaving values injected from provider state callbacks\n\nYou can have values from the provider state callbacks be injected into most places (paths, query parameters, headers, bodies, etc.). This works by using the V3 spec generators with provider state callbacks that return values. One example of where this would be useful is API calls that require an ID which would be auto-generated by the database on the provider side, so there is no way to know what the ID would be beforehand.\n\nThe following DSL methods allow you to set an expression that will be parsed with the values returned from the provider states:\n\nFor JSON bodies, use valueFromProviderState.\n\nFor headers, use headerFromProviderState.\n\nFor query parameters, use queryParameterFromProviderState.\n\nFor paths, use pathFromProviderState.\n\nFor example, assume that an API call is made to get the details of a user by ID. A provider state can be defined that specifies that the user must be exist, but the ID will be created when the user is created. So we can then define an expression for the path where the ID will be replaced with the value returned from the provider state callback.\n\nYou can also just use the key instead of an expression:\n\nA Lambda DSL for Pact\n\nThis is an extension for the pact DSL. The difference between the default pact DSL and this lambda DSL is, as the name suggests, the usage of lambdas. The use of lambdas makes the code much cleaner.\n\nThe lambda DSL solves the following two main issues. Both are visible in the following code sample:\n\nMethods may only be called in certain states. For example object() may only be called when you're currently working on an array whereas object(name) is only allowed to be called when working on an object. But both of the methods are available. You'll find out at runtime if you're using the correct method.\n\nFinally, the need for opening and closing objects and arrays makes usage cumbersome.\n\nThe lambda DSL has no ambiguous methods and there's no need to close objects and arrays as all the work on such an object is wrapped in a lamda call.\n\nWhen formatting your source code with an IDE the code becomes hard to read as there's no indentation possible. Of course, you could do it by hand but we want auto formatting! Auto formatting works great for the new DSL!\n\nStart with a static import of LambdaDsl. This class contains factory methods for the lambda dsl extension. When you come accross the body() method of PactDslWithProvider builder start using the new extensions. The call to LambdaDsl replaces the call to instance new PactDslJsonArray() and new PactDslJsonBody() of the pact library.\n\nWhen creating simple json structures the difference between the two approaches isn't big.\n\nWhen we come to more complex constructs with arrays and nested objects the beauty of lambdas become visible!\n\nAs each test will get a new mock server, connections can not be persisted between tests. HTTP clients can cache connections with HTTP/1.1, and this can cause subsequent tests to fail. See #342 and #1383."
    }
}