{
    "id": "correct_foundationPlace_00064_2",
    "rank": 65,
    "data": {
        "url": "https://fsharp.org/guides/enterprise/",
        "read_more_link": "",
        "language": "en",
        "title": "Guide - Enterprise Programming",
        "top_image": "https://fsharp.org/favicon-192x192.png",
        "meta_img": "https://fsharp.org/favicon-192x192.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "F#",
            "FSharp",
            "F# Programming"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon-57x57.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "F# is an excellent choice for enterprises.\n\nThe benefits of F# for enterprise development are:\n\nCompatibility - F# is completely integrated with the .NET platform and is a fully supported component of Visual Studio and JetBrains Rider. You can continue to use your favorite C# libraries and maintain your existing development processes.\n\nLow risk trials - It’s easier to learn F# than you might think. You can easily try out F# for non-critical development tasks such as testing and scripting without committing to wholesale change.\n\nFaster development time - F# code is generally three times shorter than C# code. And F# has many little conveniences that save coding time, such as very succinct type definitions, with immutability and equality by default.\n\nEasy data access - F# includes “type providers” that provide type-safe access to all kinds of data (SQL, CSV, JSON, XML).\n\nFewer errors, less maintenance - Many common errors, such as nulls or empty collections, are easily avoided in F#. F# classes cannot be null, exhaustive pattern matching means that edge cases are not overlooked, and units of measure can be used to avoid accidental mixups of incompatible numbers.\n\nF# code is engineered for testing - Functional programming does not use state and the logic tends to be linear, so it is very easy to test subsystems in isolation easily (using NUnit or your favorite test framework), and there are no tangled webs of dependencies. In addition, F# supports property-based testing with FsCheck.\n\nBetter domain modelling - F# has a powerful type system that can be used to model domains accurately. “Choice” types can model business cases more conveniently than inheritance, and business rules can be designed into the type system so that you get “compile-time unit tests”, eliminating the need for many tests that would otherwise have to be written by hand.\n\nTaming complexity - F# has a number of features to help you manage complexity and improve performance such as: a safer Async library, a built-in actor model that’s easier than using threads, safe parallelization with immutable data, and more.\n\nImproving developer morale - F# is a fun language to program in, and F# is a great way for developers to learn new skills that will improve their skills in other languages, such as C# and JavaScript.\n\nBenefits of F# for enterprise and line-of-business applications\n\nA tour of F# features\n\nLow risk ways to use F#\n\nF# for build automation\n\nF# for testing .NET systems\n\nFewer errors, less maintenance\n\nF# code is engineered for testing\n\nUsing F# for domain modelling\n\nData access and information-rich programming\n\nUsing F# type providers to access data\n\nUsing F# to analyze data\n\nTaming complexity\n\nAsynchronous programming in F#\n\nAgents and message queues\n\nDeveloper morale\n\nBenefits of F# for enterprise and line-of-business applications\n\nThe F# Way To Relaxation (video). A journey through the modern programming landscape and the F# approach to research, language design, interoperability, tooling and community.\n\nWhite paper: F# in the Enterprise\n\nMany of the F# testimonials are relevant to enterprise development.\n\nMany developers have posted on why they like F#:\n\nWhy am I so enthusiastic about F#?\n\nWhy F# for the Enterprise?\n\nWhy F#?\n\nA list of many other “Why F#” posts.\n\nA tour of F# features\n\nAn introduction to F# (video).\n\nWhy use F#?. This series of posts will give you a guided tour through the main features of F#.\n\nLow risk ways to use F#\n\nYou can easily try out F# for non-critical development tasks such as testing and scripting without committing to wholesale change.\n\nLow risk ways to use F#. This series suggests a number of ways you can use F# in a low-risk, incremental way, without affecting any mission critical code.\n\nF# for build automation\n\nScott Hanselman on FAKE. FAKE is a build system that uses F# as its scripting language, but can be used to build any .NET project.\n\nF# for testing .NET systems\n\nTesting .NET systems with F#\n\nF# As A Unit Testing Language.\n\nScott Hanselman on Canopy. Canopy is a web testing framework that uses F# as its scripting language.\n\nFewer errors, less maintenance\n\nMany common errors, such as nulls or empty collections, are easily avoided in F#. F# classes cannot be null, exhaustive pattern matching means that edge cases are not overlooked, and units of measure can be used to avoid accidental mixups of incompatible numbers.\n\nIt just works\n\nWhy You Must Learn F# - Even If You Aren’t Writing Rocket Science Apps\n\nF# code is engineered for testing\n\nFunctional programming does not use state and the logic tends to be linear, so it is very easy to test subsystems in isolation easily (using NUnit or your favorite test framework), and there are no tangled webs of dependencies.\n\nAlready Engineered for Testability\n\nAn introduction to property-based testing\n\nUsing F# for domain modelling\n\nF# has a powerful type system that can be used to model domains accurately. “Choice” types can model business cases more conveniently than inheritance, and business rules can be designed into the type system so that you get “compile-time unit tests”, eliminating the need for many tests that would otherwise have to be written by hand.\n\nDomain Modelling and DDD in F#. Slides and video demonstrating how the F# type system can encode business rules.\n\nF# for Trading video & slides. Demonstrates how to use F# to design a simple trading application.\n\nIf you are moving to CQRS and an event-sourcing approach, F# is a great choice for modelling this as well.\n\nDomain-Driven Design (DDD) With F# and EventStore\n\nData access and information-rich programming\n\nWe are entering a new information-rich world, one that provides huge opportunities for programmers to explore and create exciting applications. F# is a leader in this area.\n\nUsing F# type providers to access data\n\nF# type providers allow you to talk directly to data, combining the power of dynamic code generation, the safety of static types, and the ease of use of intellisense.\n\nThe standard type providers include:\n\nXML type provider\n\nJSON type provider\n\nSQL type provider.\n\nAccessing loosely structured data from F# and C#\n\nUsing F# to analyze data\n\nF# also has powerful tools to analyze and process data, such as Deedle (for data and time series manipulation) and the R type provider which makes it possible to use all of R’s capabilities from the F# interactive environment, including on-the-fly charting and data analysis.\n\nInformation Rich Programming in F# (video).\n\nHow F# Learned to Stop Worrying and Love the Data and Understanding the World with F# (video). In these demos, you’ll learn how to acquire and understand data with F#. You’ll see how to analyze the survival rate of Titanic passengers, how to correlate different indicators about countries in the world and how to link US debt data with information about US presidents and visualize the results.\n\nTaming complexity\n\nF# has a number of features to help you manage complexity and improve performance such as: a safer Async library, a built-in actor model that’s easier than using threads, safe parallelization with immutable data, and more.\n\nAsynchronous programming in F#\n\nAsync in C# and F#: An introduction\n\nAsync in C# and F#: Asynchronous gotchas in C#. Why the F# async library is safer than the C# one.\n\nWriting non-blocking user-interfaces in F#\n\nAsynchronous programming: another introduction\n\nAgents and message queues\n\nAn Introduction To F# Agents\n\nAgents. Another introduction\n\nDeveloper morale\n\nLearning functional programming (via F#) is a lot of fun, and will make your team happier. Yes, you can’t have fun all the time. But if you are enjoying yourself, then you are more likely to go the extra mile when needed.\n\nWhat’s more, using F# may help you attract talented developers. After all, wouldn’t you want to work with people who are having fun?"
    }
}