{
    "id": "correct_foundationPlace_00064_3",
    "rank": 61,
    "data": {
        "url": "https://users.rust-lang.org/t/anyone-here-go-intellij-vscode/84499",
        "read_more_link": "",
        "language": "en",
        "title": "Anyone here go IntelliJ -> VSCode?",
        "top_image": "https://global.discourse-cdn.com/business5/uploads/rust_lang/original/2X/8/83e41956eccfd67ad6ff76f15a2c22e58db31d4f.svg",
        "meta_img": "https://global.discourse-cdn.com/business5/uploads/rust_lang/original/2X/8/83e41956eccfd67ad6ff76f15a2c22e58db31d4f.svg",
        "images": [
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/vorfeedcanal/48/22432_2.png",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/vorfeedcanal/48/22432_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/vorfeedcanal/48/22432_2.png",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/vorfeedcanal/48/22432_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/vorfeedcanal/48/22432_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/afetisov/48/22736_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://emoji.discourse-cdn.com/twitter/slight_smile.png?v=12",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png",
            "https://sea1.discourse-cdn.com/business5/user_avatar/users.rust-lang.org/zicog/48/12216_2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "system Closed"
        ],
        "publish_date": "2022-11-18T09:16:28+00:00",
        "summary": "",
        "meta_description": "For those who went IntelliJ -&gt; VSCode and stuck with VSCode, what made it stick for you? \nEvery now and then, I get tempted to switch from IntelliJ to VSCode, but it never quite sticks for me -- I end up going back to In&hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://global.discourse-cdn.com/business5/uploads/rust_lang/optimized/2X/e/e011218794dba02ebb2b368fd9b831f5585caffe_2_32x32.ico",
        "meta_site_name": "The Rust Programming Language Forum",
        "canonical_link": "https://users.rust-lang.org/t/anyone-here-go-intellij-vscode/84499",
        "text": "Cost. I'm mostly quite positive about paying for software, but after a huge income drop, the All Products Pack was more than I could afford. The IntelliJ Community Edition does much but not all, and I prefer where possible to use one editor for everything. I moved to VSCode exclusively for a couple of years and found it IntelliJ's equal in most areas. I think the path was smoothed for me by the fact that I use vi keybindings everywhere they're available. I suspect if I were still doing any Java I might have found it harder to switch.\n\nPersonally I think that if a language is so complex and it's libraries so tortuous to use that you need an all singing all dancing IDE to deal with it all something has gone wrong with the language and libraries. I'm old school, brought up on BASIC and assembler.\n\nHowever, here we are. VS Code and rust-analyser work a treat. What more do I need?\n\nOften I just use vim with nothing more than a syntax highlighter installed.\n\nIt understands the java AST, so a 'rename' (the simplest example) is of a method or class or other semantic entity, not a string. You can extract a method, or pull a method up (to a superclass) without manually editing multiple sites.\n\nThat just isn't how much (actually I'm pretty sure most) code is written. You might think it 'should' be, but if (for example) you're running a small consultancy and you insist on a year up front to design a system, and refuse the daily sales-driven changes demanded of you, you'll be out of business in a week.\n\nYou are very lucky if you can finish writing code and your employer is happy. This means that you have clear definition of what your code have to do. That's extreme rarity today.\n\nMost of the code is written for people and people are finicky. They couldn't explain what they want and what they would like and/or dislike.\n\nThat, in turn, means that no code can ever be finished. Simply because requirements change all the time. Even if you would manage, somehow, to write code which solves a given task perfectly… it would still return tomorrow with request to change something.\n\nRefactoring is, indeed, not that important if you have stable criteria which your project have to satisfy. But I'm really surprised such things things exist today. Couldn't even imagine what kinda of devices you write code for that they don't change all the time.\n\nEven TI Calculators which looked as if they stuck in XX century today are changing! TI-83 went from 8bit, single-CPU device to 24bit + 32bit dual CPU device. I would expect there was significant amount of refactoring in that gradual move.\n\nRefactoring isn't just about dealing with changing requirements, although it sure helps with code maintenance over time. When I use an IDE, I rely on refactorings everywhere, regardless of the type of project and the language. Even if I write a one-off script, or edit a config file, I will use refactorings if available. They are a way to reliably automate simple common transformations.\n\nSure, you can do all that by hand, but that's slower and more error-prone. The friction would be high enough that most larger scale transformations would never be done, even if nothing technically prevents them. I don't need to get all my variable of function names right the first time, I don't need to care too much about factoring functions or data types, or which style to write code in (e.g. for loop vs iterator chains, or the amount of intermediate variables). I can write the first draft in a quick and dirty way, thinking about the domain problems and not surface code organization, and once I'm done, I can easily beat the code up into shape using refactorings. Some expression looks too complex? Extract more variables. Some naming is off? Change it, as often as you like. Thinking that a function is too long or does too much stuff? Extract parts of it into separate functions.\n\nYou can grep for a name if you want to change it or find all usages, but you would have to sift through entirely irrelevant results (e.g. fields, functions and local variables with the same name), and you can make mistakes if you misunderstand the context and get the types wrong. It's a lot of work, and on a huge codebase it's often unreasonably hard to do manually. An IDE, on the other hand, already has all your code indexed and all types inferred. You can ask it, and get exactly the relevant results, and nothing else.\n\nA high-quality IDE frees you from dealing with irrelevant minutes of coding, and allows to focus on the important tasks: domain logic, public API, architecture, algorithms.\n\nNow a days I am my own employer, so I'm happy [1]\n\nSo I understand.\n\nPresumably there are limits to this infinite flexibility in the face of ever changing requirements, otherwise one would not even know what direction to start out in and ones code would have to accommodate every possible unknown twist and turn in the future. I am by nature or experience leaning toward the more directed, rigid end of the spectrum. Otherwise I could never get anything done. We don't have any clients who are willing to pay forever for their endlessly changing requirements. Might be sweet if we did\n\nBack in the day I worked on such things as the Boeing 777 Primary Flight Computers, Rolls-Royce jet engine management, military phased array radar and secure communications systems, process control systems... These things are rigorously specified, largely dependent on the hardware they live in, subject to stringent safety standards. They are not going to be changing very quickly if ever (save bug fixes). Any change becomes a whole new, lengthy, project in itself. I guess we are still making stuff like that somewhere [2]\n\nI wonder about those calculators. I imagine software for the early ones was written in assembler. Also that the later ones are using a high-level language, say C. That is not a refactoring that is a total rewrite. I have been involved in such migrations from 8 bit to 16/32 bit projects. Assembler to HLL. It's interesting to figure out what the assembler does and recreate it, given there is no documentation an almost no comments in the code!\n\nActually, I'm pretty much never happy with my own code. Always something I'd like to improve on if there were time. At least with Rust I can be a lot more confident the thing is robust and correct if I can make the compiler happy. The compiler is my boss!\n\nSeems Boeing became more \"agile\" in their approach. Judging by the troubles they have been having in recent years.\n\nWhat you describe does indeed sound useful.\n\nI guess my problem is having tried to use low quality IDEs in the past:\n\nVisual Studio - Seems to get in the way all the time. Had it's own build/project system that was no use for the embedded code I was writing. Was not cross-platform (is it now?)\n\nEclipse - Bloated, slow and confusing. Always a pain to get it to actually work in the first place (Maybe that is better now a days).\n\nQuartus - Bloated, slow and confusing (it's based on Eclipse).\n\nVarious other IDE's from micro-controller vendors. Always seemed to end up with some kind of lock in to their product.\n\nIs IntelliJ that long lost \"high quality\" IDE I have been missing? Have the others improved since I last looked?\n\nWith VS Code and others, it looks like the dividing line between editor and IDE has become very blurred.\n\nWhilst I have always been nervous of refactoring due to the huge possibility of introducing errors I'm much more relaxed when dicing and splicing Rust code. The compiler pretty much won't let me mess things up. Do I still need that all singing all dancing refactoring tool for Rust?\n\nWhy do you think “enterprise programming”, all these factory factory factory systems were invented?\n\nIt's also why so many people who try to learn Rust rush to create “soup of pointers” designs. They are teached to not even think about design because it would be wrong, anyway, thus you can just start, cobble something together and iterate while customer is willing to pay.\n\nNot as sweet as you think. Simply because when changes are driven by desires, not needs “pay forever” becomes “pay till nearest serious crisis”. Thus you have steady, often abundant, income when economy is booming yet tend to lose when depressions starts (like… right now).\n\nMaybe, but I'm no longer sure. If the process would have followed 737 MAX fiasco would have never happened. It was precisely do what others (like Apple in Macbooks or Samsung in phones) are doing: paper of the hardware deficiency with software patch.\n\nI don't think so. Why do you think they went with weird 24bit CPU of 2001 year design for 2015 year refresh? It's because you can use more memory (new model have 256KB when old one had 24KB) yet still retain these old assembler programs. There were intermediate models with old 8bit CPU, but color screen and 128KB RAM, but 15Hz CPU turned out to be too underpowered for “large” 320x240 color screen. And before that they successfully added USB-OTG to that old design. And yes, it's pretty complete, one, you can use it with USB stick if you use third-party programs.\n\nNo, no, no! Rewrite also happened, actually it happened twice, once with TI-92 which used 68k 16/32bit CPU and later TI-Nspire with 32bit ARM. Both proved to be much less popular than refactored versions of that XX century design. Of course constant refectorings meant not just new features, but also new bugs thus they switched from mask rom to flash rom in the end of XX century, but they absolutely continued to use that old ASM-based thingie because they had no choice! Even TI-Basic have substantially different dialects on these three different branches and the original ones are by far the most popular.\n\nThey added 2nd, 32 bit CPU, because, apparently no one wanted to write Python interpreter on assembler for two decades old dead-end architecture. And it was literally added to that calculator by attaching small box to it.\n\nThey faced the exact same dilemma TI did. Customer have come to them and said:\n\nWe know there are these new things available (color screen and python for calculators, new, more frugal engines for the Boeing)\n\nWe have tons of manual, training centers, trained teachers and trained professionals. You have too, 100%, ensure all that would stay valid after upgrade.\n\nNot do you achieve that without refactorings?\n\nNo, but Visual Studio Code is cross-platform and you can even used with Rust.\n\nVisual Studio Code is happy to pick compilers from Visual Studio.\n\nI don't see where you have looked on something not C or C++ based. Refactorings in C and C++ would always be flaky and dangerous because C type system is just so inherently weak and C++ doesn't have strong typing in their metalanguage, it's duck-typing all the way from the bottom to the top.\n\nYou can not build reliable tools on that foundation. CLion is decent, but it definitely is weaker than most Java or C# based tools. And I'm sure Rust-based tools would soon be better than CLion's offers.\n\nYou never need them in any language. But in language like Rust there's hope that refactoring tools would actually work (except when you are using proc_macros because these can do so many crazy things).\n\nrust-analyser. I actually dislike-to-hate quite a few aspects of VSCode compared to Intellij/CLion, but... I don't know what state the Rust plugin is right now, but a year and a half ago when i switched it was underwhelming at best.\n\nThings like not highlighting issues check/clippy would, or erroring out on the perfectly valid code for some reason (or, for almost a year, sometimes failing to see certain modules in dependencies,so they won't show up in suggestions and any code using them was automatically marked invalid, even though it compiled and worked fine), so before switching i basically had to have a terminal window with cargo check running in parallel with the IDE just so i could see the sane output, which kind of defeated the point of using an IDE to begin with...\n\nP.S. Plus, remoting over SSH inside an IDE, so i can compile, check and run my project on my server, while editing code on my underpowered thin laptop but still getting all the benefits of a language server is rather neat."
    }
}