{
    "id": "correct_foundationPlace_00064_3",
    "rank": 21,
    "data": {
        "url": "https://kotlinlang.org/docs/coding-conventions.html",
        "read_more_link": "",
        "language": "en",
        "title": "Coding conventions | Kotlin",
        "top_image": "https://kotlinlang.org/assets/images/open-graph/docs.png",
        "meta_img": "https://kotlinlang.org/assets/images/open-graph/docs.png",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://kotlinlang.org/assets/images/favicon.svg?v2",
        "meta_site_name": "Kotlin Help",
        "canonical_link": "https://kotlinlang.org/docs/coding-conventions.html",
        "text": "Coding conventions\n\nCommonly known and easy-to-follow coding conventions are vital for any programming language. Here we provide guidelines on the code style and code organization for projects that use Kotlin.\n\nConfigure style in IDE\n\nTwo most popular IDEs for Kotlin - IntelliJ IDEA and Android Studio provide powerful support for code styling. You can configure them to automatically format your code in consistence with the given code style.\n\nApply the style guide\n\nGo to Settings/Preferences | Editor | Code Style | Kotlin.\n\nClick Set from....\n\nSelect Kotlin style guide.\n\nVerify that your code follows the style guide\n\nGo to Settings/Preferences | Editor | Inspections | General.\n\nSwitch on Incorrect formatting inspection. Additional inspections that verify other issues described in the style guide (such as naming conventions) are enabled by default.\n\nSource code organization\n\nDirectory structure\n\nIn pure Kotlin projects, the recommended directory structure follows the package structure with the common root package omitted. For example, if all the code in the project is in the org.example.kotlin package and its subpackages, files with the org.example.kotlin package should be placed directly under the source root, and files in org.example.kotlin.network.socket should be in the network/socket subdirectory of the source root.\n\nSource file names\n\nIf a Kotlin file contains a single class or interface (potentially with related top-level declarations), its name should be the same as the name of the class, with the .kt extension appended. It applies to all types of classes and interfaces. If a file contains multiple classes, or only top-level declarations, choose a name describing what the file contains, and name the file accordingly. Use an upper camel case with an uppercase first letter (also known as Pascal case), for example, ProcessDeclarations.kt.\n\nThe name of the file should describe what the code in the file does. Therefore, you should avoid using meaningless words such as Util in file names.\n\nMultiplatform projects\n\nIn multiplatform projects, files with top-level declarations in platform-specific source sets should have a suffix associated with the name of the source set. For example:\n\njvmMain/kotlin/Platform.jvm.kt\n\nandroidMain/kotlin/Platform.android.kt\n\niosMain/kotlin/Platform.ios.kt\n\nAs for the common source set, files with top-level declarations should not have a suffix. For example, commonMain/kotlin/Platform.kt.\n\nTechnical details\n\nWe recommend following this file naming scheme in multiplatform projects due to JVM limitations: it doesn't allow top-level members (functions, properties).\n\nTo work around this, the Kotlin JVM compiler creates wrapper classes (so-called \"file facades\") that contain top-level member declarations. File facades have an internal name derived from the file name.\n\nIn turn, JVM doesn't allow several classes with the same fully qualified name (FQN). This might lead to situations when a Kotlin project cannot be compiled to JVM:\n\nroot |- commonMain/kotlin/myPackage/Platform.kt // contains 'fun count() { }' |- jvmMain/kotlin/myPackage/Platform.kt // contains 'fun multiply() { }'\n\nHere both Platform.kt files are in the same package, so the Kotlin JVM compiler produces two file facades, both of which have FQN myPackage.PlatformKt. This produces the \"Duplicate JVM classes\" error.\n\nThe simplest way to avoid that is renaming one of the files according to the guideline above. This naming scheme helps avoid clashes while retaining code readability.\n\nSource file organization\n\nPlacing multiple declarations (classes, top-level functions or properties) in the same Kotlin source file is encouraged as long as these declarations are closely related to each other semantically, and the file size remains reasonable (not exceeding a few hundred lines).\n\nIn particular, when defining extension functions for a class which are relevant for all clients of this class, put them in the same file with the class itself. When defining extension functions that make sense only for a specific client, put them next to the code of that client. Avoid creating files just to hold all extensions of some class.\n\nClass layout\n\nThe contents of a class should go in the following order:\n\nProperty declarations and initializer blocks\n\nSecondary constructors\n\nMethod declarations\n\nCompanion object\n\nDo not sort the method declarations alphabetically or by visibility, and do not separate regular methods from extension methods. Instead, put related stuff together, so that someone reading the class from top to bottom can follow the logic of what's happening. Choose an order (either higher-level stuff first, or vice versa) and stick to it.\n\nPut nested classes next to the code that uses those classes. If the classes are intended to be used externally and aren't referenced inside the class, put them in the end, after the companion object.\n\nInterface implementation layout\n\nWhen implementing an interface, keep the implementing members in the same order as members of the interface (if necessary, interspersed with additional private methods used for the implementation).\n\nOverload layout\n\nAlways put overloads next to each other in a class.\n\nNaming rules\n\nPackage and class naming rules in Kotlin are quite simple:\n\nNames of packages are always lowercase and do not use underscores (org.example.project). Using multi-word names is generally discouraged, but if you do need to use multiple words, you can either just concatenate them together or use the camel case (org.example.myProject).\n\nNames of classes and objects start with an uppercase letter and use the camel case:\n\nopen class DeclarationProcessor { /*...*/ } object EmptyDeclarationProcessor : DeclarationProcessor() { /*...*/ }\n\nFunction names\n\nNames of functions, properties and local variables start with a lowercase letter and use the camel case and no underscores:\n\nfun processDeclarations() { /*...*/ } var declarationCount = 1\n\nException: factory functions used to create instances of classes can have the same name as the abstract return type:\n\ninterface Foo { /*...*/ } class FooImpl : Foo { /*...*/ } fun Foo(): Foo { return FooImpl() }\n\nNames for test methods\n\nIn tests (and only in tests), you can use method names with spaces enclosed in backticks. Note that such method names are only supported by Android runtime from API level 30. Underscores in method names are also allowed in test code.\n\nclass MyTestCase { @Test fun `ensure everything works`() { /*...*/ } @Test fun ensureEverythingWorks_onAndroid() { /*...*/ } }\n\nProperty names\n\nNames of constants (properties marked with const, or top-level or object val properties with no custom get function that hold deeply immutable data) should use uppercase underscore-separated (screaming snake case) names:\n\nconst val MAX_COUNT = 8 val USER_NAME_FIELD = \"UserName\"\n\nNames of top-level or object properties which hold objects with behavior or mutable data should use camel case names:\n\nval mutableCollection: MutableSet<String> = HashSet()\n\nNames of properties holding references to singleton objects can use the same naming style as object declarations:\n\nval PersonComparator: Comparator<Person> = /*...*/\n\nFor enum constants, it's OK to use either uppercase underscore-separated names (screaming snake case) (enum class Color { RED, GREEN }) or upper camel case names, depending on the usage.\n\nNames for backing properties\n\nIf a class has two properties which are conceptually the same but one is part of a public API and another is an implementation detail, use an underscore as the prefix for the name of the private property:\n\nclass C { private val _elementList = mutableListOf<Element>() val elementList: List<Element> get() = _elementList }\n\nChoose good names\n\nThe name of a class is usually a noun or a noun phrase explaining what the class is: List, PersonReader.\n\nThe name of a method is usually a verb or a verb phrase saying what the method does: close, readPersons. The name should also suggest if the method is mutating the object or returning a new one. For instance sort is sorting a collection in place, while sorted is returning a sorted copy of the collection.\n\nThe names should make it clear what the purpose of the entity is, so it's best to avoid using meaningless words (Manager, Wrapper) in names.\n\nWhen using an acronym as part of a declaration name, capitalize it if it consists of two letters (IOStream); capitalize only the first letter if it is longer (XmlFormatter, HttpInputStream).\n\nFormatting\n\nIndentation\n\nUse four spaces for indentation. Do not use tabs.\n\nFor curly braces, put the opening brace at the end of the line where the construct begins, and the closing brace on a separate line aligned horizontally with the opening construct.\n\nif (elements != null) { for (element in elements) { // ... } }\n\nHorizontal whitespace\n\nPut spaces around binary operators (a + b). Exception: don't put spaces around the \"range to\" operator (0..i).\n\nDo not put spaces around unary operators (a++).\n\nPut spaces between control flow keywords (if, when, for, and while) and the corresponding opening parenthesis.\n\nDo not put a space before an opening parenthesis in a primary constructor declaration, method declaration or method call.\n\nclass A(val x: Int) fun foo(x: Int) { ... } fun bar() { foo(1) }\n\nNever put a space after (, [, or before ], )\n\nNever put a space around . or ?.: foo.bar().filter { it > 2 }.joinToString(), foo?.bar()\n\nPut a space after //: // This is a comment\n\nDo not put spaces around angle brackets used to specify type parameters: class Map<K, V> { ... }\n\nDo not put spaces around ::: Foo::class, String::length\n\nDo not put a space before ? used to mark a nullable type: String?\n\nAs a general rule, avoid horizontal alignment of any kind. Renaming an identifier to a name with a different length should not affect the formatting of either the declaration or any of the usages.\n\nColon\n\nPut a space before : in the following cases:\n\nwhen it's used to separate a type and a supertype\n\nwhen delegating to a superclass constructor or a different constructor of the same class\n\nafter the object keyword\n\nDon't put a space before : when it separates a declaration and its type.\n\nAlways put a space after :.\n\nabstract class Foo<out T : Any> : IFoo { abstract fun foo(a: Int): T } class FooImpl : Foo() { constructor(x: String) : this(x) { /*...*/ } val x = object : IFoo { /*...*/ } }\n\nClass headers\n\nClasses with a few primary constructor parameters can be written in a single line:\n\nclass Person(id: Int, name: String)\n\nClasses with longer headers should be formatted so that each primary constructor parameter is in a separate line with indentation. Also, the closing parenthesis should be on a new line. If you use inheritance, the superclass constructor call, or the list of implemented interfaces should be located on the same line as the parenthesis:\n\nclass Person( id: Int, name: String, surname: String ) : Human(id, name) { /*...*/ }\n\nFor multiple interfaces, the superclass constructor call should be located first and then each interface should be located in a different line:\n\nclass Person( id: Int, name: String, surname: String ) : Human(id, name), KotlinMaker { /*...*/ }\n\nFor classes with a long supertype list, put a line break after the colon and align all supertype names horizontally:\n\nclass MyFavouriteVeryLongClassHolder : MyLongHolder<MyFavouriteVeryLongClass>(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } }\n\nTo clearly separate the class header and body when the class header is long, either put a blank line following the class header (as in the example above), or put the opening curly brace on a separate line:\n\nclass MyFavouriteVeryLongClassHolder : MyLongHolder<MyFavouriteVeryLongClass>(), SomeOtherInterface, AndAnotherOne { fun foo() { /*...*/ } }\n\nUse regular indent (four spaces) for constructor parameters. This ensures that properties declared in the primary constructor have the same indentation as properties declared in the body of a class.\n\nModifiers order\n\nIf a declaration has multiple modifiers, always put them in the following order:\n\npublic / protected / private / internal expect / actual final / open / abstract / sealed / const external override lateinit tailrec vararg suspend inner enum / annotation / fun // as a modifier in `fun interface` companion inline / value infix operator data\n\nPlace all annotations before modifiers:\n\n@Named(\"Foo\") private val foo: Foo\n\nUnless you're working on a library, omit redundant modifiers (for example, public).\n\nAnnotations\n\nPlace annotations on separate lines before the declaration to which they are attached, and with the same indentation:\n\n@Target(AnnotationTarget.PROPERTY) annotation class JsonExclude\n\nAnnotations without arguments may be placed on the same line:\n\n@JsonExclude @JvmField var x: String\n\nA single annotation without arguments may be placed on the same line as the corresponding declaration:\n\n@Test fun foo() { /*...*/ }\n\nFile annotations\n\nFile annotations are placed after the file comment (if any), before the package statement, and are separated from package with a blank line (to emphasize the fact that they target the file and not the package).\n\n/** License, copyright and whatever */ @file:JvmName(\"FooBar\") package foo.bar\n\nFunctions\n\nIf the function signature doesn't fit on a single line, use the following syntax:\n\nfun longMethodName( argument: ArgumentType = defaultValue, argument2: AnotherArgumentType, ): ReturnType { // body }\n\nUse regular indent (four spaces) for function parameters. It helps ensure consistency with constructor parameters.\n\nPrefer using an expression body for functions with the body consisting of a single expression.\n\nfun foo(): Int { // bad return 1 } fun foo() = 1 // good\n\nExpression bodies\n\nIf the function has an expression body whose first line doesn't fit on the same line as the declaration, put the = sign on the first line and indent the expression body by four spaces.\n\nfun f(x: String, y: String, z: String) = veryLongFunctionCallWithManyWords(andLongParametersToo(), x, y, z)\n\nProperties\n\nFor very simple read-only properties, consider one-line formatting:\n\nval isEmpty: Boolean get() = size == 0\n\nFor more complex properties, always put get and set keywords on separate lines:\n\nval foo: String get() { /*...*/ }\n\nFor properties with an initializer, if the initializer is long, add a line break after the = sign and indent the initializer by four spaces:\n\nprivate val defaultCharset: Charset? = EncodingRegistry.getInstance().getDefaultCharsetForPropertiesFiles(file)\n\nControl flow statements\n\nIf the condition of an if or when statement is multiline, always use curly braces around the body of the statement. Indent each subsequent line of the condition by four spaces relative to the statement start. Put the closing parentheses of the condition together with the opening curly brace on a separate line:\n\nif (!component.isSyncing && !hasAnyKotlinRuntimeInScope(module) ) { return createKotlinNotConfiguredPanel(module) }\n\nThis helps align the condition and statement bodies.\n\nPut the else, catch, finally keywords, as well as the while keyword of a do-while loop, on the same line as the preceding curly brace:\n\nif (condition) { // body } else { // else part } try { // body } finally { // cleanup }\n\nIn a when statement, if a branch is more than a single line, consider separating it from adjacent case blocks with a blank line:\n\nprivate fun parsePropertyValue(propName: String, token: Token) { when (token) { is Token.ValueToken -> callback.visitValue(propName, token.value) Token.LBRACE -> { // ... } } }\n\nPut short branches on the same line as the condition, without braces.\n\nwhen (foo) { true -> bar() // good false -> { baz() } // bad }\n\nMethod calls\n\nIn long argument lists, put a line break after the opening parenthesis. Indent arguments by four spaces. Group multiple closely related arguments on the same line.\n\ndrawSquare( x = 10, y = 10, width = 100, height = 100, fill = true )\n\nPut spaces around the = sign separating the argument name and value.\n\nWrap chained calls\n\nWhen wrapping chained calls, put the . character or the ?. operator on the next line, with a single indent:\n\nval anchor = owner ?.firstChild!! .siblings(forward = true) .dropWhile { it is PsiComment || it is PsiWhiteSpace }\n\nThe first call in the chain should usually have a line break before it, but it's OK to omit it if the code makes more sense that way.\n\nLambdas\n\nIn lambda expressions, spaces should be used around the curly braces, as well as around the arrow which separates the parameters from the body. If a call takes a single lambda, pass it outside parentheses whenever possible.\n\nlist.filter { it > 10 }\n\nIf assigning a label for a lambda, do not put a space between the label and the opening curly brace:\n\nfun foo() { ints.forEach lit@{ // ... } }\n\nWhen declaring parameter names in a multiline lambda, put the names on the first line, followed by the arrow and the newline:\n\nappendCommaSeparated(properties) { prop -> val propertyValue = prop.get(obj) // ... }\n\nIf the parameter list is too long to fit on a line, put the arrow on a separate line:\n\nfoo { context: Context, environment: Env -> context.configureEnv(environment) }\n\nTrailing commas\n\nA trailing comma is a comma symbol after the last item in a series of elements:\n\nclass Person( val firstName: String, val lastName: String, val age: Int, // trailing comma )\n\nUsing trailing commas has several benefits:\n\nIt makes version-control diffs cleaner â as all the focus is on the changed value.\n\nIt makes it easy to add and reorder elements â there is no need to add or delete the comma if you manipulate elements.\n\nIt simplifies code generation, for example, for object initializers. The last element can also have a comma.\n\nTrailing commas are entirely optional â your code will still work without them. The Kotlin style guide encourages the use of trailing commas at the declaration site and leaves it at your discretion for the call site.\n\nTo enable trailing commas in the IntelliJ IDEA formatter, go to Settings/Preferences | Editor | Code Style | Kotlin, open the Other tab and select the Use trailing comma option.\n\nEnumerations\n\nenum class Direction { NORTH, SOUTH, WEST, EAST, // trailing comma }\n\nValue arguments\n\nfun shift(x: Int, y: Int) { /*...*/ } shift( 25, 20, // trailing comma ) val colors = listOf( \"red\", \"green\", \"blue\", // trailing comma )\n\nClass properties and parameters\n\nclass Customer( val name: String, val lastName: String, // trailing comma ) class Customer( val name: String, lastName: String, // trailing comma )\n\nFunction value parameters\n\nfun powerOf( number: Int, exponent: Int, // trailing comma ) { /*...*/ } constructor( x: Comparable<Number>, y: Iterable<Number>, // trailing comma ) {} fun print( vararg quantity: Int, description: String, // trailing comma ) {}\n\nParameters with optional type (including setters)\n\nval sum: (Int, Int, Int) -> Int = fun( x, y, z, // trailing comma ): Int { return x + y + x } println(sum(8, 8, 8))\n\nIndexing suffix\n\nclass Surface { operator fun get(x: Int, y: Int) = 2 * x + 4 * y - 10 } fun getZValue(mySurface: Surface, xValue: Int, yValue: Int) = mySurface[ xValue, yValue, // trailing comma ]\n\nParameters in lambdas\n\nfun main() { val x = { x: Comparable<Number>, y: Iterable<Number>, // trailing comma -> println(\"1\") } println(x) }\n\nwhen entry\n\nfun isReferenceApplicable(myReference: KClass<*>) = when (myReference) { Comparable::class, Iterable::class, String::class, // trailing comma -> true else -> false }\n\nCollection literals (in annotations)\n\nannotation class ApplicableFor(val services: Array<String>) @ApplicableFor([ \"serializer\", \"balancer\", \"database\", \"inMemoryCache\", // trailing comma ]) fun run() {}\n\nType arguments\n\nfun <T1, T2> foo() {} fun main() { foo< Comparable<Number>, Iterable<Number>, // trailing comma >() }\n\nType parameters\n\nclass MyMap< MyKey, MyValue, // trailing comma > {}\n\nDestructuring declarations\n\ndata class Car(val manufacturer: String, val model: String, val year: Int) val myCar = Car(\"Tesla\", \"Y\", 2019) val ( manufacturer, model, year, // trailing comma ) = myCar val cars = listOf<Car>() fun printMeanValue() { var meanValue: Int = 0 for (( _, _, year, // trailing comma ) in cars) { meanValue += year } println(meanValue/cars.size) } printMeanValue()\n\nFor longer documentation comments, place the opening /** on a separate line and begin each subsequent line with an asterisk:\n\n/** * This is a documentation comment * on multiple lines. */\n\nShort comments can be placed on a single line:\n\n/** This is a short documentation comment. */\n\nGenerally, avoid using @param and @return tags. Instead, incorporate the description of parameters and return values directly into the documentation comment, and add links to parameters wherever they are mentioned. Use @param and @return only when a lengthy description is required which doesn't fit into the flow of the main text.\n\n// Avoid doing this: /** * Returns the absolute value of the given number. * @param number The number to return the absolute value for. * @return The absolute value. */ fun abs(number: Int): Int { /*...*/ } // Do this instead: /** * Returns the absolute value of the given [number]. */ fun abs(number: Int): Int { /*...*/ }\n\nAvoid redundant constructs\n\nIn general, if a certain syntactic construction in Kotlin is optional and highlighted by the IDE as redundant, you should omit it in your code. Do not leave unnecessary syntactic elements in code just \"for clarity\".\n\nUnit return type\n\nIf a function returns Unit, the return type should be omitted:\n\nfun foo() { // \": Unit\" is omitted here }\n\nSemicolons\n\nOmit semicolons whenever possible.\n\nString templates\n\nDon't use curly braces when inserting a simple variable into a string template. Use curly braces only for longer expressions.\n\nprintln(\"$name has ${children.size} children\")\n\nIdiomatic use of language features\n\nImmutability\n\nPrefer using immutable data to mutable. Always declare local variables and properties as val rather than var if they are not modified after initialization.\n\nAlways use immutable collection interfaces (Collection, List, Set, Map) to declare collections which are not mutated. When using factory functions to create collection instances, always use functions that return immutable collection types when possible:\n\n// Bad: use of a mutable collection type for value which will not be mutated fun validateValue(actualValue: String, allowedValues: HashSet<String>) { ... } // Good: immutable collection type used instead fun validateValue(actualValue: String, allowedValues: Set<String>) { ... } // Bad: arrayListOf() returns ArrayList<T>, which is a mutable collection type val allowedValues = arrayListOf(\"a\", \"b\", \"c\") // Good: listOf() returns List<T> val allowedValues = listOf(\"a\", \"b\", \"c\")\n\nDefault parameter values\n\nPrefer declaring functions with default parameter values to declaring overloaded functions.\n\n// Bad fun foo() = foo(\"a\") fun foo(a: String) { /*...*/ } // Good fun foo(a: String = \"a\") { /*...*/ }\n\nType aliases\n\nIf you have a functional type or a type with type parameters which is used multiple times in a codebase, prefer defining a type alias for it:\n\ntypealias MouseClickHandler = (Any, MouseEvent) -> Unit typealias PersonIndex = Map<String, Person>\n\nIf you use a private or internal type alias for avoiding name collision, prefer the import ... as ... mentioned in Packages and Imports.\n\nLambda parameters\n\nIn lambdas which are short and not nested, it's recommended to use the it convention instead of declaring the parameter explicitly. In nested lambdas with parameters, always declare parameters explicitly.\n\nReturns in a lambda\n\nAvoid using multiple labeled returns in a lambda. Consider restructuring the lambda so that it will have a single exit point. If that's not possible or not clear enough, consider converting the lambda into an anonymous function.\n\nDo not use a labeled return for the last statement in a lambda.\n\nNamed arguments\n\nUse the named argument syntax when a method takes multiple parameters of the same primitive type, or for parameters of Boolean type, unless the meaning of all parameters is absolutely clear from context.\n\ndrawSquare(x = 10, y = 10, width = 100, height = 100, fill = true)\n\nif versus when\n\nPrefer using if for binary conditions instead of when. For example, use this syntax with if:\n\nif (x == null) ... else ...\n\ninstead of this one with when:\n\nwhen (x) { null -> // ... else -> // ... }\n\nPrefer using when if there are three or more options.\n\nNullable Boolean values in conditions\n\nIf you need to use a nullable Boolean in a conditional statement, use if (value == true) or if (value == false) checks.\n\nLoops\n\nPrefer using higher-order functions (filter, map etc.) to loops. Exception: forEach (prefer using a regular for loop instead, unless the receiver of forEach is nullable or forEach is used as part of a longer call chain).\n\nWhen making a choice between a complex expression using multiple higher-order functions and a loop, understand the cost of the operations being performed in each case and keep performance considerations in mind.\n\nLoops on ranges\n\nUse the ..< operator to loop over an open-ended range:\n\nfor (i in 0..n - 1) { /*...*/ } // bad for (i in 0..<n) { /*...*/ } // good\n\nStrings\n\nPrefer string templates to string concatenation.\n\nPrefer multiline strings to embedding \\n escape sequences into regular string literals.\n\nTo maintain indentation in multiline strings, use trimIndent when the resulting string does not require any internal indentation, or trimMargin when internal indentation is required:\n\nfun main() { //sampleStart println(\"\"\" Not trimmed text \"\"\" ) println(\"\"\" Trimmed text \"\"\".trimIndent() ) println() val a = \"\"\"Trimmed to margin text: |if(a > 1) { | return a |}\"\"\".trimMargin() println(a) //sampleEnd }\n\nLearn the difference between Java and Kotlin multiline strings.\n\nFunctions vs properties\n\nIn some cases, functions with no arguments might be interchangeable with read-only properties. Although the semantics are similar, there are some stylistic conventions on when to prefer one to another.\n\nPrefer a property over a function when the underlying algorithm:\n\ndoes not throw\n\nis cheap to calculate (or cached on the first run)\n\nreturns the same result over invocations if the object state hasn't changed\n\nExtension functions\n\nUse extension functions liberally. Every time you have a function that works primarily on an object, consider making it an extension function accepting that object as a receiver. To minimize API pollution, restrict the visibility of extension functions as much as it makes sense. As necessary, use local extension functions, member extension functions, or top-level extension functions with private visibility.\n\nInfix functions\n\nDeclare a function as infix only when it works on two objects which play a similar role. Good examples: and, to, zip. Bad example: add.\n\nDo not declare a method as infix if it mutates the receiver object.\n\nFactory functions\n\nIf you declare a factory function for a class, avoid giving it the same name as the class itself. Prefer using a distinct name, making it clear why the behavior of the factory function is special. Only if there is really no special semantics, you can use the same name as the class.\n\nclass Point(val x: Double, val y: Double) { companion object { fun fromPolar(angle: Double, radius: Double) = Point(...) } }\n\nIf you have an object with multiple overloaded constructors that don't call different superclass constructors and can't be reduced to a single constructor with default argument values, prefer to replace the overloaded constructors with factory functions.\n\nPlatform types\n\nA public function/method returning an expression of a platform type must declare its Kotlin type explicitly:\n\nfun apiCall(): String = MyJavaApi.getProperty(\"name\")\n\nAny property (package-level or class-level) initialized with an expression of a platform type must declare its Kotlin type explicitly:\n\nclass Person { val name: String = MyJavaApi.getProperty(\"name\") }\n\nA local value initialized with an expression of a platform type may or may not have a type declaration:\n\nfun main() { val name = MyJavaApi.getProperty(\"name\") println(name) }\n\nScope functions apply/with/run/also/let\n\nKotlin provides a set of functions to execute a block of code in the context of a given object: let, run, with, apply, and also. For the guidance on choosing the right scope function for your case, refer to Scope Functions.\n\nCoding conventions for libraries\n\nWhen writing libraries, it's recommended to follow an additional set of rules to ensure API stability:\n\nAlways explicitly specify member visibility (to avoid accidentally exposing declarations as public API)\n\nAlways explicitly specify function return types and property types (to avoid accidentally changing the return type when the implementation changes)\n\nProvide KDoc comments for all public members, except for overrides that do not require any new documentation (to support generating documentation for the library)\n\nLearn more about best practices and ideas to consider when writing an API for your library in the Library authors' guidelines.\n\nLast modified: 12 June 2024"
    }
}