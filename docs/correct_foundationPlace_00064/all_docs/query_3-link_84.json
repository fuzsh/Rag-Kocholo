{
    "id": "correct_foundationPlace_00064_3",
    "rank": 84,
    "data": {
        "url": "https://medium.com/%40santimattius/from-native-libraries-to-libraries-in-kmp-good-design-and-expect-actual-for-our-mvp-in-kmp-d6533bce56a9",
        "read_more_link": "",
        "language": "en",
        "title": "From Native Libraries to Libraries in KMP: Good Design and Expect/Actual for our MVP in KMP",
        "top_image": "https://miro.medium.com/v2/resize:fit:813/1*Un1di4nQgRdmVWvazOeFYA.png",
        "meta_img": "https://miro.medium.com/v2/resize:fit:813/1*Un1di4nQgRdmVWvazOeFYA.png",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/resize:fill:88:88/0*qFH2CxPjByJiP522.",
            "https://miro.medium.com/v2/resize:fill:144:144/0*qFH2CxPjByJiP522."
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Santiago Mattiauda",
            "medium.com"
        ],
        "publish_date": "2024-06-06T22:02:15.391000+00:00",
        "summary": "",
        "meta_description": "Adopting Kotlin Multiplatform (KMP) instead of native solutions can be a strategic step towards consistency in multi-platform development. This technology allows sharing code and business logic among…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/1*m-R_BkNf1Qjr1YbyOIJY2w.png",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/@santimattius/from-native-libraries-to-libraries-in-kmp-good-design-and-expect-actual-for-our-mvp-in-kmp-d6533bce56a9",
        "text": "Adopting Kotlin Multiplatform (KMP) instead of native solutions can be a strategic step towards consistency in multi-platform development. This technology allows sharing code and business logic among platforms, which reduces duplication of efforts and improves consistency across all applications. The first step to adopting this technology in our Android and iOS projects could be to adapt our specific solutions and use them in our KMP module, without having to write much code from scratch. This will allow us to use already existing functionalities in KMP and in the specific code of each platform.\n\nIn this article, we will explore how to extend the Bugsnag SDK to be used from KMP modules, and why not on Android and iOS.\n\nWe will start with the integration with existing native SDKs, where the focus will be on the efficiency of not requiring complete rewrites.\n\nHow do we include Android or iOS specific code in a KMP module?\n\nUsing Android dependencies in KMP\n\nTo add Android-specific dependencies to a Kotlin Multiplatform module, the process is the same as for Android projects. We add the dependency in the corresponding source set for Android within the build.gradle(.kts) file in the shared directory of your project.\n\nIn our case, we will use Bugsnag and Android Startup, both dependencies are available only for Android.\n\nkotlin {\n\nsourcesets{\n\ncommonMain.dependencies{\n\n// common dependencies\n\n}\n\nandroidMain.dependencies {\n\napi(libs.bugsnag.android)\n\nimplementation(libs.androidx.startup.runtime)\n\n}\n\n}\n\n}\n\nOnce we have defined these dependencies, we can use them within the Android sourceset.\n\nNext, we will learn how to set up specific dependencies for iOS. We will resume implementation once we have configured dependencies on both platforms.\n\nHow to use iOS dependencies in KMP\n\nApple SDK dependencies, such as Foundation or Core Bluetooth, are available as a set of precompiled libraries in Kotlin Multiplatform projects, and they do not require any additional configuration.\n\nIn addition, you can reuse other libraries and frameworks from the iOS ecosystem in your iOS source sets. Kotlin supports interoperability with Objective-C dependencies and Swift dependencies, as long as their APIs are exported to Objective-C with the @objc attribute. However, pure Swift dependencies are not yet supported.\n\nIntegration with CocoaPods, the dependency manager, is also backed with the same limitation: you cannot use pure Swift pods.\n\nWe recommend using CocoaPods to manage iOS dependencies in Kotlin Multiplatform projects. Only manage dependencies manually if you need to specifically adjust the interop process or if you have a strong reason to do so.\n\nIn our case, we will use CocoaPods. To do this, we need to configure the CocoaPods plugin in our KMP project:\n\n[versions]\n\nkotlin = \"1.9.24\"\n\n[plugins]\n\ncocoaPods = { id = \"org.jetbrains.kotlin.native.cocoapods\", version.ref = \"kotlin\" }\n\nNow, we apply the CocoaPods plugin at the root of our project and in the shared module.\n\n//root build.gradle.kts\n\nplugins {\n\nalias(libs.plugins.androidApplication) apply false\n\nalias(libs.plugins.androidLibrary) apply false\n\nalias(libs.plugins.kotlinMultiplatform) apply false\n\nalias(libs.plugins.jetbrainsKotlinAndroid) apply false\n\nalias(libs.plugins.cocoaPods) apply false\n\n}\n\n//shared module build.gradle.kts\n\nplugins {\n\nalias(libs.plugins.kotlinMultiplatform)\n\nalias(libs.plugins.cocoaPods)\n\nalias(libs.plugins.androidLibrary)\n\n}\n\nAfter adding the CocoaPods plugin, we can define our shared module as a pod and specify which pods we will use in our shared module. In this case, we will use Bugsnag as an example of a native library.\n\nkotlin{\n\ncocoapods {\n\nversion = \"1.0\"\n\nsummary = \"Some description for a Kotlin/Native module\"\n\nhomepage = \"Link to a Kotlin/Native module homepage\"\n\nname = \"Shared\"\n\nios.deploymentTarget = \"14.0\"\n\nframework {\n\nbaseName = \"Shared\"\n\nisStatic = false\n\n}\n\npod(\"Bugsnag\"){\n\nversion = \"6.28.0\"\n\n}\n\n}\n\n}\n\nNow that we have set up and prepared both dependencies on both platforms, we will explore how to reuse such native APIs through Kotlin Multiplatform.\n\nExpect/Actual\n\nKotlin offers a language mechanism to access platform-specific APIs while developing common logic: expect and actual declarations.\n\nWith this mechanism, the common source set of a multiplatform module defines an expected declaration, and each platform source set must provide the actual declaration corresponding to the expected declaration. The compiler ensures that each declaration marked with the expect keyword in the common source set has the corresponding declarations marked with the actual keyword in all target platform source sets.\n\nThis applies to most Kotlin declarations, such as functions, classes, interfaces, enumerations, properties, and annotations. This section focuses on the use of expected and actual functions and properties.\n\nLet’s examine how this would be applied in our example with the Bugsnag API.\n\nAlthough the above diagram conceptually illustrates what we are going to implement, let’s analyze the code.\n\nLet’s start with our commonMain. Here, we will need to define the ‘expect’ for our API functions to ensure consistency across platforms. This is an example of Bugsnag detailed design, as the APIs it presents on both platforms maintain the same nomenclature, not only at the level of method signatures, but also at the entity level.\n\n// bugsnag.common.kt\n\npackage com.santimattius.kmp.playground\n\n//SDK configurations\n\nexpect class Configuration\n\n// Information track\n\nexpect class TrackableException\n\nobject Bugsnag {\n\nprivate val provider: PlatformTracker = PlatformTracker()\n\nfun initialize(config: Configuration) {\n\nprovider.initialize(config)\n\n}\n\nfun track(exception: TrackableException) {\n\nprovider.track(exception)\n\n}\n\n}\n\ninternal expect class PlatformTracker(){\n\nfun initialize(config: Configuration)\n\nfun track(exception: TrackableException)\n\n}\n\nLet’s examine how it would be implemented in Android and its use.\n\nIn our androidMain sourcesets, we will implement updates to the classes we have already seen in our shared code. However, there will be an exception for the entities that we will use as Configuration and TrackableException. We will use typealias. Let’s see what it would look like.\n\npackage com.santimattius.kmp.playground\n\nimport com.bugsnag.android.Bugsnag\n\nimport com.bugsnag.android.Configuration as BugsnagConfiguration\n\nactual typealias Configuration = BugsnagConfiguration\n\nactual typealias TrackableException = Throwable\n\ninternal actual class PlatformTracker {\n\nactual fun initialize(config: Configuration) {\n\nval context = applicationContext ?: run {\n\n// TODO: add logging later\n\nreturn\n\n}\n\nBugsnag.start(context, config)\n\n}\n\nactual fun track(exception: TrackableException) {\n\nBugsnag.notify(exception)\n\n}\n\n}\n\nAs we can see in the imports, the typealias that we use are direct references to the entities of the Native API.\n\nimport com.bugsnag.android.Bugsnag\n\nimport com.bugsnag.android.Configuration as BugsnagConfiguration\n\nThis is where we use the Android dependencies directly.\n\nWe need the context in Android, what do we do with that? Answer: Android Hack\n\nIf we look back at the Android dependencies we defined, one of them is Android Startup. Thanks to the flexibility that Kotlin Multiplatform offers us to define platform-specific code, we can do a little trick and define the following:\n\nWe need to initialize Bugsnag with the Android applicationContext and get it during the startup of the application. For this reason, using Android Startup, we will be able to capture the context and even initialize our library, although the latter is optional.\n\nTo achieve this, we define an Android Startup Initializer and capture the applicationContext.\n\ninternal var applicationContext: Context? = null\n\nprivate set\n\nclass ContextInitializer: Initializer<Unit> {\n\noverride fun create(context: Context) {\n\napplicationContext = context.applicationContext\n\n}\n\noverride fun dependencies(): List<Class<out Initializer<*>>> {\n\nreturn emptyList()\n\n}\n\n}\n\nOnce we have defined the initializer to work, we need to register it in the AndroidManifest. To do this, we must first create this file in our androidMain.\n\nWithin the manifest file, we add the definition.\n\n<manifest xmlns:android=\"http://schemas.android.com/apk/res/android\"\n\nxmlns:tools=\"http://schemas.android.com/tools\">\n\n<application>\n\n<provider\n\nandroid:name=\"androidx.startup.InitializationProvider\"\n\nandroid:authorities=\"${applicationId}.androidx-startup\"\n\nandroid:exported=\"false\"\n\ntools:node=\"merge\">\n\n<meta-data\n\nandroid:name=\"com.santimattius.kmp.playground.ContextInitializer\"\n\nandroid:value=\"androidx.startup\" />\n\n</provider>\n\n</application>\n\n</manifest>\n\nTo initialize and use Bugsnag, we simply refer to our Bugsnag object within our Android application. For example:\n\nimport android.app.Application\n\nimport com.santimattius.kmp.playground.Bugsnag\n\nimport com.santimattius.kmp.playground.Configuration\n\nclass MainApplication : Application() {\n\noverride fun onCreate() {\n\nsuper.onCreate()\n\n// Initialization\n\nBugsnag.initialize(config = Configuration.load(this))\n\n// Send test exception\n\nBugsnag.track(exception = Throwable(message = \"This is a test!!\"))\n\n}\n\n}\n\nThanks to the definition of aliases, we are using the native APIs directly through our module in Kotlin Multiplatform. This can be seen in the imports that we have.\n\nNow, let’s see what the implementation would be like on iOS.\n\npackage com.santimattius.kmp.playground\n\nimport cocoapods.Bugsnag.Bugsnag\n\nimport cocoapods.Bugsnag.BugsnagConfiguration\n\nimport kotlinx.cinterop.ExperimentalForeignApi\n\nimport platform.Foundation.NSException\n\n@OptIn(ExperimentalForeignApi::class)\n\nactual typealias Configuration = BugsnagConfiguration\n\nactual typealias TrackableException = NSException\n\n@OptIn(ExperimentalForeignApi::class)\n\ninternal actual class PlatformTracker {\n\nactual fun initialize(config: Configuration) {\n\nBugsnag.startWithConfiguration(config)\n\n}\n\nactual fun track(exception: TrackableException) {\n\nBugsnag.notify(exception)\n\n}\n\n}\n\nIf we check the imports, we will see that we are basing our definitions on the native APIs of the platform and Bugsnag.\n\nimport cocoapods.Bugsnag.Bugsnag\n\nimport cocoapods.Bugsnag.BugsnagConfiguration\n\nimport kotlinx.cinterop.ExperimentalForeignApi\n\nimport platform.Foundation.NSException\n\nJust like on Android, let’s see how to use our API in KMP, but from iOS. For this, in our iOSApp class, we have the following.\n\nimport SwiftUI\n\nimport Shared\n\nimport Bugsnag\n\n@main\n\nstruct iOSApp: App {\n\ninit() {\n\n// Initialization\n\nlet config = BugsnagConfiguration.loadConfig()\n\nconfig.appVersion = \"1.0.0-alpha\"\n\nBugsnag.shared.initialize(config: config)\n\n// Send test exception\n\nlet exception = NSException(name:NSExceptionName(rawValue: \"NamedException\"),\n\nreason:\"Something happened\",\n\nuserInfo:nil)\n\nBugsnag.shared.track(exception: exception)\n\n}\n\nvar body: some Scene {\n\nWindowGroup {\n\nContentView()\n\n}\n\n}\n\n}\n\nJust like in Android, we are using the platforms native types, but they are aimed at our Shared module.\n\nWe already have our solution in Kotlin Multiplatform 🎉\n\nCan we use it from a module in Kotlin Multiplatform?\n\nIs it possible to use our adaptation of the Bugsnag SDK from a Kotlin Multiplatform (KMP) module? The answer is yes. Part of adopting this technology includes making existing functionalities available for our KMP modules, which encourages their adoption.\n\nLet’s look at an example. Suppose we have the following repository.\n\nclass CrashRepository {\n\nprivate val coroutineScope = CoroutineScope(Dispatchers.Default)\n\nsuspend fun crash() {\n\nval handler = CoroutineExceptionHandler { _, exception ->\n\nprintln(\"CoroutineExceptionHandler got $exception\")\n\n// send log to bugsnag\n\nBugsnag.track(exception.asTrackableException())\n\n}\n\nval job = coroutineScope.launch(handler) { // root coroutine, running in GlobalScope\n\nthrow AssertionError()\n\n}\n\nval deferred = coroutineScope.async(handler) { // also root, but async instead of launch\n\nthrow ArithmeticException() // Nothing will be printed, relying on user to call deferred.await()\n\n}\n\njoinAll(job, deferred)\n\n}\n\n}\n\nHere we have an explicit example of causing an exception 😀. We want to capture this exception from CoroutineExceptionHandler and send it to Bugsnag through our adaptation of the SDK. To do this, we need to convert the exception to the TrackableException type.\n\n💡 We could have defined the Throwable type directly in our track function signature, since it’s a native Kotlin type. However, to create a clearer API, we decided to define the TrackableException type.\n\nTo perform the conversion, we create the following extension of the Throwable type with its respective platform updates.\n\n//bugsnag.common.kt\n\nexpect fun Throwable.asTrackableException(): TrackableException\n\n//bugsnag.android.kt\n\nactual fun Throwable.asTrackableException() = this\n\n//bugsnag.ios.kt\n\nactual fun Throwable.asTrackableException() = NSException.exceptionWithName(\n\nname = this::class.simpleName,\n\nreason = message ?: toString(),\n\nuserInfo = null\n\n)\n\nGiven that in Android, the current type of TrackableException is Throwable, the extension simply returns ‘this’. In the case of iOS, we generate a new NSException.\n\nNow, our solution is complete. However, let’s consider some pros and cons.\n\nPros and Cons\n\nPros\n\nWe can reuse existing solutions for our MVPs in KMP.\n\nWe maintain the developer experience, especially for those coming from Android, as we use the same API-level definitions.\n\nWe encourage early adoption of KMP.\n\nWe are forced to have a good design in native solutions and keep them synchronized.\n\nCons\n\nWe will not always have API designs aligned by platform.\n\nNow we will have an additional maintenance cost, as we have added a new stack to the existing product.\n\nIf there are changes in native APIs, we will also have to change our KMP adaptation.\n\nOur existing native solutions must be adapted to be used from cross-platform. In the case of Android, this implies Java and Kotlin interoperability. But on iOS, if we have Swift code that is not interoperable with ObjC, this presents a problem for conversion to Kotlin code.\n\nPersonally, I would reserve this type of solutions for specific cases, such as external solutions that do not have support for KMP. I would also evaluate the cost of rewriting these modules. Although interoperability is two-way (i.e., we can use native dependencies in KMP and vice versa), I would prefer not to generate duplicate solutions. In the software world, we already know the consequences this entails.\n\nExample seen in this article\n\nConclusion\n\nIn this article, I give you a clear idea of how to adapt native libraries for use in Kotlin Multiplatform (KMP). With specific examples, we show you how to achieve consistent development across various platforms and how to reuse existing functionalities in KMP modules. But we also tell you that this approach may involve extra maintenance costs and requires careful design and constant synchronization. Despite these challenges, adopting KMP can be a strategic move to improve efficiency and consistency in application development.\n\nReferences"
    }
}