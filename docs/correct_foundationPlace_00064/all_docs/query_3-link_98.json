{
    "id": "correct_foundationPlace_00064_3",
    "rank": 98,
    "data": {
        "url": "https://pub.dev/packages/freezed",
        "read_more_link": "",
        "language": "en",
        "title": "Dart package",
        "top_image": "https://pub.dev/static/hash-kkipkgm3/img/pub-dev-icon-cover-image.png",
        "meta_img": "https://pub.dev/static/hash-kkipkgm3/img/pub-dev-icon-cover-image.png",
        "images": [
            "https://pub.dev/static/hash-kkipkgm3/img/pub-dev-logo.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/nav-mobile-foldable-icon.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/nav-mobile-foldable-icon.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/nav-mobile-foldable-icon.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/ff-banner-desktop-2x.png",
            "https://pub.dev/static/hash-kkipkgm3/img/ff-banner-mobile-2x.png",
            "https://pub.dev/static/hash-kkipkgm3/img/content-copy-icon.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/material-icon-verified.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/like-inactive.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/like-active.svg",
            "https://github.com/rrousselGit/freezed/workflows/Build/badge.svg",
            "https://img.shields.io/pub/v/freezed.svg",
            "https://img.shields.io/discord/765557403865186374.svg?logo=discord&color=blue",
            "https://raw.githubusercontent.com/rrousselGit/provider/master/resources/flutter_favorite.png",
            "https://raw.githubusercontent.com/rrousselGit/freezed/master/resources/before.png",
            "https://raw.githubusercontent.com/rrousselGit/freezed/master/resources/after.png",
            "https://raw.githubusercontent.com/rrousselGit/freezed/master/sponsorkit/sponsors.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/material-icon-verified.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/material-icon-balance.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/material-icon-verified.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/material-icon-balance.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/keyboard_arrow_left.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/keyboard_arrow_right.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/rss-feed-icon.svg",
            "https://pub.dev/static/hash-kkipkgm3/img/bug-report-white-96px.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2020-02-08T05:31:51.934238+00:00",
        "summary": "",
        "meta_description": "Code generation for immutable classes that has a simple syntax/API without compromising on the features.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico?hash=nk4nss8c7444fg0chird9erqef2vkhb8",
        "meta_site_name": "Dart packages",
        "canonical_link": "https://pub.dev/packages/freezed",
        "text": "English | 한국어 | 简体中文\n\nWelcome to Freezed, yet another code generator for data classes, unions, and cloning.\n\nMotivation #\n\nDart is awesome, but defining a \"model\" can be tedious. You have to:\n\ndefine a constructor + properties\n\noverride toString, operator ==, hashCode\n\nimplement a copyWith method to clone the object\n\nhandle (de)serialization\n\nImplementing all of this can take hundreds of lines, which are error-prone and affect the readability of your model significantly.\n\nFreezed tries to fix that by implementing most of this for you, allowing you to focus on the definition of your model.\n\nBefore After\n\nIndex #\n\nMotivation\n\nIndex\n\nHow to use\n\nInstall\n\nDisabling invalid_annotation_target warning and warning in generates files\n\nRun the generator\n\nCreating a Model using Freezed\n\nDefining a mutable class instead of an immutable one\n\nAllowing the mutation of Lists/Maps/Sets\n\nHow copyWith works\n\nGoing further: Deep copy\n\nAdding getters and methods to our models\n\nAsserts\n\nDefault values\n\nDecorators and comments\n\nMixins and Interfaces for individual classes for union types\n\nFromJson/ToJson\n\nfromJSON - classes with multiple constructors\n\nDeserializing generic classes\n\nUnion types\n\nShared properties\n\nUsing pattern matching to read non-shared properties\n\n(Legacy) Pattern matching utilities\n\nWhen\n\nMap\n\nConfigurations\n\nChanging the behavior for a specific model\n\nChanging the behavior for the entire project\n\nUtilities\n\nIDE Extensions\n\nFreezed extension for VSCode\n\nFreezed extension for IntelliJ/Android Studio\n\nThird-party tools\n\nDartJ\n\nSponsors\n\nHow to use #\n\nInstall #\n\nTo use Freezed, you will need your typical build_runner/code-generator setup.\n\nFirst, install build_runner and Freezed by adding them to your pubspec.yaml file:\n\nFor a Flutter project:\n\nflutter pub add freezed_annotation flutter pub add dev:build_runner flutter pub add dev:freezed # if using freezed to generate fromJson/toJson, also add: flutter pub add json_annotation flutter pub add dev:json_serializable\n\nFor a Dart project:\n\ndart pub add freezed_annotation dart pub add dev:build_runner dart pub add dev:freezed # if using freezed to generate fromJson/toJson, also add: dart pub add json_annotation dart pub add dev:json_serializable\n\nThis installs three packages:\n\nbuild_runner, the tool to run code-generators\n\nfreezed, the code generator\n\nfreezed_annotation, a package containing annotations for freezed.\n\nDisabling invalid_annotation_target warning and warning in generates files #\n\nIf you plan on using Freezed in combination with json_serializable, recent versions of json_serializable and meta may require you to disable the invalid_annotation_target warning.\n\nTo do that, you can add the following to the analysis_options.yaml file at the root of your project:\n\nanalyzer: errors: invalid_annotation_target: ignore\n\nRun the generator #\n\nTo run the code generator, execute the following command:\n\ndart run build_runner build\n\nNote that like most code-generators, Freezed will need you to both import the annotation (freezed_annotation) and use the part keyword on the top of your files.\n\nAs such, a file that wants to use Freezed will start with:\n\nimport 'package:freezed_annotation/freezed_annotation.dart'; part 'my_file.freezed.dart';\n\nCONSIDER also importing package:flutter/foundation.dart.\n\nThe reason being, importing foundation.dart also imports classes to make an object nicely readable in Flutter's devtool.\n\nIf you import foundation.dart, Freezed will automatically do it for you.\n\nCreating a Model using Freezed #\n\nAn example is better than a long abstract explanation, so here's a typical Freezed class:\n\n// This file is \"main.dart\" import 'package:freezed_annotation/freezed_annotation.dart'; import 'package:flutter/foundation.dart'; // required: associates our `main.dart` with the code generated by Freezed part 'main.freezed.dart'; // optional: Since our Person class is serializable, we must add this line. // But if Person was not serializable, we could skip it. part 'main.g.dart'; @freezed class Person with _$Person { const factory Person({ required String firstName, required String lastName, required int age, }) = _Person; factory Person.fromJson(Map<String, Object?> json) => _$PersonFromJson(json); }\n\nThe following snippet defines a model named Person:\n\nPerson has 3 properties: firstName, lastName and age\n\nBecause we are using @freezed, all of this class's properties are immutable.\n\nSince we defined a fromJson, this class is de/serializable. Freezed will add a toJson method for us.\n\nFreezed will also automatically generate:\n\na copyWith method, for cloning the object with different properties\n\na toString override listing all the properties of the object\n\nan operator == and hashCode override (since Person is immutable)\n\nFrom this example, we can notice a few things:\n\nIt is necessary to annotate our model with @freezed (or @Freezed/@unfreezed, more about that later).\n\nThis annotation is what tells Freezed to generate code for that class.\n\nWe must also apply a mixin with the name of our class, prefixed by _$. This mixin is what defines the various properties/methods of our object.\n\nWhen defining a constructor in a Freezed class, we should use the factory keyword as showcased (const is optional).\n\nThe parameters of this constructor will be the list of all properties that this class contains.\n\nParameters don't have to be named and required. Feel free to use positional optional parameters if you want!\n\nDefining a mutable class instead of an immutable one #\n\nSo far, we've seen how to define a model where all of its properties are final; but you may want to define mutable properties in your model.\n\nFreezed supports this, by replacing the @freezed annotation with @unfreezed:\n\n@unfreezed class Person with _$Person { factory Person({ required String firstName, required String lastName, required final int age, }) = _Person; factory Person.fromJson(Map<String, Object?> json) => _$PersonFromJson(json); }\n\nThis defines a model mostly identical to our previous snippets, but with the following differences:\n\nfirstName and lastName are now mutable. As such, we can write:\n\nvoid main() { var person = Person(firstName: 'John', lastName: 'Smith', age: 42); person.firstName = 'Mona'; person.lastName = 'Lisa'; }\n\nage is still immutable, because we explicitly marked the property as final.\n\nPerson no-longer has a custom ==/hashCode implementation:\n\nvoid main() { var john = Person(firstName: 'John', lastName: 'Smith', age: 42); var john2 = Person(firstName: 'John', lastName: 'Smith', age: 42); print(john == john2); // false }\n\nOf course, since our Person class is mutable, it is no-longer possible to instantiate it using const.\n\nAllowing the mutation of Lists/Maps/Sets #\n\nBy default when using @freezed (but not @unfreezed), properties of type List/Map/Set are transformed to be immutable.\n\nThis means that writing the following will cause a runtime exception:\n\n@freezed class Example with _$Example { factory Example(List<int> list) = _Example; } void main() { var example = Example([]); example.list.add(42); // throws because we are mutating a collection }\n\nThat behavior can be disabled by writing:\n\n@Freezed(makeCollectionsUnmodifiable: false) class Example with _$Example { factory Example(List<int> list) = _Example; } void main() { var example = Example([]); example.list.add(42); // OK }\n\nHow copyWith works #\n\nAs explained before, when defining a model using Freezed, then the code-generator will automatically generate a copyWith method for us.\n\nThis method is used to clone an object with different values.\n\nFor example if we define:\n\n@freezed class Person with _$Person { factory Person(String name, int? age) = _Person; }\n\nThen we could write:\n\nvoid main() { var person = Person('Remi', 24); // `age` not passed, its value is preserved print(person.copyWith(name: 'Dash')); // Person(name: Dash, age: 24) // `age` is set to `null` print(person.copyWith(age: null)); // Person(name: Remi, age: null) }\n\nNotice Freezed supports person.copyWith(age: null).\n\nGoing further: Deep copy #\n\nWhile copyWith is very powerful in itself, it becomes inconvenient on more complex objects.\n\nConsider the following classes:\n\n@freezed class Company with _$Company { factory Company({String? name, required Director director}) = _Company; } @freezed class Director with _$Director { factory Director({String? name, Assistant? assistant}) = _Director; } @freezed class Assistant with _$Assistant { factory Assistant({String? name, int? age}) = _Assistant; }\n\nThen, from a reference on Company, we may want to perform changes on Assistant.\n\nFor example, to change the name of an assistant, using copyWith we would have to write:\n\nCompany company; Company newCompany = company.copyWith( director: company.director.copyWith( assistant: company.director.assistant.copyWith( name: 'John Smith', ), ), );\n\nThis works, but is relatively verbose with a lot of duplicates.\n\nThis is where we could use Freezed's \"deep copy\".\n\nIf a Freezed model contains properties that are also Freezed models, then the code-generator will offer an alternate syntax to the previous example:\n\nCompany company; Company newCompany = company.copyWith.director.assistant(name: 'John Smith');\n\nThis snippet will achieve strictly the same result as the previous snippet (creating a new company with an updated assistant name), but no longer has duplicates.\n\nGoing deeper in this syntax, if instead, we wanted to change the director's name then we could write:\n\nCompany company; Company newCompany = company.copyWith.director(name: 'John Doe');\n\nOverall, based on the definitions of Company/Director/Assistant mentioned above, all the following \"copy\" syntaxes will work:\n\nCompany company; company = company.copyWith(name: 'Google', director: Director(...)); company = company.copyWith.director(name: 'Larry', assistant: Assistant(...));\n\nNull consideration\n\nSome objects may also be null. For example, using our Company class, then Director's assistant may be null.\n\nAs such, writing:\n\nCompany company = Company(name: 'Google', director: Director(assistant: null)); Company newCompany = company.copyWith.director.assistant(name: 'John');\n\ndoesn't make sense.\n\nWe can't change the assistant's name if there is no assistant to begin with.\n\nIn that situation, company.copyWith.director.assistant will return null, causing our code to fail to compile.\n\nTo fix it, we can use the ?.call operator and write:\n\nCompany? newCompany = company.copyWith.director.assistant?.call(name: 'John');\n\nAdding getters and methods to our models #\n\nSometimes, you may want to manually define methods/properties in our classes.\n\nBut you will quickly notice that if you try to do:\n\n@freezed class Person with _$Person { const factory Person(String name, {int? age}) = _Person; void method() { print('hello world'); } }\n\nthen it won't work.\n\nFor that to work, we need an extra step: We need to define a private empty constructor:\n\n@freezed class Person with _$Person { // Added constructor. Must not have any parameter const Person._(); const factory Person(String name, {int? age}) = _Person; void method() { print('hello world'); } }\n\nAsserts #\n\nDart does not allow adding assert(...) statements to a factory constructor.\n\nAs such, to add asserts to your Freezed classes, you will need the @Assert decorator:\n\nclass Person with _$Person { @Assert('name.isNotEmpty', 'name cannot be empty') @Assert('age >= 0') factory Person({ String? name, int? age, }) = _Person; }\n\nDefault values #\n\nSimilarly to asserts, Dart does not allow \"redirecting factory constructors\" to specify default values.\n\nAs such, if you want to specify default values for your properties, you will need the @Default annotation:\n\nclass Example with _$Example { const factory Example([@Default(42) int value]) = _Example; }\n\nNOTE:\n\nIf you are using serialization/deserialization, this will automatically add a @JsonKey(defaultValue: <something>) for you.\n\nFreezed supports property and class level decorators/documentation by decorating/documenting their respective parameter and constructor definition.\n\nConsider:\n\n@freezed class Person with _$Person { const factory Person({ String? name, int? age, Gender? gender, }) = _Person; }\n\nIf you want to document name, you can do:\n\n@freezed class Person with _$Person { const factory Person({ /// The name of the user. /// /// Must not be null String? name, int? age, Gender? gender, }) = _Person; }\n\nIf you want to mark the property gender as @deprecated, then you can do:\n\n@freezed class Person with _$Person { const factory Person({ String? name, int? age, @deprecated Gender? gender, }) = _Person; }\n\nThis will deprecate both:\n\nThe constructor\n\nPerson(gender: Gender.something); // gender is deprecated\n\nThe generated class's constructor:\n\n_Person(gender: Gender.something); // gender is deprecated\n\nthe property:\n\nPerson person; print(person.gender); // gender is deprecated\n\nthe copyWith parameter:\n\nPerson person; person.copyWith(gender: Gender.something); // gender is deprecated\n\nSimilarly, if you want to decorate the generated class you can decorate the defining factory constructor.\n\nAs such, to deprecate _Person, you could do:\n\n@freezed class Person with _$Person { @deprecated const factory Person({ String? name, int? age, Gender? gender, }) = _Person; }\n\nMixins and Interfaces for individual classes for union types #\n\nWhen you have multiple types in the same class you might want one of those types to implement an interface or mixin a class. You can do that using the @Implements or @With decorators respectively. In the following example City implements GeographicArea.\n\nabstract class GeographicArea { int get population; String get name; } @freezed sealed class Example with _$Example { const factory Example.person(String name, int age) = Person; @Implements<GeographicArea>() const factory Example.city(String name, int population) = City; }\n\nThis also works for implementing or mixing in generic classes e.g. AdministrativeArea<House> except when the class has a generic type parameter e.g. AdministrativeArea<T>. In this case freezed will generate correct code but dart will throw a load error on the annotation declaration when compiling. To avoid this you should use the @Implements.fromString and @With.fromString decorators as follows:\n\nabstract class GeographicArea {} abstract class House {} abstract class Shop {} abstract class AdministrativeArea<T> {} @freezed sealed class Example<T> with _$Example<T> { const factory Example.person(String name, int age) = Person<T>; @With.fromString('AdministrativeArea<T>') const factory Example.street(String name) = Street<T>; @With<House>() @Implements<Shop>() @Implements<GeographicArea>() @Implements.fromString('AdministrativeArea<T>') const factory Example.city(String name, int population) = City<T>; }\n\nNote: You need to make sure that you comply with the interface requirements by implementing all the abstract members. If the interface has no members or just fields, you can fulfill the interface contract by adding them to the union type's constructor. Keep in mind that if the interface defines a method or a getter, that you implement in the class, you need to use the Adding getters and methods to our models instructions.\n\nNote 2: You cannot use @With/@Implements with freezed classes. Freezed classes can neither be extended nor implemented.\n\nFromJson/ToJson #\n\nWhile Freezed will not generate your typical fromJson/toJson by itself, it knows what json_serializable is.\n\nMaking a class compatible with json_serializable is very straightforward.\n\nConsider this snippet:\n\nimport 'package:freezed_annotation/freezed_annotation.dart'; part 'model.freezed.dart'; @freezed sealed class Model with _$Model { factory Model.first(String a) = First; factory Model.second(int b, bool c) = Second; }\n\nThe changes necessary to make it compatible with json_serializable consists of two lines:\n\na new part: part 'model.g.dart';\n\na new constructor on the targeted class: factory Model.fromJson(Map<String, dynamic> json) => _$ModelFromJson(json);\n\nThe end result is:\n\nimport 'package:freezed_annotation/freezed_annotation.dart'; part 'model.freezed.dart'; part 'model.g.dart'; @freezed sealed class Model with _$Model { factory Model.first(String a) = First; factory Model.second(int b, bool c) = Second; factory Model.fromJson(Map<String, dynamic> json) => _$ModelFromJson(json); }\n\nDon't forget to add json_serializable to your pubspec.yaml file:\n\ndev_dependencies: json_serializable:\n\nThat's it!\n\nWith these changes, Freezed will automatically ask json_serializable to generate all the necessary fromJson/toJson.\n\nNote:\n\nFreezed will only generate a fromJson if the factory is using =>.\n\nfromJSON - classes with multiple constructors #\n\nFor classes with multiple constructors, Freezed will check the JSON response for a string element called runtimeType and choose the constructor to use based on its value. For example, given the following constructors:\n\n@freezed sealed class MyResponse with _$MyResponse { const factory MyResponse(String a) = MyResponseData; const factory MyResponse.special(String a, int b) = MyResponseSpecial; const factory MyResponse.error(String message) = MyResponseError; factory MyResponse.fromJson(Map<String, dynamic> json) => _$MyResponseFromJson(json); }\n\nThen Freezed will use each JSON object's runtimeType to choose the constructor as follows:\n\n[ { \"runtimeType\": \"default\", \"a\": \"This JSON object will use constructor MyResponse()\" }, { \"runtimeType\": \"special\", \"a\": \"This JSON object will use constructor MyResponse.special()\", \"b\": 42 }, { \"runtimeType\": \"error\", \"message\": \"This JSON object will use constructor MyResponse.error()\" } ]\n\nYou can customize key and value with something different using @Freezed and @FreezedUnionValue decorators:\n\n@Freezed(unionKey: 'type', unionValueCase: FreezedUnionCase.pascal) sealed class MyResponse with _$MyResponse { const factory MyResponse(String a) = MyResponseData; @FreezedUnionValue('SpecialCase') const factory MyResponse.special(String a, int b) = MyResponseSpecial; const factory MyResponse.error(String message) = MyResponseError; // ... }\n\nwhich would update the previous json to:\n\n[ { \"type\": \"Default\", \"a\": \"This JSON object will use constructor MyResponse()\" }, { \"type\": \"SpecialCase\", \"a\": \"This JSON object will use constructor MyResponse.special()\", \"b\": 42 }, { \"type\": \"Error\", \"message\": \"This JSON object will use constructor MyResponse.error()\" } ]\n\nIf you want to customize key and value for all the classes, you can specify it inside your build.yaml file, for example:\n\ntargets: $default: builders: freezed: options: union_key: type union_value_case: pascal\n\nIf you don't control the JSON response, then you can implement a custom converter. Your custom converter will need to implement its own logic for determining which constructor to use.\n\nclass MyResponseConverter implements JsonConverter<MyResponse, Map<String, dynamic>> { const MyResponseConverter(); @override MyResponse fromJson(Map<String, dynamic> json) { // type data was already set (e.g. because we serialized it ourselves) if (json['runtimeType'] != null) { return MyResponse.fromJson(json); } // you need to find some condition to know which type it is. e.g. check the presence of some field in the json if (isTypeData) { return MyResponseData.fromJson(json); } else if (isTypeSpecial) { return MyResponseSpecial.fromJson(json); } else if (isTypeError) { return MyResponseError.fromJson(json); } else { throw Exception('Could not determine the constructor for mapping from JSON'); } } @override Map<String, dynamic> toJson(MyResponse data) => data.toJson(); }\n\nTo then apply your custom converter pass the decorator to a constructor parameter.\n\n@freezed class MyModel with _$MyModel { const factory MyModel(@MyResponseConverter() MyResponse myResponse) = MyModelData; factory MyModel.fromJson(Map<String, dynamic> json) => _$MyModelFromJson(json); }\n\nBy doing this, json serializable will use MyResponseConverter.fromJson() and MyResponseConverter.toJson() to convert MyResponse.\n\nYou can also use a custom converter on a constructor parameter contained in a List.\n\n@freezed class MyModel with _$MyModel { const factory MyModel(@MyResponseConverter() List<MyResponse> myResponse) = MyModelData; factory MyModel.fromJson(Map<String, dynamic> json) => _$MyModelFromJson(json); }\n\nNote:\n\nIn order to serialize nested lists of freezed objects, you are supposed to either specify a @JsonSerializable(explicitToJson: true) or change explicit_to_json inside your build.yaml file (see the documentation).\n\nDeserializing generic classes #\n\nIn order to de/serialize generic typed freezed objects, you can enable genericArgumentFactories.\n\nAll you need to do is to change the signature of the fromJson method and add genericArgumentFactories: true to the freezed configuration.\n\n@Freezed(genericArgumentFactories: true) sealed class ApiResponse<T> with _$ApiResponse<T> { const factory ApiResponse.data(T data) = ApiResponseData; const factory ApiResponse.error(String message) = ApiResponseError; factory ApiResponse.fromJson(Map<String, dynamic> json, T Function(Object?) fromJsonT) => _$ApiResponseFromJson(json, fromJsonT); }\n\nAlternatively, you can enable genericArgumentFactories for the whole project by modifying your build.yaml file to include the following:\n\ntargets: $default: builders: freezed: options: generic_argument_factories: true\n\nWhat about @JsonKey annotation?\n\nAll decorators passed to a constructor parameter are \"copy-pasted\" to the generated property too.\n\nAs such, you can write:\n\n@freezed class Example with _$Example { factory Example(@JsonKey(name: 'my_property') String myProperty) = _Example; factory Example.fromJson(Map<String, dynamic> json) => _$ExampleFromJson(json); }\n\nWhat about @JsonSerializable annotation?\n\nYou can pass @JsonSerializable annotation by placing it over constructor e.g.:\n\n@freezed class Example with _$Example { @JsonSerializable(explicitToJson: true) factory Example(@JsonKey(name: 'my_property') SomeOtherClass myProperty) = _Example; factory Example.fromJson(Map<String, dynamic> json) => _$ExampleFromJson(json); }\n\nIf you want to define some custom json_serializable flags for all the classes (e.g. explicit_to_json or any_map) you can do it via build.yaml file as described here.\n\nSee also the decorators section\n\nUnion types #\n\nComing from other languages, you may be used to features like \"union types,\" \"sealed classes,\" and pattern matching.\n\nThese are powerful tools in combination with a type system, but Dart 2 does not support them. Dart 3 does support them, but it isn't particularly ergonomic to use them.\n\nBut fear not, Freezed supports them, generating a few utilities to help you!\n\nLong story short, in any Freezed class, you can write multiple constructors:\n\n@freezed sealed class Union with _$Union { const factory Union.data(int value) = Data; const factory Union.loading() = Loading; const factory Union.error([String? message]) = Error; }\n\nBy doing this, our model now can be in different mutually exclusive states.\n\nIn particular, this snippet defines a model Union, and that model has 3 possible states:\n\ndata\n\nloading\n\nerror\n\nNote how we gave meaningful names to the right hand of the factory constructors we defined. They will come in handy later.\n\nOne thing you may also notice is that with this example, we can no longer write code such as:\n\nvoid main() { Union union = Union.data(42); print(union.value); // compilation error: property value does not exist }\n\nWe'll see why in the following section.\n\nShared properties #\n\nWhen defining multiple constructors, you will lose the ability to read properties that are not common to all constructors:\n\nFor example, if you write:\n\n@freezed sealed class Example with _$Example { const factory Example.person(String name, int age) = Person; const factory Example.city(String name, int population) = City; }\n\nThen you will be unable to read age and population directly:\n\nvar example = Example.person('Remi', 24); print(example.age); // does not compile!\n\nOn the other hand, you can read properties that are defined on all constructors. For example, the name variable is common to both Example.person and Example.city constructors.\n\nAs such we can write:\n\nvar example = Example.person('Remi', 24); print(example.name); // Remi example = Example.city('London', 8900000); print(example.name); // London\n\nThe same logic can be applied to copyWith too.\n\nWe can use copyWith with properties defined on all constructors:\n\nvar example = Example.person('Remi', 24); print(example.copyWith(name: 'Dash')); // Example.person(name: Dash, age: 24) example = Example.city('London', 8900000); print(example.copyWith(name: 'Paris')); // Example.city(name: Paris, population: 8900000)\n\nOn the other hand, properties that are unique to a specific constructor aren't available:\n\nvar example = Example.person('Remi', 24); example.copyWith(age: 42); // compilation error, parameter `age` does not exist\n\nTo solve this problem, we need check the state of our object using what we call \"pattern matching\".\n\nUsing pattern matching to read non-shared properties #\n\nFor this section, let's consider the following union:\n\n@freezed sealed class Example with _$Example { const factory Example.person(String name, int age) = Person; const factory Example.city(String name, int population) = City; }\n\nLet's see how we can use pattern matching to read the content of an Example instance.\n\nFor this, you should use Dart 3's built-in pattern matching using switch:\n\nswitch (example) { Person(:final name) => print('Person $name'), City(:final population) => print('City ($population)'), }\n\nIf using Dart 2, you can use also use the legacy pattern matching utilities generated by Freezed to inspect the content of our object. You could also using is/as to cast an Example variable into either a Person or a City, but this is heavily discouraged. Use one of the other two options.\n\n(Legacy) Pattern matching utilities\n\nWhen\n\nThe when method is the equivalent to pattern matching with destructing.\n\nThe prototype of the method depends on the constructors defined.\n\nFor example, with:\n\n@freezed sealed class Union with _$Union { const factory Union(int value) = Data; const factory Union.loading() = Loading; const factory Union.error([String? message]) = ErrorDetails; }\n\nThen when will be:\n\nvar union = Union(42); print( union.when( (int value) => 'Data $value', loading: () => 'loading', error: (String? message) => 'Error: $message', ), ); // Data 42\n\nWhereas if we defined:\n\n@freezed sealed class Model with _$Model { factory Model.first(String a) = First; factory Model.second(int b, bool c) = Second; }\n\nThen when will be:\n\nvar model = Model.first('42'); print( model.when( first: (String a) => 'first $a', second: (int b, bool c) => 'second $b $c' ), ); // first 42\n\nNotice how each callback matches with a constructor's name and prototype.\n\nMap\n\nThe map methods are equivalent to when, but without destructuring.\n\nConsider this class:\n\n@freezed sealed class Model with _$Model { factory Model.first(String a) = First; factory Model.second(int b, bool c) = Second; }\n\nWith such class, while when will be:\n\nvar model = Model.first('42'); print( model.when( first: (String a) => 'first $a', second: (int b, bool c) => 'second $b $c' ), ); // first 42\n\nmap will instead be:\n\nvar model = Model.first('42'); print( model.map( first: (First value) => 'first ${value.a}', second: (Second value) => 'second ${value.b} ${value.c}' ), ); // first 42\n\nThis can be useful if you want to do complex operations, like copyWith/toString for example:\n\nvar model = Model.second(42, false) print( model.map( first: (value) => value, second: (value) => value.copyWith(c: true), ) ); // Model.second(b: 42, c: true)\n\nConfigurations #\n\nFreezed offers various options to customize the generated code. For example, you may want to disable the generation of when methods.\n\nTo do so, there are two possibilities:\n\nChanging the behavior for a specific model #\n\nIf you want to customize the generated code for only one specific class, you can do so by using a different annotation:\n\n@Freezed() class Person with _$Person { factory Person(String name, int age) = _Person; }\n\nBy doing so, you can now pass various parameters to @Freezed to change the output:\n\n@Freezed( // Disable the generation of copyWith/== copyWith: false, equal: false, ) class Person with _$Person {...}\n\nTo view all the possibilities, see the documentation of @Freezed: https://pub.dev/documentation/freezed_annotation/latest/freezed_annotation/Freezed-class.html\n\nChanging the behavior for the entire project #\n\nInstead of applying your modification to a single class, you may want to apply it to all Freezed models at the same time.\n\nYou can do so by customizing a file called build.yaml\n\nThis file is an optional configuration file that should be placed next to your pubspec.yaml:\n\nmy_project_folder/ pubspec.yaml build.yaml lib/\n\nThere, you will be able to change the same options as the options found in @Freezed (see above) by writing:\n\ntargets: $default: builders: freezed: options: # Tells Freezed not to format .freezed.dart files. # This can significantly speed up code-generation. format: false # Disable the generation of copyWith/== for the entire project copy_with: false equal: false # `when` and `map` can be enabled/disabled entirely by setting them to `true`/`false` map: false # We can also enable/disable specific variants of `when`/`map` by setting them to `true`/`false`: when: when: true maybe_when: true when_or_null: false\n\nUtilities #\n\nIDE Extensions #\n\nFreezed extension for VSCode #\n\nThe Freezed extension might help you work faster with freezed. For example :\n\nUse Ctrl+Shift+B (Cmd+Shift+B on Mac) to quickly build using build_runner.\n\nQuickly generate a Freezed class by using Ctrl+Shift+P (Cmd+Shift+P on Mac)> Generate Freezed class.\n\nFreezed extension for IntelliJ/Android Studio #\n\nYou can get Live Templates for boiler plate code here.\n\nExample:\n\ntype freezedClass and press Tab to generate a freezed class\n\n@freezed class Demo with _$Demo { }\n\ntype freezedFromJson and press Tab to generate the fromJson method for json_serializable\n\nfactory Demo.fromJson(Map<String, dynamic> json) => _$DemoFromJson(json);\n\nThis part contains community-made tools which integrate with Freezed.\n\nDartJ #\n\nDartJ is Flutter application, made by @ttpho, which will generate the Freezed classes from a JSON payload.\n\nExample:"
    }
}