{
    "id": "dbpedia_8291_1",
    "rank": 80,
    "data": {
        "url": "https://docs.openstack.org/ironic/latest/install/configure-pxe.html",
        "read_more_link": "",
        "language": "en",
        "title": "Configuring Network Boot — ironic 26.0.1.dev21 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.openstack.org/ironic/latest/_static/images/docs/license.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Configuring Network BootÂ¶\n\nIronicâs primary means of booting hardware to perform actions or work on a baremetal node is to perform network booting. Traditionally, this has meant the use of Preboot Execution Environment, or PXE. This support and and functionality has evolve as time has gone on to include support for not just the pxe boot_interface in concert with hardware vendor specific variations, but also a distinct ipxe setting for boot_interface with default values to enable use of iPXE.\n\nAs time passed, http and http-ipxe values were also added as valid boot_interface options which may be used, which are functionally identical in behavior to pxe and ipxe, except HTTP is used as the transport mechanism. Not all hardware supports HTTPBoot, as it is often referred.\n\nDHCP server setupÂ¶\n\nA DHCP server is required for network boot clients. You need to follow steps below.\n\nSet the [dhcp]/dhcp_provider to neutron in the Bare Metal Serviceâs configuration file (/etc/ironic/ironic.conf):\n\nNote\n\nRefer Configure tenant networks for details. The dhcp_provider configuration is already set by the configuration defaults, and when you create subnet, DHCP is also enabled if you do not add any dhcp options at âopenstack subnet createâ command.\n\nEnable DHCP in the subnet of provisioning network to be used for network boot (PXE, iPXE, HTTPBoot) operations.\n\nSet the ip address range in the subnet for DHCP.\n\nNote\n\nRefer Configure the Networking service for bare metal provisioning for details about the two precedent steps.\n\nConnect the openstack DHCP agent to the external network through the OVS bridges and the interface eth2.\n\nNote\n\nRefer Configure the Networking service for bare metal provisioning for details. You do not require this part if br-int, br-eth2 and eth2 are already connected.\n\nConfigure the host ip at br-eth2. If it locates at eth2, do below:\n\nip addr del 192.168.2.10/24 dev eth2 ip addr add 192.168.2.10/24 dev br-eth2\n\nNote\n\nReplace eth2 with the interface on the network node which you are using to connect to the Bare Metal service.\n\nTFTP server setupÂ¶\n\nIn order to deploy instances via PXE, a TFTP server needs to be set up on the Bare Metal service nodes which run the ironic-conductor.\n\nMake sure the tftp root directory exist and can be written to by the user the ironic-conductor is running as. For example:\n\nsudo mkdir -p /tftpboot sudo chown -R ironic /tftpboot\n\nInstall tftp server:\n\nUbuntu:\n\nsudo apt-get install xinetd tftpd-hpa\n\nRHEL8/CentOS8/Fedora:\n\nsudo dnf install tftp-server xinetd\n\nSUSE:\n\nsudo zypper install tftp xinetd\n\nUsing xinetd to provide a tftp server setup to serve /tftpboot. Create or edit /etc/xinetd.d/tftp as below:\n\nservice tftp { protocol = udp port = 69 socket_type = dgram wait = yes user = root server = /usr/sbin/in.tftpd server_args = -v -v -v -v -v --map-file /tftpboot/map-file /tftpboot disable = no # This is a workaround for Fedora, where TFTP will listen only on # IPv6 endpoint, if IPv4 flag is not used. flags = IPv4 }\n\nand restart the xinetd service:\n\nUbuntu:\n\nsudo service xinetd restart\n\nFedora/RHEL8/CentOS8/SUSE:\n\nsudo systemctl restart xinetd\n\nNote\n\nIn certain environments the networkâs MTU may cause TFTP UDP packets to get fragmented. Certain PXE firmwares struggle to reconstruct the fragmented packets which can cause significant slow down or even prevent the server from PXE booting. In order to avoid this, TFTPd provides an option to limit the packet size so that it they do not get fragmented. To set this additional option in the server_args above:\n\n--blocksize <MAX MTU minus 32>\n\nCreate a map file in the tftp boot directory (/tftpboot):\n\necho 're ^(/tftpboot/) /tftpboot/\\2' > /tftpboot/map-file echo 're ^/tftpboot/ /tftpboot/' >> /tftpboot/map-file echo 're ^(^/) /tftpboot/\\1' >> /tftpboot/map-file echo 're ^([^/]) /tftpboot/\\1' >> /tftpboot/map-file\n\nUEFI PXE - Grub setupÂ¶\n\nIn order to deploy instances with PXE on bare metal nodes which support UEFI, perform these additional steps on the ironic conductor node to configure the PXE UEFI environment.\n\nNote\n\nMost commercial Linux distributions have signed shim and grub binaries, which are required for Secure Boot.\n\nInstall Grub2 and shim packages:\n\nUbuntu (18.04LTS and later):\n\nsudo apt-get install grub-efi-amd64-signed shim-signed\n\nRHEL8/CentOS8/Fedora:\n\nsudo dnf install grub2-efi shim\n\nSUSE:\n\nsudo zypper install grub2-x86_64-efi shim\n\nCopy grub and shim boot loader images to /tftpboot directory:\n\nUbuntu (18.04LTS and later):\n\nsudo cp /usr/lib/shim/shimx64.efi.signed /tftpboot/bootx64.efi sudo cp /usr/lib/grub/x86_64-efi-signed/grubnetx64.efi.signed /tftpboot/grubx64.efi\n\nFedora:\n\nsudo cp /boot/efi/EFI/fedora/shim.efi /tftpboot/bootx64.efi sudo cp /boot/efi/EFI/fedora/grubx64.efi /tftpboot/grubx64.efi\n\nRHEL8/CentOS8:\n\nsudo cp /boot/efi/EFI/centos/shim.efi /tftpboot/bootx64.efi sudo cp /boot/efi/EFI/centos/grubx64.efi /tftpboot/grubx64.efi\n\nSUSE:\n\nsudo cp /usr/lib64/efi/shim.efi /tftpboot/bootx64.efi sudo cp /usr/lib/grub2/x86_64-efi/grub.efi /tftpboot/grubx64.efi\n\nUpdate the bare metal node with boot_mode:uefi capability in nodeâs properties field. See Boot mode support for details.\n\nMake sure that bare metal node is configured to boot in UEFI boot mode and boot device is set to network/pxe.\n\nNote\n\nSome drivers, e.g. ilo, irmc and redfish, support automatic setting of the boot mode during deployment. This step is not required for them. Please check Drivers, Hardware Types and Hardware Interfaces for information on whether your driver requires manual UEFI configuration.\n\niPXE setupÂ¶\n\nIf you will be using iPXE to boot instead of PXE, iPXE needs to be set up on the Bare Metal service node(s) where ironic-conductor is running.\n\nMake sure these directories exist and can be written to by the user the ironic-conductor is running as. For example:\n\nsudo mkdir -p /tftpboot sudo mkdir -p /httpboot sudo chown -R ironic /tftpboot sudo chown -R ironic /httpboot\n\nCreate a map file in the tftp boot directory (/tftpboot):\n\necho 'r ^([^/]) /tftpboot/\\1' > /tftpboot/map-file echo 'r ^(/tftpboot/) /tftpboot/\\2' >> /tftpboot/map-file\n\nSet up TFTP and HTTP servers.\n\nThese servers should be running and configured to use the local /tftpboot and /httpboot directories respectively, as their root directories. (Setting up these servers is outside the scope of this install guide.)\n\nThese root directories need to be mounted locally to the ironic-conductor services, so that the services can access them.\n\nThe Bare Metal serviceâs configuration file (/etc/ironic/ironic.conf) should be edited accordingly to specify the TFTP and HTTP root directories and server addresses. For example:\n\n[pxe] # Ironic compute node's tftp root path. (string value) tftp_root=/tftpboot # IP address of Ironic compute node's tftp server. (string # value) tftp_server=192.168.0.2 [deploy] # Ironic compute node's http root path. (string value) http_root=/httpboot # Ironic compute node's HTTP server URL. Example: # http://192.1.2.3:8080 (string value) http_url=http://192.168.0.2:8080\n\nSee also: Deploying outside of the provisioning network.\n\nInstall the iPXE package with the boot images:\n\nUbuntu:\n\napt-get install ipxe\n\nRHEL8/CentOS8/Fedora:\n\ndnf install ipxe-bootimgs\n\nNote\n\nSUSE does not provide a package containing iPXE boot images. If you are using SUSE or if the packaged version of the iPXE boot image doesnât work, you can download a prebuilt one from http://boot.ipxe.org or build one image from source, see http://ipxe.org/download for more information.\n\nNote\n\nThe Ironic project is unaware of any vendor signed iPXE binaries to enable use of iPXE with Secure Boot, unless you have implemented your own Secure Boot key signing and support for the Machine Owner Key settings on individual baremetal nodes.\n\nCopy the iPXE boot image (undionly.kpxe for BIOS and ipxe.efi for UEFI) to /tftpboot. The binary might be found at:\n\nUbuntu:\n\ncp /usr/lib/ipxe/{undionly.kpxe,ipxe.efi,snponly.efi} /tftpboot\n\nFedora/RHEL8/CentOS8:\n\ncp /usr/share/ipxe/{undionly.kpxe,ipxe-x86_64.efi,ipxe-snponly-x86_64.efi} /tftpboot\n\nNote\n\nsnponly variants may not be available for all distributions.\n\nEnable/Configure iPXE overrides in the Bare Metal Serviceâs configuration file if required (/etc/ironic/ironic.conf):\n\n[pxe] # Neutron bootfile DHCP parameter. (string value) ipxe_bootfile_name=undionly.kpxe # Bootfile DHCP parameter for UEFI boot mode. (string value) uefi_ipxe_bootfile_name=ipxe.efi # Template file for PXE configuration. (string value) ipxe_config_template=$pybasedir/drivers/modules/ipxe_config.template\n\nNote\n\nMost UEFI systems have integrated networking which means the pxe.uefi_ipxe_bootfile_name setting should be set to snponly.efi or ipxe-snponly-x86_64.efi if itâs available for your distribution.\n\nNote\n\nSetting the iPXE parameters noted in the code block above to no value, in other words setting a line to something like ipxe_bootfile_name= will result in ironic falling back to the default values of the non-iPXE PXE settings. This is for backwards compatibility.\n\nEnsure iPXE is the default PXE, if applicable.\n\nIn earlier versions of ironic, a now deprecated and removed [pxe]ipxe_enabled setting allowed operators to declare the behavior of the conductor to exclusively operate as if only iPXE was to be used. As time moved on, iPXE functionality was moved to itâs own ipxe boot interface.\n\nIf you want to emulate that same behavior, set the following in the configuration file (/etc/ironic/ironic.conf):\n\n[DEFAULT] default_boot_interface=ipxe enabled_boot_interfaces=ipxe,pxe\n\nNote\n\nThe DEFAULT.enabled_boot_interfaces setting may be exclusively set to ipxe, however ironic has multiple interfaces available depending on the hardware types available for use.\n\nIt is possible to configure the Bare Metal service in such a way that nodes will boot into the deploy image directly from Object Storage. Doing this avoids having to cache the images on the ironic-conductor host and serving them via the ironic-conductorâs HTTP server. This can be done if:\n\nthe Image Service is used for image storage;\n\nthe images in the Image Service are internally stored in Object Storage;\n\nthe Object Storage supports generating temporary URLs for accessing objects stored in it. Both the OpenStack Swift and RADOS Gateway provide support for this.\n\nSee Ceph Object Gateway support on how to configure the Bare Metal Service with RADOS Gateway as the Object Storage.\n\nConfigure this by setting the [pxe]/ipxe_use_swift configuration option to True as follows:\n\n[pxe] # Download deploy images directly from swift using temporary # URLs. If set to false (default), images are downloaded to # the ironic-conductor node and served over its local HTTP # server. Applicable only when 'ipxe_enabled' option is set to # true. (boolean value) ipxe_use_swift=True\n\nAlthough the HTTP server still has to be deployed and configured (as it will serve iPXE boot script and boot configuration files for nodes), such configuration will shift some load from ironic-conductor hosts to the Object Storage service which can be scaled horizontally.\n\nNote that when SSL is enabled on the Object Storage service you have to ensure that iPXE firmware on the nodes can indeed boot from generated temporary URLs that use HTTPS protocol.\n\nRestart the ironic-conductor process:\n\nFedora/RHEL8/CentOS8/SUSE:\n\nsudo systemctl restart openstack-ironic-conductor\n\nUbuntu:\n\nsudo service ironic-conductor restart\n\nPXE multi-architecture setupÂ¶\n\nIt is possible to deploy servers of different architecture by one conductor. To use this feature, architecture-specific boot and template files must be configured using the configuration options pxe.pxe_bootfile_name_by_arch and pxe.pxe_config_template_by_arch respectively, in the Bare Metal serviceâs configuration file (/etc/ironic/ironic.conf).\n\nThese two options are dictionary values; the key is the architecture and the value is the boot (or config template) file. A nodeâs cpu_arch property is used as the key to get the appropriate boot file and template file. If the nodeâs cpu_arch is not in the dictionary, the configuration options (in [pxe] group) pxe_bootfile_name, pxe_config_template, uefi_pxe_bootfile_name and uefi_pxe_config_template will be used instead.\n\nIn the following example, since âx86â and âx86_64â keys are not in the pxe_bootfile_name_by_arch or pxe_config_template_by_arch options, x86 and x86_64 nodes will be deployed by âundionly.kpxeâ or âbootx64.efiâ, depending on the nodeâs boot_mode capability (âbiosâ or âuefiâ). However, aarch64 nodes will be deployed by âgrubaa64.efiâ, and ppc64 nodes by âbootppc64â:\n\n[pxe] # Bootfile DHCP parameter. (string value) pxe_bootfile_name=undionly.kpxe # On ironic-conductor node, template file for PXE # configuration. (string value) pxe_config_template = $pybasedir/drivers/modules/ipxe_config.template # Bootfile DHCP parameter for UEFI boot mode. (string value) uefi_pxe_bootfile_name=bootx64.efi # On ironic-conductor node, template file for PXE # configuration for UEFI boot loader. (string value) uefi_pxe_config_template=$pybasedir/drivers/modules/pxe_grub_config.template # Bootfile DHCP parameter per node architecture. (dict value) pxe_bootfile_name_by_arch=aarch64:grubaa64.efi,ppc64:bootppc64 # On ironic-conductor node, template file for PXE # configuration per node architecture. For example: # aarch64:/opt/share/grubaa64_pxe_config.template (dict value) pxe_config_template_by_arch=aarch64:pxe_grubaa64_config.template,ppc64:pxe_ppc64_config.template\n\nNote\n\nThe grub implementation may vary on different architecture, you may need to tweak the pxe config template for a specific arch. For example, grubaa64.efi shipped with CentoOS7 does not support linuxefi and initrdefi commands, youâll need to switch to use linux and initrd command instead.\n\nNote\n\nA pxe.ipxe_bootfile_name_by_arch setting is available for multi-arch iPXE based deployment, and defaults to the same behavior as the comperable pxe.pxe_bootfile_name_by_arch setting for standard PXE.\n\nNote\n\nWhen booting PowerPC based machines, the firmware loader directly boots a kernel and ramdisk. It explicitly reads a âpxelinuxâ style template, and then directly retrieves the files defined in the file without a ânetwork boot programâ.\n\nPXE timeouts tuningÂ¶\n\nBecause of its reliance on UDP-based protocols (DHCP and TFTP), PXE is particularly vulnerable to random failures during the booting stage. If the deployment ramdisk never calls back to the bare metal conductor, the build will be aborted, and the node will be moved to the deploy failed state, after the deploy callback timeout. This timeout can be changed via the conductor.deploy_callback_timeout configuration option.\n\nStarting with the Train release, the Bare Metal service can retry PXE boot if it takes too long. The timeout is defined via pxe.boot_retry_timeout and must be smaller than the deploy_callback_timeout, otherwise it will have no effect.\n\nFor example, the following configuration sets the overall timeout to 60 minutes, allowing two retries after 20 minutes:\n\n[conductor] deploy_callback_timeout=3600 [pxe] boot_retry_timeout=1200\n\nPXE artifactsÂ¶\n\nIronic features the capability to load PXE artifacts into the conductor startup, minimizing the need for external installation and configuration management tooling from having to do additional work to facilitate.\n\nWhile this is an advanced feature, and destination file names must match existing bootloader configured filenames.\n\nFor example, if using iPXE and GRUB across interfaces, you may desire a configuration similar to this example.\n\n[pxe] loader_file_paths=ipxe.efi:/usr/share/ipxe/ipxe-snponly-x86_64.efi,undionly.kpxe:/usr/share/ipxe/undionly.kpxe,bootx64.efi,/boot/efi/EFI/boot/grubx64.efi,bootx64.efi:/boot/efi/EFI/boot/BOOTX64.EFI\n\nIf you choose to use relative paths as part of your destination, those paths will be created using configuration parameter pxe.dir_permission where as actual files copied are set with the configuration parameter pxe.file_permission. Absolute destination paths are not supported and will result in ironic failing to start up as it is a misconfiguration of the deployment.\n\nConfiguring unmanaged in-band inspectionÂ¶\n\nThis section must be followed if you intend to use Unmanaged inspection without ironic-inspector. For ironic-inspector support, check its installation guide.\n\nWith PXEÂ¶\n\nAfter you followed TFTP Server Setup, you need to create the default PXE configuration. Populate /tftpboot/pxelinux.cfg/default with the following contents:\n\ndefault introspect label introspect kernel ironic-python-agent.kernel append initrd=ironic-python-agent.initramfs ipa-inspection-callback-url=http://{IP}:6385/v1/continue_inspection systemd.journald.forward_to_console=yes ipappend 3\n\nInstead of http://{IP}:6385/v1/continue_inspection, insert the correct Bare Metal API endpoint, keeping the mandatory /v1/continue_inspection suffix. You may also populate other IPA options (e.g. ipa-debug=1 for detailed logging, ipa-inspection-collectors to customize the inspection process, or ipa-api-url to enable Fast-Track Deployment).\n\nSecond, you need to configure DHCP for unknown hosts since the OpenStack Networking service wonât be able to handle them. For instance, you can install dnsmasq and use the following /etc/dnsmasq.conf:\n\nport=0 interface={INTERFACE} bind-interfaces dhcp-range={DHCP IP RANGE, e.g. 192.168.0.50,192.168.0.150} enable-tftp tftp-root=/tftpboot dhcp-boot=pxelinux.0 dhcp-sequential-ip\n\nIf you need this dnsmasq instance to co-exist with the OpenStack Networking service, some measures must be taken to prevent them from clashing over DHCP requests. One way to do it is to physically separate the inspection network. Another - to configure the PXE filter service.\n\nFinally, build or download IPA images into /tftpboot/ironic-python-agent.kernel and /tftpboot/ironic-python-agent.initramfs. These can be the same images that you use for deployment and cleaning.\n\nWith iPXEÂ¶\n\niPXE configuration is pretty similar to PXE above, but differs in details. Start with iPXE Setup, then create a new file /httpboot/inspection.ipxe with the following contents:\n\n#!ipxe :retry_dhcp dhcp || goto retry_dhcp :retry_boot imgfree kernel --timeout 30000 http://{IP}:8080/ironic-python-agent.kernel ipa-inspection-callback-url=http://{IP}:6385/v1/continue_inspection systemd.journald.forward_to_console=yes BOOTIF=${mac} initrd=ironic-python-agent.initramfs || goto retry_boot initrd --timeout 30000 http://{IP}:8080/ironic-python-agent.initramfs || goto retry_boot boot\n\nJust as with PXE, adjust ipa-inspection-callback-url to match your deployment and add any required IPA options. You also need to fix {IP}:8080 to match the iPXE server you configured previously.\n\nThe DHCP configuration is much more complex. Since most hardware does not have an up-to-date iPXE firmware, you need to bootstrap it from TFTP. The dnsmasq configuration may look roughly like this:\n\nport=0 interface={INTERFACE} bind-interfaces dhcp-range={DHCP IP RANGE, e.g. 192.168.0.50,192.168.0.150} enable-tftp tftp-root=/tftpboot dhcp-sequential-ip dhcp-match=ipxe,175 dhcp-match=set:efi,option:client-arch,7 dhcp-match=set:efi,option:client-arch,9 dhcp-match=set:efi,option:client-arch,11 # dhcpv6.option: Client System Architecture Type (61) dhcp-match=set:efi6,option6:61,0007 dhcp-match=set:efi6,option6:61,0009 dhcp-match=set:efi6,option6:61,0011 dhcp-userclass=set:ipxe6,iPXE # Client is already running iPXE; move to next stage of chainloading dhcp-boot=tag:ipxe,http://{IP}:8080/inspection.ipxe # Client is PXE booting over EFI without iPXE ROM, # send EFI version of iPXE chainloader dhcp-boot=tag:efi,tag:!ipxe,ipxe.efi dhcp-option=tag:efi6,tag:!ipxe6,option6:bootfile-url,tftp://{IP}/ipxe.efi # Client is running PXE over BIOS; send BIOS version of iPXE chainloader dhcp-boot=undionly.kpxe,localhost.localdomain,{IP}\n\nNote\n\nItâs not trivial to write such a configuration from scratch. In addition to this document, you may take some inspiration from Bifrost and Metal3.\n\nFinally, put ironic-python-agent.kernel and ironic-python-agent.initramfs to /httpboot.\n\nHTTPBootÂ¶\n\nHTTPBoot interfaces in Ironic are built upon the underlying network boot substrate. This means much of the configuration in the [pxe] and [deploy] impacts the use of HTTPBoot, except when Ironic is setting DHCP parameters, it populates a HTTP(S) URL to the DHCP server, which is then transmitted to the client attempting to Network Boot. In large part, this is because HTTPBoot is an evolution of PXE Boot technique and technology.\n\nThis means a TFTP server is not required, but the HTTP server is required as if you are utilizing iPXE. This is largely because iPXE has traditionally been leveraged by Operators to limit the TFTP packets being transmitted via UDP across a network.\n\nOne aspect to keep in mind, is HTTPBoot is relatively new when compared to PXE boot, and not all bootloaders may support HTTPBoot, as the underlying UEFI standard upon which it was largely based, UEFI v2.5, was published in 2015.\n\nIronic contains two distinct flavors of HTTPBoot, largely based upon what configuration defaults are used in terms of boot loader, templates, and overall mechanism style.\n\nhttp is the boot interface based upon the pxe boot interface. This is the interface you would want to use if you had, for example, a signed GRUB2 bootloader chain to utilize. In this case it is up to the boot loader to understand how to extract and run with the URL, and then retrieves any additional configuration loader files and configuration templates created on disk.\n\nhttp-ipxe is the boot interface based upon the ipxe boot interface. This interface signals to the client to utilize the configured iPXE loader binary over HTTP, and then the boot sequence proceeds with the pattern and capabilities of iPXE.\n\nTo enable the boot interfaces, you will need to add them to your DEFAULT.enabled_boot_interfaces configuration entry.\n\n[DEFAULT] enabled_boot_interfaces=ipxe,http-ipxe,pxe,http"
    }
}