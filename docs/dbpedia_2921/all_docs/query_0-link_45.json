{
    "id": "dbpedia_2921_0",
    "rank": 45,
    "data": {
        "url": "https://nchronas.github.io/upsat_msc_thesis/",
        "read_more_link": "",
        "language": "en",
        "title": "thesis",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://nchronas.github.io/upsat_msc_thesis/media/image3.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image4.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image5.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image6.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image7.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image9.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image10.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image11.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image12.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image13.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image14.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image15.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image16.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image17.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image18.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image19.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image20.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image21.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image22.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image23.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image24.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image25.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image26.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image27.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image28.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image29.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image30.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image31.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image32.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image33.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image34.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image35.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image36.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image37.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image38.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image39.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image40.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image41.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image42.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image43.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image44.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image45.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image46.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image47.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image48.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image49.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image50.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image51.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image52.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image53.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image54.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image55.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image56.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image57.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image58.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image59.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image60.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image61.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image62.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image63.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image64.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image65.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image66.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image67.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image68.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image69.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image70.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image71.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image72.PNG",
            "https://nchronas.github.io/upsat_msc_thesis/media/image73.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image74.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image75.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image76.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image77.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image78.png",
            "https://nchronas.github.io/upsat_msc_thesis/media/image79.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image80.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image81.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image82.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image83.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image84.jpg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image85.jpeg",
            "https://nchronas.github.io/upsat_msc_thesis/media/image86.jpeg",
            "https://i.creativecommons.org/l/by-nc-nd/4.0/80x15.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "upsat_msc_thesis",
        "canonical_link": "https://nchronas.github.io/upsat_msc_thesis/",
        "text": "ABSTRACT\n\nSpace the final frontier, has been a elusive dream since the birth of the humankind. After humankind broke out from the limits of Earth and reached space, it inspired us even more. CubeSats provide access to space for a wider audience pushing the frontier once more. As a step towards that future UPSat, the first truly open source in both hardware and software paves the way for a more open and democratized space. \\ \\ This thesis describes the design, implementation and testing of 2 software modules of UPSat: the command and control module plus the on-board computer software.\\ \\ The command and control module holds all the reusable software used in the subsystems, a common way to access it through the protocol defined ECSS-E-70-41A specification and implemented in the form of services that each subsystem provides.\\ \\ The on-board computer, the heart of UPSat provide critical operation and it is responsible for packet routing, housekeeping, timekeeping, the science unit m-NLP and the image acquisition component operation and finally mass storage of logs and configuration parameters.\\ \\ The software besides the required functionality must be written in a way that is fault tolerant and protected from the radiation induced effects and possible failures and errors.\\ \\ The primary purpose of this thesis is for the reader to easily comprehend our rational and thought process behind every action so it will give him an insight to our design intentions and hopefully provide the necessary information so that future designs are improved.\n\nSUBJECT AREA: CubeSat.\n\nKEYWORDS: fault tolerance, space, CubeSat, command and control\n\nCONTENTS\n\n1. INTRODUCTION 21\n\n1.1 Time 21\n\n1.2 Space and software 21\n\n1.3 CubeSats 22\n\n1.4 Commercial Off The Shelf Components 22\n\n1.5 Space and open source 23\n\n1.6 SatNOGS 23\n\n1.7 Mission requirements 25\n\n1.8 UPSat 27\n\n1.8.1 COMMS 29\n\n1.8.2 OBC 30\n\n1.8.3 ADCS 31\n\n1.8.4 EPS 32\n\n1.8.5 Science Unit 33\n\n1.8.6 IAC 33\n\n2. RESEARCH 34\n\n2.1 Single event effects and rad hard 34\n\n2.1.1 Radiation effects 35\n\n2.1.2 Protection from radiation effects 36\n\n2.2 State of the art 37\n\n2.2.1 NASA state of the art 37\n\n2.2.2 ZA-Aerosat 37\n\n2.2.3 SwissCube 37\n\n2.2.4 Phonesat 39\n\n2.2.5 CKUTEX 40\n\n2.2.6 i-INSPIRE II 40\n\n2.3 Command and control module 41\n\n2.3.1 Requirements 41\n\n2.3.2 CSP 41\n\n2.3.3 ECSS 42\n\n2.3.4 Comparison 43\n\n2.3.5 Result 44\n\n2.4 Safety critical software 44\n\n2.4.1 Undefined behavior 44\n\n2.4.2 Coding standards 45\n\n2.5 Fault tolerance 45\n\n2.5.1 Fault tolerant mechanisms 46\n\n2.5.2 Built in tests 46\n\n2.5.3 Single point of failure 46\n\n2.5.4 State of the art fault tolerance 47\n\n2.5.5 Fault tolerance in hardware 48\n\n2.5.6 Fault tolerance in software 49\n\n3. DESIGN 50\n\n3.1 Coding standards on UPSat 50\n\n3.1.1 10 rules 50\n\n3.1.2 17 steps 50\n\n3.2 Fault tolerance on UPSat 51\n\n3.2.1 Assertions 51\n\n3.2.2 Watchdog 51\n\n3.2.3 Heartbeat 53\n\n3.2.4 Multiple checks 54\n\n3.3 OBC 54\n\n3.3.1 OBC-ADCS schism 54\n\n3.3.2 OBC real time constraints 54\n\n3.3.3 RTOS Vs baremetal and FreeRTOS 55\n\n3.3.4 FreeRTOS concepts 56\n\n3.3.5 Introduction to FreeRTOS 56\n\n3.3.6 Tasks 57\n\n3.3.7 Critical sections 57\n\n3.3.8 Stack overflow detection 58\n\n3.3.9 Heap modes 58\n\n3.3.10 Advanced concepts 58\n\n3.3.11 Logging and file system 58\n\n3.4 ECSS services 60\n\n3.4.1 Services 60\n\n3.4.2 Application ids 63\n\n3.4.3 Packet frame 64\n\n3.4.4 Services in subsystems 66\n\n3.4.5 Software reuse 66\n\n3.4.6 Telecommand verification service 66\n\n3.4.7 Housekeeping 68\n\n3.4.8 WOD 68\n\n3.4.9 Extended WOD 69\n\n3.4.10 CW WOD 69\n\n3.4.11 Housekeeping & diagnostic data reporting service 70\n\n3.4.12 Function management service 71\n\n3.4.13 Large data transfer service 72\n\n3.4.14 On-board storage and retrieval service 74\n\n3.4.15 Test service 75\n\n4. Implementation 78\n\n4.1 ST cubeMX 78\n\n4.2 Project folder organization 79\n\n4.3 GPS 79\n\n4.4 HLDLC 80\n\n4.5 Packet Pool 81\n\n4.6 Queues 83\n\n4.7 Hardware abstraction layer 84\n\n4.8 Peripheral modes 85\n\n4.9 ECSS services 88\n\n4.10 upsat module 88\n\n4.11 Service module 91\n\n4.11.1 Error codes 92\n\n4.11.2 ECSS packet structure 92\n\n4.11.3 Assertions 96\n\n4.12 Service utilities module 96\n\n4.13 Test service module 97\n\n4.14 Telecommand verification service module 98\n\n4.15 Event reporting service module 99\n\n4.16 Housekeeping & diagnostic data reporting service module 100\n\n4.16.1 OBC Housekeeping 101\n\n4.17 Function management service module 101\n\n4.18 Time management service module 102\n\n4.19 Large data transfer service module 104\n\n4.20 Mass storage service module 105\n\n4.20.1 Note on mass storage and large data services 107\n\n4.20.2 2nd design 108\n\n4.20.3 3rd design 108\n\n4.21 SatNOGS client command and control module 109\n\n4.22 Life of a packet 109\n\n4.23 On-board computer 111\n\n4.23.1 Discovery kit 111\n\n4.23.2 FreeRTOS 111\n\n4.23.3 Real time clock 113\n\n4.23.4 FatFS 113\n\n4.23.5 Generic 114\n\n5. Testing 115\n\n5.1 OBC/ADCS PCB tests 115\n\n5.2 COMMS testing 116\n\n5.3 Unit testing 117\n\n5.4 Static analysis 118\n\n5.5 Command and control testing software 118\n\n5.6 SatNOGS client, command and control module 120\n\n5.7 Debug tools, techniques 120\n\n5.7.1 UART 121\n\n5.7.2 ST link and SWD 121\n\n5.7.3 Segger J-Link 122\n\n5.7.4 Segger systemview 122\n\n5.8 RTOS and services timing analysis 124\n\n5.8.1 Python script 124\n\n5.8.2 Arduino stress test 124\n\n5.8.3 Packet processing time analysis 124\n\n5.8.4 Packet pool timestamp 125\n\n5.8.5 Systemview 125\n\n5.9 ECSS statistics 128\n\n5.10 System operation test 129\n\n5.11 Functional tests 130\n\n5.12 e2e tests 130\n\n5.13 Environmental testing 132\n\n5.14 Testing campaign 132\n\n6. Conclusions 133\n\n6.1 Project key points 133\n\n6.2 Simplicity 134\n\n6.3 Refactor 134\n\n6.4 Future work 135\n\nABBREVIATIONS - ACRONYMS 141\n\nREFERENCES 142\n\nLIST OF FIGURES\n\nFigure 1.1 CubeSat unit specification 22\n\nFigure 1.2 CubeSat numbers 23\n\nFigure 1.3 SatNOGS [4] 24\n\nFigure 1.4 QB50 targets [8] 25\n\nFigure 1.5 UPSat subsystems. 27\n\nFigure 1.6 UPSat subsystems diagram 28\n\nFigure 1.7 COMMS subsystem [6] 29\n\nFigure 2.1 Missions with radiation issues [25] 34\n\nFigure 2.2 SEE classification [49] 35\n\nFigure 2.3 Cost of 2Mbytes rad-hard SRAM [30] 36\n\nFigure 2.4 Argos testbed rad-hard board SEU [43 36\n\nFigure 2.5 Argos testbed COTS board SEU [43] 36\n\nFigure 2.6 SwissCube exploded view [45] 38\n\nFigure 2.7 PhoneSat 2.0 data distribution architecture 40\n\nFigure 2.8 i-INSPIRE II CubeSat [47] 40\n\nFigure 2.9 i-INSPIRE II software state machine [47] 40\n\nFigure 2.10 CSP header 41\n\nFigure 2.11 ECSS TC frame header 42\n\nFigure 2.12 ECSS TC data header 42\n\nFigure 2.13 Fault tolerance mechanisms [29] 47\n\nFigure 2.14 Hardware fault tolerance [26] 48\n\nFigure 2.15 B777 flight computer [57] 48\n\nFigure 2.16 AIRBUS A320-40 flight computer [57] 49\n\nFigure 3.1 Tasks [12] 58\n\nFigure 3.2 tasks life cycle [12] 58\n\nFigure 3.3 FAT file system structure [60] 59\n\nFigure 3.4 FatFS critical operations [32] 60\n\nFigure 3.5 FatFS optimized critical operations [32] 60\n\nFigure 3.6 CW WOD frame 69\n\nFigure 3.7 CW WOD dataset 70\n\nFigure 3.8 Large data transfer split of the original packet 73\n\nFigure 4.1 OBC’s CubeMX project 78\n\nFigure 4.2 Project organization 79\n\nFigure 4.3 The life of a packet 110\n\nFigure 4.4 On-board computer software diagram 111\n\nFigure 5.1 ADCS IMU communication debugging in a logic analyzer 116\n\nFigure 5.2 Packetcraft 119\n\nFigure 5.3 UPSat command and control 120\n\nFigure 5.4 Example use of a breakpoint 121\n\nFigure 5.5 Systemview events display 123\n\nFigure 5.6 OBC extended WOD communications 126\n\nFigure 5.7 Delay before task notification fix 127\n\nFigure 5.8 Delay after task notification fix 127\n\nFigure 5.9 Mass storage service WOD storage 128\n\n\\ LIST OF IMAGES\n\nImage 1.1 SatNOGS rotator [4] 24\n\nImage 1.2 UPSat subsystems mounted in the aluminum structure 28\n\nImage 1.3 UPSat’s umbilical connector and remove before flight switch 28\n\nImage 1.4 The antenna deployment system 29\n\nImage 1.5 OBC subsystem during testing 30\n\nImage 1.6 OBC and ADCS subsystem 31\n\nImage 1.7 ADCS subsystem unpopulated PCB 31\n\nImage 1.8 ADCS Spin-Torquer 31\n\nImage 1.9 EPS subsystems PCBs 32\n\nImage 1.10 The EPS PCB with the battery pack mounted 32\n\nImage 1.11 Solar panel used in UPSat along with a SU probe 32\n\nImage 1.12 The science unit m-NLP 33\n\nImage 1.13 The DART4460 of the IAC subsystem 33\n\nImage 2.1 PhoneSat v1.0 39\n\nImage 2.2 PhoneSat v2.5 40\n\nImage 5.1 OBC prototype board 115\n\nImage 5.2 COMMS power amplifier testing 115\n\nImage 5.3 UPSat stack prototype boards 120\n\nImage 5.4 The on-board ST-link connected to the stack 121\n\nImage 5.5 J-links connected to UPSat for debugging 122\n\nImage 5.6 UPSat systemview 125\n\nImage 5.7 UPSat systemview testing 125\n\nImage 5.8 UPSat systemview testing operation 129\n\nImage 5.9 UPSat systemview operational plot 129\n\nImage 5.10 UPSat extended WOD operational plot 129\n\nImage 5.11 During S.U. E2E tests 130\n\nImage 5.12 TVAC chamber with UPSat 132\n\nImage 5.13 TVAC results 132\n\nImage 5.14 UPSat vibration test pod 132\n\nImage 5.15 UPSat subsystem thermal inspection 132\n\nImage 6.1 Some people of the team, the day before the delivery 136\n\nImage 6.2 UPSat during the final tests before delivery 136\n\nImage 6.3 UPSat in the Nanorack’s deployment pod. 137\n\nImage 6.4 UPSat 138\n\nImage 6.5 the CYGNUS supply ship that had UPSat, before docking to ISS 139\n\nImage 6.6 UPSat along with 2 other CubeSats released from ISS 140\n\nLIST OF TABLES\n\nTable 1.1 QB50 related requirements. 26\n\nTable 3.1 10 rules for developing safety critical code [39] 52\n\nTable 3.2 17 steps to safer C code [40] 53\n\nTable 3.3 ECSS services 62\n\nTable 3.4 ECSS services implemented by UPSat 63\n\nTable 3.5 UPSat application ids 63\n\nTable 3.6 Telecommand Data header 64\n\nTable 3.7 Telemetry Data header 65\n\nTable 3.8 Command and control packet frame 65\n\nTable 3.9 Services implemented in each subsystem. 66\n\nTable 3.10 Telecommand packet data ACK field settings 67\n\nTable 3.11 Telecommand verification service subtypes 67\n\nTable 3.12 Telecommand verification service acceptance report frame 67\n\nTable 3.13 Telecommand verification service acceptance failure frame. 68\n\nTable 3.14 Telecommand verification service error codes 68\n\nTable 3.15 WOD packet format 69\n\nTable 3.16 WOD dataset 69\n\nTable 3.17 Housekeeping service structure IDs 71\n\nTable 3.18 Housekeeping service request structure id frame 71\n\nTable 3.19 Housekeeping service report structure id frame 71\n\nTable 3.20 Function management service data frame 71\n\nTable 3.21 Function management services in each subsystem 72\n\nTable 3.22 Large data transfer service transfer data frame. 73\n\nTable 3.23 Large data transfer service acknowledgement frame 73\n\nTable 3.24 Large data transfer service repeat part frame 74\n\nTable 3.25 Large data transfer service abort transfer frame 74\n\nTable 3.26 On-board storage and retrieval service uplink subtype frame 75\n\nTable 3.27 On-board storage and retrieval service downlink subtype frame 75\n\nTable 3.28 On-board storage and retrieval service downlink content subtype frame 76\n\nTable 3.29 On-board storage and retrieval service subtypes used on UPSat 76\n\nTable 3.30 On-board storage and retrieval service delete subtype frame 76\n\nTable 3.31 Store IDs 77\n\nTable 3.32 On-board storage and retrieval service catalogue list subtype frame 77\n\nTable 3.33 On-board storage and retrieval service catalogue report subtype frame 77\n\nTable 4.1 Number of packets and data payload sizes in each subsystem 81\n\nTable 4.2 ECSS status codes 93\n\nTable 4.3 Event service frame 99\n\nTable 4.4 Large data transfer service, different states of the Large data state machine 105\n\nTable 5.1 Functional test list and description 131\n\nINTRODUCTION\n\nThe thesis is separated into 6 chapters that loosely correspond to the chronological time line of the events related to design and implementation.\n\nIn chapter 0 general information providing the context of the thesis will be presented.\n\nIn chapter 1 the research that was conducted in order to familiarize with the aspects of developing software for a CubeSat will be presented.\n\nIn chapter 2 the design choices that derived from the research of the previous chapter and the reasons behind them will be presented\n\nIn chapter 3 the actual implementation and the parts that diversify from the initial design and the causes of that will be discussed.\n\nIn chapter 4 the overall testing campaign and the techniques used will be presented.\n\nIn the final chapter, conclusions, thoughts and future improvements are presented and discussed.\n\nTime\n\nThe most important factor in this project was time. From the first time, I heard of UPSat, to the day I was officially involved and the original date of delivery to the final delivery date of Aug. 18, only 6 months had passed.\n\nEven though I consider my shelf to as an experienced in programmer and especially in embedded systems, writing fault tolerant software for a CubeSat was definitely new experience.\n\nThe time duration of 6 months was for: research, design, development and testing.\n\nIn this limited time frame, decisions had to be made in a instant, followed by the implementation.\n\nResearch time was reduced to minimum, design was given more time and testing was happening as the development progressed.\n\nDue to these strict conditions, time limitations affected all aspects of the CubeSat development and it was the prominent factor in all decisions.\n\nSpace and software\n\nHaving to design and implement software that is indented to work in space, differs from other projects in 2 significant factors: Environmental radiation affects the electronics resulting in corrupt memory or more permanent damage like flash and the fact that once the CubeSat is launched into space, it cannot be examined or repaired.\n\nCubeSats\n\nFigure 1.1 CubeSat unit specification\n\nCubeSats provide a low-cost access to space, it first started from California Polytechnic State University and Stanford developing the specification at 1999 with the first CubeSat launching at 2003. Most of the firsts CubeSats came from the academia but as soon as CubeSats proved their usefulness commercial companies started using it as well. Following the CubeSat as low-cost platform success are plans to send swarm of CubeSats to the moon or even mars, while all of CubeSats until now are confined to LEO.\n\nCubeSats are ideal for experiments especially high risk that justify due to the low cost of a CubeSat. A good example of that is the QB50 experiment: The cost of fleet of 50 traditional satellites is not justified by the research conducted and other means like one satellite or a rocket doesn’t spend the time in the thermosphere the researchers wished [11].\n\nCubeSats dimensions are defined in 1U that is equal to 10x10x10 cm and multiples of that. At first most of the CubeSats were 1U but later more options became available for launch configurations to 6U or even 12U.\n\nCommercial Off The Shelf Components\n\nOne reason that makes CubeSats a low-cost solution is the use of COTS. The aerospace industry traditionally uses radiation hardened components that are especially designed to withstand the extreme conditions in space. These components are a lot more expensive from the commercial available counter parts and usually one generation behind in the technologies used.\n\n(a) Cubesat launches per year [13]. (b) CubeSat launches per organization [13]. Figure 1.2 CubeSat numbers ———————————————————————————— ————————————————————————————-\n\nSpace and open source\n\nNASA states in [19]: “At the other end of the spectrum, low-cost easy-to-develop systems that take advantage of open source software and hardware are providing an easy entry into space systems development, especially for those who lack specific spacecraft expertise or for the hobbyist.”. This is also reflected in [53] as one of the best ways to improve is by reading other people’s code.\n\nSharing the same opinion, our experience, when we started working on UPSat, we couldn’t find any open source code available for examination. This made more difficult as there wasn’t a starting point in an already difficult project.\n\nIn my opinion, open source in space that fault tolerance is a must, it isn’t a luxury, but a critical necessity. By open sourcing and allowing a wider audience to view and analyze the code, not only help engage the community but also increases the possibility of discovering errors.\n\nSatNOGS\n\nThe SatNOGS [4] project aim is to provide an open source software and hardware solution of a constellation of ground stations for continuous communication with satellites in LEO. Most of the parts are designed so they can be 3d printed in order to make a ground station construction more feasible. It is currently maintained from the Libre Space Foundation [3].\n\nSatNOGS consists of 4 parts:\n\nThe Network is the web application used from the users for ground station operation.\n\nThe Database provides information about active satellites.\n\nThe Client is the software that runs on the ground stations.\n\nThe Ground Station contains the rotator, antennas and electronics.\n\nFigure 1.3 SatNOGS [4]\n\nImage 1.1 SatNOGS rotator [4]\n\nMission requirements\n\nFigure 1.4 QB50 targets [8]\n\nQB50 is a European FP7 project with worldwide participation from the von Karman Institute for Fluid Dynamics (VKI) in Brussels with the purpose to study the lower thermosphere, between 200 - 380km altitude using a network of 50 low cost cubesats.\n\nQB50 provides 3 different types of Science Units and it’s up to the universities that participate to provide the cubesat to run the experiments.\n\nThe mission requirements derive first from the QB50 system requirements, the SU specifications and finally from subsystem requirements defined internally from the UPSat team. The mission requirements is the most prominent factor that shapes the software design. Some of the requirements are generic like the QB50-SYS-1.4.6 and the rest are related to specific parts of the UPSat. The QB50 requirements define operations regarding the WOD format and frequency, mass storage operations, time keeping format, clock accuracy and testing requirements.\n\nTable 1.1 QB50 related requirements.\n\nQB50 requirement number description ————————- ———————————————————————————————————————————————————————————————— QB50-SYS-1.4.1 The CubeSat shall collect whole orbit data and log telemetry every minute for the entire duration of the mission. QB50-SYS-1.4.2 The whole orbit data shall be stored in the OBC until they are successfully downlinked. QB50-SYS-1.4.3 Any computer clock used on the CubeSat and on the ground segment shall exclusively use Coordinated Universal Time (UTC) as time reference. QB50-SYS-1.4.4 The OBC shall have a real-time clock information with an accuracy of 500ms during science operation. Relative times should be counted / stored according to the epoch 01.01.2000 00:00:00 UTC. QB50-SYS-1.4.6 The OBSW shall protect itself against unintentional infinite loops, computational errors and possible lock ups. QB50-SYS-1.4.7 The check of incoming commands, data and messages, consistency checks and rejection of illegal input shall be implemented for the OBSW. QB50-SYS-1.4.8 The OBSW programmed and developed by the CubeSat teams shall only contain code that is intended for use on that CubeSat on ground and in orbit. QB50-SYS-1.4.9 Teams shall implement a command to be sent to the CubeSat which can delete any SU data held in Mass Memory originating prior to a DATE-TIME stamp given as a parameter of the command. QB50-SYS-1.5.11 The CubeSat shall transmit the current values of the WOD parameters and its unique satellite ID through a beacon at least once every 30 seconds or more often if the power budget permits. QB50-SYS-1.7.1 The CubeSat shall be designed to have an in-orbit lifetime of at least 6 months. QB50-SYS-3.1.1 The Cubesat functionalities shall be verified using the functional test sets. QB50-SYS-3.1.2 The satellite flight software shall be tested for at least 14h satellite continuous up-time under representative operations. QB50-SYS-3.2.1 CubeSats boarding the QB50 Sensors Unit shall perform an End-to- End test, to verify the functionality of the sensors and the interfaces with the CubeSat subsystems.\n\nUPSat\n\nIn this section, the subsystems of UPSat are analyzed along with the respective hardware.\n\nMost of the hardware was already designed from the university of Patras with the sole exception the separation of the OBC and the ADCS.\n\nUART is used for subsystems communication except the IAC which uses SPI because the OBC didn’t had any UART peripheral left. All subsystems are connected to the OBC which is responsible for packet routing.\n\nAll subsystems implement at least the minimum ECSS services and provide the necessary services functionality.\n\nThe umbilical connector is used for charging the on-board batteries and serial connection with the OBC used for testing.\n\nFigure 1.5 UPSat subsystems.\n\nFigure 1.6 UPSat subsystems diagram\n\nImage 1.2 UPSat subsystems mounted in the aluminum structure Image 1.3 UPSat’s umbilical connector and remove before flight switch\n\nCOMMS\n\nFigure 1.7 COMMS subsystem [6]\n\nThe communications subsystem (COMMS) is responsible for the UPSat communication with the Earth and the ground stations.\n\nIt consists of: STM32F407 microcontroller with an ARM cortex M4 CPU core that has 1 Mbyte of Flash and\n\n192 Kbytes of SRAM, 2 CC1120 RF transceivers with 2-FSK modulation, connected with the microcontroller with SPI, one used for reception at 145 MHZ and the other for transmission at 435 MHZ, the ADT7420 temperature sensor connected with \\(I\\^2C\\) and the RF5110g power amplifier used for amplifying the transmitted signal.\n\nThe COMMS is connected to the antenna deployment system that deploys the 2 antennas after the launch from the ISS.\n\nOBC\n\nImage 1.5 OBC subsystem during testing\n\nThe On-Board Computer is responsible for routing the packets to the subsystems, operating the mass storage memory used for logs and configuration storage, managing housekeeping, maintaining UTC time and operating the SU via the SU scripts.\n\nIt consists of:\n\nSTM32F405 microcontroller with an ARM cortex M4 cpu core that has 1 Mbyte of Flash and 192 Kbytes of SRAM.\n\nThe microcontroller’s internal Real Time Clock connected with a coin cell battery.\n\nAn SD card connected with SDIO.\n\nIS25LP128 128 MBIT Flash memory connected with SPI.\n\nThe initial design that was delivered from the university had the OBC and the ADCS in one PCB running all the functionality in one microcontroller. As at that time, it was unknown if the microcontroller could host both functionalities, it was decided to split the subsystems into 2 PCBs and microcontrollers respectively.\n\nImage 1.6 OBC and ADCS subsystem Image 1.7 ADCS subsystem unpopulated PCB\n\nADCS\n\nThe Altitude Determination and Control Subsystem (ADCS) is responsible for determine UPSat’s position and rotation and controlling the behaviour according to the defined set points. The microcontoller takes the sensors information, feeds it to the controllers, which provide the output of the actuators. The B-dot controller is used during the detumbling phase (rotation greater than 0.3 deg/s) and after UPSat has stable rotation the pointing controller takes control.\n\nIt consists of:\n\nSTM32F405 microcontroller with an ARM cortex M4 CPU core that has 1 Mbyte of Flash and 192 Kbytes of SRAM.\n\nIS25LP128 128 MBIT Flash memory connected with SPI.\n\nAn SD card connected with SPI.\n\nGPS PQNAV-L1 connected with UART.\n\nPNI RM3100 3 axis high precision magnetometer connected with SPI.\n\nLSM9DS0 3 axis gyroscopes and magnetometers, connected with \\(I\\^2C\\).\n\nNewspace systems sun sensor.\n\nAD7682 A/D converter for the sun sensor connected with SPI.\n\nAD7420 temperature sensor connected with \\(I\\^2C\\).\n\nSpin-Torquer, a BLDC motor with a custom controller.\n\n2 Magneto-Torquers embedded into the solar panels and a controller with PWM connection.\n\nEPS\n\nImage 1.9 EPS subsystems PCBs\n\nThe Electrical Power Subsystem (EPS) is responsible for charging the batteries from the solar panels, subsystems power management and batteries temperature control. It is also responsible for the post launch sequence that keeps the subsystems turned off for 30 minutes after the launch from the ISS and after the 30 minutes have passed, it deploys the antennas and the SU m-NLP probes by using a resistor to burn a thread that keeps the mechanism closed.\n\nIt consists of:\n\nSTM32L152 microcontroller with an ARM cortex M3 cpu core that runs the MPTT algorithm for charging the batteries.\n\n3 Li-Po batteries.\n\nMOSFET switches for controlling the subsystems power.\n\nImage 1.10 The EPS PCB with the battery pack mounted Image 1.11 Solar panel used in UPSat along with a SU probe\n\nScience Unit\n\nImage 1.12 The science unit m-NLP\n\nThe science unit (SU) is the primary payload of UPSat. It is provided from the QB50 program and it’s the multi-Needle Langmuir Probe (m-NLP) type. It has 4 probes that are deployed after the UPSat launch from ISS.\n\nSU communicates with the OBC through a serial connection. The OBC is responsible for sending commands to the SU and saving the SU information to the OBC’s mass storage.\n\nIAC\n\nThe Image Acquisition Component (IAC) is the secondary payload of UPSat, defined from the university of Patras. It is comprised from the embedded linux board DART4460 running a custom OpenWRT build and the Ximea MU9PM-MH USB camera with a 50mm 1/2” IR MP lens.\n\nThe IAC’s DART and camera is connected to the OBC PCB and communicated directly to the OBC’s microcontroller through SPI.\n\nImage 1.13 The DART4460 of the IAC subsystem\n\nRESEARCH\n\nIn this chapter, the preliminary research for the software development of UPSat regarding the command & control module and the OBC is introduced.\n\nSingle event effects and rad hard\n\nThe most characteristic issue, during the design and operation of cubesats and satellites in general, is the harsh environment that they have to operate. The most prominent factor is the radiation. Radiation poses a threat to electronics, with observed malfunctions in missions [25] but with careful design shouldn’t be an issue.\n\nFigure 2.1 Missions with radiation issues [25]\n\nRadiation effects\n\nFigure 2.2 SEE classification [49]\n\nRadiation effects can be split in 2 categories:\n\nTotal Ionisation Dose.\n\nSingle Event Effects.\n\nTotal Ionisation Dose (TID) refers to the cumulative effects of radiation in space, resulting in gradual degradation in operational parameters in electronics [52]. This affects missions with longer duration than a typical CubeSat in LEO.\n\nSEEs are separated into different groups and it can be transient or permanent:\n\nSingle Event Upset.\n\nSingle Event Latch-up.\n\nSingle Event Transients.\n\nSingle Event Functional Interrupt.\n\nSingle Event Burnout.\n\nA SEU usually affects memory (SRAM, DRAM) and usual toggles a single bit or a larger area (more bits). SEUs are not destructive and usually dealt with a rewrite in the memory. The key issue is it need to be detected it before it leads to failure [49].\n\nA SEL and a SEB could lead to permanent damage to part if the current is not limited quick enough [52], SEL is usually dealt with protection circuits [52] when possible. Sometimes a bit could be stuck in a specific state. This could lead to failure if the bit is changed in sensitive areas. Latch-ups though are not common events in CubeSats and it usually affects mission with longer duration [25]\n\nA SET can affect logic gates and can also appear in analog to digital converters. SET are usually harmless\n\nA SEE could lead to a SEFI, if the SEE affects a microcontroller or an equivalent device and put it to an unrecoverable mode [52. By res but it could have devastating results e.g. if the SEE affects the flash memory that stores the program of the OBC resulting in a bricked device.\n\nProtection from radiation effects\n\nFigure 2.3 Cost of 2Mbytes rad-hard SRAM [30]\n\nSome traditional ways to protect a satellite from radiation is:\n\nShielding.\n\nRadiation hardened processors.\n\nEDAC memories.\n\nShielding is not the best way for a CubeSat, since it adds weight and it doesn’t fully protect from SEEs [49]. In [42] the mechanical structure can be used to shield sensitive components by placing them in less affected areas.\n\nRad-hard processors are typical most costly, have less performance, the components available are limited, more power consumption and are at least a generation older than COTS processors [30].\n\nEDAC memory which is ram with error correction in the hardware are also costly.\n\nMoreover, even if rad-hard CPUs offer protection from SEUs, they are not totally immune to SEUs [43].\n\nDue to the cost and the disadvantages stated above, associated with rad-hard components, there is a trend moving from rad-hard to COTS and from hardware protection to software [49] [30] [50] [56]. Reliability issues can be improved by using fault tolerant techniques and redundancy [50].\n\nAs already proven by PhoneSat [22] and SwissCube [45], rad-hard components, EDAC memories and other techniques for SEE mitigation, are not necessary for a CubeSat to work.\n\nFigure 2.4 Argos testbed rad-hard board SEU [43 Figure 2.5 Argos testbed COTS board SEU [43]\n\nState of the art\n\nAlmost the first thing that was researched, in order to draw inspiration, was other CubeSats. The most heavily influences were: the first swiss CubeSat [45] and ZA-Aerosat of the ESL Stellenbosch university [36]. Due to the time restrictions of project, the time allotted in the research was minimal.\n\nNASA state of the art\n\nIn “small spacecraft technology state of the art” [19]. from power, communication to integration, launch and deployment, NASA lists all of the state of the art technologies needed in a CubeSat. As software isn’t mature enough and lacks behind hardware as stated, it doesn’t provide much info in software frameworks etc.\n\nZA-Aerosat\n\nIn Heunis [36], It describes the design and implementation of a QB-50 CubeSat named ZA-Aerosat. Since it is a master thesis, it provides a lot of information about the design that is found in papers.\n\nIn the early phase of the project it provided valuable information about SEE’s, fault tolerance and modular programming. Moreover, it gave high level overview of the software about the ECSS and services, memory management and fault tolerance implementation.\n\nSwissCube\n\nThis is a great paper [45], even though it doesn’t use up to date technology, it gives valuable lessons, not only in the design but also in factors that are usually underestimated like the management of people and communication.\n\nOne interesting design feature is that the Swiss cube has a very simple CW RF beacon that is almost independent from the rest of the design. That is an excellent fault tolerant design\n\nThe Swiss cube team scheduled end of phase reviews, with reviewers from the space industry. That allowed them to have good advices that made them reconsider some parts of the design.\n\nSwiss cube software is analyzed in Flight software architecture [24].\n\nSwissCube uses a distributed architecture, this gives the advantage of isolated design, implementation, testing and allows each team to work independently.\n\nFor command and control SwissCube uses the ECSS-E-70-41 [54]. It uses the telecommand verification, housekeeping, function management and a custom service used for payload management.\n\nFinally, the suggestion that has the most impact was that we should aim for design simplicity. In my personal I couldn’t agree more with that advice.\n\nA summary of interesting point is listed below:\n\nThe EPS is designed to operate without a microcontroller, also it can lose one battery without failing.\n\nDuring the environmental tests, they did radiation tests, which provided interesting information.\n\nSwiss cube uses radiations Shields.\n\nImplement and test the communication bus as it has critical implications in the whole design.\n\nPlan big flight software tests.\n\nImplement the ground station software early as possible for testing.\n\nAdd remote software updates.\n\nFigure 2.6 SwissCube exploded view [45]\n\nPhonesat\n\nImage 2.1 PhoneSat v1.0\n\nPhoneSat [22] is a CubeSat and as the name suggests, is based on an android phone.\n\nEven though we can’t borrow software and hardware ideas due to completely different design and mission goals, it’s main mission objective apply directly to UPSat.\n\nThe PhoneSat project long term goal as stated in [22] is to “democratize space by making accessible to more people”, also it states that “The PhoneSat approach to lowering the cost of access to space consist of using off–the-shelf consumer technology, building and testing a spacecraft in a rapid way and validating the design mainly through testing”.\n\nDerived from the successful mission results, it proves that a CubeSat doesn’t need complicated fault tolerant techniques or special hardware, in order to work.\n\nThe PhoneSat project consists of 2 versions, both of the versions have a Nexus smart phone, as the main computer.\n\nPhoneSat v1.0 is a very simple design, with the mission goal to prove that such a design is feasible. It has a nexus smart phone, Lion batteries that weren’t rechargeable from solar panels, an external beacon radio and an Arduino that is used as a watchdog timer, resetting the smart phone in a case something went wrong. Also, the smart phones camera was used to take photos of the earth.\n\nPhoneSat v2.0 is building up on the first design by adding solar panels and rechargeable batteries, an ADCS and 2-way communication module (earth to PhoneSat) along with the first version beacon. It also uses more Arduinos to handle the extra tasks. This design is more similar to mainstream CubeSat.\n\nThe main software runs on android and in Java programming language. For that reason, it has little value to the UPSat design.\n\n2 PhoneSats v1.0 and 1 v2.0 were launched in 2013, all PhoneSats were operational and operated as expected.\n\nImage 2.2 PhoneSat v2.5 Figure 2.7 PhoneSat 2.0 data distribution architecture\n\nCKUTEX\n\nThe software development for CKUTEX [55] didn’t provide value for our design probably because the design is different from UPSat. It uses CAN bus for communication.\n\ni-INSPIRE II\n\nFigure 2.8 i-INSPIRE II CubeSat [47] Figure 2.9 i-INSPIRE II software state machine [47]\n\nThe CubeSat design overview report of the i-INSPIRE II CubeSat [47] which is part of the QB50 program, was found online. The report doesn’t offer too much information for the software implementation but offer some information about the hardware used.\n\nINSPIRE uses a msp430 for primary OBC and a spartan 6 FPGA for secondary processor and experimentation. It has I^2^C buses for sensor and command and control. An interesting fact is that the main processor board is a CTOS provided from Olimex and is not designed in house. The OBC and the ground station communicate with an ASCII protocol.\n\nCommand and control module\n\nThe CnC (command and control) module, defines the protocol for earth to satellite (and vice versa) communication and inter subsystem communication. It consists of the packet format, header and data definition. Operations are grouped into services, defined by the protocol.\n\nThere were two choices concerning the CnC protocol: design a custom protocol or adopt an existing.\n\nThere were 2 protocols found ECSS and CSP, I couldn’t find any other. Even if there are other protocols used in CubeSats, for example in PhoneSat [22] but the specification is either not published as a specification or there are highly specific for that mission.\n\nA custom protocol could have been developed but due to time restrictions, also due to the availability and quality of CSP and ECSS, it was decided not to reinvent the wheel.\n\nRequirements\n\nThe following requirements were set in order to evaluate CSP and ECSS:\n\nLow protocol overhead.\n\nLightweight.\n\nHighly modular and customized.\n\nSince all interactions to subsystems and earth uses the protocol, if the protocol overhead isn’t efficient, it leads to power waste and added data traffic.\n\nThe CnC module will be used with microcontrollers that have limited processing power and resources, so it need to be lightweight.\n\nThe protocol should be designed in way that allows some degree of customization, so the implementation will be tailored on the resources available and be efficient.\n\nCSP\n\nFigure 2.10 CSP header\n\nCSP was developed by students in Aalborg University and is currently maintained by the students and the spin-off company GomSpace [35].\n\nCSP at first stood for CAN Space Protocol since it used CAN bus but later as implementations for other buses were developed, it changed to CubeSat Space Protocol.\n\nIt is something like a lightweight IP. The header size is 32 bits which is small without sacrificing functionality. The data in the header is not framed in 8 bit which could lead in performance issues in 8 bit microcontrollers. CSP has a nice feature that ECSS lacks, configuration bits that allow to change the frame configuration at run time.\n\nCSP has open source code available with the code ported to FreeRTOS.\n\nIn the Wikipedia entry, it says that specific ports are bound to services such as ping but the description of the services couldn’t be found.\n\nCSP uses RPD or UDP depending on the user needs, guarantying reliability or not.\n\nECSS\n\nFigure 2.11 ECSS TC frame header\n\nFigure 2.12 ECSS TC data header\n\nThe ECSS-E-70-41A specification is a work of European Cooperation for Space Standardization and is based in previous experiences. For simplicity ECSS-E-70-41A would be refereed as ECSS in this document.\n\nECSS is a well-defined protocol and the specification is clear and well written. ECSS describes the frame header and a set of services. The header has a lot of optional parameters that makes it easily adapted to the application needs. The services listed are all optional and it’s up to the user to implement them. Moreover, each service has a list of standard and additional features depending again to the application needs.\n\nThe header has 2 parts: a) the packet header, which is standard, and is 6 bytes. b) the data field header, which is variable due to different options available. The options are: packet error control (Checksum [27]), timestamp, destination id and spare bits (so the that the frame is in octet intervals).\n\nDepending on the application and the number of distinct application ids, the user can select to have only 1 set of application ids, defining both the source and destination in one byte, If the number of application ids is large than a separate source/destination has to be used.\n\nThe header implemented was 12 bytes versus the 4 bytes of CSP. The switch between TC/TM and source/destination can be confusing. One feature that the protocol lacks is that it doesn’t have a mechanism for different configurations on runtime like the configuration bits of CSP, having configuration bits denoting different configurations, such as the existence of a timestamp or a checksum in the packet, would have made the protocol a lot more versatile.\n\nECSS is packet oriented e.g. mass storage service use of store packets, even though it’s not a huge disadvantage, it can a bit tedious and could lead to inefficiency on the implementation.\n\nIn my personal opinion, it was a delight working with such clear and well-defined document. While reading the specification, I could sense the accumulated experienced from previous designs. Also, the specification was more like targeted in microprocessors with more resources than a microcontroller, for example, an indication is the large data service: the implementation in order to be efficient and uncoupled from other modules needs the whole large data packet stored in RAM. In order to work efficient, the large data packet need to be several times larger than a usual packet, this could be an issue with resources available in microcontrollers but usually not an issue in microprocessors that have large amount of memory.\n\nComparison\n\nIn this subsection, a comparison between CSP and ECSS is performed:\n\nECSS is more versatile, in the other hand the CSP advantage is its simplicity.\n\nThe data overhead is larger in ECSS but the implementation of the same functionality in CSP could lead to similar sizes or even larger.\n\nOne important issue is that, the time the research took place, the formal specifications couldn’t be found online.\n\nCSP and ECSS have a similar source, destination port and application id.\n\nBoth of them are in binary format.\n\n~12 bytes (ECSS) versus 4 bytes (CSP).\n\nECSS doesn’t have a reliability mechanism for delivering packets.\n\n32 bits (CSP) versus 8 bits (ECSS) oriented.\n\nDynamic configuration on runtime (CSP) versus variable options but static on runtime (ECSS).\n\nOpen source code available (CSP).\n\nResult\n\nFor the following reasons, it was decided to use the ECSS protocol. It was an easy decision, primarily for the CSP lack of formal specification and the modular design of the ECSS.\n\nECSS was recommend by QB50.\n\nECSS is used by many other cubesats.\n\nThe formal CSP specifications was not found.\n\nECSS is based on experience on previous protocol designs, as a result the protocol is highly refined.\n\nECSS is highly flexible on the actual implementation and it allowed to customize it according to our needs.\n\nSafety critical software\n\nC is the language of choice for UPSat. ADA was never really embraced from the community, Rust is too young and both of them lack the ecosystem to quickly use them with the STM32 microcontroller. C though was primary designed for system programming and not for safe critical code, leading to a lot of different issues when used in that field. Developers confusion about the C language use, along with the growing complexity of the design [34] [38] the state of uncertainty [21]. In addition, as compilers is software itself, any bugs they have may introduce bugs to the application. In order to achieve a good level of safety, different techniques have been developed, such as the use of coding standards, software that checks the use of the coding standard and static analyzers that check the code for bugs [38] [21].\n\nUndefined behavior\n\nC by design has a lot of undefined behaviors. This happens because c is primary designed for systems programming and it uses undefined behaviors as a way for compilers to be optimized for specific hardware. A great example is in [63] with the case of division by zero and how different architectures handles them.\n\nUnexpected behavior in C could lead to bugs especially as most engineers aren’t aware of them (I was one of them) [64]. One interesting website [2] that questions your knowledge of C and uncovers misinformation.\n\nFrom it can be seen that different compilers produce different code. This was Also it complicates testing. Even different versions of the same compiler may introduce bugs [64].\n\nAs it can been seen from a lot of failures are introduced from compiler optimizations [63] [64]. For that reason, all of the development went with optimizations disabled.\n\nCoding standards\n\nWith the use of coding standard in the project, we try to improve code clarity [37] and prevent bugs, which are introduced by not fully understand or misuse C.\n\nThe most widely known coding standard is the misra-c [18] which is developed from MISRA. The standard was introduced in order to improve code safety and security. The next is the standard [23] developed by Michael Barr a known expert in code safety. Another 2 was found, designed from ESA [31] and NASA [46].\n\nThe main problem with the above coding standards was that they have many rules which that makes it difficult for a human to remember and use. Usually software that check for the rules and enforce them is used [38]. For the above reasons Gerard J. Holzmann at JPL introduced the power of 10 rules [39]. By having only 10 simple rules Holzmann managed to improve the usage of a coding standard by a developer. The rules are simple, specific, easy to understand and easily remembered. At first the rules seem to be draconian but as soon as someone gets a better understanding, can see the benefits in code clarity and safety [39]. After the introduction of the 10 rules the JPL coding standard [17] was created. The coding standard uses the 10 rules and most of the times add more specific rules [44]. In addition to the JPL’s 10 rules, the 17 steps [40] were consider as well.\n\nFault tolerance\n\nFault tolerance is “Fault tolerance is the property that enables a system to continue operating properly in the event of the failure of (or one or more faults within) some of its components” [59], in our case the ability of the UPSat to tolerate errors or failures, generated by either bugs in the design, implementation or radiation inducted, without leading to catastrophic events. Fault tolerance design is mostly based in adding redundancy in software, hardware or both.\n\nCareful fault tolerant design allows to use COTS components that gives great advantages in reducing cost and achieving better performance [29].\n\nThere are 2 separate planes in which fault tolerant techniques can be applied, hardware and software, with a clear trend to migrate to ta later [56], for cost reducing reasons of course. Having a historical look, we can see that trend in NASA’s missions [29].\n\nUnfortunately, the time available and the already designed hardware didn’t allowed to add fault tolerance in the hardware in the form of redundant hardware and voting mechanisms. Most of the fault tolerant designs had to be Incorporated in the software.\n\nFault tolerant mechanisms\n\nThere are up to 8 different types of error recovery mechanisms, below the 4 most important are listed [26] [29].\n\nFault masking.\n\nFault detection.\n\nRecovery.\n\nReconfiguration.\n\nFault containment is the most important mechanism, since it contains the error before leading to permanent damage.\n\nFault detection is the ability of the systems to understand that error has occurred. Even if fault masking manages to contain the issue, fault detection is crucial in order to evaluate the systems behavior. Diagnosis happens if with fault detection, the nature of the failure is not clear enough.\n\nRecovery makes the system recover from and error and behave as normal.\n\nReconfiguration as the name states is the process of reconfiguring in the event of permanent damage.\n\nFault containment and recovery are the most important mechanism in systems, since it allows the system to continue working in the event of error. Fault detection and diagnosis allows the ground crew to identify the issue and maybe give correctional procedures and afterwards the study of the failure information will lead in to better future missions. Reconfiguration is limited used in UPSat, mostly because the hardware design doesn’t allow it.\n\nBuilt in tests\n\nBuild in tests are usually automatic tests B.I.T. that run and help to determine if the state of the system is correct, they can run on startup\n\npower on BIT or when the system is idle - continuous BIT [26]. FPGAs have the advantage that they can run BIT on circuit level BIT referred as BIST. For an example, a BIST can feed components with patterns that are pre-calculated and check if the output is the same as the one expected.\n\nSingle point of failure\n\nThe single point of failure is a very important concept in fault tolerance: it denotes a part in the system that if that part fails, the whole system fails. As one can imagine it is highly undesirable in safety-critical systems and great measures has to be taken in order to avoid such parts in the design.\n\nFor example, in SwissCube [45] a single point of failure is a RF switch that alternates the RF modules responsible for communication and the RF beacon.\n\nFigure 2.13 Fault tolerance mechanisms [29]\n\nState of the art fault tolerance\n\nMost of the state of the art systems for fault tolerance, incorporate FPGAs in their designs. FPGA have the advantage that they can reconfigure so a damaged area in the IC due to SEEs can be avoided.\n\nJPL used radiation-tolerant FPGAs in the Mars exploration mission [51].\n\nZA-Aerosat [36] uses a hybrid FPGA - microcontroller approach, where the FPGA acts in an intermediate layer between the microcontroller and the memory. The FPGA houses custom logic that with the memory, emulates an EDAC memory.\n\nCNES MYRIADE uses a FPGA for safe against SEEs issues storage [50].\n\nISAS-JAXA REIMEI uses a FPGA as voting mechanism [50].\n\nFault tolerance in hardware\n\nHardware fault tolerance is induced by adding redundant hardware and usually having hardware acting as a voter deciding which of the redundant hardware is correct. The configuration of the redundant hardware and voter design is correlated to the application and the budget.\n\nFigure 2.14 Hardware fault tolerance [26]\n\nA voter which is a hardware specifically added for fault tolerance. It doesn’t mean that is immune to errors and extra caution should be taken in the design. A voter adds to the complexity of the design and it can even lead to the liability of the design. An example is the airplane of the Malaysia Airlines Flight 124 where the ADIRU due to a software error, used a faulted sensor for flight data, leading to a serious incident [58].\n\nFigure 2.15 B777 flight computer [57]\n\nTwo interesting designs are Boeing’s 777 flight computer and the AIRBUS A320-40 flight computer [57]. The B777 has a “triple-triple configuration of three identical channels, each composed of three redundant computation lanes. Each channel transmits on a preassigned data bus and receives on all the busses” [57]. AIRBUS’s flight computer has the same specification as the B777 but follows a different approach, a shadow-master technique, where the boards and software is designed by different manufactures.\n\nFigure 2.16 AIRBUS A320-40 flight computer [57]\n\nFault tolerance in software\n\nThe first basic technique is called partitioning. By writing modular software with clear boundaries, partitions: areas that contained are created.\n\nAdding recovery on partitioning with the use of Checkpoints [48] [57] add recovery to the partitioning technique, by adding points in modular software, where the state can be saved and revert back in the case of an error and resume from that point.\n\nBy integrating the fault tolerant techniques in a framework, the software development and the fault tolerance can be uncoupled, thus reducing the complexity of the software. That allows the developer to focus on the implementation of the software and not in fault tolerance [57].\n\nDynamic assertions is an interesting technique used for runtime evaluation of objects [48]. Even though the concept described is for object oriented languages doesn’t mean that we can’t use some aspects of the concept.\n\nA very common approach to software fault tolerance is the technique of multi-version software. Two software teams develop the same application with different approach, sometimes with different tools or restrictions and both of the software runs on different processors in voting scheme [57]. This approach shows no great advantages and it is not cost effective. A better approach uses the same software and the difference is that is compiled from different compilers [57]\n\nFinally testing the software with Software Fault Injection can lead to bugs discovery, when with traditional testing techniques would be very difficult to find [57].\n\nDESIGN\n\nIn this chapter, the various design choices and the reasons behind are discussed.\n\nCoding standards on UPSat\n\nThere wasn’t enough time to setup the tools needed to enforce and use properly a specific coding standard, for that reason the JPL’s 10 rules [39] and the 17 steps to safer C code [40] were primary used as guidelines.\n\n10 rules\n\nRules 1, 2, 3, 5, 8, 9 were followed religiously and in no accounts, there were allowed not to be followed.\n\nRule 4: 60 lines of code per function wasn’t strictly followed as some flexibility was needed but in any case, it wasn’t allowed to\n\nRule 5: The suggestion was to cover as more cases of assertion as possible, especially to the beginning of a function but without having a minimum.\n\nRule 6: The rule was followed in general except when code clarity was an issue the rule was allowed to be broken.\n\nRule 10: Couldn’t be used since the code generated from cubeMX broke the rule.\n\nFinally, the rules weren’t enforced automatically as there wasn’t time to setup a tool to check them and it was left to the developer’s good will to use them.\n\n17 steps\n\nThe 17 steps to safer C code provide some very good guidelines, with some complimentary to the 10 rules even if most of them they seem like common sense to an experienced programmer.\n\nThe most important step was step 2. Using enumerations not only as error types but as state variables and always defining the last enumerations allowed to make easy range checks with assertions.\n\nStep 15 might seem obvious to most programmers but in my opinion, is the essence of safety-critical code, simplicity improves clarity and clear code is easier understood and\n\nSteps 1, 3, 5 suggests something that is a basic concept for programming but sometimes when working too much hours can be forgotten\n\nSteps 4, 6, 11, 12, 14 are critical for a correct software design and lies within the idea of modular and fault tolerant software.\n\nStep 8 wasn’t applicable to our project since the requirements were already defined. Also steps 9, 10 due to the nature of the project.\n\nStep 13 is about the volatile keyword in C that it is rarely used in non-embedded projects. The concept of volatile can be quite critical in embedded and the incorrect or no usage can lead to very subtle and difficult bugs.\n\nAs seen in chapter 1, static code analyzing described in step 16 is an absolutely must.\n\nUsing the right tools can save a lot of trouble and time (step 7).\n\nFault tolerance on UPSat\n\nThe main techniques used for fault tolerance in software was:\n\nError detection.\n\nError containment.\n\nDue to mission timing constraints, implementing fault tolerance on hardware and other techniques was impossible.\n\nSoftware was designed as modular and uncoupled as possible, in order to ac hive error containment. Further techniques that was used were:\n\nAssertions.\n\nWatchdog.\n\nHeartbeat.\n\nMultiple variables.\n\nAssertions\n\nThe first line of defense was the use of assertions. Assertions check in real time for null pointers, correct range of parameters and correct parameters. If the assertion catches an error, most of the times it cancels the operation and returns to normal state. In order for assertions to be effective, they need to be used regularly.\n\nWatchdog\n\nThe next technique is the watchdog timer. Watchdog timers are a very common peripheral in microcontrollers and a widely used technique against software bugs. The watchdog resets the microcontroller if the timer it shelf is not reset in a specific time interval. This way if a task has entered a blocked state due to an error, the microcontroller resets and returns to its starting state.\n\nThere are two techniques that the watchdog is used: The OBC and the EPS, clear the timer only if certain tasks have happened. In particular for the OBC it is required that all tasks had run at least once. Every time a task runs, it clears a flag, if all flags have been cleared then the timer gets cleared. In addition to that, ADCS and COMMS check for errors in sensor reading and RF communications, accordingly. The same technique could have been used in the OBC but time constraints didn’t allow for proper design and test.\n\nTable 3.1 10 rules for developing safety critical code [39]\n\nRule Num Description ———- ———————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————– 1 Restrict all code to very simple control flow constructs - do not use goto statements, setjmp or longjmp constructs, and direct or indirect recursion. 2 All loops must have a fixed upper-bound. It must be trivially possible for a checking tool to prove statically that a preset upper-bound on the number of iterations of a loop cannot be exceeded. If the loop-bound cannot be proven statically, the rule is considered violated. 3 Do not use dynamic memory allocation after initialization. 4 No function should be longer than what can be printed on a single sheet of paper in a standard reference format with one line per statement and one line per declaration. Typically, this means no more than about 60 lines of code per function. 5 The assertion density of the code should average to a minimum of two assertions per function. Assertions are used to check for anomalous conditions that should never happen in real-life executions. Assertions must always be side-effect free and should be defined as Boolean tests. When an assertion fails, an explicit recovery action must be taken, e.g., by returning an error condition to the caller of the function that executes the failing assertion. Any assertion for which a static checking tool can prove that it can never fail or never hold violates this rule. 6 Data objects must be declared at the smallest possible level of scope. 7 The return value of non-void functions must be checked by each calling function, and the validity of parameters must be checked inside each function. 8 The use of the preprocessor must be limited to the inclusion of header files and simple macro definitions. Token pasting, variable argument lists (ellipses), and recursive macro calls are not allowed. All macros must expand into complete syntactic units. The use of conditional compilation directives is often also dubious, but cannot always be avoided. This means that there should rarely be justification for more than one or two conditional compilation directives even in large software development efforts, beyond the standard boilerplate that avoids multiple inclusion of the same header file. Each such use should be flagged by a tool-based checker and justified in the code. 9 The use of pointers should be restricted. Specifically, no more than one level of dereferencing is allowed. Pointer dereference operations may not be hidden in macro definitions or inside typedef declarations. Function pointers are not permitted. 10 All code must be compiled, from the first day of development, with all compiler warnings enabled at the compiler’s most pedantic setting. All code must compile with these setting without any warnings. All code must be checked daily with at least one, but preferably more than one, state-of-the-art static source code analyzer and should pass the analyses with zero warnings.\n\nTable 3.2 17 steps to safer C code [40]\n\nStep Description —— ————————————————- 1 Follow the rules you’ve read a hundred times 2 Use enumerations as error types 3 Expect to fail 4 Check input values: never trust a stranger 5 Write once, read many times 6 When in doubt, leave it out 7 Use the right tools 8 Define the software requirements first 9 During boot phase, dump all available versions 10 Use a software version string for every release 11 Design for reuse: use standards 12 Expose only what is needed 13 Make sure you’ve used “volatile” correctly 14 Don’t start with optimization as the goal 15 Don’t write complex code 16 Use a static code checker 17 Myths and sagas\n\nHeartbeat\n\nThe last check is the subsystem health check performed by the EPS or heartbeat as we call it. EPS was chosen for this role because it handles the subsystem power.\n\nEach subsystem sends a heartbeat packet (ECSS test service) to the EPS every 2 minutes. When the packet is received from the EPS, it updates a timestamp variable. If that timestamp minus the current time is longer than 20 minutes then the subsystem is reset. It doesn’t have to be a heartbeat packet by any packet will update the timestamp. The heartbeat is used because in normal circumstances, the ADCS and COMMS don’t communicate with the EPS.\n\nSince the OBC does the packet routing, if the OBC fails, the heartbeat packets from ADCS and COMMS destined to EPS won’t be delivered. For that reason, the EPS checks if the OBC has an updated timestamp and then checks for the other subsystems. OBC and EPS have communication every 30 seconds for housekeeping needs, so it should be clear if the OBC works. Otherwise the OBC is reset and all subsystems timestamps are updated (ADCS, COMMS, OBC). This happens so the other subsystems are not reset in case of an error of the OBC.\n\nThe heartbeat is intended as the last in line of error checking techniques, the choice of 2 minutes for refresh and 20 minutes for reset reflect this. Having a 2 minutes refresh interval in a 20 minutes window has very good possibilities to be received from the EPS, without generating too much traffic. The 20-minute window is used, in case there an error in the heartbeat mechanism or the OBC routing and the subsystem operate correct, the 20 minutes give enough time to subsystems to perform adequate.\n\nMultiple checks\n\nThe EPS and COMMS store in multiple locations the critical data. The data hold critical states of the CubeSat. The state values are generated with random number generator. More over the states have multiple values. These are used for protection against SEEs.\n\nOBC\n\nIn the following sections the design choices about the OBC will be analyzed.\n\nOBC-ADCS schism\n\nThe hardware design that was initially designed delivered, had the OBC and ADCS on the same PCB and microcontroller. There were concerns if the same microcontroller could handle both of the software, in terms of processing power and the added complexity of the software design. For that reason, it was decided to split the OBC and ADCS to different into 2 separate subsystems. The disadvantages of that design were: increased power consumption and crucial man hours spend into partial redesigning the PCBs.\n\nWithout having a good understanding of the processing requirements and the processing power of the microcontroller, having a bottleneck at a later phase of the project, which changes would had been more difficult to make or even impossible. Having both subsystems into one hardware seemed a far greater risk than spending the resources to split and redesign the hardware.\n\nIn practice, the OBC uses almost no processing power and the ADCS use only the processor periodically, meaning that that the processing needs of the subsystems could fit into one microcontroller. The decision to separate the subsystems, as it seems wrong at first, it allowed to uncouple the software development and testing, saving precious time during the integration and testing phase of the project.\n\nOBC real time constraints\n\nIn UPSat there are certain operations that are critical and they should happen in strict timeframes. For that reason, the real-time requirements in such critical tasks were defined.\n\nReal time constraints are grouped into 3 general categories [62]:\n\nHard – “missing a deadline is a total system failure”.\n\nFirm – “infrequent deadline misses are tolerable, but may degrade the system’s quality of service. The usefulness of a result is zero after its deadline”.\n\nSoft – “the usefulness of a result degrades after its deadline, thereby degrading the system’s quality of service”.\n\nThe real time constrains in OBC and command and control derived from analyzing specifications, the overall design and finally from past experience with embedded devices.\n\nThe first priority and hard real-time constraint, is to process an incoming packet before the next one comes so there aren’t lost packets. This especially critical for the OBC since it does all the packet routing.\n\nAt 9600 baud rate, with minimum 12 bytes per packet, plus minimum 2 bytes for HLDLC framing. In the worst-case scenario, a packet needs to be processed in 14.5msec. The OBC is connected to 3 subsystems so it can take 3 packets simultaneously, leading to 14.5/3 = 4.8msec.\n\nThe next hard real-time constraint is to send Housekeeping packets every 30 seconds with 500 msec accuracy. This is a huge time frame for an embedded system, so normally it wouldn’t be a problem.\n\nThe SU script engine had to be able to run within 1 second of the scripts run time.\n\nThe schedule service had to release TC within 1 second of the commands release time.\n\nFinally, all OBC’s tasks must run at least once within 30 seconds time frame.\n\nPackets processing, hard real-time constraint.\n\nHousekeeping, hard real-time constraint.\n\nSU engine, hard real-time constraint.\n\nScheduling service, hard real-time constraint.\n\nOBC tasks, hard real-time constraint.\n\nRTOS Vs baremetal and FreeRTOS\n\nFor the OBC there are 2 choices regarding the software, either run bare metal on the microcontroller and design a custom scheduler from scratch or use a RTOS.\n\nA bare metal solution offers to make unique customized and optimized code that the developer team understand (as they wrote it), but has the disadvantages of limited review, it carries a greater risk in case of a design flaw and finally another key part of the software has to be designed and implemented.\n\nThe RTOS has code that is already tested and proven working on applications but it won’t be bug free. Working with a RTOS would require evaluation of different RTOSes in order to choose the most suitable and afterwards careful examination of the RTOS in order to understand key concepts for the working and for future debugging.\n\nThe choice of a RTOS instead of bare metal was obvious, due to the nature of the tasks of the OBC: different tasks with different timings and a mix of synchronous and asynchronous events in comparison of e.g. the ADCS which has synchronous linear tasks that would be easier and simpler to implement when used a RTOS.\n\nRTOS suits better the OBC tasks.\n\nRTOS is well tested and used.\n\nTime needed to study the RTOS is far less than developing the scheduler.\n\nNeed extra time to familiarize with the RTOS concepts.\n\nThere are numerous candidates for a RTOS such as FreeRTOS, embOS [12], vxworks [9], RIOT [16] and mC/OS [7] but none of them except FreeRTOS, had met the requirements of the project. FreeRTOS is very simple with only 3 files with basic functionality, has been already ported by ST, it is open source and has already been used in many projects plus it is supported from all major companies.\n\nSimple.\n\nMinimum time for integration.\n\nOpen source.\n\nMature.\n\nFreeRTOS concepts\n\nAs the choice for the OBC’s RTOS, FreeRTOS concepts and design needed to be studied. Besides the primary reason which was to identify if FreeRTOS was suited for the OBC, a better understanding would lead to following:\n\nOptimized design and implementation.\n\nHaving a better understanding of the FreeRTOS limitations.\n\nDetecting design intricacies that might lead to bugs.\n\nSolving bugs.\n\nThe basic concepts were described in FreeRTOS documentation. Finally [41] and a combination of source code examination, step by step debugging, and systemview was used to get an in depth understanding of FreeRTOS. Finding information besides the basic concepts was extremely difficult.\n\nIntroduction to FreeRTOS\n\nFreeRTOS was by Richard Barry in 2003 and it has become an industry de facto standard RTOS for microcontrollers. It is open source and the licensing allows proprietary applications to not reveal the source code.\n\nFreeRTOS has been ported in over than 35 microcontrollers and has partners all the major microcontroller companies.\n\nFreeRTOS has been already used in many CubeSat missions [36] [41] and is available in most COTS vendors for use in their boards [35].\n\nFreeRTOS is very simple, it basically is a priority scheduler for threads, called tasks in FreeRTOS terminology, along with supporting mechanisms such as mutex, semaphores queues etc.\n\nTasks\n\nThreads are called tasks in FreeRTOS terminology. Tasks are created by using the taskCreate function. Also, tasks can be deleted but it’s not used in the project. A task has 4 different states:\n\nReady.\n\nRunning.\n\nSuspended.\n\nBlocked.\n\nTasks that are in the ready list are waiting to execute, in the running state are the current task working and in the blocked state when a task wait for a resource to become available or the delay time to be completed.\n\nEach task has a priority, that is defined at the task’s creation. A task that has the lowest priority called idle and must always exist in a FreeRTOS project.\n\nFreeRTOS has a support for semaphores and mutexes. In addition, there are queues that are used for thread safe intertask communication.\n\nThe scheduler checks in every tick if a task of a higher priority is ready to run and makes the context switch accordingly. If the task has the same priority the tasks share running time round robin.\n\nThe scheduler runs in an ISR every tick of the RTOS timer. Usually in ARM cortex M cores the timer used is the systick. The timer’s resolution defines the quantum of (minimum) running time of a task. The timer’s resolution and configuration affects the max delay possible from the freeRTOS delay function.\n\nIf a FreeRTOS API function needs to be used from an ISR has different set of functions specific for ISR use, usually the function has the ISR added in the function name.\n\nCritical sections\n\nIf an action needs to finish without an interruption there are 2 mechanisms that can be used. The first option is to disable all interrupts and thus disable the scheduler but has the major drawback that it also disables interrupts that are created from peripherals. The second option is to disable the scheduler and thus remove the chance of a possible context switch.\n\nFigure 3.1 Tasks [12] Figure 3.2 tasks life cycle [12]\n\nStack overflow detection\n\nFreeRTOS has 2 methods for detecting stack overflows. In the first method, the bottom of stack has been filled with known values and in every context, switch those values are checked if there are overwritten. The second method checks in every context switch if the stack pointer remains in valid values.\n\nHeap modes\n\nFreeRTOS has 5 models for the heap memory management that allows different levels of memory allocation with heap 1 that doesn’t allow any memory to be freed after they were allocated and to heap 5 that the maximum freedom. Since memory allocation after the initialization is prohibited in JPL’s 10 rules the only suitable model for UPSat is heap 1.\n\nAdvanced concepts\n\nA task’s information used from the FreeRTOS are stored in a Task Control Block (TCB) structure. For every state of a task FreeRTOS has lists that store each task that is in that state. Every time a task changes state it is added to the corresponding list. The scheduler in every tick, checks the ready list for a task waiting to run and compares the priorities with the currently running.\n\nIn each context switch the scheduler stores the registers value and the stack pointer which is also a register and loads the registers of the task that is about to run. This code is specific to the architecture and usually is implemented in assembly.\n\nLogging and file system\n\nOne of the basic functions of the OBC was to uplink and use SU scripts, store various logs (WOD etc.) and download them into the ground station. A SD card connected to the microcontrollers SDIO peripheral was used for primary storage and an external flash for secondary.\n\nChan’s FatFS [32] was the one-way choice for the file system because it was already ported and working with support for SD cards from ST’s cubeMX, requiring minimum configuration.\n\nFigure 3.3 FAT file system structure [60]\n\nThe other considerations were using the SD card without file system but the major issue was that the SDIO peripheral code had to be developed.\n\nFAT in general is not suitable for safety-critical systems, failure during operation could lead to corrupted files and even corrupted file system without the possibility of recovery [33].\n\nMoreover, as the FAT file system is structured it leads to inefficiency requiring traversing the file system in order to find where a file is in the data region and in read/write operations checking the FAT table. All of these locations are usually in not adjacent sectors leading in performance degradation.\n\nThe file system is separate into different regions such as the boot sector, file allocation table, the root directory and the data region.\n\nDirectories are special files that provide information for the records such as the type (directory, file), name and starting cluster. There are stored in the data region, except the root directory. The root directory is found in a known location and provides the starting point for traversing the file system.\n\nAn entry in the File Allocation Table is allocated for each cluster in the data region. The number in the entry points to the next cluster that the data continuous or the end of the file.\n\nThe data area is divided in parts called clusters with each cluster being a multiple of a sector, the sectors are usually 512 bytes. A sector is the minimum data transfer from or to the SD.\n\nChan’s implementation of FAT file systems is orientated towards microcontrollers and systems with low resources. It has a small API consisting of the basic commands such open, write, read file. The only issue is that the documentation is not very detailed with some errors returned from the commands are too general to make use.\n\nSince a sector is the minimum data transfer, for optimized reads and writes, the data should align with a sector. better if the data fit into a sector only, leading to more efficient reads and writes, because the file system doesn’t ensure the next cluster is after the current one.\n\nIn figure 3.4 the critical operations of FatFS is listed. If a failure or interruptions occur between commands with yellow or red could result in data loss or even file system corruption. Minimizing the time, a file is opened the risk of failure is minimized as well. Figure 3.5 shows optimized code with the use of sync.\n\nFigure 3.4 FatFS critical operations [32] Figure 3.5 FatFS optimized critical operations [32]\n\nECSS services\n\nThe ECSS standard is highly adaptive and provides many different choices. In this section, the design choices for UPSat are analyzed.\n\nServices\n\nThe first choice that came up was: which services were going to be used in UPSat. Even though all services provide necessary there wasn’t enough time to implement them all.\n\nThe telecommand verification service provide a way to receive a response about the successful or not outcome of a telecommand’s operation. This service is required since for some operations it is critical to know the outcome of the operation.\n\nThe housekeeping & diagnostic data reporting service provide a way to transmit and receive information (housekeeping) that denote the status of the CubeSat. The housekeeping operation is standard in CubeSats.\n\nThe function management service is used for operations that aren’t part for other services operations. In UPSat the service is used mainly for controlling the power in subsystems and devices and setting configuration parameters in different modules.\n\nThe time management service is providing a way to synchronize time between subsystems and the ground station. This service was added later when the need to synchronize time between ADCS and OBC and the ability to change the time from the ground came up.\n\nThe on-board operations scheduling service provide a way for to trigger events in specific times or continuously with specific intervals with the release of telecommands. This service allows to perform events without having connection with the ground station.\n\nThe large data transfer service provides a way to exchange packets that are larger than the size that is allowed by cutting the original packet in chunks that their size is allowed. In UPSat it is used for transferring large files such as the SU scripts.\n\nThe on-board storage and retrieval service provide a way to store and retrieve information in mass storage devices. In UPSat it is used to store various logs, SU scripts and configuration parameters in the SD card of the OBC.\n\nThe test service provides a simple way to verify that a subsystem is working. It is very similar to the ping program used in IP networks.\n\nThe event reporting service provides a way for a subsystem to report events. It was originally designed for subsystems that didn’t have storage devices to report events that were critical to the UPSat’s operation to the OBC so that it would store them for later review from a human operator. Time restrictions didn’t allow for correct implementation and testing so it was removed.\n\nEvent-action service uses the event service to generate action when a particular event takes place. Since the event service was removed there wasn’t a way to use the event-action service.\n\nThe device command distribution service is not applicable to the UPSat design.\n\nThe parameter statistics reporting service provide a way to report statistics about specific parameters when there isn’t ground coverage. In ideal conditions this service would have been used in conjunction with housekeeping service in order to provide a better understanding of the UPSat’s status. For cases that statistics were needed the were added in the housekeeping report and the specifics of the implementation were left to the discretion of the software engineer.\n\nThe memory management service provides a way to read or write memory regions in subsystems and mass storage devices. Even though it could be helpful, there wasn’t a urgent need to implement it.\n\nThe on-board monitoring service monitors parameters and checks if there are changes that need to be reported in the ground. Again, for this service there isn’t a urgent need.\n\nThe packet forwarding control service provides a way to forward a packet to different application id than it was intended. There was the thought of using the service in order to forward specific packets to a software module that captures these packets and stores them as events in mass storage but time limitations didn’t allow to implement it.\n\nThe on-board operations procedure service allows for the ground station to store and manipulate functions in subsystems in UPSat. That service provides a way to extend and or change software functionality in a CubeSat without resorting in complex firmware updates. Unfortunately, even if this service is important, once again there wasn’t enough time to implement it.\n\nFrom the 16 services only 8 were decided to with the time management service added later and the event reporting services removed during the implementation phase.\n\nSince On-board operations scheduling service was designed and implemented from Apostolos Masiakos and Time management service from Apostolos Masiakos and Agis Zisimatos, the services won’t be analyzed further.\n\nThe specification states that any custom services or services subtypes should have an number larger than 128. In UPSat’s design this rule wasn’t followed and the custom could have any number that it’s not used from the specification. This happens because there is a a large lookup table for every subsystem which defines which services are used, the way it was implemented having 128 service number and above would create a huge lookup table that wouldn’t fit in the microcontroller’s memory.\n\nTable 3.3 ECSS services\n\nService Type Service Name ————– ————————————————–\n\n1 Telecommand verification service 2 Device command distribution service 3 Housekeeping & diagnostic data reporting service 4 Parameter statistics reporting service 5 Event reporting service 6 Memory management service 7 Not used 8 Function management service 9 Time management service 10 Not used 11 On-board operations scheduling service 12 On-board monitoring service 13 Large data transfer service 14 Packet forwarding control service 15 On-board storage and retrieval service 16 Not used 17 Test service 18 On-board operations procedure service 19 Event-action service\n\nTable 3.4 ECSS services implemented by UPSat\n\nService Type Service Name ————– ————————————————–\n\n1 Telecommand verification service 3 Housekeeping & diagnostic data reporting service 8 Function management service 9 Time management service 11 On-board operations scheduling service 13 Large data transfer service 15 On-board storage and retrieval service 17 Test service\n\nApplication ids\n\nApplication ids are a core concept in ECSS, it is the address of a module that the packet is heading towards, it is very similar to the IP address concept. Using 11 bits for application ids a total of 2047 address can be achieved. Application ids are not confounded only in hardware subsystems but software modules can be given an id.\n\nIn UPSat a total of 7 application ids were used: 5 for each subsystem and 2 for the ground station. The 2 application ids used for the ground station is because there are 2 different paths available and there was a need to differentiate them. The first is the serial connection through the umbilical connector and was used only during testing. The second was through the RF communication and the COMMS subsystem. The software is design of UPSat is simple enough so there wasn’t a need for more application ids.\n\nTable 3.5 UPSat application ids\n\nSybsystem app id ———– ——– OBC 1 EPS 2 ADCS 3 COMMS 4 IAC 5 GND 6 DBG 7\n\nPacket frame\n\nEven if the ECSS standard treats the telecommand and telemetry as packets with different frame structure, the design intention of the packet frame in UPSat was that both of frames could be as identical as possible. The reason behind that was that the software remains as simple as possible, using the same code for manipulating telecommand and telemetry frames. The simpler design in software would lead in less developing the code and testing it. Hello if you, are reading this send a mail at nchronas at gmail dot com and say hi, I would be glad to hear from you.\n\nThe packet header and packet error control are identical in telecommands and telemetry packets. The data field header is designed to be identical with source ID in telecommands and destination ID in telemetry packets and without the optional fields of packet sub-counter and time in telemetry that don’t exist in a telecommand packet.\n\nFor routing purposes the source and destination application ID was added in telecommand and telemetry packets. When the packet is a telecommand the application ID in packet id denotes the subsystem destination and in the data header field the subsystem that the packet originated and vice versa in a telemetry packet. Without the source ID, it would be impossible to know to which subsystem a possible response should be send and without the destination ID where to route the telemetry packet. It was possible to only use the application ID by having application IDs would denote both the source and destination ID but that design would be more obscure leading to confusion during testing.\n\nThe maximum length of a normal frame is 210 bytes, by subtracting the headers and error correction it leaves with 198 bytes for application data. This number derives from restrictions in RF communication with the Earth. Because the COMMS subsystem doesn’t use error correction algorithms, if the size is larger than 210 bytes the probability that the packet is received correctly from the ground station, quickly deteriorates.\n\nFor the case of handling large files the normal packet size is inefficient and restrictive. For that reason and for subsystem communication only, the length of a packet can be extended to a maximum of 2050 bytes. The 2050 bytes is calculated from the maximum file transaction of a SU script with 2048 bytes size plus the 12 bytes of packet header. This transaction happens only for OBC-COMMS communication only. For RF communications if the size is larger than normal, the large data service is used.\n\nThe version number and data field header flag of the packet ID have the default values of 0 and 1.\n\nThe type equals to 1 if the packet is a telecommand and 0 if it is a telemetry packet.\n\nThe application ID uses only the 8 bits for efficiency but for compatibility reasons 11 bits are used in the frame.\n\nThe Sequence flags in telecommands or Grouping flag in telemetry packets are used only in standalone mode with default value equal to 3.\n\nTable 3.6 Telecommand Data header\n\nCCSDS Secondary Header Flag TC Packet PUS Version Number Ack Service Type Service Sub- type Source ID —————————– —————————— ——– ————– ——————- ———– 1 Bit 3 Bits 4 Bits 8 Bits 8 Bits 8 Bits\n\nThe sequence count is a counter that counts the packets that the subsystem has transmitted to another subsystem, there is a different counter for each application id. If a subsystem routes the packet to its indented destination it doesn’t modify the counter. The counter is uses 8 bits instead 14 bits as the standard for efficiency reasons. For compatibility reasons for the packet frame remains 14 bits. Every system that transmits packets frames needs to implement the counter. Moreover, the counter in UPSat is not stored in mass storage memory and it is reset to zero in each subsystem reset. By observing when the counter resets to zero in a subsystem it can be deduced that a reset happened to that subsystem.\n\nThe packet length is calculated by subtracting from the actual packet size the size of the packet header which is 6 bytes and subtracting 1.\n\nPacket length = Packet size (bytes) - 6 (packet header) - 1\n\nThe data field header varies in a telecommand and a telemetry packet. The CCSDS Secondary Header Flag has a default value of 0 in a telecommand and it’s used as padding in a telemetry packet. The Ack is used in a telecommand from the verification service and as padding in a telemetry since the verification service doesn’t work with telemetry packets.\n\nIn both telecommand and telemetry packets the Packet PUS Version Number has a default value of 1.\n\nThe service type and subtype denote the functionality of the packet and the service associated with the packet.\n\nIn a telecommand the source ID denotes the application ID of the subsystem that the packet originates from and in a telemetry packet the destination ID denotes the destined subsystem. Both the source and destination ID reside in the same position in a telecommand and telemetry packet.\n\nThe Packet error control is implemented as a CRC8 algorithm that occupies 8 bits but for compatibility reasons the frame has 16 bits with the first 8 bits are unused.\n\nThe packet sub-counter and time fields in a telemetry packet are not used because there wasn’t any need for them in UPSat.\n\nFinally, no optional spare fields were added in both telecommand and telemetry packets.\n\nTable 3.7 Telemetry Data header\n\nSpare TM Packet PUS Version Number Spare Service Type Service Subtype Destination ID ——- —————————— ——– ————– —————– —————- 1 Bit 3 Bits 4 Bits 8 Bits 8 Bits 8 Bits\n\nTable 3.8 Command and control packet frame\n\nServices in subsystems\n\nThe table 3.9 provide information about which service is implemented in each subsystem.\n\nVerification, housekeeping, function and test service are basic services needed in all subsystems.\n\nTime management is only used in ADCS and OBC since only them require precision time keeping, OBC for the SU and ADCS for the control calculations.\n\nOn-board scheduling and On-board storage services are only used in OBC since they require a mass storage device.\n\nFinally, large data transfer is only implemented in COMMS since it is the only capable for RF communications.\n\nTable 3.9 Services implemented in each subsystem.\n\nSoftware reuse\n\nOne of the first software design decisions was that since the ECSS software is generic and could be used in future missions, the software modules should be designed to be agnostic to the hardware used. For that reason, direct call functions that were hardware related was prohibited and a HAL layer that was a essentially a wrapper for the STM libraries was used.\n\nTelecommand verification service\n\nThe Telecommand verification service is the 1. In table 3.11 are shown the minimum and additional capabilities offered by the services. The service is used when a telecommand has the values shown in table 3.10 The service doesn’t support telemetry packets.\n\nFor UPSat it was decided that only the minimum capabilities would be used, even if the additional would be definitely helpful they would also complicate the software design. For that reason, only values of 0 and 1 are valid in the ACK field, if other values are present the packet is flagged as invalid and dropped.\n\nSince most of the telecommands are usually finished immediately, the acceptance report means also the competition of the telecommand but the semantics of the acceptance should be considered to be a telecommand.\n\nIf the telecommand results in failure, the frame has an error code field. By checking the error code, the ground station operators could find the reason for the failure and make correcting procedures accordingly. The ECSS standard provides some error codes about packet decoding failure listed in table 3.10.\n\nOne particular idiosyncrasy of the service is found in the table 3.14 where are listed errors about packet decoding such as error 2 incorrect checksum, that leads reporting acceptance failure about a packet that could have corrupted information including the ACK field.\n\nTable 3.10 Telecommand packet data ACK field settings\n\nValue meaning ——- ————————————- 0 none 1 Acknowledge acceptance 2 Acknowledge start of execution 4 Acknowledge progress of execution 8 Acknowledge completion of execution\n\nTable 3.11 Telecommand verification service subtypes\n\nminimum capabilities ————————————————– ——- Telecommand acceptance report - success Telecommand acceptance report - failure Additional capabilities Telecommand execution started report - success Telecommand execution started report - failure Telecommand execution progress report - success Telecommand execution progress report - failure Telecommand execution completed report - success Telecommand execution completed report - failure\n\nTable 3.12 Telecommand verification service acceptance report frame\n\nTelecommand Packet ID Packet sequence control ———————– ————————- 16 bits 16 bits\n\nTable 3.13 Telecommand verification service acceptance failure frame.\n\nTelecommand Packet ID Packet sequence control Error ———————– ————————- ——– 16 bits 16 bits 8 bits\n\nTable 3.14 Telecommand verification service error codes\n\nValue meaning ——- —————————————— 0 illegal APID 1 incomplete or invalid length packet 2 incorrect 3 illegal packet type 4 illegal packet subtype 5 illegal or inconsistent application data\n\nHousekeeping\n\nInformation indicating the status of the CubeSat, are broadcasted to earth, in specific intervals. WOD is transmitted automatically, so it can be easily gathered by ground stations that don’t have transmit capabilities.\n\nUPSat has 3 different WODs and each is used for different purposes:\n\nQB50 WOD.\n\nExtended WOD.\n\nCW WOD.\n\nThe QB50, extended and CW WOD, is used for understanding the state of UPSat. It is the last line of defense in the case there isn’t a communication link between ground stations and UPSat. It is going to be the first indication if UPSat works correctly or not. The CW WOD is crucial during the first days of operation, in order to track and verify the operation of UPSat. Since HAM operators around the globe could listen for CW WOD, a global coverage can be obtained.\n\nWOD\n\nIn the QB50 requirements, there is WOD. In the frame, it provides historical information. The dataset provides general information. For compatibility with the rest of the missions in QB50, WOD is not encapsulated in ECSS.\n\nTable 3.15 WOD packet format\n\nTable 3.16 WOD dataset\n\nExtended WOD\n\nSince WOD offers only basic information, it was decided to add an independent extended WOD. That would provide more information about the state of UPSat. It was asked of all engineers to supply a set of variables, that would help them understand what happens in the subsystems. A small refactored happened in order to fit all data in a single frame. Extended WOD is encapsulated in a ECSS frame.\n\nCW WOD\n\nIn addition to WOD and extended WOD, a CW WOD was added. The reason was that CW has better chances of receiving it from the ground than the FSK modulated WOD and extended WOD. Moreover, in CW there isn’t a need for complicated demodulation hardware, even a human with proper training can understand it. The disadvantage of CW and the reason that it hosts minimal information, is that it has far lower data rate than FSK and higher consumption due to lower data rate.\n\nFigure 3.6 CW WOD frame\n\nFigure 3.7 CW WOD dataset\n\nHousekeeping & diagnostic data reporting service\n\nIn this service, the design has deviated a lot from the specification. In the specification, each housekeeping structure send a report in specific intervals. There are also functions that implement new structures and modify the intervals that the reports are generated.\n\nFor the UPSat, a different, simpler design was followed: OBC would send a telecommand report parameters request (3,21) and the subsystem would respond with a telemetry parameters report (3,23). OBC handles all the timing and not the service. In the request, there is the structure ID that the OBC wants. The structure ID is most of the times general and the parameters in report are in conjunction with the subsystem that reports it. For WOD variants the OBC gathers the health and extended health reports, forms the WOD variant structures and then transmits it to earth. Some subsystems have structure IDs that are specific to them. Finally. the ground station could also send a request for a parameter report and receive the response.\n\nEven though the request/response mechanism works well, a design that uses intervals as specified in the ECSS standard would have been a better solution for 3 reasons:\n\nIt removes the task of sending requests.\n\nMinimizes traffic.\n\nEasier to change intervals.\n\nTable 3.17 Housekeeping service structure IDs\n\nStructure ID name Structure ID Meaning ——————- ————– ———————————- HEALTH_REP 1 Health report EX_HEALTH_REP 2 Extended health report EVENTS_REP 3 Events report WOD_REP 4 WOD report EXT_WOD_REP 5 Extended WOD report SU_SCI_HDR_REP 6 SU science header report ADCS_TLE_REP 7 ADCS TLE report EPS_FLS_REP 8 EPS flash memory contents report ECSS_STATS_REP 9 ECSS statistics report\n\nTable 3.18 Housekeeping service request structure id frame\n\nStructure ID ————– 8 bits\n\nTable 3.19 Housekeeping service report structure id frame\n\nStructure ID Data ————– ————— 8 bits 1 - 1584 bits\n\nFunction management service\n\nThe Function management service has service type 8 and only one service subtype called perform function (8,1) which is a telecommand.\n\nEach subsystem performs different functions, each device ID is associated with on/off or set value action and a subsystem\n\nTable 3.20 provide the data frame structure. There are 2 groups of actions: power control which turns on and off a device and a set value which configures the device ID parameters. Since set value is specific to each device ID the values following is specified with the device ID, the power control doesn’t need a value. Table 3.21 show which subsystems implement each device IDs and what action is associated with.\n\nTable 3.20 Function management service data frame\n\nFunction ID Device ID Data ————- ———– ————– 8 bits 8 bits 0 - 640 bits\n\nTable 3.21 Function management services in each subsystem\n\nName Sybsystem Function ID Device ID ————— ———– ————– ——————- Power control EPS 0: off 1: on OBC ADCS COMMS SU ADCS 0: off 1: on GPS Sensors OBC 0: off 1: on IAC ADCS 3: Set value Magnetorquers ADCS 3: Set value Spintorguers ADCS 3: Set value TLE ADCS 3: Set value Control gains ADCS 3: Set value Setpoint COMMS 3: Set value WOD pattern EPS 3: Set value Write flash\n\nLarge data transfer service\n\nThe specification has 2 ways for ensuring that a transfer has been completed successfully. In the first one, every time packet that is successfully received sends an acknowledgement. In order to send the next one, an acknowledgement should have been received for the previous one. The second technique uses a sliding window, where multiple parts are send and the acknowledgement verifies the packets up to the part. In UPSat, for uplink an acknowledgement for each packet is required and for downlink a modified sliding window is used.\n\nThe Large data transfer service have 2 different parts: the software running in UPSat and the one running in the ground station. Since UPSat has less resources, is more difficult to write code for UPSat and after a point the software won’t be able to change, it was decided that the operation complexity should be handled from the ground station’s software, whenever that was possible. For that reason, there was a different approach for the service design if the transfer was initiated from UPSat (downlink) or from the ground station (uplink).\n\nFor downlink, UPSat sends all the parts with 1ms delay in each transfer and waits for a specific timeout period. The first part is denoted as, all intermediates with and the final part with. During that period, the ground station should send for a packet retransmission if it didn’t receive it properly or that all packets were successfully received. If that time period expires without an acknowledgement, the service aborts the transfer.\n\nWhen the ground station receives large data transfer packets, checks if there any packets missing and asks for retransmission. If there aren’t any packets missing, it sends that the transfer finished successful. In the case that the last part hasn’t been received, the ground station requests the next part, until the last one is send.\n\nFor uplink, the ground station initiates a new transfer by sending the first part, if UPSat receives it, it sends an acknowledgement. If the ground station doesn’t receive the acknowledgement, it retransmits the packet. This continues till the last part or if the operation timeouts.\n\nFor both of transfers uplink and downlink, the ground station is responsible of retransmitting a packet in a time frame that is less than the time of UPSat’s timeout, if the ground station hasn’t got a proper response, either a acknowledgment in the case of uplink or the part that ground station requested in a downlink.\n\nFor keeping the design simple enough, it was decided to allow only one transfer at the time for both of the uplink and downlink. For the case, it was decided in the future to allow multiple transfers, a large data unit ID was added in the data frame, that ID shows which transfer that packet belongs to. For the current design if a packet arrives that has different ID than current transfer, it drops the packet.\n\nThe sequence number shows where the data should be placed when the original packet is reconstructed. For uplink if a packet arrives that has a larger sequence number than the one expected, the packet is dropped, that simplifies the design and it doesn’t allow broken packets. For the current design a maximum of 11 parts are allowed.\n\nEach part should have the max size of 196 bytes from max data size of 198 bytes minus the 2 bytes of the large data transfer service header, except the last part.\n\nFigure 3.8 Large data transfer split of the original packet\n\nTable 3.22 Large data transfer service transfer data frame.\n\nLarge data unit ID Sequence number Service data unit part ——————– —————– ———————— 8 bits 8 bits 1 - 1568 bits\n\nTable 3.23 Large data transfer service acknowledgement frame\n\nLarge data unit ID Sequence number ——————– —————– 8 bits 8 bits\n\nTable 3.24 Large data transfer service repeat part frame\n\nLarge data unit ID Sequence number ——————– —————– 8 bits 8 bits\n\nTable 3.25 Large data transfer service abort transfer frame\n\nLarge data unit ID Abort reason ——————– ————– 8 bits 8 bits\n\nOn-board storage and retrieval service\n\nThe first design choice was that the file names for the logs should only be numbers and not characters. That has the advantage of lower size overhead when there is ground to UPSat communication e.g. the file name as a string could be 8 characters long meaning 8 bytes as string when the equivalent number 99999999 only uses 4 bytes. "
    }
}