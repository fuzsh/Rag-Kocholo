{
    "id": "dbpedia_8290_1",
    "rank": 75,
    "data": {
        "url": "http://www.grosse.is-a-geek.com/pcplus/hd224sd/hd224.html",
        "read_more_link": "",
        "language": "en",
        "title": "PC Plus HelpDesk - issue 224",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/mugshots/pgrosse.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-a.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-b.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-d.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-e.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-f.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-c.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-g.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-h.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-j.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-k.jpg",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-m.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-n.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-o.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-p.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-q.gif",
            "http://www.grosse.is-a-geek.com/pcplus/hd224sd/images/hd224-s.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "POP3 protocol (rfc1939)\n\nYou can pick up your very own copy of RFC 1939 - Post Office Protocol - Version 3 from http://www.faqs.org/rfcs/rfc1939.html. It will tell you everything you need to know (near enough).\n\nOne section that is of particular interest is section 9 - Command Summary...\n\nMinimal POP3 Commands:\n\nvalid in the AUTHORISATION state...\n\nUSER name PASS string QUIT\n\nvalid in the TRANSACTION state...\n\nSTAT LIST [msg] RETR msg DELE msg NOOP RSET QUIT\n\nOptional POP3 Commands:\n\nvalid in the AUTHORISATION state...\n\nAPOP name digest\n\nvalid in the TRANSACTION state...\n\nTOP msg n UIDL [msg]\n\nPOP3 Replies:\n\n+OK -ERR\n\nNote that with the exception of the STAT, LIST, and UIDL commands, the reply given by the POP3 server to any command is significant only to \"+OK\" and \"-ERR\". Any text occurring after this reply may be ignored by the client.\n\nThe server starts a session in the authorisation state and all we have to recognise is 'USER name', 'PASS string' and 'QUIT'. However, we can have some fun by issuing additional information over an above the required +OK and -ERR in that we can do apparently insecure things like send additional information such as if a user is verified, but their password fails, we can say that that is what happened (it is advised that merely a +OK is sent on receipt of a USER regardless of whether the user exists and that the PASS is required before any potentially diagnostic information is sent - limiting it to something along the lines of '-ERR the USER/PASSWORD combination failed' but we can let a bit more of the cat out of the bag by telling them that the user is a valid one and that the password was wrong (possibly telling them that the user is valid after the USER command)).\n\nEven if we never allow them access to a particular imaginary account, we can still occupy them with perturbed feedback: for example...\n\n+OK POP3 server ready 23415.1096045378@pop.domain.com USER john123 +OK john123 is a valid account on this server PASS street-lamp -ERR Password street-limp incorrect\n\nBy returning an error in their password, we can get them to type it again., wasting some more time - those proxy servers can be a bit unreliable. There are more strategies for wasting time such as giving them long delays (only a few seconds, maybe five to fifteen - it is a busy server after all) throwing them off after only three guesses (mail clients will drop the connection if you send them an error and present the user with the error message and another opportunity to enter a password).\n\nIn effect, this is like playing a game over the Internet only instead of somebody playing a machine that it pretending to be a human, it is somebody pretending to use a mail client to access a valid POP3 account on a server that is pretending to be a valid but vulnerable POP3 server. As the account does not exist (and never could) the user cannot have any valid reason for trying to get into the account.\n\nIf you make it easy for them to start the next game, they will stay with it (if you have ever played Frozen Bubble [http://www.frozen-bubble.org/], you will know what I am talking about). Having lost that round, they will have some information to allow them more success (apparently) in the next round.\n\nxinetd Super-Server\n\nThe eXtended InterNET services Daemon is a super server that can look after a number of connections without overloading the system. It is controlled from the configuration files (each with their standard service name in /etc/xinetd.d (xinetd.directory). Paraphrasing the man page...\n\nxinetd starts programs that provide Internet services. Instead of having such servers started at system initialization time and then remain dormant until a connection request arrives, xinetd is the only daemon process started - it instead listens on all service ports for the services listed in its configuration file - when a request comes in, xinetd starts the appropriate server.\n\nFor our POP3 server, we need to have a file called pop in /etc/xinetd.d and its contents look like this...\n\n# default: on # # POP3 honeypot service pop3 { socket_type = stream protocol = tcp wait = no user = root server = /usr/local/etc/nopop log_type = FILE /var/log/pophp/nopopx 2048 2100 log_on_success = PID HOST log_on_failure = PID HOST instances = 10 bind = 10.1.2.3 }\n\nBy limiting the number of processes to 10 (you could make it as many as you wanted if you have enough memory - get one instance working, see just how much memory it does take up and work out how many you can afford) we are preventing a DoS attack on the system that could be achieved by opening up thousands of sessions thus taking a lot of memory. Note that each session that is started creates a record line in the nopopx file (in this case) so that if you think you are being attacked, you can see which IPs are doing it and get onto their abuse line whilst they are in the act.\n\nBy binding it to a particular port, we can make it listen only on that port. The advantage of this is not that great with port 110 but if we had an smtp server that we wanted to run as a tarpit on a particular interface and also used our own smtp MTA (say sendmail) which also looks for port 25, for handling our own outgoing mail traffic, we can bind our tarpit to the external interface (using a configuration file like this but for smtp) and let sendmail grab all of the other interfaces. That way, incoming attempts to connect to port 25 will be met with a tarpit and attempts to post mail to port 25 (and therefore to sendmail) either on 127.0.0.1 (local host) or internal interfaces (such as from other machines on the LAN) will get sendmail and work as normal.\n\nPerl spam-tarpit POP3 Server\n\nThere are going to be two types of user for this:\n\nPeople with mail clients trying to hack the account\n\nor at least get something positive sounding from it (if they are confirming that there is a POP3 server there or that an account actually exists) to confirm spamtrap addresses as real; and,\n\nPeople using telnet who are trying to hack into the server to some extent, either to:\n\nget at a particular mail box that they think is vulnerable: or,\n\nget more information about other accounts (apparently).\n\nYou can modify the Perl script to add any functionality you like - supplying bogus emails full of interesting details about things that are top secret or full of other 'mailing list' email addresses - the sky is the limit. Some things that you will have to do though is waste their time, their resources and have just the right balance of failure and futility with success (whatever that is :-).\n\nThis is the basic flowchart (click on it to open up a large version in a fresh browser window)...\n\nYou can see the whole file by looking on the SuperDisc but here are the key elements with some explanations...\n\nAs always the file starts off with...\n\n#!/usr/bin/perl\n\nThen the subs that need declaring are...\n\nsub printnlog ($);\n\n...which sends a string to STDOUT and records it, long with the process id (PID from the variable $$) in the log. Also...\n\nIn my experience, it is customary to have at least one procedure and/or variable with a German name so here, we declare the procedure schlafzeit (which is literally 'sleep time'). This is called each time something needs to be directed at the user and it reacts according to a variable with another German name $teergrube or 'tarpit'.\n\nsub schlafzeit ($);\n\nHere, we select STDOUT and make it respond immediately we send anything to it in the following two lines...\n\nselect(STDOUT); $| = 1;\n\nNext, we note the time for the purposes of salting and later accounting.\n\n$c_time = substr(localtime, 4, -5); $s_time = time;\n\nFollowing this, we generate the salt string for the hash-based authentication that you would use if you were going to employ the APOP command to send a password in an encrypted form...\n\nThis is how it is represented to demonstrate the dual-use of the full stop...\n\n$salt = \"<$$.$s_time\".chr(64).\"pop.domain.com>\";\n\n...as:\n\n. a dot in the string that has in front of it the PID ($$) and the time string in seconds since the beginning of the UNIX epoch (time which we stored earlier as $s_time) - (also in the FQDN at the end); and,\n\n. a concatenation character to join the end of the time with the \"@\" (chr(64)) and then with the FQDN. This could be written more elegantly as...\n\n$salt = \"<$$.$s_time\\@pop.domain.com>\";\n\nThe @ is escaped because without doing so, it would be used to show that the string following it is in fact the name of an array. Thus, if you had \"@bill\", it would use (or attempt to use) an array called \"@bill\". If you use \"\\@bill\" it generates the string; \"@bill\".\n\nNext, we respond...\n\nprint \"+OK POP3 server ready $salt\\n\";\n\nwhich sends a string like: +OK POP3 server ready <726.1096045378@pop.domain.com> to the user at the other end, whether it is a mail client or someone with telnet. We now have the time we started all of this and the ball is in the other court, so to speak. While this is going on, we do a few background operations and then wait for the 'thing' at the other end to respond.\n\nWhen we get a response, we look at the time again and, as all we have to go on is the amount of time it has taken them to respond - that is all we can use. If it is a machine, it will be fairly quick as it is automatic but if it is a human, it will take longer to type. We can set a threshold value for our decision which I have nominally set as 3 seconds but you could set this lower if you found that people were logging on with clients consistently quicker (say 2 seconds) and this could differentiate better between people with a client and people pasting a piece of text into telnet.\n\nThe main program loop happens for as long as the client keeps the connection open. If they enter QUIT, our server will end the session (after an appropriate delay) but if they just press their 'end session key sequence' (normally Ctrl+D or Ctrl+] (or something similar)) once the tarpit checks to see if STDIN has anything else to offer, it will bypass the loop and execute the next command.\n\nIn the loop, we assess the string and react appropriately. Once the delay has been assessed and teergrube has been set or reset, the input is itself is assessed Here is an example with the QUIT command...\n\n/^QUIT/ and do { # go to sleep if a tarpit schlafzeit(1); # quit exists in all states if ($process_state == 1) { printnlog \"+OK POP3 server pop.domain.com signing off\"; } elsif ($process_state == 2) { printnlog \"+OK $user_name POP3 server signing off\"; } elsif ($process_state == 3) { if ($delmessages == 0) { printnlog \"+OK $user_name POP3 server signing off\"; } else { printnlog \"+ERR $user_name some deleted messages not removed\"; }; } else { # $process_state = 4 printnlog \"+OK $user_name POP3 server signing off\"; }; done(0); next; };\n\nIn the first line the /string/ structure tries to match the string against the input. Before the word QUIT, we have a caret (^) which means that the string that follows, if it has to match, has to be at the beginning of the input. So, /^QUIT/ will only match with QUIT, it will not match with FQUIT or Quit or anything else.\n\nFollowing /^QUIT/, we see an 'and' which, if the first part is true (ie matching the string) runs what follows - the contents of the 'do'. The rest is pretty self-explanatory.\n\nIn the case of user, we need to compare the string with USER and then a space and then other text thus...\n\n/^USER\\s+(.*)/ and do {\n\nFinally, we break out of the loop for some reason or another (the client end said QUIT or they got thrown off the system for some reason) and we execute the procedure done(0).\n\nAt the end, I have put the subroutines but you don't have to - you can put them at the beginning or intersperse them between other parts of the program, making it as legible or illegible as possible. It actually doesn't matter as long as Perl can understand it, it's just that if you make it legible, you will be able to understand it when you come back to it in a few months if you want to change something and you will have to find out how it works.\n\n##### subroutines ### ## push the client mailer into ## schlafie-schlafie land sub schlafzeit ($) { #sleepy time my $sst = shift; if ($teergrube == 1) { if ($sst == 1) { sleep int(rand 5) + 50; } elsif ($sst == 2) { sleep int(rand 8) + 45; } else { sleep int(rand 7) + 2; }; } else { sleep int(rand 5) +3; }; }\n\nI have used plenty of comments in here to make it easy for you to see what is going on as it is easy for somebody else's code to look like three platefuls of spaghetti.\n\nTo see the nopop source in another window, click here.\n\nTo see the source for the open source program (which is included here for completeness) that monitors the system for the existence of nopop running, click here."
    }
}