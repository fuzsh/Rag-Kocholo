{
    "id": "dbpedia_8290_3",
    "rank": 96,
    "data": {
        "url": "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/cha-systemd.html",
        "read_more_link": "",
        "language": "en",
        "title": "The systemd daemon",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/logo.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-tip.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-tip.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-important.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-important.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/images/systemd_startup.png",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/images/yast2_runlevel.png",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-warning.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-warning.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-tip.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-note.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-note.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-tip.svg",
            "https://doc.opensuse.org/documentation/leap/reference/html/book-reference/static/images/icon-tip.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "systemd initializes the system. It has the process ID 1. systemd is started directly by the kernel and resists signalÂ 9, which normally terminates processes. Aâ¦",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "10.3.1 Targets compared to runlevels #Edit source\n\nWith System V init the system was booted into a so-called âRunlevelâ. A runlevel defines how the system is started and what services are available in the running system. Runlevels are numbered; the most commonly known ones are 0 (shutting down the system), 3 (multiuser with network) and 5 (multiuser with network and display manager).\n\nsystemd introduces a new concept by using so-called âtarget unitsâ. However, it remains fully compatible with the runlevel concept. Target units are named rather than numbered and serve specific purposes. For example, the targets local-fs.target and swap.target mount local file systems and swap spaces.\n\nThe target graphical.target provides a multiuser system with network and display manager capabilities and is equivalent to runlevel 5. Complex targets, such as graphical.target act as âmetaâ targets by combining a subset of other targets. Since systemd makes it easy to create custom targets by combining existing targets, it offers great flexibility.\n\nThe following list shows the most important systemd target units. For a full list refer to man 7 systemd.special.\n\nSelected systemd target units #\n\ndefault.target\n\nThe target that is booted by default. Not a ârealâ target, but rather a symbolic link to another target like graphic.target. Can be permanently changed via YaST (see SectionÂ 10.4, âManaging services with YaSTâ). To change it for a session, use the kernel parameter systemd.unit=MY_TARGET.target at the boot prompt.\n\nemergency.target\n\nStarts a minimal emergency root shell on the console. Only use it at the boot prompt as systemd.unit=emergency.target.\n\ngraphical.target\n\nStarts a system with network, multiuser support and a display manager.\n\nhalt.target\n\nShuts down the system.\n\nmail-transfer-agent.target\n\nStarts all services necessary for sending and receiving mails.\n\nmulti-user.target\n\nStarts a multiuser system with network.\n\nreboot.target\n\nReboots the system.\n\nrescue.target\n\nStarts a single-user root session without network. Basic tools for system administration are available. The rescue target is suitable for solving multiple system problems, for example, failing logins or fixing issues with a display driver.\n\nTo remain compatible with the System V init runlevel system, systemd provides special targets named runlevelX.target mapping the corresponding runlevels numbered X.\n\nTo inspect the current target, use the command: systemctl get-default\n\nTableÂ 10.3: System V runlevels and systemd target units #\n\nSystem V runlevel\n\nsystemd target\n\nPurpose\n\nImportant: systemd ignores /etc/inittab\n\nThe runlevels in a System V init system are configured in /etc/inittab. systemd does not use this configuration. Refer to SectionÂ 10.5.5, âCreating custom targetsâ for instructions on how to create your own bootable target.\n\n10.3.1.1 Commands to change targets #Edit source\n\nUse the following commands to operate with target units:\n\nTask\n\nsystemd Command\n\nSystem V init Command\n\n10.5.2 Override with drop-in files #Edit source\n\nDrop-in files (or drop-ins) are partial unit files that override only specific settings of the unit file. Drop-ins have higher precedence over main configuration files. The command systemctl edit SERVICE starts the default text editor and creates a directory with an empty override.conf file in /etc/systemd/system/NAME.service.d/. The command also ensures that the running systemd process is notified about the changes.\n\nFor example, to change the amount of time that the system waits for MariaDB to start, run sudo systemctl edit mariadb.service and edit the opened file to include the modified lines only:\n\n# Configures the time to wait for start-up/stop TimeoutSec=300\n\nAdjust the TimeoutSec value and save the changes. To enable the changes, run sudo systemctl daemon-reload.\n\nFor further information, refer to the man pages that can be evoked with the man 1 systemctl command.\n\nWarning: Creating a copy of a full unit file\n\nIf you use the --full option in the systemctl edit --full SERVICE command, a copy of the original unit file is created where you can modify specific options. We do not recommend such customization because when the unit file is updated by SUSE, its changes are overridden by the customized copy in the /etc/systemd/system/ directory. Moreover, if SUSE provides updates to distribution drop-ins, they override the copy of the unit file created with --full. To prevent this confusion and always have your customization valid, use drop-ins.\n\n10.6.6 Kernel control groups (cgroups) #Edit source\n\nOn a traditional System V init system, it is not always possible to match a process to the service that spawned it. Certain services, such as Apache, spawn a lot of third-party processes (for example, CGI or Java processes), which themselves spawn more processes. This makes a clear assignment difficult or even impossible. Additionally, a service may not finish correctly, leaving certain children alive.\n\nsystemd solves this problem by placing each service into its own cgroup. cgroups are a kernel feature that allows aggregating processes and all their children into hierarchical organized groups. systemd names each cgroup after its service. Since a non-privileged process is not allowed to âleaveâ its cgroup, this provides an effective way to label all processes spawned by a service with the name of the service.\n\nTo list all processes belonging to a service, use the command systemd-cgls, for example:\n\nExampleÂ 10.3: List all processes belonging to a service #\n\n# systemd-cgls --no-pager ââ1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20 ââuser.slice â ââuser-1000.slice â ââsession-102.scope â â ââ12426 gdm-session-worker [pam/gdm-password] â â ââ15831 gdm-session-worker [pam/gdm-password] â â ââ15839 gdm-session-worker [pam/gdm-password] â â ââ15858 /usr/lib/gnome-terminal-server [...] ââsystem.slice ââsystemd-hostnamed.service â ââ17616 /usr/lib/systemd/systemd-hostnamed ââcron.service â ââ1689 /usr/sbin/cron -n ââpostfix.service â ââ 1676 /usr/lib/postfix/master -w â ââ 1679 qmgr -l -t fifo -u â ââ15590 pickup -l -t fifo -u ââsshd.service â ââ1436 /usr/sbin/sshd -D [...]\n\nSee Book âSystem Analysis and Tuning Guideâ, ChapterÂ 10 âKernel control groupsâ for more information about cgroups.\n\n10.6.8 Important notes on the D-Bus service #Edit source\n\nThe D-Bus service is the message bus for communication between systemd clients and the systemd manager that is running as pid 1. Even though dbus is a stand-alone daemon, it is an integral part of the init infrastructure.\n\nStopping dbus or restarting it in the running system is similar to an attempt to stop or restart PID 1. It breaks the systemd client/server communication and makes most systemd functions unusable.\n\nTherefore, terminating or restarting dbus is neither recommended nor supported.\n\nUpdating the dbus or dbus-related packages requires a reboot. When in doubt whether a reboot is necessary, run the sudo zypper ps -s. If dbus appears among the listed services, you need to reboot the system.\n\nKeep in mind that dbus is updated even when automatic updates are configured to skip the packages that require reboot.\n\n10.7.3 Practical example #Edit source\n\nTo understand the basics of systemd timer units, we set up a timer that triggers the foo.sh shell script.\n\nFirst step is to create a systemd service unit that controls the shell script. To do this, open a new text file for editing and add the following service unit definition:\n\n[Unit] Description=\"Foo shell script\" [Service] ExecStart=/usr/local/bin/foo.sh\n\nSave the file under the name foo.service in the directory /etc/systemd/system/.\n\nNext, open a new text file for editing and add the following timer definition:\n\n[Unit] Description=\"Run foo shell script\" [Timer] OnBootSec=5min OnUnitActiveSec=24h Unit=foo.service [Install] WantedBy=multi-user.target\n\nThe [Timer] section in the example above specifies what service to trigger (foo.service) and when to trigger it. In this case, the option OnBootSec specifies a monotonic timer that triggers the service five minutes after the system boot, while the option OnUnitActiveSec triggers the service 24 hours after the service has been activated (that is, the timer triggers the service once a day). Finally, the option WantedBy specifies that the timer should start when the system has reached the multiuser target.\n\nInstead of a monotonic timer, you can specify a real-time one using the option OnCalendar. The following realtime timer definition triggers the related service unit once a week, starting on Monday at 12:00.\n\n[Timer] OnCalendar=weekly Persistent=true\n\nThe option Persistent=true indicates that the service is triggered immediately after the timer activation if the timer missed the last start time (for example, because of the system being powered off).\n\nThe option OnCalendar can also be used to define specific dates times for triggering a service using the following format: DayOfWeek Year-Month-Day Hour:Minute:Second. The example below triggers a service at 5am every day:\n\nOnCalendar=*-*-* 5:00:00\n\nYou can use an asterisk to specify any value, and commas to list possible values. Use two values separated by .. to indicate a contiguous range. The following example triggers a service at 6pm on Friday of every month:\n\nOnCalendar=Fri *-*-1..7 18:00:00\n\nTo trigger a service at different times, you can specify several OnCalendar entries:\n\nOnCalendar=Mon..Fri 10:00 OnCalendar=Sat,Sun 22:00\n\nIn the example above, a service is triggered at 10am on week days and at 10pm on weekends.\n\nWhen you are done editing the timer unit file, save it under the name foo.timer in the /etc/systemd/system/ directory. To check the correctness of the created unit files, run the following command:\n\n> sudo systemd-analyze verify /etc/systemd/system/foo.*\n\nIf the command returns no output, the files have passed the verification successfully.\n\nTo start the timer, use the command sudo systemctl start foo.timer. To enable the timer on boot, run the command sudo systemctl enable foo.timer."
    }
}