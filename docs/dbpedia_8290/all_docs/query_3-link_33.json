{
    "id": "dbpedia_8290_3",
    "rank": 33,
    "data": {
        "url": "https://groups.google.com/g/comp.unix.shell/c/l7nUSS5CgkU",
        "read_more_link": "",
        "language": "en",
        "title": "Preventing multiple invocations of script from accessing the same file",
        "top_image": "https://www.gstatic.com/images/branding/product/1x/groups_32dp.png",
        "meta_img": "https://www.gstatic.com/images/branding/product/1x/groups_32dp.png",
        "images": [
            "https://fonts.gstatic.com/s/i/productlogos/groups/v9/web-48dp/logo_groups_color_1x_web_48dp.png",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a-/ALV-UjV7KmjM4MYSnCI11Re6FwCvwM8xp2rzmANtBECOvYgP5-w_dw=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a-/ALV-UjV3MJYY-yl20T4cj8bcI5e688jjx2x7Iy9wy998jObOylykBQ5N=s40-c",
            "https://lh3.googleusercontent.com/a-/ALV-UjXbsCLjnNY1mTtfeKOtcGowqoNn-_0HwTgHiZULDYhny9xgLA=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a-/ALV-UjXbsCLjnNY1mTtfeKOtcGowqoNn-_0HwTgHiZULDYhny9xgLA=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c",
            "https://lh3.googleusercontent.com/a/default-user=s40-c"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "//www.gstatic.com/images/branding/product/1x/groups_32dp.png",
        "meta_site_name": "",
        "canonical_link": "https://groups.google.com/g/comp.unix.shell/c/l7nUSS5CgkU",
        "text": "I am writing a CGI script using the Bourne shell. I want to update a file\n\nbased on input obtained.\n\nIf another person is accessing the same web page, the script may be invoked\n\na second time, whilst the first occurance is still running.\n\nHow can I configure some sort of lock, so that the second copy of the script\n\nwill not continue, until the first copy of the script has done the update.\n\nI thought about some sort of lock file, but I thought of a problem when both\n\nscripts are invoked one after the other where the second script may not see\n\nthe lock file by the first, because it didn't exist at the time of check.\n\nPlease advise.\n\nMark.\n\n--\n\nMark Hobley\n\n393 Quinton Road West\n\nQUINTON\n\nBirmingham\n\nB32 1QE\n\nTelephone: (0121) 247 1596\n\nInternational: 0044 121 247 1596\n\nEmail: markhobley at hotpop dot donottypethisbit com\n\nhttp://markhobley.yi.org/\n\nOn Sun, 27 Nov 2005 21:08:03 +0000, Mark Hobley wrote:\n\n> I am writing a CGI script using the Bourne shell. I want to update a file\n\n> based on input obtained.\n\n>\n\n> If another person is accessing the same web page, the script may be invoked\n\n> a second time, whilst the first occurance is still running.\n\n>\n\n> How can I configure some sort of lock, so that the second copy of the script\n\n> will not continue, until the first copy of the script has done the update.\n\n>\n\n> I thought about some sort of lock file, but I thought of a problem when both\n\n> scripts are invoked one after the other where the second script may not see\n\n> the lock file by the first, because it didn't exist at the time of check.\n\n>\n\n> Please advise.\n\n>\n\nHow about:\n\n1. Check if lockfile exists, if it does wait until it doesn't.\n\n2. When there is no lockfile create a lockfile containing the current\n\nprocess id.\n\n3. Read the lockfile, if it contains the current process id carry on, if\n\nthe contained process id is different then wait until lockfile is removed.\n\n--\n\nGeoff\n\nReplace bitbucket with geoff to mail me\n\nMark Hobley wrote:\n\n> I am writing a CGI script using the Bourne shell. I want to update a file\n\n> based on input obtained.\n\n>\n\n> If another person is accessing the same web page, the script may\n\n> be invoked a second time, whilst the first ocurrence is still running.\n\n>\n\n> How can I configure some sort of lock, so that the second copy of the\n\n> script will not continue, until the first copy of the script has done\n\n> the update.\n\n>\n\nI'd suggest that you don't do it that way.\n\nThe easy way to avoid conflicts without using locks is to move all the\n\ncritical stuff into a single threaded server which only ever runs as a\n\nsingle instance and listens on a named pipe or a port.\n\nYour script needs to call a simple program that opens a connection to\n\nthe server, passes the request to the server, waits for the response,\n\ncloses the connection and quits.\n\nThe server should be written to receive a request, process it using\n\nsynchronous i/o and return a response. Because the server is single\n\nthreaded it will serialize requests: while it is handling one request it\n\nwon't accept another connection, let alone overlap it with another\n\nrequest. The server needs to use poll() to handle the listener port and\n\nthe accepted connections but should not use it for anything else apart\n\nfrom trapping signals. This assumes a single copy of a permanent server\n\nis started at boot time.\n\nThe other way to run the server is to let xinetd start the server on\n\ndemand and configure xinetd to allow only one copy of the server to be\n\nstarted. This makes the server as easy to write as a normal filter. It\n\ngets the request via stdin and writes the response to stdout. It doesn't\n\nuse poll() at all.\n\nHTH\n\n--\n\nmartin@ | Martin Gregorie\n\ngregorie. |\n\norg | Zappa fan & glider pilot\n\nIn article <fagp53-...@neptune.markhobley.yi.org>,\n\nMark Hobley <markh...@hotpop.deletethisbit.com> wrote:\n\n>I am writing a CGI script using the Bourne shell. I want to update a file\n\n>based on input obtained.\n\nWhy the Bourne shell?\n\nIf you were using Perl, you could use standard locking facilities.\n\nHowever, if you insist on doing file locking in Bourne shell, the\n\nbest way is probably via symlinks, thus:\n\nto lock:\n\nlocked=''\n\nwhile [ ! \"$locked\" ] ; do\n\nln -s $$ lockfile 2>/dev/null\n\nif [ `readlink lockfile` = $$ ] ; then\n\nlocked=yes\n\nelse\n\nsleep 10\n\n# insert error checking, timeouts, etc. to taste\n\nfi\n\ndone\n\nto unlock:\n\n# do paranoia checking that the lock is still ours if you like\n\nrm lockfile\n\nThe reason for using symlinks is that symlink creation is atomic even\n\nover NFS.\n\nIn alt.comp.os.linux Martin Gregorie <mar...@see.sig.for.address> wrote:\n\n> The easy way to avoid conflicts without using locks is to move all the\n\n> critical stuff into a single threaded server which only ever runs as a\n\n> single instance and listens on a named pipe or a port.\n\nThat sounds like something that I want to do. How easy is it to set this up ?\n\nIs there a skeleton or sample code that I can work from ?\n\n(Pipes are preferred, but I would like to know how to do this with ports also.)\n\n> Your script needs to call a simple program that opens a connection to\n\n> the server, passes the request to the server, waits for the response,\n\n> closes the connection and quits.\n\nAgain, how easy is this to set up ? Is there a skeleton ?\n\n(My background is MSDOS assembly language. I am new to Linux programming.)\n\n> The other way to run the server is to let xinetd start the server on\n\n> demand and configure xinetd to allow only one copy of the server to be\n\n> started.\n\nWill the traditional superserver daemon, inetd do this ? I am not using xinetd.\n\n\n\nOn comp.unix.shell, in <1rup53-...@neptune.markhobley.yi.org>, \"Mark Hobley\" wrote:\n\n<snip>\n\nHere's the URL to a tutorial on the subject in question, for\n\nwebmasters, with a number of solutions presented in detail (it\n\ncame up two years ago in connection with a related challenge, and\n\nI have a very good local cache, which, unlike GG, doesn't decide\n\nto drop posts for no apparent reason.\n\nOOOO://OOOO.OOOOO.OOO/~OOOOOOOO/OOOOOO/OOO-OOOO.OOOO\n\n> --\n\n> OOOO OOOOOO\n\n> OOO OOOOOOO OOOO OOOO\n\n> OOOOOOO\n\n> OOOOOOOOOO\n\n> OOO OOO\n\n>\n\n> OOOOOOOOO: (OOOO) OOO OOOO\n\n> OOOOOOOOOOOOO: OOOO OOO OOO OOOO\n\n>\n\n> OOOOO: OOOOOOOOOO OO OOOOOO OOO OOOOOOOOOOOOOOOO OOO\n\n>\n\n> OOOO://OOOOOOOOOO.OO.OOO/\n\n>\n\nI thought it was only fitting to use the same vi macro on the URL\n\nas I use on your obnoxious, over-sized, Netiquette-violating sig.\n\nBut I _will_ post it on this very thread sometime in the future.\n\n(It's on my calendar and I've saved a copy of the tutorial in\n\ncase it vanishes from the Web for some reason.)\n\nIt isn't fair to deprive everyone of the information just because\n\nof one rude jerk.\n\nThanks for the workout with find and grep, \"Mark\". I learned a\n\ncouple of valuable things in the process of searching my news\n\ncache.\n\nAlan\n\n--\n\nURLs of possible interest in my headers.\n\nMark Hobley wrote:\n\n> In alt.comp.os.linux Martin Gregorie <mar...@see.sig.for.address> wrote:\n\n>\n\n>> The easy way to avoid conflicts without using locks is to move all the\n\n>> critical stuff into a single threaded server which only ever runs as a\n\n>> single instance and listens on a named pipe or a port.\n\n>\n\n> That sounds like something that I want to do. How easy is it to set this up ?\n\n>\n\nPretty easy. The client is always easy to write. Servers are OK too once\n\nyou've written one. If you believe in having a technical library, get\n\nthe O'Reilly \"Lion\" book (Unix SVR4 System Programming) - its a goldmine\n\nfor guidance on using all sorts of useful stuff and on portability\n\nissues. In UNIX-speak \"system programming\" merely means writing code in C.\n\n> Is there a skeleton or sample code that I can work from ?\n\n>\n\nE-mail me if you want sample code. I have skeletons for single threaded,\n\nmulti-threaded and xinetd single-session servers and the associated\n\nclient. Ditto for a Java multi-threaded server and client. These are all\n\nmix'n match: all clients talk to all servers.\n\n> (Pipes are preferred, but I would like to know how to do this with ports also.)\n\n>\n\nThere's almost no difference in the code. The only practical differences\n\nare:\n\n- named pipes only link processes within the same machine but allow\n\na development team to easily run multiple development environments\n\nand not clash with ports that are already in use.\n\n- ports are not restricted to one machine, but the server needs to\n\nallow the port number to be configurable if you want to run more\n\nthan one copy on a system. Ports can't be shared between servers.\n\n- servers run under xinetd must use ports.\n\nI've used named pipes during large scale development when each developer\n\nneeded to run his own copy of the complete multi-process system, but for\n\ngeneral use I prefer ports for their greater flexibility. Don't forget\n\nthat a named pipe is effectively a special file (a so-called fifo) and\n\nexists within a directory. Unnamed pipes are not relevant to this\n\ndiscussion: unless a server is listening to a named pipe or a known port\n\nhow could the client programs find it?\n\n>> Your script needs to call a simple program that opens a connection to\n\n>> the server, passes the request to the server, waits for the response,\n\n>> closes the connection and quits.\n\n>\n\n> Again, how easy is this to set up ? Is there a skeleton ?\n\n>\n\nNot as easy as the xinetd server, but not hard. Its essentially linear code:\n\nopen a connection to the server\n\nwrite a command to the connection\n\nread the reply\n\nclose the connection\n\nexit\n\n> (My background is MSDOS assembly language. I am new to Linux programming.)\n\n>\n\nYou'll love it. Its a way of life.\n\nSeriously, Linux programming in C is (a) easier than for DOS and (b)\n\nmuch easier than assembler.\n\nI'm not up to speed on CGI, but IIRC data is passed to a CGI script as\n\ncommand line arguments. If so, you can forget the script and just call\n\nthe C client program in place of the script. Development would also be\n\neasy: you can test run the client from the command line and configure\n\ninetd/xinetd to load the server from your development directory.\n\n>> The other way to run the server is to let xinetd start the server on\n\n>> demand and configure xinetd to allow only one copy of the server to be\n\n>> started.\n\n>\n\n> Will the traditional superserver daemon, inetd do this ? I am not using xinetd.\n\n>\n\nI'm surprised. I thought all modern distros had changed over to xinetd.\n\nThat said, I can't comment on inetd's capabilities. Its not installed\n\nhere so I don't have the manpage.\n\nThe xinetd server logic looks like this:\n\nwhile not EOF\n\n{\n\nread a line from stdin\n\nprocess\n\nwrite a reply to stdout\n\n}\n\nexit(0)\n\nYou set \"wait=yes\" in the xinetd service definition for this server,\n\nwhich prevents xinetd from starting another copy of the server until the\n\ncurrent one dies. Provided that inetd supports the \"wait\" option for a\n\nservice it will also do the trick.\n\n\n\nIn comp.unix.shell Martin Gregorie <mar...@see.sig.for.address> wrote:\n\n> The easy way to avoid conflicts without using locks is to move all the\n\n> critical stuff into a single threaded server which only ever runs as a\n\n> single instance and listens on a named pipe or a port.\n\nI am setting up a server to receive a series of commands via a named pipe.\n\nDoes the pipe only allow one process to feed its input at a time ?\n\nWhat would happen if two copies of the client feed tried to write to the pipe\n\nat the same time ?\n\nI was going to use this script:\n\nPIPEFILE=/service/pipe/webcgi/count.pipe\n\nCOUNTFILE=webcount\n\neval \"`./proccgi.exe`\"\n\nif [ -e $PIPEFILE ] ;then\n\nif [ -w $PIPEFILE ] ; then\n\necho \"COUNT\" > $PIPEFILE\n\necho \"REMOTEADDR $REMOTE_ADDR\" > $PIPEFILE\n\necho \"FILE $COUNTFILE\" > $PIPEFILE\n\necho \"INCREMENT\" > $PIPEFILE\n\nfi\n\nfi\n\nBut I thought, that supposing two copies are running simultaneously.\n\nThe output from the echo lines could mix, whilst feeding the pipe:\n\nFor example:\n\nCOUNT\n\nCOUNT\n\nREMOTE ADDRESS 192.168.0.1\n\nREMOTE ADDRESS 192.168.0.2\n\nFILE webcount\n\nFILE webcount\n\nINCREMENT\n\nINCREMENT\n\nor worse, could they intermingle character by character ?\n\nCOCOUNUNT\n\nRERMEMOOTTEE A DADDRRESESS S 11992.2.116788..00.1.2\n\nFFILIELE wwebecbocuontunt\n\nIINNCCRREMEEMNETNT\n\nIf the pipe only allows one process to feed it, then presumably, this would\n\neliminate the character by character problem, due to the pipe file being\n\nopened to only one echo command at a time, in which case, I could fix the line\n\nby line echo problem, by using a single echo command for the entire line, as\n\nfollows:\n\necho \"COUNT\\nREMOTEADDR $REMOTE_ADDR\\nFILE $COUNTFILE\\nINCREMENT\" > $PIPEFILE\n\n\n\nMark Hobley wrote:\n\n> In comp.unix.shell Martin Gregorie <mar...@see.sig.for.address> wrote:\n\n>\n\n>> The easy way to avoid conflicts without using locks is to move all the\n\n>> critical stuff into a single threaded server which only ever runs as a\n\n>> single instance and listens on a named pipe or a port.\n\n>\n\n> I am setting up a server to receive a series of commands via a named pipe.\n\n> Does the pipe only allow one process to feed its input at a time ?\n\n>\n\nNo. Any number of programs can write to the pipe at once.\n\n> What would happen if two copies of the client feed tried to write to the pipe\n\n> at the same time ?\n\n>\n\nMultiple programs can write to a pipe and that each write operation is\n\natomic provided it sends less than PIPE_BUFF bytes. In Linux PIPE_BUFF =\n\n4096. This means that a write will be blocked until any other\n\nsimultaneous writes have finished, so the data from each write cannot be\n\ninterleaved with data from other programs.\n\n> I was going to use this script:\n\n>\n\n> PIPEFILE=/service/pipe/webcgi/count.pipe\n\n> COUNTFILE=webcount\n\n> eval \"`./proccgi.exe`\"\n\n>\n\n> if [ -e $PIPEFILE ] ;then\n\n> if [ -w $PIPEFILE ] ; then\n\n> echo \"COUNT\" > $PIPEFILE\n\n> echo \"REMOTEADDR $REMOTE_ADDR\" > $PIPEFILE\n\n> echo \"FILE $COUNTFILE\" > $PIPEFILE\n\n> echo \"INCREMENT\" > $PIPEFILE\n\n> fi\n\n> fi\n\n>\n\n> But I thought, that supposing two copies are running simultaneously.\n\n>\n\n> The output from the echo lines could mix, whilst feeding the pipe:\n\n>\n\n> For example:\n\n>\n\n> COUNT\n\n> COUNT\n\n> REMOTE ADDRESS 192.168.0.1\n\n> REMOTE ADDRESS 192.168.0.2\n\n> FILE webcount\n\n> FILE webcount\n\n> INCREMENT\n\n> INCREMENT\n\n>\n\nYou would certainly get that effect. You need to assemble a single\n\nmessage to avoid that:\n\nif [ -e $PIPEFILE ] ;then\n\nif [ -w $PIPEFILE ] ; then\n\nMSG=\"COUNT,REMOTEADDR $REMOTE_ADDR,FILE $COUNTFILE,INCREMENT\"\n\necho \"$MSG\" > $PIPEFILE\n\nfi\n\nfi\n\nI've just run a quick test using the single, concatenated string. It\n\nworks as expected.\n\n> or worse, could they intermingle character by character ?\n\n>\n\nDoesn't happen.\n\nIn the following the cgi script is the client and the server is, err,\n\nyour server. Do remember that:\n\n- the writer will block forever unless there is a reader with\n\nthe named pipe open\n\n- the named pipe is bidirectional but if the server sends a reply\n\nthere's no guarantee which client will get it\n\nReturning a reply is good practice because it lets the user know that\n\nhis task completed and it makes for good flow control. However, you'll\n\nneed to use a socket rather than a pipe in order to get the reply back\n\nto the correct client. Besides, if you want to take advantage of inetd\n\nto start your server you have to use sockets: inetd doesn't understand\n\nnamed pipes.\n\n"
    }
}