{
    "id": "dbpedia_8290_3",
    "rank": 39,
    "data": {
        "url": "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/cha-systemd.html",
        "read_more_link": "",
        "language": "en",
        "title": "openSUSE Leap 15.4",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/static/images/logo.svg",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/static/images/icon-tip.svg",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/static/images/icon-important.svg",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/static/images/icon-important.svg",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/images/systemd_startup.png",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/images/yast2_runlevel.png",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/static/images/icon-warning.svg",
            "https://doc.opensuse.org/documentation/leap/archive/15.4/reference/html/book-reference/static/images/icon-note.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "systemd is responsible for initializing the system, anâ¦",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "10.3.1 Targets compared to runlevels #\n\nWith System V init the system was booted into a so-called âRunlevelâ. A runlevel defines how the system is started and what services are available in the running system. Runlevels are numbered; the most commonly known ones are 0 (shutting down the system), 3 (multiuser with network) and 5 (multiuser with network and display manager).\n\nsystemd introduces a new concept by using so-called âtarget unitsâ. However, it remains fully compatible with the runlevel concept. Target units are named rather than numbered and serve specific purposes. For example, the targets local-fs.target and swap.target mount local file systems and swap spaces.\n\nThe target graphical.target provides a multiuser system with network and display manager capabilities and is equivalent to runlevel 5. Complex targets, such as graphical.target act as âmetaâ targets by combining a subset of other targets. Since systemd makes it easy to create custom targets by combining existing targets, it offers great flexibility.\n\nThe following list shows the most important systemd target units. For a full list refer to man 7 systemd.special.\n\nSelected systemd target units #\n\ndefault.target\n\nThe target that is booted by default. Not a ârealâ target, but rather a symbolic link to another target like graphic.target. Can be permanently changed via YaST (see SectionÂ 10.4, âManaging services with YaSTâ). To change it for a session, use the kernel parameter systemd.unit=MY_TARGET.target at the boot prompt.\n\nemergency.target\n\nStarts an emergency shell on the console. Only use it at the boot prompt as systemd.unit=emergency.target.\n\ngraphical.target\n\nStarts a system with network, multiuser support and a display manager.\n\nhalt.target\n\nShuts down the system.\n\nmail-transfer-agent.target\n\nStarts all services necessary for sending and receiving mails.\n\nmulti-user.target\n\nStarts a multiuser system with network.\n\nreboot.target\n\nReboots the system.\n\nrescue.target\n\nStarts a single-user system without network.\n\nTo remain compatible with the System V init runlevel system, systemd provides special targets named runlevelX.target mapping the corresponding runlevels numbered X.\n\nIf you want to know the current target, use the command: systemctl get-default\n\nTableÂ 10.3: System V runlevels and systemd target units #\n\nSystem V runlevel\n\nsystemd target\n\nPurpose\n\nImportant: systemd ignores /etc/inittab\n\nThe runlevels in a System V init system are configured in /etc/inittab. systemd does not use this configuration. Refer to SectionÂ 10.5.4, âCreating custom targetsâ for instructions on how to create your own bootable target.\n\n10.3.1.1 Commands to change targets #\n\nUse the following commands to operate with target units:\n\nTask\n\nsystemd Command\n\nSystem V init Command\n\n10.5.1 Customizing unit files #\n\nThe recommended way to customize unit files is to use the systemctl edit SERVICE command. This command starts the default text editor and creates a directory with the override.conf file in /etc/systemd/system/NAME.service.d/. The command also ensures that the running systemd process is notified about the changes.\n\nAlternatively, you can open a copy of the original file for editing instead of a blank file by running systemctl edit --full SERVICE. When editing the file, make sure that you do not remove any of the existing sections.\n\nAs an exercise, change how long the system waits for MariaDB to start. As root, run systemctl edit --full mariadb.service. The file opened will look similar to the following:\n\n[Unit] Description=MySQL server Wants=basic.target Conflicts=mariadb.target After=basic.target network.target [Install] WantedBy=multi-user.target Alias=mysql.service [Service] Restart=on-abort Type=notify ExecStartPre=/usr/lib/mysql/mysql-systemd-helper install ExecStartPre=/usr/lib/mysql/mysql-systemd-helper upgrade ExecStart=/usr/lib/mysql/mysql-systemd-helper start # Configures the time to wait for start-up/stop TimeoutSec=300 # Prevent writes to /usr, /boot, and /etc ProtectSystem=full # Prevent accessing /home, /root and /run/user ProtectHome=true UMask=007\n\nAdjust the TimeoutSec value and save the changes. To enable the changes, as root, run systemctl daemon-reload.\n\nFor further information, refer to the man pages that can be evoked with the man 1 systemctl command.\n\n10.6.6 Kernel control groups (cgroups) #\n\nOn a traditional System V init system it is not always possible to clearly assign a process to the service that spawned it. Some services, such as Apache, spawn a lot of third-party processes (for example CGI or Java processes), which themselves spawn more processes. This makes a clear assignment difficult or even impossible. Additionally, a service may not terminate correctly, leaving some children alive.\n\nsystemd solves this problem by placing each service into its own cgroup. cgroups are a kernel feature that allows aggregating processes and all their children into hierarchical organized groups. systemd names each cgroup after its service. Since a non-privileged process is not allowed to âleaveâ its cgroup, this provides an effective way to label all processes spawned by a service with the name of the service.\n\nTo list all processes belonging to a service, use the command systemd-cgls. The result will look like the following (shortened) example:\n\nExampleÂ 10.3: List all processes belonging to a service #\n\n# systemd-cgls --no-pager ââ1 /usr/lib/systemd/systemd --switched-root --system --deserialize 20 ââuser.slice â ââuser-1000.slice â ââsession-102.scope â â ââ12426 gdm-session-worker [pam/gdm-password] â â ââ15831 gdm-session-worker [pam/gdm-password] â â ââ15839 gdm-session-worker [pam/gdm-password] â â ââ15858 /usr/lib/gnome-terminal-server [...] ââsystem.slice ââsystemd-hostnamed.service â ââ17616 /usr/lib/systemd/systemd-hostnamed ââcron.service â ââ1689 /usr/sbin/cron -n ââpostfix.service â ââ 1676 /usr/lib/postfix/master -w â ââ 1679 qmgr -l -t fifo -u â ââ15590 pickup -l -t fifo -u ââsshd.service â ââ1436 /usr/sbin/sshd -D [...]\n\nSee Book âSystem Analysis and Tuning Guideâ, ChapterÂ 9 âKernel control groupsâ for more information about cgroups.\n\n10.6.8 Important notes on the D-Bus service #\n\nThe D-Bus service is the message bus for communication between systemd clients and the systemd manager that is running as pid 1. Even though dbus is a stand-alone daemon, it is an integral part of the init infrastructure.\n\nTerminating dbus or restarting it in the running system is similar to an attempt to terminate or restart pid 1. It will break systemd client/server communication and make most systemd functions unusable.\n\nTherefore, terminating or restarting dbus is neither recommended nor supported.\n\nUpdating the dbus or dbus-related packages requires a reboot. When in doubt whether a reboot is necessary, run the sudo zypper ps -s. If dbus appears among the listed services, you need to reboot the system.\n\nKeep in mind that dbus is updated even when automatic updates are configured to skip the packages that require reboot.\n\n10.7.3 Practical example #\n\nTo understand the basics of systemd timer units, we set up a timer that triggers the foo.sh shell script.\n\nFirst step is to create a systemd service unit that controls the shell script. To do this, open a new text file for editing and add the following service unit definition:\n\n[Unit] Description=\"Foo shell script\" [Service] ExecStart=/usr/local/bin/foo.sh\n\nSave the file under the name foo.service in the directory /etc/systemd/system/.\n\nNext, open a new text file for editing and add the following timer definition:\n\n[Unit] Description=\"Run foo shell script\" [Timer] OnBootSec=5min OnUnitActiveSec=24h Unit=foo.service [Install] WantedBy=multi-user.target\n\nThe [Timer] section in the example above specifies what service to trigger (foo.service) and when to trigger it. In this case, the option OnBootSec specifies a monotonic timer that triggers the service five minutes after the system boot, while the option OnUnitActiveSec triggers the service 24 hours after the service has been activated (that is, the timer will trigger the service once a day). Finally the option WantedBy specifies that the timer should start when the system has reached the multi-user target.\n\nInstead of a monotonic timer, you can specify a realtime one using the option OnCalendar. The following realtime timer definition triggers the related service unit once a week, starting on Monday at 12:00.\n\n[Timer] OnCalendar=weekly Persistent=true\n\nThe option Persistent=true indicates that the service will be triggered immediately after the timer activation if the timer missed the last start time (for example, because of the system being powered off).\n\nThe option OnCalendar can also be used to define specific dates times for triggering a service using the following format: DayOfWeek Year-Month-Day Hour:Minute:Second. The example below triggers a service at 5am every day:\n\nOnCalendar=*-*-* 5:00:00\n\nYou can use an asterisk to specify any value, and commas to list possible values. Use two values separated by .. to indicate a contiguous range. The following example triggers a service at 6pm on Friday of every month:\n\nOnCalendar=Fri *-*-1..7 18:00:00\n\nTo trigger a service at different times, you can specify several OnCalendar entries:\n\nOnCalendar=Mon..Fri 10:00 OnCalendar=Sat,Sun 22:00\n\nIn the example above, a service is triggered at 10am on week days and at 10pm on weekends.\n\nWhen you are done editing the timer unit file, save it under the name foo.timer in the /etc/systemd/system/ directory. To check the correctness of the created unit files, run the following command:\n\n> sudo systemd-analyze verify /etc/systemd/system/foo.*\n\nIf the command returns no output, the files have passed the verification successfully.\n\nTo start the timer, use the command sudo systemctl start foo.timer. To enable the timer on boot, run the command sudo systemctl enable foo.timer."
    }
}