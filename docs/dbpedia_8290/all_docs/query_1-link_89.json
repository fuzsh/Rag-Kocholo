{
    "id": "dbpedia_8290_1",
    "rank": 89,
    "data": {
        "url": "https://medium.com/shellpwn/hosting-your-own-ctf-765607dbe06f",
        "read_more_link": "",
        "language": "en",
        "title": "Hosting your own CTF",
        "top_image": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*Z8DTzT6ZVe2SybTP",
        "meta_img": "https://miro.medium.com/v2/da:true/resize:fit:1200/0*Z8DTzT6ZVe2SybTP",
        "images": [
            "https://miro.medium.com/v2/resize:fill:64:64/1*dmbNkD5D-u45r44go_cf0g.png",
            "https://miro.medium.com/v2/da:true/resize:fill:88:88/0*Hg-EcDwFghlUFdhr",
            "https://miro.medium.com/v2/resize:fill:48:48/1*BeYTrlmESu7v6qk_I0ciTg.png",
            "https://miro.medium.com/v2/da:true/resize:fill:144:144/0*Hg-EcDwFghlUFdhr",
            "https://miro.medium.com/v2/resize:fill:64:64/1*BeYTrlmESu7v6qk_I0ciTg.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Divy",
            "medium.com"
        ],
        "publish_date": "2021-06-20T22:26:23.960000+00:00",
        "summary": "",
        "meta_description": "This article is about my experiences in setting up the infrastructure for S.H.E.L.L. CTF 2021. In this blog, we’ll cover : CTFd is an easy-to-use, open-source, CTF hosting platform. It comes with…",
        "meta_lang": "en",
        "meta_favicon": "https://miro.medium.com/v2/5d8de952517e8160e40ef9841c781cdc14a5db313057fa3c3de41c6f5b494b19",
        "meta_site_name": "Medium",
        "canonical_link": "https://medium.com/shellpwn/hosting-your-own-ctf-765607dbe06f",
        "text": "The CTFd Platform\n\nCTFd/CTFd\n\nCTFd is a Capture The Flag framework focusing on ease of use and customizability. It comes with everything you need to…\n\ngithub.com\n\nCTFd is an easy-to-use, open-source, CTF hosting platform. It comes with everything one might need to host a CTF. Some features include:\n\n- An admin panel to configure the environment,\n\n- Add and edit challenges (dynamic scores and add hints, etc.),\n\n- View statistics, and\n\n- Modify the home page.\n\nDeploying CTFd\n\nThere are 3 ways in which CTFd can be deployed on your server :\n\nClone the repository, install the requirements via pip, configure it to your liking, and use python serve.py or flask run in a terminal to drop into debug mode.\n\nOne can use Docker Compose with the following command from the source repository:docker-compose up which will use the docker-compose.yml file.\n\nOne can also use the auto-generated Docker image with the following command:docker run -p 8000:8000 -it ctfd/ctfd\n\nI used option 3 as it was the easiest to set up and worked without hassles.\n\nWe start by installing docker to our instance. Since we used Ubuntu 20.04, I followed the steps mentioned here: https://www.digitalocean.com/community/tutorials/how-to-install-and-use-docker-on-ubuntu-20-04. The steps are :\n\nsudo apt updatesudo apt install apt-transport-https ca-certificates curl software-properties-commoncurl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu focal stable\"sudo apt updatesudo apt install docker-cesudo systemctl status docker\n\nOnce docker is installed, we can execute the docker run command docker run -p 8000:8000 -it ctfd/ctfd. This should startup CTFd running on port 8000 on your server.\n\nNavigate to port 8000 on <YOUR_SERVER_IP>:8000 or if you have linked a domain to your server, then at <your domain>:8000 on a browser.\n\nAfter completing the initial setup for CTFd, you should be able to now access the Admin Panel to manage your CTF!\n\nFirewall and Nginx for rate limiting\n\nNginx is a reverse proxy server, i.e. it accepts incoming connections to its port and then routes them to another service running on another port on the machine. We will be setting up Nginx and configuring it to do the following things:\n\nPreviously, you accessed your server using <your domain>:8000, we will instead route <your domain> to CTFd running on port 8000 automatically.\n\nWe’ll set up rate limiting to limit both the number of requests per second to CTFd and also the maximum number of simultaneous connections to it from a single host.\n\n(optional) If you’re going to be using Cloudflare, we’ll also reconfigure Nginx to correctly log the original user’s IP address, instead of logging only Cloudflare IPs in Nginx logs.\n\nInstalling ufw (firewall) and Nginx on Ubuntu 20.04 server :\n\nsudo apt update sudo apt install nginx ufw\n\nAllowing SSH, HTTP and HTTPS through the firewall :\n\nsudo ufw allow 'Nginx Full'sudo ufw allow 'OpenSSH'\n\nNow to enable the firewall :\n\nsudo ufw enable\n\nNow if you visit the domain, you should see the default Nginx page.\n\nWe need to route Nginx reverse proxy to port 8000, to show our CTFd page.\n\nCreate a file at /etc/nginx/sites-available/yourdomain.com (replace yourdomain.com with your domain or just your IP address if you don’t have a domain) with the following contents.\n\nlimit_req_zone $binary_remote_addr zone=mylimit:10m rate=10r/s;\n\nlimit_conn_zone $binary_remote_addr zone=addr:10m;\n\nserver {\n\nserver_name yourdomain.com;\n\nlimit_req zone=mylimit burst=15;\n\nlimit_conn addr 10;\n\nlimit_req_status 429;\n\nclient_max_body_size 8M;\n\nlocation / {\n\nproxy_pass http://localhost:8000;\n\nproxy_http_version 1.1;\n\nproxy_set_header Upgrade $http_upgrade;\n\nproxy_set_header Connection 'upgrade';\n\nproxy_set_header Host $host;\n\nproxy_cache_bypass $http_upgrade;\n\n}\n\n}\n\nThis sets up rate-limiting at 10 requests per second, and a max of 10 simultaneous connections per IP address at a time, and also tells Nginx to route requests to yourdomain.com at port 8000.\n\nIf you are using Cloudflare, replace $binary_remote_addr everywhere above with $http_cf_connecting_ip. This makes Nginx read the user IPs and limit requests on their basis, not on the Cloudflare server’s IP.\n\nWe create a symlink to the file you created in the previous step in /etc/nginx/sites-enabled and reload Nginx, and we’re done!\n\nsudo ln -s /etc/nginx/sites-available/yourdomain.com /etc/nginx/sites-enabled/yourdomain.comsudo systemctl restart nginx\n\nTry visiting yourdomain.com and you will see the CTFd page. Play around with the rate limit and see what suits your need.\n\nFor those using Cloudflare\n\nThe default Nginx configuration will log every request in /var/log/access.log but there is a slight issue: the origin IP of each request is going to be a Cloudflare server. This way we won’t be able to trace back requests of illegitimate or malicious users to their IP, during the CTF.\n\nWe can fix this by making a small change in the http section in /etc/nginx/nginx.conf to log the real User IP instead. Replace your .conf file with this:\n\nuser www-data;\n\nworker_processes auto;\n\npid /run/nginx.pid;\n\ninclude /etc/nginx/modules-enabled/*.conf;\n\nevents {\n\nworker_connections 768;\n\n# multi_accept on;\n\n}\n\nhttp {\n\n##\n\n# Basic Settings\n\n##\n\nsendfile on;\n\ntcp_nopush on;\n\ntcp_nodelay on;\n\nkeepalive_timeout 65;\n\ntypes_hash_max_size 2048;\n\n# server_tokens off;\n\n# server_names_hash_bucket_size 64;\n\n# server_name_in_redirect off;\n\ninclude /etc/nginx/mime.types;\n\ndefault_type application/octet-stream;\n\n##\n\n# SSL Settings\n\n##\n\nssl_protocols TLSv1 TLSv1.1 TLSv1.2 TLSv1.3; # Dropping SSLv3, ref: POODLE\n\nssl_prefer_server_ciphers on;\n\n##\n\n# Logging Settings\n\n##\n\nlog_format main '$http_cf_connecting_ip - $remote_user [$time_local] '\n\n'\"$request\" $status $body_bytes_sent \"$http_referer\" '\n\n'\"$http_user_agent\"' ;\n\naccess_log /var/log/nginx/access.log main;\n\nerror_log /var/log/nginx/error.log;\n\n##\n\n# Gzip Settings\n\n##\n\ngzip on;\n\n# gzip_vary on;\n\n# gzip_proxied any;\n\n# gzip_comp_level 6;\n\n# gzip_buffers 16 8k;\n\n# gzip_http_version 1.1;\n\n# gzip_types text/plain text/css application/json application/javascript text/xml application/xml application/xml+rss text/javascript;\n\n##\n\n# Virtual Host Configs\n\n##\n\ninclude /etc/nginx/conf.d/*.conf;\n\ninclude /etc/nginx/sites-enabled/*;\n\n}\n\nExecute sudo systemctl restart nginx and now, Nginx should log the user IP instead of Cloudflare server IPs!\n\nSetting up https:// using certbot and LetsEncrypt\n\nCertbot\n\nwhich is hosted on option if you want a which you can access via wildcard cert A wildcard certificate is a…\n\ncertbot.eff.org\n\nSSL Certificates normally cost money, but we’re gonna use Let’s Encrypt, a service whose primary goal is to provide free certificates to websites on the internet.\n\nYou can refer to the amazing documentation at certbot’s official site for instructions, but here is how you can set it up on Ubuntu 20.04:\n\nsudo apt-get updatesudo apt-get install software-properties-commonsudo add-apt-repository universesudo apt-get update sudo apt-get install certbot python3-certbot-nginx\n\nOnce you have certbot installed, run\n\nsudo certbot --nginx\n\nThis will prompt you with a list of domains configured with Nginx, select the domain we set up with CTFd, and follow the series of configuration options.\n\nMake sure to choose the option of always redirect to HTTPS, as we don’t want users accessing our site over HTTP.\n\nOnce you have answered all the prompts, try going to your domain, you should see it redirect to https://. Click on the tiny lock to the left of the address and your browser should say that the connection is secure.\n\nSetting up Cloudflare\n\nCloudflare is great to have. With all its features your server load decreases gradually and the performance increases. It would also serve the cached version of your web pages when your web server goes offline for maintenance. The best part is that it has a free version that does a lot of the aforementioned things.\n\n1) Log on to http://www.cloudflare.com/ and sign up for a new account. You’ll need to fill a sign-up form.\n\n2) The next step would be to add your website by entering the URL as shown below:\n\n3) Cloudflare will then scan your existing domain records.\n\nThis process is likely to take a few seconds. Once the scan is complete, you’ll be directed to another DNS Zone file where you can verify that all records have been successfully transferred.\n\nHere, you can choose to keep particular subdomains on or off the Cloudflare network. An orange cloud represents that the specific subdomain will be cached and will be served through Cloudflare, while a gray cloud represents that the particular subdomain will bypass Cloudflare and all requests will go directly to the webserver.\n\n4) Next, you can select the plan for your Cloudflare account. Remember that the basic use of Cloudflare is free. You may choose a paid plan in case you want additional features. We just went with the free plan and it worked well for our needs.\n\n5) Lastly, Cloudflare will provide you with two DNS name servers. For example, eva.cloudflare.com. You’ll need to replace the DNS name servers on your domain name management dashboard with the ones provided by Cloudflare and wait for them to resolve.\n\nAfter the wait, you will see your domain active on the Cloudflare dashboard and it will analyze and display the traffic for you.\n\nDockerizing challenges and setting up Xinetd for hosted challenges\n\nIt's always good to containerize the challenges that will be hosted. This ensures that if a challenge works on your local computer, it will work on the server.\n\nAlso if someone were to obtain remote code execution, either by solving the challenge or with malicious intent, they would be in a containerized environment and the server would be safe\n\nWe used it for Web and Python(Crypto) challenges. I will take the example of a Python Crypto challenge.\n\nWe require the following three files:\n\nDockerfile\n\nctf.xinetd\n\nstart.sh\n\nDockerfile\n\nThe Dockerfile uses ubuntu:16.04 to host the challenge. We update and upgrade the distribution, install xinetd python3 and pip3 (pip install modules). Add a lower privileged user ‘ctf’, set its home directory as the work dir. We make important file system nodes inside the workdir, copy some useful binaries like sh, ls etc., and copy the ctf.xinetd and start.sh scripts to the container. Then we copy the actual script from bin directory on local machine to the container, give it appropriate permissions, execute start.sh script and expose a port.\n\nFROM ubuntu:16.04RUN sed -i \"s/http:\\/\\/archive.ubuntu.com/http:\\/\\/mirrors.tuna.tsinghua.edu.cn/g\" /etc/apt/sources.list && \\\n\napt-get update && apt-get -y dist-upgrade && \\\n\napt-get install -y xinetd python3 python3-pipRUN useradd -m ctf\n\nRUN pip3 install pycryptoWORKDIR /home/ctfRUN cp -R /lib* /home/ctf && \\\n\ncp -R /usr/lib* /home/ctfRUN mkdir /home/ctf/dev && \\\n\nmknod /home/ctf/dev/null c 1 3 && \\\n\nmknod /home/ctf/dev/zero c 1 5 && \\\n\nmknod /home/ctf/dev/random c 1 8 && \\\n\nmknod /home/ctf/dev/urandom c 1 9 && \\\n\nchmod 666 /home/ctf/dev/*RUN mkdir /home/ctf/bin && \\\n\ncp /bin/sh /home/ctf/bin && \\\n\ncp /bin/ls /home/ctf/bin && \\\n\ncp /bin/cat /home/ctf/binCOPY ./ctf.xinetd /etc/xinetd.d/ctf\n\nCOPY ./start.sh /start.sh\n\nRUN echo \"Blocked by ctf_xinetd\" > /etc/banner_failRUN chmod +x /start.shCOPY ./bin/ /home/ctf/\n\nRUN chown -R root:ctf /home/ctf && \\\n\nchmod -R 750 /home/ctfCMD [\"/start.sh\"]EXPOSE 9999\n\nstart.sh\n\nIt starts the xinetd service.\n\n#!/bin/sh\n\n/etc/init.d/xinetd start;\n\nsleep infinity;\n\nctf.xinetd\n\nWhen you set up a netcat server using nc -lvp 8000, it sets up a listener on port 8000. However, only 1 user can connect to this netcat server at a time. Therefore we use xinetd, which allows multiple netcat connections simultaneously, and kills the processes once the connection is closed.\n\nTo configure xinetd, we need a file called ctf.xinetd containing:\n\nservice ctf\n\n{\n\ndisable = no\n\nsocket_type = stream\n\nprotocol = tcp\n\nwait = no\n\nuser = root\n\ntype = UNLISTED\n\nport = 9999\n\nbind = 0.0.0.0\n\nserver = /usr/bin/python3\n\nserver_args = /home/ctf/encrypt.py\n\nbanner_fail = /etc/banner_fails\n\n# safety options\n\nper_source = 10 # the maximum instances of this service per source IP address\n\nrlimit_cpu = 1 # the maximum number of CPU seconds that the service may use\n\n#rlimit_as = 1024M # the Address Space resource limit for the service}\n\nWe set the sockets to stream and follow TCP. For challenges using other interpreters to run, change the server and its args.\n\nBuild the container\n\nTo build your container, execute the following command:\n\ndocker build -t <challenge-name> <path-to-challenge-directory>\n\nNote: use sudo before docker, if your user is not in the docker group.\n\nNow, once you built the container, you have to run the container. You can do this using docker run.\n\ndocker run -d -p <external-port>:<container-port> <challenge-name>:latest\n\nHere, the <external-port> represents the port on your computer (or the port to be exposed by the server) and the <container-port> represents the port exposed from inside the docker container. Using -d option for it to run in the background. Test the chall by running it on the server and visiting it with netcat : nc <server-ip> <port>.\n\nTo display all the running containers, docker ps -a\n\nTo stop and remove your container respectively, you can run the following command:\n\ndocker stop <container name>\n\ndocker rm <container name>\n\nWith this, I end the blog. Thanks a lot for reading and I hope it helped you nicely.\n\nFollow shellpwn for more interesting blogs on Cybersecurity and CTFs:\n\nshellpwn\n\nWe are putting out this publication to share our findings and blogs with the world\n\nmedium.com"
    }
}