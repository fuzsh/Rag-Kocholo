{
    "id": "dbpedia_8290_2",
    "rank": 18,
    "data": {
        "url": "http://www.linuxfocus.org/English/November2000/article175.shtml",
        "read_more_link": "",
        "language": "en",
        "title": "lf175, System Administration: xinetd",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://www.linuxfocus.org/common/images/Topbar-en.gif",
            "http://www.linuxfocus.org/common/images/Bottombar-en.gif",
            "http://www.linuxfocus.org/common/images/2doc.gif",
            "http://www.linuxfocus.org/common/images/Frederic_Raynal.png",
            "http://www.linuxfocus.org/common/images/illustration175.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "This document is available in: English Castellano Deutsch Francais Nederlands Turkce\n\nConvert to GutenPalm\n\nor to PalmDoc\n\nby Frédéric Raynal\n\nAbout the author:\n\nFrédéric Raynal is preparing a thesis about watermarking of digital images at the INRIA (Institut National de Recherche en Informatique et Automatique).\n\nContent:\n\nWhat's that, xinetd ?\n\nCompilation & Installation\n\nConfiguration\n\nAccess Control\n\nService defaults\n\nConfiguring a service\n\nPort binding: the bind attribute\n\nService redirection towards an other machine: the redirect attribute\n\nSpecial services\n\nLet's play a bit...\n\nStarting with a riddle\n\nchroot a service\n\nConclusion\n\npop3 server\n\nBad configuration with RH7.0, Mandrake 7.2 and maybe some others ...\n\nTalkback form for this article\n\nxinetd\n\nAbstract:\n\nxinetd - eXtended InterNET services daemon - provides a good security against intrusion and reduces the risks of Denial of Services (DoS) attacks. Like the well known couple (inetd+tcpd), it enables the configuration of the access rights for a given machine, but it can do much more. In this article we will discover its many features.\n\nWhat's that, xinetd ?\n\nThe classical inetd helps controlling network connections to a computer. When a request comes to a port managed by inetd, then inetd forwards it to a program called tcpd. Tcpd decides, in accordance with the rules contained in the hosts.{allow, deny} files whether or not to grant the request. If the request is allowed, then the the corresponding server process (e.g ftp) can be started. This mechanism is also referred to as tcp_wrapper.\n\nxinetd provides access control capabilities similar to the ones provided by tcp_wrapper. However, its capabilities extend much further :\n\naccess control for TCP, UDP and RPC services (the latter ones aren't well supported yet).\n\naccess control based on time segments\n\nfull logging, either for connection success or failure\n\nefficient containment against Denial of Services (DoS) attacks (attacks which attempt to freeze a machine by saturating its resources) :\n\nlimitation on the number of servers of the same type to run at a time\n\nlimitation on the total number of servers\n\nlimitation on the size of the log files.\n\nbinding of a service to a specific interface: this allows you, for instance, to make services available to your private network but not to the outside world.\n\ncan be used as a proxy to other systems. Quite useful in combination with ip_masquerading (or Network Address Translation - NAT) in order to reach the internal network.\n\nThe main drawback, as already mentioned, concerns poorly supported RPC calls. However, portmap can coexist with xinetd to solve this.\n\nThe first part of this article explains how xinetd works. We'll spend some time on a service configuration, on some specific options (binding to an interface, redirection) and demonstrate this with a few examples. The second part shows xinetd at work, the logs it generates and finishes with a useful tip.\n\nCompilation & Installation\n\nYou can get xinetd from www.xinetd.org. For this article we will use version 2.1.8.9pre10.\n\nCompilation and installation are done in the classical way: the usual commands ./configure; make; make install do it all :) configure supports the usual options. Three specific options are available at compile time:\n\n--with-libwrap : with this option, xinetd checks the tcpd configuration files (/etc/hosts.{allow, deny}) and if access is accepted, it then uses its own control routines. For this option to work, tcp_wrapper and its libraries have to be installed on the machine (Author's note: what can be done with the wrapper can also be done with xinetd. Allowing this compatibility leads to multiplying the config files, and makes the administration heavier... in short, I don't recommend it);\n\n--with-loadavg : this option allows xinetd to handle the max_load configuration option. This allows the deactivation of some services when the machine is overloaded. An options essential to prevent some DoS attacks (check the attribute max_load in table 1);\n\n--with-inet6 : if you feel like using IPv6, this option allows to support it. The IPv4 and IPv6 connections are managed, but IPv4 addresses are changed into IPv6 format.\n\nBefore starting xinetd, you don't have to stop inetd. Nevertheless, not doing so may lead to an unpredictable behavior of both daemons!\n\nSome signals can be used to modify xinetd behavior:\n\nSIGUSR1 : software re-configuration : the configuration file is re-read and the services parameters are changed accordingly\n\nSIGUSR2 : hardware re-configuration: as above, but furthermore, the outdated daemons are killed\n\nSIGTERM : ends xinetd and the daemons it generated\n\nThere are a few others (let's mention a mistake in the documentation and the man pages: SIGHUP writes its dump in the file /var/run/xinetd.dump and not in /tmp/xinetd.dump), but the three mentioned above can be easily managed with a small script containing the start, stop, restart, soft, hard options (the latter two respectively corresponding to SIGUSR1 and SIGUSR2).\n\nConfiguration\n\nThe /etc/xinetd.conf file is the default configuration file for the xinetd daemon (a command line option allows to provide another one). The xinetd configuration is not very complex, but it may be a long work and the syntax is unfortunately quite different from that of its predecessor inetd.\n\nTwo utilities (itox and xconv.pl) are provided with xinetd and allow to convert the /etc/inetd.conf file into a configuration file for xinetd. Obviously, that's not enough since the rules specified in the wrapper configuration are ignored. The itox program, still maintained, is no longer developed. The xconv.pl program is a better solution, even if the result has to be modified because of features that xinetd has in addition to inetd:\n\n>>/usr/local/sbin/xconv.pl < /etc/inetd.conf > /etc/xinetd.conf\n\nThe configuration file begins with a default section. The attributes in this section will be used by every service xinetd manages. After that, you will find as many sections as there are services, each of them being able to re-define specific options in relation to the default ones.\n\nThe default values section looks like:\n\ndefaults\n\n{\n\nattribute operator value(s)\n\n...\n\n}\n\nEach attribute defined in this section keeps the provided value(s) for all services described thereafter. Thus, the only_from attribute, allows to give a list of authorized addresses that should be able to connect to servers:\n\nonly_from = 192.168.1.0/24 192.168.5.0/24 192.168.10.17\n\nEvery service declared thereafter will allow access from machines having an address contained in the list. However, these default values can be modified for each service (check the operators, explained a bit further down). Nevertheless, this process is a bit risky. As a matter of fact, to keep things simple and secure, it's much better not to define default values and change them later on within a service. For instance, talking about access rights, the simplest policy consists in denying access to everyone and next allowing access to each service to those who really need it (with tcp_wrapper, this is done from an hosts.deny file containing ALL:ALL@ALL, and an hosts.allow file only providing authorized services and addresses).\n\nEach section describing a service in the config file looks like:\n\nserviceservice_name\n\n{\n\nattribute operator value(s)\n\n...\n\n}\n\nThree operators are available: '=', '+=' and '-='. Most of the attributes only support the '=' operator, used to assign a fix value to an attribute. The '+=' operator adds an item to a list of values, while the '-=' operator removes this item.\n\nThe table 1 briefly describes some of these attributes. We'll see how to use them with a few examples. Reading the xinetd.conf man page provides more information.\n\nAttribute Values and description flags Only the most current values are mentioned here, check the documentation to find new ones:\n\nIDONLY : only accepts connexions from clients having an identification server;\n\nNORETRY : avoids a new process to be forked again in case of failure;\n\nNAMEINARGS : the first argument of the server_args attribute is used as argv[0] for the server. This allows to use tcpd by putting it in the server attribute, next writing the server name and its arguments such as server_args, as you would do with inetd.\n\nlog_type xinetd uses syslogd and the daemon.info selector by default.\n\nSYSLOG selector [level] : allows to choose among daemon, auth, user or local0-7 from syslogd ;\n\nFILE [max_size [absolute_max_size]] : the specified file receives information. The two options set the file size limit. When the size is reached, the first one sends a message to syslogd, the second one stops the logging for this service (if it's a common file - or fixed by default - then various services can be concerned).\n\nlog_on_success Different information can be logged when a server starts:\n\nPID : the server's PID (if it's an internal xinetd service, the PID has then a value of 0) ;\n\nHOST : the client address ;\n\nUSERID : the identity of the remote user, according to RFC1413 defining identification protocol;\n\nEXIT : the process exit status;\n\nDURATION : the session duration.\n\nlog_on_failure Here again, xinetd can log a lot of information when a server can't start, either by lack of resources or because of access rules:\n\nHOST, USERID : like above mentioned ;\n\nATTEMPT : logs an access attempt. This an automatic option as soon as another value is provided;\n\nRECORD : logs every information available on the client.\n\nnice Changes the server priority like the nice command does. no_access List of clients not having access to this service. only_from List of authorized clients. If this attribute has no value, the access to the service is denied. port The port associated to the service. If it's also defined in the /etc/services file, the 2 port numbers must match. protocol The specified protocol must exist in the /etc/protocols file. If no protocol is given, the service's default one is used instead. server The path to the server. server_args Arguments to be given to the server. socket_type stream (TCP), dgram (UDP), raw (IP direct access) or seqpacket (). type xinetd can manage 3 types of services :\n\nRPC : for those defined in the /etc/rpc file... but doesn't work very well;\n\nINTERNAL : for services directly managed by xinetd (echo, time, daytime, chargen and discard) ;\n\nUNLISTED : for services not defined either in the /etc/rpc file, or in the /etc/services file ;\n\nLet's note it's possible to combine various values, as we'll see with servers, services and xadmin internal services. wait Defines the service behavior towards threads. Two values are acceptable:\n\nyes : the service is mono-thread, only one connexion of this type can be managed by the service;\n\nno : a new server is started by xinetd for each new service request according to the defined maximum limit (Warning, by default this limit is infinite).\n\ncps Limits the number of incoming connexions. The first argument is this number itself. When the threshold is exceeded, the service is deactivated for a given time, expressed in seconds, provided with the second argument. instances Defines the maximum number of servers of a same type able to work at the same time. max_load This gives really the maximum load for a server (for example, 2 or 2.5). Beyond this limit, requests on this server are rejected. per_source Either an integer, or UNLIMITED, to restrict the number of connexion from a same origin to a server Tab. 1 : a few attributes for xinetd\n\nThe four last attributes shown in table1 allow to control the resources depending on a server. This is efficient to protect from Denial of Service (DoS) attacks (freezing a machine by using all of its resources)\n\nThis section presented a few xinetd features. The next sections show how to use it and give some rules to make it work properly.\n\nAccess Control\n\nAs we have seen previously, you can grant (or forbid) access to your box by using IP addresses. However, xinetd allows more features :\n\nyou can do access control by hostname resolution. When doing this, xinetd does a lookup on the hostname(s) specified _for every connection_, and compares the connecting address to the addresses returned for the hostname(s) ;\n\nyou can do access control by .domain.com. When a client connects, xinetd will reverse lookup the connecting address, and see if it is in the specified domain.\n\nTo optimize things, obviously IP addresses are obviously better, that way you avoid name lookup(s) on incoming connections to that service. If you must do access control by the hostname, you can significantly speed things up if you run a local (at least a caching) name server. It's even better if you are using domain sockets to perform your address lookup (don't put a nameserver entry in /etc/resolv.conf).\n\nService defaults\n\nThe defaults section allows setting values for an number of attributes (check the documentation for the whole list). Some of these attributes (only_from, no_access, log_on_success, log_on_failure, ...) hold simultaneously the values allocated in this section and the ones provided in the services.\n\nBy default, denying access to a machine, is the first step of a reliable security policy. Next, allowing access will be configured on a per-service basis. We've seen two attributes allowing to control access to a machine, based on IP addresses: only_from and no_access. Selecting the second one we write:\n\nno_access = 0.0.0.0/0\n\nwhich fully blocks services access. However, if you wish to allow everyone to access echo (ping) for instance, you then should write in the echo service:\n\nonly_from = 0.0.0.0/0\n\nHere is the logging message you get with this configuration:\n\nSep 17 15:11:12 charly xinetd[26686]: Service=echo-stream: only_from list and no_access list match equally the address 192.168.1.1\n\nSpecifically, the access control is done comparing the lists of addresses contained in both attributes. When the client address matches the both lists, the least general one is preferred. In case of equality, like in our example, xinetd is unable to choose and refuses the connexion. To get rid of this ambiguity, you should have written:\n\nonly_from = 192.0.0.0/8\n\nAn easier solution is to only control the access with the attribute:\n\nonly_from =\n\nNot giving a value makes every connexion fail :) Then, every service allows access by means of this same attribute.\n\nImportant, not to say essential: in case of no access rules at all (i.e. neither only_from, nor no_access) for a given service (allocated either directly or with the default) section, the access to the service is allowed!\n\nHere is an example of defaults :\n\ndefaults\n\n{\n\ninstances = 15\n\nlog_type = FILE /var/log/servicelog\n\nlog_on_success = HOST PID USERID DURATION EXIT\n\nlog_on_failure = HOST USERID RECORD\n\nonly_from =\n\nper_source = 5\n\ndisabled = shell login exec comsat\n\ndisabled = telnet ftp\n\ndisabled = name uucp tftp\n\ndisabled = finger systat netstat\n\n#INTERNAL\n\ndisabled = time daytime chargen servers services xadmin\n\n#RPC\n\ndisabled = rstatd rquotad rusersd sprayd walld\n\n}\n\namong internal services, servers, services, and xadmin allow to manage xinetd. More on this later.\n\nConfiguring a service\n\nTo configure a service, we need ...nothing :) In fact, everything works like it does with defaults values: you just have to precise the attributes and their value(s) to manage the service. This implies either a change in the defaults values or another attribute for this service.\n\nSome attributes must be present according to the type of service (INTERNAL, UNLISTED ou RPC) :\n\nAttribute Comment socket-type Every service. user Only for non INTERNAL services server Only for non INTERNAL services wait Every service. protocol Every RPC service and the ones not contained in /etc/services. rpc_version Every RPC service. rpc_number Every RPC service, not contained in /etc/rpc. port Every non RPC service, not contained in /etc/services. Tab. 2: required attributes\n\nThis example shows how to define services:\n\nservice ntalk\n\n{\n\nsocket_type = dgram\n\nwait = yes\n\nuser = nobody\n\nserver = /usr/sbin/in.ntalkd\n\nonly_from = 192.168.1.0/24\n\n}\n\nservice ftp\n\n{\n\nsocket_type = stream\n\nwait = no\n\nuser = root\n\nserver = /usr/sbin/in.ftpd\n\nserver_args = -l\n\ninstances = 4\n\naccess_times = 7:00-12:30 13:30-21:00\n\nnice = 10\n\nonly_from = 192.168.1.0/24\n\n}\n\nLet's note that these services are only allowed on the local network (192.168.1.0/24). Concerning FTP, some more restrictions are expected: only four instances are allowed and the service will be available only during certain segments of time.\n\nPort binding: the bind attribute\n\nThis attribute allows the binding of a service to a specific IP address. This is only useful when a machine has at least two network interfaces, for example a computer beeing part of a local network and connected to Internet through a separate interface.\n\nFor instance, a company wishes to install an FTP server for its employees (to access and read internal documentation). This company wants to provide its clients with an FTP access towards its products: bind has been made for this company :) The solution is to define two separate FTP services, one for public access, and a second one for internal company access only. However, xinetd must be able to differentiate them: the solution is to use the id attribute. It defines a service in a unique way (when not defined within a service, its value defaults to the name of the service).\n\nservice ftp\n\n{\n\nid = ftp-public\n\nwait = no\n\nuser = root\n\nserver = /usr/sbin/in.ftpd\n\nserver_args = -l\n\ninstances = 4\n\nnice = 10\n\nonly_from = 0.0.0.0/0 #allows every client\n\nbind = 212.198.253.142 #public IP address for this server\n\n}\n\nservice ftp\n\n{\n\nid = ftp-internal\n\nsocket_type = stream\n\nwait = no\n\nuser = root\n\nserver = /usr/sbin/in.ftpd\n\nserver_args = -l\n\nonly_from = 192.168.1.0/24 #only for internal use\n\nbind = 192.168.1.1 #local IP address for this server (charly)\n\n}\n\nThe use of bind will allow to call the corresponding daemon, according to the destination of the packets. Thus, with this configuration, a client on the local network must give the local address (or the associated name) to access internal data. In the log file, you can read:\n\n00/9/17@16:47:46: START: ftp-public pid=26861 from=212.198.253.142\n\n00/9/17@16:47:46: EXIT: ftp-public status=0 pid=26861 duration=30(sec)\n\n00/9/17@16:48:19: START: ftp-internal pid=26864 from=192.168.1.1\n\n00/9/17@16:48:19: EXIT: ftp-internal status=0 pid=26864 duration=15(sec)\n\nThe first part comes from the command ftp 212.198.253.142, while the second part is about the command from charly to itself: ftp 192.168.1.1.\n\nObviously, there's a problem: what happens if a machine doesn't have two static IP addresses? This can happen with ppp connections or when using the dhcp protocol. It seems it would be much better to bind services to interfaces than to addresses. However, this is not yet supported in xinetd and is a real problem (for instance, writing a C module to access an interface or address depends on the OS, and since xinetd is supported on many OSes...). Using a script solves the problem:\n\n#!/bin/sh\n\nPUBLIC_ADDRESS=`/sbin/ifconfig $1 | grep \"inet addr\" | awk '{print $2}'| awk -F: '{print $2}'`\n\nsed s/PUBLIC_ADDRESS/\"$PUBLIC_ADDRESS\"/g /etc/xinetd.base > /etc/xinetd.conf\n\nThis script takes the /etc/xinetd.base file, containing the desired configuration with PUBLIC_ADDRESS as a replacement for the dynamic address, and changes it in /etc/xinetd.conf, modifying the PUBLIC_ADDRESS string with the address associated to the interface passed as an argument to the script. Next, the call to this script depends on the type of connection: the simplest is to add the call into the right ifup-* file and to restart xinetd.\n\nService redirection towards an other machine: the redirect attribute\n\nxinetd can be used as a transparent proxy, sort of (well, almost ... as we'll see it later) with the redirect attribute. It allows to send a service request towards an other machine to the desired port.\n\nservice telnet\n\n{\n\nflags = REUSE\n\nsocket_type = stream\n\nwait = no\n\nuser = root\n\nserver = /usr/sbin/in.telnetd\n\nonly_from = 192.168.1.0/24\n\nredirect = 192.168.1.15 23\n\n}\n\nLet's watch what's going on now:\n\n>>telnet charly\n\nTrying 192.168.1.1...\n\nConnected to charly.\n\nEscape character is '^]'.\n\nDigital UNIX (sabrina) (ttyp1)\n\nlogin:\n\nAt first, the connection seems to be established on charly, but the following shows that sabrina (an alpha machine, hence \"Digital UNIX\") took over. This mecanism can be both useful and dangerous. When setting it up, logging must be done on both ends of the connection. Furthermore, for this type of service, the use of DMZ and firewall is strongly recommended;-)\n\nSpecial services\n\nThree services only belong to xinetd. Since these services can't be found in /etc/rpc or /etc/services, they must have the UNLISTED flag ( besides the INTERNAL flag informing they are xinetd services)\n\nservers: informs about servers in use ;\n\nservices: informs about available services, their protocol and their port ;\n\nxadmin: mixes the functions of the two previous ones.\n\nObviously, these services make your computer more vulnerable. since they provide important information. Presently, their access is not protected (password protected, for instance). You should use them only at configuration time. Next, in the defaults section, you must deny their use:\n\ndefaults {\n\n...\n\ndisabled = servers services xadmin\n\n...\n\n}\n\nBefore activating them, you should take some precautions:\n\nThe machine running xinetd must be the only one able to connect to these services\n\nLimit the number of instances to one\n\nAllow access only from the machine running the server.\n\nLet's take the example of the xadmin service (the two others can be configured in the same way, apart from the port number ;-) :\n\nservice xadmin\n\n{\n\ntype = INTERNAL UNLISTED\n\nport = 9100\n\nprotocol = tcp\n\nsocket_type = stream\n\nwait = no\n\ninstances = 1\n\nonly_from = 192.168.1.1 #charly\n\n}\n\nThe xadmin service has 5 commands :\n\nhelp ...\n\nshow run : like the servers service, informs about the presently running servers\n\nshow avail : like the services service, informs about the available services (and a bit more)\n\nbye or exit ...\n\nNow, you know they exist: forget them ;-) You can test without these services. Commands such as (netstat, fuser, lsof, ... allow you to know what's going on on your machine, without making it vulnerable as you would when using these services!\n\nLet's play a bit...\n\nStarting with a riddle\n\nHere is a small exercise for the ones who survived ;-) First I will explain configuration used in this exercise and then we will try to find out what happens and why it does not work.\n\nWe only need the finger service :\n\nservice finger\n\n{\n\nflags = REUSE NAMEINARGS\n\nserver = /usr/sbin/tcpd\n\nserver_args = in.fingerd\n\nsocket_type = stream\n\nwait = no\n\nuser = nobody\n\nonly_from = 192.168.1.1 #charly\n\n}\n\nxinetd wasn't compiled with the --with-libwrap option (check the attribute server). The defaults section is of the same kind of the one previously provided: every access to charly is denied wherever the connexion comes from. The finger service is not deactivated, nevertheless:\n\npappy@charly >> finger pappy@charly\n\n[charly]\n\npappy@charly >>\n\npappy@bosley >> finger pappy@charly\n\n[charly]\n\npappy@bosley >>\n\nIt seems the request didn't work properly, neither from charly (192.168.1.1), an authorized machine, nor from bosley (192.168.1.10). Let's have a look at the log files:\n\n/var/log/servicelog :\n\n00/9/18@17:15:42: START: finger pid=28857 from=192.168.1.1\n\n00/9/18@17:15:47: EXIT: finger status=0 pid=28857 duration=5(sec)\n\n00/9/18@17:15:55: FAIL: finger address from=192.168.1.10\n\nThe request from charly (the two first lines) works properly according to xinetd: the access is allowed and the request takes 5 seconds. On the other hand, the request from bosley is rejected (FAIL).\n\nIf we look at the configuration of the finger service, the server used is not really in.fingerd, but the tcp_wrapper tcpd service. The wrapper log says:\n\n/var/log/services :\n\nSep 18 17:15:42 charly in.fingerd[28857]: refused connect from 192.168.1.1\n\nWe see that there's only one line matching our two queries! The one from bosley (the second one) was intercepted by xinetd, so it's quite normal not to find it in that log. The selected line really corresponds to the request xinetd allowed, sent from charly to charly (the first one): time and PID are identical.\n\nLet's summarize what we have:\n\nxinetd allowed the request;\n\nthe finger request goes through tcpd ;\n\nin.fingerd rejected this request.\n\nWhat's going on, then? Since the request is accepted by xinetd, it's sent to the specified server (here tcpd). Nevertheless, tcpd rejects this connection. Then, we must have a look at hosts.{allow,deny}. The /etc/hosts.deny file only contains ALL:ALL@ALL, what explains why the request has been rejected by the wrapper!\n\nAccording to the way the server and server_args service lines have been defined, the wrapper features are still accessible (banner - there's a banner attribute in xinetd-, spawn, twist, ...). Remember that the --with-libwrap compilation option only adds access rights control (with the help of hosts.{allow,deny} files), before xinetd process starts. In this example we saw that this configuration allows us to continue using the tcp wrapper features.\n\nThis overlapping of features, if it can work, may as well lead to stange behaviors. To use xinetd together with inetd and portmap, it's much better to manage a service with only one of these \"super-daemons\".\n\nchroot a service\n\nIt's often suggested to restrict the fields of some services, or to create a new environment. The chroot command allows to change the root directory for a command (or a script):\n\nchroot [options] new_root\n\nThis is often used to protect services such as bind/DNS or ftp. To duplicate this behavior while benefiting from xinetd features, you have to declare chroot as a server. Then, you just have to pass other arguments via the server_args attribute :)\n\nservice ftp\n\n{\n\nid = ftp\n\nsocket_type = stream\n\nwait = no\n\nuser = root\n\nserver = /usr/sbin/chroot\n\nserver_args = /var/servers/ftp /usr/sbin/in.ftpd -l\n\n}\n\nThus, when a request is sent to this service, the first instruction used is chroot. Next, the first argument passed to it is the first one on the server_args line, that is the new root. Last, the server is started.\n\nConclusion\n\nYou could now ask yourself which daemon to choose from xinetd or inetd. xinetd offers more features , but it requires a bit more administration, especially until it is included by default in the into distributions (it is now true for most of them). The most secure solution is to use xinetd on machines with public access (like Internet) since it offers a better defense. For machines within a local network inetd should be enough.\n\npop3 server\n\npop3 seems to be very popular : I recieved mails asking me how to handle it throught xinetd. Here is a sample configuration :\n\nservice pop3 { disable = no socket_type = stream wait = no user = root server = /usr/sbin/ipop3d # log_on_success += USERID # log_on_failure += USERID }\n\nOf course, you have to put your own path for the server attribute.\n\nthe use of pop3 throught xinetd could be painful, depending on the values you use for logging. For instance the use of USERID send a request from your xinetd to an identd server hosted at the pop's client. If no such server is available, a timeout is waited for 30 seconds.\n\nSo, when somebody tries to get his mail, he have to wait at least for those 30 seconds if no identd server responds. You have to choose between :\n\ninstall an identd server on all the clients so your logs are very sharp (take care, one can change the informations provided by identd) ;\n\ndecrease the quality of your logging for that service so that your users could get their mails quickly.\n\nBad configuration with RH7.0, Mandrake 7.2 and maybe some others ...\n\nbug 24279 send to bugzilla.\n\nSome services configured in /etc/xinetd.d are not defined in the file /etc/services.\n\n[pappy@rootdurum xinetd.d]# grep service *udp chargen-udp:service chargen-udp daytime-udp:service daytime-udp echo-udp:service echo-udp time-udp:service time\n\nI've sublitted a fix ... but the RH's guy doesn't like it ;-( He says it can cause troubles with some other tools such as chkconfig and ntsysv. If I had to choice between those tools and xinetd, I already know what I pick ;-)\n\nLast modified: Wed Feb 28 10:15:27 CET 2001\n\nTalkback form for this article\n\nEvery article has its own talkback page. On this page you can submit a comment or look at comments from other readers:\n\ntalkback page\n\nWebpages maintained by the LinuxFocus Editor team\n\n© Frédéric Raynal, FDL\n\nLinuxFocus.org\n\nClick here to report a fault or send a comment to LinuxFocus\n\nTranslation information:\n\nfr -> -- Frédéric Raynal fr -> en Georges Tarbouriech"
    }
}