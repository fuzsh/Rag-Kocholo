{
    "id": "dbpedia_6509_3",
    "rank": 40,
    "data": {
        "url": "https://docs.djangoproject.com/en/5.0/topics/i18n/timezones/",
        "read_more_link": "",
        "language": "en",
        "title": "Time zones | Django documentation",
        "top_image": "https://static.djangoproject.com/img/logos/django-logo-negative.1d528e2cb5fb.png",
        "meta_img": "https://static.djangoproject.com/img/logos/django-logo-negative.1d528e2cb5fb.png",
        "images": [
            "https://static.djangoproject.com/img/fundraising-heart.cd6bb84ffd33.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Python",
            "Django",
            "framework",
            "open-source"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The web framework for perfectionists with deadlines.",
        "meta_lang": "en",
        "meta_favicon": "https://static.djangoproject.com/img/icon-touch.e4872c4da341.png",
        "meta_site_name": "Django Project",
        "canonical_link": "https://docs.djangoproject.com/en/5.1/topics/i18n/timezones/",
        "text": "Overview¶\n\nWhen support for time zones is enabled, Django stores datetime information in UTC in the database, uses time-zone-aware datetime objects internally, and translates them to the end user’s time zone in templates and forms.\n\nThis is handy if your users live in more than one time zone and you want to display datetime information according to each user’s wall clock.\n\nEven if your website is available in only one time zone, it’s still good practice to store data in UTC in your database. The main reason is daylight saving time (DST). Many countries have a system of DST, where clocks are moved forward in spring and backward in autumn. If you’re working in local time, you’re likely to encounter errors twice a year, when the transitions happen. This probably doesn’t matter for your blog, but it’s a problem if you over bill or under bill your customers by one hour, twice a year, every year. The solution to this problem is to use UTC in the code and use local time only when interacting with end users.\n\nTime zone support is enabled by default. To disable it, set USE_TZ = False in your settings file.\n\nChanged in Django 5.0:\n\nIn older version, time zone support was disabled by default.\n\nTime zone support uses zoneinfo, which is part of the Python standard library from Python 3.9.\n\nIf you’re wrestling with a particular problem, start with the time zone FAQ.\n\nConcepts¶\n\nDefault time zone and current time zone¶\n\nThe default time zone is the time zone defined by the TIME_ZONE setting.\n\nThe current time zone is the time zone that’s used for rendering.\n\nYou should set the current time zone to the end user’s actual time zone with activate(). Otherwise, the default time zone is used.\n\nNote\n\nAs explained in the documentation of TIME_ZONE, Django sets environment variables so that its process runs in the default time zone. This happens regardless of the value of USE_TZ and of the current time zone.\n\nWhen USE_TZ is True, this is useful to preserve backwards-compatibility with applications that still rely on local time. However, as explained above, this isn’t entirely reliable, and you should always work with aware datetimes in UTC in your own code. For instance, use fromtimestamp() and set the tz parameter to utc.\n\nSelecting the current time zone¶\n\nThe current time zone is the equivalent of the current locale for translations. However, there’s no equivalent of the Accept-Language HTTP header that Django could use to determine the user’s time zone automatically. Instead, Django provides time zone selection functions. Use them to build the time zone selection logic that makes sense for you.\n\nMost websites that care about time zones ask users in which time zone they live and store this information in the user’s profile. For anonymous users, they use the time zone of their primary audience or UTC. zoneinfo.available_timezones() provides a set of available timezones that you can use to build a map from likely locations to time zones.\n\nHere’s an example that stores the current timezone in the session. (It skips error handling entirely for the sake of simplicity.)\n\nAdd the following middleware to MIDDLEWARE:\n\nimport zoneinfo from django.utils import timezone class TimezoneMiddleware: def __init__(self, get_response): self.get_response = get_response def __call__(self, request): tzname = request.session.get(\"django_timezone\") if tzname: timezone.activate(zoneinfo.ZoneInfo(tzname)) else: timezone.deactivate() return self.get_response(request)\n\nCreate a view that can set the current timezone:\n\nfrom django.shortcuts import redirect, render # Prepare a map of common locations to timezone choices you wish to offer. common_timezones = { \"London\": \"Europe/London\", \"Paris\": \"Europe/Paris\", \"New York\": \"America/New_York\", } def set_timezone(request): if request.method == \"POST\": request.session[\"django_timezone\"] = request.POST[\"timezone\"] return redirect(\"/\") else: return render(request, \"template.html\", {\"timezones\": common_timezones})\n\nInclude a form in template.html that will POST to this view:\n\n{% load tz %} {% get_current_timezone as TIME_ZONE %} <form action=\"{% url 'set_timezone' %}\" method=\"POST\"> {% csrf_token %} <label for=\"timezone\">Time zone:</label> <select name=\"timezone\"> {% for city, tz in timezones %} <option value=\"{{ tz }}\"{% if tz == TIME_ZONE %} selected{% endif %}>{{ city }}</option> {% endfor %} </select> <input type=\"submit\" value=\"Set\"> </form>\n\nMigration guide¶\n\nHere’s how to migrate a project that was started before Django supported time zones.\n\nDatabase¶\n\nPostgreSQL¶\n\nThe PostgreSQL backend stores datetimes as timestamp with time zone. In practice, this means it converts datetimes from the connection’s time zone to UTC on storage, and from UTC to the connection’s time zone on retrieval.\n\nAs a consequence, if you’re using PostgreSQL, you can switch between USE_TZ = False and USE_TZ = True freely. The database connection’s time zone will be set to DATABASE-TIME_ZONE or UTC respectively, so that Django obtains correct datetimes in all cases. You don’t need to perform any data conversions.\n\nTime zone settings\n\nThe time zone configured for the connection in the DATABASES setting is distinct from the general TIME_ZONE setting.\n\nOther databases¶\n\nOther backends store datetimes without time zone information. If you switch from USE_TZ = False to USE_TZ = True, you must convert your data from local time to UTC – which isn’t deterministic if your local time has DST.\n\nCode¶\n\nThe first step is to add USE_TZ = True to your settings file. At this point, things should mostly work. If you create naive datetime objects in your code, Django makes them aware when necessary.\n\nHowever, these conversions may fail around DST transitions, which means you aren’t getting the full benefits of time zone support yet. Also, you’re likely to run into a few problems because it’s impossible to compare a naive datetime with an aware datetime. Since Django now gives you aware datetimes, you’ll get exceptions wherever you compare a datetime that comes from a model or a form with a naive datetime that you’ve created in your code.\n\nSo the second step is to refactor your code wherever you instantiate datetime objects to make them aware. This can be done incrementally. django.utils.timezone defines some handy helpers for compatibility code: now(), is_aware(), is_naive(), make_aware(), and make_naive().\n\nFinally, in order to help you locate code that needs upgrading, Django raises a warning when you attempt to save a naive datetime to the database:\n\nRuntimeWarning: DateTimeField ModelName.field_name received a naive datetime (2012-01-01 00:00:00) while time zone support is active.\n\nDuring development, you can turn such warnings into exceptions and get a traceback by adding the following to your settings file:\n\nimport warnings warnings.filterwarnings( \"error\", r\"DateTimeField .* received a naive datetime\", RuntimeWarning, r\"django\\.db\\.models\\.fields\", )\n\nFixtures¶\n\nWhen serializing an aware datetime, the UTC offset is included, like this:\n\n\"2011-09-01T13:20:30+03:00\"\n\nWhile for a naive datetime, it isn’t:\n\n\"2011-09-01T13:20:30\"\n\nFor models with DateTimeFields, this difference makes it impossible to write a fixture that works both with and without time zone support.\n\nFixtures generated with USE_TZ = False, or before Django 1.4, use the “naive” format. If your project contains such fixtures, after you enable time zone support, you’ll see RuntimeWarnings when you load them. To get rid of the warnings, you must convert your fixtures to the “aware” format.\n\nYou can regenerate fixtures with loaddata then dumpdata. Or, if they’re small enough, you can edit them to add the UTC offset that matches your TIME_ZONE to each serialized datetime."
    }
}