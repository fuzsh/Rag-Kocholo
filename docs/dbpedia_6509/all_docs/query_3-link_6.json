{
    "id": "dbpedia_6509_3",
    "rank": 6,
    "data": {
        "url": "https://stackoverflow.com/questions/50653641/convert-utc-to-local-time-in-iran",
        "read_more_link": "",
        "language": "en",
        "title": "convert utc to local time in iran",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://cdn.sstatic.net/Img/teams/teams-promo.svg?v=e507948b81bf",
            "https://i.sstatic.net/K0UqR.jpg?s=64",
            "https://i.sstatic.net/ZWEI3.jpg?s=64",
            "https://i.sstatic.net/gizwO.jpg?s=64",
            "https://i.sstatic.net/2vkY8.jpg?s=64",
            "https://i.sstatic.net/VvqJV.png?s=64",
            "https://stackoverflow.com/posts/50653641/ivc/fd19?prg=99aff13b-d439-46a0-a65d-6d196d0d9cf8"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2018-06-02T04:57:06",
        "summary": "",
        "meta_description": "I try convert UTC time to local time , minute work well but hour always have 1hour later, for example if UTC time is 04:55 , my phone clock is 9:25 but my code generate 8:25\n   String dateStr = &qu...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/50653641/convert-utc-to-local-time-in-iran",
        "text": "No DST in Iran in 1970\n\nThe time zone for Iran, Asia/Tehran, observes Daylight Saving Time (DST) in the summer of 2018 but did not do so back in 1970.\n\nIn summer of 2018, Iran is four and a half hours ahead of UTC rather than three and a half. So adjusting from 4:55 in UTC should result in 9:25 on a summer day, not 8:25.\n\nSystem.out.println( OffsetDateTime.of( LocalDate.of( 2018 , Month.JUNE , 1 ) , LocalTime.parse( \"04:55\" ) , ZoneOffset.UTC ) .atZoneSameInstant( ZoneId.of( \"Asia/Tehran\" ) ) );\n\n2018-06-01T09:25+04:30[Asia/Tehran]\n\nBut I suspect your code is defaulting to the epoch reference date of first moment of 1970 in UTC when parsing your string, 1970-01-01T00:00:00Z, because you are abusing that class in trying to parse a time-of-day without specifying a date.\n\nIn 1970, Iran did not observe Daylight Saving Time (DST). So the offset was three and a half hours ahead of UTC in summer of 1970 versus four and a half hours ahead of UTC in summer of 2018.\n\nSystem.out.println( OffsetDateTime.of( LocalDate.EPOCH , LocalTime.parse( \"04:55\" ) , ZoneOffset.UTC ) .atZoneSameInstant( ZoneId.of( \"Asia/Tehran\" ) ) );\n\n1970-01-01T08:25+03:30[Asia/Tehran]\n\nWrong classes\n\nYou are using the wrong classes.\n\nYou want to represent a time-of-day value. So you should be using a time-of-day class. But you are using a date-with-time-of-day class, java.util.Date.\n\nYou are using troublesome badly-designed date-time classes, java.util.Date & java.text.SimpleDateFormat. These were supplanted years ago by the java.time classes. Avoid the legacy classes entirely. Use only the classes found in the java.time package.\n\nTime-of-day\n\nParse a time-of-day string.\n\nLocalTime.parse( \"04:55\" )\n\nGet the current time-of-day.\n\nLocalTime.now() // Capture the current time of day per the JVM’s current default time zone.\n\nBetter to make explicit your intention to use the JVM’s current default time zone.\n\nLocalTime.now( ZoneId.systemDefault() // Capture the current time of day by explicitly asking for the JVM’s current default time zone. )\n\nOr specify a particular time zone.\n\nLocalTime.now( ZoneId.of( \"Asia/Kabul\" ) // Capture the current time-of-day as seen in the wall-clock time used by the people of a particular region (a time zone). )\n\n9:25\n\nGet the current time-of-day in UTC.\n\nLocalTime.now( ZoneOffset.UTC )\n\n04:55\n\nLocalTime\n\nIf you have an input string such as \"04:55\", parse as a LocalTime object. This class represents a time-of-day without a date and without a time zone.\n\nString input = \"04:55\" ; LocalTime lt = LocalTime.parse( input ) ;\n\nTerminology\n\nI try convert UTC time to local time\n\nYour phrase “local time” has a specific meaning in date-time handling. Unfortunately that meaning is the opposite of your intention. The word “local” as seen in the *java.time.Local…” classes mean any locality or all localities rather than any one particular locality.\n\nSo a LocalTime object has no real meaning until attached to a date and placed in the context of a time zone (or offset-from-UTC).\n\nTime zones\n\nif UTC time is 04:55 , my phone clock is 9:25\n\nThat means your JVM’s current default time zone is using an offset-from-UTC four and a half hours ahead of UTC, +04:30. According to this list of time zones as managed by the IANA, there are only one time zone currently using that offset: Asia/Kabul.\n\nTo represent the current moment fully, you need a date and a time-of-day and a zone/offset. To capture the current moment, use Instant. The Instant class represents a moment on the timeline in UTC with a resolution of nanoseconds (up to nine (9) digits of a decimal fraction).\n\nInstant instant = Instant.now() ; // Capture the current moment in UTC.\n\nTo see that same moment in your time zone, apply a ZoneId to get a ZonedDateTime.\n\nZoneId zKabul = ZoneId.of( \"Asia/Kabul\" ) ; ZonedDateTime zdt = instant.atZone( zKabul ) ;\n\nIf you really want only the time-of-day portion of that value, extract a LocalTime. This might be useful for rendering in a user-interface, but is not likely useful in your business logic.\n\nLocalTime lt = zdt.toLocalTime() ; // Extract just the time-of-day as seen in the wall-clock time used by the people of this region (this time zone).\n\nAs a shortcut, you could call LocalTime.now:\n\nLocalTime lt = LocalTime.now( zKabul ) ;\n\nIran time\n\nLater in your comments you explain your intended time zone is Asia/Tehran, time in Iran. Currently, Iran observes Daylight Saving Time (DST), which may be the source of your confusion. While standard offset if +03:30 (three and half hours ahead of UTC), between March 22 and September 22 the offset is +04:30, one more hour further ahead of UTC.\n\nThis is exactly why you should specify your desired/expected time zone. For casual use, you can use the JVM’s current default time zone. But know that default can change at any moment during runtime. And the default may not be what you intend. For critical usage, always confirm with the user their intended time zone.\n\nLet's build up a date-time for June 1st with your example time 4:55 in UTC. We can use the constant ZoneOffset.UTC. When using merely an offset-from-UTC (an offset of zero in this case), use OffsetDateTime. An offset-from-UTC is merely a number of hours and minutes, nothing more, nothing less. In contrast, a time zone is a history of past, present, and future changes to the offset used by the people of a specific region.\n\nLocalTime lt = LocalTime.parse( \"04:55\" ) ; LocalDate ld = LocalDate.of( 2018 , Month.JUNE , 1 ) ; OffsetDateTime odt = OffsetDateTime.of( ld , lt , ZoneOffset.UTC ) ;\n\nodt.toString(): 2018-06-01T04:55Z\n\nAdjust into the zone Asia/Tehran by applying a ZoneId to get a ZonedDateTime. Same moment, same point on the timeline, but a different wall-clock time.\n\nZoneId zTehran = ZoneId.of( \"Asia/Tehran\" ) ; ZonedDateTime zdt = odt.atZoneSameInstant( zTehran );\n\nzdt.toString(): 2018-06-01T09:25+04:30[Asia/Tehran]\n\nNote the time-of-day in summer shows as 9 hour, not 8.\n\nTry the same code with month of January, when DST is not in effect.\n\nLocalTime lt = LocalTime.parse( \"04:55\" ); LocalDate ld = LocalDate.of( 2018 , Month.JANUARY , 1 ); OffsetDateTime odt = OffsetDateTime.of( ld , lt , ZoneOffset.UTC ); ZoneId zTehran = ZoneId.of( \"Asia/Tehran\" ); ZonedDateTime zdt = odt.atZoneSameInstant( zTehran );\n\nzdt.toString(): 2018-01-01T08:25+03:30[Asia/Tehran]\n\nNow we see an hour of 8.\n\nZone names\n\nSpecify a proper time zone name in the format of continent/region, such as America/Montreal, Africa/Casablanca, or Pacific/Auckland. Never use the 3-4 letter abbreviation such as EST or IST as they are not true time zones, not standardized, and not even unique(!).\n\nZoneId z = ZoneId.of( \"America/Montreal\" ) ;\n\nIf you want to use the JVM’s current default time zone, ask for it and pass as an argument. If omitted, the JVM’s current default is applied implicitly. Better to be explicit, as the default may be changed at any moment during runtime by any code in any thread of any app within the JVM.\n\nZoneId z = ZoneId.systemDefault() ; // Get JVM’s current default time zone.\n\nAbout java.time\n\nThe java.time framework is built into Java 8 and later. These classes supplant the troublesome old legacy date-time classes such as java.util.Date, Calendar, & SimpleDateFormat.\n\nThe Joda-Time project, now in maintenance mode, advises migration to the java.time classes.\n\nTo learn more, see the Oracle Tutorial. And search Stack Overflow for many examples and explanations. Specification is JSR 310.\n\nYou may exchange java.time objects directly with your database. Use a JDBC driver compliant with JDBC 4.2 or later. No need for strings, no need for java.sql.* classes.\n\nWhere to obtain the java.time classes?\n\nJava SE 8, Java SE 9, Java SE 10, and later\n\nBuilt-in.\n\nPart of the standard Java API with a bundled implementation.\n\nJava 9 adds some minor features and fixes.\n\nJava SE 6 and Java SE 7\n\nMuch of the java.time functionality is back-ported to Java 6 & 7 in ThreeTen-Backport.\n\nAndroid\n\nLater versions of Android bundle implementations of the java.time classes.\n\nFor earlier Android (<26), the ThreeTenABP project adapts ThreeTen-Backport (mentioned above). See How to use ThreeTenABP…."
    }
}