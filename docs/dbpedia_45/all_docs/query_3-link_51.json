{
    "id": "dbpedia_45_3",
    "rank": 51,
    "data": {
        "url": "https://www.reddit.com/r/linux/comments/17590l7/x11_vs_wayland_the_actual_difference/",
        "read_more_link": "",
        "language": "en",
        "title": "Dive into anything",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://www.redditstatic.com/shreddit/assets/favicon/64x64.png",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "There seems to be a lot of confusion about that X11 is, what Wayland is, and what the difference is between them. Sometimes to such a degree that people seem to be spreading misinformation for unknown (but probably not malicious) reasons. In lieu of a full blog post here's a short explanation of what they are, their respective strengths and weaknesses.\n\nProtocol vs implementation\n\nBoth X11 and Wayland are protocols, the messages that these protocols define can be found as xml here for X11, and here for wayland, but they aren't really that interesting to look at.\n\nWhen a developer wants to write an application (client), they use that protocol (and documentation) to create messages that they send over (typically, but not always) a unix-socket, on which the server listens. The protocol is both the actual messages and their format, as well as proper ordering. F.e. If you want to send a RemapWindow request, that window first much have been created, perhaps by a CreateWindow request.\n\nOn the other side of this is the server, and here comes one of the major differences between the concepts.\n\nXorg server\n\nIn the case of X11, there is a single canonical implementation, the xorg-server, code found here. It's a complete beast, an absolute monster of legacy and quirks, as well as implementation of pretty gnarly stuff, such as input handling and localization. Same as Wayland, anyone could write an X11-server implementation, but because of how much work it is, how strange the protocol can be, and how many quirks would have to be replicated for existing applications to work with your custom server, it has never been done to any measurable success.\n\nWayland\n\nWayland exists solely as a protocol, there is an example-compositor Weston, and a library which abstracts the 'bytes-over-socket'-parts libwayland but there is no de-facto standard server.\n\nPractical differences in building a DE/WM\n\nA consequence of this design is that building a simple WM becomes incredibly difficult, since a developer has to build everything that the xorg-server does, input handling, gpu-wrangling, buffer-management, etc. etc. etc. etc. A WM becomes the size of a (more modern) xorg-server. This is a clear disadvantage, as it puts the task of creating their own WM out of the reach of more people.\n\nThere are some mitigations to the problem, the project wl-roots written by the author of sway helps a developer with most of nasty details of exposing OS-capabilities to clients. Similarly smithay attempts the same task in Rust instead of C. Hopefully, as time passes, these (and more) projects will mature and reduce the bar more for DE/WM developers.\n\nProtocol differences\n\nThe X11 protocol is old and strange, the xml itself is fairly complex as well, just parsing it is a bit of a nightmare. Developing a new one has been a long time coming. But, Waylands shoveling of complexity onto single projects doing compositor implementations has some severe, at least short-term, detriments.\n\nAny \"feature\" introduced in the Wayland protocol will have to be implemented properly for each compositor (or compositor groups if they are using a helper-library such as wl-roots), meaning, your application might work fine on one compositor, but not the other.\n\nComplexity\n\nComplex features are hard to abstract by client-libraries. As a developer, when someone says, 'Wayland allows using multiple GPUs\", all I can think of is: \"How is that exposed to the developer?\".\n\nClient-libraries generally exist on a few abstraction layers, You might start with libc, then build up to wl-roots, then you'll build some cross-platform client library that for Linux uses wl-roots, and that's what's exposed to the general client-application developer. Fine-grained control is good depending on how much it dirties up the code base, but in practice these highly specific, complex, Linux-features will likely never be exposed and used by developers of any larger application, since they will likely use tools that can't unify them with other OSes.\n\nAn alternative is that the low-level libraries make a default decision, which may or may not be correct, about how these features should be used, if they are even implemented. And if they are too hard to implement, since there is no canonical implementation, client-libraries might just not even try because it isn't reliably present, so adding 2000 lines of code to shovel some tasks onto an integrated GPU instead of the dedicated GPU just wont ever be worth it from a maintenance perspective.\n\nI think the biggest issue with how Wayland is spoken about is that there's a misconception about complexity. Wayland has loads of complexity, but that's shoveled out of the protocol and onto developers, the protocol being simple means next to nothing.\n\nTLDR\n\nThis may have come off as very critical to Wayland, and this is part critique, but it's not a pitch that we should stick to X11. The X-window-system lasted 39 years, for any code that's quite the achievement, but its time to move on. I'm not pitching that Wayland should be changed either. I'm just trying to get a realistic view about the two concepts out, neither is perfect, it'll take a lot of time and work until Wayland achieves its potential, but I think it'll be \"generally better\" than X11 when it does.\n\nThere is however a risk, that the complexity that Wayland (kind of sneakily) introduces, may make it its own beast, and that in 30 years when \"NextLand\" drops we'll be swearing about all the unnecessary complexity that was introduced that nobody benefited from."
    }
}