{
    "id": "dbpedia_45_2",
    "rank": 29,
    "data": {
        "url": "https://doc.qt.io/qt-6/wayland-and-qt.html",
        "read_more_link": "",
        "language": "en",
        "title": "Wayland and Qt",
        "top_image": "https://d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon-32x32.png",
        "meta_img": "https://d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon-32x32.png",
        "images": [
            "https://doc.qt.io/style/qt-logo-documentation.svg",
            "https://doc.qt.io/qt-6/images/wayland-multi-process.png",
            "https://doc.qt.io/qt-6/images/wayland-single-process-eglfs.png",
            "https://doc.qt.io/qt-6/images/wayland-single-process-develop.png",
            "https://doc.qt.io/images/qtgroup.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "An overview of the Wayland protocol and how it fits into Qt.",
        "meta_lang": "en",
        "meta_favicon": "//d33sqmjvzgs8hq.cloudfront.net/wp-content/themes/oneqt/assets/images/favicon.ico.gzip",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Wayland was developed as an alternative to X11 on Linux. Its main purpose is to manage how the content of applications is displayed together on a shared screen, and how a user can interact with multiple applications sharing the same input devices.\n\nThis role in an operating system is often called a display server. The Wayland display server may also sometimes be called a compositor and a window manager, referring to specific tasks it performs as part of its duty.\n\nIn the following, we will give a short introduction to Wayland and its role in Qt. For more details and background about Wayland itself, refer to the official documentation.\n\nWhat is a Display Server\n\nThe display server is the part of the operating system which manages the screen real estate and other shared resources. On a typical desktop system, you may have many independent applications running at the same time, each expecting to be able to render graphics to the screen and receive input.\n\nThe display server is a link between the application and shared resources such as a screen and input devices. A typical display server on a desktop system will place application content into distinct rectangular \"windows\", which can be moved and resized by the user. The display server makes sure that the application content is displayed at the right position on the screen, that the active window receives input from the keyboard, that overlapping windows are drawn in the right order, and so on.\n\nOn other types of systems, the display server may be more restrictive. If the screen is an instrument panel in a car, or the control panel of a fork lift, for instance, then moving and resizing windows may not be desirable. Instead, each application may be locked into a pre-defined area of the screen and receive input from preassigned devices.\n\nEither way, as long as there are multiple isolated processes competing for the same resources, a display server is useful.\n\nThe Role of Wayland\n\nThe Wayland name may refer to several related items:\n\nA set of protocols for communicating between a display server and its clients.\n\nA library written in C with functions for inter-process communication, serving as the foundation for implementing said protocols.\n\nAn XML-based language for extending the protocol, as well as a tool for generating binding code in C from such extensions.\n\nQt provides implementations for both the client and the server side of the protocol.\n\nNormal Qt applications can be run as clients on a Wayland display server by selecting the \"wayland\" QPA plugin (this is the default on certain systems). In addition, the Qt Wayland Compositor module can be used to develop the display server itself.\n\nQt also has convenience functionality for easily extending the Wayland protocols with new interfaces.\n\nWayland and Other Technology\n\nOn the Linux desktop, Wayland is an alternative to X11 and related extensions. It is a compositing display server at its core, and the term \"compositor\" is often used to describe the Wayland server. This means that clients will render content into an off-screen buffer, which will later be \"composited\" with other clients on the screen, allowing window effects such as drop shadows, transparency, background blurring, and so on.\n\nOne important design principle of the original X11 protocols is that the display server can be running on a thin terminal with only a screen and input devices. Its clients would then be running on remote systems with more processing power, communicating with the server over a network connection.\n\nIn contrast, Wayland is designed around the observation that, in modern setups, the client and display server are usually running on the same hardware. Distributed computing, remote storage and remote desktop functionality are usually handled through other mechanisms. Designing this into the protocol enables sharing graphics memory between the client and the server: When the compositor is placing client content on screen, it can simply copy it from one part of graphics memory to another.\n\nFor this to work optimally, the graphics driver must support Wayland. This support is provided through an extension to EGL which is called EXT_platform_wayland.\n\nX11 has been extended to support features such as composition and direct rendering, but Wayland is designed around this use case from the ground up. It also aims to be small and extensible, in contrast to the complexity that has developed in X11 over time.\n\nExtensibility and Embedded Systems\n\nSince Wayland has a minimal core and is easily extensible, it is an ideal tool when building embedded Linux platforms.\n\nDesktop-style window system features, for instance, are not part of the core protocol. Instead, Wayland has a special category of protocol extensions called \"shells\" that provide a way for the client to manage its surfaces. Desktop-style features are provided through a shell called XDG Shell. For other types of systems, a more specialized (and perhaps more restrictive) \"shell\" can be used. For instance, when making In-Vehicle Infotainment systems, the IVI Shell might be preferable.\n\nThe Wayland server broadcasts a list of its supported protocols (or \"interfaces\") when a client connects, and the client can bind to the ones it wants to use. This can be any of the standard interfaces, but new extensions are also easy to add. Wayland defines an easily understandable XML format for defining protocols and the waylandscanner tool can be used to generate C code from these. (In Qt, we also have qtwaylandscanner which generates additional C++ binding code.)\n\nAfter a client binds to an interface, it can make \"requests\" to the server and the server can send \"events\" to the client. The requests and events, as well as their arguments, are defined in the XML file describing the protocol.\n\nFor building a platform from scratch, when you control the code of both server and clients, adding extensions is an easy and controlled way of adding operating system features.\n\nMulti-Process or Single-Process\n\nWhen building a simple embedded platform with Qt, a perfectly viable option is to have all parts of the UI running in a single process. However, as the system becomes more complex, you may want to consider a multi-process system instead. This is where Wayland comes in. With Qt, at any point in your development process, you can choose to switch between single-process and multi-process.\n\nBenefits of Multi-Process\n\nThe following diagrams illustrate the difference between multi-process and single-process systems.\n\nMulti-Process Client Architecture\n\nSingle Process Client Architecture\n\nThe Qt Wayland Compositor module is ideal for creating the display server and compositor in multi-process systems on embedded Linux. The use of multi-process has the following benefits:\n\nStability\n\nSecurity\n\nPerformance\n\nInteroperability\n\nTrade-offs of Multi-Process\n\nWhen going from single-process to multi-process, it is important to be conscious of the following trade-offs:\n\nIncreased video memory consumption\n\nIncreased main memory consumption\n\nRepeated storage of graphical resources\n\nInput latency\n\nWhy Use Wayland Instead of X11 or Custom Solutions\n\nAs described earlier, X11 is not an optimal match for typical system setups today. It is quite large and complex, and lacks ability in customization. In fact, it is difficult to run a client fluidly with X11, and reach 60 fps without tearing. Wayland, in contrast, is easier to implement, has better performance, and contains all the necessary parts to run efficiently on modern graphics hardware. For embedded, multi-process systems on Linux, Wayland is the standard.\n\nHowever, if you are working with old hardware or legacy applications, then Wayland may not be a good option. The Wayland protocol is designed with security and isolation in mind, and is strict/conservative about what information and functionality is available to clients. While this leads to a cleaner and more secure interface, some functionality that legacy applications expect may no longer be available on Wayland.\n\nParticularly, there are three common use cases where Wayland may not be the best option:\n\nThe hardware or platform is old and only supports X11; in which case you have no choice.\n\nYou have to support legacy applications that depend on features that are absent in the Wayland protocol for security and simplicity.\n\nYou have to support legacy applications that use a UI toolkit that doesn't run on Wayland at all. In some cases, you may be able to work around this by running those applications on XWayland instead.\n\nBack when X11 was very popular, developers wrote their own custom solutions to circumvent X11 issues. Older Qt versions had the Qt Windowing System (QWS), which is now discontinued. Today, most of these use cases are covered by Wayland, and custom solutions are becoming less and less common.\n\nWhat Qt Wayland Offers\n\nFor Clients\n\nQt clients can run on any Wayland compositor, including Weston, the reference compositor developed as part of the Wayland project.\n\nAny Qt program can run as a Wayland client (as part of a multi-process system) or a standalone client (single-process). This is determined on startup, where you can choose between the different backends. During the development process, you can develop the client on the desktop first, then test it on the target hardware later. You don't need to run your clients on the actual target hardware all the time.\n\nSingle-Process Client Development\n\nIf you develop on a Linux machine, you can also run the compositor within a window on your development machine. This lets you run clients in an environment that closely resembles the target device. Without rebuilding the client, you can also run it with -platform wayland to run it inside the compositor. If you use -platform xcb (for X11), you can run the client on the desktop. In other words, you can start developing your clients before the compositor is ready for use.\n\nFor Servers\n\nThe server, or compositor, connects to the display and shows the contents of each client on the screen. The compositor handles input and sends input events to the corresponding client. In turn, each client connects to the compositor and sends the content of its windows. It's up to the compositor to decide:\n\nHow and where to show the content\n\nWhich content to show\n\nWhat to do with the different client graphics buffers\n\nThis means, it's up to the compositor to decide what a multi-process system is. For instance, the clients could be part of a 3D scene with windows on the walls, on a VR system, mapped to a sphere, and so on.\n\nThe Qt Wayland Compositor is an API for building your own compositor. It gives you full freedom to build a custom compositor UI and manage the windows of various clients. You can combine both Qt Quick and QML with the Qt Wayland Compositor to create impressive, imaginative UIs. For more information, see Qt Wayland Compositor.\n\nQt also provides powerful and user-friendly APIs to implement Wayland extensions and use them from QML or C++."
    }
}