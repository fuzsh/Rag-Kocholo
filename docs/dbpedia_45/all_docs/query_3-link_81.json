{
    "id": "dbpedia_45_3",
    "rank": 81,
    "data": {
        "url": "https://wayland.app/protocols/wayland",
        "read_more_link": "",
        "language": "en",
        "title": "Wayland protocol",
        "top_image": "https://wayland.app/protocols/favicon.ico",
        "meta_img": "https://wayland.app/protocols/favicon.ico",
        "images": [
            "https://wayland.app/protocols/logo.svg",
            "https://wayland.app/protocols/logo.svg",
            "https://wayland.app/protocols/logos/gnome.svg",
            "https://wayland.app/protocols/logos/kde.svg",
            "https://wayland.app/protocols/logos/sway.svg",
            "https://wayland.app/protocols/logos/hyprland.svg",
            "https://wayland.app/protocols/logos/weston.svg",
            "https://wayland.app/protocols/logos/mir.svg",
            "https://wayland.app/protocols/logos/Steam_Deck.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "A better way to read Wayland documentation",
        "meta_lang": "en",
        "meta_favicon": "/protocols/favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Asynchronous roundtrip\n\nThe sync request asks the server to emit the 'done' event on the returned wl_callback object. Since requests are handled in-order and events are delivered in-order, this can be used as a barrier to ensure all previous requests and the resulting events have been handled.\n\nThe object returned by this request will be destroyed by the compositor after the callback is fired and as such the client must not attempt to use it after that point.\n\nThe callback_data passed in the callback is the event serial.\n\nSet the available/preferred drag-and-drop actions\n\nSets the actions that the destination side client supports for this operation. This request may trigger the emission of wl_data_source.action and wl_data_offer.action events if the compositor needs to change the selected action.\n\nThis request can be called multiple times throughout the drag-and-drop operation, typically in response to wl_data_device.enter or wl_data_device.motion events.\n\nThis request determines the final result of the drag-and-drop operation. If the end result is that no action is accepted, the drag source will receive wl_data_source.cancelled.\n\nThe dnd_actions argument must contain only values expressed in the wl_data_device_manager.dnd_actions enum, and the preferred_action argument must only contain one of those values set, otherwise it will result in a protocol error.\n\nWhile managing an \"ask\" action, the destination drag-and-drop client may perform further wl_data_offer.receive requests, and is expected to perform one last wl_data_offer.set_actions request with a preferred action other than \"ask\" (and optionally wl_data_offer.accept) before requesting wl_data_offer.finish, in order to convey the action selected by the user. If the preferred action is not in the wl_data_offer.source_actions mask, an error will be raised.\n\nIf the \"ask\" action is dismissed (e.g. user cancellation), the client is expected to perform wl_data_offer.destroy right away.\n\nThis request can only be made on drag-and-drop offers, a protocol error will be raised otherwise.\n\nNotify the selected action\n\nThis event indicates the action selected by the compositor after matching the source/destination side actions. Only one action (or none) will be offered here.\n\nThis event can be emitted multiple times during the drag-and-drop operation in response to destination side action changes through wl_data_offer.set_actions.\n\nThis event will no longer be emitted after wl_data_device.drop happened on the drag-and-drop destination, the client must honor the last action received, or the last preferred one set through wl_data_offer.set_actions when handling an \"ask\" action.\n\nCompositors may also change the selected action on the fly, mainly in response to keyboard modifier changes during the drag-and-drop operation.\n\nThe most recent action received is always the valid one. Prior to receiving wl_data_device.drop, the chosen action may change (e.g. due to keyboard modifiers being pressed). At the time of receiving wl_data_device.drop the drag-and-drop destination must honor the last action received.\n\nAction changes may still happen after wl_data_device.drop, especially on \"ask\" actions, where the drag-and-drop destination may choose another action afterwards. Action changes happening at this stage are always the result of inter-client negotiation, the compositor shall no longer be able to induce a different action.\n\nUpon \"ask\" actions, it is expected that the drag-and-drop destination may potentially choose a different action and/or mime type, based on wl_data_offer.source_actions and finally chosen by the user (e.g. popping up a menu with the available options). The final wl_data_offer.set_actions and wl_data_offer.accept requests must happen before the call to wl_data_offer.finish.\n\nNotify the selected action\n\nThis event indicates the action selected by the compositor after matching the source/destination side actions. Only one action (or none) will be offered here.\n\nThis event can be emitted multiple times during the drag-and-drop operation, mainly in response to destination side changes through wl_data_offer.set_actions, and as the data device enters/leaves surfaces.\n\nIt is only possible to receive this event after wl_data_source.dnd_drop_performed if the drag-and-drop operation ended in an \"ask\" action, in which case the final wl_data_source.action event will happen immediately before wl_data_source.dnd_finished.\n\nCompositors may also change the selected action on the fly, mainly in response to keyboard modifier changes during the drag-and-drop operation.\n\nThe most recent action received is always the valid one. The chosen action may change alongside negotiation (e.g. an \"ask\" action can turn into a \"move\" operation), so the effects of the final action must always be applied in wl_data_offer.dnd_finished.\n\nClients can trigger cursor surface changes from this point, so they reflect the current action.\n\nStart drag-and-drop operation\n\nThis request asks the compositor to start a drag-and-drop operation on behalf of the client.\n\nThe source argument is the data source that provides the data for the eventual data transfer. If source is NULL, enter, leave and motion events are sent only to the client that initiated the drag and the client is expected to handle the data passing internally. If source is destroyed, the drag-and-drop session will be cancelled.\n\nThe origin surface is the surface where the drag originates and the client must have an active implicit grab that matches the serial.\n\nThe icon surface is an optional (can be NULL) surface that provides an icon to be moved around with the cursor. Initially, the top-left corner of the icon surface is placed at the cursor hotspot, but subsequent wl_surface.attach request can move the relative position. Attach requests must be confirmed with wl_surface.commit as usual. The icon surface is given the role of a drag-and-drop icon. If the icon surface already has another role, it raises a protocol error.\n\nThe input region is ignored for wl_surfaces with the role of a drag-and-drop icon.\n\nThe given source may not be used in any further set_selection or start_drag requests. Attempting to reuse a previously-used source may send a used_source error.\n\nDrag and drop actions\n\nThis is a bitmask of the available/preferred actions in a drag-and-drop operation.\n\nIn the compositor, the selected action is a result of matching the actions offered by the source and destination sides. \"action\" events with a \"none\" action will be sent to both source and destination if there is no match. All further checks will effectively happen on (source actions âˆ© destination actions).\n\nIn addition, compositors may also pick different actions in reaction to key modifiers being pressed. One common design that is used in major toolkits (and the behavior recommended for compositors) is:\n\n- If no modifiers are pressed, the first match (in bit order) will be used. - Pressing Shift selects \"move\", if enabled in the mask. - Pressing Control selects \"copy\", if enabled in the mask.\n\nBehavior beyond that is considered implementation-dependent. Compositors may for example bind other modifiers (like Alt/Meta) or drags initiated with other buttons than BTN_LEFT to specific actions (e.g. \"ask\").\n\nMake the surface a fullscreen surface\n\nMap the surface as a fullscreen surface.\n\nIf an output parameter is given then the surface will be made fullscreen on that output. If the client does not specify the output then the compositor will apply its policy - usually choosing the output on which the surface has the biggest surface area.\n\nThe client may specify a method to resolve a size conflict between the output size and the surface size - this is provided through the method parameter.\n\nThe framerate parameter is used only when the method is set to \"driver\", to indicate the preferred framerate. A value of 0 indicates that the client does not care about framerate. The framerate is specified in mHz, that is framerate of 60000 is 60Hz.\n\nA method of \"scale\" or \"driver\" implies a scaling operation of the surface, either via a direct scaling operation or a change of the output mode. This will override any kind of output scaling, so that mapping a surface with a buffer size equal to the mode can fill the screen independent of buffer_scale.\n\nA method of \"fill\" means we don't scale up the buffer, however any output scale is applied. This means that you may run into an edge case where the application maps a buffer with the same size of the output mode but buffer_scale 1 (thus making a surface larger than the output). In this case it is allowed to downscale the results to fit the screen.\n\nThe compositor must reply to this request with a configure event with the dimensions for the output on which the surface will be made fullscreen.\n\nSet the surface contents\n\nSet a buffer as the content of this surface.\n\nThe new size of the surface is calculated based on the buffer size transformed by the inverse buffer_transform and the inverse buffer_scale. This means that at commit time the supplied buffer size must be an integer multiple of the buffer_scale. If that's not the case, an invalid_size error is sent.\n\nThe x and y arguments specify the location of the new pending buffer's upper left corner, relative to the current buffer's upper left corner, in surface-local coordinates. In other words, the x and y, combined with the new surface size define in which directions the surface's size changes. Setting anything other than 0 as x and y arguments is discouraged, and should instead be replaced with using the separate wl_surface.offset request.\n\nWhen the bound wl_surface version is 5 or higher, passing any non-zero x or y is a protocol violation, and will result in an 'invalid_offset' error being raised. The x and y arguments are ignored and do not change the pending state. To achieve equivalent semantics, use wl_surface.offset.\n\nSurface contents are double-buffered state, see wl_surface.commit.\n\nThe initial surface contents are void; there is no content. wl_surface.attach assigns the given wl_buffer as the pending wl_buffer. wl_surface.commit makes the pending wl_buffer the new surface contents, and the size of the surface becomes the size calculated from the wl_buffer, as described above. After commit, there is no pending buffer until the next attach.\n\nCommitting a pending wl_buffer allows the compositor to read the pixels in the wl_buffer. The compositor may access the pixels at any time after the wl_surface.commit request. When the compositor will not access the pixels anymore, it will send the wl_buffer.release event. Only after receiving wl_buffer.release, the client may reuse the wl_buffer. A wl_buffer that has been attached and then replaced by another attach instead of committed will not receive a release event, and is not used by the compositor.\n\nIf a pending wl_buffer has been committed to more than one wl_surface, the delivery of wl_buffer.release events becomes undefined. A well behaved client should not rely on wl_buffer.release events in this case. Alternatively, a client could create multiple wl_buffer objects from the same backing storage or use wp_linux_buffer_release.\n\nDestroying the wl_buffer after wl_buffer.release does not change the surface contents. Destroying the wl_buffer before wl_buffer.release is allowed as long as the underlying buffer storage isn't re-used (this can happen e.g. on client process termination). However, if the client destroys the wl_buffer before receiving the wl_buffer.release event and mutates the underlying buffer storage, the surface contents become undefined immediately.\n\nIf wl_surface.attach is sent with a NULL wl_buffer, the following wl_surface.commit will remove the surface content.\n\nMark part of the surface damaged\n\nThis request is used to describe the regions where the pending buffer is different from the current surface contents, and where the surface therefore needs to be repainted. The compositor ignores the parts of the damage that fall outside of the surface.\n\nDamage is double-buffered state, see wl_surface.commit.\n\nThe damage rectangle is specified in surface-local coordinates, where x and y specify the upper left corner of the damage rectangle.\n\nThe initial value for pending damage is empty: no damage. wl_surface.damage adds pending damage: the new pending damage is the union of old pending damage and the given rectangle.\n\nwl_surface.commit assigns pending damage as the current damage, and clears pending damage. The server will clear the current damage as it repaints the surface.\n\nNote! New clients should not use this request. Instead damage can be posted with wl_surface.damage_buffer which uses buffer coordinates instead of surface coordinates.\n\nRequest a frame throttling hint\n\nRequest a notification when it is a good time to start drawing a new frame, by creating a frame callback. This is useful for throttling redrawing operations, and driving animations.\n\nWhen a client is animating on a wl_surface, it can use the 'frame' request to get notified when it is a good time to draw and commit the next frame of animation. If the client commits an update earlier than that, it is likely that some updates will not make it to the display, and the client is wasting resources by drawing too often.\n\nThe frame request will take effect on the next wl_surface.commit. The notification will only be posted for one frame unless requested again. For a wl_surface, the notifications are posted in the order the frame requests were committed.\n\nThe server must send the notifications so that a client will not send excessive updates, while still allowing the highest possible update rate for clients that wait for the reply before drawing again. The server should give some time for the client to draw and commit after sending the frame callback events to let it hit the next output refresh.\n\nA server should avoid signaling the frame callbacks if the surface is not visible in any way, e.g. the surface is off-screen, or completely obscured by other opaque surfaces.\n\nThe object returned by this request will be destroyed by the compositor after the callback is fired and as such the client must not attempt to use it after that point.\n\nThe callback_data passed in the callback is the current time, in milliseconds, with an undefined base.\n\nSets the buffer transformation\n\nThis request sets an optional transformation on how the compositor interprets the contents of the buffer attached to the surface. The accepted values for the transform parameter are the values for wl_output.transform.\n\nBuffer transform is double-buffered state, see wl_surface.commit.\n\nA newly created surface has its buffer transformation set to normal.\n\nwl_surface.set_buffer_transform changes the pending buffer transformation. wl_surface.commit copies the pending buffer transformation to the current one. Otherwise, the pending and current values are never changed.\n\nThe purpose of this request is to allow clients to render content according to the output transform, thus permitting the compositor to use certain optimizations even if the display is rotated. Using hardware overlays and scanning out a client buffer for fullscreen surfaces are examples of such optimizations. Those optimizations are highly dependent on the compositor implementation, so the use of this request should be considered on a case-by-case basis.\n\nNote that if the transform value includes 90 or 270 degree rotation, the width of the buffer will become the surface height and the height of the buffer will become the surface width.\n\nIf transform is not one of the values from the wl_output.transform enum the invalid_transform protocol error is raised.\n\nSets the buffer scaling factor\n\nThis request sets an optional scaling factor on how the compositor interprets the contents of the buffer attached to the window.\n\nBuffer scale is double-buffered state, see wl_surface.commit.\n\nA newly created surface has its buffer scale set to 1.\n\nwl_surface.set_buffer_scale changes the pending buffer scale. wl_surface.commit copies the pending buffer scale to the current one. Otherwise, the pending and current values are never changed.\n\nThe purpose of this request is to allow clients to supply higher resolution buffer data for use on high resolution outputs. It is intended that you pick the same buffer scale as the scale of the output that the surface is displayed on. This means the compositor can avoid scaling when rendering the surface on that output.\n\nNote that if the scale is larger than 1, then you have to attach a buffer that is larger (by a factor of scale in each dimension) than the desired surface size.\n\nIf scale is not positive the invalid_scale protocol error is raised.\n\nMark part of the surface damaged using buffer coordinates\n\nThis request is used to describe the regions where the pending buffer is different from the current surface contents, and where the surface therefore needs to be repainted. The compositor ignores the parts of the damage that fall outside of the surface.\n\nDamage is double-buffered state, see wl_surface.commit.\n\nThe damage rectangle is specified in buffer coordinates, where x and y specify the upper left corner of the damage rectangle.\n\nThe initial value for pending damage is empty: no damage. wl_surface.damage_buffer adds pending damage: the new pending damage is the union of old pending damage and the given rectangle.\n\nwl_surface.commit assigns pending damage as the current damage, and clears pending damage. The server will clear the current damage as it repaints the surface.\n\nThis request differs from wl_surface.damage in only one way - it takes damage in buffer coordinates instead of surface-local coordinates. While this generally is more intuitive than surface coordinates, it is especially desirable when using wp_viewport or when a drawing library (like EGL) is unaware of buffer scale and buffer transform.\n\nNote: Because buffer transformation changes and damage requests may be interleaved in the protocol stream, it is impossible to determine the actual mapping between surface and buffer damage until wl_surface.commit time. Therefore, compositors wishing to take both kinds of damage into account will have to accumulate damage from the two requests separately and only transform from one to the other after receiving the wl_surface.commit.\n\nSeat capabilities changed\n\nThis is emitted whenever a seat gains or loses the pointer, keyboard or touch capabilities. The argument is a capability enum containing the complete set of capabilities this seat has.\n\nWhen the pointer capability is added, a client may create a wl_pointer object using the wl_seat.get_pointer request. This object will receive pointer events until the capability is removed in the future.\n\nWhen the pointer capability is removed, a client should destroy the wl_pointer objects associated with the seat where the capability was removed, using the wl_pointer.release request. No further pointer events will be received on these objects.\n\nIn some compositors, if a seat regains the pointer capability and a client has a previously obtained wl_pointer object of version 4 or less, that object may start sending pointer events again. This behavior is considered a misinterpretation of the intended behavior and must not be relied upon by the client. wl_pointer objects of version 5 or later must not send events if created before the most recent event notifying the client of an added pointer capability.\n\nThe above behavior also applies to wl_keyboard and wl_touch with the keyboard and touch capabilities, respectively.\n\nUnique identifier for this seat\n\nIn a multi-seat configuration the seat name can be used by clients to help identify which physical devices the seat represents.\n\nThe seat name is a UTF-8 string with no convention defined for its contents. Each name is unique among all wl_seat globals. The name is only guaranteed to be unique for the current compositor instance.\n\nThe same seat names are used for all clients. Thus, the name can be shared across processes to refer to a specific wl_seat global.\n\nThe name event is sent after binding to the seat global. This event is only sent once per seat object, and the name does not change over the lifetime of the wl_seat global.\n\nCompositors may re-use the same seat name if the wl_seat global is destroyed and re-created later.\n\nSet the pointer surface\n\nSet the pointer surface, i.e., the surface that contains the pointer image (cursor). This request gives the surface the role of a cursor. If the surface already has another role, it raises a protocol error.\n\nThe cursor actually changes only if the pointer focus for this device is one of the requesting client's surfaces or the surface parameter is the current pointer surface. If there was a previous surface set with this request it is replaced. If surface is NULL, the pointer image is hidden.\n\nThe parameters hotspot_x and hotspot_y define the position of the pointer surface relative to the pointer location. Its top-left corner is always at (x, y) - (hotspot_x, hotspot_y), where (x, y) are the coordinates of the pointer location, in surface-local coordinates.\n\nOn surface.attach requests to the pointer surface, hotspot_x and hotspot_y are decremented by the x and y parameters passed to the request. Attach must be confirmed by wl_surface.commit as usual.\n\nThe hotspot can also be updated by passing the currently set pointer surface to this request with new values for hotspot_x and hotspot_y.\n\nThe input region is ignored for wl_surfaces with the role of a cursor. When the use as a cursor ends, the wl_surface is unmapped.\n\nThe serial parameter must match the latest wl_pointer.enter serial number sent to the client. Otherwise the request will be ignored.\n\nEnd of a pointer event sequence\n\nIndicates the end of a set of events that logically belong together. A client is expected to accumulate the data in all events within the frame before proceeding.\n\nAll wl_pointer events before a wl_pointer.frame event belong logically together. For example, in a diagonal scroll motion the compositor will send an optional wl_pointer.axis_source event, two wl_pointer.axis events (horizontal and vertical) and finally a wl_pointer.frame event. The client may use this information to calculate a diagonal vector for scrolling.\n\nWhen multiple wl_pointer.axis events occur within the same frame, the motion vector is the combined motion of all events. When a wl_pointer.axis and a wl_pointer.axis_stop event occur within the same frame, this indicates that axis movement in one axis has stopped but continues in the other axis. When multiple wl_pointer.axis_stop events occur within the same frame, this indicates that these axes stopped in the same instance.\n\nA wl_pointer.frame event is sent for every logical event group, even if the group only contains a single wl_pointer event. Specifically, a client may get a sequence: motion, frame, button, frame, axis, frame, axis_stop, frame.\n\nThe wl_pointer.enter and wl_pointer.leave events are logical events generated by the compositor and not the hardware. These events are also grouped by a wl_pointer.frame. When a pointer moves from one surface to another, a compositor should group the wl_pointer.leave event within the same wl_pointer.frame. However, a client must not rely on wl_pointer.leave and wl_pointer.enter being in the same wl_pointer.frame. Compositor-specific policies may require the wl_pointer.leave and wl_pointer.enter event being split across multiple wl_pointer.frame groups.\n\nAxis source event\n\nSource information for scroll and other axes.\n\nThis event does not occur on its own. It is sent before a wl_pointer.frame event and carries the source information for all events within that frame.\n\nThe source specifies how this event was generated. If the source is wl_pointer.axis_source.finger, a wl_pointer.axis_stop event will be sent when the user lifts the finger off the device.\n\nIf the source is wl_pointer.axis_source.wheel, wl_pointer.axis_source.wheel_tilt or wl_pointer.axis_source.continuous, a wl_pointer.axis_stop event may or may not be sent. Whether a compositor sends an axis_stop event for these sources is hardware-specific and implementation-dependent; clients must not rely on receiving an axis_stop event for these scroll sources and should treat scroll sequences from these scroll sources as unterminated by default.\n\nThis event is optional. If the source is unknown for a particular axis event sequence, no event is sent. Only one wl_pointer.axis_source event is permitted per frame.\n\nThe order of wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed.\n\nAxis click event\n\nDiscrete step information for scroll and other axes.\n\nThis event carries the axis value of the wl_pointer.axis event in discrete steps (e.g. mouse wheel clicks).\n\nThis event is deprecated with wl_pointer version 8 - this event is not sent to clients supporting version 8 or later.\n\nThis event does not occur on its own, it is coupled with a wl_pointer.axis event that represents this axis value on a continuous scale. The protocol guarantees that each axis_discrete event is always followed by exactly one axis event with the same axis number within the same wl_pointer.frame. Note that the protocol allows for other events to occur between the axis_discrete and its coupled axis event, including other axis_discrete or axis events. A wl_pointer.frame must not contain more than one axis_discrete event per axis type.\n\nThis event is optional; continuous scrolling devices like two-finger scrolling on touchpads do not have discrete steps and do not generate this event.\n\nThe discrete value carries the directional information. e.g. a value of -2 is two steps towards the negative direction of this axis.\n\nThe axis number is identical to the axis number in the associated axis event.\n\nThe order of wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed.\n\nAxis relative physical direction event\n\nRelative directional information of the entity causing the axis motion.\n\nFor a wl_pointer.axis event, the wl_pointer.axis_relative_direction event specifies the movement direction of the entity causing the wl_pointer.axis event. For example: - if a user's fingers on a touchpad move down and this causes a wl_pointer.axis vertical_scroll down event, the physical direction is 'identical' - if a user's fingers on a touchpad move down and this causes a wl_pointer.axis vertical_scroll up scroll up event ('natural scrolling'), the physical direction is 'inverted'.\n\nA client may use this information to adjust scroll motion of components. Specifically, enabling natural scrolling causes the content to change direction compared to traditional scrolling. Some widgets like volume control sliders should usually match the physical direction regardless of whether natural scrolling is active. This event enables clients to match the scroll direction of a widget to the physical direction.\n\nThis event does not occur on its own, it is coupled with a wl_pointer.axis event that represents this axis value. The protocol guarantees that each axis_relative_direction event is always followed by exactly one axis event with the same axis number within the same wl_pointer.frame. Note that the protocol allows for other events to occur between the axis_relative_direction and its coupled axis event.\n\nThe axis number is identical to the axis number in the associated axis event.\n\nThe order of wl_pointer.axis_relative_direction, wl_pointer.axis_discrete and wl_pointer.axis_source is not guaranteed.\n\nAxis source types\n\nDescribes the source types for axis events. This indicates to the client how an axis event was physically generated; a client may adjust the user interface accordingly. For example, scroll events from a \"finger\" source may be in a smooth coordinate space with kinetic scrolling whereas a \"wheel\" source may be in discrete steps of a number of lines.\n\nThe \"continuous\" axis source is a device generating events in a continuous coordinate space, but using something other than a finger. One example for this source is button-based scrolling where the vertical motion of a device is converted to scroll events while a button is held down.\n\nThe \"wheel tilt\" axis source indicates that the actual device is a wheel but the scroll event is not caused by a rotation but a (usually sideways) tilt of the wheel.\n\nUpdate shape of touch point\n\nSent when a touchpoint has changed its shape.\n\nThis event does not occur on its own. It is sent before a wl_touch.frame event and carries the new shape information for any previously reported, or new touch points of that frame.\n\nOther events describing the touch point such as wl_touch.down, wl_touch.motion or wl_touch.orientation may be sent within the same wl_touch.frame. A client should treat these events as a single logical touch point update. The order of wl_touch.shape, wl_touch.orientation and wl_touch.motion is not guaranteed. A wl_touch.down event is guaranteed to occur before the first wl_touch.shape event for this touch ID but both events may occur within the same wl_touch.frame.\n\nA touchpoint shape is approximated by an ellipse through the major and minor axis length. The major axis length describes the longer diameter of the ellipse, while the minor axis length describes the shorter diameter. Major and minor are orthogonal and both are specified in surface-local coordinates. The center of the ellipse is always at the touchpoint location as reported by wl_touch.down or wl_touch.move.\n\nThis event is only sent by the compositor if the touch device supports shape reports. The client has to make reasonable assumptions about the shape if it did not receive this event.\n\nUpdate orientation of touch point\n\nSent when a touchpoint has changed its orientation.\n\nThis event does not occur on its own. It is sent before a wl_touch.frame event and carries the new shape information for any previously reported, or new touch points of that frame.\n\nOther events describing the touch point such as wl_touch.down, wl_touch.motion or wl_touch.shape may be sent within the same wl_touch.frame. A client should treat these events as a single logical touch point update. The order of wl_touch.shape, wl_touch.orientation and wl_touch.motion is not guaranteed. A wl_touch.down event is guaranteed to occur before the first wl_touch.orientation event for this touch ID but both events may occur within the same wl_touch.frame.\n\nThe orientation describes the clockwise angle of a touchpoint's major axis to the positive surface y-axis and is normalized to the -180 to +180 degree range. The granularity of orientation depends on the touch device, some devices only support binary rotation values between 0 and 90 degrees.\n\nThis event is only sent by the compositor if the touch device supports orientation reports.\n\nProperties of the output\n\nThe geometry event describes geometric properties of the output. The event is sent when binding to the output object and whenever any of the properties change.\n\nThe physical size can be set to zero if it doesn't make sense for this output (e.g. for projectors or virtual outputs).\n\nThe geometry event will be followed by a done event (starting from version 2).\n\nNote: wl_output only advertises partial information about the output position and identification. Some compositors, for instance those not implementing a desktop-style output layout or those exposing virtual outputs, might fake this information. Instead of using x and y, clients should use xdg_output.logical_position. Instead of using make and model, clients should use name and description.\n\nAdvertise available modes for the output\n\nThe mode event describes an available mode for the output.\n\nThe event is sent when binding to the output object and there will always be one mode, the current mode. The event is sent again if an output changes mode, for the mode that is now current. In other words, the current mode is always the last mode that was received with the current flag set.\n\nNon-current modes are deprecated. A compositor can decide to only advertise the current mode and never send other modes. Clients should not rely on non-current modes.\n\nThe size of a mode is given in physical hardware units of the output device. This is not necessarily the same as the output size in the global compositor space. For instance, the output may be scaled, as described in wl_output.scale, or transformed, as described in wl_output.transform. Clients willing to retrieve the output size in the global compositor space should use xdg_output.logical_size instead.\n\nThe vertical refresh rate can be set to zero if it doesn't make sense for this output (e.g. for virtual outputs).\n\nThe mode event will be followed by a done event (starting from version 2).\n\nClients should not use the refresh rate to schedule frames. Instead, they should use the wl_surface.frame event or the presentation-time protocol.\n\nNote: this information is not always meaningful for all outputs. Some compositors, such as those exposing virtual outputs, might fake the refresh rate or the size.\n\nOutput scaling properties\n\nThis event contains scaling geometry information that is not in the geometry event. It may be sent after binding the output object or if the output scale changes later. If it is not sent, the client should assume a scale of 1.\n\nA scale larger than 1 means that the compositor will automatically scale surface buffers by this amount when rendering. This is used for very high resolution displays where applications rendering at the native resolution would be too small to be legible.\n\nIt is intended that scaling aware clients track the current output of a surface, and if it is on a scaled output it should use wl_surface.set_buffer_scale with the scale of the output. That way the compositor can avoid scaling the surface, and the client can supply a higher detail image.\n\nThe scale event will be followed by a done event.\n\nName of this output\n\nMany compositors will assign user-friendly names to their outputs, show them to the user, allow the user to refer to an output, etc. The client may wish to know this name as well to offer the user similar behaviors.\n\nThe name is a UTF-8 string with no convention defined for its contents. Each name is unique among all wl_output globals. The name is only guaranteed to be unique for the compositor instance.\n\nThe same output name is used for all clients for a given wl_output global. Thus, the name can be shared across processes to refer to a specific wl_output global.\n\nThe name is not guaranteed to be persistent across sessions, thus cannot be used to reliably identify an output in e.g. configuration files.\n\nExamples of names include 'HDMI-A-1', 'WL-1', 'X11-1', etc. However, do not assume that the name is a reflection of an underlying DRM connector, X11 connection, etc.\n\nThe name event is sent after binding the output object. This event is only sent once per output object, and the name does not change over the lifetime of the wl_output global.\n\nCompositors may re-use the same output name if the wl_output global is destroyed and re-created later. Compositors should avoid re-using the same name if possible.\n\nThe name event will be followed by a done event.\n\nHuman-readable description of this output\n\nMany compositors can produce human-readable descriptions of their outputs. The client may wish to know this description as well, e.g. for output selection purposes.\n\nThe description is a UTF-8 string with no convention defined for its contents. The description is not guaranteed to be unique among all wl_output globals. Examples might include 'Foocorp 11\" Display' or 'Virtual X11 output via :1'.\n\nThe description event is sent after binding the output object and whenever the description changes. The description is optional, and may not be sent at all.\n\nThe description event will be followed by a done event.\n\nGive a surface the role sub-surface\n\nCreate a sub-surface interface for the given surface, and associate it with the given parent surface. This turns a plain wl_surface into a sub-surface.\n\nThe to-be sub-surface must not already have another role, and it must not have an existing wl_subsurface object. Otherwise the bad_surface protocol error is raised.\n\nAdding sub-surfaces to a parent is a double-buffered operation on the parent (see wl_surface.commit). The effect of adding a sub-surface becomes visible on the next time the state of the parent surface is applied.\n\nThe parent surface must not be one of the child surface's descendants, and the parent must be different from the child surface, otherwise the bad_parent protocol error is raised.\n\nThis request modifies the behaviour of wl_surface.commit request on the sub-surface, see the documentation on wl_subsurface interface.\n\nReposition the sub-surface\n\nThis schedules a sub-surface position change. The sub-surface will be moved so that its origin (top left corner pixel) will be at the location x, y of the parent surface coordinate system. The coordinates are not restricted to the parent surface area. Negative values are allowed.\n\nThe scheduled coordinates will take effect whenever the state of the parent surface is applied. When this happens depends on whether the parent surface is in synchronized mode or not. See wl_subsurface.set_sync and wl_subsurface.set_desync for details.\n\nIf more than one set_position request is invoked by the client before the commit of the parent surface, the position of a new request always replaces the scheduled position from any previous request.\n\nThe initial position is 0, 0.\n\nRestack the sub-surface\n\nThis sub-surface is taken from the stack, and put back just above the reference surface, changing the z-order of the sub-surfaces. The reference surface must be one of the sibling surfaces, or the parent surface. Using any other surface, including this sub-surface, will cause a protocol error.\n\nThe z-order is double-buffered. Requests are handled in order and applied immediately to a pending state. The final pending state is copied to the active state the next time the state of the parent surface is applied. When this happens depends on whether the parent surface is in synchronized mode or not. See wl_subsurface.set_sync and wl_subsurface.set_desync for details.\n\nA new sub-surface is initially added as the top-most in the stack of its siblings and parent.\n\nSet sub-surface to desynchronized mode\n\nChange the commit behaviour of the sub-surface to desynchronized mode, also described as independent or freely running mode.\n\nIn desynchronized mode, wl_surface.commit on a sub-surface will apply the pending state directly, without caching, as happens normally with a wl_surface. Calling wl_surface.commit on the parent surface has no effect on the sub-surface's wl_surface state. This mode allows a sub-surface to be updated on its own.\n\nIf cached state exists when wl_surface.commit is called in desynchronized mode, the pending state is added to the cached state, and applied as a whole. This invalidates the cache.\n\nNote: even if a sub-surface is set to desynchronized, a parent sub-surface may override it to behave as synchronized. For details, see wl_subsurface.\n\nIf a surface's parent surface behaves as desynchronized, then the cached state is applied on set_desync."
    }
}