{
    "id": "dbpedia_45_3",
    "rank": 14,
    "data": {
        "url": "https://en.wikipedia.org/wiki/Wayland_(protocol)",
        "read_more_link": "",
        "language": "en",
        "title": "Wayland (protocol)",
        "top_image": "https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/Weston_10.0_screenshot.png/1200px-Weston_10.0_screenshot.png",
        "meta_img": "https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/Weston_10.0_screenshot.png/1200px-Weston_10.0_screenshot.png",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/99/Wayland_Logo.svg/100px-Wayland_Logo.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/13/Weston_10.0_screenshot.png/220px-Weston_10.0_screenshot.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a7/Wayland_display_server_protocol.svg/350px-Wayland_display_server_protocol.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/e/ea/Wayland_protocol_architecture.svg/350px-Wayland_protocol_architecture.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/2d/The_Linux_Graphics_Stack_and_glamor.svg/350px-The_Linux_Graphics_Stack_and_glamor.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/14/Window_%28windowing_system%29.svg/350px-Window_%28windowing_system%29.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/4/46/KDE_Plasma_5.24_on_Arch_Linux_screenshot.png/220px-KDE_Plasma_5.24_on_Arch_Linux_screenshot.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d8/Maynard_desktop.png/220px-Maynard_desktop.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/1/1b/Libinput_for_Wayland_compositors.svg/310px-Libinput_for_Wayland_compositors.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/36/PostmarketOS_and_Weston_compositor_running_on_Motorola_Moto_G.jpg/200px-PostmarketOS_and_Weston_compositor_running_on_Motorola_Moto_G.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/b/ba/Linux_graphics_drivers_DRI_Wayland.svg/350px-Linux_graphics_drivers_DRI_Wayland.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/3/31/Free_and_open-source_software_logo_%282009%29.svg/28px-Free_and_open-source_software_logo_%282009%29.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/df/Wikibooks-logo-en-noslogan.svg/40px-Wikibooks-logo-en-noslogan.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/7/7b/Freedesktop-logo-for-template.svg/150px-Freedesktop-logo-for-template.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2009-05-04T07:58:28+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/Wayland_(protocol)",
        "text": "Display system intended to replace X11\n\nWaylandOriginal author(s)Kristian HøgsbergDeveloper(s)freedesktop.org et al.Initial release30 September 2008; 15 years ago ( )[1]Stable release\n\nWayland: 1.23,[2] Weston: 13.0.3[3] / 30 May 2024; 2 months ago ( )\n\nRepositoryWritten inCOperating systemOfficial: Linux\n\nUnofficial: NetBSD, FreeBSD, OpenBSD, DragonFly BSD,[4] Haiku (operating system)[5]TypeLicenseMIT License[6][7][8]Websitewayland .freedesktop .org\n\nWayland is a communication protocol that specifies the communication between a display server and its clients, as well as a C library implementation of that protocol.[9] A display server using the Wayland protocol is called a Wayland compositor, because it additionally performs the task of a compositing window manager.\n\nWayland is developed by a group of volunteers initially led by Kristian Høgsberg as a free and open-source community-driven project with the aim of replacing the X Window System with a secure[10][11][12][13] and simpler windowing system for Linux and other Unix-like operating systems.[9][14] The project's source code is published under the terms of the MIT License, a permissive free software licence.[14][6]\n\nAs part of its efforts, the Wayland project also develops a reference implementation of a Wayland compositor called Weston.[9]\n\nOverview\n\n[edit]\n\nThe Wayland Display Server project was started by Red Hat developer Kristian Høgsberg in 2008.[15]\n\nBeginning around 2010, Linux desktop graphics have moved from having \"a pile of rendering interfaces... all talking to the X server, which is at the center of the universe\" towards putting the Linux kernel and its components (i.e. Direct Rendering Infrastructure (DRI), Direct Rendering Manager (DRM)) \"in the middle\", with \"window systems like X and Wayland ... off in the corner\". This will be \"a much-simplified graphics system offering more flexibility and better performance\".[16]\n\nHøgsberg could have added an extension to X as many recent projects have done, but preferred to \"[push] X out of the hotpath between clients and the hardware\" for reasons explained in the project's FAQ:[14]\n\nWhat's different now is that a lot of infrastructure has moved from the X server into the kernel (memory management, command scheduling, mode setting) or libraries (cairo, pixman, freetype, fontconfig, pango, etc.), and there is very little left that has to happen in a central server process. ... [An X server has] a tremendous amount of functionality that you must support to claim to speak the X protocol, yet nobody will ever use this. ... This includes code tables, glyph rasterization and caching, XLFDs (seriously, XLFDs!), and the entire core rendering API that lets you draw stippled lines, polygons, wide arcs and many more state-of-the-1980s style graphics primitives. For many things we've been able to keep the X.org server modern by adding extension such as XRandR, XRender and COMPOSITE ... With Wayland we can move the X server and all its legacy technology to an optional code path. Getting to a point where the X server is a compatibility option instead of the core rendering system will take a while, but we'll never get there if [we] don't plan for it.\n\nWayland consists of a protocol and a reference implementation named Weston. The project is also developing versions of GTK and Qt that render to Wayland instead of to X. Most applications are expected to gain support for Wayland through one of these libraries without modification to the application.\n\nInitial versions of Wayland have not provided network transparency, though Høgsberg noted in 2010 that network transparency is possible.[17] It was attempted as a Google Summer of Code project in 2011, but was not successful.[18] Adam Jackson has envisioned providing remote access to a Wayland application by either \"pixel-scraping\" (like VNC) or getting it to send a \"rendering command stream\" across the network (as in RDP, SPICE or X11).[19] As of early 2013, Høgsberg was experimenting with network transparency using a proxy Wayland server which sends compressed images to the real compositor.[20][21] In August 2017, GNOME saw the first such pixel-scraping VNC server implementation under Wayland.[22] In modern Wayland compositors, network transparency is handled in an xdg-desktop-portal implementation that implements the RemoteDesktop portal.\n\nMany Wayland compositors also include an xdg-desktop-portal implementation for common tasks such as a native file picker for native applications and sandboxes such as Flatpak (xdg-desktop-portal-gtk is commonly used as a fallback filepicker), screen recording, network transparency, screenshots, color picking, and other tasks that could be seen as needing user intervention and being security risks otherwise. Note that xdg-desktop-portal is not Flatpak or Wayland-specific, and can be used with alternative packaging systems and windowing systems.\n\nSoftware architecture\n\n[edit]\n\nProtocol architecture\n\n[edit]\n\nThe Wayland protocol follows a client–server model in which clients are the graphical applications requesting the display of pixel buffers on the screen, and the server (compositor) is the service provider controlling the display of these buffers.\n\nThe Wayland reference implementation has been designed as a two-layer protocol:[23]\n\nA low-level layer or wire protocol that handles the inter-process communication between the two involved processes‍—‌client and compositor‍—‌and the marshalling of the data that they interchange. This layer is message-based and usually implemented using the kernel IPC services, specifically Unix domain sockets in the case of Linux and other Unix-like operating systems.[24]\n\nA high-level layer built upon it, that handles the information that client and compositor need to exchange to implement the basic features of a window system. This layer is implemented as \"an asynchronous object-oriented protocol\".[25]\n\nWhile the low-level layer was written manually in C, the high-level layer is automatically generated from a description of the elements of the protocol stored in XML format.[26] Every time the protocol description of this XML file changes, the C source code that implements such protocol can be regenerated to include the new changes, allowing a very flexible, extensible and error-proof protocol.\n\nThe reference implementation of Wayland protocol is split in two libraries: a library to be used by Wayland clients called libwayland-client and a library to be used by Wayland compositors called libwayland-server.[27]\n\nProtocol overview\n\n[edit]\n\nThe Wayland protocol is described as an \"asynchronous object-oriented protocol\".[25] Object-oriented means that the services offered by the compositor are presented as a series of objects living on the same compositor. Each object implements an interface which has a name, a number of methods (called requests) as well as several associated events. Every request and event has zero or more arguments, each one with a name and a data type. The protocol is asynchronous in the sense that requests do not have to wait for synchronized replies or ACKs, avoiding round-trip delay time and achieving improved performance.\n\nThe Wayland clients can make a request (a method invocation) on some object if the object's interface supports that request. The client must also supply the required data for the arguments of such request. This is the way the clients request services from the compositor. The compositor in turn sends information back to the client by causing the object to emit events (probably with arguments too). These events can be emitted by the compositor as a response to a certain request, or asynchronously, subject to the occurrence of internal events (such as one from an input device) or state changes. The error conditions are also signaled as events by the compositor.[25]\n\nFor a client to be able to make a request to an object, it first needs to tell the server the ID number it will use to identify that object.[25] There are two types of objects in the compositor: global objects and non-global objects. Global objects are advertised by the compositor to the clients when they are created (and also when they are destroyed), while non-global objects are usually created by other objects that already exist as part of their functionality.[28]\n\nThe interfaces and their requests and events are the core elements that define the Wayland protocol. Each version of the protocol includes a set of interfaces, along with their requests and events, which are expected to be in any Wayland compositor. Optionally, a Wayland compositor may define and implement its own interfaces that support new requests and events, thereby extending functionality beyond the core protocol.[29] To facilitate changes to the protocol, each interface contains a \"version number\" attribute in addition to its name; this attribute allows for distinguishing variants of the same interface. Each Wayland compositor exposes not only what interfaces are available, but also the supported versions of those interfaces.[30]\n\nWayland core interfaces\n\n[edit]\n\nThe interfaces of the current version of Wayland protocol are defined in the file protocol/wayland.xml of the Wayland source code.[26] This is an XML file that lists the existing interfaces in the current version, along with their requests, events and other attributes. This set of interfaces is the minimum required to be implemented by any Wayland compositor.\n\nSome of the most basic interfaces of the Wayland protocol are:[29]\n\nwl_display – the core global object, a special object to encapsulate the Wayland protocol itself\n\nwl_registry – the global registry object, in which the compositor registers all the global objects that it wants to be available to all clients\n\nwl_compositor – an object that represents the compositor, and is in charge of combining the different surfaces into one output\n\nwl_surface – an object representing a rectangular area on the screen, defined by a location, size and pixel content\n\nwl_buffer – an object that, when attached to a wl_surface object, provides its displayable content\n\nwl_output – an object representing the displayable area of a screen\n\nwl_pointer, wl_keyboard, wl_touch – objects representing different input devices like pointers or keyboards\n\nwl_seat – an object representing a seat (a set of input/output devices) in multiseat configurations\n\nA typical Wayland client session starts by opening a connection to the compositor using the wl_display object. This is a special local object that represents the connection and does not live within the server. By using its interface the client can request the wl_registry global object from the compositor, where all the global object names live, and bind those that the client is interested in. Usually the client binds at least a wl_compositor object from where it will request one or more wl_surface objects to show the application output on the display.[28]\n\nWayland extension interfaces\n\n[edit]\n\nA Wayland compositor can define and export its own additional interfaces.[29] This feature is used to extend the protocol beyond the basic functionality provided by the core interfaces, and has become the standard way to implement Wayland protocol extensions. Certain compositors can choose to add custom interfaces to provide specialized or unique features. The Wayland reference compositor, Weston, used them to implement new experimental interfaces as a testbed for new concepts and ideas, some of which later became part of the core protocol (such as wl_subsurface interface added in Wayland 1.4[31]).\n\nExtension protocols to the core protocol\n\n[edit]\n\nXDG-Shell protocol\n\n[edit]\n\nXDG-Shell protocol (see freedesktop.org for XDG) is an extended way to manage surfaces under Wayland compositors (not only Weston). The traditional way to manipulate (maximize, minimize, fullscreen, etc.) surfaces is to use the wl_shell_*() functions, which are part of the core Wayland protocol and live in libwayland-client. An implementation of the xdg-shell protocol, on the contrary, is supposed to be provided by the Wayland compositor. So you will find the xdg-shell-client-protocol.h header in the Weston source tree.\n\nxdg_shell is a protocol aimed to substitute wl_shell in the long term, but will not be part of the Wayland core protocol. It starts as a non-stable API, aimed to be used as a development place at first, and once features are defined as required by several desktop shells, it can be finally made stable. It provides mainly two new interfaces: xdg_surface and xdg_popup. The xdg_surface interface implements a desktop-style window that can be moved, resized, maximized, etc.; it provides a request for creating child/parent relationship. The xdg_popup interface implements a desktop-style popup/menu; an xdg_popup is always transient for another surface, and also has implicit grab.[32]\n\nIVI-Shell protocol\n\n[edit]\n\nIVI-Shell is an extension to the Wayland core protocol, targeting in-vehicle infotainment (IVI) devices.[33]\n\nRendering model\n\n[edit]\n\nThe Wayland protocol does not include a rendering API.[34][14][35][36]: 2 Instead, Wayland follows a direct rendering model, in which the client must render the window contents to a buffer shareable with the compositor.[37] For that purpose, the client can choose to do all the rendering by itself, use a rendering library like Cairo or OpenGL, or rely on the rendering engine of high-level widget libraries with Wayland support, such as Qt or GTK. The client can also optionally use other specialized libraries to perform specific tasks, such as Freetype for font rendering.\n\nThe resulting buffer with the rendered window contents are stored in a wl_buffer object. The internal type of this object is implementation dependent. The only requirement is that the content data must be shareable between the client and the compositor. If the client uses a software (CPU) renderer and the result is stored in the system memory, then client and compositor can use shared memory to implement the buffer communication without extra copies. The Wayland protocol already natively provides this kind of shared memory buffer through the wl_shm[38] and wl_shm_pool[39] interfaces. The drawback of this method is that the compositor may need to do additional work (usually to copy the shared data to the GPU) to display it, which leads to slower graphics performance.\n\nThe most typical case is for the client to render directly into a video memory buffer using a hardware (GPU) accelerated API such as OpenGL, OpenGL ES or Vulkan. Client and compositor can share this GPU-space buffer using a special handler to reference it.[40] This method allows the compositor to avoid the extra data copy through itself of the main memory buffer client-to-compositor-to-GPU method, resulting in faster graphics performance, and is therefore the preferred one. The compositor can further optimize the composition of the final scene to be shown on the display by using the same hardware acceleration API as an API client.\n\nWhen rendering is completed in a shared buffer, the Wayland client should instruct the compositor to present the rendered contents of the buffer on the display. For this purpose, the client binds the buffer object that stores the rendered contents to the surface object, and sends a \"commit\" request to the surface, transferring the effective control of the buffer to the compositor.[23] Then the client waits for the compositor to release the buffer (signaled by an event) if it wants to reuse the buffer to render another frame, or it can use another buffer to render the new frame, and, when the rendering is finished, bind this new buffer to the surface and commit its contents.[41]: 7 The procedure used for rendering, including the number of buffers involved and their management, is entirely under the client control.[41]: 7\n\nComparison with other window systems\n\n[edit]\n\nSee also: Mir software architecture\n\nDifferences between Wayland and X\n\n[edit]\n\nThere are several differences between Wayland and X with regard to performance, code maintainability, and security:[42]\n\nArchitecture\n\nThe composition manager is a separate, additional feature in X, while Wayland merges display server and compositor as a single function.[43][35] Also, it incorporates some of the tasks of the window manager, which in X is a separate client-side process.[44]\n\nCompositing\n\nCompositing is optional in X, but mandatory in Wayland. Compositing in X is \"active\"; that is, the compositor must fetch all pixel data, which introduces latency. In Wayland, compositing is \"passive\", which means the compositor receives pixel data directly from clients.[45]: 8–11\n\nRendering\n\nThe X server itself is able to perform rendering, although it can also be instructed to display a rendered window sent by a client. In contrast, Wayland does not expose any API for rendering, but delegates to clients such tasks (including the rendering of fonts, widgets, etc.).[43][35] Window decorations are to be rendered on the client side (e.g., by a graphics toolkit), or on the server side (by the compositor) with the opt-in xdg-decoration protocol, if the compositor chooses to implement such functionality.[46]\n\nSecurity\n\nWayland isolates the input and output of every window, achieving confidentiality, integrity and availability for both. The original X design lacked these important security features,[11][12][13] although some extensions have been developed trying to mitigate it.[47][48][49] Also, with the vast majority of the code running in the client, less code needs to run with root privileges, improving security,[11] although multiple popular Linux distributions now allow the X server to be run without root privileges.[50][51][52][53]\n\nInter-process communication\n\nThe X server provides a basic communication method between X clients, later extended by ICCCM conventions. This X client-to-client communication is used by window managers and also to implement X sessions, selections and drag-and-drop, and other features. The Wayland core protocol does not support communication between Wayland clients at all as the corresponding functionality (if needed) is regarded by the Wayland community as something which should be implemented by the desktop environments (like KDE or GNOME), or by a third party (for example, by using native IPC of the underlying operating system).\n\nNetworking\n\nThe X Window System is an architecture that was designed at its core to run over a network. Wayland does not offer network transparency by itself;[14] however, a compositor can implement any remote desktop protocol to achieve remote display. In addition, there is research into Wayland image streaming and compression that would provide remote frame buffer access similar to that of VNC.[21]\n\nCompatibility with X\n\n[edit]\n\nXWayland is an X Server running as a Wayland client, and thus is capable of displaying native X11 client applications in a Wayland compositor environment.[54] This is similar to the way XQuartz runs X applications in macOS's native windowing system. The goal of XWayland is to facilitate the transition from X Window System to Wayland environments, providing a way to run unported applications in the meantime. XWayland was mainlined into X.Org Server version 1.16.[55]\n\nWidget toolkits such as Qt5 and GTK3 can switch their graphical back-end at run time,[56] allowing users to choose at load time whether they want to run the application over X or over Wayland. Qt 5 provides the -platform command-line option[57] to that effect, whereas GTK 3 lets users select the desired GDK back-end by setting the GDK_BACKEND Unix environment variable.[56][58]\n\nWayland compositors\n\n[edit]\n\nMain article: List of Wayland compositors\n\nDisplay servers that implement the Wayland display server protocol are also called Wayland compositors because they additionally perform the task of a compositing window manager.\n\nHyprland – a wlroots-based tiling Wayland compositor written in C++. Noteworthy features of Hyprland include dynamic tiling, tabbed windows, a clean and readable C++ code-base, and a custom renderer that provides window animations, rounded corners, and Dual-Kawase Blur on transparent windows.[59][60]\n\nWeston – the reference implementation of a Wayland compositor; Weston implements client side decorations\n\nEnlightenment claimed full Wayland support since version 0.20[61] but work is currently underway to land a complete Wayland compositor[62]\n\nKWin has nearly complete Wayland support as of 2021[63]\n\nMutter maintained a separate branch for the integration of Wayland for GNOME 3.9 (in September 2013);[64] in the 3.13.1 release in 2014, the Wayland branch was merged into the main repository.[65]\n\nClayland – a simple example Wayland compositor using Clutter\n\nSway – a tiling Wayland compositor and a drop-in replacement for the i3 window manager for X11.[66] Sway uses wlroots – a modular Wayland implementation that functions as a base for several compositors.[67][68]\n\nWeston\n\n[edit]\n\nWeston is the reference implementation of a Wayland compositor[69] also developed by the Wayland project. It is written in C and published under the MIT License. Weston has official support for only the Linux operating system due to Weston's dependence on certain features of the Linux kernel, such as kernel mode-setting, Graphics Execution Manager (GEM), and udev, which have not been implemented in other Unix-like operating systems.[70] When running on Linux, handling of the input hardware relies on evdev, while the handling of buffers relies on Generic Buffer Management (GBM). However, in 2013 a prototype port of Weston to FreeBSD was announced.[71]\n\nWeston supports High-bandwidth Digital Content Protection (HDCP).[72]\n\nWeston relies on GEM to share application buffers between the compositor and applications. It contains a plug-in system of \"shells\" for common desktop features like docks and panels.[21] Clients are responsible for the drawing of their window borders and their decorations. For rendering, Weston can use OpenGL ES[73] or the pixman library to do software rendering.[74] The full OpenGL implementation is not used, because on most current systems, installing the full OpenGL libraries would also install GLX and other X Window System support libraries as dependencies.[75]\n\nA remote access interface for Weston was proposed in October 2013 by a RealVNC employee.[76]\n\nMaynard\n\n[edit]\n\nMaynard is a graphical shell and has been written as a plug-in for Weston, just as the GNOME Shell has been written as a plug-in to Mutter.[77]\n\nThe Raspberry Pi Foundation in collaboration with Collabora released Maynard and work on improving performance and memory consumption.[78][79]\n\nlibinput\n\n[edit]\n\nThe Weston code for handling input devices (keyboards, pointers, touch screens, etc.) was split into its own separate library, called libinput, for which support was first merged in Weston 1.5.[80][81]\n\nLibinput handles input devices for multiple Wayland compositors and also provides a generic X.Org Server input driver. It aims to provide one implementation for multiple Wayland compositors with a common way to handle input events while minimizing the amount of custom input code compositors need to include. libinput provides device detection[clarification needed] (via udev), device handling, input device event processing and abstraction.[82][83]\n\nVersion 1.0 of libinput followed version 0.21, and included support for tablets, button sets and touchpad gestures. This version will maintain stable API/ABI.[84]\n\nAs GNOME/GTK and KDE Frameworks 5[85] have mainlined the required changes, Fedora 22 will replace X.Org's evdev and Synaptics drivers with libinput.[86]\n\nWith version 1.16, the X.Org Server obtained support for the libinput library in form of a wrapper called xf86-input-libinput.[87][88]\n\nWayland Security Module\n\n[edit]\n\nWayland Security Module is a proposition that resembles the Linux Security Module interface found in the Linux kernel.[89]\n\nSome applications (especially the ones related to accessibility) require privileged capabilities that should work across different Wayland compositors. Currently,[when?] applications under Wayland are generally unable to perform any sensitive tasks such as taking screenshots or injecting input events without going through xdg-desktop-portal or obtaining privileged access to the system.\n\nWayland Security Module is a way to delegate security decisions within the compositor to a centralized security decision engine.[89]\n\nAdoption\n\n[edit]\n\nThe Wayland protocol is designed to be simple so that additional protocols and interfaces need to be defined and implemented to achieve a holistic windowing system. As of July 2014 these additional interfaces were being worked on. So, while the toolkits already fully support Wayland, the developers of the graphical shells are cooperating with the Wayland developers creating the necessary additional interfaces.\n\nDesktop Linux distributions\n\n[edit]\n\nAs of 2020 most Linux distributions support Wayland out of the box. Some notable examples are:\n\nFedora starting with version 25 (released 22 November 2016) uses Wayland for the default GNOME 3.22 desktop session, with X.Org as a fallback if the graphics driver cannot support Wayland.[90] Fedora uses Wayland as the default for KDE desktop session starting with version 34 (released 27 April 2021)\n\nUbuntu shipped with Wayland by default in Ubuntu 17.10 (Artful Aardvark).[91] However, Ubuntu 18.04 LTS reverted to X.Org by default due to several issues.[92][93] Since Ubuntu 21.04, Wayland is the default again.[94]\n\nRed Hat Enterprise Linux ships Wayland as the default session in version 8, released 7 May 2019.[95]\n\nDebian ships Wayland as the default session for GNOME since version 10, released 6 July 2019.[96]\n\nSlackware Linux included Wayland on 20 February 2020[97] for the development version, -current, which became version 15.0.\n\nManjaro ships Wayland as default in the Gnome edition of Manjaro 20.2 (Nibia) (released 22 November 2020).[98]\n\nNotable early adopter:\n\nRebeccaBlackOS is a live USB Debian-based[99] Linux distribution that allows a convenient way to try out a real Wayland desktop without having to make any modifications to the main operating system of the computer.[100] It has been used since as early as 2012 to showcase Wayland.[101][102]\n\nToolkit support\n\n[edit]\n\nToolkits supporting Wayland include the following:\n\nClutter has complete Wayland support.[103][104][105]\n\nEFL has complete Wayland support, except for selection.[106]\n\nGTK 3.20 has complete Wayland support.[107]\n\nQt 5 has complete Wayland support, and can be used to write both Wayland compositors and Wayland clients.\n\nSDL support for Wayland debuted with the 2.0.2 release[108] and was enabled by default since version 2.0.4.[109]\n\nGLFW 3.2 has Wayland support.[110]\n\nFreeGLUT has initial Wayland support.[111]\n\nDesktop environments\n\n[edit]\n\nDesktop environments in the process of being ported from X to Wayland include GNOME,[112] KDE Plasma 6[113] and Enlightenment.[114]\n\nIn November 2015, Enlightenment e20 was announced with full Wayland support.[115][61][116] GNOME 3.20 was the first version to have a full Wayland session.[117] GNOME 3.22 included much improved Wayland support across GTK, Mutter, and GNOME Shell.[118] GNOME 3.24 shipped support for the proprietary Nvidia drivers under Wayland.[119]\n\nWayland support for KDE Plasma was delayed until the release of Plasma 5,[120] though previously KWin 4.11 got an experimental Wayland support.[121] The version 5.4 of Plasma was the first with a Wayland session.[122] During 2020 Klipper was ported to Wayland and Plasma 5.20, released in October 2020, improved screen casting and recording.[123][124] In Plasma 6, the default graphical session that uses Wayland was set as the default, making the X11 session secondary.[125]\n\nOther software\n\n[edit]\n\nOther software supporting Wayland includes the following:\n\nIntelligent Input Bus is working on Wayland support, it could be ready for Fedora 22.[126]\n\nRealVNC published a Wayland developer preview in July 2014.[76][127][128]\n\nwayvnc is a VNC server for wlroots-based Wayland compositors.\n\nMaliit is an input method framework that runs under Wayland.[129][130][131]\n\nkmscon supports Wayland with wlterm.[132]\n\nMesa has Wayland support integrated.[133]\n\nEclipse was made to run on Wayland during a GSoC-Project in 2014.[134]\n\nThe Vulkan WSI (Window System Interface) is a set of API calls that serve a similar purpose as EGL does for OpenGL & OpenGL ES or GLX for OpenGL on X11. Vulkan WSI includes support for Wayland from day one: VK_USE_PLATFORM_WAYLAND_KHR. Vulkan clients can run on unmodified Wayland servers, including Weston, GENIVI LayerManager, Mutter / GNOME Shell, Enlightenment, and more. The WSI allows applications to discover the different GPUs on the system, and display the results of GPU rendering to a window system.[135]\n\nWaydroid (formerly called Anbox-Halium), a container for Android applications to run on Linux distributions using Wayland.\n\nMobile and embedded hardware\n\n[edit]\n\nMobile and embedded hardware supporting Wayland includes the following:\n\npostmarketOS\n\nGENIVI Alliance: The GENIVI Aliance, now COVESA, for in-vehicle infotainment (IVI) supports Wayland.[136]\n\nRaspberry Pi: The Raspberry Pi Foundation in collaboration with Collabora released Maynard and work on improving performance and memory consumption.[78][79]\n\nJolla: Smartphones from Jolla use Wayland. It is also used as standard when Linux Sailfish OS is used with hardware from other vendors or when it is installed into Android devices by users.[137][138][139]\n\nTizen: Tizen up to 2.x supports Wayland in in-vehicle infotainment (IVI) setups[140] and from 3.0 onward defaults to Wayland.[141][142]\n\nHistory\n\n[edit]\n\nKristian Høgsberg, a Linux graphics and X.Org developer who previously worked on AIGLX and DRI2, started Wayland as a spare-time project in 2008 while working for Red Hat.[143][144][145][146] His stated goal was a system in which \"every frame is perfect, by which I mean that applications will be able to control the rendering enough that we'll never see tearing, lag, redrawing or flicker.\" Høgsberg was driving through the town of Wayland, Massachusetts when the underlying concepts \"crystallized\", hence the name (Weston and Maynard are also nearby towns in the same area, continuing the reference).[145][147]\n\nIn October 2010, Wayland became a freedesktop.org project.[148][149] As part of the migration the prior Google Group was replaced by the wayland-devel mailing list as the project's central point of discussion and development.\n\nThe Wayland client and server libraries were initially released under the MIT License,[150] while the reference compositor Weston and some example clients used the GNU General Public License version 2.[151] Later all the GPL code was relicensed under the MIT license \"to make it easier to move code between the reference implementation and the actual libraries\".[152] In 2015 it was discovered that the license text used by Wayland was a slightly different and older version of the MIT license, and the license text was updated to the current version used by the X.Org project (known as MIT Expat License).[6]\n\nWayland works with all Mesa-compatible drivers with DRI2 support[133] as well as Android drivers via the Hybris project.[153][154][155]\n\nReleases\n\n[edit]\n\nMajor Wayland and Weston releases[156] Version Date Main features Wayland Weston Wayland Protocols Old version, no longer maintained: 0.85 9 February 2012[157] First release. Old version, no longer maintained: 0.95 24 July 2012[158] Began API stabilization. Old version, no longer maintained: 1.0 22 October 2012[159][160] Stable wayland-client API. Old version, no longer maintained: 1.1 15 April 2013[161][162] Software rendering.[74] FBDEV, RDP backends. Old version, no longer maintained: 1.2 12 July 2013[163][164] Stable wayland-server API. Color management. Subsurfaces. Raspberry Pi backend. Old version, no longer maintained: 1.3 11 October 2013[165] More pixel formats. Support for language bindings. Android driver support via libhybris. Old version, no longer maintained: 1.4 23 January 2014[31] New wl_subcompositor and wl_subsurface interfaces. Multiple framebuffer formats. logind support for rootless Weston. Old version, no longer maintained: 1.5 20 May 2014[80] libinput. Fullscreen shell. Old version, no longer maintained: 1.6 19 September 2014[166] libinput by default. Old version, no longer maintained: 1.7 14 February 2015[167][168] Support for the Wayland presentation extension and for surface roles. IVI shell protocol. Old version, no longer maintained: 1.8 2 June 2015[169][170] Separated headers for core and generated protocol. Repaint scheduling. Named outputs. Output transformations. Surface-shooting API. Old version, no longer maintained: 1.9 21 September 2015[171][172] Updated license. Updated license. New test framework. Triple-head DRM compositor. linux_dmabuf extension. 1.0 (2015-11-24)[173] Old version, no longer maintained: 1.10 17 February 2016[174][175] Drag-and-drop functionality, grouped pointer events.[176] Video 4 Linux 2, touch input, debugging improvements.[177] 1.1 (2016-02-16)[178]\n\n1.4 (201-05-23)[179] Old version, no longer maintained: 1.11 1 June 2016[180][181] New backup loading routine, new setup logic. Proxy wrappers, shared memory changes, Doxygen-generated HTML docs. 1.5 (2016-07-22)[182]\n\n1.7 (2016-08-15)[183] Old version, no longer maintained: 1.12 21 September 2016[184][185] Debugging support improved. libweston and libweston-desktop. Pointer locking and confinement. Relative pointer support. Old version, no longer maintained: 1.13 24 February 2017[186] The ABI of Weston has been changed, thus the new version was named 2.0.0[187] rather than 1.13.0. 1.8 (2017-06-12)\n\n1.10 (2017-07-31)[188] Old version, no longer maintained: 1.14 8 August 2017[189] Weston 3.0.0[190] was released at the same time. 1.11 (2017-10-11)[191]\n\n1.13 (2018-02-14)[192] Old version, no longer maintained: 1.15 9 April 2018[193] Weston 4.0.0[194] was released at the same time. 1.14 (2018-05-07)[195]\n\n1.16 (2018-07-30)[196] Old version, no longer maintained: 1.16 24 August 2018[197] Weston 5.0.0[198] was released at the same time. 1.17 (2018-11-12)[199] Old version, no longer maintained: 1.17 20 March 2019[200] Weston 6.0.0[201] was released at the same time. 1.18 (2019-07-25)[202] Old version, no longer maintained: 1.18 11 February 2020[203] Weston 7.0.0[204] was released on 2019-08-23.\n\nWeston 8.0.0[205] was released on 2020-01-24.\n\nWeston 9.0.0[206] was released on 2020-09-04. 1.19 (2020-02-29)[207]\n\n1.20 (2020-02-29)[208] Old version, no longer maintained: 1.19 27 January 2021[209] 1.21 (2021-04-30)[210]\n\n1.24 (2021-11-23)[211] Old version, no longer maintained: 1.20 9 December 2021[212] Weston 10.0.0[213] was released on 2022-02-01.\n\nWeston 10.0.5[214] was released on 2023-08-02. 1.25 (2022-01-28)[215] Old version, no longer maintained: 1.21 30 June 2022[216] Weston 11.0.0[217] was released on 2022-09-22.\n\nWeston 11.0.3[218] was released on 2023-08-02. 1.26 (2022-07-07)[219]\n\n1.31 (2022-11-29)[220] Old version, no longer maintained: 1.22 4 April 2023[221] Weston 12.0.0[222] was released on 2023-05-17.\n\nWeston 12.0.4[223] was released on 2024-04-23.\n\nWeston 13.0.0[224] was released on 2023-11-27.\n\nWeston 13.0.3[3] was released on 2024-06-05. 1.32 (2023-07-03)[225]\n\n1.36 (2024-04-26)[226] Current stable version: 1.23 30 May 2024[2] Future release: 1.24\n\nLegend:\n\nOld version\n\nOlder version, still maintained\n\nLatest version\n\nLatest preview version\n\nFuture release\n\nSee also\n\n[edit]\n\nFree and open-source software portal\n\nMir (software)\n\nX Window System\n\nReferences\n\n[edit]"
    }
}