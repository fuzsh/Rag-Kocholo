{
    "id": "dbpedia_5008_1",
    "rank": 69,
    "data": {
        "url": "https://www.wireshark.org/docs/wsdg_html_chunked/ChUIQt.html",
        "read_more_link": "",
        "language": "en",
        "title": "12.2. The Qt Application Framework",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.wireshark.org/docs/wsdg_html_chunked/images/note.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "12.2.1. User Experience Considerations\n\nWhen creating or modifying Wireshark try to make sure that it will work well on Windows, macOS, and Linux. See Section 12.3, “Human Interface Reference Documents” for details. Additionally, try to keep the following in mind:\n\nWorkflow. Excessive navigation and gratuitous dialogs should be avoided or reduced. For example, compared to the legacy UI many alert dialogs have been replaced with status bar messages. Statistics dialogs are displayed immediately instead of requiring that options be specified.\n\nDiscoverability and feedback. Most users don’t like to read documentation and instead prefer to learn an application as they use it. Providing feedback increases your sense of control and awareness, and makes the application more enjoyable to use. Most of the Qt dialogs provide a “hint” area near the bottom which shows useful information. For example, the “Follow Stream” dialog shows the packet corresponding to the text under the mouse. The profile management dialog shows a clickable path to the current profile. The main welcome screen shows live interface traffic. Most dialogs have a context menu that shows keyboard shortcuts.\n\n12.2.2. Qt Creator\n\nQt Creator is a full-featured IDE and user interface editor. It makes adding new UI features much easier. It doesn’t work well on Windows at the present time, so it’s recommended that you use it on macOS or Linux.\n\nTo edit and build Wireshark using Qt Creator, open the top-level CMakeLists.txt within Qt Creator. It should ask you to choose a build location. Do so. It should then ask you to run CMake. Fill in any desired build arguments (e.g. -D CMAKE_BUILD_TYPE=Debug or -D ENABLE_CCACHE=ON) and click the Run CMake button. When that completes select Build → Open Build and Run Kit Selector…​ and make sure wireshark is selected.\n\nNote that Qt Creator uses output created by CMake’s “CodeBlocks” generator. If you run CMake outside of Qt Creator you should use the “CodeBlocks - Unix Makefiles” generator, otherwise Qt Creator will prompt you to re-run CMake.\n\n12.2.4. Coding Practices and Naming Conventions\n\n12.2.4.1. Names\n\nThe code in ui/qt directory uses three APIs: Qt (which uses upper camel case), GLib (which uses snake_case), and the Wireshark API (which also uses snake_case).\n\nAs a general rule, for names, Wireshark’s Qt code:\n\nuses upper camel case, in which words in the name are not separated by underscores, and the first letter of each word is capitalized, for classes, for example, PacketList;\n\nuses lower camel case, in which words in the name are not separated by underscores, and the first letter of each word other than the first word is capitalized, for methods, for example, resetColumns;\n\nuses snake case, in which words in the name are separated by underscores, and the first letter of the word is not capitalized, for variables, with a trailing underscore used for member variables, for example, packet_list_model_.\n\n12.2.4.2. Dialogs\n\nDialogs that work with capture file information shouldn’t close just because the capture file closes. Subclassing WiresharkDialog as described above can make it easier to persist across capture files.\n\nWhen you create a window with a row of standard “OK” and “Close” buttons at the bottom using Qt Creator you will end up with a subclass of QDialog. This is fine for traditional modal dialogs, but many times the “dialog” needs to behave like a QWindow instead.\n\nModal dialogs should be constructed with QDialog(parent). Modeless dialogs (windows) should be constructed with QDialog(NULL, Qt::Window). Other combinations (particularly QDialog(parent, Qt::Window)) can lead to odd and inconsistent behavior. Again, subclassing WiresharkDialog will take care of this for you.\n\nMost of the dialogs in ui/qt share many similarities, including method names, widget names, and behavior. Most dialogs should have the following, although it’s not strictly required:\n\nAn updateWidgets() method, which enables and disables widgets depending on the current state and constraints of the dialog. For example, the Coloring Rules dialog disables the Save button if the user has entered an invalid display filter.\n\nA hintLabel() widget subclassed from QLabel or ElidedLabel, placed just above the dialog button box. The hint label provides guidance and feedback to the user.\n\nA context menu (ctx_menu_) for additional actions not present in the button box.\n\nIf the dialog box contains a QTreeWidget you might want to add your own QTreeWidgetItem subclass with the following methods:\n\ndrawData()\n\nDraws column data with any needed formatting.\n\ncolData()\n\nReturns the data for each column as a QVariant. Used for copying as CSV, YAML, etc.\n\noperator<()\n\nAllows sorting columns based on their raw data.\n\n12.2.4.3. Strings\n\nWireshark’s C code and GLib use UTF-8 encoded character arrays. Qt (specifically QString) uses UTF-16. You can convert a char * to a QString using simple assignment. You can convert a QString to a const char * using qUtf8Printable.\n\nIf you’re using GLib string functions or plain old C character array idioms in Qt-only code you’re probably doing something wrong, particularly if you’re manually allocating and releasing memory. QStrings are generally much safer and easier to use. They also make translations easier.\n\nIf you need to pass strings between Qt and GLib you can use a number of convenience routines which are defined in ui/qt/utils/qt_ui_utils.h.\n\nIf you’re calling a function that returns wmem-allocated memory it might make more sense to add a wrapper function to qt_ui_utils than to call wmem_free in your code.\n\n12.2.4.4. Mixing C and C++\n\nSometimes we have to call C++ functions from one of Wireshark’s C callbacks and pass C++ objects to or from C. Tap listeners are a common example. The C++ FAQ describes how to do this safely.\n\nTapping usually involves declaring static methods for callbacks, passing this as the tap data.\n\n12.2.4.5. Internationalization and Translation\n\nQt provides a convenient method for translating text: Qobject::tr(), usually available as tr().\n\nHowever, please avoid using tr() for static strings and define them in *.ui files instead. tr() on manually created objects like QMenu are not automatically retranslated and must instead be manually translated using changeEvent() and retranslateUi(). See ui/qt/wireshark_main_window.cpp for an example of this.\n\nIn most cases you should handle the changeEvent in order to catch QEvent::LanguageChange.\n\nQt makes translating the Wireshark UI into different languages easy. To add a new translation, do the following:\n\nAdd your translation (ui/qt/wireshark_XX.ts) to ui/qt/CMakeLists.txt\n\n(Recommended) Add a flag image for your language in resources/languages/XX.svg. Update resources/languages/languages.qrc accordingly.\n\nRun lupdate ui/qt -ts ui/qt/wireshark_XX.ts to generate/update your translation file.\n\nAdd ui/qt/wireshark_XX.ts to .tx/config.\n\nTranslate with Qt Linguist: linguist ui/qt/wireshark_XX.ts.\n\nDo a test build and make sure the generated wireshark_XX.qm binary file is included.\n\nPush your translation to GitLab for review. See Section 3.10, “Contribute Your Changes” for details.\n\nAlternatively you can put your QM and flag files in the languages directory in the Wireshark user configuration directory ($XDG_CONFIG_HOME/wireshark/languages/ or $HOME/.wireshark/languages/ on UNIX).\n\nFor more information about Qt Linguist see its manual.\n\nYou can also manage translations online with Transifex. Translation resources are organized by type of translation and development branch:\n\nmaster\n\nQt Linguist resources in the ui/qt in the master branch.\n\ndebian\n\nGNU gettext resources in the debian directory in the master branch.\n\nqt-XY, master-XY\n\nQt Linguist resources in the ui/qt in the X.Y release branch. For example, qt-34 matches the Wireshark 3.2 release branch.\n\npo-XY, debian-XY\n\nGNU gettext (.po) resources in the debian directory in the X.Y release branch. For example, po-34 matches the Wireshark 3.4 release branch.\n\nEach week translations are automatically synchronized with the source code through the following steps:\n\nPull changes from Transifex by running tx pull -f.\n\nRun lupdate on the ts files.\n\nPush and commit on GitLab.\n\nPush changes to Transifex by running tx push.\n\n12.2.4.6. Colors And Themes\n\nQt provides a number of colors via the QPalette class. Use this class when you need a standard color provided by the underlying operating system.\n\nWireshark uses an extended version of the Tango Color Palette for many interface elements that require custom colors. This includes the I/O graphs, sequence diagrams, and RTP streams. Please use this palette (defined in tango_colors.h and the ColorUtils class) if QPalette doesn’t meet your needs.\n\nWireshark supports dark themes (aka “dark mode”) on some platforms. We leverage Qt’s dark theme support when possible, but have implemented our own support and workarounds in some cases. You can ensure that your code includes proper dark theme support by doing the following:\n\nYou can use a macOS-style template icon by creating a monochrome SVG document with “.template” appended to the name, e.g. resources/stock_icons/24x24/edit-find.template.svg.\n\nQt draws unvisited links Qt::blue no matter what. You can work around this by using ColorUtils::themeLinkBrush() and ColorUtils::themeLinkStyle().\n\nYou can catch dark and light mode changes by handling QEvent::ApplicationPaletteChange."
    }
}