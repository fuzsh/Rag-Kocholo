{
    "id": "dbpedia_5008_2",
    "rank": 88,
    "data": {
        "url": "https://blog.logrocket.com/build-desktop-app-qt-rust/",
        "read_more_link": "",
        "language": "en",
        "title": "Build a desktop app with Qt and Rust",
        "top_image": "https://blog.logrocket.com/wp-content/uploads/2023/05/build-desktop-app-qt-rust-nocdn.png",
        "meta_img": "https://blog.logrocket.com/wp-content/uploads/2023/05/build-desktop-app-qt-rust-nocdn.png",
        "images": [
            "https://blog.logrocket.com/wp-content/themes/logrocket/assets/logrocket-logo.png",
            "https://blog.logrocket.com/wp-content/uploads/2023/03/azzam-s-a.jpg?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2023/12/GalileoAIPreview.png",
            "https://blog.logrocket.com/wp-content/uploads/2023/05/build-desktop-app-qt-rust-nocdn.png",
            "https://blog.logrocket.com/wp-content/uploads/2023/05/rust-qt-hello-world-application.gif",
            "https://blog.logrocket.com/wp-content/uploads/2023/07/Screen-Shot-2023-07-06-at-7.44.15-AM.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/08/rocket-button-icon.png",
            "https://blog.logrocket.com/wp-content/uploads/2023/05/rust-qt-app-caesar-cipher-encryption.gif",
            "https://blog.logrocket.com/wp-content/uploads/2023/05/rust-qt-app-nrot-encryption.gif",
            "https://blog.logrocket.com/wp-content/uploads/2023/05/rust-qt-app-on-the-fly-encryption.gif",
            "https://blog.logrocket.com/wp-content/uploads/2023/05/rust-qt-app-decryption.gif",
            "https://blog.logrocket.com/wp-content/uploads/2017/03/1d0cd-1s_rmyo6nbrasp-xtvbaxfg.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/06/footer-cta-dots-left.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/06/footer-cta-dots-right.png",
            "https://blog.logrocket.com/wp-content/uploads/2022/09/logrocket-logo-frontend-analytics.png",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Optimizing-CSS-time-based-animations-new-CSS-functions.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2022/05/emanuel-odioko.png?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/understanding-optimistic-ui-react-useoptimistic-hook.png?w=420",
            "https://secure.gravatar.com/avatar/8b234f3a926fc733e09ed4c0eaa904d2?s=50&d=mm&r=g",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Exploring-Pragmatic-drag-drop-library-comprehensive-guide.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2022/07/rishi-purwar.png?w=150&h=150&crop=1",
            "https://blog.logrocket.com/wp-content/uploads/2024/08/Using-rehackt-share-imports-react-server-side-nextjs-code.png?w=420",
            "https://blog.logrocket.com/wp-content/uploads/2021/12/unnamed.jpg?w=150&h=150&crop=1",
            "https://secure.gravatar.com/avatar/bd65a159fba18be20f64ba483b0ddad6?s=36&d=mm&r=g"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Azzam S.A"
        ],
        "publish_date": "2023-05-11T16:00:38+00:00",
        "summary": "",
        "meta_description": "We demonstrate how to build a desktop Qt application using Rust and QML, add encryption, and create a GitHub CI workflow.",
        "meta_lang": "",
        "meta_favicon": "https://blog.logrocket.com/wp-content/uploads/2019/06/cropped-cropped-favicon-196x196.png?w=32",
        "meta_site_name": "LogRocket Blog",
        "canonical_link": "https://blog.logrocket.com/build-desktop-app-qt-rust/",
        "text": "The rise of progressive web applications has resulted in a commensurate increase in the number of desktop apps that are released every day. To see evidence of this, just go to Flathub’s new apps page or GitHub’s trending page. For example, immediately after the release of the ChatGPT API, hundreds of desktop applications emerged. Desktop apps are native, fast, and secure and provide experiences that web applications can’t match.\n\ncmOf all the programming languages used in desktop app development, Rust is one of the more popular. Rust is widely regarded as being reliable, performant, productive, and versatile. In fact, many organizations are migrating their applications to Rust. The GNOME Linux development environment is an example. Personally, I especially love Rust’s reliability principle: “If it compiles, it works.”\n\nIn this article, we’ll demonstrate how to build a desktop application using Qt (a mature, battle-tested framework for cross-platform development) and Rust.\n\nJump ahead:\n\nPrerequisites\n\nChoosing Rust Qt bindings\n\nGetting started with Rust and Qt\n\nApplication components\n\nQt application demo\n\nCreating the Rust project\n\nDesigning the UI\n\nBuilding the application\n\nUsing the Just task runner (optional)\n\nAdding encryption\n\nEncrypting with nrot\n\nUsing on-the-fly encryption\n\nAdding decryption\n\nUsing a custom component to avoid duplication\n\nCreating a GitHub CI\n\nPrerequisites\n\nTo follow along with the demo and other content included in this guide, you should have a working knowledge of Rust. To learn more, you can read the book.\n\nChoosing Rust Qt bindings\n\nRust has several Qt bindings. The most popular are Ritual, CXX-Qt, and qmetaobject. Ritual is not maintained anymore, and qmetaobject doesn’t support QWidgets. So CXX-Qt is our best bet for now.\n\nBecause Rust is a relatively new language. So is the ecosystem. CXX-Qt is not as mature as PyQt. But it is on the way there. The current latest release already has a good and simple API.\n\nGetting started with Rust and Qt\n\nInstall Rust using the following command:\n\ncurl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh\n\nIf you’re using Windows, go to https://rustup.rs/ to download the installer. To ensure everything is okay, run the following command in your terminal:\n\nrustc --version\n\nNext, install Qt:\n\n# Ubuntu sudo apt install qt6-base-dev qt6-declarative-dev # Fedora sudo dnf install qt6-qtbase-devel qt6-qtdeclarative-devel # If you are unsure. Just install all Qt dependencies # It is no more than 200 MB sudo apt install qt6* sudo dnf install qt6*\n\nTo check that Qt is successfully installed, check that you’re able to run the following:\n\nqmake --version\n\nEverything looks great! We are good to go now.\n\nApplication components\n\nCXX-Qt is the Rust Qt binding. It provides a safe mechanism for bridging between Qt code and Rust. Unlike typical one-to-one bindings. CXX-Qt uses CXX to bridge Qt and Rust. This gives more powerful code, safe API, and safe multi-threading between both codes. Unlike the previous version. You don’t need to touch any C++ code in the latest version.\n\nQML is a programming language to develop the user interface. It is very readable because it offers JSON-like syntax. QML also has support for imperative JavaScript expressions and dynamic property bindings; this will be helpful for writing our Caesar Cipher application. If you need a refresher, see this QML intro.\n\nQt application demo\n\nTo demonstrate how to work with Qt and Rust, we’ll build a simple “Hello World” application.\n\nCreating the Rust project\n\nFirst, we need to create a Rust project, like so:\n\n❯ cargo new --bin demo Created binary (application) `demo` package\n\nNext, open the Cargo.toml file and add the dependencies:\n\n[dependencies] cxx = \"1.0.83\" cxx-qt = \"0.5\" cxx-qt-lib = \"0.5\" [build-dependencies] cxx-qt-build = \"0.5\"\n\nNow, let’s create the entry point for our application. In the src/main.rs file we’ll initialize the GUI application and the QML engine. Then we’ll load the QML file and tell the application to start:\n\n// src/main.rs use cxx_qt_lib::{QGuiApplication, QQmlApplicationEngine, QUrl}; fn main() { // Create the application and engine let mut app = QGuiApplication::new(); let mut engine = QQmlApplicationEngine::new(); // Load the QML path into the engine if let Some(engine) = engine.as_mut() { engine.load(&QUrl::from(\"qrc:/main.qml\")); } // Start the app if let Some(app) = app.as_mut() { app.exec(); } }\n\nTo set up communication between Rust and Qt, we’ll define the object in the src/cxxqt_oject.rs file:\n\n// src/cxxqt_object.rs #[cxx_qt::bridge] mod my_object { #[cxx_qt::qobject(qml_uri = \"demo\", qml_version = \"1.0\")] #[derive(Default)] pub struct Hello {} impl qobject::Hello { #[qinvokable] pub fn say_hello(&self) { println!(\"Hello world!\") } } }\n\nAttribute macro is used to enable CXX-Qt features.\n\n#[cxx_qt::bridge]: marks the Rust module to be able to interact with C++\n\n#[cxx_qt::qobject]: expose a Rust struct to Qt as a QObject subclass\n\n#[qinvokable]: expose a function on the QObject to QML and C++ as a Q_INVOKABLE.\n\nNext, we’ll create a struct, named Hello, derived from the qobject traits. Then we can implement our regular Rust function to print a greeting:\n\n// src/main.rs + mod cxxqt_object; use cxx_qt_lib::{QGuiApplication, QQmlApplicationEngine, QUrl};\n\nN.B., don’t forget to tell Rust if you have a new file\n\nDesigning the UI\n\nWe’ll use QML to design the user interface. The UI file is located in the qml/main.qml file:\n\n// qml/main.qml import QtQuick.Controls 2.12 import QtQuick.Window 2.12 // This must match the qml_uri and qml_version // specified with the #[cxx_qt::qobject] macro in Rust. import demo 1.0 Window { title: qsTr(\"Hello App\") visible: true height: 480 width: 640 color: \"#e4af79\" Hello { id: hello } Column { anchors.horizontalCenter: parent.horizontalCenter anchors.verticalCenter: parent.verticalCenter /* space between widget */ spacing: 10 Button { text: \"Say Hello!\" onClicked: hello.sayHello() } } }\n\nIf you look closely at sayHello function, you‘ll notice that CXX-Qt converts the Rust function’s snake case to the camelCase C++ convention. Now our QML code doesn’t look out of place!\n\nNext, we have to tell Qt about the QML location using the Qt resource file. It should be located in the qml/qml.qrc file:\n\n<!DOCTYPE RCC> <RCC version=\"1.0\"> <qresource prefix=\"/\"> <file>main.qml</file> </qresource> </RCC>\n\nBuilding the application\n\nThe last step is to build the application. To teach Rust how to build the cxxqt_object.rs and QML files, we need to first define it in build.rs file:\n\n// build.rs use cxx_qt_build::CxxQtBuilder; fn main() { CxxQtBuilder::new() // Link Qt's Network library // - Qt Core is always linked // - Qt Gui is linked by enabling the qt_gui Cargo feature (default). // - Qt Qml is linked by enabling the qt_qml Cargo feature (default). // - Qt Qml requires linking Qt Network on macOS .qt_module(\"Network\") // Generate C++ from the `#[cxx_qt::bridge]` module .file(\"src/cxxqt_object.rs\") // Generate C++ code from the .qrc file with the rcc tool // https://doc.qt.io/qt-6/resources.html .qrc(\"qml/qml.qrc\") .setup_linker() .build(); }\n\nThe final structure should look like this:\n\n⬢ ❯ exa --tree --git-ignore . ├── qml │ ├── main.qml │ └── qml.qrc ├── src │ ├── cxxqt_object.rs │ └── main.rs ├── build.rs ├── Cargo.lock └── Cargo.toml\n\nNow, let’s use cargo check to make sure we have a correct code.\n\n# `cargo c` is an alias to `cargo check` ❯ cargo c Finished dev [unoptimized + debuginfo] target(s) in 0.04s\n\nFinally, let’s run the application:\n\n⬢ ❯ cargo --quiet r Compiling demo v0.1.0 Finished dev [unoptimized + debuginfo] target(s) in 0.49s Running `target/debug/demo` Hello world!\n\nUsing the Just task runner (Optional)\n\nA task runner can save you time by automating repetitive development tasks. I recommend using Just. To install Just, use the following command:\n\ncargo install just\n\nJust is similar to Make, but without Make’s complexity and idiosyncrasies.\n\nSimply add the justfile file into your root directory and put your repetitive tasks there:\n\n#!/usr/bin/env -S just --justfile alias d := dev alias r := run alias f := fmt alias l := lint alias t := test # List available commands. _default: just --list --unsorted # Develop the app. dev: cargo watch -x 'clippy --locked --all-targets --all-features' # Develop the app. run: touch qml/qml.qrc && cargo run # Format the codebase. fmt: cargo fmt --all # Check if the codebase is properly formatted. fmt-check: cargo fmt --all -- --check # Lint the codebase. lint: cargo clippy --locked --all-targets --all-features # Test the codebase. test: cargo test run --all-targets # Tasks to make the code base comply with the rules. Mostly used in git hooks. comply: fmt lint test # Check if the repository complies with the rules and is ready to be pushed. check: fmt-check lint test\n\nFor more convenience, you can use j as an alias for just in your shell:\n\nalias j='just'\n\nNow you can use j r for cargo run and so on.\n\nAdding encryption\n\nLet’s further improve the application by modifying the text input. We’ll add some simple encryption using Caesar Cipher encoding.\n\nFirst, let’s rename the application to \"caesar\":\n\n# Cargo.toml [package] -name = \"demo\" +name = \"caesar\"\n\nThen, we’ll add the encrypt function:\n\n// cxxqt_object.rs #[cxx_qt::bridge] mod my_object { unsafe extern \"C++\" { include!(\"cxx-qt-lib/qstring.h\"); type QString = cxx_qt_lib::QString; } #[cxx_qt::qobject(qml_uri = \"caesar\", qml_version = \"1.0\")] pub struct Rot { #[qproperty] plain: QString, #[qproperty] secret: QString, } impl Default for Rot { fn default() -> Self { Self { plain: QString::from(\"\"), secret: QString::from(\"\"), } } } impl qobject::Rot { #[qinvokable] pub fn encrypt(&self, plain: &QString) -> QString { let result = format!(\"{plain} is a secret\"); QString::from(&result) } } }\n\nNext, we need to import the Qstring, because our encrypt function accepts Qstring as an argument and also has Qstring as a return type. The struct now contains two fields: plain and secret. The encrypt function is a regular Rust function, but it accepts and returns a type from CXX-Qt: Qstring.\n\nIn the user interface, let’s add a TextArea text field component and a Button:\n\n// main.qml import QtQuick.Controls 2.12 import QtQuick.Window 2.12 // This must match the qml_uri and qml_version // specified with the #[cxx_qt::qobject] macro in Rust. import caesar 1.0 Window { title: qsTr(\"Caesar\") visible: true height: 480 width: 640 color: \"#e4af79\" Rot { id: rot plain: \"\" secret: \"\" } Column { anchors.horizontalCenter: parent.horizontalCenter anchors.verticalCenter: parent.verticalCenter /* space between widget */ spacing: 10 Label { text: \"Keep your secret safe 🔒\" font.bold: true } TextArea { placeholderText: qsTr(\"[email protected]\") text: rot.plain onTextChanged: rot.plain = text background: Rectangle { implicitWidth: 400 implicitHeight: 50 radius: 3 color: \"#e2e8f0\" border.color: \"#21be2b\" } } Button { text: \"Encrypt!\" onClicked: rot.secret = rot.encrypt(rot.plain) } Label { text: rot.secret } } }\n\nIn the TextArea we use the onTextChanged signal to set the plain field of the Rot struct to be assigned the value of the TextArea input whenever anything changes.\n\nThen, we use the onClicked signal in the Button component to assign the return value of the encrypt function to the secret field. Also, we pass the value of plain to the encrypt function.\n\nFinally, we display the value of the secret field in the Label component.\n\nNow, let’s run the application:\n\n⬢ ❯ j r touch qml/qml.qrc && cargo run Compiling caesar v0.1.0 Finished dev [unoptimized + debuginfo] target(s) in 8.12s Running `target/debug/caesar`\n\nEncrypting with nrot\n\nOne approach for encrypting the user input (secret message) text is to use the nrot third-party library.\n\nFirst, let’s add the dependency:\n\n# Cargo.toml +[dependencies] +nrot = \"2.0.0\" +# UI cxx = \"1.0.83\"\n\nThen, import the crate:\n\nmod my_object { + use nrot::{rot, rot_letter, Mode}; + unsafe extern \"C++\" {\n\nNext, let’s use nrot to improve our app’s encrypt function:\n\npub fn encrypt(&self, plain: &QString) -> QString { let rotation = 13; // common ROT rotation let plain = plain.to_string(); let plain = plain.as_bytes(); let bytes_result = rot(Mode::Encrypt, plain, rotation); let mut secret = format!(\"{}\", String::from_utf8_lossy(&bytes_result)); if plain.len() == 1 { let byte_result = rot_letter(Mode::Encrypt, plain[0], rotation); secret = format!(\"{}\", String::from_utf8_lossy(&[byte_result])); }; QString::from(&secret) }\n\nUsing on-the-fly encryption\n\nAnother approach for encrypting the user input (secret message) text is to use on-the-fly encryption. This will enable us to eliminate the old-fashioned button and actually encrypt the secret message as the user is typing.\n\nFirst, let’s remove the Button component and set the value of the secret field to update every time the user makes a change to the input field:\n\nmodified qml/main.qml placeholderText: qsTr(\"[email protected]\") text: rot.plain - onTextChanged: rot.plain = text + onTextChanged: rot.secret = rot.encrypt(text) - Button { - text: \"Encrypt!\" - onClicked: rot.secret = rot.encrypt(rot.plain) - } -\n\nAdding decryption\n\nNow, let’s add the decryption functionality. We’ll use the following decrypt function:\n\n#[qinvokable] pub fn decrypt(&self, secret: &QString) -> QString { let rotation = 13; // common ROT rotation let secret = secret.to_string(); let secret = secret.as_bytes(); let bytes_result = rot(Mode::Decrypt, secret, rotation); let mut plain = format!(\"{}\", String::from_utf8_lossy(&bytes_result)); if secret.len() == 1 { let byte_result = rot_letter(Mode::Decrypt, secret[0], rotation); plain = format!(\"{}\", String::from_utf8_lossy(&[byte_result])); }; QString::from(&plain) }\n\nThen, we’ll add the second TextArea component for interchangeable input:\n\nTextArea { placeholderText: qsTr(\"[email protected]\") text: rot.secret onTextChanged: rot.plain = rot.decrypt(text) background: Rectangle { implicitWidth: 400 implicitHeight: 50 radius: 3 color: \"#e2e8f0\" border.color: \"#21be2b\" } } }\n\nUsing a custom component to avoid duplication\n\nWe have two very similar TextArea text fields. To avoid duplication, let’s create a custom component.\n\nFirst, create an InputArea.qml file in the qml directory with the content of the previous TextArea component:\n\n// InputArea.qml import QtQuick 2.12 import QtQuick.Controls 2.12 TextArea { background: Rectangle { implicitWidth: 400 implicitHeight: 50 radius: 3 color: \"#e2e8f0\" border.color: \"#21be2b\" } }\n\nInclude the file in the Qt resource:\n\n<RCC version=\"1.0\"> <qresource prefix=\"/\"> <file>main.qml</file> + <file>InputArea.qml</file> </qresource> </RCC>\n\nNext, modify the main.qml file to use InputArea:\n\n// main.qml InputArea { placeholderText: qsTr(\"[email protected]\") text: rot.plain onTextChanged: rot.secret = rot.encrypt(text) } InputArea { placeholderText: qsTr(\"[email protected]\") text: rot.secret onTextChanged: rot.plain = rot.decrypt(text) }\n\nCreating a GitHub CI\n\nAs a final step, to ensure that we have the correct code in each commit, let’s create a GitHub CI workflow:\n\nname: Caesar jobs: code_quality: name: Code quality runs-on: ubuntu-22.04 build: name: Build for GNU/Linux runs-on: ubuntu-22.04 strategy: fail-fast: false steps: - name: Checkout source code uses: actions/checkout@v3 - name: Install Rust toolchain uses: dtolnay/rust-toolchain@stable with: target: x86_64-unknown-linux-gnu - name: Install Qt if: matrix.os == 'ubuntu-22.04' run: | sudo apt-get update sudo apt-get install -y --no-install-recommends --allow-unauthenticated \\ qt6-base-dev \\ qt6-declarative-dev - name: Build run: cargo build --release --locked\n\nConclusion\n\nIn this article, we demonstrated how to build a desktop Qt application using Rust and QML. Along the way, we discussed QObject, Qt signals, and CXX-Qt attribute macros.\n\nIf you’d like, you can further improve the demo app by adding more rotation features. Currently, the rotation value is hardcoded to 13. Also, you can play with the current QML user interface to make it fancier. The code for this article’s demo application is available on GitHub.\n\nI hope you enjoyed this article. If you have questions, feel free to leave a comment."
    }
}