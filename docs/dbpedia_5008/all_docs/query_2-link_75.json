{
    "id": "dbpedia_5008_2",
    "rank": 75,
    "data": {
        "url": "https://mayaposch.wordpress.com/category/qt/",
        "read_more_link": "",
        "language": "en",
        "title": "Maya's Programming & Electronics Blog",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://mayaposch.wordpress.com/wp-content/uploads/2012/12/opengl_coordinate_system.png?w=262&h=215",
            "https://mayaposch.wordpress.com/wp-content/uploads/2012/12/qt_coordinate_system.png?w=262&h=215",
            "https://i0.wp.com/imgs.xkcd.com/comics/file_transfer.png",
            "https://mayaposch.wordpress.com/wp-content/uploads/2011/09/universal_data_share_screenshot.png?w=595",
            "https://0.gravatar.com/avatar/0ecba7f6c4796955a6bc526f543f1f6ea3ca84821af39e5640cd8a8ee696af96?s=96&d=identicon&r=G",
            "https://www.paypalobjects.com/webstatic/en_US/btn/btn_donate_92x26.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Maya Posch"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "Posts about Qt written by Maya Posch",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "Maya's Programming & Electronics Blog",
        "canonical_link": "https://mayaposch.wordpress.com/category/qt/",
        "text": "While recently working on a project involving C++, Qt and networking using TCP sockets I came across a nasty surprise in the form of blocking socket functions not working on Windows with QTcpSocket [1]. Not working as in fundamentally broken and a bug report [1] dating back to early 2012, when Qt 4.8 was new. After a quick look through the relevant Qt source code (native socket engine and kin) in an attempt to determine whether it was something I could reasonably fix myself, I determined that this was not a realistic option due to the amount of work involved.\n\nInstead I found myself drawn to the option of implementing a QObject-based class wrapping around the native sockets on Windows (Winsock2) and others (POSIX/Berkeley). Having used these native sockets before, I could only think of how easy it’d be to write such a wrapper class for my needs. These needs involved TCP sockets, blocking functions and client-side functionality, all of which take only a little bit of effort to implement. Any further features could be implemented on an as-needed basis. The result of this is the NNetworkSocket class, which I put on Github today [2] in a slightly expanded version.\n\nAs I suspect that it won’t be the first add-on/drop-in/something else class I’ll be writing to complement the Qt framework, I decided to come up with the so very creative name of ‘Nt’ for the project. Much like ‘Qt’, its pronunciation is obvious and silly: ‘Qt’ as ‘cute’ and ‘Nt’ as ‘neat’. Feel free to have a look at the code I put online including the sample application (samples/NNetworkSocket_sample). Documentation will follow at some point once the class has matured some more.\n\nAs usual, feel free to provide feedback, patches and donations 🙂\n\nMaya\n\n[1] https://bugreports.qt-project.org/browse/QTBUG-24451\n\n[2] https://github.com/MayaPosch/Nt\n\nA few months ago I was approached by someone who wanted to have a fairly basic app developed. Nothing special there. What was special was that this person is blind and required the application to work well with his favourite screen-reader software (Window Eyes). After an initial meddling around with a basic Win32 GUI application I decided that I could much more easily do this in Qt, assuming that accessibility there worked as intended. This resulted in a quick and messy crash course into accessibility with the Qt framework.\n\nTo immediately start off with the most important lesson: forget about accessibility with Qt 4.8 and lower. This version of the framework only has partial MSAA (MicroSoft Active Accessibility) support, the API Microsoft first introduced with Windows 95 Service Release 2 (SR2) to interface with screen and braille readers, among other technologies. The MSAA support in Qt 4 is limited to some main GUI elements, but omits lists and other crucial views. As a result only the most basic, stripped-down Qt 4 applications will work via the MSAA API.\n\nThere’s hope, however. With Qt 5 accessibility has been majorly improved. Not only has MSAA been improved to the point where it’s pretty much fully accessible, but the IAccessibility2 API has also been added, which is a third-party accessibility API more recently introduced. This latter API is most easy to use with Qt 5 applications, though MSAA doesn’t require much more work either.\n\nBasically all you need to do to enable accessibility in your application is to set the ‘Accessible name’ and ‘Accessible description’ for relevant widgets in your application’s GUI (check the property list in Qt Designer/Qt Creator with the GUI file open). Then, when deploying the application make sure you have a folder named ‘accessible’ in your application’s folder with the executable and the file ‘qtaccessiblewidgets.dll’ (or comparable .so) in that accessible folder. This will cause the Qt 5 application to load the accessibility features for its widgets and enables MSAA and IA2.\n\nDuring testing and experimenting I have used both the Window Eyes and NVDA screen readers in Windows 7 x64 and Windows XP. It was found that NVDA already works with Qt 5 applications, likely via its IA2 interface, but that Window Eyes needed to have its Qt accessibility support improved due to it only supporting MSAA. I worked together with the creators of Window Eyes – GWMicro – on this improvement, resulting in a new build which works great for both me and the client. This new build will soon become available as an update for Window Eyes customers.\n\nSo after a few months of trial and error at long last this application is done and working for the client. Would it have been better to just go ahead with the Win32 API version? I’m not sure. First of all it would have represented its own share of issues, especially with regard to the implementation of the application’s other features which Qt’s object-oriented, message-slot-based architecture makes a snap. As a result of this struggle it seems that everyone came out ahead; for myself the added knowledge of accessibility in Qt, my client with an improved screen reader which now supports all Qt 5 applications which load that DLL I mentioned, and GWMicro which now has a better product.\n\nIn summary, Qt 5 accessibility support is pretty darn easy and well-supported these days, whether using the MSAA or IA2 API. As far as I’m concerned it’s worth a good look for your next project.\n\nMaya\n\nWhen it comes to Qt’s fancy 2D engine embedded in QGraphicsScene – usually attached to a QGraphicsView – a common question is what the coordinate system of it is like. Basically this means how the X and Y axes of its grid are oriented. The official Qt documentation is of little use here as they probably never consider this to be important, let alone for exchanging data with other coordinate systems, such as that of OpenGL.\n\nFor a 2.5D Arcade game my company Nyanko is currently working on I had to create a level editor. I chose Qt and QGraphicsScene for the simple reason that it is very easy to set up a kind of editor inside a fancy UI with it. When it comes to interoperability with our in-house 3D engine which is based upon OpenGL, the question was how compatible these two coordinate systems of Qt and OpenGL would be. As it turned out they’re almost the same, but also different. See the below illustrations:\n\nOpenGL’s coordinate system\n\nQGraphicsScene’s coordinate system\n\nAs you can see, QGraphicsScene has an inverted Y axis in comparison to OpenGL, with the Y axis growing downwards instead of upwards. This makes the starting point of OpenGL bottom-left and that of QGraphicsScene top-left. It’s unfortunate that this orientation was chosen, as in the level editor I had to invert the Y axis prior to saving to a level file and again upon loading. It also means that the OpenGL functionality in Qt doesn’t have the smooth interoperability with QGraphicsScene it otherwise would have had.\n\nFortunately it’s not hard to invert the Y axis, it’s just a shame that it had to be done like this, and with so little documentation. Hopefully this article will help someone out there avoid a few pitfalls 🙂\n\nMaya\n\nAs some of you may know already, I am working on the WildFox browser project which while it initially was going to fork the Mozilla code is now building a browser on top of QtWebKit. See the previous blog post for details on this decision. The WildFox project page and source can be found at www.mayaposch.com/wildfox.php.\n\nOne of the features I recently implemented was an advanced cookiejar for storing HTTP cookies. Why was this necessary, you may ask? QtWebKit does implement a cookiejar in QNetworkCookieJar, but even aside from the inability to save any of the cookies to disk, a quick look at its source code shows the following issues: a limit of 50 cookies, which is less than the 300 required by the current standard for HTTP cookies (RFC 2617) [1]. It also uses a basic QList to store the cookies, which requires it to search in linear time through every cookie to find ones for a specific URL and duplicate cookies when storing them.\n\nIn other words, the default implementation is unsuitable for any web browser. One thing it does do right, however, is the way it verifies domains. Due to the design of internet Top Level Domains (TLDs) it is impossible to algorithmically determine whether an internet URL is valid, or specifies a proper TLD.\n\nThe need to verify the domain is made clear when one imagines someone setting a cookie for the domain .com, which would then be a cookie valid for every website ending with the TLD .com. Obviously this can’t be allowed and the obvious approach would be to disallow single dot domains (.com, .org, .net). This doesn’t work for domains like .co.uk, however. Disallowing two dot domains would cause issues with the former, single dot type. Further there are more variations on this, such as URLs in the US where the public suffix can entail city.state.us style domains. Clearly the only way to do this verification is to use a look-up table. This can be found in Mozilla’s public suffix list [2].\n\nWhat we need for a better QtWebKit cookiejar thus entails the following:\n\nthe ability to store cookies to disk.\n\nstoring at least 300 cookies.\n\nquick look-ups of cookies based on their domain.\n\nFor this we recycle the existing functionality in Qt required to do the public suffix verification. The relevant files in Qt 4.8.0 are:\n\nsrc/corelib/io/qtldurl.cpp\n\nsrc/qurltlds_p.h\n\nThe former contains some basic routines to obtain the public suffix which we will expand upon and the latter contains the Public Suffix list processed in a more accessible format. The latter we’ll use almost as-is, with just the Qt namespace sections removed. The former has a major omission we’ll add. The functions we’ll keep from qtldurl.cpp are in renamed form:\n\ncontainsTLDEntry(const QString &entry)\n\nisEffectiveTLD(const QString &domain)\n\ntopLevelDomain(const QString &domain)\n\nWe add the following function:\n\nQString getPublicDomain(const QString &domain) { QStringList sections = domain.toLower().split(QLatin1Char('.'), QString::SkipEmptyParts); if (sections.isEmpty()) return QString(); QString tld = \"\"; for (int i = sections.count() - 1; i >= 0; --i) { tld.prepend(QLatin1Char('.') + sections.at(i)); if (!isEffectiveTLD(tld.right(tld.size() - 1))) { return tld; } } return tld; }\n\nThis allows us to obtain the public suffix plus the initial non-public (TLD) domain. For example, “http://www.slashdot.org&#8221; would be reduced to “.slashdot.org”. It is different from topLevelDomain() in that the latter would return just the public suffix, e.g. “.org” in the previous example, which is not desirable for our use.\n\nWith the domain verification taken care of, we move on to the next stage, which involves the data structure and storage method. To store cookies on disk we elect to use an SQLite database, as this is both efficient in terms of storage density, but also prevents disk fragmentation and allows for SQL-based look-ups instead of filesystem-based ones, as used to be common with older browsers. QtSQL comes with an SQLite driver. Do be sure to use the current version of Qt (4.8) as recently SQLite introduced journaling and the Qt 4.7.x libraries still use the old SQLite client.\n\nFor the in-memory data structure we use a QMultiMap. The rationale behind this is the key-based look-up based on the cookie domain. By taking the URL we’re seeking matching cookies for and obtaining its top domain (“.slashdot.org”) we can find any cookie in our data structure using this top domain as the key. This means we can search a large number of cookies in logarithmic (O(log N)) time for a match on the domain, a major improvement on the linear (O(N)) search of the default QList.\n\nThe link between the in-memory and on-disk storage is accomplished by the following rules:\n\nAll new cookies and cookie updates are stored in both in-memory and on-disk, except for session cookies, which are stored only in-memory.\n\nStored cookies are read into memory per-domain and on-demand.\n\nIn addition to this I have implemented a cookie manager dialogue which allows one to look through and manage (delete) stored cookies. Expired cookies are automatically deleted the first time they are fetched from the database or before they’re stored. Blocking 3rd-party cookies is also very easy, with a comparison between the top domain and the cookie’s intended domain:\n\nQString baseDomain = getPublicDomain(url.host()); if (skip3rd && (baseDomain != getPublicDomain(cookie.domain()))) { continue; }\n\nWith this we got a relatively efficient cookie storage and retrieval mechanism with the ability to manage the set cookies. It can store an unlimited number of cookies and should remain efficient with look-ups even with over 10,000 cookies thanks to the logarithmic search of the QMultiMap.\n\nEssential features still missing in the WildFox browser at this point are bookmarks and sessions. The next article on WildFox should be about the Chrome extension support I’m currently implementing, with as direct result XMarks bookmark synchronization support as well as the bookmarks feature. Stay tuned.\n\nMaya\n\n[1] http://www.ietf.org/rfc/rfc2617.txt\n\n[2] http://publicsuffix.org/\n\nLast year I did a couple of interviews for The Register and other sites regarding my WildFox project which in essence had the goal to add h.264 video support to Firefox using the GStreamer backend or FFmpeg. Due to circumstances I didn’t manage to do significant work on this project until a few months ago when I finally began the real modifications to the Firefox source.\n\nAs this article isn’t about the quality of the Mozilla source code, or the lack thereof, I won’t dwell on it too long. Suffice it to say that I found a lot of instances of NIH (‘Not Invented Here’) syndrome including the networking, smart pointer and threading sections. As my goal was to add Libav (recent fork of FFmpeg) support to the media backend of Firefox I became intimately familiar with these APIs as I discovered just how much of the code would be ripped out without causing adverse effects, and that the smart pointers do not work with anything but NSISupports-derived types.\n\nAnyway, the build system… at first glance the Mozilla build system seems to use Makefiles, that is until you notice the .in extension indicating that they’re autoconfig templates. Or autobreak as lovingly called by a large section of the internet. After much trial and error I discovered that after putting my new Libav decoder & reader into /content/media/libav and the Libav includes into /media/libav of the source tree, creating a single Makefile with EXPORTS and an individual Makefile for each library of Libav (libavformat, libavcodec, etc.), I still had to edit a host of files to make it all work:\n\n/layout/build Makefile.in /toolkit toolkit-makefiles.sh toolkit-tiers.mk /content/media Makefile.in\n\nAfter following the hints in the Mozilla documentation [1] I first discovered the files in /toolkit, and things finally began to work. Until I hit a few snags, like having to add a compiler flag to CXXFLAGS but there being no way to specify this in the Makefiles which didn’t get ignored for some reason. Libav is a C99 project and requires -D__STDC_CONSTANT_MACROS to be added to CXXFLAGS [2] to make it play nice with a C++ project. In the end I put this flag directly into the CXXFLAGS definition in the top of configure.in in the root folder. Ugly but it works.\n\nAt this point everything builds, the only thing I’m still stuck on is how to add the Libav’s LIB files to the linker flags. As usual the methods I have found do not work and even adding it to configure.in didn’t seem to do the trick.\n\nTo be quite honest I’m ready to give up on improving the Mozilla source. The changes required to bring it up to speed with proper project standards are just too daunting and severe to be handled just by me. As a fun comparison I started the WildFox-Mimic project a few days ago to investigate what it’d take to create a browser which looks and feels like Firefox, but uses Qt and the QtWebKit engine. The result is a modern, up to date browser with an HTML 5 video/audio backend which uses Qt’s Phonon which wraps around the OS’s media framework, be it DirectShow, GStreamer or something else. In other words it’s perfect. QtWebKit can also use the same NPAPI plugins Firefox uses, so Flash support is available out of the box. The Persona themes and JetPack add-ons can also be supported.\n\nThe result with WildFox-Mimic would be a browser with a codebase a fraction the size of the Firefox one, with most of the development and maintenance performed by the Qt and QtWebKit maintainers. This is the direction I think I’ll be heading towards.\n\nMaya\n\n[1] https://developer.mozilla.org/en/Adding_Files_to_the_Build\n\n[2] http://libav.org/faq.html#I_0027m-using-libavutil-from-within-my-C_002b_002b-application-but-the-compiler-complains-about-_0027UINT64_005fC_0027-was-not-declared-in-this-scope\n\nThreads in an operating system are a very simple thing. Write a function, maybe bundle it with some data and push it onto a newly created thread. Use a mutex or other method to safely communicate with the thread if necessary. Whether it are Win32, POSIX or other threads, they all basically work the same and are quite fool-proof. I’d venture to say that they’re at least a lot easier to use and handle than sockets 🙂\n\nThose who have discovered the joys of the Qt framework may assume that threads in Qt (QThread) are just like this, but they would be both wrong and right. Wrong because years of wrong documentation from Trolltech/Nokia on QThread has caused countless people to use QThreads in a convoluted and highly inappropriate manner. Right because QThreads are in fact quite easy to use, as long as you ignore the incorrect official Qt documentation on QThread [1] and the myriad of wrongful methods being employed.\n\nThe main thing to keep in mind when using a QThread is that it’s not a thread. It’s a wrapper around a thread object. This wrapper provides the signals, slots and methods to easily use the thread object within a Qt project. This should immediately show why the recommended way of using QThreads in the documentation, namely to sub-class it and implement your own run() function, is very wrong. A QThread should be used much like a regular thread instance: prepare an object (QObject) class with all your desired functionality in it. Then create a new QThread instance, push the QObject onto it using moveToThread(QThread*) of the QObject instance and call start() on the QThread instance. That’s all. You set up the proper signal/slot connections to make it quit properly and such, and that’s all.\n\nFor a basic example, check this class declaration for the Worker class:\n\nclass Worker : public QObject { Q_OBJECT public: Worker(); ~Worker(); public slots: void process(); signals: void finished(); void error(QString err); private: // add your variables here };\n\nWe add at least one public slot which will be used to trigger the instance and make it start processing data once the thread has started. Now, let’s see what the implementation for this basic class looks like.\n\n// --- CONSTRUCTOR --- Worker::Worker() { // you could copy data from constructor arguments to internal variables here. } // --- DECONSTRUCTOR --- Worker::~Worker() { // free resources } // --- PROCESS --- // Start processing data. void Worker::process() { // allocate resources using new here qDebug(\"Hello World!\"); emit finished(); }\n\nWhile this Worker class doesn’t do anything special, it nevertheless contains all the required elements. It starts processing when its main function, in this case process(), is called and when it is done it emits the signal finished() which will then be used to trigger the shutdown of the QThread instance it is contained in.\n\nBy the way, one extremely important thing to note here is that you should NEVER allocate heap objects (using new) in the constructor of the QObject class as this allocation is then performed on the main thread and not on the new QThread instance, meaning that the newly created object is then owned by the main thread and not the QThread instance. This will make your code fail to work. Instead, allocate such resources in the main function slot such as process() in this case as when that is called the object will be on the new thread instance and thus it will own the resource.\n\nNow, let’s see how to use this new construction by creating a new Worker instance and putting it on a QThread instance:\n\nQThread* thread = new QThread; Worker* worker = new Worker(); worker->moveToThread(thread); connect(worker, SIGNAL(error(QString)), this, SLOT(errorString(QString))); connect(thread, SIGNAL(started()), worker, SLOT(process())); connect(worker, SIGNAL(finished()), thread, SLOT(quit())); connect(worker, SIGNAL(finished()), worker, SLOT(deleteLater())); connect(thread, SIGNAL(finished()), thread, SLOT(deleteLater())); thread->start();\n\nThe connect() series here is the most crucial part. The first connect() line hooks up the error message signal from the worker to an error processing function in the main thread. The second connects the thread’s started() signal to the processing() slot in the worker, causing it to start.\n\nThen the clean-up: when the worker instance emits finished(), as we did in the example, it will signal the thread to quit, i.e. shut down. We then mark the worker instance using the same finished() signal for deletion. Finally, to prevent nasty crashes because the thread hasn’t fully shut down yet when it is deleted, we connect the finished() of the thread (not the worker!) to its own deleteLater() slot. This will cause the thread to be deleted only after it has fully shut down.\n\nI hope this small tutorial is of some use to people out there. It has taken me months to put together this method of doing things involving countless frustrating hours of debugging and Google searches which kept repeating the same wrong mantra of ‘sub-class QThread’. Constructive feedback on this tutorial is much appreciated. Emails to Nokia on the wrong QThreads documentation might be a good idea too as I would love for the myths surrounding QThread to finally be erased from this world 🙂\n\nMaya\n\n[1] http://doc.trolltech.com/4.7/qthread.html\n\nIn the previous installment I talked about combining UPnP’s IGD features with Qt. This culminated for me in a few days of programming and debugging in order to get a functional program working.\n\nLet’s be short about one thing: if you intend to use Qt with custom networking protocols, meaning something other than the standard HTTP, FTP and other such generic protocols, be aware that you shouldn’t use anything more of Qt than QTcpSocket and QTcpServer. QNetworkAccessManager doesn’t work unless you want to extend its range of protocols, while it’s easier to implement the protocol outside it. Avoid QByteArrays for received data and go as low-level as possible. Unsigned integers in Qt, such as quint8 are excellent to use with a standard C/C++ array. It makes data conversion so much easier, assuming you’re using a binary protocol, like I was.\n\nAlso brush up on your bitwise operators. You’ll need to know your way with the & AND operator for masking and the << and >> bitwise shifts, such as when converting an integer to bytes for adding them to an array:\n\nQByteArray output; for (quint32 i = sizeof(ourInt); i > 0; --i) { output.append((ourInt >> ((i - 1) * 8)) & 0xFF); }\n\nEarlier today I finished the first alpha build of the application. It was inspired by a recent XKCD comic:\n\nWhy not have a basic application which allows one to just transfer files without any accounts, messing with NAT router forwardings, firewalls, setting up servers and other unpleasantness? With all of the raw power available, why can’t we just give someone a link (URI/URL) which allows that person to download a file straight from our own PC? It was the original concept behind the World Wide Web after all.\n\nMay I present to you, as the first stage in making this dream a reality, the Universal Data Share (UDS) application:\n\nFor those who want to give it a try, it’s available from here, as a Windows .exe: http://www.mayaposch.com/downloads/Universal_Data_Share.exe. It’s statically compiled against the Qt libraries, so no DLLs are required. UPX was used to compress the EXE (10 MB down to 3.25 MB).\n\nQuick usage tutorial: after starting, go to Shares -> Go Online. This initiates the UPnP IGD discovery and port mapping. Port 11310 is hard-coded in this version. Under File you can add files to the local list. Under Remote you can copy the global (external) IP to the clipboard, which will then allow another person also running UDS to connect to you and obtain a list of your shares. These can then be downloaded via a menu option as well.\n\nIn the future I’d like to add URL-based downloads, maybe even add HTTP support so that it can act like a web server, allowing anyone with a browser to connect to it. Anyway, give it a whirl and let me know how it works for you. Feature requests are also quite welcome.\n\nFor the usual disclaimer, I’ll just say that this Alpha-level software. I have tested it for the past two days on my Windows 7 Enterprise system via the loopback network. The port mapping was not directly tested and may have issues with some NAT routers. I can not take responsibility for any damage which may be caused to routers, computers, files or other hardware or software. Use of this experimental software is completely at your own risk.\n\nNow go have fun 🙂\n\nMaya\n\nRecently I decided to give a feature of Universal Plug ‘n’ Play (UPnP) a whirl: Internet Gateway Device protocol (IGD) [1]. This is a feature which has become commonplace in network devices, specifically routers. Previously one would have to manually set port forwardings in the router’s administration panel in order to allow programs outside the LAN to talk to programs inside it. With UPnP’s IGD functionality the LAN-based program can now take care of those port mappings/forwardings itself. Many games, chat and other programs already use it. One could say that it is now an essential skill for anyone doing serious network programming.\n\nIf you need more than just IGD, you can go with one of the more expansive SDKs [2], but otherwise you should be perfectly happy with the extremely light-weight and easy to use MiniUPnPc library [3] which implements the IGD client functionality in ANSI C. This allows it to be used with a variety of languages, in this particular case C++.\n\nThe popular C++-based framework Qt doesn’t have native support for UPnP, thus one has to use an external library to add such support. I am currently using MiniUPnPc 1.6 with the Qt 4.7.4 libraries using the MinGW compiler.\n\nCompiling MiniUPnPC is a quick and painless process. On Windows it’s as easy as executing the provided BAT file with MinGW in the PATH and within ten seconds you are left with an .a and .lib library. There’s also MSVC project support if you want to use MSVC, although I haven’t tested it yet.\n\nAt this point we can add the first bits of IGD support to our application. Most crucial is adding these parts to the top of the source file:\n\n#define STATICLIB #include <miniupnpc.h>\n\nNext we have to initialize the network socket library, in this case Winsock2:\n\nWSADATA wsaData; int nResult = WSAStartup(MAKEWORD(2,2), &wsaData); if(nResult != NO_ERROR) { QMessageBox::critical(this, \"Error\", \"WSAStartup() failed.\"); return; }\n\nWith that out of the way, we can verify that all is working using the simple demo code below:\n\nUPNPDev* devlist; UPNPUrls urls; IGDdatas data; char lanaddr[64]; // IP address on the LAN const char* multicastif = 0; const char* minissdpdpath = 0; int error; devlist = upnpDiscover(1000, multicastif, minissdpdpath, 0, 0, &error); if (error > 0) { QMessageBox::critical(this, \"Error\", \"UPnP discovery failed: \" + QString::number(error)); } else { error = UPNP_GetValidIGD(devlist, &urls, &data, lanaddr, sizeof(lanaddr)); freeUPNPDevlist(devlist); if (error == 0) { QMessageBox::critical(this, tr(\"Devices\"), tr(\"No IGD found.\")); } else if (error == 1) { QMessageBox::critical(this, tr(\"Devices\"), tr(\"A valid connected IGD has been found.\")); } else if (error == 2) { QMessageBox::critical(this, tr(\"Devices\"), tr(\"A valid IGD has been found, but it reported as not connected.\")); } else if (error == 3) { QMessageBox::critical(this, tr(\"Devices\"), tr(\"An UPnP device was found, but wasn't recognized as an IGD.\")); } }\n\nAs defined in the source code, the error codes for the upnpDiscover() function are as follows:\n\n#define UPNPDISCOVER_SUCCESS (0) #define UPNPDISCOVER_UNKNOWN_ERROR (-1) #define UPNPDISCOVER_SOCKET_ERROR (-101) #define UPNPDISCOVER_MEMORY_ERROR (-102)\n\nNow, to get it all to compile so that we can test it. In our Qt project we need to add a few items to the Pro file. First, depending on whether the library file we intend to use is already in a known location (MinGW lib folder or Qt SDK’s lib folder) we may have to add its location using\n\nLIBS += D:/dev/miniupnpc/miniupnpc.a\n\nPersonally I prefer to put the library files I use a lot in projects directly into the compiler’s lib folder. This means I only have to add the following to the Pro file for it:\n\nLIBS += -lminiupnpc -liphlpapi\n\nNote hereby that the library itself is called ‘libminiupnpc.a’, but we prefix with -l and omit the ‘lib’ and extension. Finally we must include the libiphlpapi.a library as it contains a number of functions used by MiniUPnPc’s network functionality.\n\nAt this point we should be able to compile the project and have it run successfully. If there’s a device on the network (router) with IGD (UPnP) enabled, it will respond to the discovery broadcast and be identified. You can verify the output using the commandline test application provided with MiniUPnPc ‘upnpc-static.exe’. Detailed sample code can be found in upnpc.c, which is the source for the test application. There isn’t much available in terms of documentation, but with some puzzling and liberal use of said sample source code, it shouldn’t be too hard to figure out how to do something.\n\nUntil next time,\n\nMaya\n\n[1] http://en.wikipedia.org/wiki/Internet_Gateway_Device_Protocol\n\n[2] http://upnp.org/sdcps-and-certification/resources/sdks/\n\n[3] http://miniupnp.free.fr/"
    }
}