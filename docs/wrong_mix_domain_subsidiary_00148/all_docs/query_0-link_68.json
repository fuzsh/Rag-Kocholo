{
    "id": "wrong_mix_domain_subsidiary_00148_0",
    "rank": 68,
    "data": {
        "url": "https://www.sqlservercentral.com/forums/topic/with-nolock-vs-readuncommited-proper-way-performance-differences",
        "read_more_link": "",
        "language": "en",
        "title": "performance differences – SQLServerCentral Forums",
        "top_image": "https://www.sqlservercentral.com/wp-content/uploads/2024/01/navigating-the-database-landscape-2024.png",
        "meta_img": "",
        "images": [
            "https://www.sqlservercentral.com/wp-content/themes/ssc-twentyeighteen/images/header/ssc-logo.svg?v=1669030349",
            "https://www.sqlservercentral.com/wp-content/themes/ssc-twentyeighteen/images/header/ssc.svg",
            "https://www.sqlservercentral.com/wp-content/uploads/2024/01/navigating-the-database-landscape-2024.png",
            "https://www.sqlservercentral.com/wp-content/themes/ssc-twentyeighteen/images/footer/redgate.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2018-11-14T14:27:35+00:00",
        "summary": "",
        "meta_description": "WITH (NOLOCK) vs READUNCOMMITED proper way / performance differences Forum – Learn more on SQLServerCentral",
        "meta_lang": "en",
        "meta_favicon": "https://www.sqlservercentral.com/wp-content/uploads/2019/04/favicon.ico",
        "meta_site_name": "SQLServerCentral",
        "canonical_link": "https://www.sqlservercentral.com/forums/topic/with-nolock-vs-readuncommited-proper-way-performance-differences",
        "text": "Good afternoon everybody,\n\nI need help from the Community.\n\nFor the purposes of this post I do not worry about dirty reads. In my example I have 3 SQL statements, that I am executing within a query, i.e.:\n\nSELECT * FROM table1 WITH (NOLOCK) ;\n\nGO\n\nSELECT * FROM table2 WITH (NOLOCK);\n\nGO\n\nSELECT * FROM table3 WITH (NOLOCK);\n\nGO\n\nCould anyone please tell me if there is any performance if I would execute the following 3 scripts.\n\nSELECT * FROM table1 WITH (READUNCOMMITTED) ;\n\nGO\n\nSELECT * FROM table2 WITH (READUNCOMMITTED);\n\nGO\n\nSELECT * FROM table3 WITH (READUNCOMMITTED);\n\nGO\n\nThese scripts are being executed on the query level.\n\nBut I would also be very curious to figure out if there is any difference if we are placing the similar scripts in the stored procedures or other objects.\n\nHints (Transact-SQL) - Table\n\nNOLOCK Is equivalent to READUNCOMMITTED\n\nREADUNCOMMITTED\n\nSpecifies that dirty reads are allowed. No shared locks are issued to prevent other transactions from modifying data read by the current transaction, and exclusive locks set by other transactions do not block the current transaction from reading the locked data. Allowing dirty reads can cause higher concurrency, but at the cost of reading data modifications that then are rolled back by other transactions. This may generate errors for your transaction, present users with data that was never committed, or cause users to see records twice (or not at all).\n\nREADUNCOMMITTED and NOLOCK hints apply only to data locks. All queries, including those with READUNCOMMITTED and NOLOCK hints, acquire Sch-S (schema stability) locks during compilation and execution. Because of this, queries are blocked when a concurrent transaction holds a Sch-M (schema modification) lock on the table. For example, a data definition language (DDL) operation acquires a Sch-M lock before it modifies the schema information of the table. Any concurrent queries, including those running with READUNCOMMITTED or NOLOCK hints, are blocked when attempting to acquire a Sch-S lock. Conversely, a query holding a Sch-S lock blocks a concurrent transaction that attempts to acquire a Sch-M lock.\n\nREADUNCOMMITTED and NOLOCK cannot be specified for tables modified by insert, update, or delete operations. The SQL Server query optimizer ignores the READUNCOMMITTED and NOLOCK hints in the FROM clause that apply to the target table of an UPDATE or DELETE statement\n\nLet's start with this:\n\nBoth are evil!\n\nThat out of the way, you can only use NOLOCK by modifying code. You can use READ UNCOMITTED by changing the transaction isolation settings within the calling code (you absolutely do not have to hint it the way you've done, in fact, that's a horrific use of READ UNCOMMITTED). Here's some documentation on that.\n\nWhile I truly hate the way these options get used, I strongly recommend that you don't use NOLOCK and instead use READ UNCOMMITTED. The reason I say this is not because one behaves differently or better than the other. The reason I say this is because you should be able to change your isolation levels in one location. This means, when you realize just how horrible the things you're doing to your data are, you can easily fix it by making a single change as opposed to having to change every single query, procedure and prepared statement.\n\n\"The credit belongs to the man who is actually in the arena, whose face is marred by dust and sweat and blood\"\n\n- Theodore Roosevelt\n\nAuthor of:\n\nSQL Server Execution Plans\n\nSQL Server Query Performance Tuning\n\nIsolation level determines how much time your query will spend waiting for other processes to commit their updates. In a transaction databases (where many users are querying and updating at the same time), a query running under the default READ COMMITTED isolation level will typically alternate in and out of a blocked state many times during the course of it's execution. In contrast, READ UNCOMMITTED isolation level will not wait for update locks to be released, it will read pages in whatever state they happen to be in at the moment. For a long running query, this could mean you'll be returning duplicated rows or only part of a batch update.\n\nSo, here is an analogy: Let's assume your boss asks you to count the number of people who show up for a conference, so you can then call the catering company and order the proper number of lunches. You want as accurate a count as possible, but maybe you don't want to wait too long to get that count either.\n\nREAD UNCOMMITTED isolation (also enabled using the NOLOCK hint) would simply do a quick head count while folks are still entering and leaving the convention hall. You would get the result sooner, but it may not be entirely accurate, depending on the degree of moving about.\n\nREAD COMMITTED (the default isolation level when none is specified) would wait until all attendees are settled into their seats and then count heads.\n\nREAD COMMITTED SNAPSHOT isolation would take a photo of the convention hall, so you would have an accurate count as of a specific moment in time.\n\nSERIALIZABLE isolation would temporarily block anyone from entering or leaving the convention hall until your head count is completed. This is quickest isolation to run under (at least from your perspective), but you're causing other people to wait, because you're holding exclusive locks instead of shared locks.\n\n\"Do not seek to follow in the footsteps of the wise. Instead, seek what they sought.\" - Matsuo Basho\n\nHi again,\n\nI know what are the isolation levels, and the differences between them. I was giving exanples for reports that do not need precise accuracy (does not mean that I am using these statements).\n\nDevelopers often issuing similar scripts in pre-production environments without transactions. Some of them utilizing WITH (NOLOCK) in each 'select' statement, the others WITH (READUNCOMMITED).\n\nMy question is, if BEGIN TRANSACTION not set, then is issuing the WITH (READUNCOMMITED) on every select statement performance wise the same as WITH (NOLOCK)?\n\nMy feeling is that WITH (READUNCOMMITED) should take longer time. And also I beleive that issuing WITH (READUNCOMMITED) on every select statement is wrong?\n\nI am not sure how to accurately test the performance differences.\n\nThank you\n\nHello\n\nI know this thread is almost 2 years old, however sticks to my current situation to a measured extend. We were using Oracle database & related technologies and currently moving to MS SQL & other Microsoft technologies.\n\nI've been working with Oracle database & as there are no table hints like WITH(NOLOCK) or READPAST, I need some guidance to get start with MS SQL\n\nWe will ONLY read committed rows, said, no dirty reading. I've been referring multiple documents about MS SQL table hints and couple of places read that the Select statement could place a lock on the table, blocking other transactions. Hence, I am eager to know how exactly we circumvent situations when a time consuming query executing against a table that is expected to being committed few times per minute (Sales Order Headers/Sales Order Lines tables)\n\nAs the select statements will be doing analysis of sales and other MIS we cannot afford to have dirty reads. I hope I have made myself as clear as possible and apologize for not knowing many technical terms those are specific to MS SQL.\n\nThanks and regards,\n\nrajesh\n\nThis reply was modified 4 years, 3 months ago by rajthampi. Reason: Sentence corrections\n\nThis reply was modified 4 years, 3 months ago by rajthampi.\n\nHello @Grant\n\nThank you very much. I've read about snapshots at StackOverFlow and few other places, however, my primary concern is not truly answered.\n\nI would pry you to give me a hint about long running queries locking up referred tables. For example, our Oracle EBS material transaction table has 11M rows & at times when materialized views are insufficient (A day old usually), we are forced to refer the base table, which is updated every other second & never had any lockups or related performance issues as Oracle only selects committed rows. With MS SQL, it looks like the approach is different, hence WITH(NOLOCK) & hints are used.\n\nIf this statement is true, I have to design accordingly. We are planning to develop a subsystem for the new business application & throughout the discussions the other party (Software vendor) was asking us to use WITH(NOLOCK) against the queries we are going to execute against their tables.\n\nregards,\n\nrajesh\n\nAs Grant mentioned in order to achieve a similar functionality like Oracle you need to have your database set with Read Committed Snapshot (RCSI).\n\nBasically with RCSI your readers will not block writers and your writers will not block your readers, and it also means you do not need to use the hint \"with (nolock)\" (by the way the name is not wait(nolock) and in any case you should almost NEVER use this hint)\n\nthis will give you the same behavior as Oracle.\n\nsee some comments on it here\n\nand have a look at these also\n\nhttps://littlekendra.com/2016/02/18/how-to-choose-rcsi-snapshot-isolation-levels/\n\nhttps://www.brentozar.com/archive/2013/01/implementing-snapshot-or-read-committed-snapshot-isolation-in-sql-server-a-guide/\n\nhttps://www.red-gate.com/simple-talk/sql/performance/read-committed-snapshot-isolation-high-version_ghost_record_count/\n\nYour application needs to be designed to deal with the issues that using RCSI has which are pretty much the same that Oracle has. e.g. when updating a record it needs to verify that the record has not been changed since it was last read by the transaction that is updating it.\n\nfor your info on my shop majority of databases have RCSI enabled (and we have a lot of them!!)\n\nmain ones that have been designed to use it\n\nMicrosoft CRM - Uses sp_getapplock to enable correct handling possible multiple updates of same set of records in multiple tables\n\nIn House Pollicy Admin system - uses built in controls - each table has a transactionid column that gets updated with every single update statement with a new value, and the code when doing the update verifies that the value of this column is the same as it was when the application read the record."
    }
}