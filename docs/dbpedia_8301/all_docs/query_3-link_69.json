{
    "id": "dbpedia_8301_3",
    "rank": 69,
    "data": {
        "url": "https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto",
        "read_more_link": "",
        "language": "en",
        "title": "mesos/include/mesos/mesos.proto at master Â· apache/mesos",
        "top_image": "https://opengraph.githubassets.com/5be345bd39bcdd0daa3f7b80c456f28844188b102d99789f3349c4e20e036bc6/apache/mesos",
        "meta_img": "https://opengraph.githubassets.com/5be345bd39bcdd0daa3f7b80c456f28844188b102d99789f3349c4e20e036bc6/apache/mesos",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "Apache Mesos. Contribute to apache/mesos development by creating an account on GitHub.",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/apache/mesos/blob/master/include/mesos/mesos.proto",
        "text": "// Licensed to the Apache Software Foundation (ASF) under one\n\n// or more contributor license agreements. See the NOTICE file\n\n// distributed with this work for additional information\n\n// regarding copyright ownership. The ASF licenses this file\n\n// to you under the Apache License, Version 2.0 (the\n\n// \"License\"); you may not use this file except in compliance\n\n// with the License. You may obtain a copy of the License at\n\n//\n\n// http://www.apache.org/licenses/LICENSE-2.0\n\n//\n\n// Unless required by applicable law or agreed to in writing, software\n\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n\n// See the License for the specific language governing permissions and\n\n// limitations under the License.\n\nsyntax = \"proto2\";\n\npackage mesos;\n\noption cc_enable_arenas = true;\n\noption java_package = \"org.apache.mesos\";\n\noption java_outer_classname = \"Protos\";\n\n/**\n\n* Status is used to indicate the state of the scheduler and executor\n\n* driver after function calls.\n\n*/\n\nenum Status {\n\nDRIVER_NOT_STARTED = 1;\n\nDRIVER_RUNNING = 2;\n\nDRIVER_ABORTED = 3;\n\nDRIVER_STOPPED = 4;\n\n}\n\n/**\n\n* A unique ID assigned to a framework. A framework can reuse this ID\n\n* in order to do failover (see MesosSchedulerDriver).\n\n*/\n\nmessage FrameworkID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* A unique ID assigned to an offer.\n\n*/\n\nmessage OfferID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* A unique ID assigned to a slave. Currently, a slave gets a new ID\n\n* whenever it (re)registers with Mesos. Framework writers shouldn't\n\n* assume any binding between a slave ID and and a hostname.\n\n*/\n\nmessage SlaveID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* A framework-generated ID to distinguish a task. The ID must remain\n\n* unique while the task is active. A framework can reuse an ID _only_\n\n* if the previous task with the same ID has reached a terminal state\n\n* (e.g., TASK_FINISHED, TASK_KILLED, etc.). However, reusing task IDs\n\n* is strongly discouraged (MESOS-2198).\n\n*/\n\nmessage TaskID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* A framework-generated ID to distinguish an executor. Only one\n\n* executor with the same ID can be active on the same slave at a\n\n* time. However, reusing executor IDs is discouraged.\n\n*/\n\nmessage ExecutorID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* ID used to uniquely identify a container. If the `parent` is not\n\n* specified, the ID is a UUID generated by the agent to uniquely\n\n* identify the container of an executor run. If the `parent` field is\n\n* specified, it represents a nested container.\n\n*/\n\nmessage ContainerID {\n\nrequired string value = 1;\n\noptional ContainerID parent = 2;\n\n}\n\n/**\n\n* A unique ID assigned to a resource provider. Currently, a resource\n\n* provider gets a new ID whenever it (re)registers with Mesos.\n\n*/\n\nmessage ResourceProviderID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* A framework-generated ID to distinguish an operation. The ID\n\n* must be unique within the framework.\n\n*/\n\nmessage OperationID {\n\nrequired string value = 1;\n\n}\n\n/**\n\n* Represents time since the epoch, in nanoseconds.\n\n*/\n\nmessage TimeInfo {\n\nrequired int64 nanoseconds = 1;\n\n}\n\n/**\n\n* Represents duration in nanoseconds.\n\n*/\n\nmessage DurationInfo {\n\nrequired int64 nanoseconds = 1;\n\n}\n\n/**\n\n* A network address.\n\n*\n\n* TODO(bmahler): Use this more widely.\n\n*/\n\nmessage Address {\n\n// May contain a hostname, IP address, or both.\n\noptional string hostname = 1;\n\noptional string ip = 2;\n\nrequired int32 port = 3;\n\n}\n\n/**\n\n* Represents a URL.\n\n*/\n\nmessage URL {\n\nrequired string scheme = 1;\n\nrequired Address address = 2;\n\noptional string path = 3;\n\nrepeated Parameter query = 4;\n\noptional string fragment = 5;\n\n}\n\n/**\n\n* Represents an interval, from a given start time over a given duration.\n\n* This interval pertains to an unavailability event, such as maintenance,\n\n* and is not a generic interval.\n\n*/\n\nmessage Unavailability {\n\nrequired TimeInfo start = 1;\n\n// When added to `start`, this represents the end of the interval.\n\n// If unspecified, the duration is assumed to be infinite.\n\noptional DurationInfo duration = 2;\n\n// TODO(josephw): Add additional fields for expressing the purpose and\n\n// urgency of the unavailability event.\n\n}\n\n/**\n\n* Represents a single machine, which may hold one or more slaves.\n\n*\n\n* NOTE: In order to match a slave to a machine, both the `hostname` and\n\n* `ip` must match the values advertised by the slave to the master.\n\n* Hostname is not case-sensitive.\n\n*/\n\nmessage MachineID {\n\noptional string hostname = 1;\n\noptional string ip = 2;\n\n}\n\n/**\n\n* Holds information about a single machine, its `mode`, and any other\n\n* relevant information which may affect the behavior of the machine.\n\n*/\n\nmessage MachineInfo {\n\n// Describes the several states that a machine can be in. A `Mode`\n\n// applies to a machine and to all associated slaves on the machine.\n\nenum Mode {\n\n// In this mode, a machine is behaving normally;\n\n// offering resources, executing tasks, etc.\n\nUP = 1;\n\n// In this mode, all slaves on the machine are expected to cooperate with\n\n// frameworks to drain resources. In general, draining is done ahead of\n\n// a pending `unavailability`. The resources should be drained so as to\n\n// maximize utilization prior to the maintenance but without knowingly\n\n// violating the frameworks' requirements.\n\nDRAINING = 2;\n\n// In this mode, a machine is not running any tasks and will not offer\n\n// any of its resources. Slaves on the machine will not be allowed to\n\n// register with the master.\n\nDOWN = 3;\n\n}\n\nrequired MachineID id = 1;\n\noptional Mode mode = 2;\n\n// Signifies that the machine may be unavailable during the given interval.\n\n// See comments in `Unavailability` and for the `unavailability` fields\n\n// in `Offer` and `InverseOffer` for more information.\n\noptional Unavailability unavailability = 3;\n\n}\n\n/**\n\n* Describes a framework.\n\n*/\n\nmessage FrameworkInfo {\n\n// Used to determine the Unix user that an executor or task should be\n\n// launched as.\n\n//\n\n// When using the MesosSchedulerDriver, if the field is set to an\n\n// empty string, it will automagically set it to the current user.\n\n//\n\n// When using the HTTP Scheduler API, the user has to be set\n\n// explicitly.\n\nrequired string user = 1;\n\n// Name of the framework that shows up in the Mesos Web UI.\n\nrequired string name = 2;\n\n// Used to uniquely identify the framework.\n\n//\n\n// This field must be unset when the framework subscribes for the\n\n// first time upon which the master will assign a new ID. To\n\n// resubscribe after scheduler failover the framework should set\n\n// 'id' to the ID assigned by the master. Setting 'id' to values\n\n// not assigned by Mesos masters is unsupported.\n\noptional FrameworkID id = 3;\n\n// The amount of time (in seconds) that the master will wait for the\n\n// scheduler to failover before it tears down the framework by\n\n// killing all its tasks/executors. This should be non-zero if a\n\n// framework expects to reconnect after a failure and not lose its\n\n// tasks/executors.\n\n//\n\n// NOTE: To avoid accidental destruction of tasks, production\n\n// frameworks typically set this to a large value (e.g., 1 week).\n\noptional double failover_timeout = 4 [default = 0.0];\n\n// If set, agents running tasks started by this framework will write\n\n// the framework pid, executor pids and status updates to disk. If\n\n// the agent exits (e.g., due to a crash or as part of upgrading\n\n// Mesos), this checkpointed data allows the restarted agent to\n\n// reconnect to executors that were started by the old instance of\n\n// the agent. Enabling checkpointing improves fault tolerance, at\n\n// the cost of a (usually small) increase in disk I/O.\n\noptional bool checkpoint = 5 [default = false];\n\n// Roles are the entities to which allocations are made.\n\n// The framework must have at least one role in order to\n\n// be offered resources. Note that `role` is deprecated\n\n// in favor of `roles` and only one of these fields must\n\n// be used. Since we cannot distinguish between empty\n\n// `roles` and the default unset `role`, we require that\n\n// frameworks set the `MULTI_ROLE` capability if\n\n// setting the `roles` field.\n\noptional string role = 6 [default = \"*\", deprecated=true];\n\nrepeated string roles = 12;\n\n// Used to indicate the current host from which the scheduler is\n\n// registered in the Mesos Web UI. If set to an empty string Mesos\n\n// will automagically set it to the current hostname if one is\n\n// available.\n\noptional string hostname = 7;\n\n// This field should match the credential's principal the framework\n\n// uses for authentication. This field is used for framework API\n\n// rate limiting and dynamic reservations. It should be set even\n\n// if authentication is not enabled if these features are desired.\n\noptional string principal = 8;\n\n// This field allows a framework to advertise its web UI, so that\n\n// the Mesos web UI can link to it. It is expected to be a full URL,\n\n// for example http://my-scheduler.example.com:8080/.\n\noptional string webui_url = 9;\n\nmessage Capability {\n\nenum Type {\n\n// This must be the first enum value in this list, to\n\n// ensure that if 'type' is not set, the default value\n\n// is UNKNOWN. This enables enum values to be added\n\n// in a backwards-compatible way. See: MESOS-4997.\n\nUNKNOWN = 0;\n\n// Receive offers with revocable resources. See 'Resource'\n\n// message for details.\n\nREVOCABLE_RESOURCES = 1;\n\n// Receive the TASK_KILLING TaskState when a task is being\n\n// killed by an executor. The executor will examine this\n\n// capability to determine whether it can send TASK_KILLING.\n\nTASK_KILLING_STATE = 2;\n\n// Indicates whether the framework is aware of GPU resources.\n\n// Frameworks that are aware of GPU resources are expected to\n\n// avoid placing non-GPU workloads on GPU agents, in order\n\n// to avoid occupying a GPU agent and preventing GPU workloads\n\n// from running! Currently, if a framework is unaware of GPU\n\n// resources, it will not be offered *any* of the resources on\n\n// an agent with GPUs. This restriction is in place because we\n\n// do not have a revocation mechanism that ensures GPU workloads\n\n// can evict GPU agent occupants if necessary.\n\n//\n\n// TODO(bmahler): As we add revocation we can relax the\n\n// restriction here. See MESOS-5634 for more information.\n\nGPU_RESOURCES = 3;\n\n// Receive offers with resources that are shared.\n\nSHARED_RESOURCES = 4;\n\n// Indicates that (1) the framework is prepared to handle the\n\n// following TaskStates: TASK_UNREACHABLE, TASK_DROPPED,\n\n// TASK_GONE, TASK_GONE_BY_OPERATOR, and TASK_UNKNOWN, and (2)\n\n// the framework will assume responsibility for managing\n\n// partitioned tasks that reregister with the master.\n\n//\n\n// Frameworks that enable this capability can define how they\n\n// would like to handle partitioned tasks. Frameworks will\n\n// receive TASK_UNREACHABLE for tasks on agents that are\n\n// partitioned from the master.\n\n//\n\n// Without this capability, frameworks will receive TASK_LOST\n\n// for tasks on partitioned agents.\n\n// NOTE: Prior to Mesos 1.5, such tasks will be killed by Mesos\n\n// when the agent reregisters (unless the master has failed over).\n\n// However due to the lack of benefit in maintaining different\n\n// behaviors depending on whether the master has failed over\n\n// (see MESOS-7215), as of 1.5, Mesos will not kill these\n\n// tasks in either case.\n\nPARTITION_AWARE = 5;\n\n// This expresses the ability for the framework to be\n\n// \"multi-tenant\" via using the newly introduced `roles`\n\n// field, and examining `Offer.allocation_info` to determine\n\n// which role the offers are being made to. We also\n\n// expect that \"single-tenant\" schedulers eventually\n\n// provide this and move away from the deprecated\n\n// `role` field.\n\nMULTI_ROLE = 6;\n\n// This capability has two effects for a framework.\n\n//\n\n// (1) The framework is offered resources in a new format.\n\n//\n\n// The offered resources have the `Resource.reservations` field set\n\n// rather than `Resource.role` and `Resource.reservation`. In short,\n\n// an empty `reservations` field denotes unreserved resources, and\n\n// each `ReservationInfo` in the `reservations` field denotes a\n\n// reservation that refines the previous one.\n\n//\n\n// See the 'Resource Format' section for more details.\n\n//\n\n// (2) The framework can create refined reservations.\n\n//\n\n// A framework can refine an existing reservation via the\n\n// `Resource.reservations` field. For example, a reservation for role\n\n// `eng` can be refined to `eng/front_end`.\n\n//\n\n// See `ReservationInfo.reservations` for more details.\n\n//\n\n// NOTE: Without this capability, a framework is not offered resources\n\n// that have refined reservations. A resource is said to have refined\n\n// reservations if it uses the `Resource.reservations` field, and\n\n// `Resource.reservations_size() > 1`.\n\nRESERVATION_REFINEMENT = 7; // EXPERIMENTAL.\n\n// Indicates that the framework is prepared to receive offers\n\n// for agents whose region is different from the master's\n\n// region. Network links between hosts in different regions\n\n// typically have higher latency and lower bandwidth than\n\n// network links within a region, so frameworks should be\n\n// careful to only place suitable workloads in remote regions.\n\n// Frameworks that are not region-aware will never receive\n\n// offers for remote agents; region-aware frameworks are assumed\n\n// to implement their own logic to decide which workloads (if\n\n// any) are suitable for placement on remote agents.\n\nREGION_AWARE = 8;\n\n}\n\n// Enum fields should be optional, see: MESOS-4997.\n\noptional Type type = 1;\n\n}\n\n// This field allows a framework to advertise its set of\n\n// capabilities (e.g., ability to receive offers for revocable\n\n// resources).\n\nrepeated Capability capabilities = 10;\n\n// Labels are free-form key value pairs supplied by the framework\n\n// scheduler (e.g., to describe additional functionality offered by\n\n// the framework). These labels are not interpreted by Mesos itself.\n\n// Labels should not contain duplicate key-value pairs.\n\noptional Labels labels = 11;\n\n// Specifc resource requirements for each of the framework's roles. This field\n\n// is used by e.g., the default allocator to decide whether a framework is\n\n// interested in seeing a resource of a certain shape.\n\nmap<string, OfferFilters> offer_filters = 13;\n\n}\n\n/**\n\n* Describes a general non-interpreting non-killing check for a task or\n\n* executor (or any arbitrary process/command). A type is picked by\n\n* specifying one of the optional fields. Specifying more than one type\n\n* is an error.\n\n*\n\n* NOTE: This API is subject to change and the related feature is experimental.\n\n*/\n\nmessage CheckInfo {\n\nenum Type {\n\nUNKNOWN = 0;\n\nCOMMAND = 1;\n\nHTTP = 2;\n\nTCP = 3;\n\n// TODO(alexr): Consider supporting custom user checks. They should\n\n// probably be paired with a `data` field and complemented by a\n\n// `data` response in `CheckStatusInfo`.\n\n}\n\n// Describes a command check. If applicable, enters mount and/or network\n\n// namespaces of the task.\n\nmessage Command {\n\nrequired CommandInfo command = 1;\n\n}\n\n// Describes an HTTP check. Sends a GET request to\n\n// http://<host>:port/path. Note that <host> is not configurable and is\n\n// resolved automatically to 127.0.0.1.\n\nmessage Http {\n\n// Port to send the HTTP request.\n\nrequired uint32 port = 1;\n\n// HTTP request path.\n\noptional string path = 2;\n\n// TODO(alexr): Add support for HTTP method. While adding POST\n\n// and PUT is simple, supporting payload is more involved.\n\n// TODO(alexr): Add support for custom HTTP headers.\n\n// TODO(alexr): Consider adding an optional message to describe TLS\n\n// options and thus enabling https. Such message might contain certificate\n\n// validation, TLS version.\n\n}\n\n// Describes a TCP check, i.e. based on establishing a TCP connection to\n\n// the specified port. Note that <host> is not configurable and is resolved\n\n// automatically to 127.0.0.1.\n\nmessage Tcp {\n\nrequired uint32 port = 1;\n\n}\n\n// The type of the check.\n\noptional Type type = 1;\n\n// Command check.\n\noptional Command command = 2;\n\n// HTTP check.\n\noptional Http http = 3;\n\n// TCP check.\n\noptional Tcp tcp = 7;\n\n// Amount of time to wait to start checking the task after it\n\n// transitions to `TASK_RUNNING` or `TASK_STARTING` if the latter\n\n// is used by the executor.\n\noptional double delay_seconds = 4 [default = 15.0];\n\n// Interval between check attempts, i.e., amount of time to wait after\n\n// the previous check finished or timed out to start the next check.\n\noptional double interval_seconds = 5 [default = 10.0];\n\n// Amount of time to wait for the check to complete. Zero means infinite\n\n// timeout.\n\n//\n\n// After this timeout, the check attempt is aborted and no result is\n\n// reported. Note that this may be considered a state change and hence\n\n// may trigger a check status change delivery to the corresponding\n\n// scheduler. See `CheckStatusInfo` for more details.\n\noptional double timeout_seconds = 6 [default = 20.0];\n\n}\n\n/**\n\n* Describes a health check for a task or executor (or any arbitrary\n\n* process/command). A type is picked by specifying one of the\n\n* optional fields. Specifying more than one type is an error.\n\n*/\n\nmessage HealthCheck {\n\nenum Type {\n\nUNKNOWN = 0;\n\nCOMMAND = 1;\n\nHTTP = 2;\n\nTCP = 3;\n\n}\n\n// Describes an HTTP health check. Sends a GET request to\n\n// scheme://<host>:port/path. Note that <host> is not configurable and is\n\n// resolved automatically, in most cases to 127.0.0.1. Default executors\n\n// treat return codes between 200 and 399 as success; custom executors\n\n// may employ a different strategy, e.g. leveraging the `statuses` field.\n\nmessage HTTPCheckInfo {\n\noptional NetworkInfo.Protocol protocol = 5 [default = IPv4];\n\n// Currently \"http\" and \"https\" are supported.\n\noptional string scheme = 3;\n\n// Port to send the HTTP request.\n\nrequired uint32 port = 1;\n\n// HTTP request path.\n\noptional string path = 2;\n\n// TODO(alexr): Add support for HTTP method. While adding POST\n\n// and PUT is simple, supporting payload is more involved.\n\n// TODO(alexr): Add support for custom HTTP headers.\n\n// TODO(alexr): Add support for success and possibly failure\n\n// statuses.\n\n// NOTE: It is up to the custom executor to interpret and act on this\n\n// field. Setting this field has no effect on the default executors.\n\n//\n\n// TODO(haosdent): Deprecate this field when we add better support for\n\n// success and possibly failure statuses, e.g. ranges of success and\n\n// failure statuses.\n\nrepeated uint32 statuses = 4;\n\n// TODO(haosdent): Consider adding a flag to enable task's certificate\n\n// validation for HTTPS health checks, see MESOS-5997.\n\n// TODO(benh): Include an 'optional bytes data' field for checking\n\n// for specific data in the response.\n\n}\n\n// Describes a TCP health check, i.e. based on establishing\n\n// a TCP connection to the specified port.\n\nmessage TCPCheckInfo {\n\noptional NetworkInfo.Protocol protocol = 2 [default = IPv4];\n\n// Port expected to be open.\n\nrequired uint32 port = 1;\n\n}\n\n// TODO(benh): Consider adding a URL health check strategy which\n\n// allows doing something similar to the HTTP strategy but\n\n// encapsulates all the details in a single string field.\n\n// Amount of time to wait to start health checking the task after it\n\n// transitions to `TASK_RUNNING` or `TASK_STATING` if the latter is\n\n// used by the executor.\n\noptional double delay_seconds = 2 [default = 15.0];\n\n// Interval between health checks, i.e., amount of time to wait after\n\n// the previous health check finished or timed out to start the next\n\n// health check.\n\noptional double interval_seconds = 3 [default = 10.0];\n\n// Amount of time to wait for the health check to complete. After this\n\n// timeout, the health check is aborted and treated as a failure. Zero\n\n// means infinite timeout.\n\noptional double timeout_seconds = 4 [default = 20.0];\n\n// Number of consecutive failures until the task is killed by the executor.\n\noptional uint32 consecutive_failures = 5 [default = 3];\n\n// Amount of time after the task is launched during which health check\n\n// failures are ignored. Once a check succeeds for the first time,\n\n// the grace period does not apply anymore. Note that it includes\n\n// `delay_seconds`, i.e., setting `grace_period_seconds` < `delay_seconds`\n\n// has no effect.\n\noptional double grace_period_seconds = 6 [default = 10.0];\n\n// TODO(alexr): Add an optional `KillPolicy` that should be used\n\n// if the task is killed because of a health check failure.\n\n// The type of health check.\n\noptional Type type = 8;\n\n// Command health check.\n\noptional CommandInfo command = 7;\n\n// HTTP health check.\n\noptional HTTPCheckInfo http = 1;\n\n// TCP health check.\n\noptional TCPCheckInfo tcp = 9;\n\n}\n\n/**\n\n* Describes a kill policy for a task. Currently does not express\n\n* different policies (e.g. hitting HTTP endpoints), only controls\n\n* how long to wait between graceful and forcible task kill:\n\n*\n\n* graceful kill --------------> forcible kill\n\n* grace_period\n\n*\n\n* Kill policies are best-effort, because machine failures / forcible\n\n* terminations may occur.\n\n*\n\n* NOTE: For executor-less command-based tasks, the kill is performed\n\n* via sending a signal to the task process: SIGTERM for the graceful\n\n* kill and SIGKILL for the forcible kill. For the docker executor-less\n\n* tasks the grace period is passed to 'docker stop --time'.\n\n*/\n\nmessage KillPolicy {\n\n// The grace period specifies how long to wait before forcibly\n\n// killing the task. It is recommended to attempt to gracefully\n\n// kill the task (and send TASK_KILLING) to indicate that the\n\n// graceful kill is in progress. Once the grace period elapses,\n\n// if the task has not terminated, a forcible kill should occur.\n\n// The task should not assume that it will always be allotted\n\n// the full grace period. For example, the executor may be\n\n// shutdown more quickly by the agent, or failures / forcible\n\n// terminations may occur.\n\noptional DurationInfo grace_period = 1;\n\n}\n\n/**\n\n* Describes a command, executed via: '/bin/sh -c value'. Any URIs specified\n\n* are fetched before executing the command. If the executable field for an\n\n* uri is set, executable file permission is set on the downloaded file.\n\n* Otherwise, if the downloaded file has a recognized archive extension\n\n* (currently [compressed] tar and zip) it is extracted into the executor's\n\n* working directory. This extraction can be disabled by setting `extract` to\n\n* false. In addition, any environment variables are set before executing\n\n* the command (so they can be used to \"parameterize\" your command).\n\n*/\n\nmessage CommandInfo {\n\nmessage URI {\n\nrequired string value = 1;\n\noptional bool executable = 2;\n\n// In case the fetched file is recognized as an archive, extract\n\n// its contents into the sandbox. Note that a cached archive is\n\n// not copied from the cache to the sandbox in case extraction\n\n// originates from an archive in the cache.\n\noptional bool extract = 3 [default = true];\n\n// If this field is \"true\", the fetcher cache will be used. If not,\n\n// fetching bypasses the cache and downloads directly into the\n\n// sandbox directory, no matter whether a suitable cache file is\n\n// available or not. The former directs the fetcher to download to\n\n// the file cache, then copy from there to the sandbox. Subsequent\n\n// fetch attempts with the same URI will omit downloading and copy\n\n// from the cache as long as the file is resident there. Cache files\n\n// may get evicted at any time, which then leads to renewed\n\n// downloading. See also \"docs/fetcher.md\" and\n\n// \"docs/fetcher-cache-internals.md\".\n\noptional bool cache = 4;\n\n// The fetcher's default behavior is to use the URI string's basename to\n\n// name the local copy. If this field is provided, the local copy will be\n\n// named with its value instead. If there is a directory component (which\n\n// must be a relative path), the local copy will be stored in that\n\n// subdirectory inside the sandbox.\n\noptional string output_file = 5;\n\n}\n\nrepeated URI uris = 1;\n\noptional Environment environment = 2;\n\n// There are two ways to specify the command:\n\n// 1) If 'shell == true', the command will be launched via shell\n\n// (i.e., /bin/sh -c 'value'). The 'value' specified will be\n\n// treated as the shell command. The 'arguments' will be ignored.\n\n// 2) If 'shell == false', the command will be launched by passing\n\n// arguments to an executable. The 'value' specified will be\n\n// treated as the filename of the executable. The 'arguments'\n\n// will be treated as the arguments to the executable. This is\n\n// similar to how POSIX exec families launch processes (i.e.,\n\n// execlp(value, arguments(0), arguments(1), ...)).\n\n// NOTE: The field 'value' is changed from 'required' to 'optional'\n\n// in 0.20.0. It will only cause issues if a new framework is\n\n// connecting to an old master.\n\noptional bool shell = 6 [default = true];\n\noptional string value = 3;\n\nrepeated string arguments = 7;\n\n// Enables executor and tasks to run as a specific user. If the user\n\n// field is present both in FrameworkInfo and here, the CommandInfo\n\n// user value takes precedence.\n\noptional string user = 5;\n\n}\n\n/**\n\n* Describes information about an executor.\n\n*/\n\nmessage ExecutorInfo {\n\nenum Type {\n\nUNKNOWN = 0;\n\n// Mesos provides a simple built-in default executor that frameworks can\n\n// leverage to run shell commands and containers.\n\n//\n\n// NOTES:\n\n//\n\n// 1) `command` must not be set when using a default executor.\n\n//\n\n// 2) Default executor only accepts a *single* `LAUNCH` or `LAUNCH_GROUP`\n\n// operation.\n\n//\n\n// 3) If `container` is set, `container.type` must be `MESOS`\n\n// and `container.mesos.image` must not be set.\n\nDEFAULT = 1;\n\n// For frameworks that need custom functionality to run tasks, a `CUSTOM`\n\n// executor can be used. Note that `command` must be set when using a\n\n// `CUSTOM` executor.\n\nCUSTOM = 2;\n\n}\n\n// For backwards compatibility, if this field is not set when using `LAUNCH`\n\n// operation, Mesos will infer the type by checking if `command` is set\n\n// (`CUSTOM`) or unset (`DEFAULT`). `type` must be set when using\n\n// `LAUNCH_GROUP` operation.\n\n//\n\n// TODO(vinod): Add support for explicitly setting `type` to `DEFAULT` in\n\n// `LAUNCH` operation.\n\noptional Type type = 15;\n\nrequired ExecutorID executor_id = 1;\n\noptional FrameworkID framework_id = 8; // TODO(benh): Make this required.\n\noptional CommandInfo command = 7;\n\n// Executor provided with a container will launch the container\n\n// with the executor's CommandInfo and we expect the container to\n\n// act as a Mesos executor.\n\noptional ContainerInfo container = 11;\n\nrepeated Resource resources = 5;\n\noptional string name = 9;\n\n// 'source' is an identifier style string used by frameworks to\n\n// track the source of an executor. This is useful when it's\n\n// possible for different executor ids to be related semantically.\n\n//\n\n// NOTE: 'source' is exposed alongside the resource usage of the\n\n// executor via JSON on the slave. This allows users to import usage\n\n// information into a time series database for monitoring.\n\n//\n\n// This field is deprecated since 1.0. Please use labels for\n\n// free-form metadata instead.\n\noptional string source = 10 [deprecated = true]; // Since 1.0.\n\n// This field can be used to pass arbitrary bytes to an executor.\n\noptional bytes data = 4;\n\n// Service discovery information for the executor. It is not\n\n// interpreted or acted upon by Mesos. It is up to a service\n\n// discovery system to use this information as needed and to handle\n\n// executors without service discovery information.\n\noptional DiscoveryInfo discovery = 12;\n\n// When shutting down an executor the agent will wait in a\n\n// best-effort manner for the grace period specified here\n\n// before forcibly destroying the container. The executor\n\n// must not assume that it will always be allotted the full\n\n// grace period, as the agent may decide to allot a shorter\n\n// period and failures / forcible terminations may occur.\n\noptional DurationInfo shutdown_grace_period = 13;\n\n// Labels are free-form key value pairs which are exposed through\n\n// master and slave endpoints. Labels will not be interpreted or\n\n// acted upon by Mesos itself. As opposed to the data field, labels\n\n// will be kept in memory on master and slave processes. Therefore,\n\n// labels should be used to tag executors with lightweight metadata.\n\n// Labels should not contain duplicate key-value pairs.\n\noptional Labels labels = 14;\n\n}\n\n/**\n\n* Describes a domain. A domain is a collection of hosts that have\n\n* similar characteristics. Mesos currently only supports \"fault\n\n* domains\", which identify groups of hosts with similar failure\n\n* characteristics.\n\n*\n\n* Frameworks can generally assume that network links between hosts in\n\n* the same fault domain have lower latency, higher bandwidth, and better\n\n* availability than network links between hosts in different domains.\n\n* Schedulers may prefer to place network-intensive workloads in the\n\n* same domain, as this may improve performance. Conversely, a single\n\n* failure that affects a host in a domain may be more likely to\n\n* affect other hosts in the same domain; hence, schedulers may prefer\n\n* to place workloads that require high availability in multiple\n\n* domains. (For example, all the hosts in a single rack might lose\n\n* power or network connectivity simultaneously.)\n\n*\n\n* There are two kinds of fault domains: regions and zones. Regions\n\n* offer the highest degree of fault isolation, but network latency\n\n* between regions is typically high (typically >50 ms). Zones offer a\n\n* modest degree of fault isolation along with reasonably low network\n\n* latency (typically <10 ms).\n\n*\n\n* The mapping from fault domains to physical infrastructure is up to\n\n* the operator to configure. In cloud environments, regions and zones\n\n* can be mapped to the \"region\" and \"availability zone\" concepts\n\n* exposed by most cloud providers, respectively. In on-premise\n\n* deployments, regions and zones can be mapped to data centers and\n\n* racks, respectively.\n\n*\n\n* Both masters and agents can be configured with domains. Frameworks\n\n* can compare the domains of two hosts to determine if the hosts are\n\n* in the same zone, in different zones in the same region, or in\n\n* different regions. Note that all masters in a given Mesos cluster\n\n* must be in the same region.\n\n*\n\n* Complex deployments may have additional levels of hierarchy: for example,\n\n* multiple racks might be grouped together into \"halls\" and multiple DCs in\n\n* the same geographical vicinity might be grouped together. As a convention,\n\n* the recommended way to represent additional levels of hierarchy is via dot-\n\n* separated labels in the existing zone and region fields. For example, the\n\n* fact that racks \"abc\" and \"def\" are in the same hall might be represented\n\n* using the zone names \"rack-abc.hall-1\" and \"rack-def.hall-1\", for example.\n\n* Software that is not aware of this additional structure will compare the\n\n* zone names for equality- hence, the two zones will be treated as different\n\n* (unrelated) zones. Software that is \"hall-aware\" can inspect the zone names\n\n* and make use of the additional hierarchy.\n\n*/\n\nmessage DomainInfo {\n\nmessage FaultDomain {\n\nmessage RegionInfo {\n\nrequired string name = 1;\n\n}\n\nmessage ZoneInfo {\n\nrequired string name = 1;\n\n}\n\nrequired RegionInfo region = 1;\n\nrequired ZoneInfo zone = 2;\n\n}\n\noptional FaultDomain fault_domain = 1;\n\n}\n\n/**\n\n* Describes a master. This will probably have more fields in the\n\n* future which might be used, for example, to link a framework webui\n\n* to a master webui.\n\n*/\n\nmessage MasterInfo {\n\nrequired string id = 1;\n\n// The IP address (only IPv4) as a packed 4-bytes integer,\n\n// stored in network order. Deprecated, use `address.ip` instead.\n\nrequired uint32 ip = 2;\n\n// The TCP port the Master is listening on for incoming\n\n// HTTP requests; deprecated, use `address.port` instead.\n\nrequired uint32 port = 3 [default = 5050];\n\n// In the default implementation, this will contain information\n\n// about both the IP address, port and Master name; it should really\n\n// not be relied upon by external tooling/frameworks and be\n\n// considered an \"internal\" implementation field.\n\noptional string pid = 4;\n\n// The server's hostname, if available; it may be unreliable\n\n// in environments where the DNS configuration does not resolve\n\n// internal hostnames (eg, some public cloud providers).\n\n// Deprecated, use `address.hostname` instead.\n\noptional string hostname = 5;\n\n// The running Master version, as a string; taken from the\n\n// generated \"master/version.hpp\".\n\noptional string version = 6;\n\n// The full IP address (supports both IPv4 and IPv6 formats)\n\n// and supersedes the use of `ip`, `port` and `hostname`.\n\n// Since Mesos 0.24.\n\noptional Address address = 7;\n\n// The domain that this master belongs to. All masters in a Mesos\n\n// cluster should belong to the same region.\n\noptional DomainInfo domain = 8;\n\nmessage Capability {\n\nenum Type {\n\nUNKNOWN = 0;\n\n// NOTE: When the master starts to use a new capability that\n\n// may prevent compatible downgrade, remember to add the\n\n// capability to `Registry::MinimumCapability`. Conversely,\n\n// the added minimum capability should be removed if the capability\n\n// is deemed to be no longer required for compatible downgrade.\n\n// See MESOS-8878 for more details.\n\n// The master can handle slaves whose state\n\n// changes after reregistering.\n\nAGENT_UPDATE = 1;\n\n// The master can drain or deactivate agents when requested\n\n// via operator APIs.\n\nAGENT_DRAINING = 2;\n\n// The master can handle the new quota API, which supports setting\n\n// limits separately from guarantees (introduced in Mesos 1.9).\n\nQUOTA_V2 = 3;\n\n}\n\noptional Type type = 1;\n\n}\n\nrepeated Capability capabilities = 9;\n\n}\n\n/**\n\n* Describes a slave. Note that the 'id' field is only available after\n\n* a slave is registered with the master, and is made available here\n\n* to facilitate re-registration.\n\n*/\n\nmessage SlaveInfo {\n\nrequired string hostname = 1;\n\noptional int32 port = 8 [default = 5051];\n\n// The configured resources at the agent. This does not include any\n\n// dynamic reservations or persistent volumes that may currently\n\n// exist at the agent.\n\nrepeated Resource resources = 3;\n\nrepeated Attribute attributes = 5;\n\noptional SlaveID id = 6;\n\n// The domain that this slave belongs to. If the slave's region\n\n// differs from the master's region, it will not appear in resource\n\n// offers to frameworks that have not enabled the REGION_AWARE\n\n// capability.\n\noptional DomainInfo domain = 10;\n\n// Slave checkpointing is always enabled in recent Mesos versions;\n\n// the value of this field is ignored.\n\n// TODO(joerg84): Remove checkpoint field after deprecation cycle starting\n\n// with 0.27 (MESOS-2317).\n\noptional bool checkpoint = 7 [default = false];\n\nmessage Capability {\n\nenum Type {\n\n// This must be the first enum value in this list, to\n\n// ensure that if 'type' is not set, the default value\n\n// is UNKNOWN. This enables enum values to be added\n\n// in a backwards-compatible way. See: MESOS-4997.\n\nUNKNOWN = 0;\n\n// This expresses the ability for the agent to be able\n\n// to launch tasks of a 'multi-role' framework.\n\nMULTI_ROLE = 1;\n\n// This expresses the ability for the agent to be able to launch\n\n// tasks, reserve resources, and create volumes using resources\n\n// allocated to a 'hierarchical-role'.\n\n// NOTE: This capability is required specifically for creating\n\n// volumes because a hierchical role includes '/' (slashes) in them.\n\n// Agents with this capability know to transform the '/' (slashes)\n\n// into ' ' (spaces).\n\nHIERARCHICAL_ROLE = 2;\n\n// This capability has three effects for an agent.\n\n//\n\n// (1) The format of the checkpointed resources, and\n\n// the resources reported to master.\n\n//\n\n// These resources are reported in the \"pre-reservation-refinement\"\n\n// format if none of the resources have refined reservations. If any\n\n// of the resources have refined reservations, they are reported in\n\n// the \"post-reservation-refinement\" format. The purpose is to allow\n\n// downgrading of an agent as well as communication with a pre-1.4.0\n\n// master until the reservation refinement feature is actually used."
    }
}