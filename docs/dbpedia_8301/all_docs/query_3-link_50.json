{
    "id": "dbpedia_8301_3",
    "rank": 50,
    "data": {
        "url": "https://mesosphere.github.io/marathon/",
        "read_more_link": "",
        "language": "en",
        "title": "Marathon: A container orchestration platform for Mesos and DC",
        "top_image": "https://mesosphere.github.io/marathon/img/marathon-favicon.ico",
        "meta_img": "https://mesosphere.github.io/marathon/img/marathon-favicon.ico",
        "images": [
            "https://mesosphere.github.io/marathon/img/architecture.png",
            "https://mesosphere.github.io/marathon/img/marathon1.png",
            "https://mesosphere.github.io/marathon/img/marathon2.png",
            "https://mesosphere.github.io/marathon/img/marathon3.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/marathon/img/marathon-favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Overview\n\nMarathon is a production-grade container orchestration platform for Mesosphere’s Datacenter Operating System (DC/OS) and Apache Mesos.\n\nFeatures\n\nHigh Availability. Marathon runs as an active/passive cluster with leader election for 100% uptime.\n\nMultiple container runtimes. Marathon has first-class support for both Mesos containers (using cgroups) and Docker.\n\nStateful apps. Marathon can bind persistent storage volumes to your application. You can run databases like MySQL and Postgres, and have storage accounted for by Mesos.\n\nBeautiful and powerful UI.\n\nConstraints. These allow to e.g. place only one instance of an application per rack, node, etc.\n\nService Discovery & Load Balancing. Several methods available.\n\nHealth Checks. Evaluate your application’s health using HTTP or TCP checks.\n\nEvent Subscription. Supply an HTTP endpoint to receive notifications - for example to integrate with an external load balancer.\n\nMetrics. Query them at /metrics in JSON format, push them to systems like Graphite, StatsD and DataDog, or scrape them using Prometheus.\n\nDeprecated Metrics. Query them at /metrics in JSON format, or push them to systems like Graphite, StatsD and DataDog.\n\nComplete REST API for easy integration and scriptability.\n\nDC/OS features\n\nRunning on DC/OS, Marathon gains the following additional features:\n\nVirtual IP routing. Allocate a dedicated, virtual address to your app. Your app is now reachable anywhere in the cluster, wherever it might be scheduled. Load balancing and rerouting around failures are done automatically.\n\nAuthorization (DC/OS Enterprise Edition only). True multitenancy with each user or group having access to their own applications and groups.\n\nExamples\n\nMarathon orchestrates both apps and frameworks\n\nThe graphic below shows how Marathon runs on Apache Mesos acting as the orchestrator for other applications and services.\n\nMarathon is the first framework to be launched, running directly alongside Mesos. This means the Marathon scheduler processes are started directly using init, upstart, or a similar tool.\n\nMarathon is a powerful way to run other Mesos frameworks: in this case, Chronos. Marathon launches two instances of the Chronos scheduler using the Docker image mesosphere/chronos. The Chronos instances appear in orange on the top row.\n\nIf either of the two Chronos containers fails for any reason, then Marathon will restart them on another agent. This approach ensures that two Chronos processes are always running.\n\nSince Chronos itself is a framework and receives resource offers, it can start tasks on Mesos. In the use case below, Chronos is running two scheduled jobs, shown in blue. One dumps a production MySQL database to S3, while another sends an email newsletter to all customers via Rake.\n\nMeanwhile, Marathon also runs the other application containers - either Docker or Mesos - that make up our website: JBoss servers, Jetty, Sinatra, Rails, and so on.\n\nWe have shown that Marathon is responsible for running other frameworks, helps them maintain 100% uptime, and coexists with them creating workloads in Mesos.\n\nScaling and fault recovery\n\nThe next three images illustrate scaling and container placement.\n\nBelow we see Marathon running three applications, each scaled to a different number of containers: Search (1), Jetty (3), and Rails (5).\n\nAs the website gains traction, we decide to scale out the Search service and our Rails-based application.\n\nWe use the Marathon REST API call to to add more instances. Marathon will take care of placing the new containers on machines with spare capacity, honoring the constraints we previously set. We can see the containers are dynamically placed:\n\nFinally, imagine that one of the datacenter workers trips over a power cord and a server is unplugged. No problem for Marathon: it moves the affected Search and Rails containers to a node that has spare capacity. Marathon has maintained our uptime in the face of machine failure."
    }
}