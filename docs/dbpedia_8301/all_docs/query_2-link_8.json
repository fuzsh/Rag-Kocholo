{
    "id": "dbpedia_8301_2",
    "rank": 8,
    "data": {
        "url": "https://www.baeldung.com/apache-mesos",
        "read_more_link": "",
        "language": "en",
        "title": "A Guide to Apache Mesos",
        "top_image": "https://www.baeldung.com/wp-content/uploads/2017/08/Java-on-Baeldung-2.jpg",
        "meta_img": "https://www.baeldung.com/wp-content/uploads/2017/08/Java-on-Baeldung-2.jpg",
        "images": [
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://secure.gravatar.com/avatar/dc417739e22ae675b0e1f7012bbddaa5?s=50&r=g",
            "https://www.baeldung.com/wp-content/uploads/custom_avatars/Eric-Martin-150x150.jpg",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-arch.jpg 854w, https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-arch-300x207.jpg 300w, https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-arch-768x529.jpg 768w, https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-arch-100x69.jpg 100w",
            "https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-flow.jpg 770w, https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-flow-300x215.jpg 300w, https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-flow-768x551.jpg 768w, https://www.baeldung.com/wp-content/uploads/2019/07/Mesos-flow-100x72.jpg 100w",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2022/04/announcement-icon.png",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-main-1.2.0.jpg",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-rest-post-footer-icn-1.0.0.png",
            "https://www.baeldung.com/wp-content/uploads/2024/01/book-cover-mockito-guide-lg-1.png",
            "https://www.baeldung.com/wp-content/uploads/2016/05/baeldung-security-widget-main-1.2.0-300x235.jpg",
            "https://www.baeldung.com/wp-content/uploads/2024/08/persistence-with-spring-ebook-sidebar-widget.jpg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/logo.svg",
            "https://www.baeldung.com/wp-content/themes/baeldung/icon/whiteleaf.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2019-07-05T22:01:15+02:00",
        "summary": "",
        "meta_description": "Learn how Apache Mesos addresses problems of resource allocation within applications deployed on the same cluster",
        "meta_lang": "en",
        "meta_favicon": "https://www.baeldung.com/wp-content/themes/baeldung/favicon/apple-touch-icon-57x57.png",
        "meta_site_name": "Baeldung",
        "canonical_link": "https://www.baeldung.com/apache-mesos",
        "text": "1. Overview\n\nWe usually deploy various applications on the same cluster of machines. For example, it’s common nowadays to have a distributed processing engine like Apache Spark or Apache Flink with distributed databases like Apache Cassandra in the same cluster.\n\nApache Mesos is a platform that allows effective resource sharing between such applications.\n\nIn this article, we’ll first discuss a few problems of resource allocation within applications deployed on the same cluster. Later, we’ll see how Apache Mesos provides better resource utilization between applications.\n\n2. Sharing the Cluster\n\nMany applications need to share a cluster. By and large, there are two common approaches:\n\nPartition the cluster statically and run an application on each partition\n\nAllocate a set of machines to an application\n\nAlthough these approaches allow applications to run independently of each other, it doesn’t achieve high resource utilization.\n\nFor instance, consider an application that runs only for a short period followed by a period of inactivity. Now, since we have allocated static machines or partitions to this application, we have unutilized resources during the inactive period.\n\nWe can optimize resource utilization by reallocating free resources during the inactive period to other applications.\n\nApache Mesos helps with dynamic resource allocation between applications.\n\n3. Apache Mesos\n\nWith both cluster sharing approaches we discussed above, applications are only aware of the resources of a particular partition or machine they are running. However, Apache Mesos provides an abstract view of all the resources in the cluster to applications.\n\nAs we’ll see shortly, Mesos acts as an interface between machines and applications. It provides applications with the available resources on all machines in the cluster. It frequently updates this information to include resources that are freed up by applications that have reached completion status. This allows applications to make the best decision about which task to execute on which machine.\n\nIn order to understand how Mesos works, let’s have a look at its architecture:\n\nThis image is part of the official documentation for Mesos (source). Here, Hadoop and MPI are two applications that share the cluster.\n\nWe’ll talk about each component shown here in the next few sections.\n\n3.1. Mesos Master\n\nMaster is the core component in this setup and stores the current state of resources in the cluster. Additionally, it acts as an orchestrator between the agents and the applications by passing information about things like resources and tasks.\n\nSince any failure in master results in the loss of state about resources and tasks, we deploy it in high availability configuration. As can be seen in the diagram above, Mesos deploys standby master daemons along with one leader. These daemons rely on Zookeeper for recovering state in case of a failure.\n\n3.2. Mesos Agents\n\nA Mesos cluster must run an agent on every machine. These agents report their resources to the master periodically and in turn, receive tasks that an application has scheduled to run. This cycle repeats after the scheduled task is either complete or lost.\n\nWe’ll see how applications schedule and execute tasks on these agents in the following sections.\n\n3.3. Mesos Frameworks\n\nMesos allows applications to implement an abstract component that interacts with the Master to receive the available resources in the cluster and moreover make scheduling decisions based on them. These components are known as frameworks.\n\nA Mesos framework is composed of two sub-components:\n\nScheduler – Enables applications to schedule tasks based on available resources on all the agents\n\nExecutor – Runs on all agents and contains all the information necessary to execute any scheduled task on that agent\n\nThis entire process is depicted with this flow:\n\nFirst, the agents report their resources to the master. At this instant, master offers these resources to all registered schedulers. This process is known as a resource offer, and we’ll discuss it in detail in the next section.\n\nThe scheduler then picks the best agent and executes various tasks on it through the Master. As soon as the executor completes the assigned task, agents re-publish their resources to the master. Master repeats this process of resource sharing for all frameworks in the cluster.\n\nMesos allows applications to implement their custom scheduler and executor in various programming languages. A Java implementation of scheduler must implement the Scheduler interface:\n\npublic class HelloWorldScheduler implements Scheduler { @Override public void registered(SchedulerDriver schedulerDriver, Protos.FrameworkID frameworkID, Protos.MasterInfo masterInfo) { } @Override public void reregistered(SchedulerDriver schedulerDriver, Protos.MasterInfo masterInfo) { } @Override public void resourceOffers(SchedulerDriver schedulerDriver, List<Offer> list) { } @Override public void offerRescinded(SchedulerDriver schedulerDriver, OfferID offerID) { } @Override public void statusUpdate(SchedulerDriver schedulerDriver, Protos.TaskStatus taskStatus) { } @Override public void frameworkMessage(SchedulerDriver schedulerDriver, Protos.ExecutorID executorID, Protos.SlaveID slaveID, byte[] bytes) { } @Override public void disconnected(SchedulerDriver schedulerDriver) { } @Override public void slaveLost(SchedulerDriver schedulerDriver, Protos.SlaveID slaveID) { } @Override public void executorLost(SchedulerDriver schedulerDriver, Protos.ExecutorID executorID, Protos.SlaveID slaveID, int i) { } @Override public void error(SchedulerDriver schedulerDriver, String s) { } }\n\nAs can be seen, it mostly consists of various callback methods for communication with the master in particular.\n\nSimilarly, the implementation of an executor must implement the Executor interface:\n\npublic class HelloWorldExecutor implements Executor { @Override public void registered(ExecutorDriver driver, Protos.ExecutorInfo executorInfo, Protos.FrameworkInfo frameworkInfo, Protos.SlaveInfo slaveInfo) { } @Override public void reregistered(ExecutorDriver driver, Protos.SlaveInfo slaveInfo) { } @Override public void disconnected(ExecutorDriver driver) { } @Override public void launchTask(ExecutorDriver driver, Protos.TaskInfo task) { } @Override public void killTask(ExecutorDriver driver, Protos.TaskID taskId) { } @Override public void frameworkMessage(ExecutorDriver driver, byte[] data) { } @Override public void shutdown(ExecutorDriver driver) { } }\n\nWe’ll see an operational version of the scheduler and executor in a later section.\n\n4. Resource Management\n\n4.1. Resource Offers\n\nAs we discussed earlier, agents publish their resource information to the master. In turn, the master offers these resources to the frameworks running in the cluster. This process is known as a resource offer.\n\nA resource offer consists of two parts – resources and attributes.\n\nResources are used to publish hardware information of the agent machine such as memory, CPU, and disk.\n\nThere are five predefined resources for every Agent:\n\ncpu\n\ngpus\n\nmem\n\ndisk\n\nports\n\nThe values for these resources can be defined in one of the three types:\n\nScalar – Used to represent numerical information using floating point numbers to allow fractional values such as 1.5G of memory\n\nRange – Used to represent a range of scalar values – for example, a port range\n\nSet – Used to represent multiple text values\n\nBy default, Mesos agent tries to detect these resources from the machine.\n\nHowever, in some situations, we can configure custom resources on an agent. The values for such custom resources should again be in any one of the types discussed above.\n\nFor instance, we can start our agent with these resources:\n\n--resources='cpus:24;gpus:2;mem:24576;disk:409600;ports:[21000-24000,30000-34000];bugs(debug_role):{a,b,c}'\n\nAs can be seen, we’ve configured the agent with few of the predefined resources and one custom resource named bugs which is of set type.\n\nIn addition to resources, agents can publish key-value attributes to the master. These attributes act as additional metadata for the agent and help frameworks in scheduling decisions.\n\nA useful example can be to add agents into different racks or zones and then schedule various tasks on the same rack or zone to achieve data locality:\n\n--attributes='rack:abc;zone:west;os:centos5;level:10;keys:[1000-1500]'\n\nSimilar to resources, values for attributes can be either a scalar, a range, or a text type.\n\n4.2. Resource Roles\n\nMany modern-day operating systems support multiple users. Similarly, Mesos also supports multiple users in the same cluster. These users are known as roles. We can consider each role as a resource consumer within a cluster.\n\nDue to this, Mesos agents can partition the resources under different roles based on different allocation strategies. Furthermore, frameworks can subscribe to these roles within the cluster and have fine-grained control over resources under different roles.\n\nFor example, consider a cluster hosting applications which are serving different users in an organization. So by dividing the resources into roles, every application can work in isolation from one another.\n\nAdditionally, frameworks can use these roles to achieve data locality.\n\nFor instance, suppose we have two applications in the cluster named producer and consumer. Here, producer writes data to a persistent volume which consumer can read afterward. We can optimize the consumer application by sharing the volume with the producer.\n\nSince Mesos allows multiple applications to subscribe to the same role, we can associate the persistent volume with a resource role. Furthermore, the frameworks for both producer and consumer will both subscribe to the same resource role. Therefore, the consumer application can now launch the data reading task on the same volume as the producer application.\n\n4.3. Resource Reservation\n\nNow the question may arise as to how Mesos allocates cluster resources into different roles. Mesos allocates the resources through reservations.\n\nThere are two types of reservations:\n\nStatic Reservation\n\nDynamic Reservation\n\nStatic reservation is similar to the resource allocation on agent startup we discussed in the earlier sections:\n\n--resources=\"cpus:4;mem:2048;cpus(baeldung):8;mem(baeldung):4096\"\n\nThe only difference here is that now the Mesos agent reserves eight CPUs and 4096m of memory for the role named baeldung.\n\nDynamic reservation allows us to reshuffle the resources within roles, unlike the static reservation. Mesos allows frameworks and cluster operators to dynamically change the allocation of resources via framework messages as a response to resource offer or via HTTP endpoints.\n\nMesos allocates all resources without any role into a default role named (*). Master offers such resources to all frameworks whether or not they have subscribed to it.\n\n4.4. Resource Weights and Quotas\n\nGenerally, the Mesos master offers resources using a fairness strategy. It uses the weighted Dominant Resource Fairness (wDRF) to identify the roles that lack resources. The master then offers more resources to the frameworks that have subscribed to these roles.\n\nEvent though fair sharing of resources between applications is an important characteristic of Mesos, its not always necessary. Suppose a cluster hosting applications that have a low resource footprint along with those having a high resource demand. In such deployments, we would want to allocate resources based on the nature of the application.\n\nMesos allows frameworks to demand more resources by subscribing to roles and adding a higher value of weight for that role. Therefore, if there are two roles, one of weight 1 and another of weight 2, Mesos will allocate twice the fair share of resources to the second role.\n\nSimilar to resources, we can configure weights via HTTP endpoints.\n\nBesides ensuring a fair share of resources to a role with weights, Mesos also ensures that the minimum resources for a role are allocated.\n\nMesos allows us to add quotas to the resource roles. A quota specifies the minimum amount of resources that a role is guaranteed to receive.\n\n5. Implementing Framework\n\nAs we discussed in an earlier section, Mesos allows applications to provide framework implementations in a language of their choice. In Java, a framework is implemented using the main class – which acts as an entry point for the framework process – and the implementation of Scheduler and Executor discussed earlier.\n\n5.1. Framework Main Class\n\nBefore we implement a scheduler and an executor, we’ll first implement the entry point for our framework that:\n\nRegisters itself with the master\n\nProvides executor runtime information to agents\n\nStarts the scheduler\n\nWe’ll first add a Maven dependency for Mesos:\n\n<dependency> <groupId>org.apache.mesos</groupId> <artifactId>mesos</artifactId> <version>1.11.0</version> </dependency>\n\nNext, we’ll implement the HelloWorldMain for our framework. One of the first things we’ll do is to start the executor process on the Mesos agent:\n\npublic static void main(String[] args) { String path = System.getProperty(\"user.dir\") + \"/target/libraries2-1.0.0-SNAPSHOT.jar\"; CommandInfo.URI uri = CommandInfo.URI.newBuilder().setValue(path).setExtract(false).build(); String helloWorldCommand = \"java -cp libraries2-1.0.0-SNAPSHOT.jar com.baeldung.mesos.executors.HelloWorldExecutor\"; CommandInfo commandInfoHelloWorld = CommandInfo.newBuilder() .setValue(helloWorldCommand) .addUris(uri) .build(); ExecutorInfo executorHelloWorld = ExecutorInfo.newBuilder() .setExecutorId(Protos.ExecutorID.newBuilder() .setValue(\"HelloWorldExecutor\")) .setCommand(commandInfoHelloWorld) .setName(\"Hello World (Java)\") .setSource(\"java\") .build(); }\n\nHere, we first configured the executor binary location. Mesos agent would download this binary upon framework registration. Next, the agent would run the given command to start the executor process.\n\nNext, we’ll initialize our framework and start the scheduler:\n\nFrameworkInfo.Builder frameworkBuilder = FrameworkInfo.newBuilder() .setFailoverTimeout(120000) .setUser(\"\") .setName(\"Hello World Framework (Java)\"); frameworkBuilder.setPrincipal(\"test-framework-java\"); MesosSchedulerDriver driver = new MesosSchedulerDriver(new HelloWorldScheduler(), frameworkBuilder.build(), args[0]);\n\nFinally, we’ll start the MesosSchedulerDriver that registers itself with the Master. For successful registration, we must pass the IP of the Master as a program argument args[0] to this main class:\n\nint status = driver.run() == Protos.Status.DRIVER_STOPPED ? 0 : 1; driver.stop(); System.exit(status);\n\nIn the class shown above, CommandInfo, ExecutorInfo, and FrameworkInfo are all Java representations of protobuf messages between master and frameworks.\n\n5.2. Implementing Scheduler\n\nSince Mesos 1.0, we can invoke the HTTP endpoint from any Java application to send and receive messages to the Mesos master. Some of these messages include, for example, framework registration, resource offers, and offer rejections.\n\nFor Mesos 0.28 or earlier, we need to implement the Scheduler interface:\n\nFor the most part, we’ll only focus on the resourceOffers method of the Scheduler. Let’s see how a scheduler receives resources and initializes tasks based on them.\n\nFirst, we’ll see how the scheduler allocates resources for a task:\n\n@Override public void resourceOffers(SchedulerDriver schedulerDriver, List<Offer> list) { for (Offer offer : list) { List<TaskInfo> tasks = new ArrayList<TaskInfo>(); Protos.TaskID taskId = Protos.TaskID.newBuilder() .setValue(Integer.toString(launchedTasks++)).build(); System.out.println(\"Launching printHelloWorld \" + taskId.getValue() + \" Hello World Java\"); Protos.Resource.Builder cpus = Protos.Resource.newBuilder() .setName(\"cpus\") .setType(Protos.Value.Type.SCALAR) .setScalar(Protos.Value.Scalar.newBuilder() .setValue(1)); Protos.Resource.Builder mem = Protos.Resource.newBuilder() .setName(\"mem\") .setType(Protos.Value.Type.SCALAR) .setScalar(Protos.Value.Scalar.newBuilder() .setValue(128));\n\nHere, we allocated 1 CPU and 128M of memory for our task. Next, we’ll use the SchedulerDriver to launch the task on an agent:\n\nTaskInfo printHelloWorld = TaskInfo.newBuilder() .setName(\"printHelloWorld \" + taskId.getValue()) .setTaskId(taskId) .setSlaveId(offer.getSlaveId()) .addResources(cpus) .addResources(mem) .setExecutor(ExecutorInfo.newBuilder(helloWorldExecutor)) .build(); List<OfferID> offerIDS = new ArrayList<>(); offerIDS.add(offer.getId()); tasks.add(printHelloWorld); schedulerDriver.launchTasks(offerIDS, tasks); } }\n\nAlternatively, Scheduler often finds the need to reject resource offers. For example, if the Scheduler cannot launch a task on an agent due to lack of resources, it must immediately decline that offer:\n\nschedulerDriver.declineOffer(offer.getId());\n\n5.3. Implementing Executor\n\nAs we discussed earlier, the executor component of the framework is responsible for executing application tasks on the Mesos agent.\n\nWe used the HTTP endpoints for implementing Scheduler in Mesos 1.0. Likewise, we can use the HTTP endpoint for the executor.\n\nIn an earlier section, we discussed how a framework configures an agent to start the executor process:\n\njava -cp libraries2-1.0.0-SNAPSHOT.jar com.baeldung.mesos.executors.HelloWorldExecutor\n\nNotably, this command considers HelloWorldExecutor as the main class. We’ll implement this main method to initialize the MesosExecutorDriver that connects with Mesos agents to receive tasks and share other information like task status:\n\npublic class HelloWorldExecutor implements Executor { public static void main(String[] args) { MesosExecutorDriver driver = new MesosExecutorDriver(new HelloWorldExecutor()); System.exit(driver.run() == Protos.Status.DRIVER_STOPPED ? 0 : 1); } }\n\nThe last thing to do now is to accept tasks from the framework and launch them on the agent. The information to launch any task is self-contained within the HelloWorldExecutor:\n\npublic void launchTask(ExecutorDriver driver, TaskInfo task) { Protos.TaskStatus status = Protos.TaskStatus.newBuilder() .setTaskId(task.getTaskId()) .setState(Protos.TaskState.TASK_RUNNING) .build(); driver.sendStatusUpdate(status); System.out.println(\"Execute Task!!!\"); status = Protos.TaskStatus.newBuilder() .setTaskId(task.getTaskId()) .setState(Protos.TaskState.TASK_FINISHED) .build(); driver.sendStatusUpdate(status); }\n\nOf course, this is just a simple implementation, but it explains how an executor shares task status with the master at every stage and then executes the task before sending a completion status.\n\nIn some cases, executors can also send data back to the scheduler:\n\nString myStatus = \"Hello Framework\"; driver.sendFrameworkMessage(myStatus.getBytes());\n\n6. Conclusion\n\nIn this article, we discussed resource sharing between applications running in the same cluster in brief. We also discussed how Apache Mesos helps applications achieve maximum utilization with an abstract view of the cluster resources like CPU and memory.\n\nLater on, we discussed the dynamic allocation of resources between applications based on various fairness policies and roles. Mesos allows applications to make scheduling decisions based on resource offers from Mesos agents in the cluster.\n\nFinally, we saw an implementation of the Mesos framework in Java."
    }
}