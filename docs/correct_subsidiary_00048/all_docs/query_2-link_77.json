{
    "id": "correct_subsidiary_00048_2",
    "rank": 77,
    "data": {
        "url": "https://arxiv.org/html/2312.00714v1",
        "read_more_link": "",
        "language": "en",
        "title": "Zipr: A High-Impact, Robust, Open-source, Multi-platform, Static Binary Rewriter",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Binary Rewriting",
            "Retargetable Binary Analysis",
            "Reverse Engineering"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "License: CC BY 4.0\n\narXiv:2312.00714v1 [cs.CR] 01 Dec 2023\n\nZipr: A High-Impact, Robust, Open-source, Multi-platform,\n\nStatic Binary Rewriter\n\nJason D. Hiser, Anh Nguyen-Tuong, Jack W. Davidson\n\nAbstract.\n\nZipr is a tool for static binary rewriting, first published in 2016. Zipr was engineered to support arbitrary program modification with an emphasis on low overhead, robustness, and flexibility to perform security enhancements and instrumentation. Originally targeted to Linux x86-32 binaries, Zipr now supports 32- and 64-bit binaries for X86, ARM, and MIPS architectures, as well as preliminary support for Windows programs.\n\nThese features have helped Zipr make a dramatic impact on research. It was first used in the DARPA Cyber Grand Challenge to take second place overall, with the best security score of any participant, Zipr has now been used in a variety of research areas by both the original authors as well as third parties. Zipr has also led to publications in artificial diversity, program instrumentation, program repair, fuzzing, autonomous vehicle security, research computing security, as well as directly contributing to two student dissertations. The open-source repository has accepted accepted patches from several external authors, demonstrating the impact of Zipr beyond the original authors.\n\nBinary Rewriting, Retargetable Binary Analysis, Reverse Engineering\n\n††copyright: cc††journalyear: 2023††conference: Cybersecurity Artifacts Competition and Impact Award ; December 04–08, 2023; Austin, TX††ccs: Software and its engineering Software maintenance tools††ccs: Software and its engineering Translator writing systems and compiler generators††ccs: Security and privacy Software reverse engineering\n\n1. Introduction\n\nThe impetus for creating Zipr was the need to apply many patches to arbitrary binaries efficiently. We had a static analysis system for binaries that could identify potential buffer overflows and recommend patches, and we needed to determine the runtime costs of applying the patches. While we had access to dynamic binary translators, runtime and memory overheads were not appropriate for the embedded systems we were targeting. (Scott and Davidson, 2001; Scott et al., 2003; Hiser et al., 2007) At the time, there were two flavors of static binary rewriters: Ones that kept a copy of the original program text to deal with disassembly errors and ones that overwrote the code to be instrumented with a trampoline to an unused address to execute the instrumented code snippet, then return to the original code to continue execution.\n\nKeeping a full second copy of the program was untenable for embedded systems. Further, we knew that our static analyzer likely had many false positives (as static analyzers tend to do), so we did not want our instrumentation to suffer from the cache, branch predictor, and memory penalty overheads of frequent trampolining inside time-critical kernel loops. We needed a rewriting system suitable for embedded systems, and nothing available met the requirements: 1) low overhead (in terms of memory and performance), 2) robust for a large range of common programs, and 3) the ability to cheaply invoke arbitrary instrumentation for any instruction in the program. Of course, these features are desirable in most environments but absolutely necessary for embedded systems.\n\nThe primary publications describing Zipr were published in 2016 and 2017 (Davidson et al., 2016; Hawkins et al., 2017a; Hiser et al., 2017; Hawkins et al., 2017b). The open source release (LLC. et al., 2023b) occurred in 2019 after a dependency on a commercial software package, IDA Pro (Eagle, 2011), was eliminated. Zipr has since been extended for multiple platforms and demonstrated effective, robust binary rewriting. Section 2 discusses the Zipr artifact’s current release, while Section 3 describes the impacts that Zipr has made in artificial diversity, program instrumentation, program repair, fuzzing, autonomous vehicle security, research computing security, as well as directly contributing to two student dissertations and numerous papers in key areas of security and privacy.\n\n2. The Zipr Artifact\n\nZipr Architecture\n\nThe Zipr architecture includes a front end that parses binary programs and lifts it into a low-level Zipr intermediate representation (IR). This IR is stored in a database we call the IRDB. The front end detects instructions, functions, data objects, indirect branch targets, and stack unwinding information (also called exception handling (EH) tables) and deposits this information in the IRDB. The IRDB contains information about control transfers, data object locations, and whether the IR is complete enough to unpin a data object or instruction, etc. One key feature of the IRDB storage mechanism is that it allows for uncertain and conflicting information. For example, our disassembly technique allows multiple disassemblers to union their results. Infrequently, disassemblers disagree on the correct interpretation of a sequence of bytes. The IRDB stores both representations in the IRDB, and ultimately, both interpretations will end up in the final program (assuming no user-specified transformations remove them). While only one interpretation is correct, the program semantics will be preserved because only one of them will ever execute dynamically. The incorrect sequence will result in extra memory and disk space usage, but will not affect correctness.\n\nAfter building the IR, the user can select one or more composable transformations to the IR. To ease the task of writing transformations, Zipr provides an SDK for reading, writing, and modifying the IRDB. (LLC. and Hiser, 2023a) The current SDK is written for C++ programming, but it has always been envisioned that one could directly modify the IRDB using SQL or write interfaces for other languages.\n\nBesides direct access to any program item, we recognized that many transformations would want to analyze the program in some way before making a transformation. To facilitate this approach, the SDK provides common analysis techniques, such as the ability to create a control flow graph (CFG) for a function; the dominator graph for the CFG, a call graph of functions in the IR; the dead registers at each program point; and the disassembly and set/used registers for each instruction. While the set of analyses is by no means complete, the SDK is easily extendable by writing a new transformation and compiling it into a dynamically-linked library that others can reuse.\n\nTo help potential users write Zipr transformations, we have provided a variety of example transformations:\n\n•\n\nAn IRDB Cookbook (LLC. and Hiser, 2023c) with well-documented transformations provides documentation on writing a plugin and includes three example plugins. initialize_stack inserts code at the beginning of every function to zero-initialize the stack, preventing exploits relating to uninitialized stack variables. This example shows how to iterate over functions, inspect a function’s stack frame, and insert instrumentation. kill_deads runs the IRDB SDK’s dead register analysis and inserts a set for every dead register detected at every instruction in the program. This example shows how to invoke IRDB SDK analyses and act on the results, while simultaneously being a surprisingly effective test of the analysis results. stack_stamp modifies function entry and exit code to XOR the program’s return address with a randomly selected value. Besides being a potential security enhancement, this example shows how to iterate over functions and modify each function’s entry and exit points.\n\n•\n\nZafl is an instrumentation pass built on Zipr and the IRDB SDK to instrument a program with AFL-style instrumentation. (LLC. et al., 2023c; Nagy et al., 2021a; Wong, 2022; Fioraldi et al., 2020). Zafl yields an instrumented program that is statistically similar to a program with compiler-inserted instrumentation in terms of bug-finding abilities.\n\n•\n\nThe p1transform transformation randomizes the amount of stack space each function uses, providing an example of how to modify stack frames for a given function and providing artificial diversity for the transformed program. (LLC., 2023b)\n\nAfter completing the (possibly empty) list of user-specified transformations, Zipr invokes the back end to reconstitute the IR directly into an executable program. As we recognized that users may want to control the final layout of the program, a second SDK is provided, the Zipr Backend SDK. (LLC. et al., 2023a) The primary purpose of this SDK is to allow plugins to the reconstitution engine to allow the user to control basic block placement, and apply user-specified relocations. A Zipr relocation is analogous to a linker relocation in the compiler world. Built-in relocations for changing, for example, a data item to point at an instruction, are included. The Selective CFI transformation (LLC. and Hiser, 2023b) demonstrates how to use the Zipr Backend SDK (described below) to place executable or not-executable nonces in the code to implement a highly effective version of CFI directly on binary programs.\n\nTo facilitate quick adoption by new users, the Zephyr Gitlab repository includes docker images with pre-built Zipr installations, ready to run with a single command.\n\nZipr Platforms\n\nZipr’s most robust architecture is the x86/64 Linux platform. This platform supports all common compilers (gcc/g++, icx, clang/clang++ and the obfuscating LLVM compiler, OLLVM). (Gough and Stallman, 2004; Corporation, 2023; Lattner, 2008; Junod et al., 2015), all common compiler optimization levels and flags ( -O0, -O1, -O2, -O3, -Os, -Ofast, -fomit-frame-pointer, -static, -fPIC -fPID -pie, etc.), and most languages that are commonly compiled (C, C++, Fortran, Ada, Rust, including variants of said languages such as C++11, C++17, Fortran99, etc.) Notably missing is GoLang support due to a currently undiagnosed race condition with the GoLang custom exception handling format. Both static and dynamically linked programs and shared libraries are supported. The platform’s robustness is demonstrated in our test suite for Zipr testing, which contains thousands of binaries generated from programs used in industry. (Hiser, 2023c) X86/32 code, though the first target of Zipr, has yet to achieve as much attention as we have had fewer partners working with that code base.\n\nThe next most supported platform is 32-bit ARM on Linux. We have automated regular regressions for coreutils and several other programs used in common software deployments. (Hiser, 2023b) While there are known bugs, many large programs work and demonstrate the approach’s feasibility for this platform.\n\nWe also have preliminary support for 64-bit ARM code and 32- and 64-bit MIPS code on the Linux platform. While we do not yet have a robust test suite with widely-used programs, a variety of coreutils programs have demonstrated successful transformations. Preliminary support is also available for Windows 32- and 64-bit executables.\n\n3. Zipr Impacts\n\n3.1. Commercial Adoption\n\nGrammaTech\n\nGrammaTech was one of the first commercial adopters of the Zipr technology with the authors’ collaboration. GrammaTech concluded that Zipr was a good fit for their entry into the DARPA Cyber Grand Challenge (CGC). CGC was a fully-autonomous capture the flag (CTF) competition. Each team built a Cyber Reasoning System (CRS), and the CRSes competed to autonomously protect their (vulnerable) services and exploit vulnerabilities in competitors’ services. A CRS scored points for successfully defending against an exploit, but was harshly penalized for increases in runtime, on-disk space, or memory usage. Thus, Zipr was a natural fit due to its low runtime overhead, minimal on-disk expansion, and modest memory footprint. (Nguyen-Tuong et al., 2018)\n\nThe primary defensive mechanism was a control flow integrity (CFI) implementation (Burow et al., 2017; Abadi et al., 2009), which is now open source. (LLC. and Hiser, 2023b) The CFI implementation, dubbed Selective CFI, leveraged the IRDB analyses to detect indirect branches that were safe from exploitation, and elide expensive instrumentation in those cases to help minimize scoring penalties for using excess resources. Zipr and the Selective CFI implementation achieved the #1 score for defeating exploits created by the other competitors.\n\nLater, Zipr’s exception handling parser (Hiser et al., 2017) was adopted by GrammaTech. They were able to re-use Zipr’s libEHP (Hiser, 2023a) component in their Datalog Disassembler (ddisasm)(Flores-Montoya and Schulte, 2020). GrammaTech’s work also helped improve libEHP by submitting source code updates with bug fixes, build system improvements, and porting it to operate on MS Windows platforms.\n\nFinally, ONR sponsored GrammaTech to perform a broad comparison of binary rewriters, which includes both Zipr and ddisasm. (Schulte et al., 2022) Zipr performed very well. It was the only binary rewriter to transform every program in the extensive test suite successfully. Zipr and ddisasm were the only binary rewriters that were able to transform a majority of programs, while many other rewriters were deemed “too academic” for wide adoption.\n\nDependable Computing\n\nA joint project between Dependable Computing and the authors leveraged formal verification techniques to meet security and privacy needs for embedded systems where development artifacts such as source code were unavailable. (Davidson et al., 2016) Zipr was critical for meeting embedded systems’ strict overhead limits, and was able to apply patches to meet security requirements. Overall, Zipr demonstrated that it could rewrite a binary with patches and yield less than 5% performance penalty.\n\nApogee Software\n\nApogee software, as part of the DARPA Cyber Fault-tolerance Attack Recovery (CFAR) project, worked to realize DARPA’s vision of executing multiple diverse copies of a program in parallel to detect security violations. (Co et al., 2016) The key insight is that many attacks must be customized to the low-level details of a program under attack. For example, an attack might include an absolute address or relative offset to exploit the program. If the same input is sent to multiple diverse copies of the program, the programs will behave differently, and that difference can be detected and used to invoke recovery mechanisms.\n\nIn collaboration with the UVA team, Zipr was used to generate artificial diversity for key web server programs such as Apache and NginX. (Laurie and Laurie, 2003; Soni, 2016) Zipr was used to randomize code, data layouts, and locations for the stack, heap, and global address spaces. The Zipr backend SDK was used to control code and data layout locations so that detection of certain classes of attacks was provably certain. For example, Zipr could create two variants of a program such that their address spaces were disjoint. Thus, any attack that injected an absolute address would crash at least one variant.\n\nOther teams in the program did similar transformations using compiler technology instead of operating directly on the binary. As such, when an Ada program was introduced, the Zipr transformer was the only tool that successfully produced diverse variants for parallel execution. In fact, thanks to the robustness of Zipr binary analysis, little additional effort was required when the source language changed.\n\nZipr was also leveraged to enact automatic program repair. (Jones et al., 2019) The program repair worked by instrumenting a program’s input points to memorize recent program inputs. If the input subsequently caused a security violation, the input could be marked as malicious. Future attempts to feed the input to the program caused the input to be ignored and not processed by the program. This technique helps defeat denial-of-service (DOS) attacks where the same input causes the program to repeatedly crash and restart, preventing legitimate requests from being serviced while the program is busy restarting.\n\nRed Hat\n\nRed Hat and the authors collaborated to deploy several Zipr-based tools for ensemble fuzzing with an unnamed collaborator. (LLC. et al., 2023c; LLC., 2023a) Unfortunately, as is often the case with commercial partners, we can provide no additional detail due to confidentiality restrictions.\n\n3.3. Sponsored Research\n\nKevlar\n\nThe Kevlar project was sponsored research by the authors with funding from the Air Force Research Labs (AFRL). The project’s goal was to transition to practice a variety of research tools for randomizing program layouts and adding hardening transformations to applications. Many of these transformations were previously realized using a dynamic rewriter, and the project leveraged the Zipr technology to apply the transformations statically, significantly improving the viability for commercial and government applications for several reasons:\n\n•\n\nThe Zipr static rewriting technology is more performant and memory frugal, making adoption more likely.\n\n•\n\nThe statically rewritten binary can be easily tested in situ, as minimal environmental changes are needed to add security. Only changing the target binaries is needed, as opposed to additional runtime software, etc. Such changes are harder to deploy in many settings due to regulatory approval, testing restrictions, or other non-technical issues.\n\n•\n\nHumans need to gain trust in the system, and this trust is much more difficult to gain with dynamic translation systems. Trust in static translation systems can be audited for correctness by experts and enhanced with semi-automatic formal verification techniques.\n\nZipr dramatically improved the practicality of the security techniques.\n\nTrusted and Resilient Computation\n\nThe Trusted and Resilient Mission Operations (TRMO) project, and its follow-on project, Trusted and Resilient Systems (TRSYS) sought to provide security enhancements for autonomous vehicles. (Davidson et al., 2019; Leach et al., 2022) Myriad Zipr-based plugins provided cyber-attack detection capabilities. Program instrumentation relayed detected attacks to a supervisor module, which invoked various forms of program repair. For example, in an autonomous quad-copter, the attack-response module would put the copter into “hover” mode with a trusted controller while the more capable, yet untrusted controller program was being analyzed and repaired. If the repair is successful, the repaired controller could resume mission operations after a cyber attack.\n\nThe Zipr instrumentation system was vital to this work. It provided the low-overhead detection capabilities needed to enact program repair, and stop the cyber-attack from being undetected or immediately fatal.\n\nHelix++\n\nThe Helix++ project aimed at transitioning Zipr-based plugins to practice by leveraging Docker containers. (Davidson et al., 2023; Huband, 2023) By protecting applications in commonly used Docker containers and making these protected containers publicly available, we hoped to lower the cost of having developers use Zipr-protected applications.\n\nWe specifically worked with UVA’s Research Computing staff to identify key services and build a repository of hardened Docker containers. We are in the process of working with them to deploy their hardened application to end users and hope that this model can be used to lower the cost of adopting academic security concepts.\n\n4. Conclusions\n\nThis paper presented the Zipr binary rewriter as an artifact, published in 2016 and 2017 (Davidson et al., 2016; Hawkins et al., 2017a; Hiser et al., 2017; Hawkins et al., 2017b) and open-sourced in 2019 (LLC. et al., 2023b). Zipr’s SDKs and plugin architecture target multiple platforms, focusing on efficient binary rewriting to apply diversity and hardening transformations to improve program security. Zipr’s robust and efficient nature has been leveraged by the authors, their collaborators, and third parties to enhance the body of knowledge through publications and dissertations. Zipr also has a history of providing open-source tools for diversity, program repair, fuzzing, research computing, and autonomous vehicle security. We expect that Zipr will continue to be a valuable tool for enhancing program security, and we will continue to make it available and support user requests for features, bug fixes, and clarifications of included features.\n\nAcknowledgements.\n\nThis material is based upon work supported by the National Science Foundation under Grant No. 2115130.\n\nReferences\n\n(1)\n\nAbadi et al. (2009) Martín Abadi, Mihai Budiu, Ulfar Erlingsson, and Jay Ligatti. 2009. Control-flow integrity principles, implementations, and applications. ACM Transactions on Information and System Security (TISSEC) 13, 1 (2009), 1–40.\n\nBurow et al. (2017) Nathan Burow, Scott A Carr, Joseph Nash, Per Larsen, Michael Franz, Stefan Brunthaler, and Mathias Payer. 2017. Control-flow integrity: Precision, security, and performance. ACM Computing Surveys (CSUR) 50, 1 (2017), 1–33.\n\nCo et al. (2016) Michele Co, Jack W Davidson, Jason D Hiser, John C Knight, Anh Nguyen-Tuong, Westley Weimer, Jonathan Burket, Gregory L Frazier, Tiffany M Frazier, Bruno Dutertre, et al. 2016. Double Helix and RAVEN: a system for cyber fault tolerance and recovery. In Proceedings of the 11th Annual Cyber and Information Security Research Conference. 1–4.\n\nCorporation (2023) Intel Corporation. 2023. Intel C Compiler. https://www.intel.com/content/www/us/en/developer/tools/oneapi/dpc-compiler.html\n\nDavidson et al. (2019) Jack Davidson, Rector, and Visitors of the University of Virginia. 2019. Trusted and Resilient Mission Operation. (2019).\n\nDavidson et al. (2023) Jack W Davidson, Jason D Hiser, and Anh Nguyen-Tuong. 2023. Helix++: A platform for efficiently securing software. arXiv preprint arXiv:2304.04846 (2023).\n\nDavidson et al. (2016) Jack W Davidson, Jason D Hiser, Anh Nguyen-Tuong, Clark L Coleman, William H Hawkins, John C Knight, Benjamin D Rodes, and Ashlie B Hocking. 2016. A system for the security protection of embedded binary programs. In 2016 46th Annual IEEE/IFIP International Conference on Dependable Systems and Networks Workshop (DSN-W). IEEE, 234–237.\n\nEagle (2011) Chris Eagle. 2011. The IDA pro book. no starch press.\n\nFioraldi et al. (2020) Andrea Fioraldi, Dominik Maier, Heiko Eißfeldt, and Marc Heuse. 2020. {{\\{{AFL++}}\\}}: Combining incremental steps of fuzzing research. In 14th USENIX Workshop on Offensive Technologies (WOOT 20).\n\nFlores-Montoya and Schulte (2020) Antonio Flores-Montoya and Eric Schulte. 2020. Datalog disassembly. In 29th USENIX Security Symposium (USENIX Security 20). 1075–1092.\n\nGough and Stallman (2004) Brian J Gough and Richard Stallman. 2004. An Introduction to GCC. Network Theory Limited.\n\nHawkins et al. (2017b) William Hawkins, Jason D Hiser, Anh Nguyen-Tuong, Jack W Davidson, et al. 2017b. Securing binary code. IEEE Security & Privacy 15, 06 (2017), 77–81.\n\nHawkins et al. (2017c) William Hawkins, Anh Nguyen-Tuong, Jason D Hiser, Michele Co, and Jack W Davidson. 2017c. Mixr: Flexible runtime rerandomization for binaries. In Proceedings of the 2017 Workshop on Moving Target Defense. 27–37.\n\nHawkins (2018) William H. Hawkins. 2018. Static Binary Rewriting to Improve Software Security, Safety and Reliability. PhD Thesis. University of Virginia, Charlottesville, VA.\n\nHawkins et al. (2017a) William H Hawkins, Jason D Hiser, Michele Co, Anh Nguyen-Tuong, and Jack W Davidson. 2017a. Zipr: Efficient static binary rewriting for security. In 2017 47th Annual IEEE/IFIP International Conference on Dependable Systems and Networks (DSN). IEEE, 559–566.\n\nHawkins et al. (2016) William H Hawkins, Jason D Hiser, and Jack W Davidson. 2016. Dynamic canary randomization for improved software security. In Proceedings of the 11th Annual Cyber and Information Security Research Conference. 1–7.\n\nHiser (2023a) Jason Hiser. 2023a. libEHP Source Code. https://git.zephyr-software.com/opensrc/libehp\n\nHiser (2023b) Jason Hiser. 2023b. Zipr Regressing Testing for ARM. https://git.zephyr-software.com/opensrc/zipr-testing/zipr-arm-testing\n\nHiser (2023c) Jason Hiser. 2023c. Zipr Regressing Testing for X86. https://git.zephyr-software.com/opensrc/dod_benchmark_suite\n\nHiser et al. (2017) Jason Hiser, Anh Nguyen-Tuong, William Hawkins, Matthew McGill, Michele Co, and Jack Davidson. 2017. Zipr++ Exceptional Binary Rewriting. In Proceedings of the 2017 Workshop on Forming an Ecosystem Around Software Transformation. 9–15.\n\nHiser et al. (2007) Jason D Hiser, Daniel Williams, Wei Hu, Jack W Davidson, Jason Mars, and Bruce R Childers. 2007. Evaluating indirect branch handling mechanisms in software dynamic translation systems. In International Symposium on Code Generation and Optimization (CGO’07). IEEE, 61–73.\n\nHuband (2023) Jackie Huband. 2023. Enabling Research through Federated Access of Compute Resources for Sensitive Data. (2023). https://pearc.acm.org/pearc23/ Birds of a Feather (BOF) group discussion.\n\nJones et al. (2019) Jessica Jones, Jason D Hiser, Jack W Davidson, and Stephanie Forrest. 2019. Defeating Denial-of-Service attacks in a self-managing N-Variant system. In 2019 IEEE/ACM 14th International Symposium on Software Engineering for Adaptive and Self-Managing Systems (SEAMS). IEEE, 126–138.\n\nJunod et al. (2015) Pascal Junod, Julien Rinaldini, Johan Wehrli, and Julie Michielin. 2015. Obfuscator-LLVM–software protection for the masses. In 2015 ieee/acm 1st international workshop on software protection. IEEE, 3–9.\n\nLattner (2008) Chris Lattner. 2008. LLVM and Clang: Next generation compiler technology. In The BSD conference, Vol. 5. 1–20.\n\nLaurie and Laurie (2003) Ben Laurie and Peter Laurie. 2003. Apache: The definitive guide. ” O’Reilly Media, Inc.”.\n\nLeach et al. (2022) Kevin Leach, Christopher S Timperley, Kevin Angstadt, Anh Nguyen-Tuong, Jason Hiser, Aaron Paulos, Partha Pal, Patrick Hurley, Carl Thomas, Jack W Davidson, et al. 2022. START: A Framework for Trusted and Resilient Autonomous Vehicles (Practical Experience Report). In 2022 IEEE 33rd International Symposium on Software Reliability Engineering (ISSRE). IEEE, 73–84.\n\nLei et al. (2018) Cheng Lei, Hong-Qi Zhang, Jing-Lei Tan, Yu-Chen Zhang, and Xiao-Hu Liu. 2018. Moving target defense techniques: A survey. Security and Communication Networks 2018 (2018).\n\nLLC. (2023a) Zephyr Software LLC. 2023a. Turbo Source Code. https://git.zephyr-software.com/opensrc/turbo\n\nLLC. (2023b) Zephyr Software LLC. 2023b. Zafl: Zipr-based AFL Instrumentation. https://git.zephyr-software.com/opensrc/p1transform\n\nLLC. et al. (2023a) Zephyr Software LLC., Will Hawkins, and Jason Hiser. 2023a. The Zipr Code Placement SDK Source Code. https://git.zephyr-software.com/opensrc/zipr-sdk\n\nLLC. et al. (2023b) Zephyr Software LLC., Will Hawkins, and Jason Hiser. 2023b. Zipr Source Code. https://git.zephyr-software.com/opensrc/zipr\n\nLLC. and Hiser (2023a) Zephyr Software LLC. and Jason Hiser. 2023a. The IRDB SDK Source Code. https://git.zephyr-software.com/opensrc/irdb-sdk\n\nLLC. and Hiser (2023b) Zephyr Software LLC. and Jason Hiser. 2023b. Selective CFI. https://git.zephyr-software.com/opensrc/cfi\n\nLLC. and Hiser (2023c) Zephyr Software LLC. and Jason Hiser. 2023c. The Zipr Code Placement SDK Source Code. https://git.zephyr-software.com/opensrc/irdb-cookbook-examples\n\nLLC. et al. (2023c) Zephyr Software LLC., Jason Hiser, and Anh Nguyen-Tuong. 2023c. Zafl: Zipr-based AFL Instrumentation. https://git.zephyr-software.com/opensrc/zafl\n\nMaeckel (2023) Franziska Maeckel. 2023. binary-msan Source Code. https://github.com/fransie/binary-msan/tree/instrument-all-functions\n\nNagy (2022) Stefan Nagy. 2022. Practical Feedback and Instrumentation Enhancements for Performant Security Testing of Closed-source Executables. PhD Thesis. Virginia Tech, Blacksburg, VA.\n\nNagy et al. (2021a) Stefan Nagy, Anh Nguyen-Tuong, Jason D Hiser, Jack W Davidson, and Matthew Hicks. 2021a. Breaking through binaries: Compiler-quality instrumentation for better binary-only fuzzing. In 30th USENIX Security Symposium (USENIX Security 21). 1683–1700.\n\nNagy et al. (2021b) Stefan Nagy, Anh Nguyen-Tuong, Jason D Hiser, Jack W Davidson, and Matthew Hicks. 2021b. Same coverage, less bloat: Accelerating binary-only fuzzing with coverage-preserving coverage-guided tracing. In Proceedings of the 2021 ACM SIGSAC Conference on Computer and Communications Security. 351–365.\n\nNguyen-Tuong et al. (2018) Anh Nguyen-Tuong, David Melski, Jack W Davidson, Michele Co, William Hawkins, Jason D Hiser, Derek Morris, Ducson Nguyen, and Eric Rizzi. 2018. Xandra: An autonomous cyber battle system for the Cyber Grand Challenge. IEEE Security & Privacy 16, 2 (2018), 42–51.\n\nSchulte et al. (2022) Eric Schulte, Michael D Brown, and Vlad Folts. 2022. A Broad Comparative Evaluation of x86-64 Binary Rewriters. In Proceedings of the 15th Workshop on Cyber Security Experimentation and Test. 129–144.\n\nScott and Davidson (2001) Kevin Scott and Jack Davidson. 2001. Strata: A software dynamic translation infrastructure. In IEEE Workshop on Binary Translation.\n\nScott et al. (2003) Kevin Scott, Naveen Kumar, Siva Velusamy, Bruce Childers, Jack W Davidson, and Mary Lou Soffa. 2003. Retargetable and reconfigurable software dynamic translation. In International Symposium on Code Generation and Optimization, 2003. CGO 2003. IEEE, 36–47.\n\nSerebryany et al. (2012) Konstantin Serebryany, Derek Bruening, Alexander Potapenko, and Dmitriy Vyukov. 2012. {{\\{{AddressSanitizer}}\\}}: A fast address sanity checker. In 2012 USENIX annual technical conference (USENIX ATC 12). 309–318.\n\nSoni (2016) Rahul Soni. 2016. Nginx. Springer.\n\nWong (2022) Cerdic Wei Kit Wong. 2022. American fuzzy lop (AFL) fuzzer. (2022)."
    }
}