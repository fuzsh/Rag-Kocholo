{
    "id": "dbpedia_1066_2",
    "rank": 87,
    "data": {
        "url": "https://sites.google.com/view/vinegarhill-financelabs/black-scholes-merton",
        "read_more_link": "",
        "language": "en",
        "title": "Black Scholes Merton",
        "top_image": "https://lh5.googleusercontent.com/2PNajJviSQh0CEQIKlofYB1pro-gUsVW4EqnFk-2wns7fVZB79tfN8am4j1TiinR7Rzn_A=w16383",
        "meta_img": "https://lh5.googleusercontent.com/2PNajJviSQh0CEQIKlofYB1pro-gUsVW4EqnFk-2wns7fVZB79tfN8am4j1TiinR7Rzn_A=w16383",
        "images": [
            "https://lh5.googleusercontent.com/2PNajJviSQh0CEQIKlofYB1pro-gUsVW4EqnFk-2wns7fVZB79tfN8am4j1TiinR7Rzn_A=w16383",
            "https://lh5.googleusercontent.com/2PNajJviSQh0CEQIKlofYB1pro-gUsVW4EqnFk-2wns7fVZB79tfN8am4j1TiinR7Rzn_A=w16383",
            "https://lh4.googleusercontent.com/SVCcYOPm82UvGPIKQ1WKnlI6IdsHBNq2YbSTmmzmX2B-uJyaQiXm4e2qjx6nPZOKbbwFrcGRPQ2KAN8e6mJgxqDZtVhAmfW2jdTZTO9QBng9ER18sy1iqDd-X3kJmwPEHQ=w1280",
            "https://lh4.googleusercontent.com/24iXykbzwM76E4l4bb31-NQLvbXAR6eXM--ExCiigrceoXaA3ccrVzbf0-kJU5O-55TnzC0jm7DYI1_6cXWMaU7XqNFKcwSXfR-iuyPbs7qVbgSI=w1280",
            "https://colab.research.google.com/img/colab_favicon_256px.png",
            "https://lh5.googleusercontent.com/IX8nZxjzpmLYXv833AiTaTerVwY3F94fup2f1AR7mvEL-0pXGCSfodi7V-YRofkzOlcAUYSDhAbalABYQAoK09V44Fye9llB176fsp1jFdq__ILi=w1280"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The Black Scholes Merton model\nIf you are new to options I strongly advise you to profit from Robert Shiller's lecture on same. It combines practical market insights with a strong authoritative grasp of key models in option theory. He explains many of the areas covered below and in the following",
        "meta_lang": "en",
        "meta_favicon": "https://ssl.gstatic.com/atari/images/public/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://sites.google.com/view/vinegarhill-financelabs/black-scholes-merton",
        "text": "The Black Scholes Merton model\n\nIf you are new to options I strongly advise you to profit from Robert Shiller's lecture on same. It combines practical market insights with a strong authoritative grasp of key models in option theory. He explains many of the areas covered below and in the following pages with a lot intuition and relatable anecdotage. We start here with Black Scholes Merton which is probably the most popular option pricing framework, due largely to its simplicity and ease in terms of implementation. The closed-form solution is efficient in terms of speed and always compares favorably relative to any numerical technique. The Black–Scholes–Merton model is a mathematical go-to model for estimating the value of European calls and puts. In the early 1970’s, Myron Scholes, and Fisher Black made an important breakthrough in the pricing of complex financial instruments. Robert Merton simultaneously was working on the same problem and applied the term Black-Scholes model to describe new generation of pricing. The Black Scholes (1973) contribution developed insights originally proposed by Bachelier 70 years before. In 1997, Myron Scholes and Robert Merton received the Nobel Prize for Economics. Tragically, Fisher Black died in 1995. The Black–Scholes formula presents a theoretical estimate (or model estimate) of the price of European-style options independently of the risk of the underlying security. Future payoffs from options can be discounted using the risk-neutral rate. Earlier academic work on options (e.g., Malkiel and Quandt 1968, 1969) had contemplated using either empirical, econometric analyses or elaborate theoretical models that possessed parameters whose values could not be calibrated directly. In contrast, Black, Scholes, and Merton’s parameters were at their core simple and did not involve references to utility or to the shifting risk appetite of investors. Below, we present a standard type formula, where: c = Call option value, p = Put option value, S=Current stock (or other underlying) price, K or X=Strike price, r=Risk-free interest rate, q = dividend yield, T=Time to maturity and N denotes taking the normal cumulative probability. b = (r - q) = cost of carry.\n\nThe risk free rate and riskless portfolio breakthrough\n\nIf the price of a stock adhered to a lognormal random walk in continuous time, and other simplifying assumptions assured, then it was possible to hedge any option transaction flawlessly. A risk neutral world was possible to construct whilst a continuously adjusted portfolio of the underlying security and government bonds or cash combined could “replicate” the option position. The Nobel committee awarded their prize precisely because the trio had unraveled the intuition behind establishing risk neutrality. The formula led to a boom in options trading and provided mathematical legitimacy to the establishment of the Chicago Board Options Exchange and other emergent options markets around the world. The history of how both CBOT and CME lobbies convinced regulators to permit option trading is outlined by Mackenzie and Millo (2003). Risk Neutrality is widely used, although often with some adjustments, by options market participants. Derman and Taleb (2005) heavily criticized the risk neutrality framework as constructed by Black Scholes. See below for a simple implementation in Excel VBA for Black Scholes. For a more exhaustive explanation of Black Scholes please follow link to spreadsheet. For clearer exposition and relevant formulae see Martin Haugh's note. You also check out Martin Haugh's powerpoint pdf for Black Scholes, Greeks and Delta Hedging.\n\nVBA code for Black Scholes\n\n' VBA code from www.kerryback.net\n\nFunction Black_Scholes_Call(S, K, r, sigma, q, T)\n\n'\n\n' Inputs are S = initial stock price\n\n' K = strike price\n\n' r = risk-free rate\n\n' sigma = volatility\n\n' q = dividend yield\n\n' T = time to maturity\n\n'\n\nDim d1, d2, N1, N2\n\nIf sigma = 0 Then\n\nBlack_Scholes_Call = Application.Max(0, Exp(-q * T) * S - Exp(-r * T) * K)\n\nElse\n\nd1 = (Log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * Sqr(T))\n\nd2 = d1 - sigma * Sqr(T)\n\nN1 = Application.NormSDist(d1)\n\nN2 = Application.NormSDist(d2)\n\nBlack_Scholes_Call = Exp(-q * T) * S * N1 - Exp(-r * T) * K * N2\n\nEnd If\n\nEnd Function\n\nFunction Black_Scholes_Put(S, K, r, sigma, q, T)\n\n'\n\n' Inputs are S = initial stock price\n\n' K = strike price\n\n' r = risk-free rate\n\n' sigma = volatility\n\n' q = dividend yield\n\n' T = time to maturity\n\n'\n\nDim d1, d2, N1, N2\n\nIf sigma = 0 Then\n\nBlack_Scholes_Put = Application.Max(0, Exp(-r * T) * K - Exp(-q * T) * S)\n\nElse\n\nd1 = (Log(S / K) + (r - q + 0.5 * sigma * sigma) * T) / (sigma * Sqr(T))\n\nd2 = d1 - sigma * Sqr(T)\n\nN1 = Application.NormSDist(-d1)\n\nN2 = Application.NormSDist(-d2)\n\nBlack_Scholes_Put = Exp(-r * T) * K * N2 - Exp(-q * T) * S * N1\n\nEnd If\n\nEnd Function\n\nBlack Scholes C++ code\n\nSee below video for implementation. Also, separately to view explanation of Put call parity please follow link. Put Call Parity is invoked to obtain value of put.\n\n//From Fabrice Rouah\n\n//Adapted by Shang and Byrne for Dividends\n\n#include <iostream>\n\n#include <vector>\n\n#include <math.h>\n\nusing namespace std;\n\n// N(0,1) density\n\ndouble\n\nf (double x)\n\n{\n\ndouble pi = 4.0 * atan (1.0);\n\nreturn exp (-x * x * 0.5) / sqrt (2 * pi);\n\n}\n\n// Boole's Rule\n\ndouble\n\nBoole (double StartPoint, double EndPoint, int n)\n\n{\n\nvector < double >X (n + 1, 0.0);\n\nvector < double >Y (n + 1, 0.0);\n\ndouble delta_x = (EndPoint - StartPoint) / double (n);\n\nfor (int i = 0; i <= n; i++)\n\n{\n\nX[i] = StartPoint + i * delta_x;\n\nY[i] = f (X[i]);\n\n}\n\ndouble sum = 0;\n\nfor (int t = 0; t <= (n - 1) / 4; t++)\n\n{\n\nint ind = 4 * t;\n\nsum +=\n\n(1 / 45.0) * (14 * Y[ind] + 64 * Y[ind + 1] + 24 * Y[ind + 2] +\n\n64 * Y[ind + 3] + 14 * Y[ind + 4]) * delta_x;\n\n}\n\nreturn sum;\n\n}\n\n// N(0,1) cdf by Boole's Rule\n\ndouble\n\nN (double x)\n\n{\n\nreturn Boole (-10.0, x, 240);\n\n}\n\n// Black-Scholes Call Price\n\ndouble\n\nBSPrice (double S, double K, double T, double r,double q, double v, char OpType)\n\n{\n\ndouble d = (log (S / K) + T * (r - q + 0.5 * v * v)) / (v * sqrt (T));\n\ndouble call = S *exp(-q*T)* N (d) - exp (-r * T) * K * N (d - v * sqrt (T));\n\nif (OpType == 'C')\n\nreturn call;\n\nelse\n\n// Put Parity\n\nreturn call - S*exp (-q * T) + K * exp (-r * T);\n\n}\n\nint\n\nmain ()\n\n{\n\ndouble S = 100.0; // Stock Price\n\ndouble K = 100.0; // Strike Price\n\ndouble T = 1; // Years to maturity\n\ndouble r = 0.05; // Risk free interest rate\n\ndouble q = 0.0;\n\ndouble v = 0.20; // Yearly volatility\n\nchar OpType = 'C'; // 'C'all or 'P'ut\n\ncout << \"Black Scholes Price \" << BSPrice (S, K, T, r, q, v, OpType) << endl;\n\n};\n\nTo set up Black Scholes C++ code in Xcode for Mac please follow link.\n\nTo set up Black Scholes in Microsoft Visual Studio please follow link.\n\nPython code for Black Scholes\n\nSee below video for implementation. Also note that in the Python code put-call parity is invoked to estimate the value of the put. More on Python and Black Scholes.\n\n## https://github.com/YuChenAmberLu?tab=repositories\n\n## Adapted for Dividends\n\n## import certain packages\n\nfrom math import log, sqrt, pi, exp\n\nfrom scipy.stats import norm\n\n#import numpy as np\n\n#import pandas as pd\n\nfrom pandas import DataFrame\n\n# Underlying price (per share): S;\n\n# Strike price of the option (per share): K;\n\n# Time to maturity (years): T;\n\n# Continuously compounding risk-free interest rate: r;\n\n# Continuously compounding dividend: q;\n\n# Volatility: sigma;\n\n## define two functions, d1 and d2 in Black-Scholes model\n\ndef d1(S,K,T,r,q,sigma):\n\n# change sigma*sqrt(T) to (sigma*sqrt(T))\n\nreturn(log(S/K)+(r - q +sigma**2/2.)*T)/(sigma*sqrt(T))\n\ndef d2(S,K,T,r,q,sigma):\n\nreturn d1(S,K,T,r,q,sigma)-sigma*sqrt(T)\n\n## define the call options price function\n\ndef bs_call(S,K,T,r,q,sigma):\n\nreturn S*exp(-q*T)*norm.cdf(d1(S,K,T,r,q,sigma))-K*exp(-r*T)*norm.cdf(d2(S,K,T,r,q,sigma))\n\n## define the put options price function\n\ndef bs_put(S,K,T,r,q,sigma):\n\nreturn K*exp(-r*T)-S*exp(-q*T)+bs_call(S,K,T,r,q,sigma)\n\n## input the current stock price and check if it is a number.\n\nS = 100\n\nK = 100\n\nT = 1\n\nr = 0.05\n\nq = 0.05\n\nsigma = 0.2\n\n## calculate the call / put option price\n\nprice = {'Call' : [bs_call(S,K,T,r,q,sigma)],\n\n'Put' : [bs_put(S,K,T,r,q,sigma)]}\n\nprice = DataFrame(price)\n\nGraphing Black Scholes Time Value and Intrinsic Value in Python\n\nThe most intuitive way to graph Black Scholes is probably to use excel. Please take a look at spreadsheet and youtube explanation of spreadsheet. To set up preliminaries the excel data table example is useful. The code below was motivated by this example which I will revisit when addressing volatility surface . I combined with Amber Lu's example above to simplify content.\n\nimport math\n\nimport numpy as np\n\nimport matplotlib as mpl\n\nimport matplotlib.pyplot as plt\n\nfrom math import log, sqrt, pi, exp\n\nfrom scipy.stats import norm\n\n#import numpy as np\n\n#import pandas as pd\n\nfrom pandas import DataFrame\n\n# Underlying price (per share): S;\n\n# Strike price of the option (per share): K;\n\n# Time to maturity (years): T;\n\n# Continuously compounding risk-free interest rate: r;\n\n# Continuously compounding dividend: q;\n\n# Volatility: sigma;\n\n## define two functions, d1 and d2 in Black-Scholes model\n\ndef d1(S,K,T,r,q,sigma):\n\n# change sigma*sqrt(T) to (sigma*sqrt(T))\n\nreturn(log(S/K)+(r - q +sigma**2/2.)*T)/(sigma*sqrt(T))\n\ndef d2(S,K,T,r,q,sigma):\n\nreturn d1(S,K,T,r,q,sigma)-sigma*sqrt(T)\n\n## define the call options price function\n\ndef bs_call(S,K,T,r,q,sigma):\n\nreturn S*exp(-q*T)*norm.cdf(d1(S,K,T,r,q,sigma))-K*exp(-r*T)*norm.cdf(d2(S,K,T,r,q,sigma))\n\n## define the put options price function\n\ndef bs_put(S,K,T,r,q,sigma):\n\nreturn K*exp(-r*T)-S*exp(-q*T)+bs_call(S,K,T,r,q,sigma)\n\n# Intrinsic Value and Time value\n\n#S = 100\n\nK = 100\n\nT = 1\n\nr = 0.05\n\nq = 0.0\n\nsigma = 0.2\n\n# Generate spot prices\n\nS = np.linspace(10, 200, 20)\n\nh = np.maximum(S - K, 0) # payoff of the option\n\nC = [bs_call(Szero,K,T,r,q,sigma) for Szero in S] #BS call option values\n\nplt.figure()\n\nplt.plot(S, h, 'b-.', lw=3, label='Intrinsic Value')\n\nplt.plot(S, C, 'r', lw=3, label='Time Value')\n\nplt.grid(True)\n\nplt.legend(loc=0)\n\nplt.xlabel('Spot Price of Underlying')\n\nplt.ylabel('Option Value in Current Time')\n\nprint(C)\n\nC# code for Black Scholes\n\nC# is intended to be a simple, modern, general-purpose, object-oriented programming language. The language is intended for use in developing software components suitable for deployment in distributed environments. C# applications are intended to be economical with regard to memory and processing power requirements, the language was not intended to compete directly on performance and size with C or assembly language. The C sharp code below can used to estimate Black Scholes.\n\nnamespace BlackScholesCall1\n\n{\n\nclass BlackScholesCall\n\n{\n\nstatic void Main(string[] args)\n\n{\n\n// Option settings\n\ndouble S = 100.0;\n\ndouble K = 100.0;\n\ndouble rf = 0.05;\n\ndouble q = 0.0;\n\ndouble T = 1.0;\n\ndouble v = 0.2;\n\n// Market price\n\ndouble MktPrice = BlackScholesCall1(S, K, T, rf, q, v);\n\n// Output results\n\nConsole.WriteLine(\"-----------------------------------------------\");\n\nConsole.WriteLine(\"Black Scholes Price = {0:F5}\", MktPrice);\n\nConsole.WriteLine(\"-----------------------------------------------\");\n\nConsole.Read(); // I added this\n\n}\n\n// Standard Normal CDF\n\nstatic double NormCDF(double x)\n\n{\n\ndouble b0 = 0.2316419;\n\ndouble b1 = 0.319381530;\n\ndouble b2 = -0.356563782;\n\ndouble b3 = 1.781477937;\n\ndouble b4 = -1.821255978;\n\ndouble b5 = 1.330274429;\n\ndouble pi = Math.PI;\n\ndouble phi = Math.Exp(-x * x / 2.0) / Math.Sqrt(2.0 * pi);\n\ndouble t, c;\n\ndouble CDF = 0.5;\n\nif (x > 0.0)\n\n{\n\nt = 1.0 / (1.0 + b0 * x);\n\nCDF = 1.0 - phi * (b1 * t + b2 * Math.Pow(t, 2) + b3 * Math.Pow(t, 3) + b4 * Math.Pow(t, 4) + b5 * Math.Pow(t, 5));\n\n}\n\nelse if (x < 0.0)\n\n{\n\nx = -x;\n\nt = 1.0 / (1.0 + b0 * x);\n\nc = 1.0 - phi * (b1 * t + b2 * Math.Pow(t, 2) + b3 * Math.Pow(t, 3) + b4 * Math.Pow(t, 4) + b5 * Math.Pow(t, 5));\n\nCDF = 1.0 - c;\n\n}\n\nreturn CDF;\n\n}\n\n// Black Scholes Price of Call or put\n\nstatic double BlackScholesCall1(double S, double K, double T, double rf, double q, double v)\n\n{\n\ndouble d1 = (Math.Log(S / K) + (rf - q + v * v / 2.0) * T) / v / Math.Sqrt(T);\n\ndouble d2 = d1 - v * Math.Sqrt(T);\n\ndouble BSCall = S * Math.Exp(-q * T) * NormCDF(d1) - K * Math.Exp(-rf * T) * NormCDF(d2);\n\nreturn BSCall;\n\n}\n\n}\n\n}\n\nMFC C++ Dialog Box\n\nIn this video clip, we set out how to take native Black Scholes C++ code and create a MFC dialog box where Black Scholes can be estimated. The user experience then is purely relegated to estimating the Black Scholes model without having to manipulate scripts. MFC allows the C++ code to run as elementary software. In other words, C++ functions can be easily nested in user defined software and this can distributed as an executable file. This is a very primitive form of software development.\n\n#include <iostream>\n\n#include <vector>\n\n#include <math.h>\n\nusing namespace std;\n\n// N(0,1) density\n\ndouble\n\nf(double x)\n\n{\n\ndouble pi = 4.0 * atan(1.0);\n\nreturn exp(-x * x * 0.5) / sqrt(2 * pi);\n\n}\n\n// Boole's Rule\n\ndouble\n\nBoole(double StartPoint, double EndPoint, int n)\n\n{\n\nvector < double >X(n + 1, 0.0);\n\nvector < double >Y(n + 1, 0.0);\n\ndouble delta_x = (EndPoint - StartPoint) / double(n);\n\nfor (int i = 0; i <= n; i++)\n\n{\n\nX[i] = StartPoint + i * delta_x;\n\nY[i] = f(X[i]);\n\n}\n\ndouble sum = 0;\n\nfor (int t = 0; t <= (n - 1) / 4; t++)\n\n{\n\nint ind = 4 * t;\n\nsum +=\n\n(1 / 45.0) * (14 * Y[ind] + 64 * Y[ind + 1] + 24 * Y[ind + 2] +\n\n64 * Y[ind + 3] + 14 * Y[ind + 4]) * delta_x;\n\n}\n\nreturn sum;\n\n}\n\n// N(0,1) cdf by Boole's Rule\n\ndouble\n\nN(double x)\n\n{\n\nreturn Boole(-10.0, x, 240);\n\n}\n\n// Black-Scholes Call Price\n\ndouble\n\nBSPrice(double S, double K, double T, double r, double q, double v, char OpType)\n\n{\n\ndouble d = (log(S / K) + T * (r - q + 0.5 * v * v)) / (v * sqrt(T));\n\ndouble call = S *exp(-q*T)* N(d) - exp(-r * T) * K * N(d - v * sqrt(T));\n\nif (OpType == 'C')\n\nreturn call;\n\nelse\n\n// Put Parity\n\nreturn call - S*exp(-q * T) + K * exp(-r * T);\n\n}\n\nint\n\nmain()\n\n{\n\ndouble S = 100.0;// Stock Price\n\ndouble K = 100.0;// Strike Price\n\ndouble T = 1;// Years to maturity\n\ndouble r = 0.05;// Risk free interest rate\n\ndouble q = 0.0;\n\ndouble v = 0.20;// Yearly volatility\n\nchar OpType = 'C';// 'C'all or 'P'ut\n\ncout << \"Black Scholes Price \" << BSPrice(S, K, T, r, q, v, OpType) << endl;\n\nsystem(\"PAUSE\");\n\n}\n\nCString textInput;\n\nGetDlgItemText(txt_S, textInput);\n\ndouble S = _ttof(textInput);\n\nGetDlgItemText(txt_K, textInput);\n\ndouble K = _ttof(textInput);\n\nGetDlgItemText(txt_T, textInput);\n\ndouble T = _ttof(textInput);\n\nGetDlgItemText(txt_r, textInput);\n\ndouble r = _ttof(textInput);\n\nGetDlgItemText(txt_q, textInput);\n\ndouble q = _ttof(textInput);\n\nGetDlgItemText(txt_v, textInput);\n\ndouble v = _ttof(textInput);\n\ndouble d = (log(S / K) + T * (r - q + 0.5 * v * v)) / (v * sqrt(T));\n\ndouble call = S *exp(-q*T)* N(d) - exp(-r * T) * K * N(d - v * sqrt(T));\n\ndouble put = call - S*exp(-q * T) + K * exp(-r * T);\n\nstring strCall = to_string(call);\n\nCString dEC(strCall.c_str());\n\nSetDlgItemText(txt_Call, dEC);"
    }
}