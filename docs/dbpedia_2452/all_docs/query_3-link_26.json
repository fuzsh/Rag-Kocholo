{
    "id": "dbpedia_2452_3",
    "rank": 26,
    "data": {
        "url": "https://qrisp.eu/general/tutorial/Shor.html",
        "read_more_link": "",
        "language": "en",
        "title": "Shorâs Algorithm — documentation",
        "top_image": "https://www.qrisp.eu/_static/qrisp_logo.png",
        "meta_img": "https://www.qrisp.eu/_static/qrisp_logo.png",
        "images": [
            "https://qrisp.eu/_static/qrisp_logo.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "The next generation of quantum algorithm development.",
        "meta_lang": "en",
        "meta_favicon": "../../_static/qrisp_favicon.png",
        "meta_site_name": "",
        "canonical_link": "https://qrisp.eu/general/tutorial/Shor.html",
        "text": "The general idea#\n\nGiven the number to factorize \\(N \\in \\mathbb{N}\\), the first step of Shorâs algorithm is to find the order \\(r\\) of a random number \\(a \\in \\mathbb{Z}/N\\mathbb{Z}\\). Here,\n\n\\(a\\) is a random number \\(<N\\), which is coprime to \\(N\\) i.e., \\(\\text{GCD}(a, N) = 1\\) (otherwise \\(\\text{GCD}(a, N)\\) is a factor and we are done already).\n\n\\(r\\) is the order of \\(a\\) i.e. a number such that \\(a^r = 1(\\text{mod} N)\\).\n\n\\(a \\in \\mathbb{Z}/N\\mathbb{Z}\\) is the Quotient Ring of integers modulo \\(N\\).\n\nAssume now, that for a given classical number \\(x\\), we have access to an operator \\(U_x\\), which acts as\n\n\\[U_x \\ket{y} = \\ket{(xy) \\text{mod} N}\\]\n\nthat is, \\(U_x\\) performs an in-place modular multiplication with \\(x\\) on any quantum number \\(\\ket{y}\\).\n\nThe next step of the construction is defining the state \\(\\ket{u_s}\\) for an arbitrary \\(s < r\\)\n\n\\[\\ket{u_s} = \\frac{1}{\\sqrt{r}} \\sum_{k = 0}^{r-1} \\text{exp}\\left(\\frac{-2\\pi i s k}{r}\\right)\\ket{x^k \\text{mod} N}\\]\n\nApplying \\(U\\) to such a state reveals, that it is indeed an eigenvector:\n\n\\[\\begin{split}\\begin{align} U \\ket{u_s} &= \\frac{1}{\\sqrt{r}} \\sum_{k = 0}^{r-1} \\text{exp}\\left(\\frac{-2\\pi i s k}{r}\\right) U_x \\ket{x^k \\text{mod} N}\\\\ &= \\frac{1}{\\sqrt{r}} \\sum_{k = 0}^{r-1} \\text{exp}\\left(\\frac{-2\\pi i s k}{r}\\right) \\ket{x^{k+1} \\text{mod} N}\\\\ &= \\text{exp}\\left(\\frac{2\\pi i s}{r}\\right) \\ket{u_s} \\end{align}\\end{split}\\]\n\nTherefore if we apply quantum phase estimation (with sufficient precision) to \\(U_x\\) and \\(\\ket{u_1}\\) we have basically solved the problem:\n\n\\[\\text{QPE}_{U_x} \\ket{u_1} \\ket{0} = \\ket{u_1} \\ket{\\phi_1}\\]\n\nWhere \\(\\ket{\\phi_1}\\) is a state that, if measured, is close to \\(\\frac{1}{r}\\) with high probability.\n\nAn important point here is that we donât need to call the operator \\(U_x\\) for \\(2^j\\) times to achieve \\(U_x^{2^j}\\), which is required for the quantum phase estimation. Instead we can classically precompute \\(x^{2^j} (\\text{mod}) N\\) and use \\(U_x^{2^j} = U_{x^{2^j}}\\).\n\nAs you might have noticed however, there is a problem. We would need the solution \\(r\\) to prepare \\(\\ket{u_1}\\), so this idea is not feasible. What we can do however is preparing a superposition of different \\(\\ket{u_s}\\).\n\n\\[\\frac{1}{\\sqrt{r}}\\sum_{s = 0}^{r-1} \\ket{u_s} = \\ket{1}\\]\n\nTo get an intuition about this equation, it can be helpful to view the mapping \\(\\ket{s} \\rightarrow \\ket{u_s}\\) as the generalized quantum fourier transform over \\(\\mathbb{F}_N\\) (the regular \\(n\\) qubit QFT would be \\(N = 2^n\\)). If you believe us that this Fourier transform is itâs own inverse (maybe up to some signs), then the above equation should be no problem to understand. Otherwise feel free to investigate using one of the mentioned resources.\n\nTo commence with our factoring problem we now apply quantum phase estimation to \\(\\ket{1}\\).\n\n\\[\\begin{split}\\begin{align} \\text{QPE}_{U_x} \\ket{1} \\ket{0} &= \\frac{1}{\\sqrt{r}}\\sum_{s = 0}^{r-1} \\text{QPE}_{U_x} \\ket{u_s} \\ket{0}\\\\ &= \\frac{1}{\\sqrt{r}} \\sum_{s = 0}^{r-1} \\ket{u_s} \\ket{\\phi_s} \\end{align}\\end{split}\\]\n\nIn the next step, we measure the second register to acquire a value \\(h\\) which is close to a number of the form \\(\\frac{s}{r}\\). Using the continued fraction algorithm we can turn \\(h\\) into a fraction \\(\\frac{\\tilde{s}}{\\tilde{r}}\\). \\(\\tilde{r}\\) is therefore a potential candidate for the solution \\(r\\). Finally, we verify our potential solutin using \\(a^r = 1 (\\text{mod}) N\\) or (if neccessary) measure another \\(h\\).\n\nThe next step is to transform the equation, defining \\(r\\)\n\n\\[a^r = 1 (\\text{mod})N \\Leftrightarrow a^r -1 = 0 (\\text{mod}) N\\]\n\nCombining this with the definition of the modulus operation, we can see that \\(N\\) must be a factor of \\(a^r - 1\\) (written \\(N | (a^r - 1)\\)). If \\(r\\) is even, we can write\n\n\\[a^r - 1 = (a^{r/2} - 1)(a^{r/2} + 1)\\]\n\nOn the other hand, if \\(r\\) is odd, the algorithm needs to restart picking a different \\(a\\). Finally, we check whether one of these (for instance \\(a^{r/2} + 1\\)) has a common factor with \\(N\\) and, if so, we are done. Otherwise the algorithm needs to restart.\n\nTo acquire the final result of the factorization \\(g\\) we compute\n\n\\[g = \\text{gcd}(a^{r/2} + 1, N)\\]\n\nNaturally, the other factor is found to be \\(N/g\\).\n\nImplementation#\n\nAs you might know by now, the reason why this algorithm can be tricky to implement is because the operator \\(U_x\\) is non-trivial to encode as a quantum circuit and a variety of ideas have been proposed in the past. A popular way of constructing this circuit is to start with a regular in-place adder, build a modular adder from that, build an out-of-place modular multiplyer from that, and finally combine two out-of-place multiplyers into one modular in-place multiplyer. If this wasnât already complicated enough, you also need the controlled version of this circuit. The approach that we are using here might also be complicated but the Qrisp abstractions allow for a powerfull reduction in complexity for the user, while still retaining a degree of flexibility for customization and most importantly, PERFORMANCE. ð\n\nNote\n\nTo make sure you understand everything and get familiar with the concepts, we strongly recommend to execute the code yourself! Either with the Thebe server (might be slow) or on your own device!\n\nThe central concept of our implementation is the QuantumModulus class. This quantum type can be used to represent and process elements of a Quotient Ring, which is basically just a fancy wording for ânumbers that operate under modular arithmeticâ.\n\n>>> from qrisp import * >>> N = 13 >>> qg = QuantumModulus(N) >>> qg[:] = 8\n\nThis snippet creates such a QuantumVariable with modulus \\(N = 13\\). Subsequently we encode the value 8. The defining feature of this type is the fact that arithmetic is always modular.\n\n>>> qg += 8 >>> print(qg) {3: 1.0}\n\nWe can take a look at the quantum circuit:\n\n>>> print(qg.qs)\n\nAs you can see under the hood, there is a lot of complexity, however due to systematic development and testing, a lot of it can be hidden from the user. Feel free to try out the in-place multiplication *=!\n\nUsing the QuantumModulus class allows us to implement Shorâs algorithm within a few lines of code! For a simple example, let us factor \\(N = 99\\) using \\(a = 10\\).\n\n>>> N = 99 >>> a = 10 >>> qg = QuantumModulus(N) >>> qg[:] = 1\n\nAccording to literature, a quantum phase estimation precision of \\(2n+1\\) is sufficient, where \\(n\\) is the bit-width of \\(N\\).\n\n>>> n = qg.size >>> qpe_res = QuantumFloat(2*n+1, exponent = -(2*n+1)) >>> h(qpe_res)\n\nNote the exponent keyword of the QuantumFloat constructor. It indicates that this QuantumFloat can represent numbers up to the precision \\(2^{-(2n+1)}\\). After construction, we apply a Hadamard gate to each qubit as is customary in quantum phase estimation.\n\nWe can now code the main loop:\n\nx = a for i in range(len(qpe_res)): with control(qpe_res[i]): qg *= x x = (x*x)%N\n\nNote that we have \\(x=a^{2^i}\\) at the i-th iteration. Such a procedure is called repeated squaring and reduces the classical resources for the computation of \\(x\\) in each iteration.\n\nFinally, we conclude the phase estimation with the inverse quantum Fourier transformation and perform a measurement.\n\n>>> QFT(qpe_res, inv = True) >>> meas_res = qpe_res.get_measurement() >>> print(meas_res) {0.0: 0.5, 0.5: 0.5}\n\nTo perform the continued fraction step, we can use some sympy tools:\n\nfrom sympy import continued_fraction_convergents, continued_fraction_iterator, Rational def get_r_candidates(approx): rationals = continued_fraction_convergents(continued_fraction_iterator(Rational(approx))) return [rat.q for rat in rationals]\n\nThis function takes an approximation value approx and calculates fractionals of the form \\(\\frac{p}{q}\\) that are increasingly close to approx. To extract our results for the \\(r\\) values, we are interested in the \\(q\\) part of each fractional.\n\n>>> r_candidates = sum([get_r_candidates(approx) for approx in meas_res.keys()], [])\n\nTo find the correct \\(r\\), we perform a classical search on our results\n\nfor cand in r_candidates: if (a**cand)%N == 1: r = cand break else: raise Exception(\"Please sample again\") if r % 2: raise Exception(\"Please choose another a\")\n\nThe final step in acquiring the factor is computing the greatest common divisor of \\(a^{r/2 + 1}\\), which can be done efficiently\n\n>>> import numpy as np >>> g = np.gcd(a**(r//2)+1, N) >>> print(g) 11\n\nAaaaand we are done! â²ï¸\n\nTo highlight once more how much Qrisp simplifies the construction, we summarize the code of the quantum subroutine in a single function:\n\ndef find_order(a, N): qg = QuantumModulus(N) qg[:] = 1 qpe_res = QuantumFloat(2*qg.size + 1, exponent = -(2*qg.size + 1)) h(qpe_res) for i in range(len(qpe_res)): with control(qpe_res[i]): qg *= a a = (a*a)%N QFT(qpe_res, inv = True) return qpe_res.get_measurement()\n\n11 lines - feel free to compare with other implementations!\n\nTo learn how to compile this algorithm optimized for fault-tolerant backends and deploy an exponentially faster adder, make sure to check out the next tutorial!"
    }
}