{
    "id": "dbpedia_2452_3",
    "rank": 1,
    "data": {
        "url": "https://www.classiq.io/insights/shors-algorithm-explained",
        "read_more_link": "",
        "language": "en",
        "title": "Quantum Cryptography - Shor's Algorithm Explained",
        "top_image": "https://cdn.prod.website-files.com/6051c82bb106f381a2f95f8f/62d6be6dc33ab74cf630bddb_hacker-2021-08-31-16-06-59-utc.jpeg",
        "meta_img": "https://cdn.prod.website-files.com/6051c82bb106f381a2f95f8f/62d6be6dc33ab74cf630bddb_hacker-2021-08-31-16-06-59-utc.jpeg",
        "images": [
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60003654676fe148a0178cc2_Logo.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/65c61873c003d026d1cd04b9_burger_18px.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/65c61841352345eeb2f18a14_close_18px.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60b8c76a1595f95bf6005cb8_exit-search.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60b8cbd9dce4825730eb037a_Group%20586hover.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60cf2f3fdb4ae41a52c463e2_Vector%201%20(Stroke).svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60ced3b33ed9bdf74cfb648d_Group%2090.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60ced3b330b8915eb18e34d2_Vector.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60ced3b3d1b31b27fc8bd912_Vector-1.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60ced3b3061e1e4bc2b0235d_fluent_mail-16-filled.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/6162acd49514763345aa3b32_Polygon%201.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/615dc3af667e241c86bf80d0_Apple%20Podcast.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/615dc3aff88753b7a9c8e371_Spotify_logo_without_text%201.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/615dc3afeb694f240b6d2e5b_Amazon.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/615dc3af9d30938aba00e275_Google%20Podcast.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/615dc3ae55b907e8e2dd1f98_Rss.svg",
            "https://cdn.prod.website-files.com/6051c82bb106f381a2f95f8f/6666ffc7a8fc24e0750ad55f_image%20(37).png",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60d994fd0097ebfed4d0b25a_Play.svg",
            "https://cdn.prod.website-files.com/6051c82bb106f381a2f95f8f/6666ffc7a8fc24e0750ad55f_image%20(37).png",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60cef408d1b31b90708c2530_Vector%203.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60cef408d1b31b90708c2530_Vector%203.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60cb03ca1f76c355f618442b_Property%201%3Dplay.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60cb03caeed27231c1aca4f8_Property%201%3DAudio.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60cefd6db0f873304d18f49c_inner-blog-bg-images.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60003fce71e4e86529acda6c_Ellipse%2040.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60003fce71e4e86529acda6c_Ellipse%2040.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/600040266ee51cd2a1d414c7_Rectangle%20221.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60003fce71e4e86529acda6c_Ellipse%2040.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/61a5ff84db6e3b68f2055a1a_Classiq%27s-logo.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/605c5b4054acd02ba01f7bf3_in.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/60fd57802c973ba5370795d5_Vector.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/65a80381db00e4ec293d96f2_x.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/65a8038b4010ca31d43a1ba1_git-hub.svg",
            "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/65aa5aec4a482703713e8df1_ep_office-building.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2022-07-19T00:00:00",
        "summary": "",
        "meta_description": "\"Articles\" post in a series of articles about quantum computing software and hardware, quantum computing industry news, qc hardware/software integration and more",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.prod.website-files.com/60000db7a5f449af5e4590ac/600ff7486d5022e48c4ed193_Favicon%2036%201.png",
        "meta_site_name": "",
        "canonical_link": "https://www.classiq.io/insights/shors-algorithm-explained",
        "text": "Visit Classiqâs Library for an implementation of Shorâs algorithm\n\nâ\n\nAnyone interested in learning quantum computing cannot avoid hearing about Shorâs Factoring Algorithm. It is one of the few textbook quantum algorithms, which means that it remains one of the rare examples of quantum computational advantage. In other words, the algorithm can compute something quantumly that is harder and slower to compute classically. In fact, this particular algorithm can compute something that is for all practical intents and purposes, as far as we know, impossible to do classically at any useful scale.\n\nAmong the aforementioned textbook algorithms, Shorâs Factoring Algorithm stands out from the crowd. There are two excellent reasons for this. First, it can factor numbers exponentially faster than any known classical algorithm. While all of the textbook quantum algorithms offer computational advantages, Shorâs Algorithm is one of the elite few with an exponential speedup, as well as one of the elite few with a practical application. Most importantly, its potential to factor numbers in reasonable timeframes directly threatens the worldâs most popular cryptosystems.Â Â\n\nThe significance of that cannot be overstated. RSA encryption, protecting financial transactions worldwide, works by multiplying two huge prime numbers. Prime numbers cannot be divided into integers other than themselves and the number one. Their products are so large, that there is no known way to efficiently factor them classically. Think of factoring as reverse multiplication, determining the prime numbers used, thus allowing unauthorized decryption of internet communications.\n\nThis blog article occasionally refers to the algorithm under discussion as Shorâs Factoring Algorithm, and not simply Shorâs Algorithm, because there is also a quantum error correction code bearing the name Shor, with the same namesake, which was discovered as a consequence of publishing the factoring algorithm. For this article, to avoid ambiguity up front, know that Shorâs Algorithm and Shorâs Factoring Algorithm refer to the same algorithm.\n\nWhat is Shor's algorithm in quantum computing? Â Â Â Â Â Â Â Â Â Â Â Â\n\nShorâs Factoring Algorithm put quantum computing on the proverbial map. By threatening animated version, national governments, whole industries, and the public at large were forced to take notice of this relatively new technology. Decades later, this algorithm remains the standard bearer of quantum algorithms.Â Significant effort has been underway for a long time to protect global financial systems, national security, and all other uses of cryptography, for that matter. There is a clear and present geopolitical danger of anyone, especially a state actor, developing sufficient quantum computing power to employ Shorâs algorithm before quantum-safe cryptosystems can be universally deployed.\n\nAlmost as important, Shorâs algorithm has led to the present-day investment of billions of dollars into quantum technologies, including quantum computing. Three decades since the algorithm was discovered, the search continues for other practical applications for which exponential speedups can be realized. If at least one algorithm can achieve this, the thinking goes, there must be others. After all these years, the most likely candidates borrow from Shorâs algorithm.\n\nTo hear the full-length story of the discovery of Shorâs Factoring Algorithm, as told by Professor Peter Shor himself, watch here on Qiskitâs YouTube, or to hear a shorter, animated version of this story, watch here.\n\nHow does Shor's algorithm work?\n\nFactoring numbers with Shorâs algorithm begins with selecting a random integer smaller than the number to be factored. The classically-calculated greatest common divisor (GCD) of these two numbers, the random number and the target number, is then used to determine whether the target number has already been factored accidentally. For smaller numbers, thatâs a possibility. For larger numbers, a supercomputer could be needed. And for numbers that are believed to be cryptographically secure, a quantum computer will be needed.\n\nThe role of the quantum computer is to determine the period of the number to be factored. The calculation results determine whether a new random integer needs to be tested, or whether the sought-after factors have been discovered. Once the target integer has been factored, the role of Shorâs Algorithm is concluded\n\nAt a high level, this whole process might seem quite simple. And, at a high level, it is. However, explaining each step in detail can be broken down into a series of lectures. Implementing the algorithm can be done after completing a short tutorial, but fully understanding the algorithm can consume many hours of study.Â\n\nFor a mathematical explanation of Shorâs Factoring Algorithm, check out here. Otherwise, thatâs Shorâs Algorithm explained in a nutshell.\n\nHow is Shor's algorithm implemented?Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â\n\nShorâs Factoring Algorithm is not simple to implement. First of all, the algorithm has three major components: one using classical computation, one using quantum computation, and another using classical computation. Overall, the algorithm has six significant steps, as summarized above.\n\nAdding to this complexity, however, the quantum component of Shorâs Factoring Algorithm has four subcomponents, each of which could have an entire article of explanation in their own rights. And while two of those quantum subcomponents are relatively straightforward to explain, the other two are incredibly important quantum subroutines. In fact, they are arguably the two most significant quantum subroutines.\n\nOne of the critical quantum subcomponents is called quantum phase estimation (QPE). The important takeaway here is that it performs the modular arithmetic needed to find the period of the number to be factored. In other words, this is where the factoring power of Shorâs algorithm comes from.Â\n\nThe other key quantum subcomponent is called the inverse Quantum Fourier Transform (iQFT). Simply put, the iQFT takes the quantum result of the modular arithmetic that immediately precedes it and transforms it into classical information that can be retrieved from the quantum circuit through a process known as measurement.\n\nAll together, Shorâs Factoring Algorithm begins with a few classical steps. The quantum component then finds the period of the number to be factored. This is done through quantum modular arithmetic, the result of which is converted from quantum information to classical information so that it is useable. And, finally, there are another couple of classical steps. If the answer is not found, and the number consequently cannot be factored, the algorithm in its entirety is adjusted and repeated.\n\nâ\n\nHow many qubits are needed for Shor's algorithm?Â\n\nA distinction first needs to be made between physical and logical qubits to answer this question. All present-day qubits are physical qubits. They are extremely ânoisy,â which means they are error-prone. The results of quantum computation of any significance make it impossible to distinguish correct answers from incorrect ones. Every possible solution has the same probability of being right, which is the same as having no answers at all.\n\nThatâs where logical qubits come into play. Physical qubits need to be connected and structured in ways that they will collectively provide enough error correction to each other to be considered âfault-tolerantâ collectively. At that point, these qubit collectives become known as âlogical qubits,â or sometimes âperfect qubits.â\n\nThese logical qubits are abstractions. A quantum circuit today with five qubits represents five highly-noisy, error-prone physical qubits. Quantum algorithm designers of the near future will want those five qubits to represent logical, fault-tolerant, error-free qubits. The estimates vary as to how many physical qubits will be needed to represent one logical qubit, but a reasonable number to work with is 1,000. Most estimate that a quantum computer will need around 1,000 physical qubits to represent just one logical qubit.\n\nTo appreciate how challenging that is, the largest quantum computer today has only 127 physical qubits. And while IBM has a goal of unveiling a 1,000-qubit device by next year, that is still only 1,000 physical qubits. Much work remains to engineer the first logical qubit.\n\nEstimates of the number of qubits Shorâs Factoring Algorithm needs vary considerably. First, care must be taken, as noted, to discern estimates for logical qubits and estimates for physical qubits. Depending on the researchers' objectives, the number of required qubits can be reduced, sacrificing time of execution and circuit depth. On the other hand, the number of qubits can be significantly expanded, reducing runtime and shedding circuit depth. The differences are that lower qubit counts will become available sooner, while the quickest runtimes will be the most advantageous. A selection of estimates follows.\n\nIn an August 1, 1996 paper titled, âEfficient networks for quantum factoringâ by David Beckman, Amalavoyal N. Chari, Srikrishna Devabhaktuni, and John Preskill, the authors estimated that factoring a K-bit number would take K3 time and require 5K+1 logical qubits. Factoring a 2,048-bit number, referring to breaking RSA encryption, would therefore take 8.6 billion time and require 10,241 logical qubits, or roughly 10 million physical qubits. Unfortunately, itâs not clear how long 8.6 billion time would be, as different qubit technologies operate at different speeds.\n\nThen in a February 21, 2003, paper titled, âCircuit for Shorâs algorithm using 2n+3 qubitsâ by StÂ´ephane Beauregard, the authors estimated that factoring a K-bit number would require 2n+3 logical qubits. Factoring a 2,048-bit number would therefore require only 4,099 logical qubits, or roughly 4 million physical qubits. Again, zero logical qubits exist today. However, this paper nonetheless brought Shorâs Factoring Algorithm closer to implementation.Â\n\nThen in a May 2014 book titled, âFast quantum modular exponentiation architecture for Shor's factoring algorithmâ (pp0649-0682) by Archimedes Pavlidis and Dimitris Gizopoulos, the authors proposed a 9n+2 implementation, adding a significant number of qubits to reduce circuit depth. Breaking 2,048-bit RSA encryption would require 18,434 logical qubits or roughly 18 million physical qubits. One reason to minimize circuit depth is that qubits lose âcoherenceâ over time. The longer it takes to execute a circuit, as determined, in part, by circuit depth, the more noise can seep into the system and the more errors can pop up in the results. Even today, one way to reduce errors is to minimize circuit depth.\n\nMost recently, in an April 13, 2021 paper titled, âHow to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubitsâ by Craig Gidney and Martin Eker, the authors estimate that breaking RSA encryption, specifically, would require roughly 20,000 logical qubits, or approximately 20 million physical qubits. The authors take one step further and quantify the runtime for their configuration as only eight hours. Compare that to the estimate for the worldâs most powerful supercomputers to break RSA encryption, which is well beyond any human lifetime, and the power of Shorâs Factoring Algorithm becomes clear. For other estimates of how many qubits for Shorâs algorithm, check out the references for this paper.\n\nAgain, Shorâs algorithm runtime is inversely proportional to the number of logical qubits available. It also depends on the qubit technology in use, since different quantum computers execute operations at vastly different speeds. The fewer qubits needed, the longer the algorithm will take to run, but the sooner modern cryptosystems transition from obsolescent to obsolete. Conversely, the more qubits available, the faster modern cryptosystems will be cracked. But fortunately, those days are even further away.\n\nHow do you run Shor's algorithm?\n\nYou canât.Â\n\nThe largest number factored to date with Shorâs Algorithm is 21. And the smallest possible number to factor with the algorithm is 15. That is a very narrow range for two specific reasons. First, Shorâs Factoring Algorithm requires large numbers of qubits, as previously mentioned, and large numbers of qubits do not exist. Second, present-day qubits are ânoisy,â which means they are remarkably error-prone. The circuit depth required by the algorithm produces results with so many errors that it is impossible to distinguish correct solutions from incorrect ones.\n\nIn other words, RSA and other potentially-vulnerable cryptosystems are safe. For now. NIST continues to work toward selecting a post-quantum standard, otherwise known as a âquantum-safeâ standard, to hopefully be implemented widespread long before enough fault-tolerant qubits are available to realize this pending threat.\n\nDespite the long timeframe involved and the work being done to mitigate the risk, Shorâs Factoring Algorithm remains as good a way to raise awareness about quantum computing today as it was when it was first discovered. Executives across all industries need to concern themselves with potential risks to sensitive communications and data, and this one is genuine. In the process, theyâll hopefully be introduced to the dozens of other potential use cases of quantum computing that might substantially benefit their respective enterprises someday.\n\nVisit Classiqâs Library for an implementation of Shorâs algorithmâ\n\nVisit Classiqâs Library for an implementation of Shorâs algorithm\n\nâ\n\nAnyone interested in learning quantum computing cannot avoid hearing about Shorâs Factoring Algorithm. It is one of the few textbook quantum algorithms, which means that it remains one of the rare examples of quantum computational advantage. In other words, the algorithm can compute something quantumly that is harder and slower to compute classically. In fact, this particular algorithm can compute something that is for all practical intents and purposes, as far as we know, impossible to do classically at any useful scale.\n\nAmong the aforementioned textbook algorithms, Shorâs Factoring Algorithm stands out from the crowd. There are two excellent reasons for this. First, it can factor numbers exponentially faster than any known classical algorithm. While all of the textbook quantum algorithms offer computational advantages, Shorâs Algorithm is one of the elite few with an exponential speedup, as well as one of the elite few with a practical application. Most importantly, its potential to factor numbers in reasonable timeframes directly threatens the worldâs most popular cryptosystems.Â Â\n\nThe significance of that cannot be overstated. RSA encryption, protecting financial transactions worldwide, works by multiplying two huge prime numbers. Prime numbers cannot be divided into integers other than themselves and the number one. Their products are so large, that there is no known way to efficiently factor them classically. Think of factoring as reverse multiplication, determining the prime numbers used, thus allowing unauthorized decryption of internet communications.\n\nThis blog article occasionally refers to the algorithm under discussion as Shorâs Factoring Algorithm, and not simply Shorâs Algorithm, because there is also a quantum error correction code bearing the name Shor, with the same namesake, which was discovered as a consequence of publishing the factoring algorithm. For this article, to avoid ambiguity up front, know that Shorâs Algorithm and Shorâs Factoring Algorithm refer to the same algorithm.\n\nWhat is Shor's algorithm in quantum computing? Â Â Â Â Â Â Â Â Â Â Â Â\n\nShorâs Factoring Algorithm put quantum computing on the proverbial map. By threatening animated version, national governments, whole industries, and the public at large were forced to take notice of this relatively new technology. Decades later, this algorithm remains the standard bearer of quantum algorithms.Â Significant effort has been underway for a long time to protect global financial systems, national security, and all other uses of cryptography, for that matter. There is a clear and present geopolitical danger of anyone, especially a state actor, developing sufficient quantum computing power to employ Shorâs algorithm before quantum-safe cryptosystems can be universally deployed.\n\nAlmost as important, Shorâs algorithm has led to the present-day investment of billions of dollars into quantum technologies, including quantum computing. Three decades since the algorithm was discovered, the search continues for other practical applications for which exponential speedups can be realized. If at least one algorithm can achieve this, the thinking goes, there must be others. After all these years, the most likely candidates borrow from Shorâs algorithm.\n\nTo hear the full-length story of the discovery of Shorâs Factoring Algorithm, as told by Professor Peter Shor himself, watch here on Qiskitâs YouTube, or to hear a shorter, animated version of this story, watch here.\n\nHow does Shor's algorithm work?\n\nFactoring numbers with Shorâs algorithm begins with selecting a random integer smaller than the number to be factored. The classically-calculated greatest common divisor (GCD) of these two numbers, the random number and the target number, is then used to determine whether the target number has already been factored accidentally. For smaller numbers, thatâs a possibility. For larger numbers, a supercomputer could be needed. And for numbers that are believed to be cryptographically secure, a quantum computer will be needed.\n\nThe role of the quantum computer is to determine the period of the number to be factored. The calculation results determine whether a new random integer needs to be tested, or whether the sought-after factors have been discovered. Once the target integer has been factored, the role of Shorâs Algorithm is concluded\n\nAt a high level, this whole process might seem quite simple. And, at a high level, it is. However, explaining each step in detail can be broken down into a series of lectures. Implementing the algorithm can be done after completing a short tutorial, but fully understanding the algorithm can consume many hours of study.Â\n\nFor a mathematical explanation of Shorâs Factoring Algorithm, check out here. Otherwise, thatâs Shorâs Algorithm explained in a nutshell.\n\nHow is Shor's algorithm implemented?Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â Â\n\nShorâs Factoring Algorithm is not simple to implement. First of all, the algorithm has three major components: one using classical computation, one using quantum computation, and another using classical computation. Overall, the algorithm has six significant steps, as summarized above.\n\nAdding to this complexity, however, the quantum component of Shorâs Factoring Algorithm has four subcomponents, each of which could have an entire article of explanation in their own rights. And while two of those quantum subcomponents are relatively straightforward to explain, the other two are incredibly important quantum subroutines. In fact, they are arguably the two most significant quantum subroutines.\n\nOne of the critical quantum subcomponents is called quantum phase estimation (QPE). The important takeaway here is that it performs the modular arithmetic needed to find the period of the number to be factored. In other words, this is where the factoring power of Shorâs algorithm comes from.Â\n\nThe other key quantum subcomponent is called the inverse Quantum Fourier Transform (iQFT). Simply put, the iQFT takes the quantum result of the modular arithmetic that immediately precedes it and transforms it into classical information that can be retrieved from the quantum circuit through a process known as measurement.\n\nAll together, Shorâs Factoring Algorithm begins with a few classical steps. The quantum component then finds the period of the number to be factored. This is done through quantum modular arithmetic, the result of which is converted from quantum information to classical information so that it is useable. And, finally, there are another couple of classical steps. If the answer is not found, and the number consequently cannot be factored, the algorithm in its entirety is adjusted and repeated.\n\nâ\n\nHow many qubits are needed for Shor's algorithm?Â\n\nA distinction first needs to be made between physical and logical qubits to answer this question. All present-day qubits are physical qubits. They are extremely ânoisy,â which means they are error-prone. The results of quantum computation of any significance make it impossible to distinguish correct answers from incorrect ones. Every possible solution has the same probability of being right, which is the same as having no answers at all.\n\nThatâs where logical qubits come into play. Physical qubits need to be connected and structured in ways that they will collectively provide enough error correction to each other to be considered âfault-tolerantâ collectively. At that point, these qubit collectives become known as âlogical qubits,â or sometimes âperfect qubits.â\n\nThese logical qubits are abstractions. A quantum circuit today with five qubits represents five highly-noisy, error-prone physical qubits. Quantum algorithm designers of the near future will want those five qubits to represent logical, fault-tolerant, error-free qubits. The estimates vary as to how many physical qubits will be needed to represent one logical qubit, but a reasonable number to work with is 1,000. Most estimate that a quantum computer will need around 1,000 physical qubits to represent just one logical qubit.\n\nTo appreciate how challenging that is, the largest quantum computer today has only 127 physical qubits. And while IBM has a goal of unveiling a 1,000-qubit device by next year, that is still only 1,000 physical qubits. Much work remains to engineer the first logical qubit.\n\nEstimates of the number of qubits Shorâs Factoring Algorithm needs vary considerably. First, care must be taken, as noted, to discern estimates for logical qubits and estimates for physical qubits. Depending on the researchers' objectives, the number of required qubits can be reduced, sacrificing time of execution and circuit depth. On the other hand, the number of qubits can be significantly expanded, reducing runtime and shedding circuit depth. The differences are that lower qubit counts will become available sooner, while the quickest runtimes will be the most advantageous. A selection of estimates follows.\n\nIn an August 1, 1996 paper titled, âEfficient networks for quantum factoringâ by David Beckman, Amalavoyal N. Chari, Srikrishna Devabhaktuni, and John Preskill, the authors estimated that factoring a K-bit number would take K3 time and require 5K+1 logical qubits. Factoring a 2,048-bit number, referring to breaking RSA encryption, would therefore take 8.6 billion time and require 10,241 logical qubits, or roughly 10 million physical qubits. Unfortunately, itâs not clear how long 8.6 billion time would be, as different qubit technologies operate at different speeds.\n\nThen in a February 21, 2003, paper titled, âCircuit for Shorâs algorithm using 2n+3 qubitsâ by StÂ´ephane Beauregard, the authors estimated that factoring a K-bit number would require 2n+3 logical qubits. Factoring a 2,048-bit number would therefore require only 4,099 logical qubits, or roughly 4 million physical qubits. Again, zero logical qubits exist today. However, this paper nonetheless brought Shorâs Factoring Algorithm closer to implementation.Â\n\nThen in a May 2014 book titled, âFast quantum modular exponentiation architecture for Shor's factoring algorithmâ (pp0649-0682) by Archimedes Pavlidis and Dimitris Gizopoulos, the authors proposed a 9n+2 implementation, adding a significant number of qubits to reduce circuit depth. Breaking 2,048-bit RSA encryption would require 18,434 logical qubits or roughly 18 million physical qubits. One reason to minimize circuit depth is that qubits lose âcoherenceâ over time. The longer it takes to execute a circuit, as determined, in part, by circuit depth, the more noise can seep into the system and the more errors can pop up in the results. Even today, one way to reduce errors is to minimize circuit depth.\n\nMost recently, in an April 13, 2021 paper titled, âHow to factor 2048 bit RSA integers in 8 hours using 20 million noisy qubitsâ by Craig Gidney and Martin Eker, the authors estimate that breaking RSA encryption, specifically, would require roughly 20,000 logical qubits, or approximately 20 million physical qubits. The authors take one step further and quantify the runtime for their configuration as only eight hours. Compare that to the estimate for the worldâs most powerful supercomputers to break RSA encryption, which is well beyond any human lifetime, and the power of Shorâs Factoring Algorithm becomes clear. For other estimates of how many qubits for Shorâs algorithm, check out the references for this paper.\n\nAgain, Shorâs algorithm runtime is inversely proportional to the number of logical qubits available. It also depends on the qubit technology in use, since different quantum computers execute operations at vastly different speeds. The fewer qubits needed, the longer the algorithm will take to run, but the sooner modern cryptosystems transition from obsolescent to obsolete. Conversely, the more qubits available, the faster modern cryptosystems will be cracked. But fortunately, those days are even further away.\n\nHow do you run Shor's algorithm?\n\nYou canât.Â\n\nThe largest number factored to date with Shorâs Algorithm is 21. And the smallest possible number to factor with the algorithm is 15. That is a very narrow range for two specific reasons. First, Shorâs Factoring Algorithm requires large numbers of qubits, as previously mentioned, and large numbers of qubits do not exist. Second, present-day qubits are ânoisy,â which means they are remarkably error-prone. The circuit depth required by the algorithm produces results with so many errors that it is impossible to distinguish correct solutions from incorrect ones.\n\nIn other words, RSA and other potentially-vulnerable cryptosystems are safe. For now. NIST continues to work toward selecting a post-quantum standard, otherwise known as a âquantum-safeâ standard, to hopefully be implemented widespread long before enough fault-tolerant qubits are available to realize this pending threat.\n\nDespite the long timeframe involved and the work being done to mitigate the risk, Shorâs Factoring Algorithm remains as good a way to raise awareness about quantum computing today as it was when it was first discovered. Executives across all industries need to concern themselves with potential risks to sensitive communications and data, and this one is genuine. In the process, theyâll hopefully be introduced to the dozens of other potential use cases of quantum computing that might substantially benefit their respective enterprises someday.\n\nVisit Classiqâs Library for an implementation of Shorâs algorithmâ"
    }
}