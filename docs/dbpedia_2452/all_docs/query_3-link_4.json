{
    "id": "dbpedia_2452_3",
    "rank": 4,
    "data": {
        "url": "https://www.geeksforgeeks.org/shors-factorization-algorithm/",
        "read_more_link": "",
        "language": "en",
        "title": "Shor’s Factorization Algorithm",
        "top_image": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_200x200-min.png",
        "meta_img": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_200x200-min.png",
        "images": [
            "https://media.geeksforgeeks.org/gfg-gg-logo.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/Google-news.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/Google-news.svg",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/new-premium-rbanner-us.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/gfgFooterLogo.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/googleplay.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/appstore.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/suggestChangeIcon.png",
            "https://media.geeksforgeeks.org/auth-dashboard-uploads/createImprovementIcon.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "Data Structures",
            "Algorithms",
            "Python",
            "Java",
            "C",
            "C++",
            "JavaScript",
            "Android Development",
            "SQL",
            "Data Science",
            "Machine Learning",
            "PHP",
            "Web Development",
            "System Design",
            "Tutorial",
            "Technical Blogs",
            "Interview Experience",
            "Interview Preparation",
            "Programming",
            "Competitive Programming",
            "Jobs",
            "Coding Contests",
            "GATE CSE",
            "HTML",
            "CSS",
            "React",
            "NodeJS",
            "Placement",
            "Aptitude",
            "Quiz",
            "Computer Science",
            "Programming Examples",
            "GeeksforGeeks Courses",
            "Puzzles",
            "SSC",
            "Banking",
            "UPSC",
            "Commerce",
            "Finance",
            "CBSE",
            "School",
            "k12",
            "General Knowledge",
            "News",
            "Mathematics",
            "Exams"
        ],
        "tags": null,
        "authors": [
            "GeeksforGeeks"
        ],
        "publish_date": "2021-01-24T12:00:12",
        "summary": "",
        "meta_description": "A Computer Science portal for geeks. It contains well written, well thought and well explained computer science and programming articles, quizzes and practice/competitive programming/company interview Questions.",
        "meta_lang": "en",
        "meta_favicon": "https://media.geeksforgeeks.org/wp-content/cdn-uploads/gfg_favicon.png",
        "meta_site_name": "GeeksforGeeks",
        "canonical_link": "https://www.geeksforgeeks.org/shors-factorization-algorithm/",
        "text": "Last Updated : 16 Jan, 2024\n\nImprove\n\nShor’s Factorization Algorithm:\n\nShor’s Factorization Algorithm is proposed by Peter Shor.\n\nIt suggests that quantum mechanics allows the factorization to be performed in polynomial time, rather than exponential time achieved after using classical algorithms.\n\nThis could have a drastic impact on the field of data security, a concept based on the prime factorization of large numbers.\n\nMany polynomial-time algorithms for integer multiplication (e.g., Euclid’s Algorithm) do exist, but no polynomial-time algorithm for factorization exists.\n\nSo, Shor came up with an algorithm i.e. Shor’s Factorization Algorithm, an algorithm for factorizing non-prime integers N of L bits.\n\nQuantum algorithms are far much better than classical algorithms because they are based on Quantum Fourier Transform.\n\nRun time on the classical computer is O[exp (L1/3(log L)2/3)] but that on the quantum computer is O(L3).\n\nSo, Shor’s Algorithm in principle, shows that a quantum computer is capable of factoring very large numbers in polynomial time.\n\nShor’s Algorithm depends on:\n\nModular Arithmetic\n\nQuantum Parallelism\n\nQuantum Fourier Transformation\n\nThe Algorithm stands as:\n\nGiven an odd composite number N, find an integer d, strictly between 1 and N, that divides N.\n\nShor’s Algorithm consists of the following two parts:\n\nConversion of the problem of factorizing to the problem of finding the period. This part can be implemented with classical means.\n\nFinding the period or Quantum period finding using the Quantum Fourier Transform, and is responsible for quantum speedup, and utilizes quantum parallelism.\n\nIn Shor’s Algorithm, the Input is Non-prime number N and the Output is Non-trivial factor of N\n\nINPUT (N) —> SHOR’S ALGORITHM —> OUTPUT (Non-trivial factor of N)\n\nAlgorithm: It contains a few steps, at only step 2 the use of quantum computers is required.\n\nChoose any random number let say r, such that r < N so that they are co-primes of each other.\n\nA quantum computer is used to determine the unknown period p of the function fr, N (x) = rx mod N.\n\nIf p is an odd integer, then go back to Step 1. Else move to the next step.\n\nSince p is an even integer so, (rp/2 – 1)(rp/2 + 1) = rp – 1 = 0 mod N.\n\nNow, if the value of rp/2 + 1 = 0 mod N, go back to Step 1.\n\nIf the value of rp/2 + 1 != 0 mod N, Else move to the next step.\n\nCompute d = gcd(rp/2-1, N).\n\nThe answer required is ‘d’.\n\nClassical part (The order finding problem):\n\nThis is the classical part of order finding problem. Given that x and N, such that x<N and gcd(x, N) = 1. The order of x is the least positive integer, y such that xy = 1(mod N).\n\nA random number n is picked, such that n < N. Compute gcd(n, N).\n\nThis can be done using the Euclid Algorithm.\n\nIf gcd(n, N) != 1, then there is a non-trivial factor of N.If (x+p) = nx + p mod N = nxmod N = f(x).\n\nIf r is odd, then go back to Step 1.\n\nIf np/2 = -1(mod N), then go back to Step 1.\n\nThe gcd(np/2 +/- 1, N) is a non-trivial factor of N.\n\nQuantum part:\n\nThis is the quantum order finding part. Choose a power of 2, then\n\nQ = 2L such that N2 <= Q <= 2N2\n\nAnd consider f = {0, 1, 2, …, Q-1}\n\nWhere, f(y)=1/(Q)1/2 ∑x=0Q-1I f(x) I wxy and w = exp(2π i/Q), i.e. Qth root of unity.\n\nLet’s perform Shor’s Algorithm using an example: To factor an odd integer N (let N = 17).\n\nChoose an integer Q such that N2 <= Q ≤ 2 N2 ( lets Q = 324).\n\nThen, randomly choose any integer n such that gcd(n, N)=1, (let us choose the integer be n=7).\n\nThen create two quantum registers (these registers should be entangled so that the collapse of the input registered corresponds to the collapse of the output register)\n\nInput Register: must be containing enough qubits to represent numbers as large as Q-1.(i.e., up to 323, so we need 9 qubits).\n\nOutput Register: must be containing enough qubits to represent numbers as large as (N – 1). (i.e., up to 16, so we require 4 qubits).\n\nCode :\n\nC++\n\n#include <iostream>\n\n#include <vector>\n\n#include <cmath>\n\n#include <complex>\n\n#include <qiskit/providers/ibmq/ibmqfactory.hpp>\n\n#include <qiskit/aqua/algorithms/shor/shor.hpp>\n\nusing namespace std;\n\nusing namespace qiskit;\n\nint main() {\n\nstring apiToken = \"ENTER_API_TOKEN_HERE\";\n\nIBMQ::enable_account(apiToken);\n\nauto provider = IBMQ::get_provider(\"ibm-q\");\n\nauto backend = provider.get_backend(\"ibmq_qasm_simulator\");\n\ncout << \"\\n Shors Algorithm\" << endl;\n\ncout << \"--------------------\" << endl;\n\ncout << \"\\nExecuting...\\n\" << endl;\n\nauto factors = shor(35);\n\nauto result_dict = factors.run(QuantumInstance(\n\nbackend, 1, false\n\n));\n\nvector<complex<double>> result = result_dict[\"factors\"];\n\ncout << \"Result: \";\n\nfor (const auto &factor : result) {\n\ncout << factor << \" \";\n\n}\n\ncout << \"\\nPress any key to close\" << endl;\n\ncin.get();\n\nreturn 0;\n\n}\n\nJava\n\nimport java.io.*;\n\nimport com.qiskit.providers.ibmq.IBMQ;\n\nimport com.qiskit.providers.ibmq.runtime.IBMRuntime;\n\nimport com.qiskit.providers.ibmq.runtime.QiskitRuntime;\n\nimport com.qiskit.providers.ibmq.runtime.RunConfig;\n\nimport com.qiskit.providers.ibmq.runtime.RunConfigBuilder;\n\nimport com.qiskit.providers.ibmq.runtime.RunResult;\n\nimport com.qiskit.providers.ibmq.runtime.RunResultData;\n\nclass GFG {\n\npublic static void main (String[] args) {\n\nString apiToken = \"ENTER API TOKEN HERE\";\n\nIBMQ.enableAccount(apiToken);\n\nIBMRuntime ibmRuntime = IBMQ.getRuntime();\n\nString backendName = \"ibmq_qasm_simulator\";\n\nSystem.out.println(\"\\n Shor's Algorithm\");\n\nSystem.out.println(\"--------------------\");\n\nSystem.out.println(\"\\nExecuting...\\n\");\n\nint numberToFactorize = 35;\n\nRunConfig runConfig = new RunConfigBuilder()\n\n.backend(backendName)\n\n.shots(1)\n\n.build();\n\nQiskitRuntime shorRuntime = ibmRuntime.run(\n\nShor.class.getName(),\n\nRunConfig.class.getName(),\n\nrunConfig,\n\nnew int[]{numberToFactorize});\n\nshorRuntime.await();\n\nRunResult runResult = shorRuntime.getResult();\n\nRunResultData resultData = runResult.getData();\n\nObject[] result = (Object[]) resultData.get(\"factors\");\n\nSystem.out.println(result[0]);\n\nSystem.out.println(\"\\nPress any key to close\");\n\n}\n\n}\n\nPython\n\nfrom qiskit import IBMQ\n\nfrom qiskit.aqua import QuantumInstance\n\nfrom qiskit.aqua.algorithms import Shor\n\nIBMQ.enable_account('ENTER API TOKEN HERE')\n\nprovider = IBMQ.get_provider(hub='ibm-q')\n\nbackend = provider.get_backend('ibmq_qasm_simulator')\n\nprint('\\n Shors Algorithm')\n\nprint('--------------------')\n\nprint('\\nExecuting...\\n')\n\nfactors = Shor(35)\n\nresult_dict = factors.run(QuantumInstance(\n\nbackend, shots=1, skip_qobj_validation=False))\n\nresult = result_dict['factors']\n\nprint(result)\n\nprint('\\nPress any key to close')\n\ninput()\n\nC#\n\nusing System;\n\nusing IBM.Quantum.IBMQ;\n\nusing IBM.Quantum.IBMQ.Runtime;\n\nusing IBM.Quantum.IBMQ.Runtime.Jobs;\n\nusing IBM.Quantum.IBMQ.Runtime.Utils;\n\nusing System.Threading.Tasks;\n\nclass GFG\n\n{\n\nstatic async Task Main(string[] args)\n\n{\n\nstring apiToken = \"ENTER API TOKEN HERE\";\n\nIBMQ.IBQAccountToken = apiToken;\n\nIBMRuntime ibmRuntime = IBMQ.GetIBMRuntime();\n\nstring backendName = \"ibmq_qasm_simulator\";\n\nConsole.WriteLine(\"\\n Shor's Algorithm\");\n\nConsole.WriteLine(\"--------------------\");\n\nConsole.WriteLine(\"\\nExecuting...\\n\");\n\nint numberToFactorize = 35;\n\nRunConfig runConfig = new RunConfigBuilder()\n\n.Backend(backendName)\n\n.Shots(1)\n\n.Build();\n\nQiskitRuntime shorRuntime = await ibmRuntime.RunAsync(\n\ntypeof(Shor).FullName,\n\ntypeof(RunConfig).FullName,\n\nrunConfig,\n\nnew object[] { numberToFactorize });\n\nawait shorRuntime.AwaitCompletionAsync();\n\nRunResult runResult = shorRuntime.GetResult();\n\nRunResultData resultData = runResult.GetData();\n\nobject[] result = (object[])resultData.Get(\"factors\");\n\nConsole.WriteLine(result[0]);\n\nConsole.WriteLine(\"\\nPress any key to close\");\n\n}\n\n}\n\nJavascript\n\nconst { IBMQ } = require('ibm-q');\n\nconst { Shor } = require('qiskit.algorithms');\n\nasync function runShorsAlgorithm() {\n\ntry {\n\nconst apiToken = 'ENTER API TOKEN HERE';\n\n// Enable IBM Quantum Experience account\n\nawait IBMQ.enableAccount(apiToken);\n\n// Get the IBM Quantum provider\n\nconst ibmRuntime = IBMQ.getRuntime();\n\n// Specifies the quantum device\n\nconst backendName = 'ibmq_qasm_simulator';\n\n// Print a message\n\nconsole.log('\\n Shor\\'s Algorithm');\n\nconsole.log('--------------------');\n\nconsole.log('\\nExecuting...\\n');\n\nconst numberToFactorize = 35;\n\nconst runConfig = {\n\nbackend: backendName,\n\nshots: 1\n\n};\n\nconst shorRuntime = await ibmRuntime.run(\n\nShor,\n\nrunConfig,\n\n[numberToFactorize]\n\n);\n\nawait shorRuntime.await();\n\nconst runResult = await shorRuntime.getResult();\n\nconst resultData = runResult.getData();\n\nconst factors = resultData.get('factors');\n\n// Print the result\n\nconsole.log(factors[0]);\n\n// Print a message to close\n\nconsole.log('\\nPress any key to close');\n\n} catch (error) {\n\nconsole.error('Error:', error);\n\n}\n\n}\n\n// Run the Shor's algorithm function\n\nrunShorsAlgorithm();\n\nOutput :\n\nShors Algorithm\n\n- - - - - - - - - - - - -\n\nExecuting...\n\n[[5,7]]\n\nPress any key to close\n\nOutput for the code above showing the factors 5 and 7 for N=35.\n\nTime Complexity : O(1)\n\nSpace Complexity : O(1)\n\nPlease Login to comment..."
    }
}