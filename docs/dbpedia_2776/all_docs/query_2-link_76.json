{
    "id": "dbpedia_2776_2",
    "rank": 76,
    "data": {
        "url": "https://valis.readthedocs.io/en/latest/examples.html",
        "read_more_link": "",
        "language": "en",
        "title": "Examples — valis \"1.1.0\" documentation",
        "top_image": "https://github.com/MathOnco/valis/raw/main/docs/_images/challenging_dataset_adincar33.png",
        "meta_img": "",
        "images": [
            "https://github.com/MathOnco/valis/raw/main/docs/_images/valis_logo_black_no_bg.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/challenging_dataset_adincar33.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/ome_tiff_zoom.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/mico_rigid_reg.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/merge_ome_tiff.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/point_warping.png",
            "https://github.com/MathOnco/valis/raw/main/examples/expected_results/roi/ihc_roi.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/annotation_transfer.png",
            "https://github.com/MathOnco/valis/raw/main/docs/_images/pu_color_mplex.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Slide registration\n\nImportant\n\nOne of the most important parameters used to initialize a Valis object is max_processed_image_dim_px, which determines the size of the image used to find the rigid registration parameters. The default value is 850, but if registration fails or is poor, try adjusting that value. Generally speaking, values between 500-2000 work well. In cases where there is little empty space, around the tissue, smaller values may be better. However, if there is a large amount of empty space/slide (as in the images above), larger values may be needed so that the tissue is at a high enough resolution. To imporove alingment of the finer details in the images, larger images can be used in the non-rigid or micro-registration steps (set via the max_non_rigid_registration_dim_px parameter).\n\nImportant\n\nIf the order of slices is known and needs to be preserved, such as building a 3D image, set imgs_ordered=True when initializing the VALIS object. Otherwise, VALIS will sort the images based on similarity, which may or may not correspond on the sliced order. If using this option, ensure that the names of the files allow them to be sorted properly, e.g. 01.tiff, 02.tiff … 10.tiff, etc…\n\nIn this example, the slides that need to be registered are located in /path/to/slides. This process involves creating a Valis object, which is what conducts the registration. In this example no reference image is specified, and so all images will be aligned towards the center of the image stack. In this case, the resulting images will be cropped to the region where all of the images overlap. However, one can specify the reference image when initializing the Valis object, by setting reference_img_f to the filename of the image the others should be aligned towards. When the reference image is specified, the images will be cropped such that only the regions which overlap with the reference image will be saved. While this is the default behavior, one can also specify the cropping method by setting the crop parameter value when initializing the Valis object. The cropping method can also be changed when saving the registered images (see below).\n\nfrom valis import registration slide_src_dir = \"/path/to/slides\" results_dst_dir = \"./slide_registration_example\" registered_slide_dst_dir = \"./slide_registration_example/registered_slides\" # Create a Valis object and use it to register the slides in slide_src_dir registrar = registration.Valis(slide_src_dir, results_dst_dir) rigid_registrar, non_rigid_registrar, error_df = registrar.register()\n\nImportant\n\nIt is also possible to register a subset of images in src_dir, or combinations of images located in different directories. This can be done by passing a list of the image paths to img_list when initializing the Valis object.\n\nThe next example shows how align each image to a reference image, followed up by micro-registration. The reference image the others should be aligned towards is set with the reference_img_f argument when initializing the Valis object. This initial registration is followed up by micro-registration in order to better align features that were not present in the smaller images used for the first registration (The size of the images used for micro-registration can is set with the max_non_rigid_registartion_dim_px argument in Valis.register_micro). Setting align_to_reference to True will align each image directly to the reference image, as opposed to towards it.\n\nfrom valis import registration slide_src_dir = \"/path/to/slides\" results_dst_dir = \"./slide_registration_example\" registered_slide_dst_dir = \"./slide_registration_example/registered_slides\" reference_slide = \"HE.tiff\" # Create a Valis object and use it to register the slides in slide_src_dir, aligning *towards* the reference slide. registrar = registration.Valis(slide_src_dir, results_dst_dir, reference_img_f=reference_slide) rigid_registrar, non_rigid_registrar, error_df = registrar.register() # Perform micro-registration on higher resolution images, aligning *directly to* the reference image registrar.register_micro(max_non_rigid_registration_dim_px=2000, align_to_reference=True)\n\nAfter registration is complete, one can view the results to determine if they are acceptable. In this example, the results are located in ./slide_registration_example. Inside this folder will be 6 subfolders:\n\ndata contains 2 files:\n\na summary spreadsheet of the alignment results, such as the registration error between each pair of slides, their dimensions, physical units, etc…\n\na pickled version of the registrar. This can be reloaded (unpickled) and used later. For example, one could perform the registration locally, but then use the pickled object to warp and save the slides on an HPC. Or, one could perform the registration and use the registrar later to warp points found in the (un-registered) slide.\n\noverlaps contains thumbnails showing the how the images would look if stacked without being registered, how they look after rigid registration, and how they look after non-rigid registration. The rightmost images in the figure above provide examples of these overlap images.\n\nrigid_registration shows thumbnails of how each image looks after performing rigid registration. These would be similar to the bottom row in the figure above.\n\nnon_rigid_registration shows thumbnails of how each image looks after non-rigid registration. These would be similar to the bottom row in the figure above.\n\ndeformation_fields contains images showing what the non-rigid deformation would do to a triangular mesh. These can be used to get a sense of how the images were altered by non-rigid warping. In these images, the color indicates the direction of the displacement, while brightness indicates it’s magnitude. These would be similar to those in the middle row in the figure above.\n\nprocessed shows thumbnails of the processed images. These are thumbnails of the images that were actually used to perform the registration. The pre-processing and normalization methods should try to make these images look as similar as possible.\n\nmasks show the images with outlines of their rigid registration mask drawn around them. If non-rigid registration is being performed, there will also be an image of the reference image with the non-rigid registration mask drawn around it.\n\nIf the results look good, then one can warp and save all of the slides as ome.tiffs. When saving the images, there are three cropping options:\n\ncrop=\"overlap\" will crop the images to the region where all of the images overlap.\n\ncrop=\"reference\" will crop the images to the region where they overlap with the reference image.\n\ncrop=\"all\" will not perform any cropping. While this keep the all of the image, the dimensions of the registered image can be substantially larger than one that was cropped, as it will need to be large enough accommodate all of the other images.\n\nWhile the cropping setting can also be set when initializing the Valis object, any of the above cropping methods can be used when saving the images.\n\nImportant\n\nBy default, images are saved using lossless LZW compression. While this maintains the image’s original quality, it may also generate files with very large sizes. One can reduce the file size by setting compression to jpeg or jp2k, and/or control how lossy the compression is by setting Q to a value less than 100. Do note that currently jpeg or jp2k can only write uint8 images, and so may not be suitable for immunofluorescence (or similar) images that have a different datatype.\n\n# Save all registered slides as ome.tiff registrar.warp_and_save_slides(registered_slide_dst_dir, crop=\"overlap\") # Kill the JVM registration.kill_jvm()\n\nThe ome.tiff images can subsequently be used for downstream analysis, such as QuPath\n\nOne can also choose to save individual slides. This is accomplished by accessing the Slide object associated with a particular file, slide_f and then “telling” it to save the slide as out_f.ome.tiff.\n\nslide_obj = registrar.get_slide(slide_f) slide_obj.warp_and_save_slide(\"out_f.ome.tiff\")\n\nFinally, if the non-rigid registration is deemed to have distorted the image too much, one can apply only the rigid transformation by setting non_rigid=False in slide_obj.warp_and_save_slide or registrar.warp_and_save_slides.\n\nWarping points\n\nOnce the registration parameters have been found, VALIS can be used to warp point data, such as cell coordinates, mask polygon vertices, etc… In this example, slides will be registered, and the registration parameters will then be used warp cell positions located in a separate .csv. This accomplished by accessing the Slide object associated with each registered slide. This is done by passing the slide’s filename (with or without the extension) to registrar.get_slide. This Slide object can the be used to warp the individual slide and/or points associated with the un-registered slide. This can be useful in cases where one has already performed an analysis on the un-registered slides, as one can just warp the point data, as opposed to warping each slide and re-conducting the analysis.\n\nImportant\n\nIt is essential that the image from which the coordinates are derived has the same aspect ratio as the image used for registration. That is, the images used for registration must be scaled up/down versions of the image from which the coordinates are taken. For example, registration may be performed on lower resolution images (an upper image pyramid level), and applied to cell coordinates found by performing cell segmentation on the full resolution (pyramid level 0) image. The default is to assume that the points came from the highest resolution image, but this can be changed by setting pt_level to either the pyramid level of the image the points originated, or its dimensions (width, height, in pixels). Also, the coordinates need to be in pixel units, not physical units. Finally, be sure that the coordinates are X,Y (column, row), with the origin being the top left corner of the image.\n\nIn this first example, cell segmentation and phenotyping has already been performed on the unregistered images. We can now use the Valis object that performed the registration to warp the cell positions to their location in the registered images.\n\nimport os import numpy as np import pandas as pd import pathlib import pickle from valis import registration slide_src_dir = \"path/to/slides\" point_data_dir = \"path/to/cell_positions\" results_dst_dir = \"./point_warping_example\" # Load a Valis object that has already registered the images. registrar_f = \"path/to/results/data/registrar.pickle\" registrar = registration.load_registrar(registrar_f) # Get .csv files containing cell coordinates point_data_list = list(pathlib.Path(point_data_dir).rglob(\"*.csv\")) # Go through each file and warp the cell positions for f in point_data_list: # Get Slide object associated with the slide from which the point data originated # Point data and image have similar file names fname = os.path.split(f)[1] corresponding_img = fname.split(\".tif\")[0] slide_obj = registrar.get_slide(corresponding_img) # Read data and calculate cell centroids (x, y) points_df = pd.read_csv(f) x = np.mean(points_df[[\"XMin\", \"XMax\"]], axis=1).values y = np.mean(points_df[[\"YMin\", \"YMax\"]], axis=1).values xy = np.dstack([x, y])[0] # Use Slide to warp the coordinates warped_xy = slide_obj.warp_xy(xy) # Update dataframe with registered cell centroids points_df[[\"registered_x\", \"registered_y\"]] = warped_xy # Save updated dataframe pt_f_out = os.path.split(f)[1].replace(\".csv\", \"_registered.csv\") full_pt_f_out = os.path.join(results_dst_dir, pt_f_out) points_df.to_csv(full_pt_f_out, index=False) registration.kill_jvm() # Kill the JVM\n\nHere is a comparison of before and after applying registration to cell positions found in the original un-aligned images:\n\nIn this second example, a region of interest (ROI) was marked in one of the unregistered images, in this case “ihc_2.ome.tiff” . Using the Slide object associated with “ihc_2.ome.tiff”, we can warp those ROI coordinates to their position in the registered images, and then use those to slice the registered ROI from each slide. Because VALIS uses pyvips to read and warp the slides, this process does not require the whole image to be loaded into memory and warped. As such, this is fast and does not require much memory. It’s also worth noting that because the points are being warped to the registered coordinate system, the slide that is the source of the ROI coordinates does not have to be the same slide that was treated as the reference image during registration.\n\nimport os import pickle import numpy as np import matplotlib.pyplot as plt import pathlib from valis import registration, warp_tools # Load a registrar that has already registered the images. registrar_f = \"./expected_results/registration/ihc/data/ihc_registrar.pickle\" registrar = registration.load_registrar(registrar_f) # Set the pyramid level from which the ROI coordinates originated. Usually 0 when working with slides. COORD_LEVEL = 0 # ROI coordinates, in microns. These came from the unregistered slide, \"ihc_2.ome.tiff\" bbox_xywh_um = [14314, 13601, 3000, 3000] bbox_xy_um = warp_tools.bbox2xy(bbox_xywh_um) # Get slide from which the ROI coordinates originated pt_source_img_f = \"ihc_2.ome.tiff\" pt_source_slide = registrar.get_slide(pt_source_img_f) # Convert coordinates to pixel units um_per_px = pt_source_slide.reader.scale_physical_size(COORD_LEVEL)[0:2] bbox_xy_px = bbox_xy_um/np.array(um_per_px) # Warp coordinates to position in registered slides bbox_xy_in_registered_img = pt_source_slide.warp_xy(bbox_xy_px, slide_level=COORD_LEVEL, pt_level=COORD_LEVEL) bbox_xywh_in_registered_img = warp_tools.xy2bbox(bbox_xy_in_registered_img) bbox_xywh_in_registered_img = np.round(bbox_xywh_in_registered_img).astype(int) # Create directory where images will be saved dst_dir = \"./expected_results/roi\" pathlib.Path(dst_dir).mkdir(exist_ok=True, parents=True) # Warp each slide and slice the ROI from it using each pyips.Image's \"extract_area\" method. fig, axes = plt.subplots(2, 3, figsize=(12, 8), sharex=True, sharey=True) ax = axes.ravel() for i, slide in enumerate(registrar.slide_dict.values()): warped_slide = slide.warp_slide(level=COORD_LEVEL) roi_vips = warped_slide.extract_area(*bbox_xywh_in_registered_img) roi_img = warp_tools.vips2numpy(roi_vips) ax[i].imshow(roi_img) ax[i].set_title(slide.name) ax[i].set_axis_off() fig.delaxes(ax[5]) # Only 5 images, so remove 6th subplot out_f = os.path.join(dst_dir, f\"{registrar.name}_roi.png\") plt.tight_layout() plt.savefig(out_f) plt.close() # Opening the slide initialized the JVM, so it needs to be killed registration.kill_jvm()\n\nThe extracted and registered ROI are shown below:"
    }
}