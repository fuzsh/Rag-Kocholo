{
    "id": "dbpedia_4769_2",
    "rank": 41,
    "data": {
        "url": "https://en.wikipedia.org/wiki/ALGOL_68",
        "read_more_link": "",
        "language": "en",
        "title": "Wikipedia",
        "top_image": "https://upload.wikimedia.org/wikipedia/en/3/35/Algol68RevisedReportCover.jpg",
        "meta_img": "https://upload.wikimedia.org/wikipedia/en/3/35/Algol68RevisedReportCover.jpg",
        "images": [
            "https://en.wikipedia.org/static/images/icons/wikipedia.png",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-wordmark-en.svg",
            "https://en.wikipedia.org/static/images/mobile/copyright/wikipedia-tagline-en.svg",
            "https://upload.wikimedia.org/wikipedia/en/thumb/3/35/Algol68RevisedReportCover.jpg/121px-Algol68RevisedReportCover.jpg",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/9/9f/APL-keybd2.svg/600px-APL-keybd2.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Flag_of_the_Netherlands.svg/23px-Flag_of_the_Netherlands.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Flag_of_the_Netherlands.svg/23px-Flag_of_the_Netherlands.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/a4/Flag_of_the_United_States.svg/23px-Flag_of_the_United_States.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Flag_of_the_Soviet_Union.svg/23px-Flag_of_the_Soviet_Union.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/1/12/Flag_of_Poland.svg/23px-Flag_of_Poland.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/a4/Flag_of_the_United_States.svg/23px-Flag_of_the_United_States.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/b/ba/Flag_of_Germany.svg/23px-Flag_of_Germany.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/d/d9/Flag_of_Canada_%28Pantone%29.svg/23px-Flag_of_Canada_%28Pantone%29.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Flag_of_the_Netherlands.svg/23px-Flag_of_the_Netherlands.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Flag_of_the_Soviet_Union.svg/23px-Flag_of_the_Soviet_Union.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/a/a9/Flag_of_the_Soviet_Union.svg/23px-Flag_of_the_Soviet_Union.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/a/ae/Flag_of_the_United_Kingdom.svg/23px-Flag_of_the_United_Kingdom.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Flag_of_the_Netherlands.svg/23px-Flag_of_the_Netherlands.svg.png",
            "https://upload.wikimedia.org/wikipedia/commons/thumb/2/20/Flag_of_the_Netherlands.svg/23px-Flag_of_the_Netherlands.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/9/96/Symbol_category_class.svg/16px-Symbol_category_class.svg.png",
            "https://upload.wikimedia.org/wikipedia/en/thumb/8/8a/OOjs_UI_icon_edit-ltr-progressive.svg/10px-OOjs_UI_icon_edit-ltr-progressive.svg.png",
            "https://login.wikimedia.org/wiki/Special:CentralAutoLogin/start?type=1x1",
            "https://en.wikipedia.org/static/images/footer/wikimedia-button.svg",
            "https://en.wikipedia.org/static/images/footer/poweredby_mediawiki.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Contributors to Wikimedia projects"
        ],
        "publish_date": "2004-05-31T02:11:50+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "/static/apple-touch/wikipedia.png",
        "meta_site_name": "",
        "canonical_link": "https://en.wikipedia.org/wiki/ALGOL_68",
        "text": "Programming language\n\nALGOL 68ParadigmsMulti-paradigm: concurrent, imperativeFamilyALGOLDesigned byA. van Wijngaarden, B. J. Mailloux, J. E. L. Peck and C. H. A. Koster, et al.First appearedFinal Report: 1968; 56 years ago ( )r0Stable release\n\nAlgol 68/RR / Revised Report: 1973; 51 years ago ( )r1\n\nTyping disciplinestatic, strong, safe, structuralScopeLexicalMajor implementationsALGOL 68C, Algol 68 Genie (recent), ALGOL 68-R, ALGOL 68RS, ALGOL 68S, FLACC, Алгол 68 Ленинград/Leningrad Unit, Odra ALGOL 68DialectsALGOL 68/FR (Final Reportr0)Influenced byALGOL 60, ALGOL YInfluencedC,[3][5] C++,[6] Bourne shell, KornShell, Bash, Steelman, Ada, Python,[7] Seed7, Mary, S3\n\nALGOL 68 (short for Algorithmic Language 1968) is an imperative programming language that was conceived as a successor to the ALGOL 60 programming language, designed with the goal of a much wider scope of application and more rigorously defined syntax and semantics.\n\nThe complexity of the language's definition, which runs to several hundred pages filled with non-standard terminology, made compiler implementation difficult and it was said it had \"no implementations and no users\". This was only partly true; ALGOL 68 did find use in several niche markets, notably in the United Kingdom where it was popular on International Computers Limited (ICL) machines, and in teaching roles. Outside these fields, use was relatively limited.\n\nNevertheless, the contributions of ALGOL 68 to the field of computer science have been deep, wide-ranging and enduring, although many of these contributions were only publicly identified when they had reappeared in subsequently developed programming languages. Many languages were developed specifically as a response to the perceived complexity of the language, the most notable being Pascal, or were reimplementations for specific roles, like Ada.\n\nMany languages of the 1970s trace their design specifically to ALGOL 68, selecting some features while abandoning others that were considered too complex or out-of-scope for given roles. Among these is the language C, which was directly influenced by ALGOL 68, especially by its strong typing and structures. Most modern languages trace at least some of their syntax to either C or Pascal, and thus directly or indirectly to ALGOL 68.\n\nALGOL 68 features include expression-based syntax, user-declared types and structures/tagged-unions, a reference model of variables and reference parameters, string, array and matrix slicing, and concurrency.\n\nALGOL 68 was designed by the International Federation for Information Processing (IFIP) IFIP Working Group 2.1 on Algorithmic Languages and Calculi. On December 20, 1968, the language was formally adopted by the group, and then approved for publication by the General Assembly of IFIP.\n\nALGOL 68 was defined using a formalism, a two-level formal grammar, invented by Adriaan van Wijngaarden. Van Wijngaarden grammars use a context-free grammar to generate an infinite set of productions that will recognize a particular ALGOL 68 program; notably, they are able to express the kind of requirements that in many other programming language technical standards are labelled semantics, and must be expressed in ambiguity-prone natural language prose, and then implemented in compilers as ad hoc code attached to the formal language parser.\n\nThe main aims and principles of design of ALGOL 68:\n\nCompleteness and clarity of description[9]\n\nOrthogonality of design[10]\n\nSecurity[11]\n\nEfficiency:[12]\n\nStatic mode checking\n\nMode-independent parsing\n\nIndependent compiling\n\nLoop optimizing\n\nRepresentations – in minimal & larger character sets\n\nALGOL 68 has been criticized, most prominently by some members of its design committee such as C. A. R. Hoare and Edsger Dijkstra, for abandoning the simplicity of ALGOL 60, becoming a vehicle for complex or overly general ideas, and doing little to make the compiler writer's task easier, in contrast to deliberately simple contemporaries (and competitors) such as C, S-algol and Pascal.\n\nIn 1970, ALGOL 68-R became the first working compiler for ALGOL 68.\n\nIn the 1973 revision, certain features — such as proceduring, gommas[13] and formal bounds — were omitted.[14] C.f. The language of the unrevised report.r0\n\nThough European defence agencies (in Britain Royal Signals and Radar Establishment (RSRE)) promoted the use of ALGOL 68 for its expected security advantages, the American side of the NATO alliance decided to develop a different project, the language Ada, making its use obligatory for US defense contracts.\n\nALGOL 68 also had a notable influence in the Soviet Union, details of which can be found in Andrey Terekhov's 2014 paper: \"ALGOL 68 and Its Impact on the USSR and Russian Programming\",[15] and \"Алгол 68 и его влияние на программирование в СССР и России\".[16]\n\nSteve Bourne, who was on the ALGOL 68 revision committee, took some of its ideas to his Bourne shell (and thereby, to descendant Unix shells such as Bash) and to C (and thereby to descendants such as C++).\n\nThe complete history of the project can be found in C. H. Lindsey's A History of ALGOL 68.[18]\n\nFor a full-length treatment of the language, see \"Programming ALGOL 68 Made Easy\"[19] by Dr. Sian Mountbatten, or \"Learning ALGOL 68 Genie\"[20] by Marcel van der Veer which includes the Revised Report.\n\nALGOL 68, as the name implies, is a follow-on to the ALGOL language that was first formalized in 1960. That same year the International Federation for Information Processing (IFIP) formed and started the Working Group on ALGOL, or WG2.1. This group released an updated ALGOL 60 specification in Rome in April 1962. At a follow-up meeting in March 1964, it was agreed that the group should begin work on two follow-on standards, ALGOL X which would be a redefinition of the language with some additions, and an ALGOL Y, which would have the ability to modify its own programs in the style of the language LISP.\n\nThe first meeting of the ALGOL X group was held in Princeton University in May 1965. A report of the meeting noted two broadly supported themes, the introduction of strong typing and interest in Euler's concepts of 'trees' or 'lists' for handling collections.\n\nAt the second meeting in October in France, three formal proposals were presented, Niklaus Wirth's ALGOL W along with comments about record structures by C.A.R. (Tony) Hoare, a similar language by Gerhard Seegmüller, and a paper by Adriaan van Wijngaarden on \"Orthogonal design and description of a formal language\". The latter, written in almost indecipherable \"W-Grammar\", proved to be a decisive shift in the evolution of the language. The meeting closed with an agreement that van Wijngaarden would re-write the Wirth/Hoare submission using his W-Grammar.\n\nThis seemingly simple task ultimately proved more difficult than expected, and the follow-up meeting had to be delayed six months. When it met in April 1966 in Kootwijk, van Wijngaarden's draft remained incomplete and Wirth and Hoare presented a version using more traditional descriptions. It was generally agreed that their paper was \"the right language in the wrong formalism\". As these approaches were explored, it became clear there was a difference in the way parameters were described that would have real-world effects, and while Wirth and Hoare protested that further delays might become endless, the committee decided to wait for van Wijngaarden's version. Wirth then implemented their current definition as ALGOL W.\n\nAt the next meeting in Warsaw in October 1966,[25] there was an initial report from the I/O Subcommittee who had met at the Oak Ridge National Laboratory and the University of Illinois but had not yet made much progress. The two proposals from the previous meeting were again explored, and this time a new debate emerged about the use of pointers; ALGOL W used them only to refer to records, while van Wijngaarden's version could point to any object. To add confusion, John McCarthy presented a new proposal for operator overloading and the ability to string together and or constructs, and Klaus Samelson wanted to allow anonymous functions. In the resulting confusion, there was some discussion of abandoning the entire effort. The confusion continued through what was supposed to be the ALGOL Y meeting in Zandvoort in May 1967.\n\nA draft report was finally published in February 1968. This was met by \"shock, horror and dissent\", mostly due to the hundreds of pages of unreadable grammar and odd terminology. Charles H. Lindsey attempted to figure out what \"language was hidden inside of it\", a process that took six man-weeks of effort. The resulting paper, \"ALGOL 68 with fewer tears\",[27] was widely circulated. At a wider information processing meeting in Zürich in May 1968, attendees complained that the language was being forced upon them and that IFIP was \"the true villain of this unreasonable situation\" as the meetings were mostly closed and there was no formal feedback mechanism. Wirth and Peter Naur formally resigned their authorship positions in WG2.1 at that time.\n\nThe next WG2.1 meeting took place in Tirrenia in June 1968. It was supposed to discuss the release of compilers and other issues, but instead devolved into a discussion on the language. van Wijngaarden responded by saying (or threatening) that he would release only one more version of the report. By this point Naur, Hoare, and Wirth had left the effort, and several more were threatening to do so. Several more meetings followed, North Berwick in August 1968, Munich in December which produced the release of the official Report in January 1969 but also resulted in a contentious Minority Report being written. Finally, at Banff, Alberta in September 1969, the project was generally considered complete and the discussion was primarily on errata and a greatly expanded Introduction to the Report.\n\nThe effort took five years, burned out many of the greatest names in computer science, and on several occasions became deadlocked over issues both in the definition and the group as a whole. Hoare released a \"Critique of ALGOL 68\" almost immediately,[30] which has been widely referenced in many works. Wirth went on to further develop the ALGOL W concept and released this as Pascal in 1970.\n\nThe first implementation of the standard, based on the late-1968 draft Report, was introduced by the Royal Radar Establishment in the UK as ALGOL 68-R in July 1970. This was, however, a subset of the full language, and Barry Mailloux, the final editor of the Report, joked that \"It is a question of morality. We have a Bible and you are sinning!\"[31] This version nevertheless became very popular on the ICL machines, and became a widely-used language in military coding, especially in the UK.[32]\n\nAmong the changes in 68-R was the requirement for all variables to be declared before their first use. This had a significant advantage that it allowed the compiler to be one-pass, as space for the variables in the activation record was set aside before it was used. However, this change also had the side-effect of demanding the PROCs be declared twice, once as a declaration of the types, and then again as the body of code. Another change was to eliminate the assumed VOID mode, an expression that returns no value (named a statement in other languages) and demanding the word VOID be added where it would have been assumed. Further, 68-R eliminated the explicit parallel processing commands based on PAR.[31]\n\nThe first full implementation of the language was introduced in 1974 by CDC Netherlands for the Control Data mainframe series. This saw limited use, mostly teaching in Germany and the Netherlands.[32]\n\nA version similar to 68-R was introduced from Carnegie Mellon University in 1976 as 68S, and was again a one-pass compiler based on various simplifications of the original and intended for use on smaller machines like the DEC PDP-11. It too was used mostly for teaching purposes.[32]\n\nA version for IBM mainframes did not become available until 1978, when one was released from Cambridge University. This was \"nearly complete\". Lindsey released a version for small machines including the IBM PC in 1984.[32]\n\nThree open source Algol 68 implementations are known:[33]\n\na68g, GPLv3, written by Marcel van der Veer.\n\nalgol68toc, an open-source software port of ALGOL 68RS.\n\nexperimental Algol68 frontend for GCC, written by Jose E. Marchesi.[34]\n\nYear Event Contributor March 1959 ALGOL Bulletin Issue 1 (First) Peter Naur / ACM February 1968 Draft Report(DR) Published[35] IFIP Working Group 2.1 March 1968 Algol 68 Final Reportr0 Presented at Munich Meeting IFIP Working Group 2.1 June 1968 Meeting in Tirrenia, Italy IFIP Working Group 2.1 Aug 1968 Meeting in North Berwick, Scotland IFIP Working Group 2.1 December 1968 ALGOL 68 Final Reportr0 Presented at Munich Meeting IFIP Working Group 2.1 April 1970 ALGOL 68-R under GEORGE 3 on an ICL 1907F Royal Signals and Radar Est. July 1970 ALGOL 68 for the Dartmouth Time Sharing System[36][37] Sidney Marshall September 1973 Algol 68 Revised Report[38]r1 Published IFIP Working Group 2.1 1975 ALGOL 68C(C) – transportable compiler (zcode VM) S. Bourne, Andrew Birrell, and Michael Guy June 1975 G. E. Hedrick and Alan Robertson. The Oklahoma State ALGOL 68 Subset Compiler. 1975 International Conference on ALGOL 68. June 1977 Strathclyde ALGOL 68 conference, Scotland ACM May 1978 Proposals for ALGOL H – A Superlanguage of ALGOL 68[39] A. P. Black, V. J. Rayward-Smith 1984 Full ALGOL 68S(S) compiler for Sun, SPARC, and PCs C. H. Lindsey et al, Manchester August 1988 ALGOL Bulletin Issue 52 (last) Ed. C. H. Lindsey / ACM May 1997 Algol68 S(S) published on the internet[40] Charles H. Lindsey November 2001 Algol 68 Genie(G) published on the internet[41] (GNU GPL open source licensing) Marcel van der Veer\n\n\"A Shorter History of Algol 68\"\n\nALGOL 68 – 3rd generation ALGOL\n\nMarch 1968: Draft Report on the Algorithmic Language ALGOL 68[42] – Edited by: Adriaan van Wijngaarden, Barry J. Mailloux, John Peck and Cornelis H. A. Koster.\n\n\"Van Wijngaarden once characterized the four authors, somewhat tongue-in-cheek, as: Koster: transputter, Peck: syntaxer, Mailloux: implementer, Van Wijngaarden: party ideologist.\" – Koster.\n\nOctober 1968: Penultimate Draft Report on the Algorithmic Language ALGOL 68 — Chapters 1-9[43] Chapters 10-12[44] — Edited by: A. van Wijngaarden, B.J. Mailloux, J. E. L. Peck and C. H. A. Koster.\n\nDecember 1968: Report on the Algorithmic Language ALGOL 68 — Offprint from Numerische Mathematik, 14, 79-218 (1969); Springer-Verlag.[45] — Edited by: A. van Wijngaarden, B. J. Mailloux, J. E. L. Peck and C. H. A. Koster.\n\nMarch 1970: Minority report, ALGOL Bulletin AB31.1.1 — signed by Edsger Dijkstra, Fraser Duncan, Jan Garwick, Tony Hoare, Brian Randell, Gerhard Seegmüller, Wlad Turski, and Mike Woodger.\n\nSeptember 1973: Revised Report on the Algorithmic Language Algol 68 — Springer-Verlag 1976[46] — Edited by: A. van Wijngaarden, B. Mailloux, J. Peck, K. Koster, Michel Sintzoff, Charles H. Lindsey, Lambert Meertens and Richard G. Fisker.\n\nother WG 2.1 members active in ALGOL 68 design:[18] Friedrich L. Bauer • Hans Bekic • Gerhard Goos • Peter Zilahy Ingerman • Peter Landin • John McCarthy • Jack Merner • Peter Naur • Manfred Paul • Willem van der Poel • Doug Ross • Klaus Samelson • Niklaus Wirth • Nobuo Yoneda.\n\n1968: On 20 December 1968, the \"Final Report\" (MR 101) was adopted by the Working Group, then subsequently approved by the General Assembly of UNESCO's IFIP for publication. Translations of the standard were made for Russian, German, French and Bulgarian, and then later Japanese and Chinese.[47] The standard was also made available in Braille.\n\n1984: TC 97 considered ALGOL 68 for standardisation as \"New Work Item\" TC97/N1642 [2][3]. West Germany, Belgium, Netherlands, USSR and Czechoslovakia willing to participate in preparing the standard but the USSR and Czechoslovakia \"were not the right kinds of member of the right ISO committees\"[4] and Algol 68's ISO standardisation stalled.[5]\n\n1988: Subsequently ALGOL 68 became one of the GOST standards in Russia.\n\nGOST 27974-88 Programming language ALGOL 68 — Язык программирования АЛГОЛ 68[48]\n\nGOST 27975-88 Programming language ALGOL 68 extended — Язык программирования АЛГОЛ 68 расширенный[49]\n\nThe standard language contains about sixty reserved words, typically bolded in print, and some with \"brief symbol\" equivalents:\n\nMODE, OP, PRIO, PROC, FLEX, HEAP, LOC, LONG, REF, SHORT, BITS, BOOL, BYTES, CHAR, COMPL, INT, REAL, SEMA, STRING, VOID, CHANNEL, FILE, FORMAT, STRUCT, UNION, AT \"@\", EITHERr0, IS \":=:\", ISNT IS NOTr0 \":/=:\" \":≠:\", OF \"→\"r0, TRUE, FALSE, EMPTY, NIL \"○\", SKIP \"~\", CO \"¢\", COMMENT \"¢\", PR, PRAGMAT, CASE ~ IN ~ OUSE ~ IN ~ OUT ~ ESAC \"( ~ | ~ |: ~ | ~ | ~ )\", FOR ~ FROM ~ TO ~ BY ~ WHILE ~ DO ~ OD, IF ~ THEN ~ ELIF ~ THEN ~ ELSE ~ FI \"( ~ | ~ |: ~ | ~ | ~ )\", PAR BEGIN ~ END \"( ~ )\", GO TO, GOTO, EXIT \"□\"r0.\n\nThe basic language construct is the unit. A unit may be a formula, an enclosed clause, a routine text or one of several technically needed constructs (assignation, jump, skip, nihil). The technical term enclosed clause unifies some of the inherently bracketing constructs known as block, do statement, switch statement in other contemporary languages. When keywords are used, generally the reversed character sequence of the introducing keyword is used for terminating the enclosure, e.g. ( IF ~ THEN ~ ELSE ~ FI, CASE ~ IN ~ OUT ~ ESAC, FOR ~ WHILE ~ DO ~ OD ). This Guarded Command syntax was reused by Stephen Bourne in the common Unix Bourne shell. An expression may also yield a multiple value, which is constructed from other values by a collateral clause. This construct just looks like the parameter pack of a procedure call.\n\nThe basic data types (called modes in Algol 68 parlance) are real, int, compl (complex number), bool, char, bits and bytes. For example:\n\nINT n = 2; CO n is fixed as a constant of 2. CO INT m := 3; CO m is a newly created local variable whose value is initially set to 3. CO CO This is short for ref int m = loc int := 3; CO REAL avogadro = 6.0221415⏨23; CO Avogadro number CO long long real long long pi = 3.14159 26535 89793 23846 26433 83279 50288 41971 69399 37510; COMPL square root of minus one = 0 ⊥ 1;\n\nHowever, the declaration REAL x; is just syntactic sugar for REF REAL x = LOC REAL;. That is, x is really the constant identifier for a reference to a newly generated local REAL variable.\n\nFurthermore, instead of defining both float and double, or int and long and short, etc., ALGOL 68 provides modifiers, so that the presently common double would be written as LONG REAL or LONG LONG REAL instead, for example. The prelude constants max real and min long int are provided to adapt programs to different implementations.\n\nAll variables need to be declared, but declaration does not have to precede the first use.\n\nprimitive-declarer: INT, REAL, COMPL, COMPLEXG, BOOL, CHAR, STRING, BITS, BYTES, FORMAT, FILE, PIPEG, CHANNEL, SEMA\n\nBITS – a \"packed vector\" of BOOL.\n\nBYTES – a \"packed vector\" of CHAR.\n\nSTRING – a FLEXible array of CHAR.\n\nSEMA – a SEMAphore which can be initialised with the OPerator LEVEL.\n\nComplex types can be created from simpler ones using various type constructors:\n\nREF mode – a reference to a value of type mode, similar to & in C/C++ and REF in Pascal\n\nSTRUCT – used to build structures, like STRUCT in C/C++ and RECORD in Pascal\n\nUNION – used to build unions, like in C/C++ and Pascal\n\nPROC – used to specify procedures, like functions in C/C++ and procedures/functions in Pascal\n\nFor some examples, see Comparison of ALGOL 68 and C++.\n\nOther declaration symbols include: FLEX, HEAP, LOC, REF, LONG, SHORT, EVENTS\n\nFLEX – declare the array to be flexible, i.e. it can grow in length on demand.\n\nHEAP – allocate variable some free space from the global heap.\n\nLOC – allocate variable some free space of the local stack.\n\nLONG – declare an INT, REAL or COMPL to be of a LONGer size.\n\nSHORT – declare an INT, REAL or COMPL to be of a SHORTer size.\n\nA name for a mode (type) can be declared using a MODE declaration, which is similar to TYPEDEF in C/C++ and TYPE in Pascal:\n\nINT max=99; MODE newmode = [0:9][0:max]STRUCT ( LONG REAL a, b, c, SHORT INT i, j, k, REF REAL r );\n\nThis is similar to the following C code:\n\nconstintmax=99; typedefstruct{ doublea,b,c;shorti,j,k;float*r; }newmode[9+1][max+1];\n\nFor ALGOL 68, only the NEWMODE mode-indication appears to the left of the equals symbol, and most notably the construction is made, and can be read, from left to right without regard to priorities. Also, the lower bound of Algol 68 arrays is one by default, but can be any integer from -max int to max int.\n\nMode declarations allow types to be recursive: defined directly or indirectly in terms of themselves. This is subject to some restrictions – for instance, these declarations are illegal:\n\nMODE A = REF A MODE A = STRUCT (A a, B b) MODE A = PROC (A a) A\n\nwhile these are valid:\n\nMODE A = STRUCT (REF A a, B b) MODE A = PROC (REF A a) REF A\n\nThe coercions produce a coercee from a coercend according to three criteria: the a priori mode of the coercend before the application of any coercion, the a posteriori mode of the coercee required after those coercions, and the syntactic position or \"sort\" of the coercee. Coercions may be cascaded.\n\nThe six possible coercions are termed deproceduring, dereferencing, uniting, widening, rowing, and voiding. Each coercion, except for uniting, prescribes a corresponding dynamic effect on the associated values. Hence, many primitive actions can be programmed implicitly by coercions.\n\nContext strength – allowed coercions:\n\nsoft – deproceduring\n\nweak – dereferencing or deproceduring, yielding a name\n\nmeek – dereferencing or deproceduring\n\nfirm – meek, followed by uniting\n\nstrong – firm, followed by widening, rowing or voiding\n\nALGOL 68 has a hierarchy of contexts which determine the kind of coercions available at a particular point in the program. These contexts are:\n\nContext\n\nContext location Coercions available Coercion examples in the context\n\nSoft\n\nWeak\n\nMeek\n\nFirm\n\nStrong\n\nStrong\n\nRight hand side of:\n\nIdentity-declarations, as \"~\" in: REAL x = ~\n\nInitialisations, as \"~\" in: REAL x := ~\n\nAlso:\n\nActual-parameters of calls, as \"~\" in:PROC: sin(~)\n\nEnclosed clauses of casts, as \"~\" in: REAL(~)\n\nUnits of routine-texts\n\nStatements yielding VOID\n\nAll parts (but one) of a balanced clause\n\nOne side of an identity relation, as \"~\" in: ~ IS ~\n\ndeproc​edur​ing\n\nAll SOFT then weak derefer​encing (deref​erencing or deproc​eduring, yield​ing a name)\n\nAll WEAK then derefer​enc​ing (deref​erenc​ing or deproc​edur​ing)\n\nAll MEEK then unit​ing\n\nAll FIRM then widen​ing, rowing or voiding\n\nWidening occurs if there is no loss of precision. For example: An INT will be coerced to a REAL, and a REAL will be coerced to a LONG REAL. But not vice versa. Examples:\n\nINT to LONG INT\n\nINT to REAL\n\nREAL to COMPL\n\nBITS to []BOOL\n\nBYTES to STRING\n\nA variable can also be coerced (rowed) to an array of length 1.\n\nFor example:\n\nINT to [1]INT\n\nREAL to [1]REAL etc.\n\nFirm\n\nOperands of formulas as \"~\" in:OP: ~ * ~\n\nParameters of transput calls\n\nExample:\n\nUNION(INT,REAL) var := 1\n\nMeek\n\nTrimscripts (yielding INT)\n\nEnquiries: e.g. as \"~\" in the following\n\nIF ~ THEN ... FI and FROM ~ BY ~ TO ~ WHILE ~ DO ... OD etc\n\nPrimaries of calls (e.g. sin in sin(x))\n\nExamples:\n\nREF REF BOOL to BOOL\n\nREF REF REF INT to INT\n\nWeak\n\nPrimaries of slices, as in \"~\" in: ~[1:99]\n\nSecondaries of selections, as \"~\" in: value OF ~\n\nExamples:\n\nREF BOOL to REF BOOL\n\nREF REF INT to REF INT\n\nREF REF REF REAL to REF REAL\n\nREF REF REF REF STRUCT to REF STRUCT\n\nSoft\n\nThe LHS of assignments, as \"~\" in: ~ := ... Example:\n\ndeproceduring of: PROC REAL random: e.g. random\n\nFor more details about Primaries, Secondaries, Tertiary & Quaternaries refer to Operator precedence.\n\nPragmats are directives in the program, typically hints to the compiler; in newer languages these are called \"pragmas\" (no 't'). e.g.\n\nPRAGMAT heap=32 PRAGMAT PR heap=32 PR\n\nComments can be inserted in a variety of ways:\n\n¢ The original way of adding your 2 cents worth to a program ¢ COMMENT \"bold\" comment COMMENT CO Style i comment CO # Style ii comment # £ This is a hash/pound comment for a UK keyboard £\n\nNormally, comments cannot be nested in ALGOL 68. This restriction can be circumvented by using different comment delimiters (e.g. use hash only for temporary code deletions).\n\nALGOL 68 being an expression-oriented programming language, the value returned by an assignment statement is a reference to the destination. Thus, the following is valid ALGOL 68 code:\n\nREAL half pi, one pi; one pi := 2 * ( half pi := 2 * arc tan(1) )\n\nThis notion is present in C and Perl, among others. Note that as in earlier languages such as Algol 60 and FORTRAN, spaces are allowed in identifiers, so that half pi is a single identifier (thus avoiding the underscores versus camel case versus all lower-case issues).\n\nAs another example, to express the mathematical idea of a sum of f(i) from i=1 to n, the following ALGOL 68 integer expression suffices:\n\n(INT sum := 0; FOR i TO n DO sum +:= f(i) OD; sum)\n\nNote that, being an integer expression, the former block of code can be used in any context where an integer value can be used. A block of code returns the value of the last expression it evaluated; this idea is present in Lisp, among other languages.\n\nCompound statements are all terminated by distinctive closing brackets:\n\nIF choice clauses:\n\nIF condition THEN statements [ ELSE statements ] FI \"brief\" form: ( condition | statements | statements )\n\nIF condition1 THEN statements ELIF condition2 THEN statements [ ELSE statements ] FI \"brief\" form: ( condition1 | statements |: condition2 | statements | statements )\n\nThis scheme not only avoids the dangling else problem but also avoids having to use BEGIN and END in embedded statement sequences.\n\nCASE choice clauses:\n\nCASE switch IN statements, statements,... [ OUT statements ] ESAC \"brief\" form: ( switch | statements,statements,... | statements )\n\nCASE switch1 IN statements, statements,... OUSE switch2 IN statements, statements,... [ OUT statements ] ESAC \"brief\" form of CASE statement: ( switch1 | statements,statements,... |: switch2 | statements,statements,... | statements )\n\nChoice clause example with Brief symbols:\n\nPROC days in month = (INT year, month)INT: (month| 31, (year÷×4=0 ∧ year÷×100≠0 ∨ year÷×400=0 | 29 | 28 ), 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 );\n\nChoice clause example with Bold symbols:\n\nPROC days in month = (INT year, month)INT: CASE month IN 31, IF year MOD 4 EQ 0 AND year MOD 100 NE 0 OR year MOD 400 EQ 0 THEN 29 ELSE 28 FI, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ESAC;\n\nChoice clause example mixing Bold and Brief symbols:\n\nPROC days in month = (INT year, month)INT: CASE month IN ¢Jan¢ 31, ¢Feb¢ ( year MOD 4 = 0 AND year MOD 100 ≠ 0 OR year MOD 400 = 0 | 29 | 28 ), ¢Mar¢ 31, 30, 31, 30, 31, 31, 30, 31, 30, 31 ¢ to Dec. ¢ ESAC;\n\nAlgol68 allowed the switch to be of either type INT or (uniquely) UNION. The latter allows the enforcing strong typing onto UNION variables. c.f. union below for example.\n\ndo loop clause:\n\n[ FOR index ] [ FROM first ] [ BY increment ] [ TO last ] [ WHILE condition ] DO statements OD The minimum form of a \"loop clause\" is thus: DO statements OD\n\nThis was considered the \"universal\" loop, the full syntax is:\n\nFOR i FROM 1 BY -22 TO -333 WHILE i×i≠4444 DO ~ OD\n\nThe construct have several unusual aspects:\n\nonly the DO ~ OD portion was compulsory, in which case the loop will iterate indefinitely.\n\nthus the clause TO 100 DO ~ OD, will iterate only 100 times.\n\nthe WHILE \"syntactic element\" allowed a programmer to break from a FOR loop early. e.g.\n\nINT sum sq:=0; FOR i WHILE print((\"So far:\",i,newline)); sum sq≠70↑2 DO sum sq+:=i↑2 OD\n\nSubsequent \"extensions\" to the standard Algol68 allowed the TO syntactic element to be replaced with UPTO and DOWNTO to achieve a small optimisation. The same compilers also incorporated:\n\nUNTIL(C) – for late loop termination.\n\nFOREACH(S) – for working on arrays in parallel.\n\nFurther examples can be found in the code examples below.\n\nALGOL 68 supports arrays with any number of dimensions, and it allows for the slicing of whole or partial rows or columns.\n\nMODE VECTOR = [1:3] REAL; # vector MODE declaration (typedef) # MODE MATRIX = [1:3,1:3]REAL; # matrix MODE declaration (typedef) # VECTOR v1 := (1,2,3); # array variable initially (1,2,3) # []REAL v2 = (4,5,6); # constant array, type equivalent to VECTOR, bounds are implied # OP + = (VECTOR a,b) VECTOR: # binary OPerator definition # (VECTOR out; FOR i FROM ⌊a TO ⌈a DO out[i] := a[i]+b[i] OD; out); MATRIX m := (v1, v2, v1+v2); print ((m[,2:])); # a slice of the 2nd and 3rd columns #\n\nMatrices can be sliced either way, e.g.:\n\nREF VECTOR row = m[2,]; # define a REF (pointer) to the 2nd row # REF VECTOR col = m[,2]; # define a REF (pointer) to the 2nd column #\n\nALGOL 68 supports multiple field structures (STRUCT) and united modes. Reference variables may point to any MODE including array slices and structure fields.\n\nFor an example of all this, here is the traditional linked list declaration:\n\nMODE NODE = UNION (VOID, REAL, INT, COMPL, STRING), LIST = STRUCT (NODE val, REF LIST next);\n\nUsage example for UNION CASE of NODE:\n\nProcedure (PROC) declarations require type specifications for both the parameters and the result (VOID if none):\n\nPROC max of real = (REAL a, b) REAL: IF a > b THEN a ELSE b FI;\n\nor, using the \"brief\" form of the conditional statement:\n\nPROC max of real = (REAL a, b) REAL: (a>b | a | b);\n\nThe return value of a proc is the value of the last expression evaluated in the procedure. References to procedures (ref proc) are also permitted. Call-by-reference parameters are provided by specifying references (such as ref real) in the formal argument list. The following example defines a procedure that applies a function (specified as a parameter) to each element of an array:\n\nPROC apply = (REF [] REAL a, PROC (REAL) REAL f): FOR i FROM LWB a TO UPB a DO a[i] := f(a[i]) OD\n\nThis simplicity of code was unachievable in ALGOL 68's predecessor ALGOL 60.\n\nThe programmer may define new operators and both those and the pre-defined ones may be overloaded and their priorities may be changed by the coder. The following example defines operator MAX with both dyadic and monadic versions (scanning across the elements of an array).\n\nPRIO MAX = 9; OP MAX = (INT a,b) INT: ( a>b | a | b ); OP MAX = (REAL a,b) REAL: ( a>b | a | b ); OP MAX = (COMPL a,b) COMPL: ( ABS a > ABS b | a | b ); OP MAX = ([]REAL a) REAL: (REAL out := a[LWB a]; FOR i FROM LWB a + 1 TO UPB a DO ( a[i]>out | out:=a[i] ) OD; out)\n\nPRIOrity Operation r0&r1 +Algol68r0 +Algol68G Effectively 12\n\n(Primary) dereferencing, deproceduring(~,~), subscripting[~], rowing[~,], slicing[~:~], size denotations LONG & SHORT proceduring currying(~,,,), DIAG, TRNSP, ROW, COL Effectively 11\n\n(Secondary) OF (selection), LOC & HEAP (generators) → (selection) NEW (generators)\n\nThese are technically not operators, rather they are considered \"units associated with names\"\n\nPRIOrity\n\n(Tertiary) Algol68 \"Worthy characters \"r0&r1 +Algol68r0&r1 +Algol68C,G +Algol68r0 10 NOT ~, UP, DOWN, LWB, UPB,\n\n-, ABS, ARG, BIN, ENTIER, LENG, LEVEL, ODD, REPR, ROUND, SHORTEN\n\n¬, ↑, ↓, ⌊, ⌈ NORM, TRACE, T, DET, INV LWS, UPS, ⎩, ⎧, BTB, CTB\n\nPRIOrity\n\n(Tertiary) Algol68 \"Worthy characters\"r0&r1 +Algol68r0&r1 +Algol68C,G +Algol68r0 9 +*, I +×, ⊥ ! 8 SHL, SHR, **, UP, DOWN, LWB, UPB ↑, ↓, ⌊, ⌈ ××, ^, LWS, UPS, ⎩, ⎧ 7 *, /, %, OVER, %*, MOD, ELEM ×, ÷, ÷×, ÷*, %×, □ ÷: 6 -, + 5 <, LT, <=, LE, >=, GE, >, GT ≤, ≥ 4 EQ =, NE ~= /= ≠, ¬= 3 &, AND ∧ /\\ 2 OR ∨ \\/ 1 MINUSAB, PLUSAB, TIMESAB, DIVAB, OVERAB, MODAB, PLUSTO,\n\n-:=, +:=, *:=, /:=, %:=, %*:=, +=:\n\n×:=, ÷:=, ÷×:=, ÷*:=, %×:= MINUS, PLUS, DIV, OVERB, MODB, ÷::=, PRUS\n\nSpecific details:\n\nTertiaries include names NIL and ○.\n\nLWS: In Algol68r0 the operators LWS and ⎩ ... both return TRUE if the lower state of the dimension of an array is fixed.\n\nThe UPS and ⎧ operators are similar on the upper state.\n\nThe LWB and UPB operators are automatically available on UNIONs of different orders (and MODEs) of arrays. eg. UPB of union([]int, [,]real, flex[,,,]char)\n\nThese are technically not operators, rather they are considered \"units associated with names\"\n\nPRIOrity\n\n(Quaternaries) Algol68 \"Worthy characters\"r0&r1 +Algol68r0&r1 +Algol68C,G,R +Algol68r0 Effectively 0 :=, IS :=:, ISNT :/=: :~=:, AT @, \":\", \";\" :≠: :¬=: :=:=C, =:=R ..=, .=, CT, ::, CTAB, ::=, .., is not, \"..\", \".,\"\n\nNote: Quaternaries include names SKIP and ~.\n\n:=: (alternatively IS) tests if two pointers are equal; :/=: (alternatively ISNT) tests if they are unequal.\n\nConsider trying to compare two pointer values, such as the following variables, declared as pointers-to-integer:\n\nREF INT ip, jp\n\nNow consider how to decide whether these two are pointing to the same location, or whether one of them is pointing to NIL. The following expression\n\nip = jp\n\nwill dereference both pointers down to values of type INT, and compare those, since the = operator is defined for INT, but not REF INT. It is not legal to define = for operands of type REF INT and INT at the same time, because then calls become ambiguous, due to the implicit coercions that can be applied: should the operands be left as REF INT and that version of the operator called? Or should they be dereferenced further to INT and that version used instead? Therefore the following expression can never be made legal:\n\nip = NIL\n\nHence the need for separate constructs not subject to the normal coercion rules for operands to operators. But there is a gotcha. The following expressions:\n\nip :=: jp\n\nip :=: NIL\n\nwhile legal, will probably not do what might be expected. They will always return FALSE, because they are comparing the actual addresses of the variables ip and jp, rather than what they point to. To achieve the right effect, one would have to write\n\nip :=: REF INT(jp)\n\nip :=: REF INT(NIL)\n\nMost of Algol's \"special\" characters (⊂, ≡, ␣, ×, ÷, ≤, ≥, ≠, ¬, ⊃, ≡, ∨, ∧, →, ↓, ↑, ⌊, ⌈, ⎩, ⎧, ⊥, ⏨, ¢, ○ and □) can be found on the IBM 2741 keyboard with the APL \"golf-ball\" print head inserted; these became available in the mid-1960s while ALGOL 68 was being drafted. These characters are also part of the Unicode standard and most of them are available in several popular fonts.\n\nTransput is the term used to refer to ALGOL 68's input and output facilities. It includes pre-defined procedures for unformatted, formatted and binary transput. Files and other transput devices are handled in a consistent and machine-independent manner. The following example prints out some unformatted output to the standard output device:\n\nprint ((newpage, \"Title\", newline, \"Value of i is \", i, \"and x[i] is \", x[i], newline))\n\nNote the predefined procedures newpage and newline passed as arguments.\n\nThe TRANSPUT is considered to be of BOOKS, CHANNELS and FILES:\n\nBooks are made up of pages, lines and characters, and may be backed up by files.\n\nA specific book can be located by name with a call to match.\n\nCHANNELs correspond to physical devices. e.g. card punches and printers.\n\nThree standard channels are distinguished: stand in channel, stand out channel, stand back channel.\n\nA FILE is a means of communicating between a program and a book that has been opened via some channel.\n\nThe MOOD of a file may be read, write, char, bin, and opened.\n\ntransput procedures include: establish, create, open, associate, lock, close, scratch.\n\nposition enquires: char number, line number, page number.\n\nlayout routines include:\n\nspace, backspace, newline, newpage.\n\nget good line, get good page, get good book, and PROC set=(REF FILE f, INT page,line,char)VOID:\n\nA file has event routines. e.g. on logical file end, on physical file end, on page end, on line end, on format end, on value error, on char error.\n\n\"Formatted transput\" in ALGOL 68's transput has its own syntax and patterns (functions), with FORMATs embedded between two $ characters.[50]\n\nExamples:\n\nprintf (($2l\"The sum is:\"x, g(0)$, m + n)); ¢ prints the same as: ¢ print ((new line, new line, \"The sum is:\", space, whole (m + n, 0))\n\nALGOL 68 supports programming of parallel processing. Using the keyword PAR, a collateral clause is converted to a parallel clause, where the synchronisation of actions is controlled using semaphores. In A68G the parallel actions are mapped to threads when available on the hosting operating system. In A68S a different paradigm of parallel processing was implemented (see below).\n\nPROC eat = VOID: ( muffins-:=1; print((\"Yum!\",new line))), speak = VOID: ( words-:=1; print((\"Yak...\",new line))); INT muffins := 4, words := 8; SEMA mouth = LEVEL 1; PAR BEGIN WHILE muffins > 0 DO DOWN mouth; eat; UP mouth OD, WHILE words > 0 DO DOWN mouth; speak; UP mouth OD END\n\nFor its technical intricacies, ALGOL 68 needs a cornucopia of methods to deny the existence of something:\n\nSKIP, \"~\" or \"?\"C – an undefined value always syntactically valid, EMPTY – the only value admissible to VOID, needed for selecting VOID in a UNION, VOID – syntactically like a MODE, but not one, NIL or \"○\" – a name not denoting anything, of an unspecified reference mode, () or specifically [1:0]INT – a vacuum is an empty array (here specifically of MODE []INT). undefined – a standards reports procedure raising an exception in the runtime system. ℵ – Used in the standards report to inhibit introspection of certain types. e.g. SEMA\n\nThe term NIL IS var always evaluates to TRUE for any variable (but see above for correct use of IS :/=:), whereas it is not known to which value a comparison x < SKIP evaluates for any integer x.\n\nALGOL 68 leaves intentionally undefined what happens in case of integer overflow, the integer bit representation, and the degree of numerical accuracy for floating point.\n\nBoth official reports included some advanced features that were not part of the standard language. These were indicated with an ℵ and considered effectively private. Examples include \"≮\" and \"≯\" for templates, the OUTTYPE/INTYPE for crude duck typing, and the STRAIGHTOUT and STRAIGHTIN operators for \"straightening\" nested arrays and structures\n\nThis sample program implements the Sieve of Eratosthenes to find all the prime numbers that are less than 100. NIL is the ALGOL 68 analogue of the null pointer in other languages. The notation x OF y accesses a member x of a STRUCT y.\n\nBEGIN # Algol-68 prime number sieve, functional style # PROC error = (STRING s) VOID: (print(( newline, \" error: \", s, newline)); GOTO stop); PROC one to = (INT n) LIST: (PROC f = (INT m,n) LIST: (m>n | NIL | cons(m, f(m+1,n))); f(1,n)); MODE LIST = REF NODE; MODE NODE = STRUCT (INT h, LIST t); PROC cons = (INT n, LIST l) LIST: HEAP NODE := (n,l); PROC hd = (LIST l) INT: ( l IS NIL | error(\"hd NIL\"); SKIP | h OF l ); PROC tl = (LIST l) LIST: ( l IS NIL | error(\"tl NIL\"); SKIP | t OF l ); PROC show = (LIST l) VOID: ( l ISNT NIL | print((\" \",whole(hd(l),0))); show(tl(l))); PROC filter = (PROC (INT) BOOL p, LIST l) LIST: IF l IS NIL THEN NIL ELIF p(hd(l)) THEN cons(hd(l), filter(p,tl(l))) ELSE filter(p, tl(l)) FI; PROC sieve = (LIST l) LIST: IF l IS NIL THEN NIL ELSE PROC not multiple = (INT n) BOOL: n MOD hd(l) ~= 0; cons(hd(l), sieve( filter( not multiple, tl(l) ))) FI; PROC primes = (INT n) LIST: sieve( tl( one to(n) )); show( primes(100) ) END\n\nCambridge CAP computer – All procedures constituting the operating system were written in ALGOL 68C, although several other closely associated protected procedures, such as a paginator, are written in BCPL.[51]\n\nEldon 3 – Developed at Leeds University for the ICL 1900 was written in ALGOL 68-R.[52]\n\nFlex machine – The hardware was custom and microprogrammable, with an operating system, (modular) compiler, editor, garbage collector and filing system all written in ALGOL 68RS. The command shell Curt[53] was designed to access typed data similar to Algol-68 modes.\n\nVME – S3 was the implementation language of the operating system VME. S3 was based on ALGOL 68 but with data types and operators aligned to those offered by the ICL 2900 Series.\n\nNote: The Soviet Era computers Эльбрус-1 (Elbrus-1) and Эльбрус-2 were created using high-level language Эль-76 (AL-76), rather than the traditional assembly. Эль-76 resembles Algol-68, The main difference is the dynamic binding types in Эль-76 supported at the hardware level. Эль-76 is used for application, job control, system programming.[54]\n\nBoth ALGOL 68C and ALGOL 68-R are written in ALGOL 68, effectively making ALGOL 68 an application of itself. Other applications include:\n\nELLA – a hardware description language and support toolset. Developed by the Royal Signals and Radar Establishment during the 1980s and 1990s.\n\nRAF Strike Command System – \"... 400K of error-free ALGOL 68-RT code was produced with three man-years of work. ...\"[55]\n\nNAG Numerical Libraries – a software library of numerical analysis routines. Supplied in ALGOL 68 during the 1980s.\n\nTORRIX – a programming system for operations on vectors and matrices over arbitrary fields and of variable size by S. G. van der Meulen and M. Veldhorst.[56]\n\nA feature of ALGOL 68, inherited from the ALGOL tradition, is its different representations. There is a representation language used to describe algorithms in printed work, a strict language (rigorously defined in the Report), and an official reference language intended to be used in compiler input. The examples contain BOLD typeface words, this is the STRICT language. ALGOL 68's reserved words are effectively in a different namespace from identifiers, and spaces are allowed in identifiers, so this next fragment is legal:\n\nINT a real int = 3 ;\n\nThe programmer who writes executable code does not always have an option of BOLD typeface or underlining in the code as this may depend on hardware and cultural issues. Different methods to denote these identifiers have been devised. This is called a stropping regime. For example, all or some of the following may be available programming representations:\n\nINT a real int = 3; # the STRICT language # 'INT'A REAL INT = 3; # QUOTE stropping style # .INT A REAL INT = 3; # POINT stropping style # INT a real int = 3; # UPPER stropping style # int a_real_int = 3; # RES stropping style, there are 61 accepted reserved words #\n\nAll implementations must recognize at least POINT, UPPER and RES inside PRAGMAT sections. Of these, POINT and UPPER stropping are quite common, while RES stropping is a contradiction to the specification (as there are no reserved words). QUOTE (single apostrophe quoting) was the original recommendation, while matched apostrophe quoting, common in ALGOL 60, is not used much in ALGOL 68.[57]\n\nThe following characters were recommended for portability, and termed \"worthy characters\" in the Report on the Standard Hardware Representation of Algol 68 Archived 2014-01-02 at the Wayback Machine:\n\n^ Worthy Characters: ABCDEFGHIJKLM NOPQRSTUVWXYZ 0123456789 \"#$%'()*+,-./:;<=>@[ ]_|\n\nThis reflected a problem in the 1960s where some hardware didn't support lower-case, nor some other non-ASCII characters, indeed in the 1973 report it was written: \"Four worthy characters — \"|\", \"_\", \"[\", and \"]\" — are often coded differently, even at installations which nominally use the same character set.\"\n\nBase characters: \"Worthy characters\" are a subset of \"base characters\".\n\nALGOL 68 allows for every natural language to define its own set of keywords Algol-68. As a result, programmers are able to write programs using keywords from their native language. Below is an example of a simple procedure that calculates \"the day following\", the code is in two languages: English and German.[citation needed]\n\n# Next day date - English variant # MODE DATE = STRUCT(INT day, STRING month, INT year); PROC the day following = (DATE x) DATE: IF day OF x < length of month (month OF x, year OF x) THEN (day OF x + 1, month OF x, year OF x) ELIF month OF x = \"December\" THEN (1, \"January\", year OF x + 1) ELSE (1, successor of month (month OF x), year OF x) FI;\n\n# Nachfolgetag - Deutsche Variante # MENGE DATUM = TUPEL(GANZ tag, WORT monat, GANZ jahr); FUNKTION naechster tag nach = (DATUM x) DATUM: WENN tag VON x < monatslaenge(monat VON x, jahr VON x) DANN (tag VON x + 1, monat VON x, jahr VON x) WENNABER monat VON x = \"Dezember\" DANN (1, \"Januar\", jahr VON x + 1) ANSONSTEN (1, nachfolgemonat(monat VON x), jahr VON x) ENDEWENN;\n\nRussian/Soviet example: In English Algol68's case statement reads CASE ~ IN ~ OUT ~ ESAC, in Cyrillic this reads выб ~ в ~ либо ~ быв.\n\nExcept where noted (with a superscript), the language described above is that of the \"Revised Report(r1)\".\n\nThe original language (As per the \"Final Report\"r0) differs in syntax of the mode cast, and it had the feature of proceduring, i.e. coercing the value of a term into a procedure which evaluates the term. Proceduring would be intended to make evaluations lazy. The most useful application could have been the short-circuited evaluation of boolean operators. In:\n\nOP ANDF = (BOOL a,PROC BOOL b)BOOL:(a | b | FALSE); OP ORF = (BOOL a,PROC BOOL b)BOOL:(a | TRUE | b);\n\nb is only evaluated if a is true.\n\nAs defined in ALGOL 68, it did not work as expected, for example in the code:\n\nIF FALSE ANDF CO proc bool: CO ( print (\"Should not be executed\"); TRUE) THEN ...\n\nagainst the programmers naïve expectations the print would be executed as it is only the value of the elaborated enclosed-clause after ANDF that was procedured. Textual insertion of the commented-out PROC BOOL: makes it work.\n\nSome implementations emulate the expected behaviour for this special case by extension of the language.\n\nBefore revision, the programmer could decide to have the arguments of a procedure evaluated serially instead of collaterally by using semicolons instead of commas (gommas).\n\nFor example in:\n\nPROC test = (REAL a; REAL b) :... ... test (x PLUS 1, x);\n\nThe first argument to test is guaranteed to be evaluated before the second, but in the usual:\n\nPROC test = (REAL a, b) :... ... test (x PLUS 1, x);\n\nthen the compiler could evaluate the arguments in whatever order it felt like.\n\nAfter the revision of the report, some extensions to the language have been proposed to widen the applicability:\n\npartial parametrisation (aka Currying): creation of functions (with fewer parameters) by specification of some, but not all parameters for a call, e.g. a function logarithm of two parameters, base and argument, could be specialised to natural, binary or decadic log,[58]\n\nmodule extension: for support of external linkage, two mechanisms were proposed, bottom-up definition modules, a more powerful version of the facilities from ALGOL 68-R and top-down holes, similar to the ENVIRON and USING clauses from ALGOL 68C[59]\n\nmode parameters: for implementation of limited parametrical polymorphism (most operations on data structures like lists, trees or other data containers can be specified without touching the pay load).[60]\n\nSo far, only partial parametrisation has been implemented, in Algol 68 Genie.\n\nName Year Purpose State Description Target CPU Licensing Implementation language Generalized ALGOL 1962 Scientific NLD ALGOL for generalised grammars ALGOL YY 1966 Draft proposal Intl First version of Algol 68 Specification ACM ALGOL 68DR 1968 Draft proposal Intl IFIP WG 2.1 Draft Report Specification – March ACM ALGOL 68r0 1968 Standard Intl IFIP WG 2.1 Final Report Specification – August ACM ALGOL 68-RR 1970 Military UK ICL 1900 ALGOL 60 EPOS ALGOLE 1971 Scientific ALGOL 68RSRS 1972 Military UK Portable compiler system ICL 2900/Series 39, Multics, VMS & C generator (1993) Crown Copyright ALGOL 68RS Algol 68 with areas 1972 Experimental & other UK Addition of areas to Algol 68 Mini ALGOL 68 1973 Research NLD \"An interpreter for simple Algol 68 Programs\" Archived 2011-07-18 at the Wayback Machine Portable interpreter Mathematisch Centrum ALGOL 60 OREGANO 1973 Research US \"The importance of implementation models.\" UCLA ALGOL 68CC 1975 Scientific UK Cambridge Algol 68 ICL, IBM 360, PDP 10 & Unix, Telefunken, Tesla & Z80 (1980)[61] Cambridge ALGOL 68C ALGOL 68 Revised Reportr1 1975 Standard Intl IFIP WG 2.1 Revised Report Specification ACM Algol HH 1975 Experimental & other UK Proposed extensions to the mode system of Algol 68 Specification ALGOL W Odra Algol 68 1976 practical uses Soviet Union/Poland Odra 1204/IL Soviet ALGOL 60 Oklahoma ALGOL 68 1976 programming instruction USA Oklahoma State University implementation[62] IBM 1130 and System/370/158 Unknown ANSI Fortran 66. Berlin ALGOL 68 1977 Research DE \"The Berlin ALGOL 68 implementation\" &[63] An Abstract ALGOL 68 Machine – machine independent Compiler Technische Universität Berlin CDL 2 FLACCF 1977 Multi-purpose CAN Revised Report complete implementation with debug features System/370 lease, Chion Corporation Assembler ALGOL 68-RTRT 1979 Scientific UK Parallel ALGOL 68-R RS Algolrs 1979 Scientific UK ALGOL 68+ 1980 Scientific NLD Proposed superlanguage of ALGOL 68[64] M-220 ALGOL 68 Soviet Union M-220 Soviet EPSILON Leningrad ALGOL 68L 1980 Telecommunications Soviet Union Full language + modules IBM, DEC, CAMCOH, PS 1001 & PC Soviet Interactive ALGOL 68I 1983 UK Incremental compilation PC Noncommercial shareware ALGOL 68SS 1985 Scientific Intl Sun version of ALGOL 68 Sun-3, Sun SPARC (under SunOS 4.1 & Solaris 2), Atari ST (under GEMDOS), Acorn Archimedes (under RISC OS), VAX-11 under Ultrix-32 Algol68toC[65] (ctrans) 1985 Electronics UK ctrans from ELLA ALGOL 68RS Portable C generator Open-source software 1995 ALGOL 68RS MK2 Interactive ALGOL 68 1992 UK Incremental compilation PC Noncommercial shareware[66] Algol 68 GenieG 2001 Full language NLD Includes standard collateral clause Portable interpreter GNU GPL C Algol 68 Genie version 2.0.0 2010 Full language NLD Portable interpreter; optional compilation of selected units GNU GPL C\n\nThe S3 language that was used to write the ICL VME operating system and much other system software on the ICL 2900 Series was a direct derivative of Algol 68. However, it omitted many of the more complex features, and replaced the basic modes with a set of data types that mapped directly to the 2900 Series hardware architecture.\n\nALGOL 68R from RRE was the first ALGOL 68 subset implementation, running on the ICL 1900. Based on the original language, the main subset restrictions were definition before use and no parallel processing. This compiler was popular in UK universities in the 1970s, where many computer science students learnt ALGOL 68 as their first programming language; the compiler was renowned for good error messages.\n\nALGOL 68RS(RS) from RSRE was a portable compiler system written in ALGOL 68RS (bootstrapped from ALGOL 68R), and implemented on a variety of systems including the ICL 2900/Series 39, Multics and DEC VAX/VMS. The language was based on the Revised Report, but with similar subset restrictions to ALGOL 68R. This compiler survives in the form of an Algol68-to-C compiler.\n\nIn ALGOL 68S(S) from Carnegie Mellon University the power of parallel processing was improved by adding an orthogonal extension, eventing. Any variable declaration containing keyword EVENT made assignments to this variable eligible for parallel evaluation, i.e. the right hand side was made into a procedure which was moved to one of the processors of the C.mmp multiprocessor system. Accesses to such variables were delayed after termination of the assignment.\n\nCambridge ALGOL 68C(C) was a portable compiler that implemented a subset of ALGOL 68, restricting operator definitions and omitting garbage collection, flexible rows and formatted transput.\n\nAlgol 68 Genie(G) by M. van der Veer is an ALGOL 68 implementation for today's computers and operating systems.\n\n\"Despite good intentions, a programmer may violate portability by inadvertently employing a local extension. To guard against this, each implementation should provide a PORTCHECK pragmat option. While this option is in force, the compiler prints a message for each construct that it recognizes as violating some portability constraint.\"[67]\n\n... The scheme of type composition adopted by C owes considerable debt to Algol 68, although it did not, perhaps, emerge in a form that Algol's adherents would approve of. The central notion I captured from Algol was a type structure based on atomic types (including structures), composed into arrays, pointers (references), and functions (procedures). Algol 68's concept of unions and casts also had an influence that appeared later. Dennis Ritchie Apr 1993.[2]\n\n... C does not descend from Algol 68 is true, yet there was influence, much of it so subtle that it is hard to recover even when I think hard. In particular, the union type (a late addition to C) does owe to A68, not in any details, but in the idea of having such a type at all. More deeply, the type structure in general and even, in some strange way, the declaration syntax (the type-constructor part) was inspired by A68. And yes, of course, \"long\". Dennis Ritchie, 18 June 1988[4]\n\n\"Congratulations, your Master has done it\" – Niklaus Wirth[68]\n\nThe more I see of it, the more unhappy I become – E. W. Dijkstra, 1968[69]\n\n[...] it was said that A68's popularity was inversely proportional to [...] the distance from Amsterdam – Guido van Rossum[70]\n\n[...] The best we could do was to send with it a minority report, stating our considered view that, \"... as a tool for the reliable creation of sophisticated programs, the language was a failure.\" [...] – C. A. R. Hoare in his Oct 1980 Turing Award Lecture[71]\n\n\"[...] More than ever it will be required from an adequate programming tool that it assists, by structure, the programmer in the most difficult aspects of his job, viz. in the reliable creation of sophisticated programs. In this respect we fail to see how the language proposed here is a significant step forward: on the contrary, we feel that its implicit view of the programmer's task is very much the same as, say, ten years ago. This forces upon us the conclusion that, regarded as a programming tool, the language must be regarded as obsolete. [...]\" 1968 Working Group minority report on 23 December 1968.[72]"
    }
}