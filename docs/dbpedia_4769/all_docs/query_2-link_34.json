{
    "id": "dbpedia_4769_2",
    "rank": 34,
    "data": {
        "url": "https://cacm.acm.org/article/lessons-from-pl-i-a-most-ambitious-programming-language/",
        "read_more_link": "",
        "language": "en",
        "title": "I: A Most Ambitious Programming Language – Communications of the ACM",
        "top_image": "https://cacm.acm.org/wp-content/uploads/2023/11/cropped-cropped-cacm_favicon-1.png?w=32",
        "meta_img": "https://cacm.acm.org/wp-content/uploads/2023/11/cropped-cropped-cacm_favicon-1.png?w=32",
        "images": [
            "https://cacm.acm.org/wp-content/uploads/2024/08/August2024.Cover_.1000x1338.jpg?w=1000",
            "https://cacm.acm.org/wp-content/uploads/2023/09/091823.BLOG_.Doug-Meil.jpg",
            "https://dl.acm.org/cms/attachment/html/10.1145/3623564/assets/html/ins02.gif",
            "https://dl.acm.org/cms/attachment/html/10.1145/3623564/assets/html/ins01.gif",
            "https://acm.nui.media/pipeline/684700/0/vc?z=acm&dim=599027&kw=&click=&abr=$imginiframe",
            "https://acm.nui.media/pipeline/684700/0/vc?z=acm&dim=599027&kw=&click=&abr=$imginiframe",
            "https://cacm.acm.org/wp-content/uploads/2024/08/081424.News_.AIs-Increasing-Power-G.jpg",
            "https://cacm.acm.org/wp-content/uploads/2024/08/080924.News_.Fax-Is-Alive-S.jpg",
            "https://cacm.acm.org/wp-content/uploads/2024/06/05.28.24.BLOG_.Doug-Meil.jpg",
            "https://cacm.acm.org/wp-content/uploads/2023/09/091823.BLOG_.Doug-Meil.jpg",
            "https://cacm.acm.org/wp-content/uploads/2024/04/070523_Miel_diagram.jpg",
            "https://cacm.acm.org/wp-content/uploads/2024/04/070523_Miel_diagram2.jpg",
            "https://acm.nui.media/pipeline/684700/0/vc?z=acm&dim=599027&kw=&click=&abr=$imginiframe",
            "https://acm.nui.media/pipeline/684700/0/vc?z=acm&dim=599027&kw=&click=&abr=$imginiframe",
            "https://cacm.acm.org/wp-content/uploads/2024/08/081424.News_.AIs-Increasing-Power-G.jpg",
            "https://cacm.acm.org/wp-content/uploads/2024/08/080924.News_.Fax-Is-Alive-S.jpg",
            "https://cacm.acm.org/wp-content/uploads/2024/06/05.28.24.BLOG_.Doug-Meil.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Doug Meil",
            "R. Colin Johnson",
            "Jake Widman"
        ],
        "publish_date": "2023-11-01T00:00:00-04:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "https://cacm.acm.org/wp-content/uploads/2023/11/cropped-cropped-cacm_favicon-1.png?w=32",
        "meta_site_name": "",
        "canonical_link": "https://cacm.acm.org/article/lessons-from-pl-i-a-most-ambitious-programming-language/",
        "text": "https://bit.ly/44OqI2R July 5, 2023\n\nOne might argue language creation might be accelerating today, but it’s not a new problem. In my BLOG@CACM post “Why Are There So Many Programming Languages?”, I described how variants of programming languages go back to the dawn of computer programming. In that post I also cited one of my favorite stories: PL/I. PL/I stands for Programming Language 1, and its aim was to be the Highlander of programming languages: There would be no need for version 2, 3, or 4 if everything went to plan. While it is clear that goal was never reached, what might not be evident is that what PL/I was trying to achieve was a reasonable idea, or at least not entirely crazy. What also was not evident at the time was how difficult that reasonable idea turned out to be. We can all learn from this story.\n\nIBM designed PL/I with the goal of bringing together the power of three programming languages: FORTRAN (1954), ALGOL (1958), and COBOL (1959).\n\nFORTRAN—The scientific programming language.\n\nCOBOL—The business programming language.\n\nALGOL—Primarily a research language, but with innovative paradigms and features.\n\nOn paper, this makes sense. Computer programming can be difficult; why should there be multiple programming languages? Computer programming of the era required a lot of punched cards, so having One Good Programming Language would have on-paper (or cardboard) benefits to simplify the process of development as well. Work on the PL/I specification started in 1964, and work on the first compiler began in 1966.\n\nIn the minds of PL/I’s designers, the plan looked something like this:\n\nPL/I was not just a development effort, it was also in effect a system conversion. There was an explicit goal for developers to start using PL/I, but also implicit goals for developers not just to stop using FORTRAN, COBOL, and ALGOL directly, but also to convert their existing solutions and codebases to PL/I. Compounding the problem was that FORTRAN, COBOL, and ALGOL were evolving in real time.\n\nAs I described in my BLOG@CACM post “The Art of Speedy Systems Conversions,” a system conversion is one of the most difficult things to do in software engineering. The existing system typically has a massive head start, and the replacing system needs to start up development, accelerate, reach feature parity, and then both systems need to be stable long enough to make the switch.\n\nRefer to the 1994 action movie Speed as to why this set of activities can be a challenge. PL/I was trying to do this with not just one mobile target, but three.\n\nBack to Top\n\nThe FORTRAN Challenge\n\nAll programming languages evolve over time, and this was certainly true of FORTRAN. Some development milestones from early FORTAN were:\n\nFORTRAN language specification created by IBM (1954).\n\nFORTRAN 1 (1957)—First FORTRAN compiler available.\n\nFORTRAN 2 (1958)—This version had incremental language feature additions, including allowing user-written subroutines.\n\nFORTRAN 3 (1958)—This version was never released as a product.\n\nFORTRAN 4—Development started in 1961, initial release in 1962—with subsequent development through 1968.\n\nFORTRAN 66 (1966)—The first industry standard version of FORTRAN.\n\nFORTRAN 77 (1977)—More language feature additions, particularly trying to address shortcomings of FORTRAN 66.\n\nNote that FORTRAN 66—a significant milestone in FORTRAN’s history—happened multiple years after PL/I development had started.\n\nBack to Top\n\nThe ALGOL Challenge\n\nALGOL was a highly influential programming language; although primarily used in research and academic settings, it still had an evolutionary arc:\n\nALGOL 58 (1958)—First version. Included code blocks, an innovation in programming language design.\n\nALGOL 60—Not commercially successful, but widely used in research and hugely influential in language design. One of the first languages to implement function definitions that could also be called recursively, among other features.\n\nALGOL 68—A language specification intended as an improvement on ALGOL 60 that seemed to make everyone involved in the effort unhappy.\n\nBack to Top\n\nThe COBOL Challenge\n\nCOBOL Origins\n\nWhen people think of COBOL now, they typically think of staid mainframe banking, finance, and insurance solutions, but COBOL’s origins have a dash of drama. Designed in 1959 by CODASYL, an industry committee, COBOL was part of a U.S. Defense Department effort to create a common data-processing language that could run across the various computers it was operating. That simple-sounding requirement was anything but at the time and is another example of the desire for One Good Programming Language, as well as compilers that could run on all computers. Second, there were already two prominent “business” programming languages in existence before COBOL: FLOW-MATIC and COMTRAN:\n\nFLOW-MATIC—Created by Grace Hopper while at Remington Rand 1955–1958. FLOW-MATIC was English-based.\n\nCOMTRAN—COMTRAN, created by IBM in 1957, was intended to be “FORTRAN, for business.”\n\nThere are varying opinions on how much each language influenced COBOL, though COBOL did wind up becoming quite verbose. Despite rumors, Grace Hopper was not on the committee that designed the language.\n\nEarly COBOL\n\nSome development milestones from early COBOL were:\n\nCOBOL 60 (1960)—The first version of COBOL.\n\nCOBOL 61—Minor improvements to the language.\n\nCOBOL 61 Extended—This version appeared in 1963, including the sort and report writer facilities.\n\nCOBOL 65—This version brought further clarifications to the specification and introduced facilities for mass storage files and tables.\n\nCOBOL 68—This version became an ISO standard in 1972.\n\nCOBOL 74—More changes to the language, including sub-programs.\n\nIBM announced it would cease development of COMTRAN in 1962, in preference of COBOL.\n\nBack to Top\n\nThe Historical Verdict\n\nWhen compared to other programming languages that have been created in the past 60+ years, PL/I was a success. PL/I reportedly was used in the development of the Multics operating system and the S/360 version of the Sabre airline reservation system, among others. PL/I, taught at the college level, has been around for decades. Most programming languages would be envious to do half as well.\n\nYet PL/I did not achieve its strategic goal of consolidating scientific and business computing with the best new programming paradigms research could provide, and it wasn’t for a lack of trying. That goal became impossible as both FORTRAN and COBOL kept accelerating. COBOL became the most widely used programming language in the world by 1970, and replacing an existing COBOL system with PL/I was going to be a hard sell to customers. The same could be said of existing FORTRAN systems. COBOL and FORTRAN also kept accelerating their language definition during the 1960s, making PL/I’s feature parity with them not just a challenge, but also ambiguous as it took both COBOL and FORTRAN years to stabilize their respective standards.\n\nThe programming language landscape continued to evolve as well. By the end of the 1960s, Simula had branched from ALGOL and introduced object-oriented programming concepts, generating a new programming paradigm and a host of new languages implementing those concepts, and C emerged as the dominant systems programming language the following decade. There were even more high-level programming languages than ever.\n\nBack to Top\n\nLessons For the Rest of Us\n\nA system conversion is one of the hardest things to do in software engineering, and programming languages are one of the hardest sub-cases as its users are other developers. Exclaiming “we should rebuild it!” is a siren call that is tough to resist, though, as developers love the sight of a clean sheet of paper combined with a big new idea. It’s not wrong to think big, just don’t forget to plan for the conversion of the incumbent system: for every blank sheet of paper used to design the new thing, pull out at least one more for the migration. Keep that ratio in mind when considering timelines and the project budget as well, depending on just how deeply the prior system is entrenched.\n\nBack to Top\n\nBack to Top\n\nOne might argue that language creation might be accelerating today, but it’s not a new problem. In my BLOG@CACM post “Why Are There So Many Programming Languages?,” I described how variants of programming languages go back to the dawn of computer programming. In that post I also cited one of my favorite stories: PL/I. PL/I stands for Programming Language 1, and its aim was to be the Highlander of programming languages: there would be no need for 2, 3, or 4 if everything went to plan. While it is clear today that goal was never reached, what might not be evident is that what PL/I was trying to achieve was a pretty reasonable idea, or at least not entirely crazy. What also wasn’t evident at the time was how enormously difficult that reasonable idea turned out to be. We can all learn something from this story.\n\nThe General Idea\n\nPL/I was designed by IBM with the goal of bringing together the power of 3 different programming languages: FORTRAN (1954), ALGOL (1958), and COBOL (1959).\n\nFORTRAN – The scientific programming language\n\nCOBOL – The business programming language\n\nALGOL – Primarily a research language, but with innovative paradigms and features\n\nOn paper, this makes a lot of sense. Computer programming can be difficult, and why should there be multiple programming languages? And because computer programming of the era required a lot of punched cards, having One Good Programming Language would have on paper (or cardboard) benefits to simplify the process of development as well. Work on the PL/I specification started in 1964, and work on the first compiler in 1966.\n\nThis was playing out within a decade of the creation of the first mainstream high-level programming language (FORTRAN), and even by that point there were arguably already “too many” languages. PL/I was a solution to at least a part of that problem.\n\nThe Hard Part\n\nIn the minds of PL/I’s designers the plan looked something like this…\n\nCredit: Doug Meil\n\nBut PL/I wasn’t just a development effort, it was also in effect a system conversion. There was an explicit goal for developers to start using PL/I, but were also implicit goals for developers not just to only stop using FORTRAN, COBOL, and ALGOL directly, as well as to convert their existing solutions and codebases to PL/I. As if that wasn’t hard enough, compounding the problem was that FORTRAN, COBOL, and ALGOL were all evolving in real time. As I described in my BLOG@CACM post “The Art of Speedy Systems Conversions,” a system conversion is one of the most difficult things to do in software engineering. The existing system typically has massive head start, and the replacing system needs to start up development, accelerate, reach feature parity, and then both systems need to be stable long enough to make the switch.\n\nCredit: Doug Meil\n\nRefer to the 1994 action movie Speed as to why this set of activities can be a challenge. PL/I was trying to do this with not just one mobile target, but three.\n\nThe FORTRAN Hard Part\n\nAll programming language evolve over time, and this was certainly true of FORTRAN. Some of the development milestones from early FORTAN were:\n\nFORTRAN language specification created by IBM (1954).\n\nFORTRAN 1 (1957)—First FORTRAN compiler available.\n\nFORTRAN 2 (1958)—This version had incremental language feature additions, including allowing user-written subroutines.\n\nFORTRAN 3 (1958)—This version was apparently never released as a product.\n\nFORTRAN 4—Development started in 1961 and was initially released in 1962 – but had subsequent development through 1968.\n\nFORTRAN 66 (1966)—This version became the first industry standard version of FORTRAN.\n\nFORTRAN 77 (1977)—More language feature additions, particularly trying to address shortcomings of FORTRAN 66.\n\nNote that FORTRAN 66—a significant milestone in FORTRAN’s history—happened multiple years after PL/I development had started.\n\nThe ALGOL Hard Part\n\nALGOL was highly influential programming language, and although primarily used in research and academic settings it still had an evolutionary arc:\n\nALGOL 58 (1958)–First version of ALGOL. Included code blocks, an innovation in programming language design.\n\nALGOL 60—While not commercially successful, widely used in research and hugely influential in language design. One of the first languages to implement function definitions that could also be called recursively, among other language features.\n\nALGOL 68—A language specification intended as an improvement on ALGOL 60 that seemed to make just about everyone involved in the effort unhappy.\n\nThe COBOL Hard Part\n\nCOBOL Origins\n\nWhen people think of COBOL now, they typically think of staid mainframe banking, finance, and insurance solutions, but COBOL’s origins have a dash of drama. For starters, COBOL was designed in 1959 by CODASYL—an industry committee—which was part of a U.S. Defense Department effort to create a common data processing language that could run across the various computers it was operating. That simple-sounding requirement was anything but at the time, and is another example of the desire for One Good Programming Language, as well as compilers that could run on all those various computers. Second, there were already two prominent “business” programming languages in existence before COBOL: FLOW-MATIC and COMTRAN:\n\nFLOW-MATIC—Created by Grace Hopper when she was at Remington Rand from 1955 to 1958. FLOW-MATIC was English-based.\n\nCOMTRAN—COMTRAN was created by IBM in 1957 and was intended to be “FORTRAN, for business.”\n\nThere are varying opinions on how much each language influenced COBOL, though COBOL did wind up becoming quite verbose. Despite rumors to the contrary, Grace Hopper was not on the committee that designed the language.\n\nEarly COBOL\n\nSome of the development milestones from early COBOL were:\n\nCOBOL 60 (1960)—The first version of COBOL\n\nCOBOL 61—Minor improvements to the language.\n\nCOBOL 61 Extended—This version of COBOL appeared in 1963, including the sort and report writer facilities.\n\nCOBOL 65—This version of COBOL brought further clarifications to the specification and introduced facilities for mass storage files and tables.\n\nCOBOL 68—This version of COBOL eventually became an ISO standard in 1972.\n\nCOBOL 74 —More changes to the language, including sub-programs.\n\nIBM announced it would cease development of COMTRAN in 1962, in preference of COBOL.\n\nThe Historical Verdict\n\nWhen compared to the thousands of other programming languages that have been created in the past 60+ years, PL/I was a success. PL/I reportedly was used in the development of the Multics operating system and the S/360 version of Sabre airline reservation system, among others. PL/I was taught at the college-level. PL/I has been around for decades. Most programming languages would be envious to do half as well.\n\nBut PL/I didn’t achieve its strategic goal of consolidating scientific and business computing with the best new programming paradigms that research could provide, and it wasn’t for a lack of trying. That goal, although well-intentioned, became impossible as both FORTRAN and COBOL kept accelerating. In terms of adoption, COBOL became the most widely used programming language in the world by 1970, and ripping out an existing COBOL system and replacing it with PL/I was going to be a hard sell to customers. The same could surely be said of existing FORTRAN systems. COBOL and FORTRAN also kept accelerating in terms of language definition during the 1960s, making PL/I’s feature parity with them not just a challenge, but also ambiguous as it took both COBOL and FORTRAN years to stabilize their own respective standards.\n\nThe programming language landscape continued to evolve as well. By the end of the 1960s, Simula had branched from ALGOL and introduced object-oriented programming concepts, generating a new programming paradigm and host of new languages implementing those concepts, and C emerged as the dominant systems programming language the following decade. There were even more high-level programming languages than ever.\n\nLessons For The Rest Of Us\n\nA system conversion is one of the hardest things to do in software engineering, and programming languages are one of the hardest sub-cases as its users are other developers. Exclaiming “we should rebuild it!” is a siren call that is tough to resist, though, as developers love the sight of a clean sheet of paper combined with a Big New Idea. It’s not wrong to think big, just don’t forget to plan for the conversion of the incumbent system: for every blank sheet of paper used to design the new thing, pull out at least one more for the migration. Keep that ratio in mind when considering timelines and the project budget as well, depending on just how deep the prior system is entrenched.\n\nReferences\n\nPL/I\n\nFORTRAN\n\nALGOL\n\nCOBOL\n\nRelevant BLOG@CACM Posts\n\nWhy are there so many programming languages?\n\nArt of speedy systems conversions\n\nFilm\n\nHighlander (film)\n\n“There can be only one” works in action movies, harder in programming.\n\nSpeed (film)\n\nHelpful guidance on managing a complex rescue/systems migration.\n\nDoug Meil is a software architect in healthcare data management and analytics. He also founded the Cleveland Big Data Meetup in 2010. More of his BLOG@CACM posts can be found at https://www.linkedin.com/pulse/publications-doug-meil"
    }
}