{
    "id": "dbpedia_4769_2",
    "rank": 25,
    "data": {
        "url": "https://craftofcoding.wordpress.com/category/algol/page/2/",
        "read_more_link": "",
        "language": "en",
        "title": "Algol – Page 2 – The Craft of Coding",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://craftofcoding.wordpress.com/wp-content/uploads/2021/02/wirthlanguages1-1.png?w=599",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2021/02/wirthlanguages2.png?w=620",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2020/11/sequencegoto.jpg?w=472",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2020/11/sequencealgol.jpg?w=644",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2017/06/salgolbubblesort.jpg?w=620",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2017/06/algorithm33.jpg",
            "https://craftofcoding.wordpress.com/wp-content/uploads/2017/04/firstif.jpg",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2021-02-18T20:22:36+00:00",
        "summary": "",
        "meta_description": "Posts about Algol written by spqr",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "The Craft of Coding",
        "canonical_link": "https://craftofcoding.wordpress.com/category/algol/",
        "text": "Language design in the 1960’s was dominated by attempts to improve upon Algol60. Hoare noted in 1973 [1] that ALGOL-60 was “… a language so far ahead of its time, that it was not only an improvement on its predecessors, but also on nearly all its successors”. Niklaus Wirth was a graduate student at University of California, Berkeley when he started playing around with languages. He joined a research group which was engaged with the implementation and improvement of a dialect of ALGOL-58, NELIAC. He described the compiler as “an intricate mess“, and the process one of “1% science, and 99% sorcery” [1].\n\nThe first language Wirth designed leading to his dissertation was Euler, as Wirth himself put it “a trip with the bush knife through the jungle of language features and facilities” [1]. Euler had academic elegance, but no real practical value, however it did catch the attention of the IFIP Working Group, engaged in designing the successor to ALGOL-60. There seemed to be two camps here, one which wanted to push the boundaries of language design and another which wanted to extend ALGOL-60. Wirth belonged to the latter group. In 1965, three reports by Wirth, Seegmüller, and Wijngaarden described three different quasi-complete languages. The complexity of the design process, involving far too many people, eventually led Wirth to become disheartened with the design process, and he went off to develop his own version of ALGOL-60s successor. Designed with contributions from Tony Hoare, this language would become ALGOL-W.\n\nWirth’s first significant language was PL360, a byproduct of the ALGOL-W effort. The IBM 360 upon which ALGOL-W was implemented offered the choice of assembly language or Fortran compilers, neither of which was very attractive. PL360 [2] was a tool with which to implement ALGOL-W. ALGOL-W had a number of applications, but was deficient as a systems programming language. PL360 was to become more successful than ALGOL-W, largely because ALGOL-W was a complex language, and the target computers inadequate. In the fall of 1967, Wirth returned to Switzerland to begin work on the language that would become most closely associated with his language design efforts – Pascal. Wirth would go on to create a trinity of languages, neither of which were that closely related, but all that had one thing in common, they were “ALGOL-like” languages – Pascal, Modula-2 and Oberon.\n\nPascal – Based largely on Algol W, including the use of it’s while and case statements, and record structures. There were syntactic differences, however Algol 60 was almost a subset of Pascal.\n\nModula-2 – Wirth noted that Modula-2 “includes all aspects of Pascal, and extends them with the module concept”.\n\nOberon – Evolved from Modula-2 by very few additions, and several subtractions.\n\nNote that “ALGOL-like” really implied – a procedural paradigm, a rigorously defined syntax, traditional mathematical notation (with the nonsense of symbols like ++), block structure providing identifier scope, the availability of recursion, and a strict, static data typing system. [3]\n\n[1] Wirth, N., “From programming language design to computer construction”, CACM, 28(2), pp. 160-164 (1985)\n\n[2] Wirth, N., “PL360, a programming language for the 360 computers”, Journal of the ACM, 15(1), pp.34-74 (1968)\n\n[3] Wirth, N., “Modula-2 and Oberon”, in ACM Conf. on History of Programming Languages, pp.3-1-3-10 (2007)\n\nAlgol was the first real “algorithmic” language, more so than Fortran because the latter contained a lot of structures that we couldn’t consider pleasant, and most of them had to do with what is considered breaking the sequential flow. In early Fortran there were a lot of “jump” statements, either explicitly goto, or thinly veiled as goto (see arithmetic if). In early languages goto (or go to) was often used in place of repetitive statements, either because the programmer was use to jumps (from assembler), mistrusted loops, or just didn’t consider them. Algol used the go to statement and associated labels to break the sequential flow.\n\nConsider the arithmetic sequence, S+1/n/n where S=0 initially, and n takes on a sequence of values 1,…,∞. This can be expressed as:\n\nOf course ∞ makes for a lot of work, so it is easier to stop the process at some point, let’s say 1.6449 (π²/6). Here is an Algol program to perform the task:\n\nThis piece of code has two jumps. The first one, which uses the label L1 mimics a loop, repetitively processing the next value of n, until such time as S is greater-than-or-equal-to 1.6449, then the second jump is invoked to label L2, effectively exiting the loop.\n\nIn “The Humble Programmer”, written by Dijkstra in 1972 he made the following statement:\n\n“Another lesson we should have learned from the recent past is that development of ‘richer’ or ‘more powerful’ programming languages was a mistake in the sense that these baroque monstrosities, these conglomerations of idiosyncrasies, are really unmanageable both mechanically and mentally.”\n\nAnd to be honest, he was probably right… but that wasn’t even the worst of it. If he thought Algol 68 was a monster, C++ and Ada would balloon to gargantuan proportions. Have we lost the ability to create simple programming languages? I don’t necessarily mean for the purpose of creating commercial applications – the nature of interaction with hardware, networking etc, makes languages with large scale structure necessary. But along the way we have used these commercial languages to teach novices to program – and it hasn’t really worked.\n\nOne of the reasons why students become disengaged with introductory programming courses may be the vast amounts of language knowledge required, on top of learning problem solving skills, and algorithm design. It may be too much for people not use to thinking in a “programming” mode. Learning about language-specific syntax, and memory management, design, testing, blah, blah, blah – it may be overwhelming. Which is surprising, but then those of us who learned programming in the 1980s learned to program in Pascal, or maybe Fortran. Before languages added things like OO, became “functional”, and masters of everything that a language could be, they were simple – no really they were.\n\nThere were languages created specifically for teaching programming. Pascal was one. S-Algol was another (it appeared after Pascal).\n\nHere is a program in S-Algol which performs a Bubble sort:\n\nlet n = readi let x = vector 1::n of 0.0 for i = 1 to n do x(i) := readr for i = 1 to n-1 do for j = 1 to n-i do if x(j) > x(j+1) do begin let temp = x(j) x(j) := x(j+1) x(j+1) := temp end write \"The sorted numbers are 'n'\" for i = 1 to n do write x(i), \"'n\"?\n\nThe structure of this language was very simple. It was from a pre-OO time when the programming world was simpler, happier.\n\nWhen Algol 60 first appeared, it heralded a new era for programming languages, one which encompassed the idea of “blocks” of code, amongst other things. So why did such a promising language fail? There are likely a number of reasons.\n\nFirstly, Algol 60 had no I/O in the specification. This meant that when Algol was implemented on a particular machine I/O was added, and so the specifications for I/O differed among implementations. Secondly, the 1960s were awash with new programming languages – everyone wanted theirs to be the next “big thing”. It is harder to compete in this sort of an environment. There was also very little time between the release of Algol 60 and beginning work on its successor Algol 68. Algol may have been more successful if effort had been spent on improving Algol 60, rather than creating a whole new language.\n\nThirdly, and likely the biggest issue was IBM. Algol 60 made some headway in Europe, but never really established itself in North America. Why? IBM’s US domestic installed market share for computer systems was around 71.4% in the 1960s. Its main competitors, Honeywell and Univac held 8.1% and 9.6% of the market respectively [1]. Algol60 was suppose to take over some of Fortran’s territory, but due to IBM’s dominance, this never happened. In fact Fortran so dominated the industry, that even IBM’s other language PL/I (1964) failed to make any headway. On the business side, IBM adopted Cobol in 1962 as its primary development language.\n\nBy the time the tide started to turn against Fortran (in the late 1960s), effected by the surge of interest in structured programming, Algol60 had been usurped by Algol68. Algol68 was too complex a language, and other players in the guise of Pascal (and later C) would take over. Pascal was block-oriented, and structured, and would lead the way for programming in the 1970s. By the time S-algol appeared in the late 1970s, it was over for Algol. Which is a pity, because S-algol showed real promise. Here’s a bubblesort in S-algol.\n\n[1] Arnst, C., “Charts show IBM outran others in ’60s”, Computerworld, Nov.7, p.57 (1977)\n\nBy 1977, Fortran had likely its greatest metamorphosis from an unstructured, to a quasi-structured language. At the eleventh hour the revision for the F77 standard was modified to reduce the impact of goto statements to match other languages, where its influence was minimal, or even non-existent. The changes made Fortran 77 vastly different from its predecessor, Fortran 66.\n\nOf major importance, was the inclusion of a “block IF“, which took the following form:\n\nIF (E) THEN ... END IF\n\nThe use of THEN as a new keyword allowed a block of statements to be incorporated until the terminating keyword ENDIF was reached. This also solved the dangling else problem. This was augmented by the addition of the keyword ELSE, which allowed for a group of statements to be actioned if the preceding IF is not satisfied.\n\nIF (E) THEN ... ELSE ... ENDIF\n\nBy the mid-70s, Fortran was likely coerced into making these changes due to the competition from C and Pascal, both of which offered these conditionals. These new F77 constructs allowed for improved program readability, especially through eliminating the need for statement labels, and goto statements. Here is an example:\n\nIF (K.GT.0) THEN POSNUM = POSNUM + 1 ELSE IF (K.LT.0) THEN NEGNUM = NEGNUM + 1 ELSE ZEROS = ZEROS + 1 ENDIF\n\nThe emergence of Ada did nothing to evolve the if statement. Like Pascal and F77, it used a then keyword, borrowed the else-if idea from Algol68, renaming it elsif, and used the same structure terminator endif, as F77. By this stage, if statements had likely evolved as far as they would, and new languages were just selecting appropriate concepts from existing languages.\n\nif C1 then S1 elsif C2 then S2 elsif Cn then Sn else S(n+1) endif;\n\nFortran 90 would go on to finally make the arithmetic if obsolescent. Python would alter very little, adopting the elif of Algol68, and the lack of parentheses.\n\nif x == 0: zeroes = zeroes + 1 elif x < 0: negnum = negnum + 1 else: posnum = posnum + 1\n\nJulia as well uses an amalgam of structural pieces.\n\nif x < 0 negnum = negnum + 1 elseif x > 0 posnum = posnum + 1 else zeroes = zeroes + 1 end\n\nWe are now in the age of mix-and-match, and it is unlikely the if statement will evolve to any great extent.\n\nThe design of the if statement in Algol 60 was likely the pinnacle of its evolution. From here on in every language tweaked its syntax, but there were no major changes. Languages like Algol 68, C, and Pascal all had conditional statements. Algol 68, although having the same name as “Algol” moniker, was a different language altogether.\n\nWhereas Algol 60 required the use of explicit compound statements within an if statement if more than one statement was being controlled, Algol 68 incorporated the use of control structure terminators. For the if statement this meant the use of the reversed keyword fi. Algol 68 still lacked the parentheses of Fortran, but also had no requirements for compound statements, as each section was self-delineated. It had the following general form:\n\nif C then ... else ... fi\n\nThis had the added effect of eliminating the dangling-else problem of Algol 60. Algol 68 also added the keyword elif, a short-hand to allow for a series of else-if statements:\n\nif C1 then ... elif C2 then ... elif C3 then ... else ... fi\n\nHere is an example:\n\nif x>0 then posNum := posNum + 1; elif x<0 then negNum := negNum + 1; else zeros := zeros + 1; fi\n\nThe if statement of C simplified that of Algol 60, deleting the then clause, and adding parentheses to enclose the conditional statement. It had the following general form:\n\nif (C) statement1; else statement2;\n\nHowever, similar to Algol 60, groups of statements require the use of compound statements delineated by { }, and C also suffers from the dangling-else problem of Algol 60. Here is an example:\n\nif (x>0) posNum := posNum + 1; else if (x<0) negNum := negNum + 1; else zeros := zeros + 1;\n\nPascal, which arrived at a similar time to C, has a syntax similar to that of C – except its logical expression was bracket-less, and it used the then keyword, like Algol 60. Like Algol 60, it also suffered from the dangling-else problem, and required the use of begin-end delineators for a compound statement.\n\nif C then S else S2;\n\nFortran did not make any inroads into modifying the if statement until later. Likely spurned on by Algol 60, Fortran IV introduced the logical if statement in 1965. It had the following form:\n\nIF (E) STATEMENT\n\nWhere E was a logical expression, using operators of the form .EQ. for =, and .LE. for ≤. The statement was any statement except a DO statement or another logical IF. However unlike Algol 60, there were no compound statements, and no keyword corresponding to else. Both these had to be achieved by means of goto statements. In this sense it almost mimicked an if-else statement. Consider the example below:\n\nIF (A .LE. 0) GOTO 15 W = X ** A GOTO 20 15 W = 0 20 ...\n\nIn this case, if the value of A is less than of equal to zero, the program jumps to statement 15, setting W to 0. Otherwise it calculates W=X**A, and jumps to statement 20. Notice that the Fortran conditional “operators” are stropped by the use of periods, e.g. .EQ.. This was done to avoid potential ambiguity. The expression A LE 0 could also have been interpreted as the variable ALE0. Fortran 66, the first industry standard made no changes to the if statement.\n\nThere were a number of differences between Fortran (IV) and Algol (60):\n\nFortran used mnemonics to represent conditional operator, e.g. .LE., versus Algol’s ≤ (in some implementations <= was used due to the non-availability of ≤)\n\nFortran uses parentheses, ( ), to separate the logical expression from the statement, whereas Algol uses the additional keyword then.\n\nFortran (66) required that each arithmetic statement on either side of a conditional be of the same datatype. This is because A.GT.B was often translated to A-B.GT.0.(This disappeared in F77).\n\nBy all accounts, Fortran IV, and 66 were extremely deficient with respect to conditional statements. The next major changes were not to appear until Fortran 77.\n\nConsider code that looked like this in Algol 60:\n\nif k>0 then posNum := posNum + 1 else if k<0 then negNum := negNum + 1 else zeros := zeros + 1\n\nThe equivalent in Fortran 66 would be:\n\nIF (K.GT.0) GOTO 30 IF (K.LT.0) GOTO 31 ZEROS = ZEROS + 1 GOTO 47 30 POSNUM = POSNUM + 1 GOTO 47 31 NEGNUM = NEGNUM + 1 75 ...\n\nHow did if evolve in other languages? Algol 68, C, Pascal?\n\nArguably one of the most important control structures to evolve is “if“. Without it, programs couldn’t make any sort of decisions.\n\nFew algorithmic languages, apart from Plankalkül (1948), contained conditional statements. Plankalkül formed conditional statements with the help of a symbol which was an arrow with a period above it, which was used in the following manner:\n\nThe left side of the statement, B, signifies the condition (Bedingung) and is an expression with a boolean value, and the right side, a, is an arbitrary statement. If B evaluates to 0 (nein), then the statement ends here, otherwise if B is 1 (ja), then the statement continues with a. There is no “else” statement. Heinz Rutishauser’s Superplan (1949-1951), did not have a decision statement.\n\nDecision statements in programming languages are intrinsically linked to branch instructions in assembler. The first language to use something akin to the modern form of the if statement was likely Fortran I which used an if statement as a form of three-way goto statement.\n\nIF (E) L1, L2, L3\n\nThe expression, E is evaluated and one of the alternative paths of L1, L2, and L3 is chosen based on whether E is negative, zero or positive. This became known as the arithmetic if. This could be used to derive a three-way decision statement of the form:\n\nIF (X-Y) 10, 10, 30 10 MAXNUM = Y GO TO 20 30 MAXNUM = X 20 ...\n\nThis says that if X-Y is less than or equal to zero, then the maximum is Y, otherwise the maximum is X. This made sense in the context of unstructured jumps using go to. This allowed for a very limited decision structure, where the expression always had to be expressed in terms of some numeric output.\n\nIn 1957-58 John McCarthy, developer of Lisp, was writing a series of routines for legal chess moves in Fortran which prompted him to invent conditional expressions. He found the arithmetic if construct from Fortran I and II “awkward to use” [McCarthy81], and found it more natural to invent a Fortran function XIF(M,N1,N2) whose value was N1 or N2 based on whether M was zero or not (it was written in machine language). The function was likely not that efficient, as it required all three arguments to be evaluated before XIF() was entered. In Lisp, the conditional took the form of the cond function:\n\n(cond (condition1 result1) (condition2 result2) ... (T resultN))\n\nLater a more “traditional” like conditional operator was included into the specifications for Lisp, and appeared as follows:\n\nX = IF (N .EQ. 0, ICAR(Y), ICDR(Y))\n\nMcCarthy suggested the use of this concept in Algol 58 when he was a member of the Algol committee. In the Algol 58 preliminary report the if statement took the form:\n\nif (a>0); c:=a↑2↓×b↑2↓ if (a<0); c:=a↑2↓+b↑2↓ if (a=0); go to bed\n\nAlgol 58 did not really progress much, and was superseded by Algol 60. Algol 60 added the keyword then, to separate the logical expression from the statement to be executed. many considered this if-then combination to make the statement more readable. The Algol statement was also extended to include an “else” part. Here is an example of an if-then-else in Algol 60.\n\nif x > 0 then pos := pos + 1 else negzero := negzero + 1\n\nThis lead to the ambiguity we know today as the “dangling-else”. Whereas a statement such as:\n\nif x=0 then if y=0 then m:=m+1\n\nis not ambiguous, the following statement could be:\n\nif x=0 then if y=0 then m:=m+1 else n:=n-1\n\nIs 1 to be subtracted from n when x is non-zero, whatever the value of y, OR when x is zero but y is not? A conundrum.\n\nTo further add to the structural space, these if statements were constrained to the control of a single statement, which limited their usefulness. Algol 60 dealt with this through the use of the compound statement it had introduced using the keywords begin and end. For example, a piece of code to swap two numbers if x < y:\n\nif x<y then begin dummy:=x; x:=y; y:=dummy end\n\nOr, written in a more readable manner (many early languages crammed as much as they could on one line – blame punch-cards):\n\nif x<y then begin dummy:=x; x:=y; y:=dummy end\n\nThis structure could also be used to reduce the dangling-else problem:\n\nif x=0 then begin if y=0 then m:=m+1 else n:=n-1 end\n\nREF(S):\n\n[McCarthy81] McCarthy, J., “LISP Session”, History of Programming Languages, pp.173-197, ACM (1981)"
    }
}