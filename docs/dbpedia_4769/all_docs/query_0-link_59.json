{
    "id": "dbpedia_4769_0",
    "rank": 59,
    "data": {
        "url": "http://www.math.bas.bg/bantchev/place/algol68.html",
        "read_more_link": "",
        "language": "en",
        "title": "Algol 68",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "The language was created in the late 1960's by an international group of computer scientists, and revised in 1974. Apparently, the purpose was to create âa better Algolâ. The result, however, turned to be a rather different language compared to Algol 60, with many new features added, and much more universal in use. In most respects Algol 68 is a rather advanced programming language even by the standards of today.\n\nThe authors of Algol 68 formulated and consistently applied the principle of orthogonality. From the Revised Report (see below): âThe number of independent primitive concepts has been minimised in order that the language is easy to describe, to learn, and to implement. On the other hand, these concepts have been applied âorthogonallyâ in order to maximise the expressive power of the language while trying to avoid deleterious superfluities.â\n\nBesides orthogonality, the design of Algol 68 aimed at completeness and clarity of definition, security, and efficiency of execution. The language seemed to be secure enough to attract the attention of defence-related organisations. Efficiency was ensured by static type checking and loop optimization, among others.\n\nHere are some important features of the language. Many of them were introduced precisely by Algol 68.\n\nThe language is expression-oriented. In particular, a block of code yields the value of the last expression it evaluates and can be used in any context where a value of the corresponding type is expected.\n\nCompound statements are terminated each by a distinctive closing bracket. Thus there is no dangling-else problem, if statements can have multiple parts, and there is no need for embedding begin-ends within control constructs solely for grouping.\n\nValues can be dynamically allocated with global or local visibility (heap/stack allocation). The type of allocation is explicitly stated. Allocated values can be initialized or left unspecified, regardless of naming them or leaving them anonymous.\n\nMemory management is automatic, with garbage-collecting.\n\nCompound assignments (called assignment operators); unlike C, can be sequenced, as in a +:= b *:= c which does a := (a+b)*c.\n\nA multiplicity of numeric types is available, such as int, long int, long long int etc., including complex. The value range of the numeric types is not defined by the language (like in C later, and unlike Java).\n\nType coercions and type casts are possible.\n\nThe type system includes array, record, union, and procedure types. (Types are called modes in Algol 68âs terminology.) Program-specific datatypes can be defined using these constructors.\n\nProcedures are typed by the types of their arguments and result. The void descriptor is introduced for the type of procedures that do not return results.\n\nThe notion of reference (as opposed to machine pointer) is cleanly, abstractly and very generally defined. The references (called names in the language) are typed. Both data aggregation and datatype construction make solid use of references.\n\nTypes can be specified through composition, using type expressions with reference, array, record, union, and procedure denotations as âoperatorsâ.\n\nThe language is strongly typed. For example, the variants of a union type are safely discriminated by use of conformity clauses, and there is no way to confuse one variant with another.\n\nIt should be stressed that, in fact, Algol 68 was the language to introduce a rich, static type system to programming. The very notion of type did not receive much attention before that. All above mentioned features of Algol 68âs type system are now ubiquitous, but they were unknown at the time the language was created.\n\nIt is also worth noting that type- (mode-) denoting expressions in Algol 68 read strictly from left to right; no precedence rules are involved, unlike C, whose type expressions are notorious for bad readability. For example, [] proc (ref flex [] int) struct(compl z,w) is âan array of procedures, for each of which the argument is a reference to a flexibe array of integers and the result is a structure of two complex numbers named z and wâ. D, a recent C-like language, has its type expressions straightened in the manner of Algol 68.\n\nArrays can be dynamic: the declaration of an array's size may depend on values only known at run-time.\n\nArrays can be flexible: ones that can change their size. Any array, of the flexible kind or not, can be empty along any of its dimensions.\n\nArrays and structures can be immediately specified, anonymous values.\n\nWhole-array operations, and operations on array slices and trims are possible. Arrays, slices and trims are âfirst-classâ values and (as any other value) can be assigned, copied, read and written in I/O operations, passed as arguments to and returned by procedures.\n\n(Slices can be made along any of the directions of an array. Thus, e.g., references to both rows or columns of matrices can be formed.)\n\nProcedures are values. Thus, anonymous procedures can be created, put in data structures, passed as arguments or returned by procedures, and given names. Blocks of code could be passed as procedure-value arguments to procedures.\n\nOperators can be overloaded. New symbols can be defined as operators, each one along with its own precedence level of application.\n\nDeclarations can appear anywhere within a respective compound statement.\n\nSpace characters are permitted within names, thus neither underscores nor âcamel-casingâ is needed to form multi-part mnemonic names.\n\nWithin blocks, there can be the so called âcollateralâ execution of statements, meaning that the order of execution is non-determined, and the corresponding statements can even be executed in parallel.\n\nA simple model of concurrency is provided, with semaphores for synchronization.\n\nThe I/O (a.k.a. transput) system is rather sophisticated. Callbacks can be associated to various transput events in a file-wise manner. There are standard input and output channels. Transput channels can be connected to strings.\n\nThere are âstandard environmentâ and âstandard preludeâ, including, in particular, the transput. It was this development that reflected back on the earlier language, Algol 60, by including a definition of âenvironmental blockâ in the Modified Report on Algol 60.\n\nDespite its many attractive features, Algol 68 never was a widespread language. There are several reasons for that. One of them is that the language had the fame of being exceedingly complex, which was not really true, by any measure. On the other hand, it is true that the language definition was very complex. The defining document used an intricate formal grammar and unusual terminology, and consequently was hard to read. The grammar was so powerful, however, that large part of what in other languages is regarded as ‘semantics’ was subsumed by the syntax rules.\n\nAlgol 68 has had a significant influence on the definition of C and other languages of today.\n\nI am curious whether it itself was influenced by CPL â the levels and directions of sophistication of the two languages are remarkably similar.\n\nLinks of Relevance\n\nRevised Report on the Algorithmic Language ALGOLÂ 68 (scanned); a flat, better rendered HTML copy â verbatim from this archive\n\nInformal introduction to AlgolÂ 68, revised edition (C.H.Â Lindsey and S. G.Â vanÂ derÂ Meulen, 1977)\n\nProgramming AlgolÂ 68 made easy: a textbook; a more compact PDF form that I produced myself from the book sources\n\nA tutorial on AlgolÂ 68 (A.S.Â Tanenbaum, 1976). Corrigenda\n\nALGOL 68 with fewer tears, a tutorial (C.H.Â Lindsey, 1972)\n\nAlgolÂ 68Â Genie: an interpreter for AlgolÂ 68\n\nLearning AlgolÂ 68Â Genie: an informal introduction to the language, a manual for AlgolÂ 68Â Genie, and the Revised Report, all in one book\n\nA68toC: an AlgolÂ 68 to C translator; includes the sources for Programming AlgolÂ 68 made easy\n\nLinks to Algol 68 resources\n\nboykobbatgmaildotcom"
    }
}