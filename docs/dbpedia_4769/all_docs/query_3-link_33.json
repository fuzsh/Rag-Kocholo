{
    "id": "dbpedia_4769_3",
    "rank": 33,
    "data": {
        "url": "https://craftofcoding.wordpress.com/2017/03/page/3/",
        "read_more_link": "",
        "language": "en",
        "title": "March 2017 – Page 3 – The Craft of Coding",
        "top_image": "https://s0.wp.com/i/blank.jpg",
        "meta_img": "https://s0.wp.com/i/blank.jpg",
        "images": [
            "https://upload.wikimedia.org/wikipedia/commons/8/8f/SAC_Automated_C2_system_GAO_16-468.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://s2.wp.com/i/logo/wpcom-gray-white.png",
            "https://pixel.wp.com/b.gif?v=noscript"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2017-03-06T13:20:25+00:00",
        "summary": "",
        "meta_description": "6 posts published by spqr during March 2017",
        "meta_lang": "en",
        "meta_favicon": "https://s1.wp.com/i/favicon.ico",
        "meta_site_name": "The Craft of Coding",
        "canonical_link": null,
        "text": "People complain about old languages, usually before they even take a deeper look at them. Sure, some are “interesting”, to say the least. Go and read one of the language definitions from the 1960s, they are real eye-openers. Some of the language is quite interesting. Take Algol 68 for instance. Here’s a simple piece of code to calculate Fibonacci numbers:\n\nCOMMENT Algol 68 program to calculate the Sieve of Eratosthenes for some upper limit N COMMENT PROC eratosthenes = (INT n) []INT: ( [n]INT sieve; FOR i TO UPB sieve DO sieve[i] := i OD; INT k = ENTIER sqrt(n); sieve[1] := 0; FOR i FROM 2 TO k DO IF sieve[i] NE 0 THEN FOR j FROM i*i BY i TO n DO sieve[j] := 0 OD FI OD; sieve ); INT n; print(\"Upper limit to calculate sieve? \"); read(n); print((eratosthenes(n), newline))\n\nIf you are only use to looking at C-like code, this might look somewhat obscure, and it does get worse. But to programmers of the time, it probably seemed quite fine. Maybe we have become too complacent.\n\nThe ALGOL (ALGOrithmic Language) series of languages were developed in the mid 1950s, with the first family member, ALGOL58 appearing in 1958. These languages greatly influenced the languages which evolved after them, and became the de facto way of describing algorithms in textbooks of the era. Algol introduced the notion of code blocks, using the keyword pairs begin and end for delimiting the blocks. There were three major specifications:\n\nALGOL 58 – originally called IAL (International Algorithmic Language)\n\nALGOL 60 – first implemented in 1960, revised in 1963.\n\nALGOL 68 – revised 1973. Introduced flexible arrays, slices, parallelism, operator identification.\n\nAlgol W, designed by Niklaus Wirth before moving on to Pascal, was based on Algol 60.\n\nAlgol68, as its name suggests was released in 1968, seemingly, an extension to Algol (ALGOrithmic Language) but in reality a completely different language. But what did the family of Algol’s *do* for programming? Well, the Algol’s contributed significantly to the field of programming language design.\n\nFormalized the concept or type.\n\nNames could have any length.\n\nArrays could have any number of constructs.\n\nParameters were separated by mode (in & out)\n\nSubscripts were placed in brackets.\n\nIntroduced compound statements.\n\nUsed the semicolon as the statement separator.\n\nAssignment operator was :=\n\nThe if statement included an else-if clause.\n\nAlgol 58 introduced into programming languages such terms as type, formal versus actual parameter, declaration, identifier, for loop, switch, compound statement, and the begin end delimiters.\n\nAlgol-60 introduced:\n\nThe concept of block structure, i.e. local scope\n\nIncorporated two parameter passing methods: pass-by-value, and pass-by-name\n\nProcedures were allowed to be recursive (new for a procedural language)\n\nStack dynamic arrays\n\nAlgol 60 introduced into programming languages such terms as block, call by value, call by name, typed procedures, declaration scope, dynamic arrays, side effects, local and global variables, until, while, if then else.\n\nAlgol-68 introduced:\n\nUser defined data structures\n\nReference types\n\nDynamic arrays\n\nSadly, the only real compiler left is Algol 68 Genie, available for many platforms. It’s fun to play around with, but obviously not really practical.\n\nSo you don’t think that legacy systems are real? Consider a report from the U.S. Government Accountability Office (GAO-16-696T), published in May 2016. They have a number of examples, of really *old* systems, but one really stand out. The first is “Strategic Automated Command and Control System” at US DoD. It coordinates the operational functions of the United States’ nuclear forces, and is 53 years old. It runs on a IBM Series/1 Computer which has 8″ floppy disk drives. Here’s what a Series/1 system looks like.\n\nOn a positive note, these machines are likely not hackable, as they probably aren’t connected to the net. Also to take into consideration, that “modernizing” these systems can be fraught with problems such as poor software design. Then there is also which language? So Cobol is too old at nearly 60 years? What about C, it’s 45? Java, it’s a young 22, but isn’t exactly designed for business transactions like Cobol is. Now, of course the ultimate catch-22 is the hardware-software interdependence. Replacing old hardware means upgrading software… or vice-versa. Maybe easier to just keep the old system, which has 99.999% uptime running?\n\nThere was a time when people learned to program in more than one language. That’s because books on programming were designed around the core tenets of programming, rather than the syntax of specific languages. Nowadays, books are usually along the lines of “Learning to program in X”, where X can be any language. This is okay, but in reality its not optimal. Why? Because so many “core” languages these days are derived from C: C, C++, Java, Objective C, Swift etc. There may be subtle differences, but the underlying structure is the same. If you learned to program in the 1970s and 80s, then likely the first language learned was Pascal, followed by C, Fortran, Cobol, and Ada. There were really no scripting languages, so instead you learned about their fore-bearers: awk, sed, and the shell languages of Unix. But there-in there was also less emphasis on “software” type issues – they only really arrived in the late 1980s, and to be honest I don’t really know if learning about waterfall models did a lot for anyone (and we can thank OO for making the whole system more complicated).\n\nThere is a school of thought (likely outdated, but who knows) that says that given a structure such as an if statement, it is possible to learn 2-3 languages at the came time. In fact you should be learning about a structure and *how* it can be used in the context of building a program. Far too much time is spent on grappling with language-specific concepts, and students getting bogged down in a singular language. But then again, maybe languages used to introduce programming are too complex these days?\n\nI don’t like AI much. Every second news article in the CS community these days seems to be about AI, and how it will “revolutionize the world”. Will it? Do we need the world revolutionized? I mean we’ve had over a century of far-reaching changes, and frankly not all of them have worked out well (atomic energy anyone?). Then there are things we tried to do, but then just ended up procrastinating. Humans landed on the moon for the first time in 1969, and for the last time in 1972. In over 40 years we haven’t been back. Now we have forsaken the moon for a bigger prize – Mars (and beyond). Sound familiar? Humans have a habit of believing that incredible inventions will make life better. In the 1950s it was atomic power. A 1955 article from Modern Mechanix, “Atomic Planes Are Closer Than You Think“, discussed the virtue of atomic planes, and predicted “high-payload atom-powered jet flying-boats within the next five to ten years”. It never happened, and for that we can likely be thankful. I mean they were talking about atomic trains and cars as well. Stupid. Do we really think AI will work out well? Likely not so much. I mean we are still running programs written in languages that are nearing 60 years of age. Computing has not reached maturity, and we are talking about trying to replicate the human mind? We can’t even predict the weather properly. The problem with AI is that it lacks the ability to understand much less answer the questions we want it to answer. Sure it can answer things like “What was the capital city of Denmark in 1692?”, but it’s the deeper questions it may never be able to answer. For example:\n\n“I’m thinking of vacationing in Sweden this year, what do you think?”\n\n“What do you think makes this game pie taste so good?”\n\n“Which flower smells the best?”\n\nWho’s the funniest comedian?\n\nAnswering Q1 requires knowledge of having visited Sweden – not just information based on data retrieved from things like customer reviews. Sure, an AI could tell you what the most popular tourist attractions are, when it is best to visit, what sort of food could be eaten, but it can’t tell you what it experienced… because it never experienced anything. Answering Q2 relies in part knowing what the ingredients are and how the game pie is cooked. But it ultimately relies on a sense of taste (and smell). Computers can’t taste – salt, sweet, sour, bitter, and umami, and as such they could never answer such a question. Question 3 has similar problems. Yes, there have been breakthroughs in creating olfactory sensors, but an AI could never answer which flower smells the best, because there is no answer to this – it is a very subjective question.\n\nFinally Q4. Do computers understand humour? No. Again, it’s subjective. Some people find a comedian funny, others don’t. AI’s may be good at answering questions for which there is a definitive answer, or searching through vast amounts of data to find something, tasks humans would not do as efficiently, or as fast. But answering questions that requires subjective opinion. Not likely. Besides which humans have other non-verbal characteristics that help observers make decisions. You can tell if someone doesn’t like a game pie, just by their body language… even if they say they do. An AI might be good at answering questions like this:\n\nWhat is the best route from Montreal to Ottawa?\n\nWhere can I find Danish Esrom cheese in Toronto?\n\nWhere is Waldo?\n\nThese questions are capable of being answered because they rely on data being analyzed. Of course even Q2 might be challenging, because it’s not as easy as just finding a cheese shop. Maybe there are no cheese shops in Toronto which carry Danish cheese, or the data on what cheeses a shop carries may not be available. Nothing is as simple as it seems.\n\nMaybe, just maybe we should concentrate on doing what we curretly do properly before moving on to “shinier things”.\n\nNow to call savgol() from Julia requires some information, namely what the interface to the subroutine looks like. The Fortran 90 code for the subroutine header looks something like this:\n\nsubroutine savgol(c,np,nl,nr,ld,m) integer ld,m,nl,np,nr real c(np)\n\nIt specifies 6 parameters, the first of which is an array of real numbers, and the remaining five of which are integer‘s. The variable c returns an array of coefficients (to be used for further processing). So the trick is to associate the parameters in savgol() with their associated input values in ccall(). This is what the call the ccall() looks like:\n\nccall((:savgol_, \"SG.so\"), Int32, (Ptr{Cfloat},Ptr{Cint}, Ptr{Cint},Ptr{Cint},Ptr{Cint},Ptr{Cint}), c, &d, &nl, &nr, &0, &m)\n\nRecall that a call to ccall() has four arguments:\n\nA “function” – library pair. This is savgol_ and “SG.so”.\n\nA return type – Int32 in this case, but the subroutine does not return anything.\n\nA tuple of input values. In this case Ptr{Float}, etc.\n\nThe arguments actually passed to savgol().\n\nNote that unlike C, all Fortran arguments must be passed by reference, hence the use of Ptr{} on all the arguments. The tricky part was again linking the datatypes, but this really just means tracing the required Julia type which can be found here. The Fortran integer type meshes well with Cint, and the Fortran real type associates with Julia’s Cfloat.\n\nThere is a cornucopia of existing libraries out there in Fortran, especially for math… why not use them?"
    }
}