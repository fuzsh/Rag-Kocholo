{
    "id": "wrong_mix_domainrange_foundationPlace_00127_1",
    "rank": 85,
    "data": {
        "url": "https://arxiv.org/html/2403.04440v1",
        "read_more_link": "",
        "language": "en",
        "title": "RoboKube: Establishing a New Foundation for the Cloud Native Evolution in Robotics",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://arxiv.org/html/extracted/5455181/fig-common-platform.png",
            "https://arxiv.org/html/x1.png",
            "https://arxiv.org/html/x2.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            "RoboKube",
            "cloud native",
            "Kubernetes",
            "ROS"
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "License: arXiv.org perpetual non-exclusive license\n\narXiv:2403.04440v1 [cs.RO] 07 Mar 2024\n\nRoboKube: Establishing a New Foundation for the Cloud Native Evolution in Robotics\n\n1st Yu Liu 2nd Aitor Hernandez Herranz 3rd Roberto C. Sundin\n\nAbstract\n\nCloud native technologies have been observed to expand into the realm of Internet of Things (IoT) and Cyber-physical Systems, of which an important application domain is robotics. In this paper, we review the cloudification practice in the robotics domain from both literature and industrial perspectives. We propose RoboKube, an adaptive framework that is based on the Kubernetes (K8s) ecosystem to set up a common platform across the device-cloud continuum for the deployment of cloudified Robotic Operating System (ROS) powered applications, to facilitate the cloud native evolution in robotics. We examine the process of modernizing ROS applications using cloud-native technologies, focusing on both the platform and application perspectives. In addition, we address the challenges of networking setups for heterogeneous environments. This paper intends to serves as a guide for developers and researchers, offering insights into containerization strategies, ROS node distribution and clustering, and deployment options. To demonstrate the feasibility of our approach, we present a case study involving the cloudification of a teleoperation testbed.\n\nIndex Terms:\n\nRoboKube, cloud native, Kubernetes, ROS\n\nI Background\n\n© 2024 IEEE. Personal use of this material is permitted. Permission from IEEE must be obtained for all other uses, in any current or future media, including reprinting/republishing this material for advertising or promotional purposes, creating new collective works, for resale or redistribution to servers or lists, or reuse of any copyrighted component of this work in other works.\n\nCloud native evolution as defined by Cloud Native Computing Foundation (CNCF), is characterized by a shift from monolithic architectures to microservices, from manual deployment to continuous integration/continuous delivery (CI/CD), and from static infrastructure to dynamic, scalable, and resilient systems orchestrated by platforms like Kubernetes (K8s) [1]. The success of cloud-native practices in the cloud industry has been brought into the IoT and edge computing domains, represented by promising projects like K3s, MicroK8s, KubeEdge, Azure IoT Edge, and Edgenesis Shifu, etc.\n\nMeanwhile, Robotic Operating System (ROS), specifically ROS 2, is the robotic community’s answer to the demand for a modular, scalable, and reliable architecture to build robotic applications such as sensing, planning, mobility, and autonomy. ROS 2 offers quality of service for communications, real-time support, and enhanced security features, all of which are critical for industrial applications. The development and widespread adoption of ROS have significantly accelerated innovation in robotics, reducing the barrier to entry and fostering a global community of robotics developers [2].\n\nII Cloudification practice in ROS\n\nTo enrich the ROS ecosystem, the open-source robotics foundation (OSRF) has been releasing docker container images for different ROS distributions for years. This practice has gained popularity due to the inherent advantages of the container technology, such as encapsulation, environment consistency, and easier distribution of applications. However, the evolution towards cloudification, i.e., the integration of ROS with container orchestration platforms like K8s, has been relatively slow. This transition would mean leveraging cloud-native tools and principles to provide simplicity, reliability, scalability, and observability to ROS-based applications, creating a truly cloud-native robotics platform. We explain the state of the art of the cloudification practice in the academic and industrial ROS community in the following subsections.\n\nII-A Literature\n\nIntegrating robotics applications into the cloud stems from the “cloud robotics” concept. In [3], cloud robotics was perceived as an evolutionary step after networked robotics. Initial architectures for cloud-robot interaction were proposed. The potential advantages of cloud integration were initially touched, and the challenges in terms of computation, communication, and optimization were analyzed, albeit at a preliminary level. The survey in [4] reviewed a series of early studies that proposed architectural design of cloud-based robotic systems for dedicated applications, such as robot grasping [5] [6], path planning [7], and SLAM [8]. These early-stage attempts often fall short in scalability and extensibility, making them hardly be used as a generic framework in cloud-robot practice.\n\nWith the maturity of open-source projects in both robotic and cloud domain, ROS, container, and Kubernetes increasingly became the tools of choice for implementing cloud robotic applications. In [9], the authors proposed a cloud-based framework to provide cloud services to ROS-powered drone applications that are hosted on a Kubernetes cluster and exposed through URLs. In [10], the authors proposed a framework to enable locally deployed ROS nodes to exchange messages with ROS nodes in the Kubernetes cluster via rosbridge. In [11] [12], the authors developed an architecture to control the trajectory of ROS powered UAVs, and a model predictive controller is containerized and deployed on Kubernetes. Notably, all of these examples do not treat robots as part of the cluster, posing a significant challenge for robot-cloud communication.\n\nSeveral approaches have been proposed to address the communication challenge. Technically, they can be divided into two categories: proxy-based [13] and VPN based approaches [14] [15], of which two most promising projects are FogROS2 [16] and its successor FogROS2-SGC [17] proposed by UC Berkeley. Additionally, the authors of [18] propose to use Kubernetes to orchestrate ROS-based cooperative intelligent transport systems (C-ITS) where MQTT is adopted to facilitate communication among vehicles and cloud. The performance of these proprietary solutions under complicated network environment still needs further verification, apart from the deployment complexity.\n\nThe study in [19] advocated for leveraging Kubernetes and Docker to modularize ROS applications and standardize the application deployment procedures.\n\nII-B Industry\n\nFrom an industrial perspective, Canonical Ubuntu provided a series of blog posts to describe how to establish a ROS 2 talker and listener example in the Microk8s platform. This setup involves distributing multiple ROS 2 nodes across several machines in a local area network (LAN) [20]. Sony has also demonstrated the concept and architecture for integrating robotics into an edge cluster system . Preliminary implementation details have been revealed[21], with both ROS 1 and ROS 2 docker images shown to be deployed to a Vanilla Kubernetes cluster. RoboLaunch is a new startup which focuses on building a cloud robotics platform that offers end-to-end infrastructure and software stack to simplify development, simulation, and life-cycle management of robotics application. The cloud-based platform uses Kubernetes to orchestrate containerized ROS applications. A VPN is created among multiple clusters to enable cross-cluster communication and computation offloading. To date, this is still in the prototyping stage and not yet ready for production.\n\nIn conclusion, the exploration of incorporating ROS powered robotics applications to the Kubernetes platform has started in the industrial sector, but a mature, production-ready solution has yet to be seen. This paper aligns with the vision proposed in [19] and aims to provide a framework, namely RoboKube, that simplifies the setup of a dedicated orchestration platform for ROS powered robotic applications for research and production purpose. RoboKube enables cross-network deployment in complex network environments, eliminating the fundamental barrier in cloud-robot communication, which opens the door to advanced robot-cloud and robot-network [22] interactions.\n\nV Case study: RoboKube-powered teleoperation testbed\n\nIn this section, we demonstrate a case study of a teleoperation testbed that is set up using the proposed RoboKube framework. In the testbed, a Universal Robots UR5 robot arm can be teleoperated at a distance using a joystick. The architecture is illustrated in Figure 2.\n\nV-A Application overview\n\nThe high-level structure of the application can be seen in Figure 3, which depicts the ROS nodes and their communication through ROS topics. In each end of the graph, we have hardware connections: the joystick at the top of the graph, and the Universal Robots UR5 manipulator at the bottom. Continuing down the graph, we find servo_node, which is a node that relies on MoveIt to translate either joint or end-effector velocities into a corresponding desired joint position, which ultimately is handled by the forward_position_controller node that publishes to a topic handled by the UR5 reverse interface.\n\nIn this testbed, each ROS node can be distributed onto any Kubernetes node in the cluster apart from one exception: the joy node. This is due to that the joy node relies on USB hardware, namely, the joystick itself. While the UR5 itself also belongs to the hardware category, it is configured as a network device. Hence, the UR5 reverse interface can be placed anywhere in the cluster, just like any other ROS node.\n\nV-B Containerization and distribution of ROS nodes\n\nDuring the containerization process, the teleoperation application is split into two containers, the joystick container that is dedicated to running the joy node and the UR5 driver container that executes the servo_node and the forward_position_controller node. The splitting is due to that the joy node has to be deployed to the machine with physical joystick hardware while the other nodes can be distributed across the cluster as per the orchestrator’s runtime decision.\n\nContainerization of the application is done by a multi-stage build. Taking the joy node container for example, a two-stage build process is applied. In the first stage, ROS dependencies are installed, and the joy node application is built from source. After that, all the libraries that are required by the joy node as well as the associated libraries (i.e., libjoy_to_servo) are manually extracted with the “ldd” utility. In the second stage, a minimal ROS docker image, e.g., the ROS base image, is utilized as the base image for the application. The application executable and associated libraries, the previously extracted dependency libraries as well as the ROS stack libraries are copied from stage 1 to this stage. In this way, the joy node gets a qualified running environment with all necessary dependencies while keeping the footprint of the container image relatively small. The achieved image is further shrunken with the assistance of DockerSlim, which only keeps the joy node binary and the dependencies that are used during the node execution. All other components including system utilities, shell, unused system libraries, and other redundant have been removed from the image. In the end, the image size is reduced by 82% from 486 MB to 83 MB, lowering the footprint to a great extent. The same approach can be applied to the UR5 driver container, of which the image merely accounts for 300 MB compared to the original size of 2.6 GB.\n\nV-C Deployment\n\nAs mentioned in Section III, a Kubernetes cluster is created for the teleoperation testbed, with two Kubernetes nodes distributed in two different subnets for demonstration purpose. Deployment to the cluster is handled by Helm Chart which enables rolling update and rollback of the application. Additionally, some details are revealed as follows.\n\nV-C1 Device plugin\n\nwith the use of device plugins, a USB joystick controller connected to a node can be abstracted as a resource. Consequently, this resource can be allocated to pods using the ”requests” and ”limits” specifications, as shown below.\n\nresources:\n\nlimits:\n\nsquat.ai/joystick: 1\n\nIn this way, the joy node container can only be deployed to a node with a joystick connected, making the scheduling hardware dependent.\n\nV-C2 Ingress\n\nAs the UR5 driver launches, it will listen on port 50001 and 50002 , waiting for the robot to get connected. Due to the default limit in Kubernetes that NodePort can only be assigned within the range 30000-32767, Ingress (e.g., Traefik Ingress) becomes a more suited solution to open the needed ports.\n\nThe teleoperation testbed can be cloudified and deployed to the RoboKube orchestration platform, which is able to function in a WAN network. The deployment and upgrade can be achieved in one step with Helm Chart while all components can be freely migrated in any K8s nodes except the joystick node. This case study demonstrate how the proposed RoboKube framework can be utilized in research and production environment.\n\nVI Concluding remarks\n\nAs cloud technologies mature and expand from the cloud industry into the IoT and CPS domain, it is observed that the integration of robotics applications into cloud has started in the research community, but it is far from attaining widespread use in industrial practice. This paper bring outs RoboKube, a (work-in-progress) framework that intends to bridge the gap and facilitate the integration between cloud technologies and the ROS ecosystem. It provides comprehensive solution to create a Kubernetes based platform for cloudified ROS applications, with an emphasis on the network setup to enable deployment in heterogeneous network environments that can include wireless and cellular networks. It also aims to give guidance on the best practices of containerization approach and deployment solutions, as well as the factors to be considered when distributing and clustering ROS nodes. The paper aims to make the cloudification of ROS-powered applications an achievable reality so as to accelerate the cloud native evolution in robotics.\n\nReferences\n\n[1] CNCF, “CNCF cloud native definition v1.0,” 2018. [Online]. Available: https://github.com/cncf/toc/blob/main/DEFINITION.md\n\n[2] S. Macenski, T. Foote, B. Gerkey, C. Lalancette, and W. Woodall, “Robot operating system 2: Design, architecture, and uses in the wild,” Science Robotics, vol. 7, no. 66, may 2022.\n\n[3] G. Hu, W. P. Tay, and Y. Wen, “Cloud robotics: architecture, challenges and applications,” IEEE Network, vol. 26, no. 3, pp. 21–28, 2012.\n\n[4] B. Kehoe, S. Patil, P. Abbeel, and K. Goldberg, “A survey of research on cloud robotics and automation,” IEEE Transactions on Automation Science and Engineering, vol. 12, no. 2, pp. 398–409, 2015.\n\n[5] A. Sorokin, D. Berenson, S. S. Srinivasa, and M. Hebert, “People helping robots helping people: Crowdsourcing for grasping novel objects,” in 2010 IEEE/RSJ International Conference on Intelligent Robots and Systems, 2010, pp. 2117–2122.\n\n[6] B. Kehoe, A. Matsukawa, S. Candido, J. Kuffner, and K. Goldberg, “Cloud-based robot grasping with the google object recognition engine,” in 2013 IEEE International Conference on Robotics and Automation, 2013, pp. 4263–4270.\n\n[7] D. Berenson, P. Abbeel, and K. Goldberg, “A robot path planning framework that learns from experience,” in 2012 IEEE International Conference on Robotics and Automation, 2012, pp. 3671–3678.\n\n[8] L. Riazuelo, M. Tenorth, D. Di Marco, M. Salas, D. Gálvez-López, L. Mösenlechner, L. Kunze, M. Beetz, J. D. Tardós, L. Montano, and J. M. M. Montiel, “Roboearth semantic mapping: A cloud enabled knowledge-based approach,” IEEE Transactions on Automation Science and Engineering, vol. 12, no. 2, pp. 432–443, 2015.\n\n[9] G. Mehrooz, E. Ebeid, and P. Schneider-Kamp, “System design of an open-source cloud-based framework for internet of drones application,” in 2019 22nd Euromicro Conference on Digital System Design (DSD), 2019, pp. 572–579.\n\n[10] B. Xu and J. Bian, “A cloud robotic application platform design based on the microservices architecture,” in Proceedings of the 2020 1st International Conference on Control, Robotics and Intelligent System, ser. CCRIS ’20. New York, NY, USA: Association for Computing Machinery, 2021, p. 13–18.\n\n[11] A. S. Seisa, S. G. Satpute, and G. Nikolakopoulos, “A kubernetes-based edge architecture for controlling the trajectory of a resource-constrained aerial robot by enabling model predictive control,” in 2022 26th International Conference on Circuits, Systems, Communications and Computers (CSCC), 2022, pp. 290–295.\n\n[12] A. Santi Seisa, S. Gajanan Satpute, and G. Nikolakopoulos, “Comparison between docker and kubernetes based edge architectures for enabling remote model predictive control for aerial robots,” in IECON 2022 – 48th Annual Conference of the IEEE Industrial Electronics Society, 2022, pp. 1–6.\n\n[13] A. B. M. Pereira and G. S. Bastos, “Rosremote, using ros on cloud to access robots remotely,” in 2017 18th International Conference on Advanced Robotics (ICAR), 2017, pp. 284–289.\n\n[14] J. Z. Lim and D. W.-K. Ng, “Cloud based implementation of ros through vpn,” in 2019 7th International Conference on Smart Computing & Communications (ICSCC), 2019, pp. 1–5.\n\n[15] G. Damigos, T. Lindgren, and G. Nikolakopoulos, “Toward 5g edge computing for enabling autonomous aerial vehicles,” IEEE Access, vol. 11, pp. 3926–3941, 2023.\n\n[16] J. Ichnowski, K. Chen, K. Dharmarajan, S. Adebola, M. Danielczuk, V. Mayoral-Vilches, N. Jha, H. Zhan, E. LLontop, D. Xu, C. Buscaron, J. Kubiatowicz, I. Stoica, J. Gonzalez, and K. Goldberg, “Fogros2: An adaptive platform for cloud and fog robotics using ros 2,” 2023.\n\n[17] K. Chen, R. Hoque, K. Dharmarajan, E. LLontop, S. Adebola, J. Ichnowski, J. Kubiatowicz, and K. Goldberg, “Fogros2-sgc: A ros2 cloud robotics platform for secure global connectivity,” 2023.\n\n[18] B. Lampe, L. Reiher, L. Zanger, T. Woopen, R. van Kempen, and L. Eckstein, “RobotKube: Orchestrating large-scale cooperative multi-robot systems with kubernetes and ros,” 2023.\n\n[19] F. Lumpp, M. Panato, F. Fummi, and N. Bombieri, “A container-based design methodology for robotic applications on kubernetes edge-cloud architectures,” in 2021 Forum on specification & Design Languages (FDL), 2021, pp. 01–08.\n\n[20] “ROS 2 and Kubernetes basics,” 2020. [Online]. Available: https://ubuntu.com/blog/exploring-ros-2-with-kubernetes\n\n[21] F. Tomoya and G. Feng, “Kubernetes robotics edge cluster system,” 2021. [Online]. Available: https://www.youtube.com/watch?v=rqyLd_AhXak\n\n[22] L. Yu and H. H. Aitor, “Enabling 5g qos configuration capabilities for iot applications on container orchestration platform,” in 2023 IEEE International Conference on Cloud Computing Technology and Science (CloudCom), 2023."
    }
}