{
    "id": "dbpedia_4551_3",
    "rank": 31,
    "data": {
        "url": "https://www.grc.com/sn/sn-181.htm",
        "read_more_link": "",
        "language": "en",
        "title": "Security Now! Transcript of Episode #181",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.grc.com/image/transpixel.gif",
            "https://www.grc.com/image/snsmall.gif",
            "https://www.grc.com/image/sn_security.gif",
            "https://www.grc.com/image/sn_now.gif",
            "https://www.grc.com/image/snsmall.gif",
            "https://www.grc.com/image/transpixel.gif",
            "https://www.grc.com/image/transpixel.gif",
            "https://www.grc.com/image/fade.gif",
            "https://www.grc.com/image/transpixel.gif",
            "https://www.grc.com/image/darkredpixel.gif",
            "https://www.grc.com/image/transpixel.gif",
            "https://www.grctech.com/_mlayxwinoexzf_/image/grc-icon.gif",
            "https://www.grctech.com/_mlayxwinoexzf_/image/jumptotop.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Steve Gibson",
            "GIBSON RESEARCH CORPORATION"
        ],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Steve: I would say over the last four, or three and a half years, we've touched on the topic often because it's, I think, certainly it's interesting. And we rely on it constantly. What we're going to do in several episodes from now is go over in detail, I mean, literally the packet-by-packet operation of the SSL protocol. SSL is - we've talked about it many times - Secure Socket Layer. We've talked about asymmetric encryption, symmetric encryption. We've talked about recently, of course, digital certificates and certificate signing and the recent exploits against the MD5 hash and how that has affected the integrity of SSL. But there is no protocol, no security protocol that any of us use more than SSL. What we've never done is look at exactly how it works. How does it provide these features that we all, to varying degrees, take for granted? So I wanted to do that.\n\nBut before we do that, we need to lay a little bit more foundation. And before that I thought, you know, I see people who are - who send notes saying, wow, you know, I had to read the transcripts of that episode three times and, like, slowly, and repeat it to myself in order to understand what you guys were talking about. So I thought - and because, as you mentioned, Leo, we've had so many discussions about various aspects of security, and frankly very little repetition among them, I thought this would be a nice time, before we go any further, to just sort of have a little bit of a timeout and say, okay, hold on, let's step back from the minutiae and from the detail and do sort of a review of the major concepts and components of this that we've talked about over the last three and a half years.\n\nSteve: Well, yes. And the other example at the other end of this connection is we keep hearing how remote facilities, whether they're, for example, Network Solutions we heard about the other day, and other sorts of attacks at the remote end, like loss of confidential security information. We hear about how that information is getting away. Well, once again, it may have been absolutely secure and authenticated, and we had a fantastic experience hooking up to our banking site, and nobody was able to get the data as it was going from us to there. But unfortunately, it then sits there on some database on the banking servers, where it's vulnerable. So, again, in talking about what it is we're trying to protect, we need to delineate what it is, what the threat model is, and exactly what it is we're hoping to achieve.\n\nWe also make some assumptions. We make, for example, one assumption is that there is non-infinite computational power. That is, that there are not literally infinite resources that can be applied. Because all of the crypto that we've been talking about, for example, every single one of these things we've been talking about is subject to brute-force attack. No matter how long the key is, even though 128 bits or 256 bits, that's a lot of combinations, that's two raised to that power combinations. Well, it's not infinite. It's still a number that we're able to write down. And if we had time, we could test them all. One of them is the right combination of bits. One of them decrypts this. It makes you even feel a little uncomfortable to say that. It's like, wait a minute, you mean there's an answer to - there's a way to crack this encryption. Yes. It's you try all the combinations. But the point is, we've made it so difficult, there are so many combinations, that you can't, it's not feasible in a reasonable amount of time to try them all. But it's always worth remembering that it's not perfect security. It's just really, really, really, really, really good.\n\nSteve: No, no. And then another thing about the design of a secure crypto system is you want there not to be any single point of failure. That is, you'd like to have, in a communication network of people communicating, you would - if one dialogue between two parties were to somehow be cracked, you would like all of the other dialogues between other groups of parties, even involving the same endpoints, to retain their security in the face of that crack. That is, for example, if the security only involved everybody using a single preshared key, a single static key, then that would be an example of a system not well designed because the disclosure of that single key would not only allow you to crack the dialogue that was your target, but all the other dialogues that were unfortunately sharing the same key.\n\nSo one of the other things that we've seen and that we will be talking about shortly in a couple weeks, is this notion of coming up with some key agreement somehow, but never actually using that key for your live encryption. Instead you'd always use derivative keys that have various limited lengths of life, so that you're not actually using the sort of like the root key that you originally came up with. And so if we assume that the endpoints are secure, that is, they've not been compromised because, as we said, keystroke loggers get in before the encryption, database compromise happens after this encryption, and so we're limiting ourselves to this notion of, okay, let's assume that we have control of each end, but we have no control at all of the link between, i.e., the Internet. So that means that our communication is subject to having bits dropped, bits added, bits changed, and even bits replayed, things, packets replayed. And so we need to also guard against this notion of an attacker somehow, like, redoing something.\n\nFor example, say that a communication link with a server involved transferring a chunk of money to PayPal. Well, we would like to prevent somebody recording that whole dialogue, even if they can't understand it, and replaying it to transfer the same amount of money again. So guarding against a replay attack in addition to the idea of injecting new traffic, modifying traffic, or dropping traffic is another aspect of what any truly secure protocol would be able to do.\n\nSo finally, let's step back a little bit and say, okay, what do we mean by security? Well, security in this context, in the context of this threat model, where we're wanting to protect communications between two endpoints over the Internet in the face of injection, dropped traffic, modified traffic, and replayed traffic, we want three things. We want confidentiality of our communication, that is, we want nobody, no matter what they do, no man in the middle, whether they're able to intercept the traffic and see everything we do, change it in any way, we want them to be absolutely the case that we're going to have...\n\nSteve: So what we want is we want confidentiality. We've looked at ways, well, okay, confidentiality. We also want to guard against the message that we're sending being modified. So we need to verify the message's integrity. And lastly, we also want to authenticate the endpoints. We want to make sure that at least one, maybe both, are who we think we're talking to. We talked about this with regard to phishing attacks often, and the Kaminsky attack against DNS that has you talking to a wrong server, to certificate problems. So we want no one to be able to hear what we're doing. We want no one to be able to change what we say. And we want to absolutely be sure we're talking to the endpoint we think.\n\nAnd so if you think about it, all of that is implicit in real-world communications, in the Opie and Aunt Bee Mayberry scenario. In this case, confidentiality in that example isn't required. But the other things that we take for granted about a physical real-world communication are present. And so what we're really trying to do is we're trying to extend that model across the Internet. With regard to confidentiality, we have talked in the past about encryption, the notion of using - of symmetric encryption, where we share some sort of a key, and we use the same key at each end, thus the symmetry, to encrypt and decrypt.\n\nWe've talked about asymmetric encryption, also known as public key encryption, because in the general case we're normally keeping one key secret, the other key is private, although neither has to be the case, but that's normally the way it's used. And because asymmetric encryption is so computationally burdensome, we don't asymmetrically encrypt an entire long message. That would just take forever. Instead what we do is we choose a random symmetric key, and we use the asymmetric encryption just to encrypt it. That way that allows us to transport it to the other end, where the public key, or asymmetric encryption, is used to decrypt that. That creates a sort of a transient shared secret, a shared secret that is just going to be used for some length of time. We're able to get it to the other end, even in full view, by using public key encryption. Then it's used in order to symmetrically encrypt and decrypt our communication.\n\nAnd finally, key management is an aspect of confidentiality, whether we're using, as I just gave the example of using, public key encryption to encrypt a shared secret. There's another approach, which is known as \"key agreement,\" where it's possible for the ends to publicly disclose what they're sharing, yet maintain full confidentiality. So that someone, an attacker, can see a dialogue going back and forth in the air, essentially. Yet even so, someone watching it can't intercept or can't end up with the knowledge of the key which is agreed upon. So those are sort of the aspects of confidentiality, encryption and key management.\n\nThe next thing, the second of these three, of confidentiality, message modification prevention, and endpoint authentication, is this message integrity. We've talked about using hashes. Of course we've talked about MD5 a lot, the notion of creating a signature. And there are the SHA-1 hash, there are more modern hashes that use larger hashing results that are increasingly secure. So..."
    }
}