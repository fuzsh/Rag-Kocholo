{
    "id": "wrong_mix_range_subsidiary_00137_2",
    "rank": 61,
    "data": {
        "url": "https://python-oracledb.readthedocs.io/en/latest/user_guide/connection_handling.html",
        "read_more_link": "",
        "language": "en",
        "title": "4. Connecting to Oracle Database — python",
        "top_image": "",
        "meta_img": "",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "4.4.1. Creating a Connection Pool\n\nA connection pool is created by calling oracledb.create_pool(). Various pool options can be specified as described in create_pool() and detailed below.\n\nFor example, to create a pool that initially contains one connection but can grow up to five connections:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb\", min=1, max=5, increment=1)\n\nAfter the pool has been created, your application can get a connection from it by calling ConnectionPool.acquire():\n\nconnection = pool.acquire()\n\nThese connections can be used in the same way that Standalone Connections are used.\n\nBy default, acquire() calls wait for a connection to be available before returning to the application. A connection will be available if the pool currently has idle connections, when another user returns a connection to the pool, or after the pool grows. Waiting allows applications to be resilient to temporary spikes in connection load. Users may have to wait a brief time to get a connection but will not experience connection failures.\n\nYou can change the behavior of acquire() by setting the getmode option during pool creation. For example, the option can be set so that if all the connections are currently in use by the application, any additional acquire() call will return an error immediately.\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb\", min=2, max=5, increment=1, getmode=oracledb.POOL_GETMODE_NOWAIT)\n\nNote that when using this option value in Thick mode with Oracle Client libraries 12.2 or earlier, the acquire() call will still wait if the pool can grow. However, you will get an error immediately if the pool is at its maximum size. With newer Oracle Client libraries and with Thin mode, an error will be returned if the pool has to, or cannot, grow.\n\nWhen your application has finished performing all required database operations, the pooled connection should be released to make it available for other users of the pool. You can do this with ConnectionPool.release() or Connection.close(). Alternatively you may prefer to let pooled connections be closed implicitly at the end of scope. For example, by using a with statement:\n\nwith pool.acquire() as connection: with connection.cursor() as cursor: for result in cursor.execute(\"select * from mytab\"): print(result)\n\nAt application shutdown, the connection pool can be completely closed using ConnectionPool.close():\n\npool.close()\n\nTo force immediate pool termination when connections are still in use, execute:\n\npool.close(force=True)\n\nSee connection_pool.py for a runnable example of connection pooling.\n\nConnection Pool Growth\n\nAt pool creation, min connections are established to the database. When a pool needs to grow, new connections are created automatically limited by the max size. The pool max size restricts the number of application users that can do work in parallel on the database.\n\nThe number of connections opened by a pool can shown with the attribute. ConnectionPool.opened. The number of connections the application has obtained with acquire() can be shown with ConnectionPool.busy. The difference in values is the number of connections unused or ‘idle’ in the pool. These idle connections may be candidates for the pool to close, depending on the pool configuration.\n\nPool growth is normally initiated when acquire() is called and there are no idle connections in the pool that can be returned to the application. The number of new connections created internally will be the value of the create_pool() parameter increment.\n\nDepending on whether Thin or Thick mode is used and on the pool creation getmode value that is set, any acquire() call that initiates pool growth may wait until all increment new connections are internally opened. However, in this case the cost is amortized because later acquire() calls may not have to wait and can immediately return an available connection. Some users set larger increment values even for fixed-size pools because it can help a pool re-establish itself if all connections become invalid, for example after a network dropout. In the common case of Thin mode with the default getmode of POOL_GETMODE_WAIT, any acquire() call that initiates pool growth will return after the first new connection is created, regardless of how big increment is. The pool will then continue to re-establish connections in a background thread.\n\nA connection pool can shrink back to its minimum size min when connections opened by the pool are not used by the application. This frees up database resources while allowing pools to retain connections for active users. If connections are idle in the pool (i.e. not currently acquired by the application) and are unused for longer than the pool creation attribute timeout value, then they will be closed. The check occurs every timeout interval and hence in the worst case it may take twice the timeout time to close the idle connections. The default timeout is 0 seconds signifying an infinite time and meaning idle connections will never be closed.\n\nIn python-oracledb Thick mode, the pool creation parameter max_lifetime_session also allows pools to shrink. This parameter bounds the total length of time that a connection can exist starting from the time the pool created it. If a connection was created max_lifetime_session or longer seconds ago, then it will be closed when it is idle in the pool. In the case when timeout and max_lifetime_session are both set, the connection will be terminated if either the idle timeout happens or the max lifetime setting is exceeded. Note that when using python-oracledb in Thick mode with Oracle Client libraries prior to 21c, pool shrinkage is only initiated when the pool is accessed so pools in fully dormant applications will not shrink until the application is next used.\n\nFor pools created with external authentication, with homogeneous set to False, or when using Database Resident Connection Pooling (DRCP), then the number of connections opened at pool creation is zero even if a larger value is specified for min. Also, in these cases the pool increment unit is always 1 regardless of the value of increment.\n\nPool Connection Health\n\nBefore ConnectionPool.acquire() returns, python-oracledb does a lightweight check similar to Connection.is_healthy() to see if the network transport for the selected connection is still open. If it is not, then acquire() will clean up the connection and return a different one.\n\nThis check will not detect cases such as where the database session has been terminated by the DBA, or reached a database resource manager quota limit. To help in those cases, acquire() will also do a full round-trip database ping similar to Connection.ping() when it is about to return a connection that was idle in the pool (i.e. not acquired by the application) for ConnectionPool.ping_interval seconds. If the ping fails, the connection will be discarded and another one obtained before acquire() returns to the application. The ping_timeout parameter to oracledb.create_pool() limits the amount of time that any internal ping is allowed to take. If it is exceeded, perhaps due to a network hang, the connection is considered unusable and a different connection is returned to the application.\n\nBecause this full ping is time based and may not occur for each acquire(), the application may still get an unusable connection. Also, network timeouts and session termination may occur between the calls to acquire() and Cursor.execute(). To handle these cases, applications need to check for errors after each execute() and make application-specific decisions about retrying work if there was a connection failure. When using python-oracledb in Thick mode, Oracle Database features like Application Continuity can do this automatically in some cases.\n\nYou can explicitly initiate a full round-trip ping at any time with Connection.ping() to check connection liveness but the overuse will impact performance and scalability. To avoid pings hanging due to network errors, use Connection.call_timeout to limit the amount of time ping() is allowed to take.\n\nThe Connection.is_healthy() method is an alternative to Connection.ping(). It has lower overheads and may suit some uses, but it does not perform a full connection check.\n\nIf the getmode parameter in oracledb.create_pool() is set to oracledb.POOL_GETMODE_TIMEDWAIT, then the maxium amount of time an acquire() call will wait to get a connection from the pool is limited by the value of the ConnectionPool.wait_timeout parameter. A call that cannot be immediately satisfied will wait no longer than wait_timeout regardless of the value of ping_timeout.\n\nEnsure that the firewall, resource manager or user profile IDLE_TIME do not expire idle sessions, since this will require connections to be recreated which will impact performance and scalability.\n\nA pool’s internal connection re-establishment after lightweight and full pings can mask performance-impacting configuration issues such as firewalls terminating connections. You should monitor AWR reports for an unexpectedly large connection rate.\n\n4.4.4. Session Callbacks for Setting Pooled Connection State\n\nApplications can set “session” state in each connection. Examples of session state are NLS globalization settings from ALTER SESSION statements. Pooled connections will retain their session state after they have been released back to the pool. However, because pools can grow or connections in the pool can be recreated, there is no guarantee a subsequent acquire() call will return a database connection that has any particular state.\n\nThe create_pool() parameter session_callback enables efficient setting of session state so that connections have a known session state, without requiring that state to be explicitly set after every acquire() call. The callback is internally invoked when acquire() is called and runs first.\n\nThe session callback can be a Python function or a PL/SQL procedure.\n\nConnections can also be tagged when they are released back to the pool. The tag is a user-defined string that represents the session state of the connection. When acquiring connections, a particular tag can be requested. If a connection with that tag is available, it will be returned. If not, then another session will be returned. By comparing the actual and requested tags, applications can determine what exact state a session has, and make any necessary changes.\n\nConnection tagging and PL/SQL callbacks are only available in python-oracledb Thick mode. Python callbacks can be used in python-oracledb Thin and Thick modes.\n\nThere are three common scenarios for session_callback:\n\nWhen all connections in the pool should have the same state, use a Python callback without tagging.\n\nWhen connections in the pool require different state for different users, use a Python callback with tagging.\n\nWith Database Resident Connection Pooling (DRCP), use a PL/SQL callback with tagging.\n\n4.4.4.1. Python Callback\n\nIf the session_callback parameter is a Python procedure, it will be called whenever acquire() will return a newly created database connection that has not been used before. It is also called when connection tagging is being used and the requested tag is not identical to the tag in the connection returned by the pool.\n\nAn example is:\n\n# Set the NLS_DATE_FORMAT for a session def init_session(connection, requested_tag): with connection.cursor() as cursor: cursor.execute(\"alter session set nls_date_format = 'YYYY-MM-DD HH24:MI'\") # Create the pool with session callback defined pool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"localhost/orclpdb\", session_callback=init_session) # Acquire a connection from the pool (will always have the new date format) connection = pool.acquire()\n\nIf needed, the init_session() procedure is called internally before acquire() returns. It will not be called when previously used connections are returned from the pool. This means that the ALTER SESSION does not need to be executed after every acquire() call. This improves performance and scalability.\n\nIn this example tagging was not being used, so the requested_tag parameter is ignored.\n\nNote that if you need to execute multiple SQL statements in the callback, use an anonymous PL/SQL block to save round-trips of repeated execute() calls. With ALTER SESSION, pass multiple settings in the one statement:\n\ncursor.execute(\"\"\" begin execute immediate 'alter session set nls_date_format = ''YYYY-MM-DD'' nls_language = AMERICAN'; -- other SQL statements could be put here end;\"\"\")\n\n4.4.4.2. Connection Tagging\n\nConnection tagging is used when connections in a pool should have differing session states. In order to retrieve a connection with a desired state, the tag attribute in acquire() needs to be set.\n\nNote\n\nConnection tagging is only supported in the python-oracledb Thick mode. See Enabling python-oracledb Thick mode .\n\nWhen python-oracledb is using Oracle Client libraries 12.2 or later, then python-oracledb uses ‘multi-property tags’ and the tag string must be of the form of one or more “name=value” pairs separated by a semi-colon, for example \"loc=uk;lang=cy\".\n\nWhen a connection is requested with a given tag, and a connection with that tag is not present in the pool, then a new connection, or an existing connection with cleaned session state, will be chosen by the pool and the session callback procedure will be invoked. The callback can then set desired session state and update the connection’s tag. However, if the matchanytag parameter of acquire() is True, then any other tagged connection may be chosen by the pool and the callback procedure should parse the actual and requested tags to determine which bits of session state should be reset.\n\nThe example below demonstrates connection tagging:\n\ndef init_session(connection, requested_tag): if requested_tag == \"NLS_DATE_FORMAT=SIMPLE\": sql = \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD'\" elif requested_tag == \"NLS_DATE_FORMAT=FULL\": sql = \"ALTER SESSION SET NLS_DATE_FORMAT = 'YYYY-MM-DD HH24:MI'\" cursor = connection.cursor() cursor.execute(sql) connection.tag = requested_tag pool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"orclpdb\", session_callback=init_session) # Two connections with different session state: connection1 = pool.acquire(tag=\"NLS_DATE_FORMAT=SIMPLE\") connection2 = pool.acquire(tag=\"NLS_DATE_FORMAT=FULL\")\n\nSee session_callback.py for an example.\n\n4.4.4.3. PL/SQL Callback\n\nNote\n\nPL/SQL Callbacks are only supported in the python-oracledb Thick mode. See Enabling python-oracledb Thick mode.\n\nWhen python-oracledb uses Oracle Client 12.2 or later, the session callback can also be the name of a PL/SQL procedure. A PL/SQL callback will be initiated only when the tag currently associated with a connection does not match the tag that is requested. A PL/SQL callback is most useful when using Database Resident Connection Pooling (DRCP) because DRCP does not require a round-trip to invoke a PL/SQL session callback procedure.\n\nThe PL/SQL session callback should accept two VARCHAR2 arguments:\n\nPROCEDUREmyPlsqlCallback( requestedTagINVARCHAR2, actualTagINVARCHAR2 );\n\nThe logic in this procedure can parse the actual tag in the session that has been selected by the pool and compare it with the tag requested by the application. The procedure can then change any state required before the connection is returned to the application from acquire().\n\nIf the matchanytag attribute of acquire() is True, then a connection with any state may be chosen by the pool.\n\nOracle ‘multi-property tags’ must be used. The tag string must be of the form of one or more “name=value” pairs separated by a semi-colon, for example \"loc=uk;lang=cy\".\n\nIn python-oracledb set session_callback to the name of the PL/SQL procedure. For example:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb:pooled\", session_callback=\"MyPlsqlCallback\") connection = pool.acquire(tag=\"NLS_DATE_FORMAT=SIMPLE\", # DRCP options, if you are using DRCP cclass='MYCLASS', purity=oracledb.PURITY_SELF)\n\nSee session_callback_plsql.py for an example.\n\n4.5.2. Coding Applications to use DRCP\n\nTo use DRCP, application connection establishment must request a DRCP pooled server. The best practice is also to specify a user-chosen connection class name when creating a connection pool. A ‘purity’ of the connection session state can optionally be specified. See the Oracle Database documentation on benefiting from scalability for more information on purity and connection classes.\n\nRequesting a Pooled Server\n\nTo request a DRCP pooled server, you can:\n\nUse a specific connection string in oracledb.create_pool() or oracledb.connect(). For example with the Easy Connect syntax:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb:pooled\", min=2, max=5, increment=1, cclass=\"MYAPP\")\n\nAlternatively, add (SERVER=POOLED) to the connect descriptor such as used in an Oracle Network configuration file tnsnames.ora:\n\ncustomerpool = (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp) (HOST=dbhost.example.com) (PORT=1521))(CONNECT_DATA=(SERVICE_NAME=CUSTOMER) (SERVER=POOLED)))\n\nAnother way to use a DRCP pooled server is to set the server_type parameter during standalone connection creation or python-oracledb connection pool creation. For example:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb\", min=2, max=5, increment=1, server_type=\"pooled\", cclass=\"MYAPP\")\n\nDRCP Connection Class Names\n\nThe best practice is to specify a cclass class name when creating a python-oracledb connection pool. This user-chosen name provides some partitioning of DRCP session memory so reuse is limited to similar applications. It provides maximum pool sharing if multiple application processes are started. A class name also allows better DRCP usage tracking in the database. In the database monitoring views, the class name shown will be the value specified in the application prefixed with the user name.\n\nIf cclass was not specified during pool creation, then the python-oracledb Thin mode generates a unique connection class with the prefix “DPY” while the Thick mode generates a unique connection class with the prefix “OCI”.\n\nTo create a connection pool requesting a DRCP pooled server and specifying a class name, you can call:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb:pooled\", min=2, max=5, increment=1, cclass=\"MYAPP\")\n\nOnce the pool has been created, your application can get a connection from it by calling:\n\nconnection = pool.acquire()\n\nThe python-oracledb connection pool size does not need to match the DRCP pool size. The limit on overall execution parallelism is determined by the DRCP pool size.\n\nConnection class names can also be passed to acquire(), if you want to use a connection with a different class:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb:pooled\", min=2, max=5, increment=1, cclass=\"MYAPP\") connection = mypool.acquire(cclass=\"OTHERAPP\")\n\nIf a pooled server of a requested class is not available, a server with new session state is used. If the DRCP pool cannot grow, a server with a different class may be used and its session state cleared.\n\nIf cclass is not set, then the pooled server sessions will not be reused optimally, and the DRCP statistic views may record large values for NUM_MISSES.\n\nDRCP Connection Purity\n\nDRCP allows the connection session memory to be reused or cleaned each time a connection is acquired from the pool. The pool or connection creation purity parameter can be one of PURITY_NEW, PURITY_SELF, or PURITY_DEFAULT. The value PURITY_SELF allows reuse of both the pooled server process and session memory, giving maximum benefit from DRCP. By default, python-oracledb pooled connections use PURITY_SELF and standalone connections use PURITY_NEW.\n\nTo limit session sharing, you can explicitly require that new session memory be allocated each time acquire() is called:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb:pooled\", min=2, max=5, increment=1, cclass=\"MYAPP\", purity=oracledb.PURITY_NEW)\n\nSetting the Connection Class and Purity in the Connection String\n\nUsing python-oracledb Thin mode with Oracle Database 21c, you can specify the class and purity in the connection string itself. This removes the need to modify an existing application when you want to use DRCP:\n\ndsn = \"localhost/orclpdb:pooled?pool_connection_class=MYAPP&pool_purity=self\"\n\nFor python-oracledb Thick mode, this syntax is supported if you are using Oracle Database 21c and Oracle Client 19c (or later). However, explicitly specifying the purity as SELF in this way may cause some unusable connections in a python-oracledb Thick mode connection pool to not be terminated. In summary, if you cannot programmatically set the class name and purity, or cannot use python-oracledb Thin mode, then avoid explicitly setting the purity as a connection string parameter when using a python-oracledb connection pooling in Thick mode.\n\nClosing Connections when using DRCP\n\nSimilar to using a python-oracledb connection pool, Python scripts where python-oracledb connections do not go out of scope quickly (which releases them), or do not currently use Connection.close() or ConnectionPool.release() should be examined to see if the connections can be closed earlier. This allows maximum reuse of DRCP pooled servers by other users:\n\npool = oracledb.create_pool(user=\"hr\", password=userpwd, dsn=\"dbhost.example.com/orclpdb:pooled\", min=2, max=5, increment=1, cclass=\"MYAPP\") # Do some database operations connection = mypool.acquire() . . . connection.close(); # <- Add this to release the DRCP pooled server # Do lots of non-database work . . . # Do some more database operations connection = mypool.acquire() # <- And get a new pooled server only when needed . . . connection.close();\n\nSee drcp_pool.py for a runnable example of DRCP.\n\n4.11.1. Native Network Encryption\n\nThe python-oracledb Thick mode can additionally use Oracle Database’s native network encryption.\n\nWith native network encryption, the client and database server negotiate a key using Diffie-Hellman key exchange. This provides protection against man-in-the-middle attacks.\n\nNative network encryption can be configured by editing Oracle Net’s optional sqlnet.ora configuration file. The file on either the database server and/or on each python-oracledb ‘client’ machine can be configured. Parameters control whether data integrity checking and encryption is required or just allowed, and which algorithms the client and server should consider for use.\n\nAs an example, to ensure all connections to the database are checked for integrity and are also encrypted, create or edit the Oracle Database $ORACLE_HOME/network/admin/sqlnet.ora file. Set the checksum negotiation to always validate a checksum and set the checksum type to your desired value. The network encryption settings can similarly be set. For example, to use the SHA512 checksum and AES256 encryption use:\n\nSQLNET.CRYPTO_CHECKSUM_SERVER = required SQLNET.CRYPTO_CHECKSUM_TYPES_SERVER = (SHA512) SQLNET.ENCRYPTION_SERVER = required SQLNET.ENCRYPTION_TYPES_SERVER = (AES256)\n\nIf you definitely know that the database server enforces integrity and encryption, then you do not need to configure python-oracledb separately. However, you can also, or alternatively do so, depending on your business needs. Create a sqlnet.ora on your client machine and locate it with other Optional Oracle Net Configuration Files:\n\nSQLNET.CRYPTO_CHECKSUM_CLIENT = required SQLNET.CRYPTO_CHECKSUM_TYPES_CLIENT = (SHA512) SQLNET.ENCRYPTION_CLIENT = required SQLNET.ENCRYPTION_TYPES_CLIENT = (AES256)\n\nThe client and server sides can negotiate the protocols used if the settings indicate more than one value is accepted.\n\nNote that these are example settings only. You must review your security requirements and read the documentation for your Oracle version. In particular, review the available algorithms for security and performance.\n\nThe NETWORK_SERVICE_BANNER column of the database view V$SESSION_CONNECT_INFO can be used to verify the encryption status of a connection. For example with SQL*Plus:\n\nSQL> SELECT network_service_banner FROM v$session_connect_info;\n\nIf the connection is encrypted, then this query prints an output that includes the available encryption service, the crypto-checksumming service, and the algorithms in use, such as:\n\nNETWORK_SERVICE_BANNER ------------------------------------------------------------------------------------- TCP/IP NT Protocol Adapter for Linux: Version 19.0.0.0.0 - Production Encryption service for Linux: Version 19.0.1.0.0 - Production AES256 Encryption service adapter for Linux: Version 19.0.1.0.0 - Production Crypto-checksumming service for Linux: Version 19.0.1.0.0 - Production SHA256 Crypto-checksumming service adapter for Linux: Version 19.0.1.0.0 - Production\n\nIf the connection is unencrypted, then the query will only print the available encryption and crypto-checksumming services in the output. For example:\n\nNETWORK_SERVICE_BANNER ------------------------------------------------------------------------------------- TCP/IP NT Protocol Adapter for Linux: Version 19.0.0.0.0 - Production Encryption service for Linux: Version 19.0.1.0.0 - Production Crypto-checksumming service for Linux: Version 19.0.1.0.0 - Production\n\nFor more information about Oracle Data Network Encryption and Integrity, and for information about configuring TLS network encryption, refer to the Oracle Database Security Guide."
    }
}