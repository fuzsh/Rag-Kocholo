{
    "id": "dbpedia_4417_0",
    "rank": 59,
    "data": {
        "url": "https://forum.arduino.cc/t/coding-an-ignition-switch/1190041",
        "read_more_link": "",
        "language": "en",
        "title": "Coding an ignition switch",
        "top_image": "https://europe1.discourse-cdn.com/arduino/optimized/4X/4/6/b/46be1102e239cb952307ac32460f8c5467ac3fd8_2_1024x975.jpeg",
        "meta_img": "https://europe1.discourse-cdn.com/arduino/optimized/4X/4/6/b/46be1102e239cb952307ac32460f8c5467ac3fd8_2_1024x975.jpeg",
        "images": [
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/4/6/b/46be1102e239cb952307ac32460f8c5467ac3fd8_2_525x500.jpeg",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://emoji.discourse-cdn.com/twitter/grinning.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/+1.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/coffee.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/australia.png?v=12",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/d/d/8/dd81a5ec1708ff65a842dc8dcdf5ca59d3c1476a_2_666x500.jpeg",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/1/5/f/15fb849532f3e30f717b06d2d8b4b647f22e4ca1_2_374x500.jpeg",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/delta_g/48/967682_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/d/b/0/db078e1a2d4c1e4ffa043956eefbf4c0df563f0b_2_586x500.jpeg",
            "https://europe1.discourse-cdn.com/arduino/original/4X/c/4/5/c45c2fb92ee1328d6c13963f6aa7d50cf9ed7480.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/5/1/6/51668ec4db0be261040d3f065c499c9dece460ab_2_242x250.jpeg",
            "https://emoji.discourse-cdn.com/twitter/grinning.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/+1.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/coffee.png?v=12",
            "https://emoji.discourse-cdn.com/twitter/australia.png?v=12",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/alto777/48/317385_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/tomgeorge/48/215261_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/alto777/48/317385_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/alto777/48/317385_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/2/f/f/2ff103ebf31d1e409c058739c1ac187381e40f82_2_658x500.jpeg",
            "https://dub1.discourse-cdn.com/arduino/user_avatar/forum.arduino.cc/davie56/48/1013044_2.png",
            "https://europe1.discourse-cdn.com/arduino/optimized/4X/6/9/f/69f6d9446797b551fff9701377b916a5fb4b3460_2_641x500.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2023-11-17T01:11:16+00:00",
        "summary": "",
        "meta_description": "I am trying to make myself a truck dash to be used for American Truck Sim.  I have the buttons and switches working fine, but I cannot get the ignition switch to work right.  I hope this is a good place to come for help. &hellip;",
        "meta_lang": "en",
        "meta_favicon": "https://europe1.discourse-cdn.com/arduino/optimized/3X/c/c/cc4b0921af3d89006e843364a2b18989ad72f83e_2_32x32.png",
        "meta_site_name": "Arduino Forum",
        "canonical_link": "https://forum.arduino.cc/t/coding-an-ignition-switch/1190041",
        "text": "I am trying to make myself a truck dash to be used for American Truck Sim. I have the buttons and switches working fine, but I cannot get the ignition switch to work right. I hope this is a good place to come for help.\n\nI am using a 3 prong ignition switch (BATT/RUN/START), I have a picture below of how I have it wired to the pro micro. The code I have sorta works but not exactly how I want it to. With the code below I can start the truck when I turn the key to the START (momentary switch) on the ignition start. Once the truck is started the key \"resting\" place is in the RUN position. When I when to turn the truck off I need to key OFF then back to the RUN position. I would like it to shut off the truck when I turn the key to the OFF position but I am not having any luck.\n\nDo I need a different ignition switch? My thought is maybe having an ignition switch with ACC position could act as an OFF position for my case and it might work.\n\nDoes anyone have an idea of what to try next?\n\nThanks,\n\nDave\n\n#include <Keypad.h> #include <Joystick.h> //DEFINITIONS #define ENABLE_PULLUPS #define NUMROTARIES 4 #define NUMBUTTONS 25 #define NUMROWS 5 #define NUMCOLS 5 //BUTTON MATRIX //first change number of rows and columns to match your button matrix, //then replace all \"?\" with numbers (starting from 0) byte buttons[NUMROWS][NUMCOLS] = { {0,1,2,3,4}, {5,6,7,8,9}, {10,11,12,13,14}, {15,16,17,18,19}, {20,21,22,23,24}, }; struct rotariesdef { byte pin1; byte pin2; int ccwchar; int cwchar; volatile unsigned char state; }; //ROTARY ENCODERS //each line controls a different rotary encoder //the first two numbers refer to the pins the encoder is connected to //the second two are the buttons each click of the encoder wil press //do NOT exceed 31 for the final button number rotariesdef rotaries[NUMROTARIES] { {0,1,22,23,0}, {2,3,24,25,0}, {4,5,26,27,0}, {6,7,28,29,0} }; #define DIR_CCW 0x10 #define DIR_CW 0x20 #define R_START 0x0 #ifdef HALF_STEP #define R_CCW_BEGIN 0x1 #define R_CW_BEGIN 0x2 #define R_START_M 0x3 #define R_CW_BEGIN_M 0x4 #define R_CCW_BEGIN_M 0x5 const unsigned char ttable[6][4] = { // R_START (00) {R_START_M, R_CW_BEGIN, R_CCW_BEGIN, R_START}, // R_CCW_BEGIN {R_START_M | DIR_CCW, R_START, R_CCW_BEGIN, R_START}, // R_CW_BEGIN {R_START_M | DIR_CW, R_CW_BEGIN, R_START, R_START}, // R_START_M (11) {R_START_M, R_CCW_BEGIN_M, R_CW_BEGIN_M, R_START}, // R_CW_BEGIN_M {R_START_M, R_START_M, R_CW_BEGIN_M, R_START | DIR_CW}, // R_CCW_BEGIN_M {R_START_M, R_CCW_BEGIN_M, R_START_M, R_START | DIR_CCW}, }; #else #define R_CW_FINAL 0x1 #define R_CW_BEGIN 0x2 #define R_CW_NEXT 0x3 #define R_CCW_BEGIN 0x4 #define R_CCW_FINAL 0x5 #define R_CCW_NEXT 0x6 const unsigned char ttable[7][4] = { // R_START {R_START, R_CW_BEGIN, R_CCW_BEGIN, R_START}, // R_CW_FINAL {R_CW_NEXT, R_START, R_CW_FINAL, R_START | DIR_CW}, // R_CW_BEGIN {R_CW_NEXT, R_CW_BEGIN, R_START, R_START}, // R_CW_NEXT {R_CW_NEXT, R_CW_BEGIN, R_CW_FINAL, R_START}, // R_CCW_BEGIN {R_CCW_NEXT, R_START, R_CCW_BEGIN, R_START}, // R_CCW_FINAL {R_CCW_NEXT, R_CCW_FINAL, R_START, R_START | DIR_CCW}, // R_CCW_NEXT {R_CCW_NEXT, R_CCW_FINAL, R_CCW_BEGIN, R_START}, }; #endif //BUTTON MATRIX PART 2 byte rowPins[NUMROWS] = {21,20,19,18,15}; byte colPins[NUMCOLS] = {14,16,10,9,8}; Keypad buttbx = Keypad( makeKeymap(buttons), rowPins, colPins, NUMROWS, NUMCOLS); //JOYSTICK SETTINGS Joystick_ Joystick(JOYSTICK_DEFAULT_REPORT_ID, JOYSTICK_TYPE_JOYSTICK, 32, //number of buttons 0, //number of hat switches //Set as many axis to \"true\" as you have potentiometers for false, false, false, false, false, false, false, false, false, false, false); const int numReadings = 20; int readings[numReadings]; // the readings from the analog input int index = 0; // the index of the current reading int total = 0; // the running total int currentOutputLevel = 0; //POTENTIOMETERS PART 1 //add all the axis' which are enabled above int zAxis_ = 0; int RxAxis_ = 0; //POTENTIOMETERS PART 2 //Which pins are your potentiometers connected to? int potentiometerPin1 = 4; //Change \"?\" to the pin your potentiometer is connected to int potentiometerPin2 = 6; const bool initAutoSendState = true; void setup() { Joystick.begin(); rotary_init(); for (int thisReading = 0; thisReading < numReadings; thisReading++) { readings[thisReading] = 0; } } void loop() { CheckAllEncoders(); CheckAllButtons(); CheckAllPotentiometers(); } //POTENTIOMETERS PART 3 //change the details to match teh details above for each potentiometer you are using void CheckAllPotentiometers(){ //potentiometer 1 currentOutputLevel = getAverageOutput(potentiometerPin1); zAxis_ = map(currentOutputLevel,0,1023,0,255); Joystick.setZAxis(zAxis_); //potentiometer 2 currentOutputLevel = getAverageOutput(potentiometerPin2); RxAxis_ = map(currentOutputLevel,0,1023,0,255); Joystick.setRxAxis(RxAxis_); } int getAverageOutput(int pinToRead){ index = 0; total = 0; while (index < numReadings){ readings[index] = analogRead(pinToRead); total = total + readings[index]; index = index + 1; //delay (1); } return total / numReadings; } void CheckAllButtons(void) { if (buttbx.getKeys()) { for (int i=0; i<LIST_MAX; i++) { if ( buttbx.key[i].stateChanged ) { switch (buttbx.key[i].kstate) { case PRESSED: case HOLD: Joystick.setButton(buttbx.key[i].kchar, 1); break; case RELEASED: case IDLE: Joystick.setButton(buttbx.key[i].kchar, 0); break; } } } } } void rotary_init() { for (int i=0;i<NUMROTARIES;i++) { pinMode(rotaries[i].pin1, INPUT); pinMode(rotaries[i].pin2, INPUT); #ifdef ENABLE_PULLUPS digitalWrite(rotaries[i].pin1, HIGH); digitalWrite(rotaries[i].pin2, HIGH); #endif } } unsigned char rotary_process(int _i) { //Serial.print(\"Processing rotary: \"); //Serial.println(_i); unsigned char pinstate = (digitalRead(rotaries[_i].pin2) << 1) | digitalRead(rotaries[_i].pin1); rotaries[_i].state = ttable[rotaries[_i].state & 0xf][pinstate]; return (rotaries[_i].state & 0x30); } void CheckAllEncoders(void) { Serial.println(\"Checking rotaries\"); for (int i=0;i<NUMROTARIES;i++) { unsigned char result = rotary_process(i); if (result == DIR_CCW) { Serial.print(\"Rotary \"); Serial.print(i); Serial.println(\" <<< Going CCW\"); Joystick.setButton(rotaries[i].ccwchar, 1); delay(50); Joystick.setButton(rotaries[i].ccwchar, 0); }; if (result == DIR_CW) { Serial.print(\"Rotary \"); Serial.print(i); Serial.println(\" >>> Going CW\"); Joystick.setButton(rotaries[i].cwchar, 1); delay(50); Joystick.setButton(rotaries[i].cwchar, 0); }; } Serial.println(\"Done checking\"); }\n\nNo. You are writing to input pins\n\ndigitalWrite(inputPin1, LOW);\n\nand also using them as analog inputs.\n\nMy suggestion is completely divorced from the keypad, it just a simple idea to test the switch configuration and (probably) see it can be used as two switches.\n\nvoid setup() { pinMode(5, INPUT_PULLUP); pinMode(6, INPUT_PULLUP); pinMode(7, OUTPUT); pinMode(8, OUTPUT); } void loop() { digitalWrite(7, digitalRead(5)); digitalWrite(8, digitalRead(6)); }\n\nWire ttwo switch pins to 5 and 6 and the common one to ground. Place an LED with series limiting resistor between pin 7 and ground, and another LED with series limiting resistor between pin 8 and ground.\n\nSee and tell us what happens in three positions of the ignition thing switch.\n\nIn your matrix, the two equivalent switches that make up the ignition key thing must find themselves on the same row, or column, as they have the Batt lead in common.\n\nThe other two switch pins would be on separate columns, or rows. Where they would just appear to operate like anything at that matrix position, and yield only three of the four possible conditions that two regular pushbuttons would be capable of, onacconna that's how the ignition switch works.\n\nFWIW y'all have missed quite the trip,\\ down memory lane her under the umbrella as we recall the little dance that hot wiring a car once was…\n\na7\n\nI agree with @Delta_G, and I understand how hard it can be to take that kind of advice. Over the long run, every minute you spend now will pay off in hours and more later.\n\nStill, maybe you could have a bit of success. Go back to the code and circuit you used that let you press multiple buttons.\n\nI may have it backwards or mirrored, but you must have been using a diode-isolated scanned matrix.\n\nEach switch is wired between one row and one column. The drawing below, which looks like I drew it with my finger for good reasons, shows one regular button at matrix position R1C1.\n\nIt also shows how to place the ignition switch thing onto the matrix. Since it is effectively two switches, I used R0C2 for one (A), and R1C2 for the other (B).\n\nA, B and C according to my table above. C is the common pin.\n\nSince the normal operation of the ignition has the ability to close both its internal switches at once, you have to have the diodes, the same as you must have with your previous success.\n\nMy diodes may be reversed, so use your best common sense.\n\nIt's nothing more than two switches with a special mechanical arrangement that makes them operate non-independently.\n\na7\n\nBelow is my most recent code, everything works but the game does not recognize it how I want.\n\nThe more I think about it, I don't think I want the game to recognize a key in the RUN position, instead I want the game to see when the key is turned to the OFF position (not just in the OFF position).\n\nThe game allows you to have 2 keybinds for Start/Stop Engine. So in my game I have button 1 as primary and a combo of buttons 1 and 2 as secondary. They both do the same thing (Start/Stop cannot be made into separate functions). But my thought is to make button 1+2 into the Start because that is for IGN. Then button 1 would be for stopping the engine. The problem with that is OFF on the ignition switch does not give me functionality in the game.\n\nexample of what the keybinding looks like....\n\n#include <Joystick.h> Joystick_ Joystick; const int buttonPin1 = 5; const int buttonPin2 = 6; int buttonState1 = 0; int buttonState2 = 0; void setup() { Joystick.begin(); pinMode(buttonPin1, INPUT_PULLUP); pinMode(buttonPin2, INPUT_PULLUP); } void loop() { buttonState1 = !digitalRead(buttonPin1); buttonState2 = !digitalRead(buttonPin2); Joystick.setButton(0, buttonState1); Joystick.setButton(1, buttonState2); delay(10); }"
    }
}