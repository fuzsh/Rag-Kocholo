{
    "id": "dbpedia_1550_0",
    "rank": 42,
    "data": {
        "url": "https://mne.tools/stable/generated/mne.preprocessing.ICA.html",
        "read_more_link": "",
        "language": "en",
        "title": "mne.preprocessing.ICA — MNE 1.7.1 documentation",
        "top_image": "https://mne.tools/stable/_static/favicon.ico",
        "meta_img": "https://mne.tools/stable/_static/favicon.ico",
        "images": [
            "https://mne.tools/stable/_static/mne_logo_small.svg",
            "https://mne.tools/stable/_images/sphx_glr_10_overview_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_70_report_thumb.svg",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_10_overview_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_70_report_thumb.svg",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_10_overview_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_10_overview_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_70_report_thumb.svg",
            "https://mne.tools/stable/_images/sphx_glr_40_artifact_correction_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_find_ref_artifacts_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_ica_comparison_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_muscle_ica_thumb.png",
            "https://mne.tools/stable/_images/sphx_glr_spm_faces_dataset_thumb.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2024-07-02T04:32:46.875116+00:00",
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "../_static/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://mne.tools/stable/index.html",
        "text": "mne.preprocessing.ICA#\n\nclassmne.preprocessing.ICA(n_components=None, *, noise_cov=None, random_state=None, method='fastica', fit_params=None, max_iter='auto', allow_ref_meg=False, verbose=None)[source]#\n\nData decomposition using Independent Component Analysis (ICA).\n\nThis object estimates independent components from mne.io.Raw, mne.Epochs, or mne.Evoked objects. Components can optionally be removed (for artifact repair) prior to signal reconstruction.\n\nWarning\n\nICA is sensitive to low-frequency drifts and therefore requires the data to be high-pass filtered prior to fitting. Typically, a cutoff frequency of 1 Hz is recommended.\n\nParameters:\n\nn_componentsint | float | None\n\nNumber of principal components (from the pre-whitening PCA step) that are passed to the ICA algorithm during fitting:\n\nint\n\nMust be greater than 1 and less than or equal to the number of channels.\n\nfloat between 0 and 1 (exclusive)\n\nWill select the smallest number of components required to explain the cumulative variance of the data greater than n_components. Consider this hypothetical example: we have 3 components, the first explaining 70%, the second 20%, and the third the remaining 10% of the variance. Passing 0.8 here (corresponding to 80% of explained variance) would yield the first two components, explaining 90% of the variance: only by using both components the requested threshold of 80% explained variance can be exceeded. The third component, on the other hand, would be excluded.\n\nNone\n\n0.999999 will be used. This is done to avoid numerical stability problems when whitening, particularly when working with rank-deficient data.\n\nDefaults to None. The actual number used when executing the ICA.fit() method will be stored in the attribute n_components_ (note the trailing underscore).\n\nChanged in version 0.22: For a float, the number of components will account for greater than the given variance level instead of less than or equal to it. The default (None) will also take into account the rank deficiency of the data.\n\nnoise_covNone | instance of Covariance\n\nNoise covariance used for pre-whitening. If None (default), channels are scaled to unit variance (“z-standardized”) as a group by channel type prior to the whitening by PCA.\n\nrandom_stateNone | int | instance of RandomState\n\nA seed for the NumPy random number generator (RNG). If None (default), the seed will be obtained from the operating system (see RandomState for details), meaning it will most likely produce different output every time this function or method is run. To achieve reproducible results, pass a value here to explicitly initialize the RNG with a defined state.\n\nmethod‘fastica’ | ‘infomax’ | ‘picard’\n\nThe ICA method to use in the fit method. Use the fit_params argument to set additional parameters. Specifically, if you want Extended Infomax, set method='infomax' and fit_params=dict(extended=True) (this also works for method='picard'). Defaults to 'fastica'. For reference, see .\n\nfit_paramsdict | None\n\nAdditional parameters passed to the ICA estimator as specified by method. Allowed entries are determined by the various algorithm implementations: see FastICA, picard(), infomax().\n\nmax_iterint | ‘auto’\n\nMaximum number of iterations during fit. If 'auto', it will set maximum iterations to 1000 for 'fastica' and to 500 for 'infomax' or 'picard'. The actual number of iterations it took ICA.fit() to complete will be stored in the n_iter_ attribute.\n\nallow_ref_megbool\n\nAllow ICA on MEG reference channels. Defaults to False.\n\nNew in v0.18.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nNotes\n\nChanged in version 0.23: Version 0.23 introduced the max_iter='auto' settings for maximum iterations. With version 0.24 'auto' will be the new default, replacing the current max_iter=200.\n\nChanged in version 0.23: Warn if Epochs were baseline-corrected.\n\nNote\n\nIf you intend to fit ICA on Epochs, it is recommended to high-pass filter, but not baseline correct the data for good ICA performance. A warning will be emitted otherwise.\n\nA trailing _ in an attribute name signifies that the attribute was added to the object during fitting, consistent with standard scikit-learn practice.\n\nICA fit() in MNE proceeds in two steps:\n\nWhitening the data by means of a pre-whitening step (using noise_cov if provided, or the standard deviation of each channel type) and then principal component analysis (PCA).\n\nPassing the n_components largest-variance components to the ICA algorithm to obtain the unmixing matrix (and by pseudoinversion, the mixing matrix).\n\nICA apply() then:\n\nUnmixes the data with the unmixing_matrix_.\n\nIncludes ICA components based on ica.include and ica.exclude.\n\nRe-mixes the data with mixing_matrix_.\n\nRestores any data not passed to the ICA algorithm, i.e., the PCA components between n_components and n_pca_components.\n\nn_pca_components determines how many PCA components will be kept when reconstructing the data when calling apply(). This parameter can be used for dimensionality reduction of the data, or dealing with low-rank data (such as those with projections, or MEG data processed by SSS). It is important to remove any numerically-zero-variance components in the data, otherwise numerical instability causes problems when computing the mixing matrix. Alternatively, using n_components as a float will also avoid numerical stability problems.\n\nThe n_components parameter determines how many components out of the n_channels PCA components the ICA algorithm will actually fit. This is not typically used for EEG data, but for MEG data, it’s common to use n_components < n_channels. For example, full-rank 306-channel MEG data might use n_components=40 to find (and later exclude) only large, dominating artifacts in the data, but still reconstruct the data using all 306 PCA components. Setting n_pca_components=40, on the other hand, would actually reduce the rank of the reconstructed data to 40, which is typically undesirable.\n\nIf you are migrating from EEGLAB and intend to reduce dimensionality via PCA, similarly to EEGLAB’s runica(..., 'pca', n) functionality, pass n_components=n during initialization and then n_pca_components=n during apply(). The resulting reconstructed data after apply() will have rank n.\n\nNote\n\nCommonly used for reasons of i) computational efficiency and ii) additional noise reduction, it is a matter of current debate whether pre-ICA dimensionality reduction could decrease the reliability and stability of the ICA, at least for EEG data and especially during preprocessing . (But see also for a possibly confounding effect of the different whitening/sphering methods used in this paper (ZCA vs. PCA).) On the other hand, for rank-deficient data such as EEG data after average reference or interpolation, it is recommended to reduce the dimensionality (by 1 for average reference and 1 for each interpolated channel) for optimal ICA performance (see the EEGLAB wiki).\n\nCaveat! If supplying a noise covariance, keep track of the projections available in the cov or in the raw object. For example, if you are interested in EOG or ECG artifacts, EOG and ECG projections should be temporally removed before fitting ICA, for example:\n\n>> projs, raw.info['projs'] = raw.info['projs'], [] >> ica.fit(raw) >> raw.info['projs'] = projs\n\nMethods currently implemented are FastICA (default), Infomax, and Picard. Standard Infomax can be quite sensitive to differences in floating point arithmetic. Extended Infomax seems to be more stable in this respect, enhancing reproducibility and stability of results; use Extended Infomax via method='infomax', fit_params=dict(extended=True). Allowed entries in fit_params are determined by the various algorithm implementations: see FastICA, picard(), infomax().\n\nNote\n\nPicard can be used to solve the same problems as FastICA, Infomax, and extended Infomax, but typically converges faster than either of those methods. To make use of Picard’s speed while still obtaining the same solution as with other algorithms, you need to specify method='picard' and fit_params as a dictionary with the following combination of keys:\n\ndict(ortho=False, extended=False) for Infomax\n\ndict(ortho=False, extended=True) for extended Infomax\n\ndict(ortho=True, extended=True) for FastICA\n\nReducing the tolerance (set in fit_params) speeds up estimation at the cost of consistency of the obtained results. It is difficult to directly compare tolerance levels between Infomax and Picard, but for Picard and FastICA a good rule of thumb is tol_fastica == tol_picard ** 2.\n\nReferences\n\nAttributes:\n\ncurrent_fit‘unfitted’ | ‘raw’ | ‘epochs’\n\nWhich data type was used for the fit.\n\nch_nameslist-like\n\nChannel names resulting from initial picking.\n\nn_components_int\n\nIf fit, the actual number of PCA components used for ICA decomposition.\n\npre_whitener_ndarray, shape (n_channels, 1) or (n_channels, n_channels)\n\nIf fit, array used to pre-whiten the data prior to PCA.\n\npca_components_ndarray, shape (n_channels, n_channels)\n\nIf fit, the PCA components.\n\npca_mean_ndarray, shape (n_channels,)\n\nIf fit, the mean vector used to center the data before doing the PCA.\n\npca_explained_variance_ndarray, shape (n_channels,)\n\nIf fit, the variance explained by each PCA component.\n\nmixing_matrix_ndarray, shape (n_components_, n_components_)\n\nIf fit, the whitened mixing matrix to go back from ICA space to PCA space. It is, in combination with the pca_components_, used by ICA.apply() and ICA.get_components() to re-mix/project a subset of the ICA components into the observed channel space. The former method also removes the pre-whitening (z-scaling) and the de-meaning.\n\nunmixing_matrix_ndarray, shape (n_components_, n_components_)\n\nIf fit, the whitened matrix to go from PCA space to ICA space. Used, in combination with the pca_components_, by the methods ICA.get_sources() and ICA.apply() to unmix the observed data.\n\nexcludearray_like of int\n\nList or np.array of sources indices to exclude when re-mixing the data in the ICA.apply() method, i.e. artifactual ICA components. The components identified manually and by the various automatic artifact detection methods should be (manually) appended (e.g. ica.exclude.extend(eog_inds)). (There is also an exclude parameter in the ICA.apply() method.) To scrap all marked components, set this attribute to an empty list.\n\ninfomne.Info | None\n\nThe mne.Info object with information about the sensors and methods of measurement.\n\nn_samples_int\n\nThe number of samples used on fit.\n\nlabels_dict\n\nA dictionary of independent component indices, grouped by types of independent components. This attribute is set by some of the artifact detection functions.\n\nn_iter_int\n\nIf fit, the number of iterations required to complete ICA.\n\nMethods\n\n__contains__(ch_type)\n\nCheck channel type membership.\n\napply(inst[, include, exclude, ...])\n\nRemove selected components from the signal.\n\ncopy()\n\nCopy the ICA object.\n\nfind_bads_ecg(inst[, ch_name, threshold, ...])\n\nDetect ECG related components.\n\nfind_bads_eog(inst[, ch_name, threshold, ...])\n\nDetect EOG related components using correlation.\n\nfind_bads_muscle(inst[, threshold, start, ...])\n\nDetect muscle related components.\n\nfind_bads_ref(inst[, ch_name, threshold, ...])\n\nDetect MEG reference related components using correlation.\n\nfit(inst[, picks, start, stop, decim, ...])\n\nRun the ICA decomposition on raw data.\n\nget_channel_types([picks, unique, only_data_chs])\n\nGet a list of channel type for each channel.\n\nget_components()\n\nGet ICA topomap for components as numpy arrays.\n\nget_explained_variance_ratio(inst, *[, ...])\n\nGet the proportion of data variance explained by ICA components.\n\nget_sources(inst[, add_channels, start, stop])\n\nEstimate sources given the unmixing matrix.\n\nplot_components([picks, ch_type, inst, ...])\n\nProject mixing matrix on interpolated sensor topography.\n\nplot_overlay(inst[, exclude, picks, start, ...])\n\nOverlay of raw and cleaned signals given the unmixing matrix.\n\nplot_properties(inst[, picks, axes, dB, ...])\n\nDisplay component properties.\n\nplot_scores(scores[, exclude, labels, ...])\n\nPlot scores related to detected components.\n\nplot_sources(inst[, picks, start, stop, ...])\n\nPlot estimated latent sources given the unmixing matrix.\n\nsave(fname, *[, overwrite, verbose])\n\nStore ICA solution into a fiff file.\n\nscore_sources(inst[, target, score_func, ...])\n\nAssign score to components based on statistic or metric.\n\n__contains__(ch_type)[source]#\n\nCheck channel type membership.\n\nParameters:\n\nch_typestr\n\nChannel type to check for. Can be e.g. 'meg', 'eeg', 'stim', etc.\n\nReturns:\n\ninbool\n\nWhether or not the instance contains the given channel type.\n\nExamples\n\nChannel type membership can be tested as:\n\n>>> 'meg' in inst True >>> 'seeg' in inst False\n\napply(inst, include=None, exclude=None, n_pca_components=None, start=None, stop=None, *, on_baseline='warn', verbose=None)[source]#\n\nRemove selected components from the signal.\n\nGiven the unmixing matrix, transform the data, zero out all excluded components, and inverse-transform the data. This procedure will reconstruct M/EEG signals from which the dynamics described by the excluded components is subtracted.\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nThe data to be processed (i.e., cleaned). It will be modified in-place.\n\nincludearray_like of int\n\nThe indices referring to columns in the ummixing matrix. The components to be kept. If None (default), all components will be included (minus those defined in ica.exclude and the exclude parameter, see below).\n\nexcludearray_like of int\n\nThe indices referring to columns in the ummixing matrix. The components to be zeroed out. If None (default) or an empty list, only components from ica.exclude will be excluded. Else, the union of exclude and ica.exclude will be excluded.\n\nn_pca_componentsint | float | None\n\nThe number of PCA components to be kept, either absolute (int) or fraction of the explained variance (float). If None (default), the ica.n_pca_components from initialization will be used in 0.22; in 0.23 all components will be used.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, data will be used to the last sample.\n\non_baselinestr\n\nHow to handle baseline-corrected epochs or evoked data. Can be 'raise' to raise an error, 'warn' (default) to emit a warning, 'ignore' to ignore, or “reapply” to reapply the baseline after applying ICA.\n\nNew in v1.2.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\noutinstance of Raw, Epochs or Evoked\n\nThe processed data.\n\nNotes\n\nNote\n\nApplying ICA may introduce a DC shift. If you pass baseline-corrected Epochs or Evoked data, the baseline period of the cleaned data may not be of zero mean anymore. If you require baseline-corrected data, apply baseline correction again after cleaning via ICA. A warning will be emitted to remind you of this fact if you pass baseline-corrected data.\n\nChanged in version 0.23: Warn if instance was baseline-corrected.\n\nExamples using apply:\n\nOverview of MEG/EEG analysis with MNE-Python\n\nOverview of MEG/EEG analysis with MNE-Python\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\npropertycompensation_grade#\n\nThe current gradient compensation grade.\n\ncopy()[source]#\n\nCopy the ICA object.\n\nReturns:\n\nicainstance of ICA\n\nThe copied object.\n\nExamples using copy:\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nfind_bads_ecg(inst, ch_name=None, threshold='auto', start=None, stop=None, l_freq=8, h_freq=16, method='ctps', reject_by_annotation=True, measure='zscore', verbose=None)[source]#\n\nDetect ECG related components.\n\nCross-trial phase statistics or Pearson correlation can be used for detection.\n\nNote\n\nIf no ECG channel is available, routine attempts to create an artificial ECG based on cross-channel averaging.\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nObject to compute sources from.\n\nch_namestr\n\nThe name of the channel to use for ECG peak detection. The argument is mandatory if the dataset contains no ECG channels.\n\nthresholdfloat | ‘auto’\n\nValue above which a feature is classified as outlier. See Notes.\n\nChanged in version 0.21.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample. When working with Epochs or Evoked objects, must be float or None.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, data will be used to the last sample. When working with Epochs or Evoked objects, must be float or None.\n\nl_freqfloat\n\nLow pass frequency.\n\nh_freqfloat\n\nHigh pass frequency.\n\nmethod‘ctps’ | ‘correlation’\n\nThe method used for detection. If 'ctps', cross-trial phase statistics are used to detect ECG-related components. See Notes.\n\nreject_by_annotationbool\n\nWhether to omit bad segments from the data before fitting. If True (default), annotated segments whose description begins with 'bad' are omitted. If False, no rejection based on annotations is performed.\n\nNew in v0.14.0.\n\nmeasure‘zscore’ | ‘correlation’\n\nWhich method to use for finding outliers among the components:\n\n'zscore' (default) is the iterative z-scoring method. This method computes the z-score of the component’s scores and masks the components with a z-score above threshold. This process is repeated until no supra-threshold component remains.\n\n'correlation' is an absolute raw correlation threshold ranging from 0 to 1.\n\nNew in v0.21.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\necg_idxlist of int\n\nThe indices of ECG-related components.\n\nscoresnp.ndarray of float, shape (n_components_)\n\nIf method is ‘ctps’, the normalized Kuiper index scores. If method is ‘correlation’, the correlation scores.\n\nSee also\n\nfind_bads_eog, find_bads_ref, find_bads_muscle\n\nNotes\n\nThe threshold, method, and measure parameters interact in the following ways:\n\nIf method='ctps', threshold refers to the significance value of a Kuiper statistic, and threshold='auto' will compute the threshold automatically based on the sampling frequency.\n\nIf method='correlation' and measure='correlation', threshold refers to the Pearson correlation value, and threshold='auto' sets the threshold to 0.9.\n\nIf method='correlation' and measure='zscore', threshold refers to the z-score value (i.e., standard deviations) used in the iterative z-scoring method, and threshold='auto' sets the threshold to 3.0.\n\nReferences\n\nExamples using find_bads_ecg:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nfind_bads_eog(inst, ch_name=None, threshold=3.0, start=None, stop=None, l_freq=1, h_freq=10, reject_by_annotation=True, measure='zscore', verbose=None)[source]#\n\nDetect EOG related components using correlation.\n\nDetection is based on Pearson correlation between the filtered data and the filtered EOG channel. Thresholding is based on adaptive z-scoring. The above threshold components will be masked and the z-score will be recomputed until no supra-threshold component remains.\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nObject to compute sources from.\n\nch_namestr\n\nThe name of the channel to use for EOG peak detection. The argument is mandatory if the dataset contains no EOG channels.\n\nthresholdfloat | str\n\nValue above which a feature is classified as outlier.\n\nIf measure is 'zscore', defines the threshold on the z-score used in the iterative z-scoring method.\n\nIf measure is 'correlation', defines the absolute threshold on the correlation between 0 and 1.\n\nIf 'auto', defaults to 3.0 if measure is 'zscore' and 0.9 if measure is 'correlation'.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, data will be used to the last sample.\n\nl_freqfloat\n\nLow pass frequency.\n\nh_freqfloat\n\nHigh pass frequency.\n\nreject_by_annotationbool\n\nWhether to omit bad segments from the data before fitting. If True (default), annotated segments whose description begins with 'bad' are omitted. If False, no rejection based on annotations is performed.\n\nNew in v0.14.0.\n\nmeasure‘zscore’ | ‘correlation’\n\nWhich method to use for finding outliers among the components:\n\n'zscore' (default) is the iterative z-scoring method. This method computes the z-score of the component’s scores and masks the components with a z-score above threshold. This process is repeated until no supra-threshold component remains.\n\n'correlation' is an absolute raw correlation threshold ranging from 0 to 1.\n\nNew in v0.21.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\neog_idxlist of int\n\nThe indices of EOG related components, sorted by score.\n\nscoresnp.ndarray of float, shape (n_components_) | list of array\n\nThe correlation scores.\n\nSee also\n\nfind_bads_ecg, find_bads_ref\n\nExamples using find_bads_eog:\n\nGetting started with mne.Report\n\nGetting started with mne.Report\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\nfind_bads_muscle(inst, threshold=0.5, start=None, stop=None, l_freq=7, h_freq=45, sphere=None, verbose=None)[source]#\n\nDetect muscle related components.\n\nDetection is based on which uses data from a subject who has been temporarily paralyzed . The criteria are threefold: 1) Positive log-log spectral slope from 7 to 45 Hz 2) Peripheral component power (farthest away from the vertex) 3) A single focal point measured by low spatial smoothness\n\nThe threshold is relative to the slope, focal point and smoothness of a typical muscle-related ICA component. Note the high frequency of the power spectral density slope was 75 Hz in the reference but has been modified to 45 Hz as a default based on the criteria being more accurate in practice.\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nObject to compute sources from.\n\nthresholdfloat | str\n\nValue above which a component should be marked as muscle-related, relative to a typical muscle component.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, data will be used to the last sample.\n\nl_freqfloat\n\nLow frequency for muscle-related power.\n\nh_freqfloat\n\nHigh frequency for msucle related power.\n\nspherefloat | array_like | instance of ConductorModel | None | ‘auto’ | ‘eeglab’\n\nThe sphere parameters to use for the head outline. Can be array-like of shape (4,) to give the X/Y/Z origin and radius in meters, or a single float to give just the radius (origin assumed 0, 0, 0). Can also be an instance of a spherical ConductorModel to use the origin and radius from that object. If 'auto' the sphere is fit to digitization points. If 'eeglab' the head circle is defined by EEG electrodes 'Fpz', 'Oz', 'T7', and 'T8' (if 'Fpz' is not present, it will be approximated from the coordinates of 'Oz'). None (the default) is equivalent to 'auto' when enough extra digitization points are available, and (0, 0, 0, 0.095) otherwise.\n\nNew in v0.20.\n\nChanged in version 1.1: Added 'eeglab' option.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nmuscle_idxlist of int\n\nThe indices of EOG related components, sorted by score.\n\nscoresnp.ndarray of float, shape (n_components_) | list of array\n\nThe correlation scores.\n\nSee also\n\nfind_bads_ecg, find_bads_eog, find_bads_ref\n\nNotes\n\nNew in v1.1.\n\nExamples using find_bads_muscle:\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nfind_bads_ref(inst, ch_name=None, threshold=3.0, start=None, stop=None, l_freq=None, h_freq=None, reject_by_annotation=True, method='together', measure='zscore', verbose=None)[source]#\n\nDetect MEG reference related components using correlation.\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nObject to compute sources from. Should contain at least one channel i.e. component derived from MEG reference channels.\n\nch_namelist of str\n\nWhich MEG reference components to use. If None, then all channels that begin with REF_ICA.\n\nthresholdfloat | str\n\nValue above which a feature is classified as outlier.\n\nIf measure is 'zscore', defines the threshold on the z-score used in the iterative z-scoring method.\n\nIf measure is 'correlation', defines the absolute threshold on the correlation between 0 and 1.\n\nIf 'auto', defaults to 3.0 if measure is 'zscore' and 0.9 if measure is 'correlation'.\n\nWarning\n\nIf method is 'together', the iterative z-score method is always used.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, data will be used to the last sample.\n\nl_freqfloat\n\nLow pass frequency.\n\nh_freqfloat\n\nHigh pass frequency.\n\nreject_by_annotationbool\n\nWhether to omit bad segments from the data before fitting. If True (default), annotated segments whose description begins with 'bad' are omitted. If False, no rejection based on annotations is performed.\n\nmethod‘together’ | ‘separate’\n\nMethod to use to identify reference channel related components. Defaults to 'together'. See notes.\n\nNew in v0.21.\n\nmeasure‘zscore’ | ‘correlation’\n\nWhich method to use for finding outliers among the components:\n\n'zscore' (default) is the iterative z-scoring method. This method computes the z-score of the component’s scores and masks the components with a z-score above threshold. This process is repeated until no supra-threshold component remains.\n\n'correlation' is an absolute raw correlation threshold ranging from 0 to 1.\n\nNew in v0.21.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nref_idxlist of int\n\nThe indices of MEG reference related components, sorted by score.\n\nscoresnp.ndarray of float, shape (n_components_) | list of array\n\nThe correlation scores.\n\nSee also\n\nfind_bads_ecg, find_bads_eog, find_bads_muscle\n\nNotes\n\nICA decomposition on MEG reference channels is used to assess external magnetic noise and remove it from the MEG. Two methods are supported:\n\nWith the 'together' method, only one ICA fit is used, which encompasses both MEG and reference channels together. Components which have particularly strong weights on the reference channels may be thresholded and marked for removal.\n\nWith 'separate' selected components from a separate ICA decomposition on the reference channels are used as a ground truth for identifying bad components in an ICA fit done on MEG channels only. The logic here is similar to an EOG/ECG, with reference components replacing the EOG/ECG channels. Recommended procedure is to perform ICA separately on reference channels, extract them using get_sources(), and then append them to the inst using add_channels(), preferably with the prefix REF_ICA so that they can be automatically detected.\n\nWith 'together', thresholding is based on adaptative z-scoring.\n\nWith 'separate':\n\nValidation and further documentation for this technique can be found in .\n\nNew in v0.18.\n\nReferences\n\nExamples using find_bads_ref:\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nfit(inst, picks=None, start=None, stop=None, decim=None, reject=None, flat=None, tstep=2.0, reject_by_annotation=True, verbose=None)[source]#\n\nRun the ICA decomposition on raw data.\n\nCaveat! If supplying a noise covariance keep track of the projections available in the cov, the raw or the epochs object. For example, if you are interested in EOG or ECG artifacts, EOG and ECG projections should be temporally removed before fitting the ICA.\n\nParameters:\n\ninstinstance of Raw or Epochs\n\nThe data to be decomposed.\n\npicksstr | array_like | slice | None\n\nChannels to include. Slices and lists of integers will be interpreted as channel indices. In lists, channel type strings (e.g., ['meg', 'eeg']) will pick channels of those types, channel name strings (e.g., ['MEG0111', 'MEG2623'] will pick the given channels. Can also be the string values “all” to pick all channels, or “data” to pick data channels. None (default) will pick good data channels (excluding reference MEG channels). Note that channels in info['bads'] will be included if their names or indices are explicitly provided. This selection remains throughout the initialized ICA solution.\n\nstart, stopint | float | None\n\nFirst and last sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample and to the last sample, respectively.\n\nNote\n\nThese parameters only have an effect if inst is Raw data.\n\ndecimint | None\n\nIncrement for selecting only each n-th sampling point. If None, all samples between start and stop (inclusive) are used.\n\nreject, flatdict | None\n\nRejection parameters based on peak-to-peak amplitude (PTP) in the continuous data. Signal periods exceeding the thresholds in reject or less than the thresholds in flat will be removed before fitting the ICA.\n\nNote\n\nThese parameters only have an effect if inst is Raw data. For Epochs, perform PTP rejection via drop_bad().\n\nValid keys are all channel types present in the data. Values must be integers or floats.\n\nIf None, no PTP-based rejection will be performed. Example:\n\nreject = dict( grad=4000e-13, # T / m (gradiometers) mag=4e-12, # T (magnetometers) eeg=40e-6, # V (EEG channels) eog=250e-6 # V (EOG channels) ) flat = None # no rejection based on flatness\n\ntstepfloat\n\nLength of data chunks for artifact rejection in seconds.\n\nNote\n\nThis parameter only has an effect if inst is Raw data.\n\nreject_by_annotationbool\n\nWhether to omit bad segments from the data before fitting. If True (default), annotated segments whose description begins with 'bad' are omitted. If False, no rejection based on annotations is performed.\n\nHas no effect if inst is not a mne.io.Raw object.\n\nNew in v0.14.0.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nselfinstance of ICA\n\nReturns the modified instance.\n\nExamples using fit:\n\nOverview of MEG/EEG analysis with MNE-Python\n\nOverview of MEG/EEG analysis with MNE-Python\n\nGetting started with mne.Report\n\nGetting started with mne.Report\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\nget_channel_types(picks=None, unique=False, only_data_chs=False)[source]#\n\nGet a list of channel type for each channel.\n\nParameters:\n\npicksstr | array_like | slice | None\n\nChannels to include. Slices and lists of integers will be interpreted as channel indices. In lists, channel type strings (e.g., ['meg', 'eeg']) will pick channels of those types, channel name strings (e.g., ['MEG0111', 'MEG2623'] will pick the given channels. Can also be the string values “all” to pick all channels, or “data” to pick data channels. None (default) will pick all channels. Note that channels in info['bads'] will be included if their names or indices are explicitly provided.\n\nuniquebool\n\nWhether to return only unique channel types. Default is False.\n\nonly_data_chsbool\n\nWhether to ignore non-data channels. Default is False.\n\nReturns:\n\nchannel_typeslist\n\nThe channel types.\n\nget_components()[source]#\n\nGet ICA topomap for components as numpy arrays.\n\nReturns:\n\ncomponentsarray, shape (n_channels, n_components)\n\nThe ICA components (maps).\n\nExamples using get_components:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nget_explained_variance_ratio(inst, *, components=None, ch_type=None)[source]#\n\nGet the proportion of data variance explained by ICA components.\n\nParameters:\n\ninstmne.io.BaseRaw | mne.BaseEpochs | mne.Evoked\n\nThe uncleaned data.\n\ncomponentsarray_like of int | int | None\n\nThe component(s) for which to do the calculation. If more than one component is specified, explained variance will be calculated jointly across all supplied components. If None (default), uses all available components.\n\nch_type‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | array_like of str | None\n\nThe channel type(s) to include in the calculation. If None, all available channel types will be used.\n\nReturns:\n\ndict (str, float)\n\nThe fraction of variance in inst that can be explained by the ICA components, calculated separately for each channel type. Dictionary keys are the channel types, and corresponding explained variance ratios are the values.\n\nNotes\n\nA value similar to EEGLAB’s pvaf (percent variance accounted for) will be calculated for the specified component(s).\n\nSince ICA components cannot be assumed to be aligned orthogonally, the sum of the proportion of variance explained by all components may not be equal to 1. In certain situations, the proportion of variance explained by a component may even be negative.\n\nNew in v1.2.\n\nExamples using get_explained_variance_ratio:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nget_sources(inst, add_channels=None, start=None, stop=None)[source]#\n\nEstimate sources given the unmixing matrix.\n\nThis method will return the sources in the container format passed. Typical usecases:\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nObject to compute sources from and to represent sources in.\n\nadd_channelsNone | list of str\n\nAdditional channels to be added. Useful to e.g. compare sources with some reference. Defaults to None.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, the entire data will be used.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, the entire data will be used.\n\nReturns:\n\nsourcesinstance of Raw, Epochs or Evoked\n\nThe ICA sources time series.\n\nExamples using get_sources:\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nplot_components(picks=None, ch_type=None, *, inst=None, plot_std=True, reject='auto', sensors=True, show_names=False, contours=6, outlines='head', sphere=None, image_interp='cubic', extrapolate='auto', border='mean', res=64, size=1, cmap='RdBu_r', vlim=(None, None), cnorm=None, colorbar=False, cbar_fmt='%3.2f', axes=None, title=None, nrows='auto', ncols='auto', show=True, image_args=None, psd_args=None, verbose=None)[source]#\n\nProject mixing matrix on interpolated sensor topography.\n\nParameters:\n\npicksint | list of int | slice | None\n\nIndices of the independent components (ICs) to visualize. If an integer, represents the index of the IC to pick. Multiple ICs can be selected using a list of int or a slice. The indices are 0-indexed, so picks=1 will pick the second IC: ICA001. None will pick all independent components in the order fitted.\n\nch_type‘mag’ | ‘grad’ | ‘planar1’ | ‘planar2’ | ‘eeg’ | None\n\nThe channel type to plot. For 'grad', the gradiometers are collected in pairs and the RMS for each pair is plotted. If None the first available channel type from order shown above is used. Defaults to None.\n\ninstRaw | Epochs | None\n\nTo be able to see component properties after clicking on component topomap you need to pass relevant data - instances of Raw or Epochs (for example the data that ICA was trained on). This takes effect only when running matplotlib in interactive mode.\n\nplot_stdbool | float\n\nWhether to plot standard deviation in ERP/ERF and spectrum plots. Defaults to True, which plots one standard deviation above/below. If set to float allows to control how many standard deviations are plotted. For example 2.5 will plot 2.5 standard deviation above/below.\n\nreject'auto' | dict | None\n\nAllows to specify rejection parameters used to drop epochs (or segments if continuous signal is passed as inst). If None, no rejection is applied. The default is ‘auto’, which applies the rejection parameters used when fitting the ICA object.\n\nsensorsbool | str\n\nWhether to add markers for sensor locations. If str, should be a valid matplotlib format string (e.g., 'r+' for red plusses, see the Notes section of plot()). If True (the default), black circles will be used.\n\nshow_namesbool | callable()\n\nIf True, show channel names next to each sensor marker. If callable, channel names will be formatted using the callable; e.g., to delete the prefix ‘MEG ‘ from all channel names, pass the function lambda x: x.replace('MEG ', ''). If mask is not None, only non-masked sensor names will be shown.\n\ncontoursint | array_like\n\nThe number of contour lines to draw. If 0, no contours will be drawn. If a positive integer, that number of contour levels are chosen using the matplotlib tick locator (may sometimes be inaccurate, use array for accuracy). If array-like, the array values are used as the contour levels. The values should be in µV for EEG, fT for magnetometers and fT/m for gradiometers. If colorbar=True, the colorbar will have ticks corresponding to the contour levels. Default is 6.\n\noutlines‘head’ | dict | None\n\nThe outlines to be drawn. If ‘head’, the default head scheme will be drawn. If dict, each key refers to a tuple of x and y positions, the values in ‘mask_pos’ will serve as image mask. Alternatively, a matplotlib patch object can be passed for advanced masking options, either directly or as a function that returns patches (required for multi-axis plots). If None, nothing will be drawn. Defaults to ‘head’.\n\nspherefloat | array_like | instance of ConductorModel | None | ‘auto’ | ‘eeglab’\n\nThe sphere parameters to use for the head outline. Can be array-like of shape (4,) to give the X/Y/Z origin and radius in meters, or a single float to give just the radius (origin assumed 0, 0, 0). Can also be an instance of a spherical ConductorModel to use the origin and radius from that object. If 'auto' the sphere is fit to digitization points. If 'eeglab' the head circle is defined by EEG electrodes 'Fpz', 'Oz', 'T7', and 'T8' (if 'Fpz' is not present, it will be approximated from the coordinates of 'Oz'). None (the default) is equivalent to 'auto' when enough extra digitization points are available, and (0, 0, 0, 0.095) otherwise.\n\nNew in v0.20.\n\nChanged in version 1.1: Added 'eeglab' option.\n\nimage_interpstr\n\nThe image interpolation to be used. Options are 'cubic' (default) to use scipy.interpolate.CloughTocher2DInterpolator, 'nearest' to use scipy.spatial.Voronoi or 'linear' to use scipy.interpolate.LinearNDInterpolator.\n\nextrapolatestr\n\nOptions:\n\n'box'\n\nExtrapolate to four points placed to form a square encompassing all data points, where each side of the square is three times the range of the data in the respective dimension.\n\n'local' (default for MEG sensors)\n\nExtrapolate only to nearby points (approximately to points closer than median inter-electrode distance). This will also set the mask to be polygonal based on the convex hull of the sensors.\n\n'head' (default for non-MEG sensors)\n\nExtrapolate out to the edges of the clipping circle. This will be on the head circle when the sensors are contained within the head circle, but it can extend beyond the head when sensors are plotted outside the head circle.\n\nNew in v1.3.\n\nborderfloat | ‘mean’\n\nValue to extrapolate to on the topomap borders. If 'mean' (default), then each extrapolated point has the average value of its neighbours.\n\nNew in v1.3.\n\nresint\n\nThe resolution of the topomap image (number of pixels along each side).\n\nsizefloat\n\nSide length of each subplot in inches.\n\nNew in v1.3.\n\ncmapmatplotlib colormap | (colormap, bool) | ‘interactive’ | None\n\nColormap to use. If tuple, the first value indicates the colormap to use and the second value is a boolean defining interactivity. In interactive mode the colors are adjustable by clicking and dragging the colorbar with left and right mouse button. Left mouse button moves the scale up and down and right mouse button adjusts the range. Hitting space bar resets the range. Up and down arrows can be used to change the colormap. If None, 'Reds' is used for data that is either all-positive or all-negative, and 'RdBu_r' is used otherwise. 'interactive' is equivalent to (None, True). Defaults to None.\n\nWarning\n\nInteractive mode works smoothly only for a small amount of topomaps. Interactive mode is disabled by default for more than 2 topomaps.\n\nvlimtuple of length 2\n\nLower and upper bounds of the colormap, typically a numeric value in the same units as the data. If both entries are None, the bounds are set at (min(data), max(data)). Providing None for just one entry will set the corresponding boundary at the min/max of the data. Defaults to (None, None).\n\nNew in v1.3.\n\ncnormmatplotlib.colors.Normalize | None\n\nHow to normalize the colormap. If None, standard linear normalization is performed. If not None, vmin and vmax will be ignored. See Matplotlib docs for more details on colormap normalization, and the ERDs example for an example of its use.\n\nNew in v1.3.\n\ncolorbarbool\n\nPlot a colorbar in the rightmost column of the figure.\n\ncbar_fmtstr\n\nFormatting string for colorbar tick labels. See Format Specification Mini-Language for details.\n\naxesAxes | array of Axes | None\n\nThe subplot(s) to plot to. Either a single Axes or an iterable of Axes if more than one subplot is needed. The number of subplots must match the number of selected components. If None, new figures will be created with the number of subplots per figure controlled by nrows and ncols.\n\ntitlestr | None\n\nThe title of the generated figure. If None (default) and axes=None, a default title of “ICA Components” will be used.\n\nnrows, ncolsint | ‘auto’\n\nThe number of rows and columns of topographies to plot. If both nrows and ncols are 'auto', will plot up to 20 components in a 5×4 grid, and return multiple figures if more than 20 components are requested. If one is 'auto' and the other a scalar, a single figure is generated. If scalars are provided for both arguments, will plot up to nrows*ncols components in a grid and return multiple figures as needed. Default is nrows='auto', ncols='auto'.\n\nNew in v1.3.\n\nshowbool\n\nShow the figure if True.\n\nimage_argsdict | None\n\nDictionary of arguments to pass to plot_epochs_image() in interactive mode. Ignored if inst is not supplied. If None, nothing is passed. Defaults to None.\n\npsd_argsdict | None\n\nDictionary of arguments to pass to compute_psd() in interactive mode. Ignored if inst is not supplied. If None, nothing is passed. Defaults to None.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nfiginstance of matplotlib.figure.Figure | list of matplotlib.figure.Figure\n\nThe figure object(s).\n\nNotes\n\nWhen run in interactive mode, plot_ica_components allows to reject components by clicking on their title label. The state of each component is indicated by its label color (gray: rejected; black: retained). It is also possible to open component properties by clicking on the component topomap (this option is only available when the inst argument is supplied).\n\nExamples using plot_components:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\nplot_overlay(inst, exclude=None, picks=None, start=None, stop=None, title=None, show=True, n_pca_components=None, *, on_baseline='warn', verbose=None)[source]#\n\nOverlay of raw and cleaned signals given the unmixing matrix.\n\nThis method helps visualizing signal quality and artifact rejection.\n\nParameters:\n\ninstinstance of Raw or Evoked\n\nThe signal to plot. If Raw, the raw data per channel type is displayed before and after cleaning. A second panel with the RMS for MEG sensors and the GFP for EEG sensors is displayed. If Evoked, butterfly traces for signals before and after cleaning will be superimposed.\n\nexcludearray_like of int | None (default)\n\nThe components marked for exclusion. If None (default), the components listed in ICA.exclude will be used.\n\npicksstr | array_like | slice | None\n\nChannels to include. Slices and lists of integers will be interpreted as channel indices. In lists, channel type strings (e.g., ['meg', 'eeg']) will pick channels of those types, channel name strings (e.g., ['MEG0111', 'MEG2623'] will pick the given channels. Can also be the string values “all” to pick all channels, or “data” to pick data channels. None (default) will pick all channels that were included during fitting.\n\nstart, stopfloat | None\n\nThe first and last time point (in seconds) of the data to plot. If inst is a Raw object, start=None and stop=None will be translated into start=0. and stop=3., respectively. For Evoked, None refers to the beginning and end of the evoked signal.\n\ntitlestr | None\n\nThe title of the generated figure. If None (default), no title is displayed.\n\nshowbool\n\nShow the figure if True.\n\nn_pca_componentsint | float | None\n\nThe number of PCA components to be kept, either absolute (int) or fraction of the explained variance (float). If None (default), the ica.n_pca_components from initialization will be used in 0.22; in 0.23 all components will be used.\n\nNew in v0.22.\n\non_baselinestr\n\nHow to handle baseline-corrected epochs or evoked data. Can be 'raise' to raise an error, 'warn' (default) to emit a warning, 'ignore' to ignore, or “reapply” to reapply the baseline after applying ICA.\n\nNew in v1.2.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nfiginstance of Figure\n\nThe figure.\n\nExamples using plot_overlay:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\nplot_properties(inst, picks=None, axes=None, dB=True, plot_std=True, log_scale=False, topomap_args=None, image_args=None, psd_args=None, figsize=None, show=True, reject='auto', reject_by_annotation=True, *, verbose=None)[source]#\n\nDisplay component properties.\n\nProperties include the topography, epochs image, ERP/ERF, power spectrum, and epoch variance.\n\nParameters:\n\ninstinstance of Epochs or Raw\n\nThe data to use in plotting properties.\n\nNote\n\nYou can interactively cycle through topographic maps for different channel types by pressing T.\n\npicksint | list of int | slice | None\n\nIndices of the independent components (ICs) to visualize. If an integer, represents the index of the IC to pick. Multiple ICs can be selected using a list of int or a slice. The indices are 0-indexed, so picks=1 will pick the second IC: ICA001. None will pick the first 5 components.\n\naxeslist of Axes | None\n\nList of five matplotlib axes to use in plotting: [topomap_axis, image_axis, erp_axis, spectrum_axis, variance_axis]. If None a new figure with relevant axes is created. Defaults to None.\n\ndBbool\n\nWhether to plot spectrum in dB. Defaults to True.\n\nplot_stdbool | float\n\nWhether to plot standard deviation/confidence intervals in ERP/ERF and spectrum plots. Defaults to True, which plots one standard deviation above/below for the spectrum. If set to float allows to control how many standard deviations are plotted for the spectrum. For example 2.5 will plot 2.5 standard deviation above/below. For the ERP/ERF, by default, plot the 95 percent parametric confidence interval is calculated. To change this, use ci in ts_args in image_args (see below).\n\nlog_scalebool\n\nWhether to use a logarithmic frequency axis to plot the spectrum. Defaults to False.\n\nNote\n\nYou can interactively toggle this setting by pressing L.\n\nNew in v1.1.\n\ntopomap_argsdict | None\n\nDictionary of arguments to plot_topomap. If None, doesn’t pass any additional arguments. Defaults to None.\n\nimage_argsdict | None\n\nDictionary of arguments to plot_epochs_image. If None, doesn’t pass any additional arguments. Defaults to None.\n\npsd_argsdict | None\n\nDictionary of arguments to compute_psd(). If None, doesn’t pass any additional arguments. Defaults to None.\n\nfigsizearray_like, shape (2,) | None\n\nAllows to control size of the figure. If None, the figure size defaults to [7., 6.].\n\nshowbool\n\nShow figure if True.\n\nreject‘auto’ | dict | None\n\nAllows to specify rejection parameters used to drop epochs (or segments if continuous signal is passed as inst). If None, no rejection is applied. The default is ‘auto’, which applies the rejection parameters used when fitting the ICA object.\n\nreject_by_annotationbool\n\nWhether to omit bad segments from the data before fitting. If True (default), annotated segments whose description begins with 'bad' are omitted. If False, no rejection based on annotations is performed.\n\nHas no effect if inst is not a mne.io.Raw object.\n\nNew in v0.21.0.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nfiglist\n\nList of matplotlib figures.\n\nNotes\n\nNew in v0.13.\n\nExamples using plot_properties:\n\nOverview of MEG/EEG analysis with MNE-Python\n\nOverview of MEG/EEG analysis with MNE-Python\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nplot_scores(scores, exclude=None, labels=None, axhline=None, title='ICA component scores', figsize=None, n_cols=None, show=True)[source]#\n\nPlot scores related to detected components.\n\nUse this function to asses how well your score describes outlier sources and how well you were detecting them.\n\nParameters:\n\nscoresarray_like of float, shape (n_ica_components,) | list of array\n\nScores based on arbitrary metric to characterize ICA components.\n\nexcludearray_like of int\n\nThe components marked for exclusion. If None (default), ICA.exclude will be used.\n\nlabelsstr | list | ‘ecg’ | ‘eog’ | None\n\nThe labels to consider for the axes tests. Defaults to None. If list, should match the outer shape of scores. If ‘ecg’ or ‘eog’, the labels_ attributes will be looked up. Note that ‘/’ is used internally for sublabels specifying ECG and EOG channels.\n\naxhlinefloat\n\nDraw horizontal line to e.g. visualize rejection threshold.\n\ntitlestr\n\nThe figure title.\n\nfigsizetuple of int | None\n\nThe figure size. If None it gets set automatically.\n\nn_colsint | None\n\nScores are plotted in a grid. This parameter controls how many to plot side by side before starting a new row. By default, a number will be chosen to make the grid as square as possible.\n\nshowbool\n\nShow figure if True.\n\nReturns:\n\nfiginstance of Figure\n\nThe figure object.\n\nExamples using plot_scores:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\nplot_sources(inst, picks=None, start=None, stop=None, title=None, show=True, block=False, show_first_samp=False, show_scrollbars=True, time_format='float', precompute=None, use_opengl=None, *, theme=None, overview_mode=None, splash=True)[source]#\n\nPlot estimated latent sources given the unmixing matrix.\n\nTypical usecases:\n\nplot evolution of latent sources over time based on (Raw input)\n\nplot latent source around event related time windows (Epochs input)\n\nplot time-locking in ICA space (Evoked input)\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nThe object to plot the sources from.\n\npicksint | list of int | slice | None\n\nIndices of the independent components (ICs) to visualize. If an integer, represents the index of the IC to pick. Multiple ICs can be selected using a list of int or a slice. The indices are 0-indexed, so picks=1 will pick the second IC: ICA001. None will pick all independent components in the order fitted.\n\nstart, stopfloat | int | None\n\nIf inst is a Raw or an Evoked object, the first and last time point (in seconds) of the data to plot. If inst is a Raw object, start=None and stop=None will be translated into start=0. and stop=3., respectively. For Evoked, None refers to the beginning and end of the evoked signal. If inst is an Epochs object, specifies the index of the first and last epoch to show.\n\ntitlestr | None\n\nThe window title. If None a default is provided.\n\nshowbool\n\nShow figure if True.\n\nblockbool\n\nWhether to halt program execution until the figure is closed. Useful for interactive selection of components in raw and epoch plotter. For evoked, this parameter has no effect. Defaults to False.\n\nshow_first_sampbool\n\nIf True, show time axis relative to the raw.first_samp.\n\nshow_scrollbarsbool\n\nWhether to show scrollbars when the plot is initialized. Can be toggled after initialization by pressing z (“zen mode”) while the plot window is focused. Default is True.\n\nNew in v0.19.0.\n\ntime_format‘float’ | ‘clock’\n\nStyle of time labels on the horizontal axis. If 'float', labels will be number of seconds from the start of the recording. If 'clock', labels will show “clock time” (hours/minutes/seconds) inferred from raw.info['meas_date']. Default is 'float'.\n\nNew in v0.24.\n\nprecomputebool | str\n\nWhether to load all data (not just the visible portion) into RAM and apply preprocessing (e.g., projectors) to the full data array in a separate processor thread, instead of window-by-window during scrolling. The default None uses the MNE_BROWSER_PRECOMPUTE variable, which defaults to 'auto'. 'auto' compares available RAM space to the expected size of the precomputed data, and precomputes only if enough RAM is available. This is only used with the Qt backend.\n\nNew in v0.24.\n\nChanged in version 1.0: Support for the MNE_BROWSER_PRECOMPUTE config variable.\n\nuse_openglbool | None\n\nWhether to use OpenGL when rendering the plot (requires pyopengl). May increase performance, but effect is dependent on system CPU and graphics hardware. Only works if using the Qt backend. Default is None, which will use False unless the user configuration variable MNE_BROWSER_USE_OPENGL is set to 'true', see mne.set_config().\n\nNew in v0.24.\n\nthemestr | path-like\n\nCan be “auto”, “light”, or “dark” or a path-like to a custom stylesheet. For Dark-Mode and automatic Dark-Mode-Detection, qdarkstyle and darkdetect, respectively, are required. If None (default), the config option MNE_BROWSER_THEME will be used, defaulting to “auto” if it’s not found. Only supported by the 'qt' backend.\n\nNew in v1.0.\n\noverview_modestr | None\n\nCan be “channels”, “empty”, or “hidden” to set the overview bar mode for the 'qt' backend. If None (default), the config option MNE_BROWSER_OVERVIEW_MODE will be used, defaulting to “channels” if it’s not found.\n\nNew in v1.1.\n\nsplashbool\n\nIf True (default), a splash screen is shown during the application startup. Only applicable to the qt backend.\n\nNew in v1.6.\n\nReturns:\n\nfigmatplotlib.figure.Figure | mne_qt_browser.figure.MNEQtBrowser\n\nBrowser instance.\n\nNotes\n\nFor raw and epoch instances, it is possible to select components for exclusion by clicking on the line. The selected components are added to ica.exclude on close.\n\nMNE-Python provides two different backends for browsing plots (i.e., raw.plot(), epochs.plot(), and ica.plot_sources()). One is based on matplotlib, and the other is based on PyQtGraph. You can set the backend temporarily with the context manager mne.viz.use_browser_backend(), you can set it for the duration of a Python session using mne.viz.set_browser_backend(), and you can set the default for your computer via mne.set_config('MNE_BROWSER_BACKEND', 'matplotlib') (or 'qt').\n\nNote\n\nFor the PyQtGraph backend to run in IPython with block=False you must run the magic command %gui qt5 first.\n\nNote\n\nTo report issues with the PyQtGraph backend, please use the issues of mne-qt-browser.\n\nNew in v0.10.0.\n\nExamples using plot_sources:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nsave(fname, *, overwrite=False, verbose=None)[source]#\n\nStore ICA solution into a fiff file.\n\nParameters:\n\nfnamepath-like\n\nThe absolute path of the file name to save the ICA solution into. The file name should end with -ica.fif or -ica.fif.gz.\n\noverwritebool\n\nIf True (default False), overwrite the destination file if it exists.\n\nNew in v1.0.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nicainstance of ICA\n\nThe object.\n\nSee also\n\nread_ica\n\nExamples using save:\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nscore_sources(inst, target=None, score_func='pearsonr', start=None, stop=None, l_freq=None, h_freq=None, reject_by_annotation=True, verbose=None)[source]#\n\nAssign score to components based on statistic or metric.\n\nParameters:\n\ninstinstance of Raw, Epochs or Evoked\n\nThe object to reconstruct the sources from.\n\ntargetarray_like | str | None\n\nSignal to which the sources shall be compared. It has to be of the same shape as the sources. If str, a routine will try to find a matching channel name. If None, a score function expecting only one input-array argument must be used, for instance, scipy.stats.skew (default).\n\nscore_funccallable() | str\n\nCallable taking as arguments either two input arrays (e.g. Pearson correlation) or one input array (e. g. skewness) and returns a float. For convenience the most common score_funcs are available via string labels: Currently, all distance metrics from scipy.spatial and All functions from scipy.stats taking compatible input arguments are supported. These function have been modified to support iteration over the rows of a 2D array.\n\nstartint | float | None\n\nFirst sample to include. If float, data will be interpreted as time in seconds. If None, data will be used from the first sample.\n\nstopint | float | None\n\nLast sample to not include. If float, data will be interpreted as time in seconds. If None, data will be used to the last sample.\n\nl_freqfloat\n\nLow pass frequency.\n\nh_freqfloat\n\nHigh pass frequency.\n\nreject_by_annotationbool\n\nWhether to omit bad segments from the data before fitting. If True (default), annotated segments whose description begins with 'bad' are omitted. If False, no rejection based on annotations is performed.\n\nNew in v0.14.0.\n\nverbosebool | str | int | None\n\nControl verbosity of the logging output. If None, use the default verbosity level. See the logging documentation and mne.verbose() for details. Should only be passed as a keyword argument.\n\nReturns:\n\nscoresndarray\n\nScores for each source as returned from score_func.\n\nExamples using mne.preprocessing.ICA#\n\nOverview of MEG/EEG analysis with MNE-Python\n\nOverview of MEG/EEG analysis with MNE-Python\n\nGetting started with mne.Report\n\nGetting started with mne.Report\n\nRepairing artifacts with ICA\n\nRepairing artifacts with ICA\n\nFind MEG reference channel artifacts\n\nFind MEG reference channel artifacts\n\nCompare the different ICA algorithms in MNE\n\nCompare the different ICA algorithms in MNE\n\nRemoving muscle ICA components\n\nRemoving muscle ICA components\n\nFrom raw data to dSPM on SPM Faces dataset\n\nFrom raw data to dSPM on SPM Faces dataset\n\nOn this page"
    }
}