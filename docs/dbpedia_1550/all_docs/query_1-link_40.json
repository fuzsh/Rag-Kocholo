{
    "id": "dbpedia_1550_1",
    "rank": 40,
    "data": {
        "url": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/kconfig.html",
        "read_more_link": "",
        "language": "en",
        "title": "IDF Programming Guide v5.3 documentation",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/_static/espressif-logo.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "en",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": "https://docs.espressif.com/projects/esp-idf/en/stable/esp32/api-reference/kconfig.html",
        "text": "Application build type\n\nFound in: Build type\n\nSelect the way the application is built.\n\nBy default, the application is built as a binary file in a format compatible with the ESP-IDF bootloader. In addition to this application, 2nd stage bootloader is also built. Application and bootloader binaries can be written into flash and loaded/executed from there.\n\nAnother option, useful for only very small and limited applications, is to only link the .elf file of the application, such that it can be loaded directly into RAM over JTAG or UART. Note that since IRAM and DRAM sizes are very limited, it is not possible to build any complex application this way. However for some kinds of testing and debugging, this option may provide faster iterations, since the application does not need to be written into flash.\n\nNote: when APP_BUILD_TYPE_RAM is selected and loaded with JTAG, ESP-IDF does not contain all the startup code required to initialize the CPUs and ROM memory (data/bss). Therefore it is necessary to execute a bit of ROM code prior to executing the application. A gdbinit file may look as follows (for ESP32):\n\n# Connect to a running instance of OpenOCD target remote :3333 # Reset and halt the target mon reset halt # Run to a specific point in ROM code, # where most of initialization is complete. thb *0x40007d54 c # Load the application into RAM load # Run till app_main tb app_main c\n\nExecute this gdbinit file as follows:\n\nxtensa-esp32-elf-gdb build/app-name.elf -x gdbinit\n\nExample gdbinit files for other targets can be found in tools/test_apps/system/gdb_loadable_elf/\n\nWhen loading the BIN with UART, the ROM will jump to ram and run the app after finishing the ROM startup code, so there's no additional startup initialization required. You can use the load_ram in esptool.py to load the generated .bin file into ram and execute.\n\nExample:\n\nesptool.py --chip {chip} -p {port} -b {baud} --no-stub load_ram {app.bin}\n\nRecommended sdkconfig.defaults for building loadable ELF files is as follows. CONFIG_APP_BUILD_TYPE_RAM is required, other options help reduce application memory footprint.\n\nCONFIG_APP_BUILD_TYPE_RAM=y CONFIG_VFS_SUPPORT_TERMIOS= CONFIG_NEWLIB_NANO_FORMAT=y CONFIG_ESP_SYSTEM_PANIC_PRINT_HALT=y CONFIG_ESP_DEBUG_STUBS_ENABLE= CONFIG_ESP_ERR_TO_NAME_LOOKUP=\n\nAvailable options:\n\nDefault (binary application + 2nd stage bootloader) (CONFIG_APP_BUILD_TYPE_APP_2NDBOOT)\n\nBuild app runs entirely in RAM (EXPERIMENTAL) (CONFIG_APP_BUILD_TYPE_RAM)\n\nApp compatible with bootloaders before ESP-IDF v2.1\n\nFound in: Build type\n\nBootloaders before ESP-IDF v2.1 did less initialisation of the system clock. This setting needs to be enabled to build an app which can be booted by these older bootloaders.\n\nIf this setting is enabled, the app can be booted by any bootloader from IDF v1.0 up to the current version.\n\nIf this setting is disabled, the app can only be booted by bootloaders from IDF v2.1 or newer.\n\nEnabling this setting adds approximately 1KB to the app's IRAM usage.\n\nDefault value:\n\nNo (disabled)\n\nApp compatible with bootloader and partition table before ESP-IDF v3.1\n\nFound in: Build type\n\nPartition tables before ESP-IDF V3.1 do not contain an MD5 checksum field, and the bootloader before ESP-IDF v3.1 cannot read a partition table that contains an MD5 checksum field.\n\nEnable this option only if your app needs to boot on a bootloader and/or partition table that was generated from a version *before* ESP-IDF v3.1.\n\nIf this option and Flash Encryption are enabled at the same time, and any data partitions in the partition table are marked Encrypted, then the partition encrypted flag should be manually verified in the app before accessing the partition (see CVE-2021-27926).\n\nDefault value:\n\nNo (disabled)\n\nEnable app rollback support\n\nFound in: Bootloader config\n\nAfter updating the app, the bootloader runs a new app with the \"ESP_OTA_IMG_PENDING_VERIFY\" state set. This state prevents the re-run of this app. After the first boot of the new app in the user code, the function should be called to confirm the operability of the app or vice versa about its non-operability. If the app is working, then it is marked as valid. Otherwise, it is marked as not valid and rolls back to the previous working app. A reboot is performed, and the app is booted before the software update. Note: If during the first boot a new app the power goes out or the WDT works, then roll back will happen. Rollback is possible only between the apps with the same security versions.\n\nDefault value:\n\nNo (disabled)\n\nSkip image validation when exiting deep sleep\n\nFound in: Bootloader config\n\nThis option disables the normal validation of an image coming out of deep sleep (checksums, SHA256, and signature). This is a trade-off between wakeup performance from deep sleep, and image integrity checks.\n\nOnly enable this if you know what you are doing. It should not be used in conjunction with using deep_sleep() entry and changing the active OTA partition as this would skip the validation upon first load of the new OTA partition.\n\nIt is possible to enable this option with Secure Boot if \"allow insecure options\" is enabled, however it's strongly recommended to NOT enable it as it may allow a Secure Boot bypass.\n\nDefault value:\n\nNo (disabled) if CONFIG_SECURE_BOOT && CONFIG_SECURE_BOOT_INSECURE\n\nSkip image validation from power on reset (READ HELP FIRST)\n\nFound in: Bootloader config\n\nSome applications need to boot very quickly from power on. By default, the entire app binary is read from flash and verified which takes up a significant portion of the boot time.\n\nEnabling this option will skip validation of the app when the SoC boots from power on. Note that in this case it's not possible for the bootloader to detect if an app image is corrupted in the flash, therefore it's not possible to safely fall back to a different app partition. Flash corruption of this kind is unlikely but can happen if there is a serious firmware bug or physical damage.\n\nFollowing other reset types, the bootloader will still validate the app image. This increases the chances that flash corruption resulting in a crash can be detected following soft reset, and the bootloader will fall back to a valid app image. To increase the chances of successfully recovering from a flash corruption event, keep the option BOOTLOADER_WDT_ENABLE enabled and consider also enabling BOOTLOADER_WDT_DISABLE_IN_USER_CODE - then manually disable the RTC Watchdog once the app is running. In addition, enable both the Task and Interrupt watchdog timers with reset options set.\n\nDefault value:\n\nNo (disabled)\n\nSkip image validation always (READ HELP FIRST)\n\nFound in: Bootloader config\n\nSelecting this option prevents the bootloader from ever validating the app image before booting it. Any flash corruption of the selected app partition will make the entire SoC unbootable.\n\nAlthough flash corruption is a very rare case, it is not recommended to select this option. Consider selecting \"Skip image validation from power on reset\" instead. However, if boot time is the only important factor then it can be enabled.\n\nDefault value:\n\nNo (disabled)\n\nEnable Aggressive key revoke strategy\n\nFound in: Security features\n\nIf this option is set, ROM bootloader will revoke the public key digest burned in efuse block if it fails to verify the signature of software bootloader with it. Revocation of keys does not happen when enabling secure boot. Once secure boot is enabled, key revocation checks will be done on subsequent boot-up, while verifying the software bootloader\n\nThis feature provides a strong resistance against physical attacks on the device.\n\nNOTE: Once a digest slot is revoked, it can never be used again to verify an image This can lead to permanent bricking of the device, in case all keys are revoked because of signature verification failure.\n\nDefault value:\n\nNo (disabled) if CONFIG_SECURE_BOOT && SOC_SUPPORT_SECURE_BOOT_REVOKE_KEY\n\nFlash bootloader along with other artifacts when using the default flash command\n\nFound in: Security features\n\nWhen Secure Boot V2 is enabled, by default the bootloader is not flashed along with other artifacts like the application and the partition table images, i.e. bootloader has to be separately flashed using the command idf.py bootloader flash, whereas, the application and partition table can be flashed using the command idf.py flash itself. Enabling this option allows flashing the bootloader along with the other artifacts by invocation of the command idf.py flash.\n\nIf this option is enabled make sure that even the bootloader is signed using the correct secure boot key, otherwise the bootloader signature verification would fail, as hash of the public key which is present in the bootloader signature would not match with the digest stored into the efuses and thus the device will not be able to boot up.\n\nDefault value:\n\nNo (disabled) if CONFIG_SECURE_BOOT_V2_ENABLED && CONFIG_SECURE_BOOT_BUILD_SIGNED_BINARIES\n\nHardware Key Encoding\n\nFound in: Security features\n\nIn reflashable secure bootloader mode, a hardware key is derived from the signing key (with SHA-256) and can be written to eFuse with espefuse.py.\n\nNormally this is a 256-bit key, but if 3/4 Coding Scheme is used on the device then the eFuse key is truncated to 192 bits.\n\nThis configuration item doesn't change any firmware code, it only changes the size of key binary which is generated at build time.\n\nAvailable options:\n\nNo encoding (256 bit key) (CONFIG_SECURE_BOOTLOADER_KEY_ENCODING_256BIT)\n\n3/4 encoding (192 bit key) (CONFIG_SECURE_BOOTLOADER_KEY_ENCODING_192BIT)\n\nEncrypt only the app image that is present in the partition of type app\n\nFound in: Security features\n\nIf set (default), optimise encryption time for the partition of type APP, by only encrypting the app image that is present in the partition, instead of the whole partition. The image length used for encryption is derived from the image metadata, which includes the size of the app image, checksum, hash and also the signature sector when secure boot is enabled.\n\nIf not set, the whole partition of type APP would be encrypted, which increases the encryption time but might be useful if there is any custom data appended to the firmware image.\n\nOffset of partition table\n\nFound in: Partition Table\n\nThe address of partition table (by default 0x8000). Allows you to move the partition table, it gives more space for the bootloader. Note that the bootloader and app will both need to be compiled with the same PARTITION_TABLE_OFFSET value.\n\nThis number should be a multiple of 0x1000.\n\nNote that partition offsets in the partition table CSV file may need to be changed if this value is set to a higher value. To have each partition offset adapt to the configured partition table offset, leave all partition offsets blank in the CSV file.\n\nDefault value:\n\n\"0x8000\"\n\nOptimization Level\n\nFound in: Compiler options\n\nThis option sets compiler optimization level (gcc -O argument) for the app.\n\nThe \"Debug\" setting will add the -0g flag to CFLAGS.\n\nThe \"Size\" setting will add the -0s flag to CFLAGS.\n\nThe \"Performance\" setting will add the -O2 flag to CFLAGS.\n\nThe \"None\" setting will add the -O0 flag to CFLAGS.\n\nThe \"Size\" setting cause the compiled code to be smaller and faster, but may lead to difficulties of correlating code addresses to source file lines when debugging.\n\nThe \"Performance\" setting causes the compiled code to be larger and faster, but will be easier to correlated code addresses to source file lines.\n\n\"None\" with -O0 produces compiled code without optimization.\n\nNote that custom optimization levels may be unsupported.\n\nCompiler optimization for the IDF bootloader is set separately, see the BOOTLOADER_COMPILER_OPTIMIZATION setting.\n\nAvailable options:\n\nDebug (-Og) (CONFIG_COMPILER_OPTIMIZATION_DEBUG)\n\nOptimize for size (-Os) (CONFIG_COMPILER_OPTIMIZATION_SIZE)\n\nOptimize for performance (-O2) (CONFIG_COMPILER_OPTIMIZATION_PERF)\n\nDebug without optimization (-O0) (CONFIG_COMPILER_OPTIMIZATION_NONE)"
    }
}