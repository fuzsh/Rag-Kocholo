{
    "id": "yago_19690_2",
    "rank": 48,
    "data": {
        "url": "https://deprogrammaticaipsum.com/how-to-choose-a-programming-language-for-your-book/",
        "read_more_link": "",
        "language": "en",
        "title": "How To Choose A Programming Language For Your Book",
        "top_image": "https://deprogrammaticaipsum.com/how-to-choose-a-programming-language-for-your-book/inaki-del-olmo-NIJuEQw0RKg-unsplash-scaled-e1597779724162.jpg",
        "meta_img": "https://deprogrammaticaipsum.com/how-to-choose-a-programming-language-for-your-book/inaki-del-olmo-NIJuEQw0RKg-unsplash-scaled-e1597779724162.jpg",
        "images": [
            "https://deprogrammaticaipsum.com/img/logo.png",
            "https://deprogrammaticaipsum.com/how-to-choose-a-programming-language-for-your-book/inaki-del-olmo-NIJuEQw0RKg-unsplash-scaled-e1597779724162.jpg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "Adrian Kosmaczewski"
        ],
        "publish_date": "2020-09-07T07:00:19",
        "summary": "",
        "meta_description": "If you wanted to write a book about any subject related to computers, but not specifically about a particular programming language, which language would you â¦",
        "meta_lang": "en",
        "meta_favicon": "/apple-touch-icon.png",
        "meta_site_name": "De Programmatica Ipsum",
        "canonical_link": "https://deprogrammaticaipsum.com/how-to-choose-a-programming-language-for-your-book/",
        "text": "If you wanted to write a book about any subject related to computers, but not specifically about a particular programming language, which language would you choose? For example: if you wanted to teach programming concepts (algorithms, patterns) to an absolute beginner, which language would convey your thoughts better? Say, if you had to explain algorithms that could be implemented in any Turing-complete language, which one would you pick, and why?\n\nThis problem is not new. As this edition of the Library section coincides with the 25th anniversary of Java, I decided to look back in time to see which languages were chosen in famous (and not so famous) computer books. Of course, we are leaving aside all books called âThe X Programming Language,â since the answer for the question is, invariable, the X programming language, whatever X might be.\n\nEarly Examples\n\nLet us begin with âThe Art of Computer Programmingâ (1968), a book about which Graham wrote an article in a previous edition. To illustrate the various themes of the book, Donald Knuth invented his own programming language. Actually not one but two; MIX, used in the first editions, and a RISC version called MMIX for the latest ones. Designing a programming language for your own book is akin to J. R. R. Tolkien creating his own languages to tell a story; it is certainly fair to say that Knuthâs work can be easily compared to Tolkienâs, if not in popularity, definitely in magnitude and reputation.\n\nSomewhat similar, Niklaus Wirth used his own Pascal language to illustrate the classic âAlgorithms + Data Structures = Programsâ (1976); the book describes a Tiny Pascal compiler, which is said to have inspired Anders Hejlsberg to create Turbo Pascal. We can add Brad Cox to the same club, whose âObject Oriented Programming: An Evolutionary Approachâ (1986) title, also the subject of a popular article by Graham, uses Objective-C as a tool to explain OO concepts which were quite novel at the time.\n\nLater authors have understandably preferred to use existing languages; for example âThe Elements of Programming Styleâ (1974) by Brian W. Kernighan and P. J. Plauger. In this case the authors chose Fortran and PL/I:\n\nâ¦since these languages are widely used and are sufficiently similar that a reading knowledge of one means that the other can also be read well enough.\n\nThe Reign of C/C++\n\nThe rise of Object Oriented Programming (OOP) had it hallmark moment in the 1980s and 1990s. And at the beginning of this craze, the most widely used language to explain it was C++.\n\nI will start with the book that taught me OOP: my beloved copy of âObject-Oriented Analysis and Design with Applications (2nd edition)â (1994) by Grady Booch, which represented also my first exposure to C++ code examples. Grady Booch is one of the âthree amigosâ who came up with UML and in 2002 IBM bought their company. Interestingly, the 3rd edition of this opus (2007) has examples in C# and Java.\n\nOOP begat the design patterns movement, incarnated by two major books: âDesign Patterns for Object-Oriented Software Developmentâ (1994) by Wolfgang Pree, a title that got sadly, unjustly, and immediately shadowed by the success of the eponymous âDesign Patterns: Elements of Reusable Object-Oriented Softwareâ (1994) by the âGang of Fourâ: Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides. Both books, released one year before the smashing release of Java, show examples in C++.\n\nC++, largely thanks to the legendary speed attributed to its name, found a niche in numerical and financial processing back in the 1990s, starting a slow industrial demise of Fortran. In this sense it is worthwhile to mention âNumerical Recipes: The Art of Scientific Computing (3rd edition)â (2007) whose first edition (published in 1992) featured two distinct versions: one in C and another in Fortran. As for financial modeling, we can mention âModeling Derivatives in C++â (2004) by Justin London, and the excellent âFinancial Instrument Pricing Using C++â (2004) by Daniel J. Duffy, recently updated to C++11 in a second edition (2018).\n\nRegardless of when they are published, some low-level topics are better explained using C. Examples are the both extraordinary and fundamental âLinux Programming Interfaceâ (2011) by Michael Kerrisk, and âBeejâs Guide to Network Programming: Using Internet Socketsâ (2019) by Brian âBeej Jorgensenâ Hall.\n\nJava Takes Over\n\nBut in 1995, just as the World Wide Web was making headlines, Sun released Java and became, in just a few years, one of the most popular programming languages ever created. Book authors took notice, and promptly started using it in their work. Since Java was being actively marketed as a âbetterâ or âsimplifiedâ C++, it was quickly considered that it would make programming books immediately more approachable. The rest is history.\n\nMartin Fowlerâs âRefactoring: Improving the Design of Existing Codeâ (2000) and âProgram Development in Java: Abstraction, Specification, and Object-Oriented Designâ (2000) by John Guttag and Barbara Liskov (Graham wrote about her and this book in this magazine) are two major examples of early books centered around Java.\n\nKathy Sierraâs Head First series in OâReilly (read the article dedicated to her in this magazine) relied heavily in Java for two major titles: âHead First Design Patternsâ (2004) and âHead First Object-Oriented Analysis and Designâ (2006).\n\nIn the area of university textbooks, âComputer Networking: A Top-Down Approach Featuring the Internetâ (2004) by James F. Kurose and Keith W. Ross features a âtop down approachâ starting at the OSI Application layer, with many code examples in Java. Similarly, âSchaumâs Outline of Principles of Computer Scienceâ (2008) by Paul Tymann and Carl Reynolds followed the trend, firmly set in the early 2000s, of university Computer Science programs based in Java.\n\nGrady Booch was not the only one of the âthree amigosâ to use Java in their books: âThe Unified Modeling Language User Guide (2nd Edition)â (2005) by Grady Booch, James Rumbaugh and Ivar Jacobson features examples in JavaBeans (and COM), while âAspect Oriented Software Development with Use Casesâ (2004) by Ivar Jacobson and Pan-Wei Ng uses AspectJ (an extension to the Java language.)\n\nBeyond Java\n\nBy 2005 everybody was raving about Agile and Open Source and Web 2.0. In the middle of that frenzy, a young man called David Heinemeier Hansson presented a new web framework called Ruby on Rails. The recording of a demo explaining how to create a blog engine in 15 minutes, was then uploaded to a new platform called YouTube you might have heard about since. Besides proving that Mac OS X was a suitable programming platform, or that TextMate was a very nice editor, this video galvanized a whole generation to the notion that there were simpler languages than Java. Those thoughts were condensed in Bruce Tateâs âBeyond Javaâ book. These were the times where âthink differentâ meant something.\n\nThe reaction was immediate, and programming books started exploring other languages. The essential âPython Programming: An Introduction to Computer Scienceâ (2004) by John M. Zelle (recently updated to its third edition) uses Python. âProgramming Collective Intelligenceâ (2007) by Toby Segaran used Python as well. âRESTful Web Servicesâ (2007) by by Leonard Richardson and Sam Ruby usesâ¦ Ruby, as the authors say:\n\nWe chose Ruby because itâs concise and easy to read, even for programmers who donât know the language. (And because itâs nice and confusing in conjunction with Samâs last name.)\n\nThis trend continues to today. Two interesting examples are âThe Imposterâs Handbookâ (2016) by Rob Conery, which uses JavaScript, while âDomain Modeling Made Functionalâ (2018) by Scott Wlaschin is based in F#.\n\nOutsiders\n\nOf course not everybody falls in the buckets defined above. Some absolute classics have taken orthogonal routes, in some cases with great success.\n\nWe must mention them: âStructure and Interpretation of Computer Programsâ (1984), also called the âWizard Bookâ, by Hal Abelson, Jerry Sussman and Julie Sussman, which uses Lisp. âSpecifying Systemsâ (2003) by Leslie Lamport uses the TLA+ formal specification language. âObject-Oriented Software Constructionâ (1988) by Bertrand Meyer (which we have covered previously in this section) uses Eiffel. âIntroduction to Functional Programmingâ (1988) by Richard Bird & Philip Wadler uses Miranda. And more recently, âAPÂ® Computer Science Principles with Swiftâ (2019) by Apple Education showcases its newest programming language, Swift.\n\nMITâs âIntroduction to Algorithms, Third Editionâ (2009) by Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest and Clifford Stein uses a special pseudocode that, for the third edition, took a shape closer to Java, C, C++ and Python.\n\nFinally, in a category of its own, âAn Introduction to Functional Programming Through Lambda Calculusâ (2011) by Greg Michaelson deserves a special mention; the book illustrates all concepts through lambda calculus. But we know since Alonzo Church that lambda calculus is akin to a model of computation and can simulate a Turing machineâ¦ well, it is probably a programming language in its own right.\n\nCriteria\n\nSo, how does an author choose a programming language? There are a few factors that come into play. First, there is definitely hype and vendor lobbying; or, as others would call it, âmarket demandâ which would explain choices such as Java, Swift, and various .NET languages to appear in teaching curricula.\n\nLet us consider the target audience; are we talking to math majors, computer science PhDs, or practical programmers? Not to mention the themes of interest of such audiences; which explains why most Artificial Intelligence Machine Learning titles overwhelmingly feature examples in Python. Similarly, mathematically-oriented books will lately prefer Python today to Fortran; in both cases, the rise in popularity of NumPy was enough to drive the choice of the programming language.\n\nTeachers prefer some programming paradigms to others. For books explaining concepts around Object Oriented Programming, C++ and Java are overwhelminly used. For functional programming, though, the choice is a bit larger.\n\nWhat about cross-platform issues? Should all students use the same operating system, or could they learn on whichever one they prefer? In a related fashion, is open source a criteria to consider for the choice of a learning language?\n\nFinally, there is the approachability of the language; how easy is it to read or write it? Is there a Read-eval-print loop (REPL) available for the language? Experience shows that being able to write lines of Ruby, JavaScript, or Python code in a REPL accelerates the adoption of a language, instead of having to setup a complex toolchain to be able to compile and test a simple program.\n\nThe Polyglot Approach\n\nIn the humble opinion of the author of these words, there is no better choice of programming language than many of them at the same time. Quite a few hallmark books have adopted this strategy, which yields rich, diverse books, using the full strength of each chosen language and, at the same time, automatically expanding the horizons of readers.\n\nAs Steve Yegge once said,\n\nBut you should take anything a âJava programmerâ tells you with a hefty grain of salt, because an âX programmerâ, for any value of X, is a weak player. You have to cross-train to be a decent athlete these days. Programmers need to be fluent in multiple languages with fundamentally different âcharacterâ before they can make truly informed design decisions.\n\nFrom the 1980s, come to mind âThe Peter Norton Programmerâs Guide to the IBM PCâ (1985), whose last chapter explains Assembler, Basic, Pascal and C. Also from that era, âCompilers: Principles, Techniques, and Toolsâ (1986) also known as the âDragon Book,â by Alfred V. Aho, Monica S. Lam, Ravi Sethi, and Jeffrey D. Ullman, whose chapters show a mix of FORTRAN, C, EQN, Modula-2, and shows a compiler for a subset of Pascal as a project at the end of the book.\n\nMore recently, âWriting Secure Code, Second Editionâ (2002) by Michael Howard and David LeBlanc, illustrates common security vulnerabilities in code with examples written in C, C++, Perl, VBScript, JScript, SQL, Visual Basic.NET, and C#. The âDinosaur Bookâ âOperating System Concepts, Seventh Editionâ (2005) by Abraham Silberschatz, Peter B. Galvin and Greg Gagne, uses C code snippets illustrating the Win32 API, as well as Java for some higher-level concepts such as threads, file locking, and others. The widely celebrated âWorking Effectively with Legacy Codeâ (2004) by Michael Feathers uses Java, C++ and C â the latter two, as expected, to show âlegacyâ code. Finally, Deitel & Deitelâs series âHow to Programâ feature books in C++, Java, C#, Visual Basic, and other languages.\n\nI would like to highlight as well, although it is not a book per se, the excellent Stanford Course CS107 âProgramming Paradigmsâ (2008) where professor Jerry Cain explains various subjects using C, Assembly, C++, Scheme and Python.\n\nI will finish with a quote I could not agree more with, borrowed from âCode Complete (2nd edition)â (2004) by Steve McConnell, and which summarizes my thoughts in this matter:\n\nThe examples are in multiple languages because mastering more than one language is often a watershed in the career of a profesional programmer.\n\nCover photo by IÃ±aki del Olmo on Unsplash.\n\nContinue reading Issue 023: Academia or go back to Issue 024: Java. Did you like this article? Consider subscribing to our newsletter or contributing to the sustainability of this magazine. Thanks!"
    }
}