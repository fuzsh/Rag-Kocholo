{
    "id": "yago_19690_1",
    "rank": 71,
    "data": {
        "url": "https://github.com/ascherer/mmix/blob/master/mmix-doc.w",
        "read_more_link": "",
        "language": "en",
        "title": "mmix/mmix-doc.w at master · ascherer/mmix",
        "top_image": "https://opengraph.githubassets.com/ca00104624fafdb06e8f8ec65b68364a7add38b7a36d1d4c2b448e213d58e847/ascherer/mmix",
        "meta_img": "https://opengraph.githubassets.com/ca00104624fafdb06e8f8ec65b68364a7add38b7a36d1d4c2b448e213d58e847/ascherer/mmix",
        "images": [],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "MMIX 2009 – a RISC computer for the third millennium - mmix/mmix-doc.w at master · ascherer/mmix",
        "meta_lang": "en",
        "meta_favicon": "https://github.com/fluidicon.png",
        "meta_site_name": "GitHub",
        "canonical_link": "https://github.com/ascherer/mmix/blob/master/mmix-doc.w",
        "text": "% This file is part of the MMIXware package (c) Donald E Knuth 1999\n\n@i boilerplate.w %<< legal stuff: PLEASE READ IT BEFORE MAKING ANY CHANGES!\n\n\\def\\title{MMIX}\n\n\\input epsf % input macros for dvips to include METAPOST illustrations\n\n\\def\\MMIX{\\.{MMIX}}\n\n\\def\\NNIX{\\hbox{\\mc NNIX}}\n\n\\def\\Hex#1{\\hbox{$^{\\scriptscriptstyle\\#}$\\tt#1}} % experimental hex constant\n\n\\def\\beginword{\\vcenter\\bgroup\\let\\\\=\\wordrule\\halign\\bgroup&\\hfil##\\hfil\\cr}\n\n\\def\\endword{\\noalign{\\vskip\\baselineskip}\\egroup\\egroup\n\n\\advance\\belowdisplayskip-\\baselineskip}\n\n\\def\\wordrule{\\vrule height 9.5pt depth 4.5pt width .4pt}\n\n\\newdimen\\bitwd \\bitwd=6.6pt\n\n\\def\\field#1#2{\\vrule depth 3pt width 0pt \\hbox to#1\\bitwd{\\hss$#2$\\hss}}\n\n\\def\\XF{\\\\{XF}}\\def\\XM{\\\\{XM}}\\def\\XD{\\\\{XD}} % these not in \\tt\n\n\\def\\PC{\\\\{PC}}\n\n\\def\\Jx{\\.{J}} % conversely, I type J_ to get J in \\tt\n\n\\def\\s{{\\rm s}}\n\n\\def\\rX{{\\rm\\$X}} \\def\\rY{{\\rm\\$Y}} \\def\\rZ{{\\rm\\$Z}}\n\n\\def\\mm{{\\rm M}} \\def\\xx{{\\rm X}} \\def\\yy{{\\rm Y}} \\def\\zz{{\\rm Z}}\n\n%\\def\\ll{{\\rm L}} \\def\\gg{{\\rm G}}\n\n\\def\\ll{L} \\def\\gg{G}\n\n\\def\\?{\\mkern-1mu}\n\n\\def\\9#1{} % this is used for sort keys in the index via @@:sort key}{entry@@>\n\n@* Introduction to MMIX.\n\nThirty-eight years have passed since the \\.{MIX} computer was designed, and\n\ncomputer architecture has been converging during those years\n\ntowards a rather different\n\nstyle of machine. Therefore it is time to replace \\.{MIX} with a new\n\ncomputer that contains even less saturated fat than its predecessor.\n\nExercise 1.3.1--25 in the third edition of\n\n{\\sl Fundamental Algorithms\\/} speaks of an extended\n\n\\.{MIX} called MixMaster, which is upward compatible with the old version.\n\nBut MixMaster itself is hopelessly obsolete; although it allows for\n\nseveral gigabytes of memory, we can't even use it with {\\mc ASCII} code to\n\nget lowercase letters. And ouch, the standard subroutine calling convention\n\nof \\.{MIX} is irrevocably based on self-modifying code! Decimal arithmetic\n\nand self-modifying code were popular in 1962, but they sure have disappeared\n\nquickly as machines have gotten bigger and faster. A completely new\n\ndesign is called for, based on the principles of RISC architecture as\n\nexpounded in {\\sl Computer Architecture\\/} by Hennessy and Patterson\n\n(Morgan Kaufmann, 1996). % first ed was \"Morgan Kaufman\"! but now \"nn\" is legit\n\n@^Hennessy, John LeRoy@>\n\n@^Patterson, David Andrew@>\n\nSo here is \\MMIX, a computer that will totally replace \\.{MIX}\n\nin the ``ultimate'' editions of {\\sl The Art of Computer Programming},\n\nVolumes 1--3, and in the first editions of the remaining volumes.\n\nI~must confess that\n\nI~can hardly wait to own a computer like this.\n\nHow do you pronounce \\MMIX? I've been saying ``em-mix'' to myself,\n\nbecause the first `\\.M' represents a new millennium. Therefore I~use\n\nthe article ``an'' instead of~``a'' before the name \\MMIX\\\n\nin English phrases like ``an \\MMIX\\ simulator.''\n\nIncidentally, the {\\sl Dictionary of American Regional English\\/ \\bf3} (1996)\n\nlists ``mommix'' as a common dialect word used both as a noun and a verb;\n\nto mommix something means to botch it, to bollix it. Only time will\n\ntell whether I~have mommixed the definition of \\MMIX.\n\n@ The original \\.{MIX} computer could be operated without an operating\n\nsystem; you could bootstrap it with punched cards or paper tape and do\n\neverything yourself. But nowadays such power is no longer in the hands of\n\nordinary users. The \\MMIX\\ hardware, like all other computing machines\n\nmade today, relies on an operating system to get jobs\n\nstarted in their own address spaces and to provide I/O capabilities.\n\nWhenever anybody has asked if I will be writing about operating systems,\n\nmy reply has always been ``Nix.'' Therefore the name of\\/ \\MMIX's operating\n\nsystem, \\NNIX, will come as no surprise.\n\n@:NNIX}{\\NNIX\\ operating system@>\n\n@^operating system@>\n\nFrom time to time I will necessarily have to refer to things that \\NNIX\\ does\n\nfor its users, but I am unable to build \\NNIX\\ myself. Life is\n\ntoo short. It would be wonderful if some expert in operating system design\n\nbecame inspired to write a book that explains exactly how to construct a nice,\n\nclean \\NNIX\\ kernel for an \\MMIX\\ chip.\n\n@ I am deeply grateful to the many people who have helped me shape the behavior\n\nof\\/ \\MMIX. In particular, John Hennessy and (especially) Dick Sites\n\nhave made significant contributions.\n\n@^Hennessy, John LeRoy@>\n\n@^Sites, Richard Lee@>\n\n@ A programmer's introduction to \\MMIX\\ appears in ``Volume~1, Fascicle~1,''\n\n@^Fascicle 1@>\n\na booklet containing tutorial material that will ultimately appear in the\n\nfourth edition of {\\sl The Art of Computer Programming}.\n\nThe description in the following sections is rather different, because\n\nwe are concerned about a complete implementation, including all of the\n\nfeatures used by the operating system and invisible to normal programs.\n\nHere it is important to emphasize exceptional cases that were glossed over\n\nin the tutorial, and~to consider\n\nnitpicky details about things that might go wrong.\n\n@* MMIX basics.\n\n\\MMIX\\ is a 64-bit RISC machine with at least 256 general-purpose registers\n\nand a 64-bit address space.\n\nEvery instruction is four bytes long and has the form\n\n$$\\vcenter{\\offinterlineskip\n\n\\def\\\\#1&{\\omit&#1&}\n\n\\hrule\n\n\\halign{&\\vrule#&\\hbox to 4em{\\tt\\hfil#\\hfil}\\cr\n\nheight 9pt depth4pt&OP&&X&&Y&&Z&\\cr}\n\n\\hrule}\\,.$$\n\nThe 256 possible OP codes fall into a dozen or so easily remembered\n\n@^OP codes@>\n\ncategories; an instruction usually means, ``Set register X to the\n\nresult of\\/ Y~OP~Z\\null.'' For example,\n\n$$\\vcenter{\\offinterlineskip\n\n\\def\\\\#1&{\\omit&#1&}\n\n\\hrule\n\n\\halign{&\\vrule#&\\hbox to 4em{\\tt\\hfil#\\hfil}\\cr\n\nheight 9pt depth4pt&32&&1&&2&&3&\\cr}\n\n\\hrule}$$\n\nsets register~1 to the sum of registers 2 and 3.\n\nA few instructions combine the Y and Z bytes into\n\na 16-bit YZ field; two of the jump instructions use a 24-bit XYZ field.\n\nBut the three bytes X, Y, Z usually have three-pronged significance\n\nindependent of each other.\n\nInstructions are usually represented in a symbolic form corresponding\n\nto the \\MMIX\\ assembly language, in which each operation code has a mnemonic\n\nname. For example, operation~32 is \\.{ADD}, and the instruction above\n\nmight be written `\\.{ADD} \\.{\\$1,\\$2,\\$3}'; a dollar sign `\\.\\$' symbolizes\n\na register number. In general, the instruction\n\n\\.{ADD}~\\.{\\$X,\\$Y,\\$Z} is the operation of setting $\\rX=\\rY+\\rZ$.\n\nAn assembly language instruction with two commas has three operand\n\nfields X, Y,~Z; an instruction with one comma has two operand fields\n\nX,~YZ; an instruction with no comma has one operand field,~XYZ;\n\nan instruction with no operands has $\\xx=\\yy=\\zz=0$.\n\n\\def\\0{\\$Z\\char'174Z}\n\nMost instructions have two forms, one in which the Z field stands for\n\nregister \\$Z, and one in which Z is an unsigned ``immediate'' constant.\n\n@^immediate operands@>\n\nThus, for example, the command `\\.{ADD} \\.{\\$X,\\$Y,\\$Z}' has a counterpart\n\n`\\.{ADD} \\.{\\$X,\\$Y,Z}', which sets $\\rX=\\rY+\\zz$. Immediate constants\n\nare always nonnegative.\n\nIn the descriptions\n\nbelow we will introduce such pairs of instructions\n\nby writing just `\\.{ADD}~\\.{\\$X,\\$Y,\\0}' instead of naming both\n\ncases explicitly.\n\nThe operation code for \\.{ADD}~\\.{\\$X,\\$Y,\\$Z} is 32, but the operation\n\ncode for \\.{ADD}~\\.{\\$X,\\$Y,Z} is~33. The \\MMIX\\ assembler chooses the correct\n\ncode by noting whether the third argument is a register number or~not.\n\nRegister numbers and constants can be given symbolic names; for example, the\n\nassembly language instruction `\\.x~\\.{IS}~\\.{\\$1}' makes \\.x an\n\nabbreviation for register number~1. Similarly, `\\.{FIVE}~\\.{IS}~\\.5'\n\nmakes \\.{FIVE} an abbreviation for the constant~5.\n\nAfter these abbreviations have been specified, the instruction\n\n\\.{ADD}~\\.{x,x,FIVE} increases \\$1 by~5, using opcode~33, while\n\nthe instruction \\.{ADD}~\\.{x,x,x} doubles \\$1 using opcode~32.\n\nSymbolic names that stand for register numbers\n\nconventionally begin with a lowercase letter, while names that stand\n\nfor constants conventionally begin with an uppercase letter.\n\nThis convention is not actually enforced by the assembler,\n\nbut it tends to reduce a programmer's confusion.\n\n@ A {\\it nybble\\/} is a 4-bit quantity, often used to denote a decimal\n\nor hexadecimal digit.\n\nA {\\it byte\\/} is an 8-bit quantity, often used to denote an alphanumeric\n\ncharacter in {\\mc ASCII} code. The Unicode standard extends {\\mc ASCII} to\n\n@^Unicode@>\n\n@^ASCII@>\n\nessentially all the world's languages by using 16-bit-wide characters called\n\n{\\it wydes\\/}. (Weight watchers know that two nybbles make one byte,\n\nbut two bytes make one wyde.)\n\nIn the discussion below we use the term\n\n{\\it tetrabyte\\/} or ``tetra'' for a 4-byte quantity, and the similar term\n\n@^nybble@>\n\n@^byte@>\n\n@^wyde@>\n\n@^tetrabyte@>\n\n@^octabyte@>\n\n{\\it octabyte\\/} or ``octa'' for an 8-byte quantity. Thus, a tetra is\n\ntwo wydes, an octa is two tetras; an octabyte has 64~bits. Each \\MMIX\\\n\nregister can be thought of as containing one octabyte, or two tetras,\n\nor four wydes, or eight bytes, or sixteen nybbles.\n\nWhen bytes, wydes, tetras, and octas represent numbers they are said to be\n\neither {\\it signed\\/} or {\\it unsigned}. An unsigned byte is a number between\n\n0~and $2^8-1=255$ inclusive; an unsigned wyde lies, similarly, between\n\n0~and $2^{16}-1=65535$; an unsigned tetra lies between\n\n0~and $2^{32}-1=4{,}294{,}967{,}295$; an unsigned octa lies between\n\n0~and $2^{64}-1=18{,}446{,}744{,}073{,}709{,}551{,}615$.\n\nTheir signed counterparts use the\n\nconventions of two's complement notation, by subtracting respectively $2^8$,\n\n$2^{16}$, $2^{32}$, or~$2^{64}$ times the most significant bit. Thus,\n\nthe unsigned bytes 128 through 255 are regarded as the numbers $-128$\n\nthrough~$-1$ when they are evaluated as signed bytes; a signed byte therefore\n\nlies between $-128$ and $+127$, inclusive. A signed wyde is a number\n\nbetween $-32768$ and $+32767$; a signed tetra lies between\n\n$-2{,}147{,}483{,}648$ and $+2{,}147{,}483{,}647$; a signed octa lies between\n\n$-9{,}223{,}372{,}036{,}854{,}775{,}808$ and $+9{,}223{,}372{,}036{,}854{,}775{,}807$.\n\nThe virtual memory of\\/ \\MMIX\\ is an array M of $2^{64}$ bytes. If $k$ is any\n\nunsigned octabyte, M[$k$]~is a 1-byte quantity. \\MMIX\\ machines do not\n\nactually have such vast memories, but programmers can act as if $2^{64}$ bytes\n\nare indeed present, because \\MMIX\\ provides address translation mechanisms by\n\nwhich an operating system can maintain this illusion.\n\nWe use the notation $\\mm_{2^t}[k]$ to stand for a number consisting of\n\n$2^t$~consecutive bytes starting at location~$k\\land\\nobreak(2^{64}-2^t)$.\n\n(The notation $k\\land(2^{64}-2^t)$ means that the least\n\nsignificant $t$ bits of~$k$ are set to~0, and only the least 64~bits\n\n@^bit stuffing@>\n\nof the resulting address are retained. Similarly, the notation\n\n$k\\lor(2^t-1)$ means that the least significant $t$ bits of~$k$ are set to~1.)\n\nAll accesses to $2^t$-byte quantities by \\MMIX\\ are {\\it aligned}, in the sense\n\nthat the first byte is a multiple of~$2^t$.\n\nAddressing is always ``big-endian.'' In other words, the\n\n@^big-endian versus little-endian@>\n\n@^little-endian versus big-endian@>\n\nmost significant (leftmost) byte of $\\mm_{2^t}[k]$ is\n\n$\\mm_1[k\\land\\nobreak(2^{64}-2^t)]$\n\nand the least significant (rightmost) byte is $\\mm_1[k\\lor(2^t-1)]$.\n\nWe use the notation $\\s(\\mm_{2^t}[k])$ when we want to regard\n\nthis $2^t$-byte number as a {\\it signed\\/} integer.\n\nFormally speaking, if $l=2^t$,\n\n@^signed integers@>\n\n$$\\s(\\mm_l[k])=\\bigl(\\mm_1[k\\land(-l)]\\,\\mm_1[k\\land(-l)+1]\\,\\ldots\\,\n\n\\mm_1[k\\lor(l-1)]\\bigr)_{256}\n\n-2^{8l}[\\mm_1[k\\land(-l)]\\!\\ge\\!128].$$\n\n@* Loading and storing.\n\nSeveral instructions can be used to get information from memory into\n\nregisters. For example, the ``load tetra unsigned'' instruction\n\n\\.{LDTU} \\.{\\$1,\\$4,\\$5}\n\nputs the four bytes $\\mm_4[\\$4+\\$5]$ into register~1 as an unsigned\n\ninteger;\n\nthe most significant four bytes of register~1 are set to zero.\n\nThe similar instruction \\.{LDT} \\.{\\$1,\\$4,\\$5}, ``load tetra,'' sets\n\n\\$1 to the {\\it signed\\/} integer $\\s(\\mm_4[\\$4+\\$5])$.\n\n(Instructions generally treat numbers as\n\n@^signed integers@>\n\nsigned unless the operation code specifically calls them\n\nunsigned.) In the signed case, the most significant four bytes of the\n\nregister will be copies of the most significant bit of the tetrabyte\n\nloaded; thus they will be all~0s or all~1s, depending on whether the\n\nnumber is $\\ge0$ or $<0$.\n\n\\def\\bull{\\smallbreak\\textindent{$\\bullet$}}\n\n\\def\\bul{\\par\\textindent{$\\bullet$}}\n\n\\def\\<#1 #2 {\\.{#1}~\\.{#2} }\n\n\\def\\>{\\hfill\\break}\n\n\\bull\\<LDB \\$X,\\$Y,\\0 `load byte'.\\>\n\n@.LDB@>\n\nByte $\\s(\\mm[\\rY+\\rZ])$ or $\\s(\\mm[\\rY+\\zz])$ is loaded into register~X as a\n\nsigned number between $-128$ and $+127$, inclusive.\n\n\\bull\\<LDBU \\$X,\\$Y,\\0 `load byte unsigned'.@>\n\n@.LDBU@>\n\nByte $\\mm[\\rY+\\rZ]$ or $\\mm[\\rY+\\zz]$ is loaded into register~X as an\n\nunsigned number between $0$ and $255$, inclusive.\n\n\\bull\\<LDW \\$X,\\$Y,\\0 `load wyde'.\\>\n\n@.LDW@>\n\nBytes $\\s(\\mm_2[\\rY+\\rZ])$ or $\\s(\\mm_2[\\rY+\\zz])$\n\nare loaded into register~X as a signed number between $-32768$ and $+32767$,\n\ninclusive. As mentioned above, our notation $\\mm_2[k]$ implies that\n\nthe least significant bit of the address $\\rY+\\rZ$ or $\\rY+\\zz$ is\n\nignored and assumed to be~0.\n\n@^bit stuffing@>\n\n\\bull\\<LDWU \\$X,\\$Y,\\0 `load wyde unsigned'.@>\n\n@.LDWU@>\n\nBytes $\\mm_2[\\rY+\\rZ]$ or $\\mm_2[\\rY+\\zz]$ are loaded\n\ninto register~X as an unsigned number between $0$ and $65535$, inclusive.\n\n\\bull\\<LDT \\$X,\\$Y,\\0 `load tetra'.\\>\n\n@.LDT@>\n\nBytes $\\s(\\mm_4[\\rY+\\rZ])$ or $\\s(\\mm_4[\\rY+\\zz])$\n\nare loaded into register~X as a signed number between $-2{,}147{,}483{,}648$ and\n\n$+2{,}147{,}483{,}647$, inclusive.\n\nAs mentioned above, our notation $\\mm_4[k]$ implies that\n\nthe two least significant bits of the address $\\rY+\\rZ$ or $\\rY+\\zz$ are\n\nignored and assumed to be~0.\n\n@^bit stuffing@>\n\n\\bull\\<LDTU \\$X,\\$Y,\\0 `load tetra unsigned'.\\>\n\n@.LDTU@>\n\nBytes $\\mm_4[\\rY+\\rZ]$ or $\\mm_4[\\rY+\\zz]$\n\nare loaded into register~X as an unsigned number between 0 and\n\n4{,}294{,}967{,}296, inclusive.\n\n\\bull\\<LDO \\$X,\\$Y,\\0 `load octa'.\\>\n\n@.LDO@>\n\nBytes $\\mm_8[\\rY+\\rZ]$ or $\\mm_8[\\rY+\\zz]$ are loaded into\n\nregister~X\\null.\n\nAs mentioned above, our notation $\\mm_8[k]$ implies that\n\nthe three least significant bits of the address $\\rY+\\rZ$ or $\\rY+\\zz$ are\n\nignored and assumed to be~0.\n\n@^bit stuffing@>\n\n\\bull\\<LDOU \\$X,\\$Y,\\0 `load octa unsigned'.\\>\n\n@.LDOU@>\n\nBytes $\\mm_8[\\rY+\\rZ]$ or $\\mm_8[\\rY+\\zz]$ are loaded into\n\nregister~X\\null. There is in fact no difference between the behavior of\n\n\\.{LDOU} and~\\.{LDO}, since\n\nan octabyte can be regarded as either signed or unsigned. \\.{LDOU} is included\n\nin \\MMIX\\ just for completeness and consistency, in spite of the fact that\n\na foolish consistency is the hobgoblin of little minds.\n\n@^Emerson, Ralph Waldo@>\n\n(Niklaus Wirth made a strong plea for such consistency in his early critique\n\nof System/360; see {\\sl JACM\\/ \\bf15} (1967), 37--74.)\n\n@^Wirth, Niklaus Emil@>\n\n@^System/360@>\n\n\\bull\\<LDHT \\$X,\\$Y,\\0 `load high tetra'.\\>\n\n@.LDHT@>\n\nBytes $\\mm_4[\\rY+\\rZ]$ or $\\mm_4[\\rY+\\zz]$ are loaded into the most\n\nsignificant half of register~X, and the least significant half is\n\ncleared to zero. (One use of ``high tetra arithmetic'' is to detect\n\noverflow easily when tetrabytes are added or subtracted.)\n\n\\bull\\<LDA \\$X,\\$Y,\\0 `load address'.\\>\n\nThe address $\\rY+\\rZ$ or $\\rY+\\zz$ is loaded into register~X. This\n\ninstruction is simply another name for the \\.{ADDU} instruction\n\ndiscussed below; it can\n\nbe used when the programmer is thinking of memory addresses\n\ninstead of numbers.\n\nThe \\MMIX\\ assembler converts \\.{LDA} into the same OP-code as \\.{ADDU}.\n\n@.LDA@>\n\n@.ADDU@>\n\n@ Another family of instructions goes the other way, storing registers into\n\nmemory. For example, the ``store octa immediate'' command\n\n\\<STO \\$3,\\$2,17 puts the current contents of register~3\n\ninto $\\mm_8[\\$2+17]$.\n\n\\bull\\<STB \\$X,\\$Y,\\0 `store byte'.\\>\n\n@.STB@>\n\nThe least significant byte of register~X is stored into\n\nbyte $\\mm[\\rY+\\rZ]$ or $\\mm[\\rY+\\zz]$. An integer overflow exception occurs if\n\n@^overflow@>\n\n\\$X is not between $-128$ and $+127$. (We will discuss overflow and other\n\nkinds of exceptions later.)\n\n\\bull\\<STBU \\$X,\\$Y,\\0 `store byte unsigned'.@>\\>\n\n@.STBU@>\n\nThe least significant byte of register~X is stored into\n\nbyte $\\mm[\\rY+\\rZ]$ or $\\mm[\\rY+\\zz]$. \\.{STBU} instructions are the same\n\nas \\.{STB} instructions, except that no test for overflow is made.\n\n\\bull\\<STW \\$X,\\$Y,\\0 `store wyde'.\\>\n\n@.STW@>\n\nThe two least significant bytes of register~X are stored into\n\nbytes $\\mm_2[\\rY+\\rZ]$ or $\\mm_2[\\rY+\\zz]$.\n\nAn integer overflow exception occurs if\n\n\\$X is not between $-32768$ and $+32767$.\n\n\\bull\\<STWU \\$X,\\$Y,\\0 `store wyde unsigned'.@>\\>\n\n@.STWU@>\n\nThe two least significant bytes of register~X are stored into\n\nbytes $\\mm_2[\\rY+\\rZ]$ or $\\mm_2[\\rY+\\zz]$.\n\n\\.{STWU} instructions are the same\n\nas \\.{STW} instructions, except that no test for overflow is made.\n\n\\bull\\<STT \\$X,\\$Y,\\0 `store tetra'.\\>\n\n@.STT@>\n\nThe four least significant bytes of register~X are stored into\n\nbytes $\\mm_4[\\rY+\\rZ]$ or $\\mm_4[\\rY+\\zz]$.\n\nAn integer overflow exception occurs if\n\n\\$X is not between $-2{,}147{,}483{,}648$ and $+2{,}147{,}483{,}647$.\n\n\\bull\\<STTU \\$X,\\$Y,\\0 `store tetra unsigned'.\\>\n\n@.STTU@>\n\nThe four least significant bytes of register~X are stored into\n\nbytes $\\mm_4[\\rY+\\rZ]$ or $\\mm_4[\\rY+\\zz]$.\n\n\\.{STTU} instructions are the same\n\nas \\.{STT} instructions, except that no test for overflow is made.\n\n\\bull\\<STO \\$X,\\$Y,\\0 `store octa'.\\>\n\n@.STO@>\n\nRegister X is stored into bytes $\\mm_8[\\rY+\\rZ]$ or\n\n$\\mm_8[\\rY+\\zz]$.\n\n\\bull\\<STOU \\$X,\\$Y,\\0 `store octa unsigned'.\\>\n\n@.STOU@>\n\nIdentical to \\.{STO} \\.{\\$X,\\$Y,\\0}.\n\n\\bull\\<STCO X,\\$Y,\\0 `store constant octabyte'.\\>\n\n@.STCO@>\n\nAn octabyte whose value is the unsigned byte X is stored into\n\n$\\mm_8[\\rY+\\rZ]$ or $\\mm_8[\\rY+\\zz]$.\n\n\\bull\\<STHT \\$X,\\$Y,\\0 `store high tetra'.\\>\n\nThe most significant four bytes of register~X are stored into\n\n$\\mm_4[\\rY+\\rZ]$ or $\\mm_4[\\rY+\\zz]$.\n\n@.STHT@>\n\n@* Adding and subtracting.\n\nOnce numbers are in registers, we can compute with them. Let's consider\n\naddition and subtraction first.\n\n\\bull\\<ADD \\$X,\\$Y,\\0 `add'.\\>\n\n@.ADD@>\n\nThe sum $\\rY+\\rZ$ or $\\rY+\\zz$ is placed into register~X using signed,\n\ntwo's complement arithmetic.\n\nAn integer overflow exception occurs if the sum is $\\ge2^{63}$ or $<-2^{63}$.\n\n(We will discuss overflow and other kinds of exceptions later.)\n\n@^overflow@>\n\n\\bull\\<ADDU \\$X,\\$Y,\\0 `add unsigned'.\\>\n\n@.ADDU@>\n\nThe sum $(\\rY+\\rZ)\\bmod2^{64}$ or $(\\rY+\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\nThese instructions are the same\n\nas \\.{ADD}~\\.{\\$X,\\$Y,\\0} commands\n\nexcept that no test for overflow is made.\n\n(Overflow could be detected if desired by using the command\n\n\\<CMPU ovflo,\\$X,\\$Y after addition, where \\.{CMPU} means\n\n@.CMPU@>\n\n``compare unsigned''; see below.)\n\n\\bull\\<2ADDU \\$X,\\$Y,\\0 `times 2 and add unsigned'.\\>\n\n@.2ADDU@>\n\nThe sum $(2\\rY+\\rZ)\\bmod2^{64}$ or $(2\\rY+\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\n\\bull\\<4ADDU \\$X,\\$Y,\\0 `times 4 and add unsigned'.\\>\n\n@.4ADDU@>\n\nThe sum $(4\\rY+\\rZ)\\bmod2^{64}$ or $(4\\rY+\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\n\\bull\\<8ADDU \\$X,\\$Y,\\0 `times 8 and add unsigned'.\\>\n\n@.8ADDU@>\n\nThe sum $(8\\rY+\\rZ)\\bmod2^{64}$ or $(8\\rY+\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\n\\bull\\<16ADDU \\$X,\\$Y,\\0 `times 16 and add unsigned'.\\>\n\n@.16ADDU@>\n\nThe sum $(16\\rY+\\rZ)\\bmod2^{64}$ or $(16\\rY+\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\n\\bull\\<SUB \\$X,\\$Y,\\0 `subtract'.\\>\n\n@.SUB@>\n\nThe difference $\\rY-\\rZ$ or $\\rY-\\zz$ is placed into register~X using\n\nsigned, two's complement arithmetic.\n\nAn integer overflow exception occurs if the difference is $\\ge2^{63}$ or\n\n$<-2^{63}$.\n\n\\bull\\<SUBU \\$X,\\$Y,\\0 `subtract unsigned'.\\>\n\n@.SUBU@>\n\nThe difference $(\\rY-\\rZ)\\bmod2^{64}$ or $(\\rY-\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\nThese two instructions are the same\n\nas \\.{SUB}~\\.{\\$X,\\$Y,\\0} except that no test for overflow is made.\n\n\\bull\\<NEG \\$X,Y,\\0 `negate'.\\>\n\n@.NEG@>\n\nThe value $\\yy-\\rZ$ or $\\yy-\\zz$ is placed into register~X using\n\nsigned, two's complement arithmetic.\n\nAn integer overflow exception occurs if the result is greater\n\nthan~$2^{63}-\\nobreak1$.\n\n(Notice that in this case \\MMIX\\ works with the ``immediate'' constant~Y,\n\nnot register~Y\\null. \\.{NEG} commands are analogous to the immediate variants\n\nof other commands, because they save us from having to put one-byte\n\nconstants into a register. When $\\yy=0$, overflow occurs if and\n\nonly if $\\rZ=-2^{63}$. The instruction \\<NEG \\$X,1,2 has exactly the\n\nsame effect as \\.{NEG}~\\.{\\$X,0,1}.)\n\n\\bull\\<NEGU \\$X,Y,\\0 `negate unsigned'.\\>\n\n@.NEGU@>\n\nThe value $(\\yy-\\rZ)\\bmod2^{64}$ or $(\\yy-\\zz)\\bmod2^{64}$\n\nis placed into register~X\\null.\n\n\\.{NEGU} instructions are the same\n\nas \\.{NEG} instructions, except that no test for overflow is made.\n\n@* Bit fiddling.\n\nBefore looking at multiplication and division, which take longer than\n\naddition and subtraction, let's look at some of the other things that\n\n\\MMIX\\ can do fast. There are eighteen instructions for bitwise\n\nlogical operations on unsigned numbers.\n\n\\bull\\<AND \\$X,\\$Y,\\0 `bitwise and'.\\>\n\n@.AND@>\n\nEach bit of register Y is logically anded with the corresponding bit of\n\nregister~Z or of the constant~Z, and the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~1 if and only if the\n\ncorresponding bits of the operands are both~1;\n\nin symbols, $\\rX=\\rY\\land\\rZ$ or $\\rX=\\rY\\land\\zz$.\n\nThis means in particular that \\<AND \\$X,\\$Y,Z always zeroes out the seven\n\nmost significant bytes of register~X, because 0s are prefixed to the\n\nconstant byte~Z\\null.\n\n\\bull\\<OR \\$X,\\$Y,\\0 `bitwise or'.\\>\n\n@.OR@>\n\nEach bit of register Y is logically ored with the corresponding bit of\n\nregister~Z or of the constant~Z, and the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~0 if and only if the\n\ncorresponding bits of the operands are both~0;\n\nin symbols, $\\rX=\\rY\\lor\\rZ$ or $\\rX=\\rY\\lor\\zz$.\n\nIn the special case $\\zz=0$, the immediate variant of\n\nthis command simply copies register~Y to\n\nregister~X\\null. The \\MMIX\\ assembler allows us to write\n\n`\\.{SET}~\\.{\\$X,\\$Y}' as a convenient abbreviation for\n\n`\\.{OR}~\\.{\\$X,\\$Y,0}'.\n\n@.SET@>\n\n\\bull\\<XOR \\$X,\\$Y,\\0 `bitwise exclusive-or'.\\>\n\n@.XOR@>\n\nEach bit of register Y is logically xored with the corresponding bit of\n\nregister~Z or of the constant~Z, and the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~0 if and only if the\n\ncorresponding bits of the operands are equal;\n\nin symbols, $\\rX=\\rY\\oplus\\rZ$ or $\\rX=\\rY\\oplus\\zz$.\n\n\\bull\\<ANDN \\$X,\\$Y,\\0 `bitwise and-not'.\\>\n\n@.ANDN@>\n\nEach bit of register Y is logically anded with the complement of the\n\ncorresponding bit of\n\nregister~Z or of the constant~Z, and the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~1 if and only if the\n\ncorresponding bit of register~Y is~1 and the other corresponding bit is~0;\n\nin symbols, $\\rX=\\rY\\setminus\\rZ$ or $\\rX=\\rY\\setminus\\zz$.\n\n(This is the {\\it logical difference\\/} operation; if the operands\n\nare bit strings representing sets, we are computing the elements that\n\nlie in one set but not the other.)\n\n\\bull\\<ORN \\$X,\\$Y,\\0 `bitwise or-not'.\\>\n\n@.ORN@>\n\nEach bit of register Y is logically ored with the complement of the\n\ncorresponding bit of\n\nregister~Z or of the constant~Z, and the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~1 if and only if the\n\ncorresponding bit of register~Y is greater than or equal to the other corresponding bit;\n\nin symbols, $\\rX=\\rY\\lor\\overline\\rZ$\n\nor $\\rX=\\rY\\lor\\overline\\zz$.\n\n(This is the complement of $\\rZ\\setminus\\rY$ or $\\zz\\setminus\\rY$.)\n\n\\bull\\<NAND \\$X,\\$Y,\\0 `bitwise not-and'.\\>\n\n@.NAND@>\n\nEach bit of register Y is logically anded with the corresponding bit of\n\nregister~Z or of the constant~Z, and the complement of the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~0 if and only if the\n\ncorresponding bits of the operands are both~1;\n\nin symbols, $\\rX=\\rY\\mathbin{\\overline\\land}\\rZ$ or\n\n$\\rX=\\rY\\mathbin{\\overline\\land}\\zz$.\n\n\\bull\\<NOR \\$X,\\$Y,\\0 `bitwise not-or'.\\>\n\n@.NOR@>\n\nEach bit of register Y is logically ored with the corresponding bit of\n\nregister~Z or of the constant~Z, and the complement of the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~1 if and only if the\n\ncorresponding bits of the operands are both~0;\n\nin symbols, $\\rX=\\rY\\mathbin{\\overline\\lor}\\rZ$ or\n\n$\\rX=\\rY\\mathbin{\\overline\\lor}\\zz$.\n\n\\bull\\<NXOR \\$X,\\$Y,\\0 `bitwise not-exclusive-or'.\\>\n\n@.NAND@>\n\nEach bit of register Y is logically xored with the corresponding bit of\n\nregister~Z or of the constant~Z, and the complement of the result is placed in register~X\\null.\n\nIn other words, a bit of register~X is set to~1 if and only if the\n\ncorresponding bits of the operands are equal;\n\nin symbols, $\\rX=\\rY\\mathbin{\\overline\\oplus}\\rZ$ or\n\n$\\rX=\\rY\\mathbin{\\overline\\oplus}\\zz$.\n\n\\bull\\<MUX \\$X,\\$Y,\\0 `bitwise multiplex'.\\>\n\n@.MUX@>\n\nFor each bit position~$j$, the $j$th bit of register~X is set either to\n\nbit~$j$ of register~Y\n\nor to bit~$j$ of the other operand \\$Z~or~Z, depending on\n\nwhether bit~$j$ of the special {\\it mask register\\/}~rM is 1 or 0:\n\n@^rM@>\n\nif ${\\rm M}_j$ then $\\yy_j$ else~$\\zz_j$.\n\nIn symbols, $\\rm\\rX=(\\rY\\land rM)\\lor(\\rZ\\land\\overline{rM})$ or\n\n$\\rm\\rX=(\\rY\\land rM)\\lor(\\zz\\land\\overline{rM})$.\n\n(\\MMIX\\ has several such special registers, associated with instructions that\n\nneed more than two inputs or produce more than one output.)\n\n@ Besides the eighteen bitwise operations, \\MMIX\\ can also perform unsigned\n\nbytewise and biggerwise operations that are somewhat more exotic.\n\n\\bull\\<BDIF \\$X,\\$Y,\\0 `byte difference'.\\>\n\n@.BDIF@>\n\nFor each byte position~$j$, the $j$th byte of register~X is set to byte~$j$ of\n\nregister~Y minus byte~$j$ of the other operand \\$Z~or~Z, unless that\n\ndifference is negative; in the latter case, byte~$j$ of~\\$X is set to zero.\n\n\\bull\\<WDIF \\$X,\\$Y,\\0 `wyde difference'.\\>\n\n@.WDIF@>\n\nFor each wyde position~$j$, the $j$th wyde of register~X is set to wyde~$j$ of\n\nregister~Y minus wyde~$j$ of the other operand \\$Z~or~Z, unless that\n\ndifference is negative; in the latter case, wyde~$j$ of~\\$X is set to zero.\n\n\\bull\\<TDIF \\$X,\\$Y,\\0 `tetra difference'.\\>\n\n@.TDIF@>\n\nFor each tetra position~$j$, the $j$th tetra of register~X is set to tetra~$j$ of\n\nregister~Y minus tetra~$j$ of the other operand \\$Z~or~Z, unless that\n\ndifference is negative; in the latter case, tetra~$j$ of~\\$X is set to zero.\n\n\\bull\\<ODIF \\$X,\\$Y,\\0 `octa difference'.\\>\n\n@.ODIF@>\n\nRegister~X is set to register~Y minus the other operand \\$Z~or~Z, unless\n\n\\$Z~or~Z exceeds register~Y; in the latter case,\n\n\\$X~is set to zero. The operands are treated as unsigned integers.\n\n\\smallskip\n\nThe \\.{BDIF} and \\.{WDIF} commands are useful\n\nin applications to graphics or video; \\.{TDIF} and \\.{ODIF} are also\n\npresent for reasons of consistency. For example, if \\.a and \\.b are\n\nregisters containing\n\n8-byte quantities, their bytewise maxima~\\.c and\n\nbytewise minima~\\.d are computed by\n\n$$\\hbox{\\tt BDIF x,a,b; ADDU c,x,b; SUBU d,a,x;}$$\n\nsimilarly, the individual ``pixel differences'' \\.e, namely the absolute\n\nvalues of the differences of corresponding bytes, are computed by\n\n$$\\hbox{\\tt BDIF x,a,b; BDIF y,b,a; OR e,x,y.}$$\n\nTo add individual\n\nbytes of \\.a and \\.b while clipping all sums to 255 if they don't fit\n\nin a single byte, one can say\n\n$$\\hbox{\\tt NOR acomp,a,0; BDIF x,acomp,b; NOR clippedsums,x,0;}$$\n\nin other words, complement \\.a, apply \\.{BDIF}, and complement the result.\n\nThe operations can also be used to construct efficient operations on\n\nstrings of bytes or wydes.\n\n@^graphics@>\n\n@^pixels@>\n\n@^saturating arithmetic@>\n\n@^nybble@>\n\nExercise: Implement a ``nybble difference'' instruction that operates\n\nin a similar way on sixteen nybbles at a time.\n\nAnswer: {\\tt\\spaceskip=.5em minus .3em\n\nAND x,a,m; AND y,b,m; ANDN xx,a,m; ANDN yy,b,m;\n\nBDIF x,x,y; BDIF xx,xx,yy; OR ans,x,xx} where register \\.m contains\n\nthe mask \\Hex{0f0f0f0f0f0f0f0f}.\n\n(The \\.{ANDN} operation can be regarded as\n\na ``bit difference'' instruction that operates\n\nin a similar way on 64 bits at a time.)\n\n@ Three more pairs of bit-fiddling instructions round out the collection of exotics.\n\n\\bull\\<SADD \\$X,\\$Y,\\0 `sideways add'.\\>\n\n@.SADD@>\n\nEach bit of register Y is logically anded with the complement of the\n\ncorresponding bit of\n\nregister~Z or of the constant~Z, and the number of 1~bits in the\n\nresult is placed in register~X\\null.\n\nIn other words, register~X is set to the number of bit positions\n\nin which register~Y has a~1 and the other operand has a~0;\n\nin symbols, $\\rX=\\nu(\\rY\\setminus\\rZ)$ or $\\rX=\\nu(\\rY\\setminus\\zz)$.\n\nWhen the second operand is zero this operation is sometimes called\n\n``population counting,'' because it counts the number of 1s in register~Y\\null.\n\n@^population counting@>\n\n@^counting ones@>\n\n\\bull\\<MOR \\$X,\\$Y,\\0 `multiple or'.\\>\n\n@.MOR@>\n\nSuppose the 64 bits of register Y are indexed as\n\n$$y_{00}y_{01}\\ldots y_{07}y_{10}y_{11}\\ldots y_{17}\\ldots\n\ny_{70}y_{71}\\ldots y_{77};$$\n\nin other words, $y_{ij}$ is the $j$th bit of the $i$th byte, if we\n\nnumber the bits and bytes from 0 to 7 in big-endian fashion from left to right.\n\nLet the bits of the other operand, \\$Z or~Z, be indexed similarly:\n\n$$z_{00}z_{01}\\ldots z_{07}z_{10}z_{11}\\ldots z_{17}\\ldots\n\nz_{70}z_{71}\\ldots z_{77}.$$\n\nThe \\.{MOR} operation replaces each bit $x_{ij}$ of register~X by the bit\n\n$$ y_{0j}z_{i0}\\lor y_{1j}z_{i1}\\lor \\cdots \\lor y_{7j}z_{i7}.$$\n\nThus, for example, if register Z contains the constant\n\n\\Hex{0102040810204080},\n\n\\.{MOR} reverses the order of the bytes in register~Y, converting between\n\nlittle-endian and big-endian addressing.\n\n@^big-endian versus little-endian@>\n\n@^little-endian versus big-endian@>\n\n(The $i$th byte of~\\$X depends on the bytes of~\\$Y as specified by the\n\n$i$th byte of~\\$Z or~Z\\null. If we regard\n\n64-bit words as $8\\times8$ Boolean matrices, with one byte per column,\n\nthis operation computes the\n\nBoolean product $\\rX=\\rY\\,\\rZ$ or $\\rX=\\rY\\,\\zz$. Alternatively, if we\n\nregard 64-bit words as $8\\times8$ matrices with one byte per~{\\it row},\n\n\\.{MOR} computes the Boolean product $\\rX=\\rZ\\,\\rY$ or $\\rX=\\zz\\,\\rY$\n\nwith operands in the opposite order. The immediate form\n\n\\<MOR \\$X,\\$Y,Z always sets the leading seven bytes of register~X\n\nto zero; the other byte is set to the bitwise or of whatever bytes of\n\nregister~Y are specified by the immediate operand~Z\\null.)\n\nExercise: Explain how to compute a mask \\.m that is \\Hex{ff} in byte\n\npositions where \\.a exceeds \\.b, \\Hex{00} in all other bytes.\n\nAnswer: \\.{BDIF}~\\.{x,a,b;} \\.{MOR}~\\.{m,minusone,x;}\n\nhere \\.{minusone} is a register consisting of all 1s. (Moreover,\n\nif we \\.{AND} this result\n\nwith \\Hex{8040201008040201}, then \\.{MOR} with $\\zz=255$, we get\n\na one-byte encoding~of~\\.m.)\n\n\\bull\\<MXOR \\$X,\\$Y,\\0 `multiple exclusive-or'.\\>\n\n@.MXOR@>\n\nThis operation is like the Boolean multiplication just discussed, but\n\nexclusive-or is used to combine the bits. Thus we obtain a matrix\n\nproduct over the field of two elements instead of a Boolean matrix product.\n\nThis operation can be used to construct hash functions, among many other things.\n\n(The hash functions aren't bad, but they are not ``universal'' in the\n\nsense of {\\sl Sorting and Searching}, exercise 6.4--72.)\n\n@^matrices of bits@>\n\n@^Boolean multiplication@>\n\n@ Sixteen ``immediate wyde'' instructions are available for the common\n\ncase that a 16-bit constant is needed. In this case the Y~and~Z fields\n\nof the instruction are regarded as a single 16-bit unsigned number~YZ\\null.\n\n@^immediate operands@>\n\n\\bull\\<SETH \\$X,YZ `set to high wyde';\n\n@.SETH@>\n\n\\<SETMH \\$X,YZ `set to medium high wyde';\n\n@.SETMH@>\n\n\\<SETML \\$X,YZ `set to medium low wyde';\n\n@.SETML@>\n\n\\<SETL \\$X,YZ `set to low wyde'.\\>\n\n@.SETL@>\n\nThe 16-bit unsigned number YZ is shifted left\n\nby either 48 or 32 or 16 or 0 bits, respectively, and placed into register~X\\null.\n\nThus, for example, \\.{SETML} inserts\n\na given value into the second-least-significant wyde of register~X and\n\nsets the other three wydes to zero.\n\n\\bull\\<INCH \\$X,YZ `increase by high wyde';\n\n@.INCH@>\n\n\\<INCMH \\$X,YZ `increase by medium high wyde';\n\n@.INCMH@>\n\n\\<INCML \\$X,YZ `increase by medium low wyde';\n\n@.INCML@>\n\n\\<INCL \\$X,YZ `increase by low wyde'.\\>\n\n@.INCL@>\n\nThe 16-bit unsigned number YZ is shifted left\n\nby either 48 or 32 or 16 or 0 bits, respectively, and added to register~X,\n\nignoring overflow; the result is placed back into register~X\\null.\n\nIf YZ is the hexadecimal constant \\Hex{8000}, the command \\<INCH \\$X,YZ\n\ncomplements the most significant bit of register~X\\null. We will see\n\nbelow that this can be used to negate a floating point number.\n\n@^negation, floating point@>\n\n\\bull\\<ORH \\$X,YZ `bitwise or with high wyde';\n\n@.ORH@>\n\n\\<ORMH \\$X,YZ `bitwise or with medium high wyde';\n\n@.ORMH@>\n\n\\<ORML \\$X,YZ `bitwise or with medium low wyde';\n\n@.ORML@>\n\n\\<ORL \\$X,YZ `bitwise or with low wyde'.\\>\n\n@.ORL@>\n\nThe 16-bit unsigned number YZ is shifted left\n\nby either 48 or 32 or 16 or 0 bits, respectively, and ored with register~X;\n\nthe result is placed back into register~X\\null.\n\nNotice that any desired 4-wyde constant \\.{GH} \\.{IJ} \\.{KL} \\.{MN}\n\ncan be inserted into a register with a sequence of four instructions\n\nsuch as\n\n$$\\hbox{\\tt SETH \\$X,GH; INCMH \\$X,IJ; INCML \\$X,KL; INCL \\$X,MN;}$$\n\nany of these \\.{INC} instructions could also be replaced by \\.{OR}.\n\n\\bull\\<ANDNH \\$X,YZ `bitwise and-not high wyde';\n\n@.ANDNH@>\n\n\\<ANDNMH \\$X,YZ `bitwise and-not medium high wyde';\\>\n\n@.ANDNMH@>\n\n\\<ANDNML \\$X,YZ `bitwise and-not medium low wyde';\n\n@.ANDNML@>\n\n\\<ANDNL \\$X,YZ `bitwise and-not low wyde'.\\>\n\n@.ANDNL@>\n\nThe 16-bit unsigned number YZ is shifted left\n\nby either 48 or 32 or 16 or 0 bits, respectively, then\n\ncomplemented and anded with register~X;\n\nthe result is placed back into register~X\\null.\n\nIf YZ is the hexadecimal\n\nconstant \\Hex{8000}, the command \\<ANDNH \\$X,YZ forces the most significant\n\nbit of register~X to be~0. This can be used to compute the absolute value of\n\na floating point number.\n\n@^absolute value, floating point@>\n\n@ \\MMIX\\ knows several ways to shift a register left or right\n\nby any number of bits.\n\n\\bull\\<SL \\$X,\\$Y,\\0 `shift left'.\\>\n\n@.SL@>\n\nThe bits of register~Y are shifted left by \\$Z or Z places, and 0s\n\nare shifted in from the right; the result is placed in register~X\\null.\n\nRegister~Y is treated as a signed number, but\n\nthe second operand is treated as an unsigned number.\n\nThe effect is the same as multiplication by\n\n$2^{\\mkern1mu\\rZ}$ or by $2^\\zz$; an integer overflow exception occurs if the\n\nresult is $\\ge2^{63}$ or $<-2^{63}$.\n\nIn particular, if the second operand is 64 or~more, register~X will\n\nbecome entirely zero, and integer overflow will be signaled unless\n\nregister~Y was zero.\n\n\\bull\\<SLU \\$X,\\$Y,\\0 `shift left unsigned'.\\>\n\n@.SLU@>\n\nThe bits of register~Y are shifted left by \\$Z or Z places, and 0s\n\nare shifted in from the right; the result is placed in register~X\\null.\n\nBoth operands are treated as unsigned numbers. The \\.{SLU} instructions\n\nare equivalent to \\.{SL}, except that no test for overflow is made.\n\n\\bull\\<SR \\$X,\\$Y,\\0 `shift right'.\\>\n\n@.SR@>\n\nThe bits of register~Y are shifted right by \\$Z or Z places, and copies\n\nof the leftmost bit (the sign bit) are shifted in from the left; the result is\n\nplaced in register~X\\null.\n\nRegister~Y is treated as a signed number, but\n\nthe second operand is treated as an unsigned number.\n\nThe effect is the same as division by $2^{\\mkern1mu\\rZ}$ or by\n\n$2^\\zz$ and rounding down. In particular, if the second operand is 64 or~more,\n\nregister~X will become zero if \\$Y was nonnegative, $-1$ if \\$Y was negative.\n\n\\bull\\<SRU \\$X,\\$Y,\\0 `shift right unsigned'.\\>\n\n@.SRU@>\n\nThe bits of register~Y are shifted right by \\$Z or Z places, and 0s\n\nare shifted in from the left; the result is placed in register~X\\null.\n\nBoth operands are treated as unsigned numbers.\n\nThe effect is the same as unsigned division of a 64-bit number\n\nby $2^{\\mkern1mu\\rZ}$ or by~$2^\\zz$;\n\nif the second operand is 64 or~more, register~X will become entirely~zero.\n\n@* Comparisons.\n\nArithmetic and logical operations are nice,\n\nbut computer programs also need to compare numbers\n\nand to change the course of a calculation depending on what they find.\n\n\\MMIX\\ has four comparison instructions to facilitate such decision-making.\n\n\\bull\\<CMP \\$X,\\$Y,\\0 `compare'.\\>\n\n@.CMP@>\n\nRegister X is set to $-1$ if register Y is less than register Z or less than\n\nthe unsigned immediate value~Z, using the conventions of signed\n\narithmetic; it is set to 0 if register~Y is equal to register Z or equal to\n\nthe unsigned immediate value~Z; otherwise it is set to~1.\n\nIn symbols, $\\rX=[\\rY\\!>\\!\\rZ]-[\\rY\\!<\\!\\rZ]$ or $\\rX=[\\rY\\!>\\!\\zz]-[\\rY\\!<\\!\\zz]$.\n\n\\bull\\<CMPU \\$X,\\$Y,\\0 `compare unsigned'.\\>\n\n@.CMPU@>\n\nRegister X is set to $-1$ if register Y is less than register Z or less than\n\nthe unsigned immediate value Z, using the conventions of unsigned\n\narithmetic; it is set to 0 if register Y is equal to register Z or equal to\n\nthe unsigned immediate value~Z; otherwise it is set to~1.\n\nIn symbols, $\\rX=[\\rY\\!>\\!\\rZ]-[\\rY\\!<\\!\\rZ]$ or $\\rX=[\\rY\\!>\\!\\zz]-[\\rY\\!<\\!\\zz]$.\n\n@ There also are 32 conditional instructions, which choose quickly between\n\ntwo alternative courses of action.\n\n\\bull\\<CSN \\$X,\\$Y,\\0 `conditionally set if negative'.\\>\n\n@.CSN@>\n\nIf register Y is negative (namely if its most significant bit is~1),\n\nregister~X is set to the contents of register~Z or to the\n\nunsigned immediate value~Z. Otherwise nothing happens.\n\n\\bull\\<CSZ \\$X,\\$Y,\\0 `conditionally set if zero'.\n\n@.CSZ@>\n\n\\bul\\<CSP \\$X,\\$Y,\\0 `conditionally set if positive'.\n\n@.CSP@>\n\n\\bul\\<CSOD \\$X,\\$Y,\\0 `conditionally set if odd'.\n\n@.CSOD@>\n\n\\bul\\<CSNN \\$X,\\$Y,\\0 `conditionally set if nonnegative'.\n\n@.CSNN@>\n\n\\bul\\<CSNZ \\$X,\\$Y,\\0 `conditionally set if nonzero'.\n\n@.CSNZ@>\n\n\\bul\\<CSNP \\$X,\\$Y,\\0 `conditionally set if nonpositive'.\n\n@.CSNP@>\n\n\\bul\\<CSEV \\$X,\\$Y,\\0 `conditionally set if even'.\\>\n\n@.CSEV@>\n\nThese instructions are entirely analogous to \\.{CSN}, except\n\nthat register~X changes only if register~Y is respectively zero, positive,\n\nodd, nonnegative, nonzero, nonpositive, or nonodd.\n\n\\bull\\<ZSN \\$X,\\$Y,\\0 `zero or set if negative'.\\>\n\n@.ZSN@>\n\nIf register Y is negative (namely if its most significant bit is~1),\n\nregister~X is set to the contents of register~Z or to the\n\nunsigned immediate value~Z. Otherwise register~X is set to zero.\n\n\\bull\\<ZSZ \\$X,\\$Y,\\0 `zero or set if zero'.\n\n@.ZSZ@>\n\n\\bul\\<ZSP \\$X,\\$Y,\\0 `zero or set if positive'.\n\n@.ZSP@>\n\n\\bul\\<ZSOD \\$X,\\$Y,\\0 `zero or set if odd'.\n\n@.ZSOD@>\n\n\\bul\\<ZSNN \\$X,\\$Y,\\0 `zero or set if nonnegative'.\n\n@.ZSNN@>\n\n\\bul\\<ZSNZ \\$X,\\$Y,\\0 `zero or set if nonzero'.\n\n@.ZSNZ@>\n\n\\bul\\<ZSNP \\$X,\\$Y,\\0 `zero or set if nonpositive'.\n\n@.ZSNP@>\n\n\\bul\\<ZSEV \\$X,\\$Y,\\0 `zero or set if even'.\\>\n\n@.ZSEV@>\n\nThese instructions are entirely analogous to \\.{ZSN}, except\n\nthat \\$X is set to \\$Z or~Z if register~Y is respectively zero, positive,\n\nodd, nonnegative, nonzero, nonpositive, or even; otherwise\n\n\\$X is set to zero.\n\nNotice that the two instructions \\<CMPU r,s,0 and \\<ZSNZ r,s,1 have\n\nthe same effect. So do the two instructions \\<CSNP r,s,0 and \\.{ZSP} \\.{r,s,r}.\n\nSo do \\<AND r,s,1 and \\.{ZSOD}~\\.{r,s,1}.\n\n@* Branches and jumps.\n\n\\MMIX\\ ordinarily executes instructions in sequence, proceeding from\n\nan instruction in tetrabyte M$_4[\\lambda]$ to the instruction in\n\nM$_4[\\lambda+4]$. But there are several ways to interrupt\n\nthe normal flow of control, most of which use the Y and Z fields of\n\nan instruction as a combined 16-bit YZ field.\n\nFor example, \\<BNZ \\$3,@@+4000 (branch if nonzero)\n\nis typical: It means that control should skip ahead 1000 instructions\n\nto the command that appears $4000$ bytes after the\n\n\\.{BNZ}, if register~3 is not equal to zero.\n\nThere are eight branch-forward instructions, corresponding to the\n\neight conditions in the \\.{CS} and \\.{ZS} commands that we discussed earlier.\n\nAnd there are eight similar branch-backward instructions; for example,\n\n\\<BOD \\$2,@@-4000 (branch if odd) takes control to the\n\ninstruction that appears $4000$ bytes {\\it before\\/}\n\nthis \\.{BOD} command, if register~2 is odd. The numeric OP-code when branching\n\nbackward is one greater than the OP-code when branching\n\nforward; the assembler takes care of this automatically, just as it takes\n\ncares of changing \\.{ADD} from 32 to 33 when necessary.\n\nSince branches are relative to the current location, the \\MMIX\\ assembler\n\ntreats branch instructions in a special way.\n\nSuppose a programmer writes `\\.{BNZ} \\.{\\$3,Case5}',\n\nwhere \\.{Case5} is the address of an instruction in location~$l$.\n\nIf this instruction appears in location~$\\lambda$, the assembler first\n\ncomputes the displacement $\\delta=\\lfloor(l-\\lambda)/4\\rfloor$. Then if\n\n$\\delta$ is nonnegative, the quantity~$\\delta$\n\nis placed in the YZ field of a \\.{BNZ}\n\ncommand, and it should be less than $2^{16}$; if $\\delta$ is negative,\n\nthe quantity $2^{16}+\\delta$ is placed in the YZ field of a \\.{BNZ}\n\ncommand with OP-code increased by~1,\n\nand $\\delta$ should not be less than $-2^{16}$.\n\nThe symbol \\.{@@} used in our examples of\n\n\\.{BNZ} and \\.{BOD} above is interpreted by the\n\nassembler as an abbreviation for ``the location of the current\n\ninstruction.'' In the following\n\nnotes we will define pairs of branch commands by writing, for example,\n\n`\\.{BNZ}~\\.{\\$X,@@+4*YZ[-262144]}'; this stands for a branch-forward\n\ncommand that\n\nbranches to the current location plus four times~YZ, as well as for\n\na branch-backward command that branches to the current\n\nlocation plus four times $(\\rm YZ-65536)$.\n\n\\bull\\<BN \\$X,@@+4*YZ[-262144] `branch if negative'.\n\n@.BN@>\n\n\\bul\\<BZ \\$X,@@+4*YZ[-262144] `branch if zero'.\n\n@.BZ@>\n\n\\bul\\<BP \\$X,@@+4*YZ[-262144] `branch if positive'.\n\n@.BP@>\n\n\\bul\\<BOD \\$X,@@+4*YZ[-262144] `branch if odd'.\n\n@.BOD@>\n\n\\bul\\<BNN \\$X,@@+4*YZ[-262144] `branch if nonnegative'.\n\n@.BNN@>\n\n\\bul\\<BNZ \\$X,@@+4*YZ[-262144] `branch if nonzero'.\n\n@.BNZ@>\n\n\\bul\\<BNP \\$X,@@+4*YZ[-262144] `branch if nonpositive'.\n\n@.BNP@>\n\n\\bul\\<BEV \\$X,@@+4*YZ[-262144] `branch if even'.\\>\n\n@.BEV@>\n\nIf register X is respectively negative, zero, positive, odd, nonnegative,\n\nnonzero, nonpositive, or even, and if this instruction appears in memory\n\nlocation $\\lambda$, the next instruction is taken from memory location\n\n$\\lambda+4{\\rm YZ}$ (branching forward) or $\\lambda+4({\\rm YZ}-2^{16})$\n\n(branching backward). Thus one can go from location~$\\lambda$ to any location\n\nbetween $\\lambda-262{,}144$ and $\\lambda+262{,}140$, inclusive.\n\n\\smallskip\n\nSixteen additional branch instructions called {\\it probable branches\\/}\n\nare also provided. They have exactly the same meaning as ordinary\n\nbranch instructions; for example, \\<PBOD \\$2,@@-4000 and \\<BOD \\$2,@@-4000 both\n\ngo backward 4000 bytes if register~2 is odd. But they differ in running time:\n\nOn some implementations of\\/ \\MMIX,\n\na branch instruction takes longer when the branch is taken, while a\n\nprobable branch takes longer when the branch is {\\it not\\/} taken.\n\nThus programmers should use a \\.B instruction when they think branching is\n\nrelatively unlikely, but they should use \\.{PB} when they expect\n\nbranching to occur more often than not. Here is a list of the\n\nprobable branch commands, for completeness:\n\n\\bull\\<PBN \\$X,@@+4*YZ[-262144] `probable branch if negative'.\n\n@.PBN@>\n\n\\bul\\<PBZ \\$X,@@+4*YZ[-262144] `probable branch if zero'.\n\n@.PBZ@>\n\n\\bul\\<PBP \\$X,@@+4*YZ[-262144] `probable branch if positive'.\n\n@.PBP@>\n\n\\bul\\<PBOD \\$X,@@+4*YZ[-262144] `probable branch if odd'.\n\n@.PBOD@>\n\n\\bul\\<PBNN \\$X,@@+4*YZ[-262144] `probable branch if nonnegative'.\n\n@.PBNN@>\n\n\\bul\\<PBNZ \\$X,@@+4*YZ[-262144] `probable branch if nonzero'.\n\n@.PBNZ@>\n\n\\bul\\<PBNP \\$X,@@+4*YZ[-262144] `probable branch if nonpositive'."
    }
}