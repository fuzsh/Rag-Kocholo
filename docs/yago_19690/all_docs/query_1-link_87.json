{
    "id": "yago_19690_1",
    "rank": 87,
    "data": {
        "url": "http://eigenhombre.com/communicating-with-humans.html",
        "read_more_link": "",
        "language": "en",
        "title": "Communicating With Humans",
        "top_image": "",
        "meta_img": "",
        "images": [
            "http://eigenhombre.com/img/marg-printed.jpg",
            "http://eigenhombre.com/img/marg-screenshot.png",
            "http://eigenhombre.com/img/emacs-screenshot.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "If nobody but me likes it, let it die. — Knuth\n\nThis is the fifth post in a series about my Clojure workflow.\n\nWhen you encounter a new codebase, what best allows you to quickly understand it so that you can make effective changes to it?\n\nI switched jobs about six months ago. There was intense information transfer both while leaving my old projects behind, and while getting up to speed with new ones. I printed out a lot of code and read it front-to-back, quickly at first, and then carefully. I found this a surprisingly effective way to review and learn, compared to my usual way of navigating code on disk and in an editor solely on an as-needed basis.\n\nIf this (admittedly old-school) way of understanding a program works well, how much better might it work if there was enough prose interspersed in amongst the code to explain anything non-obvious, and if the order of the text was presented in such a way as to aid understanding?\n\nWhat is the target audience of computer programs, anyways? It is clearly the machines, which have to carry out our insanely specific instructions... but, equally clearly, it is also the humans who have to read, understand, maintain, fix, and extend those programs. It astonishes me now how little attention is paid to this basic fact.\n\nIn addition to communicating, we also have to think carefully about our work. While not every programming problem is so difficult as to merit a year’s worth of contemplation, any software system of significant size requires continual care, attention, and occasional hard thinking in order to keep complexity under control. The best way I know to think clearly about a problem is to write about it – the harder the problem, the more careful and comprehensive the required writing.\n\nWriting aids thinking, because it is slower than thought... because you can replay thoughts over and over, iterate upon and refine them. Because writing is explaining, and because explaining something is the best way I know to learn and understand it.\n\nLiterate Programming (LP) was invented by Donald Knuth in the 1980s as a way to address some of these concerns. LP has hardcore enthusiasts scattered about, but apparently not much traction in the mainstream. As I have gotten more experience working with complex codebases, and more engaged with the craft or programming, I have become increasingly interested in LP as a way to write good programs. Knuth takes it further, considering the possibility that programs are, or could be, works of literature.\n\nKnuth’s innovation was both in realizing these possibilities and in implementing the first system for LP, called WEB. WEB takes a document containing a mix of prose and code and both typesets it in a readable (beautiful, even) form for humans, and also orders and assembles the program for a compiler to consume.\n\nDescendents and variants of WEB can be found in use today. My favorite for Clojure is currently Marginalia, originally by Michael Fogus and currently maintained by Gary Deer.\n\nPurists of LP will disagree that systems like Marginalia, which do not support reordering and reassembly of source code, are “true” Literate Programming tools; and, in fact, there is a caveat on the Marginalia docs to that effect... but what Marginalia provides is good enough for me:\n\nPlacement of comments and docstrings adjacent to the code in question;\n\nBeautiful formatting of same;\n\nSupport for Markdown/HTML and attachment of JavaScript and/or CSS files; therefore, for images, mathematics (via MathJax) and graphing (see next blog post).\n\nThe result of these capabilities is a lightweight tool which lets me take an existing Clojure project and, with very little extra effort, generate a Web-based or printed/PDF artifact which I can sit down with, learn from, and enjoy contemplating.\n\nMarginalia in Action:\n\nThe Notebook Pattern\n\nI often start writing by making simple statements or questions:\n\nI want to be able to do \\(X\\)....\n\nI don’t understand \\(Y\\)....\n\nIf we had feature \\(P\\), then \\(Q\\) would be easy....\n\nHow long would it take to compute \\(Z\\)?\n\nSentences like these are like snippets of code in the REPL: things to evaluate and experiment with. Often these statements are attached to bits of code — experimental expressions, and their evaluated results. They are the building blocks of further ideas, programs, and chains of thought. In my next post, I’ll talk about using Marginalia to make small notebooks where I collect written thoughts, code, expression, even graphs and plots while working on a problem. This workflow involves some Marginalia hacks you may not see elsewhere.\n\nMeanwhile, here are some quotes about LP:\n\n“Instead of writing code containing documentation, the literate programmer writes documentation containing code.... The effect of this simple shift of emphasis can be so profound as to change one’s whole approach to programming.” —Ross Williams, FunnelWeb Tutorial Manual, p.4.\n\n“Knuth’s insight is to focus on the program as a message from its author to its readers.” —Jon Bently, “Programming Pearls,” Communications of the ACM, 1986."
    }
}