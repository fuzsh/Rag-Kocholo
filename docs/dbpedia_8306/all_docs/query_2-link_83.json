{
    "id": "dbpedia_8306_2",
    "rank": 83,
    "data": {
        "url": "https://developer.unigine.com/en/docs/latest/start/",
        "read_more_link": "",
        "language": "en",
        "title": "Unigine Developer",
        "top_image": "https://developer.unigine.com/themes/desktop/img/opengraph.png",
        "meta_img": "https://developer.unigine.com/themes/desktop/img/opengraph.png",
        "images": [
            "https://developer.unigine.com/en/docs/latest/start/project_concept.png",
            "https://developer.unigine.com/en/docs/latest/start/structure.png",
            "https://developer.unigine.com/en/docs/latest/start/world_editor.png",
            "https://developer.unigine.com/en/docs/latest/start/mesh_asset_browser.jpg",
            "https://developer.unigine.com/en/docs/latest/start/surfaces.jpg",
            "https://developer.unigine.com/en/docs/latest/start/materials.png",
            "https://developer.unigine.com/en/docs/latest/start/post_sensors.jpg",
            "https://developer.unigine.com/en/docs/latest/start/hierarchy.jpg",
            "https://developer.unigine.com/en/docs/latest/start/material_editor_sm.png",
            "https://developer.unigine.com/en/docs/latest/code/fundamentals/file_access/assign_prop_params.gif",
            "https://developer.unigine.com/en/docs/latest/start/editor.jpg",
            "https://developer.unigine.com/en/docs/latest/start/frustum.png",
            "https://developer.unigine.com/en/docs/latest/start/lighting.png",
            "https://developer.unigine.com/en/docs/latest/start/render_settings.png",
            "https://developer.unigine.com/en/docs/latest/start/sound_system.png",
            "https://developer.unigine.com/en/docs/latest/start/body.png",
            "https://developer.unigine.com/en/docs/latest/start/joints.png",
            "https://developer.unigine.com/en/docs/latest/start/engine_cycle.png",
            "https://developer.unigine.com/en/docs/latest/code/fundamentals/file_access/assign_prop_params.gif",
            "https://developer.unigine.com/en/docs/latest/sdk/demos/index.jpg",
            "https://developer.unigine.com/en/docs/latest/start/lods_switch.png",
            "https://developer.unigine.com/en/docs/latest/start/lods_fade.png",
            "https://developer.unigine.com/en/docs/latest/start/masks_match.png"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "UNIGINE developer portal. Official documentation, SDK downloads, forum community for UNIGINE real-time 3D engine.",
        "meta_lang": "en",
        "meta_favicon": "/favicon.ico",
        "meta_site_name": "",
        "canonical_link": "https://developer.unigine.com",
        "text": "A UNIGINE-based virtual world is a 3D scene that contains a set of different scene graph nodes (e.g. static meshes, lights, cameras, etc.) placed into specified positions, and global settings (rendering, physics, etc.) applied to the whole scene.\n\nA scene graph in UNIGINE is a multi-root tree (hierarchy) of nodes.\n\nEach world is represented by an XML file with the .world extension.\n\nWhen you create a new project via the SDK Browser, a new world is also created with the same name as your project.\n\nTo edit your existing worlds and create new ones, use UnigineEditor. You can create and use as many worlds as you need.\n\nIn terms of UNIGINE, all objects added to the scene are called nodes. Nodes can be of different types, determining their visual representation and behavior.\n\nThere is a rich set of built-in node types. Though the set covers almost all of required cases, it can be manually extended by the user.\n\nYou can also extend basic functionality of any node by adding components to it.\n\nEvery node has a transformation matrix, which encodes position, rotation, and scale of the node in the world.\n\nThere are node types that appear visually: Objects, Decals, and Effects. Other node types (Light Sources, Players, etc.) are invisible.\n\nNode parameters are regularly stored in the .world file, but also can be saved into a separate XML file with the .node extension (and later be referenced from the .world file via the special nodes called Node References, which is used for node instancing).\n\nOne of the most important node types is Object. Objects represent imitations of entities existing in the real world: objects (people, trees, cars, planes, etc.), sky, terrains, water, and so on. Objects have a single surface or a set of surfaces defining their visual appearance. They can have a shape to represent the volume they occupy in 3D space and a body to participate in physical interactions.\n\nIn terms of UNIGINE, a material is a rule defining how the surface will look like: its interaction with lights, reflection parameters, etc. It is based on:\n\nVertex, fragment and geometry shaders that actually draw the material based on different conditions.\n\nUser-defined textures passed to shaders.\n\nStates that specify conditions, based on which the appropriate shaders will be applied.\n\nParameters defining how shaders will be used.\n\nUNIGINE provides a rich set of built-in base materials out of the box. The recommended way is to inherit a new user material from a base one and tweak it. However, a custom material can be created as well:\n\nUsing the Material Editor for graph materials: by assembling and configuring the required blocks in the visual editor.\n\nUsing Abstract Materials for custom base materials: by inheriting a base material from an existing abstract prototype (or your own custom prototype) and adding the desired functions to it.\n\nYou can also create a custom shader via UnigineEditor and then implement the required logic using UUSL API (Unified UNIGINE Shader Language). If you prefer, you can use HLSL for custom shaders creation, but in this case you will have to manually migrate them with every SDK release.\n\nIn addition to regular materials applied to certain surfaces, there is a special type of materials called post materials, that are applied above the final screen composition (e.g. to create a night or thermal vision effect). You can also create your own post-effects using the Scriptable Materials workflow.\n\nMaterial Hierarchy#\n\nMaterials are organized in hierarchy with parameters inheritance and overloading (much like in object-oriented programming). When a material is inherited, all its parameters are inherited from the parent. If a parameter value is changed for the parent, it will be automatically changed for the child as well, unless it was overridden (set to a different value) for the child before that.\n\nExample: a material A has two parameters (color: blue and specular power of 1.4), a material B is inherited from the material A and has color parameter overridden (red). If we change specular power to 2.0 in the material A, then the material B will have the following parameters: red color (overridden) and 2.0 value of specular power (inherited).\n\nBy using parameter inheritance it is very convenient to mass control values of multiple materials parameters.\n\nMaterial Editor#\n\nUNIGINE provides the node-based Material Editor that enables creating custom materials without writing code. You simply connect nodes to build an easy-to-read graph: use basic pre-configured nodes (200+ are available) or create custom ones.\n\nAlso the Material Editor allows:\n\nCreating custom base materials (.mgraph) that can be directly assigned to objects or used as parent materials to avoid reassembling the whole graph repeatedly.\n\nCreating custom graph nodes using subgraphs or your custom code.\n\nSwitching between material types (Mesh Opaque PBR, Mesh Alpha Test PBR, Mesh Transparent PBR, Mesh Transparent Unlit, Decal PBR types are available).\n\nToggling performance-affecting features on and off.\n\nConstructing the final material's UI.\n\nUsing textures from the Asset Browser or a file manager. The textures will be automatically imported with the corresponding nodes added to the graph.\n\nWriting code in a special Function node, if necessary.\n\nThe key features of the Material Editor include the following:\n\nLoops that allow repeating an arbitrary sequence of actions multiple times. UNIGINE provides the implementation of graph loops that is almost on par with loops in code and much easier to use.\n\nPortals that help keeping visual clarity even for complex or large graphs, avoiding situations when your connection wires are all over the place criss-crossing each other.\n\nSubgraphs - custom nodes combining reusable parts of node graphs, that can be used in other material graphs. If you change anything in the subgraph, changes will apply to every material using it.\n\nConnectors - a special \"collapsed\" mode of a graph node: it occupies less space and can be attached right to an input of another graph node.\n\nExpressions - special nodes that enable writing simple arithmetic operations and use the UNIGINE Graphics API. They can be used as a swizzle in combination with the ability to change the number or order of data components.\n\nYou can reparent a material inherited from a built-in base material so that it is derived from a graph-based material. Or even convert it to a unique graph material.\n\nA property is a \"material\" for application logic. It specifies the way the object will behave and interact with other objects and the scene environment. Properties can have parameters of various types â€” from a simple integer representing your character's hit points, to node, material, file (for textures, meshes, sounds, etc.), or property, which simplifies access to various resources.\n\nProperties can be used to build components to extend the functionality of nodes.\n\nProperties, like materials, are organized in a hierarchy with parameter inheritance. But, unlike materials, they can be applied either per-surface or per-node.\n\nLighting in your worlds is created by placing Light Sources. These nodes contain parameters, which determine various light characteristics, such as brightness, color, etc. You can also use physically-based parameters, like color temperature and illuminance, to set up your lights.\n\nThere are different kinds of lights and they emit light in different ways. A light bulb, for example, emits light in all directions â€” in UNIGINE it is represented by the omni light. A projector or car headlights emit a cone of light in a certain direction â€” projected light. Light beams that come from the sun appear to be parallel, as their source is located so far away. To simulate this type of lighting in UNIGINE, the world light is used.\n\nTo learn more about lighting in UNIGINE, see the Lighting Video Tutorial.\n\nUNIGINE has a combination of full deferred renderer with forward rendering techniques:\n\nAll opaque (non-transparent) geometry is rendered in the deferred pass.\n\nTransparent geometry is rendered in the forward pass.\n\nTo learn more about the applied rendering techniques, see the Rendering Sequence article.\n\nIn UnigineEditor all rendering settings (such as global illumination, shadows, environment, anti-aliasing, post-effects, etc.) can be adjusted via the Rendering Settings section and saved to a *.render file to be used later. Each new project contains settings for low, medium, high, and ultra quality presets as well as settings optimized for best performance in VR. You can now simply double-click on any of them in the Asset Browser to apply corresponding settings.\n\nTo implement your project's logic in UNIGINE, you can use the following programming languages:\n\nC# for a good balance between speed and ease of use. It allows using C# Component System enabled by default and integrated into the UnigineEditor. It is the easiest way to implement your application logic in components and assign them to any node to be executed.\n\nC++ for maximum performance and seamless integration with the existing code base.\n\nUnigineScript, fast iterative scripting language featuring instant compilation and thousands of useful functions.\n\nAll *.usc and *.h files inside of the data folder are scripts in UnigineScript language (they do not require compilation).\n\nAll the APIs are unified: every class, method, and constant are accessible via any API. However, there are minor language-specific differences.\n\nTo learn more, see the following usage examples articles:\n\nUnigineScript API, C++ API and C# API usage examples\n\nExamples of UnigineScript extension using C++ API\n\nExamples of UnigineScript extension using C# API\n\nMixing Languages#\n\nYou can stick to a single language: C++ if maximum performance is a key factor, or C# for optimum balance. In case of C# (.NET), UNIGINE provides the C# Component System integrated into UnigineEditor. This approach is deemed to be the most convenient and ensuring good performance for complex applications with elaborate logic.\n\nAlternatively, you can have different programming languages (C++, C#, and UnigineScript) for different pieces of your project: for example, you can use C++ for base classes and performance consuming operations; and implement some simple application logic in UnigineScript. You can also call methods from one API when using another, and manually expand API functionality.\n\nEvery UNIGINE-based application has its life cycle, that consists of certain stages, some of them are performed once, others are repeated each frame. In short, these stages are as follows:\n\nUNIGINE has three main logic components, Each of them has a set of functions (named init(), update(), postUpdate(), etc.) that contain actions to be performed at corresponding stages of the Engine's working cycle. These components are:\n\nSystem Logic is the code that is run during the whole application life cycle (its scope exists even when switching between worlds).\n\nFor applications written using UnigineScript, the system logic is written to the system script file (unigine.usc).\n\nFor applications that use C++ AppSystemLogic.cpp is created, and for C# applications â€” AppSystemLogic.cs. This file is stored in the source/ folder of your project. It has implemented methods to put your logic code inside.\n\nWorld Logic is the logic of the virtual world. The logic takes effect only when the world is loaded.\n\nFor applications written using UnigineScript, the world logic is written to the world script file (*.usc named after your project) and is loaded and unloaded together with the corresponding world.\n\nFor applications that use C++ AppWorldLogic.cpp is created, and for C# applications â€” AppWorldLogic.cs. This file is stored in the source/ folder of your project and stays loaded during the whole engine runtime. It has implemented methods to put your logic code inside.\n\nEditor Logic. This component is to be used in case you need to implement your own Editor. It has more implemented methods providing you with clear understanding of the current Engine events (a node has been created, a property has been deleted, a material has been changed, etc.).\n\nIt is highly recommended that you familiarize yourself with the execution sequence to know the details, including the multi-threaded mode.\n\nComponent System#\n\nComponent System enables you to implement your application's logic via a set of building blocks â€” components, and assign these blocks to nodes extending their basic functionality. You can add a component to a node via code or via UnigineEditor.\n\nEach component's logic is implemented inside the following functions: init(), update(), postUpdate(), etc. Just like for the main logic components, these functions are executed at corresponding stages of the Engine's working cycle.\n\nThe logic of a certain component is active only when the corresponding node and property are enabled. Thus, you can enable/disable logic of each particular component at run time, when necessary.\n\nYou can assign several properties corresponding to different components to a single node. The order in which the logic of components is executed can be changed at run time to fit your needs, giving you an exceptional flexibility and freedom to implement any functionality you have in mind.\n\nIn UNIGINE, there are two implementations of the Component System:\n\nC# Component System available for C# projects. In this case, a logic component integrates a node and a C# class, containing logic implementation (actions to be performed), defining a set of additional parameters to be used.\n\nC++ Component System available for C++ projects. In this case, a logic component integrates a node, a C++ class, containing logic implementation (actions to be performed), and a property, defining a set of additional parameters to be used.\n\nUNIGINE provides a rich set of built-in samples and demo projects covering basic principles of working with the Engine (operations with the built-in nodes, output rendering, GUI setting, etc.). There are different samples for each of the 3 programming languages. All samples come with the full source code. To check them out, go to SDK browser -> Samples.\n\nAn extended set of art samples is also included for your convenience to illustrate various aspects of working with content: you can learn how to use UNIGINE's built-in objects with different settings, set up LODs and materials, adjust rendering settings, or work with vegetation. These art samples are available via UNIGINE SDK Browser as a demo: go to Samples -> Demos and install the Art Samples demo."
    }
}