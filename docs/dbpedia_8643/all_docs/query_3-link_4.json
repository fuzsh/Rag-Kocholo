{
    "id": "dbpedia_8643_3",
    "rank": 4,
    "data": {
        "url": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do",
        "read_more_link": "",
        "language": "en",
        "title": "What does if __name__ == \"__main__\": do?",
        "top_image": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "meta_img": "https://cdn.sstatic.net/Sites/stackoverflow/Img/apple-touch-icon@2.png?v=73d79a89bded",
        "images": [
            "https://i.sstatic.net/RoPPo.jpg?s=64",
            "https://www.gravatar.com/avatar/eb5a95cb1be342c4089183cd8232a7f2?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/rvIFj.jpg?s=64",
            "https://www.gravatar.com/avatar/6ec78954391f88681b2a5b97ef958d08?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/JlM4b.jpg?s=64",
            "https://www.gravatar.com/avatar/924800e76876546c5c575c0175e1f434?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RoPPo.jpg?s=64",
            "https://www.gravatar.com/avatar/2d6ef152f55ad02f221278801069a854?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wftMn.jpg?s=64",
            "https://i.sstatic.net/cP8pZ.jpg?s=64",
            "https://www.gravatar.com/avatar/e5778b659d144e38ed982c3f4e566089?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/RoPPo.jpg?s=64",
            "https://i.sstatic.net/wftMn.jpg?s=64",
            "https://www.gravatar.com/avatar/46e25d1ddc623e371bd5636936be2843?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/8GwzL.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://i.sstatic.net/bqaZL.png?s=64",
            "https://i.sstatic.net/hWLqr.png",
            "https://i.sstatic.net/Eql0u.png",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/29b3d054f726e392812cda8e416f5fdf?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/lpMxS.png?s=64",
            "https://i.sstatic.net/wuiuT.jpg?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/d973b2cb54f5a0fe3ebf42731818ca5e?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/d7287a3bae1ff0021d663e6bb080ee91?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/091f411d57db5be8298e057a32e5ad72?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/3fd4388325d411bfde857169f3c8a34b?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/091f411d57db5be8298e057a32e5ad72?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/72UbV.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://graph.facebook.com/852873768142712/picture?type=large",
            "https://www.gravatar.com/avatar/6178b59305359920a922edd061a55e7a?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/wlSqQ.png?s=64",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://lh3.googleusercontent.com/-tFRIV7rG-M4/AAAAAAAAAAI/AAAAAAAAAHw/kUupZIXcBpI/photo.jpg?sz=64",
            "https://i.sstatic.net/cBRbe.jpg?s=64",
            "https://i.sstatic.net/Cz1dL.jpg?s=64",
            "https://www.gravatar.com/avatar/091f411d57db5be8298e057a32e5ad72?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/eywIU.jpg?s=64",
            "https://www.gravatar.com/avatar/091f411d57db5be8298e057a32e5ad72?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/399be7d0046c4c8acf65a41153114122?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/3e7a5713292fbe3e95c9bfceb9aabc7e?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/RIZKi.png?s=64",
            "https://www.gravatar.com/avatar/4328c64b5421a326baf5bf7be3e06f2b?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://i.sstatic.net/gAYS0.jpg?s=64",
            "https://www.gravatar.com/avatar/8dfa92044d56ff2a1fe5df317fd19790?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/091f411d57db5be8298e057a32e5ad72?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/AEYqB.png?s=64",
            "https://www.gravatar.com/avatar/091f411d57db5be8298e057a32e5ad72?s=64&d=identicon&r=PG",
            "https://www.gravatar.com/avatar/adbdc5848764fc9147f44ca6748dd319?s=64&d=identicon&r=PG&f=y&so-version=2",
            "https://www.gravatar.com/avatar/0427cc0f2395156b566254b2f93f75ca?s=64&d=identicon&r=PG",
            "https://i.sstatic.net/AxnVo.jpg?s=64",
            "https://www.gravatar.com/avatar/0427cc0f2395156b566254b2f93f75ca?s=64&d=identicon&r=PG",
            "https://lh3.googleusercontent.com/-JwI_aHAmvgg/AAAAAAAAAAI/AAAAAAAAGv8/PgjL7mWphRc/photo.jpg?sz=64",
            "https://stackoverflow.com/posts/419163/ivc/3cf8?prg=55c98569-ec4b-4dee-acd7-924e3f42310c",
            "https://stackoverflow.com/js-false.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": "2009-01-07T04:11:00",
        "summary": "",
        "meta_description": "What does this do, and why should one include the if statement?\nif __name__ == &quot;__main__&quot;:\n    print(&quot;Hello, World!&quot;)\r\nIf you are trying to close a question where someone should...",
        "meta_lang": "en",
        "meta_favicon": "https://cdn.sstatic.net/Sites/stackoverflow/Img/favicon.ico?v=ec617d715196",
        "meta_site_name": "Stack Overflow",
        "canonical_link": "https://stackoverflow.com/questions/419163/what-does-if-name-main-do",
        "text": "Short Answer\n\nIt's boilerplate code that protects users from accidentally invoking the script when they didn't intend to. Here are some common problems when the guard is omitted from a script:\n\nIf you import the guardless script in another script (e.g. import my_script_without_a_name_eq_main_guard), then the latter script will trigger the former to run at import time and using the second script's command line arguments. This is almost always a mistake.\n\nIf you have a custom class in the guardless script and save it to a pickle file, then unpickling it in another script will trigger an import of the guardless script, with the same problems outlined in the previous bullet.\n\nLong Answer\n\nTo better understand why and how this matters, we need to take a step back to understand how Python initializes scripts and how this interacts with its module import mechanism.\n\nWhenever the Python interpreter reads a source file, it does two things:\n\nit sets a few special variables like __name__, and then\n\nit executes all of the code found in the file.\n\nLet's see how this works and how it relates to your question about the __name__ checks we always see in Python scripts.\n\nCode Sample\n\nLet's use a slightly different code sample to explore how imports and scripts work. Suppose the following is in a file called foo.py.\n\n# Suppose this is foo.py. print(\"before import\") import math print(\"before function_a\") def function_a(): print(\"Function A\") print(\"before function_b\") def function_b(): print(\"Function B {}\".format(math.sqrt(100))) print(\"before __name__ guard\") if __name__ == '__main__': function_a() function_b() print(\"after __name__ guard\")\n\nSpecial Variables\n\nWhen the Python interpreter reads a source file, it first defines a few special variables. In this case, we care about the __name__ variable.\n\nWhen Your Module Is the Main Program\n\nIf you are running your module (the source file) as the main program, e.g.\n\npython foo.py\n\nthe interpreter will assign the hard-coded string \"__main__\" to the __name__ variable, i.e.\n\n# It's as if the interpreter inserts this at the top # of your module when run as the main program. __name__ = \"__main__\"\n\nWhen Your Module Is Imported By Another\n\nOn the other hand, suppose some other module is the main program and it imports your module. This means there's a statement like this in the main program, or in some other module the main program imports:\n\n# Suppose this is in some other main program. import foo\n\nThe interpreter will search for your foo.py file (along with searching for a few other variants), and prior to executing that module, it will assign the name \"foo\" from the import statement to the __name__ variable, i.e.\n\n# It's as if the interpreter inserts this at the top # of your module when it's imported from another module. __name__ = \"foo\"\n\nExecuting the Module's Code\n\nAfter the special variables are set up, the interpreter executes all the code in the module, one statement at a time. You may want to open another window on the side with the code sample so you can follow along with this explanation.\n\nAlways\n\nIt prints the string \"before import\" (without quotes).\n\nIt loads the math module and assigns it to a variable called math. This is equivalent to replacing import math with the following (note that __import__ is a low-level function in Python that takes a string and triggers the actual import):\n\n# Find and load a module given its string name, \"math\", # then assign it to a local variable called math. math = __import__(\"math\")\n\nIt prints the string \"before function_a\".\n\nIt executes the def block, creating a function object, then assigning that function object to a variable called function_a.\n\nIt prints the string \"before function_b\".\n\nIt executes the second def block, creating another function object, then assigning it to a variable called function_b.\n\nIt prints the string \"before __name__ guard\".\n\nOnly When Your Module Is the Main Program\n\nIf your module is the main program, then it will see that __name__ was indeed set to \"__main__\" and it calls the two functions, printing the strings \"Function A\" and \"Function B 10.0\".\n\nOnly When Your Module Is Imported by Another\n\n(instead) If your module is not the main program but was imported by another one, then __name__ will be \"foo\", not \"__main__\", and it'll skip the body of the if statement.\n\nAlways\n\nIt will print the string \"after __name__ guard\" in both situations.\n\nSummary\n\nIn summary, here's what'd be printed in the two cases:\n\n# What gets printed if foo is the main program before import before function_a before function_b before __name__ guard Function A Function B 10.0 after __name__ guard\n\n# What gets printed if foo is imported as a regular module before import before function_a before function_b before __name__ guard after __name__ guard\n\nWhy Does It Work This Way?\n\nYou might naturally wonder why anybody would want this. Well, sometimes you want to write a .py file that can be both used by other programs and/or modules as a module, and can also be run as the main program itself. Examples:\n\nYour module is a library, but you want to have a script mode where it runs some unit tests or a demo.\n\nYour module is only used as a main program, but it has some unit tests, and the testing framework works by importing .py files like your script and running special test functions. You don't want it to try running the script just because it's importing the module.\n\nYour module is mostly used as a main program, but it also provides a programmer-friendly API for advanced users.\n\nBeyond those examples, it's elegant that running a script in Python is just setting up a few magic variables and importing the script. \"Running\" the script is a side effect of importing the script's module.\n\nFood for Thought\n\nQuestion: Can I have multiple __name__ checking blocks? Answer: it's strange to do so, but the language won't stop you.\n\nSuppose the following is in foo2.py. What happens if you say python foo2.py on the command-line? Why?\n\n# Suppose this is foo2.py. import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters def function_a(): print(\"a1\") from foo2 import function_b print(\"a2\") function_b() print(\"a3\") def function_b(): print(\"b\") print(\"t1\") if __name__ == \"__main__\": print(\"m1\") function_a() print(\"m2\") print(\"t2\")\n\nNow, figure out what will happen in foo3.py (having removed the __name__ check):\n\n# Suppose this is foo3.py. import os, sys; sys.path.insert(0, os.path.dirname(__file__)) # needed for some interpreters def function_a(): print(\"a1\") from foo3 import function_b print(\"a2\") function_b() print(\"a3\") def function_b(): print(\"b\") print(\"t1\") print(\"m1\") function_a() print(\"m2\") print(\"t2\")\n\nWhat will this do when used as a script? When imported as a module?\n\n# Suppose this is in foo4.py __name__ = \"__main__\" def bar(): print(\"bar\") print(\"before __name__ guard\") if __name__ == \"__main__\": bar() print(\"after __name__ guard\")\n\nWhen your script is run by passing it as a command to the Python interpreter,\n\npython myscript.py\n\nall of the code that is at indentation level 0 gets executed. Functions and classes that are defined are, well, defined, but none of their code gets run. Unlike other languages, there's no main() function that gets run automatically - the main() function is implicitly all the code at the top level.\n\nIn this case, the top-level code is an if block. __name__ is a built-in variable which evaluates to the name of the current module. However, if a module is being run directly (as in myscript.py above), then __name__ instead is set to the string \"__main__\". Thus, you can test whether your script is being run directly or being imported by something else by testing\n\nif __name__ == \"__main__\": ...\n\nIf your script is being imported into another module, its various function and class definitions will be imported and its top-level code will be executed, but the code in the then-body of the if clause above won't get run as the condition is not met. As a basic example, consider the following two scripts:\n\n# file one.py def func(): print(\"func() in one.py\") print(\"top-level in one.py\") if __name__ == \"__main__\": print(\"one.py is being run directly\") else: print(\"one.py is being imported into another module\")\n\n# file two.py import one print(\"top-level in two.py\") one.func() if __name__ == \"__main__\": print(\"two.py is being run directly\") else: print(\"two.py is being imported into another module\")\n\nNow, if you invoke the interpreter as\n\npython one.py\n\nThe output will be\n\ntop-level in one.py one.py is being run directly\n\nIf you run two.py instead:\n\npython two.py\n\nYou get\n\ntop-level in one.py one.py is being imported into another module top-level in two.py func() in one.py two.py is being run directly\n\nThus, when module one gets loaded, its __name__ equals \"one\" instead of \"__main__\".\n\nWhat does the if __name__ == \"__main__\": do?\n\nTo outline the basics:\n\nThe global variable, __name__, in the module that is the entry point to your program, is '__main__'. Otherwise, it's the name you import the module by.\n\nSo, code under the if block will only run if the module is the entry point to your program.\n\nIt allows the code in the module to be importable by other modules, without executing the code block beneath on import.\n\nWhy do we need this?\n\nDeveloping and Testing Your Code\n\nSay you're writing a Python script designed to be used as a module:\n\ndef do_important(): \"\"\"This function does something very important\"\"\"\n\nYou could test the module by adding this call of the function to the bottom:\n\ndo_important()\n\nand running it (on a command prompt) with something like:\n\n~$ python important.py\n\nThe Problem\n\nHowever, if you want to import the module to another script:\n\nimport important\n\nOn import, the do_important function would be called, so you'd probably comment out your function call, do_important(), at the bottom.\n\n# do_important() # I must remember to uncomment to execute this!\n\nAnd then you'll have to remember whether or not you've commented out your test function call. And this extra complexity would mean you're likely to forget, making your development process more troublesome.\n\nA Better Way\n\nThe __name__ variable points to the namespace wherever the Python interpreter happens to be at the moment.\n\nInside an imported module, it's the name of that module.\n\nBut inside the primary module (or an interactive Python session, i.e. the interpreter's Read, Eval, Print Loop, or REPL) you are running everything from its \"__main__\".\n\nSo if you check before executing:\n\nif __name__ == \"__main__\": do_important()\n\nWith the above, your code will only execute when you're running it as the primary module (or intentionally call it from another script).\n\nAn Even Better Way\n\nThere's a Pythonic way to improve on this, though.\n\nWhat if we want to run this business process from outside the module?\n\nIf we put the code we want to exercise as we develop and test in a function like this and then do our check for '__main__' immediately after:\n\ndef main(): \"\"\"business logic for when running this module as the primary one!\"\"\" setup() foo = do_important() bar = do_even_more_important(foo) for baz in bar: do_super_important(baz) teardown() # Here's our payoff idiom! if __name__ == '__main__': main()\n\nWe now have a final function for the end of our module that will run if we run the module as the primary module.\n\nIt will allow the module and its functions and classes to be imported into other scripts without running the main function, and will also allow the module (and its functions and classes) to be called when running from a different '__main__' module, i.e.\n\nimport important important.main()\n\nThis idiom can also be found in the Python documentation in an explanation of the __main__ module. That text states:\n\nThis module represents the (otherwise anonymous) scope in which the interpreter’s main program executes — commands read either from standard input, from a script file, or from an interactive prompt. It is this environment in which the idiomatic “conditional script” stanza causes a script to run:\n\nif __name__ == '__main__': main()\n\nThere are lots of different takes here on the mechanics of the code in question, the \"How\", but for me none of it made sense until I understood the \"Why\". This should be especially helpful for new programmers.\n\nTake file \"ab.py\":\n\ndef a(): print('A function in ab file'); a()\n\nAnd a second file \"xy.py\":\n\nimport ab def main(): print('main function: this is where the action is') def x(): print ('peripheral task: might be useful in other projects') x() if __name__ == \"__main__\": main()\n\nWhat is this code actually doing?\n\nWhen you execute xy.py, you import ab. The import statement runs the module immediately on import, so ab's operations get executed before the remainder of xy's. Once finished with ab, it continues with xy.\n\nThe interpreter keeps track of which scripts are running with __name__. When you run a script - no matter what you've named it - the interpreter calls it \"__main__\", making it the master or 'home' script that gets returned to after running an external script.\n\nAny other script that's called from this \"__main__\" script is assigned its filename as its __name__ (e.g., __name__ == \"ab.py\"). Hence, the line if __name__ == \"__main__\": is the interpreter's test to determine if it's interpreting/parsing the 'home' script that was initially executed, or if it's temporarily peeking into another (external) script. This gives the programmer flexibility to have the script behave differently if it's executed directly vs. called externally.\n\nLet's step through the above code to understand what's happening, focusing first on the unindented lines and the order they appear in the scripts. Remember that function - or def - blocks don't do anything by themselves until they're called. What the interpreter might say if mumbled to itself:\n\nOpen xy.py as the 'home' file; call it \"__main__\" in the __name__ variable.\n\nImport and open file with the __name__ == \"ab.py\".\n\nOh, a function. I'll remember that.\n\nOk, function a(); I just learned that. Printing 'A function in ab file'.\n\nEnd of file; back to \"__main__\"!\n\nOh, a function. I'll remember that.\n\nAnother one.\n\nFunction x(); ok, printing 'peripheral task: might be useful in other projects'.\n\nWhat's this? An if statement. Well, the condition has been met (the variable __name__ has been set to \"__main__\"), so I'll enter the main() function and print 'main function: this is where the action is'.\n\nThe bottom two lines mean: \"If this is the \"__main__\" or 'home' script, execute the function called main()\". That's why you'll see a def main(): block up top, which contains the main flow of the script's functionality.\n\nWhy implement this?\n\nRemember what I said earlier about import statements? When you import a module it doesn't just 'recognize' it and wait for further instructions - it actually runs all the executable operations contained within the script. So, putting the meat of your script into the main() function effectively quarantines it, putting it in isolation so that it won't immediately run when imported by another script.\n\nAgain, there will be exceptions, but common practice is that main() doesn't usually get called externally. So you may be wondering one more thing: if we're not calling main(), why are we calling the script at all? It's because many people structure their scripts with standalone functions that are built to be run independent of the rest of the code in the file. They're then later called somewhere else in the body of the script. Which brings me to this:\n\nBut the code works without it\n\nYes, that's right. These separate functions can be called from an in-line script that's not contained inside a main() function. If you're accustomed (as I am, in my early learning stages of programming) to building in-line scripts that do exactly what you need, and you'll try to figure it out again if you ever need that operation again ... well, you're not used to this kind of internal structure to your code, because it's more complicated to build and it's not as intuitive to read.\n\nBut that's a script that probably can't have its functions called externally, because if it did it would immediately start calculating and assigning variables. And chances are if you're trying to re-use a function, your new script is related closely enough to the old one that there will be conflicting variables.\n\nIn splitting out independent functions, you gain the ability to re-use your previous work by calling them into another script. For example, \"example.py\" might import \"xy.py\" and call x(), making use of the 'x' function from \"xy.py\". (Maybe it's capitalizing the third word of a given text string; creating a NumPy array from a list of numbers and squaring them; or detrending a 3D surface. The possibilities are limitless.)\n\n(As an aside, this question contains an answer by @kindall that finally helped me to understand - the why, not the how. Unfortunately it's been marked as a duplicate of this one, which I think is a mistake.)\n\nPut simply, __name__ is a variable defined for each script that defines whether the script is being run as the main module or it is being run as an imported module.\n\nSo if we have two scripts;\n\n#script1.py print \"Script 1's name: {}\".format(__name__)\n\nand\n\n#script2.py import script1 print \"Script 2's name: {}\".format(__name__)\n\nThe output from executing script1 is\n\nScript 1's name: __main__\n\nAnd the output from executing script2 is:\n\nScript1's name is script1 Script 2's name: __main__\n\nAs you can see, __name__ tells us which code is the 'main' module. This is great, because you can just write code and not have to worry about structural issues like in C/C++, where, if a file does not implement a 'main' function then it cannot be compiled as an executable and if it does, it cannot then be used as a library.\n\nSay you write a Python script that does something great and you implement a boatload of functions that are useful for other purposes. If I want to use them I can just import your script and use them without executing your program (given that your code only executes within the if __name__ == \"__main__\": context). Whereas in C/C++ you would have to portion out those pieces into a separate module that then includes the file. Picture the situation below;\n\nThe arrows are import links. For three modules each trying to include the previous modules code there are six files (nine, counting the implementation files) and five links. This makes it difficult to include other code into a C project unless it is compiled specifically as a library. Now picture it for Python:\n\nYou write a module, and if someone wants to use your code they just import it and the __name__ variable can help to separate the executable portion of the program from the library part.\n\nBefore explaining anything about if __name__ == '__main__' it is important to understand what __name__ is and what it does.\n\nWhat is __name__?\n\n__name__ is a DunderAlias - can be thought of as a global variable (accessible from modules) and works in a similar way to global.\n\nIt is a string (global as mentioned above) as indicated by type(__name__) (yielding <class 'str'>), and is an inbuilt standard for both Python 3 and Python 2 versions.\n\nWhere\n\nIt can not only be used in scripts but can also be found in both the interpreter and modules/packages.\n\nInterpreter:\n\n>>> print(__name__) __main__ >>>\n\nScript:\n\ntest_file.py:\n\nprint(__name__)\n\nResulting in __main__\n\nModule or package:\n\nsomefile.py:\n\ndef somefunction(): print(__name__)\n\ntest_file.py:\n\nimport somefile somefile.somefunction()\n\nResulting in somefile\n\nNotice that when used in a package or module, __name__ takes the name of the file. The path of the actual module or package path is not given, but has its own DunderAlias __file__, that allows for this.\n\nYou should see that, where __name__, where it is the main file (or program) will always return __main__, and if it is a module/package, or anything that is running off some other Python script, will return the name of the file where it has originated from.\n\nPractice\n\nBeing a variable means that it's value can be overwritten (\"can\" does not mean \"should\"), overwriting the value of __name__ will result in a lack of readability. So do not do it, for any reason. If you need a variable define a new variable.\n\nIt is always assumed that the value of __name__ to be __main__ or the name of the file. Once again changing this default value will cause more confusion that it will do good, causing problems further down the line.\n\nExample:\n\n>>> __name__ = 'Horrify' # Change default from __main__ >>> if __name__ == 'Horrify': print(__name__) ... >>> else: print('Not Horrify') ... Horrify >>>\n\nIt is considered good practice in general to include the if __name__ == '__main__' in scripts.\n\nNow to answer if __name__ == '__main__':\n\nNow we know the behaviour of __name__ things become clearer:\n\nAn if is a flow control statement that contains the block of code will execute if the value given is true. We have seen that __name__ can take either __main__ or the file name it has been imported from.\n\nThis means that if __name__ is equal to __main__ then the file must be the main file and must actually be running (or it is the interpreter), not a module or package imported into the script.\n\nIf indeed __name__ does take the value of __main__ then whatever is in that block of code will execute.\n\nThis tells us that if the file running is the main file (or you are running from the interpreter directly) then that condition must execute. If it is a package then it should not, and the value will not be __main__.\n\nModules\n\n__name__ can also be used in modules to define the name of a module\n\nVariants\n\nIt is also possible to do other, less common but useful things with __name__, some I will show here:\n\nExecuting only if the file is a module or package\n\nif __name__ != '__main__': # Do some useful things\n\nRunning one condition if the file is the main one and another if it is not\n\nif __name__ == '__main__': # Execute something else: # Do some useful things\n\nYou can also use it to provide runnable help functions/utilities on packages and modules without the elaborate use of libraries.\n\nIt also allows modules to be run from the command line as main scripts, which can be also very useful.\n\nThere are a number of variables that the system (Python interpreter) provides for source files (modules). You can get their values anytime you want, so, let us focus on the __name__ variable/attribute:\n\nWhen Python loads a source code file, it executes all of the code found in it. (Note that it doesn't call all of the methods and functions defined in the file, but it does define them.)\n\nBefore the interpreter executes the source code file though, it defines a few special variables for that file; __name__ is one of those special variables that Python automatically defines for each source code file.\n\nIf Python is loading this source code file as the main program (i.e. the file you run), then it sets the special __name__ variable for this file to have a value \"__main__\".\n\nIf this is being imported from another module, __name__ will be set to that module's name.\n\nSo, in your example in part:\n\nif __name__ == \"__main__\": lock = thread.allocate_lock() thread.start_new_thread(myfunction, (\"Thread #: 1\", 2, lock)) thread.start_new_thread(myfunction, (\"Thread #: 2\", 2, lock))\n\nmeans that the code block:\n\nlock = thread.allocate_lock() thread.start_new_thread(myfunction, (\"Thread #: 1\", 2, lock)) thread.start_new_thread(myfunction, (\"Thread #: 2\", 2, lock))\n\nwill be executed only when you run the module directly; the code block will not execute if another module is calling/importing it because the value of __name__ will not equal to \"main\" in that particular instance.\n\nHope this helps out.\n\nIf you are a beginner, probably the only answer you need right now is that this code is unnecessary for a simple script. It is only useful if you want to be able to import your script (or unpickle etc; see the other answers here for some other non-beginner scenarios).\n\nIn slightly different words, the if __name__ guard is a mechanism for hiding code from other code. If you don't have a specific reason to hide something, don't: If you don't need to hide some code from import, don't put it behind this guard, and if you do, hide as little as possible.\n\nIn slightly more detail, let's say you have a simple script fib.py (adapted from this answer):\n\n# XXX FIXME: useless (see below) if __name__ == \"__main__\": n = int(input('Write a number: ')) a, b = 0, 1 while b < n: a, b = b, a+b print('Fibonacci number %i: %i' % (n, b))\n\nNow, if you simply run python fib.py it works fine. But __name__ will always be \"__main__\" in this scenario, so the condition is actually unnecessary. The script could be simplified to just\n\nn = int(input('Write a number: ')) a, b = 0, 1 while b < n: a, b = b, a+b print('Fibonacci number %i: %i' % (n, b))\n\nNow, you still can't import fib with the new version, but if you didn't plan to do that in the first place, this version is actually better, because it's simpler and clearer.\n\nIf you do want to be able to import fib, the first version was useless, too, because the useful code was in a section which will not run when you import that file (in which case __name__ will not be \"__main__\"). The proper design in that case would be to refactor the code so that the useful parts are in a function you can run when you want to after you have imported it.\n\ndef main(): n = int(input('Write a number: ')) a, b = 0, 1 while b < n: a, b = b, a+b print('Fibonacci number %i: %i' % (n, b)) if __name__ == \"__main__\": main()\n\nNow, if you import fib, the call to main() will not be executed; but when you run python fib.py, it will.\n\nActually, a better design still would be to isolate the reusable part (the actual calculation) from the user-visible input/output:\n\ndef fibn(n: int) -> int: a, b = 0, 1 while b < n: a, b = b, a+b return b def main() -> None: n = int(input('Write a number: ')) print('Fibonacci number %i: %i' % (n, fibn(n))) if __name__ == \"__main__\": main()\n\nNow, you can from fib import fibn and call the fibn() function from the code which performs this import.\n\n(I called the function fibn() just to make it clearer what is what in this example. In real life, you might call it fib() and do from fib import fib.)\n\nNotice the more modular and reusable design; the fibn function contains the actual calculation, but no user interface parts; and the pesky interactive I/O is separated out into the main function so that you can bypass it (or call it if you want to, of course).\n\nReturning to the code in the question, I would similarly move the code from the if into a function as well, so that callers can invoke that function if they want to.\n\ndef main(): lock = thread.allocate_lock() thread.start_new_thread(myfunction, (\"Thread #: 1\", 2, lock)) thread.start_new_thread(myfunction, (\"Thread #: 2\", 2, lock)) if __name__ == \"__main__\": main()\n\nThis changes the scope of the lock variable; if the surrounding code needs access to it, you will need to make it global (or, perhaps, better, refactor main to return lock, and have the caller capture the value in a local variable of its own).\n\n(Unlike in languages like C, the name main has no specific meaning to Python; but it's a common convention to use it as the name of the thing which will be run. You still have to actually explicitly call it, like main(), unlike in C.)"
    }
}