{
    "id": "dbpedia_4957_2",
    "rank": 36,
    "data": {
        "url": "https://w3c.github.io/did-core/",
        "read_more_link": "",
        "language": "en",
        "title": "Decentralized Identifiers (DIDs) v1.1",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://w3c.github.io/did-core/diagrams/parts-of-a-did.svg",
            "https://w3c.github.io/did-core/diagrams/did_brief_architecture_overview.svg",
            "https://w3c.github.io/did-core/diagrams/diagram-did-document-entries.svg",
            "https://w3c.github.io/did-core/diagrams/diagram-production-consumption.svg",
            "https://w3c.github.io/did-core/diagrams/diagram-resolve-resolverepresentation.svg",
            "https://w3c.github.io/did-core/diagrams/did_url_dereference_overview.svg",
            "https://w3c.github.io/did-core/diagrams/did_detailed_architecture_overview.svg",
            "https://w3c.github.io/did-core/diagrams/figure-a.1-did-and-did-document-graph.svg",
            "https://w3c.github.io/did-core/diagrams/figure-a.2-also-known-as-graph.svg",
            "https://w3c.github.io/did-core/diagrams/figure-b.1-controller-and-subject-equivalence.svg",
            "https://w3c.github.io/did-core/diagrams/figure-c.1-independent-did-controllers.svg",
            "https://w3c.github.io/did-core/diagrams/figure-c.2-group-did-controllers.svg"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "Introduction\n\nAs individuals and organizations, many of us use globally unique identifiers in a wide variety of contexts. They serve as communications addresses (telephone numbers, email addresses, usernames on social media), ID numbers (for passports, drivers licenses, tax IDs, health insurance), and product identifiers (serial numbers, barcodes, RFIDs). URIs (Uniform Resource Identifiers) are used for resources on the Web and each web page you view in a browser has a globally unique URL (Uniform Resource Locator).\n\nThe vast majority of these globally unique identifiers are not under our control. They are issued by external authorities that decide who or what they refer to and when they can be revoked. They are useful only in certain contexts and recognized only by certain bodies not of our choosing. They might disappear or cease to be valid with the failure of an organization. They might unnecessarily reveal personal information. In many cases, they can be fraudulently replicated and asserted by a malicious third-party, which is more commonly known as \"identity theft\".\n\nThe Decentralized Identifiers (DIDs) defined in this specification are a new type of globally unique identifier. They are designed to enable individuals and organizations to generate their own identifiers using systems they trust. These new identifiers enable entities to prove control over them by authenticating using cryptographic proofs such as digital signatures.\n\nSince the generation and assertion of Decentralized Identifiers is entity-controlled, each entity can have as many DIDs as necessary to maintain their desired separation of identities, personas, and interactions. The use of these identifiers can be scoped appropriately to different contexts. They support interactions with other people, institutions, or systems that require entities to identify themselves, or things they control, while providing control over how much personal or private data should be revealed, all without depending on a central authority to guarantee the continued existence of the identifier. These ideas are explored in the DID Use Cases document [[DID-USE-CASES]].\n\nThis specification does not presuppose any particular technology or cryptography to underpin the generation, persistence, resolution, or interpretation of DIDs. For example, implementers can create Decentralized Identifiers based on identifiers registered in federated or centralized identity management systems. Indeed, almost all types of identifier systems can add support for DIDs. This creates an interoperability bridge between the worlds of centralized, federated, and decentralized identifiers. This also enables implementers to design specific types of DIDs to work with the computing infrastructure they trust, such as distributed ledgers, decentralized file systems, distributed databases, and peer-to-peer networks.\n\nThis specification is for:\n\nAnyone that wants to understand the core architectural principles that are the foundation for Decentralized Identifiers;\n\nSoftware developers that want to produce and consume Decentralized Identifiers and their associated data formats;\n\nSystems integrators that want to understand how to use Decentralized Identifiers in their software and hardware systems;\n\nSpecification authors that want to create new DID infrastructures, known as DID methods, that conform to the ecosystem described by this document.\n\nIn addition to this specification, readers might find the Use Cases and Requirements for Decentralized Identifiers [[DID-USE-CASES]] document useful.\n\nA Simple Example\n\nA DID is a simple text string consisting of three parts: 1) the did URI scheme identifier, 2) the identifier for the DID method, and 3) the DID method-specific identifier.\n\nThe example DID above resolves to a DID document. A DID document contains information associated with the DID, such as ways to cryptographically authenticate a DID controller.\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ], \"id\": \"did:example:123456789abcdefghi\", \"authentication\": [{ \"id\": \"did:example:123456789abcdefghi#keys-1\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" }] }\n\nDesign Goals\n\nDecentralized Identifiers are a component of larger systems, such as the Verifiable Credentials ecosystem [[VC-DATA-MODEL]], which influenced the design goals for this specification. The design goals for Decentralized Identifiers are summarized here.\n\nGoal Description Decentralization Eliminate the requirement for centralized authorities or single points of failure in identifier management, including the registration of globally unique identifiers, public verification keys, services, and other information. Control Give entities, both human and non-human, the power to directly control their digital identifiers without the need to rely on external authorities. Privacy Enable entities to control the privacy of their information, including minimal, selective, and progressive disclosure of attributes or other data. Security Enable sufficient security for requesting parties to depend on DID documents for their required level of assurance. Proof-based Enable DID controllers to provide cryptographic proof when interacting with other entities. Discoverability Make it possible for entities to discover DIDs for other entities, to learn more about or interact with those entities. Interoperability Use interoperable standards so DID infrastructure can make use of existing tools and software libraries designed for interoperability. Portability Be system- and network-independent and enable entities to use their digital identifiers with any system that supports DIDs and DID methods. Simplicity Favor a reduced set of simple features to make the technology easier to understand, implement, and deploy. Extensibility Where possible, enable extensibility provided it does not greatly hinder interoperability, portability, or simplicity.\n\nArchitecture Overview\n\nThis section provides a basic overview of the major components of Decentralized Identifier architecture.\n\nSix internally-labeled shapes appear in the diagram, with labeled arrows between them, as follows. In the center of the diagram is a rectangle labeled DID URL, containing small typewritten text \"did:example:123/path/to/rsrc\". At the center top of the diagram is a rectangle labeled, \"DID\", containing small typewritten text \"did:example:123\". At the top left of the diagram is an oval, labeled \"DID Subject\". At the bottom center of the diagram is a rectangle labeled, \"DID document\". At the bottom left is an oval, labeled, \"DID Controller\". On the center right of the diagram is a two-dimensional rendering of a cylinder, labeled, \"Verifiable Data Registry\".\n\nFrom the top of the \"DID URL\" rectangle, an arrow, labeled \"contains\", extends upwards, pointing to the \"DID\" rectangle. From the bottom of the \"DID URL\" rectangle, an arrow, labeled \"refers, and dereferences, to\", extends downward, pointing to the \"DID document\" rectangle. An arrow from the \"DID\" rectangle, labeled \"resolves to\", points down to the \"DID document\" rectangle. An arrow from the \"DID\" rectangle, labeled \"refers to\", points left to the \"DID subject\" oval. An arrow from the \"DID controller\" oval, labeled \"controls\", points right to the \"DID document\" rectangle. An arrow from the \"DID\" rectangle, labeled \"recorded on\", points downards to the right, to the \"Verifiable Data Registry\" cylinder. An arrow from the \"DID document\" rectangle, labeled \"recorded on\", points upwards to the right to the \"Verifiable Data Registry\" cylinder.\n\nDIDs and DID URLs\n\nA Decentralized Identifier, or DID, is a URI composed of three parts: the scheme did:, a method identifier, and a unique, method-specific identifier specified by the DID method. DIDs are resolvable to DID documents. A DID URL extends the syntax of a basic DID to incorporate other standard URI components such as path, query, and fragment in order to locate a particular resource—for example, a cryptographic public key inside a DID document, or a resource external to the DID document. These concepts are elaborated upon in and .\n\nDID subjects\n\nThe subject of a DID is, by definition, the entity identified by the DID. The DID subject might also be the DID controller. Anything can be the subject of a DID: person, group, organization, thing, or concept. This is further defined in .\n\nDID controllers\n\nThe controller of a DID is the entity (person, organization, or autonomous software) that has the capability—as defined by a DID method—to make changes to a DID document. This capability is typically asserted by the control of a set of cryptographic keys used by software acting on behalf of the controller, though it might also be asserted via other mechanisms. Note that a DID might have more than one controller, and the DID subject can be the DID controller, or one of them. This concept is documented in .\n\nVerifiable data registries\n\nIn order to be resolvable to DID documents, DIDs are typically recorded on an underlying system or network of some kind. Regardless of the specific technology used, any such system that supports recording DIDs and returning data necessary to produce DID documents is called a verifiable data registry. Examples include distributed ledgers, decentralized file systems, databases of any kind, peer-to-peer networks, and other forms of trusted data storage. This concept is further elaborated upon in .\n\nDID documents\n\nDID documents contain information associated with a DID. They typically express verification methods, such as cryptographic public keys, and services relevant to interactions with the DID subject. The generic properties supported in a DID document are specified in . A DID document can be serialized to a byte stream (see ). The properties present in a DID document can be updated according to the applicable operations outlined in .\n\nDID methods\n\nDID methods are the mechanism by which a particular type of DID and its associated DID document are created, resolved, updated, and deactivated. DID methods are defined using separate DID method specifications as defined in .\n\nDID resolvers and DID resolution\n\nA DID resolver is a system component that takes a DID as input and produces a conforming DID document as output. This process is called DID resolution. The steps for resolving a specific type of DID are defined by the relevant DID method specification. The process of DID resolution is elaborated upon in .\n\nDID URL dereferencers and DID URL dereferencing\n\nA DID URL dereferencer is a system component that takes a DID URL as input and produces a resource as output. This process is called DID URL dereferencing. The process of DID URL dereferencing is elaborated upon in .\n\nThis document contains examples that contain JSON and JSON-LD content. Some of these examples contain characters that are invalid, such as inline comments (//) and the use of ellipsis (...) to denote information that adds little value to the example. Implementers are cautioned to remove this content if they desire to use the information as valid JSON or JSON-LD.\n\nSome examples contain terms, both property names and values, that are not defined in this specification. These are indicated with a comment (// external (property name|value)). Such terms, when used in a DID document, are expected to be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]] with links to both a formal definition and a JSON-LD context.\n\nInteroperability of implementations for DIDs and DID documents is tested by evaluating an implementation's ability to create and parse DIDs and DID documents that conform to this specification. Interoperability for producers and consumers of DIDs and DID documents is provided by ensuring the DIDs and DID documents conform. Interoperability for DID method specifications is provided by the details in each DID method specification. It is understood that, in the same way that a web browser is not required to implement all known URI schemes, conformant software that works with DIDs is not required to implement all known DID methods. However, all implementations of a given DID method are expected to be interoperable for that method.\n\nA conforming DID is any concrete expression of the rules specified in which complies with relevant normative statements in that section.\n\nA conforming DID document is any concrete expression of the data model described in this specification which complies with the relevant normative statements in and . A serialization format for the conforming document is deterministic, bi-directional, and lossless, as described in .\n\nA conforming producer is any algorithm realized as software and/or hardware that generates conforming DIDs or conforming DID Documents and complies with the relevant normative statements in .\n\nA conforming consumer is any algorithm realized as software and/or hardware that consumes conforming DIDs or conforming DID documents and complies with the relevant normative statements in .\n\nA conforming DID resolver is any algorithm realized as software and/or hardware that complies with the relevant normative statements in .\n\nA conforming DID URL dereferencer is any algorithm realized as software and/or hardware that complies with the relevant normative statements in .\n\nA conforming DID method is any specification that complies with the relevant normative statements in .\n\nCore Properties\n\nA DID is associated with a DID document. DID documents are expressed using the data model and can be serialized into a representation. The following sections define the properties in a DID document, including whether these properties are required or optional. These properties describe relationships between the DID subject and the value of the property.\n\nThe following tables contain informative references for the core properties defined by this specification, with expected values, and whether or not they are required. The property names in the tables are linked to the normative definitions and more detailed descriptions of each property.\n\nThe property names id, type, and controller can be present in maps of different types with possible differences in constraints.\n\nDID Document properties\n\nProperty Required? Value constraints id yes A string that conforms to the rules in . alsoKnownAs no A set of strings that conform to the rules of [[RFC3986]] for URIs. controller no A string or a set of strings that conform to the rules in . verificationMethod no A set of Verification Method maps that conform to the rules in . authentication no A set of either Verification Method maps that conform to the rules in ) or strings that conform to the rules in . assertionMethod no keyAgreement no capabilityInvocation no capabilityDelegation no service no A set of Service Endpoint maps that conform to the rules in .\n\nVerification Method properties\n\nProperty Required? Value constraints id yes A string that conforms to the rules in . controller yes A string that conforms to the rules in . type yes A string. publicKeyJwk no A map representing a JSON Web Key that conforms to [[RFC7517]]. See definition of publicKeyJwk for additional constraints. publicKeyMultibase no A string that conforms to a [[?MULTIBASE]] encoded public key.\n\nService properties\n\nProperty Required? Value constraints id yes A string that conforms to the rules of [[RFC3986]] for URIs. type yes A string or a set of strings. serviceEndpoint yes A string that conforms to the rules of [[RFC3986]] for URIs, a map, or a set composed of a one or more strings that conform to the rules of [[RFC3986]] for URIs and/or maps.\n\nIdentifiers\n\nThis section describes the mechanisms by which DID documents include identifiers for DID subjects and DID controllers.\n\nDID Subject\n\nThe DID for a particular DID subject is expressed using the id property in the DID document.\n\nid\n\nThe value of id MUST be a string that conforms to the rules in and MUST exist in the root map of the data model for the DID document.\n\n{ \"id\": \"did:example:123456789abcdefghijk\" }\n\nThe id property only denotes the DID of the DID subject when it is present in the topmost map of the DID document.\n\nDID method specifications can create intermediate representations of a DID document that do not contain the id property, such as when a DID resolver is performing DID resolution. However, the fully resolved DID document always contains a valid id property.\n\nDID Controller\n\nA DID controller is an entity that is authorized to make changes to a DID document. The process of authorizing a DID controller is defined by the DID method.\n\ncontroller\n\nThe controller property is OPTIONAL. If present, the value MUST be a string or a set of strings that conform to the rules in . The corresponding DID document(s) SHOULD contain verification relationships that explicitly permit the use of certain verification methods for specific purposes.\n\nWhen a controller property is present in a DID document, its value expresses one or more DIDs. Any verification methods contained in the DID documents for those DIDs SHOULD be accepted as authoritative, such that proofs that satisfy those verification methods are to be considered equivalent to proofs provided by the DID subject and represent the DID controller(s) authorized to make updates to the DID document.\n\n{ \"@context\": \"https://www.w3.org/ns/did/v1\", \"id\": \"did:example:123456789abcdefghi\", \"controller\": \"did:example:bcehfew7h32f32h7af3\", }\n\nNote that authorization provided by the value of controller is separate from authentication as described in . This is particularly important for key recovery in the case of cryptographic key loss, where the DID subject no longer has access to their keys, or key compromise, where the DID controller's trusted third parties need to override malicious activity by an attacker. See for information related to threat models and attack vectors.\n\nAlso Known As\n\nA DID subject can have multiple identifiers for different purposes, or at different times. The assertion that two or more DIDs (or other types of URI) refer to the same DID subject can be made using the alsoKnownAs property.\n\nalsoKnownAs\n\nThe alsoKnownAs property is OPTIONAL. If present, the value MUST be a set where each item in the set is a URI conforming to [[RFC3986]].\n\nThis relationship is a statement that the subject of this identifier is also identified by one or more other identifiers.\n\nApplications might choose to consider two identifiers related by alsoKnownAs to be equivalent if the alsoKnownAs relationship is reciprocated in the reverse direction. It is best practice not to consider them equivalent in the absence of this inverse relationship. In other words, the presence of an alsoKnownAs assertion does not prove that this assertion is true. Therefore, it is strongly advised that a requesting party obtain independent verification of an alsoKnownAs assertion.\n\nGiven that the DID subject might use different identifiers for different purposes, an expectation of strong equivalence between the two identifiers, or merging the information of the two corresponding DID documents, is not necessarily appropriate, even with a reciprocal relationship.\n\nVerification Methods\n\nA DID document can express verification methods, such as cryptographic public keys, which can be used to authenticate or authorize interactions with the DID subject or associated parties. For example, a cryptographic public key can be used as a verification method with respect to a digital signature; in such usage, it verifies that the signer could use the associated cryptographic private key. Verification methods might take many parameters. An example of this is a set of five cryptographic keys from which any three are required to contribute to a cryptographic threshold signature.\n\nverificationMethod\n\nThe verificationMethod property is OPTIONAL. If present, the value MUST be a set of verification methods, where each verification method is expressed using a map. The verification method map MUST include the id, type, controller, and specific verification material properties that are determined by the value of type and are defined in . A verification method MAY include additional properties. Verification methods SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]].\n\nid\n\nThe value of the id property for a verification method MUST be a string that conforms to the rules in Section . This value represents the DID URL that dereferences to the identified verification method.\n\ntype\n\nThe value of the type property MUST be a string that references exactly one verification method type. In order to maximize global interoperability, the verification method type SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This value represents the type of verification method suite in use.\n\ncontroller\n\nThe value of the controller property MUST be a string that conforms to the rules in . This value represents either the DID controller or DID delegate who possesses the secret cryptographic material used to authenticate the verification method.\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/jws-2020/v1\" \"https://w3id.org/security/suites/ed25519-2020/v1\" ] \"id\": \"did:example:123456789abcdefghi\", \"verificationMethod\": [{ \"id\": , \"type\": , \"controller\": , \"publicKeyJwk\": }, { \"id\": , \"type\": , \"controller\": , \"publicKeyMultibase\": }] }\n\nThe semantics of the controller property are the same when the subject of the relationship is the DID document as when the subject of the relationship is a verification method, such as a cryptographic public key. Since a key can't control itself, and the key controller cannot be inferred from the DID document, it is necessary to explicitly express the identity of the controller of the key. The difference is that the value of controller for a verification method is not necessarily a DID controller. DID controllers are expressed using the controller property at the highest level of the DID document (the topmost map in the data model); see .\n\nVerification Material\n\nVerification material is any information that is used by a process that applies a verification method. The type of a verification method is expected to be used to determine its compatibility with such processes. Examples of verification material properties are publicKeyJwk or publicKeyMultibase. A cryptographic suite specification is responsible for specifying the verification method type and its associated verification material. For example, see JSON Web Signature 2020 and Ed25519 Signature 2020. For all registered verification method types and associated verification material available for DIDs, please see the DID Specification Registries [[?DID-SPEC-REGISTRIES]].\n\nTo increase the likelihood of interoperable implementations, this specification limits the number of formats for expressing verification material in a DID document. The fewer formats that implementers have to implement, the more likely it will be that they will support all of them. This approach attempts to strike a delicate balance between ease of implementation and supporting formats that have historically had broad deployment. Two supported verification material properties are listed below:\n\npublicKeyJwk\n\nThe publicKeyJwk property is OPTIONAL. If present, the value MUST be a map representing a JSON Web Key that conforms to [[RFC7517]]. The map MUST NOT contain \"d\", or any other members of the private information class as described in Registration Template. It is RECOMMENDED that verification methods that use JWKs [[RFC7517]] to represent their public keys use the value of kid as their fragment identifier. It is RECOMMENDED that JWK kid values are set to the public key fingerprint [[RFC7638]]. See the first key in for an example of a public key with a compound key identifier.\n\npublicKeyMultibase\n\nThe publicKeyMultibase property is OPTIONAL. This feature is non-normative. If present, the value MUST be a string representation of a [[?MULTIBASE]] encoded public key.\n\nNote that the [[?MULTIBASE]] specification is not yet a standard and is subject to change. There might be some use cases for this data format where publicKeyMultibase is defined, to allow for expression of public keys, but privateKeyMultibase is not defined, to protect against accidental leakage of secret keys.\n\nA verification method MUST NOT contain multiple verification material properties for the same material. For example, expressing key material in a verification method using both publicKeyJwk and publicKeyMultibase at the same time is prohibited.\n\nAn example of a DID document containing verification methods using both properties above is shown below.\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/jws-2020/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ] \"id\": \"did:example:123456789abcdefghi\", \"verificationMethod\": [{ \"id\": \"did:example:123#_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A\", \"type\": \"JsonWebKey2020\", \"controller\": \"did:example:123\", \"publicKeyJwk\": { \"crv\": \"Ed25519\", \"x\": \"VCpo2LMLhn6iWku8MKvSLg2ZAoC-nlOyPVQaO3FxVeQ\", \"kty\": \"OKP\", \"kid\": \"_Qq0UL2Fq651Q0Fjd6TvnYE-faHiOpRlPVQcY_-tA4A\" } }, { \"id\": \"did:example:123456789abcdefghi#keys-1\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:pqrstuvwxyz0987654321\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" }], }\n\nReferring to Verification Methods\n\nVerification methods can be embedded in or referenced from properties associated with various verification relationships as described in . Referencing verification methods allows them to be used by more than one verification relationship.\n\nIf the value of a verification method property is a map, the verification method has been embedded and its properties can be accessed directly. However, if the value is a URL string, the verification method has been included by reference and its properties will need to be retrieved from elsewhere in the DID document or from another DID document. This is done by dereferencing the URL and searching the resulting resource for a verification method map with an id property whose value matches the URL.\n\n{ \"authentication\": [ \"did:example:123456789abcdefghi#keys-1\", { \"id\": \"did:example:123456789abcdefghi#keys-2\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" } ], }\n\nVerification Relationships\n\nA verification relationship expresses the relationship between the DID subject and a verification method.\n\nDifferent verification relationships enable the associated verification methods to be used for different purposes. It is up to a verifier to ascertain the validity of a verification attempt by checking that the verification method used is contained in the appropriate verification relationship property of the DID Document.\n\nThe verification relationship between the DID subject and the verification method is explicit in the DID document. Verification methods that are not associated with a particular verification relationship cannot be used for that verification relationship. For example, a verification method in the value of the authentication property cannot be used to engage in key agreement protocols with the DID subject—the value of the keyAgreement property needs to be used for that.\n\nThe DID document does not express revoked keys using a verification relationship. If a referenced verification method is not in the latest DID Document used to dereference it, then that verification method is considered invalid or revoked. Each DID method specification is expected to detail how revocation is performed and tracked.\n\nThe following sections define several useful verification relationships. A DID document MAY include any of these, or other properties, to express a specific verification relationship. In order to maximize global interoperability, any such properties used SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]].\n\nAuthentication\n\nThe authentication verification relationship is used to specify how the DID subject is expected to be authenticated, for purposes such as logging into a website or engaging in any sort of challenge-response protocol.\n\nauthentication\n\nThe authentication property is OPTIONAL. If present, the associated value MUST be a set of one or more verification methods. Each verification method MAY be embedded or referenced.\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ], \"id\": \"did:example:123456789abcdefghi\", \"authentication\": [ \"did:example:123456789abcdefghi#keys-1\", { \"id\": \"did:example:123456789abcdefghi#keys-2\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" } ], }\n\nIf authentication is established, it is up to the DID method or other application to decide what to do with that information. A particular DID method could decide that authenticating as a DID controller is sufficient to, for example, update or delete the DID document. Another DID method could require different keys, or a different verification method entirely, to be presented in order to update or delete the DID document than that used to authenticate. In other words, what is done after the authentication check is out of scope for the data model; DID methods and applications are expected to define this themselves.\n\nThis is useful to any authentication verifier that needs to check to see if an entity that is attempting to authenticate is, in fact, presenting a valid proof of authentication. When a verifier receives some data (in some protocol-specific format) that contains a proof that was made for the purpose of \"authentication\", and that says that an entity is identified by the DID, then that verifier checks to ensure that the proof can be verified using a verification method (e.g., public key) listed under authentication in the DID Document.\n\nNote that the verification method indicated by the authentication property of a DID document can only be used to authenticate the DID subject. To authenticate a different DID controller, the entity associated with the value of controller, as defined in , needs to authenticate with its own DID document and associated authentication verification relationship.\n\nAssertion\n\nThe assertionMethod verification relationship is used to specify how the DID subject is expected to express claims, such as for the purposes of issuing a Verifiable Credential [[?VC-DATA-MODEL]].\n\nassertionMethod\n\nThe assertionMethod property is OPTIONAL. If present, the associated value MUST be a set of one or more verification methods. Each verification method MAY be embedded or referenced.\n\nThis property is useful, for example, during the processing of a verifiable credential by a verifier. During verification, a verifier checks to see if a verifiable credential contains a proof created by the DID subject by checking that the verification method used to assert the proof is associated with the assertionMethod property in the corresponding DID document.\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ], \"id\": \"did:example:123456789abcdefghi\", \"assertionMethod\": [ \"did:example:123456789abcdefghi#keys-1\", { \"id\": \"did:example:123456789abcdefghi#keys-2\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" } ], }\n\nKey Agreement\n\nThe keyAgreement verification relationship is used to specify how an entity can generate encryption material in order to transmit confidential information intended for the DID subject, such as for the purposes of establishing a secure communication channel with the recipient.\n\nkeyAgreement\n\nThe keyAgreement property is OPTIONAL. If present, the associated value MUST be a set of one or more verification methods. Each verification method MAY be embedded or referenced.\n\nAn example of when this property is useful is when encrypting a message intended for the DID subject. In this case, the counterparty uses the cryptographic public key information in the verification method to wrap a decryption key for the recipient.\n\n{ \"@context\": \"https://www.w3.org/ns/did/v1\", \"id\": \"did:example:123456789abcdefghi\", \"keyAgreement\": [ \"did:example:123456789abcdefghi#keys-1\", { \"id\": \"did:example:123#zC9ByQ8aJs8vrNXyDhPHHNNMSHPcaSgNpjjsBYpMMjsTdS\", \"type\": \"X25519KeyAgreementKey2019\", \"controller\": \"did:example:123\", \"publicKeyMultibase\": \"z6LSn6p3HRxx1ZZk1dT9VwcfTBCYgtNWdzdDMKPZjShLNWG7\" } ], }\n\nCapability Invocation\n\nThe capabilityInvocation verification relationship is used to specify a verification method that might be used by the DID subject to invoke a cryptographic capability, such as the authorization to update the DID Document.\n\ncapabilityInvocation\n\nThe capabilityInvocation property is OPTIONAL. If present, the associated value MUST be a set of one or more verification methods. Each verification method MAY be embedded or referenced.\n\nAn example of when this property is useful is when a DID subject needs to access a protected HTTP API that requires authorization in order to use it. In order to authorize when using the HTTP API, the DID subject uses a capability that is associated with a particular URL that is exposed via the HTTP API. The invocation of the capability could be expressed in a number of ways, e.g., as a digitally signed message that is placed into the HTTP Headers.\n\nThe server providing the HTTP API is the verifier of the capability and it would need to verify that the verification method referred to by the invoked capability exists in the capabilityInvocation property of the DID document. The verifier would also check to make sure that the action being performed is valid and the capability is appropriate for the resource being accessed. If the verification is successful, the server has cryptographically determined that the invoker is authorized to access the protected resource.\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ], \"id\": \"did:example:123456789abcdefghi\", \"capabilityInvocation\": [ \"did:example:123456789abcdefghi#keys-1\", { \"id\": \"did:example:123456789abcdefghi#keys-2\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" } ], }\n\nCapability Delegation\n\nThe capabilityDelegation verification relationship is used to specify a mechanism that might be used by the DID subject to delegate a cryptographic capability to another party, such as delegating the authority to access a specific HTTP API to a subordinate.\n\ncapabilityDelegation\n\nThe capabilityDelegation property is OPTIONAL. If present, the associated value MUST be a set of one or more verification methods. Each verification method MAY be embedded or referenced.\n\nAn example of when this property is useful is when a DID controller chooses to delegate their capability to access a protected HTTP API to a party other than themselves. In order to delegate the capability, the DID subject would use a verification method associated with the capabilityDelegation verification relationship to cryptographically sign the capability over to another DID subject. The delegate would then use the capability in a manner that is similar to the example described in .\n\n{ \"@context\": [ \"https://www.w3.org/ns/did/v1\", \"https://w3id.org/security/suites/ed25519-2020/v1\" ], \"id\": \"did:example:123456789abcdefghi\", \"capabilityDelegation\": [ \"did:example:123456789abcdefghi#keys-1\", { \"id\": \"did:example:123456789abcdefghi#keys-2\", \"type\": \"Ed25519VerificationKey2020\", \"controller\": \"did:example:123456789abcdefghi\", \"publicKeyMultibase\": \"z6MkmM42vxfqZQsv4ehtTjFFxQ4sQKS2w6WR7emozFAn5cxu\" } ], }\n\nServices\n\nServices are used in DID documents to express ways of communicating with the DID subject or associated entities. A service can be any type of service the DID subject wants to advertise, including decentralized identity management services for further discovery, authentication, authorization, or interaction.\n\nDue to privacy concerns, revealing public information through services, such as social media accounts, personal websites, and email addresses, is discouraged. Further exploration of privacy concerns can be found in and . The information associated with services is often service specific. For example, the information associated with an encrypted messaging service can express how to initiate the encrypted link before messaging begins.\n\nServices are expressed using the service property, which is described below:\n\nservice\n\nThe service property is OPTIONAL. If present, the associated value MUST be a set of services, where each service is described by a map. Each service map MUST contain id, type, and serviceEndpoint properties. Each service extension MAY include additional properties and MAY further restrict the properties associated with the extension.\n\nid\n\nThe value of the id property MUST be a URI conforming to [[RFC3986]]. A conforming producer MUST NOT produce multiple service entries with the same id. A conforming consumer MUST produce an error if it detects multiple service entries with the same id.\n\ntype\n\nThe value of the type property MUST be a string or a set of strings. In order to maximize interoperability, the service type and its associated properties SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]].\n\nserviceEndpoint\n\nThe value of the serviceEndpoint property MUST be a string, a map, or a set composed of one or more strings and/or maps. All string values MUST be valid URIs conforming to [[RFC3986]] and normalized according to the Normalization and Comparison rules in RFC3986 and to any normalization rules in its applicable URI scheme specification.\n\nFor more information regarding privacy and security considerations related to services see , , , and .\n\n{ \"service\": [{ \"id\":\"did:example:123#linked-domain\", \"type\": \"LinkedDomains\", \"serviceEndpoint\": \"https://bar.example.com\" }] }\n\nResolution\n\nThis section defines the inputs and outputs of DID resolution and DID URL dereferencing. Their exact implementation is out of scope for this specification, but some considerations for implementers are discussed in [[?DID-RESOLUTION]].\n\nAll conformant DID resolvers MUST implement the DID resolution functions for at least one DID method and MUST be able to return a DID document in at least one conformant representation.\n\nDID Resolution\n\nThe DID resolution functions resolve a DID into a DID document by using the \"Read\" operation of the applicable DID method as described in . The details of how this process is accomplished are outside the scope of this specification, but all conforming DID resolvers implement the functions below, which have the following abstract forms:\n\nresolve(did, resolutionOptions) → « didResolutionMetadata, didDocument, didDocumentMetadata » resolveRepresentation(did, resolutionOptions) → « didResolutionMetadata, didDocumentStream, didDocumentMetadata »\n\nThe resolve function returns the DID document in its abstract form (a map). The resolveRepresentation function returns a byte stream of the DID Document formatted in the corresponding representation.\n\nThe upper middle part of the diagram contains a rectangle with dashed grey outline, containing two blue-outlined rectangles, one above the other. The upper, larger rectangle is labeled, in blue, \"Core Properties\", and contains the following INFRA notation:\n\n«[ \"id\" → \"example:123\", \"verificationMethod\" → « «[ \"id\": \"did:example:123#keys-1\", \"controller\": \"did:example:123\", \"type\": \"Ed25519VerificationKey2018\", \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVA\" ]» », \"authentication\" → « \"did:example:123#keys-1\" » ]»\n\nThe lower, smaller rectangle is labeled, in blue, \"Core Representation-specific Entries (JSON-LD)\", and contains the following monospaced INFRA notation:\n\n«[ \"@context\" → \"https://www.w3.org/ns/did/v1\" ]»\n\nFrom the grey-outlined rectangle, three pairs of arrows extend to three different black-outlined rectangles, aligned in a horizontal row side-by-side, in the bottom half of the diagram. Each pair of arrows consists of one blue arrow pointing from the grey-outlined rectangle to the respective black-outlined rectangle, labeled \"produce\", and one red arrow pointing in the reverse direction, labeled \"consume\". The first black-outlined rectangle in the row is labeled \"application/did+ld+json\", and contains the following JSON-LD data:\n\n{ \"@context\": [\"https://www.w3.org/ns/did/v1\"], \"id\": \"did:example:123\", \"verificationMethod\": [{ \"id\": \"did:example:123#keys-1\", \"controller\": \"did:example:123\", \"type\": \"Ed25519VerificationKey2018\", \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVA\" }], \"authentication\": [ \"did:example:123#keys-1\" ] }\n\nThe second rectangle in the row is labeled \"application/did+json\" and contains the following JSON data:\n\n{ \"id\": \"did:example:123\", \"verificationMethod\": [{ \"id\": \"did:example:123#keys-1\", \"controller\": \"did:example:123\", \"type\": \"Ed25519VerificationKey2018\", \"publicKeyBase58\": \"H3C2AVvLMv6gmMNam3uVA\" }], \"authentication\": [ \"did:example:123#keys-1\" ] }\n\nThe third rectangle in the row is labeled \"application/did+cbor\", and contains hexadecimal data.\n\nIn the left part of the diagram, in the middle, there is a box, with black outline and light gray background. This box is labeled \"VERIFIABLE DATA REGISTRY\" and contains a symbol representing a graph with nodes and arcs. From this box, one arrow, labeled \"resolve()\", extends upwards and points to the top half of the diagram where the grey-outlined rectangle is located. Another arrow, labeled \"resolveRepresentation()\", extends downwards and points to the bottom half of the diagram, where the row of three black-outlined rectangles is located.\n\nThe input variables of the resolve and resolveRepresentation functions are as follows:\n\ndid\n\nThis is the DID to resolve. This input is REQUIRED and the value MUST be a conformant DID as defined in .\n\nresolutionOptions\n\nA metadata structure containing properties defined in . This input is REQUIRED, but the structure MAY be empty.\n\nThese functions each return multiple values, and no limitations are placed on how these values are returned together. The return values of resolve are didResolutionMetadata, didDocument, and didDocumentMetadata. The return values of resolveRepresentation are didResolutionMetadata, didDocumentStream, and didDocumentMetadata. These values are described below:\n\ndidResolutionMetadata\n\nA metadata structure consisting of values relating to the results of the DID resolution process which typically changes between invocations of the resolve and resolveRepresentation functions, as it represents data about the resolution process itself. This structure is REQUIRED, and in the case of an error in the resolution process, this MUST NOT be empty. This metadata is defined by . If resolveRepresentation was called, this structure MUST contain a contentType property containing the Media Type of the representation found in the didDocumentStream. If the resolution is not successful, this structure MUST contain an error property describing the error.\n\ndidDocument\n\nIf the resolution is successful, and if the resolve function was called, this MUST be a DID document abstract data model (a map) as described in that is capable of being transformed into a conforming DID Document (representation), using the production rules specified by the representation. The value of id in the resolved DID document MUST match the DID that was resolved. If the resolution is unsuccessful, this value MUST be empty.\n\ndidDocumentStream\n\nIf the resolution is successful, and if the resolveRepresentation function was called, this MUST be a byte stream of the resolved DID document in one of the conformant representations. The byte stream might then be parsed by the caller of the resolveRepresentation function into a data model, which can in turn be validated and processed. If the resolution is unsuccessful, this value MUST be an empty stream.\n\ndidDocumentMetadata\n\nIf the resolution is successful, this MUST be a metadata structure. This structure contains metadata about the DID document contained in the didDocument property. This metadata typically does not change between invocations of the resolve and resolveRepresentation functions unless the DID document changes, as it represents metadata about the DID document. If the resolution is unsuccessful, this output MUST be an empty metadata structure. Properties defined by this specification are in .\n\nConforming DID resolver implementations do not alter the signature of these functions in any way. DID resolver implementations might map the resolve and resolveRepresentation functions to a method-specific internal function to perform the actual DID resolution process. DID resolver implementations might implement and expose additional functions with different signatures in addition to the resolve and resolveRepresentation functions specified here.\n\nDID Resolution Options\n\nThe possible properties within this structure and their possible values are registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following common properties.\n\naccept\n\nThe Media Type of the caller's preferred representation of the DID document. The Media Type MUST be expressed as an ASCII string. The DID resolver implementation SHOULD use this value to determine the representation contained in the returned didDocumentStream if such a representation is supported and available. This property is OPTIONAL for the resolveRepresentation function and MUST NOT be used with the resolve function.\n\nDID Resolution Metadata\n\nThe possible properties within this structure and their possible values are registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following DID resolution metadata properties:\n\ncontentType\n\nThe Media Type of the returned didDocumentStream. This property is REQUIRED if resolution is successful and if the resolveRepresentation function was called. This property MUST NOT be present if the resolve function was called. The value of this property MUST be an ASCII string that is the Media Type of the conformant representations. The caller of the resolveRepresentation function MUST use this value when determining how to parse and process the didDocumentStream returned by this function into the data model.\n\nerror\n\nThe error code from the resolution process. This property is REQUIRED when there is an error in the resolution process. The value of this property MUST be a single keyword ASCII string. The possible property values of this field SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following common error values:\n\ninvalidDid\n\nThe DID supplied to the DID resolution function does not conform to valid syntax. (See .)\n\nnotFound\n\nThe DID resolver was unable to find the DID document resulting from this resolution request.\n\nrepresentationNotSupported\n\nThis error code is returned if the representation requested via the accept input metadata property is not supported by the DID method and/or DID resolver implementation.\n\nDID Document Metadata\n\nThe possible properties within this structure and their possible values SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following common properties.\n\ncreated\n\nDID document metadata SHOULD include a created property to indicate the timestamp of the Create operation. The value of the property MUST be a string formatted as an XML Datetime normalized to UTC 00:00:00 and without sub-second decimal precision. For example: 2020-12-20T19:17:47Z.\n\nupdated\n\nDID document metadata SHOULD include an updated property to indicate the timestamp of the last Update operation for the document version which was resolved. The value of the property MUST follow the same formatting rules as the created property. The updated property is omitted if an Update operation has never been performed on the DID document. If an updated property exists, it can be the same value as the created property when the difference between the two timestamps is less than one second.\n\ndeactivated\n\nIf a DID has been deactivated, DID document metadata MUST include this property with the boolean value true. If a DID has not been deactivated, this property is OPTIONAL, but if included, MUST have the boolean value false.\n\nnextUpdate\n\nDID document metadata MAY include a nextUpdate property if the resolved document version is not the latest version of the document. It indicates the timestamp of the next Update operation. The value of the property MUST follow the same formatting rules as the created property.\n\nversionId\n\nDID document metadata SHOULD include a versionId property to indicate the version of the last Update operation for the document version which was resolved. The value of the property MUST be an ASCII string.\n\nnextVersionId\n\nDID document metadata MAY include a nextVersionId property if the resolved document version is not the latest version of the document. It indicates the version of the next Update operation. The value of the property MUST be an ASCII string.\n\nequivalentId\n\nA DID method can define different forms of a DID that are logically equivalent. An example is when a DID takes one form prior to registration in a verifiable data registry and another form after such registration. In this case, the DID method specification might need to express one or more DIDs that are logically equivalent to the resolved DID as a property of the DID document. This is the purpose of the equivalentId property.\n\nDID document metadata MAY include an equivalentId property. If present, the value MUST be a set where each item is a string that conforms to the rules in Section . The relationship is a statement that each equivalentId value is logically equivalent to the id property value and thus refers to the same DID subject. Each equivalentId DID value MUST be produced by, and a form of, the same DID method as the id property value. (e.g., did:example:abc == did:example:ABC)\n\nA conforming DID method specification MUST guarantee that each equivalentId value is logically equivalent to the id property value.\n\nA requesting party is expected to retain the values from the id and equivalentId properties to ensure any subsequent interactions with any of the values they contain are correctly handled as logically equivalent (e.g., retain all variants in a database so an interaction with any one maps to the same underlying account).\n\nequivalentId is a much stronger form of equivalence than alsoKnownAs because the equivalence MUST be guaranteed by the governing DID method. equivalentId represents a full graph merge because the same DID document describes both the equivalentId DID and the id property DID.\n\nIf a requesting party does not retain the values from the id and equivalentId properties and ensure any subsequent interactions with any of the values they contain are correctly handled as logically equivalent, there might be negative or unexpected issues that arise. Implementers are strongly advised to observe the directives related to this metadata property.\n\ncanonicalId\n\nThe canonicalId property is identical to the equivalentId property except: a) it is associated with a single value rather than a set, and b) the DID is defined to be the canonical ID for the DID subject within the scope of the containing DID document.\n\nDID document metadata MAY include a canonicalId property. If present, the value MUST be a string that conforms to the rules in Section . The relationship is a statement that the canonicalId value is logically equivalent to the id property value and that the canonicalId value is defined by the DID method to be the canonical ID for the DID subject in the scope of the containing DID document. A canonicalId value MUST be produced by, and a form of, the same DID method as the id property value. (e.g., did:example:abc == did:example:ABC).\n\nA conforming DID method specification MUST guarantee that the canonicalId value is logically equivalent to the id property value.\n\nA requesting party is expected to use the canonicalId value as its primary ID value for the DID subject and treat all other equivalent values as secondary aliases (e.g., update corresponding primary references in their systems to reflect the new canonical ID directive).\n\ncanonicalId is the same statement of equivalence as equivalentId except it is constrained to a single value that is defined to be canonical for the DID subject in the scope of the DID document. Like equivalentId, canonicalId represents a full graph merge because the same DID document describes both the canonicalId DID and the id property DID.\n\nIf a resolving party does not use the canonicalId value as its primary ID value for the DID subject and treat all other equivalent values as secondary aliases, there might be negative or unexpected issues that arise related to user experience. Implementers are strongly advised to observe the directives related to this metadata property.\n\nDID URL Dereferencing\n\nThe DID URL dereferencing function dereferences a DID URL into a resource with contents depending on the DID URL's components, including the DID method, method-specific identifier, path, query, and fragment. This process depends on DID resolution of the DID contained in the DID URL. DID URL dereferencing might involve multiple steps (e.g., when the DID URL being dereferenced includes a fragment), and the function is defined to return the final resource after all steps are completed. The details of how this process is accomplished are outside the scope of this specification. The following figure depicts the relationship described above.\n\nThe top left part of the diagram contains a rectangle with black outline, labeled \"DID\".\n\nThe bottom left part of the diagram contains a rectangle with black outline, labeled \"DID URL\". This rectangle contains four smaller black-outlined rectangles, aligned in a horizontal row adjacent to each other. These smaller rectangles are labeled, in order, \"DID\", \"path\", \"query\", and \"fragment.\n\nThe top right part of the diagram contains a rectangle with black outline, labeled \"DID document\". This rectangle contains three smaller black-outlined rectangles. These smaller rectangles are labeled \"id\", \"(property X)\", and \"(property Y)\", and are surrounded by multiple series of three dots (ellipses). A curved black arrow, labeled \"DID document - relative fragment dereference\", extends from the rectangle labeled \"(property X)\", and points to the rectangle labeled \"(property Y)\".\n\nThe bottom right part of the diagram contains an oval shape with black outline, labeled \"Resource\".\n\nA black arrow, labeled \"resolves to a DID document\", extends from the rectangle in the top left part of the diagram, labeled \"DID\", and points to the rectangle in the top right part of diagram, labeled \"DID document\".\n\nA black arrow, labeled \"refers to\", extends from the rectangle in the top right part of the diagram, labeled \"DID document\", and points to the oval shape in the bottom right part of diagram, labeled \"Resource\".\n\nA black arrow, labeled \"contains\", extends from the small rectangle labeled \"DID\" inside the rectangle in the bottom left part of the diagram, labeled \"DID URL\", and points to the rectangle in the top left part of diagram, labeled \"DID\".\n\nA black arrow, labeled \"dereferences to a DID document\", extends from the rectangle in the bottom left part of the diagram, labeled \"DID URL\", and points to the rectangle in the top right part of diagram, labeled \"DID document\".\n\nA black arrow, labeled \"dereferences to a resource\", extends from the rectangle in the bottom left part of the diagram, labeled \"DID URL\", and points to the oval shape in the bottom right part of diagram, labeled \"Resource\".\n\nAll conforming DID resolvers implement the following function which has the following abstract form:\n\ndereference(didUrl, dereferenceOptions) → « dereferencingMetadata, contentStream, contentMetadata »\n\nThe input variables of the dereference function are as follows:\n\ndidUrl\n\nA conformant DID URL as a single string. This is the DID URL to dereference. To dereference a DID fragment, the complete DID URL including the DID fragment MUST be used. This input is REQUIRED.\n\nWhile it is valid for any didUrl to be passed to a DID URL dereferencer, implementers are expected to refer to [[?DID-RESOLUTION]] to further understand common patterns for how a DID URL is expected to be dereferenced.\n\ndereferencingOptions\n\nA metadata structure consisting of input options to the dereference function in addition to the didUrl itself. Properties defined by this specification are in . This input is REQUIRED, but the structure MAY be empty.\n\nThis function returns multiple values, and no limitations are placed on how these values are returned together. The return values of the dereference include dereferencingMetadata, contentStream, and contentMetadata:\n\ndereferencingMetadata\n\nA metadata structure consisting of values relating to the results of the DID URL dereferencing process. This structure is REQUIRED, and in the case of an error in the dereferencing process, this MUST NOT be empty. Properties defined by this specification are in . If the dereferencing is not successful, this structure MUST contain an error property describing the error.\n\ncontentStream\n\nIf the dereferencing function was called and successful, this MUST contain a resource corresponding to the DID URL. The contentStream MAY be a resource such as a DID document that is serializable in one of the conformant representations, a Verification Method, a service, or any other resource format that can be identified via a Media Type and obtained through the resolution process. If the dereferencing is unsuccessful, this value MUST be empty.\n\ncontentMetadata\n\nIf the dereferencing is successful, this MUST be a metadata structure, but the structure MAY be empty. This structure contains metadata about the contentStream. If the contentStream is a DID document, this MUST be a didDocumentMetadata structure as described in DID Resolution. If the dereferencing is unsuccessful, this output MUST be an empty metadata structure.\n\nConforming DID URL dereferencing implementations do not alter the signature of these functions in any way. DID URL dereferencing implementations might map the dereference function to a method-specific internal function to perform the actual DID URL dereferencing process. DID URL dereferencing implementations might implement and expose additional functions with different signatures in addition to the dereference function specified here.\n\nDID URL Dereferencing Options\n\nThe possible properties within this structure and their possible values SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following common properties for dereferencing options:\n\naccept\n\nThe Media Type that the caller prefers for contentStream. The Media Type MUST be expressed as an ASCII string. The DID URL dereferencing implementation SHOULD use this value to determine the contentType of the representation contained in the returned value if such a representation is supported and available.\n\nDID URL Dereferencing Metadata\n\nThe possible properties within this structure and their possible values are registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following common properties.\n\ncontentType\n\nThe Media Type of the returned contentStream SHOULD be expressed using this property if dereferencing is successful. The Media Type value MUST be expressed as an ASCII string.\n\nerror\n\nThe error code from the dereferencing process. This property is REQUIRED when there is an error in the dereferencing process. The value of this property MUST be a single keyword expressed as an ASCII string. The possible property values of this field SHOULD be registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]]. This specification defines the following common error values:\n\ninvalidDidUrl\n\nThe DID URL supplied to the DID URL dereferencing function does not conform to valid syntax. (See .)\n\nnotFound\n\nThe DID URL dereferencer was unable to find the contentStream resulting from this dereferencing request.\n\nMetadata Structure\n\nInput and output metadata is often involved during the DID Resolution, DID URL dereferencing, and other DID-related processes. The structure used to communicate this metadata MUST be a map of properties. Each property name MUST be a string. Each property value MUST be a string, map, list, set, boolean, or null. The values within any complex data structures such as maps and lists MUST be one of these data types as well. All metadata property definitions registered in the DID Specification Registries [[?DID-SPEC-REGISTRIES]] MUST define the value type, including any additional formats or restrictions to that value (for example, a string formatted as a date or as a decimal integer). It is RECOMMENDED that property definitions use strings for values. The entire metadata structure MUST be serializable according to the JSON serialization rules in the [[INFRA]] specification. Implementations MAY serialize the metadata structure to other data formats.\n\nAll implementations of functions that use metadata structures as either input or output are able to fully represent all data types described here in a deterministic fashion. As inputs and outputs using metadata structures are defined in terms of data types and not their serialization, the method for representation is internal to the implementation of the function and is out of scope of this specification.\n\nThe following example demonstrates a JSON-encoded metadata structure that might be used as DID resolution input metadata.\n\n{ \"accept\": \"application/did+ld+json\" }\n\nThis example corresponds to a metadata structure of the following format:\n\n«[ \"accept\" → \"application/did+ld+json\" ]»\n\nThe next example demonstrates a JSON-encoded metadata structure that might be used as DID resolution metadata if a DID was not found.\n\n{ \"error\": \"notFound\" }\n\nThis example corresponds to a metadata structure of the following format:\n\n«[ \"error\" → \"notFound\" ]»\n\nThe next example demonstrates a JSON-encoded metadata structure that might be used as DID document metadata to describe timestamps associated with the DID document.\n\n{ \"created\": \"2019-03-23T06:35:22Z\", \"updated\": \"2023-08-10T13:40:06Z\" }\n\nThis example corresponds to a metadata structure of the following format:\n\n«[ \"created\" → \"2019-03-23T06:35:22Z\", \"updated\" → \"2023-08-10T13:40:06Z\" ]»\n\nSecurity Considerations\n\nThis section contains a variety of security considerations that people using Decentralized Identifiers are advised to consider before deploying this technology in a production setting. DIDs are designed to operate under the threat model used by many IETF standards and documented in [[?RFC3552]]. This section elaborates upon a number of the considerations in [[?RFC3552]], as well as other considerations that are unique to DID architecture.\n\nChoosing DID Resolvers\n\nThe DID Specification Registries [[?DID-SPEC-REGISTRIES]] contains an informative list of DID method names and their corresponding DID method specifications. Implementers need to bear in mind that there is no central authority to mandate which DID method specification is to be used with any specific DID method name. If there is doubt on whether or not a specific DID resolver implements a DID method correctly, the DID Specification Registries can be used to look up the registered specification and make an informed decision regarding which DID resolver implementation to use.\n\nProving Control and Binding\n\nBinding an entity in the digital world or the physical world to a DID, to a DID document, or to cryptographic material requires, the use of security protocols contemplated by this specification. The following sections describe some possible scenarios and how an entity therein might prove control over a DID or a DID document for the purposes of authentication or authorization.\n\nProving Control of a DID and/or DID Document\n\nProving control over a DID and/or a DID Document is useful when updating either in a verifiable data registry or authenticating with remote systems. Cryptographic digital signatures and verifiable timestamps enable certain security protocols related to DID documents to be cryptographically verifiable. For these purposes, this specification defines useful verification relationships in and . The secret cryptographic material associated with the verification methods can be used to generate a cryptographic digital signature as a part of an authentication or authorization security protocol.\n\nSome DID methods allow digital signatures and other proofs to be included in the DID document or a . However, such proofs by themselves do not necessarily prove control over a DID, or guarantee that the DID document is the correct one for the DID. In order to obtain the correct DID document and verify control over a DID, it is necessary to perform the DID resolution process as defined by the DID method.\n\nBinding to Physical Identity\n\nA DID and DID document do not inherently carry any personal data and it is strongly advised that non-public entities do not publish personal data in DID documents.\n\nIt can be useful to express a binding of a DID to a person's or organization's physical identity in a way that is provably asserted by a trusted authority, such as a government. This specification provides the verification relationship for these purposes. This feature can enable interactions that are private and can be considered legally enforceable under one or more jurisdictions; establishing such bindings has to be carefully balanced against privacy considerations (see ).\n\nThe process of binding a DID to something in the physical world, such as a person or an organization — for example, by using verifiable credentials with the same subject as that DID — is contemplated by this specification and further defined in the Verifiable Credentials Data Model [[VC-DATA-MODEL]].\n\nAuthentication Service Endpoints\n\nIf a DID document publishes a service intended for authentication or authorization of the DID subject (see Section ), it is the responsibility of the service endpoint provider, subject, or requesting party to comply with the requirements of the authentication protocols supported at that service endpoint.\n\nNon-Repudiation\n\nNon-repudiation of DIDs and DID document updates is supported if:\n\nThe verifiable data registry supports verifiable timestamps. See for further information on useful timestamps that can be used during the DID resolution process.\n\nThe subject is monitoring for unauthorized updates as elaborated upon in .\n\nThe subject has had adequate opportunity to revert malicious updates according to the authorization mechanism for the DID method.\n\nNotification of DID Document Changes\n\nOne mitigation against unauthorized changes to a DID document is monitoring and actively notifying the DID subject when there are changes. This is analogous to helping prevent account takeover on conventional username/password accounts by sending password reset notifications to the email addresses on file.\n\nIn the case of a DID, there is no intermediary registrar or account provider to generate such notifications. However, if the verifiable data registry on which the DID is registered directly supports change notifications, a subscription service can be offered to DID controllers. Notifications could be sent directly to the relevant service endpoints listed in an existing DID.\n\nIf a DID controller chooses to rely on a third-party monitoring service (other than the verifiable data registry itself), this introduces another vector of attack.\n\nKey and Signature Expiration\n\nIn a decentralized identifier architecture, there might not be centralized authorities to enforce cryptographic material or cryptographic digital signature expiration policies. Therefore, it is with supporting software such as DID resolvers and verification libraries that requesting parties validate that cryptographic material were not expired at the time they were used. Requesting parties might employ their own expiration policies in addition to inputs into their verification processes. For example, some requesting parties might accept authentications from five minutes in the past, while others with access to high precision time sources might require authentications to be time stamped within the last 500 milliseconds.\n\nThere are some requesting parties that have legitimate needs to extend the use of already-expired cryptographic material, such as verifying legacy cryptographic digital signatures. In these scenarios, a requesting party might instruct their verification software to ignore cryptographic key material expiration or determine if the cryptographic key material was expired at the time it was used.\n\nVerification Method Rotation\n\nRotation is a management process that enables the secret cryptographic material associated with an existing verification method to be deactivated or destroyed once a new verification method has been added to the DID document. Going forward, any new proofs that a controller would have generated using the old secret cryptographic material can now instead be generated using the new cryptographic material and can be verified using the new verification method.\n\nRotation is a useful mechanism for protecting against verification method compromise, since frequent rotation of a verification method by the controller reduces the value of a single compromised verification method to an attacker. Performing revocation immediately after rotation is useful for verification methods that a controller designates for short-lived verifications, such as those involved in encrypting messages and authentication.\n\nThe following considerations might be of use when contemplating the use of verification method rotation:\n\nVerification method rotation is a proactive security measure.\n\nIt is generally considered a best practice to perform verification method rotation on a regular basis.\n\nHigher security environments tend to employ more frequent verification method rotation.\n\nVerification method rotation manifests only as changes to the current or latest version of a DID document.\n\nWhen a verification method has been active for a long time, or used for many operations, a controller might wish to perform a rotation.\n\nFrequent rotation of a verification method might be frustrating for parties that are forced to continuously renew or refresh associated credentials.\n\nProofs or signatures that rely on verification methods that are not present in the latest version of a DID document are not impacted by rotation. In these cases, verification software might require additional information, such as when a particular verification method was expected to be valid as well as access to a verifiable data registry containing a historical record, to determine the validity of the proof or signature. This option might not be available in all DID methods.\n\nThe section on DID method operations specifies the DID operations to be supported by a DID method specification, including update which is expected to be used to perform a verification method rotation.\n\nA controller performs a rotation when they add a new verification method that is meant to replace an existing verification method after some time.\n\nNot all DID methods support verification method rotation.\n\nVerification Method Revocation\n\nRevocation is a management process that enables the secret cryptographic material associated with an existing verification method to be deactivated such that it ceases to be a valid form of creating new proofs of digital signatures.\n\nRevocation is a useful mechanism for reacting to a verification method compromise. Performing revocation immediately after rotation is useful for verification methods that a controller designates for short-lived verifications, such as those involved in encrypting messages and authentication.\n\nCompromise of the secrets associated with a verification method allows the attacker to use them according to the verification relationship expressed by controller in the DID document, for example, for authentication. The attacker's use of the secrets might be indistinguishable from the legitimate controller's use starting from the time the verification method was registered, to the time it was revoked.\n\nThe following considerations might be of use when contemplating the use of verification method revocation:\n\nVerification method revocation is a reactive security measure.\n\nIt is considered a best practice to support key revocation.\n\nA controller is expected to immediately revoke any verification method that is known to be compromised.\n\nVerification method revocation can only be embodied in changes to the latest version of a DID Document; it cannot retroactively adjust previous versions.\n\nAs described in , absence of a verification method is the only form of revocation that applies to all DID Methods that support revocation.\n\nIf a verification method is no longer exclusively accessible to the controller or parties trusted to act on behalf of the controller, it is expected to be revoked immediately to reduce the risk of compromises such as masquerading, theft, and fraud.\n\nRevocation is expected to be understood as a controller expressing that proofs or signatures associated with a revoked verification method created after its revocation should be treated as invalid. It could also imply a concern that existing proofs or signatures might have been created by an attacker, but this is not necessarily the case. Verifiers, however, might still choose to accept or reject any such proofs or signatures at their own discretion.\n\nThe section on DID method operations specifies the DID operations to be supported by a DID method specification, including update and deactivate, which might be used to remove a verification method from a DID document.\n\nNot all DID methods support verification method revocation.\n\nEven if a verification method is present in a DID document, additional information, such as a public key revocation certificate, or an external allow or deny list, could be used to determine whether a verification method has been revoked.\n\nThe day-to-day operation of any software relying on a compromised verification method, such as an individual's operating system, antivirus, or endpoint protection software, could be impacted when the verification method is publicly revoked.\n\nRevocation Semantics\n\nAlthough verifiers might choose not to accept proofs or signatures from a revoked verification method, knowing whether a verification was made with a revoked verification method is trickier than it might seem. Some DID methods provide the ability to look back at the state of a DID at a point in time, or at a particular version of the DID document. When such a feature is combined with a reliable way to determine the time or DID version that existed when a cryptographically verifiable statement was made, then revocation does not undo that statement. This can be the basis for using DIDs to make binding commitments; for example, to sign a mortgage.\n\nIf these conditions are met, revocation is not retroactive; it only nullifies future use of the method.\n\nHowever, in order for such semantics to be safe, the second condition — an ability to know what the state of the DID document was at the time the assertion was made — is expected to apply. Without that guarantee, someone could discover a revoked key and use it to make cryptographically verifiable statements with a simulated date in the past.\n\nSome DID methods only allow the retrieval of the current state of a DID. When this is true, or when the state of a DID at the time of a cryptographically verifiable statement cannot be reliably determined, then the only safe course is to disallow any consideration of DID state with respect to time, except the present moment. DID ecosystems that take this approach essentially provide cryptographically verifiable statements as ephemeral tokens that can be invalidated at any time by the DID controller.\n\nRevocation in Trustless Systems\n\nTrustless systems are those where all trust is derived from cryptographically provable assertions, and more specifically, where no metadata outside of the cryptographic system is factored into the determination of trust in the system. To verify a signature of proof for a verification method which has been revoked in a trustless system, a DID method needs to support either or both of the `versionId` or `versionTime`, as well as both the `updated` and `nextUpdate`, DID document metadata properties. A verifier can validate a signature or proof of a revoked key if and only if all of the following are true:\n\nThe proof or signature includes the `versionId` or `versionTime` of the DID document that was used at the point the signature or proof was created.\n\nThe verifier can determine the point in time at which the signature or proof was made; for example, it was anchored on a blockchain.\n\nFor the resolved DID document metadata, the `updated` timestamp is before, and the `nextUpdate` timestamp is after, the point in time at which the signature or proof was made.\n\nIn systems that are willing to admit metadata other than those constituting cryptographic input, similar trust may be achieved -- but always on the same basis where a careful judgment is made about whether a DID document's content at the moment of a signing event contained the expected content.\n\nDID Recovery\n\nRecovery is a reactive security measure whereby a controller that has lost the ability to perform DID operations, such as through the loss of a device, is able to regain the ability to perform DID operations.\n\nThe following considerations might be of use when contemplating the use of DID recovery:\n\nPerforming recovery proactively on an infrequent but regular basis, can help to ensure that control has not been lost.\n\nIt is considered a best practice to never reuse cryptographic material associated with recovery for any other purposes.\n\nRecovery is commonly performed in conjunction with verification method rotation and verification method revocation.\n\nRecovery is advised when a controller or services trusted to act on their behalf no longer have the exclusive ability to perform DID operations as described in .\n\nDID method specifications might choose to enable support for a quorum of trusted parties to facilitate recovery. Some of the facilities to do so are suggested in .\n\nNot all DID method specifications will recognize control from DIDs registered using other DID methods and they might restrict third-party control to DIDs that use the same method.\n\nAccess control and recovery in a DID method specification can also include a time lock feature to protect against key compromise by maintaining a second track of control for recovery.\n\nThere are currently no common recovery mechanisms that apply to all DID methods.\n\nThe Role of Human-Friendly Identifiers\n\nDIDs achieve global uniqueness without the need for a central registration authority. This comes at the cost of human memorability. Algorithms capable of generating globally unambiguous identifiers produce random strings of characters that have no human meaning. This trade-off is often referred to as Zooko's Triangle.\n\nThere are use cases where it is desirable to discover a DID when starting from a human-friendly identifier. For example, a natural language name, a domain name, or a conventional address for a DID controller, such as a mobile telephone number, email address, social media username, or blog URL. However, the problem of mapping human-friendly identifiers to DIDs, and doing so in a way that can be verified and trusted, is outside the scope of this specification.\n\nSolutions to this problem are defined in separate specifications, such as [[?DNS-DID]], that reference this specification. It is strongly recommended that such specifications carefully consider the:\n\nNumerous security attacks based on deceiving users about the true human-friendly identifier for a target entity.\n\nPrivacy consequences of using human-friendly identifiers that are inherently correlatable, especially if they are globally unique.\n\nDIDs as Enhanced URNs\n\nIf desired by a DID controller, a DID or a DID URL is capable of acting as persistent, location-independent resource identifier. These sorts of identifiers are classified as Uniform Resource Names (URNs) and are defined in [[RFC8141]]. DIDs are an enhanced form of URN that provide a cryptographically secure, location-independent identifier for a digital resource, while also providing metadata that enables retrieval. Due to the indirection between the DID document and the DID itself, the DID controller can adjust the actual location of the resource — or even provide the resource directly — without adjusting the DID. DIDs of this type can definitively verify that the resource retrieved is, in fact, the resource identified.\n\nA DID controller who intends to use a DID for this purpose is advised to follow the security considerations in [[RFC8141]]. In particular:\n\nThe DID controller is expected to choose a DID method that supports the controller's requirements for persistence. The Decentralized Characteristics Rubric [[?DID-RUBRIC]] is one tool available to help implementers decide upon the most suitable DID method.\n\nThe DID controller is expected to publish its operational policies so requesting parties can determine the degree to which they can rely on the persistence of a DID controlled by that DID controller. In the absence of such policies, requesting parties are not expected to make any assumption about whether a DID is a persistent identifier for the same DID subject.\n\nImmutability\n\nMany cybersecurity abuses hinge on exploiting gaps between reality and the assumptions of rational, good-faith actors. Immutability of DID documents can provide some security benefits. Individual DID methods ought to consider constraints that would eliminate behaviors or semantics they do not need. The more locked down a DID method is, while providing the same set of features, the less it can be manipulated by malicious actors.\n\nAs an example, consider that a single edit to a DID document can change anything except the root id property of the document. But is it actually desirable for a service to change its type after it is defined? Or for a key to change its value? Or would it be better to require a new id when certain fundamental properties of an object change? Malicious takeovers of a website often aim for an outcome where the site keeps its host name identifier, but is subtly changed underneath. If certain properties of the site, such as the ASN associated with its IP address, were required by the specification to be immutable, anomaly detection would be easier, and attacks would be much harder and more expensive to carry out.\n\nFor DID methods tied to a global source of truth, a direct, just-in-time lookup of the latest version of a DID document is always possible. However, it seems likely that layers of cache might eventually sit between a DID resolver and that source of truth. If they do, believing the attributes of an object in the DID document to have a given state when they are actually subtly different might invite exploits. This is particularly true if some lookups are of a full DID document, and others are of partial data where the larger context is assumed.\n\nEncrypted Data in DID Documents\n\nEncryption algorithms have been known to fail due to advances in cryptography and computing power. Implementers are advised to assume that any encrypted data placed in a DID document might eventually be made available in clear text to the same audience to which the encrypted data is available. This is particularly pertinent if the DID document is public.\n\nEncrypting all or parts of a DID document is not an appropriate means to protect data in the long term. Similarly, placing encrypted data in a DID document is not an appropriate means to protect personal data.\n\nGiven the caveats above, if encrypted data is included in a DID document, implementers are advised to not associate any correlatable information that could be used to infer a relationship between the encrypted data and an associated party. Examples of correlatable information include public keys of a receiving party, identifiers to digital assets known to be under the control of a receiving party, or human readable descriptions of a receiving party.\n\nEquivalence Properties\n\nGiven the equivalentId and canonicalId properties are generated by DID methods themselves, the same security and accuracy guarantees that apply to the resolved DID present in the id field of a DID document also apply to these properties. The alsoKnownAs property is not guaranteed to be an accurate statement of equivalence, and should not be relied upon without performing validation steps beyond the resolution of the DID document.\n\nThe equivalentId and canonicalId properties express equivalence assertions to variants of a single DID produced by the same DID method and can be trusted to the extent the requesting party trusts the DID method and a conforming producer and resolver.\n\nThe alsoKnownAs property permits an equivalence assertion to URIs that are not governed by the same DID method and cannot be trusted without performing verification steps outside of the governing DID method. See additional guidance in .\n\nAs with any other security-related properties in the DID document, parties relying on any equivalence statement in a DID document should guard against the values of these properties being substituted by an attacker after the proper verification has been performed. Any write access to a DID document stored in memory or disk after verification has been performed is an attack vector that might circumvent verification unless the DID document is re-verified.\n\nContent Integrity Protection\n\nDID documents which include links to external machine-readable content such as images, web pages, or schemas are vulnerable to tampering. It is strongly advised that external links are integrity protected using solutions such as a hashlink [[?HASHLINK]]. External links are to be avoided if they cannot be integrity protected and the DID document's integrity is dependent on the external link.\n\nOne example of an external link where the integrity of the DID document itself could be affected is the JSON-LD Context [[JSON-LD11]]. To protect against compromise, DID document consumers are advised to cache local static copies of JSON-LD contexts and/or verify the integrity of external contexts against a cryptographic hash that is known to be associated with a safe version of the external JSON-LD Context.\n\nPersistence\n\nDIDs are designed to be persistent such that a controller need not rely upon a single trusted third party or administrator to maintain their identifiers. In an ideal case, no administrator can take control away from the controller, nor can an administrator prevent their identifiers' use for any particular purpose such as authentication, authorization, and attestation. No third party can act on behalf of a controller to remove or render inoperable an entity's identifier without the controller's consent.\n\nHowever, it is important to note that in all DID methods that enable cryptographic proof-of-control, the means of proving control can always be transferred to another party by transferring the secret cryptographic material. Therefore, it is vital that systems relying on the persistence of an identifier over time regularly check to ensure that the identifier is, in fact, still under the control of the intended party.\n\nUnfortunately, it is impossible to determine from the cryptography alone whether or not the secret cryptographic material associated with a given verification method has been compromised. It might well be that the expected controller still has access to the secret cryptographic material — and as such can execute a proof-of-control as part of a verification process — while at the same time, a bad actor also has access to those same keys, or to a copy thereof.\n\nAs such, cryptographic proof-of-control is expected to only be used as one factor in evaluating the level of identity assurance required for high-stakes scenarios. DID-based authentication provides much greater assurance than a username and password, thanks to the ability to determine control over a cryptographic secret without transmitting that secret between systems. However, it is not infallible. Scenarios that involve sensitive, high value, or life-critical operations are expected to use additional factors as appropriate.\n\nIn addition to potential ambiguity from use by different controllers, it is impossible to guarantee, in general, that a given DID is being used in reference to the same subject at any given point in time. It is technically possible for the controller to reuse a DID for different subjects and, more subtly, for the precise definition of the subject to either change over time or be misunderstood.\n\nFor example, consider a DID used for a sole proprietorship, receiving various credentials used for financial transactions. To the controller, that identifier referred to the business. As the business grows, it eventually gets incorporated as a Limited Liability Company. The controller continues using that same DID, because to them the DID refers to the business. However, to the state, the tax authority, and the local municipality, the DID no longer refers to the same entity. Whether or not the subtle shift in meaning matters to a credit provider or supplier is necessarily up to them to decide. In many cases, as long as the bills get paid and collections can be enforced, the shift is immaterial.\n\nDue to these potential ambiguities, DIDs are to be considered valid contextually rather than absolutely. Their persistence does not imply that they refer to the exact same subject, nor that they are under the control of the same controller. Instead, one needs to understand the context in which the DID was created, how it is used, and consider the likely shifts in their meaning, and adopt procedures and policies to address both potential and inevitable semantic drift.\n\nLevel of Assurance\n\nAdditional information about the security context of authentication events is often required for compliance reasons, especially in regulated areas such as the financial and public sectors. This information is often referred to as a Level of Assurance (LOA). Examples include the protection of secret cryptographic material, the identity proofing process, and the form-factor of the authenticator.\n\nPayment services (PSD 2) and eIDAS introduce such requirements to the security context. Level of assurance frameworks are classified and defined by regulations and standards such as eIDAS, NIST 800-63-3 and ISO/IEC 29115:2013, including their requirements for the security context, and making recommendations on how to achieve them. This might include strong user authentication where FIDO2/WebAuthn can fulfill the requirement.\n\nSome regulated scenarios require the implementation of a specific level of assurance. Since verification relationships such as assertionMethod and authentication might be used in some of these situations, information about the applied security context might need to be expressed and provided to a verifier. Whether and how to encode this information in the DID document data model is out of scope for this specification. Interested readers might note that 1) the information could be transmitted using Verifiable Credentials [[?VC-DATA-MODEL]], and 2) the DID document data model can be extended to incorporate this information as described in , and where is applicable for such extensions.\n\nEvaluating Competing Considerations\n\nThis specification does not require or suggest the use of any specific type of verifiable data registry. Different use cases might result in different requirements. Different requirements might suggest different considerations with different trade-offs. For example, trade-offs between computation (energy usage), trust (deference to authority), coordination (network bandwidth), or memory (physical storage) might or might not be appropriate for any given use case. Other use cases might not make the same trade-offs. Those that need to consider different criteria for their use case are directed to the DID Method Rubric, which provides evaluation criteria to help decision makers determine whether or not a particular DID Method is appropriate for their use cases.\n\nPrivacy Considerations\n\nSince DIDs and DID documents are designed to be administered directly by the DID controller(s), it is critically important to apply the principles of Privacy by Design [[PRIVACY-BY-DESIGN]] to all aspects of the decentralized identifier architecture. All seven of these principles have been applied throughout the development of this specification. The design used in this specification does not assume that there is a registrar, hosting company, nor other intermediate service provider to recommend or apply additional privacy safeguards. Privacy in this specification is preventive, not remedial, and is an embedded default. The following sections cover privacy considerations that implementers might find useful when building systems that utilize decentralized identifiers.\n\nKeep Personal Data Private\n\nIf a DID method specification is written for a public-facing verifiable data registry where corresponding DIDs and DID documents might be made publicly available, it is critical that those DID documents contain no personal data. Personal data can instead be transmitted through other means such as 1) Verifiable Credentials [[?VC-DATA-MODEL]], or 2) service endpoints under control of the DID subject or DID controller.\n\nDue diligence is expected to be taken around the use of URLs in service endpoints to prevent leakage of personal data or correlation within a URL of a service endpoint. For example, a URL that contains a username is dangerous to include in a DID Document because the username is likely to be human-meaningful in a way that can reveal information that the DID subject did not consent to sharing. With the privacy architecture suggested by this specification, personal data can be exchanged on a private, peer-to-peer basis using communication channels identified and secured by verification methods in DID documents. This also enables DID subjects and requesting parties to implement the GDPR right to be forgotten, because no personal data is written to an immutable distributed ledger.\n\nDID Correlation Risks\n\nLike any type of globally unambiguous identifier, DIDs might be used for correlation. DID controllers can mitigate this privacy risk by using pairwise DIDs that are unique to each relationship; in effect, each DID acts as a pseudonym. A pairwise DID need only be shared with more than one party when correlation is explicitly desired. If pairwise DIDs are the default, then the only need to publish a DID openly, or to share it with multiple parties, is when the DID controller(s) and/or DID subject explicitly desires public identification and correlation.\n\nDID Document Correlation Risks\n\nThe anti-correlation protections of pairwise DIDs are easily defeated if the data in the corresponding DID documents can be correlated. For example, using identical verification methods or bespoke service endpoints in multiple DID documents can provide as much correlation information as using the same DID. Therefore, the DID document for a pairwise DID also needs to use pairwise unique information, such as ensuring that verification methods are unique to the pairwise relationship.\n\nIt might seem natural to also use pairwise unique service endpoints in the DID document for a pairwise DID. However, unique endpoints allow all traffic between two DIDs to be isolated perfectly into unique buckets, where timing correlation and similar analysis is easy. Therefore, a better strategy for endpoint privacy might be to share an endpoint among a large number of DIDs controlled by many different subjects (see ).\n\nDID Subject Classification\n\nIt is dangerous to add properties to the DID document that can be used to indicate, explicitly or through inference, what type or nature of thing the DID subject is, particularly if the DID subject is a person.\n\nNot only do such properties potentially result in personal data (see ) or correlatable data (see and ) being present in the DID document, but they can be used for grouping particular DIDs in such a way that they are included in or excluded from certain operations or functionalities.\n\nIncluding type information in a DID Document can result in personal privacy harms even for DID Subjects that are non-person entities, such as IoT devices. The aggregation of such information around a DID Controller could serve as a form of digital fingerprint and this is best avoided.\n\nTo minimize these risks, all properties in a DID document ought to be for expressing cryptographic material, endpoints, or verification methods related to using the DID.\n\nHerd Privacy\n\nWhen a DID subject is indistinguishable from others in the herd, privacy is available. When the act of engaging privately with another party is by itself a recognizable flag, privacy is greatly diminished.\n\nDIDs and DID methods need to work to improve herd privacy, particularly for those who legitimately need it most. Choose technologies and human interfaces that default to preserving anonymity and pseudonymity. To reduce digital fingerprints, share common settings across requesting party implementations, keep negotiated options to a minimum on wire protocols, use encrypted transport layers, and pad messages to standard lengths.\n\nService Privacy\n\nThe ability for a controller to optionally express at least one service endpoint in the DID document increases their control and agency. Each additional endpoint in the DID document adds privacy risk either due to correlation, such as across endpoint descriptions, or because the services are not protected by an authorization mechanism, or both.\n\nDID documents are often public and, since they are standardized, will be stored and indexed efficiently by their very standards-based nature. This risk is worse if DID documents are published to immutable verifiable data registries. Access to a history of the DID documents referenced by a DID represents a form of traffic analysis made more efficient through the use of standards.\n\nThe degree of additional privacy risk caused by using multiple service endpoints in one DID document can be difficult to estimate. Privacy harms are typically unintended consequences. DIDs can refer to documents, services, schemas, and other things that might be associated with individual people, households, clubs, and employers — and correlation of their service endpoints could become a powerful surveillance and inference tool. An example of this potential harm can be seen when multiple common country-level top level domains such as https://example.co.uk might be used to infer the approximate location of the DID subject with a greater deg"
    }
}