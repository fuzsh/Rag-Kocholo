{
    "id": "dbpedia_4957_3",
    "rank": 20,
    "data": {
        "url": "https://www.tech-invite.com/y40/tinv-ietf-rfc-4086-2.html",
        "read_more_link": "",
        "language": "en",
        "title": "RFC 4086: 2 of 2, p. 21 to 48",
        "top_image": "",
        "meta_img": "",
        "images": [
            "https://www.tech-invite.com/img/ti-menu-idx25.gif",
            "https://www.tech-invite.com/img/ti-menu-prev25.gif",
            "https://www.tech-invite.com/img/ti-menu-next25.gif",
            "https://www.tech-invite.com/img/ti-blue-first25.gif",
            "https://www.tech-invite.com/img/ti-blue-prev25.gif",
            "https://www.tech-invite.com/img/ti-blue-none25.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-top22.gif",
            "https://www.tech-invite.com/img/ti-ctrl-list22.gif"
        ],
        "movies": [],
        "keywords": [],
        "meta_keywords": [
            ""
        ],
        "tags": null,
        "authors": [],
        "publish_date": null,
        "summary": "",
        "meta_description": "",
        "meta_lang": "",
        "meta_favicon": "../favicon.ico",
        "meta_site_name": "",
        "canonical_link": null,
        "text": "6. Pseudo-random Number Generators\n\nWhen a seed has sufficient entropy, from input as described in Section 3 and possibly de-skewed and mixed as described in Sections 4 and 5, one can algorithmically extend that seed to produce a large number of cryptographically-strong random quantities. Such algorithms are platform independent and can operate in the same fashion on any computer. For the algorithms to be secure, their input and internal workings must be protected from adversarial observation. The design of such pseudo-random number generation algorithms, like the design of symmetric encryption algorithms, is not a task for amateurs. Section 6.1 below lists a number of bad ideas that failed algorithms have used. To learn what works, skip Section 6.1 and just read the remainder of this section and Section 7, which describes and references some standard pseudo random number generation algorithms. See Section 7 and Part 3 of [X9.82].\n\n6.1. Some Bad Ideas\n\nThe subsections below describe a number of ideas that might seem reasonable but that lead to insecure pseudo-random number generation.\n\n6.1.1. The Fallacy of Complex Manipulation\n\nOne approach that may give a misleading appearance of unpredictability is to take a very complex algorithm (or an excellent traditional pseudo-random number generator with good statistical properties) and to calculate a cryptographic key by starting with limited data such as the computer system clock value as the seed. Adversaries who knew roughly when the generator was started would have a relatively small number of seed values to test, as they would know likely values of the system clock. Large numbers of pseudo-\n\nrandom bits could be generated, but the search space that an adversary would need to check could be quite small. Thus, very strong or complex manipulation of data will not help if the adversary can learn what the manipulation is and if there is not enough entropy in the starting seed value. They can usually use the limited number of results stemming from a limited number of seed values to defeat security. Another serious strategic error is to assume that a very complex pseudo-random number generation algorithm will produce strong random numbers, when there has been no theory behind or analysis of the algorithm. There is a excellent example of this fallacy near the beginning of Chapter 3 in [KNUTH], where the author describes a complex algorithm. It was intended that the machine language program corresponding to the algorithm would be so complicated that a person trying to read the code without comments wouldn't know what the program was doing. Unfortunately, actual use of this algorithm showed that it almost immediately converged to a single repeated value in one case and a small cycle of values in another case. Not only does complex manipulation not help you if you have a limited range of seeds, but blindly-chosen complex manipulation can destroy the entropy in a good seed!\n\n6.1.2. The Fallacy of Selection from a Large Database\n\nAnother approach that can give a misleading appearance of unpredictability is to randomly select a quantity from a database and to assume that its strength is related to the total number of bits in the database. For example, typical USENET servers process many megabytes of information per day [USENET_1, USENET_2]. Assume that a random quantity was selected by fetching 32 bytes of data from a random starting point in this data. This does not yield 32*8 = 256 bits worth of unguessability. Even if much of the data is human language that contains no more than 2 or 3 bits of information per byte, it doesn't yield 32*2 = 64 bits of unguessability. For an adversary with access to the same Usenet database, the unguessability rests only on the starting point of the selection. That is perhaps a little over a couple of dozen bits of unguessability. The same argument applies to selecting sequences from the data on a publicly available CD/DVD recording or any other large public database. If the adversary has access to the same database, this \"selection from a large volume of data\" step buys little. However, if a selection can be made from data to which the adversary has no access, such as system buffers on an active multi-user system, it may be of help.\n\n6.1.3. Traditional Pseudo-random Sequences\n\nThis section talks about traditional sources of deterministic or \"pseudo-random\" numbers. These typically start with a \"seed\" quantity and use simple numeric or logical operations to produce a sequence of values. Note that none of the techniques discussed in this section is suitable for cryptographic use. They are presented for general information. [KNUTH] has a classic exposition on pseudo-random numbers. Applications he mentions are simulations of natural phenomena, sampling, numerical analysis, testing computer programs, decision making, and games. None of these have the same characteristics as the sorts of security uses we are talking about. Only in the last two could there be an adversary trying to find the random quantity. However, in these cases, the adversary normally has only a single chance to use a guessed value. In guessing passwords or attempting to break an encryption scheme, the adversary normally has many, perhaps unlimited, chances at guessing the correct value. Sometimes the adversary can store the message to be broken and repeatedly attack it. Adversaries are also be assumed to be aided by a computer. For testing the \"randomness\" of numbers, Knuth suggests a variety of measures, including statistical and spectral. These tests check things like autocorrelation between different parts of a \"random\" sequence or distribution of its values. But these tests could be met by a constant stored random sequence, such as the \"random\" sequence printed in the CRC Standard Mathematical Tables [CRC]. Despite meeting all the tests suggested by Knuth, that sequence is unsuitable for cryptographic us, as adversaries must be assumed to have copies of all commonly published \"random\" sequences and to be able to spot the source and predict future values. A typical pseudo-random number generation technique is the linear congruence pseudo-random number generator. This technique uses modular arithmetic, where the value numbered N+1 is calculated from the value numbered N by V = ( V * a + b )(Mod c) N+1 N The above technique has a strong relationship to linear shift register pseudo-random number generators, which are well understood cryptographically [SHIFT*]. In such generators, bits are introduced at one end of a shift register as the Exclusive Or (binary sum without carry) of bits from selected fixed taps into the register. For example, consider the following:\n\n+----+ +----+ +----+ +----+ | B | <-- | B | <-- | B | <-- . . . . . . <-- | B | <-+ | 0 | | 1 | | 2 | | n | | +----+ +----+ +----+ +----+ | | | | | | | V +-----+ | V +----------------> | | V +-----------------------------> | XOR | +---------------------------------------------------> | | +-----+ V = ( ( V * 2 ) + B XOR B ... )(Mod 2^n) N+1 N 0 2 The quality of traditional pseudo-random number generator algorithms is measured by statistical tests on such sequences. Carefully-chosen values a, b, c, and initial V or carefully-chosen placement of the shift register tap in the above simple process can produce excellent statistics. These sequences may be adequate in simulations (Monte Carlo experiments) as long as the sequence is orthogonal to the structure of the space being explored. Even there, subtle patterns may cause problems. However, such sequences are clearly bad for use in security applications. They are fully predictable if the initial state is known. Depending on the form of the pseudo-random number generator, the sequence may be determinable from observation of a short portion of the sequence [SCHNEIER, STERN]. For example, with the generators above, one can determine V(n+1) given knowledge of V(n). In fact, it has been shown that with these techniques, even if only one bit of the pseudo-random values are released, the seed can be determined from short sequences. Not only have linear congruent generators been broken, but techniques are now known for breaking all polynomial congruent generators [KRAWCZYK].\n\n6.2. Cryptographically Strong Sequences\n\nIn cases where a series of random quantities must be generated, an adversary may learn some values in the sequence. In general, adversaries should not be able to predict other values from the ones that they know. The correct technique is to start with a strong random seed, to take cryptographically strong steps from that seed [FERGUSON, SCHNEIER], and not to reveal the complete state of the generator in the sequence elements. If each value in the sequence can be calculated in a fixed\n\nway from the previous value, then when any value is compromised, all future values can be determined. This would be the case, for example, if each value were a constant function of the previously used values, even if the function were a very strong, non-invertible message digest function. (Note that if a technique for generating a sequence of key values is fast enough, it can trivially be used as the basis for a confidentiality system. If two parties use the same sequence generation technique and start with the same seed material, they will generate identical sequences. These could, for example, be XOR'ed at one end with data being sent to encrypt it, and XOR'ed with this data as received to decrypt it, due to the reversible properties of the XOR operation. This is commonly referred to as a simple stream cipher.)\n\n6.2.1. OFB and CTR Sequences\n\nOne way to produce a strong sequence is to take a seed value and hash the quantities produced by concatenating the seed with successive integers, or the like, and then to mask the values obtained so as to limit the amount of generator state available to the adversary. It may also be possible to use an \"encryption\" algorithm with a random key and seed value to encrypt successive integers, as in counter (CTR) mode encryption. Alternatively, one can feedback all of the output value from encryption into the value to be encrypted for the next iteration. This is a particular example of output feedback mode (OFB) [MODES]. An example is shown below in which shifting and masking are used to combine part of the output feedback with part of the old input. This type of partial feedback should be avoided for reasons described below.\n\n+---------------+ | V | | | n |--+ +--+------------+ | | | +---------+ shift| +---> | | +-----+ +--+ | Encrypt | <--- | Key | | +-------- | | +-----+ | | +---------+ V V +------------+--+ | V | | | n+1 | +---------------+ Note that if a shift of one is used, this is the same as the shift register technique described in Section 6.1.3, but with the all- important difference that the feedback is determined by a complex non-linear function of all bits rather than by a simple linear or polynomial combination of output from a few bit position taps. Donald W. Davies showed that this sort of shifted partial output feedback significantly weakens an algorithm, compared to feeding all the output bits back as input. In particular, for DES, repeatedly encrypting a full 64-bit quantity will give an expected repeat in about 2^63 iterations. Feeding back anything less than 64 (and more than 0) bits will give an expected repeat in between 2^31 and 2^32 iterations! To predict values of a sequence from others when the sequence was generated by these techniques is equivalent to breaking the cryptosystem or to inverting the \"non-invertible\" hashing with only partial information available. The less information revealed in each iteration, the harder it will be for an adversary to predict the sequence. Thus it is best to use only one bit from each value. It has been shown that in some cases this makes it impossible to break a system even when the cryptographic system is invertible and could be broken if all of each generated value were revealed.\n\n6.2.2. The Blum Blum Shub Sequence Generator\n\nCurrently the generator which has the strongest public proof of strength is called the Blum Blum Shub generator, named after its inventors [BBS]. It is also very simple and is based on quadratic residues. Its only disadvantage is that it is computationally intensive compared to the traditional techniques given in Section 6.1.3. This is not a major drawback if it is used for moderately- infrequent purposes, such as generating session keys.\n\nSimply choose two large prime numbers (say, p and q) that each gives a remainder of 3 when divided by 4. Let n = p * q. Then choose a random number, x, that is relatively prime to n. The initial seed for the generator and the method for calculating subsequent values are then: 2 s = ( x )(Mod n) 0 2 s = ( s )(Mod n) i+1 i Be careful to use only a few bits from the bottom of each s. It is always safe to use only the lowest-order bit. If one uses no more than the: log ( log ( s ) ) 2 2 i low-order bits, then predicting any additional bits from a sequence generated in this manner is provably as hard as factoring n. As long as the initial x is secret, n can be made public if desired. An interesting characteristic of this generator is that any of the s values can be directly calculated. In particular, ( (2^i) (Mod ((p-1)*(q-1)) ) ) s = ( s )(Mod n) i 0 This means that in applications where many keys are generated in this fashion, it is not necessary to save them all. Each key can be effectively indexed and recovered from that small index and the initial s and n.\n\n6.3. Entropy Pool Techniques\n\nMany modern pseudo-random number sources, such as those described in Sections 7.1.2 and 7.1.3 utilize the technique of maintaining a \"pool\" of bits and providing operations for strongly mixing input with some randomness into the pool and extracting pseudo-random bits from the pool. This is illustrated in the figure below.\n\n+--------+ +------+ +---------+ --->| Mix In |--->| POOL |--->| Extract |---> | Bits | | | | Bits | +--------+ +------+ +---------+ ^ V | | +-----------+ Bits to be fed into the pool can come from any of the various hardware, environmental, or user input sources discussed above. It is also common to save the state of the pool on system shutdown and to restore it on re-starting, when stable storage is available. Care must be taken that enough entropy has been added to the pool to support particular output uses desired. See [RSA_BULL1] for similar suggestions.\n\n7. Randomness Generation Examples and Standards\n\nSeveral public standards and widely deployed examples are now in place for the generation of keys or other cryptographically random quantities. Some, in section 7.1, include an entropy source. Others, described in section 7.2, provide the pseudo-random number strong-sequence generator but assume the input of a random seed or input from a source of entropy.\n\n7.1. Complete Randomness Generators\n\nThree standards are described below. The two older standards use DES, with its 64-bit block and key size limit, but any equally strong or stronger mixing function could be substituted [DES]. The third is a more modern and stronger standard based on SHA-1 [SHA*]. Lastly, the widely deployed modern UNIX and Windows random number generators are described.\n\n7.1.1. US DoD Recommendations for Password Generation\n\nThe United States Department of Defense has specific recommendations for password generation [DoD]. It suggests using the US Data Encryption Standard [DES] in Output Feedback Mode [MODES] as follows:\n\nUse an initialization vector determined from the system clock, system ID, user ID, and date and time; use a key determined from system interrupt registers, system status registers, and system counters; and, as plain text, use an external randomly generated 64-bit quantity such as the ASCII bytes for 8 characters typed in by a system administrator. The password can then be calculated from the 64 bit \"cipher text\" generated by DES in 64-bit Output Feedback Mode. As many bits as are needed can be taken from these 64 bits and expanded into a pronounceable word, phrase, or other format if a human being needs to remember the password.\n\n7.1.2. The /dev/random Device\n\nSeveral versions of the UNIX operating system provide a kernel- resident random number generator. Some of these generators use events captured by the Kernel during normal system operation. For example, on some versions of Linux, the generator consists of a random pool of 512 bytes represented as 128 words of 4 bytes each. When an event occurs, such as a disk drive interrupt, the time of the event is XOR'ed into the pool, and the pool is stirred via a primitive polynomial of degree 128. The pool itself is treated as a ring buffer, with new data being XOR'ed (after stirring with the polynomial) across the entire pool. Each call that adds entropy to the pool estimates the amount of likely true entropy the input contains. The pool itself contains a accumulator that estimates the total over all entropy of the pool. Input events come from several sources, as listed below. Unfortunately, for server machines without human operators, the first and third are not available, and entropy may be added slowly in that case. 1. Keyboard interrupts. The time of the interrupt and the scan code are added to the pool. This in effect adds entropy from the human operator by measuring inter-keystroke arrival times. 2. Disk completion and other interrupts. A system being used by a person will likely have a hard-to-predict pattern of disk\n\naccesses. (But not all disk drivers support capturing this timing information with sufficient accuracy to be useful.) 3. Mouse motion. The timing and mouse position are added in. When random bytes are required, the pool is hashed with SHA-1 [SHA*] to yield the returned bytes of randomness. If more bytes are required than the output of SHA-1 (20 bytes), then the hashed output is stirred back into the pool and a new hash is performed to obtain the next 20 bytes. As bytes are removed from the pool, the estimate of entropy is correspondingly decremented. To ensure a reasonably random pool upon system startup, the standard startup and shutdown scripts save the pool to a disk file at shutdown and read this file at system startup. There are two user-exported interfaces. /dev/random returns bytes from the pool but blocks when the estimated entropy drops to zero. As entropy is added to the pool from events, more data becomes available via /dev/random. Random data obtained from such a /dev/random device is suitable for key generation for long term keys, if enough random bits are in the pool or are added in a reasonable amount of time. /dev/urandom works like /dev/random; however, it provides data even when the entropy estimate for the random pool drops to zero. This may be adequate for session keys or for other key generation tasks for which blocking to await more random bits is not acceptable. The risk of continuing to take data even when the pool's entropy estimate is small in that past output may be computable from current output, provided that an attacker can reverse SHA-1. Given that SHA-1 is designed to be non-invertible, this is a reasonable risk. To obtain random numbers under Linux, Solaris, or other UNIX systems equipped with code as described above, all an application has to do is open either /dev/random or /dev/urandom and read the desired number of bytes. (The Linux Random device was written by Theodore Ts'o. It was based loosely on the random number generator in PGP 2.X and PGP 3.0 (aka PGP 5.0).)\n\n7.1.3. Windows CryptGenRandom\n\nMicrosoft's recommendation to users of the widely deployed Windows operating system is generally to use the CryptGenRandom pseudo-random number generation call with the CryptAPI cryptographic service provider. This takes a handle to a cryptographic service provider\n\nlibrary, a pointer to a buffer by which the caller can provide entropy and into which the generated pseudo-randomness is returned, and an indication of how many octets of randomness are desired. The Windows CryptAPI cryptographic service provider stores a seed state variable with every user. When CryptGenRandom is called, this is combined with any randomness provided in the call and with various system and user data such as the process ID, thread ID, system clock, system time, system counter, memory status, free disk clusters, and hashed user environment block. This data is all fed to SHA-1, and the output is used to seed an RC4 key stream. That key stream is used to produce the pseudo-random data requested and to update the user's seed state variable. Users of Windows \".NET\" will probably find it easier to use the RNGCryptoServiceProvider.GetBytes method interface. For further information, see [WSC].\n\n7.2. Generators Assuming a Source of Entropy\n\nThe pseudo-random number generators described in the following three sections all assume that a seed value with sufficient entropy is provided to them. They then generate a strong sequence (see Section 6.2) from that seed.\n\n7.2.1. X9.82 Pseudo-Random Number Generation\n\nThe ANSI X9F1 committee is in the final stages of creating a standard for random number generation covering both true randomness generators and pseudo-random number generators. It includes a number of pseudo-random number generators based on hash functions, one of which will probably be based on HMAC SHA hash constructs [RFC2104]. The draft version of this generator is described below, omitting a number of optional features [X9.82]. In the subsections below, the HMAC hash construct is simply referred to as HMAC but, of course, a particular standard SHA function must be selected in an particular use. Generally speaking, if the strength of the pseudo-random values to be generated is to be N bits, the SHA function chosen must generate N or more bits of output, and a source of at least N bits of input entropy will be required. The same hash function must be used throughout an instantiation of this generator.\n\n7.2.1.1. Notation\n\nIn the following sections, the notation give below is used: hash_length is the output size of the underlying hash function in use. input_entropy is the input bit string that provides entropy to the generator. K is a bit string of size hash_length that is part of the state of the generator and is updated at least once each time random bits are generated. V is a bit string of size hash_length and is part of the state of the generator. It is updated each time hash_length bits of output are generated. \"|\" represents concatenation.\n\n7.2.1.2. Initializing the Generator\n\nSet V to all zero bytes, except the low-order bit of each byte is set to one. Set K to all zero bytes, then set: K = HMAC ( K, V | 0x00 | input_entropy ) V = HMAC ( K, V ) K = HMAC ( K, V | 0x01 | input_entropy ) V = HMAC ( K, V ) Note: All SHA algorithms produce an integral number of bytes, so the lengths of K and V will be integral numbers of bytes.\n\n7.2.1.3. Generating Random Bits\n\nWhen output is called for, simply set: V = HMAC ( K, V ) and use the leading bits from V. If more bits are needed than the length of V, set \"temp\" to a null bit string and then repeatedly perform:\n\nV = HMAC ( K, V ) temp = temp | V stopping as soon as temp is equal to or longer than the number of random bits requested. Use the requested number of leading bits from temp. The definition of the algorithm prohibits requesting more than 2^35 bits. After extracting and saving the pseudo-random output bits as described above, before returning you must also perform two more HMACs as follows: K = HMAC ( K, V | 0x00 ) V = HMAC ( K, V )\n\n7.2.2. X9.17 Key Generation\n\nThe American National Standards Institute has specified the following method for generating a sequence of keys [X9.17]: s is the initial 64 bit seed. 0 g is the sequence of generated 64-bit key quantities n k is a random key reserved for generating this key sequence. t is the time at which a key is generated, to as fine a resolution as is available (up to 64 bits). DES ( K, Q ) is the DES encryption of quantity Q with key K. Then: g = DES ( k, DES ( k, t ) XOR s ) n n s = DES ( k, DES ( k, t ) XOR g ) n+1 n If g sub n is to be used as a DES key, then every eighth bit should be adjusted for parity for that use, but the entire 64 bit unmodified g should be used in calculating the next s.\n\n7.2.3. DSS Pseudo-random Number Generation\n\nAppendix 3 of the NIST Digital Signature Standard [DSS] provides a method of producing a sequence of pseudo-random 160 bit quantities for use as private keys or the like. This has been modified by Change Notice 1 [DSS_CN1] to produce the following algorithm for generating general-purpose pseudo-random numbers: t = 0x 67452301 EFCDAB89 98BADCFE 10325476 C3D2E1F0 XKEY = initial seed 0 For j = 0 to ... XVAL = ( XKEY + optional user input ) (Mod 2^512) j X = G( t, XVAL ) j XKEY = ( 1 + XKEY + X ) (Mod 2^512) j+1 j j The quantities X thus produced are the pseudo-random sequence of 160-bit values. Two functions can be used for \"G\" above. Each produces a 160-bit value and takes two arguments, a 160-bit value and a 512 bit value. The first is based on SHA-1 and works by setting the 5 linking variables, denoted H with subscripts in the SHA-1 specification, to the first argument divided into fifths. Then steps (a) through (e) of section 7 of the NIST SHA-1 specification are run over the second argument as if it were a 512-bit data block. The values of the linking variable after those steps are then concatenated to produce the output of G [SHA*]. As an alternative method, NIST also defined an alternate G function based on multiple applications of the DES encryption function [DSS].\n\n8. Examples of Randomness Required\n\nBelow are two examples showing rough calculations of randomness needed for security. The first is for moderate security passwords, while the second assumes a need for a very high-security cryptographic key.\n\nIn addition, [ORMAN] and [RSA_BULL13] provide information on the public key lengths that should be used for exchanging symmetric keys.\n\n8.1. Password Generation\n\nAssume that user passwords change once a year and that it is desired that the probability that an adversary could guess the password for a particular account be less than one in a thousand. Further assume that sending a password to the system is the only way to try a password. Then the crucial question is how often an adversary can try possibilities. Assume that delays have been introduced into a system so that an adversary can make at most one password try every six seconds. That's 600 per hour, or about 15,000 per day, or about 5,000,000 tries in a year. Assuming any sort of monitoring, it is unlikely that someone could actually try continuously for a year. Even if log files are only checked monthly, 500,000 tries is more plausible before the attack is noticed and steps are taken to change passwords and make it harder to try more passwords. To have a one-in-a-thousand chance of guessing the password in 500,000 tries implies a universe of at least 500,000,000 passwords, or about 2^29. Thus, 29 bits of randomness are needed. This can probably be achieved by using the US DoD-recommended inputs for password generation, as it has 8 inputs that probably average over 5 bits of randomness each (see section 7.1). Using a list of 1,000 words, the password could be expressed as a three-word phrase (1,000,000,000 possibilities). By using case-insensitive letters and digits, six characters would suffice ((26+10)^6 = 2,176,782,336 possibilities). For a higher-security password, the number of bits required goes up. To decrease the probability by 1,000 requires increasing the universe of passwords by the same factor, which adds about 10 bits. Thus, to have only a one in a million chance of a password being guessed under the above scenario would require 39 bits of randomness and a password that was a four-word phrase from a 1,000 word list, or eight letters/digits. To go to a one-in-10^9 chance, 49 bits of randomness are needed, implying a five-word phrase or a ten-letter/digit password. In a real system, of course, there are other factors. For example, the larger and harder to remember passwords are, the more likely users will bed to write them down, resulting in an additional risk of compromise.\n\n8.2. A Very High Security Cryptographic Key\n\nAssume that a very high security key is needed for symmetric encryption/decryption between two parties. Assume also that an adversary can observe communications and knows the algorithm being used. Within the field of random possibilities, the adversary can try key values in hopes of finding the one in use. Assume further that brute force trial of keys is the best the adversary can do.\n\n8.2.1. Effort per Key Trial\n\nHow much effort will it take to try each key? For very high-security applications, it is best to assume a low value of effort. Even if it would clearly take tens of thousands of computer cycles or more to try a single key, there may be some pattern that enables huge blocks of key values to be tested with much less effort per key. Thus, it is probably best to assume no more than a couple of hundred cycles per key. (There is no clear lower bound on this, as computers operate in parallel on a number of bits and a poor encryption algorithm could allow many keys or even groups of keys to be tested in parallel. However, we need to assume some value and can hope that a reasonably strong algorithm has been chosen for our hypothetical high-security task.) If the adversary can command a highly parallel processor or a large network of work stations, 10^11 cycles per second is probably a minimum assumption today. Looking forward a few years, there should be at least an order of magnitude improvement. Thus, it is reasonable to assume that 10^10 keys could be checked per second, or 3.6*10^12 per hour or 6*10^14 per week, or 2.4*10^15 per month. This implies a need for a minimum of 63 bits of randomness in keys, to be sure that they cannot be found in a month. Even then it is possible that, a few years from now, a highly determined and resourceful adversary could break the key in 2 weeks; on average, they need try only half the keys. These questions are considered in detail in \"Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security: A Report by an Ad Hoc Group of Cryptographers and Computer Scientists\" [KeyStudy] that was sponsored by the Business Software Alliance. It concluded that a reasonable key length in 1995 for very high security is in the range of 75 to 90 bits and, since the cost of cryptography does not vary much with the key size, it recommends 90 bits. To update these recommendations, just add 2/3 of a bit per year for Moore's law [MOORE]. This translates to a determination, in the year 2004, a reasonable key length is in the 81- to 96-bit range. In fact, today, it is increasingly common to use keys longer than 96\n\nbits, such as 128-bit (or longer) keys with AES and keys with effective lengths of 112-bits with triple-DES.\n\n8.2.2. Meet-in-the-Middle Attacks\n\nIf chosen or known plain text and the resulting encrypted text are available, a \"meet-in-the-middle\" attack is possible if the structure of the encryption algorithm allows it. (In a known plain text attack, the adversary knows all or part (possibly some standard header or trailer fields) of the messages being encrypted. In a chosen plain text attack, the adversary can force some chosen plain text to be encrypted, possibly by \"leaking\" an exciting text that is sent by the adversary over an encrypted channel because the text is so interesting. The following is an oversimplified explanation of the meet-in-the- middle attack: the adversary can half-encrypt the known or chosen plain text with all possible first half-keys, sort the output, and then half-decrypt the encoded text with all the second half-keys. If a match is found, the full key can be assembled from the halves and used to decrypt other parts of the message or other messages. At its best, this type of attack can halve the exponent of the work required by the adversary while adding a very large but roughly constant factor of effort. Thus, if this attack can be mounted, a doubling of the amount of randomness in the very strong key to a minimum of 192 bits (96*2) is required for the year 2004, based on the [KeyStudy] analysis. This amount of randomness is well beyond the limit of that in the inputs recommended by the US DoD for password generation and could require user-typing timing, hardware random number generation, or other sources of randomness. The meet-in-the-middle attack assumes that the cryptographic algorithm can be decomposed in this way. Hopefully no modern algorithm has this weakness, but there may be cases where we are not sure of that or even of what algorithm a key will be used with. Even if a basic algorithm is not subject to a meet-in-the-middle attack, an attempt to produce a stronger algorithm by applying the basic algorithm twice (or two different algorithms sequentially) with different keys will gain less added security than would be expected. Such a composite algorithm would be subject to a meet-in-the-middle attack. Enormous resources may be required to mount a meet-in-the-middle attack, but they are probably within the range of the national security services of a major nation. Essentially all nations spy on other nations' traffic.\n\n8.2.3. Other Considerations\n\n[KeyStudy] also considers the possibilities of special-purpose code- breaking hardware and having an adequate safety margin. Note that key length calculations such as those above are controversial and depend on various assumptions about the cryptographic algorithms in use. In some cases, a professional with a deep knowledge of algorithm-breaking techniques and of the strength of the algorithm in use could be satisfied with less than half of the 192 bit key size derived above. For further examples of conservative design principles, see [FERGUSON].\n\n9. Conclusion\n\nGeneration of unguessable \"random\" secret quantities for security use is an essential but difficult task. Hardware techniques for producing the needed entropy would be relatively simple. In particular, the volume and quality would not need to be high, and existing computer hardware, such as audio input or disk drives, can be used. Widely-available computational techniques can process low-quality random quantities from multiple sources, or a larger quantity of such low-quality input from one source, to produce a smaller quantity of higher-quality keying material. In the absence of hardware sources of randomness, a variety of user and software sources can frequently, with care, be used instead. However, most modern systems already have hardware, such as disk drives or audio input, that could be used to produce high-quality randomness. Once a sufficient quantity of high-quality seed key material (a couple of hundred bits) is available, computational techniques are available to produce cryptographically-strong sequences of computationally-unpredictable quantities from this seed material.\n\n10. Security Considerations\n\nThe entirety of this document concerns techniques and recommendations for generating unguessable \"random\" quantities for use as passwords, cryptographic keys, initialization vectors, sequence numbers, and similar security applications.\n\nAppendix A: Changes from RFC 1750\n\n1. Additional acknowledgements have been added. 2. Insertion of section 5.3 on mixing with S-boxes. 3. Addition of section 3.3 on Ring Oscillator randomness sources. 4. Addition of AES and the members of the SHA series producing more than 160 bits. Use of AES has been emphasized and the use of DES de-emphasized. 5. Addition of section 6.3 on entropy pool techniques. 6. Addition of section 7.2.3 on the pseudo-random number generation techniques given in FIPS 186-2 (with Change Notice 1), 7.2.1 on those given in X9.82, section 7.1.2 on the random number generation techniques of the /dev/random device in Linux and other UNIX systems, and section 7.1.3 on random number generation techniques in the Windows operating system. 7. Addition of references to the \"Minimal Key Lengths for Symmetric Ciphers to Provide Adequate Commercial Security\" study published in January 1996 [KeyStudy] and to [RFC1948]. 8. Added caveats to using Diffie-Hellman as a mixing function and, because of those caveats and its computationally intensive nature, recommend against its use. 9. Addition of references to the X9.82 effort and the [TURBID] and [NASLUND] papers. 10. Addition of discussion of min-entropy and Renyi entropy and references to the [LUBY] book. 11. Major restructuring, minor wording changes, and a variety of reference updates."
    }
}